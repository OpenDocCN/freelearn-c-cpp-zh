<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-167"><a id="_idTextAnchor172"/>12</h1>
<h1 id="_idParaDest-168"><a id="_idTextAnchor173"/>Writing Generic Containers with Explicit Memory Management</h1>
<p>We have come quite a long way since the beginning of our journey into the wonders of memory management mechanisms and techniques in C++. From <a href="B21071_04.xhtml#_idTextAnchor062"><em class="italic">Chapter 4</em></a> to <a href="B21071_07.xhtml#_idTextAnchor116"><em class="italic">Chapter 7</em></a>, we built an interesting toolbox, one on which we can build and from which we can adapt to solve new problems we might face in the future. This toolbox now contains, among other things, the following:</p>
<ul>
<li>Techniques through which an object implicitly manages its resources</li>
<li>Types that behave like pointers but encode responsibility over the pointee in the type system</li>
<li>Various ways in which we can take over the behavior of memory allocation mechanisms of a program</li>
</ul>
<p>One (important!) aspect of memory management we have not covered yet is how containers manage memory. This is actually quite an interesting topic, one that we will address through three different angles, in three different chapters.</p>
<p>The first angle is how to handle memory management <em class="italic">explicitly</em> yet efficiently in a container. This is what the current chapter is about. In some application domains, it is customary to implement (or maintain) one’s own containers instead of using those provided by the standard library. There can be various reasons for this: for example, maybe your company has highly specialized needs. Maybe your company has been unsatisfied with standard library containers’ performance in the past, perhaps because the implementations were less efficient than they hoped back then, and developed its own alternative containers in response. After years of writing code based on your own containers, moving back to standard library containers might seem too costly.</p>
<p>The second angle, which is somewhat shorter, is how to handle memory <em class="italic">implicitly</em> yet efficiently in a container, and will be covered in <a href="B21071_13.xhtml#_idTextAnchor187"><em class="italic">Chapter 13</em></a> of this book, where we will revisit and simplify the implementations seen in the current chapter.</p>
<p>The third angle, which is more complex and subtle, is how to handle memory through an allocator in a container, and will form <a href="B21071_14.xhtml#_idTextAnchor199"><em class="italic">Chapter 14</em></a> of this book.</p>
<p>In the current chapter, we will write a (naïve) <code>std::vector&lt;T&gt;</code> lookalike named <code>Vector&lt;T&gt;</code>. We will use that as an opportunity to discuss exception safety (an important issue, especially when writing generic code). Then, we will notice that we have been very inefficient up to that point, in the sense that <code>std::vector&lt;T&gt;</code> will be significantly more efficient than our <code>Vector&lt;T&gt;</code> alternative, at least for some types. Based on this realization, we will revisit our design with better memory management, seeing important improvements in many aspects, and discuss some important low-level standard facilities for memory management that can (and will) make our lives easier.</p>
<p>We will also write a homemade <code>std::forward_list&lt;T&gt;</code> lookalike named <code>ForwardList&lt;T&gt;</code>, as there are issues and considerations specific to node-based containers that a vector-like type does not really allow us to discuss. This chapter will write a “vanilla” version of a forward list, and we will revisit it briefly in <a href="B21071_13.xhtml#_idTextAnchor187"><em class="italic">Chapter 13</em></a>, then in more detail in <a href="B21071_14.xhtml#_idTextAnchor199"><em class="italic">Chapter 14</em></a>.</p>
<p>This means that after reading this chapter, you will be able to do the following:</p>
<ul>
<li>Write a correct and exception-safe container with naïve memory management techniques</li>
<li>Understand the problems associated with <code>const</code> or reference data members</li>
<li>Use standard-provided low-level memory management algorithms</li>
</ul>
<p>More generally, you will know why <code>std::vector&lt;T&gt;</code> is so fast, and why that type is so difficult to beat at the resource management game. You will also get an idea of the challenges faced by node-based containers such as <code>std::forward_list&lt;T&gt;</code>, although later chapters will delve more deeply into this. That does not mean you should not write your own containers (for specific use cases, we can often do better than a general solution), but it does mean that you will know better why (and when) to do so, and how much effort you will need to invest.</p>
<p class="callout-heading">Exhaustiveness or representativeness</p>
<p class="callout">This book does not in general aim for exhaustive representations or implementations (there are size limits to a physical object such as a book!), and this chapter will be no exception to that rule… far from it! Implementing the full set of member functions provided for two container types inspired by the standard library would require this book to grow immensely – and your standard library implementation covers many more corner cases (and offers many more cool optimizations) than a book such as this one could hope to present. For that reason, we will try to expose a core set of member functions from which you can build instead of trying to write every single one of them.</p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor174"/>Technical requirements</h1>
<p><a id="_idTextAnchor175"/>You can find the code files for this chapter in the book’s GitHub repository here: <a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter12">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter12</a>.</p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor176"/>Writing your own vector&lt;T&gt; alternative</h1>
<p>Suppose you <a id="_idIndexMarker629"/>get up one day and say: “Hey, I’m going to beat <code>std::vector</code> at its own game” and confidently start coding. Some words to the wise:</p>
<ul>
<li>This seemingly simple task is astonishingly difficult to accomplish: for one thing, <code>std::vector</code> is a work of art, and then there’s the fact that your favorite standard library writers are spectacularly skilled individuals.</li>
<li>You might still think you can do it, so it’s fine to try, but make sure you test your ideas with both a type of element that is trivially constructible (for example, <code>int</code> or <code>double</code>) and one that is not (for example, <code>std::string</code>) and compare the results. For many, the former will lead to stellar performance, but the latter might bring …sadness.</li>
<li>The reason for this difference is that a container such as <code>std::vector</code> is extremely efficient at… managing memory (I know, reading this in this book must come as quite a shock!). It is much better, in fact, than a homegrown alternative would be, unless you invest significant time and effort and (most probably) have a specific use case in mind, one for which the homegrown version would be optimized more specifically.</li>
</ul>
<p>Your standard library vendor does invest such time and effort and does so for your very benefit, so it is possible that learning how to use <code>std::vector</code> optimally will end up being an avenue that brings better results than trying to write your personal equivalent container. Of course, in the end, which container to use is up to you, and you can often write code <a id="_idIndexMarker630"/>for custom situations that outperforms general solutions the way standard containers do.</p>
<p class="callout-heading">A general note on how we will write our containers</p>
<p class="callout">We will be writing (and using) containers in this chapter and the ones that follow, so a brief explanation is needed if we want to have a common understanding of how we will proceed. For one thing, we will use type aliases in our containers that match those used in standard containers, as this helps toward a more fluid integration in other standard library tools, such as the standard algorithms. Then, we will strive to use the same public names for our member functions as those used in the standard library (for example, we will write <code>empty()</code> for the predicate used to test whether a container is empty or not, matching existing practice in the standard library, even though some might argue <code>is_empty()</code> would be preferable). Finally, we will adopt a gradual refinement approach: our first versions will be simpler but less efficient than later ones, so be patient, dear reader: we are following our own path to enlightenment!</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor177"/>Representational choices for a container of contiguous elements</h2>
<p>Informally, a <code>std::vector</code> represents a dynamically allocated array that can grow as needed. As with <a id="_idIndexMarker631"/>any array, a <code>std::vector&lt;T&gt;</code> is a sequence of elements of type <code>T</code> arranged contiguously in memory. We will name our homemade version <code>Vector&lt;T&gt;</code> to make it visibly distinct from <code>std::vector&lt;T&gt;</code>.</p>
<p>To get a reasonably performant implementation, the first key idea is to <em class="italic">distinguish size from capacity</em>. If we do not do so, deciding to make size and capacity the same thing, our <code>Vector&lt;T&gt;</code> implementation will always conceptually be full and will need to grow, which means allocating more memory, copying the elements from the old storage to the new storage, getting rid of the old storage, and so on with every insertion of even a single element. To say such an implementation would be painful seems like a severe understatement.</p>
<p>There are two main approaches to the internal representation of a vector-like type. One is to keep track of three pointers:</p>
<ul>
<li>One to the beginning of the allocated storage</li>
<li>One to the end of the elements</li>
<li>One to the end of the allocated storage (note that we are referring to half-open ranges here, with the beginning included and the end excluded)</li>
</ul>
<p>A simplified <a id="_idIndexMarker632"/>illustration would be as follows:</p>
<pre class="source-code">
template &lt;class T&gt;
   class Vector {
      T *elems;
      T *end_elems;
      T *end_storage;
      // ...</pre> <p>Another is to keep a pointer to the beginning of the allocated storage as well as  two integers (for the container’s size and capacity, respectively). A simplified illustration in this case would be the following:</p>
<pre class="source-code">
template &lt;class T&gt;
   class Vector {
      T *elems;
      std:size_t nelems; // number of elements
      std::size_t cap; // capacity
      // ...</pre> <p>These are equivalent representations in the sense that they both allow us to write a correct container, but they bring different trade-offs. For example, keeping three pointers makes computing the <code>end()</code> iterator fast but makes <code>size()</code> and <code>capacity()</code> require computing a pointer subtraction, whereas keeping a pointer and two integers makes both <code>size()</code> and <code>capacity()</code> fast but requires computing the addition of a pointer and an integer to get the <code>end()</code> iterator.</p>
<p>As far as size goes, the three-pointer representation makes <code>sizeof(Vector&lt;T&gt;)</code> equal to <code>3*sizeof(void*)</code>, thus probably 24 bytes on a 64-bit platform with an alignment of 8. The pointer and two integers might be of the same size or might be slightly different depending on the integer types used. For example, choosing 32-bit integers for the size and capacity on a 64-bit machine would lead to a 16-byte representation <a id="_idIndexMarker633"/>and an alignment of 8. These details may make a difference on a resource-constrained system, but as you have probably deduced already, the main memory consumption cost of something such as <code>Vector&lt;T&gt;</code> comes from the memory allocated for the <code>T</code> objects.</p>
<p>Different implementations will make different representational choices due to size considerations, estimates of which member functions will be called more often on average, and so on. We will need to make a choice too; in this book, we will choose the “one pointer and two integers” approach, but keep in mind it’s one of a few reasonable options (you can even play with the idea and implement what follows through other representational choices and see where this leads you!).</p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor178"/>The implementation of Vector&lt;T&gt;</h2>
<p>We will walk through our initial (naïve) <code>Vector&lt;T&gt;</code> implementation step by step, building <a id="_idIndexMarker634"/>a gradual understanding of how this all works, and what makes us claim that this implementation is indeed naïve. Our initial step has mostly been covered already and consists of defining our abstractions through standard library-conforming type aliases and choosing our internal representation:</p>
<pre class="source-code">
#include &lt;cstddef&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;initializer_list&gt;
#include &lt;iterator&gt;
#include &lt;type_traits&gt;
template &lt;class T&gt;
   class Vector {
   public:
      using value_type = T;
      using size_type = std::size_t;
      using pointer = T*;
      using const_pointer = const T*;
      using reference = T&amp;;
      using const_reference = const T&amp;;
   private:
      pointer elems{};
      size_type nelems{},
                cap{};
      // ...</pre> <p>You will notice that this implementation makes the choice of using non-<code>static</code> data member <a id="_idIndexMarker635"/>initializers for the three data members of a <code>Vector&lt;T&gt;</code>, initializing them to their default values (integers are 0, the pointer is null), which is suitable in our implementation as it represents an empty container, which seems like a reasonable state for a default <code>Vector&lt;T&gt;</code>.</p>
<p>Some simple yet fundamental member functions follow:</p>
<pre class="source-code">
   // ...
   public:
      size_type size() const { return nelems; }
      size_type capacity() const { return cap; }
      bool empty() const { return size() == 0; }
   private:
      bool full() const { return size() == capacity(); }
   // ...</pre> <p>Pay attention to the implementation of <code>empty()</code> and <code>full()</code>. Some people will prefer accessing data members (here: using <code>nelems</code> and <code>cap</code> instead of <code>size()</code> and <code>capacity()</code>) internally when implementing member functions, but consider reusing your more fundamental member functions to implement the more “synthetic” ones. This will <a id="_idIndexMarker636"/>make your code less sensitive to changes in the implementation, and C++ compilers are very good at function inlining, particularly when these functions are non-<code>virtual</code>.</p>
<p>At this point, the most useful set of members we could probably design is the iterator types and data members of our class, as this will help us use standard algorithms to cleanly and efficiently implement the rest of our member functions.</p>
<h3>Iterators</h3>
<p>C++ containers usually expose iterators as part of their interface, and ours will be no exception. We will <a id="_idIndexMarker637"/>define type aliases for the <code>const</code> and non-<code>const</code> iterator types, as this makes it simpler to implement alternatives such as bounds-checked iterators if we feel the need to do so, and implement both <code>const</code> and non-<code>const</code> versions of the <code>begin()</code> and <code>end()</code> member functions:</p>
<pre class="source-code">
      // ...
   public:
      using iterator = pointer;
      using const_iterator = const_pointer;
      iterator begin() { return elems; }
      const_iterator begin() const { return elems; }
      iterator end() { return begin() + size(); }
      const_iterator end() const {
         return begin() + size();
      }
      // for users' convenience
      const_iterator cend() const { return end(); }
      const_iterator cbegin() const { return begin(); }
      // ...</pre> <p>You might <a id="_idIndexMarker638"/>complain about the syntactic repetition that comes with writing a <code>const</code> and non-<code>const</code> version for <code>begin()</code> and <code>end()</code>, as these are syntactically similar yet semantically distinct. If you have a C++23 compiler at hand, you can simplify this somewhat through the handy “deduced <code>this</code>” feature:</p>
<pre class="source-code">
      <strong class="bold">// alternative approach (requires C++23)</strong>
      template &lt;class S&gt;
         auto begin(this S &amp;&amp; self) { return self.elems; }
      template &lt;class S&gt;
         auto end(this S &amp;&amp; self) {
            return self.begin() + self.size();
         }</pre> <p>This is a slightly more complicated way of expressing these functions, but it lets us coalesce both versions of <code>begin()</code> and <code>end()</code> into one by leveraging the type deduction system through forwarding references.</p>
<h3>Constructors and other special member functions</h3>
<p>We now get to our constructors. The first two we will look at are the default constructor and a <a id="_idIndexMarker639"/>parametric constructor that takes as arguments a number of elements and an initial value, such that <code>Vector&lt;char&gt;(3,'a')</code> yields a container <a id="_idIndexMarker640"/>with three elements of value <code>'a'</code>. Note that the <code>default</code>-ed default constructor (yes, I know) in this case is implicitly <code>constexpr</code> as all the non-<code>static</code> member initializers can be resolved in a <code>constexpr</code> context:</p>
<pre class="source-code">
      // ...
      Vector() = default;
      Vector(size_type n, const_reference init)
         : elems{ new value_type[n] },
           nelems{ n }, cap{ n } {
         try {
            std::fill(begin(), end(), init);
         } catch(...) {
            delete [] elems;
            throw;
         }
      }
      // ...</pre> <p>Pay attention to the exception-handling code in this constructor, as it will come back again and again. We are writing a generic container, so we are using some type <code>T</code> we have no <a id="_idIndexMarker641"/>prior knowledge of. When calling <code>std::fill()</code>, which assigns the value of the <code>init</code> argument to each of the <code>T</code> objects in the sequence, we are <a id="_idIndexMarker642"/>assigning a <code>T</code> value to a <code>T</code> object, but we do not know whether that assignment operator can throw.</p>
<p>Our responsibility is to <code>elems</code>, a dynamically allocated array of <code>T</code>, so if one of the assignment operators throws, we need to make sure that array is destroyed and deallocated before the <code>Vector&lt;T&gt;</code> constructor fails; otherwise, we will leak the memory and (even worse) the objects we had constructed in that array will not be finalized. The <code>catch(...)</code> block means “catch anything,” without really knowing what you caught in this case, and the <code>throw;</code> expression means “re-throw whatever you had caught.” Indeed, we do not want to handle the exception in such a case (we do not have sufficient knowledge of the execution context to do so: is this a console application? A graphical application? An embedded system? Something else?); we just want to make sure our failure to construct the <code>Vector&lt;T&gt;</code> object did not leak resources and let user code know exactly why it is that our constructor failed to meet its postconditions (failed to construct a valid object).</p>
<p>The copy constructor will follow a similar pattern, except that instead of filling the sequence with copies of a single value, it copies values from a source sequence (<code>other</code>) to a destination sequence (<code>*this</code> or <code>elems</code> depending on how you see it). The move constructor is, of course, quite different:</p>
<pre class="source-code">
      // ...
      Vector(const Vector &amp;other)
         : elems{ new value_type[other.size()] },
           nelems{ other.size() }, cap{ other.size() } {
         try {
            std::copy(other.begin(), other.end(), begin());
         } catch(...) {
            delete [] elems;
            throw;
         }
      }
      // ...
      Vector(Vector &amp;&amp;other) noexcept
         : elems{ std::exchange(other.elems, nullptr) },
           nelems{ std::exchange(other.nelems, 0) },
           cap{ std::exchange(other.cap, 0) } {
      }
      // ...</pre> <p>As you <a id="_idIndexMarker643"/>can see, the copy constructor is a costly beast for <a id="_idIndexMarker644"/>this type: an allocation for <code>other.size()</code> objects (with as many calls to the default constructor of type <code>T</code> accompanying this for non-trivially-constructible objects), then <code>other.size()</code> assignments, and exception handling thrown in.</p>
<p>The move constructor is simpler: it’s a constant-time, <code>noexcept</code> function. You don’t technically need move operations in most classes (C++ got along fine for years without move operations, after all), but when you can take advantage of them, you probably should do so. The speed improvements can be stupendous, and execution speed becomes more predictable.</p>
<p class="callout-heading">On values and salient properties</p>
<p class="callout">If you read the copy constructor’s code attentively, you might have noticed that <code>*this</code> did not copy <code>other.capacity()</code>, instead deciding to make <code>cap</code> a copy of <code>other.size()</code>. That’s actually the correct thing to do in such a case: the <code>size()</code> of a container is <a id="_idIndexMarker645"/>what is called a <code>capacity()</code> is more of an artifact of that object’s life, showing traces of how it has grown over time. What we want is that, after copying an object, the original and the copy compare equal with respect to <code>operator==</code> and, of course, <code>capacity()</code> does not intervene in that function: two arrays are generally considered equal if they have the same number of elements and each of these elements has the same value when compared to its counterpart in the other container. Copying the capacity would work in practice, but it would be wasteful for most use cases.</p>
<p>I added (for convenience) a constructor that accepts an <code>initializer_list&lt;T&gt;</code>, argument <a id="_idIndexMarker646"/>to allow for initializing a <code>Vector&lt;T&gt;</code> object with a <a id="_idIndexMarker647"/>sequence of values of type <code>T</code>. The destructor should be self-explanatory:</p>
<pre class="source-code">
      // ...
      Vector(std::initializer_list&lt;T&gt; src)
         : elems{ new value_type[src.size()] },
           nelems {src.size() }, cap{ src.size() } {
         try {
            std::copy(src.begin(), src.end(), begin());
         } catch(...) {
            delete [] elems;
            throw;
         }
      }
      // ...
      ~Vector() {
         delete [] elems;
      }</pre> <p>Implementing the copy assignment operator from a source object (here: <code>other</code>) to a destination object (<code>*this</code>) can be complicated if done in an…  undisciplined manner, as it involves cleanup code (for the before-assignment contents of <code>*this</code>), duplication of the state of <a id="_idIndexMarker648"/>the source object, and ensuring we handle both self-assignment and potential exceptions thrown when duplicating the source object’s state appropriately.</p>
<p>Luckily, there’s a <a id="_idIndexMarker649"/>neat trick suggested by Scott Meyers (and re-proposed by countless others!) who noticed that copy assignment can be expressed as a combination of a copy constructor (the locus of object duplication), the destructor (where cleanup happens) and a <code>swap()</code> member function: you simply copy the argument into an anonymous object (to make its lifetime minimal), then swap the states of that unnamed temporary with those of <code>*this</code>, leading to <code>*this</code> becoming a copy of <code>other</code>. This programming idiom almost always works, which explains its success!</p>
<p>Move assignment can be expressed along the same lines as copy assignment, but replacing the copy constructor with a move constructor in the implementation of the assignment operator:</p>
<pre class="source-code">
      // ...
      void swap(Vector &amp;other) noexcept {
         using std::swap;
         swap(elems, other.elems);
         swap(nelems, other.nelems);
         swap(cap, other.cap);
      }
      Vector&amp; operator=(const Vector &amp;other) {
         Vector{ other }.swap(*this);
         return *this;
      }
      Vector&amp; operator=(Vector &amp;&amp;other) {
         Vector{ std::move(other) }.swap(*this);
         return *this;
      }
      // ...</pre> <h3>Basic services of a vector-like class</h3>
<p>We have <a id="_idIndexMarker650"/>now implemented the special member functions that handle the internal representation of a <code>Vector&lt;T&gt;</code> object, but there is more to writing a convenient dynamic array type. For example, member functions that let you access the <code>first()</code> element, or the last (<code>back()</code>) element, or that let you access the element at a specific index in the array (using square brackets) are all to be expected:</p>
<pre class="source-code">
      // ...
      reference operator[](size_type n) {
         return elems[n];
      }
      const_reference operator[](size_type n) const {
         return elems[n];
      }
      // precondition: !empty()
      reference front() { return (*this)[0]; }
      const_reference front() const { return (*this)[0]; }
      reference back() { return (*this)[size() - 1]; }
      const_reference back() const {
         return (*this)[size() - 1];
      }
      // ...</pre> <p>As can be expected, calling <code>front()</code> or <code>back()</code> on an empty <code>Vector&lt;T&gt;</code> is undefined behavior (you could make these functions throw if you prefer, but then everyone <a id="_idIndexMarker651"/>would pay the price for those few programs that are badly behaved maybe only in so-called <code>this</code>” feature:</p>
<pre class="source-code">
      <strong class="bold">// alternative approach, (requires C++23)</strong>
      // ...
      template &lt;class S&gt;
         decltype(auto) operator[](this S &amp;&amp; self,
                                   size_type n) {
            return self.elems[n];
         }
      // precondition: !empty()
      template &lt;class S&gt;
         decltype(auto) front(this S &amp;&amp;self) {
            return self[0];
         }
      template &lt;class S&gt;
         decltype(auto) back(this S &amp;&amp;self) {
            return self[self.size()-1];
         }
      // ...</pre> <p>Some will want to add an <code>at()</code> member function in both <code>const</code> and non-<code>const</code> form that behaves like <code>operator[]</code> but throws an exception if an attempt to access the underlying array is out of bounds. Feel free to do so if you wish.</p>
<p>Comparing two <code>Vector&lt;T&gt;</code> objects for equivalence or lack thereof is a relatively easy matter if we use algorithms since we implemented iterators for our type:</p>
<pre class="source-code">
      // ...
      bool operator==(const Vector &amp;other) const {
         return size() == other.size() &amp;&amp;
                std::equal(begin(), end(), other.begin());
      }
<strong class="bold">      // can be omitted since C++20 (synthesized by</strong>
<strong class="bold">      // the compiler through operator==())</strong>
      bool operator!=(const Vector &amp;other) const {
         return !(*this == other);
      }
      // ...</pre> <p>Finally, you might say, we reach the point that interests us the most in a book discussing memory <a id="_idIndexMarker653"/>management: how to add elements to our container, and how the underlying memory is managed. Without going through every mechanism client code could use to add elements to a <code>Vector&lt;T&gt;</code> object, we will at least examine the <code>push_back()</code> and <code>emplace_back()</code> member functions:</p>
<ul>
<li>In this version, there will be two <code>push_back()</code> member functions: one that takes <code>const T&amp;</code> as argument and one that instead takes a <code>T&amp;&amp;</code>. The one that takes a <code>const T&amp;</code> argument will copy that argument at the end of the container, and the one that takes a <code>T&amp;&amp;</code> will move it at that location.</li>
<li>The <code>emplace_back()</code> member function will take a variadic pack of arguments, then perfectly forward them to the constructor of a <code>T</code> object that will be placed at the end of the container.</li>
<li>A reference to the newly constructed object is returned by <code>emplace_back()</code> for convenience, in case user code would like to use it right away. This is not done by <code>push_back()</code>, which is called with a fully constructed object to which user code already has access.</li>
</ul>
<p>In all three functions, we first check whether the container is full, in which case we call <code>grow()</code>, a private member <a id="_idIndexMarker654"/>function. The <code>grow()</code> function needs to allocate more memory than <a id="_idIndexMarker655"/>what the container currently holds, something that can, of course, fail. Note that if <code>grow()</code> throws, the addition of a new object never occurred and the container remains intact. Note that <code>grow()</code> takes into account the possibility of a <code>capacity()</code> of value <code>0</code>, in which case an arbitrary default capacity is chosen.</p>
<p>Once <code>grow()</code> has succeeded, we add the new element after the last object in the container’s storage. Note that the value is added through assignment, which implies an object to the left side of the assignment operation, meaning that <code>grow()</code> not only added storage but initialized it with (most probably) default objects of type <code>T</code>. Thus, we can infer that with this implementation of <code>Vector&lt;T&gt;</code>, type <code>T</code> needs to expose a default constructor:</p>
<pre class="source-code">
      // ...
      void push_back(const_reference val) {
         if(full())
            grow();
         elems[size()] = val;
         ++nelems;
      }
      void push_back(T &amp;&amp;val) {
         if(full())
            grow();
         elems[size()] = std::move(val);
         ++nelems;
      }
   template &lt;class ... Args&gt;
      reference emplace_back(Args &amp;&amp;...args) {
         if (full())
            grow();
         elems[size()] =
            value_type(std::forward&lt;Args&gt;(args)...);
         ++nelems;
         return back();
      }
   private:
      void grow() {
         resize(capacity()? capacity() * 2 : 16);
      }
   // ...</pre> <p>Note that <a id="_idIndexMarker656"/>the insertion code in <code>push_back()</code> and <code>emplace_back()</code> does, in both cases, the following:</p>
<pre class="source-code">
elems[size()] = // the object to insert
++nelems;</pre> <p>You might be tempted to combine the incrementation of the number of elements and the actual insertion expression into one, as follows:</p>
<pre class="source-code">
elems[nelems++] = // the object to insert</pre> <p>Do <em class="italic">not</em> do that, however. “Why are you stopping me?” you might ask. Well, this would lead to exception-unsafe code! The reason for this is that the suffix version of <code>operator++()</code> has a high (very high!) priority, <em class="italic">much</em> higher than assignment does. This means that in the combined expression, <code>nelems++</code> happens very early on (which might go unnoticed as that expression yields the old value of <code>nelems</code>), and assignment follows later, but assignment can throw: we are assigning from an object of some type <code>T</code> to another object of that same type, and we do not know whether <code>T::operator=(const T&amp;)</code> will throw. Of course, if it does throw, the assignment will not have occurred, and no object will have been added at the end of the containers; but the number of elements will have been incremented, leading to an incoherent <code>Vector&lt;T&gt;</code> object.</p>
<p>There’s a general trick here: do not modify your object until you know you can do so safely. Try to <a id="_idIndexMarker657"/>do the potentially throwing operations first, then do the operations that can mutate your object. You will sleep better, and the risks of object corruption will be alleviated somewhat.</p>
<p>Our <code>grow()</code> member function did its work by calling <code>resize()</code> and doubling the container’s capacity (unless that capacity was 0, in which case it picked a default capacity). How does <code>resize()</code> work? With our implementation, it’s a matter of allocating enough memory to cover the needs of the new capacity, copying or moving the objects from the old memory block to the new one, then replacing the old memory block with the new one and updating the capacity.</p>
<p>How do we know whether we should move or copy the objects? Well, since moving could destroy the original objects, we only do so if <code>T::operator=(T&amp;&amp;)</code> is explicitly <code>noexcept</code>. The <code>std::is_nothrow_move_assignable&lt;T&gt;</code> trait is our tool of choice to determine whether that is indeed the case (if it is not, then we copy the objects, which is the safe option as it leaves the original objects intact):</p>
<pre class="source-code">
  // ...
  public:
     void resize(size_type new_cap) {
        if (new_cap &lt;= capacity()) return;
        auto p = new T[new_cap];
        if constexpr(std::is_nothrow_move_assignable_v&lt;T&gt;){
           std::move(begin(), end(), p);
        } else try {
           std::copy(begin(), end(), p);
        } catch (...) {
           delete[] p;
           throw;
        }
        delete[] elems;
        elems = p;
        cap = new_cap;
     }
     // ...</pre> <p>There we go. It’s not exactly trivial code, I agree, but it’s not insurmountable either. Remember that this is only our first draft, and that it will be much slower than <code>std::vector&lt;T&gt;</code> for a wide array of types.</p>
<p>One last aspect of this container we should address is how to <code>insert()</code> elements into it and how to <code>erase()</code> elements from it. In industrial-strength containers such as those found <a id="_idIndexMarker658"/>in the standard library, there is a wide array of functions to perform these two tasks, so we will limit ourselves to one of each: inserting a sequence of values at a given location in the container and erasing an element at a given location from the container.</p>
<p>Our <code>insert()</code> member function will be a template that takes a pair of source iterators named <code>first</code> and <code>last</code>, as well as a <code>const_iterator</code> named <code>pos</code> representing a location within the <code>Vector&lt;T&gt;</code> object. Making it a <code>template</code> means that we will be able to use pairs of iterators from any container as a source of values to insert, a useful property indeed.</p>
<p>Within the function, we will use a non-<code>const</code> equivalent of <code>pos</code> named <code>pos_</code>, but only because we are writing a simplified and incomplete container where many member functions that would work on <code>const_iterator</code> objects are missing.</p>
<p>To perform the insertion, we will compute <code>remaining</code>, the space we will have available in the container (expressed as a number of objects), and <code>n</code>, which will be the number of objects to insert. If the available space remaining is insufficient, we will allocate more through our <code>resize()</code> member function. Of course, calling <code>resize()</code> will probably lead to <code>pos_</code> becoming invalid (it pointed into the old block of memory, which will be replaced by another block once <code>resize()</code> has completed its task), so we take care of computing the relative <code>index</code> in the container before resizing, and recomputing the equivalent of <code>pos_</code> in the new memory block after resizing.</p>
<p>An interesting twist in the insertion process is that we will want to copy (or move, but we will keep things simple here) the objects from <code>pos_</code> to <code>end()</code> at the location <em class="italic">ending</em> at <code>end()+n</code> before performing the insertion of <code>n</code> objects at the <code>pos_</code> location, but that copy has to be made <em class="italic">backward</em> (from the last to the first) if we are to avoid overwriting some of the objects we are trying to copy along the way. The <code>std::copy_backward()</code> algorithm is expressed this way: the third argument expressed where the destination of the copy stops, not where it begins.</p>
<p>Only then <a id="_idIndexMarker659"/>do we copy the sequence determined by <code>first</code> and <code>last</code> at position <code>pos_</code>, update the number of elements in the <code>Vector&lt;T&gt;</code> object, and return what the standard requires (an iterator to the first element inserted, or <code>pos</code> in the case where <code>first==last</code>, meaning that they determine an empty sequence):</p>
<pre class="source-code">
   template &lt;class It&gt;
   iterator insert(const_iterator pos, It first, It last) {
      iterator pos_ = const_cast&lt;iterator&gt;(pos);
      // deliberate usage of unsigned integrals
      const std::size_t remaining = capacity() - size();
      const std::size_t n = std::distance(first, last);
      if (remaining &lt; n) {
         auto index = std::distance(begin(), pos_);
         resize(capacity() + n - remaining);
         pos_ = std::next(begin(), index);
      }
      std::copy_backward(pos_, end(), end() + n);
      std::copy(first, last, pos_);
      nelems += n;
      return pos_;
   }</pre> <p>Our <code>erase()</code> member function will take a <code>const_iterator</code> argument named <code>pos</code> representing the location of the element to erase from the <code>Vector&lt;T&gt;</code> object. We again resort to the trick of using a non-<code>const</code> iterator named <code>pos_</code> within the function. Erasing <code>end()</code> is a no-op (as it should); otherwise, we perform a linear copy from <code>next(pos_)</code> to <code>end()</code> into the location starting at <code>pos_</code>, effectively replacing each element from that point on with its immediate successor.</p>
<p>Finally, we replace the last element with some default value, something that might not seem necessary but actually is since the <code>T</code> object at the end could have been holding some resource that needed to be freed. For example, in a program where we use a <code>Vector&lt;Res&gt;</code> object and where <code>Res</code> is an RAII type that releases a resource on destruction, not replacing the object “lying around just past the end” might lead to the associated <a id="_idIndexMarker660"/>resource being closed only when the <code>Vector</code> object is destroyed, which might occur later, maybe much later, than client code would expect it to be.</p>
<p>We then update the number of elements in the <code>Vector&lt;T&gt;</code> object. Once again, this implementation means we are requiring that <code>T</code> exposes a default constructor, something that is not fundamentally necessary (and a requirement that we will alleviate later in this chapter):</p>
<pre class="source-code">
   iterator erase(const_iterator pos) {
      iterator pos_ = const_cast&lt;iterator&gt;(pos);
      if (pos_ == end()) return pos_;
      std::copy(std::next(pos_), end(), pos_);
<strong class="bold">      *std::prev(end()) = {};</strong>
      --nelems;
      return pos_;
   }</pre> <p>I’m sure you’re wondering how we could do better, but we will get back to this very soon. We will look at how to implement a simple node-based container (a homemade <code>std::forward_list&lt;T&gt;</code>-like type) in the meantime.</p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor179"/>Writing your own forward_list&lt;T&gt; alternative</h1>
<p>Writing a node-based container such as <code>std::list</code>, <code>std::unordered_map</code>, <code>std:: map</code>, and so on is an interesting exercise, but in this chapter, the fact that it is interesting <a id="_idIndexMarker661"/>will not necessarily “shine” right away. The points of interest for such classes will be more evident in <a href="B21071_13.xhtml#_idTextAnchor187"><em class="italic">Chapter 13</em></a> and <a href="B21071_14.xhtml#_idTextAnchor199"><em class="italic">Chapter 14</em></a>, but we will still write a basic, simplified version here to make the side-by-side evolution of our container types clearer in the pages and chapters to come.</p>
<p>A forward list is an exercise in leanness. We want the type to be small and do what it does well. Some forward lists occupy the size of a single pointer in memory (a pointer to the first node in the sequence); in our implementation, we will pay the price for an additional integer (the number of elements) in order to get a constant-time complexity guarantee for the <code>size()</code> member function.</p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor180"/>Representational choices for a node-based container</h2>
<p>In our implementation, <code>ForwardList&lt;T&gt;</code> will hold nodes, and each node will hold a pair made <a id="_idIndexMarker662"/>of a value (of type <code>T</code>) and a pointer to the next node in the sequence. The last node will have a null pointer as the <code>next</code> node.</p>
<p>The representation of a <code>ForwardList&lt;T&gt;</code> object will thus be a <code>Node*</code> and an unsigned integral (for the number of elements in the list). Our implementation will be very simple and will show a small set of member functions. Feel free to enrich it as you want, as long as you limit yourself to functions that can be written efficiently.</p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor181"/>The implementation of ForwardList&lt;T&gt;</h2>
<p>As we <a id="_idIndexMarker663"/>did for <code>Vector&lt;T&gt;</code>, we will walk through our initial (naïve) <code>ForwardList&lt;T&gt;</code> implementation in steps. Our initial step consists of defining our abstractions through standard library-conforming type aliases and choosing our internal representation, as is usually the case with containers:</p>
<pre class="source-code">
#include &lt;cstddef&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iterator&gt;
#include &lt;initializer_list&gt;
#include &lt;concepts&gt;
template &lt;class T&gt;
class ForwardList {
public:
   using value_type = T;
   using size_type = std::size_t;
   using pointer = T*;
   using const_pointer = const T*;
   using reference = T&amp;;
   using const_reference = const T&amp;;
   // ...</pre> <p>As mentioned earlier, a<code>ForwardList&lt;T&gt;::Node</code> object will hold a value and a pointer to <a id="_idIndexMarker664"/>the next node in the sequence. Initially, the next node will always be a null pointer; it is the list’s responsibility to organize nodes, the nodes themselves being responsible for the ownership of the values stored therein:</p>
<pre class="source-code">
   // ...
private:
   struct Node {
      value_type value;
      Node *next = nullptr;
      Node(const_reference value) : value { value } {
      }
      Node(value_type &amp;&amp;value)
         : value { std::move(value) } {
      }
   };
   Node *head {};
   size_type nelems {};
   // ...</pre> <p>The default state of a <code>ForwardList&lt;T&gt;</code> object will be equivalent to that of an empty list (a null pointer for <code>head</code> and no elements). That’s a reasonable default for most containers <a id="_idIndexMarker665"/>as an empty container is usually what users expect in practice when asking for a default constructor.</p>
<p>The <code>size()</code> and <code>empty()</code> member functions are both trivial to write. I expressed <code>empty()</code> in terms of a null head rather than as a zero <code>size()</code> since in some (reasonable) forward list implementations, the size would be computed, not stored, which would make <code>size()</code> a linear complexity operation instead of a constant-time one. In practice, exposing a constant-time <code>size()</code> member function is a good idea as it matches most users’ expectations:</p>
<pre class="source-code">
   // ...
public:
   size_type size() const { return nelems; }
   bool empty() const { return !head; }
   // ...</pre> <p>Iterators on a linked list cannot be raw pointers, as the elements it stores are not contiguous in memory. We need a class whose instances can iterate over elements of the list, and that can take into account the <code>const</code>-ness of the elements (or lack thereof).</p>
<p>Our (private) <code>ForwardList&lt;T&gt;::Iterator</code> class will be a template on some type, <code>U</code>, where (in practice) <code>U</code> will be <code>T</code> for <code>ForwardList&lt;T&gt;::iterator</code> and <code>const T</code> for <code>ForwardList&lt;T&gt;::const_iterator</code>.</p>
<p>Standard iterators in C++ are expected to provide five aliases:</p>
<ul>
<li><code>value_type</code>: The type of the pointed-to value.</li>
<li><code>reference</code>: The type that represents a reference to a pointed-to value.</li>
<li><code>pointer</code>: The type that represents a pointer to a pointed-to value.</li>
<li><code>difference_type</code>: The type that represents the distance between two iterators of this type (a signed integral).</li>
<li><code>iterator_category</code>: There are six categories as of C++20, and they guide the code generation by describing what an iterator can do. In our case, since we will provide <code>++</code> but not <code>--</code>, we will describe our iterators as being part of <code>forward_iterator_category</code>.</li>
</ul>
<p>An iterator <a id="_idIndexMarker666"/>is an object that describes how we can traverse a sequence of values, and <code>ForwardList&lt;T&gt;::Iterator</code> is no exception. The key operations exposed by an iterator are probably <code>operator++()</code> (advance one position in the sequence), <code>operator!=()</code> (compare two iterators to know whether we have attained the end of a sequence), as well as <code>operator*()</code> and <code>operator-&gt;()</code> (accessing the pointed-to element or its services). Note that we make <code>ForwardList&lt;T&gt;</code> our friend as that class will be responsible for the organization of nodes, which is easier done when you have full access privileges to private data members such as <code>cur</code>:</p>
<pre class="source-code">
   // ...
private:
   template &lt;class U&gt; class Iterator {
   public:
      using value_type =
         typename ForwardList&lt;T&gt;::value_type;
      using pointer = typename ForwardList&lt;T&gt;::pointer;
      using reference = typename ForwardList&lt;T&gt;::reference;
      using difference_type = std::ptrdiff_t;
      using iterator_category =
         std::forward_iterator_tag;
      friend class ForwardList&lt;T&gt;;
   private:
      Node *cur {};
   public:
      Iterator() = default;
      Iterator(Node *p) : cur { p } {
      }
      Iterator&amp; operator++() {
         cur = cur-&gt;next;
         return *this;
      }
      Iterator operator++(int) {
         auto temp = *this;
         operator++();
         return temp;
      }
      bool operator==(const Iterator &amp;other) const {
         return cur == other.cur;
      }
      // not needed since C++20
      bool operator!=(const Iterator &amp;other) const {
         return !(*this == other);
      }
      U&amp; operator*() { return cur-&gt;value; }
      const U&amp; operator*() const { return cur-&gt;value; }
      U* operator-&gt;() { return cur-&gt;value; }
      const U* operator-&gt;() const { return cur-&gt;value; }
   };
public:
   using iterator = Iterator&lt;T&gt;;
   using const_iterator = Iterator&lt;const T&gt;;
   // ...</pre> <p>The preceding <a id="_idIndexMarker667"/>proposed implementation uses a template based on the type, <code>U</code>, of the elements that an <code>Iterator&lt;U&gt;</code> can traverse. We used <code>U</code> instead of <code>T</code> as <code>T</code> is the type of the values in a <code>ForwardList&lt;T&gt;</code> object. In <code>ForwardList&lt;T&gt;</code>, we then make aliases for types <code>Iterator&lt;T&gt;</code> and <code>Iterator&lt;const T&gt;</code> through <code>iterator</code> and <code>const_iterator</code>, respectively. We could also have written two distinct types had we preferred that approach, but a template seemed less verbose.</p>
<p>The <code>begin()</code> and <code>end()</code> set of member functions are essentially trivial; <code>begin()</code> yields an iterator to the head of the list, and the conceptual just-after-the-end node returned by <code>end()</code> is a null pointer, which is what the default constructor of our <code>Iterator&lt;U&gt;</code> gives us:</p>
<pre class="source-code">
   // ...
   iterator begin() { return { head }; }
   const_iterator begin() const { return { head }; }
   const_iterator cbegin() const { return begin(); }
   iterator end() { return {}; }
   const_iterator end() const { return {}; }
   const_iterator cend() const { return end(); }
   // ...</pre> <p>We will sometimes need to <code>clear()</code> a <code>ForwardList&lt;T&gt;</code> object, which will lead us to destroy <a id="_idIndexMarker668"/>that container’s content. In this implementation, for simplicity, I made the destructor call the <code>clear()</code> member function, but we could have spared a tiny bit of processing time (the reinitialization of <code>nelems</code>, not needed in the destructor) by writing the destructor separately:</p>
<pre class="source-code">
   // ...
   void clear() noexcept {
      for(auto p = head; p; ) {
         auto q = p-&gt;next;
         delete p;
         p = q;
      }
      nelems = 0;
   }
   ~ForwardList() {
      clear();
   }
   // ...</pre> <p>One thing that might seem tempting would be to write a <code>Node</code> destructor that applies <code>delete</code> to its <code>next</code> data member; if we did so, <code>clear()</code> would simply be <code>delete head;</code> (which would call <code>delete head-&gt;next</code> and continue from that point on, recursively) followed by <code>nelems=0;</code>. However, I would not do that if I were you: on principle, the <code>ForwardList&lt;T&gt;</code> object should organize the nodes in a <code>ForwardList&lt;T&gt;</code>, and this responsibility should not be given to the numerous <code>Node</code> objects themselves. Then, there is a small technical problem: calling <code>delete head;</code> would call <code>delete head-&gt;next;</code>, which would then technically call <code>delete</code> on <code>head-&gt; next-&gt; next;</code> and so on. This leads to a very concrete risk of stack overflow if the list is long enough, something that a loop would avoid altogether.</p>
<p>There is a simple lesson here: life is easier when each class has a single responsibility. This is something that’s been known for a while as the “single responsibility principle”. That principle is the ‘S’ in the well-known SOLID principles of object-oriented programming. Let the container deal with the organization of nodes in a node-based container and let the nodes store values.</p>
<p>As far as <a id="_idIndexMarker669"/>constructors go, we will implement a small set for this class:</p>
<ul>
<li>A default constructor that models an empty list</li>
<li>A constructor that accepts a <code>std::initializer_list&lt;T&gt;</code> as argument</li>
<li>A copy constructor that duplicates each node from the source list in order</li>
<li>A move constructor</li>
<li>A sequence constructor that accepts two objects of some type, <code>It</code>, that satisfies the <code>std::input_iterator</code> concept (essentially: that lets you make at least a single pass through the sequence and consume the elements, which is all we need to do the job)</li>
</ul>
<p>It happens that this last constructor can be seen as a generalization of some of the others, and that only the default constructor and the move constructor really benefit from being written separately (we could technically compute the size of the sequence more efficiently if we did not delegate the work to a general constructor, so if this makes a difference in your code base, feel free to do so):</p>
<pre class="source-code">
   // ...
   ForwardList() = default;
   template &lt;std::input_iterator It&gt;
      ForwardList(It b, It e) {
         if(b == e) return;
         try {
            head = new Node{ *b };
            auto q = head;
            ++nelems;
            for(++b; b != e; ++b) {
               q-&gt;next = new Node{ *b };
               q = q-&gt;next;
               ++nelems;
            }
         } catch (...) {
            clear();
            throw;
         }
      }
   ForwardList(const ForwardList&amp; other)
      : ForwardList(other.begin(), other.end()) {
   }
   ForwardList(std::initializer_list&lt;T&gt; other)
      : ForwardList(other.begin(), other.end()) {
   }
   ForwardList(ForwardList&amp;&amp; other) noexcept
      : head{ std::exchange(other.head, nullptr) },
        nelems{ std::exchange(other.nelems, 0) } {
   }
   // ...</pre> <p>Unsurprisingly, assignment <a id="_idIndexMarker670"/>can be expressed through the safe assignment idiom that we applied in the case of type <code>Vector&lt;T&gt;</code> earlier:</p>
<pre class="source-code">
   // ...
   void swap(ForwardList&amp; other) noexcept {
      using std::swap;
      swap(head, other.head);
      swap(nelems, other.nelems);
   }
   ForwardList&amp; operator=(const ForwardList&amp; other) {
      ForwardList{ other }.swap(*this);
      return *this;
   }
   ForwardList&amp; operator=(ForwardList&amp;&amp; other) {
      ForwardList{ std::move(other) }.swap(*this);
      return *this;
   }
   // ...</pre> <p>Some of the remaining operations can reasonably be said to be trivial, for example, <code>front()</code>, <code>operator==()</code>, and <code>push_front()</code>. As you could reasonably assume for a forward list, we will implement neither a <code>back()</code> nor a <code>push_back()</code> member function as <a id="_idIndexMarker671"/>there would not be an efficient way to do so with our representational choices (the only reasonable algorithm would require looping through the whole construct in order to find the last node, leading to a linear complexity algorithm):</p>
<pre class="source-code">
   // ...
   // precondition: !empty()
   reference front() { return head-&gt;value; }
   const_reference front() const { return head-&gt;value; }
   bool operator==(const ForwardList &amp;other) const {
      return size() == other.size() &amp;&amp;
             std::equal(begin(), end(), other.begin());
   }
   // can be omitted since C++20
   bool operator!=(const ForwardList &amp;other) const {
      return !(*this == other);
   }
   void push_front(const_reference val) {
      auto p = new Node{ val };
      p-&gt;next = head;
      head = p;
      ++nelems;
   }
   void push_front(T&amp;&amp; val) {
      auto p = new Node{ std::move(val) };
      p-&gt;next = head;
      head = p;
      ++nelems;
   }
   // ...</pre> <p>As an <a id="_idIndexMarker672"/>example of value insertion into a container, consider the following <code>insert_after()</code> member function, which inserts a node with a value of <code>value</code> after the node pointed to by <code>pos</code>. With this function, we could easily build more complex ones, such as one that inserts a sequence of values after some position in the list (try it!):</p>
<pre class="source-code">
   // ...
   iterator insert_after
      (iterator pos, const_reference value) {
      auto p = new Node{ value };
      p-&gt;next = pos.cur-&gt;next;
      pos.cur-&gt;next = p;
      ++nelems;
      return { p };
   }
   // ...</pre> <p>Offering the possibility of adding elements to a container is a useful feature indeed, and so is offering <a id="_idIndexMarker673"/>the option of removing an element from a container. As an example, see the following <code>erase_after()</code> member function implementation:</p>
<pre class="source-code">
   // ...
   iterator erase_after(iterator pos) {
      if (pos == end() || std::next(pos) == end())
         return end();
      auto p = pos.cur-&gt;next-&gt;next;
      delete pos.cur-&gt;next;
      pos.cur-&gt;next = p;
      return { p-&gt;next };
   }
};</pre> <p>That should do the job for this class. For the rest of this chapter, there will be little room for improvement for <code>ForwardList&lt;T&gt;</code>, but we will return to this class in <a href="B21071_13.xhtml#_idTextAnchor187"><em class="italic">Chapter 13</em></a>, and more so in <a href="B21071_14.xhtml#_idTextAnchor199"><em class="italic">Chapter 14</em></a>.</p>
<p>For <code>Vector&lt;T&gt;</code>, however, we can do significantly better than we have so far… at the cost of some added complexity. But we are ready for this, are we not?</p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor182"/>Better memory management</h1>
<p>So, this humble writer claims our nice but simple <code>Vector&lt;T&gt;</code> type is no match for <code>std::vector&lt;T&gt;</code>. That may seem like a bold claim: after all, we seemed to do what was needed and, no less, we used algorithms instead of raw loops; we caught exceptions as <a id="_idIndexMarker674"/>we wanted to be exception-safe but limited ourselves to cleaning up the resources… What are we doing wrong?</p>
<p>If you run comparative benchmarks between a <code>Vector&lt;int&gt;</code> object and a <code>std::vector&lt;int&gt;</code> object, in fact, you will probably not notice much of a difference in the respective numbers of both tests. For example, try adding a million <code>int</code> objects (through <code>push_back()</code>) to each of these containers and you will think our container holds its own quite well. Cool! Now, change that to a comparative test between <code>Vector&lt;std::string&gt;</code> and <code>std::vector&lt;std::string&gt;</code> and you might be saddened a bit, seeing that we’re “left behind in the dust,” as they say.</p>
<p class="callout-heading">A word about the small object optimization</p>
<p class="callout">This will show more if you add strings that are not too short (try at least 25 characters, say) as with “short” strings (for some indeterminate value of “short”) most standard libraries <a id="_idIndexMarker675"/>will perform what is called the <strong class="bold">Small String Optimization</strong> (<strong class="bold">SSO</strong>), a special case of the <strong class="bold">Small Object Optimization</strong> (<strong class="bold">SOO</strong>). Through <a id="_idIndexMarker676"/>this optimization, when the data to store in an object is small enough, the implementation will use the storage for the so-called “control block” (the data members, really) of the object as raw storage, avoiding dynamic memory allocation altogether. Because of this, “small” strings do not allocate and are very, very fast in practice.</p>
<p>But why?</p>
<p>There is a clue in the type of element in both tests: <code>int</code> is a trivially constructible type, and <code>std::string</code> is not. This clue is an indication that <code>std::vector</code> might be calling fewer constructors than we are, essentially being more efficient than <code>Vector&lt;T&gt;</code> in the way it handles memory and the objects therein.</p>
<p>What’s the problem? Well, let’s look at one of the constructors of <code>Vector&lt;T&gt;</code> to get an appreciation of the problem with our implementation. Any constructor but the default constructor (defaulted in our implementation) and the move constructor would do, so let’s take <a id="_idIndexMarker677"/>the one that accepts a number of elements and an initial value as arguments. Pay special attention to the highlighted code:</p>
<pre class="source-code">
   // ...
   Vector(size_type n, const_reference init)
      : <strong class="bold">elems{ new value_type[n] }</strong>, nelems{ n }, cap{ n } {
      try {
         <strong class="bold">std::fill(begin(), end(), init);</strong>
      } catch(...) {
         delete [] elems;
         throw;
      }
   }
   // ...</pre> <p>The construction of the <code>elems</code> data member allocates a block of memory big enough to hold <code>n</code> objects of type <code>T</code> and calls the default constructor for each of these <code>n</code> elements. Obviously, if <code>T</code> is trivially constructible, then these default constructors are not a big source of worries, but you could question the virtue of so doing if <code>T</code> is not trivially constructible.</p>
<p>Still, you might want to argue that the objects need to be constructed, but then look ahead and you will notice that <code>std::fill()</code> replaces each of these default <code>T</code> objects with a copy of <code>init</code>, showing that the initial default construction of the objects was essentially a waste of time (we never used these objects!). This is the sort of thing that <code>std::vector&lt;T&gt;</code> does so much better than we do: it avoids wasteful operations, restricting itself to what is necessary.</p>
<p>We will now try to see how we could get closer in performance to what <code>std::vector&lt;T&gt;</code> achieves in practice.</p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor183"/>A more efficient Vector&lt;T&gt;</h2>
<p>The key to a more efficient <code>Vector&lt;T&gt;</code> is distinguishing allocation from construction, something we have discussed many times in this book, and, well, lying to the type system in <a id="_idIndexMarker678"/>adequate ways and in a controlled environment. Yes, those “evil” early chapters of this book will come in handy now.</p>
<p>We will not rewrite the entirety of <code>Vector&lt;T&gt;</code> in these pages, but we will look at selected member functions to highlight what needs to be done (a full implementation is available in the GitHub repository mentioned at the beginning of this chapter).</p>
<p>We could try to do this effort manually, using the language facilities we already know about, such as <code>std::malloc()</code>, to allocate a raw memory block and placement <code>new</code> to construct the objects in that block. Taking the same constructor that takes a number of elements and an initial value as arguments, we would then get the following:</p>
<pre class="source-code">
   // ...
   Vector(size_type n, const_reference init)
      <strong class="bold">// A</strong>
      : <strong class="bold">elems{ static_cast&lt;pointer&gt;(</strong>
<strong class="bold">           std::malloc(n * sizeof(value_type)</strong>
<strong class="bold">        ) }</strong>, nelems{ n }, cap{ n } {
      <strong class="bold">// B</strong>
<strong class="bold">      auto p = begin(); // note: we know p is a T*</strong>
      try {
      <strong class="bold">// C</strong>
         <strong class="bold">for(; p != end(); ++p)</strong>
<strong class="bold">            new(static_cast&lt;void*&gt;(p)) value_type{ init };</strong>
      } catch(...) {
      <strong class="bold">// D</strong>
<strong class="bold">         for(auto q = begin(); q != p; ++q)</strong>
<strong class="bold">            q-&gt;~value_type();</strong>
<strong class="bold">         std::free(elems);</strong>
         throw;
      }
   }
   // ...</pre> <p>Now <a id="_idIndexMarker679"/>that’s… unpleasant. Pay attention to the sections marked with are <strong class="bold">A</strong> to <strong class="bold">D</strong> in this function:</p>
<ul>
<li>In <code>n</code> objects of type <code>T</code> but limit ourselves to raw memory allocation (the constructor of no <code>T</code> object is being called at this point), yet we keep a <code>T*</code> to that block of memory for our own purposes. Our implementation needs to be aware, internally, that the type of the <code>elems</code> pointer is incorrect at this stage.</li>
<li>In <code>begin()</code> knowing that <code>iterator</code> is the same thing as <code>T*</code> in our implementation. If our implementation used a class instead of a raw pointer to model an iterator, we would have to do some work here to get the underlying pointer to the raw storage in order to implement the rest of the function.</li>
<li>In <code>T</code> objects in place within the block of memory we allocated. Since there are no objects there to replace, we construct these objects with the placement <code>new</code>, and use the fact that we lied to the type system (in the sense that we used a <code>T*</code> even though we allocated raw memory) to do the pointer arithmetic required to move from one object to another.</li>
<li>In <code>T</code> objects. Since we are the only ones who know that there are <code>T</code> objects therein, just as we are the only ones who know exactly where the first object that we failed to construct is, we need to destroy the objects manually, then free the (now raw) memory block and re-throw the exception. As a bonus, this implementation is not even standards-compliant; we should destroy the objects in reverse order of construction, something this example does not do.</li>
</ul>
<p>By the way, this example shows a clear example of the reasons why you cannot throw from a destructor: if an exception is thrown during <strong class="bold">D</strong>, we cannot reasonably hope to recover (at least not without incurring prohibitive costs).</p>
<p>You, dear reader, are probably thinking right now that this is unreasonably complicated and way too error-prone for non-specialists to hope to be able to write a whole container <a id="_idIndexMarker680"/>that way. Indeed, this sort of complexity would creep into a significant number of member functions, making quality control much more difficult than you would hope.</p>
<p>But wait, there is hope! As you might imagine, your library vendors face the same challenges we do (and more!), so the standard library provides low-level facilities that make handling raw memory in homemade containers a reasonably achievable task as long as you know, well, what you have read in this book so far.</p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor184"/>Using low-level standard facilities</h2>
<p>The <code>&lt;memory&gt;</code> standard library header is a treasure trove of useful facilities for those who dabble in memory management. We have already discussed the standard smart pointers <a id="_idIndexMarker681"/>defined in that header (see <a href="B21071_05.xhtml#_idTextAnchor079"><em class="italic">Chapter 5</em></a> for a reminder), but if you look a bit deeper, you will see some algorithms made to operate on raw memory.</p>
<p>Keeping as <a id="_idIndexMarker682"/>an example the <code>Vector&lt;T&gt;</code> constructor that takes a number of elements and an initial value as argument, we went from something rather simple that allocates an array of <code>T</code> objects and replaces them through a call to <code>std::fill()</code> to something significantly more complicated. The original version was both simple and inefficient (we constructed unneeded objects just to replace them); the replacement was much more efficient (doing minimal work) but required much more skill to write and maintain.</p>
<p>We will now examine the impact of these facilities on the implementation of our allocating member functions. The first such functions we will pay attention to are the constructors, as they make a nice starting point.</p>
<h3>Impact on constructors</h3>
<p>In practice, when you <a id="_idIndexMarker683"/>want to write a homemade container that manages memory explicitly, it’s better to use the low-level facilities found in <code>&lt;memory&gt;</code>. Take the following example:</p>
<pre class="source-code">
   // ...
   Vector(size_type n, const_reference init)
      : <strong class="bold">elems{ static_cast&lt;pointer&gt;(</strong>
<strong class="bold">           std:malloc(n * sizeof(value_type))</strong>
<strong class="bold">        ) }</strong>, nelems{ n }, cap{ n } {
      try {
         <strong class="bold">std::uninitialized_fill(begin(), end(), init);</strong>
      } catch(...) {
         <strong class="bold">std::free(elems);</strong>
         throw;
      }
   }
   // ...</pre> <p>This is <a id="_idIndexMarker684"/>much nicer than the version we entirely wrote ourselves, is it not? The two highlights of this version are as follows:</p>
<ul>
<li>We allocate a properly sized block of raw memory instead of an array of <code>T</code> objects, thus avoiding all of the unneeded default constructors the initial version had.</li>
<li>We replaced the call to <code>std::fill()</code> (found in <code>&lt;algorithm&gt;</code>), which uses <code>T::operator=(const T&amp;)</code> and thus supposes an existing object to the left side of the assignment with a call to <code>std::uninitialized_fill()</code>, which instead supposes that it is iterating through raw memory and initializes the objects through the placement <code>new</code>.</li>
</ul>
<p>The beauty of this algorithm (and others of this family) is that it is exception-safe. If one of the constructors invoked by <code>std::uninitialized_fill()</code> ends up throwing, then the objects it had managed to create before the exception occurred will be destroyed (in reverse order of construction, as they should) before the exception leaves the function.</p>
<p>It’s what we had written (clumsily) by hand, really. Apart from the fact that we now allocate and free raw memory, the rest of the code is very similar to the original, simple version. This probably makes you feel much better… and it should.</p>
<p>A similar <a id="_idIndexMarker685"/>approach can be taken with other constructors. Take, for example, the copy constructor:</p>
<pre class="source-code">
   // ...
   Vector(const Vector&amp; other)
      : <strong class="bold">elems{ static_cast&lt;pointer&gt;(</strong>
<strong class="bold">           std::malloc(n * sizeof(value_type))</strong>
<strong class="bold">        ) }</strong>,
        nelems{ other.size() }, cap{ other.size() } {
      try {
         <strong class="bold">std::uninitialized_copy(</strong>
<strong class="bold">            other.begin(), other.end(), begin()</strong>
<strong class="bold">         );</strong>
      } catch (...) {
         <strong class="bold">std::free(elems);</strong>
         throw;
      }
   }
   // ...</pre> <p>As you can see, with the proper algorithms, the fast implementations that work on raw memory are very similar to the naïve and slower versions.</p>
<p>The key point here is to understand the boundaries of the API. A function such as <code>std::uninitialized_copy()</code> takes three arguments: the beginning and end of a source sequence (this sequence is presumed to contain objects) and the beginning of the destination sequence (this sequence is presumed to be appropriately aligned and made of raw memory, not objects). If the function concludes its execution because it met its postconditions and constructed the objects in the destination sequence, then that <a id="_idIndexMarker686"/>destination sequence contains objects. On the other hand, if the function fails to meet its postconditions, then there are no objects in the destination sequence as whatever the function has constructed, it will also have destructed.</p>
<p>Similar maneuvers can be done with other constructors, keeping in mind that the default constructor and the move constructor are implemented very differently and as such deserve a different treatment.</p>
<h3>Impact on the destructor</h3>
<p>The destructor in this implementation of <code>Vector&lt;T&gt;</code> is interesting: when the object reaches <a id="_idIndexMarker687"/>the end of its lifetime, we cannot simply call <code>delete[]</code> on the <code>elems</code> data member as it has not been allocated by <code>new[]</code> in the first place and it is made of a sequence of <code>T</code> objects, potentially followed by a sequence of raw bytes. We would not want to call <code>T::~T()</code> on an arbitrary sequence of bytes since this could cause quite a lot of damage in our program and incur <strong class="bold">UB</strong>.</p>
<p>The only entity that knows how many objects there are in the container is the <code>Vector&lt;T&gt;</code> object itself, which means that it will need to <code>destroy()</code> the remaining objects, and only then <code>free()</code> the (now devoid of objects) memory block that remains. Applying the <code>std::destroy()</code> algorithm on a sequence of <code>T</code> objects calls <code>T::~T()</code> on each of them, turning a sequence of objects into raw memory:</p>
<pre class="source-code">
   // ...
   ~Vector() {
      <strong class="bold">std::destroy(begin(), end());</strong>
      <strong class="bold">std::free(elems);</strong>
   }
   // ...</pre> <p>These low-level memory management algorithms really help in clarifying the intent of the code we write, as you can see.</p>
<h3>Impact on per-element insertion functions</h3>
<p>A similar situation <a id="_idIndexMarker688"/>happens in member functions <code>push_back()</code> and <code>emplace_back()</code> where we used to replace through an assignment <a id="_idIndexMarker689"/>some existing object at the end of our array; we <a id="_idIndexMarker690"/>now need to construct an object at the end of the array since there is no object there anymore (we do not construct objects needlessly; that’s the point of our efforts!).</p>
<p>We could use placement <code>new</code> to do this, obviously, but the standard library offers a moral equivalent named <code>std::construct_at()</code>. This makes our intent even clearer from the source code:</p>
<pre class="source-code">
   // ...
   void push_back(const_reference val) {
      if (full())
         grow();
      <strong class="bold">std::construct_at(end(), val);</strong>
      ++nelems;
   }
   void push_back(T&amp;&amp; val) {
      if (full())
         grow();
      <strong class="bold">std::construct_at(end(), std::move(val));</strong>
      ++nelems;
   }
   template &lt;class ... Args&gt;
      reference emplace_back(Args &amp;&amp;...args) {
         if (full())
            grow();
         <strong class="bold">std::construct_at(</strong>
<strong class="bold">            end(), std::forward&lt;Args&gt;(args)...</strong>
<strong class="bold">         );</strong>
         ++nelems;
         return back();
      }</pre> <h3>Impact on growth functions</h3>
<p>The <code>grow()</code> function <a id="_idIndexMarker691"/>we had implemented initially called <code>resize()</code> on our <code>Vector&lt;T&gt;</code>, but <code>resize()</code> is meant to initialize the storage with objects. To <a id="_idIndexMarker692"/>make the allocated storage grow in size without initializing it with objects, we need a different member function, namely <code>reserve()</code>.</p>
<p class="callout-heading">On the differences between resize() and reserve()</p>
<p class="callout">Expressed <a id="_idIndexMarker693"/>simply, <code>resize()</code> potentially <a id="_idIndexMarker694"/>adds objects to the container, and as such it can modify both <code>size()</code> and <code>capacity()</code>. On the other hand, <code>reserve()</code> adds no object to the container, limiting itself to potentially increasing the storage space being used by the container; in other words, <code>reserve()</code> can change <code>capacity()</code> but will not change <code>size()</code>.</p>
<p>Following the example set by <code>std::vector&lt;T&gt;</code>, our <code>Vector&lt;T&gt;</code> class will offer both <code>resize()</code> and <code>reserve()</code>. A version of <code>resize()</code> adapted to the new reality of our part-objects, part-raw-memory container follows, accompanied by an implementation of <code>reserve()</code> that suits <code>Vector&lt;T&gt;</code>. We will discuss <code>reserve()</code> and <code>resize()</code> separately:</p>
<pre class="source-code">
   // ...
private:
   void grow() {
      <strong class="bold">reserve</strong>(capacity()? capacity() * 2 : 16);
   }
public:
   void reserve(size_type new_cap) {
      if(new_cap &lt;= capacity()) return;
      auto p = static_cast&lt;pointer&gt;(
         std::malloc(new_cap * sizeof(T))
      );
      if constexpr(std::is_nothrow_move_assignable_v&lt;T&gt;) {
         std::uninitialized_move(begin(), end(), p);
      } else try {
         std::uninitialized_copy(begin(), end(), p);
      } catch (...) {
         std::free(p);
         throw;
      }
      std::destroy(begin(), end());
      std::free(elems);
      elems = p;
      cap = new_cap;
   }
   // ...</pre> <p>The <code>reserve()</code> member <a id="_idIndexMarker695"/>function first ensures that the requested new capacity is higher than the existing one (otherwise there’s nothing to do). If that is so, it allocates a new memory block and either moves or copies the existing elements of the <code>Vector&lt;T&gt;</code> object into that new memory (a copy will be made if moving <code>T</code> objects can throw: it pays to make move operations <code>noexcept</code>, dear readers!) using algorithms that construct objects into raw memory.</p>
<p>The <code>T</code> objects left in <code>elems</code> are then destroyed (even if they have been moved-from: they still need to be finalized), and we ensure that <code>cap</code> is updated and <code>elems</code> points to the new block of storage. Of course, <code>size()</code> does not change as no new object has been added to the container.</p>
<p>The procedure <a id="_idIndexMarker696"/>is similar for <code>resize()</code> (as follows), except that the locations in the memory block starting at the <code>size()</code> index are initialized with a default <code>T</code> instead of being left in their raw memory state. Consequently, <code>size()</code> is updated, leading to different semantics from those obtained following a call to <code>reserve()</code>:</p>
<pre class="source-code">
   // ...
   void resize(size_type new_cap) {
      if(new_cap &lt;= capacity()) return;
      auto p = static_cast&lt;pointer&gt;(
         std::malloc(new_cap * sizeof(T))
      );
      if constexpr(std::is_nothrow_move_assignable_v&lt;T&gt;) {
         std::uninitialized_move(begin(), end(), p);
      } else try {
         std::uninitialized_copy(begin(), end(), p);
      } catch (...) {
         std::free(p);
         throw;
      }
      std::uninitialized_fill(
         p + size(), p + capacity(), value_type{}
      );
      std::destroy(begin(), end());
      std::free(elems);
      elems = p;
      nelems = new_cap;
      cap = new_cap;
   }
   // ...</pre> <p>This more <a id="_idIndexMarker697"/>sophisticated structure we are implementing will obviously have an impact on the way we <code>insert()</code> or <code>erase()</code> elements.</p>
<h3>Impact on element insertion and erasure functions</h3>
<p>As expected, member <a id="_idIndexMarker698"/>functions such as <code>insert()</code> and <code>erase()</code> have to <a id="_idIndexMarker699"/>be updated to take into account the changes we <a id="_idIndexMarker700"/>have made to the internal <a id="_idIndexMarker701"/>organization of <code>Vector&lt;T&gt;</code> objects. That does not have to be painful (and, indeed, required changes, if any, can be tiny) as long as the semantics of every function are clear from the onset, but it does require care.</p>
<p>For example, using <code>insert(pos,first,last)</code> as an example, we are moving from the simple model described in <em class="italic">Figure 12</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 12.1 – Example of the naïve Vector&lt;T&gt; insertion model" src="img/B21071_12_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Example of the naïve Vector&lt;T&gt; insertion model</p>
<p>Here, inserting a <code>[first,last)</code> sequence at position <code>pos</code> means copying (in reverse order) the <a id="_idIndexMarker702"/>elements in <code>[pos,end())</code> at <a id="_idIndexMarker703"/>position <code>pos + n</code>, then overwriting the elements of <code>[pos,pos+n)</code> with <code>[first,last)</code> to the more complex model described in <em class="italic">Figure 12</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 12.2 – Example of the current Vector&lt;T&gt; insertion model" src="img/B21071_12_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Example of the current Vector&lt;T&gt; insertion model</p>
<p>The idea is that we need to insert <code>[first,last)</code> at position <code>pos</code>, which means that the elements in <code>[pos,pos+n)</code> have to be copied (or moved) to the right. This will require <a id="_idIndexMarker704"/>constructing some <a id="_idIndexMarker705"/>objects in raw memory (the gray area in the preceding figure) and replacing some other objects through copy (or move) assignment.</p>
<p>There are four steps to consider here:</p>
<ul>
<li>How many elements should be copied or moved from the <code>[begin(),end()) </code>sequence to the raw memory block at the end of the container, and where in that block should the resulting objects be constructed.</li>
<li>If there are elements from the <code>[first,last)</code> sequence to insert in raw memory (there could be none), how many should there be? If there are any such objects, they will be inserted at <code>end()</code>.</li>
<li>If there are elements to copy or move from the <code>[pos,end())</code> sequence to copy or move as a replacement to existing objects in the container (there could be none), how many should there be? The end of the destination range will be <code>end()</code> in this case.</li>
<li>Finally, whatever remains to be inserted from the <code>[first,last)</code> sequence will be copied in the container starting at <code>pos</code>.</li>
</ul>
<p>A possible implementation would be the following:</p>
<pre class="source-code">
   // ...
   template &lt;class It&gt;
   iterator insert(const_iterator pos, It first, It last) {
      iterator pos_ = const_cast&lt;iterator&gt;(pos);
      const auto remaining = capacity() - size();
      const auto n = std::distance(first, last);
<strong class="bold">      // we use cmp_less() here as remaining is an unsigned</strong>
<strong class="bold">      // integral but n is a signed integral</strong>
      if (<strong class="bold">std::cmp_less(remaining, n)</strong>) {
         auto index = std::distance(begin(), pos_);
         reserve(capacity() + n - remaining);
         pos_ = std::next(begin(), index);
      }
<strong class="bold">      // objects to displace (move or copy) from the</strong>
<strong class="bold">      // [begin(),end()) sequence into raw memory</strong>
      const auto nb_to_uninit_displace =
         std::min&lt;std::ptrdiff_t&gt;(n, end() - pos_);
      auto where_to_uninit_displace =
         end() + n - nb_to_uninit_displace;
      if constexpr(std::is_nothrow_move_constructible_v&lt;T&gt;)
         std::uninitialized_move(
            end() - nb_to_uninit_displace, end(),
            where_to_uninit_displace
         );
      else
         std::uninitialized_copy(
            end() - nb_to_uninit_displace, end(),
            where_to_uninit_displace
         );
<strong class="bold">      // objects from [first,last) to insert into raw</strong>
<strong class="bold">      // memory (note: there might be none)</strong>
      const auto nb_to_uninit_insert =
         std::max&lt;std::ptrdiff_t&gt;(
            0, n - nb_to_uninit_displace
         );
      auto where_to_uninit_insert = end();
      std::uninitialized_copy(
         last - nb_to_uninit_insert, last,
         where_to_uninit_insert
      );
<strong class="bold">      // objects to displace (copy or move) from the</strong>
<strong class="bold">      // [pos,end()) sequence into that space (note:</strong>
<strong class="bold">      // there might be none)</strong>
      const auto nb_to_backward_displace =
         std::max&lt;std::ptrdiff_t&gt;(
            0, end() - pos_ - nb_to_uninit_displace
         );
<strong class="bold">       // note : end of destination</strong>
      auto where_to_backward_displace = end();
      if constexpr (std::is_nothrow_move_assignable_v&lt;T&gt;)
         std::move_backward(
            pos_, pos_ + nb_to_backward_displace,
            where_to_backward_displace
         );
      else
         std::copy_backward(
            pos_, pos_ + nb_to_backward_displace,
            where_to_backward_displace
         );
<strong class="bold">      // objects to copy from [first,last) to pos</strong>
      std::copy(
         first, first + n - nb_to_uninit_insert, pos
      );
      nelems += n;
      return pos_;
   }</pre> <p>Make sure you do not move the elements in <code>[first,last)</code>, however: that would be user-hostile as it would potentially destroy the data in the source range!</p>
<p>As for the <code>erase()</code> member function that we had written in a more naïve manner initially, the key adjustment we will need to make is in the way we handle the removed element: you might remember that in our naïve version, we assigned a default <code>T</code> to the erased <a id="_idIndexMarker706"/>element at the end of <a id="_idIndexMarker707"/>the container, and complained that this added the suspicious requirement of a default constructor in type <code>T</code>. In this version, we will quite simply destroy this object, ending its lifetime and turning its underlying storage back into raw memory:</p>
<pre class="source-code">
   iterator erase(const_iterator pos) {
      iterator pos_ = const_cast&lt;iterator&gt;(pos);
      if (pos_ == end()) return pos_;
      std::copy(std::next(pos_), end(), pos_);
<strong class="bold">      std::destroy_at(std::prev(end()));</strong>
      --nelems;
      return pos_;
   }</pre> <p>Hopefully, this gives you, dear reader, a better idea of what it takes to write a more serious implementation of a homemade <code>std::vector</code>-like type and a better appreciation for the craftsmanship of the individuals behind your favorite standard library provider. Know that they do all this and more for your programs to be the wonderfully efficient things they are!</p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor185"/>Const or reference members and std::launder()</h2>
<p>Before we <a id="_idIndexMarker708"/>conclude this chapter, we <a id="_idIndexMarker709"/>need to say a few words on those oddities that are containers that hold objects of <code>const</code> types, as well as on containers whose elements are of a type with <code>const</code> or reference members.</p>
<p>Consider this seemingly innocuous program:</p>
<pre class="source-code">
// ...
int main() {
   Vector&lt;<strong class="bold">const int</strong>&gt; v;
   for(int n : { 2, 3, 5, 7, 11 })
      v.push_back(n);
}</pre> <p>With the implementation we have, this will refuse to compile as our implementation calls a number of low-level functions (<code>std::free()</code>, <code>std::destroy_at()</code>, <code>std::construct_at()</code>, and so on) that take a pointer to a non-<code>const</code> type as an argument.</p>
<p>If we are to support such a program, it means we will have to “cast away” <code>const</code>-ness in some places in our implementation. For example, replacing the following line</p>
<pre class="source-code">
      std::free(<strong class="bold">elems</strong>); <strong class="bold">// illegal if elems points to const</strong></pre> <p>with this:</p>
<pre class="source-code">
      using type = <strong class="bold">std::remove_const_t&lt;value_type&gt;*</strong>;
      std::free(<code>std::copy()</code> or <code>std::copy_backward()</code> algorithms will not work on <code>const</code> objects or objects with <code>const</code> data members. You can make it work by replacing assignment with destruction followed by construction, but your code will be less exception-safe if the construction fails just after the destruction of the object that had to be replaced.</p>
<p>Of course, casting away <code>const</code>-ness leads us into tricky territory as we are bordering the frightening lands of undefined behavior. Standard library implementors can, of course, do what they want, having the ears of the compiler implementors, but we mere mortals do not share this privilege and, for that reason, must tread carefully.</p>
<p>A similar <a id="_idIndexMarker710"/>situation arises with composite objects that have data members of some reference type: you cannot make a container <a id="_idIndexMarker711"/>of references as references are not objects, but you sure can make a container of objects with reference-type data members. The problem, of course, is making sense of what happens when an object with a reference data member is being replaced.</p>
<p>Let’s take a simpler example than <code>Vector&lt;T&gt;</code> to explain this situation. Suppose we have the following class, made to hold a reference to some object of type <code>T</code>:</p>
<pre class="source-code">
#include &lt;type_traits&gt;
template &lt;class T&gt;
struct X {
   <strong class="bold">static_assert(std::is_trivially_destructible_v&lt;T&gt;);</strong>
   <strong class="bold">T &amp;r</strong>;
public:
   X(T &amp;r) : r{ r } {
   }
   T&amp; value() { return r; }
   const T &amp; value() const { return r; }
};
// ...</pre> <p>As is, this class is simple enough and seems easy to reason about. Now, suppose we have the following client code:</p>
<pre class="source-code">
// ...
#include &lt;iostream&gt;
#include &lt;new&gt;
int main() {
   int n = 3;
   X&lt;int&gt; h{ n };
   h.value()++;
   std::cout &lt;&lt; n &lt;&lt; '\n'; // 4
   std::cout &lt;&lt; h.value() &lt;&lt; '\n'; // 4
   int m = -3;
<strong class="bold">   // h = X&lt;int&gt;{ m }; // nope</strong>
<strong class="bold">   X&lt;int&gt; *p = new (static_cast&lt;void*&gt;(&amp;h)) X&lt;int&gt;{ m };</strong>
<strong class="bold">   std::cout &lt;&lt; p-&gt;value() &lt;&lt; '\n'; // -3</strong>
<strong class="bold">   // UB (-3? 4? something else?)</strong>
<strong class="bold">   std::cout &lt;&lt; h.value() &lt;&lt; '\n';</strong>
<strong class="bold">   std::cout &lt;&lt; std::launder(&amp;h)-&gt;value() &lt;&lt; '\n'; // -3</strong>
}</pre> <p>Replacing an <code>X&lt;int&gt;</code> object through assignment is incorrect as having a reference data member deletes your assignment operator, at least by default (the default meaning would <a id="_idIndexMarker712"/>be ambiguous: should the reference <a id="_idIndexMarker713"/>be rebound to something else, or should the referred-to object be assigned to?).</p>
<p>One way to get around this problem is to destroy the original object and construct a new object in its place. In our example, since we ensured (through <code>static_assert</code>) that <code>T</code> was trivially destructible, we just constructed a new object where the previous one stood (ending the previous object’s lifetime). The bits are then all mapped properly to the new object... except that the compiler might not follow our reasoning.</p>
<p>In practice, compilers track the lifetime of objects the best they can, but we placed ourselves in a situation where the original <code>X&lt;int&gt;</code> object has never been explicitly destroyed. For that reason, this original <code>X&lt;int&gt;</code> object could still be considered to be there by the compiler, but the bits of the original object have been replaced by the new object placed at that specific address through very manual means. There might be a discrepancy between what the bits say and what the compiler understands from the source code, because (to be honest) we have been playing dirty tricks with the explicit construction <a id="_idIndexMarker714"/>of an object at a specific address <a id="_idIndexMarker715"/>that happens to have been occupied by another object.</p>
<p>Accessing <code>value()</code> through <code>p</code> will definitely give you <code>-3</code> as it’s obvious that <code>p</code> points to an <code>X&lt;int&gt;</code> object that holds a reference to <code>m</code>, and <code>m</code> has the value <code>-3</code> at that point. Accessing <code>value()</code> through <code>h</code> is undefined behavior (will the resulting code give you what the bits say or what the compiler thinks that code is saying?).</p>
<p>This sort of evil-seeming situation, where the code logic as understood by the compiler might not match the bits, happens with objects with <code>const</code> data members, objects with reference data members, and some <code>union</code> types crafted in weird ways, but these are the tools we use for the low-level manipulation of objects, and that can be found underneath <code>std::optional&lt;T&gt;</code>, <code>std::vector&lt;T&gt;</code>, and others. It’s our fault, in the end, for using these weird types, but it’s part of life.</p>
<p>When the bits do not necessarily align with what the compiler can understand, we have <code>std::launder()</code>. Use this cautiously: it’s an optimization barrier that states “just look at the bits, compiler; forget what you know about source code when looking at this pointed-to object.” Of course, this is a very dangerous tool and should be used with a lot of care, but sometimes it’s just what is needed.</p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor186"/>Summary</h1>
<p>Whew, this was a long chapter! We implemented a naïve <code>vector</code>-like container, then a naïve <code>forward_list</code>-like container, and then took another look at the <code>vector</code>-like container (we will return to the <code>forward_list</code>-like container in the next two chapters) to show how tighter control over memory can lead to more efficient containers.</p>
<p>Our implementations in this chapter were “manual,” in the sense that we did the memory management by hand. That involved writing a lot of code, something we will reconsider in <a href="B21071_13.xhtml#_idTextAnchor187"><em class="italic">Chapter 13</em></a>. In <a href="B21071_14.xhtml#_idTextAnchor199"><em class="italic">Chapter 14</em></a>, we will examine how allocators interact with containers, and will use this opportunity to revisit our <code>forward_list</code>-like container as there will be interesting aspects to examine as we continue our adventure through memory management in C++.</p>
</div>
</body></html>