<html><head></head><body>
<div id="_idContainer044">
<h1 class="chapter-number" id="_idParaDest-167"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-168"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.2.1">Writing Generic Containers with Explicit Memory Management</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We have come quite a long way since the beginning of our journey into the wonders of memory management mechanisms and techniques in C++. </span><span class="koboSpan" id="kobo.3.2">From </span><a href="B21071_04.xhtml#_idTextAnchor062"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.5.1"> to </span><a href="B21071_07.xhtml#_idTextAnchor116"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.7.1">, we built an interesting toolbox, one on which we can build and from which we can adapt to solve new problems we might face in the future. </span><span class="koboSpan" id="kobo.7.2">This toolbox now contains, among other things, </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Techniques through which an object implicitly manages </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">its resources</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Types that behave like pointers but encode responsibility over the pointee in the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">type system</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Various ways in which we can take over the behavior of memory allocation mechanisms of </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">a program</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.15.1">One (important!) aspect of memory management we have not covered yet is how containers manage memory. </span><span class="koboSpan" id="kobo.15.2">This is actually quite an interesting topic, one that we will address through three different angles, in three </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">different chapters.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">The first angle is how to handle memory management </span><em class="italic"><span class="koboSpan" id="kobo.18.1">explicitly</span></em><span class="koboSpan" id="kobo.19.1"> yet efficiently in a container. </span><span class="koboSpan" id="kobo.19.2">This is what the current chapter is about. </span><span class="koboSpan" id="kobo.19.3">In some application domains, it is customary to implement (or maintain) one’s own containers instead of using those provided by the standard library. </span><span class="koboSpan" id="kobo.19.4">There can be various reasons for this: for example, maybe your company has highly specialized needs. </span><span class="koboSpan" id="kobo.19.5">Maybe your company has been unsatisfied with standard library containers’ performance in the past, perhaps because the implementations were less efficient than they hoped back then, and developed its own alternative containers in response. </span><span class="koboSpan" id="kobo.19.6">After years of writing code based on your own containers, moving back to standard library containers might seem </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">too costly.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">The second angle, which is somewhat shorter, is how to handle memory </span><em class="italic"><span class="koboSpan" id="kobo.22.1">implicitly</span></em><span class="koboSpan" id="kobo.23.1"> yet efficiently in a container, and will be covered in </span><a href="B21071_13.xhtml#_idTextAnchor187"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.24.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.25.1"> of this book, where we will revisit and simplify the implementations seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">current chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">The third angle, which is more complex and subtle, is how to handle memory through an allocator in a container, and will form </span><a href="B21071_14.xhtml#_idTextAnchor199"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.28.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.29.1"> of </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">In the current chapter, we will write a (naïve) </span><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">std::vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.33.1"> lookalike named </span><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.35.1">. </span><span class="koboSpan" id="kobo.35.2">We will use that as an opportunity to discuss exception safety (an important issue, especially when writing generic code). </span><span class="koboSpan" id="kobo.35.3">Then, we will notice that we have been very inefficient up to that point, in the sense that </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">std::vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.37.1"> will be significantly more efficient than our </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.39.1"> alternative, at least for some types. </span><span class="koboSpan" id="kobo.39.2">Based on this realization, we will revisit our design with better memory management, seeing important improvements in many aspects, and discuss some important low-level standard facilities for memory management that can (and will) make our </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">lives easier.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">We will also write a homemade </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">std::forward_list&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.43.1"> lookalike named </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.45.1">, as there are issues and considerations specific to node-based containers that a vector-like type does not really allow us to discuss. </span><span class="koboSpan" id="kobo.45.2">This chapter will write a “vanilla” version of a forward list, and we will revisit it briefly in </span><a href="B21071_13.xhtml#_idTextAnchor187"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.46.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.47.1">, then in more detail in </span><a href="B21071_14.xhtml#_idTextAnchor199"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.48.1">Chapter 14</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.49.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">This means that after reading this chapter, you will be able to do </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.52.1">Write a correct and exception-safe container with naïve memory </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">management techniques</span></span></li>
<li><span class="koboSpan" id="kobo.54.1">Understand the problems associated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">const</span></strong><span class="koboSpan" id="kobo.56.1"> or reference </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">data members</span></span></li>
<li><span class="koboSpan" id="kobo.58.1">Use standard-provided low-level memory </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">management algorithms</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.60.1">More generally, you will know why </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">std::vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.62.1"> is so fast, and why that type is so difficult to beat at the resource management game. </span><span class="koboSpan" id="kobo.62.2">You will also get an idea of the challenges faced by node-based containers such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">std::forward_list&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.64.1">, although later chapters will delve more deeply into this. </span><span class="koboSpan" id="kobo.64.2">That does not mean you should not write your own containers (for specific use cases, we can often do better than a general solution), but it does mean that you will know better why (and when) to do so, and how much effort you will need </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">to invest.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.66.1">Exhaustiveness or representativeness</span></p>
<p class="callout"><span class="koboSpan" id="kobo.67.1">This book does not in general aim for exhaustive representations or implementations (there are size limits to a physical object such as a book!), and this chapter will be no exception to that rule… far from it! </span><span class="koboSpan" id="kobo.67.2">Implementing the full set of member functions provided for two container types inspired by the standard library would require this book to grow immensely – and your standard library implementation covers many more corner cases (and offers many more cool optimizations) than a book such as this one could hope to present. </span><span class="koboSpan" id="kobo.67.3">For that reason, we will try to expose a core set of member functions from which you can build instead of trying to write every single one </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">of them.</span></span></p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.69.1">Technical requirements</span></h1>
<p><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.70.1">You can find the code files for this chapter in the book’s GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">here: </span></span><a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter12"><span class="No-Break"><span class="koboSpan" id="kobo.72.1">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter12</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.73.1">.</span></span></p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.74.1">Writing your own vector&lt;T&gt; alternative</span></h1>
<p><span class="koboSpan" id="kobo.75.1">Suppose you </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.76.1">get up one day and say: “Hey, I’m going to beat </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">std::vector</span></strong><span class="koboSpan" id="kobo.78.1"> at its own game” and confidently start coding. </span><span class="koboSpan" id="kobo.78.2">Some words to </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">the wise:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.80.1">This seemingly simple task is astonishingly difficult to accomplish: for one thing, </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">std::vector</span></strong><span class="koboSpan" id="kobo.82.1"> is a work of art, and then there’s the fact that your favorite standard library writers are spectacularly </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">skilled individuals.</span></span></li>
<li><span class="koboSpan" id="kobo.84.1">You might still think you can do it, so it’s fine to try, but make sure you test your ideas with both a type of element that is trivially constructible (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">int</span></strong><span class="koboSpan" id="kobo.86.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">double</span></strong><span class="koboSpan" id="kobo.88.1">) and one that is not (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">std::string</span></strong><span class="koboSpan" id="kobo.90.1">) and compare the results. </span><span class="koboSpan" id="kobo.90.2">For many, the former will lead to stellar performance, but the latter might </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">bring …sadness.</span></span></li>
<li><span class="koboSpan" id="kobo.92.1">The reason for this difference is that a container such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">std::vector</span></strong><span class="koboSpan" id="kobo.94.1"> is extremely efficient at… managing memory (I know, reading this in this book must come as quite a shock!). </span><span class="koboSpan" id="kobo.94.2">It is much better, in fact, than a homegrown alternative would be, unless you invest significant time and effort and (most probably) have a specific use case in mind, one for which the homegrown version would be optimized </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">more specifically.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.96.1">Your standard library vendor does invest such time and effort and does so for your very benefit, so it is possible that learning how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">std::vector</span></strong><span class="koboSpan" id="kobo.98.1"> optimally will end up being an avenue that brings better results than trying to write your personal equivalent container. </span><span class="koboSpan" id="kobo.98.2">Of course, in the end, which container to use is up to you, and you can often write code </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.99.1">for custom situations that outperforms general solutions the way standard </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">containers do.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.101.1">A general note on how we will write our containers</span></p>
<p class="callout"><span class="koboSpan" id="kobo.102.1">We will be writing (and using) containers in this chapter and the ones that follow, so a brief explanation is needed if we want to have a common understanding of how we will proceed. </span><span class="koboSpan" id="kobo.102.2">For one thing, we will use type aliases in our containers that match those used in standard containers, as this helps toward a more fluid integration in other standard library tools, such as the standard algorithms. </span><span class="koboSpan" id="kobo.102.3">Then, we will strive to use the same public names for our member functions as those used in the standard library (for example, we will write </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">empty()</span></strong><span class="koboSpan" id="kobo.104.1"> for the predicate used to test whether a container is empty or not, matching existing practice in the standard library, even though some might argue </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">is_empty()</span></strong><span class="koboSpan" id="kobo.106.1"> would be preferable). </span><span class="koboSpan" id="kobo.106.2">Finally, we will adopt a gradual refinement approach: our first versions will be simpler but less efficient than later ones, so be patient, dear reader: we are following our own path </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">to enlightenment!</span></span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.108.1">Representational choices for a container of contiguous elements</span></h2>
<p><span class="koboSpan" id="kobo.109.1">Informally, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">std::vector</span></strong><span class="koboSpan" id="kobo.111.1"> represents a dynamically allocated array that can grow as needed. </span><span class="koboSpan" id="kobo.111.2">As with </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.112.1">any array, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">std::vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.114.1"> is a sequence of elements of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">T</span></strong><span class="koboSpan" id="kobo.116.1"> arranged contiguously in memory. </span><span class="koboSpan" id="kobo.116.2">We will name our homemade version </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.118.1"> to make it visibly distinct </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">std::vector&lt;T&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">To get a reasonably performant implementation, the first key idea is to </span><em class="italic"><span class="koboSpan" id="kobo.123.1">distinguish size from capacity</span></em><span class="koboSpan" id="kobo.124.1">. </span><span class="koboSpan" id="kobo.124.2">If we do not do so, deciding to make size and capacity the same thing, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.126.1"> implementation will always conceptually be full and will need to grow, which means allocating more memory, copying the elements from the old storage to the new storage, getting rid of the old storage, and so on with every insertion of even a single element. </span><span class="koboSpan" id="kobo.126.2">To say such an implementation would be painful seems like a </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">severe understatement.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">There are two main approaches to the internal representation of a vector-like type. </span><span class="koboSpan" id="kobo.128.2">One is to keep track of </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">three pointers:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.130.1">One to the beginning of the </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">allocated storage</span></span></li>
<li><span class="koboSpan" id="kobo.132.1">One to the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">the elements</span></span></li>
<li><span class="koboSpan" id="kobo.134.1">One to the end of the allocated storage (note that we are referring to half-open ranges here, with the beginning included and the </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">end excluded)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.136.1">A simplified </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.137.1">illustration would be </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.139.1">
template &lt;class T&gt;
   class Vector {
      T *elems;
      T *end_elems;
      T *end_storage;
      // ...</span></pre> <p><span class="koboSpan" id="kobo.140.1">Another is to keep a pointer to the beginning of the allocated storage as well as  two integers (for the container’s size and capacity, respectively). </span><span class="koboSpan" id="kobo.140.2">A simplified illustration in this case would be </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.142.1">
template &lt;class T&gt;
   class Vector {
      T *elems;
      std:size_t nelems; // number of elements
      std::size_t cap; // capacity
      // ...</span></pre> <p><span class="koboSpan" id="kobo.143.1">These are equivalent representations in the sense that they both allow us to write a correct container, but they bring different trade-offs. </span><span class="koboSpan" id="kobo.143.2">For example, keeping three pointers makes computing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">end()</span></strong><span class="koboSpan" id="kobo.145.1"> iterator fast but makes </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">size()</span></strong><span class="koboSpan" id="kobo.147.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">capacity()</span></strong><span class="koboSpan" id="kobo.149.1"> require computing a pointer subtraction, whereas keeping a pointer and two integers makes both </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">size()</span></strong><span class="koboSpan" id="kobo.151.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">capacity()</span></strong><span class="koboSpan" id="kobo.153.1"> fast but requires computing the addition of a pointer and an integer to get the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">end()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.155.1"> iterator.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">As far as size goes, the three-pointer representation makes </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">sizeof(Vector&lt;T&gt;)</span></strong><span class="koboSpan" id="kobo.158.1"> equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">3*sizeof(void*)</span></strong><span class="koboSpan" id="kobo.160.1">, thus probably 24 bytes on a 64-bit platform with an alignment of 8. </span><span class="koboSpan" id="kobo.160.2">The pointer and two integers might be of the same size or might be slightly different depending on the integer types used. </span><span class="koboSpan" id="kobo.160.3">For example, choosing 32-bit integers for the size and capacity on a 64-bit machine would lead to a 16-byte representation </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.161.1">and an alignment of 8. </span><span class="koboSpan" id="kobo.161.2">These details may make a difference on a resource-constrained system, but as you have probably deduced already, the main memory consumption cost of something such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.163.1"> comes from the memory allocated for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">T</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.165.1"> objects.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">Different implementations will make different representational choices due to size considerations, estimates of which member functions will be called more often on average, and so on. </span><span class="koboSpan" id="kobo.166.2">We will need to make a choice too; in this book, we will choose the “one pointer and two integers” approach, but keep in mind it’s one of a few reasonable options (you can even play with the idea and implement what follows through other representational choices and see where this </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">leads you!).</span></span></p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.168.1">The implementation of Vector&lt;T&gt;</span></h2>
<p><span class="koboSpan" id="kobo.169.1">We will walk through our initial (naïve) </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.171.1"> implementation step by step, building </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.172.1">a gradual understanding of how this all works, and what makes us claim that this implementation is indeed naïve. </span><span class="koboSpan" id="kobo.172.2">Our initial step has mostly been covered already and consists of defining our abstractions through standard library-conforming type aliases and choosing our </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">internal representation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.174.1">
#include &lt;cstddef&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;initializer_list&gt;
#include &lt;iterator&gt;
#include &lt;type_traits&gt;
template &lt;class T&gt;
   class Vector {
   public:
      using value_type = T;
      using size_type = std::size_t;
      using pointer = T*;
      using const_pointer = const T*;
      using reference = T&amp;;
      using const_reference = const T&amp;;
   private:
      pointer elems{};
      size_type nelems{},
                cap{};
      // ...</span></pre> <p><span class="koboSpan" id="kobo.175.1">You will notice that this implementation makes the choice of using non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">static</span></strong><span class="koboSpan" id="kobo.177.1"> data member </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.178.1">initializers for the three data members of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.180.1">, initializing them to their default values (integers are 0, the pointer is null), which is suitable in our implementation as it represents an empty container, which seems like a reasonable state for a </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">default </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">Vector&lt;T&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">Some simple yet fundamental member </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">functions follow:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.186.1">
   // ...
</span><span class="koboSpan" id="kobo.186.2">   public:
      size_type size() const { return nelems; }
      size_type capacity() const { return cap; }
      bool empty() const { return size() == 0; }
   private:
      bool full() const { return size() == capacity(); }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.187.1">Pay attention to the implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">empty()</span></strong><span class="koboSpan" id="kobo.189.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">full()</span></strong><span class="koboSpan" id="kobo.191.1">. </span><span class="koboSpan" id="kobo.191.2">Some people will prefer accessing data members (here: using </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">nelems</span></strong><span class="koboSpan" id="kobo.193.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">cap</span></strong><span class="koboSpan" id="kobo.195.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">size()</span></strong><span class="koboSpan" id="kobo.197.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">capacity()</span></strong><span class="koboSpan" id="kobo.199.1">) internally when implementing member functions, but consider reusing your more fundamental member functions to implement the more “synthetic” ones. </span><span class="koboSpan" id="kobo.199.2">This will </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.200.1">make your code less sensitive to changes in the implementation, and C++ compilers are very good at function inlining, particularly when these functions </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">are non-</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">virtual</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">At this point, the most useful set of members we could probably design is the iterator types and data members of our class, as this will help us use standard algorithms to cleanly and efficiently implement the rest of our </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">member functions.</span></span></p>
<h3><span class="koboSpan" id="kobo.206.1">Iterators</span></h3>
<p><span class="koboSpan" id="kobo.207.1">C++ containers usually expose iterators as part of their interface, and ours will be no exception. </span><span class="koboSpan" id="kobo.207.2">We will </span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.208.1">define type aliases for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">const</span></strong><span class="koboSpan" id="kobo.210.1"> and non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">const</span></strong><span class="koboSpan" id="kobo.212.1"> iterator types, as this makes it simpler to implement alternatives such as bounds-checked iterators if we feel the need to do so, and implement both </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">const</span></strong><span class="koboSpan" id="kobo.214.1"> and non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">const</span></strong><span class="koboSpan" id="kobo.216.1"> versions of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">begin()</span></strong><span class="koboSpan" id="kobo.218.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">end()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.220.1">member functions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.221.1">
      // ...
</span><span class="koboSpan" id="kobo.221.2">   public:
      using iterator = pointer;
      using const_iterator = const_pointer;
      iterator begin() { return elems; }
      const_iterator begin() const { return elems; }
      iterator end() { return begin() + size(); }
      const_iterator end() const {
         return begin() + size();
      }
      // for users' convenience
      const_iterator cend() const { return end(); }
      const_iterator cbegin() const { return begin(); }
      // ...</span></pre> <p><span class="koboSpan" id="kobo.222.1">You might </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.223.1">complain about the syntactic repetition that comes with writing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">const</span></strong><span class="koboSpan" id="kobo.225.1"> and non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">const</span></strong><span class="koboSpan" id="kobo.227.1"> version for </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">begin()</span></strong><span class="koboSpan" id="kobo.229.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">end()</span></strong><span class="koboSpan" id="kobo.231.1">, as these are syntactically similar yet semantically distinct. </span><span class="koboSpan" id="kobo.231.2">If you have a C++23 compiler at hand, you can simplify this somewhat through the handy “deduced </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">this</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">” feature:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.234.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.235.1">// alternative approach (requires C++23)</span></strong><span class="koboSpan" id="kobo.236.1">
      template &lt;class S&gt;
         auto begin(this S &amp;&amp; self) { return self.elems; }
      template &lt;class S&gt;
         auto end(this S &amp;&amp; self) {
            return self.begin() + self.size();
         }</span></pre> <p><span class="koboSpan" id="kobo.237.1">This is a slightly more complicated way of expressing these functions, but it lets us coalesce both versions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">begin()</span></strong><span class="koboSpan" id="kobo.239.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">end()</span></strong><span class="koboSpan" id="kobo.241.1"> into one by leveraging the type deduction system through </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">forwarding references.</span></span></p>
<h3><span class="koboSpan" id="kobo.243.1">Constructors and other special member functions</span></h3>
<p><span class="koboSpan" id="kobo.244.1">We now get to our constructors. </span><span class="koboSpan" id="kobo.244.2">The first two we will look at are the default constructor and a </span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.245.1">parametric constructor that takes as arguments a number of elements and an initial value, such that </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">Vector&lt;char&gt;(3,'a')</span></strong><span class="koboSpan" id="kobo.247.1"> yields a container </span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.248.1">with three elements of value </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">'a'</span></strong><span class="koboSpan" id="kobo.250.1">. </span><span class="koboSpan" id="kobo.250.2">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">default</span></strong><span class="koboSpan" id="kobo.252.1">-ed default constructor (yes, I know) in this case is implicitly </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">constexpr</span></strong><span class="koboSpan" id="kobo.254.1"> as all the non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">static</span></strong><span class="koboSpan" id="kobo.256.1"> member initializers can be resolved in a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">constexpr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.258.1"> context:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.259.1">
      // ...
</span><span class="koboSpan" id="kobo.259.2">      Vector() = default;
      Vector(size_type n, const_reference init)
         : elems{ new value_type[n] },
           nelems{ n }, cap{ n } {
         try {
            std::fill(begin(), end(), init);
         } catch(...) {
            delete [] elems;
            throw;
         }
      }
      // ...</span></pre> <p><span class="koboSpan" id="kobo.260.1">Pay attention to the exception-handling code in this constructor, as it will come back again and again. </span><span class="koboSpan" id="kobo.260.2">We are writing a generic container, so we are using some type </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">T</span></strong><span class="koboSpan" id="kobo.262.1"> we have no </span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.263.1">prior knowledge of. </span><span class="koboSpan" id="kobo.263.2">When calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">std::fill()</span></strong><span class="koboSpan" id="kobo.265.1">, which assigns the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">init</span></strong><span class="koboSpan" id="kobo.267.1"> argument to each of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">T</span></strong><span class="koboSpan" id="kobo.269.1"> objects in the sequence, we are </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.270.1">assigning a </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">T</span></strong><span class="koboSpan" id="kobo.272.1"> value to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">T</span></strong><span class="koboSpan" id="kobo.274.1"> object, but we do not know whether that assignment operator </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">can throw.</span></span></p>
<p><span class="koboSpan" id="kobo.276.1">Our responsibility is to </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">elems</span></strong><span class="koboSpan" id="kobo.278.1">, a dynamically allocated array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">T</span></strong><span class="koboSpan" id="kobo.280.1">, so if one of the assignment operators throws, we need to make sure that array is destroyed and deallocated before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.282.1"> constructor fails; otherwise, we will leak the memory and (even worse) the objects we had constructed in that array will not be finalized. </span><span class="koboSpan" id="kobo.282.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">catch(...)</span></strong><span class="koboSpan" id="kobo.284.1"> block means “catch anything,” without really knowing what you caught in this case, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">throw;</span></strong><span class="koboSpan" id="kobo.286.1"> expression means “re-throw whatever you had caught.” </span><span class="koboSpan" id="kobo.286.2">Indeed, we do not want to handle the exception in such a case (we do not have sufficient knowledge of the execution context to do so: is this a console application? </span><span class="koboSpan" id="kobo.286.3">A graphical application? </span><span class="koboSpan" id="kobo.286.4">An embedded system? </span><span class="koboSpan" id="kobo.286.5">Something else?); we just want to make sure our failure to construct the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.288.1"> object did not leak resources and let user code know exactly why it is that our constructor failed to meet its postconditions (failed to construct a </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">valid object).</span></span></p>
<p><span class="koboSpan" id="kobo.290.1">The copy constructor will follow a similar pattern, except that instead of filling the sequence with copies of a single value, it copies values from a source sequence (</span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">other</span></strong><span class="koboSpan" id="kobo.292.1">) to a destination sequence (</span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">*this</span></strong><span class="koboSpan" id="kobo.294.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">elems</span></strong><span class="koboSpan" id="kobo.296.1"> depending on how you see it). </span><span class="koboSpan" id="kobo.296.2">The move constructor is, of course, </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">quite different:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.298.1">
      // ...
</span><span class="koboSpan" id="kobo.298.2">      Vector(const Vector &amp;other)
         : elems{ new value_type[other.size()] },
           nelems{ other.size() }, cap{ other.size() } {
         try {
            std::copy(other.begin(), other.end(), begin());
         } catch(...) {
            delete [] elems;
            throw;
         }
      }
      // ...
</span><span class="koboSpan" id="kobo.298.3">      Vector(Vector &amp;&amp;other) noexcept
         : elems{ std::exchange(other.elems, nullptr) },
           nelems{ std::exchange(other.nelems, 0) },
           cap{ std::exchange(other.cap, 0) } {
      }
      // ...</span></pre> <p><span class="koboSpan" id="kobo.299.1">As you </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.300.1">can see, the copy constructor is a costly beast for </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.301.1">this type: an allocation for </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">other.size()</span></strong><span class="koboSpan" id="kobo.303.1"> objects (with as many calls to the default constructor of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">T</span></strong><span class="koboSpan" id="kobo.305.1"> accompanying this for non-trivially-constructible objects), then </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">other.size()</span></strong><span class="koboSpan" id="kobo.307.1"> assignments, and exception handling </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">thrown in.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">The move constructor is simpler: it’s a constant-time, </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">noexcept</span></strong><span class="koboSpan" id="kobo.311.1"> function. </span><span class="koboSpan" id="kobo.311.2">You don’t technically need move operations in most classes (C++ got along fine for years without move operations, after all), but when you can take advantage of them, you probably should do so. </span><span class="koboSpan" id="kobo.311.3">The speed improvements can be stupendous, and execution speed becomes </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">more predictable.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.313.1">On values and salient properties</span></p>
<p class="callout"><span class="koboSpan" id="kobo.314.1">If you read the copy constructor’s code attentively, you might have noticed that </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">*this</span></strong><span class="koboSpan" id="kobo.316.1"> did not copy </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">other.capacity()</span></strong><span class="koboSpan" id="kobo.318.1">, instead deciding to make </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">cap</span></strong><span class="koboSpan" id="kobo.320.1"> a copy of </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">other.size()</span></strong><span class="koboSpan" id="kobo.322.1">. </span><span class="koboSpan" id="kobo.322.2">That’s actually the correct thing to do in such a case: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">size()</span></strong><span class="koboSpan" id="kobo.324.1"> of a container is </span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.325.1">what is called a </span><strong class="bold"><span class="koboSpan" id="kobo.326.1">salient property</span></strong><span class="koboSpan" id="kobo.327.1"> of the object, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">capacity()</span></strong><span class="koboSpan" id="kobo.329.1"> is more of an artifact of that object’s life, showing traces of how it has grown over time. </span><span class="koboSpan" id="kobo.329.2">What we want is that, after copying an object, the original and the copy compare equal with respect to </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">operator==</span></strong><span class="koboSpan" id="kobo.331.1"> and, of course, </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">capacity()</span></strong><span class="koboSpan" id="kobo.333.1"> does not intervene in that function: two arrays are generally considered equal if they have the same number of elements and each of these elements has the same value when compared to its counterpart in the other container. </span><span class="koboSpan" id="kobo.333.2">Copying the capacity would work in practice, but it would be wasteful for most </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">use cases.</span></span></p>
<p><span class="koboSpan" id="kobo.335.1">I added (for convenience) a constructor that accepts an </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">initializer_list&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.337.1">, argument </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.338.1">to allow for initializing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.340.1"> object with a </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.341.1">sequence of values of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">T</span></strong><span class="koboSpan" id="kobo.343.1">. </span><span class="koboSpan" id="kobo.343.2">The destructor should </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">be self-explanatory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.345.1">
      // ...
</span><span class="koboSpan" id="kobo.345.2">      Vector(std::initializer_list&lt;T&gt; src)
         : elems{ new value_type[src.size()] },
           nelems {src.size() }, cap{ src.size() } {
         try {
            std::copy(src.begin(), src.end(), begin());
         } catch(...) {
            delete [] elems;
            throw;
         }
      }
      // ...
</span><span class="koboSpan" id="kobo.345.3">      ~Vector() {
         delete [] elems;
      }</span></pre> <p><span class="koboSpan" id="kobo.346.1">Implementing the copy assignment operator from a source object (here: </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">other</span></strong><span class="koboSpan" id="kobo.348.1">) to a destination object (</span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">*this</span></strong><span class="koboSpan" id="kobo.350.1">) can be complicated if done in an…  undisciplined manner, as it involves cleanup code (for the before-assignment contents of </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">*this</span></strong><span class="koboSpan" id="kobo.352.1">), duplication of the state of </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.353.1">the source object, and ensuring we handle both self-assignment and potential exceptions thrown when duplicating the source object’s </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">state appropriately.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">Luckily, there’s a </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.356.1">neat trick suggested by Scott Meyers (and re-proposed by countless others!) who noticed that copy assignment can be expressed as a combination of a copy constructor (the locus of object duplication), the destructor (where cleanup happens) and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">swap()</span></strong><span class="koboSpan" id="kobo.358.1"> member function: you simply copy the argument into an anonymous object (to make its lifetime minimal), then swap the states of that unnamed temporary with those of </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">*this</span></strong><span class="koboSpan" id="kobo.360.1">, leading to </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">*this</span></strong><span class="koboSpan" id="kobo.362.1"> becoming a copy of </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">other</span></strong><span class="koboSpan" id="kobo.364.1">. </span><span class="koboSpan" id="kobo.364.2">This programming idiom almost always works, which explains </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">its success!</span></span></p>
<p><span class="koboSpan" id="kobo.366.1">Move assignment can be expressed along the same lines as copy assignment, but replacing the copy constructor with a move constructor in the implementation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">assignment operator:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.368.1">
      // ...
</span><span class="koboSpan" id="kobo.368.2">      void swap(Vector &amp;other) noexcept {
         using std::swap;
         swap(elems, other.elems);
         swap(nelems, other.nelems);
         swap(cap, other.cap);
      }
      Vector&amp; operator=(const Vector &amp;other) {
         Vector{ other }.swap(*this);
         return *this;
      }
      Vector&amp; operator=(Vector &amp;&amp;other) {
         Vector{ std::move(other) }.swap(*this);
         return *this;
      }
      // ...</span></pre> <h3><span class="koboSpan" id="kobo.369.1">Basic services of a vector-like class</span></h3>
<p><span class="koboSpan" id="kobo.370.1">We have </span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.371.1">now implemented the special member functions that handle the internal representation of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.373.1"> object, but there is more to writing a convenient dynamic array type. </span><span class="koboSpan" id="kobo.373.2">For example, member functions that let you access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">first()</span></strong><span class="koboSpan" id="kobo.375.1"> element, or the last (</span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">back()</span></strong><span class="koboSpan" id="kobo.377.1">) element, or that let you access the element at a specific index in the array (using square brackets) are all to </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">be expected:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.379.1">
      // ...
</span><span class="koboSpan" id="kobo.379.2">      reference operator[](size_type n) {
         return elems[n];
      }
      const_reference operator[](size_type n) const {
         return elems[n];
      }
      // precondition: !empty()
      reference front() { return (*this)[0]; }
      const_reference front() const { return (*this)[0]; }
      reference back() { return (*this)[size() - 1]; }
      const_reference back() const {
         return (*this)[size() - 1];
      }
      // ...</span></pre> <p><span class="koboSpan" id="kobo.380.1">As can be expected, calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">front()</span></strong><span class="koboSpan" id="kobo.382.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">back()</span></strong><span class="koboSpan" id="kobo.384.1"> on an empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.386.1"> is undefined behavior (you could make these functions throw if you prefer, but then everyone </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.387.1">would pay the price for those few programs that are badly behaved maybe only in so-called </span><strong class="bold"><span class="koboSpan" id="kobo.388.1">debug mode</span></strong><span class="koboSpan" id="kobo.389.1">?). </span><span class="koboSpan" id="kobo.389.2">Again, this set of six member </span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.390.1">functions can be reduced to only three through C++23’s “deduced </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">this</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">” feature:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.393.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.394.1">// alternative approach, (requires C++23)</span></strong><span class="koboSpan" id="kobo.395.1">
      // ...
</span><span class="koboSpan" id="kobo.395.2">      template &lt;class S&gt;
         decltype(auto) operator[](this S &amp;&amp; self,
                                   size_type n) {
            return self.elems[n];
         }
      // precondition: !empty()
      template &lt;class S&gt;
         decltype(auto) front(this S &amp;&amp;self) {
            return self[0];
         }
      template &lt;class S&gt;
         decltype(auto) back(this S &amp;&amp;self) {
            return self[self.size()-1];
         }
      // ...</span></pre> <p><span class="koboSpan" id="kobo.396.1">Some will want to add an </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">at()</span></strong><span class="koboSpan" id="kobo.398.1"> member function in both </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">const</span></strong><span class="koboSpan" id="kobo.400.1"> and non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">const</span></strong><span class="koboSpan" id="kobo.402.1"> form that behaves like </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">operator[]</span></strong><span class="koboSpan" id="kobo.404.1"> but throws an exception if an attempt to access the underlying array is out of bounds. </span><span class="koboSpan" id="kobo.404.2">Feel free to do so if </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">you wish.</span></span></p>
<p><span class="koboSpan" id="kobo.406.1">Comparing two </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.408.1"> objects for equivalence or lack thereof is a relatively easy matter if we use algorithms since we implemented iterators for </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">our type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.410.1">
      // ...
</span><span class="koboSpan" id="kobo.410.2">      bool operator==(const Vector &amp;other) const {
         return size() == other.size() &amp;&amp;
                std::equal(begin(), end(), other.begin());
      }
</span><strong class="bold"><span class="koboSpan" id="kobo.411.1">      // can be omitted since C++20 (synthesized by</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.412.1">      // the compiler through operator==())</span></strong><span class="koboSpan" id="kobo.413.1">
      bool operator!=(const Vector &amp;other) const {
         return !(*this == other);
      }
      // ...</span></pre> <p><span class="koboSpan" id="kobo.414.1">Finally, you might say, we reach the point that interests us the most in a book discussing memory </span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.415.1">management: how to add elements to our container, and how the underlying memory is managed. </span><span class="koboSpan" id="kobo.415.2">Without going through every mechanism client code could use to add elements to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.417.1"> object, we will at least examine the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">push_back()</span></strong><span class="koboSpan" id="kobo.419.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">emplace_back()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.421.1">member functions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.422.1">In this version, there will be two </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">push_back()</span></strong><span class="koboSpan" id="kobo.424.1"> member functions: one that takes </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">const T&amp;</span></strong><span class="koboSpan" id="kobo.426.1"> as argument and one that instead takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">T&amp;&amp;</span></strong><span class="koboSpan" id="kobo.428.1">. </span><span class="koboSpan" id="kobo.428.2">The one that takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">const T&amp;</span></strong><span class="koboSpan" id="kobo.430.1"> argument will copy that argument at the end of the container, and the one that takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">T&amp;&amp;</span></strong><span class="koboSpan" id="kobo.432.1"> will move it at </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">that location.</span></span></li>
<li><span class="koboSpan" id="kobo.434.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">emplace_back()</span></strong><span class="koboSpan" id="kobo.436.1"> member function will take a variadic pack of arguments, then perfectly forward them to the constructor of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">T</span></strong><span class="koboSpan" id="kobo.438.1"> object that will be placed at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">the container.</span></span></li>
<li><span class="koboSpan" id="kobo.440.1">A reference to the newly constructed object is returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">emplace_back()</span></strong><span class="koboSpan" id="kobo.442.1"> for convenience, in case user code would like to use it right away. </span><span class="koboSpan" id="kobo.442.2">This is not done by </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">push_back()</span></strong><span class="koboSpan" id="kobo.444.1">, which is called with a fully constructed object to which user code already </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">has access.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.446.1">In all three functions, we first check whether the container is full, in which case we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">grow()</span></strong><span class="koboSpan" id="kobo.448.1">, a private member </span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.449.1">function. </span><span class="koboSpan" id="kobo.449.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">grow()</span></strong><span class="koboSpan" id="kobo.451.1"> function needs to allocate more memory than </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.452.1">what the container currently holds, something that can, of course, fail. </span><span class="koboSpan" id="kobo.452.2">Note that if </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">grow()</span></strong><span class="koboSpan" id="kobo.454.1"> throws, the addition of a new object never occurred and the container remains intact. </span><span class="koboSpan" id="kobo.454.2">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">grow()</span></strong><span class="koboSpan" id="kobo.456.1"> takes into account the possibility of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">capacity()</span></strong><span class="koboSpan" id="kobo.458.1"> of value </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">0</span></strong><span class="koboSpan" id="kobo.460.1">, in which case an arbitrary default capacity </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">is chosen.</span></span></p>
<p><span class="koboSpan" id="kobo.462.1">Once </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">grow()</span></strong><span class="koboSpan" id="kobo.464.1"> has succeeded, we add the new element after the last object in the container’s storage. </span><span class="koboSpan" id="kobo.464.2">Note that the value is added through assignment, which implies an object to the left side of the assignment operation, meaning that </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">grow()</span></strong><span class="koboSpan" id="kobo.466.1"> not only added storage but initialized it with (most probably) default objects of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">T</span></strong><span class="koboSpan" id="kobo.468.1">. </span><span class="koboSpan" id="kobo.468.2">Thus, we can infer that with this implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.470.1">, type </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">T</span></strong><span class="koboSpan" id="kobo.472.1"> needs to expose a </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">default constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.474.1">
      // ...
</span><span class="koboSpan" id="kobo.474.2">      void push_back(const_reference val) {
         if(full())
            grow();
         elems[size()] = val;
         ++nelems;
      }
      void push_back(T &amp;&amp;val) {
         if(full())
            grow();
         elems[size()] = std::move(val);
         ++nelems;
      }
   template &lt;class ... </span><span class="koboSpan" id="kobo.474.3">Args&gt;
      reference emplace_back(Args &amp;&amp;...args) {
         if (full())
            grow();
         elems[size()] =
            value_type(std::forward&lt;Args&gt;(args)...);
         ++nelems;
         return back();
      }
   private:
      void grow() {
         resize(capacity()? </span><span class="koboSpan" id="kobo.474.4">capacity() * 2 : 16);
      }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.475.1">Note that </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.476.1">the insertion code in </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">push_back()</span></strong><span class="koboSpan" id="kobo.478.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">emplace_back()</span></strong><span class="koboSpan" id="kobo.480.1"> does, in both cases, </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.482.1">
elems[size()] = // the object to insert
++nelems;</span></pre> <p><span class="koboSpan" id="kobo.483.1">You might be tempted to combine the incrementation of the number of elements and the actual insertion expression into one, </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.485.1">
elems[nelems++] = // the object to insert</span></pre> <p><span class="koboSpan" id="kobo.486.1">Do </span><em class="italic"><span class="koboSpan" id="kobo.487.1">not</span></em><span class="koboSpan" id="kobo.488.1"> do that, however. </span><span class="koboSpan" id="kobo.488.2">“Why are you stopping me?” </span><span class="koboSpan" id="kobo.488.3">you might ask. </span><span class="koboSpan" id="kobo.488.4">Well, this would lead to exception-unsafe code! </span><span class="koboSpan" id="kobo.488.5">The reason for this is that the suffix version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">operator++()</span></strong><span class="koboSpan" id="kobo.490.1"> has a high (very high!) priority, </span><em class="italic"><span class="koboSpan" id="kobo.491.1">much</span></em><span class="koboSpan" id="kobo.492.1"> higher than assignment does. </span><span class="koboSpan" id="kobo.492.2">This means that in the combined expression, </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">nelems++</span></strong><span class="koboSpan" id="kobo.494.1"> happens very early on (which might go unnoticed as that expression yields the old value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">nelems</span></strong><span class="koboSpan" id="kobo.496.1">), and assignment follows later, but assignment can throw: we are assigning from an object of some type </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">T</span></strong><span class="koboSpan" id="kobo.498.1"> to another object of that same type, and we do not know whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">T::operator=(const T&amp;)</span></strong><span class="koboSpan" id="kobo.500.1"> will throw. </span><span class="koboSpan" id="kobo.500.2">Of course, if it does throw, the assignment will not have occurred, and no object will have been added at the end of the containers; but the number of elements will have been incremented, leading to an incoherent </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">Vector&lt;T&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.502.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.503.1">There’s a general trick here: do not modify your object until you know you can do so safely. </span><span class="koboSpan" id="kobo.503.2">Try to </span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.504.1">do the potentially throwing operations first, then do the operations that can mutate your object. </span><span class="koboSpan" id="kobo.504.2">You will sleep better, and the risks of object corruption will be </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">alleviated somewhat.</span></span></p>
<p><span class="koboSpan" id="kobo.506.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">grow()</span></strong><span class="koboSpan" id="kobo.508.1"> member function did its work by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">resize()</span></strong><span class="koboSpan" id="kobo.510.1"> and doubling the container’s capacity (unless that capacity was 0, in which case it picked a default capacity). </span><span class="koboSpan" id="kobo.510.2">How does </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">resize()</span></strong><span class="koboSpan" id="kobo.512.1"> work? </span><span class="koboSpan" id="kobo.512.2">With our implementation, it’s a matter of allocating enough memory to cover the needs of the new capacity, copying or moving the objects from the old memory block to the new one, then replacing the old memory block with the new one and updating </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">the capacity.</span></span></p>
<p><span class="koboSpan" id="kobo.514.1">How do we know whether we should move or copy the objects? </span><span class="koboSpan" id="kobo.514.2">Well, since moving could destroy the original objects, we only do so if </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">T::operator=(T&amp;&amp;)</span></strong><span class="koboSpan" id="kobo.516.1"> is explicitly </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">noexcept</span></strong><span class="koboSpan" id="kobo.518.1">. </span><span class="koboSpan" id="kobo.518.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">std::is_nothrow_move_assignable&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.520.1"> trait is our tool of choice to determine whether that is indeed the case (if it is not, then we copy the objects, which is the safe option as it leaves the original </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">objects intact):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.522.1">
  // ...
</span><span class="koboSpan" id="kobo.522.2">  public:
     void resize(size_type new_cap) {
        if (new_cap &lt;= capacity()) return;
        auto p = new T[new_cap];
        if constexpr(std::is_nothrow_move_assignable_v&lt;T&gt;){
           std::move(begin(), end(), p);
        } else try {
           std::copy(begin(), end(), p);
        } catch (...) {
           delete[] p;
           throw;
        }
        delete[] elems;
        elems = p;
        cap = new_cap;
     }
     // ...</span></pre> <p><span class="koboSpan" id="kobo.523.1">There we go. </span><span class="koboSpan" id="kobo.523.2">It’s not exactly trivial code, I agree, but it’s not insurmountable either. </span><span class="koboSpan" id="kobo.523.3">Remember that this is only our first draft, and that it will be much slower than </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">std::vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.525.1"> for a wide array </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">of types.</span></span></p>
<p><span class="koboSpan" id="kobo.527.1">One last aspect of this container we should address is how to </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">insert()</span></strong><span class="koboSpan" id="kobo.529.1"> elements into it and how to </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">erase()</span></strong><span class="koboSpan" id="kobo.531.1"> elements from it. </span><span class="koboSpan" id="kobo.531.2">In industrial-strength containers such as those found </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.532.1">in the standard library, there is a wide array of functions to perform these two tasks, so we will limit ourselves to one of each: inserting a sequence of values at a given location in the container and erasing an element at a given location from </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">the container.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">insert()</span></strong><span class="koboSpan" id="kobo.536.1"> member function will be a template that takes a pair of source iterators named </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">first</span></strong><span class="koboSpan" id="kobo.538.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">last</span></strong><span class="koboSpan" id="kobo.540.1">, as well as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">const_iterator</span></strong><span class="koboSpan" id="kobo.542.1"> named </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">pos</span></strong><span class="koboSpan" id="kobo.544.1"> representing a location within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.546.1"> object. </span><span class="koboSpan" id="kobo.546.2">Making it a </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">template</span></strong><span class="koboSpan" id="kobo.548.1"> means that we will be able to use pairs of iterators from any container as a source of values to insert, a useful </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">property indeed.</span></span></p>
<p><span class="koboSpan" id="kobo.550.1">Within the function, we will use a non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">const</span></strong><span class="koboSpan" id="kobo.552.1"> equivalent of </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">pos</span></strong><span class="koboSpan" id="kobo.554.1"> named </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">pos_</span></strong><span class="koboSpan" id="kobo.556.1">, but only because we are writing a simplified and incomplete container where many member functions that would work on </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">const_iterator</span></strong><span class="koboSpan" id="kobo.558.1"> objects </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">are missing.</span></span></p>
<p><span class="koboSpan" id="kobo.560.1">To perform the insertion, we will compute </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">remaining</span></strong><span class="koboSpan" id="kobo.562.1">, the space we will have available in the container (expressed as a number of objects), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">n</span></strong><span class="koboSpan" id="kobo.564.1">, which will be the number of objects to insert. </span><span class="koboSpan" id="kobo.564.2">If the available space remaining is insufficient, we will allocate more through our </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">resize()</span></strong><span class="koboSpan" id="kobo.566.1"> member function. </span><span class="koboSpan" id="kobo.566.2">Of course, calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">resize()</span></strong><span class="koboSpan" id="kobo.568.1"> will probably lead to </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">pos_</span></strong><span class="koboSpan" id="kobo.570.1"> becoming invalid (it pointed into the old block of memory, which will be replaced by another block once </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">resize()</span></strong><span class="koboSpan" id="kobo.572.1"> has completed its task), so we take care of computing the relative </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">index</span></strong><span class="koboSpan" id="kobo.574.1"> in the container before resizing, and recomputing the equivalent of </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">pos_</span></strong><span class="koboSpan" id="kobo.576.1"> in the new memory block </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">after resizing.</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">An interesting twist in the insertion process is that we will want to copy (or move, but we will keep things simple here) the objects from </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">pos_</span></strong><span class="koboSpan" id="kobo.580.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">end()</span></strong><span class="koboSpan" id="kobo.582.1"> at the location </span><em class="italic"><span class="koboSpan" id="kobo.583.1">ending</span></em><span class="koboSpan" id="kobo.584.1"> at </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">end()+n</span></strong><span class="koboSpan" id="kobo.586.1"> before performing the insertion of </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">n</span></strong><span class="koboSpan" id="kobo.588.1"> objects at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">pos_</span></strong><span class="koboSpan" id="kobo.590.1"> location, but that copy has to be made </span><em class="italic"><span class="koboSpan" id="kobo.591.1">backward</span></em><span class="koboSpan" id="kobo.592.1"> (from the last to the first) if we are to avoid overwriting some of the objects we are trying to copy along the way. </span><span class="koboSpan" id="kobo.592.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">std::copy_backward()</span></strong><span class="koboSpan" id="kobo.594.1"> algorithm is expressed this way: the third argument expressed where the destination of the copy stops, not where </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">it begins.</span></span></p>
<p><span class="koboSpan" id="kobo.596.1">Only then </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.597.1">do we copy the sequence determined by </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">first</span></strong><span class="koboSpan" id="kobo.599.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">last</span></strong><span class="koboSpan" id="kobo.601.1"> at position </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">pos_</span></strong><span class="koboSpan" id="kobo.603.1">, update the number of elements in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.605.1"> object, and return what the standard requires (an iterator to the first element inserted, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">pos</span></strong><span class="koboSpan" id="kobo.607.1"> in the case where </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">first==last</span></strong><span class="koboSpan" id="kobo.609.1">, meaning that they determine an </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">empty sequence):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.611.1">
   template &lt;class It&gt;
   iterator insert(const_iterator pos, It first, It last) {
      iterator pos_ = const_cast&lt;iterator&gt;(pos);
      // deliberate usage of unsigned integrals
      const std::size_t remaining = capacity() - size();
      const std::size_t n = std::distance(first, last);
      if (remaining &lt; n) {
         auto index = std::distance(begin(), pos_);
         resize(capacity() + n - remaining);
         pos_ = std::next(begin(), index);
      }
      std::copy_backward(pos_, end(), end() + n);
      std::copy(first, last, pos_);
      nelems += n;
      return pos_;
   }</span></pre> <p><span class="koboSpan" id="kobo.612.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">erase()</span></strong><span class="koboSpan" id="kobo.614.1"> member function will take a </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">const_iterator</span></strong><span class="koboSpan" id="kobo.616.1"> argument named </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">pos</span></strong><span class="koboSpan" id="kobo.618.1"> representing the location of the element to erase from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.620.1"> object. </span><span class="koboSpan" id="kobo.620.2">We again resort to the trick of using a non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">const</span></strong><span class="koboSpan" id="kobo.622.1"> iterator named </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">pos_</span></strong><span class="koboSpan" id="kobo.624.1"> within the function. </span><span class="koboSpan" id="kobo.624.2">Erasing </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">end()</span></strong><span class="koboSpan" id="kobo.626.1"> is a no-op (as it should); otherwise, we perform a linear copy from </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">next(pos_)</span></strong><span class="koboSpan" id="kobo.628.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">end()</span></strong><span class="koboSpan" id="kobo.630.1"> into the location starting at </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">pos_</span></strong><span class="koboSpan" id="kobo.632.1">, effectively replacing each element from that point on with its </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">immediate successor.</span></span></p>
<p><span class="koboSpan" id="kobo.634.1">Finally, we replace the last element with some default value, something that might not seem necessary but actually is since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">T</span></strong><span class="koboSpan" id="kobo.636.1"> object at the end could have been holding some resource that needed to be freed. </span><span class="koboSpan" id="kobo.636.2">For example, in a program where we use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">Vector&lt;Res&gt;</span></strong><span class="koboSpan" id="kobo.638.1"> object and where </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">Res</span></strong><span class="koboSpan" id="kobo.640.1"> is an RAII type that releases a resource on destruction, not replacing the object “lying around just past the end” might lead to the associated </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.641.1">resource being closed only when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">Vector</span></strong><span class="koboSpan" id="kobo.643.1"> object is destroyed, which might occur later, maybe much later, than client code would expect it </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">to be.</span></span></p>
<p><span class="koboSpan" id="kobo.645.1">We then update the number of elements in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.647.1"> object. </span><span class="koboSpan" id="kobo.647.2">Once again, this implementation means we are requiring that </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">T</span></strong><span class="koboSpan" id="kobo.649.1"> exposes a default constructor, something that is not fundamentally necessary (and a requirement that we will alleviate later in </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">this chapter):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.651.1">
   iterator erase(const_iterator pos) {
      iterator pos_ = const_cast&lt;iterator&gt;(pos);
      if (pos_ == end()) return pos_;
      std::copy(std::next(pos_), end(), pos_);
</span><strong class="bold"><span class="koboSpan" id="kobo.652.1">      *std::prev(end()) = {};</span></strong><span class="koboSpan" id="kobo.653.1">
      --nelems;
      return pos_;
   }</span></pre> <p><span class="koboSpan" id="kobo.654.1">I’m sure you’re wondering how we could do better, but we will get back to this very soon. </span><span class="koboSpan" id="kobo.654.2">We will look at how to implement a simple node-based container (a homemade </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">std::forward_list&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.656.1">-like type) in </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">the meantime.</span></span></p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.658.1">Writing your own forward_list&lt;T&gt; alternative</span></h1>
<p><span class="koboSpan" id="kobo.659.1">Writing a node-based container such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">std::list</span></strong><span class="koboSpan" id="kobo.661.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">std::unordered_map</span></strong><span class="koboSpan" id="kobo.663.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">std:: map</span></strong><span class="koboSpan" id="kobo.665.1">, and so on is an interesting exercise, but in this chapter, the fact that it is interesting </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.666.1">will not necessarily “shine” right away. </span><span class="koboSpan" id="kobo.666.2">The points of interest for such classes will be more evident in </span><a href="B21071_13.xhtml#_idTextAnchor187"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.667.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.668.1"> and </span><a href="B21071_14.xhtml#_idTextAnchor199"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.669.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.670.1">, but we will still write a basic, simplified version here to make the side-by-side evolution of our container types clearer in the pages and chapters </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">to come.</span></span></p>
<p><span class="koboSpan" id="kobo.672.1">A forward list is an exercise in leanness. </span><span class="koboSpan" id="kobo.672.2">We want the type to be small and do what it does well. </span><span class="koboSpan" id="kobo.672.3">Some forward lists occupy the size of a single pointer in memory (a pointer to the first node in the sequence); in our implementation, we will pay the price for an additional integer (the number of elements) in order to get a constant-time complexity guarantee for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">size()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.674.1">member function.</span></span></p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.675.1">Representational choices for a node-based container</span></h2>
<p><span class="koboSpan" id="kobo.676.1">In our implementation, </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.678.1"> will hold nodes, and each node will hold a pair made </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.679.1">of a value (of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">T</span></strong><span class="koboSpan" id="kobo.681.1">) and a pointer to the next node in the sequence. </span><span class="koboSpan" id="kobo.681.2">The last node will have a null pointer as the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">next</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.683.1"> node.</span></span></p>
<p><span class="koboSpan" id="kobo.684.1">The representation of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.686.1"> object will thus be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">Node*</span></strong><span class="koboSpan" id="kobo.688.1"> and an unsigned integral (for the number of elements in the list). </span><span class="koboSpan" id="kobo.688.2">Our implementation will be very simple and will show a small set of member functions. </span><span class="koboSpan" id="kobo.688.3">Feel free to enrich it as you want, as long as you limit yourself to functions that can be </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">written efficiently.</span></span></p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.690.1">The implementation of ForwardList&lt;T&gt;</span></h2>
<p><span class="koboSpan" id="kobo.691.1">As we </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.692.1">did for </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.694.1">, we will walk through our initial (naïve) </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.696.1"> implementation in steps. </span><span class="koboSpan" id="kobo.696.2">Our initial step consists of defining our abstractions through standard library-conforming type aliases and choosing our internal representation, as is usually the case </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">with containers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.698.1">
#include &lt;cstddef&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
#include &lt;iterator&gt;
#include &lt;initializer_list&gt;
#include &lt;concepts&gt;
template &lt;class T&gt;
class ForwardList {
public:
   using value_type = T;
   using size_type = std::size_t;
   using pointer = T*;
   using const_pointer = const T*;
   using reference = T&amp;;
   using const_reference = const T&amp;;
   // ...</span></pre> <p><span class="koboSpan" id="kobo.699.1">As mentioned earlier, a</span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">ForwardList&lt;T&gt;::Node</span></strong><span class="koboSpan" id="kobo.701.1"> object will hold a value and a pointer to </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.702.1">the next node in the sequence. </span><span class="koboSpan" id="kobo.702.2">Initially, the next node will always be a null pointer; it is the list’s responsibility to organize nodes, the nodes themselves being responsible for the ownership of the values </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">stored therein:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.704.1">
   // ...
</span><span class="koboSpan" id="kobo.704.2">private:
   struct Node {
      value_type value;
      Node *next = nullptr;
      Node(const_reference value) : value { value } {
      }
      Node(value_type &amp;&amp;value)
         : value { std::move(value) } {
      }
   };
   Node *head {};
   size_type nelems {};
   // ...</span></pre> <p><span class="koboSpan" id="kobo.705.1">The default state of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.707.1"> object will be equivalent to that of an empty list (a null pointer for </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">head</span></strong><span class="koboSpan" id="kobo.709.1"> and no elements). </span><span class="koboSpan" id="kobo.709.2">That’s a reasonable default for most containers </span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.710.1">as an empty container is usually what users expect in practice when asking for a </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">default constructor.</span></span></p>
<p><span class="koboSpan" id="kobo.712.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">size()</span></strong><span class="koboSpan" id="kobo.714.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">empty()</span></strong><span class="koboSpan" id="kobo.716.1"> member functions are both trivial to write. </span><span class="koboSpan" id="kobo.716.2">I expressed </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">empty()</span></strong><span class="koboSpan" id="kobo.718.1"> in terms of a null head rather than as a zero </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">size()</span></strong><span class="koboSpan" id="kobo.720.1"> since in some (reasonable) forward list implementations, the size would be computed, not stored, which would make </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">size()</span></strong><span class="koboSpan" id="kobo.722.1"> a linear complexity operation instead of a constant-time one. </span><span class="koboSpan" id="kobo.722.2">In practice, exposing a constant-time </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">size()</span></strong><span class="koboSpan" id="kobo.724.1"> member function is a good idea as it matches most </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">users’ expectations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.726.1">
   // ...
</span><span class="koboSpan" id="kobo.726.2">public:
   size_type size() const { return nelems; }
   bool empty() const { return !head; }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.727.1">Iterators on a linked list cannot be raw pointers, as the elements it stores are not contiguous in memory. </span><span class="koboSpan" id="kobo.727.2">We need a class whose instances can iterate over elements of the list, and that can take into account the </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">const</span></strong><span class="koboSpan" id="kobo.729.1">-ness of the elements (or </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">lack thereof).</span></span></p>
<p><span class="koboSpan" id="kobo.731.1">Our (private) </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">ForwardList&lt;T&gt;::Iterator</span></strong><span class="koboSpan" id="kobo.733.1"> class will be a template on some type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">U</span></strong><span class="koboSpan" id="kobo.735.1">, where (in practice) </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">U</span></strong><span class="koboSpan" id="kobo.737.1"> will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">T</span></strong><span class="koboSpan" id="kobo.739.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">ForwardList&lt;T&gt;::iterator</span></strong><span class="koboSpan" id="kobo.741.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">const T</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.743.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">ForwardList&lt;T&gt;::const_iterator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.746.1">Standard iterators in C++ are expected to provide </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">five aliases:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">value_type</span></strong><span class="koboSpan" id="kobo.749.1">: The type of the </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">pointed-to value.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">reference</span></strong><span class="koboSpan" id="kobo.752.1">: The type that represents a reference to a </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">pointed-to value.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">pointer</span></strong><span class="koboSpan" id="kobo.755.1">: The type that represents a pointer to a </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">pointed-to value.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">difference_type</span></strong><span class="koboSpan" id="kobo.758.1">: The type that represents the distance between two iterators of this type (a </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">signed integral).</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">iterator_category</span></strong><span class="koboSpan" id="kobo.761.1">: There are six categories as of C++20, and they guide the code generation by describing what an iterator can do. </span><span class="koboSpan" id="kobo.761.2">In our case, since we will provide </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">++</span></strong><span class="koboSpan" id="kobo.763.1"> but not </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">--</span></strong><span class="koboSpan" id="kobo.765.1">, we will describe our iterators as being part </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">forward_iterator_category</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.769.1">An iterator </span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.770.1">is an object that describes how we can traverse a sequence of values, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">ForwardList&lt;T&gt;::Iterator</span></strong><span class="koboSpan" id="kobo.772.1"> is no exception. </span><span class="koboSpan" id="kobo.772.2">The key operations exposed by an iterator are probably </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">operator++()</span></strong><span class="koboSpan" id="kobo.774.1"> (advance one position in the sequence), </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">operator!=()</span></strong><span class="koboSpan" id="kobo.776.1"> (compare two iterators to know whether we have attained the end of a sequence), as well as </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">operator*()</span></strong><span class="koboSpan" id="kobo.778.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">operator-&gt;()</span></strong><span class="koboSpan" id="kobo.780.1"> (accessing the pointed-to element or its services). </span><span class="koboSpan" id="kobo.780.2">Note that we make </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.782.1"> our friend as that class will be responsible for the organization of nodes, which is easier done when you have full access privileges to private data members such </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">cur</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.786.1">
   // ...
</span><span class="koboSpan" id="kobo.786.2">private:
   template &lt;class U&gt; class Iterator {
   public:
      using value_type =
         typename ForwardList&lt;T&gt;::value_type;
      using pointer = typename ForwardList&lt;T&gt;::pointer;
      using reference = typename ForwardList&lt;T&gt;::reference;
      using difference_type = std::ptrdiff_t;
      using iterator_category =
         std::forward_iterator_tag;
      friend class ForwardList&lt;T&gt;;
   private:
      Node *cur {};
   public:
      Iterator() = default;
      Iterator(Node *p) : cur { p } {
      }
      Iterator&amp; operator++() {
         cur = cur-&gt;next;
         return *this;
      }
      Iterator operator++(int) {
         auto temp = *this;
         operator++();
         return temp;
      }
      bool operator==(const Iterator &amp;other) const {
         return cur == other.cur;
      }
      // not needed since C++20
      bool operator!=(const Iterator &amp;other) const {
         return !(*this == other);
      }
      U&amp; operator*() { return cur-&gt;value; }
      const U&amp; operator*() const { return cur-&gt;value; }
      U* operator-&gt;() { return cur-&gt;value; }
      const U* operator-&gt;() const { return cur-&gt;value; }
   };
public:
   using iterator = Iterator&lt;T&gt;;
   using const_iterator = Iterator&lt;const T&gt;;
   // ...</span></pre> <p><span class="koboSpan" id="kobo.787.1">The preceding </span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.788.1">proposed implementation uses a template based on the type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">U</span></strong><span class="koboSpan" id="kobo.790.1">, of the elements that an </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">Iterator&lt;U&gt;</span></strong><span class="koboSpan" id="kobo.792.1"> can traverse. </span><span class="koboSpan" id="kobo.792.2">We used </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">U</span></strong><span class="koboSpan" id="kobo.794.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">T</span></strong><span class="koboSpan" id="kobo.796.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">T</span></strong><span class="koboSpan" id="kobo.798.1"> is the type of the values in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.800.1"> object. </span><span class="koboSpan" id="kobo.800.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.802.1">, we then make aliases for types </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">Iterator&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.804.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">Iterator&lt;const T&gt;</span></strong><span class="koboSpan" id="kobo.806.1"> through </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">iterator</span></strong><span class="koboSpan" id="kobo.808.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">const_iterator</span></strong><span class="koboSpan" id="kobo.810.1">, respectively. </span><span class="koboSpan" id="kobo.810.2">We could also have written two distinct types had we preferred that approach, but a template seemed </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">less verbose.</span></span></p>
<p><span class="koboSpan" id="kobo.812.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">begin()</span></strong><span class="koboSpan" id="kobo.814.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">end()</span></strong><span class="koboSpan" id="kobo.816.1"> set of member functions are essentially trivial; </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">begin()</span></strong><span class="koboSpan" id="kobo.818.1"> yields an iterator to the head of the list, and the conceptual just-after-the-end node returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">end()</span></strong><span class="koboSpan" id="kobo.820.1"> is a null pointer, which is what the default constructor of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">Iterator&lt;U&gt;</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.822.1">gives us:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.823.1">
   // ...
</span><span class="koboSpan" id="kobo.823.2">   iterator begin() { return { head }; }
   const_iterator begin() const { return { head }; }
   const_iterator cbegin() const { return begin(); }
   iterator end() { return {}; }
   const_iterator end() const { return {}; }
   const_iterator cend() const { return end(); }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.824.1">We will sometimes need to </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">clear()</span></strong><span class="koboSpan" id="kobo.826.1"> a </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.828.1"> object, which will lead us to destroy </span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.829.1">that container’s content. </span><span class="koboSpan" id="kobo.829.2">In this implementation, for simplicity, I made the destructor call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">clear()</span></strong><span class="koboSpan" id="kobo.831.1"> member function, but we could have spared a tiny bit of processing time (the reinitialization of </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">nelems</span></strong><span class="koboSpan" id="kobo.833.1">, not needed in the destructor) by writing the </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">destructor separately:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.835.1">
   // ...
</span><span class="koboSpan" id="kobo.835.2">   void clear() noexcept {
      for(auto p = head; p; ) {
         auto q = p-&gt;next;
         delete p;
         p = q;
      }
      nelems = 0;
   }
   ~ForwardList() {
      clear();
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.836.1">One thing that might seem tempting would be to write a </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">Node</span></strong><span class="koboSpan" id="kobo.838.1"> destructor that applies </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">delete</span></strong><span class="koboSpan" id="kobo.840.1"> to its </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">next</span></strong><span class="koboSpan" id="kobo.842.1"> data member; if we did so, </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">clear()</span></strong><span class="koboSpan" id="kobo.844.1"> would simply be </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">delete head;</span></strong><span class="koboSpan" id="kobo.846.1"> (which would call </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">delete head-&gt;next</span></strong><span class="koboSpan" id="kobo.848.1"> and continue from that point on, recursively) followed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">nelems=0;</span></strong><span class="koboSpan" id="kobo.850.1">. </span><span class="koboSpan" id="kobo.850.2">However, I would not do that if I were you: on principle, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.852.1"> object should organize the nodes in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.854.1">, and this responsibility should not be given to the numerous </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">Node</span></strong><span class="koboSpan" id="kobo.856.1"> objects themselves. </span><span class="koboSpan" id="kobo.856.2">Then, there is a small technical problem: calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">delete head;</span></strong><span class="koboSpan" id="kobo.858.1"> would call </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">delete head-&gt;next;</span></strong><span class="koboSpan" id="kobo.860.1">, which would then technically call </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">delete</span></strong><span class="koboSpan" id="kobo.862.1"> on </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">head-&gt; next-&gt; next;</span></strong><span class="koboSpan" id="kobo.864.1"> and so on. </span><span class="koboSpan" id="kobo.864.2">This leads to a very concrete risk of stack overflow if the list is long enough, something that a loop would </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">avoid altogether.</span></span></p>
<p><span class="koboSpan" id="kobo.866.1">There is a simple lesson here: life is easier when each class has a single responsibility. </span><span class="koboSpan" id="kobo.866.2">This is something that’s been known for a while as the “single responsibility principle”. </span><span class="koboSpan" id="kobo.866.3">That principle is the ‘S’ in the well-known SOLID principles of object-oriented programming. </span><span class="koboSpan" id="kobo.866.4">Let the container deal with the organization of nodes in a node-based container and let the nodes </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">store values.</span></span></p>
<p><span class="koboSpan" id="kobo.868.1">As far as </span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.869.1">constructors go, we will implement a small set for </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">this class:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.871.1">A default constructor that models an </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">empty list</span></span></li>
<li><span class="koboSpan" id="kobo.873.1">A constructor that accepts a </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">std::initializer_list&lt;T&gt;</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.875.1">as argument</span></span></li>
<li><span class="koboSpan" id="kobo.876.1">A copy constructor that duplicates each node from the source list </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">in order</span></span></li>
<li><span class="koboSpan" id="kobo.878.1">A </span><span class="No-Break"><span class="koboSpan" id="kobo.879.1">move constructor</span></span></li>
<li><span class="koboSpan" id="kobo.880.1">A sequence constructor that accepts two objects of some type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">It</span></strong><span class="koboSpan" id="kobo.882.1">, that satisfies the </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">std::input_iterator</span></strong><span class="koboSpan" id="kobo.884.1"> concept (essentially: that lets you make at least a single pass through the sequence and consume the elements, which is all we need to do </span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">the job)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.886.1">It happens that this last constructor can be seen as a generalization of some of the others, and that only the default constructor and the move constructor really benefit from being written separately (we could technically compute the size of the sequence more efficiently if we did not delegate the work to a general constructor, so if this makes a difference in your code base, feel free to </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">do so):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.888.1">
   // ...
</span><span class="koboSpan" id="kobo.888.2">   ForwardList() = default;
   template &lt;std::input_iterator It&gt;
      ForwardList(It b, It e) {
         if(b == e) return;
         try {
            head = new Node{ *b };
            auto q = head;
            ++nelems;
            for(++b; b != e; ++b) {
               q-&gt;next = new Node{ *b };
               q = q-&gt;next;
               ++nelems;
            }
         } catch (...) {
            clear();
            throw;
         }
      }
   ForwardList(const ForwardList&amp; other)
      : ForwardList(other.begin(), other.end()) {
   }
   ForwardList(std::initializer_list&lt;T&gt; other)
      : ForwardList(other.begin(), other.end()) {
   }
   ForwardList(ForwardList&amp;&amp; other) noexcept
      : head{ std::exchange(other.head, nullptr) },
        nelems{ std::exchange(other.nelems, 0) } {
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.889.1">Unsurprisingly, assignment </span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.890.1">can be expressed through the safe assignment idiom that we applied in the case of type </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">Vector&lt;T&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.892.1"> earlier:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.893.1">
   // ...
</span><span class="koboSpan" id="kobo.893.2">   void swap(ForwardList&amp; other) noexcept {
      using std::swap;
      swap(head, other.head);
      swap(nelems, other.nelems);
   }
   ForwardList&amp; operator=(const ForwardList&amp; other) {
      ForwardList{ other }.swap(*this);
      return *this;
   }
   ForwardList&amp; operator=(ForwardList&amp;&amp; other) {
      ForwardList{ std::move(other) }.swap(*this);
      return *this;
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.894.1">Some of the remaining operations can reasonably be said to be trivial, for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">front()</span></strong><span class="koboSpan" id="kobo.896.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">operator==()</span></strong><span class="koboSpan" id="kobo.898.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">push_front()</span></strong><span class="koboSpan" id="kobo.900.1">. </span><span class="koboSpan" id="kobo.900.2">As you could reasonably assume for a forward list, we will implement neither a </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">back()</span></strong><span class="koboSpan" id="kobo.902.1"> nor a </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">push_back()</span></strong><span class="koboSpan" id="kobo.904.1"> member function as </span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.905.1">there would not be an efficient way to do so with our representational choices (the only reasonable algorithm would require looping through the whole construct in order to find the last node, leading to a linear </span><span class="No-Break"><span class="koboSpan" id="kobo.906.1">complexity algorithm):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.907.1">
   // ...
</span><span class="koboSpan" id="kobo.907.2">   // precondition: !empty()
   reference front() { return head-&gt;value; }
   const_reference front() const { return head-&gt;value; }
   bool operator==(const ForwardList &amp;other) const {
      return size() == other.size() &amp;&amp;
             std::equal(begin(), end(), other.begin());
   }
   // can be omitted since C++20
   bool operator!=(const ForwardList &amp;other) const {
      return !(*this == other);
   }
   void push_front(const_reference val) {
      auto p = new Node{ val };
      p-&gt;next = head;
      head = p;
      ++nelems;
   }
   void push_front(T&amp;&amp; val) {
      auto p = new Node{ std::move(val) };
      p-&gt;next = head;
      head = p;
      ++nelems;
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.908.1">As an </span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.909.1">example of value insertion into a container, consider the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">insert_after()</span></strong><span class="koboSpan" id="kobo.911.1"> member function, which inserts a node with a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">value</span></strong><span class="koboSpan" id="kobo.913.1"> after the node pointed to by </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">pos</span></strong><span class="koboSpan" id="kobo.915.1">. </span><span class="koboSpan" id="kobo.915.2">With this function, we could easily build more complex ones, such as one that inserts a sequence of values after some position in the list (</span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">try it!):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.917.1">
   // ...
</span><span class="koboSpan" id="kobo.917.2">   iterator insert_after
      (iterator pos, const_reference value) {
      auto p = new Node{ value };
      p-&gt;next = pos.cur-&gt;next;
      pos.cur-&gt;next = p;
      ++nelems;
      return { p };
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.918.1">Offering the possibility of adding elements to a container is a useful feature indeed, and so is offering </span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.919.1">the option of removing an element from a container. </span><span class="koboSpan" id="kobo.919.2">As an example, see the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">erase_after()</span></strong><span class="koboSpan" id="kobo.921.1"> member </span><span class="No-Break"><span class="koboSpan" id="kobo.922.1">function implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.923.1">
   // ...
</span><span class="koboSpan" id="kobo.923.2">   iterator erase_after(iterator pos) {
      if (pos == end() || std::next(pos) == end())
         return end();
      auto p = pos.cur-&gt;next-&gt;next;
      delete pos.cur-&gt;next;
      pos.cur-&gt;next = p;
      return { p-&gt;next };
   }
};</span></pre> <p><span class="koboSpan" id="kobo.924.1">That should do the job for this class. </span><span class="koboSpan" id="kobo.924.2">For the rest of this chapter, there will be little room for improvement for </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">ForwardList&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.926.1">, but we will return to this class in </span><a href="B21071_13.xhtml#_idTextAnchor187"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.927.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.928.1">, and more so in </span><a href="B21071_14.xhtml#_idTextAnchor199"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.929.1">Chapter 14</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.930.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.931.1">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.933.1">, however, we can do significantly better than we have so far… at the cost of some added complexity. </span><span class="koboSpan" id="kobo.933.2">But we are ready for this, are </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">we not?</span></span></p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.935.1">Better memory management</span></h1>
<p><span class="koboSpan" id="kobo.936.1">So, this humble writer claims our nice but simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.938.1"> type is no match for </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">std::vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.940.1">. </span><span class="koboSpan" id="kobo.940.2">That may seem like a bold claim: after all, we seemed to do what was needed and, no less, we used algorithms instead of raw loops; we caught exceptions as </span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.941.1">we wanted to be exception-safe but limited ourselves to cleaning up the resources… What are we </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">doing wrong?</span></span></p>
<p><span class="koboSpan" id="kobo.943.1">If you run comparative benchmarks between a </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">Vector&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.945.1"> object and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">std::vector&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.947.1"> object, in fact, you will probably not notice much of a difference in the respective numbers of both tests. </span><span class="koboSpan" id="kobo.947.2">For example, try adding a million </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">int</span></strong><span class="koboSpan" id="kobo.949.1"> objects (through </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">push_back()</span></strong><span class="koboSpan" id="kobo.951.1">) to each of these containers and you will think our container holds its own quite well. </span><span class="koboSpan" id="kobo.951.2">Cool! </span><span class="koboSpan" id="kobo.951.3">Now, change that to a comparative test between </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">Vector&lt;std::string&gt;</span></strong><span class="koboSpan" id="kobo.953.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">std::vector&lt;std::string&gt;</span></strong><span class="koboSpan" id="kobo.955.1"> and you might be saddened a bit, seeing that we’re “left behind in the dust,” as </span><span class="No-Break"><span class="koboSpan" id="kobo.956.1">they say.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.957.1">A word about the small object optimization</span></p>
<p class="callout"><span class="koboSpan" id="kobo.958.1">This will show more if you add strings that are not too short (try at least 25 characters, say) as with “short” strings (for some indeterminate value of “short”) most standard libraries </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.959.1">will perform what is called the </span><strong class="bold"><span class="koboSpan" id="kobo.960.1">Small String Optimization</span></strong><span class="koboSpan" id="kobo.961.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.962.1">SSO</span></strong><span class="koboSpan" id="kobo.963.1">), a special case of the </span><strong class="bold"><span class="koboSpan" id="kobo.964.1">Small Object Optimization</span></strong><span class="koboSpan" id="kobo.965.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.966.1">SOO</span></strong><span class="koboSpan" id="kobo.967.1">). </span><span class="koboSpan" id="kobo.967.2">Through </span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.968.1">this optimization, when the data to store in an object is small enough, the implementation will use the storage for the so-called “control block” (the data members, really) of the object as raw storage, avoiding dynamic memory allocation altogether. </span><span class="koboSpan" id="kobo.968.2">Because of this, “small” strings do not allocate and are very, very fast </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">in practice.</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.970.1">But why?</span></span></p>
<p><span class="koboSpan" id="kobo.971.1">There is a clue in the type of element in both tests: </span><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">int</span></strong><span class="koboSpan" id="kobo.973.1"> is a trivially constructible type, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.974.1">std::string</span></strong><span class="koboSpan" id="kobo.975.1"> is not. </span><span class="koboSpan" id="kobo.975.2">This clue is an indication that </span><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">std::vector</span></strong><span class="koboSpan" id="kobo.977.1"> might be calling fewer constructors than we are, essentially being more efficient than </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.979.1"> in the way it handles memory and the </span><span class="No-Break"><span class="koboSpan" id="kobo.980.1">objects therein.</span></span></p>
<p><span class="koboSpan" id="kobo.981.1">What’s the problem? </span><span class="koboSpan" id="kobo.981.2">Well, let’s look at one of the constructors of </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.983.1"> to get an appreciation of the problem with our implementation. </span><span class="koboSpan" id="kobo.983.2">Any constructor but the default constructor (defaulted in our implementation) and the move constructor would do, so let’s take </span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.984.1">the one that accepts a number of elements and an initial value as arguments. </span><span class="koboSpan" id="kobo.984.2">Pay special attention to the </span><span class="No-Break"><span class="koboSpan" id="kobo.985.1">highlighted code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.986.1">
   // ...
</span><span class="koboSpan" id="kobo.986.2">   Vector(size_type n, const_reference init)
      : </span><strong class="bold"><span class="koboSpan" id="kobo.987.1">elems{ new value_type[n] }</span></strong><span class="koboSpan" id="kobo.988.1">, nelems{ n }, cap{ n } {
      try {
         </span><strong class="bold"><span class="koboSpan" id="kobo.989.1">std::fill(begin(), end(), init);</span></strong><span class="koboSpan" id="kobo.990.1">
      } catch(...) {
         delete [] elems;
         throw;
      }
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.991.1">The construction of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">elems</span></strong><span class="koboSpan" id="kobo.993.1"> data member allocates a block of memory big enough to hold </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">n</span></strong><span class="koboSpan" id="kobo.995.1"> objects of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">T</span></strong><span class="koboSpan" id="kobo.997.1"> and calls the default constructor for each of these </span><strong class="source-inline"><span class="koboSpan" id="kobo.998.1">n</span></strong><span class="koboSpan" id="kobo.999.1"> elements. </span><span class="koboSpan" id="kobo.999.2">Obviously, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">T</span></strong><span class="koboSpan" id="kobo.1001.1"> is trivially constructible, then these default constructors are not a big source of worries, but you could question the virtue of so doing if </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">T</span></strong><span class="koboSpan" id="kobo.1003.1"> is not </span><span class="No-Break"><span class="koboSpan" id="kobo.1004.1">trivially constructible.</span></span></p>
<p><span class="koboSpan" id="kobo.1005.1">Still, you might want to argue that the objects need to be constructed, but then look ahead and you will notice that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">std::fill()</span></strong><span class="koboSpan" id="kobo.1007.1"> replaces each of these default </span><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">T</span></strong><span class="koboSpan" id="kobo.1009.1"> objects with a copy of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1010.1">init</span></strong><span class="koboSpan" id="kobo.1011.1">, showing that the initial default construction of the objects was essentially a waste of time (we never used these objects!). </span><span class="koboSpan" id="kobo.1011.2">This is the sort of thing that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">std::vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1013.1"> does so much better than we do: it avoids wasteful operations, restricting itself to what </span><span class="No-Break"><span class="koboSpan" id="kobo.1014.1">is necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.1015.1">We will now try to see how we could get closer in performance to what </span><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">std::vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1017.1"> achieves </span><span class="No-Break"><span class="koboSpan" id="kobo.1018.1">in practice.</span></span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.1019.1">A more efficient Vector&lt;T&gt;</span></h2>
<p><span class="koboSpan" id="kobo.1020.1">The key to a more efficient </span><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1022.1"> is distinguishing allocation from construction, something we have discussed many times in this book, and, well, lying to the type system in </span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.1023.1">adequate ways and in a controlled environment. </span><span class="koboSpan" id="kobo.1023.2">Yes, those “evil” early chapters of this book will come in </span><span class="No-Break"><span class="koboSpan" id="kobo.1024.1">handy now.</span></span></p>
<p><span class="koboSpan" id="kobo.1025.1">We will not rewrite the entirety of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1027.1"> in these pages, but we will look at selected member functions to highlight what needs to be done (a full implementation is available in the GitHub repository mentioned at the beginning of </span><span class="No-Break"><span class="koboSpan" id="kobo.1028.1">this chapter).</span></span></p>
<p><span class="koboSpan" id="kobo.1029.1">We could try to do this effort manually, using the language facilities we already know about, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">std::malloc()</span></strong><span class="koboSpan" id="kobo.1031.1">, to allocate a raw memory block and placement </span><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">new</span></strong><span class="koboSpan" id="kobo.1033.1"> to construct the objects in that block. </span><span class="koboSpan" id="kobo.1033.2">Taking the same constructor that takes a number of elements and an initial value as arguments, we would then get </span><span class="No-Break"><span class="koboSpan" id="kobo.1034.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1035.1">
   // ...
</span><span class="koboSpan" id="kobo.1035.2">   Vector(size_type n, const_reference init)
      </span><strong class="bold"><span class="koboSpan" id="kobo.1036.1">// A</span></strong><span class="koboSpan" id="kobo.1037.1">
      : </span><strong class="bold"><span class="koboSpan" id="kobo.1038.1">elems{ static_cast&lt;pointer&gt;(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1039.1">           std::malloc(n * sizeof(value_type)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1040.1">        ) }</span></strong><span class="koboSpan" id="kobo.1041.1">, nelems{ n }, cap{ n } {
      </span><strong class="bold"><span class="koboSpan" id="kobo.1042.1">// B</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1043.1">      auto p = begin(); // note: we know p is a T*</span></strong><span class="koboSpan" id="kobo.1044.1">
      try {
      </span><strong class="bold"><span class="koboSpan" id="kobo.1045.1">// C</span></strong><span class="koboSpan" id="kobo.1046.1">
         </span><strong class="bold"><span class="koboSpan" id="kobo.1047.1">for(; p != end(); ++p)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1048.1">            new(static_cast&lt;void*&gt;(p)) value_type{ init };</span></strong><span class="koboSpan" id="kobo.1049.1">
      } catch(...) {
      </span><strong class="bold"><span class="koboSpan" id="kobo.1050.1">// D</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1051.1">         for(auto q = begin(); q != p; ++q)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1052.1">            q-&gt;~value_type();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1053.1">         std::free(elems);</span></strong><span class="koboSpan" id="kobo.1054.1">
         throw;
      }
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.1055.1">Now </span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.1056.1">that’s… unpleasant. </span><span class="koboSpan" id="kobo.1056.2">Pay attention to the sections marked with are </span><strong class="bold"><span class="koboSpan" id="kobo.1057.1">A</span></strong><span class="koboSpan" id="kobo.1058.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.1059.1">D</span></strong><span class="koboSpan" id="kobo.1060.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.1061.1">this function:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1062.1">In </span><strong class="bold"><span class="koboSpan" id="kobo.1063.1">A</span></strong><span class="koboSpan" id="kobo.1064.1">, we face our first lie as we allocate storage that can hold </span><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">n</span></strong><span class="koboSpan" id="kobo.1066.1"> objects of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1067.1">T</span></strong><span class="koboSpan" id="kobo.1068.1"> but limit ourselves to raw memory allocation (the constructor of no </span><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">T</span></strong><span class="koboSpan" id="kobo.1070.1"> object is being called at this point), yet we keep a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1071.1">T*</span></strong><span class="koboSpan" id="kobo.1072.1"> to that block of memory for our own purposes. </span><span class="koboSpan" id="kobo.1072.2">Our implementation needs to be aware, internally, that the type of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1073.1">elems</span></strong><span class="koboSpan" id="kobo.1074.1"> pointer is incorrect at </span><span class="No-Break"><span class="koboSpan" id="kobo.1075.1">this stage.</span></span></li>
<li><span class="koboSpan" id="kobo.1076.1">In </span><strong class="bold"><span class="koboSpan" id="kobo.1077.1">B</span></strong><span class="koboSpan" id="kobo.1078.1">, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.1079.1">begin()</span></strong><span class="koboSpan" id="kobo.1080.1"> knowing that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1081.1">iterator</span></strong><span class="koboSpan" id="kobo.1082.1"> is the same thing as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1083.1">T*</span></strong><span class="koboSpan" id="kobo.1084.1"> in our implementation. </span><span class="koboSpan" id="kobo.1084.2">If our implementation used a class instead of a raw pointer to model an iterator, we would have to do some work here to get the underlying pointer to the raw storage in order to implement the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.1085.1">the function.</span></span></li>
<li><span class="koboSpan" id="kobo.1086.1">In </span><strong class="bold"><span class="koboSpan" id="kobo.1087.1">C</span></strong><span class="koboSpan" id="kobo.1088.1">, we construct the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">T</span></strong><span class="koboSpan" id="kobo.1090.1"> objects in place within the block of memory we allocated. </span><span class="koboSpan" id="kobo.1090.2">Since there are no objects there to replace, we construct these objects with the placement </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">new</span></strong><span class="koboSpan" id="kobo.1092.1">, and use the fact that we lied to the type system (in the sense that we used a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1093.1">T*</span></strong><span class="koboSpan" id="kobo.1094.1"> even though we allocated raw memory) to do the pointer arithmetic required to move from one object </span><span class="No-Break"><span class="koboSpan" id="kobo.1095.1">to another.</span></span></li>
<li><span class="koboSpan" id="kobo.1096.1">In </span><strong class="bold"><span class="koboSpan" id="kobo.1097.1">D</span></strong><span class="koboSpan" id="kobo.1098.1">, we handle potential exceptions thrown by the constructors of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">T</span></strong><span class="koboSpan" id="kobo.1100.1"> objects. </span><span class="koboSpan" id="kobo.1100.2">Since we are the only ones who know that there are </span><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">T</span></strong><span class="koboSpan" id="kobo.1102.1"> objects therein, just as we are the only ones who know exactly where the first object that we failed to construct is, we need to destroy the objects manually, then free the (now raw) memory block and re-throw the exception. </span><span class="koboSpan" id="kobo.1102.2">As a bonus, this implementation is not even standards-compliant; we should destroy the objects in reverse order of construction, something this example does </span><span class="No-Break"><span class="koboSpan" id="kobo.1103.1">not do.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1104.1">By the way, this example shows a clear example of the reasons why you cannot throw from a destructor: if an exception is thrown during </span><strong class="bold"><span class="koboSpan" id="kobo.1105.1">D</span></strong><span class="koboSpan" id="kobo.1106.1">, we cannot reasonably hope to recover (at least not without incurring </span><span class="No-Break"><span class="koboSpan" id="kobo.1107.1">prohibitive costs).</span></span></p>
<p><span class="koboSpan" id="kobo.1108.1">You, dear reader, are probably thinking right now that this is unreasonably complicated and way too error-prone for non-specialists to hope to be able to write a whole container </span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.1109.1">that way. </span><span class="koboSpan" id="kobo.1109.2">Indeed, this sort of complexity would creep into a significant number of member functions, making quality control much more difficult than you </span><span class="No-Break"><span class="koboSpan" id="kobo.1110.1">would hope.</span></span></p>
<p><span class="koboSpan" id="kobo.1111.1">But wait, there is hope! </span><span class="koboSpan" id="kobo.1111.2">As you might imagine, your library vendors face the same challenges we do (and more!), so the standard library provides low-level facilities that make handling raw memory in homemade containers a reasonably achievable task as long as you know, well, what you have read in this book </span><span class="No-Break"><span class="koboSpan" id="kobo.1112.1">so far.</span></span></p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.1113.1">Using low-level standard facilities</span></h2>
<p><span class="koboSpan" id="kobo.1114.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">&lt;memory&gt;</span></strong><span class="koboSpan" id="kobo.1116.1"> standard library header is a treasure trove of useful facilities for those who dabble in memory management. </span><span class="koboSpan" id="kobo.1116.2">We have already discussed the standard smart pointers </span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.1117.1">defined in that header (see </span><a href="B21071_05.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1118.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.1119.1"> for a reminder), but if you look a bit deeper, you will see some algorithms made to operate on </span><span class="No-Break"><span class="koboSpan" id="kobo.1120.1">raw memory.</span></span></p>
<p><span class="koboSpan" id="kobo.1121.1">Keeping as </span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.1122.1">an example the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1123.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1124.1"> constructor that takes a number of elements and an initial value as argument, we went from something rather simple that allocates an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1125.1">T</span></strong><span class="koboSpan" id="kobo.1126.1"> objects and replaces them through a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">std::fill()</span></strong><span class="koboSpan" id="kobo.1128.1"> to something significantly more complicated. </span><span class="koboSpan" id="kobo.1128.2">The original version was both simple and inefficient (we constructed unneeded objects just to replace them); the replacement was much more efficient (doing minimal work) but required much more skill to write </span><span class="No-Break"><span class="koboSpan" id="kobo.1129.1">and maintain.</span></span></p>
<p><span class="koboSpan" id="kobo.1130.1">We will now examine the impact of these facilities on the implementation of our allocating member functions. </span><span class="koboSpan" id="kobo.1130.2">The first such functions we will pay attention to are the constructors, as they make a nice </span><span class="No-Break"><span class="koboSpan" id="kobo.1131.1">starting point.</span></span></p>
<h3><span class="koboSpan" id="kobo.1132.1">Impact on constructors</span></h3>
<p><span class="koboSpan" id="kobo.1133.1">In practice, when you </span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.1134.1">want to write a homemade container that manages memory explicitly, it’s better to use the low-level facilities found in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1135.1">&lt;memory&gt;</span></strong><span class="koboSpan" id="kobo.1136.1">. </span><span class="koboSpan" id="kobo.1136.2">Take the </span><span class="No-Break"><span class="koboSpan" id="kobo.1137.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1138.1">
   // ...
</span><span class="koboSpan" id="kobo.1138.2">   Vector(size_type n, const_reference init)
      : </span><strong class="bold"><span class="koboSpan" id="kobo.1139.1">elems{ static_cast&lt;pointer&gt;(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1140.1">           std:malloc(n * sizeof(value_type))</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1141.1">        ) }</span></strong><span class="koboSpan" id="kobo.1142.1">, nelems{ n }, cap{ n } {
      try {
         </span><strong class="bold"><span class="koboSpan" id="kobo.1143.1">std::uninitialized_fill(begin(), end(), init);</span></strong><span class="koboSpan" id="kobo.1144.1">
      } catch(...) {
         </span><strong class="bold"><span class="koboSpan" id="kobo.1145.1">std::free(elems);</span></strong><span class="koboSpan" id="kobo.1146.1">
         throw;
      }
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.1147.1">This is </span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.1148.1">much nicer than the version we entirely wrote ourselves, is it not? </span><span class="koboSpan" id="kobo.1148.2">The two highlights of this version are </span><span class="No-Break"><span class="koboSpan" id="kobo.1149.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1150.1">We allocate a properly sized block of raw memory instead of an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1151.1">T</span></strong><span class="koboSpan" id="kobo.1152.1"> objects, thus avoiding all of the unneeded default constructors the initial </span><span class="No-Break"><span class="koboSpan" id="kobo.1153.1">version had.</span></span></li>
<li><span class="koboSpan" id="kobo.1154.1">We replaced the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">std::fill()</span></strong><span class="koboSpan" id="kobo.1156.1"> (found in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">&lt;algorithm&gt;</span></strong><span class="koboSpan" id="kobo.1158.1">), which uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1159.1">T::operator=(const T&amp;)</span></strong><span class="koboSpan" id="kobo.1160.1"> and thus supposes an existing object to the left side of the assignment with a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1161.1">std::uninitialized_fill()</span></strong><span class="koboSpan" id="kobo.1162.1">, which instead supposes that it is iterating through raw memory and initializes the objects through the </span><span class="No-Break"><span class="koboSpan" id="kobo.1163.1">placement </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1164.1">new</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1165.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1166.1">The beauty of this algorithm (and others of this family) is that it is exception-safe. </span><span class="koboSpan" id="kobo.1166.2">If one of the constructors invoked by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1167.1">std::uninitialized_fill()</span></strong><span class="koboSpan" id="kobo.1168.1"> ends up throwing, then the objects it had managed to create before the exception occurred will be destroyed (in reverse order of construction, as they should) before the exception leaves </span><span class="No-Break"><span class="koboSpan" id="kobo.1169.1">the function.</span></span></p>
<p><span class="koboSpan" id="kobo.1170.1">It’s what we had written (clumsily) by hand, really. </span><span class="koboSpan" id="kobo.1170.2">Apart from the fact that we now allocate and free raw memory, the rest of the code is very similar to the original, simple version. </span><span class="koboSpan" id="kobo.1170.3">This probably makes you feel much better… and </span><span class="No-Break"><span class="koboSpan" id="kobo.1171.1">it should.</span></span></p>
<p><span class="koboSpan" id="kobo.1172.1">A similar </span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.1173.1">approach can be taken with other constructors. </span><span class="koboSpan" id="kobo.1173.2">Take, for example, the </span><span class="No-Break"><span class="koboSpan" id="kobo.1174.1">copy constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1175.1">
   // ...
</span><span class="koboSpan" id="kobo.1175.2">   Vector(const Vector&amp; other)
      : </span><strong class="bold"><span class="koboSpan" id="kobo.1176.1">elems{ static_cast&lt;pointer&gt;(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1177.1">           std::malloc(n * sizeof(value_type))</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1178.1">        ) }</span></strong><span class="koboSpan" id="kobo.1179.1">,
        nelems{ other.size() }, cap{ other.size() } {
      try {
         </span><strong class="bold"><span class="koboSpan" id="kobo.1180.1">std::uninitialized_copy(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1181.1">            other.begin(), other.end(), begin()</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1182.1">         );</span></strong><span class="koboSpan" id="kobo.1183.1">
      } catch (...) {
         </span><strong class="bold"><span class="koboSpan" id="kobo.1184.1">std::free(elems);</span></strong><span class="koboSpan" id="kobo.1185.1">
         throw;
      }
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.1186.1">As you can see, with the proper algorithms, the fast implementations that work on raw memory are very similar to the naïve and </span><span class="No-Break"><span class="koboSpan" id="kobo.1187.1">slower versions.</span></span></p>
<p><span class="koboSpan" id="kobo.1188.1">The key point here is to understand the boundaries of the API. </span><span class="koboSpan" id="kobo.1188.2">A function such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1189.1">std::uninitialized_copy()</span></strong><span class="koboSpan" id="kobo.1190.1"> takes three arguments: the beginning and end of a source sequence (this sequence is presumed to contain objects) and the beginning of the destination sequence (this sequence is presumed to be appropriately aligned and made of raw memory, not objects). </span><span class="koboSpan" id="kobo.1190.2">If the function concludes its execution because it met its postconditions and constructed the objects in the destination sequence, then that </span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.1191.1">destination sequence contains objects. </span><span class="koboSpan" id="kobo.1191.2">On the other hand, if the function fails to meet its postconditions, then there are no objects in the destination sequence as whatever the function has constructed, it will also </span><span class="No-Break"><span class="koboSpan" id="kobo.1192.1">have destructed.</span></span></p>
<p><span class="koboSpan" id="kobo.1193.1">Similar maneuvers can be done with other constructors, keeping in mind that the default constructor and the move constructor are implemented very differently and as such deserve a </span><span class="No-Break"><span class="koboSpan" id="kobo.1194.1">different treatment.</span></span></p>
<h3><span class="koboSpan" id="kobo.1195.1">Impact on the destructor</span></h3>
<p><span class="koboSpan" id="kobo.1196.1">The destructor in this implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1197.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1198.1"> is interesting: when the object reaches </span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.1199.1">the end of its lifetime, we cannot simply call </span><strong class="source-inline"><span class="koboSpan" id="kobo.1200.1">delete[]</span></strong><span class="koboSpan" id="kobo.1201.1"> on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1202.1">elems</span></strong><span class="koboSpan" id="kobo.1203.1"> data member as it has not been allocated by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1204.1">new[]</span></strong><span class="koboSpan" id="kobo.1205.1"> in the first place and it is made of a sequence of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1206.1">T</span></strong><span class="koboSpan" id="kobo.1207.1"> objects, potentially followed by a sequence of raw bytes. </span><span class="koboSpan" id="kobo.1207.2">We would not want to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.1208.1">T::~T()</span></strong><span class="koboSpan" id="kobo.1209.1"> on an arbitrary sequence of bytes since this could cause quite a lot of damage in our program and </span><span class="No-Break"><span class="koboSpan" id="kobo.1210.1">incur </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1211.1">UB</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1212.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1213.1">The only entity that knows how many objects there are in the container is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1215.1"> object itself, which means that it will need to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1216.1">destroy()</span></strong><span class="koboSpan" id="kobo.1217.1"> the remaining objects, and only then </span><strong class="source-inline"><span class="koboSpan" id="kobo.1218.1">free()</span></strong><span class="koboSpan" id="kobo.1219.1"> the (now devoid of objects) memory block that remains. </span><span class="koboSpan" id="kobo.1219.2">Applying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1220.1">std::destroy()</span></strong><span class="koboSpan" id="kobo.1221.1"> algorithm on a sequence of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1222.1">T</span></strong><span class="koboSpan" id="kobo.1223.1"> objects calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.1224.1">T::~T()</span></strong><span class="koboSpan" id="kobo.1225.1"> on each of them, turning a sequence of objects into </span><span class="No-Break"><span class="koboSpan" id="kobo.1226.1">raw memory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1227.1">
   // ...
</span><span class="koboSpan" id="kobo.1227.2">   ~Vector() {
      </span><strong class="bold"><span class="koboSpan" id="kobo.1228.1">std::destroy(begin(), end());</span></strong><span class="koboSpan" id="kobo.1229.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.1230.1">std::free(elems);</span></strong><span class="koboSpan" id="kobo.1231.1">
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.1232.1">These low-level memory management algorithms really help in clarifying the intent of the code we write, as you </span><span class="No-Break"><span class="koboSpan" id="kobo.1233.1">can see.</span></span></p>
<h3><span class="koboSpan" id="kobo.1234.1">Impact on per-element insertion functions</span></h3>
<p><span class="koboSpan" id="kobo.1235.1">A similar situation </span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.1236.1">happens in member functions </span><strong class="source-inline"><span class="koboSpan" id="kobo.1237.1">push_back()</span></strong><span class="koboSpan" id="kobo.1238.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1239.1">emplace_back()</span></strong><span class="koboSpan" id="kobo.1240.1"> where we used to replace through an assignment </span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.1241.1">some existing object at the end of our array; we </span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.1242.1">now need to construct an object at the end of the array since there is no object there anymore (we do not construct objects needlessly; that’s the point of </span><span class="No-Break"><span class="koboSpan" id="kobo.1243.1">our efforts!).</span></span></p>
<p><span class="koboSpan" id="kobo.1244.1">We could use placement </span><strong class="source-inline"><span class="koboSpan" id="kobo.1245.1">new</span></strong><span class="koboSpan" id="kobo.1246.1"> to do this, obviously, but the standard library offers a moral equivalent named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1247.1">std::construct_at()</span></strong><span class="koboSpan" id="kobo.1248.1">. </span><span class="koboSpan" id="kobo.1248.2">This makes our intent even clearer from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1249.1">source code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1250.1">
   // ...
</span><span class="koboSpan" id="kobo.1250.2">   void push_back(const_reference val) {
      if (full())
         grow();
      </span><strong class="bold"><span class="koboSpan" id="kobo.1251.1">std::construct_at(end(), val);</span></strong><span class="koboSpan" id="kobo.1252.1">
      ++nelems;
   }
   void push_back(T&amp;&amp; val) {
      if (full())
         grow();
      </span><strong class="bold"><span class="koboSpan" id="kobo.1253.1">std::construct_at(end(), std::move(val));</span></strong><span class="koboSpan" id="kobo.1254.1">
      ++nelems;
   }
   template &lt;class ... </span><span class="koboSpan" id="kobo.1254.2">Args&gt;
      reference emplace_back(Args &amp;&amp;...args) {
         if (full())
            grow();
         </span><strong class="bold"><span class="koboSpan" id="kobo.1255.1">std::construct_at(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1256.1">            end(), std::forward&lt;Args&gt;(args)...</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1257.1">         );</span></strong><span class="koboSpan" id="kobo.1258.1">
         ++nelems;
         return back();
      }</span></pre> <h3><span class="koboSpan" id="kobo.1259.1">Impact on growth functions</span></h3>
<p><span class="koboSpan" id="kobo.1260.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1261.1">grow()</span></strong><span class="koboSpan" id="kobo.1262.1"> function </span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.1263.1">we had implemented initially called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1264.1">resize()</span></strong><span class="koboSpan" id="kobo.1265.1"> on our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1267.1">, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.1268.1">resize()</span></strong><span class="koboSpan" id="kobo.1269.1"> is meant to initialize the storage with objects. </span><span class="koboSpan" id="kobo.1269.2">To </span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.1270.1">make the allocated storage grow in size without initializing it with objects, we need a different member function, </span><span class="No-Break"><span class="koboSpan" id="kobo.1271.1">namely </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1272.1">reserve()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1273.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1274.1">On the differences between resize() and reserve()</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1275.1">Expressed </span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.1276.1">simply, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1277.1">resize()</span></strong><span class="koboSpan" id="kobo.1278.1"> potentially </span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.1279.1">adds objects to the container, and as such it can modify both </span><strong class="source-inline"><span class="koboSpan" id="kobo.1280.1">size()</span></strong><span class="koboSpan" id="kobo.1281.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1282.1">capacity()</span></strong><span class="koboSpan" id="kobo.1283.1">. </span><span class="koboSpan" id="kobo.1283.2">On the other hand, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1284.1">reserve()</span></strong><span class="koboSpan" id="kobo.1285.1"> adds no object to the container, limiting itself to potentially increasing the storage space being used by the container; in other words, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1286.1">reserve()</span></strong><span class="koboSpan" id="kobo.1287.1"> can change </span><strong class="source-inline"><span class="koboSpan" id="kobo.1288.1">capacity()</span></strong><span class="koboSpan" id="kobo.1289.1"> but will not </span><span class="No-Break"><span class="koboSpan" id="kobo.1290.1">change </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1291.1">size()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1292.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1293.1">Following the example set by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1294.1">std::vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1295.1">, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1297.1"> class will offer both </span><strong class="source-inline"><span class="koboSpan" id="kobo.1298.1">resize()</span></strong><span class="koboSpan" id="kobo.1299.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1300.1">reserve()</span></strong><span class="koboSpan" id="kobo.1301.1">. </span><span class="koboSpan" id="kobo.1301.2">A version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1302.1">resize()</span></strong><span class="koboSpan" id="kobo.1303.1"> adapted to the new reality of our part-objects, part-raw-memory container follows, accompanied by an implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1304.1">reserve()</span></strong><span class="koboSpan" id="kobo.1305.1"> that suits </span><strong class="source-inline"><span class="koboSpan" id="kobo.1306.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1307.1">. </span><span class="koboSpan" id="kobo.1307.2">We will discuss </span><strong class="source-inline"><span class="koboSpan" id="kobo.1308.1">reserve()</span></strong><span class="koboSpan" id="kobo.1309.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1310.1">resize()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1311.1"> separately:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1312.1">
   // ...
</span><span class="koboSpan" id="kobo.1312.2">private:
   void grow() {
      </span><strong class="bold"><span class="koboSpan" id="kobo.1313.1">reserve</span></strong><span class="koboSpan" id="kobo.1314.1">(capacity()? </span><span class="koboSpan" id="kobo.1314.2">capacity() * 2 : 16);
   }
public:
   void reserve(size_type new_cap) {
      if(new_cap &lt;= capacity()) return;
      auto p = static_cast&lt;pointer&gt;(
         std::malloc(new_cap * sizeof(T))
      );
      if constexpr(std::is_nothrow_move_assignable_v&lt;T&gt;) {
         std::uninitialized_move(begin(), end(), p);
      } else try {
         std::uninitialized_copy(begin(), end(), p);
      } catch (...) {
         std::free(p);
         throw;
      }
      std::destroy(begin(), end());
      std::free(elems);
      elems = p;
      cap = new_cap;
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.1315.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1316.1">reserve()</span></strong><span class="koboSpan" id="kobo.1317.1"> member </span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.1318.1">function first ensures that the requested new capacity is higher than the existing one (otherwise there’s nothing to do). </span><span class="koboSpan" id="kobo.1318.2">If that is so, it allocates a new memory block and either moves or copies the existing elements of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1319.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1320.1"> object into that new memory (a copy will be made if moving </span><strong class="source-inline"><span class="koboSpan" id="kobo.1321.1">T</span></strong><span class="koboSpan" id="kobo.1322.1"> objects can throw: it pays to make move operations </span><strong class="source-inline"><span class="koboSpan" id="kobo.1323.1">noexcept</span></strong><span class="koboSpan" id="kobo.1324.1">, dear readers!) using algorithms that construct objects into </span><span class="No-Break"><span class="koboSpan" id="kobo.1325.1">raw memory.</span></span></p>
<p><span class="koboSpan" id="kobo.1326.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1327.1">T</span></strong><span class="koboSpan" id="kobo.1328.1"> objects left in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1329.1">elems</span></strong><span class="koboSpan" id="kobo.1330.1"> are then destroyed (even if they have been moved-from: they still need to be finalized), and we ensure that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1331.1">cap</span></strong><span class="koboSpan" id="kobo.1332.1"> is updated and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">elems</span></strong><span class="koboSpan" id="kobo.1334.1"> points to the new block of storage. </span><span class="koboSpan" id="kobo.1334.2">Of course, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1335.1">size()</span></strong><span class="koboSpan" id="kobo.1336.1"> does not change as no new object has been added to </span><span class="No-Break"><span class="koboSpan" id="kobo.1337.1">the container.</span></span></p>
<p><span class="koboSpan" id="kobo.1338.1">The procedure </span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.1339.1">is similar for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1340.1">resize()</span></strong><span class="koboSpan" id="kobo.1341.1"> (as follows), except that the locations in the memory block starting at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1342.1">size()</span></strong><span class="koboSpan" id="kobo.1343.1"> index are initialized with a default </span><strong class="source-inline"><span class="koboSpan" id="kobo.1344.1">T</span></strong><span class="koboSpan" id="kobo.1345.1"> instead of being left in their raw memory state. </span><span class="koboSpan" id="kobo.1345.2">Consequently, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1346.1">size()</span></strong><span class="koboSpan" id="kobo.1347.1"> is updated, leading to different semantics from those obtained following a call </span><span class="No-Break"><span class="koboSpan" id="kobo.1348.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1349.1">reserve()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1350.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1351.1">
   // ...
</span><span class="koboSpan" id="kobo.1351.2">   void resize(size_type new_cap) {
      if(new_cap &lt;= capacity()) return;
      auto p = static_cast&lt;pointer&gt;(
         std::malloc(new_cap * sizeof(T))
      );
      if constexpr(std::is_nothrow_move_assignable_v&lt;T&gt;) {
         std::uninitialized_move(begin(), end(), p);
      } else try {
         std::uninitialized_copy(begin(), end(), p);
      } catch (...) {
         std::free(p);
         throw;
      }
      std::uninitialized_fill(
         p + size(), p + capacity(), value_type{}
      );
      std::destroy(begin(), end());
      std::free(elems);
      elems = p;
      nelems = new_cap;
      cap = new_cap;
   }
   // ...</span></pre> <p><span class="koboSpan" id="kobo.1352.1">This more </span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.1353.1">sophisticated structure we are implementing will obviously have an impact on the way we </span><strong class="source-inline"><span class="koboSpan" id="kobo.1354.1">insert()</span></strong><span class="koboSpan" id="kobo.1355.1"> or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1356.1">erase()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1357.1"> elements.</span></span></p>
<h3><span class="koboSpan" id="kobo.1358.1">Impact on element insertion and erasure functions</span></h3>
<p><span class="koboSpan" id="kobo.1359.1">As expected, member </span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.1360.1">functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1361.1">insert()</span></strong><span class="koboSpan" id="kobo.1362.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1363.1">erase()</span></strong><span class="koboSpan" id="kobo.1364.1"> have to </span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.1365.1">be updated to take into account the changes we </span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.1366.1">have made to the internal </span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.1367.1">organization of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1368.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1369.1"> objects. </span><span class="koboSpan" id="kobo.1369.2">That does not have to be painful (and, indeed, required changes, if any, can be tiny) as long as the semantics of every function are clear from the onset, but it does </span><span class="No-Break"><span class="koboSpan" id="kobo.1370.1">require care.</span></span></p>
<p><span class="koboSpan" id="kobo.1371.1">For example, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1372.1">insert(pos,first,last)</span></strong><span class="koboSpan" id="kobo.1373.1"> as an example, we are moving from the simple model described in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1374.1">Figure 12</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1375.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1376.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.1377.1"><img alt="Figure 12.1 – Example of the naïve Vector&lt;T&gt; insertion model" src="image/B21071_12_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1378.1">Figure 12.1 – Example of the naïve Vector&lt;T&gt; insertion model</span></p>
<p><span class="koboSpan" id="kobo.1379.1">Here, inserting a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1380.1">[first,last)</span></strong><span class="koboSpan" id="kobo.1381.1"> sequence at position </span><strong class="source-inline"><span class="koboSpan" id="kobo.1382.1">pos</span></strong><span class="koboSpan" id="kobo.1383.1"> means copying (in reverse order) the </span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.1384.1">elements in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1385.1">[pos,end())</span></strong><span class="koboSpan" id="kobo.1386.1"> at </span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.1387.1">position </span><strong class="source-inline"><span class="koboSpan" id="kobo.1388.1">pos + n</span></strong><span class="koboSpan" id="kobo.1389.1">, then overwriting the elements of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1390.1">[pos,pos+n)</span></strong><span class="koboSpan" id="kobo.1391.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1392.1">[first,last)</span></strong><span class="koboSpan" id="kobo.1393.1"> to the more complex model described in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1394.1">Figure 12</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1395.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1396.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.1397.1"><img alt="Figure 12.2 – Example of the current Vector&lt;T&gt; insertion model" src="image/B21071_12_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1398.1">Figure 12.2 – Example of the current Vector&lt;T&gt; insertion model</span></p>
<p><span class="koboSpan" id="kobo.1399.1">The idea is that we need to insert </span><strong class="source-inline"><span class="koboSpan" id="kobo.1400.1">[first,last)</span></strong><span class="koboSpan" id="kobo.1401.1"> at position </span><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">pos</span></strong><span class="koboSpan" id="kobo.1403.1">, which means that the elements in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1404.1">[pos,pos+n)</span></strong><span class="koboSpan" id="kobo.1405.1"> have to be copied (or moved) to the right. </span><span class="koboSpan" id="kobo.1405.2">This will require </span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.1406.1">constructing some </span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.1407.1">objects in raw memory (the gray area in the preceding figure) and replacing some other objects through copy (or </span><span class="No-Break"><span class="koboSpan" id="kobo.1408.1">move) assignment.</span></span></p>
<p><span class="koboSpan" id="kobo.1409.1">There are four steps to </span><span class="No-Break"><span class="koboSpan" id="kobo.1410.1">consider here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1411.1">How many elements should be copied or moved from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1412.1">[begin(),end()) </span></strong><span class="koboSpan" id="kobo.1413.1">sequence to the raw memory block at the end of the container, and where in that block should the resulting objects </span><span class="No-Break"><span class="koboSpan" id="kobo.1414.1">be constructed.</span></span></li>
<li><span class="koboSpan" id="kobo.1415.1">If there are elements from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1416.1">[first,last)</span></strong><span class="koboSpan" id="kobo.1417.1"> sequence to insert in raw memory (there could be none), how many should there be? </span><span class="koboSpan" id="kobo.1417.2">If there are any such objects, they will be inserted </span><span class="No-Break"><span class="koboSpan" id="kobo.1418.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1419.1">end()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1420.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1421.1">If there are elements to copy or move from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1422.1">[pos,end())</span></strong><span class="koboSpan" id="kobo.1423.1"> sequence to copy or move as a replacement to existing objects in the container (there could be none), how many should there be? </span><span class="koboSpan" id="kobo.1423.2">The end of the destination range will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.1424.1">end()</span></strong><span class="koboSpan" id="kobo.1425.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.1426.1">this case.</span></span></li>
<li><span class="koboSpan" id="kobo.1427.1">Finally, whatever remains to be inserted from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1428.1">[first,last)</span></strong><span class="koboSpan" id="kobo.1429.1"> sequence will be copied in the container starting </span><span class="No-Break"><span class="koboSpan" id="kobo.1430.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1431.1">pos</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1432.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1433.1">A possible implementation would be </span><span class="No-Break"><span class="koboSpan" id="kobo.1434.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1435.1">
   // ...
</span><span class="koboSpan" id="kobo.1435.2">   template &lt;class It&gt;
   iterator insert(const_iterator pos, It first, It last) {
      iterator pos_ = const_cast&lt;iterator&gt;(pos);
      const auto remaining = capacity() - size();
      const auto n = std::distance(first, last);
</span><strong class="bold"><span class="koboSpan" id="kobo.1436.1">      // we use cmp_less() here as remaining is an unsigned</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1437.1">      // integral but n is a signed integral</span></strong><span class="koboSpan" id="kobo.1438.1">
      if (</span><strong class="bold"><span class="koboSpan" id="kobo.1439.1">std::cmp_less(remaining, n)</span></strong><span class="koboSpan" id="kobo.1440.1">) {
         auto index = std::distance(begin(), pos_);
         reserve(capacity() + n - remaining);
         pos_ = std::next(begin(), index);
      }
</span><strong class="bold"><span class="koboSpan" id="kobo.1441.1">      // objects to displace (move or copy) from the</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1442.1">      // [begin(),end()) sequence into raw memory</span></strong><span class="koboSpan" id="kobo.1443.1">
      const auto nb_to_uninit_displace =
         std::min&lt;std::ptrdiff_t&gt;(n, end() - pos_);
      auto where_to_uninit_displace =
         end() + n - nb_to_uninit_displace;
      if constexpr(std::is_nothrow_move_constructible_v&lt;T&gt;)
         std::uninitialized_move(
            end() - nb_to_uninit_displace, end(),
            where_to_uninit_displace
         );
      else
         std::uninitialized_copy(
            end() - nb_to_uninit_displace, end(),
            where_to_uninit_displace
         );
</span><strong class="bold"><span class="koboSpan" id="kobo.1444.1">      // objects from [first,last) to insert into raw</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1445.1">      // memory (note: there might be none)</span></strong><span class="koboSpan" id="kobo.1446.1">
      const auto nb_to_uninit_insert =
         std::max&lt;std::ptrdiff_t&gt;(
            0, n - nb_to_uninit_displace
         );
      auto where_to_uninit_insert = end();
      std::uninitialized_copy(
         last - nb_to_uninit_insert, last,
         where_to_uninit_insert
      );
</span><strong class="bold"><span class="koboSpan" id="kobo.1447.1">      // objects to displace (copy or move) from the</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1448.1">      // [pos,end()) sequence into that space (note:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1449.1">      // there might be none)</span></strong><span class="koboSpan" id="kobo.1450.1">
      const auto nb_to_backward_displace =
         std::max&lt;std::ptrdiff_t&gt;(
            0, end() - pos_ - nb_to_uninit_displace
         );
</span><strong class="bold"><span class="koboSpan" id="kobo.1451.1">       // note : end of destination</span></strong><span class="koboSpan" id="kobo.1452.1">
      auto where_to_backward_displace = end();
      if constexpr (std::is_nothrow_move_assignable_v&lt;T&gt;)
         std::move_backward(
            pos_, pos_ + nb_to_backward_displace,
            where_to_backward_displace
         );
      else
         std::copy_backward(
            pos_, pos_ + nb_to_backward_displace,
            where_to_backward_displace
         );
</span><strong class="bold"><span class="koboSpan" id="kobo.1453.1">      // objects to copy from [first,last) to pos</span></strong><span class="koboSpan" id="kobo.1454.1">
      std::copy(
         first, first + n - nb_to_uninit_insert, pos
      );
      nelems += n;
      return pos_;
   }</span></pre> <p><span class="koboSpan" id="kobo.1455.1">Make sure you do not move the elements in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1456.1">[first,last)</span></strong><span class="koboSpan" id="kobo.1457.1">, however: that would be user-hostile as it would potentially destroy the data in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1458.1">source range!</span></span></p>
<p><span class="koboSpan" id="kobo.1459.1">As for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1460.1">erase()</span></strong><span class="koboSpan" id="kobo.1461.1"> member function that we had written in a more naïve manner initially, the key adjustment we will need to make is in the way we handle the removed element: you might remember that in our naïve version, we assigned a default </span><strong class="source-inline"><span class="koboSpan" id="kobo.1462.1">T</span></strong><span class="koboSpan" id="kobo.1463.1"> to the erased </span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.1464.1">element at the end of </span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.1465.1">the container, and complained that this added the suspicious requirement of a default constructor in type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1466.1">T</span></strong><span class="koboSpan" id="kobo.1467.1">. </span><span class="koboSpan" id="kobo.1467.2">In this version, we will quite simply destroy this object, ending its lifetime and turning its underlying storage back into </span><span class="No-Break"><span class="koboSpan" id="kobo.1468.1">raw memory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1469.1">
   iterator erase(const_iterator pos) {
      iterator pos_ = const_cast&lt;iterator&gt;(pos);
      if (pos_ == end()) return pos_;
      std::copy(std::next(pos_), end(), pos_);
</span><strong class="bold"><span class="koboSpan" id="kobo.1470.1">      std::destroy_at(std::prev(end()));</span></strong><span class="koboSpan" id="kobo.1471.1">
      --nelems;
      return pos_;
   }</span></pre> <p><span class="koboSpan" id="kobo.1472.1">Hopefully, this gives you, dear reader, a better idea of what it takes to write a more serious implementation of a homemade </span><strong class="source-inline"><span class="koboSpan" id="kobo.1473.1">std::vector</span></strong><span class="koboSpan" id="kobo.1474.1">-like type and a better appreciation for the craftsmanship of the individuals behind your favorite standard library provider. </span><span class="koboSpan" id="kobo.1474.2">Know that they do all this and more for your programs to be the wonderfully efficient things </span><span class="No-Break"><span class="koboSpan" id="kobo.1475.1">they are!</span></span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.1476.1">Const or reference members and std::launder()</span></h2>
<p><span class="koboSpan" id="kobo.1477.1">Before we </span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.1478.1">conclude this chapter, we </span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.1479.1">need to say a few words on those oddities that are containers that hold objects of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1480.1">const</span></strong><span class="koboSpan" id="kobo.1481.1"> types, as well as on containers whose elements are of a type with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1482.1">const</span></strong><span class="koboSpan" id="kobo.1483.1"> or </span><span class="No-Break"><span class="koboSpan" id="kobo.1484.1">reference members.</span></span></p>
<p><span class="koboSpan" id="kobo.1485.1">Consider this seemingly </span><span class="No-Break"><span class="koboSpan" id="kobo.1486.1">innocuous program:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1487.1">
// ...
</span><span class="koboSpan" id="kobo.1487.2">int main() {
   Vector&lt;</span><strong class="bold"><span class="koboSpan" id="kobo.1488.1">const int</span></strong><span class="koboSpan" id="kobo.1489.1">&gt; v;
   for(int n : { 2, 3, 5, 7, 11 })
      v.push_back(n);
}</span></pre> <p><span class="koboSpan" id="kobo.1490.1">With the implementation we have, this will refuse to compile as our implementation calls a number of low-level functions (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1491.1">std::free()</span></strong><span class="koboSpan" id="kobo.1492.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1493.1">std::destroy_at()</span></strong><span class="koboSpan" id="kobo.1494.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1495.1">std::construct_at()</span></strong><span class="koboSpan" id="kobo.1496.1">, and so on) that take a pointer to a non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.1497.1">const</span></strong><span class="koboSpan" id="kobo.1498.1"> type as </span><span class="No-Break"><span class="koboSpan" id="kobo.1499.1">an argument.</span></span></p>
<p><span class="koboSpan" id="kobo.1500.1">If we are to support such a program, it means we will have to “cast away” </span><strong class="source-inline"><span class="koboSpan" id="kobo.1501.1">const</span></strong><span class="koboSpan" id="kobo.1502.1">-ness in some places in our implementation. </span><span class="koboSpan" id="kobo.1502.2">For example, replacing the </span><span class="No-Break"><span class="koboSpan" id="kobo.1503.1">following line</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1504.1">
      std::free(</span><strong class="bold"><span class="koboSpan" id="kobo.1505.1">elems</span></strong><span class="koboSpan" id="kobo.1506.1">); </span><strong class="bold"><span class="koboSpan" id="kobo.1507.1">// illegal if elems points to const</span></strong></pre> <p><span class="No-Break"><span class="koboSpan" id="kobo.1508.1">with this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1509.1">
      using type = </span><strong class="bold"><span class="koboSpan" id="kobo.1510.1">std::remove_const_t&lt;value_type&gt;*</span></strong><span class="koboSpan" id="kobo.1511.1">;
      std::free(</span><strong class="bold"><span class="koboSpan" id="kobo.1512.1">const_cast&lt;type&gt;(elems)</span></strong><span class="koboSpan" id="kobo.1513.1">);</span></pre> <p><span class="koboSpan" id="kobo.1514.1">Likewise, if your container is to support insertion where there are already existing objects, assignment such as what will be done with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1515.1">std::copy()</span></strong><span class="koboSpan" id="kobo.1516.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1517.1">std::copy_backward()</span></strong><span class="koboSpan" id="kobo.1518.1"> algorithms will not work on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1519.1">const</span></strong><span class="koboSpan" id="kobo.1520.1"> objects or objects with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1521.1">const</span></strong><span class="koboSpan" id="kobo.1522.1"> data members. </span><span class="koboSpan" id="kobo.1522.2">You can make it work by replacing assignment with destruction followed by construction, but your code will be less exception-safe if the construction fails just after the destruction of the object that had to </span><span class="No-Break"><span class="koboSpan" id="kobo.1523.1">be replaced.</span></span></p>
<p><span class="koboSpan" id="kobo.1524.1">Of course, casting away </span><strong class="source-inline"><span class="koboSpan" id="kobo.1525.1">const</span></strong><span class="koboSpan" id="kobo.1526.1">-ness leads us into tricky territory as we are bordering the frightening lands of undefined behavior. </span><span class="koboSpan" id="kobo.1526.2">Standard library implementors can, of course, do what they want, having the ears of the compiler implementors, but we mere mortals do not share this privilege and, for that reason, must </span><span class="No-Break"><span class="koboSpan" id="kobo.1527.1">tread carefully.</span></span></p>
<p><span class="koboSpan" id="kobo.1528.1">A similar </span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.1529.1">situation arises with composite objects that have data members of some reference type: you cannot make a container </span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.1530.1">of references as references are not objects, but you sure can make a container of objects with reference-type data members. </span><span class="koboSpan" id="kobo.1530.2">The problem, of course, is making sense of what happens when an object with a reference data member is </span><span class="No-Break"><span class="koboSpan" id="kobo.1531.1">being replaced.</span></span></p>
<p><span class="koboSpan" id="kobo.1532.1">Let’s take a simpler example than </span><strong class="source-inline"><span class="koboSpan" id="kobo.1533.1">Vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1534.1"> to explain this situation. </span><span class="koboSpan" id="kobo.1534.2">Suppose we have the following class, made to hold a reference to some object of </span><span class="No-Break"><span class="koboSpan" id="kobo.1535.1">type </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1536.1">T</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1537.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1538.1">
#include &lt;type_traits&gt;
template &lt;class T&gt;
struct X {
   </span><strong class="bold"><span class="koboSpan" id="kobo.1539.1">static_assert(std::is_trivially_destructible_v&lt;T&gt;);</span></strong><span class="koboSpan" id="kobo.1540.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.1541.1">T &amp;r</span></strong><span class="koboSpan" id="kobo.1542.1">;
public:
   X(T &amp;r) : r{ r } {
   }
   T&amp; value() { return r; }
   const T &amp; value() const { return r; }
};
// ...</span></pre> <p><span class="koboSpan" id="kobo.1543.1">As is, this class is simple enough and seems easy to reason about. </span><span class="koboSpan" id="kobo.1543.2">Now, suppose we have the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1544.1">client code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1545.1">
// ...
</span><span class="koboSpan" id="kobo.1545.2">#include &lt;iostream&gt;
#include &lt;new&gt;
int main() {
   int n = 3;
   X&lt;int&gt; h{ n };
   h.value()++;
   std::cout &lt;&lt; n &lt;&lt; '\n'; // 4
   std::cout &lt;&lt; h.value() &lt;&lt; '\n'; // 4
   int m = -3;
</span><strong class="bold"><span class="koboSpan" id="kobo.1546.1">   // h = X&lt;int&gt;{ m }; // nope</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1547.1">   X&lt;int&gt; *p = new (static_cast&lt;void*&gt;(&amp;h)) X&lt;int&gt;{ m };</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1548.1">   std::cout &lt;&lt; p-&gt;value() &lt;&lt; '\n'; // -3</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1549.1">   // UB (-3? </span><span class="koboSpan" id="kobo.1549.2">4? </span><span class="koboSpan" id="kobo.1549.3">something else?)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1550.1">   std::cout &lt;&lt; h.value() &lt;&lt; '\n';</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1551.1">   std::cout &lt;&lt; std::launder(&amp;h)-&gt;value() &lt;&lt; '\n'; // -3</span></strong><span class="koboSpan" id="kobo.1552.1">
}</span></pre> <p><span class="koboSpan" id="kobo.1553.1">Replacing an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1554.1">X&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.1555.1"> object through assignment is incorrect as having a reference data member deletes your assignment operator, at least by default (the default meaning would </span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.1556.1">be ambiguous: should the reference </span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.1557.1">be rebound to something else, or should the referred-to object be </span><span class="No-Break"><span class="koboSpan" id="kobo.1558.1">assigned to?).</span></span></p>
<p><span class="koboSpan" id="kobo.1559.1">One way to get around this problem is to destroy the original object and construct a new object in its place. </span><span class="koboSpan" id="kobo.1559.2">In our example, since we ensured (through </span><strong class="source-inline"><span class="koboSpan" id="kobo.1560.1">static_assert</span></strong><span class="koboSpan" id="kobo.1561.1">) that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1562.1">T</span></strong><span class="koboSpan" id="kobo.1563.1"> was trivially destructible, we just constructed a new object where the previous one stood (ending the previous object’s lifetime). </span><span class="koboSpan" id="kobo.1563.2">The bits are then all mapped properly to the new object... </span><span class="koboSpan" id="kobo.1563.3">except that the compiler might not follow </span><span class="No-Break"><span class="koboSpan" id="kobo.1564.1">our reasoning.</span></span></p>
<p><span class="koboSpan" id="kobo.1565.1">In practice, compilers track the lifetime of objects the best they can, but we placed ourselves in a situation where the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.1566.1">X&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.1567.1"> object has never been explicitly destroyed. </span><span class="koboSpan" id="kobo.1567.2">For that reason, this original </span><strong class="source-inline"><span class="koboSpan" id="kobo.1568.1">X&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.1569.1"> object could still be considered to be there by the compiler, but the bits of the original object have been replaced by the new object placed at that specific address through very manual means. </span><span class="koboSpan" id="kobo.1569.2">There might be a discrepancy between what the bits say and what the compiler understands from the source code, because (to be honest) we have been playing dirty tricks with the explicit construction </span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.1570.1">of an object at a specific address </span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.1571.1">that happens to have been occupied by </span><span class="No-Break"><span class="koboSpan" id="kobo.1572.1">another object.</span></span></p>
<p><span class="koboSpan" id="kobo.1573.1">Accessing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1574.1">value()</span></strong><span class="koboSpan" id="kobo.1575.1"> through </span><strong class="source-inline"><span class="koboSpan" id="kobo.1576.1">p</span></strong><span class="koboSpan" id="kobo.1577.1"> will definitely give you </span><strong class="source-inline"><span class="koboSpan" id="kobo.1578.1">-3</span></strong><span class="koboSpan" id="kobo.1579.1"> as it’s obvious that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1580.1">p</span></strong><span class="koboSpan" id="kobo.1581.1"> points to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1582.1">X&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.1583.1"> object that holds a reference to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1584.1">m</span></strong><span class="koboSpan" id="kobo.1585.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1586.1">m</span></strong><span class="koboSpan" id="kobo.1587.1"> has the value </span><strong class="source-inline"><span class="koboSpan" id="kobo.1588.1">-3</span></strong><span class="koboSpan" id="kobo.1589.1"> at that point. </span><span class="koboSpan" id="kobo.1589.2">Accessing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1590.1">value()</span></strong><span class="koboSpan" id="kobo.1591.1"> through </span><strong class="source-inline"><span class="koboSpan" id="kobo.1592.1">h</span></strong><span class="koboSpan" id="kobo.1593.1"> is undefined behavior (will the resulting code give you what the bits say or what the compiler thinks that code </span><span class="No-Break"><span class="koboSpan" id="kobo.1594.1">is saying?).</span></span></p>
<p><span class="koboSpan" id="kobo.1595.1">This sort of evil-seeming situation, where the code logic as understood by the compiler might not match the bits, happens with objects with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1596.1">const</span></strong><span class="koboSpan" id="kobo.1597.1"> data members, objects with reference data members, and some </span><strong class="source-inline"><span class="koboSpan" id="kobo.1598.1">union</span></strong><span class="koboSpan" id="kobo.1599.1"> types crafted in weird ways, but these are the tools we use for the low-level manipulation of objects, and that can be found underneath </span><strong class="source-inline"><span class="koboSpan" id="kobo.1600.1">std::optional&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1601.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1602.1">std::vector&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1603.1">, and others. </span><span class="koboSpan" id="kobo.1603.2">It’s our fault, in the end, for using these weird types, but it’s part </span><span class="No-Break"><span class="koboSpan" id="kobo.1604.1">of life.</span></span></p>
<p><span class="koboSpan" id="kobo.1605.1">When the bits do not necessarily align with what the compiler can understand, we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.1606.1">std::launder()</span></strong><span class="koboSpan" id="kobo.1607.1">. </span><span class="koboSpan" id="kobo.1607.2">Use this cautiously: it’s an optimization barrier that states “just look at the bits, compiler; forget what you know about source code when looking at this pointed-to object.” </span><span class="koboSpan" id="kobo.1607.3">Of course, this is a very dangerous tool and should be used with a lot of care, but sometimes it’s just what </span><span class="No-Break"><span class="koboSpan" id="kobo.1608.1">is needed.</span></span></p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.1609.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1610.1">Whew, this was a long chapter! </span><span class="koboSpan" id="kobo.1610.2">We implemented a naïve </span><strong class="source-inline"><span class="koboSpan" id="kobo.1611.1">vector</span></strong><span class="koboSpan" id="kobo.1612.1">-like container, then a naïve </span><strong class="source-inline"><span class="koboSpan" id="kobo.1613.1">forward_list</span></strong><span class="koboSpan" id="kobo.1614.1">-like container, and then took another look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1615.1">vector</span></strong><span class="koboSpan" id="kobo.1616.1">-like container (we will return to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1617.1">forward_list</span></strong><span class="koboSpan" id="kobo.1618.1">-like container in the next two chapters) to show how tighter control over memory can lead to more </span><span class="No-Break"><span class="koboSpan" id="kobo.1619.1">efficient containers.</span></span></p>
<p><span class="koboSpan" id="kobo.1620.1">Our implementations in this chapter were “manual,” in the sense that we did the memory management by hand. </span><span class="koboSpan" id="kobo.1620.2">That involved writing a lot of code, something we will reconsider in </span><a href="B21071_13.xhtml#_idTextAnchor187"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1621.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.1622.1">. </span><span class="koboSpan" id="kobo.1622.2">In </span><a href="B21071_14.xhtml#_idTextAnchor199"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1623.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.1624.1">, we will examine how allocators interact with containers, and will use this opportunity to revisit our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1625.1">forward_list</span></strong><span class="koboSpan" id="kobo.1626.1">-like container as there will be interesting aspects to examine as we continue our adventure through memory management </span><span class="No-Break"><span class="koboSpan" id="kobo.1627.1">in C++.</span></span></p>
</div>
</body></html>