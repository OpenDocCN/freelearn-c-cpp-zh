<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3D Minigolf</h1>
                
            
            <article>
                
<p class="calibre2">The previous projects in this book have been designed in 2D space. This is intentional, in order to introduce the various features and concepts of Godot while keeping the projects' scopes limited. In this chapter, you'll venture into the 3D side of game development. For some, 3D development feels significantly more difficult to manage; for others, it is more straightforward. In either case, there is certainly an additional layer of complexity for you to understand.</p>
<p class="calibre2">If you've never worked with any kind of 3D software before, you may find yourself encountering many new concepts. This chapter will explain them as much as possible, but remember to refer to the Godot documentation whenever you need a more in-depth understanding of a particular topic.</p>
<p class="calibre2">The game you'll make in this chapter is called <strong class="calibre4">Minigolf</strong>. This will consist of a small customizable course, a ball, and an interface for aiming and shooting the ball towards the hole.</p>
<p class="calibre2">This is what you'll learn in this chapter:</p>
<ul class="calibre10">
<li class="calibre11">Navigating Godot's 3D editor</li>
<li class="calibre11">The Spatial node and its properties</li>
<li class="calibre11">Importing 3D meshes and using 3D collision shapes</li>
<li class="calibre11">How to use 3D cameras, both stationary and moving</li>
<li class="calibre11">Using GridMap to place the tiles of your golf course</li>
<li class="calibre11">Setting up lighting and the environment</li>
<li class="calibre11">An introduction to PBR rendering and materials</li>
</ul>
<p class="calibre2">But first, here's a brief introduction to 3D in Godot.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introduction to 3D</h1>
                
            
            <article>
                
<p class="calibre2">One of the strengths of Godot is its ability to handle both 2D and 3D games. While much of what you've learned earlier in this book applies equally well in 3D (nodes, scenes, signals, and so on), changing from 2D to 3D brings with it a whole new layer of complexity and capabilities. First, you'll find that there are some additional features available in the 3D editor window, and it's a good idea to familiarize yourself with how to navigate in the 3D editor window.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Orienting in 3D space</h1>
                
            
            <article>
                
<p class="calibre2">When you click on the 3D button at the top of the editor window, you will see the 3D project view:</p>
<div class="cdpaligncenter1"><img src="../images/00140.jpeg" class="calibre144"/></div>
<p class="calibre2">The first thing you should notice is the three colored lines in the center. These are the <em class="calibre17">x</em> (red), <em class="calibre17">y</em> (green), and <em class="calibre17">z</em> (blue) axes. The point where they meet is the origin, with coordinates of <kbd class="calibre12">(0, 0, 0)</kbd>.</p>
<div class="packt_infobox">Just as you used <kbd class="calibre51">Vector2(x, y)</kbd> to indicate a position in two-dimensional space, <kbd class="calibre51">Vector3(x, y, z)</kbd> describes a position in three dimensions along these three axes.</div>
<p class="calibre2">One issue that arises when working in 3D is that different applications use different conventions for orientation. Godot uses Y-Up orientation, so when looking at the axes, if <em class="calibre17">x</em> is pointing to the left/right, then <em class="calibre17">y</em> is up/down, and <em class="calibre17">z</em> is forward/back. You may find when using other popular 3D software that they use Z-Up. It's good to be aware of this, as it can lead to confusion when moving between different programs.</p>
<p class="calibre2">Another major aspect to be aware of is the unit of measure. In 2D, everything is measured in pixels, which makes sense as a natural basis for measurement when drawing on the screen. However, when working in 3D space, pixels aren't really useful. Two objects of exactly the same size will occupy different areas on the screen depending on how far away they are from the camera (more about cameras soon). For this reason, in 3D space all objects in Godot are measured in generic units. You're free to call these units whatever you like: meters, inches, or even light years, depending on the scale of your game world.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Godot's 3D editor</h1>
                
            
            <article>
                
<p class="calibre2">Before getting started with 3D, it will be useful to briefly review how to navigate in Godot's 3D space. The camera is controlled with the mouse and keyboard:</p>
<ul class="calibre10">
<li class="calibre11">Mousewheel up/down: Zoom in/out</li>
<li class="calibre11">Middle button + drag: Orbit the camera around the current target</li>
<li class="calibre11"><em class="calibre20">Shift</em> + middle button + drag: Pan camera up/down/left/right</li>
<li class="calibre11">Right-click + drag: Rotate camera in place</li>
</ul>
<p class="calibre2">If you're familiar with popular 3D games such as <em class="calibre17">Minecraft</em>, you can press <em class="calibre17">Shift</em> + <em class="calibre17">F</em> to switch to Freelook mode. In this mode, you can use the WASD keys to <em class="calibre17">fly</em> around the scene while aiming with the mouse. Press <em class="calibre17">Shift</em> + <em class="calibre17">F</em> again to exit Freelook mode. </p>
<p class="calibre2">You can also alter the camera's view by clicking on the <span class="calibre5">[ Perspective ]</span> label in the upper-left corner. Here, you can snap the camera to a particular orientation such as <span class="calibre5">Top View</span> or <span class="calibre5">Front View</span>:</p>
<div class="cdpaligncenter1"><img src="../images/00141.jpeg" class="calibre145"/></div>
<p class="calibre2">This can be especially useful on large displays when combined with the use of multiple <span class="calibre5">Viewports</span>. Click the <span class="calibre5">View</span> menu and you can split the screen into multiple views of the space, allowing you to see an object from all sides simultaneously.</p>
<div class="packt_infobox"><span class="calibre24">Note that each of these menu options has a keyboard shortcut associated with it. </span>You can click on <span class="calibre24">Editor</span> <em class="calibre55">|</em> <span class="calibre24">Editor Settings</span> <em class="calibre55">|</em> <span class="calibre24">3D</span> to adjust the 3D navigation and shortcuts to your liking.</div>
<div class="cdpaligncenter1"><img src="../images/00142.jpeg" class="calibre146"/></div>
<p class="calibre2">When using multiple viewports, each can be set to a different perspective so you can see the effect of your actions from multiple directions at the same time:</p>
<div class="cdpaligncenter1"><img src="../images/00143.jpeg" class="calibre147"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding 3D objects</h1>
                
            
            <article>
                
<p class="calibre2">It's time to add your first 3D node. Just as all 2D nodes inherit from <kbd class="calibre12">Node2D</kbd>, which provides properties such as <kbd class="calibre12">position</kbd> and <kbd class="calibre12">rotation</kbd>, 3D nodes inherit from the <kbd class="calibre12">Spatial</kbd> node. Add one to the scene and you'll see the following:</p>
<div class="cdpaligncenter1"><img src="../images/00144.jpeg" class="calibre148"/></div>
<p class="calibre2">That colorful object you see is not the node, but rather a 3D <em class="calibre17">gizmo</em>. Gizmos are tools that allow you to move and rotate objects in space. The three rings control rotation, while the three arrows move (translate) the object along the three axes. Notice that the rings and arrows are color-coded to match the axis colors. The arrows move the object <em class="calibre17">along</em> the respective axis, while the rings rotate the object <em class="calibre17">around</em> a particular axis. There are also three small squares that lock one axis and allow you to move the object in a single plane.</p>
<p class="calibre2">Take a few minutes to experiment and get familiar with the gizmo. Use Undo if you find yourself getting lost.</p>
<p class="calibre2">Sometimes, gizmos get in the way. You can click on the mode icons to restrict yourself to only one type of transformation: move, rotate, or scale:</p>
<p class="mce-root"><img src="../images/00145.jpeg" class="calibre90"/></p>
<p class="calibre2">The <em class="calibre17">Q</em>, <em class="calibre17">W</em>, <em class="calibre17">E</em>, and <em class="calibre17">R</em> keys are shortcuts for these buttons, allowing for quickly changing between modes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Global versus Local Space</h1>
                
            
            <article>
                
<p class="calibre2">By default, the gizmo controls operate in global space. Try rotating the object. No matter how you turn it, the gizmo's movement arrows still point along the axes. Now try this: put the <kbd class="calibre12">Spatial</kbd> node back to its original position and orientation (or delete it and add a new one). Rotate the object around one axis, then click the <span class="calibre5">Local Space Mode (T)</span> button:</p>
<div class="cdpaligncenter1"><img src="../images/00146.jpeg" class="calibre149"/></div>
<p class="calibre2">Observe what happened to the gizmo arrows. They now point along the <em class="calibre17">object's</em> local <em class="calibre17">x</em>/<em class="calibre17">y</em>/<em class="calibre17">z</em> axes and not the world's. When you click and drag them, they will move the object relative to its axes. Switching back and forth between these two modes can make it much easier to place an object exactly where you want it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Transforms</h1>
                
            
            <article>
                
<p class="calibre2">Look at the <span class="calibre5">Inspector</span> for your <kbd class="calibre12">Spatial</kbd> node. Instead of a <span class="calibre5">Position</span> property, you now have <span class="calibre5">Translation</span>, as well as <span class="calibre5">Rotation Degrees</span> and <span class="calibre5">Scale</span>. As you move the object around, observe how these values change. Note that the <span class="calibre5">Translation</span> represents the object's coordinates relative to the origin:</p>
<div class="cdpaligncenter1"><img src="../images/00147.jpeg" class="calibre150"/></div>
<p class="calibre2">You'll also notice a <span class="calibre5">Transform</span><span class="calibre5"> property, which also changes as you move and rotate the object. When you change translation or rotation, you'll notice that the 12 transform quantities will change as well.</span></p>
<p class="calibre2">A full explanation of the math behind transforms is beyond the scope of this book, but in a nutshell, a transform is a <em class="calibre17">matrix</em> that describes an object's translation, rotation, and scale all at once. You briefly used the 2D equivalent in the Space Rocks game earlier in this book, but the concept is more widely applied in 3D.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Transforms in code</h1>
                
            
            <article>
                
<p class="calibre2">When positioning a 3D node via code, you have access to its <kbd class="calibre12">transform</kbd> and <kbd class="calibre12">global_transform</kbd> properties, which are <kbd class="calibre12">Transform</kbd> objects. A <kbd class="calibre12">Transform</kbd> has two sub-properties: <kbd class="calibre12">origin</kbd> and <kbd class="calibre12">basis</kbd>. The <kbd class="calibre12">origin</kbd> represents the body's offset from its parent's origin or the global origin, respectively. The <kbd class="calibre12">basis</kbd> property contains three vectors that define a local coordinate system traveling with the object. Think of the three axis arrows in the gizmo when you are in Local Space mode.</p>
<p class="calibre2">You'll see more about how to use 3D transforms later in this section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Meshes</h1>
                
            
            <article>
                
<p class="calibre2">Just like <kbd class="calibre12">Node2D</kbd>, a <kbd class="calibre12">Spatial</kbd> node has no size or appearance of its own. In 2D, you added a Sprite to assign a texture to the node. In 3D, you need to add a <em class="calibre17">mesh</em>. A mesh is a mathematical description of a shape. It consists of a collection of points, called <em class="calibre17">vertices</em>. These vertices are connected by lines, called <em class="calibre17">edges,</em> and multiple edges (at least three) together make a <em class="calibre17">face</em>:</p>
<div class="cdpaligncenter1"><img src="../images/00148.jpeg" class="calibre151"/></div>
<p class="calibre2">A cube, for example, is composed of eight vertices, twelve edges, and six faces.</p>
<p class="calibre2">If you've ever used 3D design software, this will be very familiar to you. If you haven't, and you're interested in learning about 3D modeling, Blender is a very popular open source tool for designing 3D objects. You can find many tutorials and lessons on the internet to help you get started with Blender.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Importing meshes</h1>
                
            
            <article>
                
<p class="calibre2">Whatever modeling software you may use, you will need to export your models in a format that is readable by Godot. Wavefront (<kbd class="calibre12">.obj</kbd>) and Collada (<kbd class="calibre12">.dae</kbd>) are the most popular. Unfortunately, if you're using Blender, its Collada exporter has some flaws that make it unusable with Godot. To fix this, Godot's developers have created a Blender plugin called <strong class="calibre4">Better Collada Exporter</strong> that <span class="calibre5">you can download from</span> <a href="https://godotengine.org/download" class="calibre9">https://godotengine.org/download</a>.</p>
<p class="calibre2">If your objects are in another format, such as FBX, you'll need to use a converter tool to save them as OBJ or DAE in order to use them with Godot.</p>
<div class="packt_infobox">A new format called GLTF is gaining in popularity and has some significant advantages over Collada. Godot already supports it, so feel free to experiment with any models you may find in this format.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Primitives</h1>
                
            
            <article>
                
<p class="calibre2">If you don't have any models handy, or if you just need a simple model quickly, Godot has the ability to create certain 3D meshes directly. Add a <kbd class="calibre12">MeshInstance</kbd> node as a child of Spatial, and in the <span class="calibre5">Inspector</span>, click the <span class="calibre5">Mesh</span> property:</p>
<div class="cdpaligncenter1">.<img src="../images/00149.jpeg" class="calibre152"/></div>
<p class="calibre2">These predefined shapes are called <em class="calibre17">primitives</em> and they represent a handy collection of common useful shapes. You can use these shapes for a variety of purposes, as you'll see later in this chapter. Select <span class="calibre5">New CubeMesh</span> and you'll see a plain cube appear on the screen. The cube itself is white, but it may appear bluish on your screen due to the default ambient light in the 3D editor window. You'll learn how to work with lighting later in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Multiple meshes</h1>
                
            
            <article>
                
<p class="calibre2">Often, you'll find yourself with an object composed of many different meshes. A character might have separate meshes for its head, torso, and limbs. If you have a great many of these types of objects, it can lead to performance issues as the engine tries to render so many meshes. As a result, <kbd class="calibre12">MultiMeshInstance</kbd> is designed to provide a high-performance method of grouping many meshes together into a single object. You probably don't need it yet, because it won't be necessary for this project, but keep it in mind as a tool that may come in handy later.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Cameras</h1>
                
            
            <article>
                
<p class="calibre2">Try running the scene with your cube mesh. Where is it? In 3D, you won't see anything in the game viewport without using a <kbd class="calibre12">Camera</kbd>. Add one, and use the camera's gizmo to position and point it towards the cube, as in the following screenshot:</p>
<div class="cdpaligncenter1"><img src="../images/00150.jpeg" class="calibre153"/></div>
<p class="calibre2"><span class="calibre5">The pinkish-purple, pyramid-shaped object is called the camera's </span><em class="calibre17">fustrum</em><span class="calibre5">. It represents the camera's view, and can be made narrow or wide to affect the camera's <em class="calibre17">field of view</em>. The triangular arrow at the top of the fustrum is the camera's up direction. </span></p>
<p class="calibre2"><span class="calibre5">As you're moving the camera around, you can use the <span class="calibre5">Preview</span> button in the upper-right to check your aim. <span class="calibre5">Preview</span> will always show you what the selected camera can see.</span></p>
<p class="calibre2">As with the <kbd class="calibre12">Camera2D</kbd> you used earlier, a <kbd class="calibre12">Camera</kbd> must be set as <span class="calibre5">Current</span> for it to be active. Its other properties affect how it <em class="calibre17">sees</em>: field of view, projection, and near/far. The default values of these properties are good for this project, but go ahead and experiment with them to see how they affect the view of the cube. Use Undo to return everything to the default values when you're done.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Project setup</h1>
                
            
            <article>
                
<p class="calibre2">Now that you've learned how to navigate in Godot's 3D editor, you're ready to start on the Minigolf project. As with the other projects, download the <span class="calibre5">game assets from the following link and unzip them in your project folder. The unzipped <kbd class="calibre12">assets</kbd> folder contains images, 3D models, and the other assets you need to complete the project. You can download a Zip file of the art and sounds (collectively known as <em class="calibre17">assets</em>) for the game here, <a href="https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases" class="calibre9">https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases</a>.</span></p>
<p class="calibre2">This game will use the left mouse button as an input. The Input Map does not have any default actions defined for this, so you need to add one. Open <span class="calibre5">Project</span> | <span class="calibre5">Project Settings</span> and go to the <span class="calibre5">Input Map</span> tab. Add a new action called <span class="calibre5">click</span>, then click the plus to add a <span class="calibre5">Mouse Button</span> event to it. Choose <span class="calibre5">Left Button</span>:</p>
<div class="cdpaligncenter1"><img src="../images/00151.jpeg" class="calibre154"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating the course</h1>
                
            
            <article>
                
<p class="calibre2">For the first scene, add a node called <kbd class="calibre12">Main</kbd> to serve as your scene's root. This scene will contain the major parts of the game, starting with the course itself. Start by adding a <kbd class="calibre12">GridMap</kbd> node to lay out the course.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">GridMaps</h1>
                
            
            <article>
                
<p class="calibre2"><kbd class="calibre12">GridMap</kbd> is the 3D equivalent of the <kbd class="calibre12">TileMap</kbd> node you used in earlier projects. It allows you to use a collection of meshes (contained in a <kbd class="calibre12">MeshLibrary</kbd>) and lay them out in a grid to more quickly design an environment. Because it is 3D, you can stack the meshes in any direction, although for this project, you'll stick to the same plane.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Making a MeshLibrary</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">res://assets</kbd> folder contains a pre-generated <kbd class="calibre12">MeshLibrary</kbd> for the project, containing all the necessary course parts along with collision shapes. However, if you need to change it or make your own, you'll find the procedure is very similar to how <kbd class="calibre12">TileSet</kbd> is created in 2D.</p>
<div class="packt_infobox">The scene used to create the pre-generated <kbd class="calibre51">MeshLibrary</kbd> can also be found in the <kbd class="calibre51">res://assets</kbd> folder. Its name is <kbd class="calibre51">course_tiles_edit1.tscn</kbd>. Feel free to open it and look at how it is set up.</div>
<p class="calibre2">Start by making a new scene, with a <kbd class="calibre12">Spatial</kbd> as its root. To this node, add any number of <kbd class="calibre12">MeshInstance</kbd>. You can find the original course meshes, exported from Blender, in the <kbd class="calibre12">res://assets/dae</kbd> folder.</p>
<p class="calibre2">The names you give to these nodes will be their names in the <kbd class="calibre12">MeshLibrary</kbd>.</p>
<p class="calibre2">Once you have added the meshes, they need static collision bodies added to them. Creating collision shapes that match a given mesh can be complicated, but Godot has a method of automatically generating them.</p>
<p class="calibre2">Select a mesh and you'll see a <kbd class="calibre12">Mesh</kbd> menu appear at the top of the editor window:</p>
<div class="cdpaligncenter1"><img src="../images/00152.jpeg" class="calibre155"/></div>
<p class="calibre2">Select <span class="calibre5">Create Trimesh Static Body</span> and Godot will create a <kbd class="calibre12">StaticBody</kbd> and add a <kbd class="calibre12">CollisionShape</kbd> using the mesh's data:</p>
<div class="cdpaligncenter1"><img src="../images/00153.jpeg" class="calibre156"/></div>
<p class="calibre2">Do this with each of your mesh objects, and then select <span class="calibre5">Scene</span> | <span class="calibre5">Convert To</span> | <span class="calibre5">MeshLibrary</span> to save the resource.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Drawing the course</h1>
                
            
            <article>
                
<p class="calibre2">Drag the <kbd class="calibre12">MeshLibrary</kbd> (<kbd class="calibre12">res://assets/course_tiles.tres</kbd> or the one you created) into the <span class="calibre5">Theme</span> property of <kbd class="calibre12">GridMap</kbd> in the <span class="calibre5">Inspector</span>. Also, check that the <span class="calibre5">Cell</span>/<span class="calibre5">Size</span> property is set to <kbd class="calibre12">(2, 2, 2)</kbd>:</p>
<div class="cdpaligncenter1"><img src="../images/00154.jpeg" class="calibre157"/></div>
<p class="calibre2">Try drawing by selecting the tile piece from the list on the right and placing it by left-clicking in the editor window. You can rotate a piece around the y axis by pressing <em class="calibre17">S</em>. To remove a tile, use <em class="calibre17">Shift</em> + right-click.</p>
<p class="calibre2">For now, stick to a simple course; you can get fancy later when everything is working. Don't forget the hole!</p>
<div class="cdpaligncenter1"><img src="../images/00155.jpeg" class="calibre158"/></div>
<p class="calibre2">Now, it's time to see what this is going to look like when the game is run. Add a <kbd class="calibre12">Camera</kbd> to the scene. Move it up and angle it so it looks down on the course. Remember, you can use the Preview button to check what the camera sees.</p>
<p class="calibre2">Run the scene. You'll see that everything seems very dark. By default, there is minimal environmental light in the scene. To see more clearly, you need to add more light.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">WorldEnvironment</h1>
                
            
            <article>
                
<p class="calibre2">Lighting is a complex subject all on its own. Deciding where to place lights and how to set their color and intensity can dramatically affect how a scene looks. </p>
<p class="calibre2">Godot provides three lighting nodes in 3D:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">OmniLight</kbd>: For light that is emitted in all directions, like from a light bulb or candle</li>
<li class="calibre11"><kbd class="calibre12">DirectionalLight</kbd>: Infinite light from a distant source, such as sunlight</li>
<li class="calibre11"><kbd class="calibre12">SpotLight</kbd>: Directional light from a single source, such as a flashlight</li>
</ul>
<p class="calibre2">In addition to using individual lights, you can also set an <em class="calibre17">ambient</em> light using <kbd class="calibre12">WorldEnvironment</kbd>.</p>
<p class="calibre2">Add a <kbd class="calibre12">WorldEnvironment</kbd> node to the scene. In the Inspector, select <span class="calibre5">New Environment</span> in the <span class="calibre5">Environment</span> property. Everything will turn black, but don't worry, you'll fix that soon:</p>
<div class="cdpaligncenter1"><img src="../images/00156.jpeg" class="calibre159"/></div>
<p class="calibre2">Click on <span class="calibre5">New Environment</span> and you'll see a large list of properties. The one you want is <span class="calibre5">Ambient Light</span>. Set <span class="calibre5">Color</span> to white and you'll see your scene become more brightly lit.</p>
<div class="packt_infobox">Keep in mind that ambient light comes from all directions equally. If your scene needs shadows or other light effects, you'll want to use one of the <kbd class="calibre51">Light</kbd> nodes. You'll see how light nodes work later in the chapter.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Finishing the scene</h1>
                
            
            <article>
                
<p class="calibre2">Now that you have the course laid out, two more items remain: the <em class="calibre17">tee,</em> or location where the ball will start, and a way to detect when the ball has entered the hole.</p>
<p class="calibre2">Add a <kbd class="calibre12">Position3D</kbd> node named <kbd class="calibre12">Tee</kbd>. Just like <kbd class="calibre12">Position2D</kbd>, this node is used to mark a location in space. Place this node where you want the ball to start. Make sure you put it just above the surface so that the ball doesn't spawn inside the ground.</p>
<p class="calibre2">To detect the ball entering the hole, you can use an <kbd class="calibre12">Area</kbd> node. This node is directly analogous to the 2D version: it can signal when a body enters its assigned shape. Add an <kbd class="calibre12">Area</kbd> and give it a <kbd class="calibre12">CollisionShape</kbd> child.</p>
<p class="calibre2">In the child's<span class="calibre5"> </span><span class="calibre5">Shape</span> property of the <kbd class="calibre12">CollisionShape</kbd>, add a <kbd class="calibre12">SphereShape</kbd>:</p>
<div class="cdpaligncenter1"><img src="../images/00157.jpeg" class="calibre160"/></div>
<p class="calibre2">To size the collision sphere, use the single radius adjustment handle:</p>
<div class="cdpaligncenter1"><img src="../images/00158.jpeg" class="calibre161"/></div>
<p class="calibre2">Place the <kbd class="calibre12">Area</kbd> just below the hole and size the collision shape so that it overlaps the bottom of the hole. Don't let it project above the top of the hole, or the ball will count as <em class="calibre17">in</em> when it hasn't dropped in yet.</p>
<div class="cdpaligncenter1"><img src="../images/00159.jpeg" class="calibre162"/></div>
<p class="calibre2">You may find it easier to position the node if you use the Perspective button to view the hole from one direction at at time. When you've finished positioning it, change the name of the <kbd class="calibre12">Area</kbd> to <kbd class="calibre12">Hole</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Ball</h1>
                
            
            <article>
                
<p class="calibre2">Now, you're ready to make the ball. Since the ball needs physics—gravity, friction, collision with walls, and other physics properties—<kbd class="calibre12">RigidBody</kbd> will be the best choice of node. Create a new scene with a <kbd class="calibre12">RigidBody</kbd> named <span class="calibre5"><kbd class="calibre12">Ball</kbd>.</span></p>
<p class="calibre2">RigidBody is the 3D equivalent of the <kbd class="calibre12">RigidBody2D</kbd> node you used in <a href="part0079.html#2BASE0-5809b3bef8d2453086d97dfad17b2ee2" class="calibre9">Chapter 3</a>, <em class="calibre17">Escape the Maze</em>. Its behavior and properties are very similar, and you use many of the same methods to interact with it, such as <kbd class="calibre12">apply_impulse()</kbd> and <kbd class="calibre12">_integrate_forces()</kbd>.</p>
<p class="calibre2">The shape of the ball needs to be a sphere. The basic 3D shapes such as sphere, cube, cylinder, and so on are called <em class="calibre17">primitives</em>. Godot can automatically make primitives using the <kbd class="calibre12">MeshInstance</kbd> node, so add one as a child of the body. In the <span class="calibre5">Inspector</span>, choose <span class="calibre5">New SphereMesh</span> in the <span class="calibre5">Mesh</span> property:</p>
<div class="cdpaligncenter1"><img src="../images/00160.jpeg" class="calibre163"/></div>
<p class="calibre2">The default size is much too large, so click on the new sphere mesh and set its size properties, <span class="calibre5">Radius</span> to <kbd class="calibre12">0.15</kbd> and <span class="calibre5">Height</span> to <kbd class="calibre12">0.3</kbd>:</p>
<div class="cdpaligncenter1"><img class="alignnone17" src="../images/00161.jpeg"/></div>
<p class="calibre2">Next, add a <kbd class="calibre12">CollisionShape</kbd> node to the <kbd class="calibre12">Ball</kbd> and give it a <kbd class="calibre12">SphereShape</kbd>. Size it to fit the mesh using the size handle (orange dot):</p>
<div class="cdpaligncenter1"><img src="../images/00162.jpeg" class="calibre164"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing the ball</h1>
                
            
            <article>
                
<p class="calibre2">To test the ball, add it to the <kbd class="calibre12">Main</kbd> scene with the instance button. Position it somewhere above the course and hit Play. You should see the ball fall and land on the ground. You may find it helpful to add another <kbd class="calibre12">Camera</kbd> node positioned on the side of the course for a different view. Set the <span class="calibre5">Current</span> property on whichever camera you want to use.</p>
<p class="calibre2">You can also temporarily give the ball some motion by setting its <span class="calibre5">Linear</span>/<span class="calibre5">Velocity</span> property. Try setting it to different values and playing the scene. Remember that the <em class="calibre17">y</em> axis is up and that using too large a value may cause the ball to go right through the wall. Set it back to <kbd class="calibre12">(0, 0, 0)</kbd> when you're done.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Improving collisions</h1>
                
            
            <article>
                
<p class="calibre2">You may have noticed when adjusting the velocity that the ball sometimes goes straight through the wall and/or bounces oddly, especially if you choose a high value. There are a few adjustments you can make to the <kbd class="calibre12">RigidBody</kbd> properties to improve the collision behavior at high speeds.</p>
<p class="calibre2">First, turn on <strong class="calibre4">Continuous Collision Detection</strong> (<strong class="calibre4">CCD</strong>). You'll find it listed as <span class="calibre5">Continuous Cd</span> in the <span class="calibre5">Inspector</span>. Using CCD alters the way the physics engine calculates collisions. Normally, the engine operates by first moving the object and then testing for and resolving collisions. This is fast, and works in most common situations. When using CCD, however, the engine projects the object's movement along its path and attempts to predict where the collision may occur. This is slower than the default behavior, and so not as efficient, especially when simulating many objects, but it is much more accurate. Since you only have one ball in the game, CCD is a good option because it won't introduce any noticeable performance penalty, but will greatly improve collision detection.</p>
<p class="calibre2">The ball also needs a little more action, so set the <span class="calibre5">Bounce</span> to <kbd class="calibre12">0.2</kbd> and the <span class="calibre5">Gravity Scale</span> to <kbd class="calibre12">2</kbd>.</p>
<p class="calibre2">Finally, you may also have noticed that the ball takes a long time to come to a stop. Set the <span class="calibre5">Linear</span>/<span class="calibre5">Damp</span> property to <kbd class="calibre12">0.5</kbd> and <span class="calibre5">Angular</span>/<span class="calibre5">Damp</span> to <kbd class="calibre12">0.1</kbd> so that you won't have to wait as long for the ball to stop moving.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">UI</h1>
                
            
            <article>
                
<p class="calibre2">Now that the ball is on the course, you need a way to aim and hit the ball. There are a number of possible control schemes for a game of this type. For this project, you'll use a two-step process:</p>
<ol class="calibre14">
<li class="calibre11" value="1">Aim: An arrow will appear swinging back and forth. Clicking the mouse button will set the aim direction to the arrow's.</li>
<li class="calibre11" value="2">Shoot: A power bar will move up and down on the screen. Clicking the mouse will set the power and launch the ball.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Aiming arrow</h1>
                
            
            <article>
                
<p class="calibre2">Drawing an object in 3D is not as easy as it is in 2D. In many cases, you'll have to switch to a 3D modeling program such as Blender to create your game's objects. However, in this case Godot's primitives have you covered; to make an arrow, you just need two meshes: a long, thin rectangle and a triangular prism.</p>
<p class="calibre2">Start a new scene by adding a <kbd class="calibre12">Spatial</kbd> node with a <kbd class="calibre12">MeshInstance</kbd> child. Add a new <kbd class="calibre12">CubeMesh</kbd>. Click on the <span class="calibre5">Mesh</span> property and set the <span class="calibre5">Size</span> property to <kbd class="calibre12">(0.5, 0.2, 2)</kbd>. This is the body of the arrow, but it still has one problem. If you rotate the parent, the mesh rotates around its center. Instead, you need the arrow to rotate around its end, so change the <span class="calibre5">Transform</span>/<span class="calibre5">Translation</span> of <span class="calibre5"><span class="calibre5">MeshInstance</span></span> to <kbd class="calibre12">(0, 0, -1)</kbd>:</p>
<div class="cdpaligncenter1"><img src="../images/00163.jpeg" class="calibre165"/></div>
<p class="calibre2">Try rotating the <kbd class="calibre12">Arrow</kbd> (root) node with the gizmo to confirm that the shape is now offset correctly.</p>
<p class="calibre2">To create the point of the arrow, add another <kbd class="calibre12">MeshInstance</kbd>, and this time choose <span class="calibre5">New PrismMesh</span>. Set its size to <kbd class="calibre12">(1.5, 2, 0.5)</kbd>. You now have a flat triangle shape. To place it properly at the end of the rectangle, change the mesh's <span class="calibre5">Transform</span>/<span class="calibre5">Translation</span> to <kbd class="calibre12">(0, 0, -3)</kbd> and its <span class="calibre5">Rotation Degrees</span> to <kbd class="calibre12">(-90, 0, 0)</kbd>.</p>
<div class="packt_infobox">Using primitives is a quick way to create placeholder objects directly in Godot without having to open up your 3D modeling software.</div>
<p class="calibre2">Finally, scale the whole arrow down by setting the root node's <span class="calibre5">Transform</span>/<span class="calibre5">Scale</span> to <kbd class="calibre12">(0.5, 0.5, 0.5)</kbd>:</p>
<div class="cdpaligncenter1"><img src="../images/00164.jpeg" class="calibre166"/></div>
<p class="calibre2">You now have a completed arrow shape. Save it, then instance it in the <kbd class="calibre12">Main</kbd> scene.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">UI display</h1>
                
            
            <article>
                
<p class="calibre2">Create a new scene with a <span class="calibre5">CanvasLayer</span> called <kbd class="calibre12">UI</kbd>. In this scene, you'll show the power bar as well as the shot count for the player's score. Add a <kbd class="calibre12">MarginContainer</kbd>, <kbd class="calibre12">VBoxContainer</kbd>, two <kbd class="calibre12">Label</kbd> properties, and a <kbd class="calibre12">TextureProgress</kbd>. Name them as shown:</p>
<div class="cdpaligncenter1"><img src="../images/00165.jpeg" class="calibre167"/></div>
<p class="calibre2">Set the <span class="calibre5">Custom Constants</span> of <kbd class="calibre12"><span>MarginContainer</span></kbd> all to <kbd class="calibre12">20</kbd>. Add the <kbd class="calibre12">Xolonium-Regular.ttf</kbd> font to both of the <kbd class="calibre12">Label</kbd> nodes and set their font sizes to <kbd class="calibre12">30</kbd>. Set the <kbd class="calibre12">Shots</kbd> label's <span class="calibre5">Text</span> to <span class="calibre5">Shots: 0</span> and the <kbd class="calibre12">Label</kbd> <span class="calibre5">Text</span> to <span class="calibre5">Power</span>. Drag one of the colored bar textures from <kbd class="calibre12">res://assets</kbd> into the <span class="calibre5">Texture</span>/<span class="calibre5">Progress</span> of <kbd class="calibre12"><span>PowerBar</span></kbd>. By default, <kbd class="calibre12">TextureProgress</kbd> bars grow from left to right, so for a vertical orientation, change the <span class="calibre5">Fill Mode</span> to <span class="calibre5">Bottom to Top</span>.</p>
<p class="calibre2">The completed UI layout should look like this:</p>
<div class="cdpaligncenter1"><img src="../images/00166.jpeg" class="calibre168"/></div>
<p class="calibre2">Instance this scene in the <kbd class="calibre12">Main</kbd> scene. Because it's a CanvasLayer, it will be drawn on top of the 3D camera view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scripts</h1>
                
            
            <article>
                
<p class="calibre2">In this section, you'll create the scripts needed to make everything work together. The flow of the game will be as follows:</p>
<ol class="calibre14">
<li value="1" class="calibre11">Place the ball at the start (<kbd class="calibre12">Tee</kbd>)</li>
<li value="2" class="calibre11">Angle mode: Aim the ball</li>
<li value="3" class="calibre11">Power mode: Set the hit power</li>
<li value="4" class="calibre11">Launch the ball</li>
<li value="5" class="calibre11">Repeat from step 2 until the ball is in the hole</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">UI</h1>
                
            
            <article>
                
<p class="calibre2">Add the following script to the <kbd class="calibre12">UI</kbd> to update the UI elements:</p>
<pre class="calibre18">extends CanvasLayer<br class="title-page-name"/><br class="title-page-name"/>var bar_red = preload("res://assets/bar_red.png")<br class="title-page-name"/>var bar_green = preload("res://assets/bar_green.png")<br class="title-page-name"/>var bar_yellow = preload("res://assets/bar_yellow.png")<br class="title-page-name"/><br class="title-page-name"/>func update_shots(value):<br class="title-page-name"/>    $Margin/Container/Shots.text = 'Shots: %s' % value<br class="title-page-name"/><br class="title-page-name"/>func update_powerbar(value):<br class="title-page-name"/>    $Margin/Container/PowerBar.texture_progress = bar_green<br class="title-page-name"/>    if value &gt; 70:<br class="title-page-name"/>        $Margin/Container/PowerBar.texture_progress = bar_red<br class="title-page-name"/>    elif value &gt; 40:<br class="title-page-name"/>        $Margin/Container/PowerBar.texture_progress = bar_yellow<br class="title-page-name"/>    $Margin/Container/PowerBar.value = value</pre>
<p class="calibre2">The two functions provide a way to update the UI elements when they need to display a new value. As you did in the Space Rocks game, changing the progress bar's texture based on its size gives a nice high/medium/low feel to the power level.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Main</h1>
                
            
            <article>
                
<p class="calibre2">Next, add a script to <kbd class="calibre12">Main</kbd> and start with these variables:</p>
<pre class="calibre18">extends Node<br class="title-page-name"/><br class="title-page-name"/>var shots = 0<br class="title-page-name"/>var state<br class="title-page-name"/>var power = 0<br class="title-page-name"/>var power_change = 1<br class="title-page-name"/>var power_speed = 100<br class="title-page-name"/>var angle_change = 1<br class="title-page-name"/>var angle_speed = 1.1<br class="title-page-name"/>enum {SET_ANGLE, SET_POWER, SHOOT, WIN}</pre>
<p class="calibre2">The <kbd class="calibre12">enum</kbd> lists the states the game can be in, while the <kbd class="calibre12">power*</kbd> and <kbd class="calibre12">angle*</kbd> variables will be used to set their respective values and change them over time. Take a look at the following code snippet:</p>
<pre class="calibre18">func _ready():<br class="title-page-name"/>    $Arrow.hide()<br class="title-page-name"/>    $Ball.transform.origin = $Tee.transform.origin<br class="title-page-name"/>    change_state(SET_ANGLE)</pre>
<p class="calibre2">At the beginning, the ball is placed at the location of the <kbd class="calibre12">Tee</kbd> using both bodies' <kbd class="calibre12">transform.origin</kbd> properties. Then, the game is put into the <kbd class="calibre12">SET_ANGLE</kbd> state: </p>
<pre class="calibre18">func change_state(new_state):<br class="title-page-name"/>    state = new_state<br class="title-page-name"/>    match state:<br class="title-page-name"/>        SET_ANGLE:<br class="title-page-name"/>            $Arrow.transform.origin = $Ball.transform.origin<br class="title-page-name"/>            $Arrow.show()<br class="title-page-name"/>        SET_POWER:<br class="title-page-name"/>            pass<br class="title-page-name"/>        SHOOT:<br class="title-page-name"/>            $Arrow.hide()<br class="title-page-name"/>            $Ball.shoot($Arrow.rotation.y, power)<br class="title-page-name"/>            shots += 1<br class="title-page-name"/>            $UI.update_shots(shots)<br class="title-page-name"/>        WIN:<br class="title-page-name"/>            $Ball.hide()<br class="title-page-name"/>            $Arrow.hide()</pre>
<p class="calibre2">The <kbd class="calibre12">SET_ANGLE</kbd> state places the arrow at the ball's location. Recall that you offset the arrow, so it will appear to be pointing out from the ball. When rotating the arrow, you rotate it around the <em class="calibre17">y</em> axis so that it remains flat (the <em class="calibre17">y</em> axis points upwards).</p>
<p class="calibre2">Also, note that when entering the <kbd class="calibre12">SHOOT</kbd> state, you call the <kbd class="calibre12">shoot()</kbd> function on the <kbd class="calibre12">Ball</kbd>. You'll add that function in the next section.</p>
<p class="calibre2">The next step is to check for user input:</p>
<pre class="calibre18">func _input(event):<br class="title-page-name"/>    if event.is_action_pressed('click'):<br class="title-page-name"/>        match state:<br class="title-page-name"/>            SET_ANGLE:<br class="title-page-name"/>                change_state(SET_POWER)<br class="title-page-name"/>            SET_POWER:<br class="title-page-name"/>                change_state(SHOOT)</pre>
<p class="calibre2">The only input for the game is clicking the left mouse button. Depending on what state you're in, clicking it will transition to the next state:</p>
<pre class="calibre18">func _process(delta):<br class="title-page-name"/>    match state:<br class="title-page-name"/>        SET_ANGLE:<br class="title-page-name"/>            animate_angle(delta)<br class="title-page-name"/>        SET_POWER:<br class="title-page-name"/>            animate_power_bar(delta)<br class="title-page-name"/>        SHOOT:<br class="title-page-name"/>            pass</pre>
<p class="calibre2">In <kbd class="calibre12">_process()</kbd>, you determine what to animate based on the state. For now, it just calls the function that animates the property that's currently being set:</p>
<pre class="calibre18">func animate_power_bar(delta):<br class="title-page-name"/>    power += power_speed * power_change * delta<br class="title-page-name"/>    if power &gt;= 100:<br class="title-page-name"/>        power_change = -1<br class="title-page-name"/>    if power &lt;= 0:<br class="title-page-name"/>        power_change = 1<br class="title-page-name"/>    $UI.update_powerbar(power)<br class="title-page-name"/><br class="title-page-name"/>func animate_angle(delta):<br class="title-page-name"/>    $Arrow.rotation.y += angle_speed * angle_change * delta<br class="title-page-name"/>    if $Arrow.rotation.y &gt; PI/2:<br class="title-page-name"/>        angle_change = -1<br class="title-page-name"/>    if $Arrow.rotation.y &lt; -PI/2:<br class="title-page-name"/>        angle_change = 1</pre>
<p class="calibre2">Both of these functions are similar. They gradually change a value between two extremes, reversing direction when a limit is hit. Note that the arrow is animating over a +/- 90-degree arc.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Ball</h1>
                
            
            <article>
                
<p class="calibre2">In the ball script, there are two functions needed. First, an impulse must be applied to the ball to launch it. Second, when the ball stops moving, it needs to notify the <kbd class="calibre12">Main</kbd> scene so that the player can take another shot:</p>
<pre class="calibre18">extends RigidBody<br class="title-page-name"/><br class="title-page-name"/>signal stopped<br class="title-page-name"/><br class="title-page-name"/>func shoot(angle, power):<br class="title-page-name"/>    var force = Vector3(0, 0, -1).rotated(Vector3(0, 1, 0), angle)<br class="title-page-name"/>    apply_impulse(Vector3(), force * power / 5)<br class="title-page-name"/><br class="title-page-name"/>func _integrate_forces(state):<br class="title-page-name"/>    if state.linear_velocity.length() &lt; 0.1:<br class="title-page-name"/>        emit_signal("stopped")<br class="title-page-name"/>        state.linear_velocity = Vector3()</pre>
<p class="calibre2">As you saw in the Space Rocks game, you can use the physics state in <kbd class="calibre12">_integrate_forces()</kbd> to safely stop the ball if the speed has gotten too slow. Remember, due to floating point number precision, the velocity may not actually slow to <kbd class="calibre12">0</kbd> on its own. The ball may appear to be stopped, but its velocity may actually be something like <kbd class="calibre12">0.0000001</kbd> instead. Rather than wait for it to reach <kbd class="calibre12">0</kbd>, you can make the ball stop if its speed drops below <kbd class="calibre12">0.1</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Hole</h1>
                
            
            <article>
                
<p class="calibre2">To detect when the ball has dropped into the hole, click on the <kbd class="calibre12">Area</kbd> in <kbd class="calibre12">Main</kbd> and connect its <kbd class="calibre12">body_entered</kbd> signal:</p>
<pre class="calibre18">func _on_Hole_body_entered(body):<br class="title-page-name"/>    print("Win!")<br class="title-page-name"/>    change_state(WIN)</pre>
<p class="calibre2">Changing to the <kbd class="calibre12">WIN</kbd> state will prevent the ball's <kbd class="calibre12">stopped</kbd> signal from allowing another shot.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing it out</h1>
                
            
            <article>
                
<p class="calibre2">Try running the game. You may want to make sure you have a very easy course with a straight shot to the hole for this part. You should see the arrow rotating at the ball's position. When you click the mouse button, the arrow stops, and the power bar starts moving up and down. When you click a second time, the ball is launched.</p>
<p class="calibre2">If any of those steps don't work, don't go any further, but stop and go back to try and find what you missed.</p>
<p class="calibre2">Once everything is working, you'll notice some areas that need improvement. First, when the ball stops moving the arrow may not point in the direction you want. The reason for this is that the starting angle is always <kbd class="calibre12">0</kbd>, which points along the <em class="calibre17">z</em> axis, and then the arrow swings +/- 90 degrees from there. <span class="calibre5">In the next sections, you'll have the option of improving the aiming in two ways. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Improving aiming – option 1</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre5">The aim could be improved by making the 180-degree swing of the arrow always begin by pointing towards the hole.</span></p>
<p class="calibre2">Add a variable called <kbd class="calibre12">hole_dir</kbd> to the <kbd class="calibre12">Main</kbd> script. At the start of aiming, this will be set to the angle pointing towards the hole using the following function:</p>
<pre class="calibre18">func set_start_angle():<br class="title-page-name"/>    var hole_pos = Vector2($Hole.transform.origin.z, $Hole.transform.origin.x)<br class="title-page-name"/>    var ball_pos = Vector2($Ball.transform.origin.z, $Ball.transform.origin.x)<br class="title-page-name"/>    hole_dir = (ball_pos - hole_pos).angle()<br class="title-page-name"/>    $Arrow.rotation.y = hole_dir</pre>
<p class="calibre2">Remember that the ball's position is its center, so it's slightly above the surface, while the hole's center is somewhat below. Because of this, an arrow pointing directly between them would point at a downward angle into the ground. To prevent this and keep the arrow level, you can use only the <em class="calibre17">x</em> and <em class="calibre17">z</em> values from the <kbd class="calibre12">transform.origin</kbd> to produce a <kbd class="calibre12">Vector2</kbd>.</p>
<p class="calibre2">Now the initial arrow direction is towards the hole, so you can alter the animation to add +/-90 degrees to that angle:</p>
<pre class="calibre18">func animate_angle(delta):<br class="title-page-name"/>    $Arrow.rotation.y += angle_speed * angle_change * delta<br class="title-page-name"/>    if $Arrow.rotation.y &gt; hole_dir + PI/2:<br class="title-page-name"/>        angle_change = -1<br class="title-page-name"/>    if $Arrow.rotation.y &lt; hole_dir - PI/2:<br class="title-page-name"/>        angle_change = 1</pre>
<p class="calibre2">Lastly, change the <kbd class="calibre12">SET_ANGLE</kbd> state to call the function:</p>
<pre class="calibre18">SET_ANGLE:<br class="title-page-name"/>    $Arrow.transform.origin = $Ball.transform.origin<br class="title-page-name"/>    $Arrow.show()<br class="title-page-name"/>    set_start_angle()</pre>
<p class="calibre2">Try the game again. The ball should now always point in the general direction of the hole. This is better, but you still can't point in any direction you like. For that, you can try aiming option 2.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Improving aiming – option 2</h1>
                
            
            <article>
                
<p class="calibre2">The previous solution is acceptable, but there is another possibility. Instead of the arrow bouncing back and forth, you can aim by moving the mouse side-to-side. The benefit of this option is that you're not limited to 180 degrees of motion.</p>
<p class="calibre2">To accomplish this, you can make use of a particular input event: <kbd class="calibre12">InputEventMouseMotion</kbd>. This event occurs when the mouse moves, and returns with it a <kbd class="calibre12">relative</kbd> property representing how far the mouse moved in the previous frame. You can use this value to rotate the arrow by a small amount.</p>
<p class="calibre2">First, disable the arrow animation by removing the <kbd class="calibre12">SET_ANGLE</kbd> portion from <kbd class="calibre12">_process()</kbd>. Next, add the following code to <kbd class="calibre12">_input()</kbd>:</p>
<pre class="calibre18">func _input(event):<br class="title-page-name"/>    if event is InputEventMouseMotion:<br class="title-page-name"/>        if state == SET_ANGLE:<br class="title-page-name"/>            $Arrow.rotation.y -= event.relative.x / 150</pre>
<p class="calibre2">This sets the arrow's rotation as you move the mouse left/right on the screen. Dividing by <kbd class="calibre12">150</kbd> ensures that the movement isn't too fast and that you can move a full 360 degrees if you move the mouse all the way from one side of the screen to the other. Depending on your mouse's sensitivity, you can adjust this to your preference.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Camera improvements</h1>
                
            
            <article>
                
<p class="calibre2">Another problem, especially if you have a relatively large course, is that if your camera is placed to show the starting area near the tee, it may not show the other parts of the course well, or at all. This can make it challenging to aim when the ball is in certain places.</p>
<p class="calibre2">In this section, you'll learn two different ways to address this problem. One involves creating multiple cameras and activating whichever one is closer to the ball's position. The other solution is to create an <em class="calibre17">orbiting</em> camera that follows the ball and that the player can control to view the course from any angle.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Multiple cameras</h1>
                
            
            <article>
                
<p class="calibre2">Add a second <kbd class="calibre12">Camera</kbd> node and position it near the hole or at the opposite end of your course, for example:</p>
<div class="cdpaligncenter1"><img src="../images/00167.jpeg" class="calibre169"/></div>
<p class="calibre2">Add an <kbd class="calibre12">Area</kbd> child to this second camera. Name it <kbd class="calibre12">Camera2Area</kbd> and then add a <kbd class="calibre12">CollisionShape</kbd>. You could use a spherical shape just as well, but for this example, choose a <kbd class="calibre12">BoxShape</kbd>. Note that because you've rotated the camera, the box is rotated as well. You can reverse this by setting the rotation of <kbd class="calibre12"><span>CollisionShape</span></kbd> to the opposite value, or you can leave it rotated. Either way, adjust the size and position of the box to cover the portion of the course you want the camera to be responsible for:</p>
<div class="cdpaligncenter1"><img src="../images/00168.jpeg" class="calibre170"/></div>
<p class="calibre2">Now, connect the area's <kbd class="calibre12">body_entered</kbd> signal to the main script. When the ball enters the area, the signal will be emitted, and you can change the active camera:</p>
<pre class="calibre18">func _on_Cam2Area_body_entered(body):<br class="title-page-name"/>    $Camera2.current = true</pre>
<p class="calibre2">Play the game again and hit the ball toward the new camera area. Confirm that the camera view changes when the ball enters the area. For a large course, you can add as many cameras as you want/need and set them to activate for different sections of the course.</p>
<p class="calibre2">The drawback of this method is that the cameras are still static. Unless you've very carefully placed them in the right positions, it still may not be comfortable to aim the ball from some locations on the course.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Orbiting camera</h1>
                
            
            <article>
                
<p class="calibre2">In many 3D games, the player can control a camera that rotates and moves as desired. Typically, the control scheme uses a combination of mouse and keyboard. The first step will be to add some new input actions:</p>
<div class="cdpaligncenter1"><img src="../images/00169.jpeg" class="calibre171"/></div>
<p class="calibre2">The WASD keys will be used to orbit the camera by moving it side to side and up and down. The mouse wheel will control zooming in/out.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a gimbal</h1>
                
            
            <article>
                
<p class="calibre2">The camera movement needs to have some restrictions. For one, it should always remain level, and not be tilted side to side. Try this: take a camera and rotate it a small amount around x (red ring), then a small amount around <em class="calibre17">z</em> (blue ring). Now, reverse the <em class="calibre17">x</em> rotation and click the Preview button. Do you see how the camera is now tilted? </p>
<p class="calibre2">The solution to this problem is to place the camera on a <em class="calibre17">gimbal—</em>a device designed to keep an object level during movement. You can create a gimbal using two <kbd class="calibre12">Spatial</kbd> nodes, which will control the camera's left/right and up/down movement respectively.</p>
<p class="calibre2">First, make sure to remove any other <kbd class="calibre12">Camera</kbd> nodes in the scene. If you tried the multiple camera setup from the previous section and you'd rather not delete them, you can set their <span class="calibre5">Current</span> values to <span class="calibre5">Off</span> and <span class="calibre5">disconnect </span>any <kbd class="calibre12">Area</kbd> signals for them.</p>
<p class="calibre2">Add a new <kbd class="calibre12">Spatial</kbd> node called <kbd class="calibre12">GimbalOut</kbd> and place it near the center of the course. Make sure not to rotate it. Give it a <kbd class="calibre12">Spatial</kbd> child called <kbd class="calibre12">GimbalIn</kbd>, and then add a <kbd class="calibre12">Camera</kbd> to that node. Set the <span class="calibre5">Transform</span>/<span class="calibre5">Translation</span> of <span class="calibre5">Camera</span> to <kbd class="calibre12">(0, 0, 10)</kbd>:</p>
<div class="cdpaligncenter1"><img src="../images/00170.jpeg" class="calibre25"/></div>
<p class="calibre2">Here's how the gimbal works: the outer spatial is allowed to rotate <em class="calibre17">only</em> in <em class="calibre17">y</em>, while the inner one rotates <em class="calibre17">only</em> in <em class="calibre17">x</em>. You can try it yourself, but make sure you change to <span class="calibre5">Local Space Mode</span> (see the <em class="calibre17">Introduction to 3D</em> section). Remember to only move the <em class="calibre17">green</em> ring of the outer gimbal node and only the <em class="calibre17">red</em> ring of the inner one. Don't change the camera at all. Reset all the rotations to <kbd class="calibre12">0</kbd> once you've finished experimenting.</p>
<p class="calibre2">To control this motion in the game, attach a script to <kbd class="calibre12">GimbalOut</kbd> and add the following:</p>
<pre class="calibre18"><br class="title-page-name"/>extends Spatial<br class="title-page-name"/><br class="title-page-name"/>var cam_speed = PI/2<br class="title-page-name"/>var zoom_speed = 0.1<br class="title-page-name"/>var zoom = 0.5<br class="title-page-name"/><br class="title-page-name"/>func _input(event):<br class="title-page-name"/>    if event.is_action_pressed('cam_zoom_in'):<br class="title-page-name"/>        zoom -= zoom_speed<br class="title-page-name"/>    if event.is_action_pressed('cam_zoom_out'):<br class="title-page-name"/>        zoom += zoom_speed<br class="title-page-name"/><br class="title-page-name"/>func _process(delta):<br class="title-page-name"/>    zoom = clamp(zoom, 0.1, 2)<br class="title-page-name"/>    scale = Vector3(1, 1, 1) * zoom<br class="title-page-name"/>    if Input.is_action_pressed('cam_left'):<br class="title-page-name"/>        rotate_y(-cam_speed * delta)<br class="title-page-name"/>    if Input.is_action_pressed('cam_right'):<br class="title-page-name"/>        rotate_y(cam_speed * delta)<br class="title-page-name"/>    if Input.is_action_pressed('cam_up'):<br class="title-page-name"/>        $GimbalIn.rotate_x(-cam_speed * delta)<br class="title-page-name"/>    if Input.is_action_pressed('cam_down'):<br class="title-page-name"/>        $GimbalIn.rotate_x(cam_speed * delta)<br class="title-page-name"/>    $GimbalIn.rotation.x = clamp($GimbalIn.rotation.x, -PI/2, -0.2)</pre>
<p class="calibre2">As you can see, the left/right actions rotate <kbd class="calibre12">GimbalOut</kbd> only on the <em class="calibre17">y</em> axis, while the up/down actions rotate <kbd class="calibre12">GimbalIn</kbd> on the <em class="calibre17">x</em> axis. The entire gimbal system's <kbd class="calibre12">scale</kbd> property is used to handle zooming. It is also necessary to set some limits using <kbd class="calibre12">clamp()</kbd>. The rotation limit holds up/down movement between <kbd class="calibre12">-0.2</kbd> (almost level with the ground) to <kbd class="calibre12">-90</kbd> degrees (looking straight down) while the zoom limit keeps you from getting too close or too far away.</p>
<p class="calibre2">Run the game and test the camera controls. You should be able to pan in all four directions and zoom with your mouse wheel. However, the gimbal's position is still static, so you may have trouble seeing the ball properly from certain angles.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Tracking camera</h1>
                
            
            <article>
                
<p class="calibre2">There is one final improvement to the camera: making it follow the ball. Now that you have a stable, gimbaled camera, it will work great if the gimbal is set to follow the ball's position. Add this line to the <kbd class="calibre12">Main</kbd> scene's <kbd class="calibre12">_process()</kbd> function:</p>
<pre class="calibre18">$GimbalOut.transform.origin = $Ball.transform.origin</pre>
<p class="calibre2">Note that you shouldn't set the gimbal's transform to the ball's transform, or it will also <em class="calibre17">rotate</em> as the ball rolls!</p>
<p class="calibre2">Try the game now and observe how the camera tracks the ball's movement while still being able to rotate and zoom.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Visual effects</h1>
                
            
            <article>
                
<p class="calibre2">The appearance of the ball and the other meshes in your scene have been intentionally left very plain. You can think of the flat, white ball like a blank canvas, ready to be molded and shaped the way you want it. Applying graphics to 3D models can be a very complex process, especially if you're not familiar with it. First, a bit of vocabulary:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Textures</strong>: Textures are flat, 2D images that are <em class="calibre20">wrapped</em> around 3D objects to give them more interesting appearances. Imagine wrapping a present: the flat paper is folded around the package, conforming to its shape. Textures can be very simple or quite complex depending on the shape they are designed to be applied to. An example of a simple one would be a small pattern of bricks that can be repeated on a large wall object.</li>
</ul>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Shaders</strong>: While textures determine <em class="calibre20">what</em> <span>is drawn on an object's surface, shaders determine </span><em class="calibre20">how</em> <span>it is drawn. Imagine that same brick wall. How would it look if it were wet? The mesh and the texture would still be the same, but the way the light reflects from it would be quite different. This is the function of shaders: to alter the appearance of an object without actually changing it. </span>Shaders are typically written in a specialized programming language and can use a great deal of advanced math, the details of which are beyond the scope of this book. For many effects, writing your own shader is unavoidable. However, Godot provides an alternative method of creating a shader for your object that allows for a great deal of customization without diving into shader code: <kbd class="calibre12">ShaderMaterial</kbd><span>.</span></li>
</ul>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Materials</strong>: Godot uses a computer graphics model called <strong class="calibre1">Physically Based Rendering</strong> (<strong class="calibre1"><span>PBR</span></strong>). The goal of PBR is to render the surface of objects in a way that more accurately models the way light works in the real world. These affects are applied to meshes using the <kbd class="calibre12">Material</kbd> <span>property. </span>Materials are essentially containers for textures and shaders. Rather than apply them individually, they are contained in the material, which is then added to the object. The material's properties determine how the textures and shader effects are applied. Using Godot's built-in material properties, you can simulate a wide range of realistic (or stylized) real-world physical materials, such as stone, cloth, or metal. If the built-in properties aren't enough for your purposes, you can write your own shader code to add even more effects.</li>
</ul>
<p class="calibre2">You can add a PBR material to a mesh using a <kbd class="calibre12">SpatialMaterial</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">SpatialMaterials</h1>
                
            
            <article>
                
<p class="calibre2">Click on the ball's <kbd class="calibre12">MeshInstance</kbd> and, under <span class="calibre5">Material</span>, select <span class="calibre5">New SpatialMaterial</span>, then click the new material. You will see a great number of parameters, far more than can be covered in this book. This section will focus on some of the most useful ones for making the ball look more appealing. You are encouraged to visit <a href="http://docs.godotengine.org/en/3.0/tutorials/3d/spatial_material.html" class="calibre9">http://docs.godotengine.org/en/3.0/tutorials/3d/spatial_material.html</a> for a full explanation of all the <kbd class="calibre12">SpatialMaterial</kbd> settings. To improve the look of the ball, try experimenting with these parameters:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Albedo</strong>: This property sets the base color of the material. Change this to make the ball whatever color you like. If you're working with an object that needs a texture to be applied, you can add it here as well. </li>
</ul>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Metallic and Roughness</strong>: These parameters control how reflective the surface is. Both can be set to values between <kbd class="calibre12">0</kbd> <span>and</span> <kbd class="calibre12">1</kbd><span>. The </span>Metallic <span>value controls the <em class="calibre20">shininess</em>; higher values will reflect more light. The </span><em class="calibre20">Roughness</em> <span>value applies an amount of blur to the reflection. You can simulate a wide variety of materials by adjusting these two properties. </span>The following is a guide to how the <em class="calibre20">Roughness</em> <span>and </span><em class="calibre20">Metallic</em> <span>properties affect the appearance of an object. Keep in mind that lighting and other factors will alter the surface appearance as well. Understanding how light and reflections interact with surface properties is a big part of learning to design effective 3D objects:</span></li>
</ul>
<div class="cdpaligncenter1"><img src="../images/00171.jpeg" class="alignnone2"/></div>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Normal Map</strong>: Normal mapping <span>is a 3D graphics technique for <em class="calibre20">faking</em> the appearance of bumps and dents in a surface. Modeling these in the mesh itself would result in a large increase in the number of polygons, or faces, making up the object, leading to reduced performance. Instead, a 2D texture is used that maps the pattern of light and shadow that would result from these small surface features. The lighting engine then uses that information to alter the lighting as if those details were actually there. A properly constructed normal map can add a great amount of detail to an otherwise bland-looking object.</span></li>
</ul>
<p class="calibre2">The ball is a perfect example of a good use of normal mapping because a real golf ball has hundreds of dimples on its surface, but the sphere primitive is a smooth surface. Using a regular texture could add spots, but they would look flat and painted on. A normal map that would simulate those dimples looks like this:</p>
<div class="cdpaligncenter1"><img src="../images/00172.jpeg" class="calibre172"/></div>
<p class="calibre2">It doesn't look like much, but the pattern of red and blue contains information telling the engine which direction it should assume the surface is facing at that point and therefore which direction light should reflect from it there. Note the stretching along the top and the bottom—that's because this image is made to be wrapped around a sphere shape.</p>
<p class="calibre2">Enable the <span class="calibre5">Normal Map</span> property and drag <kbd class="calibre12">res://assets/ball_normal_map.png</kbd> into the <em class="calibre17">Texture</em> field. Try this with the <em class="calibre17">Albedo</em> color set to white at first, so you can best see the effect. Adjust the <kbd class="calibre12">Depth</kbd> parameter to increase or decrease the strength of the effect. A negative value will make the dimples look inset; something between <kbd class="calibre12">-1.0</kbd> and <kbd class="calibre12">-1.5</kbd> is a good value:</p>
<div class="cdpaligncenter1"><img src="../images/00173.jpeg" class="calibre173"/></div>
<p class="calibre2">Take some time to experiment with these settings and find a combination you like. Don't forget to try it in the game as well, as the ambient lighting of the <kbd class="calibre12">WorldEnvironment</kbd> will effect the final result.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Environment options</h1>
                
            
            <article>
                
<p class="calibre2">When you added the WorldEnvironment, the only parameter you changed was the <em class="calibre17">Ambient Light</em> color. In this section, you'll learn about some of the other properties you can adjust for improved visual appeal:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Background</strong>: This parameter lets you specify what the background of the world looks like. The default value is Clear Color, which is the plain grey you see currently. Change the <span>Mode</span> <span>to <span>Sky</span> and, in the </span><span>Sky</span> <span>property, choose <span>New Procedural Sky</span>. Note that the sky is not just for background appearance—objects will reflect and absorb its ambient light. Observe how the ball's appearance changes as you change the </span><kbd class="calibre12">Energy</kbd> <span><span>parameter. This setting can be used to give the impression of a day or night sky, or even that of an alien planet.</span></span></li>
</ul>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Screen Space Ambient Occlusion</strong> (<strong class="calibre1">SSAO</strong>): When enabled, this parameter works together with any ambient light to produce shadows in corners. You have two sources of ambient light now: the <em class="calibre20">Background</em> <span>(sky) and the </span><em class="calibre20">Ambient Light</em> <span>settings. Enable SSAO and you'll immediately see an improvement, making the walls of the course look much less fake and plastic. </span>Feel free to try adjusting the various SSAO properties, but remember, a small change can make a big difference. Adjust the properties in small increments, and observe the effects before changing them further.</li>
</ul>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">DOF Far Blur</strong>: <em class="calibre20">Depth of Field</em> <span>adds a blur effect to objects that are above a certain distance from the camera. Try adjusting the </span><span>Distance</span> <span>property to see the effect.</span></li>
</ul>
<p class="calibre2">For more information about advanced usage of environmental effects, see <a href="http://docs.godotengine.org/en/3.0/tutorials/3d/environment_and_post_processing.html" class="calibre9">http://docs.godotengine.org/en/3.0/tutorials/3d/environment_and_post_processing.html</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Lighting</h1>
                
            
            <article>
                
<p class="calibre2">Add a <kbd class="calibre12">DirectionalLight</kbd> to the scene. This type of light simulates an infinite number of parallel rays of light, so it's often used to represent sunlight or another very distant source of light that illuminates an entire area equally. The location of the node in the scene doesn't matter, only its direction, so you can position it anywhere you like. Aim it using the gizmo so that it strikes the course at an angle, then turn <span class="calibre5">Shadow</span>/<span class="calibre5">Enabled</span> to <span class="calibre5">On</span> so that you'll see shadows being cast from the walls and other objects:</p>
<div class="cdpaligncenter1"><img src="../images/00174.jpeg" class="calibre25"/></div>
<p class="calibre2">There are a number of properties available to adjust and alter the appearance of the shadows, both in the <em class="calibre17">Shadow</em> section, which is present for all <kbd class="calibre12">Light</kbd> nodes, and in the <em class="calibre17">Directional Shadow</em> section, which is specific to <kbd class="calibre12">DirectionalLight</kbd>. The default values will work for most general cases, but the one property that you should probably adjust to improve shadow appearance is <em class="calibre17">Max Distance</em>. Lowering this value will improve shadow appearance, but only when the camera is closer than the given distance. If your camera will mostly be close to objects, you can reduce this value. To see the effect, try setting it to just <kbd class="calibre12">10</kbd> and zooming in/out, then do the same with it set to <kbd class="calibre12">1000</kbd>.</p>
<p class="calibre2">Directional light can even be used to simulate the day/night cycle. If you attach a script to the light and slowly rotate it around one axis, you'll see the shadows change as if the sun is rising and setting.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">This chapter introduced you to the world of 3D graphics. One of Godot's great strengths is that the same tools and workflow are used in both 2D and 3D. Everything you learned about the process of creating scenes, instancing, and using signals works in the same way. For example, an interface you build with control nodes for a 2D game can be dropped into a 3D game and will work just the same.</p>
<p class="calibre2">In this chapter, you learned how to navigate in the the 3D editor to view and place nodes using gizmos.You learned about meshes and how to quickly make your own objects using Godot's primitives. You used GridMap to lay out your minigolf course. You learned about using cameras, lighting, and the world environment to design how your game will appear on screen. Finally, you got a taste of using PBR rendering via Godot's SpatialMaterial resource.</p>
<p class="calibre2">Congratulations, you've made it to the end! But with these five projects, your journey to becoming a game developer has just begun. As you become more proficient with Godot's features, you'll be able to make any game you can imagine.</p>


            </article>

            
        </section>
    </body></html>