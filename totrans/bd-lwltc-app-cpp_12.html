<html><head></head><body>
<div id="_idContainer086">
<h1 class="chapter-number" id="_idParaDest-297"><a id="_idTextAnchor310"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-298"><a id="_idTextAnchor311"/><span class="koboSpan" id="kobo.2.1">Analyzing and Optimizing the Performance of Our C++ System</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will analyze the performance of our electronic trading ecosystem based on the measurements we added in the previous chapter, </span><em class="italic"><span class="koboSpan" id="kobo.4.1">Adding instrumentation and measuring performance</span></em><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">Using the insights we develop about the performance of our trading systems based on this analysis, we will learn what areas to focus on in terms of potential performance bottlenecks and what areas we can improve. </span><span class="koboSpan" id="kobo.5.3">We will discuss tips and techniques for optimizing our C++ trading ecosystem. </span><span class="koboSpan" id="kobo.5.4">Finally, we will think about the future of our electronic trading ecosystem and what enhancements can be made in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">the future.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Analyzing the performance of our </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">trading ecosystem</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Discussing tips and techniques for optimizing our C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">trading system</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Thinking about the future of our </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">trading ecosystem</span></span></li>
</ul>
<h1 id="_idParaDest-299"><a id="_idTextAnchor312"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.16.1">All the book’s code can be found in the GitHub repository for this book at </span><a href="https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP"><span class="koboSpan" id="kobo.17.1">https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP</span></a><span class="koboSpan" id="kobo.18.1">. </span><span class="koboSpan" id="kobo.18.2">The source code for this chapter is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.19.1">Chapter12</span></strong><span class="koboSpan" id="kobo.20.1"> directory in </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">the repository.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">Since this is the concluding chapter of this book and we will discuss tips for improving the performance of the full electronic trading ecosystem as well as future enhancements, we expect you to have gone through all the </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">preceding chapters.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">The specifications of the environment in which the source code for this book was developed are listed as follows. </span><span class="koboSpan" id="kobo.24.2">We have presented the details of this environment since all the C++ code presented in this book is not necessarily portable and might require some minor changes to work in </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">your environment:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.26.1">OS: </span><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr 18 17:40:00 UTC 2 x86_64 x86_64 </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.28.1">x86_64 GNU/Linux</span></strong></span></li>
<li><span class="koboSpan" id="kobo.29.1">GCC: </span><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">g++ (Ubuntu </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">11.3.0-1ubuntu1~22.04.1) 11.3.0</span></strong></span></li>
<li><span class="koboSpan" id="kobo.32.1">CMake: </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">cmake </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">version 3.23.2</span></strong></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.35.1">Ninja: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">1.10.2</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.37.1">Additionally, for those who are interested in running the </span><em class="italic"><span class="koboSpan" id="kobo.38.1">optional</span></em><span class="koboSpan" id="kobo.39.1"> Python Jupyter notebook included with this chapter, the following environment was used. </span><span class="koboSpan" id="kobo.39.2">We will not discuss the installation process for Python, Jupyter, and these libraries and assume that you will figure it out on </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">your own:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.41.1">
-----
Python 3.10.6 (main, Mar 10 2023, 10:55:28) [GCC 11.3.0]
Linux-5.19.0-43-generic-x86_64-with-glibc2.35
-----
IPython             8.13.2
jupyter_client      8.2.0
jupyter_core        5.3.0
notebook            6.5.4
-----
hvplot              0.8.3
numpy               1.24.3
pandas              2.0.1
plotly              5.14.1
-----</span></pre>
<h1 id="_idParaDest-300"><a id="_idTextAnchor313"/><span class="koboSpan" id="kobo.42.1">Analyzing the performance of our trading ecosystem</span></h1>
<p><span class="koboSpan" id="kobo.43.1">Before we analyze the performance of our</span><a id="_idIndexMarker1536"/><span class="koboSpan" id="kobo.44.1"> electronic trading ecosystem, let us quickly recap the measurements we added in the </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">previous chapter.</span></span></p>
<h2 id="_idParaDest-301"><a id="_idTextAnchor314"/><span class="koboSpan" id="kobo.46.1">Revisiting the latencies we measure</span></h2>
<p><span class="koboSpan" id="kobo.47.1">We added two </span><a id="_idIndexMarker1537"/><span class="koboSpan" id="kobo.48.1">forms of measurement. </span><span class="koboSpan" id="kobo.48.2">The first one measures the performance of internal components and the second one generates timestamps at key points in our </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">entire system.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">The first form, which measures the latencies of internal components, generates differences in </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">RDTSC</span></strong><span class="koboSpan" id="kobo.52.1"> values before and after calls to different functions, and generates log entries such as </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.54.1">
exchange_order_server.log:18:48:29.452140238 RDTSC Exchange_FIFOSequencer_addClientRequest 26
trading_engine_1.log:18:48:29.480664387 RDTSC Trading_FeatureEngine_onOrderBookUpdate 39272
trading_engine_1.log:18:48:29.480584410 RDTSC Trading_MarketOrderBook_addOrder 176
trading_engine_1.log:18:48:29.480712854 RDTSC Trading_OrderManager_moveOrder 32
trading_engine_1.log:18:48:29.254832602 RDTSC Trading_PositionKeeper_addFill 94350
trading_engine_1.log:18:48:29.480492650 RDTSC Trading_RiskManager_checkPreTradeRisk 1036
...</span></pre>
<p><span class="koboSpan" id="kobo.55.1">The second form, which measures the latencies at key points in the trading ecosystem, generates absolute timestamp values and generates log entries such as </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.57.1">
trading_engine_1.log:18:48:29.440526826 TTT T10_TradeEngine_LFQueue_write 1686008909440526763
exchange_order_server.log:18:48:29.452087295 TTT T1_OrderServer_TCP_read 1686008909452087219
exchange_market_data_publisher.log:18:48:29.467680305 TTT T5_MarketDataPublisher_LFQueue_read 1686008909467680251
trading_market_data_consumer_1.log:18:48:29.478030090 TTT T8_MarketDataConsumer_LFQueue_write 1686008909478029956
trading_engine_1.log:18:48:29.480552551 TTT T9_TradeEngine_LFQueue_read 1686008909480552495
...</span></pre>
<p><span class="koboSpan" id="kobo.58.1">Now, let us move </span><a id="_idIndexMarker1538"/><span class="koboSpan" id="kobo.59.1">forward and analyze these </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">latency measurements.</span></span></p>
<h2 id="_idParaDest-302"><a id="_idTextAnchor315"/><span class="koboSpan" id="kobo.61.1">Analyzing the performance</span></h2>
<p><span class="koboSpan" id="kobo.62.1">To analyze these</span><a id="_idIndexMarker1539"/><span class="koboSpan" id="kobo.63.1"> performance metrics, we have built a Python Jupyter notebook, which is available at </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">Chapter12/notebooks/perf_analysis.ipynb</span></strong><span class="koboSpan" id="kobo.65.1">. </span><span class="koboSpan" id="kobo.65.2">Note that since this is a book about C++ and low-latency applications, we will not discuss the source code in this notebook, but instead describe the analysis. </span><span class="koboSpan" id="kobo.65.3">Running the notebook is optional, so we also included an HTML file with the results of this analysis, which is available at </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">Chapter12/notebooks/perf_analysis.html</span></strong><span class="koboSpan" id="kobo.67.1">. </span><span class="koboSpan" id="kobo.67.2">To run this notebook, you will first have to launch the </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">jupyter notebook</span></strong><span class="koboSpan" id="kobo.69.1"> server from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">Chapter12</span></strong><span class="koboSpan" id="kobo.71.1"> root directory (where the log files exist) using the </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.73.1">
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter12$ jupyter notebook
...
</span><span class="koboSpan" id="kobo.73.2">    To access the notebook, open this file in a browser:
        file:///home/sghosh/.local/share/jupyter/runtime/nbserver-182382-open.html
    Or copy and paste one of these URLs:
        http://localhost:8888/?token=d28e3bd3b1f8109b12afe1210ae8c494c7 7a4128e23bdae7
     or http://127.0.0.1:8888/?token=d28e3bd3b1f8109b12afe1210ae8c494c7 7a4128e23bdae7</span></pre>
<p><span class="koboSpan" id="kobo.74.1">If your browser does not already launch the web page for this notebook, you can copy and paste the URL you receive and navigate to and open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">notebooks/perf_analysis.ipynb</span></strong><span class="koboSpan" id="kobo.76.1"> notebook. </span><span class="koboSpan" id="kobo.76.2">Note that the preceding addresses are just examples for this specific run; you will receive a different address, which you should </span><a id="_idIndexMarker1540"/><span class="koboSpan" id="kobo.77.1">use. </span><span class="koboSpan" id="kobo.77.2">Once you open the notebook, you can run it using </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">Cell</span></strong><span class="koboSpan" id="kobo.79.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">Run All</span></strong><span class="koboSpan" id="kobo.81.1">, or the closest equivalent in your notebook instance, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">following screenshot.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<span class="koboSpan" id="kobo.83.1"><img alt="Figure 12.1 – Screenshot of the perf_analysis.ipynb notebook" src="image/B19434_12_001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.84.1">Figure 12.1 – Screenshot of the perf_analysis.ipynb notebook</span></p>
<p><span class="koboSpan" id="kobo.85.1">Since we will not discuss the details of this notebook, we will briefly describe the analysis performed in it. </span><span class="koboSpan" id="kobo.85.2">This notebook performs the following steps in the order </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">presented here:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.87.1">First, it looks for the log files generated by running the electronic trading ecosystem in the current working directory. </span><span class="koboSpan" id="kobo.87.2">Specifically, it looks for log files from the trading exchange; in the case of this notebook, we look for log files from the trading client </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">ClientId=1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.91.1">It opens</span><a id="_idIndexMarker1541"/><span class="koboSpan" id="kobo.92.1"> each log file and looks for log entries that contain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">RDTSC</span></strong><span class="koboSpan" id="kobo.94.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">TTT</span></strong><span class="koboSpan" id="kobo.96.1"> tokens in them to find the log entries corresponding to the measurements we discussed in the previous chapter and revisited in the </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">preceding sub-section.</span></span></li>
<li><span class="koboSpan" id="kobo.98.1">It then creates two </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">pandas</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.100.1">DataFrame</span></strong><span class="koboSpan" id="kobo.101.1"> instances containing each of the measurements it extracts from the </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">log files.</span></span></li>
<li><span class="koboSpan" id="kobo.103.1">For the measurement entries corresponding to the measurement of internal functions, which are tagged with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">RDTSC</span></strong><span class="koboSpan" id="kobo.105.1"> token, we generate a scatter plot of those measurements as well as a rolling mean of those plots (to smooth the overall latency measurements). </span><span class="koboSpan" id="kobo.105.2">One crucial point here is that the measurement values in the log files represent the difference in </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">RDTSC</span></strong><span class="koboSpan" id="kobo.107.1"> values, that is, the number of CPU cycles elapsed for a function call. </span><span class="koboSpan" id="kobo.107.2">In this notebook, we convert the CPU cycles into nanoseconds using a constant factor of 2.6 GHz, which is specific to our system and will differ based on your hardware; it will need to be adjusted. </span><span class="koboSpan" id="kobo.107.3">We will look at a few examples of these plots in the </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">next sub-section.</span></span></li>
<li><span class="koboSpan" id="kobo.109.1">For the measurement entries corresponding to the timestamps at key spots in our electronic trading ecosystem, which are tagged with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">TTT</span></strong><span class="koboSpan" id="kobo.111.1"> token, we also generate a scatter plot and a plot of the rolling mean values. </span><span class="koboSpan" id="kobo.111.2">The difference here is that we display the transit times from one hop to the other. </span><span class="koboSpan" id="kobo.111.3">For instance, we will plot the time it takes from the hop at </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">T1_OrderServer_TCP_read</span></strong><span class="koboSpan" id="kobo.113.1"> to the hop at </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">T2_OrderServer_LFQueue_write</span></strong><span class="koboSpan" id="kobo.115.1">, from </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">T2_OrderServer_LFQueue_write</span></strong><span class="koboSpan" id="kobo.117.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">T3_MatchingEngine_LFQueue_read</span></strong><span class="koboSpan" id="kobo.119.1">, from </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">T3_MatchingEngine_LFQueue_read</span></strong><span class="koboSpan" id="kobo.121.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">T4_MatchingEngine_LFQueue_write</span></strong><span class="koboSpan" id="kobo.123.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">so forth.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.125.1">Each of these inter-hop transits on the side of the exchange is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">following diagram.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<span class="koboSpan" id="kobo.127.1"><img alt="Figure 12.2 – Flow of data between different hops at the electronic exchange" src="image/B19434_12_002.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.128.1">Figure 12.2 – Flow of data between different hops at the electronic exchange</span></p>
<p><span class="koboSpan" id="kobo.129.1">Each of these inter-hop</span><a id="_idIndexMarker1542"/><span class="koboSpan" id="kobo.130.1"> transits on the side of the trading client is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">following diagram.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<span class="koboSpan" id="kobo.132.1"><img alt="Figure 12.3 – Flow of data between different hops on the electronic trading client" src="image/B19434_12_003.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.133.1">Figure 12.3 – Flow of data between different hops on the electronic trading client</span></p>
<p><span class="koboSpan" id="kobo.134.1">In the next sub-section, we will observe the distribution of a few of these different latency metrics from both groups (</span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">RDTSC</span></strong><span class="koboSpan" id="kobo.136.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">TTT</span></strong><span class="koboSpan" id="kobo.138.1">) and see what we can learn </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">from them.</span></span></p>
<h2 id="_idParaDest-303"><a id="_idTextAnchor316"/><span class="koboSpan" id="kobo.140.1">Understanding the output of our analysis</span></h2>
<p><span class="koboSpan" id="kobo.141.1">In this section, we will present the distribution of the latencies for a subset of the measurements we added in the previous chapter and analyzed using the notebook presented in the previous sub-section. </span><span class="koboSpan" id="kobo.141.2">Our objective here is to gain some insight into the performance of different</span><a id="_idIndexMarker1543"/><span class="koboSpan" id="kobo.142.1"> components and sub-components in our ecosystem. </span><span class="koboSpan" id="kobo.142.2">First, we will start with a few examples of latencies for internal function calls in the next sub-section. </span><span class="koboSpan" id="kobo.142.3">One thing to note is that for the sake of brevity, we will present and discuss a subset of all the performance plots available in the Python notebook in this chapter. </span><span class="koboSpan" id="kobo.142.4">Also, note that these are not arranged in any particular order; we simply picked some of the more interesting ones and left all possible plots in the notebook for you to </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">inspect further.</span></span></p>
<h3><span class="koboSpan" id="kobo.144.1">Observing the latencies for internal function calls</span></h3>
<p><span class="koboSpan" id="kobo.145.1">The first performance plot we present in this chapter is the distribution of the latency of calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">Exchange::MEOrderBook::removeOrder()</span></strong><span class="koboSpan" id="kobo.147.1"> method in the matching engine inside the trading exchange. </span><span class="koboSpan" id="kobo.147.2">That is presented as follows, but our key takeaway here</span><a id="_idIndexMarker1544"/><span class="koboSpan" id="kobo.148.1"> is that this is a very well-behaved function; that is, the minimum and maximum latencies are within a tight range between 0.4 and 3.5 microseconds and the mean is relatively stable around the 1-to-1.5-microsecond range. </span><span class="koboSpan" id="kobo.148.2">There might be the possibility to make this faster, of course, but this seems quite well behaved for now and has low-performance latencies; we should evaluate whether this method is a bottleneck before trying to optimize it </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">any further.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<span class="koboSpan" id="kobo.150.1"><img alt="Figure 12.4 – Latency distribution for the removeOrder() method in MEOrderBook for the matching engine" src="image/B19434_12_004.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.151.1">Figure 12.4 – Latency distribution for the removeOrder() method in MEOrderBook for the matching engine</span></p>
<p><span class="koboSpan" id="kobo.152.1">The next plot presents the distribution of latencies for </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">Exchange::FIFOSequencer::</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1"> sequenceAndPublish()</span></strong><span class="koboSpan" id="kobo.156.1"> method. </span><span class="koboSpan" id="kobo.156.2">This instance is more interesting because here we see that while this method has low average latencies in</span><a id="_idIndexMarker1545"/><span class="koboSpan" id="kobo.157.1"> the 90 microseconds range, it experiences many spikes in latencies spiking up to values in the 500 to 1,200 microseconds range. </span><span class="koboSpan" id="kobo.157.2">This behavior will result in jitter in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">OrderServer</span></strong><span class="koboSpan" id="kobo.159.1"> component’s performance when it comes to processing client order requests and is something we might need </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">to investigate.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<span class="koboSpan" id="kobo.161.1"><img alt="Figure 12.5 – Latency distribution of the sequenceAndPublish() method in FIFOSequencer for the matching engine" src="image/B19434_12_005.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.162.1">Figure 12.5 – Latency distribution of the sequenceAndPublish() method in FIFOSequencer for the matching engine</span></p>
<p><span class="koboSpan" id="kobo.163.1">The next plot shows another interesting distribution of latency values for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">Trading::PositionKeeper::addFill()</span></strong><span class="koboSpan" id="kobo.165.1"> method. </span><span class="koboSpan" id="kobo.165.2">In this case, the average performance latency </span><a id="_idIndexMarker1546"/><span class="koboSpan" id="kobo.166.1">remains stable around the 50 microseconds range. </span><span class="koboSpan" id="kobo.166.2">However, between </span><strong class="bold"><span class="koboSpan" id="kobo.167.1">15:28:00</span></strong><span class="koboSpan" id="kobo.168.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.169.1">15:29:00</span></strong><span class="koboSpan" id="kobo.170.1">, there are a few spikes in latency that warrant a closer look. </span><span class="koboSpan" id="kobo.170.2">The difference here compared to </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.171.1">Figure 12</span></em></span><em class="italic"><span class="koboSpan" id="kobo.172.1">.4</span></em><span class="koboSpan" id="kobo.173.1"> is that there the spikes were distributed evenly, but in this case, there appears to be a small patch </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">of spikes.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<span class="koboSpan" id="kobo.175.1"><img alt="Figure 12.6 – Latency distribution of the addFill() method in PositionKeeper for the trade engine" src="image/B19434_12_006.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.176.1">Figure 12.6 – Latency distribution of the addFill() method in PositionKeeper for the trade engine</span></p>
<p><span class="koboSpan" id="kobo.177.1">We conclude this sub-section by presenting one more plot, this time of </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">Trading::</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1"> PositionKeeper::updateBBO()</span></strong><span class="koboSpan" id="kobo.181.1"> method, which updates the PnL for open positions. </span><span class="koboSpan" id="kobo.181.2">This is</span><a id="_idIndexMarker1547"/><span class="koboSpan" id="kobo.182.1"> another well-behaved method with an average performance latency of 10 microseconds, and there seem to be many measurements close to 0 microseconds, which is slightly different from </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.183.1">Figure 12</span></em></span><em class="italic"><span class="koboSpan" id="kobo.184.1">.3</span></em><span class="koboSpan" id="kobo.185.1">, where the minimum latency value was never remarkably close </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">to 0.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer079">
<span class="koboSpan" id="kobo.187.1"><img alt="Figure 12.7 – Latency distribution of the updateBBO() method in PositionKeeper for the trade engine" src="image/B19434_12_007.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.188.1">Figure 12.7 – Latency distribution of the updateBBO() method in PositionKeeper for the trade engine</span></p>
<p><span class="koboSpan" id="kobo.189.1">In the next</span><a id="_idIndexMarker1548"/><span class="koboSpan" id="kobo.190.1"> sub-section, we will look at a few similar examples, but this time pertaining to the latencies between the different hops in </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">our ecosystem.</span></span></p>
<h3><span class="koboSpan" id="kobo.192.1">Observing the latencies between hops in the ecosystem</span></h3>
<p><span class="koboSpan" id="kobo.193.1">The first plot we will look at is the</span><a id="_idIndexMarker1549"/><span class="koboSpan" id="kobo.194.1"> time difference between when a trading client’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.196.1"> component writes a client request to the TCP socket (</span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">T12</span></strong><span class="koboSpan" id="kobo.198.1">) up to the point when the exchange’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">OrderServer</span></strong><span class="koboSpan" id="kobo.200.1"> component reads that client request from the TCP socket (</span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">T1</span></strong><span class="koboSpan" id="kobo.202.1">). </span><span class="koboSpan" id="kobo.202.2">This represents the network transit time from the trading client to the trading exchange on the TCP connection. </span><span class="koboSpan" id="kobo.202.3">The average latency in this case is around 15 to 20 microseconds and the distribution is </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">evenly distributed.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer080">
<span class="koboSpan" id="kobo.204.1"><img alt="Figure 12.8 – Latency distribution between the T12_OrderGateway_TCP_write and T1_OrderServer_TCP_read hops" src="image/B19434_12_008.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.205.1">Figure 12.8 – Latency distribution between the T12_OrderGateway_TCP_write and T1_OrderServer_TCP_read hops</span></p>
<p><span class="koboSpan" id="kobo.206.1">The next plot displays the distribution of the network transit time for the market data updates, from when the market data</span><a id="_idIndexMarker1550"/><span class="koboSpan" id="kobo.207.1"> updates are written to the UDP socket by </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.209.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">T6</span></strong><span class="koboSpan" id="kobo.211.1">) to when they are read from the UDP socket by </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.213.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">T7</span></strong><span class="koboSpan" id="kobo.215.1">). </span><span class="koboSpan" id="kobo.215.2">There seems to be a great amount of variance in the latencies for this measurement, as the plot shows; however, this has lower overall latencies than the </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">TCP path.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer081">
<span class="koboSpan" id="kobo.217.1"><img alt="Figure 12.9 – Latency distribution between the T6_MarketDataPublisher_UDP_write and T7_MarketDataConsumer_UDP_read hops" src="image/B19434_12_009.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.218.1">Figure 12.9 – Latency distribution between the T6_MarketDataPublisher_UDP_write and T7_MarketDataConsumer_UDP_read hops</span></p>
<p><span class="koboSpan" id="kobo.219.1">The next diagram shows the</span><a id="_idIndexMarker1551"/><span class="koboSpan" id="kobo.220.1"> distribution of latencies measured from </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.222.1"> reading a market update from the UDP socket (</span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">T7</span></strong><span class="koboSpan" id="kobo.224.1">) to the time when the market update is written to </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">LFQueue</span></strong><span class="koboSpan" id="kobo.226.1"> connected to </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.228.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">T8</span></strong><span class="koboSpan" id="kobo.230.1">). </span><span class="koboSpan" id="kobo.230.2">This path experiences huge spikes in latencies (up to 2,000 microseconds) compared to its average performance of around 100 microseconds, so this is something we need </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">to investigate.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer082">
<span class="koboSpan" id="kobo.232.1"><img alt="Figure 12.10 – Latency distribution between the T7_MarketDataConsumer_UDP_read and T8_MarketDataConsumer_LFQueue_write hops" src="image/B19434_12_010.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.233.1">Figure 12.10 – Latency distribution between the T7_MarketDataConsumer_UDP_read and T8_MarketDataConsumer_LFQueue_write hops</span></p>
<p><span class="koboSpan" id="kobo.234.1">The next plot displays</span><a id="_idIndexMarker1552"/><span class="koboSpan" id="kobo.235.1"> the distribution of the latencies between </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.237.1"> reading a client request from </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">LFQueue</span></strong><span class="koboSpan" id="kobo.239.1"> attached to </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">OrderServer</span></strong><span class="koboSpan" id="kobo.241.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">T3</span></strong><span class="koboSpan" id="kobo.243.1">) and the time </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.245.1"> processes it and writes the client response to </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">LFQueue</span></strong><span class="koboSpan" id="kobo.247.1"> back to </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">OrderServer</span></strong><span class="koboSpan" id="kobo.249.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">T4t</span></strong><span class="koboSpan" id="kobo.251.1">). </span><span class="koboSpan" id="kobo.251.2">This path also appears to be experiencing large latency spikes and should </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">be investigated.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer083">
<span class="koboSpan" id="kobo.253.1"><img alt="Figure 12.11 – Latency distribution between the T3_MatchingEngine_LFQueue_read and T4t_MatchingEngine_LFQueue_write hops" src="image/B19434_12_011.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.254.1">Figure 12.11 – Latency distribution between the T3_MatchingEngine_LFQueue_read and T4t_MatchingEngine_LFQueue_write hops</span></p>
<p><span class="koboSpan" id="kobo.255.1">This section was </span><a id="_idIndexMarker1553"/><span class="koboSpan" id="kobo.256.1">dedicated to the analysis of the different latency measurements in our ecosystem. </span><span class="koboSpan" id="kobo.256.2">In the next section, we will discuss some tips and techniques that we can use to optimize the design and implementation of the different components in our electronic </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">trading ecosystem.</span></span></p>
<h1 id="_idParaDest-304"><a id="_idTextAnchor317"/><span class="koboSpan" id="kobo.258.1">Discussing tips and techniques for optimizing our C++ trading system</span></h1>
<p><span class="koboSpan" id="kobo.259.1">In this section, we will present a few </span><a id="_idIndexMarker1554"/><span class="koboSpan" id="kobo.260.1">possible areas where we can optimize our C++ trading ecosystem. </span><span class="koboSpan" id="kobo.260.2">Note that these are only some examples and a lot more is possible, but we will leave you to measure and discover those inefficiencies, as well as improve on them. </span><span class="koboSpan" id="kobo.260.3">To reiterate what we have mentioned a few times before, you should measure the performance of various parts of your system with everything we learned in the previous chapter, </span><em class="italic"><span class="koboSpan" id="kobo.261.1">Adding instrumentation and measuring performance</span></em><span class="koboSpan" id="kobo.262.1">. </span><span class="koboSpan" id="kobo.262.2">You should analyze them using the approach we discussed in this chapter and use the C++ discussions we had in the chapter </span><em class="italic"><span class="koboSpan" id="kobo.263.1">Exploring C++ Concepts from a Low-Latency Application’s Perspective</span></em><span class="koboSpan" id="kobo.264.1"> to improve on them further. </span><span class="koboSpan" id="kobo.264.2">Now, let us discuss some areas of improvement next. </span><span class="koboSpan" id="kobo.264.3">We have tried to arrange these</span><a id="_idIndexMarker1555"/><span class="koboSpan" id="kobo.265.1"> loosely in order from least to </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">most effort.</span></span></p>
<h2 id="_idParaDest-305"><a id="_idTextAnchor318"/><span class="koboSpan" id="kobo.267.1">Optimizing the release build</span></h2>
<p><span class="koboSpan" id="kobo.268.1">The first suggestion would be to try and optimize the release build we run for our system. </span><span class="koboSpan" id="kobo.268.2">Some simple things we</span><a id="_idIndexMarker1556"/><span class="koboSpan" id="kobo.269.1"> can do in the code itself is remove the calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">ASSERT()</span></strong><span class="koboSpan" id="kobo.271.1"> from the release binaries. </span><span class="koboSpan" id="kobo.271.2">The motivation behind this is to remove the extra </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">if</span></strong><span class="koboSpan" id="kobo.273.1"> condition this macro introduces in our code base wherever it gets used. </span><span class="koboSpan" id="kobo.273.2">However, this can be dangerous since we might allow exceptional conditions through. </span><span class="koboSpan" id="kobo.273.3">The optimal middle ground is to remove the use of this macro only from the critical code path wherever it is safe to </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">do so.</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">Another suggestion would be to reduce logging in the release build. </span><span class="koboSpan" id="kobo.275.2">We have made a decent amount of effort to make logging efficient and low-latency. </span><span class="koboSpan" id="kobo.275.3">Additionally, it is not wise to eliminate all logging since it makes troubleshooting difficult, if not impossible. </span><span class="koboSpan" id="kobo.275.4">However, logging is not free, so we should try to reduce logging on the critical path for release builds as much </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">as possible.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">The most common method to perform optimizations, as we suggested here, that only apply to release builds is to define the NDEBUG (No Debug) preprocessor flag and check for its existence in our code base. </span><span class="koboSpan" id="kobo.277.2">If the flag is defined, we build a release build and skip non-essential code such as asserts </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">and logging.</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">An example of this for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">MemoryPool::deallocate()</span></strong><span class="koboSpan" id="kobo.281.1"> method is </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.283.1">
    auto deallocate(const T *elem) noexcept {
      const auto elem_index = (reinterpret_cast&lt;const
         ObjectBlock *&gt;(elem) - &amp;store_[0]);
#if !defined(NDEBUG)
      ASSERT(elem_index &gt;= 0 &amp;&amp; static_cast&lt;size_t&gt;
       (elem_index) &lt; store_.size(), "Element being
      deallocated does not belong to this Memory pool.");
      ASSERT(!store_[elem_index].is_free_, "Expected in-use
         ObjectBlock at index:" + std::
            to_string(elem_index));
#endif
      store_[elem_index].is_free_ = true;
    }</span></pre>
<p><span class="koboSpan" id="kobo.284.1">Another example </span><a id="_idIndexMarker1557"/><span class="koboSpan" id="kobo.285.1">for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">FIFOSequencer::sequenceAndPublish()</span></strong><span class="koboSpan" id="kobo.287.1"> method is </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.289.1">
    auto sequenceAndPublish() {
      ...
</span><span class="koboSpan" id="kobo.289.2">#if !defined(NDEBUG)
      logger_-&gt;log("%:% %() % Processing % requests.\n",
          __FILE__, __LINE__, __FUNCTION__, Common::
            getCurrentTimeStr(&amp;time_str_), pending_size_);
#endif
      ...
</span><span class="koboSpan" id="kobo.289.3">      for (size_t i = 0; i &lt; pending_size_; ++i) {
        const auto &amp;client_request =
           pending_client_requests_.at(i);
#if !defined(NDEBUG)
        logger_-&gt;log("%:% %() % Writing RX:% Req:% to
         FIFO.\n", __FILE__, __LINE__, __FUNCTION__,
          Common::getCurrentTimeStr(&amp;time_str_),
                     client_request.recv_time_,
                        client_request.request_.toString());
#endif
    ...
</span><span class="koboSpan" id="kobo.289.4">    }</span></pre>
<p><span class="koboSpan" id="kobo.290.1">Another thing to think about is whether the actual entries being logged can be output in a more optimal method. </span><span class="koboSpan" id="kobo.290.2">For instance, </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">Common:: getCurrentTimeStr()</span></strong><span class="koboSpan" id="kobo.292.1">, which gets called in each of our log lines in the current code base state itself, is quite expensive. </span><span class="koboSpan" id="kobo.292.2">This is because it performs string formatting operations using </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">sprintf()</span></strong><span class="koboSpan" id="kobo.294.1">, which is quite expensive, like most string formatting operations. </span><span class="koboSpan" id="kobo.294.2">Here, we have another optimization where in</span><a id="_idIndexMarker1558"/><span class="koboSpan" id="kobo.295.1"> release builds, we can output a simple integer value representing time, instead of a formatted string, which, while more readable, is </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">less efficient.</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">Let us move on to the next possible optimization area – managing </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">thread affinity.</span></span></p>
<h2 id="_idParaDest-306"><a id="_idTextAnchor319"/><span class="koboSpan" id="kobo.299.1">Setting thread affinity correctly</span></h2>
<p><span class="koboSpan" id="kobo.300.1">So far, in all the instances of creating and launching threads, we have passed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">core_id</span></strong><span class="koboSpan" id="kobo.302.1"> parameter to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">-1</span></strong><span class="koboSpan" id="kobo.304.1"> in the call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">Common::createAndStartThread()</span></strong><span class="koboSpan" id="kobo.306.1"> method; that is, the threads were not pinned to any specific core. </span><span class="koboSpan" id="kobo.306.2">This was</span><a id="_idIndexMarker1559"/><span class="koboSpan" id="kobo.307.1"> done intentionally since, as we mentioned before, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">exchange_main</span></strong><span class="koboSpan" id="kobo.309.1"> application instance creates and runs 10 threads and each </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">trading_main</span></strong><span class="koboSpan" id="kobo.311.1"> application instance creates and runs 8 threads. </span><span class="koboSpan" id="kobo.311.2">Unless you are executing the source code for this book on a production-grade trading server, it is unlikely to have too many CPU cores. </span><span class="koboSpan" id="kobo.311.3">Our system, for example, has only four cores. </span><span class="koboSpan" id="kobo.311.4">In practice, however, each of the following performance-critical threads would be assigned a CPU core all to themselves. </span><span class="koboSpan" id="kobo.311.5">We present a sample core assignment next; however, this will change from server to server and might also depend on the NUMA architecture – but that is beyond the scope of this book. </span><span class="koboSpan" id="kobo.311.6">Note that these names refer to the names we passed to the method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">name</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.313.1">string parameter:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">core_id</span></strong><span class="koboSpan" id="kobo.315.1">=0 : </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">Exchange/MarketDataPublisher</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">core_id</span></strong><span class="koboSpan" id="kobo.318.1">=1 : </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">Exchange/MatchingEngine</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">core_id</span></strong><span class="koboSpan" id="kobo.321.1">=2 : </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">Exchange/OrderServer</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">core_id</span></strong><span class="koboSpan" id="kobo.324.1">=3 : </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">Trading/MarketDataConsumer</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">core_id</span></strong><span class="koboSpan" id="kobo.327.1">=4 : </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">Trading/OrderGateway</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">core_id</span></strong><span class="koboSpan" id="kobo.330.1">=5 : </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">Trading/TradeEngine</span></strong></span></li>
<li><span class="koboSpan" id="kobo.332.1">Any additional performance critical threads get assigned the remaining core ids in a </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">similar fashion</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.334.1">The remaining non-critical threads, as well as any Linux processes running on the server, would be given a block of CPU</span><a id="_idIndexMarker1560"/><span class="koboSpan" id="kobo.335.1"> cores to be run on without any affinity settings. </span><span class="koboSpan" id="kobo.335.2">Specifically, in our system, they would be the following </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">non-critical threads:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">core_id</span></strong><span class="koboSpan" id="kobo.338.1">=-1 : </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">Exchange/SnapshotSynthesizer</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">core_id</span></strong><span class="koboSpan" id="kobo.341.1">=-1 : </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">Common/Logger exchange_main.log</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">core_id</span></strong><span class="koboSpan" id="kobo.344.1">=-1 : </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">Common/Logger exchange_matching_engine.log</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">core_id</span></strong><span class="koboSpan" id="kobo.347.1">=-1 : </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">Common/Logger exchange_market_data_publisher.log</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">core_id</span></strong><span class="koboSpan" id="kobo.350.1">=-1 : </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">Common/Logger exchange_snapshot_synthesizer.log</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">core_id</span></strong><span class="koboSpan" id="kobo.353.1">=-1 : </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">Common/Logger exchange_order_server.log</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">core_id</span></strong><span class="koboSpan" id="kobo.356.1">=-1 : </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">Common/Logger trading_main_1.log</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">core_id</span></strong><span class="koboSpan" id="kobo.359.1">=-1 : </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">Common/Logger trading_engine_1.log</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">core_id</span></strong><span class="koboSpan" id="kobo.362.1">=-1 : </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">Common/Logger trading_order_gateway_1.log</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">core_id</span></strong><span class="koboSpan" id="kobo.365.1">=-1 : </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">Common/Logger trading_market_data_con</span></strong></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">sumer_1.log</span></strong></span></li>
<li><span class="koboSpan" id="kobo.368.1">Any other non-critical threads would also be assigned core id -1 i.e. </span><span class="koboSpan" id="kobo.368.2">these threads will not be pinned to any specific </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">CPU code</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.370.1">Note one additional detail: for this setup to be as optimized as possible, we need to make sure that the Linux process scheduler does not assign any OS processes to the CPU cores being used by the critical threads. </span><span class="koboSpan" id="kobo.370.2">This is achieved on Linux using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">isolcpus</span></strong><span class="koboSpan" id="kobo.372.1"> kernel parameter, which we will not discuss in detail here. </span><span class="koboSpan" id="kobo.372.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">isolcpus</span></strong><span class="koboSpan" id="kobo.374.1"> parameter tells the process scheduler which cores to ignore when deciding where to schedule </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">a process.</span></span></p>
<h2 id="_idParaDest-307"><a id="_idTextAnchor320"/><span class="koboSpan" id="kobo.376.1">Optimizing Logger for strings</span></h2>
<p><span class="koboSpan" id="kobo.377.1">There is an opportunity to </span><a id="_idIndexMarker1561"/><span class="koboSpan" id="kobo.378.1">optimize our </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">Logger</span></strong><span class="koboSpan" id="kobo.380.1"> class to handle parameters of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">char*</span></strong><span class="koboSpan" id="kobo.382.1"> type better. </span><span class="koboSpan" id="kobo.382.2">Remember that our implementation for logging </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">char*</span></strong><span class="koboSpan" id="kobo.384.1"> parameters consists of calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">Logger::pushValue(const char value)</span></strong><span class="koboSpan" id="kobo.386.1"> method on each of the characters iteratively, </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">as shown:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.388.1">
    auto pushValue(const char *value) noexcept {
      while (*value) {
        pushValue(*value);
        ++value;
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.389.1">One option here is to introduce a new enumeration value to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">LogType</span></strong><span class="koboSpan" id="kobo.391.1"> enumeration. </span><span class="koboSpan" id="kobo.391.2">Let’s call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">STRING</span></strong><span class="koboSpan" id="kobo.393.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.395.1">
  enum class LogType : int8_t {
    ...
</span><span class="koboSpan" id="kobo.395.2">    DOUBLE = 8,
    STRING = 9
  };</span></pre>
<p><span class="koboSpan" id="kobo.396.1">We’ll update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">LogElement</span></strong><span class="koboSpan" id="kobo.398.1"> type to have a fixed-size </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">char*</span></strong><span class="koboSpan" id="kobo.400.1"> array of </span><em class="italic"><span class="koboSpan" id="kobo.401.1">some</span></em><span class="koboSpan" id="kobo.402.1"> size, as shown. </span><span class="koboSpan" id="kobo.402.2">We are vague on the size of this array on purpose since this is pseudo-code and we want to focus more on the design and the idea and less on the </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">implementation details:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.404.1">
  struct LogElement {
    LogType type_ = LogType::CHAR;
    union {
      ...
</span><span class="koboSpan" id="kobo.404.2">      double d;
      char str[SOME_SIZE];
    } u_;
  };</span></pre>
<p><span class="koboSpan" id="kobo.405.1">Then, finally, update </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">Logger::pushValue(const char *value)</span></strong><span class="koboSpan" id="kobo.407.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">Logger::flushQueue()</span></strong><span class="koboSpan" id="kobo.409.1"> to copy </span><a id="_idIndexMarker1562"/><span class="koboSpan" id="kobo.410.1">and write the strings in blocks of characters rather than a single character at </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">a time.</span></span></p>
<h2 id="_idParaDest-308"><a id="_idTextAnchor321"/><span class="koboSpan" id="kobo.412.1">Eliminating the use of std::function instances</span></h2>
<p><span class="koboSpan" id="kobo.413.1">In our </span><a id="_idIndexMarker1563"/><span class="koboSpan" id="kobo.414.1">code base, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">std::function&lt;&gt;</span></strong><span class="koboSpan" id="kobo.416.1"> function wrapper in a couple of places, as </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">listed here:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">Common::McastSocket</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.420.1">
std::function&lt;void(McastSocket *s)&gt; recv_callback_;</span></pre></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">Common::TCPServer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.423.1">
std::function&lt;void(TCPSocket *s, Nanos rx_time)&gt; recv_callback_;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.424.1">
std::function&lt;void()&gt; recv_finished_callback_;</span></pre></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">Common::TCPSocket</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.427.1">
std::function&lt;void(TCPSocket *s, Nanos rx_time)&gt; recv_callback_;</span></pre></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">Trading::TradeEngine</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.430.1">
std::function&lt;void(TickerId ticker_id, Price price, Side side, MarketOrderBook *book)&gt; algoOnOrderBookUpdate_;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.431.1">
std::function&lt;void(const Exchange::MEMarketUpdate *market_update, MarketOrderBook *book)&gt; algoOnTradeUpdate_;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.432.1">
std::function&lt;void(const Exchange::MEClientResponse *client_response)&gt; algoOnOrderUpdate_;</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.433.1">Calling functions through these objects is slower than directly calling functions, and these incur similar costs as </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">virtual</span></strong><span class="koboSpan" id="kobo.435.1"> functions. </span><span class="koboSpan" id="kobo.435.2">This mechanism of calling methods using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">std::function&lt;&gt;</span></strong><span class="koboSpan" id="kobo.437.1"> objects can be replaced with templates. </span><span class="koboSpan" id="kobo.437.2">To refresh your memory on the drawbacks of calling functions indirectly, please revisit the chapter </span><em class="italic"><span class="koboSpan" id="kobo.438.1">Exploring C++ Concepts from a Low-Latency Application’s Perspective</span></em><span class="koboSpan" id="kobo.439.1">, specifically the </span><em class="italic"><span class="koboSpan" id="kobo.440.1">Avoiding function pointers</span></em><span class="koboSpan" id="kobo.441.1"> sub-section of the </span><em class="italic"><span class="koboSpan" id="kobo.442.1">Calling functions efficiently</span></em><span class="koboSpan" id="kobo.443.1"> section. </span><span class="koboSpan" id="kobo.443.2">Additionally, revisit the </span><em class="italic"><span class="koboSpan" id="kobo.444.1">Using compile-time polymorphism</span></em><span class="koboSpan" id="kobo.445.1"> section in the same chapter, reviewing the discussion on the </span><strong class="bold"><span class="koboSpan" id="kobo.446.1">Curiously Recurring Template Pattern</span></strong><span class="koboSpan" id="kobo.447.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.448.1">CRTP</span></strong><span class="koboSpan" id="kobo.449.1">), to see an example of</span><a id="_idIndexMarker1564"/><span class="koboSpan" id="kobo.450.1"> how to do this. </span><span class="koboSpan" id="kobo.450.2">For the sake of brevity, we will not discuss the details of how to replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">std::function&lt;&gt;</span></strong><span class="koboSpan" id="kobo.452.1"> instances in our code base, but we encourage those who are interested to attempt </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">that improvement.</span></span></p>
<h2 id="_idParaDest-309"><a id="_idTextAnchor322"/><span class="koboSpan" id="kobo.454.1">Inspecting the impact of these optimizations</span></h2>
<p><span class="koboSpan" id="kobo.455.1">We will not be able to investigate every optimization opportunity in detail, but before we finish this section, we will discuss the details of two optimizations that we discussed in this section. </span><span class="koboSpan" id="kobo.455.2">First, let us discuss the implementation and impact of the optimization on our </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">Logger</span></strong><span class="koboSpan" id="kobo.457.1"> class for </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">logging strings.</span></span></p>
<h3><span class="koboSpan" id="kobo.459.1">Benchmarking Logger string optimization</span></h3>
<p><span class="koboSpan" id="kobo.460.1">To implement the Logger</span><a id="_idIndexMarker1565"/><span class="koboSpan" id="kobo.461.1"> string optimization, we will change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">pushValue()</span></strong><span class="koboSpan" id="kobo.463.1"> method for </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">char*</span></strong><span class="koboSpan" id="kobo.465.1"> arguments as discussed before. </span><span class="koboSpan" id="kobo.465.2">For the sake of brevity, we will not look at the full class, which we implement in an alternate </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">OptLogger</span></strong><span class="koboSpan" id="kobo.467.1"> class available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">Chapter12/common/opt_logging.h</span></strong><span class="koboSpan" id="kobo.469.1"> source file. </span><span class="koboSpan" id="kobo.469.2">The most important change is shown here, but please refer to the full source file to see the other </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">minor changes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.471.1">
    auto pushValue(const char *value) noexcept {
      LogElement l{LogType::STRING, {.s = {}}};
      strncpy(l.u_.s, value, sizeof(l.u_.s) - 1);
      pushValue(l);
    }</span></pre>
<p><span class="koboSpan" id="kobo.472.1">To benchmark this and compare it against the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">Logger</span></strong><span class="koboSpan" id="kobo.474.1"> implementation, we will create a simple standalone binary called </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">logger_benchmark</span></strong><span class="koboSpan" id="kobo.476.1">. </span><span class="koboSpan" id="kobo.476.2">We do this so that we can check the performance impact in a controlled environment. </span><span class="koboSpan" id="kobo.476.3">Remember that running the full trading ecosystem introduces a lot of variance due to the number of processes and threads, the network activity, the trading activity, and so on, and it can be difficult to properly assess the impact of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">Logger</span></strong><span class="koboSpan" id="kobo.478.1"> optimization. </span><span class="koboSpan" id="kobo.478.2">The source code for this benchmark application can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">Chapter12/benchmarks/logger_benchmark.cpp</span></strong><span class="koboSpan" id="kobo.480.1"> source file. </span><span class="koboSpan" id="kobo.480.2">Let us look at the implementation of this source file quickly before looking at </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">the results.</span></span></p>
<p><span class="koboSpan" id="kobo.482.1">First, we will include the</span><a id="_idIndexMarker1566"/><span class="koboSpan" id="kobo.483.1"> header files corresponding to the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">Logger</span></strong><span class="koboSpan" id="kobo.485.1"> and the new </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">OptLogger</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.487.1"> classes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.488.1">
#include "common/logging.h"
#include "common/opt_logging.h"</span></pre>
<p><span class="koboSpan" id="kobo.489.1">Next, we will define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">random_string()</span></strong><span class="koboSpan" id="kobo.491.1"> method, which simply generates random strings of a specified length. </span><span class="koboSpan" id="kobo.491.2">We will use this to generate random strings for the two loggers to log to compare the performance difference when it comes to strings. </span><span class="koboSpan" id="kobo.491.3">This uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">charset()</span></strong><span class="koboSpan" id="kobo.493.1"> lambda method, which returns a random alphanumeric (0-9, a-z, or A-z) character. </span><span class="koboSpan" id="kobo.493.2">It then uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">std::generate_n()</span></strong><span class="koboSpan" id="kobo.495.1"> method to generate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">std::string</span></strong><span class="koboSpan" id="kobo.497.1"> with a length specified in the length argument by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">charset()</span></strong><span class="koboSpan" id="kobo.499.1"> lambda </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">method repeatedly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.501.1">
std::string random_string(size_t length) {
  auto randchar = []() -&gt; char {
    const char charset[] =
        "0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";
    const size_t max_index = (sizeof(charset) - 1);
    return charset[rand() % max_index];
  };
  std::string str(length, 0);
  std::generate_n(str.begin(), length, randchar);
  return str;
}</span></pre>
<p><span class="koboSpan" id="kobo.502.1">Next, we will define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">benchmarkLogging()</span></strong><span class="koboSpan" id="kobo.504.1"> method, which accepts a template parameter, </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">T</span></strong><span class="koboSpan" id="kobo.506.1">, which it expects</span><a id="_idIndexMarker1567"/><span class="koboSpan" id="kobo.507.1"> to be an instance of one of the two loggers we are comparing here. </span><span class="koboSpan" id="kobo.507.2">It runs a loop 100,000 times and uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">random_string()</span></strong><span class="koboSpan" id="kobo.509.1"> method we built previously and the logger’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">log()</span></strong><span class="koboSpan" id="kobo.511.1"> method to log 100,000 random strings. </span><span class="koboSpan" id="kobo.511.2">For each call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">log()</span></strong><span class="koboSpan" id="kobo.513.1"> method, it records and sums up the difference in clock cycles, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">Common::rdtsc()</span></strong><span class="koboSpan" id="kobo.515.1"> method we built in the previous chapter. </span><span class="koboSpan" id="kobo.515.2">Finally, it returns the average clock cycles by dividing the sum of each RDTSC difference by the </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">loop count:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.517.1">
template&lt;typename T&gt;
size_t benchmarkLogging(T *logger) {
  constexpr size_t loop_count = 100000;
  size_t total_rdtsc = 0;
  for (size_t i = 0; i &lt; loop_count; ++i) {
    const auto s = random_string(128);
    const auto start = Common::rdtsc();
    logger-&gt;log("%\n", s);
    total_rdtsc += (Common::rdtsc() - start);
  }
  return (total_rdtsc / loop_count);
}</span></pre>
<p><span class="koboSpan" id="kobo.518.1">Now, we can finally build the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">main()</span></strong><span class="koboSpan" id="kobo.520.1"> method, which is quite simple. </span><span class="koboSpan" id="kobo.520.2">It creates an instance of the old logger – </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">Common::Logger()</span></strong><span class="koboSpan" id="kobo.522.1"> – calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">benchmarkLogging()</span></strong><span class="koboSpan" id="kobo.524.1"> method on it, and </span><a id="_idIndexMarker1568"/><span class="koboSpan" id="kobo.525.1">outputs the average clock cycle count to the screen. </span><span class="koboSpan" id="kobo.525.2">Then, it does exactly the same thing again, except this time it uses the new logger – </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">OptCommon::OptLogger()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.528.1">
int main(int, char **) {
  using namespace std::literals::chrono_literals;
  {
    Common::Logger logger("logger_benchmark_original.log");
    const auto cycles = benchmarkLogging(&amp;logger);
    std::cout &lt;&lt; "ORIGINAL LOGGER " &lt;&lt; cycles &lt;&lt; " CLOCK
      CYCLES PER OPERATION." </span><span class="koboSpan" id="kobo.528.2">&lt;&lt; std::endl;
    std::this_thread::sleep_for(10s);
  }
  {
    OptCommon::OptLogger opt_logger
      ("logger_benchmark_optimized.log");
    const auto cycles = benchmarkLogging(&amp;opt_logger);
    std::cout &lt;&lt; "OPTIMIZED LOGGER " &lt;&lt; cycles &lt;&lt; " CLOCK
      CYCLES PER OPERATION." </span><span class="koboSpan" id="kobo.528.3">&lt;&lt; std::endl;
    std::this_thread::sleep_for(10s);
  }
  exit(EXIT_SUCCESS);
}</span></pre>
<p><span class="koboSpan" id="kobo.529.1">This binary can be built using the same script as before, that is, by running </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">scripts/build.sh</span></strong><span class="koboSpan" id="kobo.531.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">Chapter12</span></strong><span class="koboSpan" id="kobo.533.1"> root directory. </span><span class="koboSpan" id="kobo.533.2">To run the binary, you can call it directly from the command line, as shown here, and, among other output, you will see the following two lines </span><a id="_idIndexMarker1569"/><span class="koboSpan" id="kobo.534.1">displaying the results of </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">the benchmarking:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.536.1">
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter12$ ./cmake-build-release/logger_benchmark
ORIGINAL LOGGER 25757 CLOCK CYCLES PER OPERATION.
</span><span class="koboSpan" id="kobo.536.2">OPTIMIZED LOGGER 466 CLOCK CYCLES PER OPERATION.</span></pre>
<p><span class="koboSpan" id="kobo.537.1">Note that there will be some variance in the output for each run, and the results you get will likely be different due to system-dependent reasons, but amount the optimization has sped things up, should be somewhat similar to what we have shown. </span><span class="koboSpan" id="kobo.537.2">In this case, it seems like our optimization efforts have sped up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">log()</span></strong><span class="koboSpan" id="kobo.539.1"> method for strings to be roughly 50 times faster. </span><span class="koboSpan" id="kobo.539.2">Next, let us look at another example of the optimization tips we discussed before, which is optimizing the binary for </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">release builds.</span></span></p>
<h3><span class="koboSpan" id="kobo.541.1">Benchmarking release build optimization</span></h3>
<p><span class="koboSpan" id="kobo.542.1">To benchmark an example of leaving out non-essential code from the release build, we picked the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">MemPool</span></strong><span class="koboSpan" id="kobo.544.1"> class. </span><span class="koboSpan" id="kobo.544.2">Note that this </span><a id="_idIndexMarker1570"/><span class="koboSpan" id="kobo.545.1">principle applies to all the components we built, but we arbitrarily picked a single one to limit the scope of our discussion. </span><span class="koboSpan" id="kobo.545.2">Similar to what we did for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">Logger</span></strong><span class="koboSpan" id="kobo.547.1"> class, we create a new class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">OptMemPool</span></strong><span class="koboSpan" id="kobo.549.1">, which you will find in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">Chapter12/common/opt_mem_pool.h</span></strong><span class="koboSpan" id="kobo.551.1"> source file. </span><span class="koboSpan" id="kobo.551.2">The primary change in this file compared to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">MemPool</span></strong><span class="koboSpan" id="kobo.553.1"> class is that the calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">ASSERT()</span></strong><span class="koboSpan" id="kobo.555.1"> are only built for non-release builds. </span><span class="koboSpan" id="kobo.555.2">This is achieved by checking for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">NDEBUG</span></strong><span class="koboSpan" id="kobo.557.1"> preprocessor flag, as shown in the following two examples. </span><span class="koboSpan" id="kobo.557.2">You can check out the full source code in the file we </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">mentioned previously:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.559.1">
    template&lt;typename... </span><span class="koboSpan" id="kobo.559.2">Args&gt;
    T *allocate(Args... </span><span class="koboSpan" id="kobo.559.3">args) noexcept {
      auto obj_block = &amp;(store_[next_free_index_]);
#if !defined(NDEBUG)
      ASSERT(obj_block-&gt;is_free_, "Expected free
        ObjectBlock at index:" + std::to_string
          (next_free_index_));
#endif
      ...
</span><span class="koboSpan" id="kobo.559.4">    }
    auto deallocate(const T *elem) noexcept {
      const auto elem_index = (reinterpret_cast&lt;const
        ObjectBlock *&gt;(elem) - &amp;store_[0]);
#if !defined(NDEBUG)
      ASSERT(elem_index &gt;= 0 &amp;&amp; static_cast
        &lt;size_t&gt;(elem_index) &lt; store_.size(), "Element
          being deallocated does not belong to this Memory
            pool.");
      ASSERT(!store_[elem_index].is_free_, "Expected in-use
        ObjectBlock at index:" + std::to_string
          (elem_index));
#endif
      ...
</span><span class="koboSpan" id="kobo.559.5">    }</span></pre>
<p><span class="koboSpan" id="kobo.560.1">To benchmark this optimization, we will build a </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">release_benchmark</span></strong><span class="koboSpan" id="kobo.562.1"> binary, and the code for that is available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">Chapter12/benchmarks/release_benchmark.cpp</span></strong><span class="koboSpan" id="kobo.564.1"> source file. </span><span class="koboSpan" id="kobo.564.2">First, let us look at the header files we need to include, most importantly the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">mem_pool.h</span></strong><span class="koboSpan" id="kobo.566.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">opt_mem_pool.h</span></strong><span class="koboSpan" id="kobo.568.1"> files. </span><span class="koboSpan" id="kobo.568.2">Since memory</span><a id="_idIndexMarker1571"/><span class="koboSpan" id="kobo.569.1"> pools store structures, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">Exchange::MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.571.1"> as an example, so we include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">market_update.h</span></strong><span class="koboSpan" id="kobo.573.1"> header file for that </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">as well:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.575.1">
#include "common/mem_pool.h"
#include "common/opt_mem_pool.h"
#include "common/perf_utils.h"
#include "exchange/market_data/market_update.h"</span></pre>
<p><span class="koboSpan" id="kobo.576.1">Similar to what we did with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">logger_benchmark.cpp</span></strong><span class="koboSpan" id="kobo.578.1"> file, we will create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">benchmarkMemPool()</span></strong><span class="koboSpan" id="kobo.580.1"> method, which accepts a template parameter, </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">T</span></strong><span class="koboSpan" id="kobo.582.1">, and expects it to be one of the two memory pools we are comparing. </span><span class="koboSpan" id="kobo.582.2">In this method, we will first allocate and save 256 </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.584.1"> objects from the memory pool, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">allocate()</span></strong><span class="koboSpan" id="kobo.586.1"> method. </span><span class="koboSpan" id="kobo.586.2">Then, we will deallocate each of these objects and return them to the memory pool, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">deallocate()</span></strong><span class="koboSpan" id="kobo.588.1"> method. </span><span class="koboSpan" id="kobo.588.2">We will run this loop 100,000 times to find a reliable average over many iterations. </span><span class="koboSpan" id="kobo.588.3">We will measure and sum up the clock cycles elapsed</span><a id="_idIndexMarker1572"/><span class="koboSpan" id="kobo.589.1"> for each call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">allocate()</span></strong><span class="koboSpan" id="kobo.591.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">deallocate()</span></strong><span class="koboSpan" id="kobo.593.1"> as we did before with the logger benchmark. </span><span class="koboSpan" id="kobo.593.2">Finally, we return the average clock cycles by dividing the sum of elapsed clock cycles by the </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">loop count:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.595.1">
template&lt;typename T&gt;
size_t benchmarkMemPool(T *mem_pool) {
  constexpr size_t loop_count = 100000;
  size_t total_rdtsc = 0;
  std::array&lt;Exchange::MDPMarketUpdate*, 256&gt;
    allocated_objs;
  for (size_t i = 0; i &lt; loop_count; ++i) {
    for(size_t j = 0; j &lt; allocated_objs.size(); ++j) {
      const auto start = Common::rdtsc();
      allocated_objs[j] = mem_pool-&gt;allocate();
      total_rdtsc += (Common::rdtsc() - start);
    }
    for(size_t j = 0; j &lt; allocated_objs.size(); ++j) {
      const auto start = Common::rdtsc();
      mem_pool-&gt;deallocate(allocated_objs[j]);
      total_rdtsc += (Common::rdtsc() - start);
    }
  }
  return (total_rdtsc / (loop_count *
    allocated_objs.size()));
}</span></pre>
<p><span class="koboSpan" id="kobo.596.1">Finally, we build the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">main()</span></strong><span class="koboSpan" id="kobo.598.1"> method, which again is quite simple. </span><span class="koboSpan" id="kobo.598.2">It calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">benchmarkMemPool()</span></strong><span class="koboSpan" id="kobo.600.1"> method twice, once with an object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">Common::MemPool</span></strong><span class="koboSpan" id="kobo.602.1"> type and next with </span><a id="_idIndexMarker1573"/><span class="koboSpan" id="kobo.603.1">an object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">OptCommon::OptMemPool</span></strong><span class="koboSpan" id="kobo.605.1"> type, and outputs the average clock cycles elapsed for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">allocate()</span></strong><span class="koboSpan" id="kobo.607.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">deallocate()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.609.1"> methods:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.610.1">
int main(int, char **) {
  {
    Common::MemPool&lt;Exchange::MDPMarketUpdate&gt;
      mem_pool(512);
    const auto cycles = benchmarkMemPool(&amp;mem_pool);
    std::cout &lt;&lt; "ORIGINAL MEMPOOL " &lt;&lt; cycles &lt;&lt; " CLOCK
      CYCLES PER OPERATION." </span><span class="koboSpan" id="kobo.610.2">&lt;&lt; std::endl;
  }
  {
    OptCommon::OptMemPool&lt;Exchange::MDPMarketUpdate&gt;
      opt_mem_pool(512);
    const auto cycles = benchmarkMemPool(&amp;opt_mem_pool);
    std::cout &lt;&lt; "OPTIMIZED MEMPOOL " &lt;&lt; cycles &lt;&lt; " CLOCK
      CYCLES PER OPERATION." </span><span class="koboSpan" id="kobo.610.3">&lt;&lt; std::endl;
  }
  exit(EXIT_SUCCESS);
}</span></pre>
<p><span class="koboSpan" id="kobo.611.1">The process to build this benchmark binary remains the same, so we will not repeat it. </span><span class="koboSpan" id="kobo.611.2">Running the binary will yield something that resembles </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.613.1">
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter12$ ./cmake-build-release/release_benchmark
ORIGINAL MEMPOOL 343 CLOCK CYCLES PER OPERATION.
</span><span class="koboSpan" id="kobo.613.2">OPTIMIZED MEMPOOL 44 CLOCK CYCLES PER OPERATION.</span></pre>
<p><span class="koboSpan" id="kobo.614.1">In this case, our optimization efforts yielded a speed up of around 7 to 8 times for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">allocate()</span></strong><span class="koboSpan" id="kobo.616.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">deallocate()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.618.1"> methods.</span></span></p>
<p><span class="koboSpan" id="kobo.619.1">In this section, we presented and</span><a id="_idIndexMarker1574"/><span class="koboSpan" id="kobo.620.1"> explained a subset of optimization areas/ideas in our electronic trading ecosystem. </span><span class="koboSpan" id="kobo.620.2">The goal here is to get you to understand what these optimization areas can look like and how to approach them with the goal of optimizing performance. </span><span class="koboSpan" id="kobo.620.3">In the next section, we’ll discuss some more future improvements and enhancements that can be made to our electronic </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">trading ecosystem.</span></span></p>
<h1 id="_idParaDest-310"><a id="_idTextAnchor323"/><span class="koboSpan" id="kobo.622.1">Thinking about the future of our trading ecosystem</span></h1>
<p><span class="koboSpan" id="kobo.623.1">Before we conclude this chapter and this book, we will discuss a few possible enhancements to our electronic</span><a id="_idIndexMarker1575"/><span class="koboSpan" id="kobo.624.1"> trading ecosystem. </span><span class="koboSpan" id="kobo.624.2">In the previous section, we discussed some examples of things that can be optimized for those interested in maximizing the performance of the electronic trading system we built in this book. </span><span class="koboSpan" id="kobo.624.3">In this section, we will discuss some examples of how this ecosystem can be enhanced, not necessarily to reduce latency but to make the system more feature-rich and </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">add functionality.</span></span></p>
<h2 id="_idParaDest-311"><a id="_idTextAnchor324"/><span class="koboSpan" id="kobo.626.1">Growing containers dynamically</span></h2>
<p><span class="koboSpan" id="kobo.627.1">We built and used a</span><a id="_idIndexMarker1576"/><span class="koboSpan" id="kobo.628.1"> few containers in this book, as </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">listed here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.630.1">The lock-free queue – </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">LFQueue</span></strong><span class="koboSpan" id="kobo.632.1"> – which is used in multiple components for various object types, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.634.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">MDPMarketUpdate</span></strong><span class="koboSpan" id="kobo.636.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.638.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">MEClientResponse</span></strong></span></li>
<li><span class="koboSpan" id="kobo.641.1">The memory pool – </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">MemPool</span></strong><span class="koboSpan" id="kobo.643.1"> – which was used for multiple object types, such as instances of </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">MEMarketUpdate</span></strong><span class="koboSpan" id="kobo.645.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">MEOrder</span></strong><span class="koboSpan" id="kobo.647.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.649.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">MarketOrder</span></strong><span class="koboSpan" id="kobo.651.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">MarketOrdersAtPrice</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.654.1">In all these cases, we assumed a safe maximum size value. </span><span class="koboSpan" id="kobo.654.2">In practice, that still leaves us open to the possibility that </span><a id="_idIndexMarker1577"/><span class="koboSpan" id="kobo.655.1">under some circumstances, we might exceed these limits and get in trouble. </span><span class="koboSpan" id="kobo.655.2">One enhancement we can make to this system is to improve our handling of this unlikely </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">edge case.</span></span></p>
<p><span class="koboSpan" id="kobo.657.1">One option would be to fail/exit if we encounter a scenario where </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">LFQueue</span></strong><span class="koboSpan" id="kobo.659.1"> is full or </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">MemPool</span></strong><span class="koboSpan" id="kobo.661.1"> is out of memory. </span><span class="koboSpan" id="kobo.661.2">Another option would be to fall back to dynamic memory allocation or a secondary inefficient container for this unlikely event; that is, we will be inefficient and slow in this extremely rare case that we run out of memory or space in our containers, but we will continue to function until it is resolved. </span><span class="koboSpan" id="kobo.661.3">Yet another option is to make these containers flexible where they can be grown if needed even though the task of growing these containers when needed will be extremely slow, since in practice we do not expect to encounter </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">that condition.</span></span></p>
<h2 id="_idParaDest-312"><a id="_idTextAnchor325"/><span class="koboSpan" id="kobo.663.1">Growing and enhancing the hash maps</span></h2>
<p><span class="koboSpan" id="kobo.664.1">In this book, we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">std::array</span></strong><span class="koboSpan" id="kobo.666.1"> in many contexts as a hash map by assuming a safe upper bound. </span><span class="koboSpan" id="kobo.666.2">For instance, by </span><a id="_idIndexMarker1578"/><span class="koboSpan" id="kobo.667.1">assuming that valid </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">TickerId</span></strong><span class="koboSpan" id="kobo.669.1"> values fall in the range of 0 and </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">ME_MAX_TICKERS</span></strong><span class="koboSpan" id="kobo.671.1">, we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">std::array</span></strong><span class="koboSpan" id="kobo.673.1"> instances of size </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">ME_MAX_TICKERS</span></strong><span class="koboSpan" id="kobo.675.1"> as hash maps with </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">TickerId</span></strong><span class="koboSpan" id="kobo.677.1"> keys. </span><span class="koboSpan" id="kobo.677.2">A similar</span><a id="_idIndexMarker1579"/><span class="koboSpan" id="kobo.678.1"> design was used for containers such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">TradeEngineCfgHashMap</span></strong><span class="koboSpan" id="kobo.680.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">OrderHashMap</span></strong><span class="koboSpan" id="kobo.682.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">ClientOrderHashMap</span></strong><span class="koboSpan" id="kobo.684.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">OrdersAtPriceHashMap</span></strong><span class="koboSpan" id="kobo.686.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">OrderBookHashMap</span></strong><span class="koboSpan" id="kobo.688.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">MarketOrderBookHashMap</span></strong><span class="koboSpan" id="kobo.690.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">OMOrderTickerSideHashMap</span></strong><span class="koboSpan" id="kobo.692.1">. </span><span class="koboSpan" id="kobo.692.2">While in practice, some of these can continue to exist, that is, valid and reasonable upper bounds can be decided and used, for some of these, this design will not scale </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">up elegantly.</span></span></p>
<p><span class="koboSpan" id="kobo.694.1">There are several different hash map implementations available – </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">std::unordered_map</span></strong><span class="koboSpan" id="kobo.696.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">absl::flat_hash_map</span></strong><span class="koboSpan" id="kobo.698.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">boost::</span></strong><span class="koboSpan" id="kobo.700.1"> hash maps, </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">emhash7::HashMap</span></strong><span class="koboSpan" id="kobo.702.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">folly::AtomicHashmap</span></strong><span class="koboSpan" id="kobo.704.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">robin_hood::unordered_map</span></strong><span class="koboSpan" id="kobo.706.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">tsl::hopscotch_map</span></strong><span class="koboSpan" id="kobo.708.1">, and many more. </span><span class="koboSpan" id="kobo.708.2">Additionally, it is common to optimize and tweak these containers so that they perform best under our specific use cases. </span><span class="koboSpan" id="kobo.708.3">We’ll leave those of you who are interested with the task of exploring these and deciding which ones can replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">std::array</span></strong><span class="koboSpan" id="kobo.710.1">-based hash maps in </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">our system.</span></span></p>
<p><span class="koboSpan" id="kobo.712.1">For the sake of demonstrating an example, we will replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">std::array</span></strong><span class="koboSpan" id="kobo.714.1">-based hash maps in the limit order book that the matching engine builds and maintains (</span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">MEOrderBook</span></strong><span class="koboSpan" id="kobo.716.1">) with </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">std::unordered_map</span></strong><span class="koboSpan" id="kobo.718.1"> hash maps. </span><span class="koboSpan" id="kobo.718.2">We will then benchmark the two implementations to see how much of a difference it makes. </span><span class="koboSpan" id="kobo.718.3">Following the same pattern as we used in the</span><a id="_idIndexMarker1580"/><span class="koboSpan" id="kobo.719.1"> benchmarking we performed earlier in this chapter, we will introduce a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">MEOrderBook</span></strong><span class="koboSpan" id="kobo.721.1"> class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">UnorderedMapMEOrderBook</span></strong><span class="koboSpan" id="kobo.723.1">, where the only difference is the </span><a id="_idIndexMarker1581"/><span class="koboSpan" id="kobo.724.1">use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">std::unordered_map</span></strong><span class="koboSpan" id="kobo.726.1"> containers instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">std::array</span></strong><span class="koboSpan" id="kobo.728.1"> containers. </span><span class="koboSpan" id="kobo.728.2">All the source code for this new class is available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">Chapter12/exchange/matcher/unordered_map_me_order_book.h</span></strong><span class="koboSpan" id="kobo.730.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">Chapter12/exchange/matcher/unordered_map_me_order_book.cpp</span></strong><span class="koboSpan" id="kobo.732.1"> source files. </span><span class="koboSpan" id="kobo.732.2">For the sake of brevity, we will not repeat the entire class implementation here, but we will discuss the important changes. </span><span class="koboSpan" id="kobo.732.3">The first important and obvious change is the inclusion of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">unordered_map</span></strong><span class="koboSpan" id="kobo.734.1"> header file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">unordered_map_me_order_book.h</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.736.1">header file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.737.1">
#include &lt;unordered_map&gt;</span></pre>
<p><span class="koboSpan" id="kobo.738.1">We change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">cid_oid_to_order_</span></strong><span class="koboSpan" id="kobo.740.1"> data member to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">std::unordered_map&lt;ClientId, std::unordered_map&lt;OrderId, MEOrder *&gt;&gt;</span></strong><span class="koboSpan" id="kobo.742.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">ClientOrderHashMap</span></strong><span class="koboSpan" id="kobo.744.1">, which is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">typedef</span></strong><span class="koboSpan" id="kobo.746.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">std::array&lt;OrderHashMap, ME_MAX_NUM_CLIENTS&gt;</span></strong><span class="koboSpan" id="kobo.748.1">. </span><span class="koboSpan" id="kobo.748.2">This data member is a hash map from </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">ClientId</span></strong><span class="koboSpan" id="kobo.750.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">OrderId</span></strong><span class="koboSpan" id="kobo.752.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">MEOrder</span></strong><span class="koboSpan" id="kobo.754.1"> objects. </span><span class="koboSpan" id="kobo.754.2">Remember that </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">ClientOrderHashMap</span></strong><span class="koboSpan" id="kobo.756.1"> is actually a hash map of hash maps, that is, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">std::array</span></strong><span class="koboSpan" id="kobo.758.1"> whose elements are also </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">std::array</span></strong><span class="koboSpan" id="kobo.760.1"> objects. </span><span class="koboSpan" id="kobo.760.2">The other data member we change is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">price_orders_at_price_</span></strong><span class="koboSpan" id="kobo.762.1"> member, which we change to </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">std::unordered_map&lt;Price, MEOrdersAtPrice *&gt;</span></strong><span class="koboSpan" id="kobo.764.1"> instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">OrdersAtPriceHashMap</span></strong><span class="koboSpan" id="kobo.766.1"> type. </span><span class="koboSpan" id="kobo.766.2">This data member is a hash map from </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">Price</span></strong><span class="koboSpan" id="kobo.768.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.770.1"> objects. </span><span class="koboSpan" id="kobo.770.2">If you have forgotten what </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">MEOrder</span></strong><span class="koboSpan" id="kobo.772.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">MEOrdersAtPrice</span></strong><span class="koboSpan" id="kobo.774.1"> are, please revisit the </span><em class="italic"><span class="koboSpan" id="kobo.775.1">Designing the exchange order book</span></em><span class="koboSpan" id="kobo.776.1"> sub-section in the </span><em class="italic"><span class="koboSpan" id="kobo.777.1">Defining the operations and interactions in our matching engine</span></em><span class="koboSpan" id="kobo.778.1"> section of the chapter </span><em class="italic"><span class="koboSpan" id="kobo.779.1">Building the C++ Matching Engine</span></em><span class="koboSpan" id="kobo.780.1">. </span><span class="koboSpan" id="kobo.780.2">These changes are </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.782.1">
namespace Exchange {
  class UnorderedMapMEOrderBook final {
  private:
    ...
</span><span class="koboSpan" id="kobo.782.2">    std::unordered_map&lt;ClientId, std::
      unordered_map&lt;OrderId, MEOrder *&gt;&gt; cid_oid_to_order_;
    std::unordered_map&lt;Price, MEOrdersAtPrice *&gt;
      price_orders_at_price_;
    ...
</span><span class="koboSpan" id="kobo.782.3">  };
}</span></pre>
<p><span class="koboSpan" id="kobo.783.1">We will need to</span><a id="_idIndexMarker1582"/><span class="koboSpan" id="kobo.784.1"> remove the following lines from the</span><a id="_idIndexMarker1583"/><span class="koboSpan" id="kobo.785.1"> destructor since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">fill()</span></strong><span class="koboSpan" id="kobo.787.1"> method does not apply to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">std::unordered_map</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.789.1"> objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.790.1">
  MEOrderBook::~MEOrderBook() {
    …
    for (auto &amp;itr: cid_oid_to_order_) {
      itr.fill(nullptr);
    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.791.1">In terms of accessing these modified containers, we replace the calls to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">std::array::at()</span></strong><span class="koboSpan" id="kobo.793.1"> method for </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">cid_oid_to_order_</span></strong><span class="koboSpan" id="kobo.795.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">price_orders_at_price_</span></strong><span class="koboSpan" id="kobo.797.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">std::unordered_map::operator[]</span></strong><span class="koboSpan" id="kobo.799.1"> method. </span><span class="koboSpan" id="kobo.799.2">These changes for </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">cid_oid_to_order_</span></strong><span class="koboSpan" id="kobo.801.1"> are </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.803.1">
    auto removeOrder(MEOrder *order) noexcept {
      ...
</span><span class="koboSpan" id="kobo.803.2">      cid_oid_to_order_[order-&gt;client_id_][order-&gt;
        client_order_id_] = nullptr;
      order_pool_.deallocate(order);
    }
    auto addOrder(MEOrder *order) noexcept {
      ...
</span><span class="koboSpan" id="kobo.803.3">      cid_oid_to_order_[order-&gt;client_id_][order-&gt;
        client_order_id_] = order;
    }
  auto UnorderedMapMEOrderBook::cancel(ClientId client_id,
    OrderId order_id, TickerId ticker_id) noexcept -&gt; void {
    auto is_cancelable = (client_id &lt;
      cid_oid_to_order_.size());
    MEOrder *exchange_order = nullptr;
    if (LIKELY(is_cancelable)) {
      auto &amp;co_itr = cid_oid_to_order_[client_id];
      exchange_order = co_itr[order_id];
      is_cancelable = (exchange_order != nullptr);
    }
    ...
</span><span class="koboSpan" id="kobo.803.4">  }</span></pre>
<p><span class="koboSpan" id="kobo.804.1">We need to make similar changes in </span><a id="_idIndexMarker1584"/><span class="koboSpan" id="kobo.805.1">spots where we access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">price_orders_at_price_</span></strong><span class="koboSpan" id="kobo.807.1"> container, which is </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.809.1">
    auto getOrdersAtPrice(Price price) const noexcept -&gt;
      MEOrdersAtPrice * {
      if(price_orders_at_price_.find(priceToIndex(price))
        == price_orders_at_price_.end())
        return nullptr;
      return price_orders_at_price_
        .at(priceToIndex(price));
    }
    auto addOrdersAtPrice(MEOrdersAtPrice
      *new_orders_at_price) noexcept {
      price_orders_at_price_
        [priceToIndex(new_orders_at_price-&gt;price_)] =
          new_orders_at_price;
      ...
</span><span class="koboSpan" id="kobo.809.2">    }
    auto removeOrdersAtPrice(Side side, Price price)
      noexcept {
      ...
</span><span class="koboSpan" id="kobo.809.3">      price_orders_at_price_[priceToIndex(price)] =
        nullptr;
      orders_at_price_pool_.deallocate(orders_at_price);
    }</span></pre>
<p><span class="koboSpan" id="kobo.810.1">Finally, we present the </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">hash_benchmark</span></strong><span class="koboSpan" id="kobo.812.1"> binary to measure the performance differences because of these</span><a id="_idIndexMarker1585"/><span class="koboSpan" id="kobo.813.1"> changes. </span><span class="koboSpan" id="kobo.813.2">The source code for this binary can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">Chapter12/benchmarks/hash_benchmark.cpp</span></strong><span class="koboSpan" id="kobo.815.1"> source file. </span><span class="koboSpan" id="kobo.815.2">First, we include the header files shown as follows and also define a global </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">loop_count</span></strong><span class="koboSpan" id="kobo.817.1"> variable as we have done in our </span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">previous benchmarks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.819.1">
#include "matcher/matching_engine.h"
#include "matcher/unordered_map_me_order_book.h"
static constexpr size_t loop_count = 100000;</span></pre>
<p><span class="koboSpan" id="kobo.820.1">As we have done before, we will define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">benchmarkHashMap()</span></strong><span class="koboSpan" id="kobo.822.1"> method, which accepts a template parameter, </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">T</span></strong><span class="koboSpan" id="kobo.824.1">, to represent either </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">MEOrderBook</span></strong><span class="koboSpan" id="kobo.826.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">UnorderedMapMEOrderBook</span></strong><span class="koboSpan" id="kobo.828.1">. </span><span class="koboSpan" id="kobo.828.2">It also accepts a vector of </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">Exchange::MEClientRequest</span></strong><span class="koboSpan" id="kobo.830.1"> messages, which will be processed in the benchmark. </span><span class="koboSpan" id="kobo.830.2">The actual processing is </span><a id="_idIndexMarker1586"/><span class="koboSpan" id="kobo.831.1">quite simple. </span><span class="koboSpan" id="kobo.831.2">It checks the type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.833.1"> and then calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">add()</span></strong><span class="koboSpan" id="kobo.835.1"> method for </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">ClientRequestType::NEW</span></strong><span class="koboSpan" id="kobo.837.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">cancel()</span></strong><span class="koboSpan" id="kobo.839.1"> method for </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">ClientRequestType::CANCEL</span></strong><span class="koboSpan" id="kobo.841.1">. </span><span class="koboSpan" id="kobo.841.2">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">Common::rdtsc()</span></strong><span class="koboSpan" id="kobo.843.1"> to measure and sum up the clock cycles elapsed for each of these calls and then return the average at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">this method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.845.1">
template&lt;typename T&gt;
size_t benchmarkHashMap(T *order_book, const
  std::vector&lt;Exchange::MEClientRequest&gt;&amp; client_requests) {
  size_t total_rdtsc = 0;
  for (size_t i = 0; i &lt; loop_count; ++i) {
    const auto&amp; client_request = client_requests[i];
    switch (client_request.type_) {
      case Exchange::ClientRequestType::NEW: {
        const auto start = Common::rdtsc();
        order_book-&gt;add(client_request.client_id_,
          client_request.order_id_,
            client_request.ticker_id_,
                        client_request.side_,
                          client_request.price_,
                            client_request.qty_);
        total_rdtsc += (Common::rdtsc() - start);
      }
        break;
      case Exchange::ClientRequestType::CANCEL: {
        const auto start = Common::rdtsc();
        order_book-&gt;cancel(client_request.client_id_,
          client_request.order_id_,
            client_request.ticker_id_);
        total_rdtsc += (Common::rdtsc() - start);
      }
        break;
      default:
        break;
    }
  }
  return (total_rdtsc / (loop_count * 2));
}</span></pre>
<p><span class="koboSpan" id="kobo.846.1">Now we can look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">main()</span></strong><span class="koboSpan" id="kobo.848.1"> method. </span><span class="koboSpan" id="kobo.848.2">We need </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">Logger</span></strong><span class="koboSpan" id="kobo.850.1"> and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.852.1"> object to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">MEOrderBook</span></strong><span class="koboSpan" id="kobo.854.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">UnorderedMapMEOrderBook</span></strong><span class="koboSpan" id="kobo.856.1"> object, but to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.858.1"> object, we need</span><a id="_idIndexMarker1587"/><span class="koboSpan" id="kobo.859.1"> three lock-free queues as we have seen in the implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">exchange_main</span></strong><span class="koboSpan" id="kobo.861.1"> binary. </span><span class="koboSpan" id="kobo.861.2">So, we create these objects as shown here, even though we are not measuring the performance of any of </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">these components:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.863.1">
int main(int, char **) {
  srand(0);
  Common::Logger logger("hash_benchmark.log");
  Exchange::ClientRequestLFQueue
    client_requests(ME_MAX_CLIENT_UPDATES);
  Exchange::ClientResponseLFQueue
    client_responses(ME_MAX_CLIENT_UPDATES);
  Exchange::MEMarketUpdateLFQueue
    market_updates(ME_MAX_MARKET_UPDATES);
  auto matching_engine = new Exchange::
    MatchingEngine(&amp;client_requests, &amp;client_responses,
      &amp;market_updates);</span></pre>
<p><span class="koboSpan" id="kobo.864.1">Next, we will create a vector of 100,000 (</span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">loop_count</span></strong><span class="koboSpan" id="kobo.866.1">) </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">MEClientRequest</span></strong><span class="koboSpan" id="kobo.868.1"> objects, which will be composed of new order requests as well as requests to cancel these orders. </span><span class="koboSpan" id="kobo.868.2">We have seen</span><a id="_idIndexMarker1588"/><span class="koboSpan" id="kobo.869.1"> similar code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">trading_main</span></strong><span class="koboSpan" id="kobo.871.1"> application for the random </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">trading algorithm:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.873.1">
  Common::OrderId order_id = 1000;
  std::vector&lt;Exchange::MEClientRequest&gt;
    client_requests_vec;
  Price base_price = (rand() % 100) + 100;
  while (client_requests_vec.size() &lt; loop_count) {
    const Price price = base_price + (rand() % 10) + 1;
    const Qty qty = 1 + (rand() % 100) + 1;
    const Side side = (rand() % 2 ? </span><span class="koboSpan" id="kobo.873.2">Common::Side::BUY :
      Common::Side::SELL);
    Exchange::MEClientRequest new_request
      {Exchange::ClientRequestType::NEW, 0, 0, order_id++,
        side, price, qty};
    client_requests_vec.push_back(new_request);
    const auto cxl_index = rand() %
      client_requests_vec.size();
    auto cxl_request = client_requests_vec[cxl_index];
    cxl_request.type_ =
      Exchange::ClientRequestType::CANCEL;
    client_requests_vec.push_back(cxl_request);
  }</span></pre>
<p><span class="koboSpan" id="kobo.874.1">Finally, we</span><a id="_idIndexMarker1589"/><span class="koboSpan" id="kobo.875.1"> end the </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">main()</span></strong><span class="koboSpan" id="kobo.877.1"> method by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">benchmarkHashMap()</span></strong><span class="koboSpan" id="kobo.879.1"> method twice – once with an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">MEOrderBook</span></strong><span class="koboSpan" id="kobo.881.1"> and once with an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">UnorderedMapMEOrderBook</span></strong><span class="koboSpan" id="kobo.883.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">as shown:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.885.1">
  {
    auto me_order_book = new Exchange::MEOrderBook(0,
      &amp;logger, matching_engine);
    const auto cycles = benchmarkHashMap(me_order_book,
      client_requests_vec);
    std::cout &lt;&lt; "ARRAY HASHMAP " &lt;&lt; cycles &lt;&lt; " CLOCK
      CYCLES PER OPERATION." </span><span class="koboSpan" id="kobo.885.2">&lt;&lt; std::endl;
  }
  {
    auto me_order_book = new Exchange::
      UnorderedMapMEOrderBook(0, &amp;logger, matching_engine);
    const auto cycles = benchmarkHashMap(me_order_book,
      client_requests_vec);
    std::cout &lt;&lt; "UNORDERED-MAP HASHMAP " &lt;&lt; cycles &lt;&lt; "
      CLOCK CYCLES PER OPERATION." </span><span class="koboSpan" id="kobo.885.3">&lt;&lt; std::endl;
  }
  exit(EXIT_SUCCESS);
}</span></pre>
<p><span class="koboSpan" id="kobo.886.1">The process to build this application remains the same, which is by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">scripts/build.sh</span></strong><span class="koboSpan" id="kobo.888.1"> script from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">Chapter12</span></strong><span class="koboSpan" id="kobo.890.1"> root directory. </span><span class="koboSpan" id="kobo.890.2">Running the application by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">hash_benchmark</span></strong><span class="koboSpan" id="kobo.892.1"> binary will yield output like what is shown here, with some variance</span><a id="_idIndexMarker1590"/><span class="koboSpan" id="kobo.893.1"> between independent runs and depending on </span><span class="No-Break"><span class="koboSpan" id="kobo.894.1">the system:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.895.1">
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter12$ ./cmake-build-release/hash_benchmark
Set core affinity for Common/Logger hash_benchmark.log 140327631447616 to -1
Set core affinity for Common/Logger exchange_matching_engine.log 140327461033536 to -1
ARRAY HASHMAP 142650 CLOCK CYCLES PER OPERATION.
</span><span class="koboSpan" id="kobo.895.2">UNORDERED-MAP HASHMAP 152457 CLOCK CYCLES PER OPERATION.</span></pre>
<p><span class="koboSpan" id="kobo.896.1">Based on the output of this run, it appears that switching from a </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">std::array</span></strong><span class="koboSpan" id="kobo.898.1"> hash map implementation to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">std::unordered_map</span></strong><span class="koboSpan" id="kobo.900.1"> hash map implementation adds an approximate 6 to 7% extra overhead to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">MEOrderBook</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.902.1">add()</span></strong><span class="koboSpan" id="kobo.903.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">cancel()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.905.1"> performance.</span></span></p>
<h2 id="_idParaDest-313"><a id="_idTextAnchor326"/><span class="koboSpan" id="kobo.906.1">Optimizing snapshot messages</span></h2>
<p><span class="koboSpan" id="kobo.907.1">In our design of the</span><a id="_idIndexMarker1591"/><span class="koboSpan" id="kobo.908.1"> snapshot messages in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">MarketDataPublisher</span></strong><span class="koboSpan" id="kobo.910.1"> component at the trading exchange, a full cycle of snapshot messages between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">START_SNAPSHOT</span></strong><span class="koboSpan" id="kobo.912.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">END_SNAPSHOT</span></strong><span class="koboSpan" id="kobo.914.1"> messages contains the snapshot for all trading instruments, as shown in the following diagram (which we have seen before). </span><span class="koboSpan" id="kobo.914.2">In our </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">SnapshotSynthesizer</span></strong><span class="koboSpan" id="kobo.916.1">, this full snapshot for all trading instruments is published once every 60 seconds. </span><span class="koboSpan" id="kobo.916.2">What this means is that if the order books for each of these trading instruments have a lot of orders, then every 60 seconds, there is a huge spike in network traffic on the snapshot multicast channels followed by silence in the remaining </span><span class="No-Break"><span class="koboSpan" id="kobo.917.1">60 seconds.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer084">
<span class="koboSpan" id="kobo.918.1"><img alt="Figure 12.12 – Current composition of snapshot messages" src="image/B19434_12_012.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.919.1">Figure 12.12 – Current composition of snapshot messages</span></p>
<p><span class="koboSpan" id="kobo.920.1">It would be an</span><a id="_idIndexMarker1592"/><span class="koboSpan" id="kobo.921.1"> enhancement to this design if we changed this such that these snapshots are spaced out more evenly and each snapshot cycle contained the snapshot messages corresponding to only one </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">TickerId</span></strong><span class="koboSpan" id="kobo.923.1">. </span><span class="koboSpan" id="kobo.923.2">As a simple example, instead of sending a snapshot message cycle for 6 instruments every 60 seconds, we can send 6 snapshots each containing information for a single instrument, and each of these snapshots is spaced out with 10 seconds in between them. </span><span class="koboSpan" id="kobo.923.3">This hypothetical proposal is represented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">following diagram.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer085">
<span class="koboSpan" id="kobo.925.1"><img alt="Figure 12.13 – A proposal for an optimized snapshot messaging format" src="image/B19434_12_013.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.926.1">Figure 12.13 – A proposal for an optimized snapshot messaging format</span></p>
<p><span class="koboSpan" id="kobo.927.1">In this new proposal, as we mentioned, there are fewer spikes in network traffic since the full snapshot is </span><a id="_idIndexMarker1593"/><span class="koboSpan" id="kobo.928.1">distributed over time. </span><span class="koboSpan" id="kobo.928.2">This leads to a lower chance of dropping packets on the snapshot multicast stream for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">MarketDataConsumer</span></strong><span class="koboSpan" id="kobo.930.1"> components in the trading client’s systems. </span><span class="koboSpan" id="kobo.930.2">This also leads to the client’s system synchronizing or catching up with the snapshot stream for each trading instrument faster, since it does not need to wait for the full snapshot across all trading instruments before it can mark some of the instruments </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">as </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.932.1">recovered</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.933.1">.</span></span></p>
<h2 id="_idParaDest-314"><a id="_idTextAnchor327"/><span class="koboSpan" id="kobo.934.1">Adding authentication and rejection messages to the Order protocol</span></h2>
<p><span class="koboSpan" id="kobo.935.1">Our electronic trading </span><a id="_idIndexMarker1594"/><span class="koboSpan" id="kobo.936.1">exchange right now</span><a id="_idIndexMarker1595"/><span class="koboSpan" id="kobo.937.1"> has no concept of user authentication and is missing a lot of error checking and handling. </span><span class="koboSpan" id="kobo.937.2">By this, we mean that it does not check whether clients log in with the correct credentials and are authorized to trade the instruments they try to trade. </span><span class="koboSpan" id="kobo.937.3">Additionally, if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">ClientId</span></strong><span class="koboSpan" id="kobo.939.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">TCPSocket</span></strong><span class="koboSpan" id="kobo.941.1"> instances do not match or there is a sequence number gap in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">ClientRequest</span></strong><span class="koboSpan" id="kobo.943.1"> messages that a client sends, we quietly ignore it in </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">Exchange::OrderServer</span></strong><span class="koboSpan" id="kobo.945.1">. </span><span class="koboSpan" id="kobo.945.2">This is </span><a id="_idIndexMarker1596"/><span class="koboSpan" id="kobo.946.1">shown in the following code block from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">exchange/order_server/order_server.h</span></strong><span class="koboSpan" id="kobo.948.1"> source file, which we have already discussed </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">in detail:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.950.1">
    auto recvCallback(TCPSocket *socket, Nanos rx_time)       noexcept {
      ...
</span><span class="koboSpan" id="kobo.950.2">      if (socket-&gt;next_rcv_valid_index_ &gt;=         sizeof(OMClientRequest)) {
          ...
</span><span class="koboSpan" id="kobo.950.3">          if (cid_tcp_socket_[request-&gt;            me_client_request_.client_id_] != socket) {
            ...
</span><span class="koboSpan" id="kobo.950.4">            continue;
          }
          auto &amp;next_exp_seq_num =             cid_next_exp_seq_num_[request-&gt;              me_client_request_.client_id_];
          if (request-&gt;seq_num_ != next_exp_seq_num) {
            ...
</span><span class="koboSpan" id="kobo.950.5">            continue;
          }
          ...
</span><span class="koboSpan" id="kobo.950.6">        }
        ...
</span><span class="koboSpan" id="kobo.950.7">      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.951.1">Silently ignoring errors like these is not ideal since the clients are not notified about these errors. </span><span class="koboSpan" id="kobo.951.2">An enhancement to this workflow would be to add a rejection message to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">ClientResponse</span></strong><span class="koboSpan" id="kobo.953.1"> message </span><a id="_idIndexMarker1597"/><span class="koboSpan" id="kobo.954.1">protocol, which the </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">OrderServer</span></strong><span class="koboSpan" id="kobo.956.1"> component can use to notify the clients about these errors. </span><span class="koboSpan" id="kobo.956.2">This enhancement is in addition to the enhancements we </span><a id="_idIndexMarker1598"/><span class="koboSpan" id="kobo.957.1">suggested to the order protocol to facilitate the authentication of the </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">trading clients.</span></span></p>
<h2 id="_idParaDest-315"><a id="_idTextAnchor328"/><span class="koboSpan" id="kobo.959.1">Supporting modify messages in the Order protocol</span></h2>
<p><span class="koboSpan" id="kobo.960.1">Our current order protocol for </span><strong class="source-inline"><span class="koboSpan" id="kobo.961.1">ClientRequest</span></strong><span class="koboSpan" id="kobo.962.1"> messages only supports </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">ClientRequestType::NEW</span></strong><span class="koboSpan" id="kobo.964.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">ClientRequestType::CANCEL</span></strong><span class="koboSpan" id="kobo.966.1"> requests. </span><span class="koboSpan" id="kobo.966.2">An enhancement to this protocol would be to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">ClientRequestType::MODIFY</span></strong><span class="koboSpan" id="kobo.968.1"> message type so that </span><a id="_idIndexMarker1599"/><span class="koboSpan" id="kobo.969.1">client trading systems can modify their order’s price or quantity attributes. </span><span class="koboSpan" id="kobo.969.2">We would need to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">OrderServer</span></strong><span class="koboSpan" id="kobo.971.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">MatchingEngine</span></strong><span class="koboSpan" id="kobo.973.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.974.1">MEOrderBook</span></strong><span class="koboSpan" id="kobo.975.1">, and other components on the exchange’s side and update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">OrderGateway</span></strong><span class="koboSpan" id="kobo.977.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">OrderManager</span></strong><span class="koboSpan" id="kobo.979.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.981.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">TradeEngine</span></strong><span class="koboSpan" id="kobo.983.1">, and other components on the trading </span><span class="No-Break"><span class="koboSpan" id="kobo.984.1">client’s side.</span></span></p>
<h2 id="_idParaDest-316"><a id="_idTextAnchor329"/><span class="koboSpan" id="kobo.985.1">Enhancing trade engine components</span></h2>
<p><span class="koboSpan" id="kobo.986.1">The trade engine has </span><a id="_idIndexMarker1600"/><span class="koboSpan" id="kobo.987.1">several components that can be improved and/or enhanced. </span><span class="koboSpan" id="kobo.987.2">In this section, we provide brief descriptions of these improvements for each of the components with potential </span><span class="No-Break"><span class="koboSpan" id="kobo.988.1">future enhancements.</span></span></p>
<h3><span class="koboSpan" id="kobo.989.1">Adding risk metrics to RiskManager</span></h3>
<p><span class="koboSpan" id="kobo.990.1">In the</span><a id="_idIndexMarker1601"/><span class="koboSpan" id="kobo.991.1"> chapter </span><em class="italic"><span class="koboSpan" id="kobo.992.1">Designing Our Trading Ecosystem</span></em><span class="koboSpan" id="kobo.993.1">, in the </span><em class="italic"><span class="koboSpan" id="kobo.994.1">Understanding the risk management systems</span></em><span class="koboSpan" id="kobo.995.1"> section, we described a couple of different risk metrics. </span><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">RiskManager</span></strong><span class="koboSpan" id="kobo.997.1"> was built only with a small subset of those risk metrics and can be enhanced by adding additional risk </span><a id="_idIndexMarker1602"/><span class="koboSpan" id="kobo.998.1">measures, as described in </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">that section.</span></span></p>
<h3><span class="koboSpan" id="kobo.1000.1">Enhancing OrderManager</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1002.1"> was built extremely simply – it supports a maximum of one active order on each side, that is, at most one buy order and one sell order. </span><span class="koboSpan" id="kobo.1002.2">Obviously, this is an extremely simplified </span><a id="_idIndexMarker1603"/><span class="koboSpan" id="kobo.1003.1">version and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1004.1">OrderManager</span></strong><span class="koboSpan" id="kobo.1005.1"> can be enhanced to support much more complex </span><span class="No-Break"><span class="koboSpan" id="kobo.1006.1">order management.</span></span></p>
<h3><span class="koboSpan" id="kobo.1007.1">Enriching FeatureEngine</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">FeatureEngine</span></strong><span class="koboSpan" id="kobo.1009.1"> was set up with two</span><a id="_idIndexMarker1604"/><span class="koboSpan" id="kobo.1010.1"> hardcoded features built into it. </span><span class="koboSpan" id="kobo.1010.2">It can be enriched a lot to support complex configurations of features, a library of diverse types of features, complex interactions between these features, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1011.1">so on.</span></span></p>
<h3><span class="koboSpan" id="kobo.1012.1">Enhancing the trading algorithms</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1013.1">LiquidityTaker</span></strong><span class="koboSpan" id="kobo.1014.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">MarketMaker</span></strong><span class="koboSpan" id="kobo.1016.1"> in this book were also extremely simple representations of realistic</span><a id="_idIndexMarker1605"/><span class="koboSpan" id="kobo.1017.1"> trading strategies. </span><span class="koboSpan" id="kobo.1017.2">These can be enhanced/improved in many ways – improvements in terms of feature compositions, order management, efficient execution, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1018.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.1019.1">This concludes our discussion of future enhancement possibilities for our electronic </span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1">trading ecosystem.</span></span></p>
<h1 id="_idParaDest-317"><a id="_idTextAnchor330"/><span class="koboSpan" id="kobo.1021.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1022.1">The first section of this chapter focused on analyzing the latency metrics we added to our electronic trading systems in the previous chapter. </span><span class="koboSpan" id="kobo.1022.2">We discussed a few examples of latency measurements for internal functions, as well as a few examples of latency measurements between critical hops in our system. </span><span class="koboSpan" id="kobo.1022.3">The goal was to understand the distribution of latencies in different cases so that you understand how to identify and investigate areas of potential problems or </span><span class="No-Break"><span class="koboSpan" id="kobo.1023.1">optimization opportunities.</span></span></p>
<p><span class="koboSpan" id="kobo.1024.1">In the second section of this chapter, we discussed a few tips and techniques regarding how to approach potential performance optimization possibilities. </span><span class="koboSpan" id="kobo.1024.2">We presented a few examples of what could be improved and discussed the performance problems that exist in the current design and solutions to </span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1">those problems.</span></span></p>
<p><span class="koboSpan" id="kobo.1026.1">In the concluding section, we described a roadmap for the future of the electronic trading ecosystem we built in this book. </span><span class="koboSpan" id="kobo.1026.2">We discussed several different components, sub-components, and workflows that can be enriched to build a more mature electronic </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">trading ecosystem.</span></span></p>
<p><span class="koboSpan" id="kobo.1028.1">The approach and principles we discussed in this book pertaining to latency-sensitive applications developed in C++ should guide you on your journey. </span><span class="koboSpan" id="kobo.1028.2">The full end-to-end electronic trading ecosystem we built is a prime example of a low-latency application and hopefully provided a good practical example of how to build a low-latency application from scratch. </span><span class="koboSpan" id="kobo.1028.3">Hopefully, this chapter added to the experience by providing you with tools to analyze the performance and iteratively improve the system. </span><span class="koboSpan" id="kobo.1028.4">We wish you all the best as you continue your low-latency application </span><span class="No-Break"><span class="koboSpan" id="kobo.1029.1">development journey!</span></span></p>
</div>
</body></html>