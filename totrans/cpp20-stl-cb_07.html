<html><head></head><body>
		<div id="_idContainer038">
			<h1 id="_idParaDest-213"><em class="italic"><a id="_idTextAnchor212"/>Chapter 7</em>: Strings, Streams, and Formatting</h1>
			<p>The STL <strong class="source-inline">string</strong> class is a powerful, full-featured tool for storing, manipulating, and displaying character-based data. It has much of the convenience you would find in a high-level scripting language, yet remains as quick and agile as you would expect from C++.</p>
			<p>The <strong class="source-inline">string</strong> class is based on <strong class="source-inline">basic_string</strong>, a contiguous container class that may be instantiated with any character type. Its class signature looks like this:</p>
			<p class="source-code">template&lt;</p>
			<p class="source-code">    typename CharT,</p>
			<p class="source-code">    typename Traits = std::char_traits&lt;CharT&gt;,</p>
			<p class="source-code">    typename Allocator = std::allocator&lt;CharT&gt;</p>
			<p class="source-code">&gt; class basic_string;</p>
			<p>The <strong class="source-inline">Traits</strong> and <strong class="source-inline">Allocator</strong> template parameters are usually left to their default values.</p>
			<p>The underlying storage of <strong class="source-inline">basic_string</strong> is a contiguous sequence of <strong class="source-inline">CharT</strong>, and can be accessed with the <strong class="source-inline">data()</strong> member function:</p>
			<p class="source-code">const <strong class="bold">std::basic_string&lt;char&gt;</strong> s{"hello"};</p>
			<p class="source-code">const char * sdata = <strong class="bold">s.data()</strong>;</p>
			<p class="source-code">for(size_t i{0}; i &lt; s.size(); ++i) {</p>
			<p class="source-code">    cout &lt;&lt; sdata[i] &lt;&lt; ' ';</p>
			<p class="source-code">}</p>
			<p class="source-code">cout &lt;&lt; '\n';</p>
			<p>Output:</p>
			<p class="source-code">h e l l o</p>
			<p>The <strong class="source-inline">data()</strong> member function returns a <strong class="source-inline">CharT*</strong> that points to the underlying array of characters. Since C++11, the array returned by <strong class="source-inline">data()</strong> is null-terminated, making <strong class="source-inline">data()</strong> equivalent to <strong class="source-inline">c_str()</strong>.</p>
			<p>The <strong class="source-inline">basic_string</strong> class includes many of the methods you would find in other contiguous-storage classes, including <strong class="source-inline">insert()</strong>, <strong class="source-inline">erase()</strong>, <strong class="source-inline">push_back()</strong>, <strong class="source-inline">pop_back()</strong>, and others. These methods operate on the underlying array of <strong class="source-inline">CharT</strong>.</p>
			<p><strong class="source-inline">std::string</strong> is a type alias for <strong class="source-inline">std::basic_string&lt;char&gt;</strong>:</p>
			<p class="source-code">using std::string = std::basic_string&lt;char&gt;;</p>
			<p>For most purposes, you'll use <strong class="source-inline">std::string</strong>.</p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor213"/>String formatting</h1>
			<p>String formatting has traditionally been a weak point with the STL. Until recently, we've been left with an imperfect choice between the cumbersome STL <strong class="source-inline">iostreams</strong> or the archaic legacy <strong class="source-inline">printf()</strong>. Beginning with C++20 and the <strong class="source-inline">format</strong> library, STL string formatting has finally grown up. Closely based on Python's <strong class="source-inline">str.format()</strong> method, the new <strong class="source-inline">format</strong> library is fast and flexible, providing many of the advantages of both <strong class="source-inline">iostreams</strong> and <strong class="source-inline">printf()</strong>, along with good memory management and type safety.</p>
			<p>For more about the <strong class="source-inline">format</strong> library, see the <em class="italic">Format text with the new format library</em> recipe in <a href="B18267_01_ePub.xhtml#_idTextAnchor027"><em class="italic">Chaper 1</em></a>, <em class="italic">New C++20 Features</em>.</p>
			<p>While we no longer need to use <strong class="source-inline">iostreams</strong> for string formatting, it is still quite useful for other purposes, including file and stream I/O, and some type conversions.</p>
			<p>In this chapter, we will cover these subjects and more in the following recipes:</p>
			<ul>
				<li>Use <strong class="source-inline">string_view</strong> as a lightweight string object</li>
				<li>Concatenate strings</li>
				<li>Transform strings</li>
				<li>Format text with C++20's <strong class="source-inline">format</strong> library</li>
				<li>Trim whitespace from strings</li>
				<li>Read strings from user input</li>
				<li>Count words in a file</li>
				<li>Initialize complex structures from file input</li>
				<li>Customize a string class with <strong class="source-inline">char_traits</strong></li>
				<li>Parse strings with Regular Expressions</li>
			</ul>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor214"/>Technical requirements</h1>
			<p>You can find code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap07">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap07</a>.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor215"/>Use string_view as a lightweight string object</h1>
			<p>The <strong class="source-inline">string_view</strong> class provides a lightweight alternative to the <strong class="source-inline">string</strong> class. Instead of maintaining its own data<a id="_idIndexMarker561"/> store, <strong class="source-inline">string_view</strong> operates on a <em class="italic">view</em> of a C-string. This makes <strong class="source-inline">string_view</strong> smaller and more efficient than <strong class="source-inline">std::string</strong>. It's useful in cases where you need a string object but don't <a id="_idIndexMarker562"/>need the more memory- and computation-intensive features of <strong class="source-inline">std::string</strong>.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor216"/>How to do it…</h2>
			<p>The <strong class="source-inline">string_view</strong> class looks deceptively similar to the STL <strong class="source-inline">string</strong> class, but it works a bit differently. Let's consider some examples:</p>
			<ul>
				<li>Here's an STL <strong class="source-inline">string</strong> initialized from a C-string (array of <strong class="source-inline">char</strong>):<p class="source-code">char text[]{ "hello" };</p><p class="source-code">string greeting{ text };</p><p class="source-code">text[0] = 'J';</p><p class="source-code">cout &lt;&lt; text &lt;&lt; ' ' &lt;&lt; greeting &lt;&lt; '\n';</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">Jello hello</strong></p>
			<p>Notice that the <strong class="source-inline">string</strong> does not change when we modify the array. This is because the <strong class="source-inline">string</strong> constructor creates its own copy of the underlying data.</p>
			<ul>
				<li>When we do the same with a <strong class="source-inline">string_view</strong>, we get a different result:<p class="source-code">char text[]{ "hello" };</p><p class="source-code">string_view greeting{ text };</p><p class="source-code">text[0] = 'J';</p><p class="source-code">cout &lt;&lt; text &lt;&lt; ' ' &lt;&lt; greeting &lt;&lt; '\n';</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">Jello Jello</strong></p>
			<p>The <strong class="source-inline">string_view</strong> constructor creates a <em class="italic">view</em> of the underlying data. It does not make its own copy. This results in significant efficiencies but also allows for side effects.</p>
			<ul>
				<li>Because <strong class="source-inline">string_view</strong> doesn't copy the<a id="_idIndexMarker563"/> underlying data, the <a id="_idIndexMarker564"/>source data must remain in scope for the duration of the <strong class="source-inline">string_view</strong> object. So, this does not work:<p class="source-code">string_view sv() {</p><p class="source-code">    <strong class="bold">const char text[]{ "hello" }</strong>;  // temporary storage</p><p class="source-code">    string_view greeting{ text };</p><p class="source-code">    return greeting;</p><p class="source-code">}</p><p class="source-code">int main() {</p><p class="source-code">    <strong class="bold">string_view greeting = sv();</strong>  // data out of scope</p><p class="source-code">    cout &lt;&lt; <strong class="bold">greeting</strong> &lt;&lt; '\n';  // output undefined</p><p class="source-code">}</p></li>
			</ul>
			<p>Because the underlying data goes out of scope after the <strong class="source-inline">sv()</strong> function returns, the <strong class="source-inline">greeting</strong> object in <strong class="source-inline">main()</strong> is no longer valid by the time we use it.</p>
			<ul>
				<li>The <strong class="source-inline">string_view</strong> class has constructors that make sense for the underlying data. This includes character arrays (<strong class="source-inline">const char*</strong>), contiguous <em class="italic">ranges</em> (including <strong class="source-inline">std::string</strong>), and other <strong class="source-inline">string_view</strong> objects. This example uses the <em class="italic">ranges</em> constructor:<p class="source-code">string str{ "hello" };</p><p class="source-code">string_view greeting{ str };</p><p class="source-code">cout &lt;&lt; greeting &lt;&lt; '\n';</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">hello</strong></p>
			<ul>
				<li>There is also<a id="_idIndexMarker565"/> a <strong class="source-inline">string_view</strong> literal <a id="_idIndexMarker566"/>operator <strong class="source-inline">sv</strong>, defined in the <strong class="source-inline">std::literals</strong> namespace:<p class="source-code">using namespace std::literals;</p><p class="source-code">cout &lt;&lt; "hello"sv.substr(1, 4) &lt;&lt; '\n';</p></li>
			</ul>
			<p>This constructs a <strong class="source-inline">constexpr string_view</strong> object and calls its method <strong class="source-inline">substr()</strong> to get the <strong class="source-inline">4</strong> values starting at index <strong class="source-inline">1</strong>.</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">ello</strong></p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor217"/>How it works…</h2>
			<p>The <strong class="source-inline">string_view</strong> class is effectively an <em class="italic">iterator adapter</em> on a contiguous sequence of characters. The implementation typically has two members: a <strong class="source-inline">const CharT *</strong> and a <strong class="source-inline">size_t</strong>. It works by wrapping a <strong class="source-inline">contiguous_iterator</strong> around the source data.</p>
			<p>This means that you can use it like <strong class="source-inline">std::string</strong> for many purposes, with a few important distinctions:</p>
			<ul>
				<li>The copy constructor does not copy the data. This means that when you make a copy of a <strong class="source-inline">string_view</strong>, each copy operates on the same underlying data:<p class="source-code">char text[]{ "hello" };</p><p class="source-code">string_view sv1{ text };</p><p class="source-code">string_view sv2{ sv1 };</p><p class="source-code">string_view sv3{ sv2 };</p><p class="source-code">string_view sv4{ sv3 };</p><p class="source-code">cout &lt;&lt; format("{} {} {} {}\n", sv1, sv2, sv3, sv4);</p><p class="source-code">text[0] = 'J';</p><p class="source-code">cout &lt;&lt; format("{} {} {} {}\n", sv1, sv2, sv3, sv4);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">hello hello hello hello</strong></p>
			<p class="source-code"><strong class="bold">Jello Jello Jello Jello</strong></p>
			<ul>
				<li>Keep in mind<a id="_idIndexMarker567"/> that when <a id="_idIndexMarker568"/>you pass a <strong class="source-inline">string_view</strong> to a function, it uses the copy constructor:<p class="source-code">void f(string_view sv) {</p><p class="source-code">    if(sv.size()) {</p><p class="source-code">        <strong class="bold">char* x = (char*)sv.data();  // dangerous</strong></p><p class="source-code"><strong class="bold">        x[0] = 'J';</strong>  // modifies the source</p><p class="source-code">    }</p><p class="source-code">    cout &lt;&lt; format("f(sv): {} {}\n", (void*)sv.data(),      sv);</p><p class="source-code">}</p><p class="source-code">int main() {</p><p class="source-code">    char text[]{ "hello" };</p><p class="source-code">    string_view sv1{ text };</p><p class="source-code">    cout &lt;&lt; format("sv1: {} {}\n", (void*)sv1.data(),       sv1);</p><p class="source-code">    f(sv1);</p><p class="source-code">    cout &lt;&lt; format("sv1: {} {}\n", (void*)sv1.data(),       sv1);</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">sv1: 0x7ffd80fa7b2a hello</strong></p>
			<p class="source-code"><strong class="bold">f(sv): 0x7ffd80fa7b2a Jello</strong></p>
			<p class="source-code"><strong class="bold">sv1: 0x7ffd80fa7b2a Jello</strong></p>
			<p>Notice that the address <a id="_idIndexMarker569"/>of the <a id="_idIndexMarker570"/>underlying data (returned by the <strong class="source-inline">data()</strong> member function) is the same for all instances of the <strong class="source-inline">string_view</strong>. That's because the copy constructor does not make a copy of the underlying data. Even though the <strong class="source-inline">string_view</strong> member pointer is <strong class="source-inline">const</strong>-qualified, it's still possible to cast away the <strong class="source-inline">const</strong> qualifier, though it's <em class="italic">not recommended</em> because it could cause unintended side effects. But it is worth noting that the data is never copied.</p>
			<ul>
				<li>The <strong class="source-inline">string_view</strong> class lacks methods that directly operate on the underlying string. Methods such as <strong class="source-inline">append()</strong>, <strong class="source-inline">operator+()</strong>, <strong class="source-inline">push_back()</strong>, <strong class="source-inline">pop_back()</strong>, <strong class="source-inline">replace()</strong>, and <strong class="source-inline">resize()</strong>, which are supported in <strong class="source-inline">string</strong>, are not supported in <strong class="source-inline">string_view</strong>.</li>
			</ul>
			<p>If you need to concatenate strings with the <strong class="source-inline">+</strong> operator, you'll need a <strong class="source-inline">std::string</strong>. For example, this does not work with <strong class="source-inline">string_view</strong>:</p>
			<p class="source-code">sv1 = sv2 + sv3 + sv4; // does not work</p>
			<p>You'll need to use <strong class="source-inline">string</strong> instead:</p>
			<p class="source-code">string str1{ text };</p>
			<p class="source-code">string str2{ str1 };</p>
			<p class="source-code">string str3{ str2 };</p>
			<p class="source-code">string str4{ str3 };</p>
			<p class="source-code">str1 = str2 + str3 + str4; // works</p>
			<p class="source-code">cout &lt;&lt; str1 &lt;&lt; '\n';</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">JelloJelloJello</strong></p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor218"/>Concatenate strings</h1>
			<p>There are several ways<a id="_idIndexMarker571"/> to concatenate strings in C++. In this recipe, we will look at the three most common: the <strong class="source-inline">string</strong> class <strong class="source-inline">operator+()</strong>, the <strong class="source-inline">string</strong> class <strong class="source-inline">append()</strong> function, and the <strong class="source-inline">ostringstream</strong> class <strong class="source-inline">operator&lt;&lt;()</strong>. New in C++20, we also have the <strong class="source-inline">format()</strong> function. Each of these has its advantages, disadvantages, and use cases.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor219"/>How to do it…</h2>
			<p>In this recipe, we will examine ways to concatenate strings. We will then perform some benchmarks and consider the different use cases.</p>
			<ul>
				<li>We'll start with a couple of <strong class="source-inline">std::string</strong> objects:<p class="source-code">string a{ "a" };</p><p class="source-code">string b{ "b" };</p></li>
			</ul>
			<p>The <strong class="source-inline">string</strong> objects are constructed from literal C-strings.</p>
			<p>The C-string constructor makes a copy of the literal string and uses the local copy as the underlying data for the <strong class="source-inline">string</strong> object.</p>
			<ul>
				<li>Now, let's construct a new empty string object and concatenate <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> with a separator and a newline:<p class="source-code">string x{};</p><p class="source-code">x += a + ", " + b + "\n";</p><p class="source-code">cout &lt;&lt; x;</p></li>
			</ul>
			<p>Here, we used the <strong class="source-inline">string</strong> object's <strong class="source-inline">+=</strong> and <strong class="source-inline">+</strong> operators to concatenate the <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> strings, along with literal strings <strong class="source-inline">", "</strong> and <strong class="source-inline">"\n"</strong>. The resulting string has the elements concatenated together:</p>
			<p class="source-code"><strong class="bold">a, b</strong></p>
			<ul>
				<li>We could instead use the <strong class="source-inline">string</strong> object's <strong class="source-inline">append()</strong> member function:<p class="source-code">string x{};</p><p class="source-code">x.append(a);</p><p class="source-code">x.append(", ");</p><p class="source-code">x.append(b);</p><p class="source-code">x.append("\n");</p><p class="source-code">cout &lt;&lt; x;</p></li>
			</ul>
			<p>This gives us the same result:</p>
			<p class="source-code"><strong class="bold">a, b</strong></p>
			<ul>
				<li>Or, we could<a id="_idIndexMarker572"/> construct an <strong class="source-inline">ostringstream</strong> object, which uses the stream interface:<p class="source-code">ostringstream x{};</p><p class="source-code">x &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; "\n";</p><p class="source-code">cout &lt;&lt; x.str();</p></li>
			</ul>
			<p>We get the same result:</p>
			<p class="source-code"><strong class="bold">a, b</strong></p>
			<ul>
				<li>We could also use the C++20 <strong class="source-inline">format()</strong> function:<p class="source-code">string x{};</p><p class="source-code">x = format("{}, {}\n", a, b);</p><p class="source-code">cout &lt;&lt; x;</p></li>
			</ul>
			<p>Again, we have the same result:</p>
			<p class="source-code"><strong class="bold">a, b</strong></p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor220"/>How it works…</h2>
			<p>The <strong class="source-inline">string</strong> object has two<a id="_idIndexMarker573"/> distinct methods for concatenating a string, the <strong class="source-inline">+</strong> operator and the <strong class="source-inline">append()</strong> member function.</p>
			<p>The <strong class="source-inline">append()</strong> member function adds data to the end of the <strong class="source-inline">string</strong> object's data. It must allocate and manage memory to accomplish this.</p>
			<p>The <strong class="source-inline">+</strong> operator uses the <strong class="source-inline">operator+()</strong> overload to construct a new <strong class="source-inline">string</strong> object with the old and new data, and returns the new object.</p>
			<p>The <strong class="source-inline">ostringstream</strong> object works like an <strong class="source-inline">ostream</strong> but stores its output for use as a string.</p>
			<p>The C++20 <strong class="source-inline">format()</strong> function uses a format string with variadic arguments and returns a newly constructed <strong class="source-inline">string</strong> object.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor221"/>There's more…</h2>
			<p>How do you decide which concatenation strategy is right for your code? We can start with some benchmarks.</p>
			<h3>Benchmarks</h3>
			<p>I performed these tests<a id="_idIndexMarker574"/> using GCC 11 on Debian Linux:</p>
			<ul>
				<li>First, we'll create a <strong class="source-inline">timer</strong> function using the <strong class="source-inline">&lt;chrono&gt;</strong> library:<p class="source-code">using std::chrono::high_resolution_clock;</p><p class="source-code">using std::chrono::duration;</p><p class="source-code">void timer(string(*f)()) {</p><p class="source-code">    auto t1 = high_resolution_clock::now();</p><p class="source-code">    string s{ f() };</p><p class="source-code">    auto t2 = high_resolution_clock::now();</p><p class="source-code">    duration&lt;double, std::milli&gt; ms = t2 - t1;</p><p class="source-code">    cout &lt;&lt; s;</p><p class="source-code">    cout &lt;&lt; format("duration: {} ms\n", ms.count());</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">timer</strong> function calls the function passed to it, marking the time before and after the function call. It then displays the duration using <strong class="source-inline">cout</strong>.</p>
			<ul>
				<li>Now, we create a function that <a id="_idIndexMarker575"/>concatenates strings, using the <strong class="source-inline">append()</strong> member function:<p class="source-code">string append_string() {</p><p class="source-code">    cout &lt;&lt; "append_string\n";</p><p class="source-code">    string a{ "a" };</p><p class="source-code">    string b{ "b" };</p><p class="source-code">    long n{0};</p><p class="source-code">    while(++n) {</p><p class="source-code">        string x{};</p><p class="source-code">        x.append(a);</p><p class="source-code">        x.append(", ");</p><p class="source-code">        x.append(b);</p><p class="source-code">        x.append("\n");</p><p class="source-code">        if(n &gt;= 10000000) return x;</p><p class="source-code">    }</p><p class="source-code">    return "error\n";</p><p class="source-code">}</p></li>
			</ul>
			<p>For benchmarking purposes, this function repeats the concatenation 10 million times. We call this function <a id="_idIndexMarker576"/>from <strong class="source-inline">main()</strong> with <strong class="source-inline">timer()</strong>:</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    timer(append_string);</p>
			<p class="source-code">}</p>
			<p>We get this output:</p>
			<p class="source-code"><strong class="bold">append_string</strong></p>
			<p class="source-code"><strong class="bold">a, b</strong></p>
			<p class="source-code"><strong class="bold">duration: 425.361643 ms</strong></p>
			<p>So, on this system, our concatenation ran 10 million iterations in about 425 milliseconds.</p>
			<ul>
				<li>Now, let's create the same function with the <strong class="source-inline">+</strong> operator overload:<p class="source-code">string concat_string() {</p><p class="source-code">    cout &lt;&lt; "concat_string\n";</p><p class="source-code">    string a{ "a" };</p><p class="source-code">    string b{ "b" };</p><p class="source-code">    long n{0};</p><p class="source-code">    while(++n) {</p><p class="source-code">        string x{};</p><p class="source-code">        x += a + ", " + b + "\n";</p><p class="source-code">        if(n &gt;= 10000000) return x;</p><p class="source-code">    }</p><p class="source-code">    return "error\n";</p><p class="source-code">}</p></li>
			</ul>
			<p>Our benchmark output:</p>
			<p class="source-code"><strong class="bold">concat_string</strong></p>
			<p class="source-code"><strong class="bold">a, b</strong></p>
			<p class="source-code"><strong class="bold">duration: 659.957702 ms</strong></p>
			<p>This version<a id="_idIndexMarker577"/> performed 10 million iterations in about 660 milliseconds.</p>
			<ul>
				<li>Now, let's try it with <strong class="source-inline">ostringstream</strong>:<p class="source-code">string concat_ostringstream() {</p><p class="source-code">    cout &lt;&lt; "ostringstream\n";</p><p class="source-code">    string a { "a" };</p><p class="source-code">    string b { "b" };</p><p class="source-code">    long n{0};</p><p class="source-code">    while(++n) {</p><p class="source-code">        ostringstream x{};</p><p class="source-code">        x &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; "\n";</p><p class="source-code">        if(n &gt;= 10000000) return x.str();</p><p class="source-code">    }</p><p class="source-code">    return "error\n";</p><p class="source-code">}</p></li>
			</ul>
			<p>Our benchmark output:</p>
			<p class="source-code"><strong class="bold">ostringstream</strong></p>
			<p class="source-code"><strong class="bold">a, b</strong></p>
			<p class="source-code"><strong class="bold">duration: 3462.020587 ms</strong></p>
			<p>This version ran 10 million iterations in about 3.5 seconds.</p>
			<ul>
				<li>Here's the <strong class="source-inline">format()</strong> version:<p class="source-code">string concat_format() {</p><p class="source-code">    cout &lt;&lt; "append_format\n";</p><p class="source-code">    string a{ "a" };</p><p class="source-code">    string b{ "b" };</p><p class="source-code">    long n{0};</p><p class="source-code">    while(++n) {</p><p class="source-code">        string x{};</p><p class="source-code">        x = format("{}, {}\n", a, b);</p><p class="source-code">        if(n &gt;= 10000000) return x;</p><p class="source-code">    }</p><p class="source-code">    return "error\n";</p><p class="source-code">}</p></li>
			</ul>
			<p>Our benchmark<a id="_idIndexMarker578"/> output:</p>
			<p class="source-code"><strong class="bold">append_format</strong></p>
			<p class="source-code"><strong class="bold">a, b</strong></p>
			<p class="source-code"><strong class="bold">duration: 782.800547 ms</strong></p>
			<p>The <strong class="source-inline">format()</strong> version ran 10 million iterations in about 783 milliseconds.</p>
			<ul>
				<li>Summary of the results:</li>
			</ul>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B18267_table_7.1.jpg" alt="A comparison of concatenation performance&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">A comparison of concatenation performance</p>
			<h3>Why the performance discrepancies?</h3>
			<p>We can see from these benchmarks that the <strong class="source-inline">ostringstream</strong> version takes many times longer than the <strong class="source-inline">string</strong>-based versions.</p>
			<p>The <strong class="source-inline">append()</strong> method is<a id="_idIndexMarker579"/> slightly faster than the <strong class="source-inline">+</strong> operator. It needs to allocate memory but does not construct new objects. Some optimizations may be possible due to repetition.</p>
			<p>The <strong class="source-inline">+</strong> operator overload probably calls the <strong class="source-inline">append()</strong> method. The extra function call could make it incrementally slower than the <strong class="source-inline">append()</strong> method.</p>
			<p>The <strong class="source-inline">format()</strong> version creates one new <strong class="source-inline">string</strong> object but without the overhead of the <strong class="source-inline">iostream</strong> system.</p>
			<p>The <strong class="source-inline">ostringstream</strong> operator <strong class="source-inline">&lt;&lt;</strong> overload creates a new <strong class="source-inline">ostream</strong> object for each operation. Given the complexity of the stream object, along with managing the stream state, this makes it much slower than either of the <strong class="source-inline">string</strong>-based versions.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor222"/>Why would I choose one over another?</h2>
			<p>Some measure of personal preference<a id="_idIndexMarker580"/> will be involved. The operator overloads (<strong class="source-inline">+</strong> or <strong class="source-inline">&lt;&lt;</strong>) can be convenient. Performance may or may not be an issue for you.</p>
			<p>The <strong class="source-inline">ostringstream</strong> class has one distinct advantage over the <strong class="source-inline">string</strong> methods: it specializes the <strong class="source-inline">&lt;&lt;</strong> operator for each different type, so it's able to operate in circumstances where you may have different types calling the same code.</p>
			<p>The <strong class="source-inline">format()</strong> function offers the same type-safety and customization options and is significantly faster than the <strong class="source-inline">ostringstream</strong> class.</p>
			<p>The <strong class="source-inline">string</strong> object's <strong class="source-inline">+</strong> operator overload is fast, easy to use, and easy to read but is incrementally slower than <strong class="source-inline">append()</strong>.</p>
			<p>The <strong class="source-inline">append()</strong> version is fastest but requires a separate function call for each item.</p>
			<p>For my purposes, I like the <strong class="source-inline">format()</strong> function or the <strong class="source-inline">string</strong> object's <strong class="source-inline">+</strong> operator for most circumstances. I'll use <strong class="source-inline">append()</strong> if every <a id="_idIndexMarker581"/>bit of speed matters. I'll use <strong class="source-inline">ostringstream</strong> where I need its unique features and performance is not an issue.</p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor223"/>Transform strings</h1>
			<p>The <strong class="source-inline">std::string</strong> class is a <em class="italic">contiguous container</em>, much like a <strong class="source-inline">vector</strong> or an <strong class="source-inline">array</strong>. It supports<a id="_idIndexMarker582"/> the <strong class="source-inline">contiguous_iterator</strong> concept and all corresponding algorithms.</p>
			<p>The <strong class="source-inline">string</strong> class is a specialization of <strong class="source-inline">basic_string</strong> with a <strong class="source-inline">char</strong> type. This means that the elements of the container are of type <strong class="source-inline">char</strong>. Other specializations are available, but <strong class="source-inline">string</strong> is most common.</p>
			<p>Because it is fundamentally a contiguous container of <strong class="source-inline">char</strong> elements, <strong class="source-inline">string</strong> may be used with the <strong class="source-inline">transform()</strong> algorithm, or any other technique that uses the <strong class="source-inline">contiguous_iterator</strong> concept.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor224"/>How to do it…</h2>
			<p>There are several ways to do transformations, depending on the application. This recipe will explore a few of them.</p>
			<ul>
				<li>We'll start with a few predicate functions. A predicate function takes a transformation element and returns a related element. For example, here is a simple predicate that returns an upper-case character:<p class="source-code">char char_upper(const char&amp; c) {</p><p class="source-code">    return static_cast&lt;char&gt;(std::toupper(c));</p><p class="source-code">}</p></li>
			</ul>
			<p>This function is a wrapper around <strong class="source-inline">std::toupper()</strong>. Because the <strong class="source-inline">toupper()</strong> function returns an <strong class="source-inline">int</strong> and <strong class="source-inline">string</strong> elements are type <strong class="source-inline">char</strong>, we cannot use the <strong class="source-inline">toupper()</strong> function directly in a transformation.</p>
			<p>Here is a corresponding <strong class="source-inline">char_lower()</strong> function:</p>
			<p class="source-code">char char_lower(const char&amp; c) {</p>
			<p class="source-code">    return static_cast&lt;char&gt;(std::tolower(c));</p>
			<p class="source-code">}</p>
			<ul>
				<li>The <strong class="source-inline">rot13()</strong> function is a fun transformation predicate for demonstration purposes. It's a simple substitution cypher, <em class="italic">not suitable for encryption</em> but commonly used for <em class="italic">obfuscation</em>:<p class="source-code">char rot13(const char&amp; x) {</p><p class="source-code">    auto rot13a = [](char x, char a)-&gt;char { </p><p class="source-code">        return a + (x - a + 13) % 26; </p><p class="source-code">    };</p><p class="source-code">    if (x &gt;= 'A' &amp;&amp; x &lt;= 'Z') return rot13a(x, 'A');</p><p class="source-code">    if (x &gt;= 'a' &amp;&amp; x &lt;= 'z') return rot13a(x, 'a');</p><p class="source-code">    return x;</p><p class="source-code">}</p></li>
				<li>We can use these <a id="_idIndexMarker583"/>predicates with the <strong class="source-inline">transform()</strong> algorithm:<p class="source-code">main() {</p><p class="source-code">    string s{ "hello jimi\n" };</p><p class="source-code">    cout &lt;&lt; s;</p><p class="source-code">    std::transform(s.begin(), s.end(), s.begin(), </p><p class="source-code">      char_upper);</p><p class="source-code">    cout &lt;&lt; s;</p><p class="source-code">    ...</p></li>
			</ul>
			<p>The <strong class="source-inline">transform()</strong> function calls <strong class="source-inline">char_upper()</strong> with each element of <strong class="source-inline">s</strong>, puts the result back in <strong class="source-inline">s</strong> and<a id="_idIndexMarker584"/> transforms all the characters to uppercase:</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">hello jimi</strong></p>
			<p class="source-code"><strong class="bold">HELLO JIMI</strong></p>
			<ul>
				<li>Instead of <strong class="source-inline">transform()</strong>, we can also use a simple <strong class="source-inline">for</strong> loop with a <em class="italic">predicate</em> <em class="italic">function</em>:<p class="source-code">for(auto&amp; c : s) c = rot13(c);</p><p class="source-code">cout &lt;&lt; s;</p></li>
			</ul>
			<p>Starting with our uppercase string object, the result is:</p>
			<p class="source-code"><strong class="bold">URYYB WVZV</strong></p>
			<ul>
				<li>The fun thing about the <strong class="source-inline">rot13</strong> cypher is that it unscrambles itself. Because there are 26 letters in the <em class="italic">ASCII</em> alphabet, rotating 13 and then rotating 13 again results in the original string. Let's transform to lowercase and <strong class="source-inline">rot13</strong> again to restore our string:<p class="source-code">for(auto&amp; c : s) c = rot13(char_lower(c));</p><p class="source-code">cout &lt;&lt; s;</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">hello jimi</strong></p>
			<p>Because of their uniform interface, the predicate functions may be <em class="italic">chained</em> as parameters of each other. We could also use <strong class="source-inline">char_lower(rot13(c))</strong> with the same result.</p>
			<ul>
				<li>If your requirement is too complex for a simple character-by-character transformation, you may use <strong class="source-inline">string</strong> iterators as you would with any contiguous container. Here's a simple function that transforms a lowercase string to <em class="italic">Title Case</em> by capitalizing the first character and every character that follows a space:<p class="source-code">string&amp; title_case(string&amp; s) {</p><p class="source-code">    auto begin = s.begin();</p><p class="source-code">    auto end = s.end();</p><p class="source-code">    *begin++ = char_upper(*begin);  // first element</p><p class="source-code">    bool space_flag{ false };</p><p class="source-code">    for(auto it{ begin }; it != end; ++it) {</p><p class="source-code">        if(*it == ' ') {</p><p class="source-code">            space_flag = true;</p><p class="source-code">        } else {</p><p class="source-code">            if(space_flag) *it = char_upper(*it);</p><p class="source-code">            space_flag = false;</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    return s;</p><p class="source-code">}</p></li>
			</ul>
			<p>Because it returns a reference<a id="_idIndexMarker585"/> to the transformed string, we can call it with <strong class="source-inline">cout</strong>, like this:</p>
			<p class="source-code">cout &lt;&lt; title_case(s);</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">Hello Jimi</strong></p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor225"/>How it works…</h2>
			<p>The <strong class="source-inline">std::basic_string</strong> class, and its specializations (including <strong class="source-inline">string</strong>), are supported by iterators fully compliant with <strong class="source-inline">contiguous_iterator</strong>. This means that any technique that works with any <a id="_idIndexMarker586"/>contiguous container also works with <strong class="source-inline">string</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">These transformations will not work with <strong class="source-inline">string_view</strong> objects because the underlying data is <strong class="source-inline">const</strong>-qualified. </p>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor226"/>Format text with C++20's format library</h1>
			<p>C++20 introduces the new <strong class="source-inline">format()</strong> function, which returns a formatted representation<a id="_idIndexMarker587"/> of its arguments in a string. <strong class="source-inline">format()</strong> uses a <a id="_idIndexMarker588"/>Python-style formatting string, with concise syntax, type safety, and excellent performance.</p>
			<p>The <strong class="source-inline">format()</strong> function takes a format string and a template, <em class="italic">parameter pack</em>, for its arguments:</p>
			<p class="source-code">template&lt; class... Args &gt;</p>
			<p class="source-code">string format(const string_view fmt, Args&amp;&amp;... args );</p>
			<p>The format string uses curly braces <strong class="source-inline">{}</strong> as a placeholder for the formatted arguments:</p>
			<p class="source-code">const int a{47};</p>
			<p class="source-code">format("a is {}\n", a);</p>
			<p>Output:</p>
			<p class="source-code">a is 47</p>
			<p>It also uses the braces for format specifiers, for example:</p>
			<p class="source-code">format("Hex: {:x} Octal: {:o} Decimal {:d} \n", a, a, a);</p>
			<p>Output:</p>
			<p class="source-code">Hex: 2f Octal: 57 Decimal 47</p>
			<p>This recipe will show you how to use the <strong class="source-inline">format()</strong> function for some common string formatting solutions.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This chapter was developed using a preview release of the Microsoft Visual C++ compiler on Windows 10. At the time of writing, this is the only compiler that fully supports the C++20 <strong class="source-inline">&lt;format&gt;</strong> library. Final implementations may differ in some details.</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor227"/>How to do it…</h2>
			<p>Let's consider some common<a id="_idIndexMarker589"/> formatting solutions using the <strong class="source-inline">format()</strong> function:</p>
			<ul>
				<li>We'll start with some <a id="_idIndexMarker590"/>variables to format: <p class="source-code">const int inta{ 47 };</p><p class="source-code">const char * human{ "earthlings" };</p><p class="source-code">const string_view alien{ "vulcans" };</p><p class="source-code">const double df_pi{ pi };</p></li>
			</ul>
			<p>The <strong class="source-inline">pi</strong> constant is in the <strong class="source-inline">&lt;numbers&gt;</strong> header and the <strong class="source-inline">std::numbers</strong> namespace.</p>
			<ul>
				<li>We can display the variables using <strong class="source-inline">cout</strong>:<p class="source-code">cout &lt;&lt; "inta is " &lt;&lt; inta &lt;&lt; '\n'</p><p class="source-code">    &lt;&lt; "hello, " &lt;&lt; human &lt;&lt; '\n'</p><p class="source-code">    &lt;&lt; "All " &lt;&lt; alien &lt;&lt; " are welcome here\n"</p><p class="source-code">    &lt;&lt; "π is " &lt;&lt; df_pi &lt;&lt; '\n';</p></li>
			</ul>
			<p>We get this output:</p>
			<p class="source-code"><strong class="bold">a is 47</strong></p>
			<p class="source-code"><strong class="bold">hello, earthlings</strong></p>
			<p class="source-code"><strong class="bold">All vulcans are welcome here</strong></p>
			<p class="source-code"><strong class="bold">π is 3.14159</strong></p>
			<ul>
				<li>Now, let's look at each of these with <strong class="source-inline">format()</strong>, starting with the C-string, <strong class="source-inline">human</strong>:<p class="source-code">cout &lt;&lt; format("Hello {}\n", human);</p></li>
			</ul>
			<p>This is the simplest form <a id="_idIndexMarker591"/>of the <strong class="source-inline">format()</strong> function. The format <a id="_idIndexMarker592"/>string has one placeholder <strong class="source-inline">{}</strong> and one corresponding variable, <strong class="source-inline">human</strong>. The output is:</p>
			<p class="source-code"><strong class="bold">Hello earthlings</strong></p>
			<ul>
				<li>The <strong class="source-inline">format()</strong> function returns a string, and we use <strong class="source-inline">cout &lt;&lt;</strong> to display the string.</li>
			</ul>
			<p>The original proposal for the <strong class="source-inline">format()</strong> library included a <strong class="source-inline">print()</strong> function, using the same parameters as <strong class="source-inline">format()</strong>. That would allow us to print our formatted strings in one step:</p>
			<p class="source-code">print("Hello {}\n", cstr);</p>
			<p>Unfortunately, <strong class="source-inline">print()</strong> didn't make it into the C++20 standard, although it is expected to be included in C++23.</p>
			<p>We can provide the same functionality with a simple function, using <strong class="source-inline">vformat()</strong>:</p>
			<p class="source-code">template&lt;typename... Args&gt;</p>
			<p class="source-code">constexpr void print(const string_view str_fmt, </p>
			<p class="source-code">                     Args&amp;&amp;... args) {</p>
			<p class="source-code">    fputs(<strong class="bold">std::vformat</strong>(str_fmt, </p>
			<p class="source-code">          <strong class="bold">std::make_format_args</strong>(args...)).c_str(), </p>
			<p class="source-code">          stdout);</p>
			<p class="source-code">}</p>
			<p>This simple one-line function <a id="_idIndexMarker593"/>gives us a serviceable <strong class="source-inline">print()</strong> function. We <a id="_idIndexMarker594"/>can use it in place of the <strong class="source-inline">cout &lt;&lt; format()</strong> combination:</p>
			<p class="source-code">print("Hello {}\n", human);</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">Hello earthlings</strong></p>
			<p>A more complete version of this function may be found in the <strong class="source-inline">include</strong> directory of the example files.</p>
			<ul>
				<li>The format string also provides positional options:<p class="source-code">print("Hello {} we are {}\n", human, alien);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">Hello earthlings we are vulcans</strong></p>
			<p>We can change the order of the arguments by using positional options in the format string:</p>
			<p class="source-code">print("Hello {1} we are {0}\n", human, alien);</p>
			<p>Now, we get this output:</p>
			<p class="source-code"><strong class="bold">Hello vulcans we are earthlings</strong></p>
			<p>Notice that the arguments remain the same. Only the positional values in the braces have changed. The positional indices are zero-based, just like the <strong class="source-inline">[]</strong> operator.</p>
			<p>This feature can be useful for internationalization, as different languages use different orders for parts of speech in a sentence.</p>
			<ul>
				<li>There are many formatting options for numbers:<p class="source-code">print("π is {}\n", df_pi);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">π is 3.141592653589793</strong></p>
			<p>We can specify the number<a id="_idIndexMarker595"/> of digits of precision:</p>
			<p class="source-code">print("π is {:.5}\n", df_pi);</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">π is 3.1416</strong></p>
			<p>The colon character <strong class="source-inline">:</strong> is used to<a id="_idIndexMarker596"/> separate positional indices from formatting arguments:</p>
			<p class="source-code">print("inta is {1:}, π is {0:.5}\n", df_pi, inta);</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">inta is 47, π is 3.1416</strong></p>
			<ul>
				<li>If we want a value to take up a certain amount of space, we can specify the number of characters like this:<p class="source-code">print("inta is [{:10}]\n", inta);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">inta is [        47]</strong></p>
			<p>We can align it left or right:</p>
			<p class="source-code">print("inta is [{:&lt;10}]\n", inta);</p>
			<p class="source-code">print("inta is [{:&gt;10}]\n", inta);</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">inta is [47        ]</strong></p>
			<p class="source-code"><strong class="bold">inta is [        47]</strong></p>
			<p>By default, it fills with space characters, but we can change that:</p>
			<p class="source-code">print("inta is [{:*&lt;10}]\n", inta);</p>
			<p class="source-code">print("inta is [{:0&gt;10}]\n", inta);</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">inta is [47********]</strong></p>
			<p class="source-code"><strong class="bold">inta is [0000000047]</strong></p>
			<p>We can also center a value:</p>
			<p class="source-code">print("inta is [{:^10}]\n", inta);</p>
			<p class="source-code">print("inta is [{:_^10}]\n", inta);</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">inta is [    47    ]</strong></p>
			<p class="source-code"><strong class="bold">inta is [____47____]</strong></p>
			<ul>
				<li>We can format integer numbers <a id="_idIndexMarker597"/>as hexadecimal, octal, or the default <a id="_idIndexMarker598"/>decimal representation:<p class="source-code">print("{:&gt;8}: [{:04x}]\n", "Hex", inta);</p><p class="source-code">print("{:&gt;8}: [{:4o}]\n", "Octal", inta);</p><p class="source-code">print("{:&gt;8}: [{:4d}]\n", "Decimal", inta);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code">     <strong class="bold">Hex: [002f]</strong></p>
			<p class="source-code"><strong class="bold">   Octal: [  57]</strong></p>
			<p class="source-code"><strong class="bold"> Decimal: [  47]</strong></p>
			<p>Notice that I used right alignment to line up the labels.</p>
			<p>Use a capital <strong class="source-inline">X</strong> for uppercase hexadecimal:</p>
			<p class="source-code">print("{:&gt;8}: [{:04X}]\n", "Hex", inta);</p>
			<p>Output:</p>
			<p class="source-code">     <strong class="bold">Hex: [002F]</strong></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">By default, Windows uses uncommon character encodings. Recent versions may default to UTF-16 or UTF-8 BOM. Older versions may default to "code page" 1252, a superset of the ISO 8859-1 ASCII standard. No Windows system defaults to the more common UTF-8 (no BOM).</p>
			<p class="callout">By default, Windows will not display the standard UTF-8 <strong class="source-inline">π</strong> character. To make Windows compatible with UTF-8 encoding (and the rest of the world), use the compiler switch <strong class="source-inline">/utf-8</strong> and issue the command <strong class="source-inline">chcp 65001</strong> on the command line when testing. Now, you can have your <strong class="source-inline">π</strong> and eat it too.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor228"/>How it works…</h2>
			<p>The <strong class="source-inline">&lt;format&gt;</strong> library uses a<a id="_idIndexMarker599"/> template <em class="italic">parameter pack</em> to pass arguments to the formatter. This allows the arguments to be individually inspected for<a id="_idIndexMarker600"/> class and type. The library function, <strong class="source-inline">make_format_args()</strong> takes a parameter pack and returns a <strong class="source-inline">format_args</strong> object, which provides a <em class="italic">type erased</em> list of arguments to be formatted.</p>
			<p>We can see this in action in our <strong class="source-inline">print()</strong> function:</p>
			<p class="source-code">template&lt;typename... Args&gt;</p>
			<p class="source-code">constexpr void print(const string_view str_fmt, Args&amp;&amp;... args) {</p>
			<p class="source-code">    fputs(<strong class="bold">vformat</strong>(str_fmt, </p>
			<p class="source-code">      <strong class="bold">make_format_args(args...)</strong>).c_str(), </p>
			<p class="source-code">          stdout);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">make_format_args()</strong> function takes a <a id="_idIndexMarker601"/>parameter pack and returns a <strong class="source-inline">format_args</strong> object. The <strong class="source-inline">vformat()</strong> function takes a format string and the <strong class="source-inline">format_args</strong> object, and returns a <strong class="source-inline">std::string</strong>. We use the <strong class="source-inline">c_str()</strong> method to <a id="_idIndexMarker602"/>get a C-string for use with <strong class="source-inline">fputs()</strong>.</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor229"/>There's more…</h2>
			<p>It's common practice to overload<a id="_idIndexMarker603"/> the <strong class="source-inline">ostream</strong> <strong class="source-inline">&lt;&lt;</strong> operator for custom classes. For example, given a class <strong class="source-inline">Frac</strong> that holds the values of a fraction:</p>
			<p class="source-code">template&lt;typename T&gt;</p>
			<p class="source-code">struct Frac {</p>
			<p class="source-code">    T n;</p>
			<p class="source-code">    T d;</p>
			<p class="source-code">};</p>
			<p class="source-code">...</p>
			<p class="source-code">Frac&lt;long&gt; n{ 3, 5 };</p>
			<p class="source-code">cout &lt;&lt; "Frac: " &lt;&lt; n &lt;&lt; '\n';</p>
			<p>We want to print the object as a fraction like <strong class="source-inline">3/5</strong>. So, we would write a simple <strong class="source-inline">operator&lt;&lt;</strong> specialization like this:</p>
			<p class="source-code">template &lt;typename T&gt;</p>
			<p class="source-code">std::ostream&amp; <strong class="bold">operator&lt;&lt;</strong>(std::ostream&amp; os, const <strong class="bold">Frac&lt;T&gt;</strong>&amp; f) {</p>
			<p class="source-code">    <strong class="bold">os &lt;&lt; f.n &lt;&lt; '/' &lt;&lt; f.d</strong>;</p>
			<p class="source-code">    return os;</p>
			<p class="source-code">}</p>
			<p>Now our output is:</p>
			<p class="source-code">Frac: 3/5</p>
			<p>To provide <strong class="source-inline">format()</strong> support for our custom class, we need to create a <strong class="source-inline">formatter</strong> object specialization, like this:</p>
			<p class="source-code">template &lt;typename T&gt;</p>
			<p class="source-code">struct <strong class="bold">std::formatter&lt;Frac&lt;T&gt;&gt;</strong> : <strong class="bold">std::formatter&lt;unsigned&gt;</strong> {</p>
			<p class="source-code">    template &lt;typename Context&gt;</p>
			<p class="source-code">    auto <strong class="bold">format</strong>(const <strong class="bold">Frac&lt;T&gt;</strong>&amp; f, Context&amp; ctx) const {</p>
			<p class="source-code">        return format_to(ctx.out(), <strong class="bold">"{}/{}"</strong>, <strong class="bold">f.n</strong>, <strong class="bold">f.d</strong>);</p>
			<p class="source-code">    }</p>
			<p class="source-code">};</p>
			<p>The specialization<a id="_idIndexMarker604"/> of the <strong class="source-inline">std::formatter</strong> class overloads its <strong class="source-inline">format()</strong> method. We inherit from the <strong class="source-inline">formatter&lt;unsigned&gt;</strong> specialization for simplicity. The <strong class="source-inline">format()</strong> method is called with a <strong class="source-inline">Context</strong> object, which provides the output context for the formatted string. For the return value, we use the <strong class="source-inline">format_to()</strong> function with <strong class="source-inline">ctx.out</strong>, a normal format string, and parameters.</p>
			<p>Now, we can now use our <strong class="source-inline">print()</strong> function with the <strong class="source-inline">Frac</strong> class:</p>
			<p class="source-code">print("Frac: {}\n", <strong class="bold">n</strong>);</p>
			<p>The formatter now recognizes our class and provides our desired output:</p>
			<p class="source-code">Frac: 3/5</p>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor230"/>Trim whitespace from strings</h1>
			<p>It is common for input from <a id="_idIndexMarker605"/>users to include extraneous whitespace at one <a id="_idIndexMarker606"/>or both ends of a string. This can be problematic, so we often need to remove it. In this recipe, we'll use the <strong class="source-inline">string</strong> class methods, <strong class="source-inline">find_first_not_of()</strong> and <strong class="source-inline">find_last_not_of()</strong>, to trim whitespace from the ends of a string.</p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor231"/>How to do it…</h2>
			<p>The <strong class="source-inline">string</strong> class includes methods for finding elements that are, or are not, included in a list of characters. We'll use these methods to trim <strong class="source-inline">string</strong>:</p>
			<ul>
				<li>We start by defining <strong class="source-inline">string</strong> with input from a hypothetical ten-thumbed user:<p class="source-code">int main() {</p><p class="source-code">    string s{" \t  ten-thumbed input   \t   \n \t "};</p><p class="source-code">    cout &lt;&lt; format("[{}]\n", s);</p><p class="source-code">    ...</p></li>
			</ul>
			<p>Our input has a few<a id="_idIndexMarker607"/> extra tab <strong class="source-inline">\t</strong> and newline <strong class="source-inline">\n</strong> characters before <a id="_idIndexMarker608"/>and after the content. We print it with surrounding brackets to show the whitespace:</p>
			<p class="source-code">[       ten-thumbed input</p>
			<p class="source-code">      ]</p>
			<ul>
				<li>Here's a <strong class="source-inline">trimstr()</strong> function to remove all the whitespace characters from both ends of <strong class="source-inline">string</strong>:<p class="source-code">string <strong class="bold">trimstr</strong>(const string&amp; s) {</p><p class="source-code">    constexpr const char * whitespace{ <strong class="bold">" \t\r\n\v\f"</strong> };</p><p class="source-code">    if(<strong class="bold">s.empty()</strong>) return s;</p><p class="source-code">    const auto first{ <strong class="bold">s.find_first_not_of(whitespace)</strong> };</p><p class="source-code">    if(<strong class="bold">first == string::npos</strong>) return {};</p><p class="source-code">    const auto last{ <strong class="bold">s.find_last_not_of(whitespace)</strong> };</p><p class="source-code">    return s.<strong class="bold">substr</strong>(first, (last - first + 1));</p><p class="source-code">}</p></li>
			</ul>
			<p>We defined our set of whitespace characters as <em class="italic">space</em>, <em class="italic">tab</em>, <em class="italic">return</em>, <em class="italic">newline</em>, <em class="italic">vertical tab</em>, and <em class="italic">form feed</em>. Some of these are more common than others, but that's the canonical set.</p>
			<p>This function uses the <strong class="source-inline">find_first_not_of()</strong> and <strong class="source-inline">find_last_not_of()</strong> methods of the <strong class="source-inline">string</strong> class to find the first/last elements that are <em class="italic">not</em> a member of the set.</p>
			<ul>
				<li>Now, we can call the <a id="_idIndexMarker609"/>function to get rid of all that unsolicited<a id="_idIndexMarker610"/> whitespace:<p class="source-code">cout &lt;&lt; format("[{}]\n", trimstr(s));</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">[ten-thumbed input]</strong></p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor232"/>How it works…</h2>
			<p>The <strong class="source-inline">string</strong> class's various <strong class="source-inline">find...()</strong> member functions return a position as a <strong class="source-inline">size_t</strong> value:</p>
			<p class="source-code">size_t find_first_not_of( const CharT* s, size_type pos = 0 );</p>
			<p class="source-code">size_t find_last_not_of( const CharT* s, size_type pos = 0 );</p>
			<p>The return value is the zero-based position of the first matching character (<em class="italic">not</em> in the <strong class="source-inline">s</strong> list of characters) or the special value, <strong class="source-inline">string::npos</strong>, if not found. <strong class="source-inline">npos</strong> is a static member constant that represents an invalid position.</p>
			<p>We test for <strong class="source-inline">(first == string::npos)</strong> and return an empty string <strong class="source-inline">{}</strong> if there is no match. Otherwise, we use the <strong class="source-inline">first</strong> and <strong class="source-inline">last</strong> positions with the <strong class="source-inline">s.substr()</strong> method to return the string without whitespace.</p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor233"/>Read strings from user input</h1>
			<p>The STL provides<a id="_idIndexMarker611"/> character-based input from<a id="_idIndexMarker612"/> the standard input stream using the <strong class="source-inline">std::cin</strong> object. The <strong class="source-inline">cin</strong> object is a global <em class="italic">singleton</em> that reads input from the console as an <strong class="source-inline">istream</strong> input stream.</p>
			<p>By default, <strong class="source-inline">cin</strong> reads <em class="italic">one word at a time</em> until it reaches the end of the stream:</p>
			<p class="source-code">string word{};</p>
			<p class="source-code">cout &lt;&lt; "Enter words: ";</p>
			<p class="source-code">while(cin &gt;&gt; word) {</p>
			<p class="source-code">    cout &lt;&lt; format("[{}] ", word);</p>
			<p class="source-code">}</p>
			<p class="source-code">cout &lt;&lt; '\n';</p>
			<p>Output:</p>
			<p class="source-code">$ ./working</p>
			<p class="source-code">Enter words: big light in sky<img src="image/1.png" alt=""/></p>
			<p class="source-code">[big] [light] [in] [sky]</p>
			<p>This is of limited <a id="_idIndexMarker613"/>usefulness, and it may lead some to dismiss <strong class="source-inline">cin</strong> as minimally<a id="_idIndexMarker614"/> functional.</p>
			<p>While <strong class="source-inline">cin</strong> certainly has its quirks, it can be easily wrangled into providing line-oriented input.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor234"/>How to do it…</h2>
			<p>To get basic line-oriented functionality from <strong class="source-inline">cin</strong>, there are two significant behaviors that need to be understood. One is the ability to get a line at a time, instead of a word at a time. The other is the ability to reset the stream after an error condition. Let's look at these in some detail:</p>
			<ul>
				<li>First, we need to prompt the user for input. Here's a simple <strong class="source-inline">prompt</strong> function:<p class="source-code">bool prompt(const string_view s, const string_view s2 = "") {</p><p class="source-code">    if(s2.size()) cout &lt;&lt; format("{} ({}): ", s, s2);</p><p class="source-code">    else cout &lt;&lt; format("{}: ", s);</p><p class="source-code">    <strong class="bold">cout.flush()</strong>;</p><p class="source-code">    return true;</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">cout.flush()</strong> function call ensures that the output is displayed immediately. Sometimes, when<a id="_idIndexMarker615"/> the output doesn't include a<a id="_idIndexMarker616"/> newline, the output stream may not flush automatically.</p>
			<ul>
				<li>The <strong class="source-inline">cin</strong> class has a <strong class="source-inline">getline()</strong> method that gets a line of text from the input stream and puts it in <a id="_idIndexMarker617"/>a C-string array:<p class="source-code">constexpr size_t <strong class="bold">MAXLINE{1024 * 10}</strong>;</p><p class="source-code">char <strong class="bold">s</strong>[<strong class="bold">MAXLINE</strong>]{};</p><p class="source-code">const char * p1{ "Words here" };</p><p class="source-code">prompt(p1);</p><p class="source-code">cin.getline(<strong class="bold">s</strong>, <strong class="bold">MAXLINE</strong>, <strong class="bold">'\n'</strong>);</p><p class="source-code">cout &lt;&lt; s &lt;&lt; '\n';</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">Words here: big light in sky</strong><strong class="bold"><img src="image/1.png" alt=""/></strong></p>
			<p class="source-code"><strong class="bold">big light in sky</strong></p>
			<p>The <strong class="source-inline">cin.getline()</strong> method takes three arguments:</p>
			<p class="source-code">getline(char* s, size_t count, char delim );</p>
			<p>The first argument is a C-string array for the destination. The second is the size of the array. The third is the delimiter for the end of the line. </p>
			<p>The function will not put more than <strong class="source-inline">count</strong>-1 characters in the array, leaving room for a <em class="italic">null</em> terminator.</p>
			<p>The delimiter defaults to the newline <strong class="source-inline">'\n'</strong> character.</p>
			<ul>
				<li>The STL also provides a stand-alone <strong class="source-inline">getline()</strong> function that works with an STL <strong class="source-inline">string</strong> object:<p class="source-code">string line{};</p><p class="source-code">const char * p1a{ "More words here" };</p><p class="source-code">prompt(p1a, "p1a");</p><p class="source-code">getline(cin, line, '\n');</p><p class="source-code">cout &lt;&lt; line &lt;&lt; '\n';</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">$ ./working</strong></p>
			<p class="source-code"><strong class="bold">More words here (p1a): slated to appear in east</strong><strong class="bold"><img src="image/1.png" alt=""/></strong></p>
			<p class="source-code"><strong class="bold">slated to appear in east</strong></p>
			<p>The stand-alone <strong class="source-inline">std::getline()</strong> function takes three arguments:</p>
			<p class="source-code">getline(basic_istream&amp;&amp; in, string&amp; str, char delim );</p>
			<p>The first argument is the output stream, second is a reference to a <strong class="source-inline">string</strong> object, and the third is the end-of-line delimiter.</p>
			<p>If not specified, the delimiter defaults to the newline <strong class="source-inline">'\n'</strong> character.</p>
			<p>I find the standalone <strong class="source-inline">getline()</strong> more convenient than the <strong class="source-inline">cin.getline()</strong> method.</p>
			<ul>
				<li>We can use <strong class="source-inline">cin</strong> to get a <a id="_idIndexMarker618"/>specific type from the input stream. To do<a id="_idIndexMarker619"/> this, we must be able to handle an error condition.</li>
			</ul>
			<p>When <strong class="source-inline">cin</strong> encounters an error, it sets the stream to an error condition and stops accepting input. To retry input after an error, we must reset the state of the stream. Here's a function that resets the input stream after an error:</p>
			<p class="source-code">void clearistream() {</p>
			<p class="source-code">    string s{};</p>
			<p class="source-code">    cin.clear();</p>
			<p class="source-code">    getline(cin, s);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">cin.clear()</strong> function<a id="_idIndexMarker620"/> resets the error flags on the input stream<a id="_idIndexMarker621"/> but leaves text in the buffer. We then clear the buffer by reading a line and discarding it.</p>
			<ul>
				<li>We can accept numeric input by using <strong class="source-inline">cin</strong> with numeric type variables:<p class="source-code">double a{};</p><p class="source-code">double b{};</p><p class="source-code">const char * p2{ "Please enter two numbers" };</p><p class="source-code">for(prompt(p2); <strong class="bold">!(cin &gt;&gt; a &gt;&gt; b)</strong>; prompt(p2)) {</p><p class="source-code">    cout &lt;&lt; "not numeric\n";</p><p class="source-code">    <strong class="bold">clearistream();</strong></p><p class="source-code">}</p><p class="source-code">cout &lt;&lt; format("You entered {} and {}\n", a, b);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">$ ./working</strong></p>
			<p class="source-code"><strong class="bold">Please enter two numbers: a b</strong><strong class="bold"><img src="image/1.png" alt=""/></strong></p>
			<p class="source-code"><strong class="bold">not numeric</strong></p>
			<p class="source-code"><strong class="bold">Please enter two numbers: 47 73</strong><strong class="bold"><img src="image/1.png" alt=""/></strong></p>
			<p class="source-code"><strong class="bold">You entered 47 and 73</strong></p>
			<p>The <strong class="source-inline">cin &gt;&gt; a &gt;&gt; b</strong> expression accepts input from the console and attempts to convert the first two words to types compatible with <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> (<strong class="source-inline">double</strong>). If it fails, we call <strong class="source-inline">clearistream()</strong> and try again.</p>
			<ul>
				<li>We can use the <strong class="source-inline">getline()</strong> separator <a id="_idIndexMarker622"/>parameter to get comma-separated input:<p class="source-code">line.clear();</p><p class="source-code">prompt(p3);</p><p class="source-code"><strong class="bold">while(line.empty()) getline(cin, line);</strong></p><p class="source-code"><strong class="bold">stringstream ss(line);</strong></p><p class="source-code">while(<strong class="bold">getline(ss, word, ',')</strong>) {</p><p class="source-code">    if(word.empty()) continue;</p><p class="source-code">    cout &lt;&lt; format("word: [{}]\n", <strong class="bold">trimstr(word)</strong>);</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">$ ./working</strong></p>
			<p class="source-code"><strong class="bold">Comma-separated words: this, that, other</strong></p>
			<p class="source-code"><strong class="bold">word: [this]</strong></p>
			<p class="source-code"><strong class="bold">word: [that]</strong></p>
			<p class="source-code"><strong class="bold">word: [other]</strong></p>
			<p>Because this code runs after the numbers code, and because <strong class="source-inline">cin</strong> is messy, there may still be a line ending in<a id="_idIndexMarker623"/> the buffer. The <strong class="source-inline">while(line.empty())</strong> loop will optionally eat any empty lines.</p>
			<p>We use a <strong class="source-inline">stringstream</strong> object to process the words, so we don't have to do it with <strong class="source-inline">cin</strong>. This allows us to use <strong class="source-inline">getline()</strong> to get one line without waiting for the end-of-file state.</p>
			<p>Then, we call <strong class="source-inline">getline()</strong> on the <strong class="source-inline">stringstream</strong> object to parse out words separated by commas. This gives us words but with leading whitespace. We use the <strong class="source-inline">trimstr()</strong> function from the <em class="italic">Trim whitespace from strings</em> recipe in this chapter to trim the whitespace.</p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor235"/>How it works…</h2>
			<p>The <strong class="source-inline">std::cin</strong> object is more useful than<a id="_idIndexMarker624"/> it may appear, but it can be a challenge to use. It tends to leave line endings on the stream, and in the case of errors, it can end up<a id="_idIndexMarker625"/> ignoring input.</p>
			<p>The solution is to use <strong class="source-inline">getline()</strong> and, when necessary, put the line into a <strong class="source-inline">stringstream</strong> for convenient parsing.</p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor236"/>Count words in a file</h1>
			<p>By default, the <strong class="source-inline">basic_istream</strong> class reads <a id="_idIndexMarker626"/>one word at a time. We can take advantage of this <a id="_idIndexMarker627"/>property to use an <strong class="source-inline">istream_iterator</strong> to count words.</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor237"/>How to do it…</h2>
			<p>This is a simple recipe to count words using an <strong class="source-inline">istream_iterator</strong>:</p>
			<ul>
				<li>We'll start with a simple function to count words using an <strong class="source-inline">istream_iterator</strong> object:<p class="source-code">size_t wordcount(auto&amp; is) {</p><p class="source-code">    using it_t = <strong class="bold">istream_iterator</strong>&lt;string&gt;;</p><p class="source-code">    return <strong class="bold">distance</strong>(it_t{is}, it_t{});</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">distance()</strong> function takes two iterators and returns the number of steps between them. The <strong class="source-inline">using</strong> statement creates an alias <strong class="source-inline">it_t</strong> for the <strong class="source-inline">istream_iterator</strong> class with a <strong class="source-inline">string</strong> specialization. We then call <strong class="source-inline">distance()</strong> with an iterator, initialized with the input stream <strong class="source-inline">it_t{is}</strong>, and another with the default constructor, which gives us an end-of-stream sentinel.</p>
			<ul>
				<li>We call <strong class="source-inline">wordcount()</strong> from <strong class="source-inline">main()</strong>:<p class="source-code">int main() {</p><p class="source-code">    const char * fn{ "the-raven.txt" };</p><p class="source-code">    std::ifstream infile{fn, std::ios_base::in};</p><p class="source-code">    size_t wc{ <strong class="bold">wordcount(infile)</strong> };</p><p class="source-code">    cout &lt;&lt; format("There are {} words in the </p><p class="source-code">      file.\n", wc);</p><p class="source-code">}</p></li>
			</ul>
			<p>This calls <strong class="source-inline">wordcount()</strong> with our <strong class="source-inline">fstream</strong> object and prints the number of words in the file. When I call it with<a id="_idIndexMarker628"/> the text of Edgar Allan Poe's <em class="italic">The Raven</em>, we get this <a id="_idIndexMarker629"/>output:</p>
			<p class="source-code"><strong class="bold">There are 1068 words in the file.</strong></p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor238"/>How it works…</h2>
			<p>Because <strong class="source-inline">basic_istream</strong> defaults to word-by-word input, the number of steps in a file will be the number of words. The <strong class="source-inline">distance()</strong> function will measure the number of steps between two iterators, so calling it with the beginning and the sentinel of a compatible object will count the number of words in the file.</p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor239"/>Initialize complex structures from file input</h1>
			<p>One strength of the <em class="italic">input stream</em> is its ability to parse <a id="_idIndexMarker630"/>different types of data <a id="_idIndexMarker631"/>from a text file and convert them to their corresponding fundamental types. Here's a simple technique for importing data into a container of structures using an input stream.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor240"/>How to do it…</h2>
			<p>In this recipe, we'll take a data file and import its disparate fields into a <strong class="source-inline">vector</strong> of <strong class="source-inline">struct</strong> objects. The data file<a id="_idIndexMarker632"/> represents cities with their populations and map coordinates:</p>
			<ul>
				<li>This is <strong class="source-inline">cities.txt</strong>, the data file we'll read:<p class="source-code">Las Vegas</p><p class="source-code">661903 36.1699 -115.1398</p><p class="source-code">New York City</p><p class="source-code">8850000 40.7128 -74.0060</p><p class="source-code">Berlin</p><p class="source-code">3571000 52.5200 13.4050</p><p class="source-code">Mexico City</p><p class="source-code">21900000 19.4326 -99.1332</p><p class="source-code">Sydney</p><p class="source-code">5312000 -33.8688 151.2093</p></li>
			</ul>
			<p>The city name is on a line by itself. The second line is population, followed by longitude and latitude. This<a id="_idIndexMarker633"/> pattern repeats for each of the five cities.</p>
			<ul>
				<li>We'll define our filename in a constant so that we can open it later:<p class="source-code">constexpr const char * fn{ "cities.txt" };</p></li>
				<li>Here's a <strong class="source-inline">City</strong> struct to hold the data:<p class="source-code">struct City {</p><p class="source-code">    string name;</p><p class="source-code">    unsigned long population;</p><p class="source-code">    double latitude;</p><p class="source-code">    double longitude;</p><p class="source-code">};</p></li>
				<li>We would like to read the file and populate a <strong class="source-inline">vector</strong> of <strong class="source-inline">City</strong> objects:<p class="source-code">vector&lt;City&gt; cities;</p></li>
				<li>Here's where the input stream makes this easy. We can simply specialize <strong class="source-inline">operator&gt;&gt;</strong> for our <strong class="source-inline">City</strong> class like this:<p class="source-code">std::istream&amp; operator&gt;&gt;(std::istream&amp; in, <strong class="bold">City&amp; c</strong>) {</p><p class="source-code">    in &gt;&gt; <strong class="bold">std::ws</strong>;</p><p class="source-code">    <strong class="bold">std::getline(in, c.name);</strong></p><p class="source-code">    <strong class="bold">in &gt;&gt; c.population &gt;&gt; c.latitude &gt;&gt; c.longitude;</strong></p><p class="source-code">    return in;</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">std::ws</strong> input manipulator discards<a id="_idIndexMarker634"/> leading whitespace from the input stream.</p>
			<p>We use <strong class="source-inline">getline()</strong> to read the city name, as it could be one or more words.</p>
			<p>This leverages the <strong class="source-inline">&gt;&gt;</strong> operator <a id="_idIndexMarker635"/>for the <strong class="source-inline">population</strong> (<strong class="source-inline">unsigned long</strong>), and <strong class="source-inline">latitude</strong> and <strong class="source-inline">longitude</strong> (both <strong class="source-inline">double</strong>) elements to populate the correct type.</p>
			<ul>
				<li>Now, we can open the file and use the <strong class="source-inline">&gt;&gt;</strong> operator to read the file directly into the <strong class="source-inline">vector</strong> of <strong class="source-inline">City</strong> objects:<p class="source-code">ifstream infile(fn, std::ios_base::in);</p><p class="source-code">if(!infile.is_open()) {</p><p class="source-code">    cout &lt;&lt; format("failed to open file {}\n", fn);</p><p class="source-code">    return 1;</p><p class="source-code">}</p><p class="source-code">for(City c{}; infile &gt;&gt; c;) cities.emplace_back(c);</p></li>
				<li>We can display the vector<a id="_idIndexMarker636"/> using <strong class="source-inline">format()</strong>:<p class="source-code">for (const auto&amp; [name, pop, lat, lon] : cities) {</p><p class="source-code">    cout &lt;&lt; format("{:.&lt;15} pop {:&lt;10} coords {}, {}\n", </p><p class="source-code">        name, make_commas(pop), lat, lon);</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">$ ./initialize_container &lt; cities.txt</strong></p>
			<p class="source-code"><strong class="bold">Las Vegas...... pop 661,903    coords 36.1699, -115.1398</strong></p>
			<p class="source-code"><strong class="bold">New York City.. pop 8,850,000  coords 40.7128, -74.006</strong></p>
			<p class="source-code"><strong class="bold">Berlin......... pop 3,571,000  coords 52.52, 13.405</strong></p>
			<p class="source-code"><strong class="bold">Mexico City.... pop 21,900,000 coords 19.4326, -99.1332</strong></p>
			<p class="source-code"><strong class="bold">Sydney......... pop 5,312,000  coords -33.8688, 151.2093</strong></p>
			<ul>
				<li>The <strong class="source-inline">make_commas()</strong> function was also used in the <em class="italic">Use structured binding to return multiple values</em> recipe in <a href="B18267_02_ePub.xhtml#_idTextAnchor057"><em class="italic">Chapter 2</em></a>, <em class="italic">General STL Features</em>. It takes a numeric value and<a id="_idIndexMarker637"/> returns a <strong class="source-inline">string</strong> object, with commas added for readability:<p class="source-code">string make_commas(const unsigned long num) {</p><p class="source-code">    string s{ std::to_string(num) };</p><p class="source-code">    for(int l = s.length() - 3; l &gt; 0; l -= 3) {</p><p class="source-code">        s.insert(l, ",");</p><p class="source-code">    }</p><p class="source-code">    return s;</p><p class="source-code">}</p></li>
			</ul>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor241"/>How it works…</h2>
			<p>The heart of this<a id="_idIndexMarker638"/> recipe is the <strong class="source-inline">istream</strong> class <strong class="source-inline">operator&gt;&gt;</strong> overload:</p>
			<p class="source-code">std::istream&amp; <strong class="bold">operator&gt;&gt;</strong>(std::istream&amp; in, <strong class="bold">City&amp; c</strong>) {</p>
			<p class="source-code">    in &gt;&gt; std::ws;</p>
			<p class="source-code">    std::getline(in, c.name);</p>
			<p class="source-code">    in &gt;&gt; c.population &gt;&gt; c.latitude &gt;&gt; c.longitude;</p>
			<p class="source-code">    return in;</p>
			<p class="source-code">}</p>
			<p>By specifying our <strong class="source-inline">City</strong> class in the function header, this function will be called every time a <strong class="source-inline">City</strong> object appears on the right-hand side of an input stream <strong class="source-inline">&gt;&gt;</strong> operator:</p>
			<p class="source-code">City c{};</p>
			<p class="source-code">infile &gt;&gt; c;</p>
			<p>This allows us to specify exactly how the<a id="_idIndexMarker639"/> input stream reads data into a <strong class="source-inline">City</strong> object.</p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor242"/>There's more…</h2>
			<p>When you run this code on a Windows system, you'll notice that the first word of the first line gets corrupted. That's because Windows <a id="_idIndexMarker640"/>always includes a <strong class="bold">Byte Order Mark</strong> (<strong class="bold">BOM</strong>) at the head of any UTF-8 file. So, when you read a file on Windows, the BOM will be included in the first object you read. The BOM is anachronistic, but at the time of writing, there is no way to stop Windows from employing it.</p>
			<p>The solution is to call a function that checks the first three bytes of a file for the BOM. The BOM for UTF-8 is <strong class="source-inline">EF BB BF</strong>. Here's a function that searches for, and skips, a UTF-8 BOM:</p>
			<p class="source-code">// skip BOM for UTF-8 on Windows</p>
			<p class="source-code">void skip_bom(auto&amp; <strong class="bold">fs</strong>) {</p>
			<p class="source-code">    const unsigned char boms[]{ <strong class="bold">0xef</strong>, <strong class="bold">0xbb</strong>, <strong class="bold">0xbf</strong> };</p>
			<p class="source-code">    bool have_bom{ true };</p>
			<p class="source-code">    for(const auto&amp; c : boms) {</p>
			<p class="source-code">        if((unsigned char)fs.get() != c) have_bom = false; </p>
			<p class="source-code">    }</p>
			<p class="source-code">    if(!have_bom) <strong class="bold">fs.seekg(0)</strong>;</p>
			<p class="source-code">    return;</p>
			<p class="source-code">}</p>
			<p>This reads the first three bytes of the file and<a id="_idIndexMarker641"/> checks them for the UTF-8 BOM signature. If any of the three bytes do not match, it resets the input stream to the beginning of the file. If the file has no BOM, there's no harm done.</p>
			<p>You simply call this function before you begin reading from a file:</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    ifstream infile(fn, std::ios_base::in);</p>
			<p class="source-code">    if(!infile.is_open()) {</p>
			<p class="source-code">        cout &lt;&lt; format("failed to open file {}\n", fn);</p>
			<p class="source-code">        return 1;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    <strong class="bold">skip_bom(infile);</strong></p>
			<p class="source-code">    for(City c{}; infile &gt;&gt; c;) cities.emplace_back(c);</p>
			<p class="source-code">    ...</p>
			<p class="source-code">}</p>
			<p>This will ensure that the BOM is not included in the first string of the file.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Because the <strong class="source-inline">cin</strong> input stream is not seekable, the <strong class="source-inline">skip_bom()</strong> function will not work on the <strong class="source-inline">cin</strong> stream. It will only work with a seekable text file.</p>
			<h1 id="_idParaDest-244"><a id="_idTextAnchor243"/>Customize a string class with char_traits</h1>
			<p>The <strong class="source-inline">string</strong> class is an <a id="_idIndexMarker642"/>alias of the <strong class="source-inline">basic_string</strong> class, with the <a id="_idIndexMarker643"/>signature:</p>
			<p class="source-code">class basic_string&lt;char, std::char_traits&lt;char&gt;&gt;;</p>
			<p>The first template parameter provides the type of character. The second template parameter provides a character traits class, which provides basic character and string operations for the specified character type. We normally use the default <strong class="source-inline">char_traits&lt;char&gt;</strong> class.</p>
			<p>We can modify the behavior of a string by providing our own custom character traits class.</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor244"/>How to do it…</h2>
			<p>In this recipe, we will create a <em class="italic">character traits class</em> for use with <strong class="source-inline">basic_string</strong> that will ignore casing for comparison purposes:</p>
			<ul>
				<li>First, we'll need a function to convert characters to a common case. We'll use lowercase here, but it's an arbitrary choice. Uppercase would work just as well:<p class="source-code">constexpr char char_lower(const char&amp; c) {</p><p class="source-code">    if(c &gt;= 'A' &amp;&amp; c &lt;= 'Z') return c + ('a' - 'A');</p><p class="source-code">    else return c;</p><p class="source-code">}</p></li>
			</ul>
			<p>This function must be <strong class="source-inline">constexpr</strong> (for C++20 and later), so the existing <strong class="source-inline">std::tolower()</strong> function won't work here. Fortunately, it's a simple solution to a simple problem.</p>
			<ul>
				<li>Our traits class is called <strong class="source-inline">ci_traits</strong> (<em class="italic">ci</em> stands for case-independent). It inherits from <strong class="source-inline">std::char_traits&lt;char&gt;</strong>:<p class="source-code">class ci_traits : public std::char_traits&lt;char&gt; {</p><p class="source-code">public:</p><p class="source-code">    ...</p><p class="source-code">};</p></li>
			</ul>
			<p>The inheritance allows us to override only the functions that we need.</p>
			<ul>
				<li>The comparison functions<a id="_idIndexMarker644"/> are called <strong class="source-inline">lt()</strong> for less than <a id="_idIndexMarker645"/>and <strong class="source-inline">eq()</strong> for equal to:<p class="source-code">static constexpr bool lt(char_type a, char_type b) noexcept {</p><p class="source-code">    return <strong class="bold">char_lower(a)</strong> &lt; <strong class="bold">char_lower(b)</strong>;</p><p class="source-code">}</p><p class="source-code">static constexpr bool eq(char_type a, char_type b) noexcept {</p><p class="source-code">    return <strong class="bold">char_lower(a)</strong> == <strong class="bold">char_lower(b)</strong>;</p><p class="source-code">}</p></li>
			</ul>
			<p>Notice that we compare the <em class="italic">lowercase</em> versions of characters.</p>
			<ul>
				<li>There's also a <strong class="source-inline">compare()</strong> function, which compares two C-strings. It returns <strong class="source-inline">+1</strong> for greater than, <strong class="source-inline">-1</strong> for less than, and <strong class="source-inline">0</strong> for equal to. We can use the spaceship <strong class="source-inline">&lt;=&gt;</strong> operator for this:<p class="source-code">static constexpr int compare(const char_type* s1, </p><p class="source-code">        const char_type* s2, size_t count) {</p><p class="source-code">    for(size_t i{0}; i &lt; count; ++i) {</p><p class="source-code">        auto diff{ <strong class="bold">char_lower(s1[i]) &lt;=&gt; </strong></p><p class="source-code"><strong class="bold">          char_lower(s2[i])</strong> };</p><p class="source-code">        if(diff &gt; 0) return 1;</p><p class="source-code">        if(diff &lt; 0) return -1;</p><p class="source-code">        }</p><p class="source-code">    return 0;</p><p class="source-code">}</p></li>
				<li>Finally, we need to <a id="_idIndexMarker646"/>implement a <strong class="source-inline">find()</strong> function. This returns a pointer to the first instance of a found <a id="_idIndexMarker647"/>character, or <strong class="source-inline">nullptr</strong> if not found:<p class="source-code">static constexpr const char_type* find(const char_type* p, </p><p class="source-code">        size_t count, const char_type&amp; ch) {</p><p class="source-code">    const char_type find_c{ char_lower(ch) };</p><p class="source-code">    for(size_t i{0}; i &lt; count; ++i) {</p><p class="source-code">        if(find_c == char_lower(p[i])) <strong class="bold">return p + i</strong>;</p><p class="source-code">    }</p><p class="source-code">    return <strong class="bold">nullptr</strong>;</p><p class="source-code">}</p></li>
				<li>Now that we have a <strong class="source-inline">ci_traits</strong> class, we can define an alias for our <strong class="source-inline">string</strong> class:<p class="source-code">using ci_string = std::basic_string&lt;char, ci_traits&gt;;</p></li>
				<li>In our <strong class="source-inline">main()</strong> function, we define a <strong class="source-inline">string</strong> and a <strong class="source-inline">ci_string</strong>:<p class="source-code">int main() {</p><p class="source-code">    string s{"Foo Bar Baz"};</p><p class="source-code">    ci_string ci_s{"Foo Bar Baz"};</p><p class="source-code">    ...</p></li>
				<li>We want to print them using <strong class="source-inline">cout</strong>, but this won't work:<p class="source-code">cout &lt;&lt; "string: " &lt;&lt; s &lt;&lt; '\n';</p><p class="source-code">cout &lt;&lt; "ci_string: " &lt;&lt; ci_s &lt;&lt; '\n';</p></li>
			</ul>
			<p>First, we need an operator overload for the <strong class="source-inline">operator&lt;&lt;</strong>:</p>
			<p class="source-code">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, </p>
			<p class="source-code">        const ci_string&amp; str) {</p>
			<p class="source-code">    return os &lt;&lt; str.c_str();</p>
			<p class="source-code">}</p>
			<p>Now, we get this<a id="_idIndexMarker648"/> output:</p>
			<p class="source-code">string: Foo Bar Baz</p>
			<p class="source-code">ci_string: Foo Bar Baz</p>
			<ul>
				<li>Let's compare two <strong class="source-inline">ci_string</strong> objects<a id="_idIndexMarker649"/> with different cases:<p class="source-code">ci_string compare1{"CoMpArE StRiNg"};</p><p class="source-code">ci_string compare2{"compare string"};</p><p class="source-code">if (compare1 == compare2) {</p><p class="source-code">    cout &lt;&lt; format("Match! {} == {}\n", compare1, </p><p class="source-code">      compare2);</p><p class="source-code">} else {</p><p class="source-code">    cout &lt;&lt; format("no match {} != {}\n", compare1, </p><p class="source-code">      compare2);</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">Match! CoMpArE StRiNg == compare string</strong></p>
			<p>The comparison works as expected.</p>
			<ul>
				<li>Using the <strong class="source-inline">find()</strong> function on the <strong class="source-inline">ci_s</strong> object, we<a id="_idIndexMarker650"/> search for <a id="_idIndexMarker651"/>a lowercase <strong class="source-inline">b</strong> and find an uppercase <strong class="source-inline">B</strong>:<p class="source-code">size_t found = ci_s.find('b');</p><p class="source-code">cout &lt;&lt; format("found: pos {} char {}\n", found, ci_s[found]);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">found: pos 4 char B</strong></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Notice that the <strong class="source-inline">format()</strong> function doesn't require a specialization. This was tested with the <strong class="source-inline">fmt.dev</strong> reference implementation. It did not work with the preview release of MSVC's <strong class="source-inline">format()</strong>, even with a specialization. Hopefully, this will be fixed in a future release.</p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor245"/>How it works…</h2>
			<p>This recipe works by replacing the <strong class="source-inline">std::char_traits</strong> class in the template specialization of the <strong class="source-inline">string</strong> class with a <strong class="source-inline">ci_traits</strong> class of our own. The <strong class="source-inline">basic_string</strong> class uses the traits class for its fundamental character-specific functions, such as comparisons and searching. When we replace it with our own class, we can change these fundamental behaviors.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor246"/>There's more…</h2>
			<p>We can also override the <strong class="source-inline">assign()</strong> and <strong class="source-inline">copy()</strong> member<a id="_idIndexMarker652"/> functions to create a class that stores <a id="_idIndexMarker653"/>lowercase characters:</p>
			<p class="source-code">class lc_traits : public std::char_traits&lt;char&gt; {</p>
			<p class="source-code">public:</p>
			<p class="source-code">    static constexpr void <strong class="bold">assign</strong>( char_type&amp; r, const</p>
			<p class="source-code">      char_type&amp; a )</p>
			<p class="source-code">            noexcept {</p>
			<p class="source-code">        r = char_lower(a);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    static constexpr char_type* <strong class="bold">assign</strong>( char_type* p,</p>
			<p class="source-code">            std::size_t count, char_type a ) {</p>
			<p class="source-code">        for(size_t i{}; i &lt; count; ++i) p[i] = </p>
			<p class="source-code">          char_lower(a);</p>
			<p class="source-code">        return p;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    static constexpr char_type* <strong class="bold">copy</strong>(char_type* dest, </p>
			<p class="source-code">            const char_type* src, size_t count) {</p>
			<p class="source-code">        for(size_t i{0}; i &lt; count; ++i) {</p>
			<p class="source-code">            dest[i] = char_lower(src[i]);</p>
			<p class="source-code">        }</p>
			<p class="source-code">        return dest;</p>
			<p class="source-code">    }</p>
			<p class="source-code">};</p>
			<p>Now, we can create an <strong class="source-inline">lc_string</strong> alias, and the object <a id="_idIndexMarker654"/>stores lowercase<a id="_idIndexMarker655"/> characters:</p>
			<p class="source-code">using lc_string = std::basic_string&lt;char, lc_traits&gt;;</p>
			<p class="source-code">...</p>
			<p class="source-code">lc_string lc_s{"Foo Bar Baz"};</p>
			<p class="source-code">cout &lt;&lt; "lc_string: " &lt;&lt; lc_s &lt;&lt; '\n';</p>
			<p>Output:</p>
			<p class="source-code">lc_string: foo bar baz</p>
			<p class="callout-heading">Note</p>
			<p class="callout">These techniques work as expected on GCC and Clang but not on the preview release of MSVC. I expect that this will be fixed in a future release.</p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor247"/>Parse strings with Regular Expressions</h1>
			<p><em class="italic">Regular Expressions</em> (commonly<a id="_idIndexMarker656"/> abbreviated as <em class="italic">regex</em>) are commonly used for lexical analysis and pattern-matching on streams of text. They are common in Unix text-processing utilities, such as <strong class="source-inline">grep</strong>, <strong class="source-inline">awk</strong>, and <strong class="source-inline">sed</strong>, and are an integral <a id="_idIndexMarker657"/>part of the <em class="italic">Perl</em> language. There are a few common variations in the syntax. A POSIX standard was approved in 1992, while other common variations include <em class="italic">Perl</em> and <em class="italic">ECMAScript</em> (JavaScript) dialects. The C++ <strong class="source-inline">regex</strong> library defaults to the ECMAScript dialect.</p>
			<p>The <strong class="source-inline">regex</strong> library was first introduced to the STL with C++11. It can be very useful for finding patterns in text files.</p>
			<p>To learn more about Regular Expression syntax and usage, I recommend the book, <em class="italic">Mastering Regular Expressions</em> by Jeffrey Friedl.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor248"/>How to do it…</h2>
			<p>For this recipe, we will extract hyperlinks from an HTML file. A hyperlink is coded in HTML like this:</p>
			<p class="source-code">&lt;a href="http://example.com/file.html"&gt;Text goes here&lt;/a&gt;</p>
			<p>We will use a <strong class="source-inline">regex</strong> object to extract both the link and the text, as two separate strings.</p>
			<ul>
				<li>Our example file is called <strong class="source-inline">the-end.html</strong>. It's taken from my website (<a href="https://bw.org/end/">https://bw.org/end/</a>), and is included in the GitHub repository:<p class="source-code">const char * fn{ "the-end.html" };</p></li>
				<li>Now, we define our <strong class="source-inline">regex</strong> object with a regular expression string:<p class="source-code">const std::regex </p><p class="source-code">    link_re{ "&lt;a href=\"([^\"]*)\"[^&lt;]*&gt;([^&lt;]*)&lt;/a&gt;" };</p></li>
			</ul>
			<p>Regular expressions can look<a id="_idIndexMarker658"/> intimidating at first, but<a id="_idIndexMarker659"/> they're actually rather simple.</p>
			<p>This is parsed as follows:</p>
			<ol>
				<li>Match the whole string.</li>
				<li>Find the substring <strong class="source-inline">&lt;a href="</strong>.</li>
				<li>Store everything up to the next <strong class="source-inline">"</strong> as sub-match <strong class="source-inline">1</strong>.</li>
				<li>Skip past the <strong class="source-inline">&gt;</strong> character.</li>
				<li>Store everything up to the string <strong class="source-inline">&lt;/a&gt;</strong> as sub-match <strong class="source-inline">2</strong>.</li>
			</ol>
			<ul>
				<li>Now, we read our file entirely into a string:<p class="source-code">string in{};</p><p class="source-code">std::ifstream <strong class="bold">infile</strong>(<strong class="bold">fn</strong>, std::ios_base::in);</p><p class="source-code">for(string line{}; <strong class="bold">getline</strong>(infile, line);) <strong class="bold">in += line</strong>;</p></li>
			</ul>
			<p>This opens the HTML file, reads it line by line, and appends each line to the <strong class="source-inline">string</strong> object, <strong class="source-inline">in</strong>.</p>
			<ul>
				<li>To extract the link strings, we set up an <strong class="source-inline">sregex_token_iterator</strong> object to step through the file and extract each of the matched elements:<p class="source-code">std::sregex_token_iterator it{ in.begin(), in.end(),</p><p class="source-code">    link_re, {<strong class="bold">1</strong>, <strong class="bold">2</strong>} };</p></li>
			</ul>
			<p>The <strong class="source-inline">1</strong> and <strong class="source-inline">2</strong> correspond to the sub-matches in the regular expression.</p>
			<ul>
				<li>We have a corresponding function to step through the results with the iterator:<p class="source-code">template&lt;typename It&gt;</p><p class="source-code">void get_links(It <strong class="bold">it</strong>) {</p><p class="source-code">    for(It end_it{}; <strong class="bold">it != end_it</strong>; ) {</p><p class="source-code">        const string <strong class="bold">link{ *it++ }</strong>;</p><p class="source-code">        if(it == end_it) break;</p><p class="source-code">        const string <strong class="bold">desc{ *it++ }</strong>;</p><p class="source-code">        <strong class="bold">cout &lt;&lt; format("{:.&lt;24} {}\n", desc, link);</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>We call the function with<a id="_idIndexMarker660"/> the <strong class="source-inline">regex</strong> iterator:</p>
			<p class="source-code">get_links(it);</p>
			<p>And we get this result with <a id="_idIndexMarker661"/>our descriptions and links:</p>
			<p class="source-code"><strong class="bold">Bill Weinman............ https://bw.org/</strong></p>
			<p class="source-code"><strong class="bold">courses................. https://bw.org/courses/</strong></p>
			<p class="source-code"><strong class="bold">music................... https://bw.org/music/</strong></p>
			<p class="source-code"><strong class="bold">books................... https://packt.com/</strong></p>
			<p class="source-code"><strong class="bold">back to the internet.... https://duckduckgo.com/</strong></p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor249"/>How it works…</h2>
			<p>The STL <strong class="source-inline">regex</strong> engine operates as a <em class="italic">generator</em> that evaluates and yields one result at a time. We set up the iterator using <strong class="source-inline">sregex_iterator</strong> or <strong class="source-inline">sregex_token_iterator</strong>. While <strong class="source-inline">sregex_token_iterator</strong> supports sub-matches, <strong class="source-inline">sregex_iterator</strong> does not.</p>
			<p>The parentheses in our regex serve as <em class="italic">sub-matches</em>, numbered <strong class="source-inline">1</strong> and <strong class="source-inline">2</strong> respectively:</p>
			<p class="source-code">const regex link_re{ "&lt;a href=\"<strong class="bold">([^\"]*)</strong>\"[^&lt;]*&gt;<strong class="bold">([^&lt;]*)</strong>&lt;/a&gt;" };</p>
			<p>Each part of the <strong class="source-inline">regex</strong> matches is illustrated here:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B18267_07_01.jpg" alt="Figure 7.1 – A Regular Expression with sub-matches&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – A Regular Expression with sub-matches</p>
			<p>This allows us to match a string and use <a id="_idIndexMarker662"/>parts of that string as our results:</p>
			<p class="source-code"><strong class="bold">sregex_token_iterator</strong> it{ in.begin(), in.end(), <strong class="bold">link_re</strong>, {<strong class="bold">1</strong>, <strong class="bold">2</strong>} };</p>
			<p>The sub-matches are numbered, beginning <a id="_idIndexMarker663"/>with <strong class="source-inline">1</strong>. Sub-match <strong class="source-inline">0</strong> is a special value that represents the entire match.</p>
			<p>Once we have our iterator, we use it as we would any other iterator:</p>
			<p class="source-code">for(It end_it{}; it != end_it; ) {</p>
			<p class="source-code">    const string link{ <strong class="bold">*it++</strong> };</p>
			<p class="source-code">    if(it == end_it) break;</p>
			<p class="source-code">    const string desc{ <strong class="bold">*it++</strong> };</p>
			<p class="source-code">    cout &lt;&lt; format("{:.&lt;24} {}\n", desc, link);</p>
			<p class="source-code">}</p>
			<p>This simply steps through our<a id="_idIndexMarker664"/> results via the <strong class="source-inline">regex</strong> iterator, giving<a id="_idIndexMarker665"/> us the formatted output:</p>
			<p class="source-code">Bill Weinman............ https://bw.org/</p>
			<p class="source-code">courses................. https://bw.org/courses/</p>
			<p class="source-code">music................... https://bw.org/music/</p>
			<p class="source-code">books................... https://packt.com/</p>
			<p class="source-code">back to the internet.... https://duckduckgo.com/</p>
		</div>
	</body></html>