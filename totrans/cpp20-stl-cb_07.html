<html><head></head><body>
		<div><h1 id="_idParaDest-213"><em class="italic"><a id="_idTextAnchor212"/>Chapter 7</em>: Strings, Streams, and Formatting</h1>
			<p>The STL <code>string</code> class is a powerful, full-featured tool for storing, manipulating, and displaying character-based data. It has much of the convenience you would find in a high-level scripting language, yet remains as quick and agile as you would expect from C++.</p>
			<p>The <code>string</code> class is based on <code>basic_string</code>, a contiguous container class that may be instantiated with any character type. Its class signature looks like this:</p>
			<pre>template&lt;
    typename CharT,
    typename Traits = std::char_traits&lt;CharT&gt;,
    typename Allocator = std::allocator&lt;CharT&gt;
&gt; class basic_string;</pre>
			<p>The <code>Traits</code> and <code>Allocator</code> template parameters are usually left to their default values.</p>
			<p>The underlying storage of <code>basic_string</code> is a contiguous sequence of <code>CharT</code>, and can be accessed with the <code>data()</code> member function:</p>
			<pre>const <strong class="bold">std::basic_string&lt;char&gt;</strong> s{"hello"};
const char * sdata = <strong class="bold">s.data()</strong>;
for(size_t i{0}; i &lt; s.size(); ++i) {
    cout &lt;&lt; sdata[i] &lt;&lt; ' ';
}
cout &lt;&lt; '\n';</pre>
			<p>Output:</p>
			<pre>h e l l o</pre>
			<p>The <code>data()</code> member function returns a <code>CharT*</code> that points to the underlying array of characters. Since C++11, the array returned by <code>data()</code> is null-terminated, making <code>data()</code> equivalent to <code>c_str()</code>.</p>
			<p>The <code>basic_string</code> class includes many of the methods you would find in other contiguous-storage classes, including <code>insert()</code>, <code>erase()</code>, <code>push_back()</code>, <code>pop_back()</code>, and others. These methods operate on the underlying array of <code>CharT</code>.</p>
			<p><code>std::string</code> is a type alias for <code>std::basic_string&lt;char&gt;</code>:</p>
			<pre>using std::string = std::basic_string&lt;char&gt;;</pre>
			<p>For most purposes, you'll use <code>std::string</code>.</p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor213"/>String formatting</h1>
			<p>String formatting has traditionally been a weak point with the STL. Until recently, we've been left with an imperfect choice between the cumbersome STL <code>iostreams</code> or the archaic legacy <code>printf()</code>. Beginning with C++20 and the <code>format</code> library, STL string formatting has finally grown up. Closely based on Python's <code>str.format()</code> method, the new <code>format</code> library is fast and flexible, providing many of the advantages of both <code>iostreams</code> and <code>printf()</code>, along with good memory management and type safety.</p>
			<p>For more about the <code>format</code> library, see the <em class="italic">Format text with the new format library</em> recipe in <a href="B18267_01_ePub.xhtml#_idTextAnchor027"><em class="italic">Chaper 1</em></a>, <em class="italic">New C++20 Features</em>.</p>
			<p>While we no longer need to use <code>iostreams</code> for string formatting, it is still quite useful for other purposes, including file and stream I/O, and some type conversions.</p>
			<p>In this chapter, we will cover these subjects and more in the following recipes:</p>
			<ul>
				<li>Use <code>string_view</code> as a lightweight string object</li>
				<li>Concatenate strings</li>
				<li>Transform strings</li>
				<li>Format text with C++20's <code>format</code> library</li>
				<li>Trim whitespace from strings</li>
				<li>Read strings from user input</li>
				<li>Count words in a file</li>
				<li>Initialize complex structures from file input</li>
				<li>Customize a string class with <code>char_traits</code></li>
				<li>Parse strings with Regular Expressions</li>
			</ul>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor214"/>Technical requirements</h1>
			<p>You can find code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap07">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap07</a>.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor215"/>Use string_view as a lightweight string object</h1>
			<p>The <code>string_view</code> class provides a lightweight alternative to the <code>string</code> class. Instead of maintaining its own data<a id="_idIndexMarker561"/> store, <code>string_view</code> operates on a <em class="italic">view</em> of a C-string. This makes <code>string_view</code> smaller and more efficient than <code>std::string</code>. It's useful in cases where you need a string object but don't <a id="_idIndexMarker562"/>need the more memory- and computation-intensive features of <code>std::string</code>.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor216"/>How to do it…</h2>
			<p>The <code>string_view</code> class looks deceptively similar to the STL <code>string</code> class, but it works a bit differently. Let's consider some examples:</p>
			<ul>
				<li>Here's an STL <code>string</code> initialized from a C-string (array of <code>char</code>):<pre>char text[]{ "hello" };
string greeting{ text };
text[0] = 'J';
cout &lt;&lt; text &lt;&lt; ' ' &lt;&lt; greeting &lt;&lt; '\n';</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">Jello hello</strong></pre>
			<p>Notice that the <code>string</code> does not change when we modify the array. This is because the <code>string</code> constructor creates its own copy of the underlying data.</p>
			<ul>
				<li>When we do the same with a <code>string_view</code>, we get a different result:<pre>char text[]{ "hello" };
string_view greeting{ text };
text[0] = 'J';
cout &lt;&lt; text &lt;&lt; ' ' &lt;&lt; greeting &lt;&lt; '\n';</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">Jello Jello</strong></pre>
			<p>The <code>string_view</code> constructor creates a <em class="italic">view</em> of the underlying data. It does not make its own copy. This results in significant efficiencies but also allows for side effects.</p>
			<ul>
				<li>Because <code>string_view</code> doesn't copy the<a id="_idIndexMarker563"/> underlying data, the <a id="_idIndexMarker564"/>source data must remain in scope for the duration of the <code>string_view</code> object. So, this does not work:<pre>string_view sv() {
    <strong class="bold">const char text[]{ "hello" }</strong>;  // temporary storage
    string_view greeting{ text };
    return greeting;
}
int main() {
    <strong class="bold">string_view greeting = sv();</strong>  // data out of scope
    cout &lt;&lt; <strong class="bold">greeting</strong> &lt;&lt; '\n';  // output undefined
}</pre></li>
			</ul>
			<p>Because the underlying data goes out of scope after the <code>sv()</code> function returns, the <code>greeting</code> object in <code>main()</code> is no longer valid by the time we use it.</p>
			<ul>
				<li>The <code>string_view</code> class has constructors that make sense for the underlying data. This includes character arrays (<code>const char*</code>), contiguous <em class="italic">ranges</em> (including <code>std::string</code>), and other <code>string_view</code> objects. This example uses the <em class="italic">ranges</em> constructor:<pre>string str{ "hello" };
string_view greeting{ str };
cout &lt;&lt; greeting &lt;&lt; '\n';</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">hello</strong></pre>
			<ul>
				<li>There is also<a id="_idIndexMarker565"/> a <code>string_view</code> literal <a id="_idIndexMarker566"/>operator <code>sv</code>, defined in the <code>std::literals</code> namespace:<pre>using namespace std::literals;
cout &lt;&lt; "hello"sv.substr(1, 4) &lt;&lt; '\n';</pre></li>
			</ul>
			<p>This constructs a <code>constexpr string_view</code> object and calls its method <code>substr()</code> to get the <code>4</code> values starting at index <code>1</code>.</p>
			<p>Output:</p>
			<pre><strong class="bold">ello</strong></pre>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor217"/>How it works…</h2>
			<p>The <code>string_view</code> class is effectively an <em class="italic">iterator adapter</em> on a contiguous sequence of characters. The implementation typically has two members: a <code>const CharT *</code> and a <code>size_t</code>. It works by wrapping a <code>contiguous_iterator</code> around the source data.</p>
			<p>This means that you can use it like <code>std::string</code> for many purposes, with a few important distinctions:</p>
			<ul>
				<li>The copy constructor does not copy the data. This means that when you make a copy of a <code>string_view</code>, each copy operates on the same underlying data:<pre>char text[]{ "hello" };
string_view sv1{ text };
string_view sv2{ sv1 };
string_view sv3{ sv2 };
string_view sv4{ sv3 };
cout &lt;&lt; format("{} {} {} {}\n", sv1, sv2, sv3, sv4);
text[0] = 'J';
cout &lt;&lt; format("{} {} {} {}\n", sv1, sv2, sv3, sv4);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">hello hello hello hello</strong>
<strong class="bold">Jello Jello Jello Jello</strong></pre>
			<ul>
				<li>Keep in mind<a id="_idIndexMarker567"/> that when <a id="_idIndexMarker568"/>you pass a <code>string_view</code> to a function, it uses the copy constructor:<pre>void f(string_view sv) {
    if(sv.size()) {
        <strong class="bold">char* x = (char*)sv.data();  // dangerous</strong>
<strong class="bold">        x[0] = 'J';</strong>  // modifies the source
    }
    cout &lt;&lt; format("f(sv): {} {}\n", (void*)sv.data(),      sv);
}
int main() {
    char text[]{ "hello" };
    string_view sv1{ text };
    cout &lt;&lt; format("sv1: {} {}\n", (void*)sv1.data(),       sv1);
    f(sv1);
    cout &lt;&lt; format("sv1: {} {}\n", (void*)sv1.data(),       sv1);
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">sv1: 0x7ffd80fa7b2a hello</strong>
<strong class="bold">f(sv): 0x7ffd80fa7b2a Jello</strong>
<strong class="bold">sv1: 0x7ffd80fa7b2a Jello</strong></pre>
			<p>Notice that the address <a id="_idIndexMarker569"/>of the <a id="_idIndexMarker570"/>underlying data (returned by the <code>data()</code> member function) is the same for all instances of the <code>string_view</code>. That's because the copy constructor does not make a copy of the underlying data. Even though the <code>string_view</code> member pointer is <code>const</code>-qualified, it's still possible to cast away the <code>const</code> qualifier, though it's <em class="italic">not recommended</em> because it could cause unintended side effects. But it is worth noting that the data is never copied.</p>
			<ul>
				<li>The <code>string_view</code> class lacks methods that directly operate on the underlying string. Methods such as <code>append()</code>, <code>operator+()</code>, <code>push_back()</code>, <code>pop_back()</code>, <code>replace()</code>, and <code>resize()</code>, which are supported in <code>string</code>, are not supported in <code>string_view</code>.</li>
			</ul>
			<p>If you need to concatenate strings with the <code>+</code> operator, you'll need a <code>std::string</code>. For example, this does not work with <code>string_view</code>:</p>
			<pre>sv1 = sv2 + sv3 + sv4; // does not work</pre>
			<p>You'll need to use <code>string</code> instead:</p>
			<pre>string str1{ text };
string str2{ str1 };
string str3{ str2 };
string str4{ str3 };
str1 = str2 + str3 + str4; // works
cout &lt;&lt; str1 &lt;&lt; '\n';</pre>
			<p>Output:</p>
			<pre><strong class="bold">JelloJelloJello</strong></pre>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor218"/>Concatenate strings</h1>
			<p>There are several ways<a id="_idIndexMarker571"/> to concatenate strings in C++. In this recipe, we will look at the three most common: the <code>string</code> class <code>operator+()</code>, the <code>string</code> class <code>append()</code> function, and the <code>ostringstream</code> class <code>operator&lt;&lt;()</code>. New in C++20, we also have the <code>format()</code> function. Each of these has its advantages, disadvantages, and use cases.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor219"/>How to do it…</h2>
			<p>In this recipe, we will examine ways to concatenate strings. We will then perform some benchmarks and consider the different use cases.</p>
			<ul>
				<li>We'll start with a couple of <code>std::string</code> objects:<pre>string a{ "a" };
string b{ "b" };</pre></li>
			</ul>
			<p>The <code>string</code> objects are constructed from literal C-strings.</p>
			<p>The C-string constructor makes a copy of the literal string and uses the local copy as the underlying data for the <code>string</code> object.</p>
			<ul>
				<li>Now, let's construct a new empty string object and concatenate <code>a</code> and <code>b</code> with a separator and a newline:<pre>string x{};
x += a + ", " + b + "\n";
cout &lt;&lt; x;</pre></li>
			</ul>
			<p>Here, we used the <code>string</code> object's <code>+=</code> and <code>+</code> operators to concatenate the <code>a</code> and <code>b</code> strings, along with literal strings <code>", "</code> and <code>"\n"</code>. The resulting string has the elements concatenated together:</p>
			<pre><strong class="bold">a, b</strong></pre>
			<ul>
				<li>We could instead use the <code>string</code> object's <code>append()</code> member function:<pre>string x{};
x.append(a);
x.append(", ");
x.append(b);
x.append("\n");
cout &lt;&lt; x;</pre></li>
			</ul>
			<p>This gives us the same result:</p>
			<pre><strong class="bold">a, b</strong></pre>
			<ul>
				<li>Or, we could<a id="_idIndexMarker572"/> construct an <code>ostringstream</code> object, which uses the stream interface:<pre>ostringstream x{};
x &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; "\n";
cout &lt;&lt; x.str();</pre></li>
			</ul>
			<p>We get the same result:</p>
			<pre><strong class="bold">a, b</strong></pre>
			<ul>
				<li>We could also use the C++20 <code>format()</code> function:<pre>string x{};
x = format("{}, {}\n", a, b);
cout &lt;&lt; x;</pre></li>
			</ul>
			<p>Again, we have the same result:</p>
			<pre><strong class="bold">a, b</strong></pre>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor220"/>How it works…</h2>
			<p>The <code>string</code> object has two<a id="_idIndexMarker573"/> distinct methods for concatenating a string, the <code>+</code> operator and the <code>append()</code> member function.</p>
			<p>The <code>append()</code> member function adds data to the end of the <code>string</code> object's data. It must allocate and manage memory to accomplish this.</p>
			<p>The <code>+</code> operator uses the <code>operator+()</code> overload to construct a new <code>string</code> object with the old and new data, and returns the new object.</p>
			<p>The <code>ostringstream</code> object works like an <code>ostream</code> but stores its output for use as a string.</p>
			<p>The C++20 <code>format()</code> function uses a format string with variadic arguments and returns a newly constructed <code>string</code> object.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor221"/>There's more…</h2>
			<p>How do you decide which concatenation strategy is right for your code? We can start with some benchmarks.</p>
			<h3>Benchmarks</h3>
			<p>I performed these tests<a id="_idIndexMarker574"/> using GCC 11 on Debian Linux:</p>
			<ul>
				<li>First, we'll create a <code>timer</code> function using the <code>&lt;chrono&gt;</code> library:<pre>using std::chrono::high_resolution_clock;
using std::chrono::duration;
void timer(string(*f)()) {
    auto t1 = high_resolution_clock::now();
    string s{ f() };
    auto t2 = high_resolution_clock::now();
    duration&lt;double, std::milli&gt; ms = t2 - t1;
    cout &lt;&lt; s;
    cout &lt;&lt; format("duration: {} ms\n", ms.count());
}</pre></li>
			</ul>
			<p>The <code>timer</code> function calls the function passed to it, marking the time before and after the function call. It then displays the duration using <code>cout</code>.</p>
			<ul>
				<li>Now, we create a function that <a id="_idIndexMarker575"/>concatenates strings, using the <code>append()</code> member function:<pre>string append_string() {
    cout &lt;&lt; "append_string\n";
    string a{ "a" };
    string b{ "b" };
    long n{0};
    while(++n) {
        string x{};
        x.append(a);
        x.append(", ");
        x.append(b);
        x.append("\n");
        if(n &gt;= 10000000) return x;
    }
    return "error\n";
}</pre></li>
			</ul>
			<p>For benchmarking purposes, this function repeats the concatenation 10 million times. We call this function <a id="_idIndexMarker576"/>from <code>main()</code> with <code>timer()</code>:</p>
			<pre>int main() {
    timer(append_string);
}</pre>
			<p>We get this output:</p>
			<pre><strong class="bold">append_string</strong>
<strong class="bold">a, b</strong>
<strong class="bold">duration: 425.361643 ms</strong></pre>
			<p>So, on this system, our concatenation ran 10 million iterations in about 425 milliseconds.</p>
			<ul>
				<li>Now, let's create the same function with the <code>+</code> operator overload:<pre>string concat_string() {
    cout &lt;&lt; "concat_string\n";
    string a{ "a" };
    string b{ "b" };
    long n{0};
    while(++n) {
        string x{};
        x += a + ", " + b + "\n";
        if(n &gt;= 10000000) return x;
    }
    return "error\n";
}</pre></li>
			</ul>
			<p>Our benchmark output:</p>
			<pre><strong class="bold">concat_string</strong>
<strong class="bold">a, b</strong>
<strong class="bold">duration: 659.957702 ms</strong></pre>
			<p>This version<a id="_idIndexMarker577"/> performed 10 million iterations in about 660 milliseconds.</p>
			<ul>
				<li>Now, let's try it with <code>ostringstream</code>:<pre>string concat_ostringstream() {
    cout &lt;&lt; "ostringstream\n";
    string a { "a" };
    string b { "b" };
    long n{0};
    while(++n) {
        ostringstream x{};
        x &lt;&lt; a &lt;&lt; ", " &lt;&lt; b &lt;&lt; "\n";
        if(n &gt;= 10000000) return x.str();
    }
    return "error\n";
}</pre></li>
			</ul>
			<p>Our benchmark output:</p>
			<pre><strong class="bold">ostringstream</strong>
<strong class="bold">a, b</strong>
<strong class="bold">duration: 3462.020587 ms</strong></pre>
			<p>This version ran 10 million iterations in about 3.5 seconds.</p>
			<ul>
				<li>Here's the <code>format()</code> version:<pre>string concat_format() {
    cout &lt;&lt; "append_format\n";
    string a{ "a" };
    string b{ "b" };
    long n{0};
    while(++n) {
        string x{};
        x = format("{}, {}\n", a, b);
        if(n &gt;= 10000000) return x;
    }
    return "error\n";
}</pre></li>
			</ul>
			<p>Our benchmark<a id="_idIndexMarker578"/> output:</p>
			<pre><strong class="bold">append_format</strong>
<strong class="bold">a, b</strong>
<strong class="bold">duration: 782.800547 ms</strong></pre>
			<p>The <code>format()</code> version ran 10 million iterations in about 783 milliseconds.</p>
			<ul>
				<li>Summary of the results:</li>
			</ul>
			<div><div><img src="img/B18267_table_7.1.jpg" alt="A comparison of concatenation performance&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">A comparison of concatenation performance</p>
			<h3>Why the performance discrepancies?</h3>
			<p>We can see from these benchmarks that the <code>ostringstream</code> version takes many times longer than the <code>string</code>-based versions.</p>
			<p>The <code>append()</code> method is<a id="_idIndexMarker579"/> slightly faster than the <code>+</code> operator. It needs to allocate memory but does not construct new objects. Some optimizations may be possible due to repetition.</p>
			<p>The <code>+</code> operator overload probably calls the <code>append()</code> method. The extra function call could make it incrementally slower than the <code>append()</code> method.</p>
			<p>The <code>format()</code> version creates one new <code>string</code> object but without the overhead of the <code>iostream</code> system.</p>
			<p>The <code>ostringstream</code> operator <code>&lt;&lt;</code> overload creates a new <code>ostream</code> object for each operation. Given the complexity of the stream object, along with managing the stream state, this makes it much slower than either of the <code>string</code>-based versions.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor222"/>Why would I choose one over another?</h2>
			<p>Some measure of personal preference<a id="_idIndexMarker580"/> will be involved. The operator overloads (<code>+</code> or <code>&lt;&lt;</code>) can be convenient. Performance may or may not be an issue for you.</p>
			<p>The <code>ostringstream</code> class has one distinct advantage over the <code>string</code> methods: it specializes the <code>&lt;&lt;</code> operator for each different type, so it's able to operate in circumstances where you may have different types calling the same code.</p>
			<p>The <code>format()</code> function offers the same type-safety and customization options and is significantly faster than the <code>ostringstream</code> class.</p>
			<p>The <code>string</code> object's <code>+</code> operator overload is fast, easy to use, and easy to read but is incrementally slower than <code>append()</code>.</p>
			<p>The <code>append()</code> version is fastest but requires a separate function call for each item.</p>
			<p>For my purposes, I like the <code>format()</code> function or the <code>string</code> object's <code>+</code> operator for most circumstances. I'll use <code>append()</code> if every <a id="_idIndexMarker581"/>bit of speed matters. I'll use <code>ostringstream</code> where I need its unique features and performance is not an issue.</p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor223"/>Transform strings</h1>
			<p>The <code>std::string</code> class is a <em class="italic">contiguous container</em>, much like a <code>vector</code> or an <code>array</code>. It supports<a id="_idIndexMarker582"/> the <code>contiguous_iterator</code> concept and all corresponding algorithms.</p>
			<p>The <code>string</code> class is a specialization of <code>basic_string</code> with a <code>char</code> type. This means that the elements of the container are of type <code>char</code>. Other specializations are available, but <code>string</code> is most common.</p>
			<p>Because it is fundamentally a contiguous container of <code>char</code> elements, <code>string</code> may be used with the <code>transform()</code> algorithm, or any other technique that uses the <code>contiguous_iterator</code> concept.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor224"/>How to do it…</h2>
			<p>There are several ways to do transformations, depending on the application. This recipe will explore a few of them.</p>
			<ul>
				<li>We'll start with a few predicate functions. A predicate function takes a transformation element and returns a related element. For example, here is a simple predicate that returns an upper-case character:<pre>char char_upper(const char&amp; c) {
    return static_cast&lt;char&gt;(std::toupper(c));
}</pre></li>
			</ul>
			<p>This function is a wrapper around <code>std::toupper()</code>. Because the <code>toupper()</code> function returns an <code>int</code> and <code>string</code> elements are type <code>char</code>, we cannot use the <code>toupper()</code> function directly in a transformation.</p>
			<p>Here is a corresponding <code>char_lower()</code> function:</p>
			<pre>char char_lower(const char&amp; c) {
    return static_cast&lt;char&gt;(std::tolower(c));
}</pre>
			<ul>
				<li>The <code>rot13()</code> function is a fun transformation predicate for demonstration purposes. It's a simple substitution cypher, <em class="italic">not suitable for encryption</em> but commonly used for <em class="italic">obfuscation</em>:<pre>char rot13(const char&amp; x) {
    auto rot13a = [](char x, char a)-&gt;char { 
        return a + (x - a + 13) % 26; 
    };
    if (x &gt;= 'A' &amp;&amp; x &lt;= 'Z') return rot13a(x, 'A');
    if (x &gt;= 'a' &amp;&amp; x &lt;= 'z') return rot13a(x, 'a');
    return x;
}</pre></li>
				<li>We can use these <a id="_idIndexMarker583"/>predicates with the <code>transform()</code> algorithm:<pre>main() {
    string s{ "hello jimi\n" };
    cout &lt;&lt; s;
    std::transform(s.begin(), s.end(), s.begin(), 
      char_upper);
    cout &lt;&lt; s;
    ...</pre></li>
			</ul>
			<p>The <code>transform()</code> function calls <code>char_upper()</code> with each element of <code>s</code>, puts the result back in <code>s</code> and<a id="_idIndexMarker584"/> transforms all the characters to uppercase:</p>
			<p>Output:</p>
			<pre><strong class="bold">hello jimi</strong>
<strong class="bold">HELLO JIMI</strong></pre>
			<ul>
				<li>Instead of <code>transform()</code>, we can also use a simple <code>for</code> loop with a <em class="italic">predicate</em> <em class="italic">function</em>:<pre>for(auto&amp; c : s) c = rot13(c);
cout &lt;&lt; s;</pre></li>
			</ul>
			<p>Starting with our uppercase string object, the result is:</p>
			<pre><strong class="bold">URYYB WVZV</strong></pre>
			<ul>
				<li>The fun thing about the <code>rot13</code> cypher is that it unscrambles itself. Because there are 26 letters in the <em class="italic">ASCII</em> alphabet, rotating 13 and then rotating 13 again results in the original string. Let's transform to lowercase and <code>rot13</code> again to restore our string:<pre>for(auto&amp; c : s) c = rot13(char_lower(c));
cout &lt;&lt; s;</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">hello jimi</strong></pre>
			<p>Because of their uniform interface, the predicate functions may be <em class="italic">chained</em> as parameters of each other. We could also use <code>char_lower(rot13(c))</code> with the same result.</p>
			<ul>
				<li>If your requirement is too complex for a simple character-by-character transformation, you may use <code>string</code> iterators as you would with any contiguous container. Here's a simple function that transforms a lowercase string to <em class="italic">Title Case</em> by capitalizing the first character and every character that follows a space:<pre>string&amp; title_case(string&amp; s) {
    auto begin = s.begin();
    auto end = s.end();
    *begin++ = char_upper(*begin);  // first element
    bool space_flag{ false };
    for(auto it{ begin }; it != end; ++it) {
        if(*it == ' ') {
            space_flag = true;
        } else {
            if(space_flag) *it = char_upper(*it);
            space_flag = false;
        }
    }
    return s;
}</pre></li>
			</ul>
			<p>Because it returns a reference<a id="_idIndexMarker585"/> to the transformed string, we can call it with <code>cout</code>, like this:</p>
			<pre>cout &lt;&lt; title_case(s);</pre>
			<p>Output:</p>
			<pre><strong class="bold">Hello Jimi</strong></pre>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor225"/>How it works…</h2>
			<p>The <code>std::basic_string</code> class, and its specializations (including <code>string</code>), are supported by iterators fully compliant with <code>contiguous_iterator</code>. This means that any technique that works with any <a id="_idIndexMarker586"/>contiguous container also works with <code>string</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">These transformations will not work with <code>string_view</code> objects because the underlying data is <code>const</code>-qualified. </p>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor226"/>Format text with C++20's format library</h1>
			<p>C++20 introduces the new <code>format()</code> function, which returns a formatted representation<a id="_idIndexMarker587"/> of its arguments in a string. <code>format()</code> uses a <a id="_idIndexMarker588"/>Python-style formatting string, with concise syntax, type safety, and excellent performance.</p>
			<p>The <code>format()</code> function takes a format string and a template, <em class="italic">parameter pack</em>, for its arguments:</p>
			<pre>template&lt; class... Args &gt;
string format(const string_view fmt, Args&amp;&amp;... args );</pre>
			<p>The format string uses curly braces <code>{}</code> as a placeholder for the formatted arguments:</p>
			<pre>const int a{47};
format("a is {}\n", a);</pre>
			<p>Output:</p>
			<pre>a is 47</pre>
			<p>It also uses the braces for format specifiers, for example:</p>
			<pre>format("Hex: {:x} Octal: {:o} Decimal {:d} \n", a, a, a);</pre>
			<p>Output:</p>
			<pre>Hex: 2f Octal: 57 Decimal 47</pre>
			<p>This recipe will show you how to use the <code>format()</code> function for some common string formatting solutions.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This chapter was developed using a preview release of the Microsoft Visual C++ compiler on Windows 10. At the time of writing, this is the only compiler that fully supports the C++20 <code>&lt;format&gt;</code> library. Final implementations may differ in some details.</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor227"/>How to do it…</h2>
			<p>Let's consider some common<a id="_idIndexMarker589"/> formatting solutions using the <code>format()</code> function:</p>
			<ul>
				<li>We'll start with some <a id="_idIndexMarker590"/>variables to format: <pre>const int inta{ 47 };
const char * human{ "earthlings" };
const string_view alien{ "vulcans" };
const double df_pi{ pi };</pre></li>
			</ul>
			<p>The <code>pi</code> constant is in the <code>&lt;numbers&gt;</code> header and the <code>std::numbers</code> namespace.</p>
			<ul>
				<li>We can display the variables using <code>cout</code>:<pre>cout &lt;&lt; "inta is " &lt;&lt; inta &lt;&lt; '\n'
    &lt;&lt; "hello, " &lt;&lt; human &lt;&lt; '\n'
    &lt;&lt; "All " &lt;&lt; alien &lt;&lt; " are welcome here\n"
    &lt;&lt; "π is " &lt;&lt; df_pi &lt;&lt; '\n';</pre></li>
			</ul>
			<p>We get this output:</p>
			<pre><strong class="bold">a is 47</strong>
<strong class="bold">hello, earthlings</strong>
<strong class="bold">All vulcans are welcome here</strong>
<strong class="bold">π is 3.14159</strong></pre>
			<ul>
				<li>Now, let's look at each of these with <code>format()</code>, starting with the C-string, <code>human</code>:<pre>cout &lt;&lt; format("Hello {}\n", human);</pre></li>
			</ul>
			<p>This is the simplest form <a id="_idIndexMarker591"/>of the <code>format()</code> function. The format <a id="_idIndexMarker592"/>string has one placeholder <code>{}</code> and one corresponding variable, <code>human</code>. The output is:</p>
			<pre><strong class="bold">Hello earthlings</strong></pre>
			<ul>
				<li>The <code>format()</code> function returns a string, and we use <code>cout &lt;&lt;</code> to display the string.</li>
			</ul>
			<p>The original proposal for the <code>format()</code> library included a <code>print()</code> function, using the same parameters as <code>format()</code>. That would allow us to print our formatted strings in one step:</p>
			<pre>print("Hello {}\n", cstr);</pre>
			<p>Unfortunately, <code>print()</code> didn't make it into the C++20 standard, although it is expected to be included in C++23.</p>
			<p>We can provide the same functionality with a simple function, using <code>vformat()</code>:</p>
			<pre>template&lt;typename... Args&gt;
constexpr void print(const string_view str_fmt, 
                     Args&amp;&amp;... args) {
    fputs(<strong class="bold">std::vformat</strong>(str_fmt, 
          <strong class="bold">std::make_format_args</strong>(args...)).c_str(), 
          stdout);
}</pre>
			<p>This simple one-line function <a id="_idIndexMarker593"/>gives us a serviceable <code>print()</code> function. We <a id="_idIndexMarker594"/>can use it in place of the <code>cout &lt;&lt; format()</code> combination:</p>
			<pre>print("Hello {}\n", human);</pre>
			<p>Output:</p>
			<pre><strong class="bold">Hello earthlings</strong></pre>
			<p>A more complete version of this function may be found in the <code>include</code> directory of the example files.</p>
			<ul>
				<li>The format string also provides positional options:<pre>print("Hello {} we are {}\n", human, alien);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">Hello earthlings we are vulcans</strong></pre>
			<p>We can change the order of the arguments by using positional options in the format string:</p>
			<pre>print("Hello {1} we are {0}\n", human, alien);</pre>
			<p>Now, we get this output:</p>
			<pre><strong class="bold">Hello vulcans we are earthlings</strong></pre>
			<p>Notice that the arguments remain the same. Only the positional values in the braces have changed. The positional indices are zero-based, just like the <code>[]</code> operator.</p>
			<p>This feature can be useful for internationalization, as different languages use different orders for parts of speech in a sentence.</p>
			<ul>
				<li>There are many formatting options for numbers:<pre>print("π is {}\n", df_pi);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">π is 3.141592653589793</strong></pre>
			<p>We can specify the number<a id="_idIndexMarker595"/> of digits of precision:</p>
			<pre>print("π is {:.5}\n", df_pi);</pre>
			<p>Output:</p>
			<pre><strong class="bold">π is 3.1416</strong></pre>
			<p>The colon character <code>:</code> is used to<a id="_idIndexMarker596"/> separate positional indices from formatting arguments:</p>
			<pre>print("inta is {1:}, π is {0:.5}\n", df_pi, inta);</pre>
			<p>Output:</p>
			<pre><strong class="bold">inta is 47, π is 3.1416</strong></pre>
			<ul>
				<li>If we want a value to take up a certain amount of space, we can specify the number of characters like this:<pre>print("inta is [{:10}]\n", inta);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">inta is [        47]</strong></pre>
			<p>We can align it left or right:</p>
			<pre>print("inta is [{:&lt;10}]\n", inta);
print("inta is [{:&gt;10}]\n", inta);</pre>
			<p>Output:</p>
			<pre><strong class="bold">inta is [47        ]</strong>
<strong class="bold">inta is [        47]</strong></pre>
			<p>By default, it fills with space characters, but we can change that:</p>
			<pre>print("inta is [{:*&lt;10}]\n", inta);
print("inta is [{:0&gt;10}]\n", inta);</pre>
			<p>Output:</p>
			<pre><strong class="bold">inta is [47********]</strong>
<strong class="bold">inta is [0000000047]</strong></pre>
			<p>We can also center a value:</p>
			<pre>print("inta is [{:^10}]\n", inta);
print("inta is [{:_^10}]\n", inta);</pre>
			<p>Output:</p>
			<pre><strong class="bold">inta is [    47    ]</strong>
<strong class="bold">inta is [____47____]</strong></pre>
			<ul>
				<li>We can format integer numbers <a id="_idIndexMarker597"/>as hexadecimal, octal, or the default <a id="_idIndexMarker598"/>decimal representation:<pre>print("{:&gt;8}: [{:04x}]\n", "Hex", inta);
print("{:&gt;8}: [{:4o}]\n", "Octal", inta);
print("{:&gt;8}: [{:4d}]\n", "Decimal", inta);</pre></li>
			</ul>
			<p>Output:</p>
			<pre>     <strong class="bold">Hex: [002f]</strong>
<strong class="bold">   Octal: [  57]</strong>
<strong class="bold"> Decimal: [  47]</strong></pre>
			<p>Notice that I used right alignment to line up the labels.</p>
			<p>Use a capital <code>X</code> for uppercase hexadecimal:</p>
			<pre>print("{:&gt;8}: [{:04X}]\n", "Hex", inta);</pre>
			<p>Output:</p>
			<pre>     <strong class="bold">Hex: [002F]</strong></pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">By default, Windows uses uncommon character encodings. Recent versions may default to UTF-16 or UTF-8 BOM. Older versions may default to "code page" 1252, a superset of the ISO 8859-1 ASCII standard. No Windows system defaults to the more common UTF-8 (no BOM).</p>
			<p class="callout">By default, Windows will not display the standard UTF-8 <code>π</code> character. To make Windows compatible with UTF-8 encoding (and the rest of the world), use the compiler switch <code>/utf-8</code> and issue the command <code>chcp 65001</code> on the command line when testing. Now, you can have your <code>π</code> and eat it too.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor228"/>How it works…</h2>
			<p>The <code>&lt;format&gt;</code> library uses a<a id="_idIndexMarker599"/> template <em class="italic">parameter pack</em> to pass arguments to the formatter. This allows the arguments to be individually inspected for<a id="_idIndexMarker600"/> class and type. The library function, <code>make_format_args()</code> takes a parameter pack and returns a <code>format_args</code> object, which provides a <em class="italic">type erased</em> list of arguments to be formatted.</p>
			<p>We can see this in action in our <code>print()</code> function:</p>
			<pre>template&lt;typename... Args&gt;
constexpr void print(const string_view str_fmt, Args&amp;&amp;... args) {
    fputs(<strong class="bold">vformat</strong>(str_fmt, 
      <strong class="bold">make_format_args(args...)</strong>).c_str(), 
          stdout);
}</pre>
			<p>The <code>make_format_args()</code> function takes a <a id="_idIndexMarker601"/>parameter pack and returns a <code>format_args</code> object. The <code>vformat()</code> function takes a format string and the <code>format_args</code> object, and returns a <code>std::string</code>. We use the <code>c_str()</code> method to <a id="_idIndexMarker602"/>get a C-string for use with <code>fputs()</code>.</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor229"/>There's more…</h2>
			<p>It's common practice to overload<a id="_idIndexMarker603"/> the <code>ostream</code> <code>&lt;&lt;</code> operator for custom classes. For example, given a class <code>Frac</code> that holds the values of a fraction:</p>
			<pre>template&lt;typename T&gt;
struct Frac {
    T n;
    T d;
};
...
Frac&lt;long&gt; n{ 3, 5 };
cout &lt;&lt; "Frac: " &lt;&lt; n &lt;&lt; '\n';</pre>
			<p>We want to print the object as a fraction like <code>3/5</code>. So, we would write a simple <code>operator&lt;&lt;</code> specialization like this:</p>
			<pre>template &lt;typename T&gt;
std::ostream&amp; <strong class="bold">operator&lt;&lt;</strong>(std::ostream&amp; os, const <strong class="bold">Frac&lt;T&gt;</strong>&amp; f) {
    <strong class="bold">os &lt;&lt; f.n &lt;&lt; '/' &lt;&lt; f.d</strong>;
    return os;
}</pre>
			<p>Now our output is:</p>
			<pre>Frac: 3/5</pre>
			<p>To provide <code>format()</code> support for our custom class, we need to create a <code>formatter</code> object specialization, like this:</p>
			<pre>template &lt;typename T&gt;
struct <strong class="bold">std::formatter&lt;Frac&lt;T&gt;&gt;</strong> : <strong class="bold">std::formatter&lt;unsigned&gt;</strong> {
    template &lt;typename Context&gt;
    auto <strong class="bold">format</strong>(const <strong class="bold">Frac&lt;T&gt;</strong>&amp; f, Context&amp; ctx) const {
        return format_to(ctx.out(), <strong class="bold">"{}/{}"</strong>, <strong class="bold">f.n</strong>, <strong class="bold">f.d</strong>);
    }
};</pre>
			<p>The specialization<a id="_idIndexMarker604"/> of the <code>std::formatter</code> class overloads its <code>format()</code> method. We inherit from the <code>formatter&lt;unsigned&gt;</code> specialization for simplicity. The <code>format()</code> method is called with a <code>Context</code> object, which provides the output context for the formatted string. For the return value, we use the <code>format_to()</code> function with <code>ctx.out</code>, a normal format string, and parameters.</p>
			<p>Now, we can now use our <code>print()</code> function with the <code>Frac</code> class:</p>
			<pre>print("Frac: {}\n", <strong class="bold">n</strong>);</pre>
			<p>The formatter now recognizes our class and provides our desired output:</p>
			<pre>Frac: 3/5</pre>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor230"/>Trim whitespace from strings</h1>
			<p>It is common for input from <a id="_idIndexMarker605"/>users to include extraneous whitespace at one <a id="_idIndexMarker606"/>or both ends of a string. This can be problematic, so we often need to remove it. In this recipe, we'll use the <code>string</code> class methods, <code>find_first_not_of()</code> and <code>find_last_not_of()</code>, to trim whitespace from the ends of a string.</p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor231"/>How to do it…</h2>
			<p>The <code>string</code> class includes methods for finding elements that are, or are not, included in a list of characters. We'll use these methods to trim <code>string</code>:</p>
			<ul>
				<li>We start by defining <code>string</code> with input from a hypothetical ten-thumbed user:<pre>int main() {
    string s{" \t  ten-thumbed input   \t   \n \t "};
    cout &lt;&lt; format("[{}]\n", s);
    ...</pre></li>
			</ul>
			<p>Our input has a few<a id="_idIndexMarker607"/> extra tab <code>\t</code> and newline <code>\n</code> characters before <a id="_idIndexMarker608"/>and after the content. We print it with surrounding brackets to show the whitespace:</p>
			<pre>[       ten-thumbed input
      ]</pre>
			<ul>
				<li>Here's a <code>trimstr()</code> function to remove all the whitespace characters from both ends of <code>string</code>:<pre>string <strong class="bold">trimstr</strong>(const string&amp; s) {
    constexpr const char * whitespace{ <strong class="bold">" \t\r\n\v\f"</strong> };
    if(<strong class="bold">s.empty()</strong>) return s;
    const auto first{ <strong class="bold">s.find_first_not_of(whitespace)</strong> };
    if(<strong class="bold">first == string::npos</strong>) return {};
    const auto last{ <strong class="bold">s.find_last_not_of(whitespace)</strong> };
    return s.<strong class="bold">substr</strong>(first, (last - first + 1));
}</pre></li>
			</ul>
			<p>We defined our set of whitespace characters as <em class="italic">space</em>, <em class="italic">tab</em>, <em class="italic">return</em>, <em class="italic">newline</em>, <em class="italic">vertical tab</em>, and <em class="italic">form feed</em>. Some of these are more common than others, but that's the canonical set.</p>
			<p>This function uses the <code>find_first_not_of()</code> and <code>find_last_not_of()</code> methods of the <code>string</code> class to find the first/last elements that are <em class="italic">not</em> a member of the set.</p>
			<ul>
				<li>Now, we can call the <a id="_idIndexMarker609"/>function to get rid of all that unsolicited<a id="_idIndexMarker610"/> whitespace:<pre>cout &lt;&lt; format("[{}]\n", trimstr(s));</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">[ten-thumbed input]</strong></pre>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor232"/>How it works…</h2>
			<p>The <code>string</code> class's various <code>find...()</code> member functions return a position as a <code>size_t</code> value:</p>
			<pre>size_t find_first_not_of( const CharT* s, size_type pos = 0 );
size_t find_last_not_of( const CharT* s, size_type pos = 0 );</pre>
			<p>The return value is the zero-based position of the first matching character (<em class="italic">not</em> in the <code>s</code> list of characters) or the special value, <code>string::npos</code>, if not found. <code>npos</code> is a static member constant that represents an invalid position.</p>
			<p>We test for <code>(first == string::npos)</code> and return an empty string <code>{}</code> if there is no match. Otherwise, we use the <code>first</code> and <code>last</code> positions with the <code>s.substr()</code> method to return the string without whitespace.</p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor233"/>Read strings from user input</h1>
			<p>The STL provides<a id="_idIndexMarker611"/> character-based input from<a id="_idIndexMarker612"/> the standard input stream using the <code>std::cin</code> object. The <code>cin</code> object is a global <em class="italic">singleton</em> that reads input from the console as an <code>istream</code> input stream.</p>
			<p>By default, <code>cin</code> reads <em class="italic">one word at a time</em> until it reaches the end of the stream:</p>
			<pre>string word{};
cout &lt;&lt; "Enter words: ";
while(cin &gt;&gt; word) {
    cout &lt;&lt; format("[{}] ", word);
}
cout &lt;&lt; '\n';</pre>
			<p>Output:</p>
			<pre>$ ./working
Enter words: big light in sky<img src="img/1.png" alt=""/>
[big] [light] [in] [sky]</pre>
			<p>This is of limited <a id="_idIndexMarker613"/>usefulness, and it may lead some to dismiss <code>cin</code> as minimally<a id="_idIndexMarker614"/> functional.</p>
			<p>While <code>cin</code> certainly has its quirks, it can be easily wrangled into providing line-oriented input.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor234"/>How to do it…</h2>
			<p>To get basic line-oriented functionality from <code>cin</code>, there are two significant behaviors that need to be understood. One is the ability to get a line at a time, instead of a word at a time. The other is the ability to reset the stream after an error condition. Let's look at these in some detail:</p>
			<ul>
				<li>First, we need to prompt the user for input. Here's a simple <code>prompt</code> function:<pre>bool prompt(const string_view s, const string_view s2 = "") {
    if(s2.size()) cout &lt;&lt; format("{} ({}): ", s, s2);
    else cout &lt;&lt; format("{}: ", s);
    <strong class="bold">cout.flush()</strong>;
    return true;
}</pre></li>
			</ul>
			<p>The <code>cout.flush()</code> function call ensures that the output is displayed immediately. Sometimes, when<a id="_idIndexMarker615"/> the output doesn't include a<a id="_idIndexMarker616"/> newline, the output stream may not flush automatically.</p>
			<ul>
				<li>The <code>cin</code> class has a <code>getline()</code> method that gets a line of text from the input stream and puts it in <a id="_idIndexMarker617"/>a C-string array:<pre>constexpr size_t <strong class="bold">MAXLINE{1024 * 10}</strong>;
char <strong class="bold">s</strong>[<strong class="bold">MAXLINE</strong>]{};
const char * p1{ "Words here" };
prompt(p1);
cin.getline(<strong class="bold">s</strong>, <strong class="bold">MAXLINE</strong>, <strong class="bold">'\n'</strong>);
cout &lt;&lt; s &lt;&lt; '\n';</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">Words here: big light in sky</strong><strong class="bold"><img src="img/1.png" alt=""/></strong>
<strong class="bold">big light in sky</strong></pre>
			<p>The <code>cin.getline()</code> method takes three arguments:</p>
			<pre>getline(char* s, size_t count, char delim );</pre>
			<p>The first argument is a C-string array for the destination. The second is the size of the array. The third is the delimiter for the end of the line. </p>
			<p>The function will not put more than <code>count</code>-1 characters in the array, leaving room for a <em class="italic">null</em> terminator.</p>
			<p>The delimiter defaults to the newline <code>'\n'</code> character.</p>
			<ul>
				<li>The STL also provides a stand-alone <code>getline()</code> function that works with an STL <code>string</code> object:<pre>string line{};
const char * p1a{ "More words here" };
prompt(p1a, "p1a");
getline(cin, line, '\n');
cout &lt;&lt; line &lt;&lt; '\n';</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">$ ./working</strong>
<strong class="bold">More words here (p1a): slated to appear in east</strong><strong class="bold"><img src="img/1.png" alt=""/></strong>
<strong class="bold">slated to appear in east</strong></pre>
			<p>The stand-alone <code>std::getline()</code> function takes three arguments:</p>
			<pre>getline(basic_istream&amp;&amp; in, string&amp; str, char delim );</pre>
			<p>The first argument is the output stream, second is a reference to a <code>string</code> object, and the third is the end-of-line delimiter.</p>
			<p>If not specified, the delimiter defaults to the newline <code>'\n'</code> character.</p>
			<p>I find the standalone <code>getline()</code> more convenient than the <code>cin.getline()</code> method.</p>
			<ul>
				<li>We can use <code>cin</code> to get a <a id="_idIndexMarker618"/>specific type from the input stream. To do<a id="_idIndexMarker619"/> this, we must be able to handle an error condition.</li>
			</ul>
			<p>When <code>cin</code> encounters an error, it sets the stream to an error condition and stops accepting input. To retry input after an error, we must reset the state of the stream. Here's a function that resets the input stream after an error:</p>
			<pre>void clearistream() {
    string s{};
    cin.clear();
    getline(cin, s);
}</pre>
			<p>The <code>cin.clear()</code> function<a id="_idIndexMarker620"/> resets the error flags on the input stream<a id="_idIndexMarker621"/> but leaves text in the buffer. We then clear the buffer by reading a line and discarding it.</p>
			<ul>
				<li>We can accept numeric input by using <code>cin</code> with numeric type variables:<pre>double a{};
double b{};
const char * p2{ "Please enter two numbers" };
for(prompt(p2); <strong class="bold">!(cin &gt;&gt; a &gt;&gt; b)</strong>; prompt(p2)) {
    cout &lt;&lt; "not numeric\n";
    <strong class="bold">clearistream();</strong>
}
cout &lt;&lt; format("You entered {} and {}\n", a, b);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">$ ./working</strong>
<strong class="bold">Please enter two numbers: a b</strong><strong class="bold"><img src="img/1.png" alt=""/></strong>
<strong class="bold">not numeric</strong>
<strong class="bold">Please enter two numbers: 47 73</strong><strong class="bold"><img src="img/1.png" alt=""/></strong>
<strong class="bold">You entered 47 and 73</strong></pre>
			<p>The <code>cin &gt;&gt; a &gt;&gt; b</code> expression accepts input from the console and attempts to convert the first two words to types compatible with <code>a</code> and <code>b</code> (<code>double</code>). If it fails, we call <code>clearistream()</code> and try again.</p>
			<ul>
				<li>We can use the <code>getline()</code> separator <a id="_idIndexMarker622"/>parameter to get comma-separated input:<pre>line.clear();
prompt(p3);
<strong class="bold">while(line.empty()) getline(cin, line);</strong>
<strong class="bold">stringstream ss(line);</strong>
while(<strong class="bold">getline(ss, word, ',')</strong>) {
    if(word.empty()) continue;
    cout &lt;&lt; format("word: [{}]\n", <strong class="bold">trimstr(word)</strong>);
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">$ ./working</strong>
<strong class="bold">Comma-separated words: this, that, other</strong>
<strong class="bold">word: [this]</strong>
<strong class="bold">word: [that]</strong>
<strong class="bold">word: [other]</strong></pre>
			<p>Because this code runs after the numbers code, and because <code>cin</code> is messy, there may still be a line ending in<a id="_idIndexMarker623"/> the buffer. The <code>while(line.empty())</code> loop will optionally eat any empty lines.</p>
			<p>We use a <code>stringstream</code> object to process the words, so we don't have to do it with <code>cin</code>. This allows us to use <code>getline()</code> to get one line without waiting for the end-of-file state.</p>
			<p>Then, we call <code>getline()</code> on the <code>stringstream</code> object to parse out words separated by commas. This gives us words but with leading whitespace. We use the <code>trimstr()</code> function from the <em class="italic">Trim whitespace from strings</em> recipe in this chapter to trim the whitespace.</p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor235"/>How it works…</h2>
			<p>The <code>std::cin</code> object is more useful than<a id="_idIndexMarker624"/> it may appear, but it can be a challenge to use. It tends to leave line endings on the stream, and in the case of errors, it can end up<a id="_idIndexMarker625"/> ignoring input.</p>
			<p>The solution is to use <code>getline()</code> and, when necessary, put the line into a <code>stringstream</code> for convenient parsing.</p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor236"/>Count words in a file</h1>
			<p>By default, the <code>basic_istream</code> class reads <a id="_idIndexMarker626"/>one word at a time. We can take advantage of this <a id="_idIndexMarker627"/>property to use an <code>istream_iterator</code> to count words.</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor237"/>How to do it…</h2>
			<p>This is a simple recipe to count words using an <code>istream_iterator</code>:</p>
			<ul>
				<li>We'll start with a simple function to count words using an <code>istream_iterator</code> object:<pre>size_t wordcount(auto&amp; is) {
    using it_t = <strong class="bold">istream_iterator</strong>&lt;string&gt;;
    return <strong class="bold">distance</strong>(it_t{is}, it_t{});
}</pre></li>
			</ul>
			<p>The <code>distance()</code> function takes two iterators and returns the number of steps between them. The <code>using</code> statement creates an alias <code>it_t</code> for the <code>istream_iterator</code> class with a <code>string</code> specialization. We then call <code>distance()</code> with an iterator, initialized with the input stream <code>it_t{is}</code>, and another with the default constructor, which gives us an end-of-stream sentinel.</p>
			<ul>
				<li>We call <code>wordcount()</code> from <code>main()</code>:<pre>int main() {
    const char * fn{ "the-raven.txt" };
    std::ifstream infile{fn, std::ios_base::in};
    size_t wc{ <strong class="bold">wordcount(infile)</strong> };
    cout &lt;&lt; format("There are {} words in the 
      file.\n", wc);
}</pre></li>
			</ul>
			<p>This calls <code>wordcount()</code> with our <code>fstream</code> object and prints the number of words in the file. When I call it with<a id="_idIndexMarker628"/> the text of Edgar Allan Poe's <em class="italic">The Raven</em>, we get this <a id="_idIndexMarker629"/>output:</p>
			<pre><strong class="bold">There are 1068 words in the file.</strong></pre>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor238"/>How it works…</h2>
			<p>Because <code>basic_istream</code> defaults to word-by-word input, the number of steps in a file will be the number of words. The <code>distance()</code> function will measure the number of steps between two iterators, so calling it with the beginning and the sentinel of a compatible object will count the number of words in the file.</p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor239"/>Initialize complex structures from file input</h1>
			<p>One strength of the <em class="italic">input stream</em> is its ability to parse <a id="_idIndexMarker630"/>different types of data <a id="_idIndexMarker631"/>from a text file and convert them to their corresponding fundamental types. Here's a simple technique for importing data into a container of structures using an input stream.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor240"/>How to do it…</h2>
			<p>In this recipe, we'll take a data file and import its disparate fields into a <code>vector</code> of <code>struct</code> objects. The data file<a id="_idIndexMarker632"/> represents cities with their populations and map coordinates:</p>
			<ul>
				<li>This is <code>cities.txt</code>, the data file we'll read:<pre>Las Vegas
661903 36.1699 -115.1398
New York City
8850000 40.7128 -74.0060
Berlin
3571000 52.5200 13.4050
Mexico City
21900000 19.4326 -99.1332
Sydney
5312000 -33.8688 151.2093</pre></li>
			</ul>
			<p>The city name is on a line by itself. The second line is population, followed by longitude and latitude. This<a id="_idIndexMarker633"/> pattern repeats for each of the five cities.</p>
			<ul>
				<li>We'll define our filename in a constant so that we can open it later:<pre>constexpr const char * fn{ "cities.txt" };</pre></li>
				<li>Here's a <code>City</code> struct to hold the data:<pre>struct City {
    string name;
    unsigned long population;
    double latitude;
    double longitude;
};</pre></li>
				<li>We would like to read the file and populate a <code>vector</code> of <code>City</code> objects:<pre>vector&lt;City&gt; cities;</pre></li>
				<li>Here's where the input stream makes this easy. We can simply specialize <code>operator&gt;&gt;</code> for our <code>City</code> class like this:<pre>std::istream&amp; operator&gt;&gt;(std::istream&amp; in, <strong class="bold">City&amp; c</strong>) {
    in &gt;&gt; <strong class="bold">std::ws</strong>;
    <strong class="bold">std::getline(in, c.name);</strong>
    <strong class="bold">in &gt;&gt; c.population &gt;&gt; c.latitude &gt;&gt; c.longitude;</strong>
    return in;
}</pre></li>
			</ul>
			<p>The <code>std::ws</code> input manipulator discards<a id="_idIndexMarker634"/> leading whitespace from the input stream.</p>
			<p>We use <code>getline()</code> to read the city name, as it could be one or more words.</p>
			<p>This leverages the <code>&gt;&gt;</code> operator <a id="_idIndexMarker635"/>for the <code>population</code> (<code>unsigned long</code>), and <code>latitude</code> and <code>longitude</code> (both <code>double</code>) elements to populate the correct type.</p>
			<ul>
				<li>Now, we can open the file and use the <code>&gt;&gt;</code> operator to read the file directly into the <code>vector</code> of <code>City</code> objects:<pre>ifstream infile(fn, std::ios_base::in);
if(!infile.is_open()) {
    cout &lt;&lt; format("failed to open file {}\n", fn);
    return 1;
}
for(City c{}; infile &gt;&gt; c;) cities.emplace_back(c);</pre></li>
				<li>We can display the vector<a id="_idIndexMarker636"/> using <code>format()</code>:<pre>for (const auto&amp; [name, pop, lat, lon] : cities) {
    cout &lt;&lt; format("{:.&lt;15} pop {:&lt;10} coords {}, {}\n", 
        name, make_commas(pop), lat, lon);
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">$ ./initialize_container &lt; cities.txt</strong>
<strong class="bold">Las Vegas...... pop 661,903    coords 36.1699, -115.1398</strong>
<strong class="bold">New York City.. pop 8,850,000  coords 40.7128, -74.006</strong>
<strong class="bold">Berlin......... pop 3,571,000  coords 52.52, 13.405</strong>
<strong class="bold">Mexico City.... pop 21,900,000 coords 19.4326, -99.1332</strong>
<strong class="bold">Sydney......... pop 5,312,000  coords -33.8688, 151.2093</strong></pre>
			<ul>
				<li>The <code>make_commas()</code> function was also used in the <em class="italic">Use structured binding to return multiple values</em> recipe in <a href="B18267_02_ePub.xhtml#_idTextAnchor057"><em class="italic">Chapter 2</em></a>, <em class="italic">General STL Features</em>. It takes a numeric value and<a id="_idIndexMarker637"/> returns a <code>string</code> object, with commas added for readability:<pre>string make_commas(const unsigned long num) {
    string s{ std::to_string(num) };
    for(int l = s.length() - 3; l &gt; 0; l -= 3) {
        s.insert(l, ",");
    }
    return s;
}</pre></li>
			</ul>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor241"/>How it works…</h2>
			<p>The heart of this<a id="_idIndexMarker638"/> recipe is the <code>istream</code> class <code>operator&gt;&gt;</code> overload:</p>
			<pre>std::istream&amp; <strong class="bold">operator&gt;&gt;</strong>(std::istream&amp; in, <strong class="bold">City&amp; c</strong>) {
    in &gt;&gt; std::ws;
    std::getline(in, c.name);
    in &gt;&gt; c.population &gt;&gt; c.latitude &gt;&gt; c.longitude;
    return in;
}</pre>
			<p>By specifying our <code>City</code> class in the function header, this function will be called every time a <code>City</code> object appears on the right-hand side of an input stream <code>&gt;&gt;</code> operator:</p>
			<pre>City c{};
infile &gt;&gt; c;</pre>
			<p>This allows us to specify exactly how the<a id="_idIndexMarker639"/> input stream reads data into a <code>City</code> object.</p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor242"/>There's more…</h2>
			<p>When you run this code on a Windows system, you'll notice that the first word of the first line gets corrupted. That's because Windows <a id="_idIndexMarker640"/>always includes a <strong class="bold">Byte Order Mark</strong> (<strong class="bold">BOM</strong>) at the head of any UTF-8 file. So, when you read a file on Windows, the BOM will be included in the first object you read. The BOM is anachronistic, but at the time of writing, there is no way to stop Windows from employing it.</p>
			<p>The solution is to call a function that checks the first three bytes of a file for the BOM. The BOM for UTF-8 is <code>EF BB BF</code>. Here's a function that searches for, and skips, a UTF-8 BOM:</p>
			<pre>// skip BOM for UTF-8 on Windows
void skip_bom(auto&amp; <strong class="bold">fs</strong>) {
    const unsigned char boms[]{ <strong class="bold">0xef</strong>, <strong class="bold">0xbb</strong>, <strong class="bold">0xbf</strong> };
    bool have_bom{ true };
    for(const auto&amp; c : boms) {
        if((unsigned char)fs.get() != c) have_bom = false; 
    }
    if(!have_bom) <strong class="bold">fs.seekg(0)</strong>;
    return;
}</pre>
			<p>This reads the first three bytes of the file and<a id="_idIndexMarker641"/> checks them for the UTF-8 BOM signature. If any of the three bytes do not match, it resets the input stream to the beginning of the file. If the file has no BOM, there's no harm done.</p>
			<p>You simply call this function before you begin reading from a file:</p>
			<pre>int main() {
    ...
    ifstream infile(fn, std::ios_base::in);
    if(!infile.is_open()) {
        cout &lt;&lt; format("failed to open file {}\n", fn);
        return 1;
    }
    <strong class="bold">skip_bom(infile);</strong>
    for(City c{}; infile &gt;&gt; c;) cities.emplace_back(c);
    ...
}</pre>
			<p>This will ensure that the BOM is not included in the first string of the file.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Because the <code>cin</code> input stream is not seekable, the <code>skip_bom()</code> function will not work on the <code>cin</code> stream. It will only work with a seekable text file.</p>
			<h1 id="_idParaDest-244"><a id="_idTextAnchor243"/>Customize a string class with char_traits</h1>
			<p>The <code>string</code> class is an <a id="_idIndexMarker642"/>alias of the <code>basic_string</code> class, with the <a id="_idIndexMarker643"/>signature:</p>
			<pre>class basic_string&lt;char, std::char_traits&lt;char&gt;&gt;;</pre>
			<p>The first template parameter provides the type of character. The second template parameter provides a character traits class, which provides basic character and string operations for the specified character type. We normally use the default <code>char_traits&lt;char&gt;</code> class.</p>
			<p>We can modify the behavior of a string by providing our own custom character traits class.</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor244"/>How to do it…</h2>
			<p>In this recipe, we will create a <em class="italic">character traits class</em> for use with <code>basic_string</code> that will ignore casing for comparison purposes:</p>
			<ul>
				<li>First, we'll need a function to convert characters to a common case. We'll use lowercase here, but it's an arbitrary choice. Uppercase would work just as well:<pre>constexpr char char_lower(const char&amp; c) {
    if(c &gt;= 'A' &amp;&amp; c &lt;= 'Z') return c + ('a' - 'A');
    else return c;
}</pre></li>
			</ul>
			<p>This function must be <code>constexpr</code> (for C++20 and later), so the existing <code>std::tolower()</code> function won't work here. Fortunately, it's a simple solution to a simple problem.</p>
			<ul>
				<li>Our traits class is called <code>ci_traits</code> (<em class="italic">ci</em> stands for case-independent). It inherits from <code>std::char_traits&lt;char&gt;</code>:<pre>class ci_traits : public std::char_traits&lt;char&gt; {
public:
    ...
};</pre></li>
			</ul>
			<p>The inheritance allows us to override only the functions that we need.</p>
			<ul>
				<li>The comparison functions<a id="_idIndexMarker644"/> are called <code>lt()</code> for less than <a id="_idIndexMarker645"/>and <code>eq()</code> for equal to:<pre>static constexpr bool lt(char_type a, char_type b) noexcept {
    return <strong class="bold">char_lower(a)</strong> &lt; <strong class="bold">char_lower(b)</strong>;
}
static constexpr bool eq(char_type a, char_type b) noexcept {
    return <strong class="bold">char_lower(a)</strong> == <strong class="bold">char_lower(b)</strong>;
}</pre></li>
			</ul>
			<p>Notice that we compare the <em class="italic">lowercase</em> versions of characters.</p>
			<ul>
				<li>There's also a <code>compare()</code> function, which compares two C-strings. It returns <code>+1</code> for greater than, <code>-1</code> for less than, and <code>0</code> for equal to. We can use the spaceship <code>&lt;=&gt;</code> operator for this:<pre>static constexpr int compare(const char_type* s1, 
        const char_type* s2, size_t count) {
    for(size_t i{0}; i &lt; count; ++i) {
        auto diff{ <strong class="bold">char_lower(s1[i]) &lt;=&gt; </strong>
<strong class="bold">          char_lower(s2[i])</strong> };
        if(diff &gt; 0) return 1;
        if(diff &lt; 0) return -1;
        }
    return 0;
}</pre></li>
				<li>Finally, we need to <a id="_idIndexMarker646"/>implement a <code>find()</code> function. This returns a pointer to the first instance of a found <a id="_idIndexMarker647"/>character, or <code>nullptr</code> if not found:<pre>static constexpr const char_type* find(const char_type* p, 
        size_t count, const char_type&amp; ch) {
    const char_type find_c{ char_lower(ch) };
    for(size_t i{0}; i &lt; count; ++i) {
        if(find_c == char_lower(p[i])) <strong class="bold">return p + i</strong>;
    }
    return <strong class="bold">nullptr</strong>;
}</pre></li>
				<li>Now that we have a <code>ci_traits</code> class, we can define an alias for our <code>string</code> class:<pre>using ci_string = std::basic_string&lt;char, ci_traits&gt;;</pre></li>
				<li>In our <code>main()</code> function, we define a <code>string</code> and a <code>ci_string</code>:<pre>int main() {
    string s{"Foo Bar Baz"};
    ci_string ci_s{"Foo Bar Baz"};
    ...</pre></li>
				<li>We want to print them using <code>cout</code>, but this won't work:<pre>cout &lt;&lt; "string: " &lt;&lt; s &lt;&lt; '\n';
cout &lt;&lt; "ci_string: " &lt;&lt; ci_s &lt;&lt; '\n';</pre></li>
			</ul>
			<p>First, we need an operator overload for the <code>operator&lt;&lt;</code>:</p>
			<pre>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, 
        const ci_string&amp; str) {
    return os &lt;&lt; str.c_str();
}</pre>
			<p>Now, we get this<a id="_idIndexMarker648"/> output:</p>
			<pre>string: Foo Bar Baz
ci_string: Foo Bar Baz</pre>
			<ul>
				<li>Let's compare two <code>ci_string</code> objects<a id="_idIndexMarker649"/> with different cases:<pre>ci_string compare1{"CoMpArE StRiNg"};
ci_string compare2{"compare string"};
if (compare1 == compare2) {
    cout &lt;&lt; format("Match! {} == {}\n", compare1, 
      compare2);
} else {
    cout &lt;&lt; format("no match {} != {}\n", compare1, 
      compare2);
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">Match! CoMpArE StRiNg == compare string</strong></pre>
			<p>The comparison works as expected.</p>
			<ul>
				<li>Using the <code>find()</code> function on the <code>ci_s</code> object, we<a id="_idIndexMarker650"/> search for <a id="_idIndexMarker651"/>a lowercase <code>b</code> and find an uppercase <code>B</code>:<pre>size_t found = ci_s.find('b');
cout &lt;&lt; format("found: pos {} char {}\n", found, ci_s[found]);</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">found: pos 4 char B</strong></pre>
			<p class="callout-heading">Note</p>
			<p class="callout">Notice that the <code>format()</code> function doesn't require a specialization. This was tested with the <code>fmt.dev</code> reference implementation. It did not work with the preview release of MSVC's <code>format()</code>, even with a specialization. Hopefully, this will be fixed in a future release.</p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor245"/>How it works…</h2>
			<p>This recipe works by replacing the <code>std::char_traits</code> class in the template specialization of the <code>string</code> class with a <code>ci_traits</code> class of our own. The <code>basic_string</code> class uses the traits class for its fundamental character-specific functions, such as comparisons and searching. When we replace it with our own class, we can change these fundamental behaviors.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor246"/>There's more…</h2>
			<p>We can also override the <code>assign()</code> and <code>copy()</code> member<a id="_idIndexMarker652"/> functions to create a class that stores <a id="_idIndexMarker653"/>lowercase characters:</p>
			<pre>class lc_traits : public std::char_traits&lt;char&gt; {
public:
    static constexpr void <strong class="bold">assign</strong>( char_type&amp; r, const
      char_type&amp; a )
            noexcept {
        r = char_lower(a);
    }
    static constexpr char_type* <strong class="bold">assign</strong>( char_type* p,
            std::size_t count, char_type a ) {
        for(size_t i{}; i &lt; count; ++i) p[i] = 
          char_lower(a);
        return p;
    }
    static constexpr char_type* <strong class="bold">copy</strong>(char_type* dest, 
            const char_type* src, size_t count) {
        for(size_t i{0}; i &lt; count; ++i) {
            dest[i] = char_lower(src[i]);
        }
        return dest;
    }
};</pre>
			<p>Now, we can create an <code>lc_string</code> alias, and the object <a id="_idIndexMarker654"/>stores lowercase<a id="_idIndexMarker655"/> characters:</p>
			<pre>using lc_string = std::basic_string&lt;char, lc_traits&gt;;
...
lc_string lc_s{"Foo Bar Baz"};
cout &lt;&lt; "lc_string: " &lt;&lt; lc_s &lt;&lt; '\n';</pre>
			<p>Output:</p>
			<pre>lc_string: foo bar baz</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">These techniques work as expected on GCC and Clang but not on the preview release of MSVC. I expect that this will be fixed in a future release.</p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor247"/>Parse strings with Regular Expressions</h1>
			<p><em class="italic">Regular Expressions</em> (commonly<a id="_idIndexMarker656"/> abbreviated as <em class="italic">regex</em>) are commonly used for lexical analysis and pattern-matching on streams of text. They are common in Unix text-processing utilities, such as <code>grep</code>, <code>awk</code>, and <code>sed</code>, and are an integral <a id="_idIndexMarker657"/>part of the <em class="italic">Perl</em> language. There are a few common variations in the syntax. A POSIX standard was approved in 1992, while other common variations include <em class="italic">Perl</em> and <em class="italic">ECMAScript</em> (JavaScript) dialects. The C++ <code>regex</code> library defaults to the ECMAScript dialect.</p>
			<p>The <code>regex</code> library was first introduced to the STL with C++11. It can be very useful for finding patterns in text files.</p>
			<p>To learn more about Regular Expression syntax and usage, I recommend the book, <em class="italic">Mastering Regular Expressions</em> by Jeffrey Friedl.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor248"/>How to do it…</h2>
			<p>For this recipe, we will extract hyperlinks from an HTML file. A hyperlink is coded in HTML like this:</p>
			<pre>&lt;a href="http://example.com/file.html"&gt;Text goes here&lt;/a&gt;</pre>
			<p>We will use a <code>regex</code> object to extract both the link and the text, as two separate strings.</p>
			<ul>
				<li>Our example file is called <code>the-end.html</code>. It's taken from my website (<a href="https://bw.org/end/">https://bw.org/end/</a>), and is included in the GitHub repository:<pre>const char * fn{ "the-end.html" };</pre></li>
				<li>Now, we define our <code>regex</code> object with a regular expression string:<pre>const std::regex 
    link_re{ "&lt;a href=\"([^\"]*)\"[^&lt;]*&gt;([^&lt;]*)&lt;/a&gt;" };</pre></li>
			</ul>
			<p>Regular expressions can look<a id="_idIndexMarker658"/> intimidating at first, but<a id="_idIndexMarker659"/> they're actually rather simple.</p>
			<p>This is parsed as follows:</p>
			<ol>
				<li>Match the whole string.</li>
				<li>Find the substring <code>&lt;a href="</code>.</li>
				<li>Store everything up to the next <code>"</code> as sub-match <code>1</code>.</li>
				<li>Skip past the <code>&gt;</code> character.</li>
				<li>Store everything up to the string <code>&lt;/a&gt;</code> as sub-match <code>2</code>.</li>
			</ol>
			<ul>
				<li>Now, we read our file entirely into a string:<pre>string in{};
std::ifstream <strong class="bold">infile</strong>(<strong class="bold">fn</strong>, std::ios_base::in);
for(string line{}; <strong class="bold">getline</strong>(infile, line);) <strong class="bold">in += line</strong>;</pre></li>
			</ul>
			<p>This opens the HTML file, reads it line by line, and appends each line to the <code>string</code> object, <code>in</code>.</p>
			<ul>
				<li>To extract the link strings, we set up an <code>sregex_token_iterator</code> object to step through the file and extract each of the matched elements:<pre>std::sregex_token_iterator it{ in.begin(), in.end(),
    link_re, {<strong class="bold">1</strong>, <strong class="bold">2</strong>} };</pre></li>
			</ul>
			<p>The <code>1</code> and <code>2</code> correspond to the sub-matches in the regular expression.</p>
			<ul>
				<li>We have a corresponding function to step through the results with the iterator:<pre>template&lt;typename It&gt;
void get_links(It <strong class="bold">it</strong>) {
    for(It end_it{}; <strong class="bold">it != end_it</strong>; ) {
        const string <strong class="bold">link{ *it++ }</strong>;
        if(it == end_it) break;
        const string <strong class="bold">desc{ *it++ }</strong>;
        <strong class="bold">cout &lt;&lt; format("{:.&lt;24} {}\n", desc, link);</strong>
    }
}</pre></li>
			</ul>
			<p>We call the function with<a id="_idIndexMarker660"/> the <code>regex</code> iterator:</p>
			<pre>get_links(it);</pre>
			<p>And we get this result with <a id="_idIndexMarker661"/>our descriptions and links:</p>
			<pre><strong class="bold">Bill Weinman............ https://bw.org/</strong>
<strong class="bold">courses................. https://bw.org/courses/</strong>
<strong class="bold">music................... https://bw.org/music/</strong>
<strong class="bold">books................... https://packt.com/</strong>
<strong class="bold">back to the internet.... https://duckduckgo.com/</strong></pre>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor249"/>How it works…</h2>
			<p>The STL <code>regex</code> engine operates as a <em class="italic">generator</em> that evaluates and yields one result at a time. We set up the iterator using <code>sregex_iterator</code> or <code>sregex_token_iterator</code>. While <code>sregex_token_iterator</code> supports sub-matches, <code>sregex_iterator</code> does not.</p>
			<p>The parentheses in our regex serve as <em class="italic">sub-matches</em>, numbered <code>1</code> and <code>2</code> respectively:</p>
			<pre>const regex link_re{ "&lt;a href=\"<strong class="bold">([^\"]*)</strong>\"[^&lt;]*&gt;<strong class="bold">([^&lt;]*)</strong>&lt;/a&gt;" };</pre>
			<p>Each part of the <code>regex</code> matches is illustrated here:</p>
			<div><div><img src="img/B18267_07_01.jpg" alt="Figure 7.1 – A Regular Expression with sub-matches&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – A Regular Expression with sub-matches</p>
			<p>This allows us to match a string and use <a id="_idIndexMarker662"/>parts of that string as our results:</p>
			<pre><strong class="bold">sregex_token_iterator</strong> it{ in.begin(), in.end(), <strong class="bold">link_re</strong>, {<strong class="bold">1</strong>, <strong class="bold">2</strong>} };</pre>
			<p>The sub-matches are numbered, beginning <a id="_idIndexMarker663"/>with <code>1</code>. Sub-match <code>0</code> is a special value that represents the entire match.</p>
			<p>Once we have our iterator, we use it as we would any other iterator:</p>
			<pre>for(It end_it{}; it != end_it; ) {
    const string link{ <strong class="bold">*it++</strong> };
    if(it == end_it) break;
    const string desc{ <strong class="bold">*it++</strong> };
    cout &lt;&lt; format("{:.&lt;24} {}\n", desc, link);
}</pre>
			<p>This simply steps through our<a id="_idIndexMarker664"/> results via the <code>regex</code> iterator, giving<a id="_idIndexMarker665"/> us the formatted output:</p>
			<pre>Bill Weinman............ https://bw.org/
courses................. https://bw.org/courses/
music................... https://bw.org/music/
books................... https://packt.com/
back to the internet.... https://duckduckgo.com/</pre>
		</div>
	</body></html>