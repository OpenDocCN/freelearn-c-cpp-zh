- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swap – from Simple to Subtle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We begin our exploration of basic C++ idioms with a very simple, even humble,
    operation—`std::swap`, to do just that. Rest assured that C++ manages to turn
    even something as basic as a swap into a complex issue with subtle nuances.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How is `swap` used by the standard C++ library?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the applications of swap?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we write exception-safe code using swap?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we implement swap for our own types correctly?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we correctly swap variables of an arbitrary type?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a link to all the example code of this chapter: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter04)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a link to the C++ Core Guidelines: [https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a link for the C++ **Guidelines Support Library** (**GSL**): [https://github.com/Microsoft/GSL](https://github.com/Microsoft/GSL)'
  prefs: []
  type: TYPE_NORMAL
- en: Swap and the standard template library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The swap operation is widely used in the C++ standard library. All `std::swap`.
    There are also uses of swap in STL algorithms. The standard library is also a
    template for implementing custom features that resemble standard ones.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we’ll begin our study of the swap operation with a look at the functionality
    provided by the standard.
  prefs: []
  type: TYPE_NORMAL
- en: Swap and STL containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conceptually, swap is equivalent to the following operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `swap()` is called, the contents of the `x` and `y` objects are swapped.
    This, however, is probably the worst possible way to actually implement swap.
    The first and most obvious problem with this implementation is that it copies
    both objects unnecessarily (it actually does three copy operations). The execution
    time of this operation is proportional to the size of the `T` type. For an STL
    container, the size would refer to the size of the actual container, not to the
    type of the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that this code compiles, and, in most cases, even does the right thing.
    However, it copies every element of the vector several times. The second problem
    is that it temporarily allocates resources—for example, during the swap, we create
    a third vector that uses as much memory as one of the vectors being swapped. This
    allocation seems unnecessary, given that, in the final state, we have exactly
    as much data as we started with; only the names we use to access this data have
    been changed. The last problem with naive implementation is revealed when we consider
    what happens if, for example, the memory allocation we just mentioned fails.
  prefs: []
  type: TYPE_NORMAL
- en: The entire swap operation, which should have been as simple and foolproof as
    exchanging the names used to access vector elements, instead fails with a memory
    allocation failure.
  prefs: []
  type: TYPE_NORMAL
- en: But that’s not the only way it can fail—the copy constructor and the assignment
    operator can both throw exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: All STL containers, including `std::vector`, provide a guarantee that they can
    be swapped in constant time. The way this is accomplished is rather straightforward
    if you consider that the STL container objects themselves contain only pointers
    to the data, plus some state, such as object size. To swap these containers, we
    need only to swap the pointers (and the rest of the state, of course)—the elements
    of the container remain exactly where they always were, in dynamically allocated
    memory, and do not need to be copied or even accessed. The implementation of the
    swap needs only to swap the pointers, the sizes, and other state variables (in
    a real STL implementation, a container class, such as a vector, does not directly
    consist of data members of built-in types, such as pointers, but has one or more
    class data members that, in turn, are made from pointers and other built-in types).
  prefs: []
  type: TYPE_NORMAL
- en: Since any pointers or other vector data members are not publicly accessible,
    the swap has to be implemented as a member function of the container, or be declared
    a friend. The STL takes the former approach—all STL containers have a `swap()`
    member function that swaps the object with another object of the same type (see
    examples `01a` and `01b`).
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of this by swapping pointers takes care, indirectly, of the
    two other problems we mentioned. First of all, because only the data members of
    the containers are swapped, there is no memory allocation. Secondly, copying pointers
    and other built-in types cannot throw an exception, and so the entire swap operation
    does not throw (and cannot otherwise fail).
  prefs: []
  type: TYPE_NORMAL
- en: The simple and consistent picture we have described so far is only mostly true.
    The first complication, and by far the simpler one, applies only to containers
    that are parameterized not just on the element type, but also on a callable object
    of some sort. For example, the `std::map` container accepts the optional comparison
    function for comparing the elements of the map, which, by default, is `std::less`.
    Such callable objects have to be stored with the container. Since they are invoked
    very often, it is highly desirable, for performance reasons, to keep them in the
    same memory allocation as the container object itself, and indeed they are made
    data members of the container class.
  prefs: []
  type: TYPE_NORMAL
- en: However, that optimization comes with a price—swapping two containers now requires
    exchanging the compare functions; that is, the actual objects, not the pointers
    to them. The comparison objects are implemented by the client of the library,
    so there is no guarantee that swapping them is possible, let alone that it will
    not throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, for `std::map`, the standard provides the following guarantee—in
    order for the map to be swappable, the callable objects must also be swappable.
    Furthermore, swapping two maps does not throw an exception, unless swapping comparison
    objects may throw, in which case, any exception thrown by that swap is propagated
    from the `std::map` swap.
  prefs: []
  type: TYPE_NORMAL
- en: This consideration does not apply to containers, such as `std::vector`, that
    do not use any callable objects, and swapping these containers still does not
    throw an exception (as far as we know up to now).
  prefs: []
  type: TYPE_NORMAL
- en: The other complication in the otherwise consistent and natural behavior of the
    swap is due to the allocators, and that is a hard one to resolve. Consider the
    problem—the two swapped containers must, necessarily, have allocators of the same
    type, but not necessarily the same allocator object. Each container has its elements
    allocated by its own allocator, and they must be deallocated by the same allocator.
    After the swap, the first container owns the elements from the second one and
    must eventually deallocate them. This can only be done (correctly) using the allocator
    of the first container; therefore, the allocators must also be exchanged.
  prefs: []
  type: TYPE_NORMAL
- en: C++ standards prior to `allocator_type` allocator class, there is a `trait`
    class that defines, among other things, the `std::allocator_traits<allocator_type>::propagate_on_container_swap::value`
    trait property, and if this value is `true`, then the allocators are exchanged
    using an unqualified call to a non-member swap; that is, simply a `swap(allocator1,
    allocator2)` call (see the next section to learn what that call actually does).
    If this value is not `true`, then the allocators are not swapped at all, and both
    container objects must use the same allocator. If that is not `true` either, then
    we are back to undefined behavior. `swap()` member functions of STL containers
    to be conditionally `noexcept()`, with the same limitations.
  prefs: []
  type: TYPE_NORMAL
- en: The requirement that swapping two containers cannot throw an exception, at least
    as long as the allocators are not involved and the container does not use callable
    objects or uses non-throwing ones, ends up imposing a rather subtle limitation
    on the implementation of the container—it prevents the use of local buffer optimization.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about this optimization in great detail in [*Chapter 10*](B19262_10.xhtml#_idTextAnchor453),
    *Local* *Buffer Optimization*, but in a nutshell, the idea is to avoid dynamic
    memory allocation for containers of very few elements, such as short strings,
    by defining a buffer inside the container class itself. This optimization, however,
    is generally incompatible with the notion of a non-throwing swap, since the elements
    inside the container object can no longer be exchanged by merely swapping pointers,
    but have to be copied between the containers.
  prefs: []
  type: TYPE_NORMAL
- en: Non-member swap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard also provides a template `std::swap()` function. Prior to C++11,
    it was declared in the `<algorithm>` header; in C++11, it was moved to `<utility>`.
    The declaration of the function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The overload for arrays was added in C++11\. In C++20, both versions are additionally
    declared `constexpr`. For STL containers, `std::swap()` calls the member function
    `swap()`. As we will see in the following section, the behavior of `swap()` can
    be customized for other types as well, but without any special efforts, the default
    implementation is used. This implementation does a swap using a temporary object.
    Before C++11, the temporary object was copy-constructed, and the swap was done
    with two assignments, just as we did in the preceding section. The type has to
    be copyable (both copy-constructible and copy-assignable), otherwise `std::swap()`
    will not compile (see examples `02a` and `02b`). In C++11, `std::swap()` has been
    redefined to use move construction and move assignment (see example `02c`). As
    usual, if the class is copyable, but does not have move operations declared at
    all, then the copy constructor and assignment are used. Note that if the class
    has copy operations declared and move operations declared as deleted, there is
    no automatic fallback to copying—that class is a non-movable type and `std::swap()`
    will not compile for it (see example `02d`).
  prefs: []
  type: TYPE_NORMAL
- en: Since copying an object can, in general, throw an exception, swapping two objects
    for which a custom swap behavior is not provided can throw an exception as well.
    Move operations do not usually throw exceptions, and in C++11, if the object has
    a move constructor and an assignment operator and neither throws an exception,
    `std::swap()` also provides a no-throw guarantee. That behavior has been formalized
    in C++17 with a conditional `noexcept()` specification.
  prefs: []
  type: TYPE_NORMAL
- en: Swapping like the standard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the preceding review of how the standard library handles a swap, we can
    deduce the following guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes that support swap should implement `swap()` member functions that perform
    the operation in constant time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A free-standing `swap()` non-member function should also be provided for all
    types that can be swapped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swapping two objects should not throw exceptions or otherwise fail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latter guideline is less strict, and it is not always possible to follow
    it. In general, if the type has move operations that do not throw an exception,
    a non-throwing swap implementation is also possible. Note also that many exception-safety
    guarantees, and in particular those provided by the standard library, require
    that move and swap operations do not throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: When and why to use swap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is so important about the swap functionality that it deserves its own chapter?
    For that matter, why even use swap, and not continue to refer to an object by
    its original name?
  prefs: []
  type: TYPE_NORMAL
- en: Mostly, it has to do with exception safety, which is also why we keep mentioning
    when swap can and cannot throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Swap and exception safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important application of swap in C++ has to do with writing exception-safe
    code, or, more generally, error-safe code. Here is the problem, in a nutshell—in
    an exception-safe program, throwing an exception should never leave the program
    in an undefined state.
  prefs: []
  type: TYPE_NORMAL
- en: More generally, an error condition should never leave the program in an undefined
    state. Note that the error does not need to be handled by means of an exception—for
    example, returning an error code from a function should also be handled without
    creating undefined behavior. In particular, if an operation causes an error, the
    resources already consumed by the operation in progress should be released. Often,
    an even stronger guarantee is desired—every operation either succeeds or is entirely
    rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider an example where we will apply a transform to all elements of
    a vector, and store the results in a new vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we return the vector via an output parameter. Let us assume that it is
    a requirement to use an already existing vector for output and we are not doing
    it for performance reasons. In all recent versions of C++, returning a vector
    by value is quite fast: the compiler will either apply the return-value optimization
    and elide the copy completely (copy elision is not guaranteed but likely) or replace
    copy by move (also fast, guaranteed). The vector is made empty at first, and grows
    to the same size as the input vector. Any data the `out` vector may have had is
    gone. Note the `reserve()` call that is used to avoid repeated deallocations of
    the growing vector.'
  prefs: []
  type: TYPE_NORMAL
- en: This code works fine as long as there are no errors, that is, no exceptions
    are thrown. But this is not guaranteed. First of all, `reserve()` does a memory
    allocation, which may fail. If this happens, the `transmogrify()` function will
    exit via the exception, and the output vector will be empty since the `resize(0)`
    call has already been executed. The initial content of the output vector is lost,
    and nothing is written to replace it. Secondly, any iteration of the loop over
    the elements of the vector may throw an exception. An exception could be thrown
    by the copy constructor of the new element of the output vector, or by the transformation
    itself. Either way, the loop is interrupted. STL guarantees that the output vector
    is not left in an undefined state even if the copy constructor inside the `push_back()`
    call fails—the new element is not *partially* created, and the vector size is
    not increased.
  prefs: []
  type: TYPE_NORMAL
- en: However, the elements already stored will remain in the output vector (and any
    elements that were there originally are gone). This may not be what we intended—it
    is not unreasonable to request that the `transmogrify()` operation either succeeds
    and applies the transform to the entire vector, or fails and changes nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to such exception-safe implementation is the swap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have changed the code to operate on a temporary vector during
    the entire transformation. Note that, in a typical case of an output vector that
    is empty on input, this does not increase the amount of memory in use. If the
    output vector has some data in it, both the new data and the old data exist in
    memory until the end of the function. This is necessary to provide a guarantee
    that the old data will not be deleted unless the new data can be fully computed.
    If desired, this guarantee can be traded for lower overall memory use, and the
    output vector can be emptied at the beginning of the function (on the other hand,
    any caller who wants to make such a trade-off can just empty the vector before
    calling `transmogrify()`).
  prefs: []
  type: TYPE_NORMAL
- en: If an exception is thrown at any time during the execution of the `transmogrify()`
    function, right up until the last line, then the temporary vector is deleted,
    as would be any local variable allocated on the stack (see [*Chapter 5*](B19262_05.xhtml#_idTextAnchor199),
    *A Comprehensive Look at RAII*, later in this book). The last line is the key
    to exception safety—it swaps the content of the output vector with that of the
    temporary one. If that line can throw an exception, then our entire work is for
    nothing—the swap has failed, and the output vector is left in an undefined state
    since we do not know how much of the swap had succeeded before the exception was
    thrown. But if the swap does not throw an exception, as in the case for `std::vector`,
    then, as long as the control reached the last line, the entire `transmogrify()`
    operation has succeeded, and the result will be returned to the caller. What happens
    to the old content of the output vector? It is now owned by the temporary vector,
    which is about to be deleted, implicitly, on the next line (the closing brace).
    Assuming the destructor of `C` follows the C++ guidelines and does not throw an
    exception (to do otherwise would be to invite the dreaded specter of undefined
    behavior), our entire function has been made exception-safe.
  prefs: []
  type: TYPE_NORMAL
- en: This idiom is sometimes known as **copy-and-swap** and is, perhaps, the easiest
    way to implement an operation with commit-or-rollback semantics, or a strong exception-safety
    guarantee. The key to the idiom is the ability to swap objects cheaply and without
    exceptions being thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Other common swap idioms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few more commonly used techniques that rely on swap, although none
    are as critically important as the use of swap for exception safety.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a very simple way to reset a container, or any other swappable
    object, to its default-constructed state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this code explicitly creates a default-constructed (*empty*) object
    just to swap with it, and uses an extra scope (a pair of curly braces) to ensure
    that that object is deleted as soon as possible. We can do better by using a temporary
    object, without a name, to swap with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The temporary object here is created and deleted within the same line of code
    and takes the old content of the object `c` with it. Note that the order of what
    is swapped with what is very important—the `swap()` member function is called
    on the temporary object. An attempt to do the reverse will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is because the `swap()` member function takes its argument by a `C&` non-const
    reference, and non-const references cannot be bound to temporary objects (more
    generally, to `r`-values). Note that, for the same reason, the `swap()` non-member
    function cannot be used to swap an object with a temporary object either, so if
    the class does not have a `swap()` member function, then an explicitly named object
    must be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more general form of this idiom is used to apply transforms to the original
    object without changing its name in the program. Let’s suppose that we have a
    vector in our program to which we want to apply the preceding `transmogrify()`
    function; however, we do not want to create a new vector. Instead, we want to
    continue using the original vector (or at least its variable name) in the program,
    but with the new data in it. This idiom is an elegant way to achieve the desired
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if `transmogrify()` can throw an exception, we have to use the entire
    scope, including swap, as a `try` block to achieve exception safety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This pattern can be repeated as many times as needed, replacing the content
    of the object without introducing new names into the program. Contrast it with
    the more traditional, C-like way that does not use swap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that the old names, `vec` and `vec1`, are still accessible after the new
    data is computed. It would be an easy mistake to use `vec` in the following code
    when `vec1` should be used instead. With the previously demonstrated swap technique,
    the program is not polluted with new variable names.
  prefs: []
  type: TYPE_NORMAL
- en: How to implement and use swap correctly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how the swap functionality is implemented by the standard library,
    and what the expectations are for a swap implementation. Let’s now see how to
    correctly support swap for your own types.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing swap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen that all STL containers, and many other standard library types
    (for example, `std::thread`), provide a `swap()` member function. While not required,
    it is the easiest way to implement swap that needs access to the private data
    of the class, as well as the only way to swap an object with a temporary object
    of the same type. The proper way to declare the `swap()` member function is like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the `noexcept` specification should only be included if a no-throw
    guarantee can indeed be given; in some cases, it may need to be conditional, based
    on properties of other types. The function may also be declared `constexpr`, if
    appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: How should the swap be implemented? There are several ways. For many classes,
    we can simply swap the data members, one at a time. This delegates the problem
    of swapping the objects to their contained types, which, if they follow the pattern,
    will eventually end up swapping the built-in types that everything is made of.
    If you know that your data member has a `swap()` member function, then you can
    call that. Otherwise, you have to call the non-member swap. This is likely to
    call an instantiation of the `std::swap()` template, but you should not invoke
    it by that name for reasons that will be explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, you should bring the name into the containing scope, and call `swap()`
    without the `std::` qualifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A particular implementation idiom that is very swap-friendly is the so-called
    `.C` file. The *pointer to implementation* data member is often called `p_impl`
    or `pimpl`, hence the name of the idiom. Swapping a pimpl-implemented class is
    as easy as swapping the two pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This takes care of the member function `swap()`. But what if someone calls
    a non-member `swap()` function on our custom types? As written, that call will
    invoke the default implementation of `std::swap()`, if it’s visible (for example,
    due to a `using` `std::swap` declaration), that is, the one that uses the copy
    or move operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though we have a `swap()` member function, `std::swap` does not use it.
    It is evident that we must also support a non-member `swap()` function. We can
    easily declare one, right after the class declaration. However, we should also
    consider what happens if the class is declared not in the global scope, but in
    a namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The unqualified call to `swap()` calls the `swap()` non-member function inside
    the `N` namespace, which in turn calls the member function `swap()` on one of
    the arguments (the convention adopted by the standard library is to call `lhs.swap()`).
    Note, however, that we did not invoke `N::swap()`, only `swap()`. Outside of the
    `N` namespace and without a `using` `namespace` `N;` specification, an unqualified
    call would not normally resolve to a function inside a namespace. However, in
    this case, it does, due to a feature in the standard called the **Argument-Dependent
    Lookup** (**ADL**), also known as the **Koenig lookup**. The ADL adds to the overload
    resolution all functions declared in the scopes where the arguments of the function
    are declared.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the compiler sees the `c1` and `c2` arguments of the `swap(...)`
    function and recognizes their type as `N::C`, even before it figures out what
    the `swap` name refers to. Since the arguments are in the `N` namespace, all functions
    declared in that namespace are added to the overload resolution, and thus, the
    `N::swap` function becomes visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the type has a `swap()` member function, then the easiest way to implement
    the non-member `swap()` function is to call that. However, such a member function
    is not required; if the decision was made to not support a `swap()` member function,
    then the `swap()` non-member has to have access to the private data of the class.
    It would have to be declared a `friend` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to define the implementation of the `swap()` function inline,
    without a separate definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is particularly handy when we have a class template, instead of a single
    class. We consider this pattern in more detail later, in [*Chapter* *11*](B19262_11.xhtml#_idTextAnchor509),
    *ScopeGuard*.
  prefs: []
  type: TYPE_NORMAL
- en: One often forgotten implementation detail is the self-swap—`swap(x, x)`, or,
    in the case of a member function call, `x.swap(x)`. Is it well-defined, but what
    does it do? The answer appears to be that it is, or should be, well-defined in
    both C++03 and C++11 (and later), but ends up doing nothing; that is, it does
    not change the object (although not necessarily at zero cost). A user-defined
    swap implementation should either be implicitly safe for self-swap or should explicitly
    test for it. If the swap is implemented in terms of copy or move assignments,
    it is important to note that the copy assignment is required by the standard to
    be safe against self-assignments, while the move assignment may change the object,
    but must leave it in a valid state, called a **moved-from** state (in this state,
    we can still assign something else to the object).
  prefs: []
  type: TYPE_NORMAL
- en: We should also note that similarly named STL functions `std::iter_swap` and
    `std::swap_ranges` are, in fact, algorithms that use `swap()` – possibly `std::swap`
    – to swap values pointed to by iterators or by entire ranges of iterators. They
    are also an example of how to correctly invoke `swap()` functions, not just in
    STL but everywhere in your code, as shown in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using swap correctly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until now, we have switched between calling a `swap()` member function, a
    `swap()` non-member function, and the explicitly qualified `std::swap()` operation,
    without any pattern or reason. We should now bring some discipline to this matter.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, it is always safe and appropriate to call the `swap()` member
    function as long as you know that it exists. The latter qualification usually
    comes up when writing template code—when dealing with concrete types, you typically
    know what interface they provide. This leaves us with just one question—when calling
    the `swap()` non-member function, should we use the `std::` prefix?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider what happens if we do, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the argument-dependent lookup does not apply to qualified names,
    which is why the call to `std::swap()` still calls the instantiation of the template
    swap from the `<utility>` header file of the STL. For this reason, it is recommended
    never to call `std::swap()` explicitly, but to bring that overload into the current
    scope with a `using` declaration, then call the unqualified `swap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly what STL algorithms do. For example, `std::iter_swap` is usually
    implemented something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the fully qualified invocation of `std::swap()` is often found
    in many programs. To protect yourself against such code and to ensure that your
    custom swap implementation is called no matter what, you can instantiate the `std::swap()`
    template for your own type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Generally, declaring your own functions or classes for the reserved `std::`
    namespace is not allowed by the standard. However, the standard makes an exception
    for explicit instantiations of certain template functions (`std::swap()` being
    among them). With such specialization in place, a call to `std::swap()` will invoke
    that instantiation, which forwards it to our custom swap implementation. Note
    that it is not sufficient to instantiate the `std::swap()` template, because such
    instantiations do not participate in the argument-dependent lookup. If the other
    non-member swap function is not provided, we have the reverse problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, the non-qualified call ends up calling the instantiation of the default
    `std::swap()` operation—the one with the move constructors and assignments. In
    order to ensure that every call to swap is correctly handled, both a non-member
    `swap()` function and the explicit `std::swap()` instantiation should be implemented
    (of course, they can, and should, all forward to the same implementation). Finally,
    note that the standard allows us to extend the `std::` namespace with template
    instantiations, but not with additional template overloads. Therefore, if, instead
    of a single type, we have a class template, we cannot specialize `std::swap` for
    it; such code will, in all likelihood, compile, but the standard does not guarantee
    that the desired overload will be selected (technically, the standard invokes
    the undefined behavior and guarantees nothing at all). For that reason alone,
    calling `std::swap` directly should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The swap functionality in C++ is used to implement several important patterns.
    The most critical one is the copy-and-swap implementation of exception-safe transactions.
    All standard library containers, and most other STL objects, provide the swap
    member function that is fast and, when possible, does not throw exceptions. User-defined
    types that need to support swap should follow the same pattern. Note, however,
    that implementing a non-throwing swap function usually requires an extra indirection
    and goes against several optimization patterns. In addition to the member function
    swap, we have reviewed the use and implementation of the non-member swap. Given
    that `std::swap` is always available, and can be called on any copyable or movable
    objects, the programmer should take care to implement a non-member swap function
    too if a better way to swap exists for a given type (in particular, any type with
    a member function swap should also provide a non-member function overload that
    calls that member function).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, while the preferred invocation of the non-member swap is without the
    `std::` prefix, the alternative use, although ill-advised, is common enough that
    an implicit instantiation of the `std::swap` template should be considered.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter takes us on a tour of one of the most popular, and powerful,
    C++ idioms—the C++ way of managing resources.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does swap do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is swap used in exception-safe programs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should a swap function be non-throwing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should a member or a non-member implementation of swap be preferred?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do standard library objects implement swap?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should the non-member swap function be called without the `std::` qualifier?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
