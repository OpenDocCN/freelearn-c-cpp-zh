- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Swap – from Simple to Subtle
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交换——从简单到微妙
- en: We begin our exploration of basic C++ idioms with a very simple, even humble,
    operation—`std::swap`, to do just that. Rest assured that C++ manages to turn
    even something as basic as a swap into a complex issue with subtle nuances.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个非常简单、甚至可以说是谦逊的操作——`std::swap`开始，来探索基本的C++惯用法。请放心，C++能够将交换这样基本的事情变成一个复杂的问题，具有细微的差别。
- en: 'The following topics are covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: How is `swap` used by the standard C++ library?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准C++库中是如何使用`swap`的？
- en: What are the applications of swap?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换的应用有哪些？
- en: How can we write exception-safe code using swap?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何使用交换编写异常安全的代码？
- en: How can we implement swap for our own types correctly?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何正确地为我们自己的类型实现交换？
- en: How can we correctly swap variables of an arbitrary type?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何正确地交换任意类型的变量？
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here is a link to all the example code of this chapter: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter04)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个链接到本章的所有示例代码：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter04)
- en: 'This is a link to the C++ Core Guidelines: [https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个链接到C++核心指南：[https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md)
- en: 'This is a link for the C++ **Guidelines Support Library** (**GSL**): [https://github.com/Microsoft/GSL](https://github.com/Microsoft/GSL)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个链接到C++ **指南支持库**（**GSL**）：[https://github.com/Microsoft/GSL](https://github.com/Microsoft/GSL)
- en: Swap and the standard template library
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交换与标准模板库
- en: The swap operation is widely used in the C++ standard library. All `std::swap`.
    There are also uses of swap in STL algorithms. The standard library is also a
    template for implementing custom features that resemble standard ones.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 交换操作在C++标准库中被广泛使用。所有`std::swap`。STL算法中也有交换的使用。标准库也是一个模板，用于实现类似于标准库的自定义功能。
- en: Therefore, we’ll begin our study of the swap operation with a look at the functionality
    provided by the standard.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将从查看标准提供的功能开始研究交换操作。
- en: Swap and STL containers
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交换与STL容器
- en: 'Conceptually, swap is equivalent to the following operation:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，交换等同于以下操作：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After the `swap()` is called, the contents of the `x` and `y` objects are swapped.
    This, however, is probably the worst possible way to actually implement swap.
    The first and most obvious problem with this implementation is that it copies
    both objects unnecessarily (it actually does three copy operations). The execution
    time of this operation is proportional to the size of the `T` type. For an STL
    container, the size would refer to the size of the actual container, not to the
    type of the element:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`swap()`之后，`x`和`y`对象的内容被交换。然而，这可能是实现交换的最糟糕的方式。这种实现的第一和最明显的问题是它不必要地复制了两个对象（实际上进行了三次复制操作）。这个操作的执行时间与`T`类型的大小成比例。对于STL容器，大小指的是实际容器的大小，而不是元素类型的大小：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that this code compiles, and, in most cases, even does the right thing.
    However, it copies every element of the vector several times. The second problem
    is that it temporarily allocates resources—for example, during the swap, we create
    a third vector that uses as much memory as one of the vectors being swapped. This
    allocation seems unnecessary, given that, in the final state, we have exactly
    as much data as we started with; only the names we use to access this data have
    been changed. The last problem with naive implementation is revealed when we consider
    what happens if, for example, the memory allocation we just mentioned fails.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这段代码可以编译，并且在大多数情况下甚至做对了。然而，它复制了向量的每个元素多次。第二个问题是它临时分配了资源——例如，在交换过程中，我们创建了一个使用与被交换的向量一样多的内存的第三个向量。考虑到最终状态中我们拥有的数据与开始时完全相同；只是我们用来访问这些数据的名称发生了变化，这种分配似乎是不必要的。原始实现中的最后一个问题是在考虑例如我们刚才提到的内存分配失败时出现的。
- en: The entire swap operation, which should have been as simple and foolproof as
    exchanging the names used to access vector elements, instead fails with a memory
    allocation failure.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 整个交换操作，本应像交换访问向量元素的名称一样简单且万无一失，却因为内存分配失败而失败。
- en: But that’s not the only way it can fail—the copy constructor and the assignment
    operator can both throw exceptions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是它失败的唯一方式——拷贝构造函数和赋值运算符都可以抛出异常。
- en: All STL containers, including `std::vector`, provide a guarantee that they can
    be swapped in constant time. The way this is accomplished is rather straightforward
    if you consider that the STL container objects themselves contain only pointers
    to the data, plus some state, such as object size. To swap these containers, we
    need only to swap the pointers (and the rest of the state, of course)—the elements
    of the container remain exactly where they always were, in dynamically allocated
    memory, and do not need to be copied or even accessed. The implementation of the
    swap needs only to swap the pointers, the sizes, and other state variables (in
    a real STL implementation, a container class, such as a vector, does not directly
    consist of data members of built-in types, such as pointers, but has one or more
    class data members that, in turn, are made from pointers and other built-in types).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所有STL容器，包括`std::vector`，都提供保证，它们可以在常数时间内进行交换。如果你考虑到STL容器对象本身只包含指向数据的指针和一些状态（如对象大小），那么这种实现方式相当直接。为了交换这些容器，我们只需要交换指针（以及当然的其他状态）——容器中的元素仍然保持在它们始终所在的位置，即在动态分配的内存中，不需要复制或甚至访问。交换的实现只需要交换指针、大小和其他状态变量（在真实的STL实现中，容器类，如向量，并不直接由内置类型（如指针）的数据成员组成，而是有一个或多个类数据成员，这些数据成员反过来由指针和其他内置类型组成）。
- en: Since any pointers or other vector data members are not publicly accessible,
    the swap has to be implemented as a member function of the container, or be declared
    a friend. The STL takes the former approach—all STL containers have a `swap()`
    member function that swaps the object with another object of the same type (see
    examples `01a` and `01b`).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任何指针或其他向量数据成员都不是公开可访问的，交换操作必须实现为容器的成员函数，或者声明为友元。STL采用前者方法——所有STL容器都有一个`swap()`成员函数，用于与同一类型的另一个对象交换对象（参见示例`01a`和`01b`）。
- en: The implementation of this by swapping pointers takes care, indirectly, of the
    two other problems we mentioned. First of all, because only the data members of
    the containers are swapped, there is no memory allocation. Secondly, copying pointers
    and other built-in types cannot throw an exception, and so the entire swap operation
    does not throw (and cannot otherwise fail).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过交换指针来实现这一点的实现间接地解决了我们提到的另外两个问题。首先，因为只有容器的数据成员被交换，所以没有内存分配。其次，复制指针和其他内置类型不能抛出异常，因此整个交换操作不会抛出（也不能以其他方式失败）。
- en: The simple and consistent picture we have described so far is only mostly true.
    The first complication, and by far the simpler one, applies only to containers
    that are parameterized not just on the element type, but also on a callable object
    of some sort. For example, the `std::map` container accepts the optional comparison
    function for comparing the elements of the map, which, by default, is `std::less`.
    Such callable objects have to be stored with the container. Since they are invoked
    very often, it is highly desirable, for performance reasons, to keep them in the
    same memory allocation as the container object itself, and indeed they are made
    data members of the container class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止描述的简单且一致的图景只是大部分情况下是正确的。第一个复杂问题，而且是最简单的一个，仅适用于那些不仅参数化元素类型，还参数化某种可调用对象的容器。例如，`std::map`容器接受可选的比较函数来比较映射中的元素，默认情况下是`std::less`。这些可调用对象必须与容器一起存储。由于它们被频繁调用，出于性能考虑，最好将它们与容器对象本身放在相同的内存分配中，并且确实它们被作为容器类的数据成员。
- en: However, that optimization comes with a price—swapping two containers now requires
    exchanging the compare functions; that is, the actual objects, not the pointers
    to them. The comparison objects are implemented by the client of the library,
    so there is no guarantee that swapping them is possible, let alone that it will
    not throw an exception.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种优化是有代价的——现在交换两个容器需要交换比较函数；也就是说，交换的是实际的对象，而不是指向它们的指针。比较对象由库的客户实现，因此没有保证交换它们是可能的，更不用说它不会抛出异常。
- en: Therefore, for `std::map`, the standard provides the following guarantee—in
    order for the map to be swappable, the callable objects must also be swappable.
    Furthermore, swapping two maps does not throw an exception, unless swapping comparison
    objects may throw, in which case, any exception thrown by that swap is propagated
    from the `std::map` swap.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于`std::map`，标准提供了以下保证——为了使映射可交换，可调用对象也必须是可交换的。此外，交换两个映射不会抛出异常，除非交换比较对象可能会抛出异常，在这种情况下，任何由该交换抛出的异常都将从`std::map`交换中传播。
- en: This consideration does not apply to containers, such as `std::vector`, that
    do not use any callable objects, and swapping these containers still does not
    throw an exception (as far as we know up to now).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种考虑不适用于不使用任何可调用对象的容器，例如`std::vector`，并且交换这些容器仍然不会抛出异常（至少到目前为止我们所知）。
- en: The other complication in the otherwise consistent and natural behavior of the
    swap is due to the allocators, and that is a hard one to resolve. Consider the
    problem—the two swapped containers must, necessarily, have allocators of the same
    type, but not necessarily the same allocator object. Each container has its elements
    allocated by its own allocator, and they must be deallocated by the same allocator.
    After the swap, the first container owns the elements from the second one and
    must eventually deallocate them. This can only be done (correctly) using the allocator
    of the first container; therefore, the allocators must also be exchanged.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在交换操作中，除了交换操作本身的一致性和自然行为之外，另一个复杂问题是由分配器引起的，这是一个难以解决的问题。考虑以下问题——两个交换的容器必须必然具有相同类型的分配器，但不一定是相同的分配器对象。每个容器都由其自己的分配器为其元素分配内存，并且它们必须由相同的分配器进行释放。交换之后，第一个容器拥有来自第二个容器的元素，并最终必须释放它们。这只能通过使用第一个容器的分配器（正确地）来完成；因此，分配器也必须进行交换。
- en: C++ standards prior to `allocator_type` allocator class, there is a `trait`
    class that defines, among other things, the `std::allocator_traits<allocator_type>::propagate_on_container_swap::value`
    trait property, and if this value is `true`, then the allocators are exchanged
    using an unqualified call to a non-member swap; that is, simply a `swap(allocator1,
    allocator2)` call (see the next section to learn what that call actually does).
    If this value is not `true`, then the allocators are not swapped at all, and both
    container objects must use the same allocator. If that is not `true` either, then
    we are back to undefined behavior. `swap()` member functions of STL containers
    to be conditionally `noexcept()`, with the same limitations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`allocator_type`分配器类出现之前，C++标准中有一个`trait`类，它定义了诸如`std::allocator_traits<allocator_type>::propagate_on_container_swap::value`这样的特性属性，如果这个值是`true`，那么分配器将通过非成员交换的不限定调用进行交换；即简单的`swap(allocator1,
    allocator2)`调用（参见下一节了解该调用实际执行的操作）。如果这个值不是`true`，那么分配器根本不会交换，并且两个容器对象必须使用相同的分配器。如果这也不是`true`，那么我们就回到了未定义行为。STL容器中的`swap()`成员函数将条件性地声明为`noexcept()`，具有相同的限制。
- en: The requirement that swapping two containers cannot throw an exception, at least
    as long as the allocators are not involved and the container does not use callable
    objects or uses non-throwing ones, ends up imposing a rather subtle limitation
    on the implementation of the container—it prevents the use of local buffer optimization.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要求交换两个容器不能抛出异常，至少在分配器不涉及并且容器不使用可调用对象或使用不抛出异常的对象的情况下是这样，这最终对容器的实现施加了一个相当微妙限制——它阻止了使用局部缓冲区优化。
- en: We will talk about this optimization in great detail in [*Chapter 10*](B19262_10.xhtml#_idTextAnchor453),
    *Local* *Buffer Optimization*, but in a nutshell, the idea is to avoid dynamic
    memory allocation for containers of very few elements, such as short strings,
    by defining a buffer inside the container class itself. This optimization, however,
    is generally incompatible with the notion of a non-throwing swap, since the elements
    inside the container object can no longer be exchanged by merely swapping pointers,
    but have to be copied between the containers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第10章*](B19262_10.xhtml#_idTextAnchor453)中详细讨论这种优化，*局部* *缓冲区优化*，但简而言之，这个想法是通过在容器类内部定义一个缓冲区来避免为元素非常少的容器（如短字符串）进行动态内存分配。然而，这种优化通常与非抛出异常的交换概念不兼容，因为容器对象内部的元素不能再通过交换指针来交换，而必须在不同容器之间进行复制。
- en: Non-member swap
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非成员交换
- en: 'The standard also provides a template `std::swap()` function. Prior to C++11,
    it was declared in the `<algorithm>` header; in C++11, it was moved to `<utility>`.
    The declaration of the function is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 标准还提供了一个模板`std::swap()`函数。在C++11之前，它在`<algorithm>`头文件中声明；在C++11中，它被移动到`<utility>`。函数的声明如下：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The overload for arrays was added in C++11\. In C++20, both versions are additionally
    declared `constexpr`. For STL containers, `std::swap()` calls the member function
    `swap()`. As we will see in the following section, the behavior of `swap()` can
    be customized for other types as well, but without any special efforts, the default
    implementation is used. This implementation does a swap using a temporary object.
    Before C++11, the temporary object was copy-constructed, and the swap was done
    with two assignments, just as we did in the preceding section. The type has to
    be copyable (both copy-constructible and copy-assignable), otherwise `std::swap()`
    will not compile (see examples `02a` and `02b`). In C++11, `std::swap()` has been
    redefined to use move construction and move assignment (see example `02c`). As
    usual, if the class is copyable, but does not have move operations declared at
    all, then the copy constructor and assignment are used. Note that if the class
    has copy operations declared and move operations declared as deleted, there is
    no automatic fallback to copying—that class is a non-movable type and `std::swap()`
    will not compile for it (see example `02d`).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: C++11中增加了数组重载。在C++20中，这两个版本都被额外声明为`constexpr`。对于STL容器，`std::swap()`调用成员函数`swap()`。正如我们将在下一节中看到的，`swap()`的行为也可以为其他类型定制，但如果没有特别的努力，默认实现就会被使用。这个实现使用一个临时对象进行交换。在C++11之前，临时对象是通过拷贝构造来创建的，交换是通过两个赋值操作完成的，就像我们在前一节中所做的那样。类型必须是可拷贝的（即必须可拷贝构造和可拷贝赋值），否则`std::swap()`将无法编译（参见示例`02a`和`02b`）。在C++11中，`std::swap()`被重新定义为使用移动构造和移动赋值（参见示例`02c`）。通常，如果类是可拷贝的，但没有声明移动操作，那么就会使用拷贝构造函数和赋值操作。注意，如果类声明了拷贝操作，但声明了移动操作为删除，则没有自动回退到拷贝——那个类是非可移动类型，`std::swap()`将无法编译（参见示例`02d`）。
- en: Since copying an object can, in general, throw an exception, swapping two objects
    for which a custom swap behavior is not provided can throw an exception as well.
    Move operations do not usually throw exceptions, and in C++11, if the object has
    a move constructor and an assignment operator and neither throws an exception,
    `std::swap()` also provides a no-throw guarantee. That behavior has been formalized
    in C++17 with a conditional `noexcept()` specification.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通常拷贝对象可能会抛出异常，因此对于没有提供自定义交换行为的两个对象进行交换也可能抛出异常。移动操作通常不会抛出异常，并且在C++11中，如果对象有一个移动构造函数和一个赋值操作符，并且它们都没有抛出异常，`std::swap()`也提供了一个无异常保证。这种行为在C++17中通过条件`noexcept()`规范得到了正式化。
- en: Swapping like the standard
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准化的交换
- en: 'From the preceding review of how the standard library handles a swap, we can
    deduce the following guidelines:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从对标准库如何处理交换的前述回顾中，我们可以得出以下准则：
- en: Classes that support swap should implement `swap()` member functions that perform
    the operation in constant time
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持swap的类应该实现执行操作常时间的`swap()`成员函数
- en: A free-standing `swap()` non-member function should also be provided for all
    types that can be swapped
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应为所有可以交换的类型提供一个独立的`swap()`非成员函数
- en: Swapping two objects should not throw exceptions or otherwise fail
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换两个对象不应该抛出异常或以其他方式失败
- en: The latter guideline is less strict, and it is not always possible to follow
    it. In general, if the type has move operations that do not throw an exception,
    a non-throwing swap implementation is also possible. Note also that many exception-safety
    guarantees, and in particular those provided by the standard library, require
    that move and swap operations do not throw an exception.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 后一个准则不那么严格，并且并不总是可能遵循。一般来说，如果类型有不会抛出异常的移动操作，那么也可以有一个非抛出异常的swap实现。还要注意，许多异常安全性保证，特别是标准库提供的，要求移动和交换操作不能抛出异常。
- en: When and why to use swap
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时以及为什么使用swap
- en: What is so important about the swap functionality that it deserves its own chapter?
    For that matter, why even use swap, and not continue to refer to an object by
    its original name?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 交换功能为什么如此重要，以至于值得拥有自己的章节？关于这一点，为什么甚至要使用swap，而不是继续通过原始名称引用对象？
- en: Mostly, it has to do with exception safety, which is also why we keep mentioning
    when swap can and cannot throw an exception.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 主要是因为异常安全性，这也是我们为什么一直提到何时swap可以抛出异常，何时不可以。
- en: Swap and exception safety
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交换和异常安全性
- en: The most important application of swap in C++ has to do with writing exception-safe
    code, or, more generally, error-safe code. Here is the problem, in a nutshell—in
    an exception-safe program, throwing an exception should never leave the program
    in an undefined state.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，交换操作最重要的应用是编写异常安全代码，或者更普遍地说，是错误安全代码。简而言之，在异常安全程序中，抛出异常不应该使程序处于未定义状态。
- en: More generally, an error condition should never leave the program in an undefined
    state. Note that the error does not need to be handled by means of an exception—for
    example, returning an error code from a function should also be handled without
    creating undefined behavior. In particular, if an operation causes an error, the
    resources already consumed by the operation in progress should be released. Often,
    an even stronger guarantee is desired—every operation either succeeds or is entirely
    rolled back.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 更普遍地说，错误条件不应该使程序处于未定义状态。请注意，错误不需要通过异常处理方式来处理——例如，从函数返回错误代码也应该在不创建未定义行为的情况下处理。特别是，如果操作导致错误，则应释放操作过程中已消耗的资源。通常，人们还希望有一个更强的保证——每个操作要么成功，要么完全回滚。
- en: 'Let’s consider an example where we will apply a transform to all elements of
    a vector, and store the results in a new vector:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子，我们将对向量的所有元素应用转换，并将结果存储在一个新的向量中：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we return the vector via an output parameter. Let us assume that it is
    a requirement to use an already existing vector for output and we are not doing
    it for performance reasons. In all recent versions of C++, returning a vector
    by value is quite fast: the compiler will either apply the return-value optimization
    and elide the copy completely (copy elision is not guaranteed but likely) or replace
    copy by move (also fast, guaranteed). The vector is made empty at first, and grows
    to the same size as the input vector. Any data the `out` vector may have had is
    gone. Note the `reserve()` call that is used to avoid repeated deallocations of
    the growing vector.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过输出参数返回向量。让我们假设使用一个已经存在的向量作为输出是一个要求，而我们并不是出于性能原因这样做。在所有最近的C++版本中，通过值返回向量相当快：编译器要么应用返回值优化并完全省略复制（复制省略不是保证的但很可能是的）或者用移动来替换复制（也很快，是保证的）。向量最初为空，并增长到与输入向量相同的大小。`out`向量可能拥有的任何数据都消失了。注意，使用`reserve()`调用来避免重复释放正在增长的向量。
- en: This code works fine as long as there are no errors, that is, no exceptions
    are thrown. But this is not guaranteed. First of all, `reserve()` does a memory
    allocation, which may fail. If this happens, the `transmogrify()` function will
    exit via the exception, and the output vector will be empty since the `resize(0)`
    call has already been executed. The initial content of the output vector is lost,
    and nothing is written to replace it. Secondly, any iteration of the loop over
    the elements of the vector may throw an exception. An exception could be thrown
    by the copy constructor of the new element of the output vector, or by the transformation
    itself. Either way, the loop is interrupted. STL guarantees that the output vector
    is not left in an undefined state even if the copy constructor inside the `push_back()`
    call fails—the new element is not *partially* created, and the vector size is
    not increased.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 只要没有错误，即没有抛出异常，这段代码就能正常工作。但这并不保证。首先，`reserve()`执行内存分配，可能会失败。如果发生这种情况，`transmogrify()`函数将通过异常退出，并且输出向量将为空，因为`resize(0)`调用已经执行。输出向量的初始内容丢失，并且没有写入任何内容来替换它。其次，对向量元素的任何迭代都可能抛出异常。异常可能由输出向量的新元素的复制构造函数抛出，或者由转换本身抛出。无论如何，循环都会中断。STL保证，即使在`push_back()`调用中的复制构造函数失败的情况下，输出向量也不会处于未定义状态——新元素不是*部分*创建的，向量大小也不会增加。
- en: However, the elements already stored will remain in the output vector (and any
    elements that were there originally are gone). This may not be what we intended—it
    is not unreasonable to request that the `transmogrify()` operation either succeeds
    and applies the transform to the entire vector, or fails and changes nothing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，已经存储的元素将保留在输出向量中（并且原始存在的任何元素都消失了）。这可能不是我们想要的——要求`transmogrify()`操作要么成功并应用于整个向量，要么失败而不做任何改变，这是合理的。
- en: 'The key to such exception-safe implementation is the swap:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种异常安全实现的关键是交换操作：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we have changed the code to operate on a temporary vector during
    the entire transformation. Note that, in a typical case of an output vector that
    is empty on input, this does not increase the amount of memory in use. If the
    output vector has some data in it, both the new data and the old data exist in
    memory until the end of the function. This is necessary to provide a guarantee
    that the old data will not be deleted unless the new data can be fully computed.
    If desired, this guarantee can be traded for lower overall memory use, and the
    output vector can be emptied at the beginning of the function (on the other hand,
    any caller who wants to make such a trade-off can just empty the vector before
    calling `transmogrify()`).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们改变了代码，在整个转换过程中操作临时向量。请注意，在典型的输出向量为空输入的情况下，这并不会增加内存的使用量。如果输出向量中有些数据，新数据和旧数据将一直存在于内存中，直到函数结束。这是必要的，以确保旧数据只有在新数据可以完全计算的情况下才会被删除。如果需要，可以通过降低整体内存使用量来交换这个保证，并在函数开始时（另一方面，任何想要进行这种权衡的调用者只需在调用`transmogrify()`之前清空向量）清空输出向量。
- en: If an exception is thrown at any time during the execution of the `transmogrify()`
    function, right up until the last line, then the temporary vector is deleted,
    as would be any local variable allocated on the stack (see [*Chapter 5*](B19262_05.xhtml#_idTextAnchor199),
    *A Comprehensive Look at RAII*, later in this book). The last line is the key
    to exception safety—it swaps the content of the output vector with that of the
    temporary one. If that line can throw an exception, then our entire work is for
    nothing—the swap has failed, and the output vector is left in an undefined state
    since we do not know how much of the swap had succeeded before the exception was
    thrown. But if the swap does not throw an exception, as in the case for `std::vector`,
    then, as long as the control reached the last line, the entire `transmogrify()`
    operation has succeeded, and the result will be returned to the caller. What happens
    to the old content of the output vector? It is now owned by the temporary vector,
    which is about to be deleted, implicitly, on the next line (the closing brace).
    Assuming the destructor of `C` follows the C++ guidelines and does not throw an
    exception (to do otherwise would be to invite the dreaded specter of undefined
    behavior), our entire function has been made exception-safe.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在执行`transmogrify()`函数的过程中，任何时刻抛出异常，直到最后一行，那么临时向量将被删除，就像在栈上分配的任何局部变量一样（参见[*第5章*](B19262_05.xhtml#_idTextAnchor199)，本书后面的*RAII全面探讨*）。最后一行是异常安全的关键——它交换输出向量和临时向量的内容。如果这一行可以抛出异常，那么我们所有的努力都将白费——交换失败，输出向量将处于未定义状态，因为我们不知道在异常抛出之前交换成功了多少。但是，如果交换没有抛出异常，就像`std::vector`的情况一样，那么只要控制流到达最后一行，整个`transmogrify()`操作就成功了，结果将返回给调用者。输出向量的旧内容会发生什么？现在它由临时向量拥有，而临时向量将在下一行（闭括号）隐式删除。假设`C`的析构函数遵循C++指南并且不会抛出异常（否则将招致可怕的未定义行为），那么我们的整个函数已经实现了异常安全。
- en: This idiom is sometimes known as **copy-and-swap** and is, perhaps, the easiest
    way to implement an operation with commit-or-rollback semantics, or a strong exception-safety
    guarantee. The key to the idiom is the ability to swap objects cheaply and without
    exceptions being thrown.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种惯用方法有时被称为**拷贝-交换**，可能是实现具有提交-回滚语义或强异常安全保证的操作的最简单方法。这个惯用方法的关键是能够以低成本且不抛出异常的方式交换对象。
- en: Other common swap idioms
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他常见的交换惯用方法
- en: There are a few more commonly used techniques that rely on swap, although none
    are as critically important as the use of swap for exception safety.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几种更常用的技术依赖于交换，尽管它们都没有像交换用于异常安全那样至关重要。
- en: 'Let’s start with a very simple way to reset a container, or any other swappable
    object, to its default-constructed state:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一种非常简单的方法开始，将容器或任何其他可交换对象重置为其默认构造状态：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that this code explicitly creates a default-constructed (*empty*) object
    just to swap with it, and uses an extra scope (a pair of curly braces) to ensure
    that that object is deleted as soon as possible. We can do better by using a temporary
    object, without a name, to swap with:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此代码明确创建了一个默认构造的（*空*）对象，仅为了与之交换，并使用额外的范围（一对大括号）来确保该对象尽快被删除。我们可以通过使用一个没有名称的临时对象来交换，做得更好：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The temporary object here is created and deleted within the same line of code
    and takes the old content of the object `c` with it. Note that the order of what
    is swapped with what is very important—the `swap()` member function is called
    on the temporary object. An attempt to do the reverse will not compile:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，临时对象是在同一行代码中创建和删除的，并且它携带了对象 `c` 的旧内容。请注意，交换内容的顺序非常重要——`swap()` 成员函数是在临时对象上被调用的。尝试进行反向操作将无法编译：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is because the `swap()` member function takes its argument by a `C&` non-const
    reference, and non-const references cannot be bound to temporary objects (more
    generally, to `r`-values). Note that, for the same reason, the `swap()` non-member
    function cannot be used to swap an object with a temporary object either, so if
    the class does not have a `swap()` member function, then an explicitly named object
    must be created.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `swap()` 成员函数通过 `C&` 非常量引用来接收其参数，非非常量引用不能绑定到临时对象（更一般地说，到 `r`-值）。请注意，出于同样的原因，`swap()`
    非成员函数也不能用于交换对象与临时对象，因此如果类没有 `swap()` 成员函数，那么必须显式创建一个命名对象。
- en: 'A more general form of this idiom is used to apply transforms to the original
    object without changing its name in the program. Let’s suppose that we have a
    vector in our program to which we want to apply the preceding `transmogrify()`
    function; however, we do not want to create a new vector. Instead, we want to
    continue using the original vector (or at least its variable name) in the program,
    but with the new data in it. This idiom is an elegant way to achieve the desired
    result:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种习语的更一般形式用于在不更改程序中名称的情况下应用转换到原始对象。假设我们在程序中有一个向量，我们想要应用前面的 `transmogrify()`
    函数；然而，我们不想创建一个新的向量。相反，我们想在程序中继续使用原始向量（或者至少它的变量名），但里面包含新的数据。这种习语是实现所需结果的一种优雅方式：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that if `transmogrify()` can throw an exception, we have to use the entire
    scope, including swap, as a `try` block to achieve exception safety:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果 `transmogrify()` 可以抛出异常，我们必须使用整个作用域，包括交换，作为一个 `try` 块来实现异常安全性：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This pattern can be repeated as many times as needed, replacing the content
    of the object without introducing new names into the program. Contrast it with
    the more traditional, C-like way that does not use swap:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式可以根据需要重复多次，替换对象的内容，而不需要在程序中引入新的名称。将其与传统的不使用交换的 C 风格方法进行对比：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the old names, `vec` and `vec1`, are still accessible after the new
    data is computed. It would be an easy mistake to use `vec` in the following code
    when `vec1` should be used instead. With the previously demonstrated swap technique,
    the program is not polluted with new variable names.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在计算新数据后，旧名称 `vec` 和 `vec1` 仍然可访问。在以下代码中使用 `vec` 而不是 `vec1` 将是一个容易犯的错误。使用之前演示的交换技术，程序不会被新的变量名称所污染。
- en: How to implement and use swap correctly
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何正确实现和使用交换
- en: We have seen how the swap functionality is implemented by the standard library,
    and what the expectations are for a swap implementation. Let’s now see how to
    correctly support swap for your own types.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了标准库如何实现交换功能，以及对于交换实现的期望。现在让我们看看如何正确支持您自己的类型的交换。
- en: Implementing swap
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现交换
- en: 'We have seen that all STL containers, and many other standard library types
    (for example, `std::thread`), provide a `swap()` member function. While not required,
    it is the easiest way to implement swap that needs access to the private data
    of the class, as well as the only way to swap an object with a temporary object
    of the same type. The proper way to declare the `swap()` member function is like
    this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，所有 STL 容器以及许多其他标准库类型（例如，`std::thread`）都提供了一个 `swap()` 成员函数。虽然这不是必需的，但这是实现交换的最简单方法，因为它需要访问类的私有数据，以及交换相同类型的对象与临时对象的唯一方法。正确声明
    `swap()` 成员函数的方式如下：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Of course, the `noexcept` specification should only be included if a no-throw
    guarantee can indeed be given; in some cases, it may need to be conditional, based
    on properties of other types. The function may also be declared `constexpr`, if
    appropriate.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，只有当确实可以提供无抛出保证时，才应包含 `noexcept` 规范；在某些情况下，它可能需要基于其他类型的属性进行条件化。如果适当，函数也可以声明为
    `constexpr`。
- en: How should the swap be implemented? There are several ways. For many classes,
    we can simply swap the data members, one at a time. This delegates the problem
    of swapping the objects to their contained types, which, if they follow the pattern,
    will eventually end up swapping the built-in types that everything is made of.
    If you know that your data member has a `swap()` member function, then you can
    call that. Otherwise, you have to call the non-member swap. This is likely to
    call an instantiation of the `std::swap()` template, but you should not invoke
    it by that name for reasons that will be explained in the next section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如何实现交换？有几种方法。对于许多类，我们可以简单地逐个交换数据成员。这会将交换对象的问题委托给它们包含的类型，如果它们遵循该模式，最终会结束于交换构成一切的内建类型。如果你知道你的数据成员有一个`swap()`成员函数，那么你可以调用它。否则，你必须调用非成员交换。这很可能会调用`std::swap()`模板的一个实例化，但你不应通过该名称调用它，原因将在下一节中解释。
- en: 'Instead, you should bring the name into the containing scope, and call `swap()`
    without the `std::` qualifier:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你应该将名称引入包含作用域，并调用`swap()`而不使用`std::`限定符：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A particular implementation idiom that is very swap-friendly is the so-called
    `.C` file. The *pointer to implementation* data member is often called `p_impl`
    or `pimpl`, hence the name of the idiom. Swapping a pimpl-implemented class is
    as easy as swapping the two pointers:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一种非常适用于交换的特定实现习惯用法是所谓的`.C`文件。实现数据的指针成员通常被称为`p_impl`或`pimpl`，因此得名该习惯用法。交换pimpl实现的类就像交换两个指针一样简单：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This takes care of the member function `swap()`. But what if someone calls
    a non-member `swap()` function on our custom types? As written, that call will
    invoke the default implementation of `std::swap()`, if it’s visible (for example,
    due to a `using` `std::swap` declaration), that is, the one that uses the copy
    or move operations:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这就处理了成员函数`swap()`。但如果有人在我们的自定义类型上调用非成员`swap()`函数呢？按照目前的写法，这个调用将调用`std::swap()`的默认实现，如果它是可见的（例如，由于`using
    std::swap`声明），即使用复制或移动操作的那个实现。
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Even though we have a `swap()` member function, `std::swap` does not use it.
    It is evident that we must also support a non-member `swap()` function. We can
    easily declare one, right after the class declaration. However, we should also
    consider what happens if the class is declared not in the global scope, but in
    a namespace:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们有一个`swap()`成员函数，但`std::swap`并没有使用它。很明显，我们也必须支持一个非成员的`swap()`函数。我们可以在类声明之后轻松地声明一个，然而，我们也应该考虑如果类不是在全局作用域中声明，而是在一个命名空间中声明会发生什么：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The unqualified call to `swap()` calls the `swap()` non-member function inside
    the `N` namespace, which in turn calls the member function `swap()` on one of
    the arguments (the convention adopted by the standard library is to call `lhs.swap()`).
    Note, however, that we did not invoke `N::swap()`, only `swap()`. Outside of the
    `N` namespace and without a `using` `namespace` `N;` specification, an unqualified
    call would not normally resolve to a function inside a namespace. However, in
    this case, it does, due to a feature in the standard called the **Argument-Dependent
    Lookup** (**ADL**), also known as the **Koenig lookup**. The ADL adds to the overload
    resolution all functions declared in the scopes where the arguments of the function
    are declared.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 无限定符调用`swap()`会调用`N`命名空间内的`swap()`非成员函数，该函数反过来会调用其中一个参数上的成员函数`swap()`（标准库采用的约定是调用`lhs.swap()`）。请注意，然而，我们没有调用`N::swap()`，而是只调用了`swap()`。在`N`命名空间之外，并且没有`using
    namespace N;`指定的情况下，无限定符调用通常不会解析为命名空间内的函数。然而，在这种情况下，它确实解析了，这是由于标准中的一个特性，称为**参数依赖查找**（**ADL**），也称为**科宁查找**。ADL将所有在函数参数声明的作用域中声明的函数添加到重载解析中。
- en: In our case, the compiler sees the `c1` and `c2` arguments of the `swap(...)`
    function and recognizes their type as `N::C`, even before it figures out what
    the `swap` name refers to. Since the arguments are in the `N` namespace, all functions
    declared in that namespace are added to the overload resolution, and thus, the
    `N::swap` function becomes visible.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，编译器在弄清楚`swap(...)`函数中的`c1`和`c2`参数所引用的`swap`名称之前，就已经将它们的类型识别为`N::C`。由于这些参数位于`N`命名空间中，因此该命名空间中声明的所有函数都会被添加到重载解析中，从而使`N::swap`函数变得可见。
- en: 'If the type has a `swap()` member function, then the easiest way to implement
    the non-member `swap()` function is to call that. However, such a member function
    is not required; if the decision was made to not support a `swap()` member function,
    then the `swap()` non-member has to have access to the private data of the class.
    It would have to be declared a `friend` function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型有一个 `swap()` 成员函数，那么实现非成员 `swap()` 函数的最简单方法就是调用它。然而，这样的成员函数不是必需的；如果决定不支持
    `swap()` 成员函数，那么非成员 `swap()` 必须能够访问类的私有数据。它必须被声明为一个 `friend` 函数：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It is also possible to define the implementation of the `swap()` function inline,
    without a separate definition:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在不使用单独定义的情况下，内联定义 `swap()` 函数的实现：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is particularly handy when we have a class template, instead of a single
    class. We consider this pattern in more detail later, in [*Chapter* *11*](B19262_11.xhtml#_idTextAnchor509),
    *ScopeGuard*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个类模板而不是单个类时，这尤其方便。我们将在稍后的 [*第 11 章*](B19262_11.xhtml#_idTextAnchor509)，*作用域保护*
    中更详细地考虑这个模式。
- en: One often forgotten implementation detail is the self-swap—`swap(x, x)`, or,
    in the case of a member function call, `x.swap(x)`. Is it well-defined, but what
    does it do? The answer appears to be that it is, or should be, well-defined in
    both C++03 and C++11 (and later), but ends up doing nothing; that is, it does
    not change the object (although not necessarily at zero cost). A user-defined
    swap implementation should either be implicitly safe for self-swap or should explicitly
    test for it. If the swap is implemented in terms of copy or move assignments,
    it is important to note that the copy assignment is required by the standard to
    be safe against self-assignments, while the move assignment may change the object,
    but must leave it in a valid state, called a **moved-from** state (in this state,
    we can still assign something else to the object).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常被遗忘的实现细节是自我交换——`swap(x, x)`，或者，在成员函数调用的情况下，`x.swap(x)`。这是否定义良好？它到底做了什么？答案似乎是在
    C++03 和 C++11（以及之后的版本）中，它应该是定义良好的，但最终什么也不做；也就是说，它不会改变对象（尽管不一定是零成本）。用户定义的 swap
    实现应该对自我交换是隐式安全的，或者应该显式检查它。如果 swap 是基于复制或移动赋值实现的，那么需要注意的是，标准要求复制赋值必须对自我赋值是安全的，而移动赋值可能会改变对象，但必须将其置于一个有效状态，称为
    **已移动状态**（在这个状态下，我们仍然可以将其他东西赋值给对象）。
- en: We should also note that similarly named STL functions `std::iter_swap` and
    `std::swap_ranges` are, in fact, algorithms that use `swap()` – possibly `std::swap`
    – to swap values pointed to by iterators or by entire ranges of iterators. They
    are also an example of how to correctly invoke `swap()` functions, not just in
    STL but everywhere in your code, as shown in the next section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该注意，同名但功能不同的 STL 函数 `std::iter_swap` 和 `std::swap_ranges` 实际上是使用 `swap()`
    – 可能是 `std::swap` – 来交换迭代器或迭代器范围的值的算法。它们也是如何正确调用 `swap()` 函数的一个例子，不仅是在 STL 中，而且在代码的任何地方，如下一节所示。
- en: Using swap correctly
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正确使用 swap
- en: Up until now, we have switched between calling a `swap()` member function, a
    `swap()` non-member function, and the explicitly qualified `std::swap()` operation,
    without any pattern or reason. We should now bring some discipline to this matter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在调用 `swap()` 成员函数、`swap()` 非成员函数和显式命名的 `std::swap()` 操作之间切换，没有任何模式或理由。我们现在应该在这方面引入一些纪律。
- en: First of all, it is always safe and appropriate to call the `swap()` member
    function as long as you know that it exists. The latter qualification usually
    comes up when writing template code—when dealing with concrete types, you typically
    know what interface they provide. This leaves us with just one question—when calling
    the `swap()` non-member function, should we use the `std::` prefix?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，只要你知道它存在，调用 `swap()` 成员函数总是安全且合适的。后者的条件通常在编写模板代码时出现——当处理具体类型时，你通常知道它们提供了什么接口。这让我们只剩下一个问题——在调用
    `swap()` 非成员函数时，我们应该使用 `std::` 前缀吗？
- en: 'Consider what happens if we do, as shown here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情况，如图所示：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that the argument-dependent lookup does not apply to qualified names,
    which is why the call to `std::swap()` still calls the instantiation of the template
    swap from the `<utility>` header file of the STL. For this reason, it is recommended
    never to call `std::swap()` explicitly, but to bring that overload into the current
    scope with a `using` declaration, then call the unqualified `swap`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，基于参数的查找不适用于合格名称，这就是为什么对`std::swap()`的调用仍然调用STL的`<utility>`头文件中模板`swap`的实例化。因此，建议永远不要显式调用`std::swap()`，而是使用`using`声明将那个重载引入当前作用域，然后调用无前缀的`swap`：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is exactly what STL algorithms do. For example, `std::iter_swap` is usually
    implemented something like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是STL算法所做的事情。例如，`std::iter_swap`通常是这样实现的：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Unfortunately, the fully qualified invocation of `std::swap()` is often found
    in many programs. To protect yourself against such code and to ensure that your
    custom swap implementation is called no matter what, you can instantiate the `std::swap()`
    template for your own type:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`std::swap()`的完全合格调用在许多程序中很常见。为了保护自己免受此类代码的影响，并确保无论发生什么情况都能调用你的自定义`swap`实现，你可以为你自己的类型实例化`std::swap()`模板：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Generally, declaring your own functions or classes for the reserved `std::`
    namespace is not allowed by the standard. However, the standard makes an exception
    for explicit instantiations of certain template functions (`std::swap()` being
    among them). With such specialization in place, a call to `std::swap()` will invoke
    that instantiation, which forwards it to our custom swap implementation. Note
    that it is not sufficient to instantiate the `std::swap()` template, because such
    instantiations do not participate in the argument-dependent lookup. If the other
    non-member swap function is not provided, we have the reverse problem:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，根据标准，不允许声明自己的函数或类用于保留的`std::`命名空间。然而，标准为某些模板函数的显式实例化（包括`std::swap()`）做出了例外。有了这样的特化，对`std::swap()`的调用将调用那个实例化，并将其转发到我们的自定义`swap`实现。请注意，仅实例化`std::swap()`模板是不够的，因为这样的实例化不参与基于参数的查找。如果未提供其他非成员`swap`函数，我们将遇到相反的问题：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, the non-qualified call ends up calling the instantiation of the default
    `std::swap()` operation—the one with the move constructors and assignments. In
    order to ensure that every call to swap is correctly handled, both a non-member
    `swap()` function and the explicit `std::swap()` instantiation should be implemented
    (of course, they can, and should, all forward to the same implementation). Finally,
    note that the standard allows us to extend the `std::` namespace with template
    instantiations, but not with additional template overloads. Therefore, if, instead
    of a single type, we have a class template, we cannot specialize `std::swap` for
    it; such code will, in all likelihood, compile, but the standard does not guarantee
    that the desired overload will be selected (technically, the standard invokes
    the undefined behavior and guarantees nothing at all). For that reason alone,
    calling `std::swap` directly should be avoided.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，非合格调用最终会调用默认的`std::swap()`操作的实例化——即带有移动构造函数和赋值操作的实例。为了确保每个`swap`调用都得到正确处理，应该实现一个非成员`swap()`函数和显式的`std::swap()`实例化（当然，它们可以，并且应该，都转发到相同的实现）。最后，请注意，标准允许我们通过模板实例化扩展`std::`命名空间，但不允许通过额外的模板重载。因此，如果我们有一个类模板而不是单个类型，我们不能为它特化`std::swap`；这样的代码很可能会编译，但标准不保证会选择所需的重载（技术上，标准调用未定义的行为并保证一切）。因此，直接调用`std::swap`应该避免。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The swap functionality in C++ is used to implement several important patterns.
    The most critical one is the copy-and-swap implementation of exception-safe transactions.
    All standard library containers, and most other STL objects, provide the swap
    member function that is fast and, when possible, does not throw exceptions. User-defined
    types that need to support swap should follow the same pattern. Note, however,
    that implementing a non-throwing swap function usually requires an extra indirection
    and goes against several optimization patterns. In addition to the member function
    swap, we have reviewed the use and implementation of the non-member swap. Given
    that `std::swap` is always available, and can be called on any copyable or movable
    objects, the programmer should take care to implement a non-member swap function
    too if a better way to swap exists for a given type (in particular, any type with
    a member function swap should also provide a non-member function overload that
    calls that member function).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的swap功能用于实现几个重要模式。其中最关键的是异常安全事务的拷贝-交换实现。所有标准库容器以及大多数其他STL对象都提供了快速且在可能的情况下不抛出异常的swap成员函数。需要支持swap的用户定义类型应遵循相同的模式。然而，请注意，实现非抛出异常的swap函数通常需要额外的间接引用，并违反了几个优化模式。除了成员函数swap之外，我们还回顾了非成员swap的使用和实现。鉴于`std::swap`总是可用，并且可以在任何可拷贝或可移动的对象上调用，如果给定类型存在更好的swap方式（特别是任何具有成员函数swap的类型也应提供调用该成员函数的非成员函数重载），程序员应确保实现非成员swap函数。
- en: Finally, while the preferred invocation of the non-member swap is without the
    `std::` prefix, the alternative use, although ill-advised, is common enough that
    an implicit instantiation of the `std::swap` template should be considered.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，虽然不推荐，但非成员swap的替代用法足够常见，以至于应该考虑隐式实例化`std::swap`模板。
- en: The next chapter takes us on a tour of one of the most popular, and powerful,
    C++ idioms—the C++ way of managing resources.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将带我们游览C++中最流行且强大的惯用法之一——C++管理资源的方式。
- en: Questions
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does swap do?
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: swap的作用是什么？
- en: How is swap used in exception-safe programs?
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: swap在异常安全程序中是如何使用的？
- en: Why should a swap function be non-throwing?
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么swap函数应该是非抛出异常的？
- en: Should a member or a non-member implementation of swap be preferred?
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该优先选择成员或非成员的swap实现？
- en: How do standard library objects implement swap?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准库对象是如何实现swap的？
- en: Why should the non-member swap function be called without the `std::` qualifier?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么非成员swap函数应该不带`std::`限定符调用？
