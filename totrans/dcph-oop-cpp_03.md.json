["```cpp\nint x = 10;\nint *pointerToX = nullptr; // pointer variable which may \n                           // someday point to an integer\npointerToX = &x;  // assign memory loc. of x to pointerToX\ncout << \"x: \" << x << \" and *pointerToX: \" << *pointerToX;\n```", "```cpp\nX: 10 and *pointerToX: 10\n```", "```cpp\nint *y = nullptr; // ptr y may someday point to an int\ny = new int;   // y pts to uninit. memory allocated on heap\n*y = 17;   // dereference y to load the newly allocated\n           // memory with a value of 17\ncout << \"*y is: \" << *y << endl;\ndelete y;  // relinquish the allocated memory\n// alternative ptr declaration, mem alloc., initialization\nint *z = new int(22); \ncout <<  \"*z is: \" << *z << endl;\ndelete z;  // relinquish heap memory\n```", "```cpp\n#include <iostream>\nusing std::cout;\nusing std::endl;\nstruct collection\n{\n    int x;\n    float y;\n};\n\nint main()  \n{\n    collection *item = nullptr;   // pointer declaration \n    item = new collection;   // memory allocation \n    item->x = 9;        // use -> to access data member x\n    (*item).y = 120.77; // alt. notation to access member y\n    cout << (*item).x << \" \" << item->y << endl;\n    delete item;           // relinquish memory\n    return 0;\n}\n```", "```cpp\n9 120.77\n```", "```cpp\n#include <iostream>\nusing std::cout;\nusing std::cin;\nusing std:::endl;\nusing std::flush;\nstruct collection\n{\n    int x;\n    float y;\n};\n\nint main()\n{\n    int numElements = 0;\n    int *intArray = nullptr;    // pointer declarations to\n    collection *collectionArray = nullptr; // future arrays\n    cout << \"How many elements would you like? \" << flush;\n    cin >> numElements;\n    intArray = new int[numElements]; // alloc. array bodies\n    collectionArray = new collection[numElements];\n    // continued …\n```", "```cpp\n    // load each array with values\n    for (int i = 0; i < numElements; i++)\n    {\n        intArray[i] = i; // load each array w values using\n        collectionArray[i].x = i;  // array notation []\n        collectionArray[i].y = i + .5;\n        // alternatively use ptr notation to print values\n        cout << *(intArray + i) << \" \";\n        cout << (*(collectionArray + i)).y << endl;\n    }\n    delete [] intArray;     // mark memory for deletion\n    delete [] collectionArray;\n    return 0;\n}\n```", "```cpp\nHow many elements would you like? 3\n0 0.5\n1 1.5\n2 2.5\n```", "```cpp\n#include <iostream>\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::flush;\nconstexpr int NUMROWS = 5; // convention to use uppercase\n                    // since value is known at compile time\nint main()\n{\n    float *TwoDimArray[NUMROWS] = { }; // init. to nullptrs\n    int numColumns = 0;\n    cout << \"Enter number of columns: \";\n    cin >> numColumns;\n    for (int i = 0; i < NUMROWS; i++)\n    {\n        // allocate column quantity for each row\n        TwoDimArray[i] = new float [numColumns];\n        // load each column entry with data\n        for (int j = 0; j < numColumns; j++)\n        {\n            TwoDimArray[i][j] = i + j + .05;\n            cout << TwoDimArray[i][j] << \" \";\n        }\n        cout << endl;  // print newline between rows\n    }\n    for (int i = 0; i < NUMROWS; i++)\n        delete [] TwoDimArray[i];  // del col. for each row\n    return 0;\n}\n```", "```cpp\nEnter number of columns: 3\n0.05 1.05 2.05\n1.05 2.05 3.05\n2.05 3.05 4.05\n3.05 4.05 5.05\n4.05 5.05 6.05\n```", "```cpp\n#include <iostream>\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::flush;\nint main()\n{\n    int numRows = 0, numColumns = 0;\n    float **TwoDimArray = nullptr;  // pointer to a pointer\n    cout << \"Enter number of rows: \" << flush;\n    cin >> numRows;\n    TwoDimArray = new float * [numRows]; // alloc. row ptrs\n    cout << \"Enter number of Columns: \";\n    cin >> numColumns;\n    for (int i = 0; i < numRows; i++)\n    {\n        // allocate column quantity for each row\n        TwoDimArray[i] = new float [numColumns];\n        // load each column entry with data\n        for (int j = 0; j < numColumns; j++)\n        {\n            TwoDimArray[i][j] = i + j + .05;\n            cout << TwoDimArray[i][j] << \" \";\n        }\n        cout << end;  // print newline between rows\n    }\n    for (i = 0; i < numRows; i++)\n        delete [] TwoDimArray[i];  // del col. for each row\n    delete [] TwoDimArray;  // delete allocated rows\n    return 0;\n}\n```", "```cpp\nEnter number of rows: 3\nEnter number of columns: 4\n0.05 1.05 2.05 3.05\n1.05 2.05 3.05 4.05\n2.05 3.05 4.05 5.05\n```", "```cpp\n#include <iostream>\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::flush;\nint main()\n{\n    int dim1 = 0, dim2 = 0, dim3 = 0;\n    int ***ThreeDimArray = nullptr; // 3D dyn. alloc. array\n    cout << \"Enter dim 1, dim 2, dim 3: \";\n    cin >> dim1 >> dim2 >> dim3;\n    ThreeDimArray = new int ** [dim1]; // allocate dim 1\n    for (int i = 0; i < dim1; i++)\n    {\n        ThreeDimArray[i] = new int * [dim2]; // alloc dim 2\n        for (int j = 0; j < dim2; j++)\n        {\n            // allocate dim 3\n            ThreeDimArray[i][j] = new int [dim3];\n            for (int k = 0; k < dim3; k++)\n            {\n               ThreeDimArray[i][j][k] = i + j + k; \n               cout << ThreeDimArray[i][j][k] << \" \";\n            }\n            cout << endl;  // print '\\n' between dimensions\n        }\n        cout << end;  // print '\\n' between dimensions\n    }\n    for (int i = 0; i < dim1; i++)\n    {\n        for (int j = 0; j < dim2; j++)\n           delete [] ThreeDimArray[i][j]; // release dim 3\n        delete [] ThreeDimArray[i];  // release dim 2\n    }\n    delete [] ThreeDimArray;   // release dim 1\n    return 0;\n}\n```", "```cpp\nEnter dim1, dim2, dim3: 2 4 3\n0 1 2\n1 2 3\n2 3 4\n3 4 5\n1 2 3\n2 3 4\n3 4 5\n4 5 6\n```", "```cpp\nvoid TryToAddOne(int arg)\n{\n   arg++;\n}\nvoid AddOne(int *arg)\n{\n   (*arg)++;\n}\n```", "```cpp\n#include <iostream>\nusing std::cout;\nusing std::endl;\nvoid TryToAddOne(int); // function prototypes\nvoid AddOne(int *);\nint main()\n{\n   int x = 10, *y = nullptr;\n   y = new int;    // allocate y's memory\n   *y = 15;        // dereference y to assign a value\n   cout << \"x: \" << x << \" and *y: \" << *y << endl;\n   TryToAddOne(x);   // unsuccessful, call by value\n   TryToAddOne(*y);  // still unsuccessful\n   cout << \"x: \" << x << \" and *y: \" << *y << endl;\n   AddOne(&x);   // successful, passing an address \n   AddOne(y);    // also successful\n   cout << \"x: \" << x << \" and *y: \" << *y << endl;\n   delete y;     // relinquish heap memory\n   return 0;\n}\n```", "```cpp\nx: 10 and *y: 15\nx: 10 and *y: 15\nx: 11 and *y: 16\n```", "```cpp\n#include <iostream>\n#include <iomanip>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::flush;\nusing std::setw;\nconstexpr int MAX = 20;\n[[nodiscard]] char *createName();  // function prototype\nint main()    \n{\n   char *name = nullptr;   // pointer declaration and init.\n   name = createName();    // function will allocate memory\n   cout << \"Name: \" << name << endl;\n   delete [] name;  // del alloc. memory (in a diff. scope\n   return 0;   // than allocated); this can be error prone!\n}\n[[nodiscard]] char *createName()\n{\n   char *temp = new char[MAX];\n   cout << \"Enter name: \" << flush;\n   cin >> setw(MAX) >> temp; // ensure no overflow of temp\n   return temp;\n}\n```", "```cpp\nEnter name: Gabrielle\nName: Gabrielle\n```", "```cpp\n// const qualified str; the data pointed to will be const\nconst char *constData = \"constant\"; \nconst char *moreConstData = nullptr;  \n// regular strings, defined. One is loaded using strcpy()  \nchar *regularString = nullptr;\nchar *anotherRegularString = new char[8];  // sized to fit \n                                           // this string \nstrcpy(anotherRegularString, \"regular\");\n// Trying to modify data marked as const will not work\n// strcpy(constData, \"Can I do this? \");  // NO! \n// Trying to circumvent by having a char * point to\n// a const char * also will not work\n// regularString = constData; // NO! \n// But we can treat a char * more strictly by assigning to \n// const char *. It will be const from that viewpoint only\nmoreConstData = anotherRegularString; // Yes - can do this!\n```", "```cpp\n// Define, allocate, load simple strings using strcpy()\nchar *regularString = new char[36]; // sized for str below\nstrcpy(regularString, \"I am a modifiable string\");\nchar *anotherRegularString = new char[21]; // sized for\n                                           // string below\nstrcpy(anotherRegularString, \"I am also modifiable\");\n// Define a const pointer to a string; must be initialized\nchar *const constPtrString = regularString; // Ok\n// You may not modify a const pointer to point elsewhere\n// constPtrString = anotherRegularString;  // No! \n// But you may change the data which you point to\nstrcpy(constPtrString, \"I can change the value\"); // Yes\n```", "```cpp\n// Define two regular strings and load using strcpy()\nchar *regularString = new char[36]; // sized for str below\nstrcpy(regularString, \"I am a modifiable string\");\nchar *anotherRegularString = new char[21]; // sized for\n                                           // string below\nstrcpy(anotherRegularString, \"I am also modifiable\");\n// Define const ptr to a const object; must be initialized\nconst char *const constStringandPtr = regularString; // Ok \n// Trying to change the pointer or the data is illegal\nconstStringandPtr = anotherRegularString; // No! Can't \n                                          // modify address\nstrcpy(constStringandPtr, \"Nope\"); // No! Can't modify data\n```", "```cpp\n#include <iostream>\n#include <iomanip>\n#include <cstring>  // we'll generally prefer std::string, \n        // however, let's understand ptr concept shown here\nusing std::cout;\nusing std::endl;\nchar suffix = 'A';\nconst char *GenId(const char *);  // function prototype\nint main()    \n{\n    const char *newId1, *newId2;   // pointer declarations\n    newId1 = GenId(\"Group\");  // func. will allocate memory\n    newId2 = GenId(\"Group\");  \n    cout << \"New ids: \" << newId1 << \" \" << newId2 << endl;\n    delete [] newId1;  // delete allocated memory  \n    delete [] newId2;  // caution: deleting in different \n                       // scope than allocation can \n                       // lead to potential errors\n    return 0;\n}\nconst char *GenId(const char *base)\n{\n    char *temp = new char[strlen(base) + 2]; \n    strcpy(temp, base);  // use base to initialize string\n    temp[strlen(base)] = suffix++; // Append suffix to base\n    temp[strlen(base) + 1] = '\\0'; // Add null character\n    return temp; // temp will be upcast to a const char *\n                 // to be treated more restrictively than \n                 // it was defined\n}  \n```", "```cpp\nNew ids: GroupA GroupB\n```", "```cpp\n#include <iostream>\nusing std::cout;\nusing std::endl;\nint main()\n{\n    void *unspecified = nullptr; // may point to any \n                                 // data type\n    int *x = nullptr;\n    unspecified = new int; // void ptr now points to an int\n    // void * must be cast to int * before dereferencing\n    *(static_cast<int *>(unspecified)) = 89;\n    // let x point to the memory that unspecified points to\n    x = static_cast<int *>(unspecified);\n    cout << *x << \" \" << *(static_cast<int *>(unspecified)) \n         << endl;\n    delete static_cast<int *>(unspecified);\n    return 0;\n}\n```", "```cpp\n89 89\n```"]