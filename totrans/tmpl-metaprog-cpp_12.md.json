["```cpp\n// sorts a vector\n```", "```cpp\nstd::vector<int> v{ 1, 5, 3, 2, 4 };\n```", "```cpp\nstd::sort(v.begin(), v.end());\n```", "```cpp\n// counts even numbers in an array\n```", "```cpp\nstd::array<int, 5> a{ 1, 5, 3, 2, 4 };\n```", "```cpp\nauto even = std::count_if(\n```", "```cpp\n   a.begin(), a.end(), \n```", "```cpp\n   [](int const n) {return n % 2 == 0; });\n```", "```cpp\n// sorts a vector\n```", "```cpp\nstd::vector<int> v{ 1, 5, 3, 2, 4 };\n```", "```cpp\nsort(v);\n```", "```cpp\n// counts even numbers in an array\n```", "```cpp\nstd::array<int, 5> a{ 1, 5, 3, 2, 4 };\n```", "```cpp\nauto even = std::count_if(\n```", "```cpp\n   a, \n```", "```cpp\n   [](int const n) {return n % 2 == 0; });\n```", "```cpp\nstd::vector<int> v{ 1, 5, 3, 2, 8, 7, 6, 4 };\n```", "```cpp\n// copy only the even elements\n```", "```cpp\nstd::vector<int> temp;\n```", "```cpp\nstd::copy_if(v.begin(), v.end(), \n```", "```cpp\n             std::back_inserter(temp), \n```", "```cpp\n             [](int const n) {return n % 2 == 0; });\n```", "```cpp\n// sort the sequence\n```", "```cpp\nstd::sort(temp.begin(), temp.end(), \n```", "```cpp\n          [](int const a, int const b) {return a > b; });\n```", "```cpp\n// remove the first two\n```", "```cpp\ntemp.erase(temp.begin() + temp.size() - 2, temp.end());\n```", "```cpp\n// transform the elements\n```", "```cpp\nstd::transform(temp.begin(), temp.end(), \n```", "```cpp\n               temp.begin(),\n```", "```cpp\n               [](int const n) {return n * n; });\n```", "```cpp\n// print each element\n```", "```cpp\nstd::for_each(temp.begin(), temp.end(), \n```", "```cpp\n              [](int const n) {std::cout << n << '\\n'; });\n```", "```cpp\nstd::vector<int> v{ 1, 5, 3, 2, 8, 7, 6, 4 };\n```", "```cpp\nsort(v);\n```", "```cpp\nauto r = v\n```", "```cpp\n         | filter([](int const n) {return n % 2 == 0; })\n```", "```cpp\n         | drop(2)\n```", "```cpp\n         | reverse\n```", "```cpp\n         | transform([](int const n) {return n * n; });\n```", "```cpp\nfor_each(r, [](int const n) {std::cout << n << '\\n'; });\n```", "```cpp\nstd::vector<int> v{ 8, 5, 3, 2, 4, 7, 6, 1 };\n```", "```cpp\nauto r = std::views::iota(1, 10);\n```", "```cpp\nstd::cout << \"size(v)=\" << std::ranges::size(v) << '\\n';\n```", "```cpp\nstd::cout << \"size(r)=\" << std::ranges::size(r) << '\\n';\n```", "```cpp\nstd::cout << \"empty(v)=\" << std::ranges::empty(v) << '\\n';\n```", "```cpp\nstd::cout << \"empty(r)=\" << std::ranges::empty(r) << '\\n';\n```", "```cpp\nstd::cout << \"first(v)=\" << *std::ranges::begin(v) << '\\n';\n```", "```cpp\nstd::cout << \"first(r)=\" << *std::ranges::begin(r) << '\\n';\n```", "```cpp\nstd::cout << \"rbegin(v)=\" << *std::ranges::rbegin(v) \n```", "```cpp\n          << '\\n';\n```", "```cpp\nstd::cout << \"rbegin(r)=\" << *std::ranges::rbegin(r) \n```", "```cpp\n          << '\\n';\n```", "```cpp\nstd::cout << \"data(v)=\" << *std::ranges::data(v) << '\\n'; \n```", "```cpp\n// using the iota_view type\n```", "```cpp\nfor (auto i : std::ranges::iota_view(1, 10))\n```", "```cpp\n   std::cout << i << '\\n';\n```", "```cpp\n// using the iota variable template\n```", "```cpp\nfor (auto i : std::views::iota(1, 10))\n```", "```cpp\n   std::cout << i << '\\n';\n```", "```cpp\nconstexpr std::ranges::empty_view<int> ev;\n```", "```cpp\nstatic_assert(std::ranges::empty(ev));\n```", "```cpp\nstatic_assert(std::ranges::size(ev) == 0);\n```", "```cpp\nstatic_assert(std::ranges::data(ev) == nullptr);\n```", "```cpp\nconstexpr std::ranges::single_view<int> sv{42};\n```", "```cpp\nstatic_assert(!std::ranges::empty(sv));\n```", "```cpp\nstatic_assert(std::ranges::size(sv) == 1);\n```", "```cpp\nstatic_assert(*std::ranges::data(sv) == 42);\n```", "```cpp\nauto v1 = std::ranges::views::iota(1, 10);\n```", "```cpp\nstd::ranges::for_each(\n```", "```cpp\n     v1, \n```", "```cpp\n     [](int const n) {std::cout << n << '\\n'; });\n```", "```cpp\nauto v2 = std::ranges::views::iota(1) |\n```", "```cpp\n          std::ranges::views::take(9);\n```", "```cpp\nstd::ranges::for_each(\n```", "```cpp\n     v2,\n```", "```cpp\n     [](int const n) {std::cout << n << '\\n'; });\n```", "```cpp\nauto text = \"19.99 7.50 49.19 20 12.34\";\n```", "```cpp\nauto stream = std::istringstream{ text };\n```", "```cpp\nstd::vector<double> prices;\n```", "```cpp\ndouble price;\n```", "```cpp\nwhile (stream >> price)\n```", "```cpp\n{\n```", "```cpp\n   prices.push_back(price);\n```", "```cpp\n}\n```", "```cpp\nauto total = std::accumulate(prices.begin(), prices.end(), \n```", "```cpp\n                             0.0);\n```", "```cpp\nstd::cout << std::format(\"total: {}\\n\", total);\n```", "```cpp\nfor (double const price : \n```", "```cpp\n        std::ranges::istream_view<double>(stream))\n```", "```cpp\n{\n```", "```cpp\n   prices.push_back(price);\n```", "```cpp\n}\n```", "```cpp\nstd::ranges::for_each(\n```", "```cpp\n   std::ranges::istream_view<double>(stream),\n```", "```cpp\n   [&prices](double const price) {\n```", "```cpp\n      prices.push_back(price); });\n```", "```cpp\nnamespace rv = std::ranges::views;\n```", "```cpp\nstd::ranges::sort(v);\n```", "```cpp\nauto r = v\n```", "```cpp\n        | rv::filter([](int const n) {return n % 2 == 0; })\n```", "```cpp\n        | rv::drop(2)\n```", "```cpp\n        | rv::reverse\n```", "```cpp\n        | rv::transform([](int const n) {return n * n; });\n```", "```cpp\nstd::ranges::sort(v);auto r =\n```", "```cpp\n  rv::transform(\n```", "```cpp\n    rv::reverse(\n```", "```cpp\n      rv::drop(\n```", "```cpp\n        rv::filter(\n```", "```cpp\n          v,\n```", "```cpp\n          [](int const n) {return n % 2 == 0; }),\n```", "```cpp\n        2)),\n```", "```cpp\n    [](int const n) {return n * n; });\n```", "```cpp\n    std::vector<int> v{ 1, 5, 3, 2, 8, 7, 6, 4 };\n    namespace rv = std::ranges::views;\n    auto r1 = rv::reverse(v);\n    auto r2 = v | rv::reverse;\n    ```", "```cpp\n    std::vector<int> v{ 1, 5, 3, 2, 8, 7, 6, 4 };\n    namespace rv = std::ranges::views;\n    auto r1 = rv::take(v, 2);\n    auto r2 = rv::take(2)(v);\n    auto r3 = v | rv::take(2);\n    ```", "```cpp\n    std::vector<int> v{ 1, 5, 3, 2, 4, 7, 6, 8 };\n    for (auto i : v |\n      rv::reverse |\n      rv::filter([](int const n) {return n % 2 == 1; }) |\n      rv::take(2))\n    {\n       std::cout << i << '\\n'; // prints 7 and 3\n    }\n    ```", "```cpp\n    std::vector<int> v{ 1, 5, 3, 2, 4, 7, 16, 8 };\n    for (auto i : v |\n     rv::take_while([](int const n){return n < 10; }) |\n     rv::drop_while([](int const n){return n % 2 == 1; })\n    )\n    {\n       std::cout << i << '\\n'; // prints 2 4 7\n    }\n    ```", "```cpp\n    std::vector<std::tuple<int,double,std::string>> v = \n    { \n       {1, 1.1, \"one\"}, \n       {2, 2.2, \"two\"}, \n       {3, 3.3, \"three\"}\n    };\n    for (auto i : v | rv::keys)\n       std::cout << i << '\\n'; // prints 1 2 3\n    for (auto i : v | rv::values)\n       std::cout << i << '\\n'; // prints 1.1 2.2 3.3\n    for (auto i : v | rv::elements<2>)\n       std::cout << i << '\\n'; // prints one two three\n    ```", "```cpp\n    std::vector<std::vector<int>> v { \n       {1,2,3}, {4}, {5, 6}\n    };\n    for (int const i : v | rv::join)\n       std::cout << i << ' ';  // prints 1 2 3 4 5 6\n    ```", "```cpp\n    std::vector<std::vector<int>> v{\n       {1,2,3}, {4}, {5, 6}\n    };\n    for(int const i : v | rv::join_with(0))\n       std::cout << i << ' ';  // print 1 2 3 0 4 0 5 6\n    ```", "```cpp\n    std::string text{ \"this is a demo!\" };\n    constexpr std::string_view delim{ \" \" };\n    for (auto const word : text | rv::split(delim))\n    {\n       std::cout << std::string_view(word.begin(), \n                                     word.end()) \n                 << '\\n';\n    }\n    ```", "```cpp\n    std::array<int, 4> a {1, 2, 3, 4};\n    std::vector<double> v {10.0, 20.0, 30.0};\n    auto z = rv::zip(a, v)\n    // { {1, 10.0}, {2, 20.0}, {3, 30.0} }\n    ```", "```cpp\n    std::array<int, 4> a {1, 2, 3, 4};\n    std::vector<double> v {10.0, 20.0, 30.0};\n    auto z = rv::zip_transform(\n       std::multiplies<double>(), a, v)\n    // { {1, 10.0}, {2, 20.0}, {3, 30.0} }\n    ```", "```cpp\n    std::vector<int> v {1, 2, 3, 4};\n    for (auto i : v | rv::adjacent<2>)\n    {\n       // prints: (1, 2) (2, 3) (3, 4)\n       std::cout << std::format(\"({},{})\", \n                                i.first, i.second)\";\n    }\n    ```", "```cpp\n    std::vector<int> v {1, 2, 3, 4, 5};\n    for (auto i : v | rv::adjacent_transform<3>(\n        std::multiplies()))\n    {\n       std::cout << i << ' '; // prints: 3 24 60\n    }\n    ```", "```cpp\nauto l_odd = [](int const n) {return n % 2 == 1; };\n```", "```cpp\nstd::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\n```", "```cpp\nstd::vector<int> o;\n```", "```cpp\nauto e1 = std::copy_if(v.begin(), v.end(),\n```", "```cpp\n                       std::back_inserter(o),\n```", "```cpp\n                       l_odd);\n```", "```cpp\nint arr[] = { 1, 1, 2, 3, 5, 8, 13 };\n```", "```cpp\nauto e2 = std::copy_if(std::begin(arr), std::end(arr), \n```", "```cpp\n                       std::back_inserter(o), \n```", "```cpp\n                       l_odd);\n```", "```cpp\ntemplate <typename InputIt, typename OutputIt,\n```", "```cpp\n          typename UnaryPredicate>\n```", "```cpp\nconstexpr OutputIt copy_if(InputIt first, InputIt last,\n```", "```cpp\n                           OutputIt d_first,\n```", "```cpp\n                           UnaryPredicate pred);\n```", "```cpp\ntemplate <typename ExecutionPolicy,\n```", "```cpp\n          typename ForwardIt1, typename ForwardIt2,\n```", "```cpp\n          typename UnaryPredicate>\n```", "```cpp\nForwardIt2 copy_if(ExecutionPolicy&& policy,\n```", "```cpp\n                   ForwardIt1 first, ForwardIt1 last,\n```", "```cpp\n                   ForwardIt2 d_first,\n```", "```cpp\n                   UnaryPredicate pred);\n```", "```cpp\ntemplate <std::input_iterator I,\n```", "```cpp\n          std::sentinel_for<I> S,\n```", "```cpp\n          std::weakly_incrementable O,\n```", "```cpp\n          class Proj = std::identity,\n```", "```cpp\n          std::indirect_unary_predicate<\n```", "```cpp\n             std::projected<I, Proj>> Pred>\n```", "```cpp\nrequires std::indirectly_copyable<I, O>\n```", "```cpp\nconstexpr copy_if_result<I, O> copy_if(I first, S last,\n```", "```cpp\n                                       O result,\n```", "```cpp\n                                       Pred pred,\n```", "```cpp\n                                       Proj proj = {} );\n```", "```cpp\ntemplate <ranges::input_range R,\n```", "```cpp\n      std::weakly_incrementable O,\n```", "```cpp\n      class Proj = std::identity,\n```", "```cpp\n      std::indirect_unary_predicate<\n```", "```cpp\n      std::projected<ranges::iterator_t<R>, Proj>> Pred>\n```", "```cpp\nrequires std::indirectly_copyable<ranges::iterator_t<R>, O>\n```", "```cpp\nconstexpr copy_if_result<ranges::borrowed_iterator_t<R>, O>\n```", "```cpp\n          copy_if(R&& r,\n```", "```cpp\n                  O result,\n```", "```cpp\n                  Pred pred,\n```", "```cpp\n                  Proj proj = {});\n```", "```cpp\nstd::vector<int> v{ 1, 1, 2, 3, 5, 8, 13 };\n```", "```cpp\nstd::vector<int> o;\n```", "```cpp\nauto e1 = std::ranges::copy_if(v, std::back_inserter(o), \n```", "```cpp\n                               l_odd);\n```", "```cpp\nint arr[] = { 1, 1, 2, 3, 5, 8, 13 };\n```", "```cpp\nauto e2 = std::ranges::copy_if(arr, std::back_inserter(o), \n```", "```cpp\n                               l_odd);\n```", "```cpp\nauto r = std::ranges::views::iota(1, 10);\n```", "```cpp\nauto e3 = std::ranges::copy_if(r, std::back_inserter(o), \n```", "```cpp\n                               l_odd);\n```", "```cpp\nstruct Item\n```", "```cpp\n{\n```", "```cpp\n   int         id;\n```", "```cpp\n   std::string name;\n```", "```cpp\n   double      price;\n```", "```cpp\n};\n```", "```cpp\nstd::vector<Item> items{\n```", "```cpp\n   {1, \"pen\", 5.49},\n```", "```cpp\n   {2, \"ruler\", 3.99},\n```", "```cpp\n   {3, \"pensil case\", 12.50}\n```", "```cpp\n};\n```", "```cpp\nstd::vector<Item> copies;\n```", "```cpp\nstd::ranges::copy_if(\n```", "```cpp\n   items, \n```", "```cpp\n   std::back_inserter(copies),\n```", "```cpp\n   [](Item const& i) {return i.name[0] == 'p'; });\n```", "```cpp\nstd::vector<Item> copies;\n```", "```cpp\nstd::ranges::copy_if(\n```", "```cpp\n   items, \n```", "```cpp\n   std::back_inserter(copies),\n```", "```cpp\n   [](std::string const& name) {return name[0] == 'p'; },\n```", "```cpp\n   &Item::name);\n```", "```cpp\nstd::vector<std::string> names;\n```", "```cpp\nstd::ranges::copy_if(\n```", "```cpp\n   items | rv::transform(&Item::name),\n```", "```cpp\n   std::back_inserter(names),\n```", "```cpp\n   [](std::string const& name) {return name[0] == 'p'; });\n```", "```cpp\nfor (auto i : std::views::iota(1, 10) | views::step(1))\n```", "```cpp\n   std::cout << i << '\\n';\n```", "```cpp\nfor (auto i : std::views::iota(1, 10) | views::step(2))\n```", "```cpp\n   std::cout << i << '\\n';\n```", "```cpp\nfor (auto i : std::views::iota(1, 10) | views::step(3))\n```", "```cpp\n   std::cout << i << '\\n';\n```", "```cpp\nfor (auto i : std::views::iota(1, 10) | views::step(2) | \n```", "```cpp\n              std::views::take(3))\n```", "```cpp\n   std::cout << i << '\\n';\n```", "```cpp\ntemplate <typename R>\n```", "```cpp\nstruct step_iterator;\n```", "```cpp\ntemplate <typename R>\n```", "```cpp\nstruct step_sentinel\n```", "```cpp\n{\n```", "```cpp\n   using base      = std::ranges::iterator_t<R>;\n```", "```cpp\n   using size_type = std::ranges::range_difference_t<R>;\n```", "```cpp\n   step_sentinel() = default;\n```", "```cpp\n   constexpr step_sentinel(base end) : end_{ end } {}\n```", "```cpp\n   constexpr bool is_at_end(step_iterator<R> it) const;\n```", "```cpp\nprivate:\n```", "```cpp\n   base      end_;\n```", "```cpp\n};\n```", "```cpp\n// definition of the step_iterator type\n```", "```cpp\ntemplate <typename R>\n```", "```cpp\nconstexpr bool step_sentinel<R>::is_at_end(\n```", "```cpp\n   step_iterator<R> it) const\n```", "```cpp\n{\n```", "```cpp\n   return end_ == it.value();\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename R>\n```", "```cpp\nstruct step_iterator : std::ranges::iterator_t<R>\n```", "```cpp\n{\n```", "```cpp\n   using base\n```", "```cpp\n      = std::ranges::iterator_t<R>;\n```", "```cpp\n   using value_type\n```", "```cpp\n      = typename std::ranges::range_value_t<R>;\n```", "```cpp\n   using reference_type\n```", "```cpp\n      = typename std::ranges::range_reference_t<R>;\n```", "```cpp\n   constexpr step_iterator(\n```", "```cpp\n      base start, base end,\n```", "```cpp\n      std::ranges::range_difference_t<R> step) :\n```", "```cpp\n      pos_{ start }, end_{ end }, step_{ step }\n```", "```cpp\n   {\n```", "```cpp\n   }\n```", "```cpp\n   constexpr step_iterator operator++(int)\n```", "```cpp\n   {\n```", "```cpp\n      auto ret = *this;\n```", "```cpp\n      pos_ = std::ranges::next(pos_, step_, end_);\n```", "```cpp\n      return ret;\n```", "```cpp\n   }\n```", "```cpp\n   constexpr step_iterator& operator++()\n```", "```cpp\n   {\n```", "```cpp\n      pos_ = std::ranges::next(pos_, step_, end_);\n```", "```cpp\n      return *this;\n```", "```cpp\n   }\n```", "```cpp\n   constexpr reference_type operator*() const\n```", "```cpp\n   {\n```", "```cpp\n      return *pos_;\n```", "```cpp\n   }\n```", "```cpp\n   constexpr bool operator==(step_sentinel<R> s) const\n```", "```cpp\n   {\n```", "```cpp\n      return s.is_at_end(*this);\n```", "```cpp\n   }\n```", "```cpp\n   constexpr base const value() const { return pos_; }\n```", "```cpp\nprivate:\n```", "```cpp\n   base                                pos_;\n```", "```cpp\n   base                                end_;\n```", "```cpp\n   std::ranges::range_difference_t<R>  step_;\n```", "```cpp\n};\n```", "```cpp\nnamespace details\n```", "```cpp\n{\n```", "```cpp\n   using test_range_t = \n```", "```cpp\n      std::ranges::views::all_t<std::vector<int>>;\n```", "```cpp\n   static_assert(\n```", "```cpp\n      std::input_iterator<step_iterator<test_range_t>>);\n```", "```cpp\n   static_assert(\n```", "```cpp\n      std::sentinel_for<step_sentinel<test_range_t>, \n```", "```cpp\n      step_iterator<test_range_t>>);\n```", "```cpp\n}\n```", "```cpp\ntemplate<std::ranges::view R>\n```", "```cpp\nstruct step_view : \n```", "```cpp\n   public std::ranges::view_interface<step_view<R>>\n```", "```cpp\n{\n```", "```cpp\nprivate:\n```", "```cpp\n   R                                   base_;\n```", "```cpp\n   std::ranges::range_difference_t<R>  step_;\n```", "```cpp\npublic:\n```", "```cpp\n   step_view() = default;\n```", "```cpp\n   constexpr step_view(\n```", "```cpp\n      R base,\n```", "```cpp\n      std::ranges::range_difference_t<R> step)\n```", "```cpp\n         : base_(std::move(base))\n```", "```cpp\n         , step_(step)\n```", "```cpp\n   {\n```", "```cpp\n   }\n```", "```cpp\n   constexpr R base() const&\n```", "```cpp\n      requires std::copy_constructible<R>\n```", "```cpp\n   { return base_; }\n```", "```cpp\n   constexpr R base()&& { return std::move(base_); }\n```", "```cpp\n   constexpr std::ranges::range_difference_t<R> const& increment() const \n```", "```cpp\n   { return step_; }\n```", "```cpp\n   constexpr auto begin()\n```", "```cpp\n   {\n```", "```cpp\n      return step_iterator<R const>(\n```", "```cpp\n         std::ranges::begin(base_),\n```", "```cpp\n         std::ranges::end(base_), step_);\n```", "```cpp\n   }\n```", "```cpp\n   constexpr auto begin() const \n```", "```cpp\n   requires std::ranges::range<R const>\n```", "```cpp\n   {\n```", "```cpp\n      return step_iterator<R const>(\n```", "```cpp\n         std::ranges::begin(base_),\n```", "```cpp\n         std::ranges::end(base_), step_);\n```", "```cpp\n   }\n```", "```cpp\n   constexpr auto end()\n```", "```cpp\n   {\n```", "```cpp\n      return step_sentinel<R const>{ \n```", "```cpp\n         std::ranges::end(base_) };\n```", "```cpp\n   }\n```", "```cpp\n   constexpr auto end() const \n```", "```cpp\n   requires std::ranges::range<R const>\n```", "```cpp\n   {\n```", "```cpp\n      return step_sentinel<R const>{ \n```", "```cpp\n         std::ranges::end(base_) };\n```", "```cpp\n   }\n```", "```cpp\n   constexpr auto size() const \n```", "```cpp\n   requires std::ranges::sized_range<R const>\n```", "```cpp\n   {\n```", "```cpp\n      auto d = std::ranges::size(base_); \n```", "```cpp\n      return step_ == 1 ? d : \n```", "```cpp\n         static_cast<int>((d + 1)/step_); }\n```", "```cpp\n   constexpr auto size() \n```", "```cpp\n   requires std::ranges::sized_range<R>\n```", "```cpp\n   {\n```", "```cpp\n      auto d = std::ranges::size(base_); \n```", "```cpp\n      return step_ == 1 ? d : \n```", "```cpp\n         static_cast<int>((d + 1)/step_);\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\ntemplate<class R>\n```", "```cpp\nstep_view(R&& base, \n```", "```cpp\n          std::ranges::range_difference_t<R> step)\n```", "```cpp\n   -> step_view<std::ranges::views::all_t<R>>;\n```", "```cpp\nnamespace details\n```", "```cpp\n{\n```", "```cpp\n   struct step_view_fn_closure\n```", "```cpp\n   {\n```", "```cpp\n      std::size_t step_;\n```", "```cpp\n      constexpr step_view_fn_closure(std::size_t step)\n```", "```cpp\n         : step_(step)\n```", "```cpp\n      {\n```", "```cpp\n      }\n```", "```cpp\n      template <std::ranges::range R>\n```", "```cpp\n      constexpr auto operator()(R&& r) const\n```", "```cpp\n      {\n```", "```cpp\n         return step_view(std::forward<R>(r), step_);\n```", "```cpp\n      }\n```", "```cpp\n   };\n```", "```cpp\n   template <std::ranges::range R>\n```", "```cpp\n   constexpr auto operator | (R&& r, \n```", "```cpp\n                              step_view_fn_closure&& a)\n```", "```cpp\n   {\n```", "```cpp\n      return std::forward<step_view_fn_closure>(a)(\n```", "```cpp\n         std::forward<R>(r));\n```", "```cpp\n   }\n```", "```cpp\n}\n```", "```cpp\nnamespace details\n```", "```cpp\n{\n```", "```cpp\n   struct step_view_fn\n```", "```cpp\n   {\n```", "```cpp\n      template<std::ranges::range R>\n```", "```cpp\n      constexpr auto operator () (R&& r, \n```", "```cpp\n                                  std::size_t step) const\n```", "```cpp\n      {\n```", "```cpp\n         return step_view(std::forward<R>(r), step);\n```", "```cpp\n      }\n```", "```cpp\n      constexpr auto operator () (std::size_t step) const\n```", "```cpp\n      {\n```", "```cpp\n         return step_view_fn_closure(step);\n```", "```cpp\n      }\n```", "```cpp\n   };\n```", "```cpp\n}\n```", "```cpp\nnamespace views\n```", "```cpp\n{\n```", "```cpp\n   inline constexpr details::step_view_fn step;\n```", "```cpp\n}\n```"]