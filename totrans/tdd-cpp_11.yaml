- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Managing Dependencies
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理依赖关系
- en: 'Identifying dependencies and implementing your code around common interfaces
    that the dependencies use will help you in many ways. You’ll be able to do the
    following things:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 识别依赖关系并在依赖关系使用的公共接口周围实现您的代码将有助于您以多种方式。您将能够做到以下事情：
- en: Avoid waiting for another team or even yourself to finish a complicated and
    necessary component
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免等待其他团队或甚至自己完成复杂且必要的组件
- en: Isolate your code and make sure it works, even if there are bugs in other code
    that you use
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的代码隔离并确保其正常工作，即使您使用的其他代码中存在错误
- en: Achieve greater flexibility with your designs so that you can change the behavior
    by simply changing dependent components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过您的设计实现更大的灵活性，以便您只需更改依赖组件即可更改行为
- en: Create interfaces that clearly document and highlight essential requirements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建接口，清晰地记录并突出关键要求
- en: In this chapter, you’ll learn what dependencies are and how to design your code
    to use them. By the end of this chapter, you’ll learn how to finish writing your
    code faster and prove that it works, even if the rest of the project is not ready
    for it yet.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解依赖关系是什么以及如何设计您的代码来使用它们。到本章结束时，您将了解如何更快地完成代码编写并证明其工作，即使项目的其余部分尚未准备好也是如此。
- en: You don’t need to be using TDD to design and use dependencies. But if you are
    using TDD, then the whole process becomes even better because you’ll also be able
    to write better tests that can focus on specific areas of code without worrying
    about extra complexity and bugs coming from outside the code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要使用TDD来设计和使用依赖关系。但如果您正在使用TDD，那么整个过程将变得更好，因为您还将能够编写更好的测试，这些测试可以专注于代码的特定区域，而无需担心来自代码外部的额外复杂性和错误。
- en: 'This chapter will cover the following main topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Designing with dependencies
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于依赖进行设计
- en: Adding multiple logging outputs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加多个日志输出
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All code in this chapter uses standard C++ that builds on any modern C++ 20
    or later compiler and standard library. The code uses the testing library from
    *Part 1*, *Testing MVP*, of this book and continues the development of a logging
    library started in the previous chapters.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有代码都使用基于任何现代C++ 20或更高版本编译器和标准库的标准C++。代码使用了本书*第1部分*，*测试MVP*中提到的测试库，并继续开发在前面章节中开始的日志库。
- en: 'You can find all the code for this chapter in the following GitHub repository:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下GitHub仓库中找到本章所有代码：
- en: '[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)'
- en: )
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: Designing with dependencies
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于依赖进行设计
- en: Dependencies are not always obvious. If a project uses a library, such as how
    the logging project uses the unit test library, then that’s an easy dependency
    to spot. The logging project depends on the unit test library to function correctly.
    Or in this case, only the logging tests depend on the unit test library. But that’s
    enough to form a dependency.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系并不总是显而易见的。如果一个项目使用库，例如日志项目如何使用单元测试库，那么这是一个容易发现的依赖关系。日志项目依赖于单元测试库以正确运行。或者在这种情况下，只有日志测试依赖于单元测试库。但这已经足够形成一个依赖关系。
- en: Another easy dependency to spot is if you need to call another service. Even
    if the code checks to see if the other service is available first before making
    a call, the dependency still exists.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个容易发现的依赖关系是如果您需要调用另一个服务。即使代码在调用之前检查其他服务是否可用，依赖关系仍然存在。
- en: Libraries and services are good examples of *external dependencies*. You have
    to do extra work to get a project to use the code or services of another project,
    which is why an external dependency is so easy to spot.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 库和服务是*外部依赖关系*的好例子。您必须做额外的工作才能使项目使用另一个项目的代码或服务，这就是为什么外部依赖关系如此容易被发现。
- en: Other dependencies are harder to spot, and these are usually *internal dependencies*
    within the project. In a way, almost all the code in a project depends on the
    rest of the code doing what it’s supposed to do. So let’s refine what we mean
    by a dependency. Normally, when a dependency is mentioned, as it relates to code
    design, we refer to something that can be exchanged.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 其他依赖关系更难发现，这些通常是项目内部的*内部依赖关系*。从某种意义上说，项目中的几乎所有代码都依赖于其他代码正确执行其预期功能。因此，让我们细化一下我们对依赖关系的理解。通常，当提到依赖关系时，与代码设计相关，我们指的是可以交换的东西。
- en: This might be easiest to understand with the external service dependency example.
    The service operates on its own with a well-defined interface. You make a request
    to a service based on its location or address using the interface that the service
    defines. You could instead call a different service for the same request if the
    first service is not available. Ideally, the two services would use the same interface
    so that the only thing your code needs to change is the address.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能通过外部服务依赖的例子最容易理解。该服务在自己的接口上运行。你使用服务定义的接口，根据其位置或地址向服务发出请求。如果第一个服务不可用，你可以为相同的请求调用不同的服务。理想情况下，两个服务会使用相同的接口，这样你代码需要更改的只有地址。
- en: If the two services use different interfaces, then it might make sense to create
    a wrapper for each service that knows how to translate between what each service
    expects and a *common interface* that your code will use. With a common interface,
    you can swap one service for another without changing your code. Your code depends
    on the service interface definition more than any specific service.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个服务使用不同的接口，那么为每个服务创建一个包装器可能是有意义的，这个包装器知道如何将每个服务期望的内容翻译成你的代码将使用的*通用接口*。有了通用接口，你可以交换一个服务为另一个服务，而无需更改代码。你的代码更多地依赖于服务接口定义，而不是任何特定的服务。
- en: If we look at internal design decisions, maybe there is a base class and a derived
    class. The derived class definitely depends on the base class, but this is not
    the type of dependency that can be changed without rewriting the code to use a
    different base class.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看内部设计决策，可能有一个基类和一个派生类。派生类肯定依赖于基类，但这种依赖类型不能在不重写代码以使用不同的基类的情况下更改。
- en: We get closer to a dependency that can be swapped when considering the tags
    that the logging library defines. New tags can be defined and used without changing
    existing code. And the logging library can use any tag without worrying about
    what each tag does. But are we really swapping out tags? To me, the tags were
    designed to solve the problem of logging key=value elements in the log file in
    a consistent manner that does not depend on the data type of the value. Even though
    the logging library depends on tags and the interface they use, I wouldn’t classify
    the tag design as the same type of dependency as the external service.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑日志库定义的标签时，我们更接近可以替换的依赖。可以定义新的标签并使用它们，而无需更改现有代码。日志库可以使用任何标签，无需担心每个标签的作用。但我们是真的在替换标签吗？对我来说，标签的设计是为了在日志文件中以一致的方式解决日志键=值元素的问题，而不依赖于值的类型。尽管日志库依赖于标签及其使用的接口，但我不会将标签设计归类为与外部服务相同的依赖类型。
- en: I mentioned early on when thinking about the logging library that we will need
    the ability to send the log information to different destinations, or maybe even
    multiple destinations. The code uses the `log` function and expects it to either
    be ignored or to go somewhere. The ability to send a log message to a specific
    destination is a dependency that the logging library needs to rely on. The logging
    library should let the project doing the logging decide on the destination.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期思考日志库时，我提到过我们需要能够将日志信息发送到不同的目的地，或者甚至多个目的地。代码使用`log`函数，并期望它要么被忽略，要么发送到某个地方。将日志消息发送到特定目的地的能力是日志库需要依赖的。日志库应该让执行日志的项目决定目的地。
- en: And this brings us to another aspect of dependencies. A dependency is often
    something that is configured. What I mean is that we can say that the logging
    library depends on some component to perform the task of sending a message to
    a destination. The logging library can be designed to choose its own destination,
    or the logging library can be told what dependency to use. When we let other code
    control the dependencies, we get something called *dependency injection*. You
    get a more flexible solution when you let the calling code inject dependencies.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了依赖关系的另一个方面。依赖通常是指配置过的某些东西。我的意思是，我们可以这样说，日志库依赖于某些组件来执行将消息发送到目的地的任务。日志库可以被设计成选择自己的目的地，或者日志库可以被告知使用哪个依赖。当我们让其他代码控制依赖时，我们得到的是所谓的*依赖注入*。当你允许调用代码注入依赖时，你会得到一个更灵活的解决方案。
- en: 'Here’s some initial code that I put into the `main` function to configure a
    component that knows how to send log messages to a file and then inject the file
    component into the logger so that the logger will know where to send the log messages:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我放入 `main` 函数中的初始代码，用于配置一个知道如何将日志消息发送到文件的组件，然后将文件组件注入到日志记录器中，以便日志记录器知道将日志消息发送到何处：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The idea is to create a class called `FileOutput` and give it the name of the
    file to write log messages. Because we don’t want log files to get too big, we
    should be able to specify a maximum size. The code uses 10 million bytes for the
    maximum size. What do we do when a log file reaches the maximum size? We should
    stop writing to that file and create a new file. We should be able to specify
    how many log files to create before we start deleting old log files. The code
    sets the maximum number of log files to five.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是创建一个名为 `FileOutput` 的类，并给它提供写入日志消息的文件名。因为我们不希望日志文件变得太大，所以我们应该能够指定最大大小。代码使用
    1000 万字节作为最大大小。当日志文件达到最大大小时，我们应该停止向该文件写入，并创建一个新的文件。我们应该能够在开始删除旧文件之前指定要创建的日志文件数量。代码将最大日志文件数设置为五个。
- en: Once the `FileOutput` instance is created and configured the way we want, it
    is injected into the logging library by calling the `addLogOutput` function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建并配置好我们想要的 `FileOutput` 实例，就可以通过调用 `addLogOutput` 函数将其注入到日志库中。
- en: Will this code meet our needs? Is it intuitive and easy to understand? Even
    though this is not a test, we’re still following TDD by concentrating on the usage
    of a new feature before writing the code to implement the new feature.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码能满足我们的需求吗？它是否直观且易于理解？尽管这不是一个测试，但我们仍然通过在编写实现新功能的代码之前专注于新功能的用法来遵循 TDD。
- en: As for meeting our needs, that’s not really the right question to ask. We need
    to ask if it will meet the needs of our target customer. We’re designing the logging
    library to be used by a micro-services developer. There might be hundreds of services
    running on a server computer and we really should place the log files in a specific
    location. The first change we’ll need is to let the caller specify a path where
    the log files should be created. The path seems like it should be separate from
    the filename.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 至于满足我们的需求，这并不是真正需要问的问题。我们需要问的是它是否能够满足我们目标客户的需求。我们正在设计一个日志库，供微服务开发者使用。可能有数百个服务在服务器计算机上运行，我们真的应该将日志文件放在特定的位置。我们需要的第一个更改是让调用者指定日志文件应该创建的路径。路径似乎应该与文件名分开。
- en: 'And for the filenames, how will we name multiple log files? They can’t all
    be called `application.log`. Should the files be numbered? They will all be placed
    in the same directory and the only requirement that the filesystem needs is that
    each file has a unique name. We need to let the caller provide a pattern for the
    log filenames instead of a single filename. A pattern will let the logging library
    know how to make the name unique while still following the overall naming style
    that the developer wants. We can change the initial code to look like this instead:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文件名，我们将如何命名多个日志文件？它们不能都叫 `application.log`。文件应该编号吗？它们都将放在同一个目录中，文件系统唯一的要求是每个文件都有一个唯一的名称。我们需要让调用者提供日志文件名的模式，而不是单个文件名。一个模式将让日志库知道如何使名称唯一，同时仍然遵循开发者想要的总体命名风格。我们可以将初始代码更改为如下：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When designing a class, it’s a good idea to make the class work with reasonable
    defaults after construction. For file output, the bare minimum we need is the
    directory to create the log files. The other properties are nice but not required.
    If the name pattern is not provided, we can default to a simple unique number.
    The max size can have an unlimited default, or at least a really big number. And
    we only need a single log file. So, the rollover count can be some value that
    tells us to use a single file.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计一个类时，在构造后让类以合理的默认值工作是一个好主意。对于文件输出，我们需要的最基本的是创建日志文件的目录。其他属性很好，但不是必需的。如果没有提供名称模式，我们可以默认为简单的唯一数字。最大大小可以有一个无限默认值，或者至少一个非常大的数字。我们只需要一个日志文件。因此，轮换计数可以是一个告诉我们使用单个文件的值。
- en: I decided to use simple open and close curly braces `{}` for the placeholder
    in the pattern where a unique number will be placed. We’ll just pick a random
    three-digit number to make the log filename unique. That will give us up to a
    thousand log files, which should be more than enough. Most users will only want
    to keep a handful and delete older files.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定使用简单的花括号 `{}` 作为模式中的占位符，其中将放置一个唯一的数字。我们将随机选择一个三位数来使日志文件名唯一。这将给我们提供多达一千个日志文件，这应该足够了。大多数用户可能只想保留少数几个，并删除较旧的文件。
- en: 'Because the output is a dependency that can be swapped or even have multiple
    outputs at the same time, what would a different type of output look like? We’ll
    figure out what the output dependency component interface will be later. For now,
    we just want to explore how to use different outputs. Here is how output can be
    sent to the `std::cout` console:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因为输出是一个可以被替换的依赖，甚至可以同时有多个输出，那么不同类型的输出会是什么样子呢？我们将在稍后确定输出依赖组件接口。现在，我们只想探索如何使用不同的输出。以下是输出如何发送到
    `std::cout` 控制台的方式：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The console output is an ostream so we should be able to create a stream output
    that can work with any ostream. This example creates an output component called
    `consoleStream`, which can be added to the log output just like the file output.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出是一个 ostream，因此我们应该能够创建一个可以与任何 ostream 一起工作的流输出。这个例子创建了一个名为 `consoleStream`
    的输出组件，它可以像文件输出一样添加到日志输出中。
- en: When using TDD, it’s important to avoid interesting features that may not really
    be needed by the customer. We’re not going to add the ability to remove outputs.
    Once an output is added to the logging library, it will remain. In order to remove
    an output, we’d have to return some sort of identifier that can be used to later
    remove the same output that was added. We did add the ability to remove filter
    clauses because that ability seemed likely to be needed. Removing outputs is something
    that seems unlikely for most customers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 TDD 时，避免添加可能并非客户真正需要的有趣特性是很重要的。我们不会添加删除输出的功能。一旦输出被添加到日志库中，它将保持不变。为了删除输出，我们可能需要返回某种标识符，以便稍后删除之前添加的相同输出。我们确实添加了删除过滤条件的能力，因为这看起来可能是需要的。对于大多数客户来说，删除输出似乎不太可能。
- en: 'In order to design a dependency that can be swapped for another, we’ll need
    a common interface class that all outputs implement. The class will be called
    `Output` and goes in `Log.h` right before the `LogStream` class, like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计一个可以被其他依赖替换的依赖，我们需要一个所有输出都实现的公共接口类。这个类将被命名为 `Output`，并放置在 `Log.h` 文件中，紧挨着
    `LogStream` 类之前，如下所示：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The only methods that are part of the interface are the `clone` and the `sendLine`
    methods. We’ll follow a similar cloning pattern as the tags, except we’re not
    going to use templates. The `sendLine` method will be called whenever a line of
    text needs to be sent to the output. The other methods make sure that nobody can
    construct instances of `Output` directly or copy or assign one `Output` instance
    to another. The `Output` class is designed to be inherited from.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中仅包含 `clone` 和 `sendLine` 方法。我们将遵循与标签类似的克隆模式，但不会使用模板。`sendLine` 方法将在需要将一行文本发送到输出时被调用。其他方法确保没有人可以直接构造
    `Output` 的实例，或者复制或分配一个 `Output` 实例到另一个实例。`Output` 类被设计为可以被继承的。
- en: 'We’ll keep track of all the outputs that have been added with the next two
    functions, which go right after the `Output` class like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过接下来的两个函数来跟踪所有已添加的输出，这两个函数紧随 `Output` 类之后，如下所示：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `getOutputs` function uses a static vector of unique pointers and returns
    the collection when requested. The `addLogOutput` function adds a clone of the
    given output to the collection. This is all similar to how the default tags are
    handled.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`getOutputs` 函数使用一个静态的唯一指针向量，并在请求时返回集合。`addLogOutput` 函数将给定输出的克隆添加到集合中。这都与默认标签的处理方式相似。'
- en: One interesting use of dependencies that you should be aware of is their ability
    to swap out a real component for a fake component. We’re adding two real components
    to manage the logging output. One will send output to a file and the other to
    the console. But you can also use dependencies if you want to make progress on
    your code and are waiting for another team to finish writing a needed component.
    Instead of waiting, make the component a dependency that you can swap out for
    a simpler version. The simpler version is not a real version, but it should be
    faster to write and let you continue making progress until the real version becomes
    available.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该知道的一个有趣的依赖关系的使用是它们能够用一个假组件替换一个真实组件的能力。我们正在添加两个真实组件来管理日志输出。一个将输出到文件，另一个到控制台。但是，如果你想在你代码的进展上取得进展，而正在等待另一个团队完成编写所需的组件时，你也可以使用依赖关系。与其等待，不如将组件设置为依赖关系，你可以用更简单的版本替换它。这个更简单的版本不是真实版本，但它应该更快编写，并让你继续取得进展，直到真实版本可用。
- en: Some other testing libraries take this fake dependency ability a step further
    and let you create components with just a few lines of code that respond in various
    ways that you can control. This lets you isolate your code and make sure it behaves
    as it should because you can rely on the fake dependency to always behave as specified,
    and you no longer have to worry about bugs in the real dependency affecting the
    results of your tests. The common term for these fake components is *mocks*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他的测试库将这种假依赖关系的能力更进一步，并允许你用几行代码创建可以以各种方式响应的组件，这些方式你可以控制。这让你可以隔离你的代码，并确保它按预期行为，因为你可以依赖假依赖关系始终按指定方式行为，你也不再需要担心真实依赖关系中的错误会影响测试结果。这些假组件的通用术语是*模拟*。
- en: It doesn’t matter if you are using a testing library that generates a mock for
    you with a few lines of code or if you are writing your own mock. Anytime you
    have a class that imitates another class, you have a mock.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是使用一个通过几行代码为你生成模拟的测试库，还是你自己编写模拟，都没有关系。任何时候，当你有一个模仿另一个类的类时，你就有了一个模拟。
- en: Other than isolating your code from bugs, a mock can also help speed up your
    tests and improve collaboration with other teams. The speed is improved because
    the real code might need to spend time requesting or calculating a result, while
    the mock can return quickly without the need to do any real work. Collaboration
    with other teams is improved because everybody can agree to simple mocks that
    are quick to develop and can be used to communicate design changes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将你的代码与错误隔离之外，模拟还可以帮助你加快测试速度，并改善与其他团队的协作。速度的提高是因为真实代码可能需要花费时间请求或计算结果，而模拟可以快速返回，无需进行任何实际工作。与其他团队的协作得到改善，因为每个人都可以同意简单的模拟，这些模拟易于开发，可以用来传达设计变更。
- en: The next section will implement the file and stream output classes based on
    the common interface. We’ll be able to simplify the `LogStream` class and the
    `log` function to use the common interface, which will document and make it easier
    to understand what is really needed to send log messages to an output.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将实现基于通用接口的文件和流输出类。我们将能够简化 `LogStream` 类和 `log` 函数，以使用通用接口，这将记录并使理解发送日志消息到输出的真正需求变得更加容易。
- en: Adding multiple logging outputs
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加多个日志输出
- en: A good way to validate that a design works with multiple scenarios is to implement
    solutions for each scenario. We have a common `Output` interface class that defines
    two methods, `clone` and `sendLine`, and we need to make sure this interface will
    work for sending log messages to a log file and to the console.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 验证设计是否适用于多种场景的一个好方法是实现每个场景的解决方案。我们有一个通用的 `Output` 接口类，它定义了两个方法，`clone` 和 `sendLine`，我们需要确保这个接口将适用于将日志消息发送到日志文件和到控制台。
- en: 'Let’s start with a class called `FileOutput` that inherits from `Output`. The
    new class goes in `Log.h` right after the `getOutputs` and the `addLogOutput`
    functions, like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从继承自 `Output` 的一个名为 `FileOutput` 的类开始。新类放在 `Log.h` 中，紧接在 `getOutputs` 和 `addLogOutput`
    函数之后，如下所示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `FileOutput` class follows the usage that was determined in the previous
    section, which looks like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileOutput` 类遵循上一节中确定的用法，如下所示：'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We give the `FileOutput` class a directory in the constructor where the log
    files will be saved. The class also supports a name pattern, a max log file size,
    and a rollover count. All the data members need to be initialized in the constructors
    and we have three constructors.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构造函数中给`FileOutput`类一个目录，日志文件将保存在那里。该类还支持名称模式、最大日志文件大小和滚动计数。所有数据成员都需要在构造函数中初始化，我们有三个构造函数。
- en: The first constructor is a normal constructor that accepts the directory and
    gives default values to the other data members.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个构造函数是一个普通构造函数，它接受目录并为其他数据成员提供默认值。
- en: The second constructor is the copy constructor, and it initializes the data
    members based on the values in the other instance of `FileOutput`. Only the `mFile`
    data member is left in a default state because we don’t copy fstreams.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个构造函数是复制构造函数，它根据`FileOutput`的另一个实例中的值初始化数据成员。只有`mFile`数据成员保留在默认状态，因为我们没有复制`fstream`。
- en: The third constructor is the move copy constructor, and it looks almost identical
    to the copy constructor. The only difference is that we now move the fstream into
    the `FileOutput` class being constructed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个构造函数是移动复制构造函数，它看起来几乎与复制构造函数相同。唯一的区别是我们现在将`fstream`移动到正在构建的`FileOutput`类中。
- en: The destructor will close the output file. This is actually a big improvement
    over what was done up to this point. We used to open and close the output file
    each time a log message was made. We’ll now open the log file and keep it open
    until we need to close it at a later time. The destructor makes sure that the
    log file gets closed if it hasn’t already been closed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数将关闭输出文件。这实际上是对之前所做工作的重大改进。我们过去每次记录日志消息时都会打开和关闭输出文件。现在我们将打开日志文件并保持打开状态，直到我们稍后需要关闭它。析构函数确保如果日志文件尚未关闭，则将其关闭。
- en: Next is the `clone` method, which calls the copy constructor to create a new
    instance that gets sent back as a unique pointer to the base class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`clone`方法，它调用复制构造函数来创建一个新的实例，并将其作为基类的唯一指针返回。
- en: The `sendLine` method is the last method, and it needs to check whether the
    output file has been opened already or not before sending the line to the file.
    We’ll add the ending newline here after each line gets sent to the output file.
    We also flush the log file after every line, which helps to make sure that the
    log file contains everything written to it in case the application doing the logging
    crashes suddenly.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendLine`方法是最后一个方法，在将行发送到文件之前，它需要检查输出文件是否已经打开。我们将在每行发送到输出文件后添加结束换行符。我们还每行刷新日志文件，这有助于确保在应用程序突然崩溃的情况下，日志文件包含所有写入的内容。'
- en: 'The last thing we need to do in the `FileOutput` class is to define the data
    members. We’re not going to fully implement all the data members though. For example,
    you can see that we’re still opening a file called `application.log` instead of
    following the naming pattern. We have the basic idea already and skipping the
    data members will let us test this part to make sure we haven’t broken anything.
    We’ll need to comment out the configuration in the `main` function, so it looks
    like this for now:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FileOutput`类中，我们需要做的最后一件事是定义数据成员。我们不会完全实现所有数据成员。例如，你可以看到我们仍然在打开一个名为`application.log`的文件，而不是遵循命名模式。我们已经有了基本想法，跳过数据成员将使我们能够测试这部分，以确保我们没有破坏任何东西。我们需要在`main`函数中注释掉配置，所以现在看起来是这样的：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can always come back to the configuration methods and the directory later
    once we get the multiple outputs working in a basic manner. This follows the TDD
    practice of doing as little as possible each step along the way. In a way, what
    we’re doing is creating a mock for the ultimate `FileOutput` class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们以基本方式使多个输出工作，我们就可以随时返回配置方法和目录。这遵循了TDD实践，即每一步尽可能少做。从某种意义上说，我们正在为最终的`FileOutput`类创建一个模拟。
- en: 'I almost forgot to mention that because we’re using `filesystem` features,
    such as `path`, we need to include `filesystem` at the top of `Log.h`, like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我差点忘了提，因为我们使用了`filesystem`功能，例如`path`，所以我们需要在`Log.h`的顶部包含`filesystem`，如下所示：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ll make use of `filesystem` more once we start rolling log files over into
    new files instead of always opening the same file each time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始将日志文件滚动到新文件而不是每次都打开相同的文件时，我们将更多地使用`filesystem`。
- en: 'Next is the `StreamOutput` class, which can go in `Log.h` right after the `FileOutput`
    class and looks like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`StreamOutput`类，它可以直接放在`FileOutput`类后面`Log.h`中，如下所示：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `StreamOutput` class is simpler than the `FileOutput` class because it
    has fewer data members. We only need to keep track of an ostream reference that
    gets passed in the constructor in `main`. We also don’t need to worry about a
    specific move copy constructor because we can easily copy the ostream reference.
    The `StreamOutput` class was already added in `main` like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamOutput`类比`FileOutput`类简单，因为它具有更少的数据成员。我们只需要跟踪在`main`中的构造函数中传入的ostream引用。我们也不需要担心特定的移动复制构造函数，因为我们可以轻松地复制ostream引用。`StreamOutput`类已经在`main`中添加，如下所示：'
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `StreamOutput` class will hold a reference to `std::cout` that `main` passes
    to it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamOutput`类将持有`main`传递给它的`std::cout`的引用。'
- en: 'Now that we’re working with the output interface, we no longer need to manage
    a file in the `LogStream` class. The constructors can be simplified to no longer
    worry about an fstream data member, like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在处理输出接口，我们不再需要在`LogStream`类中管理文件。构造函数可以简化，不再需要担心fstream数据成员，如下所示：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The destructor of the `LogStream` class is where all the work happens. It no
    longer needs to send the message directly to a file that the class manages. The
    destructor now gets *all* the outputs and sends the message to each one using
    the common interface, like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogStream`类的析构函数是所有工作的发生地。它不再需要直接将消息发送到由类管理的文件。析构函数现在获取*所有*输出，并使用通用接口将消息发送给每个输出，如下所示：'
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Remember that the `LogStream` class inherits from `std::stringstream` and holds
    the message to be logged. If we are to proceed, then we can get the fully formatted
    message by calling the `str` method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`LogStream`类从`std::stringstream`继承，并持有要记录的消息。如果我们继续进行，我们可以通过调用`str`方法来获取完整格式的消息。
- en: 'The end of `LogStream` no longer needs the `mFile` data member and only needs
    the `mProceed` flag, like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogStream`类的末尾不再需要`mFile`数据成员，只需要`mProceed`标志，如下所示：'
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Because we removed the `LogStream` constructor parameters for the filename
    and open mode, we can simplify how the `LogStream` class gets created in the `log`
    function like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们移除了`LogStream`构造函数的文件名和打开模式参数，我们可以简化`log`函数中`LogStream`类的创建方式，如下所示：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can now construct the `ls` instance without any arguments, and it will use
    all the outputs that have been added.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以不带任何参数构造`ls`实例，它将使用所有已添加的输出。
- en: 'Let’s check the test application by building and running the project. The output
    to the console looks like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过构建和运行项目来检查测试应用程序。控制台输出的内容如下：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can see that the log messages did indeed go to the console window. The
    log messages are included in the console alongside the test results. What about
    the log file? It looks like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到日志消息确实被发送到了控制台窗口。日志消息包含在控制台结果中。那么日志文件呢？它看起来如下所示：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The log file contains only the log messages, which are the same log messages
    that were sent to the console window. This shows that we have multiple outputs!
    There’s no good way to verify that the log messages are being sent to the console
    window, such as how we can open the log file and search for a specific line.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件只包含日志消息，这些日志消息与发送到控制台窗口的日志消息相同。这表明我们有多处输出！没有很好的方法来验证日志消息是否被发送到控制台窗口，例如，我们可以打开日志文件并搜索特定的行。
- en: 'But we could add yet another output using the `StreamOutput` class that is
    given `std::fstream` instead of `std::cout`. We can do this because fstream implements
    ostream, which is all that the `StreamOutput` class needs. This is also dependency
    injection because the `StreamOutput` class depends on an ostream and we can give
    it any ostream we want it to use, like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以使用`StreamOutput`类添加另一个输出，该类使用`std::fstream`而不是`std::cout`。我们可以这样做，因为fstream实现了ostream，这正是`StreamOutput`类所需要的。这也是依赖注入，因为`StreamOutput`类依赖于一个ostream，我们可以给它任何我们想要的ostream，如下所示：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’re not going to make this change. It’s just for demonstration purposes only.
    But it shows that you can open a file and pass that file to the `StreamOutput`
    class to use instead of the console output. If you do make this change, then you’ll
    see that the `stream.log` and `application.log` files are the same.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会进行这个更改。这只是为了演示目的。但它表明你可以打开一个文件并将该文件传递给`StreamOutput`类以代替控制台输出。如果你真的做出这个更改，那么你会看到`stream.log`和`application.log`文件是相同的。
- en: Why would you want to consider using `StreamOutput` as if it was `FileOutput`?
    And why do we need `FileOutput` if `StreamOutput` can also write to a file?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你想考虑使用`StreamOutput`就像使用`FileOutput`一样？而且如果`StreamOutput`也可以写入文件，我们为什么还需要`FileOutput`？
- en: First of all, `FileOutput` is specialized for files. It will eventually know
    how to check the current file size to make sure it doesn’t get too big and roll
    over to a new log file whenever the current log file approaches the maximum size.
    There is a need for file management that `StreamOutput` will not even be aware
    of.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`FileOutput`是针对文件专门化的。它最终将知道如何检查当前文件大小，以确保它不会变得太大，并在当前日志文件接近最大大小时滚动到新的日志文件。需要文件管理，而`StreamOutput`甚至不会意识到这一点。
- en: The `StreamOutput` class is simpler though because it doesn’t need to worry
    about files at all. You might want to use `StreamOutput` to write to a file in
    case the `FileOutput` class takes too long to create. Sure, we created a simplified
    `FileOutput` without all the file management features, but another team might
    not be so willing to give you a partial implementation. You might find it better
    to use a mock solution while you wait for a full implementation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`StreamOutput`类更简单，因为它根本不需要担心文件。你可能想使用`StreamOutput`将内容写入文件，以防`FileOutput`类创建得太慢。当然，我们创建了一个没有所有文件管理功能的简化`FileOutput`，但另一个团队可能并不愿意给你一个部分实现。你可能发现，在等待完整实现的同时使用模拟解决方案会更好。
- en: The ability to swap one implementation for another is a big advantage you get
    with properly managed dependencies.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 能够交换一种实现方式为另一种实现方式是，通过适当管理的依赖关系获得的一大优势。
- en: In fact, this book will leave the current implementation of `FileOutput` as
    it is now because finishing the implementation would take us into topics that
    have little to do with learning about TDD.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这本书将保留当前`FileOutput`的实现方式，因为它现在是这样，因为完成实现将使我们进入与学习TDD关系不大的主题。
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We not only added a great new feature to the logging library that lets it send
    log messages to multiple destinations but we also added this ability using an
    interface. The interface helps document and isolate the idea of sending lines
    of text to a destination. This helped uncover a dependency that the logging library
    has. The logging library depends on the ability to send text somewhere.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅为日志库添加了一个让它能够将日志消息发送到多个目的地的出色新功能，而且还使用接口添加了这种能力。该接口有助于记录和隔离将文本行发送到目的地的概念。这有助于揭示日志库的一个依赖关系。日志库依赖于将文本发送到某处的功能。
- en: The destination could be a log file or the console, or somewhere else. Until
    we identified this dependency, the logging library was making assumptions in many
    places that it was working with a log file only. We were able to simplify the
    design and, at the same time create a more flexible design.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 目的地可以是日志文件或控制台，或者任何其他地方。在我们确定这个依赖关系之前，日志库在很多地方都做出了假设，认为它只与日志文件一起工作。我们能够简化设计，同时创建一个更灵活的设计。
- en: We were also able to get the file logging working without a complete file logging
    component. We created a mock of the file logging component that leaves out all
    the additional file management tasks that a full implementation will need. While
    useful, the additional capabilities are not needed right now, and the mock will
    let us proceed without them.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还能够在没有完整的文件记录组件的情况下使文件记录功能正常工作。我们创建了一个文件记录组件的模拟，省略了完整实现所需的所有额外文件管理任务。虽然这些附加功能很有用，但目前并不需要，这个模拟将使我们能够在没有它们的情况下继续前进。
- en: The next chapter will go back to the unit testing library and will show you
    how to enhance the confirmations to a new style that is extensible and easier
    to understand.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将回到单元测试库，并展示如何将确认提升到一个可扩展且更容易理解的新风格。
- en: 'Part 3: Extending the TDD Library to Support the Growing Needs of the Logging
    Library'
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：扩展TDD库以支持日志库不断增长的需求
- en: This book is divided into three parts. In this third and final part, we’ll be
    enhancing the unit test confirmations to use a new modern style called Hamcrest
    confirmations. You’ll also learn how to test services and how to test with multiple
    threads. This third part will tie everything you’ve learned so far together and
    prepare you to use TDD in your own projects.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本书分为三部分。在这第三部分和最后一部分，我们将增强单元测试确认，以使用一种称为Hamcrest确认的新现代风格。你还将学习如何测试服务和如何使用多线程进行测试。这一部分将把你迄今为止所学的一切结合起来，并为你使用TDD在自己的项目中做好准备。
- en: 'The following chapters are covered in this part:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分涵盖了以下章节：
- en: '[*Chapter 12*](B18567_12.xhtml#_idTextAnchor123), *Creating better test assertions*'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18567_12.xhtml#_idTextAnchor123)，*创建更好的测试断言*'
- en: '[*Chapter 13*](B18567_13.xhtml#_idTextAnchor131), *How to Test Floating-Point
    and Custom Values*'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B18567_13.xhtml#_idTextAnchor131)，*如何测试浮点数和自定义值*'
- en: '[*Chapter 14*](B18567_14.xhtml#_idTextAnchor139), *How to Test Services*'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B18567_14.xhtml#_idTextAnchor139), *如何测试服务*'
- en: '[*Chapter 15*](B18567_15.xhtml#_idTextAnchor149), *Testing Across Multiple
    Threads*'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B18567_15.xhtml#_idTextAnchor149), *多线程测试*'
