- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: STL with Ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discusses the transformative adoption of ranges in C++, marking
    a paradigm shift from traditional iterators. As an integral facet of modern C++,
    ranges champion expressive and ergonomic code. Through this chapter, you will
    grasp the mechanics of utilizing ranges with standard algorithms, achieving cleaner
    code that’s simultaneously intuitive and powerful. By mastering ranges, C++ developers
    can harness a more compositional and streamlined approach to algorithm application,
    setting the stage for more maintainable and efficient code bases.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to ranges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ranges for sorting algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ranges for searching algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming paradigms evolve, and C++ is no exception. As the journey through
    the vast landscape of the C++ **Standard Template Library** (**STL**) unfolds,
    it is evident that adaptability and growth have been at their core. One such evolutionary
    step, which stands out for its expressiveness and efficiency, is the advent of
    ranges in modern C++. But what exactly are ranges?
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the essence of ranges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`begin` and `end` to define a sequence, ranges encapsulate this information
    within a unified entity. This seemingly subtle shift has profound implications,
    reshaping how we approach algorithms and data manipulations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At a glance, the following shows the verbose legacy way to sort a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'However, with ranges, we could express it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The beauty lies in the clarity and conciseness. No longer must we juggle multiple
    iterators; the range elegantly conveys the intent.
  prefs: []
  type: TYPE_NORMAL
- en: Why the shift to ranges?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The evolution from iterators to ranges wasn’t just a whimsical design choice;
    it addressed pressing needs in the C++ community, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expressiveness**: The preceding example shows that the code becomes more
    readable. Expressing algorithms over entire sequences without explicitly mentioning
    boundary iterators facilitates a more natural, declarative style of coding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composability**: Ranges enable a more functional approach to programming
    in C++. This means algorithms can be seamlessly composed, leading to modular and
    easily understandable code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error minimization**: By reducing the need to manage individual iterators,
    there’s a lower chance of errors related to mismatched or incorrectly used iterators.
    This leads to safer and more maintainable code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A glimpse into range operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ranges aren’t just about cleaner syntax; they offer a plethora of operations
    that can transform sequences in expressive ways. Some operations include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filtering**: Easily refine sequences based on certain conditions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transformations**: Modify sequences by applying functions to their elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concatenation**: Seamlessly join multiple sequences'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With ranges, these operations can be chained, leading to code that’s both intuitive
    and powerful. For instance, transforming and filtering a sequence becomes a straightforward
    task with ranges.
  prefs: []
  type: TYPE_NORMAL
- en: Looking ahead – the power of modern STL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The introduction of ranges in the STL represents a significant stride toward
    a more expressive and ergonomic C++. As developers embark on this new chapter,
    they’ll find that the familiar operations they have come to rely on have been
    enhanced and primed for the modern challenges of the software industry.
  prefs: []
  type: TYPE_NORMAL
- en: Ranges in C++ significantly enhance code quality and developer productivity.
    Ranges offer a more declarative approach to data manipulation, promoting cleaner
    and more readable code. They enable operations on collections of data without
    the explicit need to handle iterators or create temporary containers. This abstraction
    not only reduces boilerplate but also minimizes the likelihood of errors associated
    with manual iterator management. Furthermore, ranges facilitate lazy evaluation,
    where computations are deferred until values are actually needed. This can lead
    to performance improvements, especially in scenarios involving large datasets
    or complex filtering criteria. Looking ahead, ranges have the potential to revolutionize
    C++ coding practices by simplifying algorithm applications, enhancing composability,
    and potentially introducing more opportunities for compiler optimizations. As
    the C++ language evolves, ranges will likely become integral in writing more efficient,
    maintainable, and intuitive code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored the concept of ranges in modern C++, a significant
    advancement in the C++ STL. Ranges represent an abstraction over sequences, offering
    a unified way to handle data sequences as opposed to the traditional pair of iterators.
    This shift to ranges improves code expressiveness, readability, and maintainability.
    Ranges reduce the need for verbose iterator management, minimizing errors and
    enhancing code clarity. They support a variety of operations such as filtering,
    transformations, and concatenation, which can be seamlessly chained for more intuitive
    and powerful coding. The advent of ranges in C++ marks a step toward more declarative
    data manipulation, promising improvements in developer productivity and code quality.
    As C++ continues to evolve, ranges are poised to play a crucial role in shaping
    more efficient and ergonomic coding practices.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we’ll delve deeper into the nuances of ranges, exploring
    their applications with classic STL algorithms, and uncovering best practices
    to ensure that they’re leveraged to their utmost potential.
  prefs: []
  type: TYPE_NORMAL
- en: Ranges for sorting algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Sorting** is a fundamental operation, a bedrock in the vast universe of algorithms.
    Over the years, the STL has empowered us with robust sorting capabilities. With
    the introduction of ranges, this power has been augmented by simplifying the syntax
    and infusing a heightened sense of expressiveness into the mix.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore how ranges simplify the implementation of sorting
    algorithms in C++. We will examine how range-based sorting reduces the syntactical
    overhead and potential errors associated with traditional iterator-based methods.
    Furthermore, we will discuss how ranges enhance the readability and maintainability
    of sorting code, making it easier to understand and modify.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional STL sorting – a recap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into the enhancements brought by ranges, let’s quickly recall
    the conventional STL sorting approach. Traditionally, the `std::sort` function
    is employed, requiring two iterators marking the beginning and the end of the
    sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While effective, this approach leaves room for enhancement in readability and
    user-friendliness. To address this, enter the STL’s range-based sorting.
  prefs: []
  type: TYPE_NORMAL
- en: Range-based sorting – the basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Redefining elegance, the range-based `std::ranges::sort` function allows us
    to pass the sequence to be sorted directly. No fussing with iterators. Given our
    earlier example, with ranges, the sorting becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The concise nature of range-based sorting makes it a joy to use, reducing potential
    error avenues and enhancing readability.
  prefs: []
  type: TYPE_NORMAL
- en: Embracing composability in sorting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the crown jewels of ranges is their ability to facilitate composability,
    which shines exceptionally bright in sorting scenarios. Consider the need to sort
    only a subset of a sequence or the necessity to chain multiple operations before
    sorting. Ranges cater to such needs seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine the requirement to sort only the even numbers from a sequence
    in reverse order. With ranges, this can be expressed in a few lines, harnessing
    the power of filtering combined with sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output[1](B21945_15.xhtml#footnote-000):'
  prefs: []
  type: TYPE_NORMAL
- en: '[1](B21945_15.xhtml#footnote-000-backlink) This example has been tested to
    work with Visual Studio v17.8.6 but does not yet compile with GCC v13.2 or Clang
    v17.0.1.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, vector data contains a sequence of integers. We use a range
    pipeline to create a view that first filters out the even numbers using `std::views::filter`.
    Then, we use `std::views::transform` to negate the numbers, allowing them to be
    sorted in reverse order. Finally, `std::ranges::to` is used to convert the view
    into a vector. The sorted even numbers are then displayed. This showcases the
    composability of ranges, allowing for concise and expressive manipulation of data
    sequences.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to chain operations, leading from filtering to sorting fluidly,
    exemplifies the compositional strength of ranges.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages beyond syntax – why ranges shine in sorting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Beyond the evident syntactical elegance, using ranges with STL sorting algorithms
    offers a buffet of benefits, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`begin` and `end` in a single entity diminishes the risk of mismatched iterators,
    elevating code safety.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: Ranges, coupled with views, provide a dynamic toolkit. Whether
    sorting with custom comparators or adapting to different data structures, the
    range-based approach remains consistent and straightforward.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expressive power**: Ranges foster a declarative coding style, wherein the
    intent of the code stands out. This expressiveness proves invaluable when sorting
    complex data types or applying multifaceted logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The revolution of ranges in sorting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sorting, an operation as old as programming itself, witnesses a rejuvenation
    with the introduction of ranges. Combining traditional STL sorting prowess with
    the modern elegance of ranges can revolutionize our implementations with more
    intuitive, maintainable, and efficient code.
  prefs: []
  type: TYPE_NORMAL
- en: Ranges have transformed sorting algorithms in modern C++. We have seen the traditional
    iterator-based approach of STL sorting with the more streamlined and readable
    range-based approach. The traditional method, using `std::sort` with iterators,
    is effective but can be improved in terms of readability and user-friendliness.
    Range-based sorting, using `std::ranges::sort`, simplifies this by allowing direct
    passing of the sequence, reducing syntactical complexity and potential errors.
    A key highlight is the composability of ranges, particularly beneficial in sorting
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of using ranges in sorting extend beyond syntax. They provide
    safety by encapsulating the beginning and end of sequences into a single entity,
    reducing the risk of mismatched iterators. They offer flexibility with dynamic
    tools for sorting using custom comparators or different data structures. Moreover,
    ranges enable a declarative coding style, making the code’s intent more apparent,
    especially beneficial for sorting complex data types or applying intricate logic.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of ranges in C++ has married the traditional strength of STL
    sorting algorithms with the modern finesse of ranges. This revolution leads to
    more intuitive, maintainable, and efficient code implementations. The exploration
    continues in subsequent sections, delving deeper into the interaction of ranges
    with other STL algorithms for searching and uncovering best practices for their
    effective utilization.
  prefs: []
  type: TYPE_NORMAL
- en: Ranges for searching algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When delving into the domain of algorithmic searching within the STL, it’s evident
    that the advent of ranges heralds an era of simplified and expressive code. To
    appreciate this evolution, looking back at the traditional search methods in the
    STL is essential.
  prefs: []
  type: TYPE_NORMAL
- en: 'The classic way of searching within a container involved using functions such
    as `std::find` or `std::find_if`, wherein you’d provide iterators marking the
    search range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Effective? Yes. Optimal in terms of expressiveness and adaptability? Perhaps
    not.
  prefs: []
  type: TYPE_NORMAL
- en: Finding elegance – range-based searching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The transition to more readable and concise code is evident using the range-based
    approach. With ranges, searching operations become inherently more declarative,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Beyond mere simplicity, the real power of range-based searching emerges when
    combined with other range adaptors, opening a gateway to more adaptive and modular
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining and filtering – the beauty of composability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The elegance of code often lies in its ability to express complex operations
    in a simple, readable manner. Ranges, with their composability, play a pivotal
    role in achieving such elegance. Let’s consider a nuanced example to understand
    this better: finding the first three numbers in a sequence that are both prime
    and greater than a specified value. This task, when approached with traditional
    STL methods, might involve cumbersome loops and condition checks. However, ranges
    transform it into an efficient and easily understandable series of operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an interesting example to illustrate this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we start with a `nums` vector containing a sequence of integers.
    Using ranges, we chain together three operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Filtering for numbers greater than 10: `std::views::filter([](int n) { return
    n > 10; })` selects numbers greater than.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Filtering for prime numbers: `std::views::filter(is_prime)` uses the `is_prime`
    function to keep only prime numbers'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Taking the first three elements: `std::views::take(3)` limits the results to
    the first three elements that meet the previous criteria.'
  prefs: []
  type: TYPE_NORMAL
- en: The result is a seamless integration of conditions in a single, readable line
    of code. This example not only demonstrates the power of chaining and filtering
    but also highlights how ranges can significantly enhance the expressiveness and
    adaptability of C++ code. The combination of simplicity and expressiveness is
    what makes ranges an invaluable feature in modern C++ development.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding views in searches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Views** are pivotal in the range-based landscape, especially in searching
    scenarios. Unlike containers, views don’t own their elements. They present a transformed
    *view* of their source data, which can be another range (such as a container).
    When incorporated into searches, views don’t modify the original data but provide
    a new perspective, which can be particularly useful in modular and reusable code.'
  prefs: []
  type: TYPE_NORMAL
- en: The extended toolkit – more than just find
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While `std::ranges::find` is a cornerstone, the modern range-based approach
    offers a broad spectrum of searching algorithms. Functions such as `std::ranges::search`,
    which locates a subsequence, or `std::ranges::find_end`, which finds the last
    occurrence of a sequence, encapsulate the richness of range-based searching. Their
    true power is unlocked with other range adaptors, offering a palette of possibilities
    for efficient and expressive searching tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning from traditional methods, range-based searching in the STL stands
    as a testament to the evolution of C++ toward more readable, modular, and expressive
    code. As we advance further into the world of ranges, harnessing these tools and
    techniques will be paramount for those eager to craft efficient and maintainable
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The transition to range-based STL is undoubtedly exhilarating. With this newfound
    expressiveness and clarity, we have powerful tools at our fingertips. However,
    understanding a set of best practices is essential to maximize the potential of
    ranges and ensure the maintainability of your code base. Let us look at some of
    the best practices that we can implement.
  prefs: []
  type: TYPE_NORMAL
- en: Embracing the power of chaining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the standout features of ranges is their natural ability to chain operations.
    Chaining not only enhances readability but also improves efficiency by avoiding
    intermediary storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This elegant one-liner filters out odd numbers and then doubles the even ones.
    By promoting such chaining, you can foster cleaner, more concise code.
  prefs: []
  type: TYPE_NORMAL
- en: Guarding against range pitfalls – lifetime awareness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Going all out with ranges is tempting, especially with their composability.
    Yet, caution is advised. One of the most common pitfalls is the unintentional
    dangling of views, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code returns a view on a local variable. As this function exits,
    the local variable will be destroyed. Since a view of this destroyed variable
    is being returned, it will lead to undefined behavior. Always be aware of the
    lifetime of the underlying data when working with views.
  prefs: []
  type: TYPE_NORMAL
- en: Performance considerations – laziness and evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ranges, especially views, operate lazily. This means that they evaluate their
    elements only when accessed. While this can be a boon for efficiency, it might
    also lead to pitfalls, especially when combined with stateful operations or side
    effects, as illustrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If `range` is evaluated multiple times, the side effect in the lambda accumulates,
    leading to unexpected results. It is advisable to force an eager evaluation for
    such scenarios, perhaps by converting the range to a container.
  prefs: []
  type: TYPE_NORMAL
- en: Readability over brevity – striking the balance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While ranges enable concise code, remember the cardinal rule: code is read
    more often than written. Overly compacted chains of range operations can be challenging
    to understand, especially for those new to the code base. Strike a balance between
    brevity and clarity.'
  prefs: []
  type: TYPE_NORMAL
- en: Adhering to range idioms – keep it standard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with other parts of the C++ language, certain idioms and patterns have emerged
    for using ranges. When possible, prefer the standard idioms. (For example, use
    `std::ranges::sort` for sorting and `std::ranges::find` for finding. Both of these
    are better than writing your own loops to do essentially the same thing.) This
    makes your code more understandable to other C++ developers and ensures that you
    benefit from community-tested patterns.
  prefs: []
  type: TYPE_NORMAL
- en: This section highlights key best practices for effectively using range-based
    STL in C++. It emphasizes the importance of embracing the power of chaining, which
    enhances code readability and efficiency by avoiding intermediary storage. However,
    it also cautions against common pitfalls, such as dangling views, and advises
    awareness of the lifetime of underlying data. The section notes the lazy evaluation
    nature of ranges, recommending eager evaluation in scenarios involving stateful
    operations or side effects to avoid unexpected results. Additionally, it advises
    maintaining a balance between code conciseness and readability, ensuring that
    code remains accessible and understandable. Finally, it suggests adhering to established
    range idioms, leveraging standard patterns for better clarity and community alignment.
    These practices aim to maximize the potential of ranges while ensuring maintainable
    and robust code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the concept of ranges in the C++ STL and how they
    enhance how we work with sequences of elements. We began with an introduction
    to ranges, understanding their essence and the motivations behind the shift to
    this new paradigm. We saw how range operations facilitate more expressive and
    readable code, and we delved into the composability that ranges introduce to sorting
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter then focused on range-based sorting, discussing the basic concepts
    and the advantages ranges bring to the table, such as cleaner syntax and improved
    composability. We also examined the application of ranges in searching algorithms,
    appreciating the elegant and powerful ways ranges enable us to chain operations
    and apply filters.
  prefs: []
  type: TYPE_NORMAL
- en: Ranges help us write cleaner code in a way that better expresses our intent.
    The shift to ranges represents a significant evolution in the STL, offering enhanced
    clarity and efficiency in code. It allows us to compose complex operations in
    a more readable and maintainable way, which is beneficial for both the development
    process and the longevity of the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a strong understanding of STL data types, algorithms, and other
    core concepts, we will use this knowledge in the next chapter to create our own
    container types that integrate seamlessly with the existing STL algorithms and
    iterators. We will cover the essential requirements for STL compatibility, such
    as iterator implementation and value semantics. We will guide you through the
    effective use of operator overloading and the creation of custom hash functions.
    By learning to create STL-compatible containers, we can extend the STL to suit
    their specific needs, ensuring that their custom types can benefit from the power
    and flexibility of the STL algorithms and practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: Creating STL-Compatible Types and Algorithms'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part of our book is dedicated to the creation and integration of custom
    types and algorithms within the C++ Standard Template Library ecosystem. We start
    by exploring the construction of STL-compatible containers, detailing the essential
    requirements for seamless interoperability with STL algorithms. We discuss the
    importance of crafting robust iterators and the nuances of operator overloading
    to provide intuitive and consistent behavior for custom types. Special attention
    is given to creating custom hash functions to facilitate the use of user-defined
    types with unordered associative containers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we get into the intricacies of developing STL-compatible algorithms. This
    includes mastering template functions, understanding the subtleties of overloading,
    and leveraging inline functions for performance. We will emphasize the use of
    predicates and functors for enhanced flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we are introduced to type traits and policies, powerful tools that
    allow developers to craft more adaptable and modular code. We gain insights into
    implementing these concepts effectively, ensuring that your custom types and algorithms
    not only integrate well with the STL but also adhere to best practices in modern
    C++ programming.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this part, you will have gained the knowledge to extend the STL
    to fit your unique requirements, fostering a deeper understanding of template
    metaprogramming and the powerful abstractions provided by C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B21945_16.xhtml#_idTextAnchor590)*: Creating STL-Types Containers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 17*](B21945_17.xhtml#_idTextAnchor636)*: Creating STL-Compatible
    Algorithms*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 18*](B21945_18.xhtml#_idTextAnchor658)*: Type Traits and Policies*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
