["```cpp\nstruct MeshTriangle {\n **std::array<glm::vec3, 3> edges{};**\n **std::array<****float****, 3> edgeLengths{};**\n}; \n```", "```cpp\nstruct NavTriangle {\n  int index;\n  std::array<glm::vec3, 3> points{};\n  glm::vec3 center{};\n  glm::vec3 normal{};\n  std::unordered_set<int> neighborTris{};\n}; \n```", "```cpp\nstruct NavData {\n  int triIndex;\n  int prevTriIndex;\n  float distanceFromSource;\n  float heuristicToDest;\n  float distanceToDest;\n}; \n```", "```cpp\n void generateGroundTriangles(OGLRenderData& renderData,\n      std::shared_ptr<TriangleOctree> octree,\n      BoundingBox3D worldbox);\n    std::vector<int> findPath(int startTriIndex,\n      int targetTriIndex); \n```", "```cpp\n std::unordered_map<int, NavTriangle> mNavTriangles{}; \n```", "```cpp\n mNavTriangles.clear();\n  std::vector<MeshTriangle> levelTris =\n    octree->query(worldbox); \n```", "```cpp\n std::vector<MeshTriangle> groundTris{};\n  NavTriangle navTri;\n  for (const auto& tri: levelTris) {\n    if (glm::dot(tri.normal,\n     glm::vec3(0.0f, 1.0f, 0.0f)) >=\n      std::cos(glm::radians(\n      renderData.rdMaxLevelGroundSlopeAngle))) {\n        groundTris.emplace_back(tri); \n```", "```cpp\n navTri.points = tri.points;\n      navTri.normal = tri.normal;\n      navTri.index = tri.index;\n      navTri.center = (tri.points.at(0) +\n        tri.points.at(1) + tri.points.at(2)) / 3.0f;\n      mNavTriangles.insert(std::make_pair(tri.index,\n        navTri))\n    }\n  } \n```", "```cpp\n for (const auto& tri : groundTris) {\n    std::vector<MeshTriangle> nearbyTris =\n      octree->query(tri.boundingBox); \n```", "```cpp\n NavTriangle& navTri = mNavTriangles.at(tri.index);\n    for (const auto& peer : nearbyTris) { \n```", "```cpp\n if (tri.index == peer.index) {\n        continue;\n      }\n      if (glm::dot(peer.normal,\n        glm::vec3(0.0f, 1.0f, 0.0f)) <\n          std::cos(glm::radians(\n          renderData.rdMaxLevelGroundSlopeAngle))) {\n        continue;\n      } \n```", "```cpp\n if (mNavTriangles.count(peer.index) == 0) {\n        continue;\n      } \n```", "```cpp\n NavTriangle peerNavTri =\n        mNavTriangles.at(peer.index); \n```", "```cpp\n for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) { \n```", "```cpp\n glm::vec3 pointToPeerLine =\n            glm::cross(tri.points.at(j) -\n            peer. points.at(i), tri.points.at(j) -\n            peer.points.at((i + 1) % 3));\n          float pointDistance =\n            glm::length(pointToPeerLine) /\n            peer.edgeLengths.at(i);\n          glm::vec3 peerPointToTriLine =\n            glm::cross(peer.points.at(j) -\n            tri. points.at(i), peer.points.at(j) -\n            tri.points.at((i + 1) % 3));\n          float peerPointDistance =\n            glm::length(peerPointToTriLine) /\n            tri.edgeLengths.at(i); \n```", "```cpp\n if ((pointDistance < 0.01f ||\n              peerPointDistance < 0.01f)) {\n            navTri.neighborTris.insert(peerNavTri.index);\n          } \n```", "```cpp\n NavTriangle targetTri = mNavTriangles.at(targetTriIndex);\n  glm::vec3 targetPoint = targetTri.center;\n  NavTriangle startTri = mNavTriangles.at(startTriIndex);\n  glm::vec3 startPoint = startTri.center; \n```", "```cpp\n std::unordered_set<int> navOpenList{};\n  std::unordered_set<int> navClosedList{};\n  std::unordered_map<int, NavData> navPoints{}; \n```", "```cpp\n int currentIndex = startTriIndex;\n  NavData navStartPoint{};\n  navStartPoint.triIndex = startTriIndex;\n  navStartPoint.prevTriIndex = -1;\n  navStartPoint.distanceFromSource = 0;\n  navStartPoint.heuristicToDest =\n    glm::distance(startPoint, targetPoint);\n  navStartPoint.distanceToDest =\n    navStartPoint.distanceFromSource +\n    navStartPoint.heuristicToDest;\n  navPoints.emplace(std::make_pair(startTriIndex,\n    navStartPoint));\n  navOpenList.insert(startTriIndex); \n```", "```cpp\n while (currentIndex != targetTriIndex) {\n    NavTriangle currentTri = mNavTriangles.at(currentIndex);\n    glm::vec3 currentTriPoint = currentTri.center;\n    std::unordered_set<int> neighborTris =\n      currentTri.neighborTris; \n```", "```cpp\n for (const auto& navTriIndex : neighborTris) {\n      NavTriangle navTri = mNavTriangles.at(navTriIndex);\n      glm::vec3 navTriPoint = navTri.center; \n```", "```cpp\n if (navClosedList.count(navTriIndex) == 0) {\n        if (navOpenList.count(navTriIndex) == 0) {\n          navOpenList.insert(navTriIndex); \n```", "```cpp\n NavData navPoint{};\n          navPoint.triIndex = navTriIndex;\n          navPoint.prevTriIndex = currentIndex; \n```", "```cpp\n NavData prevNavPoint =\n            navPoints.at(navPoint.prevTriIndex);\n          navPoint.distanceFromSource =\n            prevNavPoint.distanceFromSource +\n            glm::distance(currentTriPoint, navTriPoint);\n          navPoint.heuristicToDest =\n            glm::distance(navTriPoint, targetPoint);\n          navPoint.distanceToDest =\n            navPoint.distanceFromSource +\n            navPoint.heuristicToDest;\n          navPoints.emplace(\n            std::make_pair(navTriIndex, navPoint));\n        } \n```", "```cpp\n } else {\n          NavData& navPoint = navPoints.at(navTriIndex); \n```", "```cpp\n NavData possibleNewPrevNavPoint =\n             navPoints.at(currentIndex);\n          float newDistanceFromSource =\n            possibleNewPrevNavPoint.distanceFromSource +\n            glm::distance(currentTriPoint, navTriPoint);\n          float newDistanceToDest = newDistanceFromSource +\n            navPoint.heuristicToDest; \n```", "```cpp\n if (newDistanceToDest < navPoint.distanceToDest) {\n            navPoint.prevTriIndex = currentIndex;\n            navPoint.distanceFromSource =\n              newDistanceFromSource;\n            navPoint.distanceToDest = newDistanceToDest;\n          } \n```", "```cpp\n navClosedList.insert(currentIndex); \n```", "```cpp\n if (navOpenList.empty()) {\n      return std::vector<int>{};\n    } \n```", "```cpp\n auto cmp = [](NavData left, NavData right) {\n    return left.distanceToDest > right.distanceToDest;\n  }; \n```", "```cpp\n std::priority_queue<NavData, std::vector<NavData>,\n      decltype(cmp)> naviDataQueue(cmp);\n    for (const auto& navTriIndex : navOpenList) {\n      NavData navPoint = navPoints.at(navTriIndex);\n      naviDataQueue.push(navPoint);\n    } \n```", "```cpp\n NavData nextPointToDest{};\n      nextPointToDest = naviDataQueue.top();\n      currentIndex = nextPointToDest.triIndex; \n```", "```cpp\n navOpenList.erase(currentIndex);\n    } \n```", "```cpp\n std::vector<int> foundPath{};\n  foundPath.emplace_back(currentIndex); \n```", "```cpp\n NavData navPoint = navPoints.at(currentIndex);\n  while (navPoint.prevTriIndex != -1) {\n    foundPath.emplace_back(navPoint.prevTriIndex);\n    navPoint = navPoints.at(navPoint.prevTriIndex);\n  } \n```", "```cpp\n std::reverse(foundPath.begin(), foundPath.end()); \n```", "```cpp\n return foundPath; \n```", "```cpp\n bool msUseAsNavigationTarget = false; \n```", "```cpp\n void setAsNavigationTarget(bool value);\n    bool isNavigationTarget(); \n```", "```cpp\n bool isNavigationEnabled = false;\n  int isPathTargetInstance = -1;\n  int isPathStartTriangleIndex = -1;\n  int isPathTargetTriangleIndex = -1;\n  std::vector<int> isPathToTarget{}; \n```", "```cpp\n void setPathStartTriIndex(int index);\n    void setPathTargetTriIndex(int index);\n    int getPathTargetTriIndex();\n    void setPathTargetInstanceId(int instanceId);\n    void setPathToTarget(std::vector<int> indices);\n    std::vector<int> getPathToTarget(); \n```", "```cpp\nusing getNavTargetsCallback = std::function<std::vector<int>(void)>; \n```", "```cpp\n std::vector<int> targets;\n for (const auto& model : mModelInstCamData.micModelList) {\n   if (!model->isNavigationTarget()) {\n     continue;\n   } \n```", "```cpp\n std::string modelName = model->getModelFileName();\n    for (auto& instance : mModelInstCamData.\n        micAssimpInstancesPerModel[modelName]) {\n      InstanceSettings settings =\n        instance->getInstanceSettings();\n      targets.emplace_back(\n        settings.isInstanceIndexPosition);\n    }\n  }\n  return targets; \n```", "```cpp\n mOctree->add(\n            instSettings.isInstanceIndexPosition);\n **mLevelCollisionTimer.****start****();**\n **...**\n **mRenderData.rdLevelCollisionTime +=**\n **mLevelCollisionTimer.****stop****();** \n```", "```cpp\n **instances.****at****(i)->****updateInstancePosition****(**\n **deltaTime);** \n```", "```cpp\n mWorldPosMatrices.at(i) =\n            instances.at(i)->getWorldTransformMatrix(); \n```", "```cpp\n if (instSettings.isNavigationEnabled) {\n        int pathTargetInstance =\n          instSettings.isPathTargetInstance; \n```", "```cpp\n if (pathTargetInstance >=\n           mModelInstCamData.micAssimpInstances.size()) {\n         pathTargetInstance = -1;\n         instances.at(i)->setPathTargetInstanceId(\n           pathTargetInstance);\n       } \n```", "```cpp\n int pathTargetInstanceTriIndex = -1;\n        glm::vec3 pathTargetWorldPos = glm::vec3(0.0f);\n        if (pathTargetInstance != -1) {\n          std::shared_ptr<AssimpInstance>\n            targetInstance =\n            mModelInstCamData.micAssimpInstances.at(\n            pathTargetInstance);\n          pathTargetInstanceTriIndex =\n            targetInstance->\n              getCurrentGroundTriangleIndex();\n          pathTargetWorldPos =\n            targetInstance->getWorldPosition();\n        } \n```", "```cpp\n if ((instSettings.isCurrentGroundTriangleIndex > -1 &&\n        pathTargetInstanceTriIndex > -1) &&\n        (instSettings.isCurrentGroundTriangleIndex !=\n        instSettings.isPathStartTriangleIndex ||\n        pathTargetInstanceTriIndex !=\n        instSettings.isPathTargetTriangleIndex)) {\n        instances.at(i)->setPathStartTriIndex(\n      instSettings.isCurrentGroundTriangleIndex);\n      instances.at(i)->setPathTargetTriIndex(\n        pathTargetInstanceTriIndex); \n```", "```cpp\n std::vector<int> pathToTarget =\n        mPathFinder.findPath(\n        instSettings.isCurrentGroundTriangleIndex,\n        pathTargetInstanceTriIndex); \n```", "```cpp\n if (pathToTarget.size() == 0) {\n        instances.at(i)->setNavigationEnabled(false);\n        instances.at(i)->setPathTargetInstanceId(-1);\n      } else {\n        instances.at(i)->setPathToTarget(pathToTarget);\n      } \n```", "```cpp\n std::vector<int> pathToTarget =\n      instances.at(i)->getPathToTarget(); \n```", "```cpp\n if (pathToTarget.size() > 1) {\n      pathToTarget.pop_back();\n    }\n    if (pathToTarget.size() > 0) {\n      pathToTarget.erase(pathToTarget.begin());\n    } \n```", "```cpp\n if (pathToTarget.size() > 0) {\n      int nextTarget = pathToTarget.at(0);\n      glm::vec3 destPos =\n        mPathFinder.getTriangleCenter(nextTarget);\n      instances.at(i)->rotateTo(destPos, deltaTime);\n    } else {\n      instances.at(i)->rotateTo(pathTargetWorldPos,\n        deltaTime);\n    } \n```", "```cpp\n if (mInstanceSettings.isMoveState != moveState::walk &&\n      mInstanceSettings.isMoveState != moveState::run) {\n    return;\n  } \n```", "```cpp\n glm::vec3 myRotation = get2DRotationVector();\n  glm::vec3 twoDimWorldPos =\n    glm::vec3(mInstanceSettings.isWorldPosition.x,\n     0.0f, mInstanceSettings.isWorldPosition.z);\n  glm::vec3 toTarget = glm::normalize(glm::vec3(\n    targetPos.x, 0.0f, targetPos.z) - twoDimWorldPos); \n```", "```cpp\n float angleDiff = glm::degrees(std::acos(\n    glm::dot(myRotation, toTarget))); \n```", "```cpp\n if (angleDiff > 6.0f) {\n    glm::quat destRoation =\n      glm::rotation(toTarget, myRotation);\n    glm::vec3 angles = glm::eulerAngles(destRoation);\n    rotateInstance(glm::degrees(angles.y) *\n      deltaTime * 2.0f);\n  } \n```", "```cpp\n if (mRenderData.rdDrawInstancePaths &&\n      pathTargetInstance > -1) { \n```", "```cpp\n glm::vec3 pathColor = glm::vec3(0.4f, 1.0f, 0.4f);\n      glm::vec3 pathYOffset = glm::vec3(0.0f, 1.0f, 0.0f);\n      OGLLineVertex vert;\n      vert.color = pathColor; \n```", "```cpp\n vert.position = instSettings.isWorldPosition +\n        pathYOffset;\n      mInstancePathMesh->vertices.emplace_back(vert); \n```", "```cpp\n if (pathToTarget.size() > 0) {\n        vert.position = mPathFinder.getTriangleCenter(\n          pathToTarget.at(0)) + pathYOffset;\n        mInstancePathMesh->vertices.emplace_back(vert); \n```", "```cpp\n std::shared_ptr<OGLLineMesh> pathMesh =\n          mPathFinder.getAsLineMesh(pathToTarget,\n          pathColor, pathYOffset);\n        mInstancePathMesh->vertices.insert(\n        mInstancePathMesh->vertices.end(),\n          pathMesh->vertices.begin(),\n          pathMesh->vertices.end()); \n```", "```cpp\n vert.position = mPathFinder.getTriangleCenter(\n          pathToTarget.at(pathToTarget.size() - 1)) +\n          pathYOffset;\n        mInstancePathMesh->vertices.emplace_back(vert);\n      } \n```", "```cpp\n vert.position = pathTargetWorldPos + pathYOffset;\n      mInstancePathMesh->vertices.emplace_back(vert); \n```"]