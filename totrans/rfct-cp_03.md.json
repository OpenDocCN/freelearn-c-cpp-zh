["```cpp\nauto process_data = [](const std::vector<int>& data) {\n    return std::accumulate(data.begin(), data.end(), 0L);\n};\n```", "```cpp\nlong process_data(const std::vector<int>& data) {\n    long sum = 0;\n    for (int value : data) {\n        sum += value;\n    }\n    return sum;\n}\n```", "```cpp\nvoid copy_array(const char* source, char* destination, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        destination[i] = source[i];\n    }\n}\n```", "```cpp\nvoid copy_array(const std::vector<char>& source, std::vector<char>& destination) {\n    std::copy(source.begin(), source.end(), std::back_inserter(destination));\n}\n```", "```cpp\nclass Shape {\npublic:\n    virtual void draw() const = 0;\n    virtual ~Shape() = default;\n};\nclass Circle : public Shape {\npublic:\n    void draw() const override {\n        // Draw circle\n    }\n};\nclass Square : public Shape {\npublic:\n    void draw() const override {\n        // Draw square\n    }\n};\nclass ShapeDrawer {\npublic:\n    explicit ShapeDrawer(std::unique_ptr<Shape> shape) : shape_(std::move(shape)) {}\n    void draw() const {\n        shape_->draw();\n    }\nprivate:\n    std::unique_ptr<Shape> shape_;\n};\n```", "```cpp\ntemplate<typename ShapeType>\nclass ShapeDrawer {\npublic:\n    explicit ShapeDrawer(ShapeType shape) : shape_(std::move(shape)) {}\n    void draw() const {\n        shape_.draw();\n    }\nprivate:\n    ShapeType shape_;\n};\nclass Circle {\npublic:\n    void draw() const {\n        // Draw circle\n    }\n};\nclass Square {\npublic:\n    void draw() const {\n        // Draw square\n    }\n};\n```", "```cpp\nint process_file(const std::string& filename) {\n    FILE* file = fopen(filename.c_str(), \"r\");\n    if (!file) {\n        return -1; // Error opening file\n    }\n    // Process file\n    return fclose(file);\n}\n```", "```cpp\nvoid process_file(const std::string& filename) {\n    std::ifstream file(filename);\n    if (!file) {\n        throw std::runtime_error(\"Error opening file\");\n    }\n    // Process file\n}\n```", "```cpp\nvoid process() {\n    int* data = new int[100];\n    // ... perform operations on data\n    delete[] data;\n}\n```", "```cpp\nvoid process() {\n    std::vector<int> data(100);\n    // ... perform operations on data\n}\n```", "```cpp\nstd::shared_ptr<int> create() {\n    std::shared_ptr<int> ptr(new int(42));\n    return ptr;\n}\n```", "```cpp\nstd::shared_ptr<int> create() {\n    return std::make_shared<int>(42);\n}\n```", "```cpp\nvoid append_data(std::vector<int>& target, const std::vector<int>& source) {\n    for (const int& value : source) {\n        target.push_back(value); // Copies each element\n    }\n}\n```", "```cpp\nvoid append_data(std::vector<int>& target, std::vector<int>&& source) {\n    for (int& value : source) {\n        target.push_back(std::move(value)); // Moves each element\n    }\n}\n```", "```cpp\nvoid append_data(std::vector<int>& target, std::vector<int>&& source) {\n    target.insert(target.end(), std::make_move_iterator(source.begin()), std::make_move_iterator(source.end()));\n}\n```", "```cpp\nclass MyClass {\npublic:\n    int get_value() { return value; }\n    void set_value(int v) { value = v; }\nprivate:\n    int value;\n};\n```", "```cpp\nclass MyClass {\npublic:\n    int get_value() const { return value; }\n    void set_value(int v) { value = v; }\nprivate:\n    int value;\n};\n```", "```cpp\nchar message[100];\nstrcpy(message, \"Hello, world!\");\nstd::cout << message << std::endl;\n```", "```cpp\nstd::string message = \"Hello, world!\";\nstd::cout << message << std::endl;\n```", "```cpp\nauto create_lambda() {\n    int value = 42;\n    return [&]() { return value; };\n}\nauto lambda = create_lambda();\nint result = lambda(); // Undefined behavior\n```", "```cpp\nauto create_lambda() {\n    int value = 42;\n    return [=]() { return value; };\n}\nauto lambda = create_lambda();\nint result = lambda(); // Safe\n```", "```cpp\nint sum() {\n    int x;\n    int y = 5;\n    return x + y; // Undefined behavior: x is uninitialized\n}\n```", "```cpp\nint sum() {\n    int x = 0;\n    int y = 5;\n    return x + y; // Defined behavior\n}\n```", "```cpp\nint* create_array() {\n    int arr[5] = {1, 2, 3, 4, 5};\n    return arr; // Undefined behavior: returning a pointer to a local array\n}\n```", "```cpp\nstd::array<int, 5> create_array() {\n    return {1, 2, 3, 4, 5};\n}\n```", "```cpp\nstd::array<int, 5> arr = create_array();\nstd::sort(arr.begin(), arr.end());\n```", "```cpp\nstd::shared_ptr<int> create() {\n    std::shared_ptr<int> ptr(new int(42));\n    return ptr;\n}\n```", "```cpp\nstd::shared_ptr<int> create() {\n    return std::make_shared<int>(42);\n}\n```", "```cpp\nvoid process_shared_ptr(std::shared_ptr<int> ptr) {\n    // Inefficient: copies shared_ptr by value\n}\nvoid process_shared_ptr(const std::shared_ptr<int>& ptr) {\n    // Efficient: passes shared_ptr by reference\n}\n```", "```cpp\nstruct B;\nstruct A {\n    std::shared_ptr<B> b_ptr;\n    ~A() { std::cout << \"A destroyed\\n\"; }\n};\nstruct B {\n    std::shared_ptr<A> a_ptr;\n    ~B() { std::cout << \"B destroyed\\n\"; }\n};\nvoid create_cycle() {\n    auto a = std::make_shared<A>();\n    auto b = std::make_shared<B>();\n    a->b_ptr = b;\n    b->a_ptr = a;\n}\n```", "```cpp\nstruct B;\nstruct A {\n    std::weak_ptr<B> b_ptr; // Use weak_ptr to break the cycle\n    ~A() { std::cout << \"A destroyed\\n\"; }\n};\nstruct B {\n    std::shared_ptr<A> a_ptr;\n    ~B() { std::cout << \"B destroyed\\n\"; }\n};\nvoid create_cycle() {\n    auto a = std::make_shared<A>();\n    auto b = std::make_shared<B>();\n    a->b_ptr = b;\n    b->a_ptr = a;\n}\n```", "```cpp\nstd::weak_ptr<int> weak_ptr = some_shared_ptr;\nvoid check_and_use_weak_ptr() {\n    if (!weak_ptr.expired()) {\n        // This is not thread-safe\n        auto shared_ptr = weak_ptr.lock();\n        shared_ptr->do_something();\n    }\n}\n```", "```cpp\nvoid check_and_use_weak_ptr_correctly() {\n    // This is thread-safe\n    if (auto shared_ptr = weak_ptr.lock()) {\n        // Use shared_ptr\n        shared_ptr->do_something();\n    }\n}\n```"]