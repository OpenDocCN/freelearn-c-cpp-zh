["```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/Interface.h\"\n#include \"PostBeginPlay.generated.h\"\n\nUINTERFACE(meta = (CannotImplementInterfaceInBlueprint))\nclass UPostBeginPlay : public UInterface\n{\n    GENERATED_BODY()\n};\n\n/**\n * \n */\nclass CHAPTER_08_API IPostBeginPlay\n{\n    GENERATED_BODY()\n\n    // Add interface functions to this class. This is the\n    // class that will be inherited to implement\n    // this interface.\npublic:\n UFUNCTION(BlueprintCallable, Category = Test)\n virtual void OnPostBeginPlay();\n};\n```", "```cpp\n#include \"PostBeginPlay.h\"\n\n// Add default functionality here for any IPostBeginPlay \n// functions that are not pure virtual.\nvoid IPostBeginPlay::OnPostBeginPlay()\n{\n GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, \"PostBeginPlay called\");\n}\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"PostBeginPlay.h\"\n#include \"PostBeginPlayTest.generated.h\"\n\nUCLASS()\nclass CHAPTER_08_API APostBeginPlayTest : public AActor, public IPostBeginPlay\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/Interface.h\"\n#include \"AttackAvoider.generated.h\"\n\n// This class does not need to be modified.\nUINTERFACE(MinimalAPI)\nclass UAttackAvoider : public UInterface\n{\n  GENERATED_BODY()\n};\n\nclass CHAPTER_08_API IAttackAvoider\n{\n  GENERATED_BODY()\n\n  // Add interface functions to this class. This is the class\n  // that will be inherited to implement this interface.\npublic:\n    UFUNCTION(BlueprintImplementableEvent, BlueprintCallable, \n Category = AttackAvoider)\n void AttackIncoming(AActor* AttackActor);\n};\n```", "```cpp\nclass CHAPTER_08_API IWearable\n{\n    GENERATED_BODY()\n\n    // Add interface functions to this class. This is the\n    // class that will be inherited to implement\n    // this interface.\npublic:\n UFUNCTION(BlueprintNativeEvent, BlueprintCallable, \n Category = Wearable)\n int32 GetStrengthRequirement();\n\n UFUNCTION(BlueprintNativeEvent, BlueprintCallable, \n Category = Wearable)\n bool CanEquip(APawn* Wearer);\n\n UFUNCTION(BlueprintNativeEvent, BlueprintCallable, \n Category = Wearable)\n void OnEquip(APawn* Wearer);\n};\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Wearable.h\"\n#include \"Boots.generated.h\"\n\nUCLASS()\nclass CHAPTER_08_API ABoots : public AActor, public IWearable\n```", "```cpp\nUCLASS()\nclass CHAPTER_08_API ABoots : public AActor, public IWearable\n{\n    GENERATED_BODY()\n\npublic: \n    // Sets default values for this actor's properties\n    ABoots();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic: \n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n // Implementing the functions needed for IWearable\n virtual void OnEquip_Implementation(APawn* Wearer) override\n {\n GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, \n                                         \"Item being worn\");\n } \n virtual bool CanEquip_Implementation(APawn* Wearer) override\n {\n return true;\n } \n virtual int32 GetStrengthRequirement_Implementation() override\n {\n return 0;\n }\n\n};\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/Interface.h\"\n#include \"Talker.generated.h\"\n\n// This class does not need to be modified.\nUINTERFACE(MinimalAPI)\nclass UTalker : public UInterface\n{\n    GENERATED_BODY()\n};\n\n/**\n * \n */\nclass CHAPTER_08_API ITalker\n{\n    GENERATED_BODY()\n\n    // Add interface functions to this class. This is the\n    // class that will be inherited to implement\n    // this interface.\npublic:\n UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = Talk)\n void StartTalking();\n\n};\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Engine/StaticMeshActor.h\"\n#include \"Talker.h\"\n#include \"TalkingMesh.generated.h\"\n\n/**\n * \n */\nUCLASS()\nclass CHAPTER_08_API ATalkingMesh : public AStaticMeshActor, public ITalker\n```", "```cpp\nUCLASS()\nclass CHAPTER_08_API ATalkingMesh : public AStaticMeshActor, public ITalker\n{\n    GENERATED_BODY()\n\npublic:\n ATalkingMesh();\n void StartTalking_Implementation();\n};\n```", "```cpp\n#include \"TalkingMesh.h\"\n#include \"ConstructorHelpers.h\"\n\nATalkingMesh::ATalkingMesh() : Super()\n{\n auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"StaticMesh'/Engine/BasicShapes/Cube.Cube'\"));\n\n UStaticMeshComponent * SM = GetStaticMeshComponent();\n\n if(SM != nullptr)\n {\n if (MeshAsset.Object != nullptr)\n {\n SM->SetStaticMesh(MeshAsset.Object);\n SM->SetGenerateOverlapEvents(true);\n }\n\n SM->SetMobility(EComponentMobility::Movable);\n\n }\n\n SetActorEnableCollision(true);\n}\n\nvoid ATalkingMesh::StartTalking_Implementation()\n{\n GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, \n TEXT(\"Hello there. What is your name?\"));\n}\n```", "```cpp\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/DefaultPawn.h\"\n#include \"Components/BoxComponent.h\" // UBoxComponent\n#include \"TalkingPawn.generated.h\"\n\n/**\n * \n */\nUCLASS()\nclass CHAPTER_08_API ATalkingPawn : public ADefaultPawn\n{\n  GENERATED_BODY()\n\npublic:\n // Sets default values for this character's properties\n ATalkingPawn();\n\n UPROPERTY()\n UBoxComponent* TalkCollider;\n\n UFUNCTION()\n void OnTalkOverlap(UPrimitiveComponent* OverlappedComponent, \n AActor* OtherActor, \n UPrimitiveComponent* OtherComp, \n int32 OtherBodyIndex, bool bFromSweep, \n const FHitResult & SweepResult);\n\n};\n```", "```cpp\n#include \"TalkingPawn.h\"\n#include \"Talker.h\"\n```", "```cpp\nATalkingPawn::ATalkingPawn() : Super()\n{\n    // Set this character to call Tick() every frame. You can\n    // turn this off to improve performance if you\n    // don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    TalkCollider = CreateDefaultSubobject<UBoxComponent>(\"TalkCollider\");\n\n    TalkCollider->SetBoxExtent(FVector(200, 200, 100));\n\n    TalkCollider->OnComponentBeginOverlap.AddDynamic(this, &ATalkingPawn::OnTalkOverlap);\n\n    TalkCollider->AttachTo(RootComponent);\n}\n```", "```cpp\n// Called to bind functionality to input\nvoid ATalkingPawn::OnTalkOverlap(UPrimitiveComponent* OverlappedComponent, \n                                 AActor* OtherActor, \n                                 UPrimitiveComponent* OtherComp, \n                                 int32 OtherBodyIndex, bool bFromSweep, \n                                 const FHitResult & SweepResult)\n{\n    auto Class = OtherActor->GetClass();\n    if (Class->ImplementsInterface(UTalker::StaticClass()))\n    {\n        ITalker::Execute_StartTalking(OtherActor);\n    }\n}\n```"]