# 游戏

在 [第 6 章](f20d7a19-156f-43e8-92a5-46b9068128fc.xhtml)，“增强 QT 图形应用”中，我们使用 Qt 图形库开发了一个模拟时钟、一个绘图程序和一个编辑器。在本章中，我们继续开发 Othello 和井字棋游戏，使用 Qt 库。您将在本介绍之后找到这些游戏的描述。我们从这个章节的基本版本开始，其中两名玩家相互对战。在第 8 章 [计算机游戏](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml)中，我们将游戏改进为计算机与人类对战。

本章我们将涵盖的主题包括：

+   博弈论简介。我们开发了一个游戏网格，玩家轮流将他们的标记添加到游戏网格中。

+   我们宣布获胜者。在国际象棋中，每走一步棋后，我们计算有多少个对手的标记可以被改变。当游戏网格的每个位置都被占据后，我们宣布获胜者或平局。

+   在井字棋中，我们计算一行中的标记数量。如果一行中有五个标记，我们宣布获胜者。

+   我们继续使用 C++ 特性，如类、字段和方法。我们还继续使用 Qt 特性，如窗口和小部件。

# 国际象棋

在国际象棋中，游戏网格在游戏开始时是空的。在游戏过程中，两名玩家轮流将黑白标记添加到游戏网格中。每次玩家添加标记时，我们查看其他标记，看看新的标记是否会导致对手的任何标记被包围。如果是这样，我们就交换对手被包围标记的颜色。

例如，如果黑子在三个白标记的左侧添加一个黑标记，第四个标记是黑，那么这三个白标记被两个黑标记包围，它们被交换成黑标记。当游戏网格上的每个位置都被黑白标记占据后，我们计算标记数量，标记数量最多的玩家获胜。如果黑白标记数量相等，则为平局。

这是我们游戏应该看起来像的：

![游戏](img/c7a9a4b5-274d-46fc-8bde-d9d10a94b08f.png)

# 游戏小部件

首先，我们需要一个游戏网格。`GameWidget` 类是本章以及 [第 8 章](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml)，“计算机游戏”中所有应用的通用类。在第 5 章 [Qt 图形应用](411aae8c-9215-4315-8a2e-882bf028834c.xhtml)和第 6 章 [增强 QT 图形应用](f20d7a19-156f-43e8-92a5-46b9068128fc.xhtml)中，由于我们处理的是基于文档的应用，我们开发了 `DocumentWidget` 类。在本章和 [第 8 章](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml)，“计算机游戏”中，我们则开发了 `GameWidget` 类。

上一章的`DocumentWidget`类和本章以及下一章的`GameWidget`类既有相似之处也有不同之处。它们都是Qt类`QWidget`的子类，并且都旨在嵌入到窗口中。然而，`DocumentWidget`旨在包含文档，而`GameWidget`旨在包含游戏网格。它绘制网格并捕获网格位置的鼠标点击。`GameWidget`是一个抽象类，允许其子类定义当用户点击鼠标或游戏网格中某个位置的标记需要重绘时调用的方法。

然而，我们重用了上一章的`MainWindow`类来包含应用程序的主窗口及其菜单栏。

**GameWidget.h**

[PRE0]

构造函数初始化游戏网格的行数和列数：

[PRE1]

`clearGrid`方法将游戏网格中的每个位置都设置为零，这被假定为表示一个空位置。因此，继承`GameWidget`的每个类都应该让零值代表一个空位置：

[PRE2]

当用户改变窗口大小时会调用`resizeEvent`方法。由于行数和列数是固定的，每个位置的宽度和高度会根据窗口的新大小进行改变：

[PRE3]

当用户按下鼠标按钮时调用`mousePressEvent`，当窗口需要重绘时调用`paintEvent`，当用户点击窗口右上角的关闭框时调用`closeEvent`：

[PRE4]

`mouseMark`和`drawMark`方法是纯虚方法，旨在被子类覆盖；当用户在网格中的某个位置点击时调用`mouseMark`，当需要重绘某个位置时调用`drawMark`。它们是纯虚方法，而`GameWidget`是抽象的，这意味着只能将其用作基类。`GameWidget`的子类必须覆盖这些方法以使其非抽象：

[PRE5]

`isQuitOk`方法显示一个消息框，询问用户是否真的想要退出游戏：

[PRE6]

在`Game`菜单可见之前调用`isQuitEnabled`方法。当游戏正在进行时，`Quit`项被启用：

[PRE7]

当用户选择退出或退出菜单项时调用`onQuit`和`onExit`方法：

[PRE8]

`isGameInProgress`和`setGameInProgress`方法返回和设置`m_gameInProgress`字段的值：

[PRE9]

`get`和`set`方法用于在游戏网格中的某个位置获取和设置一个值。该值是一个整数；记住，一个空位置被假定为包含值零：

[PRE10]

`m_gameInProgress` 字段在游戏进行中时为真。`m_rows` 和 `m_columns` 字段分别存储游戏网格的行数和列数；`m_rowHeight` 和 `m_columnWidth` 分别存储游戏网格中每个位置的高度和宽度（以像素为单位）。最后，`m_gameGrid` 是一个指向缓冲区的指针，该缓冲区包含游戏网格中位置值：

[PRE11]

`GameWidget.cpp` 文件包含 `GameWidget` 类的方法定义、鼠标事件方法、菜单方法，以及标记的绘制和设置。

**GameWidget.cpp**

[PRE12]

构造函数初始化网格的行数和列数，动态分配其内存，并调用 `clearGrid` 以清除网格：

[PRE13]

`get` 方法返回由行和列指示的位置的值，而 `set` 设置该值。包含值的缓冲区按行组织。也就是说，缓冲区的第一部分包含第一行，然后是第二行，依此类推：

[PRE14]

`clearGrid` 方法将每个位置设置为零，因为零假设表示一个空位置：

[PRE15]

只要游戏在进行中，`Quit` 菜单项就处于启用状态：

[PRE16]

如果用户在游戏进行中选择退出游戏，则显示一个带有确认问题的消息框：

[PRE17]

如果用户按下 `Yes` 按钮，则返回 `true`：

[PRE18]

当用户选择退出菜单项时，会调用 `onQuit` 方法。如果 `isQuitOk` 的调用返回 `true`，则将 `m_gameInProgress` 设置为 `false` 并调用更新，这最终强制重新绘制游戏网格所在的窗口，并清除网格。

[PRE19]

当用户选择退出菜单项时，会调用 `onExit` 方法。如果 `isQuitOk` 的调用返回 `true`，则应用程序退出。这在上面的代码中显示：

[PRE20]

当用户调整窗口大小时，会调用 `resizeEvent` 方法。由于行数和列数是固定的，无论窗口大小如何，都会重新计算行高和列宽。我们将窗口的高度和宽度除以行数和列数加二，因为我们添加了额外的行和列作为边距。考虑以下代码：

[PRE21]

当用户点击窗口时，会调用 `mousePressEvent` 方法：

[PRE22]

由于游戏网格被边距包围，因此从鼠标点中减去列宽和行高：

[PRE23]

如果鼠标点位于游戏网格中的一个位置内，并且该位置为空（零），则调用纯虚方法 `mouseMark`，该方法负责处理鼠标点击的实际操作。在下一节中，将在游戏网格中添加黑白标记，并在稍后的井字棋应用中添加。井字棋被添加到游戏网格中：

[PRE24]

如果点击的行和列位于游戏网格内（而不是游戏网格外的边距中）并且位置为空（零），我们调用 `mouseMark`，这是一个纯虚方法，并带有行和列：

[PRE25]

当窗口需要重绘时，会调用 `paintEvent` 方法。如果游戏正在进行中（`m_gameInProgress` 为 true），则写入行和列，然后对游戏网格中的每个位置调用纯虚方法 `drawMark`，该方法负责实际绘制每个位置：

[PRE26]

首先，我们遍历行，并为每一行写入一个从 `A` 到 `Z` 的字母。字母表中有 26 个字母，我们假设没有超过 26 行：

[PRE27]

然后我们遍历列，并为每一列写入其编号：

[PRE28]

纯虚方法是那些不打算在类中定义，而只在其子类中定义的方法。包含至少一个纯虚方法的类成为抽象类，这意味着无法创建该类的对象。该类只能作为类层次结构中的基类使用。继承自抽象类的类必须定义基类中的每个纯虚方法，或者自身也成为抽象类。

最后，我们遍历游戏网格，并对每个位置调用纯虚方法 `drawMark`，该方法使用位置的矩形及其当前标记：

[PRE29]

当用户点击窗口右上角的关闭按钮时，会调用 `closeEvent` 方法。如果 `isQuitOk` 的调用返回 true，则窗口关闭，应用程序退出：

[PRE30]

# OthelloWindow 类

`Othello` 类是来自 [第 6 章](f20d7a19-156f-43e8-92a5-46b9068128fc.xhtml)，*增强 QT 图形应用程序* 的 `MainWindow` 子类。它向窗口添加菜单，并将 `OthelloWidget` 类（它是 `GameWidget` 的子类）设置为中央小部件。

**OthelloWindow.h**

[PRE31]

`m_othelloWidgetPtr` 字段持有指向窗口中心小部件的指针。它指向 `OthelloWidget` 类的对象。以下代码展示了这一点：

[PRE32]

`OthelloWindow.cpp` 文件定义了 `OthelloWindow` 类的方法。

**OthelloWindow.cpp**

[PRE33]

构造函数将窗口标题设置为 `Othello` 并将大小设置为 *1000* x *500* 像素：

[PRE34]

动态创建 `OthelloWidget` 对象并将其放置在窗口中心：

[PRE35]

我们将菜单 `Game` 添加到菜单栏，并将 `onMenuShow` 方法连接到菜单，这样在菜单可见之前就会调用它：

[PRE36]

用户可以选择黑色或白色来开始第一步。在项目可见之前会调用 `isBlackStartsEnabled` 和 `isWhiteStartsEnabled` 方法。当游戏进行时，项目会变为不可用：

[PRE37]

当游戏进行时，用户可以退出游戏。如果没有游戏进行，项目会变为不可用：

[PRE38]

用户可以随时退出应用程序：

[PRE39]

析构函数释放窗口中心 `Othello` 小部件的资源：

[PRE40]

# OthelloWidget 类

`OthelloWidget`是我们在本章开头定义的`GameWidget`类的子类。通过重写`mouseMark`和`drawMark`，它成为一个非抽象类，这两个方法分别在用户点击游戏网格中的位置和需要重绘位置时被调用。

**OthelloWidget.h**

[PRE41]

在奥赛罗游戏中，标记可以是黑色或白色。我们使用`Mark`枚举来存储游戏网格上的值。`Empty`项持有零值，它被假定为`GameWidget`以表示空位：

[PRE42]

在`BlackStarts`和`WhiteStarts`菜单项可见之前，会调用`isBlackStartsEnabled`和`isWhiteStartsEnabled`监听器以启用它们。请注意，监听器和方法必须被标记为公共槽，以便菜单框架允许它们作为监听器：

[PRE43]

当用户选择`BlackStarts`和`WhiteStarts`菜单项时，会调用`onBlackStarts`和`onWhiteStarts`方法：

[PRE44]

如果游戏网格上的每个位置都被黑白标记占据，`checkWinner`方法会检查。如果是这样，就会计算标记，并宣布获胜者，除非是平局：

[PRE45]

当一位玩家移动时，会调用`turn`方法。它计算移动结果导致的翻转位置：

[PRE46]

`calculateMark`方法计算如果玩家在由行和列给出的位置放置标记，则要翻转的标记集合：

[PRE47]

`m_nextMark`字段交替地赋予前一个`Mark`枚举的`Black`和`White`值，这取决于哪个玩家即将进行下一步移动。

它由`onBlackStarts`或`onWhiteStarts`初始化，如前述代码所示：

[PRE48]

`OthelloWidget`类包含游戏的功能。它允许玩家将黑白标记添加到游戏网格，翻转标记，并宣布获胜者。

**OthelloWidget.cpp**

[PRE49]

当没有正在进行的游戏时，`BlackStarts`和`WhiteStarts`菜单项被启用：

[PRE50]

`onBlackStarts`和`onWhiteStarts`方法设置一个新游戏开始，设置第一个移动的标记（黑色或白色），清除网格，并更新窗口以绘制一个空的游戏网格：

[PRE51]

当玩家在游戏网格上点击一个空位时，会调用`onMouseMark`。我们使用下一个标记设置位置，翻转所有受移动影响的标记，并更新窗口以反映变化：

[PRE52]

我们检查移动是否使游戏网格变得满载，并切换下一个标记：

[PRE53]

当游戏网格中的某个位置需要重绘时，会调用`drawMark`方法。如果位置不为空，我们用黑色边框绘制一个黑色或白色的椭圆。如果位置为空，我们不做任何操作。请注意，框架在调用重绘之前清除窗口：

[PRE54]

[PRE55]

`checkWinner`方法计算被黑白标记占据或为空的格子的数量：

[PRE56]

如果没有剩余的空位置，游戏结束，我们宣布获胜者，除非是平局。获胜者是拥有最多标记的玩家：

[PRE57]

`turn` 方法调用 `calculateMark` 来获取标记应翻转的位置集合。然后，将集合中的每个位置都设置为相应的标记。

在这个应用程序中，`turn` 是唯一调用 `calculateMark` 的方法。然而，在[第8章](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml)，《计算机对战》中，`calculateMark` 也会被调用以计算计算机玩家的移动。因此，`turn` 和 `calculateMark` 的功能被分为两个方法：

[PRE58]

`calculateMark` 方法计算游戏网格上每个位置将翻转的标记数量，包括八个方向：

[PRE59]

`directionArray` 中的每个整数对都根据罗盘上升的方向指代一个方向：

[PRE60]

数组的大小可以通过将其总大小（以字节为单位）除以第一个值的大小来确定：

[PRE61]

我们遍历方向，并且对于每个方向，只要我们找到对手的标记就继续移动：

[PRE62]

`row` 和 `column` 字段在迭代该方向时保持当前行和列：

[PRE63]

我们在迭代过程中找到的标记收集到 `directionSet` 中：

[PRE64]

如果我们到达游戏网格的边界之一，或者如果我们找到一个空位置，我们就会中断迭代：

[PRE65]

如果我们找到玩家的标记，我们将方向集合添加到总集合中，并中断迭代：

[PRE66]

如果我们没有找到玩家的标记或空位置，我们就找到了对手的标记，并将其位置添加到方向集合中：

[PRE67]

# 主函数

`main` 函数与之前 Qt 应用程序中的方式相同。它创建一个应用程序，显示 Othello 窗口，并执行应用程序。执行将继续，直到调用 `exit` 方法，这通常发生在用户关闭窗口或选择退出菜单项时。

**Main.cpp**

[PRE68]

# 井字棋

Noughts and Crosses 应用程序设置了一个游戏网格，并允许两名玩家相互对战。在井字棋游戏中，两名玩家轮流在游戏网格上添加圆圈和叉号。首先成功将五个标记连成一线的玩家赢得游戏。标记可以水平、垂直或对角放置。虽然每个玩家都试图将五个自己的标记连成一线，但他们也必须尝试阻止对手将五个标记连成一线。

在[第8章](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml)，《计算机对战》中，计算机与人类玩家对战。

# NaCWindow 类

我们重用了游戏部件部分的 `GameWidget`。`NaCWindow` 类与 `OthelloWindow` 类类似。它将 `Nought Begins` 和 `Cross Begins` 菜单项添加到窗口的菜单栏中。

**NaCWindow.h**

[PRE69]

`NaCWindow.cpp` 文件包含 `NacWindow` 类的方法定义。

**NaCWindow.cpp**

[PRE70]

# NaCWidget 类

`NaCWidget` 类处理井字棋的功能。它允许两个玩家相互对战。在[第8章](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml)，*计算机对战*中，我们将编写一个计算机对战人类的游戏：

**NaCWidget.h**

[PRE71]

与奥赛罗应用类似，游戏网格中的位置可以持有三个值之一：

+   `Empty`（即零）

+   `Nought`

+   `Cross`

`Mark` 枚举对应于 `Empty`、`Nought` 和 `Cross` 值：

[PRE72]

`NaCWidget.cpp` 文件包含 `NaCWidget` 类的方法定义：

**NaCWidget.cpp**

[PRE73]

在 `Game` 菜单可见之前，会调用 `isNoughtStartsEnabled` 和 `isCrossStartsEnabled` 方法。如果没有正在进行的游戏，则启用 `Noughts Begins` 和 `Cross Begins` 菜单项：

[PRE74]

当用户选择 `Nought Begins` 和 `Cross Begins` 菜单项时，会调用 `onNoughtBegins` 和 `onCrossBegins` 方法。它们设置正在进行的游戏，设置第一个标记以进行第一次移动（`m_nextMark`），并通过调用 `update` 强制重绘游戏网格：

[PRE75]

当玩家在游戏网格中点击一个位置时，会调用 `mouseMark` 方法。我们在该位置设置下一个标记，检查是否有玩家赢得了游戏，交换下一个移动，并通过调用 `update` 来重绘窗口：

[PRE76]

当游戏网格中的位置需要重绘时，会调用 `drawMark` 方法：

[PRE77]

我们将笔的颜色设置为黑色，在井的情况下，我们画一个椭圆，如下所示：

[PRE78]

在十字的情况下，我们在左上角和右下角以及右上角和左下角之间画两条线：

[PRE79]

在空位的情况下，我们不做任何操作。请记住，框架在重绘之前会清除窗口：

[PRE80]

当玩家移动时，我们检查该移动是否导致了胜利。我们调用 `countMarks` 在四个方向上到 `checkWinner`，看看移动是否导致了五个标记连成一线：

[PRE81]

对于北和南方向，代码如下：

[PRE82]

对于西和东方向，代码如下：

[PRE83]

对于西北和东南方向，代码如下：

[PRE84]

对于东南和西北方向，代码如下：

[PRE85]

如果移动导致一行有五个标记，我们将显示一个包含获胜者（黑色或白色）的消息框。在井字棋中，不可能平局：

[PRE86]

游戏网格被清除，因此准备好进行另一场比赛：

[PRE87]

`countMarks` 方法计算一行中的标记数量。我们在两个方向上计算标记的数量。例如，如果 `rowStep` 和 `columnStep` 都是减一，那么我们每次迭代都减少当前行和列。这意味着我们在第一次迭代中在东北方向调用 `countMarks`。在第二次迭代中，我们在相反的方向调用 `countMarks`，即西南方向：

[PRE88]

我们继续计数，直到遇到游戏网格的边界，或者我们找到的不是我们正在计数的标记，即对手的标记或空标记：

[PRE89]

在第二次迭代中，我们减去行和列的步长而不是增加它们。这样，我们以相反的方向调用`countMarks`。我们还通过顺序添加步长来初始化当前行和列，这样我们就不会对中间的标记进行两次`countMarks`：

[PRE90]

# 主函数

`main`函数创建应用程序，显示窗口，并在用户关闭窗口或选择退出菜单项之前执行应用程序。

**Main.cpp**

[PRE91]

上述代码的输出如下：

![](img/d0111dd0-efe7-4911-8851-1bfa61a04170.png)

# 摘要

在本章中，我们开发了两个游戏，黑白棋和井字棋。我们介绍了博弈论，并开发了一个游戏网格，玩家轮流在其上添加标记。在黑白棋中，我们开发了计算每步需要更改的标记数量的方法，在井字棋中，我们开发了识别玩家是否成功在一行中放置了五个标记的方法——如果他们做到了，我们宣布他们为胜者。

在[第8章](ddd1aeb1-7f0c-4a44-b715-860c57771663.xhtml)，《计算机游戏》，我们将开发这些游戏的更高级版本，其中计算机与人类玩家对战。
