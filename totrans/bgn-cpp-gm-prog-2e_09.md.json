["```cpp\n#pragma once\n#include <SFML/Graphics.hpp>\nusing namespace sf;\nclass Player\n{\n};\n```", "```cpp\nclass Player\n{\nprivate:\n    const float START_SPEED = 200;\n    const float START_HEALTH = 100;\n    // Where is the player\n    Vector2f m_Position;\n    // Of course, we will need a sprite\n    Sprite m_Sprite;\n    // And a texture\n    // !!Watch this space – Interesting changes here soon!!\n    Texture m_Texture;\n    // What is the screen resolution\n    Vector2f m_Resolution;\n    // What size is the current arena\n    IntRect m_Arena;\n    // How big is each tile of the arena\n    int m_TileSize;\n    // Which direction(s) is the player currently moving in\n    bool m_UpPressed;\n    bool m_DownPressed;\n    bool m_LeftPressed;\n    bool m_RightPressed;\n    // How much health has the player got?\n    int m_Health;\n    // What is the maximum health the player can have\n    int m_MaxHealth;\n    // When was the player last hit\n    Time m_LastHit;\n    // Speed in pixels per second\n    float m_Speed;\n// All our public functions will come next\n};\n```", "```cpp\n// All our public functions will come next\npublic:\n    Player();\n    void spawn(IntRect arena, Vector2f resolution, int tileSize);\n    // Call this at the end of every game\n    void resetPlayerStats();\n\n    // Handle the player getting hit by a zombie\n    bool hit(Time timeHit);\n    // How long ago was the player last hit\n    Time getLastHitTime();\n    // Where is the player\n    FloatRect getPosition();\n    // Where is the center of the player\n    Vector2f getCenter();\n    // What angle is the player facing\n    float getRotation();\n    // Send a copy of the sprite to the main function\n    Sprite getSprite();\n    // The next four functions move the player\n    void moveLeft();\n    void moveRight();\n    void moveUp();\n    void moveDown();\n    // Stop the player moving in a specific direction\n    void stopLeft();\n    void stopRight();\n    void stopUp();\n    void stopDown();\n    // We will call this function once every frame\n    void update(float elapsedTime, Vector2i mousePosition);\n    // Give the player a speed boost\n    void upgradeSpeed();\n    // Give the player some health\n    void upgradeHealth();\n    // Increase the maximum amount of health the player can have\n    void increaseHealthLevel(int amount);\n    // How much health has the player currently got?\n    int getHealth();\n};\n```", "```cpp\nplayer.getSprite();\n```", "```cpp\nwindow.draw(player.getSprite());\n```", "```cpp\n#include \"player.h\"\nPlayer::Player()\n{\n    m_Speed = START_SPEED;\n    m_Health = START_HEALTH;\n    m_MaxHealth = START_HEALTH;\n    // Associate a texture with the sprite\n    // !!Watch this space!!\n    m_Texture.loadFromFile(\"graphics/player.png\");\n    m_Sprite.setTexture(m_Texture);\n    // Set the origin of the sprite to the center, \n    // for smooth rotation\n    m_Sprite.setOrigin(25, 25);\n}\n```", "```cpp\nPlayer player;\n```", "```cpp\nvoid Player::spawn(IntRect arena, \n        Vector2f resolution, \n        int tileSize)\n{\n    // Place the player in the middle of the arena\n    m_Position.x = arena.width / 2;\n    m_Position.y = arena.height / 2;\n    // Copy the details of the arena \n    // to the player's m_Arena\n    m_Arena.left = arena.left;\n    m_Arena.width = arena.width;\n    m_Arena.top = arena.top;\n    m_Arena.height = arena.height;\n    // Remember how big the tiles are in this arena\n    m_TileSize = tileSize;\n    // Store the resolution for future use\n    m_Resolution.x = resolution.x;\n    m_Resolution.y = resolution.y;\n}\n```", "```cpp\nvoid Player::resetPlayerStats()\n{\n    m_Speed = START_SPEED;\n    m_Health = START_HEALTH;\n    m_MaxHealth = START_HEALTH;\n}\n```", "```cpp\nTime Player::getLastHitTime()\n{\n    return m_LastHit;\n}\nbool Player::hit(Time timeHit)\n{\n    if (timeHit.asMilliseconds() \n        - m_LastHit.asMilliseconds() > 200)\n    {\n        m_LastHit = timeHit;\n        m_Health -= 10;\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n```", "```cpp\nFloatRect Player::getPosition()\n{\n    return m_Sprite.getGlobalBounds();\n}\nVector2f Player::getCenter()\n{\n    return m_Position;\n}\nfloat Player::getRotation()\n{\n    return m_Sprite.getRotation();\n}\nSprite Player::getSprite()\n{\n    return m_Sprite;\n}\nint Player::getHealth()\n{\n    return m_Health;\n}\n```", "```cpp\nvoid Player::moveLeft()\n{\n    m_LeftPressed = true;\n}\nvoid Player::moveRight()\n{\n    m_RightPressed = true;\n}\nvoid Player::moveUp()\n{\n    m_UpPressed = true;\n}\nvoid Player::moveDown()\n{\n    m_DownPressed = true;\n}\nvoid Player::stopLeft()\n{\n    m_LeftPressed = false;\n}\nvoid Player::stopRight()\n{\n    m_RightPressed = false;\n}\nvoid Player::stopUp()\n{\n    m_UpPressed = false;\n}\nvoid Player::stopDown()\n{\n    m_DownPressed = false;\n}\n```", "```cpp\nvoid Player::update(float elapsedTime, Vector2i mousePosition)\n{\n    if (m_UpPressed)\n    {\n        m_Position.y -= m_Speed * elapsedTime;\n    }\n    if (m_DownPressed)\n    {\n        m_Position.y += m_Speed * elapsedTime;\n    }\n    if (m_RightPressed)\n    {\n        m_Position.x += m_Speed * elapsedTime;\n    }\n    if (m_LeftPressed)\n    {\n        m_Position.x -= m_Speed * elapsedTime;\n    }\n    m_Sprite.setPosition(m_Position);\n    // Keep the player in the arena\n    if (m_Position.x > m_Arena.width - m_TileSize)\n    {\n        m_Position.x = m_Arena.width - m_TileSize;\n    }\n    if (m_Position.x < m_Arena.left + m_TileSize)\n    {\n        m_Position.x = m_Arena.left + m_TileSize;\n    }\n    if (m_Position.y > m_Arena.height - m_TileSize)\n    {\n        m_Position.y = m_Arena.height - m_TileSize;\n    }\n    if (m_Position.y < m_Arena.top + m_TileSize)\n    {\n        m_Position.y = m_Arena.top + m_TileSize;\n    }\n    // Calculate the angle the player is facing\n    float angle = (atan2(mousePosition.y - m_Resolution.y / 2,\n        mousePosition.x - m_Resolution.x / 2)\n        * 180) / 3.141;\n    m_Sprite.setRotation(angle);\n}\n```", "```cpp\nif (m_Position.x > m_Arena.width - m_TileSize)\n{\n    m_Position.x = m_Arena.width - m_TileSize;\n}\n```", "```cpp\nvoid Player::upgradeSpeed()\n{\n    // 20% speed upgrade\n    m_Speed += (START_SPEED * .2);\n}\nvoid Player::upgradeHealth()\n{\n    // 20% max health upgrade\n    m_MaxHealth += (START_HEALTH * .2);\n}\nvoid Player::increaseHealthLevel(int amount)\n{\n    m_Health += amount;\n    // But not beyond the maximum\n    if (m_Health > m_MaxHealth)\n    {\n        m_Health = m_MaxHealth;\n    }\n}\n```", "```cpp\n// Create a view to fill a 1920 x 1080 monitor\nView mainView(sf::FloatRect(0, 0, 1920, 1080));\n// Create a view for the HUD\nView hudView(sf::FloatRect(0, 0, 1920, 1080));\n```", "```cpp\n// In the update part of the game\n// There are lots of things you can do with a View\n// Make the view centre around the player                \nmainView.setCenter(player.getCenter());\n// Rotate the view 45 degrees\nmainView.rotate(45)\n// Note that hudView is totally unaffected by the previous code\n```", "```cpp\n// Set the current view\nwindow.setView(mainView);\n```", "```cpp\n// Do all the drawing for this view\nwindow.draw(playerSprite);\nwindow.draw(otherGameObject);\n// etc\n```", "```cpp\n// Switch to the hudView\nwindow.setView(hudView);\n// Do all the drawing for the HUD\nwindow.draw(scoreText);\nwindow.draw(healthBar);\n// etc\n```", "```cpp\nwindow.display();\n```", "```cpp\n#include <SFML/Graphics.hpp>\n#include \"Player.h\"\nusing namespace sf;\nint main()\n{\n    return 0;\n}\n```", "```cpp\nint main()\n{\n    // The game will always be in one of four states\nenum class State { PAUSED, LEVELING_UP, \n            GAME_OVER, PLAYING };\n\n    // Start with the GAME_OVER state\n    State state = State::GAME_OVER;\n// Get the screen resolution and \n    // create an SFML window\n    Vector2f resolution;\nresolution.x = \n        VideoMode::getDesktopMode().width;\nresolution.y = \n        VideoMode::getDesktopMode().height;\n    RenderWindow window(\nVideoMode(resolution.x, resolution.y), \n        \"Zombie Arena\", Style::Fullscreen);\n    // Create a an SFML View for the main action\nView mainView(sf::FloatRect(0, 0, \n            resolution.x, resolution.y));\n    // Here is our clock for timing everything\n    Clock clock;\n    // How long has the PLAYING state been active\n    Time gameTimeTotal;\n// Where is the mouse in \n    // relation to world coordinates\n    Vector2f mouseWorldPosition;\n// Where is the mouse in \n    // relation to screen coordinates\n    Vector2i mouseScreenPosition;\n    // Create an instance of the Player class\n    Player player;\n    // The boundaries of the arena\n    IntRect arena;\n    // The main game loop\n    while (window.isOpen())\n    {\n\n    }\n    return 0;\n}\n```", "```cpp\n// The game will always be in one of four states\nenum class State { PAUSED, LEVELING_UP, GAME_OVER, PLAYING };\n// Start with the GAME_OVER state\nState state = State::GAME_OVER;\n```", "```cpp\n// Get the screen resolution and create an SFML window\nVector2f resolution;\nresolution.x = VideoMode::getDesktopMode().width;\nresolution.y = VideoMode::getDesktopMode().height;\nRenderWindow window(VideoMode(resolution.x, resolution.y), \n    \"Zombie Arena\", Style::Fullscreen);\n```", "```cpp\n// Create a an SFML View for the main action\nView mainView(sf::FloatRect(0, 0, resolution.x, resolution.y));\n```", "```cpp\n// Here is our clock for timing everything\nClock clock;\n// How long has the PLAYING state been active\nTime gameTimeTotal;\n```", "```cpp\n// Where is the mouse in relation to world coordinates\nVector2f mouseWorldPosition;\n// Where is the mouse in relation to screen coordinates\nVector2i mouseScreenPosition;\n```", "```cpp\n// Create an instance of the Player class\nPlayer player;\n```", "```cpp\n// The boundaries of the arena\nIntRect arena;\n```", "```cpp\n// The main game loop\nwhile (window.isOpen())\n{\n}\n```", "```cpp\n// The main game loop\nwhile (window.isOpen())\n{\n    /*\n    ************\n    Handle input\n    ************\n    */\n    // Handle events by polling\n    Event event;\n    while (window.pollEvent(event))\n    {\n        if (event.type == Event::KeyPressed)\n        {                                    \n            // Pause a game while playing\n            if (event.key.code == Keyboard::Return &&\n                state == State::PLAYING)\n            {\n                state = State::PAUSED;\n            }\n            // Restart while paused\n            else if (event.key.code == Keyboard::Return &&\n                state == State::PAUSED)\n            {\n                state = State::PLAYING;\n                // Reset the clock so there isn't a frame jump\n                clock.restart();\n            }\n            // Start a new game while in GAME_OVER state\n            else if (event.key.code == Keyboard::Return &&\n                state == State::GAME_OVER)\n            {\n                state = State::LEVELING_UP;\n            }\n            if (state == State::PLAYING)\n            {\n            }\n        }\n    }// End event polling\n}// End game loop\n```", "```cpp\n    }// End event polling\n    // Handle the player quitting\n    if (Keyboard::isKeyPressed(Keyboard::Escape))\n    {\n        window.close();\n    }\n    // Handle WASD while playing\n    if (state == State::PLAYING)\n    {\n        // Handle the pressing and releasing of the WASD keys\n        if (Keyboard::isKeyPressed(Keyboard::W))\n        {\n            player.moveUp();\n        }\n        else\n        {\n            player.stopUp();\n        }\n        if (Keyboard::isKeyPressed(Keyboard::S))\n        {\n            player.moveDown();\n        }\n        else\n        {\n            player.stopDown();\n        }\n        if (Keyboard::isKeyPressed(Keyboard::A))\n        {\n            player.moveLeft();\n        }\n        else\n        {\n            player.stopLeft();\n        }\n        if (Keyboard::isKeyPressed(Keyboard::D))\n        {\n            player.moveRight();\n        }\n        else\n        {\n            player.stopRight();\n        }\n    }// End WASD while playing\n}// End game loop\n```", "```cpp\n    }// End WASD while playing\n    // Handle the LEVELING up state\n    if (state == State::LEVELING_UP)\n    {\n        // Handle the player LEVELING up\n        if (event.key.code == Keyboard::Num1)\n        {\n            state = State::PLAYING;\n        }\n        if (event.key.code == Keyboard::Num2)\n        {\n            state = State::PLAYING;\n        }\n        if (event.key.code == Keyboard::Num3)\n        {\n            state = State::PLAYING;\n        }\n        if (event.key.code == Keyboard::Num4)\n        {\n            state = State::PLAYING;\n        }\n        if (event.key.code == Keyboard::Num5)\n        {\n            state = State::PLAYING;\n        }\n        if (event.key.code == Keyboard::Num6)\n        {\n            state = State::PLAYING;\n        }\n\n        if (state == State::PLAYING)\n        {            \n            // Prepare the level\n            // We will modify the next two lines later\n            arena.width = 500;\n            arena.height = 500;\n            arena.left = 0;\n            arena.top = 0;\n            // We will modify this line of code later\n            int tileSize = 50;\n            // Spawn the player in the middle of the arena\n            player.spawn(arena, resolution, tileSize);\n\n            // Reset the clock so there isn't a frame jump\n            clock.restart();\n        }\n    }// End LEVELING up\n\n}// End game loop\n```", "```cpp\n    }// End LEVELING up\n    /*\n    ****************\n    UPDATE THE FRAME\n    ****************\n    */\n    if (state == State::PLAYING)\n    {\n        // Update the delta time\n        Time dt = clock.restart();\n\n        // Update the total game time\n        gameTimeTotal += dt;\n\n        // Make a decimal fraction of 1 from the delta time\n        float dtAsSeconds = dt.asSeconds();\n        // Where is the mouse pointer\n        mouseScreenPosition = Mouse::getPosition();\n        // Convert mouse position to world coordinates of mainView\n        mouseWorldPosition = window.mapPixelToCoords(\n            Mouse::getPosition(), mainView);\n        // Update the player\n        player.update(dtAsSeconds, Mouse::getPosition());\n        // Make a note of the players new position\n        Vector2f playerPosition(player.getCenter());\n\n        // Make the view centre around the player                \n        mainView.setCenter(player.getCenter());\n    }// End updating the scene\n\n}// End game loop\n```", "```cpp\n// Update the delta time\nTime dt = clock.restart();\n```", "```cpp\n// Update the total game time\ngameTimeTotal += dt;\n```", "```cpp\n        }// End updating the scene\n        /*\n        **************\n        Draw the scene\n        **************\n        */\n        if (state == State::PLAYING)\n        {\n            window.clear();\n            // set the mainView to be displayed in the window\n            // And draw everything related to it\n            window.setView(mainView);\n            // Draw the player\n            window.draw(player.getSprite());\n        }\n        if (state == State::LEVELING_UP)\n        {\n        }\n        if (state == State::PAUSED)\n        {\n        }\n        if (state == State::GAME_OVER)\n        {\n        }\n        window.display();\n    }// End game loop\n    return 0;\n}\n```"]