- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How to Call Lua from C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will implement a C++ utility class to execute Lua scripts.
    This serves two purposes. First, by doing this, you will learn in detail how to
    integrate the Lua library and call Lua code from C++. Second, you will have a
    Lua wrapper class ready to use. This helps in hiding all the details. We will
    start with a basic Lua executor and then we will gradually add more features to
    it as we progress. You will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Lua executor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing a Lua file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing a Lua script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Lua stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating on global variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling Lua functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting from this chapter, we will focus more on code and Lua integration
    itself and will be brief about toolchain and project settings. However, you can
    always refer to the book’s GitHub repository to get the complete projects. Please
    make sure you meet the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to be able to compile the Lua library from source code. *Chapter 1*
    covered this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to be able to write some basic Lua code to test the C++ class that
    we will write. *Chapter 2* covered this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create a `Makefile` project, or use an alternative. In *Chapter 1*,
    we created three `Makefile` projects. We will create a new project for this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can access the source code for this chapter here: [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter03](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter03)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a Lua executor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will implement a reusable C++ Lua executor class step by step. Let us call
    it `LuaExecutor`. We will continue to improve this executor by adding new functions
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: How to include the Lua library in C++ code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To work with the Lua library, you only need three header files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lua.h` for core functions. Everything here has a `lua_` prefix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lauxlib.h` for the auxiliary library (`auxlib`). The auxiliary library provides
    more helper functions built on top of the core functions in `lua.h`. Everything
    here has a `luaL_` prefix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lualib.h` for loading and building Lua libraries. For example, the `luaL_openlibs`
    function opens all standard libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lua is implemented in C and those three header files are C header files. To
    work with C++, Lua provides a convenient wrapper, `lua.hpp`, whose content is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In your C++ code, `lua.hpp` is the only Lua header file you need to include.
    With this sorted out, let us start to work on our Lua executor.
  prefs: []
  type: TYPE_NORMAL
- en: C++ filename extensions
  prefs: []
  type: TYPE_NORMAL
- en: The Lua library uses `hpp` as the header file extension for `lua.hpp`. This
    is to distinguish it from other C header files from the Lua library. In this book,
    for our own C++ code, we use `h` for header files with declaration, `hpp` for
    header files that include all implementation, `cc` for C++ class implementation,
    and `cpp` for C++ code not part of a class. This is only one way to name the source
    code files. Feel free to use your own convention.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a Lua instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to get hold of “an instance” of the Lua library to execute Lua scripts.
    With some other C++ library, you might create a certain class instance and work
    with the object. With Lua, you get a **Lua state** and pass this state around
    for different operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Lua executor will hide the low-level Lua library details and provide a
    high-level API for your projects. Here is the `LuaExecutor.h` class definition
    to start with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have defined a constructor, a destructor, and a private member variable of
    type `lua_State`, which is the Lua state, and named it `L` per Lua conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `LuaExecutor.cc` class implementation for the definition so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The class encapsulates the creation and cleaning up of Lua state:'
  prefs: []
  type: TYPE_NORMAL
- en: '`luaL_newstate()` creates a new Lua state. We do this in the constructor initializer
    list.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`luaL_openlibs(L)` opens the Lua standard libraries for the provided Lua state.
    This makes library functions – for example, `string.gmatch` – available to be
    used in Lua scripts.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lua_close(L)` closes the Lua state and releases its allocated resources –
    for example, dynamically allocated memory, and so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now learn more about Lua state.
  prefs: []
  type: TYPE_NORMAL
- en: What is Lua state?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Lua library maintains no global state, instead, except for `luaL_newstate`,
    all Lua library functions expect a Lua state as the first parameter. This makes
    Lua re-entrant and it can be used for multithreaded code with little effort.
  prefs: []
  type: TYPE_NORMAL
- en: Lua state is a structure named `lua_State` that keeps all Lua internal states.
    To create a Lua state, use `luaL_newstate`. You can use Lua and treat this state
    transparently, without being concerned about its internal details.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can compare this to C++ classes. Lua state holds the class member variables
    and states. Lua library functions serve the purpose of class member functions.
    To go one step further, consider the C++ **pimpl** (pointer to implementation)
    idiom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this analogy, `class Lua` is our pseudo C++ Lua library; `struct LuaState`
    is the private implementation that defines and hides the details. In header files,
    you would only see its forward declaration, not the definition. The `openlibs`
    public member function uses `pImpl` (the Lua state) internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an advanced topic, C++ member functions will have `this` as the first parameter
    after being compiled. The Lua library functions expecting `LuaState` as their
    first parameter can be understood in a similar way: both `this` and `LuaState`
    point to the private details of the class.'
  prefs: []
  type: TYPE_NORMAL
- en: All this information is to make you feel comfortable in passing Lua state around,
    while at the same time remaining at ease with not operating on it directly. Now,
    let us go back and continue to build our Lua executor.
  prefs: []
  type: TYPE_NORMAL
- en: Executing a Lua file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *Chapter 1*, we used the Lua library to load a file and run the script.
    We will do the same here but in a more proper C++ way. In `LuaExecutor.h`, add
    the following new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can of course make all those member functions `const`, for example, `std::string
    popString() const`, because in `LuaExecutor` we only keep the Lua state `L` transparently
    and do not change its value. Here, we are omitting it to prevent too many line
    breaks in code listings.
  prefs: []
  type: TYPE_NORMAL
- en: '`executeFile` is our public function and the other two are internal helper
    functions. In `LuaExecutor.cc`, let us implement `executeFile` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We load the script with `luaL_loadfile`, providing the file path. `luaL_loadfile`
    will load the file, compile it into a **chunk**, and put it onto the **Lua stack**.
    We will explain what a chunk is and what the Lua stack is soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most Lua library functions will return 0 if they are successful. You can also
    compare the return value with `LUA_OK` explicitly, which is defined as 0\. In
    our case, if no error occurs, we will proceed to the next step to call `pcall`.
    If there is an error, we will get the error with `popString` and print it out.
    Next, implement `pcall` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In `pcall`, we execute the compiled chunk, which is already on the top of the
    stack, with `lua_pcall`. This will also remove the chunk from the stack. If an
    error occurs, we retrieve and print out the error message.
  prefs: []
  type: TYPE_NORMAL
- en: Besides `L`, `lua_pcall` takes three more parameters. We are passing 0 for them
    now. For now, you only need to know that the second parameter is the number of
    parameters the Lua chunk expects, and the third parameter is the number of values
    the Lua chunk returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will implement the last function, `popString`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This pops the top of the Lua stack as a string. We will explain more when you
    learn more about the Lua stack.
  prefs: []
  type: TYPE_NORMAL
- en: We have two concepts to explain before trying out `LuaExecutor`.
  prefs: []
  type: TYPE_NORMAL
- en: What is a chunk?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A unit of compilation in Lua is called a chunk. Syntactically, a chunk is simply
    a code block. When put on the stack, a chunk is a value of the function type.
    So, although not fully accurate, you can consider it a function, and a Lua file
    an implicit function definition. Further, functions can have embedded functions
    defined within them.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Lua stack?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Lua stack is a stack data structure. Each Lua state internally maintains a
    Lua stack. Each element in the stack can hold a reference to a piece of Lua data.
    If you recall that a function is also a basic Lua type, you will feel more comfortable
    about a stack element representing a function. Both Lua code and C++ code can
    push elements onto and pop elements from the Lua stack, either explicitly or implicitly.
    We will discuss more about the Lua stack and how our `popString` function works
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have learned about chunks and the Lua stack, two of the important concepts
    in Lua, we can test `LuaExecutor`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Lua executor so far
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test our executor, we need to write a Lua script and some C++ test code
    to call `LuaExecutor`. Write `script.lua` as the following one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will print `Hello C++` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write `main.cpp` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will create an instance of `LuaExecutor` and execute the Lua script file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, write the `Makefile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Compared to the `Makefiles` in *Chapter 1*, we have one more source file, `LuaExecutor.cc`,
    and one more header file, `LuaExecutor.h`, that the `project` target depends on.
    Remember to use tabs for indentations, not spaces. You can find explanations on
    how to write a `Makefile` in *Chapter 1* if you need to revisit it.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all the test code written, test this out in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you have done everything correctly, the code will compile. When executed,
    it will output `Hello C++`, which is from the Lua script file.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to execute Lua code from a file. Now let us try to execute
    a Lua script directly.
  prefs: []
  type: TYPE_NORMAL
- en: Executing a Lua script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some projects, you may have a file layer abstraction, or you may get a Lua
    script from a remote server. Then, you cannot pass a file path to the Lua library
    and ask it to load it for you. You may also want to load the file yourself as
    a string to do more auditing before executing it. In those situations, you can
    ask the Lua library to execute a string as a Lua script.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we will add a new capability to our Lua executor. In `LuaExecutor.h`,
    add one more function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This new function will accept the Lua code in a string directly and execute
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `LuaExecutor.cc`, add this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This new function is exactly the same as `executeFile` with only one difference.
    It calls the Lua library `luaL_loadstring` function, which compiles the string
    as Lua code and puts the compiled chunk onto the stack. Then, `pcall` will pop
    and execute the chunk.
  prefs: []
  type: TYPE_NORMAL
- en: Testing it out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us test a Lua script. We no longer need a script file now. Write `main.cpp`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells the Lua executor to run the Lua code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Make and run the project and you will see the output `Hello Lua`.
  prefs: []
  type: TYPE_NORMAL
- en: More on Lua compilation and execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As explained before, `luaL_loadstring` and `luaL_loadfile` will compile the
    Lua code, while `lua_pcall` will execute the compiled code. In our `LuaExecutor`
    implementation, we are outputting different error messages – `Failed to prepare`
    and `Failed to execute` respectively. Let us test the two different scenarios
    to understand the execution stages more.
  prefs: []
  type: TYPE_NORMAL
- en: Testing compilation errors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In `main.cpp`, change the statement to execute the Lua code and make a Lua
    syntax error intentionally, by deleting the closing parenthesis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now recompile the project and run it. You should see the following error output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`pcall` is not called at all, because the Lua code failed to compile.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the runtime error
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This time, change the Lua code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no syntax error. Recompile, run the project, and see the new error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is an execution error because the `a` variable is not defined yet, but
    we used it for division.
  prefs: []
  type: TYPE_NORMAL
- en: By now, we have a reusable Lua executor that can execute both a Lua script file
    and Lua code. Let us learn more about the Lua stack before adding even more features
    to our executor.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Lua stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Lua stack is used between C/C++ code and Lua code so that they can communicate
    with each other. Both C++ code and Lua code can operate on this stack either explicitly
    or implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen some Lua library functions reading from and writing to the stack.
    For example, `luaL_loadstring` can push a compiled chuck onto the stack, and `lua_pcall`
    pops the chunk from the stack. Let us learn some explicit ways to operate on the
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Lua library provides functions to push different types of values onto the
    stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There are more `lua_pushX` functions but the ones shown above are the basic
    ones. `lua_Number` is a type alias most likely for either `double` or `float`,
    and `lua_Integer` can be `long,` `long long`, or something else. They depend on
    how the Lua library is configured and on your operating system defaults. You would
    need to decide on the scope of the different platforms your project will support
    and how you would like to map them to C++ types. In most situations, mapping `lua_Number`
    to `double` and `lua_Integer` to `long` might be good enough, however, if required,
    you can implement it in a more portable way.
  prefs: []
  type: TYPE_NORMAL
- en: Querying elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use `lua_gettop` to check how many elements are in the stack. The first
    element in the stack is the bottom of the stack and is indexed with 1\. The second
    element is indexed as 2, and so on. You can also access the stack by referencing
    the top of the stack. In this referencing system, the top of the stack is indexed
    with -1, the second from the top is indexed with -2, and so on. You can see the
    two referencing systems in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Two ways to access stack elements](img/B20927_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Two ways to access stack elements
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the figure, each element can be indexed with two numbers.
    Using the minus number can be very convenient when you need to access the elements
    you just pushed onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to `lua_pushX` for pushing elements, we have `lua_toX` to query elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The querying functions will always convert the values to the requested type.
    This may not be what you want. In this case, you can use `lua_type` to query the
    type of the element in a given index. There are also corresponding `lua_isX` functions
    to check whether a given stack index contains a certain type.
  prefs: []
  type: TYPE_NORMAL
- en: Popping elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To remove the top `n` elements from the stack, use `lua_pop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For high-level operations in your projects, you should maintain a balanced
    stack in most situations. This means after you are done, the stack size remains
    the same as the size before you started. Compared with when you started, if you
    remove more elements from the stack, you will corrupt the stack and cause undefined
    behaviors the next time you call Lua. On the other hand, if you remove fewer elements
    from the stack, you will waste stack space, as well as causing memory leaks. So,
    popping elements correctly is important at the end of the operation. For example,
    in our `LuaExecutor::pcall` function, if there is an error, the Lua library will
    push the error message onto the stack. Because this is triggered by our action,
    we need to remove the error message with `LuaExecutor::popString`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This function first reads the top of the stack as a string and then pops the
    top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: All communications between C++ and Lua need to use the Lua stack. With a good
    understanding of the Lua stack, we can continue to learn about Lua global variables.
  prefs: []
  type: TYPE_NORMAL
- en: Operating on global variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lua global variables are accessible for the whole Lua state. Consider this
    Lua code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `hello` function uses the global variable `whom` to print out a greeting.
  prefs: []
  type: TYPE_NORMAL
- en: How do we get and set this Lua global variable from C++? We will now extend
    `LuaExecutor` to do this and use the `hello` function to test it. In this chapter,
    we will only implement the method to work with string variables to focus primarily
    on the mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Getting global variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You use the Lua library `lua_getglobal` function to get global variables. Its
    prototype is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`lua_getglobal` expects two parameters. The first one is the Lua state. The
    second one is the name for the global variable. `lua_getglobal` pushes the value
    of the global variable onto the stack and returns its type. The types are defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can check the returned type against those constants to see if the type of
    the returned data is what was expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us extend `LuaExecutor` to get global variables. In `LuaExecutor.h`, add
    a new function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will get a Lua global variable and return it as a string. Implement
    it in `LuaExecutor.cc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We call `lua_getglobal` to get the global variable and check to make sure it
    is of the string type. Then we pop it from the stack with the `popString` function
    that we implemented earlier to get the Lua library error message.
  prefs: []
  type: TYPE_NORMAL
- en: Setting global variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To set a Lua global variable from C++, we also utilize the stack. This time,
    we push the value onto the stack. The Lua library pops it and assigns it to the
    variable. The Lua library `lua_setglobal` function does the popping and assigning
    part.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add the capability to set global variables to our executor. In `LuaExecutor.h`,
    add one more function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It will set a Lua global variable. The variable’s name is provided by the `name`
    parameter, and the value is set by `value`. In `LuaExecutor.cc`, add the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The code affects the Lua stack as depicted in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Set global variable](img/B20927_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Set global variable
  prefs: []
  type: TYPE_NORMAL
- en: As explained, we first push the value onto the stack with `lua_pushstring`,
    then invoke the `lua_setglobal` library function to set the global variable. We
    have maintained a balanced stack size.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us test our implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Testing it out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will get and set the `whom` global variable and call our `hello` Lua function
    to test our Lua executor. Rewrite `main.cpp` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The test code is doing four things:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading `script.lua`, whose content is the `hello` function referencing the
    `whom` global variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling our `getGlobalString` executor function to check the value of the `whom`
    global variable and executing the Lua `hello` function to see the truth from Lua’s
    side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using our `setGlobal` executor function to change the value of `whom` to `"Lua"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verifying that `whom` has a new value from both the C++ side and the Lua side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you have done everything correctly so far, this test code will output the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Well done for making it this far in the Lua integration journey. With the knowledge
    of getting and setting global variables, let us move on to the last topic of this
    chapter: how to call Lua functions from C++.'
  prefs: []
  type: TYPE_NORMAL
- en: Calling Lua functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Lua `hello` function we used in the previous section is a good example
    to demonstrate global variables, but it is not how you would usually implement
    such a feature. Now consider a more suitable implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This Lua `greetings` function expects `whom` as a function parameter and returns
    the greeting string instead of printing it out. You can use the greeting string
    in more flexible ways, for example, by using it on a GUI window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, while learning how to execute Lua scripts, we implemented
    the `execute` function in our executor. We can invoke `greetings` with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'But this is not C++ calling a Lua function; it is a Lua script calling a Lua
    function. C++ just compiles the Lua script and has no access to the function’s
    return value. To call this function from C++ properly, C++ needs to provide the
    Lua function parameter and retrieve the return value. By now, this should not
    be a surprise: you need to use the Lua stack to do that.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing function invocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have actually learned everything we need to do this. How it works is a leap
    of faith in understanding. Let us see the code first and then the explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `LuaExecutor.h`, add a function to execute a Lua function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This function calls a Lua function, whose name is provided in `function`. It
    passes a single parameter to the Lua function and expects the Lua function to
    return a single string type value. It is not very general but is good enough for
    the purpose of learning for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `LuaExecutor.cc`, implement the `call` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We implemented `pcall` and `popString` earlier in this chapter. The `call`
    function does the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Pushes the Lua function – the name provided in the `function` parameter – onto
    the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pushes the Lua function parameter – the value provided in the `param` parameter
    – onto the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calls the Lua `lua_pcall` library function – indicating that the Lua function
    expects one parameter and returns one value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wait! The first line of code looks exactly the same as getting a global variable,
    no? Indeed, it is! Do you recall that `function` is one of the basic types in
    Lua? You are getting a global variable, whose name is the function name, and whose
    value is the function body, onto the stack. Actually, you can also write a Lua
    function this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is more cumbersome to write, but shows what is really happening under the
    hood.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us look at another similarity:'
  prefs: []
  type: TYPE_NORMAL
- en: In our Lua `execute` and `executeFile` executor functions, we first compile
    the Lua script as a chunk and put it onto the stack. Then we call `lua_pcall`,
    indicating a zero count of parameters and a zero count of return values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To call a Lua function, we first load the function onto the stack with `lua_getglobal`.
    Then we push the parameter onto the stack. Finally, we call `lua_pcall` to execute
    the Lua function, indicating it needs one parameter and will return one value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing Lua scripts is a simplified version of calling a Lua function, without
    the need to pass parameters and retrieve return values.
  prefs: []
  type: TYPE_NORMAL
- en: By looking at the similarities instead of differences, you will understand better.
    Now let us test our work.
  prefs: []
  type: TYPE_NORMAL
- en: Testing it out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rewrite `main.cpp` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This will output `"Hello next adventure"` and concludes this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we implemented a Lua executor. Not only can it load and execute
    Lua scripts, but it can also call specific Lua functions. We also learned how
    to get and set Lua global variables. During the course of the chapter, we explained
    the Lua stack.
  prefs: []
  type: TYPE_NORMAL
- en: Please take a moment to reflect on how the Lua stack changes during the process
    of calling a Lua function.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue to improve this Lua executor and work
    on Lua data types and C++ data type mappings.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implement another function in `LuaExecutor` to call a Lua function with two
    parameters and two return values. Try to use different Lua data types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `LuaExecutor`, we are using `std::cerr` to print error messages to the console.
    So far, the callers cannot get the error state. Design an interface to notify
    failures. You can pass an implementation of this interface in the `LuaExecutor`
    constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
