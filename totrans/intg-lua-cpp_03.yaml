- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: How to Call Lua from C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何从C++调用Lua
- en: 'In this chapter, we will implement a C++ utility class to execute Lua scripts.
    This serves two purposes. First, by doing this, you will learn in detail how to
    integrate the Lua library and call Lua code from C++. Second, you will have a
    Lua wrapper class ready to use. This helps in hiding all the details. We will
    start with a basic Lua executor and then we will gradually add more features to
    it as we progress. You will learn about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现一个C++实用类来执行Lua脚本。这有两个目的。首先，通过这样做，你将详细了解如何集成Lua库并从C++调用Lua代码。其次，你将拥有一个现成的Lua包装类。这有助于隐藏所有细节。我们将从一个基本的Lua执行器开始，然后随着我们的进展逐步添加更多功能。你将了解以下内容：
- en: Implementing a Lua executor
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Lua执行器
- en: Executing a Lua file
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行Lua文件
- en: Executing a Lua script
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行Lua脚本
- en: Understanding the Lua stack
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Lua堆栈
- en: Operating on global variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作全局变量
- en: Calling Lua functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用Lua函数
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Starting from this chapter, we will focus more on code and Lua integration
    itself and will be brief about toolchain and project settings. However, you can
    always refer to the book’s GitHub repository to get the complete projects. Please
    make sure you meet the following requirements:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将更多地关注代码和Lua集成本身，并对工具链和项目设置进行简要说明。然而，你始终可以参考本书的GitHub仓库以获取完整的项目。请确保你满足以下要求：
- en: You need to be able to compile the Lua library from source code. *Chapter 1*
    covered this.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要能够从源代码编译Lua库。*第一章*介绍了这一点。
- en: You need to be able to write some basic Lua code to test the C++ class that
    we will write. *Chapter 2* covered this.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要能够编写一些基本的Lua代码来测试我们将编写的C++类。*第二章*介绍了这一点。
- en: You can create a `Makefile` project, or use an alternative. In *Chapter 1*,
    we created three `Makefile` projects. We will create a new project for this chapter.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以创建一个`Makefile`项目，或者使用其他替代方案。在*第一章*中，我们创建了三个`Makefile`项目。我们将为这一章创建一个新的项目。
- en: 'You can access the source code for this chapter here: [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter03](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter03)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在此处访问本章的源代码：[https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter03](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter03)
- en: Implementing a Lua executor
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Lua执行器
- en: We will implement a reusable C++ Lua executor class step by step. Let us call
    it `LuaExecutor`. We will continue to improve this executor by adding new functions
    to it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步实现一个可重用的C++ Lua执行器类。让我们称它为`LuaExecutor`。我们将通过向其中添加新功能来继续改进这个执行器。
- en: How to include the Lua library in C++ code
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在C++代码中包含Lua库
- en: 'To work with the Lua library, you only need three header files:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要与Lua库一起工作，你只需要三个头文件：
- en: '`lua.h` for core functions. Everything here has a `lua_` prefix.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lua.h`用于核心函数。这里所有内容都有`lua_`前缀。'
- en: '`lauxlib.h` for the auxiliary library (`auxlib`). The auxiliary library provides
    more helper functions built on top of the core functions in `lua.h`. Everything
    here has a `luaL_` prefix.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lauxlib.h`用于辅助库（`auxlib`）。辅助库在`lua.h`中的核心函数之上提供了更多辅助函数。这里所有内容都有`luaL_`前缀。'
- en: '`lualib.h` for loading and building Lua libraries. For example, the `luaL_openlibs`
    function opens all standard libraries.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lualib.h`用于加载和构建Lua库。例如，`luaL_openlibs`函数打开所有标准库。'
- en: 'Lua is implemented in C and those three header files are C header files. To
    work with C++, Lua provides a convenient wrapper, `lua.hpp`, whose content is
    as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Lua是用C语言实现的，这三个头文件都是C语言的头文件。为了与C++一起工作，Lua提供了一个方便的包装器，`lua.hpp`，其内容如下：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In your C++ code, `lua.hpp` is the only Lua header file you need to include.
    With this sorted out, let us start to work on our Lua executor.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的C++代码中，`lua.hpp`是唯一需要包含的Lua头文件。解决这个问题后，让我们开始我们的Lua执行器工作。
- en: C++ filename extensions
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: C++文件名扩展名
- en: The Lua library uses `hpp` as the header file extension for `lua.hpp`. This
    is to distinguish it from other C header files from the Lua library. In this book,
    for our own C++ code, we use `h` for header files with declaration, `hpp` for
    header files that include all implementation, `cc` for C++ class implementation,
    and `cpp` for C++ code not part of a class. This is only one way to name the source
    code files. Feel free to use your own convention.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Lua库使用`hpp`作为`lua.hpp`的头文件扩展名。这是为了将其与其他Lua库的C头文件区分开来。在本书中，对于我们的C++代码，我们使用`h`作为声明头文件的扩展名，`hpp`用于包含所有实现的头文件，`cc`用于C++类实现，`cpp`用于不属于类的C++代码。这只是命名源代码文件的一种方式。请随意使用你自己的约定。
- en: Getting a Lua instance
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取 Lua 实例
- en: We need to get hold of “an instance” of the Lua library to execute Lua scripts.
    With some other C++ library, you might create a certain class instance and work
    with the object. With Lua, you get a **Lua state** and pass this state around
    for different operations.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要获取“一个”Lua 库的实例来执行 Lua 脚本。使用其他 C++ 库，你可能创建一个特定的类实例并与之交互。对于 Lua，你得到一个 **Lua
    状态**，并将此状态传递给不同的操作。
- en: 'Our Lua executor will hide the low-level Lua library details and provide a
    high-level API for your projects. Here is the `LuaExecutor.h` class definition
    to start with:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Lua 执行器将隐藏低级 Lua 库的细节，并为你的项目提供高级 API。以下是从 `LuaExecutor.h` 类定义开始的示例：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have defined a constructor, a destructor, and a private member variable of
    type `lua_State`, which is the Lua state, and named it `L` per Lua conventions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个构造函数、一个析构函数和一个类型为 `lua_State` 的私有成员变量，即 Lua 状态，按照 Lua 习惯命名为 `L`。
- en: 'Here is the `LuaExecutor.cc` class implementation for the definition so far:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是到目前为止的 `LuaExecutor.cc` 类实现的示例：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The class encapsulates the creation and cleaning up of Lua state:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类封装了 Lua 状态的创建和清理：
- en: '`luaL_newstate()` creates a new Lua state. We do this in the constructor initializer
    list.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`luaL_newstate()` 创建一个新的 Lua 状态。我们在构造函数初始化列表中这样做。'
- en: '`luaL_openlibs(L)` opens the Lua standard libraries for the provided Lua state.
    This makes library functions – for example, `string.gmatch` – available to be
    used in Lua scripts.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`luaL_openlibs(L)` 为提供的 Lua 状态打开 Lua 标准库。这使得库函数——例如，`string.gmatch`——可用于 Lua
    脚本中。'
- en: '`lua_close(L)` closes the Lua state and releases its allocated resources –
    for example, dynamically allocated memory, and so on.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lua_close(L)` 关闭 Lua 状态并释放其分配的资源——例如，动态分配的内存等。'
- en: We will now learn more about Lua state.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将更深入地了解 Lua 状态。
- en: What is Lua state?
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Lua 状态？
- en: The Lua library maintains no global state, instead, except for `luaL_newstate`,
    all Lua library functions expect a Lua state as the first parameter. This makes
    Lua re-entrant and it can be used for multithreaded code with little effort.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 库不维护全局状态，除了 `luaL_newstate`，所有 Lua 库函数都期望 Lua 状态作为第一个参数。这使得 Lua 可重入，并且可以轻松用于多线程代码。
- en: Lua state is a structure named `lua_State` that keeps all Lua internal states.
    To create a Lua state, use `luaL_newstate`. You can use Lua and treat this state
    transparently, without being concerned about its internal details.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 状态是一个名为 `lua_State` 的结构，它保存了所有 Lua 内部状态。要创建 Lua 状态，请使用 `luaL_newstate`。你可以使用
    Lua 并透明地处理这个状态，而不必关心其内部细节。
- en: 'We can compare this to C++ classes. Lua state holds the class member variables
    and states. Lua library functions serve the purpose of class member functions.
    To go one step further, consider the C++ **pimpl** (pointer to implementation)
    idiom:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这比作 C++ 类。Lua 状态持有类成员变量和状态。Lua 库函数充当类成员函数的作用。更进一步，考虑 C++ 的 **pimpl**（指向实现的指针）惯用法：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this analogy, `class Lua` is our pseudo C++ Lua library; `struct LuaState`
    is the private implementation that defines and hides the details. In header files,
    you would only see its forward declaration, not the definition. The `openlibs`
    public member function uses `pImpl` (the Lua state) internally.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类比中，`class Lua` 是我们的伪 C++ Lua 库；`struct LuaState` 是定义并隐藏细节的私有实现。在头文件中，你只会看到它的前向声明，而不是定义。`openlibs`
    公共成员函数内部使用 `pImpl`（Lua 状态）。
- en: 'As an advanced topic, C++ member functions will have `this` as the first parameter
    after being compiled. The Lua library functions expecting `LuaState` as their
    first parameter can be understood in a similar way: both `this` and `LuaState`
    point to the private details of the class.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 作为高级话题，编译后的 C++ 成员函数将 `this` 作为第一个参数。期望 `LuaState` 作为第一个参数的 Lua 库函数可以以类似的方式进行理解：`this`
    和 `LuaState` 都指向类的私有细节。
- en: All this information is to make you feel comfortable in passing Lua state around,
    while at the same time remaining at ease with not operating on it directly. Now,
    let us go back and continue to build our Lua executor.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些信息都是为了让你在传递 Lua 状态时感到舒适，同时仍然对直接操作它感到安心。现在，让我们回到 Lua 执行器的构建中继续前进。
- en: Executing a Lua file
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行 Lua 文件
- en: 'In *Chapter 1*, we used the Lua library to load a file and run the script.
    We will do the same here but in a more proper C++ way. In `LuaExecutor.h`, add
    the following new code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第一章* 中，我们使用了 Lua 库来加载文件并运行脚本。我们在这里也将这样做，但将以更合适的 C++ 方式进行。在 `LuaExecutor.h`
    中添加以下新代码：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can of course make all those member functions `const`, for example, `std::string
    popString() const`, because in `LuaExecutor` we only keep the Lua state `L` transparently
    and do not change its value. Here, we are omitting it to prevent too many line
    breaks in code listings.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以将所有这些成员函数都设置为 `const`，例如，`std::string popString() const`，因为在 `LuaExecutor`
    中我们只透明地保持 Lua 状态 `L`，并不改变其值。在这里，我们省略它以防止代码列表中出现过多的换行符。
- en: '`executeFile` is our public function and the other two are internal helper
    functions. In `LuaExecutor.cc`, let us implement `executeFile` first:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`executeFile` 是我们的公共函数，其他两个是内部辅助函数。在 `LuaExecutor.cc` 中，让我们首先实现 `executeFile`：'
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We load the script with `luaL_loadfile`, providing the file path. `luaL_loadfile`
    will load the file, compile it into a **chunk**, and put it onto the **Lua stack**.
    We will explain what a chunk is and what the Lua stack is soon.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `luaL_loadfile` 加载脚本，提供文件路径。`luaL_loadfile` 将加载文件，将其编译成 **代码块**，并将其放置到
    **Lua 栈** 上。我们将在稍后解释什么是代码块以及什么是 Lua 栈。
- en: 'Most Lua library functions will return 0 if they are successful. You can also
    compare the return value with `LUA_OK` explicitly, which is defined as 0\. In
    our case, if no error occurs, we will proceed to the next step to call `pcall`.
    If there is an error, we will get the error with `popString` and print it out.
    Next, implement `pcall` as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Lua 库函数在成功时将返回 0。你也可以将返回值与 `LUA_OK` 进行显式比较，它定义为 0。在我们的情况下，如果没有错误发生，我们将继续到下一步调用
    `pcall`。如果有错误，我们将使用 `popString` 获取错误并将其打印出来。接下来，按照以下方式实现 `pcall`：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In `pcall`, we execute the compiled chunk, which is already on the top of the
    stack, with `lua_pcall`. This will also remove the chunk from the stack. If an
    error occurs, we retrieve and print out the error message.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `pcall` 中，我们使用 `lua_pcall` 执行编译后的代码块，该代码块已经位于栈顶。这将也会从栈中移除代码块。如果发生错误，我们将检索并打印出错误信息。
- en: Besides `L`, `lua_pcall` takes three more parameters. We are passing 0 for them
    now. For now, you only need to know that the second parameter is the number of
    parameters the Lua chunk expects, and the third parameter is the number of values
    the Lua chunk returns.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `L`，`lua_pcall` 还需要三个其他参数。我们现在为它们传递 0。目前，你只需要知道第二个参数是 Lua 代码块期望的参数数量，第三个参数是
    Lua 代码块返回的值数量。
- en: 'Finally, we will implement the last function, `popString`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实现最后一个函数，`popString`：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This pops the top of the Lua stack as a string. We will explain more when you
    learn more about the Lua stack.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将 Lua 栈顶的元素作为字符串弹出。我们将在你学习更多关于 Lua 栈的知识时进行更多解释。
- en: We have two concepts to explain before trying out `LuaExecutor`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试 `LuaExecutor` 之前，我们需要解释两个概念。
- en: What is a chunk?
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是代码块？
- en: A unit of compilation in Lua is called a chunk. Syntactically, a chunk is simply
    a code block. When put on the stack, a chunk is a value of the function type.
    So, although not fully accurate, you can consider it a function, and a Lua file
    an implicit function definition. Further, functions can have embedded functions
    defined within them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 中的编译单元称为代码块。从语法上讲，代码块只是一个代码块。当放置在栈上时，代码块是函数类型的一个值。所以，虽然不是完全准确，你可以将其视为一个函数，Lua
    文件是一个隐式的函数定义。此外，函数可以在其中定义嵌套函数。
- en: What is a Lua stack?
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Lua 栈？
- en: A Lua stack is a stack data structure. Each Lua state internally maintains a
    Lua stack. Each element in the stack can hold a reference to a piece of Lua data.
    If you recall that a function is also a basic Lua type, you will feel more comfortable
    about a stack element representing a function. Both Lua code and C++ code can
    push elements onto and pop elements from the Lua stack, either explicitly or implicitly.
    We will discuss more about the Lua stack and how our `popString` function works
    later in this chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 栈是一个栈数据结构。每个 Lua 状态内部维护一个 Lua 栈。栈中的每个元素可以持有对 Lua 数据的引用。如果你还记得函数也是一个基本的 Lua
    类型，你将更舒服地认为栈元素代表一个函数。Lua 代码和 C++ 代码都可以将元素推入和从 Lua 栈中弹出，无论是显式还是隐式。我们将在本章后面讨论更多关于
    Lua 栈以及我们的 `popString` 函数是如何工作的。
- en: Now you have learned about chunks and the Lua stack, two of the important concepts
    in Lua, we can test `LuaExecutor`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了代码块和 Lua 栈，Lua 中的两个重要概念，我们可以测试 `LuaExecutor`。
- en: Testing the Lua executor so far
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 到目前为止，正在测试 Lua 执行器
- en: 'To test our executor, we need to write a Lua script and some C++ test code
    to call `LuaExecutor`. Write `script.lua` as the following one-liner:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的执行器，我们需要编写一个 Lua 脚本和一些 C++ 测试代码来调用 `LuaExecutor`。编写 `script.lua` 如下所示：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will print `Hello C++` to the console.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台打印 `Hello C++`。
- en: 'Write `main.cpp` as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 `main.cpp` 如下所示：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will create an instance of `LuaExecutor` and execute the Lua script file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个 `LuaExecutor` 实例并执行 Lua 脚本文件。
- en: 'Now, write the `Makefile`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编写 `Makefile`：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Compared to the `Makefiles` in *Chapter 1*, we have one more source file, `LuaExecutor.cc`,
    and one more header file, `LuaExecutor.h`, that the `project` target depends on.
    Remember to use tabs for indentations, not spaces. You can find explanations on
    how to write a `Makefile` in *Chapter 1* if you need to revisit it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *第一章* 中的 `Makefiles` 相比，我们有一个额外的源文件 `LuaExecutor.cc` 和一个额外的头文件 `LuaExecutor.h`，`project`
    目标依赖于它们。记住使用制表符进行缩进，而不是空格。如果你需要回顾，可以在 *第一章* 中找到如何编写 `Makefile` 的解释。
- en: 'With all the test code written, test this out in a terminal:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写完所有测试代码后，在终端中测试一下：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you have done everything correctly, the code will compile. When executed,
    it will output `Hello C++`, which is from the Lua script file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一切操作正确，代码将编译。执行时，它将输出 `Hello C++`，这是来自 Lua 脚本文件的。
- en: We have learned how to execute Lua code from a file. Now let us try to execute
    a Lua script directly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何从文件中执行 Lua 代码。现在让我们尝试直接执行一个 Lua 脚本。
- en: Executing a Lua script
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行 Lua 脚本
- en: In some projects, you may have a file layer abstraction, or you may get a Lua
    script from a remote server. Then, you cannot pass a file path to the Lua library
    and ask it to load it for you. You may also want to load the file yourself as
    a string to do more auditing before executing it. In those situations, you can
    ask the Lua library to execute a string as a Lua script.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些项目中，你可能有一个文件层抽象，或者你可能从远程服务器获取 Lua 脚本。然后，你不能传递文件路径给 Lua 库并要求它为你加载它。你也许还希望将文件作为字符串加载以在执行之前进行更多审计。在这些情况下，你可以要求
    Lua 库执行一个字符串作为 Lua 脚本。
- en: 'To do this, we will add a new capability to our Lua executor. In `LuaExecutor.h`,
    add one more function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将向我们的 Lua 执行器添加一个新功能。在 `LuaExecutor.h` 中添加一个额外的函数：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This new function will accept the Lua code in a string directly and execute
    it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新函数将直接接受字符串形式的 Lua 代码并执行它。
- en: 'In `LuaExecutor.cc`, add this implementation:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LuaExecutor.cc` 中，添加以下实现：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This new function is exactly the same as `executeFile` with only one difference.
    It calls the Lua library `luaL_loadstring` function, which compiles the string
    as Lua code and puts the compiled chunk onto the stack. Then, `pcall` will pop
    and execute the chunk.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新函数与 `executeFile` 完全相同，只有一个区别。它调用 Lua 库的 `luaL_loadstring` 函数，将字符串编译成 Lua
    代码并将编译后的代码块推入栈。然后，`pcall` 将弹出并执行代码块。
- en: Testing it out
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试它
- en: 'Let us test a Lua script. We no longer need a script file now. Write `main.cpp`
    as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一个 Lua 脚本。现在我们不再需要脚本文件。将 `main.cpp` 编写如下：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This tells the Lua executor to run the Lua code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 Lua 执行器运行 Lua 代码：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Make and run the project and you will see the output `Hello Lua`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行项目，你将看到输出 `Hello Lua`。
- en: More on Lua compilation and execution
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多关于 Lua 编译和执行的内容
- en: As explained before, `luaL_loadstring` and `luaL_loadfile` will compile the
    Lua code, while `lua_pcall` will execute the compiled code. In our `LuaExecutor`
    implementation, we are outputting different error messages – `Failed to prepare`
    and `Failed to execute` respectively. Let us test the two different scenarios
    to understand the execution stages more.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`luaL_loadstring` 和 `luaL_loadfile` 将编译 Lua 代码，而 `lua_pcall` 将执行编译后的代码。在我们的
    `LuaExecutor` 实现中，我们正在输出不同的错误消息——分别是 `Failed to prepare` 和 `Failed to execute`。让我们测试两种不同的场景，以更好地理解执行阶段。
- en: Testing compilation errors
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试编译错误
- en: 'In `main.cpp`, change the statement to execute the Lua code and make a Lua
    syntax error intentionally, by deleting the closing parenthesis:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.cpp` 中，更改执行 Lua 代码的语句，并故意删除关闭括号以制造 Lua 语法错误：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now recompile the project and run it. You should see the following error output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新编译项目并运行它。你应该会看到以下错误输出：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`pcall` is not called at all, because the Lua code failed to compile.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`pcall` 没有被调用，因为 Lua 代码编译失败。'
- en: Testing the runtime error
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试运行时错误
- en: 'This time, change the Lua code to the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，将 Lua 代码更改为以下内容：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There is no syntax error. Recompile, run the project, and see the new error:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 没有语法错误。重新编译，运行项目，并查看新的错误：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is an execution error because the `a` variable is not defined yet, but
    we used it for division.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个执行错误，因为变量 `a` 尚未定义，但我们使用了它进行除法。
- en: By now, we have a reusable Lua executor that can execute both a Lua script file
    and Lua code. Let us learn more about the Lua stack before adding even more features
    to our executor.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个可重用的 Lua 执行器，它可以执行 Lua 脚本文件和 Lua 代码。在向我们的执行器添加更多功能之前，让我们先了解更多关于 Lua
    栈的知识。
- en: Understanding the Lua stack
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Lua 栈
- en: The Lua stack is used between C/C++ code and Lua code so that they can communicate
    with each other. Both C++ code and Lua code can operate on this stack either explicitly
    or implicitly.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 栈用于 C/C++ 代码和 Lua 代码之间，以便它们可以相互通信。C++ 代码和 Lua 代码都可以显式或隐式地操作这个栈。
- en: We have seen some Lua library functions reading from and writing to the stack.
    For example, `luaL_loadstring` can push a compiled chuck onto the stack, and `lua_pcall`
    pops the chunk from the stack. Let us learn some explicit ways to operate on the
    stack.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些 Lua 库函数从栈中读取和写入。例如，`luaL_loadstring` 可以将编译后的代码块推送到栈上，而 `lua_pcall`
    则从栈中弹出代码块。让我们学习一些显式操作栈的方法。
- en: Pushing elements
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推送元素
- en: 'The Lua library provides functions to push different types of values onto the
    stack:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 库提供了将不同类型的值推送到栈上的函数：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are more `lua_pushX` functions but the ones shown above are the basic
    ones. `lua_Number` is a type alias most likely for either `double` or `float`,
    and `lua_Integer` can be `long,` `long long`, or something else. They depend on
    how the Lua library is configured and on your operating system defaults. You would
    need to decide on the scope of the different platforms your project will support
    and how you would like to map them to C++ types. In most situations, mapping `lua_Number`
    to `double` and `lua_Integer` to `long` might be good enough, however, if required,
    you can implement it in a more portable way.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多的 `lua_pushX` 函数，但上面显示的是基本函数。`lua_Number` 是一个类型别名，很可能是 `double` 或 `float`，而
    `lua_Integer` 可以是 `long`、`long long` 或其他。这取决于 Lua 库的配置和你的操作系统默认设置。你需要决定你的项目将支持的不同平台的作用域，以及你希望如何将它们映射到
    C++ 类型。在大多数情况下，将 `lua_Number` 映射到 `double` 和将 `lua_Integer` 映射到 `long` 可能已经足够好了，但如果需要，你可以以更可移植的方式实现它。
- en: Querying elements
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询元素
- en: 'We can use `lua_gettop` to check how many elements are in the stack. The first
    element in the stack is the bottom of the stack and is indexed with 1\. The second
    element is indexed as 2, and so on. You can also access the stack by referencing
    the top of the stack. In this referencing system, the top of the stack is indexed
    with -1, the second from the top is indexed with -2, and so on. You can see the
    two referencing systems in the following figure:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `lua_gettop` 来检查栈中有多少元素。栈中的第一个元素是栈底，索引为 1。第二个元素索引为 2，以此类推。你也可以通过引用栈顶来访问栈。在这个引用系统中，栈顶索引为
    -1，栈顶下第二个索引为 -2，依此类推。你可以在下面的图中看到这两种引用系统：
- en: '![Figure 3.1 – Two ways to access stack elements](img/B20927_03_01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 访问栈元素的两种方式](img/B20927_03_01.jpg)'
- en: Figure 3.1 – Two ways to access stack elements
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 访问栈元素的两种方式
- en: As you can see in the figure, each element can be indexed with two numbers.
    Using the minus number can be very convenient when you need to access the elements
    you just pushed onto the stack.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，每个元素都可以用两个数字来索引。当你需要访问刚刚推送到栈上的元素时，使用负数索引可以非常方便。
- en: 'Similar to `lua_pushX` for pushing elements, we have `lua_toX` to query elements:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与用于推送元素的 `lua_pushX` 类似，我们有 `lua_toX` 来查询元素：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The querying functions will always convert the values to the requested type.
    This may not be what you want. In this case, you can use `lua_type` to query the
    type of the element in a given index. There are also corresponding `lua_isX` functions
    to check whether a given stack index contains a certain type.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 查询函数始终会将值转换为请求的类型。这可能不是你想要的。在这种情况下，你可以使用 `lua_type` 来查询给定索引中元素的类型。还有相应的 `lua_isX`
    函数来检查给定的栈索引是否包含某种类型。
- en: Popping elements
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹出元素
- en: 'To remove the top `n` elements from the stack, use `lua_pop`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要从栈中移除最顶部的 `n` 个元素，请使用 `lua_pop`：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For high-level operations in your projects, you should maintain a balanced
    stack in most situations. This means after you are done, the stack size remains
    the same as the size before you started. Compared with when you started, if you
    remove more elements from the stack, you will corrupt the stack and cause undefined
    behaviors the next time you call Lua. On the other hand, if you remove fewer elements
    from the stack, you will waste stack space, as well as causing memory leaks. So,
    popping elements correctly is important at the end of the operation. For example,
    in our `LuaExecutor::pcall` function, if there is an error, the Lua library will
    push the error message onto the stack. Because this is triggered by our action,
    we need to remove the error message with `LuaExecutor::popString`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中的高级操作中，大多数情况下你应该保持堆栈平衡。这意味着在你完成之后，堆栈大小保持与开始之前相同。与开始时相比，如果你从堆栈中移除更多元素，你将破坏堆栈，并在下次调用
    Lua 时导致未定义的行为。另一方面，如果你从堆栈中移除较少的元素，你将浪费堆栈空间，并可能导致内存泄漏。因此，在操作结束时正确弹出元素非常重要。例如，在我们的
    `LuaExecutor::pcall` 函数中，如果有错误，Lua 库将错误消息推送到堆栈上。因为这是由我们的操作触发的，我们需要使用 `LuaExecutor::popString`
    来移除错误消息：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function first reads the top of the stack as a string and then pops the
    top of the stack.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先将堆栈顶部的元素读取为字符串，然后弹出堆栈顶部。
- en: All communications between C++ and Lua need to use the Lua stack. With a good
    understanding of the Lua stack, we can continue to learn about Lua global variables.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 C++ 和 Lua 之间的通信都需要使用 Lua 堆栈。有了对 Lua 堆栈的良好理解，我们可以继续学习 Lua 全局变量。
- en: Operating on global variables
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对全局变量进行操作
- en: 'Lua global variables are accessible for the whole Lua state. Consider this
    Lua code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 全局变量在整个 Lua 状态中都是可访问的。考虑以下 Lua 代码：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `hello` function uses the global variable `whom` to print out a greeting.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello` 函数使用全局变量 `whom` 打印问候语。'
- en: How do we get and set this Lua global variable from C++? We will now extend
    `LuaExecutor` to do this and use the `hello` function to test it. In this chapter,
    we will only implement the method to work with string variables to focus primarily
    on the mechanism.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何从 C++ 获取和设置这个 Lua 全局变量？现在我们将扩展 `LuaExecutor` 来实现这一点，并使用 `hello` 函数来测试它。在本章中，我们只实现与字符串变量一起工作的方法，主要关注机制。
- en: Getting global variables
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取全局变量
- en: 'You use the Lua library `lua_getglobal` function to get global variables. Its
    prototype is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 Lua 库的 `lua_getglobal` 函数来获取全局变量。其原型如下：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`lua_getglobal` expects two parameters. The first one is the Lua state. The
    second one is the name for the global variable. `lua_getglobal` pushes the value
    of the global variable onto the stack and returns its type. The types are defined
    as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`lua_getglobal` 需要两个参数。第一个是 Lua 状态。第二个是全局变量的名称。`lua_getglobal` 将全局变量的值推送到堆栈上并返回其类型。类型如下定义：'
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can check the returned type against those constants to see if the type of
    the returned data is what was expected.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将返回的类型与这些常量进行比较，以查看返回的数据类型是否符合预期。
- en: 'Let us extend `LuaExecutor` to get global variables. In `LuaExecutor.h`, add
    a new function declaration:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展 `LuaExecutor` 来获取全局变量。在 `LuaExecutor.h` 中，添加一个新的函数声明：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This function will get a Lua global variable and return it as a string. Implement
    it in `LuaExecutor.cc`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将获取一个 Lua 全局变量并将其作为字符串返回。在 `LuaExecutor.cc` 中实现它：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We call `lua_getglobal` to get the global variable and check to make sure it
    is of the string type. Then we pop it from the stack with the `popString` function
    that we implemented earlier to get the Lua library error message.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 `lua_getglobal` 来获取全局变量并检查它是否为字符串类型。然后我们使用我们之前实现的 `popString` 函数从堆栈中弹出它以获取
    Lua 库的错误消息。
- en: Setting global variables
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置全局变量
- en: To set a Lua global variable from C++, we also utilize the stack. This time,
    we push the value onto the stack. The Lua library pops it and assigns it to the
    variable. The Lua library `lua_setglobal` function does the popping and assigning
    part.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 C++ 设置 Lua 全局变量，我们同样使用堆栈。这次，我们将值推送到堆栈上。Lua 库将其弹出并分配给变量。Lua 库的 `lua_setglobal`
    函数执行弹出和分配的部分。
- en: 'We will add the capability to set global variables to our executor. In `LuaExecutor.h`,
    add one more function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向我们的执行器添加设置全局变量的功能。在 `LuaExecutor.h` 中，添加一个额外的函数：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It will set a Lua global variable. The variable’s name is provided by the `name`
    parameter, and the value is set by `value`. In `LuaExecutor.cc`, add the implementation:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 它将设置一个 Lua 全局变量。变量的名称由 `name` 参数提供，值由 `value` 设置。在 `LuaExecutor.cc` 中添加实现：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The code affects the Lua stack as depicted in the following figure:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 代码影响 Lua 栈，如图所示：
- en: '![Figure 3.2 – Set global variable](img/B20927_03_02.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 设置全局变量](img/B20927_03_02.jpg)'
- en: Figure 3.2 – Set global variable
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 设置全局变量
- en: As explained, we first push the value onto the stack with `lua_pushstring`,
    then invoke the `lua_setglobal` library function to set the global variable. We
    have maintained a balanced stack size.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如解释的那样，我们首先使用 `lua_pushstring` 将值推入栈中，然后调用 `lua_setglobal` 库函数来设置全局变量。我们保持了栈大小的平衡。
- en: Now, let us test our implementations.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试我们的实现。
- en: Testing it out
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试操作
- en: 'We will get and set the `whom` global variable and call our `hello` Lua function
    to test our Lua executor. Rewrite `main.cpp` as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获取和设置 `whom` 全局变量，并调用我们的 `hello` Lua 函数来测试我们的 Lua 执行器。将 `main.cpp` 修改如下：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The test code is doing four things:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码做了以下四件事情：
- en: Loading `script.lua`, whose content is the `hello` function referencing the
    `whom` global variable.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载 `script.lua`，其内容是引用 `whom` 全局变量的 `hello` 函数。
- en: Calling our `getGlobalString` executor function to check the value of the `whom`
    global variable and executing the Lua `hello` function to see the truth from Lua’s
    side.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用我们的 `getGlobalString` 执行函数来检查 `whom` 全局变量的值，并执行 Lua `hello` 函数以从 Lua 的角度看到真相。
- en: Using our `setGlobal` executor function to change the value of `whom` to `"Lua"`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的 `setGlobal` 执行函数将 `whom` 的值更改为 `"Lua"`。
- en: Verifying that `whom` has a new value from both the C++ side and the Lua side.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 C++ 方面和 Lua 方面验证 `whom` 是否具有新的值。
- en: 'If you have done everything correctly so far, this test code will output the
    following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你到目前为止一切操作正确，这个测试代码将输出以下内容：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Well done for making it this far in the Lua integration journey. With the knowledge
    of getting and setting global variables, let us move on to the last topic of this
    chapter: how to call Lua functions from C++.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lua 集成之旅中走这么远，做得很好。在了解获取和设置全局变量的知识后，让我们继续本章的最后一个主题：如何从 C++ 调用 Lua 函数。
- en: Calling Lua functions
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 Lua 函数
- en: 'The Lua `hello` function we used in the previous section is a good example
    to demonstrate global variables, but it is not how you would usually implement
    such a feature. Now consider a more suitable implementation:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中我们使用的 Lua `hello` 函数是一个很好的例子，用来展示全局变量，但它并不是你通常实现此类功能的方式。现在考虑一个更合适的实现：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This Lua `greetings` function expects `whom` as a function parameter and returns
    the greeting string instead of printing it out. You can use the greeting string
    in more flexible ways, for example, by using it on a GUI window.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Lua `greetings` 函数期望 `whom` 作为函数参数，并返回问候字符串而不是打印它。你可以更灵活地使用问候字符串，例如，在 GUI
    窗口中使用它。
- en: 'Earlier in this chapter, while learning how to execute Lua scripts, we implemented
    the `execute` function in our executor. We can invoke `greetings` with it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，当我们学习如何执行 Lua 脚本时，我们在执行器中实现了 `execute` 函数。我们可以用这个函数来调用 `greetings`：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'But this is not C++ calling a Lua function; it is a Lua script calling a Lua
    function. C++ just compiles the Lua script and has no access to the function’s
    return value. To call this function from C++ properly, C++ needs to provide the
    Lua function parameter and retrieve the return value. By now, this should not
    be a surprise: you need to use the Lua stack to do that.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是 C++ 调用 Lua 函数；这是一个 Lua 脚本调用 Lua 函数。C++ 只是编译 Lua 脚本，无法访问函数的返回值。要从 C++ 正确调用此函数，C++
    需要提供 Lua 函数参数并检索返回值。到目前为止，这应该不会令人惊讶：你需要使用 Lua 栈来完成这个操作。
- en: Implementing function invocation
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现函数调用
- en: We have actually learned everything we need to do this. How it works is a leap
    of faith in understanding. Let us see the code first and then the explanation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上已经学到了完成这项工作所需的一切。它的工作原理是对理解的一次飞跃。让我们先看看代码，然后再进行解释。
- en: 'In `LuaExecutor.h`, add a function to execute a Lua function:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LuaExecutor.h` 中添加一个执行 Lua 函数的函数：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This function calls a Lua function, whose name is provided in `function`. It
    passes a single parameter to the Lua function and expects the Lua function to
    return a single string type value. It is not very general but is good enough for
    the purpose of learning for now.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数调用一个 Lua 函数，其名称由 `function` 提供。它向 Lua 函数传递一个参数，并期望 Lua 函数返回一个单一字符串类型的值。它现在并不非常通用，但对于目前的学习目的来说已经足够好了。
- en: 'In `LuaExecutor.cc`, implement the `call` function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LuaExecutor.cc` 中实现 `call` 函数：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We implemented `pcall` and `popString` earlier in this chapter. The `call`
    function does the following things:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面实现了 `pcall` 和 `popString`。`call` 函数执行以下操作：
- en: Pushes the Lua function – the name provided in the `function` parameter – onto
    the stack.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Lua 函数——在 `function` 参数中提供的名称——推入栈中。
- en: Pushes the Lua function parameter – the value provided in the `param` parameter
    – onto the stack.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Lua 函数参数——在 `param` 参数中提供的值——推入栈中。
- en: Calls the Lua `lua_pcall` library function – indicating that the Lua function
    expects one parameter and returns one value.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 Lua 的 `lua_pcall` 库函数——表示 Lua 函数期望一个参数并返回一个值。
- en: 'Wait! The first line of code looks exactly the same as getting a global variable,
    no? Indeed, it is! Do you recall that `function` is one of the basic types in
    Lua? You are getting a global variable, whose name is the function name, and whose
    value is the function body, onto the stack. Actually, you can also write a Lua
    function this way:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！代码的第一行看起来和获取全局变量完全一样，不是吗？确实如此！你还记得 `function` 是 Lua 中的基本类型之一吗？你正在将一个全局变量推入栈中，其名称是函数名，其值是函数体。实际上，你也可以用这种方式编写
    Lua 函数：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is more cumbersome to write, but shows what is really happening under the
    hood.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这写起来比较繁琐，但展示了底层实际发生的事情。
- en: 'Now, let us look at another similarity:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个相似之处：
- en: In our Lua `execute` and `executeFile` executor functions, we first compile
    the Lua script as a chunk and put it onto the stack. Then we call `lua_pcall`,
    indicating a zero count of parameters and a zero count of return values.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的 Lua `execute` 和 `executeFile` 执行函数中，我们首先将 Lua 脚本编译为一个代码块并将其推入栈中。然后我们调用
    `lua_pcall`，表示参数数量为零和返回值数量为零。
- en: To call a Lua function, we first load the function onto the stack with `lua_getglobal`.
    Then we push the parameter onto the stack. Finally, we call `lua_pcall` to execute
    the Lua function, indicating it needs one parameter and will return one value.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要调用 Lua 函数，我们首先使用 `lua_getglobal` 将函数加载到栈中。然后我们将参数推入栈中。最后，我们调用 `lua_pcall` 来执行
    Lua 函数，表示它需要一个参数并将返回一个值。
- en: Executing Lua scripts is a simplified version of calling a Lua function, without
    the need to pass parameters and retrieve return values.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 Lua 脚本是一个简化版的调用 Lua 函数，无需传递参数和检索返回值。
- en: By looking at the similarities instead of differences, you will understand better.
    Now let us test our work.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察相似之处而不是差异，你会更好地理解。现在让我们测试我们的工作。
- en: Testing it out
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: 'Rewrite `main.cpp` as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `main.cpp` 重新编写如下：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will output `"Hello next adventure"` and concludes this chapter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出 `"Hello next adventure"` 并结束本章内容。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we implemented a Lua executor. Not only can it load and execute
    Lua scripts, but it can also call specific Lua functions. We also learned how
    to get and set Lua global variables. During the course of the chapter, we explained
    the Lua stack.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实现了一个 Lua 执行器。它不仅能够加载和执行 Lua 脚本，还能够调用特定的 Lua 函数。我们还学习了如何获取和设置 Lua 全局变量。在章节的过程中，我们解释了
    Lua 栈。
- en: Please take a moment to reflect on how the Lua stack changes during the process
    of calling a Lua function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请花点时间思考在调用 Lua 函数的过程中 Lua 栈是如何变化的。
- en: In the next chapter, we will continue to improve this Lua executor and work
    on Lua data types and C++ data type mappings.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续改进这个 Lua 执行器，并处理 Lua 数据类型和 C++ 数据类型映射。
- en: Exercises
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Implement another function in `LuaExecutor` to call a Lua function with two
    parameters and two return values. Try to use different Lua data types.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LuaExecutor` 中实现另一个函数，用于调用具有两个参数和两个返回值的 Lua 函数。尝试使用不同的 Lua 数据类型。
- en: In `LuaExecutor`, we are using `std::cerr` to print error messages to the console.
    So far, the callers cannot get the error state. Design an interface to notify
    failures. You can pass an implementation of this interface in the `LuaExecutor`
    constructor.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LuaExecutor` 中，我们使用 `std::cerr` 将错误信息打印到控制台。到目前为止，调用者无法获取错误状态。设计一个接口来通知失败。你可以在
    `LuaExecutor` 构造函数中传递此接口的实现。
