- en: Data Structures and Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created classes for the `stack` and `queue` abstract
    datatypes. In this chapter, we will continue with the `list` and `set` abstract
    datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the stack and queue of the previous chapter, a list is an ordered
    structure with a beginning and an end. However, it is possible to add and remove
    values at any position in the list. It is also possible to iterate through the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: A set, on the other hand, is an unordered structure of values. The only thing
    we can say about a set is whether a certain value is present. We cannot say that
    a value has any position in relation to any other value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a rather simple and ineffective version of the list and set
    classes. We will also look into basic algorithms for searching and sorting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we will continue by creating more advanced versions of the list and set
    classes, and look into more advanced searching and sorting algorithms. We will
    also introduce new concepts such as templates, operator overloading, exceptions,
    and reference overloading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also look into the searching algorithms linear search, which works on
    every sequence, ordered and unordered, but is rather ineffective, and binary search,
    which is more effective but only works on ordered sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will study the rather simple sorting algorithms, insert sort, select
    sort, and bubble sort, as well as the more advanced and more effective merge sort
    and quick sort algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The List class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `LinkedList` class is a more complicated abstract data type than the stack
    and the queue. It is possible to add and remove values at any location in the
    list. It is also possible to iterate through the list.
  prefs: []
  type: TYPE_NORMAL
- en: The Cell class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cell of this section is an extension of the cell of the `stack` and `queue`
    sections. Similar to them, it holds a value and a pointer to the next cell. However,
    this version also holds a pointer to the previous cell, which makes the list of
    this section a double-linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the constructor is `private`, which means that the cell object can
    be created by its own methods only. However, there is a way to circumvent that
    limitation. We can define a class or a function to be a friend of `LinkedList`.
    In this way, we define `LinkedList` as a friend of `Cell`. This means that `LinkedList`
    has access to all private and protected members of `Cell`, including the constructor,
    and can thereby create `Cell` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cell.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Cell.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Iterator class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When going through a list, we need an iterator, which is initialized to the
    beginning of the list and step-wise moves to its end. Similar to the preceding
    cell, the constructor of `Iterator` is private, but we define `LinkedList` as
    a friend of `Iterator` too.
  prefs: []
  type: TYPE_NORMAL
- en: '**Iterator.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The third constructor is a `copy` constructor. It takes another iterator and
    then copies it. We cannot just accept the iterator as a parameter. Instead, we
    define a reference parameter. The ampersands (&) states that the parameter is
    a reference to an iterator object rather than an iterator object. In this way,
    the memory address of the iterator is sent as a parameter instead of the object
    itself. We also state that the object referred to is constant, so that it cannot
    be altered by the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, it is necessary to use a reference parameter. If we had defined
    a simple iterator object as a parameter it would have caused indefinite circular
    initialization. However, in other cases, we use this technique for efficiency
    reasons. It takes less time and requires less memory to pass the address of the
    object than to copy the object itself as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hasNext` methods returns `true` if the iterator has not yet reached the
    end of the list, and `next` moves the iterator one step forwards, towards the
    end of the list, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, the `hasPrevious` method returns `true` if the iterator has
    not yet reached the beginning of the list, and `previous` moves the iterator one
    step backward, to the beginning of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Iterator.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The List class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `LinkedList` class holds methods for finding, adding, inserting, and removing
    values, as well as comparing lists. Moreover, it also holds methods for reading
    and writing the list, and iterating through the list both forwards and backwards.
    The linked list is in fact a double-linked list. We can follow the links of the
    cells in both directions: from the beginning to the end as well as backwards from
    the end to the beginning.'
  prefs: []
  type: TYPE_NORMAL
- en: '**LinkedList.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `copy` constructor and the `assign` method both copies the given list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor deallocates all memory allocated for the cells in the linked
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `find` methods search for the `value`. If it finds the `value`, it returns
    `true` and sets `findIterator` to the position of the `value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `equal` and `notEqual` methods compare this linked list to the given linked
    list and return `true` if they are equal or not equal, respectively, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we want to add a value or another list to an existing list? The `add`
    methods adds a value or another list at the end of this list, and `insert` inserts
    a value or a list at the position given by the iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `erase` method erases the value at the given position, and `clear` erases
    every value in the list, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `remove` method removes the values from the first iterator to the last
    iterator, inclusive. The second parameter is a default parameter. It means that
    the method can be called with one or two parameters. In case of one parameter,
    the second parameter is given the value in the declaration, which in this case
    is the `Iterator(nullptr)` that represents the position one step beyond the end
    of the list. This implies that when `remove` is called with one iterator, every
    value from that iterator, inclusive, to the end of the list are removed.  The
    `nullptr` pointer is in fact a special pointer that is converted to the type it
    points at or is compared to. In this case, a pointer to `Cell`. Informally, we
    can say that a point is null when it holds the value `nullptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `first` and `last` methods return iterators located at the first and last
    value of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `read` and `write` methods read the values of the list from an input file
    stream and write its values to an output file stream. A file stream is used to
    communicate with a file. Note that the `cin` and `cout` objects, which we have
    used in earlier sections, are in fact input and output stream objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the queue of the earlier section, the list holds pointers to the
    first and last cell in the linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**LinkedList.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `copy` constructor simply calls `assign` to copy the values of the `list`
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `assign` method copies the given list into its own linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor simply calls clear to deallocate all the memory allocated by
    the cells of the linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clear` method iterates through the linked list and deallocates every cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For each cell in the linked list, we must first save its address in `deleteCellPtr`,
    move forward in the linked list, and deallocate the cell. If we would simply call
    `delete` on `currCellPtr`, the following call to `getNext` would not work since,
    in that case, we would call a method of a deallocated object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When the list has become empty, both cell pointers are null and the size is
    zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `find` method iterates through the linked list, sets `findIterator`, and
    returns `true` when it has found the value. If it does not find the value, `false`
    is returned and `findIterator` remains unaffected. In order for this to work,
    `findIterator` must be a reference to an `Iterator` object rather than an `Iterator`
    object itself. A pointer to an `Iterator` object would also work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If two lists have different sizes, they are not equal. Likewise, if they have
    the same size, but not the same values, they are not equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the list holds the same size and the same values, they are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have to decide whether two lists are not equal, we simply call `equal`.
    The exclamation mark (`!`) is the logical `not` operator, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When adding a value to the list, we dynamically allocate a cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If the first cell pointer is null, we set it to point at the new cell since
    the list is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the first cell pointer is not null, the list is not empty, and
    we set the next pointer of the last cell pointer to point at the new cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Either way, we set the last cell pointer to point at the new cell and increase
    the size of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Adding a list to an existing list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When adding a whole list to the list, we act the same way for each value in
    the list as when we added a single value in `add` previously. We dynamically allocate
    a new cell, if the first cell pointer is null, we assign it to point at the new
    cell. If it is not null, we assign the last cell pointer''s next-pointer to point
    at the new cell. Either way, we set the last cell pointer to point at a new cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `while` statement repeats for as long as its condition is true. In this
    case, for as long as we have not reached the end of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If `m_firstList` is null, our linked list is still empty and `newCellPtr` points
    to the first cell of a new linked list. In that case, we let `m_firstList` point
    at the new cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If `m_firstList` is not null, our list is not empty and `m_firstList` shall
    not be modified. Instead, we set the next pointer of `m_lastCellPtr` to point
    at the new cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Either way, the last cell pointer is set to the new cell pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the list cell pointer is set to point at its next cell pointer. Eventually,
    the list cell pointer will be null and the `while` statement is finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When inserting a value at the position given by the iterator, we set its previous
    pointer to point at the cell before the position in the list (which is null if
    the position is the first one in the list). We then check whether the first cell
    pointer is null in the same way as in the preceding `add` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When inserting a list, we begin by checking whether the position represents
    the null pointer. In that case, the position is beyond the end of our list, and
    we just call `add` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We check whether the list to be inserted is empty by comparing `firstInsertCellPtr` with
    `nullptr`. Since `firstInsertCellPtr` points at the first value of the list, the
    list is empty if it is null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Erasing a value from the list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `erase` method simply calls `remove` with the given position as both its
    start and end position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'When erasing a value from the list, we iterate through the list and deallocate
    the cell for each value to be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have to erase the cells, we have three cases to consider. If the last
    cell before the first removed cell is not null, meaning that there is a part of
    the list remaining before the remove position, we set its next pointer to point
    at the first cell after the removed position. If the last cell before the first
    removed cell is null, we set the first cell pointer to point at that cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We do the same thing with the position of the list remaining after the last
    cell to be removed. If there is a remaining part of the list left, we set its
    first cell''s previous pointer to the last cell of the list remaining before the
    removed part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When reading a list, we first read its `size`. Then we read the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'When writing a list, we write the values separated by commas and enclosed by
    brackets ("`[`" and "`]`"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We test the list by adding some values and iterate through them, forwards and
    backward.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing the code, the output is displayed in a command window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12893731-9b8b-4a4b-a928-55a543679ee5.png)'
  prefs: []
  type: TYPE_IMG
- en: The Set class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A set is an unordered structure without duplicates. The `Set` class is a subclass
    of `LinkedList`. Note that the inheritance is private, causing all public and
    protected members of `LinkedList` to be private in `Set`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Set.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `equal` method returns `true` if the set has the values. Note that we do
    not care about any order in the set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `exists` method returns `true` if the given value, or each value in the
    given set, respectively, is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `insert` method inserts the given value or each value of the given set.
    It only inserts values not already present in the set, since a set holds no duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `remove` method removes the given value or each value of the given set,
    if present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `size`, `empty`, and `first` methods simply call their counterparts in
    `LinkedList`. Since there is no order in a set it would be meaningless to also
    override `end` in `LinkedList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `unionSet`, `intersection`, and `difference` free-standing functions are
    friends to `Set`, which means that they have access to all private and protected
    members of `Set`.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot name the `unionSet` method `union` since it is a keyword in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that when a method in a class is marked as a `friend`, it is in fact not
    a method of that class, but rather a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `read` and `write` methods read and write the set in the same way as their
    counterparts in `LinkedList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `unionSet`, `intersection`, and `difference` functions that were friends
    of `Set` are declared outside the class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '**Set.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructors call their counterparts in `LinkedList`. The default constructor
    (without parameters) calls, in fact, the default constructor of `LinkedList` implicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor calls implicitly its counterparts in `LinkedList`, which deallocates
    the memory associated with the values of the set. In this case, we could have
    omitted the destructor, and the destructor of `LinkedList` would still be called
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `assign` method simply clears the set and adds the given set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The sets are equal if they have the same `size`, and if every value of one
    set is present in the other set. In that case, every value of the other set must
    also be present in the first set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `exists` method uses the iterator of `LinkedList` to iterate through the
    set. It returns `true` if it finds the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The second `exists` method iterates through the given set and returns `false`
    if any of its values are not present in the set. It returns `true` if all its
    values are present in the set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `insert` method adds the value if it is not already present in the
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The second `insert` method iterates through the given set and inserts every
    value by calling the first insert method. In this way, each value not already
    present in the set is inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `remove` method removes the value and returns `true` if it is present
    in the set. If it is not present, it returns `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The second `remove` method iterates through the given set and removes each
    of its values. It returns `true` if at least one value is removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Union, intersection, and difference operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `unionSet` function creates a resulting set initialized with the left-hand
    set and then adds the right-hand set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The `intersection` method is a little bit more complicated than the `union`
    or `difference` methods. The intersection of two sets, A and B, can be defined
    as the difference between their union and their differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A∩B=(A∪B)-((A-B)-(B-A))*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The `difference` method creates a result set with the left-hand set and then
    removes the right-hand set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `read` method is similar to its counterpart in `LinkedList`. However, `insert`
    is called instead of `add`. In this way, no duplicates are inserted in the set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The `write` method is also similar to its counterpart in `LinkedList`. However,
    the set is enclosed in brackets ("`{`" and "`}`") instead of squares ("`[`" and
    "`]`"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: We test the set by letting the user input two sets and evaluate their union,
    intersection, and difference.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Basic searching and sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will also study some searching and sorting algorithms. When
    searching for a value with linear search we simply go through the list from its
    beginning to its end. We return the zero-based index of the value, or minus one
    if it was not found.
  prefs: []
  type: TYPE_NORMAL
- en: '**Search.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '**Search.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `first` method of the list to obtain the iterator that we use to
    go through the list; `hasNext` returns `true` as long as there is another value
    in the list and `next` moves the iterator one step forward in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Now we study the select sort, insert sort, and bubble sort algorithms. Note
    that they take a reference to the list, not the list itself, a parameter in order
    for the list to become changed. Also note that the reference is not constant in
    these cases; if it was constant we would not be able to sort the list.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sort.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '**Sort.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The select sort algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The select sort algorithm is quite simple, we iterate through the list repeatedly
    until it becomes empty. For each iteration, we found the smallest value, which
    we remove from the list and add to the resulting list. In this way, the resulting
    list will eventually be filled with the same values as the list. As the values
    were selected in order, the resulting list is sorted. Finally, we assign the resulting
    list to the original list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The insert sort algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the insert sort algorithm, we iterate through the list, and for each value
    we insert it at its appropriate location in the resulting list. Then we assign
    the resulting list to the original list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The `insert` function takes a list and a value and places the value at its
    correct location in the list. It iterates through the list and places the value
    before the first value that it is less. If there is no such value in the list,
    the value is added at the end of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The bubble sort algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bubble sort algorithm compares the values pairwise and lets them change
    place if they occur in the wrong order. After the first iteration, we know that
    the largest value is located at the end of the list. Therefore, we do not need
    to iterate through the whole list the second time, we can omit the last value.
    In this way, we iterate through the list at most the number of the values in the
    list minus one, because when all values except the first one is at it''s correct
    location, the first one is also at its correct location. However, the list may
    be properly sorted before that. Therefore, we check after each iteration if any
    pair of values has been swapped. If they have not, the list has been properly
    sorted and we exit the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The `swap` function swaps the values at the locations given by the iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: We test the algorithms by adding some values to a list, and then sort the list.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `iterator` class to go through the list and call `linarySearch`
    for each value in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We also test the search algorithm for values not present in the list, their
    indexes will be minus one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'We sort the list by the bubble sort, select sort, and insert sort algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: One way to classify searching and sorting algorithms is to use the big O notation.
    Informally speaking, the notation focuses on the worst-case scenario. In the insert
    sort case, we iterate through the list once for each value, and for each value,
    we may have to iterate through the whole list to find its correct location. Likewise,
    in the select sort case we iterate through the list once for each value, and for
    each value, we may need to iterate through the whole list.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the bubble sort case, we iterate through the list once for each
    value and we may have to iterate through the whole list for each value. In all
    three cases, we may have to perform *n*² operations on a list of *n* values. Therefore,
    the insert, select, and bubble sort algorithms have the big-O *n*², or O (*n*²)
    with regards to their time efficiency. However, when it comes to their space efficiency,
    bubble sort is better since it operates on the same list, while insert and select
    sort demand an extra list for the resulting sorted list.
  prefs: []
  type: TYPE_NORMAL
- en: The extended List class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will revisit the `LinkedList` class. However, we will expand
    it in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Cell` class had a set of `set` and `get` methods. Instead, we will replace
    each pair with a pair of overloaded reference methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The previous list could only store values of the type `double`. Now we will
    define the list to be `template`, which allows it to store values of arbitrary
    types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will replace some of the methods with overloaded operators*.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cell` and `Iterator` were free-standing classes. Now we will let them be inner
    classes, defined inside `LinkedList`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**List.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'In the classes of the earlier sections, the list stored values of the type
    `double`. However, in these classes, instead of `double` we use the template type
    `T`, which is a generic type that can be instantiated by any arbitrary type. The
    `LinkedList` class of this section is `template`, with the generic type `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The `value` method is overloaded in two versions. The first version is constant
    and returns a constant value. The other version is not constant and returns a
    reference to the value. In this way, it is possible to assign values to the cell''s
    value, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Cell*&` construct means that the methods return a reference to a pointer
    to a `Cell` object. That reference can then be used to assign a new value to the
    pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of `equal` and `notEqual`, we overload the equal and not-equal operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We also replace the increment and decrement methods with the increment (`++`)
    and decrement (`--`) operators. They come in two versions each—prefix and postfix.
    The version without parameters is the prefix version (`++i` and `--i`) and the
    version with an integer parameter is the postfix version (`i++` and `i--`). Note
    that we actually do not pass an integer parameter to the operator. The parameter
    is included only to distinguish between the two versions, and is ignored by the
    compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We replace the `getValue` and `setValue` methods with two overloaded dereference
    operators (`*`). They work in a way similar to the `value` methods in the preceding `Cell`
    class. The first version is constant and returns a value, while the second version
    is not constant and returns a reference to the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The ReverseIterator class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to iterate from the end to the beginning, as well as from the beginning
    to the end, we add `ReverseIterator`. It is nearly identical to `Iterator` used
    previously; the only difference is that the increment and decrement operators
    move in opposite directions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'In the earlier section, there was only the `first` and `last` methods, which
    return an iterator. In this section, the `begin` and `end` methods are used for
    forward iteration, while `rbegin` and `rend` (stands for reverse begin and reverse
    end) are used for backward iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We replace the `read` and `write` methods with overloaded input and output
    stream operators. Since they are functions rather than methods, they need their
    own template markings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Note that when we implement the methods of a `template` class, we do so in the
    header file. Consequently, we do not need an implementation file when implementing
    a `template` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the class definitions, the method definitions must be preceded by
    the `template` keyword. Note that the class name `LinkedList` is followed by the
    type marker `<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that when we implement a method of an inner class, we need to include
    both the names of the outer class (`LinkedList`) and inner class (`Cell`) in the
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `LinkedList` is a `template` class, it is not known to the compiler that
    its inner class `Iterator` is, in fact, a class. As far as the compiler knows,
    the iterator could be a type, a value, or a class. Therefore, we need to inform
    the compiler by using the `typename` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The following operator versions are implemented in the same way as its method
    counterparts in the previous version of `LinkedList`. That is, the `equal` method
    has been replaced by the equation operator (`operator==`), and the `notEqual`
    method has been replaced by the not-equal operator (`operator!=`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The increase operator has been replaced with both the prefix and postfix version
    of `operator++`. The difference between them is that the prefix version does not
    take any parameters, while the postfix version takes a single integer value as
    parameter. Note that the integer value is not used by the operator. Its value
    is undefined (however, it is usually set to zero) and is always ignored. It is
    present only to distinguish between the prefix and postfix cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The `decrease` operator also comes in a prefix and a postfix version, and works
    in a way similar to the `increase` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The dereference operator also comes in two versions. The first version is constant
    and returns a value. The second version is not constant and returns a reference
    to the value, instead of the value itself. In this way, the first version can
    be called on a constant object, in which case we are not allowed to change its
    value. The second version can be called on a non-constant object only, we can
    change the value by assigning a new value to the value returned by the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three constructors of the `ReverseIterator` class. The first constructor
    is a default constructor, the second constructor is initialized with a `Cell`
    pointer, and the third constructor is a `copy` constructor. It takes a reference
    to another `ReverseIterator` object, and initializes the `Cell` pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The equality operator initializes the `Cell` pointer with the `Cell` pointer
    of the given `ReverseIterator` object reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Two reverse iterators are equal if their cell pointers point at the same cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between the increase and decrease operators of the `Iterator`
    and `ReverseIterator` classes is that in `Iterator` the increment operators calls
    next and the `decrement` operators call `previous` in `Cell`. In `ReverseIterator`
    it is the other way around: the increment operators call `previous` and the decrement
    operators call `next`. As the names implies: `Iterator` iterates forward, while
    `ReverseIterator` iterates backwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The default constructor of `LinkedList` initializes the list to become empty,
    with the pointer to the first and last cell set to null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The assignment operator copies the values of the given list, in the same way
    as the non-template method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we use the reference version of the `next` method, which allows us
    to assign values to the method call. Since `next` returns a reference to the next
    pointer of the cell, we can assign value of `newCellPtr` to that pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor simply calls the `clear` method, which goes through the linked
    list and deletes every cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'When the cells are deleted, the pointer to the first and last cell is set to
    null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Two lists are equal if they have the same size, and if their cells hold the
    same values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The `add` method adds a cell with a new value at the end of the list, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The second version of `add` adds the given list at the end of the list, as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The `insert` method adds a value or a list at the given position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The `erase` and `remove` methods remove a value of a sub-list from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The input stream operator first reads the `size` of the list, and then the
    values themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The output stream operator writes the list on the given stream, surrounded
    by brackets and with the values separated by commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: We test the `LinkedList` class by letting the user input a list that we iterate
    automatically with the `for` statement, as well as manually with forward and backward
    iterators.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that it is possible to use the `for` statement directly on the list since
    the extended list holds the `begin` method, which returns an iterator with the
    prefix increment (`++`) and dereference (`*`) operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also iterate through the list manually with the `begin` and `end` methods
    of the `Iterator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `rbegin` and `rend` methods and the `ReverseIterator` class we iterate
    from its end to its beginning. Note that we still use increment (`++`) rather
    than decrement (`--`), even though we iterate through the list backwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The extended Set class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Set` class of this section has been extended in three ways compared to
    the version of the earlier section:'
  prefs: []
  type: TYPE_NORMAL
- en: The set is stored as an ordered list, which makes some of the methods more efficient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class is a template; it may store values of arbitrary types as long as those
    types support ordering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class has operator overloading, which (hopefully) makes it easier and more
    intuitive to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In C++ it is possible to define our own types with the `typedef` keyword. We
    define `Iterator` of `Set` to be the same iterator as in `LinkedList`. In the
    earlier section, `Iterator` was a free-standing class that we could reuse when
    working with sets. However, in this section, `Iterator` is an inner class. Otherwise,
    `LinkedList` could not be accessed when handling sets since `Set` inherits `LinkedList`
    privately. Remember that when we inherit privately, all methods and fields of
    the base class become private in the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: '**Set.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'We replace the `equal` and `notEqual` methods with overloaded operators for
    comparison. In this way, it is possible to compare two sets in the same way as
    when comparing, for instance, two integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'We replace the `unionSet`, `intersection`, and `difference` methods with the
    operators for addition, multiplication, and subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'The `merge` function is called by the set methods to perform efficient merging
    of sets. Since it is a function rather than a method, it must have its own template
    marking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the preceding `LinkedList` class, we replace the `read` and `write`
    methods with overloaded stream operators. Since they also are functions rather
    than methods, they also need their own template markings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructors look pretty much the same, compared to the non-template versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'When testing whether two sets are equal, we can just simply call the equality
    operator in `LinkedList` since the sets of this section are ordered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the earlier classes, we test whether two sets are not equal by calling
    `equal`. However, in this class, we use the equality operator explicitly by comparing
    the own object (by using the `this` pointer) with the given set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Union, intersection, and difference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We replace the `unionSet`, `intersection`, and `difference` methods with the
    addition, subtraction, and multiplication operators. They all call `merge`, with
    the sets and different values for the `addLeft`, `addEqual`, and `addRight` parameters.
    In case of union, all three of them are `true`, which means that values present
    in the left-hand set only, or in both sets, or in the right-hand set only shall
    be included in the union set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of intersection, only `addEqual` is `true`, which means that the values
    present in both sets, but not values present in only one of the sets, shall be
    included in the intersection set. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of difference, only `addLeft` is true, which means that only the values
    present in the left-hand set, but not in both the sets or the right-hand set only,
    shall be included in the difference set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'The `merge` method takes two sets and the three Boolean values `addLeft`, `addEqual`,
    and `addRight`. If `addLeft` is true, values present in the left-hand set only
    are added to the resulting set, if `addEqual` is true, values present in both
    sets are added, and if `rightAdd` is `true`, values present in the right-hand
    set only are added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'The `while` statement keeps iterating while there are values left in both the
    left-hand set and right-hand set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'If the left-hand value is smaller, it is added to the resulting set if `addLeft`
    is `true`. Then the iterator for the left-hand set is incremented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'If the right-hand value is smaller, it is added to the resulting set if `addRight`
    is `true`. Then the iterator for the right-hand set is incremented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if the values are equal, one of them (but not both, since there are
    no duplicates in a set) is added and both iterators are incremented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'If `addLeft` is `true`, all remaining values of the left-hand set, if any,
    are added to the resulting set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'If `addRight` is `true`, all remaining values of the right-hand set, if any,
    are added to the resulting set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the resulting set is returned using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'When performing the union operator to this set and another set, we simply call
    the addition operator. Note that we return our own object by using the `this`
    pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, we call the multiplication and subtraction operators when
    performing intersection and difference on this set and another set. Look at the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'When reading a set, the number of values of the set is input, and then the
    values themselves are input. This function is very similar to its counterpart
    in the `LinkedList` class. However, in order to avoid duplicates, we call the
    compound addition operator (`+=`) instead of the `add` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'When writing a set we enclose the value in brackets ("`{`" and "`}`") instead
    of squares ("`[`" and "`]`"), as in the list case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: We test the set by letting the user input two sets, which we iterate manually
    with iterators and automatically with the `for` statement. We also evaluate the
    union, intersection, and difference between the sets.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the program, the output is displayed in a command window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85e15c8f-935f-43a7-b872-d7cde0f81a6a.png)'
  prefs: []
  type: TYPE_IMG
- en: Advanced searching and sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We looked at linear search in the earlier section. In this section, we will
    look at binary search. The binary search algorithm looks for the value in the
    middle of the list, and then performs the search with half of the list. In this
    way, it has *O(log[2]n) *since it splits the list in half in each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '**Search.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: The merge sort algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The merge sort algorithm divides the list into two equal sublists, sorts the
    sublists by recursive calls (a recursive call occurs when a method or function
    calls itself), and then merges the sorted sublist in a way similar to the `merge`
    method of the extended version of the `Set` class in the earlier section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sort.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'The `merge` method of this section is reusing the idea of `merge` in the extended
    `Set` class earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: The quick sort algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The quick sort algorithm selects the first value (called the **pivot value**)
    and then places all values less than the pivot value in the smaller sublist, and
    all values greater or equal to the pivot value in the larger sublist. Then the
    two lists are sorted by recursive calls and then just concatenated together. Let''s
    look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: The merge sort algorithm is balanced in a way that it always divides the list
    into two equal parts and sorts them. The algorithm must iterate through the list
    once to divide them into two sublists and sorts the sublists. Given a list of
    values, it must iterate through its *n* values and divide the list *log[2]n* times.
    Therefore, merge sort *O(n log[2]n)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The quick sort algorithm, on the other hand, is, in the worst case (if the
    list is already sorted), no better than insert, select, or bubble sort: *O(n²)*.
    However, it is fast in the average case.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have created classes for the abstract datatypes list and
    set. A list is an ordered structure with a beginning and an end, while a set is
    an unordered structure.
  prefs: []
  type: TYPE_NORMAL
- en: We started off with rather simple versions where the list had separate classes
    for the cell and iterator. Then we created a more advanced version where we used
    templates and operator overloading. We also placed the cell and iterator classes
    inside the list class. Finally, we introduced overloaded reference methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, we started by creating a rather simple and ineffective version
    of the set class. Then we created a more advanced version with templates and operator
    overloading, where we stored the values in order to be able to perform the union,
    intersection, and difference operations in a more effective way.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we have implemented the linear and binary search algorithms. The linear
    search works on every unordered sequence, but it is rather ineffective. The binary
    search is more effective, but it only works on ordered sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked into sorting algorithms. We started with the simple but rather
    ineffective insert, select, and bubble sort algorithms. Then we continued with
    the more advanced and effective merge and quick sort algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start to build a library management system.
  prefs: []
  type: TYPE_NORMAL
