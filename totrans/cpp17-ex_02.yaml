- en: Data Structures and Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构和算法
- en: In the previous chapter, we created classes for the `stack` and `queue` abstract
    datatypes. In this chapter, we will continue with the `list` and `set` abstract
    datatypes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了 `stack` 和 `queue` 抽象数据类型的类。在这一章中，我们将继续 `list` 和 `set` 抽象数据类型。
- en: Similar to the stack and queue of the previous chapter, a list is an ordered
    structure with a beginning and an end. However, it is possible to add and remove
    values at any position in the list. It is also possible to iterate through the
    list.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于上一章中的栈和队列，列表是一个有序结构，有开始和结束。然而，可以在列表的任何位置添加和删除值。还可以遍历列表。
- en: A set, on the other hand, is an unordered structure of values. The only thing
    we can say about a set is whether a certain value is present. We cannot say that
    a value has any position in relation to any other value.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，集合是无序的值结构。我们只能说集合中是否存在某个值。我们无法说一个值相对于其他值有任何位置。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将探讨以下主题：
- en: We will start with a rather simple and ineffective version of the list and set
    classes. We will also look into basic algorithms for searching and sorting.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从列表和集合类的相对简单且效率不高的版本开始。我们还将研究搜索和排序的基本算法。
- en: Then we will continue by creating more advanced versions of the list and set
    classes, and look into more advanced searching and sorting algorithms. We will
    also introduce new concepts such as templates, operator overloading, exceptions,
    and reference overloading.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将继续创建列表和集合类的更高级版本，并研究更高级的搜索和排序算法。我们还将介绍新的概念，如模板、运算符重载、异常和引用重载。
- en: We will also look into the searching algorithms linear search, which works on
    every sequence, ordered and unordered, but is rather ineffective, and binary search,
    which is more effective but only works on ordered sequences.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将研究搜索算法线性搜索，它适用于任何序列，有序和无序，但效率较低，以及二分搜索，它更有效，但仅适用于有序序列。
- en: Finally, we will study the rather simple sorting algorithms, insert sort, select
    sort, and bubble sort, as well as the more advanced and more effective merge sort
    and quick sort algorithms.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将研究相对简单的排序算法，插入排序、选择排序和冒泡排序，以及更高级且更有效的归并排序和快速排序算法。
- en: The List class
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The List class
- en: The `LinkedList` class is a more complicated abstract data type than the stack
    and the queue. It is possible to add and remove values at any location in the
    list. It is also possible to iterate through the list.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList` 类比栈和队列更复杂，它可以在列表的任何位置添加和删除值。还可以遍历列表。'
- en: The Cell class
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The Cell class
- en: The cell of this section is an extension of the cell of the `stack` and `queue`
    sections. Similar to them, it holds a value and a pointer to the next cell. However,
    this version also holds a pointer to the previous cell, which makes the list of
    this section a double-linked list.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的单元格是 `stack` 和 `queue` 节中的单元格的扩展。类似于它们，它包含一个值和一个指向下一个单元格的指针。然而，这个版本还包含一个指向前一个单元格的指针，这使得本节中的列表成为双向链表。
- en: Note that the constructor is `private`, which means that the cell object can
    be created by its own methods only. However, there is a way to circumvent that
    limitation. We can define a class or a function to be a friend of `LinkedList`.
    In this way, we define `LinkedList` as a friend of `Cell`. This means that `LinkedList`
    has access to all private and protected members of `Cell`, including the constructor,
    and can thereby create `Cell` objects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，构造函数是 `private` 的，这意味着单元格对象只能通过其自己的方法创建。然而，有一种方法可以绕过这种限制。我们可以定义一个类或函数作为 `LinkedList`
    的朋友。这样，我们将 `LinkedList` 定义为 `Cell` 的朋友。这意味着 `LinkedList` 可以访问 `Cell` 的所有私有和受保护成员，包括构造函数，从而可以创建
    `Cell` 对象。
- en: '**Cell.h:**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cell.h:**'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Cell.cpp:**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cell.cpp:**'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Iterator class
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The Iterator class
- en: When going through a list, we need an iterator, which is initialized to the
    beginning of the list and step-wise moves to its end. Similar to the preceding
    cell, the constructor of `Iterator` is private, but we define `LinkedList` as
    a friend of `Iterator` too.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历列表时，我们需要一个迭代器，它被初始化为列表的开始，并逐步移动到其结束。类似于前面的单元格，`Iterator` 的构造函数是私有的，但我们也将
    `LinkedList` 定义为 `Iterator` 的朋友。
- en: '**Iterator.h:**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**Iterator.h:**'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The third constructor is a `copy` constructor. It takes another iterator and
    then copies it. We cannot just accept the iterator as a parameter. Instead, we
    define a reference parameter. The ampersands (&) states that the parameter is
    a reference to an iterator object rather than an iterator object. In this way,
    the memory address of the iterator is sent as a parameter instead of the object
    itself. We also state that the object referred to is constant, so that it cannot
    be altered by the constructor.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个构造函数是一个`复制构造函数`。它接受另一个迭代器并将其复制。我们不能仅仅接受迭代器作为参数。相反，我们定义一个引用参数。`&`符号表示该参数是迭代器对象的引用，而不是迭代器对象本身。这样，迭代器的内存地址作为参数传递，而不是对象本身。我们还声明所引用的对象是常量，因此构造函数不能修改它。
- en: 'In this case, it is necessary to use a reference parameter. If we had defined
    a simple iterator object as a parameter it would have caused indefinite circular
    initialization. However, in other cases, we use this technique for efficiency
    reasons. It takes less time and requires less memory to pass the address of the
    object than to copy the object itself as a parameter:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用引用参数是必要的。如果我们定义了一个简单的迭代器对象作为参数，它将导致不确定的循环初始化。然而，在其他情况下，我们出于效率原因使用这种技术。传递对象地址所需的时间比复制对象本身作为参数所需的时间更少，并且需要的内存也更少：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `hasNext` methods returns `true` if the iterator has not yet reached the
    end of the list, and `next` moves the iterator one step forwards, towards the
    end of the list, as shown in the following example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasNext`方法返回`true`，如果迭代器尚未到达列表的末尾，`next`方法将迭代器向前移动一步，向列表的末尾移动，如下面的示例所示：'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the same way, the `hasPrevious` method returns `true` if the iterator has
    not yet reached the beginning of the list, and `previous` moves the iterator one
    step backward, to the beginning of the list:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`hasPrevious`方法返回`true`，如果迭代器尚未到达列表的开始，`previous`方法将迭代器向后移动一步，到列表的开始：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Iterator.cpp:**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**Iterator.cpp:**'
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The List class
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`List`类'
- en: 'The `LinkedList` class holds methods for finding, adding, inserting, and removing
    values, as well as comparing lists. Moreover, it also holds methods for reading
    and writing the list, and iterating through the list both forwards and backwards.
    The linked list is in fact a double-linked list. We can follow the links of the
    cells in both directions: from the beginning to the end as well as backwards from
    the end to the beginning.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList`类包含查找、添加、插入和删除值的方法，以及比较列表的方法。此外，它还包含读取和写入列表的方法，以及正向和反向遍历列表的方法。实际上，这是一个双向链表。我们可以从两个方向跟踪单元格的链接：从开始到结束，以及从结束到开始的反向：'
- en: '**LinkedList.h:**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**LinkedList.h:**'
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `copy` constructor and the `assign` method both copies the given list:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`复制构造函数`和`assign`方法都复制给定的列表：'
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The destructor deallocates all memory allocated for the cells in the linked
    list:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数释放链表中所有单元格分配的内存：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `find` methods search for the `value`. If it finds the `value`, it returns
    `true` and sets `findIterator` to the position of the `value`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`方法搜索`value`。如果找到`value`，则返回`true`并将`findIterator`设置为`value`的位置：'
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `equal` and `notEqual` methods compare this linked list to the given linked
    list and return `true` if they are equal or not equal, respectively, as shown
    in the following code snippet:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`equal`和`notEqual`方法比较这个链表与给定的链表，如果它们相等或不相等，则分别返回`true`，如下面的代码片段所示：'
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'What if we want to add a value or another list to an existing list? The `add`
    methods adds a value or another list at the end of this list, and `insert` inserts
    a value or a list at the position given by the iterator:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在现有列表中添加一个值或另一个列表，`add`方法将值或另一个列表添加到列表的末尾，而`insert`方法将值或列表插入到迭代器指定的位置：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `erase` method erases the value at the given position, and `clear` erases
    every value in the list, as shown in the following example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`erase`方法删除给定位置上的值，而`clear`方法删除列表中的所有值，如下面的示例所示：'
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `remove` method removes the values from the first iterator to the last
    iterator, inclusive. The second parameter is a default parameter. It means that
    the method can be called with one or two parameters. In case of one parameter,
    the second parameter is given the value in the declaration, which in this case
    is the `Iterator(nullptr)` that represents the position one step beyond the end
    of the list. This implies that when `remove` is called with one iterator, every
    value from that iterator, inclusive, to the end of the list are removed.  The
    `nullptr` pointer is in fact a special pointer that is converted to the type it
    points at or is compared to. In this case, a pointer to `Cell`. Informally, we
    can say that a point is null when it holds the value `nullptr`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`方法从第一个迭代器到最后一个迭代器（包括）删除值。第二个参数是默认参数。这意味着该方法可以用一个或两个参数调用。如果只有一个参数，则第二个参数在声明中给出的值，在这种情况下是表示列表末尾位置一步之外的`Iterator(nullptr)`。这意味着当`remove`用一个迭代器调用时，从该迭代器（包括）到列表末尾的所有值都将被删除。`nullptr`指针实际上是一个特殊的指针，它被转换为它指向的类型或与之比较。在这种情况下，一个指向`Cell`的指针。非正式地说，我们可以称一个指针为null，当它持有值`nullptr`时：'
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `first` and `last` methods return iterators located at the first and last
    value of the list:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`first`和`last`方法返回位于列表第一个和最后一个值处的迭代器：'
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `read` and `write` methods read the values of the list from an input file
    stream and write its values to an output file stream. A file stream is used to
    communicate with a file. Note that the `cin` and `cout` objects, which we have
    used in earlier sections, are in fact input and output stream objects:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`和`write`方法从输入文件流中读取列表的值并将其写入输出文件流。文件流用于与文件通信。请注意，我们在前面的章节中使用的`cin`和`cout`对象实际上是输入和输出流对象：'
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Similar to the queue of the earlier section, the list holds pointers to the
    first and last cell in the linked list:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一部分的队列类似，该列表持有指向链表第一个和最后一个单元格的指针：
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**LinkedList.cpp:**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**LinkedList.cpp:**'
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `copy` constructor simply calls `assign` to copy the values of the `list`
    parameter:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数简单地调用`assign`来复制`list`参数的值：
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `assign` method copies the given list into its own linked list:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`assign`方法将给定的列表复制到其自己的链表中：'
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The destructor simply calls clear to deallocate all the memory allocated by
    the cells of the linked list:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数简单地调用`clear`来释放链表单元格分配的所有内存：
- en: '[PRE21]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `clear` method iterates through the linked list and deallocates every cell:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`clear`方法遍历链表并释放每个单元格：'
- en: '[PRE22]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For each cell in the linked list, we must first save its address in `deleteCellPtr`,
    move forward in the linked list, and deallocate the cell. If we would simply call
    `delete` on `currCellPtr`, the following call to `getNext` would not work since,
    in that case, we would call a method of a deallocated object:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于链表中的每个单元格，我们首先必须将其地址保存在`deleteCellPtr`中，然后在链表中前进，并释放该单元格。如果我们直接在`currCellPtr`上调用`delete`，那么接下来的`getNext`调用将不会工作，因为在这种情况下，我们会调用一个已释放对象的函数：
- en: '[PRE23]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When the list has become empty, both cell pointers are null and the size is
    zero:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当列表变为空时，两个单元格指针都是null，大小为零：
- en: '[PRE24]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `find` method iterates through the linked list, sets `findIterator`, and
    returns `true` when it has found the value. If it does not find the value, `false`
    is returned and `findIterator` remains unaffected. In order for this to work,
    `findIterator` must be a reference to an `Iterator` object rather than an `Iterator`
    object itself. A pointer to an `Iterator` object would also work:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`方法遍历链表，设置`findIterator`，并在找到值时返回`true`。如果没有找到值，则返回`false`，并且`findIterator`保持不变。为了使这起作用，`findIterator`必须是一个`Iterator`对象的引用，而不是`Iterator`对象本身。一个`Iterator`对象的指针也会工作：'
- en: '[PRE25]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If two lists have different sizes, they are not equal. Likewise, if they have
    the same size, but not the same values, they are not equal:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个列表的大小不同，它们不相等。同样，如果它们的大小相同，但值不同，它们也不相等：
- en: '[PRE26]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, if the list holds the same size and the same values, they are equal:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果列表持有相同的大小和相同的值，它们是相等的：
- en: '[PRE27]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When we have to decide whether two lists are not equal, we simply call `equal`.
    The exclamation mark (`!`) is the logical `not` operator, as shown in the following
    example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要决定两个列表是否不相等时，我们只需调用`equal`。感叹号（`!`）是逻辑非运算符，如下例所示：
- en: '[PRE28]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When adding a value to the list, we dynamically allocate a cell:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当向列表添加值时，我们动态分配一个单元格：
- en: '[PRE29]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the first cell pointer is null, we set it to point at the new cell since
    the list is empty:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个单元格指针为null，我们将其设置为指向新单元格，因为列表为空：
- en: '[PRE30]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, if the first cell pointer is not null, the list is not empty, and
    we set the next pointer of the last cell pointer to point at the new cell:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果第一个单元格指针不为空，列表不为空，我们将最后一个单元格指针的下一个指针设置为指向新单元格：
- en: '[PRE31]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Either way, we set the last cell pointer to point at the new cell and increase
    the size of the list:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，我们都将最后一个单元格指针设置为指向新单元格，并增加列表的大小：
- en: '[PRE32]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Adding a list to an existing list
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向现有列表中添加列表
- en: 'When adding a whole list to the list, we act the same way for each value in
    the list as when we added a single value in `add` previously. We dynamically allocate
    a new cell, if the first cell pointer is null, we assign it to point at the new
    cell. If it is not null, we assign the last cell pointer''s next-pointer to point
    at the new cell. Either way, we set the last cell pointer to point at a new cell:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当向列表中添加整个列表时，我们对列表中的每个值所采取的行动与我们在`add`中添加单个值时相同。如果第一个单元格指针为空，我们动态分配一个新的单元格，并将其分配给指向新单元格。如果它不为空，我们将最后一个单元格指针的下一个指针设置为指向新单元格。无论哪种方式，我们都将最后一个单元格指针设置为指向新单元格：
- en: '[PRE33]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `while` statement repeats for as long as its condition is true. In this
    case, for as long as we have not reached the end of the list:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`语句会一直重复，直到其条件为真。在这种情况下，只要我们没有到达列表的末尾：'
- en: '[PRE34]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If `m_firstList` is null, our linked list is still empty and `newCellPtr` points
    to the first cell of a new linked list. In that case, we let `m_firstList` point
    at the new cell:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`m_firstList`为空，我们的链表仍然是空的，而`newCellPtr`指向新链表的第一个单元格。在这种情况下，我们让`m_firstList`指向新单元格：
- en: '[PRE35]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If `m_firstList` is not null, our list is not empty and `m_firstList` shall
    not be modified. Instead, we set the next pointer of `m_lastCellPtr` to point
    at the new cell:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`m_firstList`不为空，我们的列表不为空，且`m_firstList`不应被修改。相反，我们将`m_lastCellPtr`的下一个指针设置为指向新单元格：
- en: '[PRE36]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Either way, the last cell pointer is set to the new cell pointer:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，都将最后一个单元格指针设置为新的单元格指针：
- en: '[PRE37]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, the list cell pointer is set to point at its next cell pointer. Eventually,
    the list cell pointer will be null and the `while` statement is finished:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将列表单元格指针设置为指向其下一个单元格指针。最终，列表单元格指针将为空，`while`语句结束：
- en: '[PRE38]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When inserting a value at the position given by the iterator, we set its previous
    pointer to point at the cell before the position in the list (which is null if
    the position is the first one in the list). We then check whether the first cell
    pointer is null in the same way as in the preceding `add` methods:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当在迭代器给出的位置插入值时，我们将它的前指针设置为指向列表中该位置之前的单元格（如果位置是列表中的第一个，则该位置为空）。然后我们以与前面`add`方法相同的方式检查第一个单元格指针是否为空：
- en: '[PRE39]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When inserting a list, we begin by checking whether the position represents
    the null pointer. In that case, the position is beyond the end of our list, and
    we just call `add` instead:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当插入列表时，我们首先检查位置是否表示空指针。在这种情况下，位置超出了我们列表的末尾，我们只需调用`add`：
- en: '[PRE40]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We check whether the list to be inserted is empty by comparing `firstInsertCellPtr` with
    `nullptr`. Since `firstInsertCellPtr` points at the first value of the list, the
    list is empty if it is null:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过比较`firstInsertCellPtr`与`nullptr`来检查要插入的列表是否为空。由于`firstInsertCellPtr`指向列表的第一个值，如果它是空的，则列表为空：
- en: '[PRE41]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Erasing a value from the list
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从列表中删除值
- en: 'The `erase` method simply calls `remove` with the given position as both its
    start and end position:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`erase`方法简单地调用`remove`，并将给定位置作为其起始和结束位置：'
- en: '[PRE42]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When erasing a value from the list, we iterate through the list and deallocate
    the cell for each value to be removed:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当从列表中删除值时，我们遍历列表，并为要删除的每个值释放单元格：
- en: '[PRE43]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When we have to erase the cells, we have three cases to consider. If the last
    cell before the first removed cell is not null, meaning that there is a part of
    the list remaining before the remove position, we set its next pointer to point
    at the first cell after the removed position. If the last cell before the first
    removed cell is null, we set the first cell pointer to point at that cell:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们必须删除单元格时，我们有三种情况要考虑。如果第一个要移除的单元格之前的最后一个单元格不为空，这意味着在移除位置之前有列表的剩余部分，我们将它的下一个指针设置为指向移除位置之后的第一个单元格。如果第一个要移除的单元格之前的最后一个单元格为空，我们将第一个单元格指针设置为指向该单元格：
- en: '[PRE44]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We do the same thing with the position of the list remaining after the last
    cell to be removed. If there is a remaining part of the list left, we set its
    first cell''s previous pointer to the last cell of the list remaining before the
    removed part:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对要移除的最后一个单元格之后的列表位置做同样的事情。如果有列表的剩余部分，我们将它的第一个单元格的前指针设置为指向移除部分之前的最后一个单元格：
- en: '[PRE45]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When reading a list, we first read its `size`. Then we read the values:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取列表时，我们首先读取其`size`。然后读取值：
- en: '[PRE46]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When writing a list, we write the values separated by commas and enclosed by
    brackets ("`[`" and "`]`"):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当写入列表时，我们以逗号分隔值，并用括号("`[`"和"`]`")括起来：
- en: '[PRE47]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We test the list by adding some values and iterate through them, forwards and
    backward.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加一些值并正向和反向遍历来测试列表：
- en: '**Main.cpp:**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp:**'
- en: '[PRE48]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When executing the code, the output is displayed in a command window:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行代码时，输出显示在命令窗口中：
- en: '![](img/12893731-9b8b-4a4b-a928-55a543679ee5.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12893731-9b8b-4a4b-a928-55a543679ee5.png)'
- en: The Set class
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Set`类'
- en: A set is an unordered structure without duplicates. The `Set` class is a subclass
    of `LinkedList`. Note that the inheritance is private, causing all public and
    protected members of `LinkedList` to be private in `Set`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一个无序的结构，不包含重复项。`Set`类是`LinkedList`的子类。请注意，继承是私有的，这导致`LinkedList`的所有公共和受保护成员在`Set`中都是私有的：
- en: '**Set.h:**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**Set.h:**'
- en: '[PRE49]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `equal` method returns `true` if the set has the values. Note that we do
    not care about any order in the set:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`equal`方法如果集合包含这些值则返回`true`。请注意，我们不在意集合中的任何顺序：'
- en: '[PRE50]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `exists` method returns `true` if the given value, or each value in the
    given set, respectively, is present:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`exists`方法如果给定的值或给定集合中的每个值分别存在，则返回`true`：'
- en: '[PRE51]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `insert` method inserts the given value or each value of the given set.
    It only inserts values not already present in the set, since a set holds no duplicates:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert`方法插入给定的值或给定集合中的每个值。它只插入集合中尚未存在的值，因为集合不包含重复项：'
- en: '[PRE52]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `remove` method removes the given value or each value of the given set,
    if present:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`方法如果存在，则移除给定的值或给定集合中的每个值：'
- en: '[PRE53]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `size`, `empty`, and `first` methods simply call their counterparts in
    `LinkedList`. Since there is no order in a set it would be meaningless to also
    override `end` in `LinkedList`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`size`、`empty`和`first`方法简单地调用`LinkedList`中的对应方法。由于集合中没有顺序，因此覆盖`LinkedList`中的`end`方法是没有意义的：'
- en: '[PRE54]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `unionSet`, `intersection`, and `difference` free-standing functions are
    friends to `Set`, which means that they have access to all private and protected
    members of `Set`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`unionSet`、`intersection`和`difference`独立函数是`Set`的朋友，这意味着它们可以访问`Set`的所有私有和受保护成员：'
- en: We cannot name the `unionSet` method `union` since it is a keyword in C++.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能将`unionSet`方法命名为`union`，因为在C++中它是关键字：
- en: 'Note that when a method in a class is marked as a `friend`, it is in fact not
    a method of that class, but rather a function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当一个类中的方法被标记为`friend`时，实际上它不是该类的方法，而是一个函数：
- en: '[PRE55]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `read` and `write` methods read and write the set in the same way as their
    counterparts in `LinkedList`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`和`write`方法以与`LinkedList`中的对应方法相同的方式读取和写入集合：'
- en: '[PRE56]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `unionSet`, `intersection`, and `difference` functions that were friends
    of `Set` are declared outside the class definition:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`unionSet`、`intersection`和`difference`函数是`Set`的朋友，它们在类定义外部声明：'
- en: '[PRE57]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**Set.cpp:**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**Set.cpp:**'
- en: '[PRE58]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The constructors call their counterparts in `LinkedList`. The default constructor
    (without parameters) calls, in fact, the default constructor of `LinkedList` implicitly:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数调用`LinkedList`中的对应函数。默认构造函数（无参数）实际上隐式调用`LinkedList`的默认构造函数：
- en: '[PRE59]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The destructor calls implicitly its counterparts in `LinkedList`, which deallocates
    the memory associated with the values of the set. In this case, we could have
    omitted the destructor, and the destructor of `LinkedList` would still be called
    using the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数隐式调用`LinkedList`中的对应函数，从而释放与集合值关联的内存。在这种情况下，我们可以省略析构函数，使用以下代码调用`LinkedList`的析构函数：
- en: '[PRE60]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `assign` method simply clears the set and adds the given set:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`assign`方法简单地清除集合并添加给定的集合：'
- en: '[PRE61]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The sets are equal if they have the same `size`, and if every value of one
    set is present in the other set. In that case, every value of the other set must
    also be present in the first set:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个集合具有相同的`大小`，并且一个集合中的每个值都存在于另一个集合中，那么这两个集合是相等的。在这种情况下，另一个集合中的每个值也必须存在于第一个集合中：
- en: '[PRE62]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `exists` method uses the iterator of `LinkedList` to iterate through the
    set. It returns `true` if it finds the value:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`exists`方法使用`LinkedList`的迭代器遍历集合。如果找到该值，则返回`true`：'
- en: '[PRE63]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The second `exists` method iterates through the given set and returns `false`
    if any of its values are not present in the set. It returns `true` if all its
    values are present in the set:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`exists`方法遍历给定的集合，如果其中任何值不在集合中，则返回`false`。如果所有值都在集合中，则返回`true`：
- en: '[PRE64]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The first `insert` method adds the value if it is not already present in the
    set:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `insert` 方法如果值不在集合中则添加它：
- en: '[PRE65]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The second `insert` method iterates through the given set and inserts every
    value by calling the first insert method. In this way, each value not already
    present in the set is inserted:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `insert` 方法遍历给定的集合，通过调用第一个插入方法将每个值插入。这样，每个不在集合中已经存在的值都会被插入：
- en: '[PRE66]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The first `remove` method removes the value and returns `true` if it is present
    in the set. If it is not present, it returns `false`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `remove` 方法移除值，如果它在集合中存在则返回 `true`。如果不存在，则返回 `false`：
- en: '[PRE67]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The second `remove` method iterates through the given set and removes each
    of its values. It returns `true` if at least one value is removed:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `remove` 方法遍历给定的集合并移除其每个值。如果至少移除了一个值，则返回 `true`：
- en: '[PRE68]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Union, intersection, and difference operations
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并集、交集和差集操作
- en: 'The `unionSet` function creates a resulting set initialized with the left-hand
    set and then adds the right-hand set:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`unionSet` 函数创建一个以左侧集合初始化的结果集合，然后添加右侧集合：'
- en: '[PRE69]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `intersection` method is a little bit more complicated than the `union`
    or `difference` methods. The intersection of two sets, A and B, can be defined
    as the difference between their union and their differences:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`intersection` 方法比 `union` 或 `difference` 方法稍微复杂一些。两个集合 A 和 B 的交集可以定义为它们的并集与它们的差集之差：'
- en: '*A∩B=(A∪B)-((A-B)-(B-A))*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*A∩B=(A∪B)-((A-B)-(B-A))*'
- en: '[PRE70]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `difference` method creates a result set with the left-hand set and then
    removes the right-hand set:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`difference` 方法创建一个结果集合，以左侧集合为基础，然后移除右侧集合：'
- en: '[PRE71]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `read` method is similar to its counterpart in `LinkedList`. However, `insert`
    is called instead of `add`. In this way, no duplicates are inserted in the set:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`read` 方法与 `LinkedList` 中的对应方法类似。然而，`insert` 被调用而不是 `add`。这样，就不会在集合中插入重复项：'
- en: '[PRE72]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `write` method is also similar to its counterpart in `LinkedList`. However,
    the set is enclosed in brackets ("`{`" and "`}`") instead of squares ("`[`" and
    "`]`"):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`write` 方法与 `LinkedList` 中的对应方法类似。然而，集合是用括号 ("`{`" 和 "`}`") 而不是方括号 ("`[`" 和
    "`]`") 括起来的：'
- en: '[PRE73]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We test the set by letting the user input two sets and evaluate their union,
    intersection, and difference.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过让用户输入两个集合并评估它们的并集、交集和差集来测试集合。
- en: '**Main.cpp:**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp:** '
- en: '[PRE74]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Basic searching and sorting
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本搜索和排序
- en: In this chapter, we will also study some searching and sorting algorithms. When
    searching for a value with linear search we simply go through the list from its
    beginning to its end. We return the zero-based index of the value, or minus one
    if it was not found.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将研究一些搜索和排序算法。当使用线性搜索查找值时，我们只需从列表的开始遍历到结束。我们返回值的零基于索引，如果没有找到则返回负一。
- en: '**Search.h:**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**Search.h:** '
- en: '[PRE75]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '**Search.cpp:**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**Search.cpp:** '
- en: '[PRE76]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We use the `first` method of the list to obtain the iterator that we use to
    go through the list; `hasNext` returns `true` as long as there is another value
    in the list and `next` moves the iterator one step forward in the list:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用列表的 `first` 方法来获取我们用来遍历列表的迭代器；`hasNext` 只要列表中还有另一个值就返回 `true`，`next` 将迭代器在列表中向前移动一步：
- en: '[PRE77]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Now we study the select sort, insert sort, and bubble sort algorithms. Note
    that they take a reference to the list, not the list itself, a parameter in order
    for the list to become changed. Also note that the reference is not constant in
    these cases; if it was constant we would not be able to sort the list.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们研究选择排序、插入排序和冒泡排序算法。请注意，它们接受列表的引用，而不是列表本身，以便列表可以改变。还请注意，在这些情况下引用不是常量；如果它是常量，我们就无法对列表进行排序。
- en: '**Sort.h:**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sort.h:** '
- en: '[PRE78]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '**Sort.cpp:**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sort.cpp:** '
- en: '[PRE79]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The select sort algorithm
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择排序算法
- en: 'The select sort algorithm is quite simple, we iterate through the list repeatedly
    until it becomes empty. For each iteration, we found the smallest value, which
    we remove from the list and add to the resulting list. In this way, the resulting
    list will eventually be filled with the same values as the list. As the values
    were selected in order, the resulting list is sorted. Finally, we assign the resulting
    list to the original list:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 选择排序算法相当简单，我们重复遍历列表直到它为空。在每次迭代中，我们找到最小的值，将其从列表中移除并添加到结果列表中。这样，结果列表最终将填充与列表相同的值。由于值是有序选择的，因此结果列表是有序的。最后，我们将结果列表赋值给原始列表：
- en: '[PRE80]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The insert sort algorithm
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入排序算法
- en: 'In the insert sort algorithm, we iterate through the list, and for each value
    we insert it at its appropriate location in the resulting list. Then we assign
    the resulting list to the original list:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入排序算法中，我们遍历列表，并为每个值将其插入到结果列表中的适当位置。然后我们将结果列表赋值给原始列表：
- en: '[PRE81]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `insert` function takes a list and a value and places the value at its
    correct location in the list. It iterates through the list and places the value
    before the first value that it is less. If there is no such value in the list,
    the value is added at the end of the list:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert` 函数接受一个列表和一个值，并将该值放置在列表中的正确位置。它遍历列表，并将值放置在第一个小于它的值之前。如果列表中没有这样的值，该值将被添加到列表的末尾：'
- en: '[PRE82]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The bubble sort algorithm
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冒泡排序算法
- en: 'The bubble sort algorithm compares the values pairwise and lets them change
    place if they occur in the wrong order. After the first iteration, we know that
    the largest value is located at the end of the list. Therefore, we do not need
    to iterate through the whole list the second time, we can omit the last value.
    In this way, we iterate through the list at most the number of the values in the
    list minus one, because when all values except the first one is at it''s correct
    location, the first one is also at its correct location. However, the list may
    be properly sorted before that. Therefore, we check after each iteration if any
    pair of values has been swapped. If they have not, the list has been properly
    sorted and we exit the algorithm:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序算法逐对比较值，如果它们出现在错误的位置，则允许它们交换位置。在第一次迭代之后，我们知道最大的值位于列表的末尾。因此，我们不需要第二次遍历整个列表，可以省略最后一个值。这样，我们最多遍历列表的值数减一，因为当除了第一个值之外的所有值都位于其正确的位置时，第一个值也位于其正确的位置。然而，列表可能在那时已经正确排序。因此，我们在每次迭代后检查是否有任何一对值被交换。如果没有，则列表已经正确排序，我们可以退出算法：
- en: '[PRE83]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `swap` function swaps the values at the locations given by the iterators:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`swap` 函数交换由迭代器给出的位置的值：'
- en: '[PRE84]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We test the algorithms by adding some values to a list, and then sort the list.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过向列表中添加一些值并排序列表来测试这些算法。
- en: '**Main.cpp:**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp:**'
- en: '[PRE85]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We use the `iterator` class to go through the list and call `linarySearch`
    for each value in the list:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `iterator` 类遍历列表，并对列表中的每个值调用 `linarySearch`：
- en: '[PRE86]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We also test the search algorithm for values not present in the list, their
    indexes will be minus one:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还测试了列表中不存在的值的搜索算法，它们的索引将是负一：
- en: '[PRE87]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We sort the list by the bubble sort, select sort, and insert sort algorithms:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过冒泡排序、选择排序和插入排序算法对列表进行排序：
- en: '[PRE88]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: One way to classify searching and sorting algorithms is to use the big O notation.
    Informally speaking, the notation focuses on the worst-case scenario. In the insert
    sort case, we iterate through the list once for each value, and for each value,
    we may have to iterate through the whole list to find its correct location. Likewise,
    in the select sort case we iterate through the list once for each value, and for
    each value, we may need to iterate through the whole list.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将搜索和排序算法进行分类的一种方法是用大 O 表示法。非正式地说，该表示法关注最坏的情况。在插入排序的情况下，我们为每个值遍历列表一次，并且可能需要为每个值遍历整个列表以找到其正确的位置。同样，在选择排序的情况下，我们为每个值遍历列表一次，并且可能需要为每个值遍历整个列表。
- en: Finally, in the bubble sort case, we iterate through the list once for each
    value and we may have to iterate through the whole list for each value. In all
    three cases, we may have to perform *n*² operations on a list of *n* values. Therefore,
    the insert, select, and bubble sort algorithms have the big-O *n*², or O (*n*²)
    with regards to their time efficiency. However, when it comes to their space efficiency,
    bubble sort is better since it operates on the same list, while insert and select
    sort demand an extra list for the resulting sorted list.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在冒泡排序的情况下，我们为每个值遍历列表一次，并且可能需要为每个值遍历整个列表。在所有三种情况下，我们可能需要在包含 *n* 个值的列表上执行 *n*²
    次操作。因此，插入、选择和冒泡排序算法在时间效率方面具有大-O *n*²，或 O (*n*²)。然而，当涉及到空间效率时，冒泡排序更好，因为它在同一个列表上操作，而插入和选择排序则需要额外的列表来存储排序后的列表。
- en: The extended List class
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展的 List 类
- en: 'In this section, we will revisit the `LinkedList` class. However, we will expand
    it in several ways:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重新审视 `LinkedList` 类。然而，我们将以几种方式扩展它：
- en: The `Cell` class had a set of `set` and `get` methods. Instead, we will replace
    each pair with a pair of overloaded reference methods.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cell` 类有一组 `set` 和 `get` 方法。相反，我们将每个对替换为一对重载的引用方法。'
- en: The previous list could only store values of the type `double`. Now we will
    define the list to be `template`, which allows it to store values of arbitrary
    types.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前的列表只能存储`double`类型的值。现在我们将列表定义为`template`，这样它就可以存储任意类型的值。
- en: We will replace some of the methods with overloaded operators*.*
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将用重载运算符替换一些方法。
- en: '`Cell` and `Iterator` were free-standing classes. Now we will let them be inner
    classes, defined inside `LinkedList`.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cell`和`Iterator`原本是独立类。现在我们将它们定义为`LinkedList`内部的内部类：'
- en: '**List.h:**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**List.h:** '
- en: '[PRE89]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'In the classes of the earlier sections, the list stored values of the type
    `double`. However, in these classes, instead of `double` we use the template type
    `T`, which is a generic type that can be instantiated by any arbitrary type. The
    `LinkedList` class of this section is `template`, with the generic type `T`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节的课程中，列表存储的是`double`类型的值。然而，在这些类中，我们不再使用`double`，而是使用模板类型`T`，它是一种泛型类型，可以被任何任意类型实例化。本节中的`LinkedList`类是`template`的，具有泛型类型`T`：
- en: '[PRE90]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The `value` method is overloaded in two versions. The first version is constant
    and returns a constant value. The other version is not constant and returns a
    reference to the value. In this way, it is possible to assign values to the cell''s
    value, as shown in the following example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`value`方法有两个重载版本。第一个版本是常量版本，返回一个常量值。另一个版本不是常量版本，返回值的引用。这样，就可以将值赋给单元格的值，如下面的示例所示：'
- en: '[PRE91]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `Cell*&` construct means that the methods return a reference to a pointer
    to a `Cell` object. That reference can then be used to assign a new value to the
    pointer:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cell*&`构造意味着方法返回一个指向`Cell`对象的指针的引用。然后，可以使用这个引用将新值赋给指针：'
- en: '[PRE92]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Instead of `equal` and `notEqual`, we overload the equal and not-equal operators:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用重载的相等和不等运算符替换了`equal`和`notEqual`：
- en: '[PRE93]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We also replace the increment and decrement methods with the increment (`++`)
    and decrement (`--`) operators. They come in two versions each—prefix and postfix.
    The version without parameters is the prefix version (`++i` and `--i`) and the
    version with an integer parameter is the postfix version (`i++` and `i--`). Note
    that we actually do not pass an integer parameter to the operator. The parameter
    is included only to distinguish between the two versions, and is ignored by the
    compiler:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还用增量（`++`）和减量（`--`）运算符替换了增量方法和减量方法。每个运算符有两种版本——前缀和后缀。不带参数的版本是前缀版本（`++i`和`--i`），带有整数参数的版本是后缀版本（`i++`和`i--`）。请注意，实际上我们没有传递整数参数给运算符。参数只包含在内以区分两个版本，并且被编译器忽略：
- en: '[PRE94]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We replace the `getValue` and `setValue` methods with two overloaded dereference
    operators (`*`). They work in a way similar to the `value` methods in the preceding `Cell`
    class. The first version is constant and returns a value, while the second version
    is not constant and returns a reference to the value:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用两个重载的解引用运算符（`*`）替换了`getValue`和`setValue`方法。它们的工作方式与前面`Cell`类中的`value`方法类似。第一个版本是常量版本，返回一个值，而第二个版本不是常量版本，返回值的引用：
- en: '[PRE95]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The ReverseIterator class
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ReverseIterator`类'
- en: 'In order to iterate from the end to the beginning, as well as from the beginning
    to the end, we add `ReverseIterator`. It is nearly identical to `Iterator` used
    previously; the only difference is that the increment and decrement operators
    move in opposite directions:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从末尾到开头以及从开头到末尾进行迭代，我们添加了`ReverseIterator`。它与之前使用的`Iterator`几乎相同；唯一的区别是增量运算符和减量运算符的方向相反：
- en: '[PRE96]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'In the earlier section, there was only the `first` and `last` methods, which
    return an iterator. In this section, the `begin` and `end` methods are used for
    forward iteration, while `rbegin` and `rend` (stands for reverse begin and reverse
    end) are used for backward iteration:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，只有`first`和`last`方法，它们返回一个迭代器。在本节中，使用`begin`和`end`方法进行正向迭代，而`rbegin`和`rend`（表示反向开始和反向结束）用于反向迭代：
- en: '[PRE97]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We replace the `read` and `write` methods with overloaded input and output
    stream operators. Since they are functions rather than methods, they need their
    own template markings:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用重载的输入和输出流运算符替换了`read`和`write`方法。由于它们是函数而不是方法，它们需要自己的模板标记：
- en: '[PRE98]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Note that when we implement the methods of a `template` class, we do so in the
    header file. Consequently, we do not need an implementation file when implementing
    a `template` class.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们实现`template`类的成员函数时，我们是在头文件中实现的。因此，在实现`template`类时，我们不需要实现文件。
- en: 'Similar to the class definitions, the method definitions must be preceded by
    the `template` keyword. Note that the class name `LinkedList` is followed by the
    type marker `<T>`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 与类定义类似，方法定义必须以 `template` 关键字开头。请注意，类名 `LinkedList` 后跟类型标记 `<T>`：
- en: '[PRE99]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Note that when we implement a method of an inner class, we need to include
    both the names of the outer class (`LinkedList`) and inner class (`Cell`) in the
    implementation:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们实现内部类的方法时，我们需要在实现中包含外部类（`LinkedList`）和内部类（`Cell`）的名称：
- en: '[PRE100]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Since `LinkedList` is a `template` class, it is not known to the compiler that
    its inner class `Iterator` is, in fact, a class. As far as the compiler knows,
    the iterator could be a type, a value, or a class. Therefore, we need to inform
    the compiler by using the `typename` keyword:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `LinkedList` 是一个 `template` 类，编译器并不知道其内部类 `Iterator` 实际上是一个类。就编译器所知，迭代器可能是一个类型、一个值或一个类。因此，我们需要通过使用
    `typename` 关键字来通知编译器：
- en: '[PRE101]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The following operator versions are implemented in the same way as its method
    counterparts in the previous version of `LinkedList`. That is, the `equal` method
    has been replaced by the equation operator (`operator==`), and the `notEqual`
    method has been replaced by the not-equal operator (`operator!=`):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以下运算符版本与之前版本 `LinkedList` 中的方法对应方式相同。也就是说，`equal` 方法已被等式运算符（`operator==`）所取代，而
    `notEqual` 方法已被不等式运算符（`operator!=`）所取代：
- en: '[PRE102]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The increase operator has been replaced with both the prefix and postfix version
    of `operator++`. The difference between them is that the prefix version does not
    take any parameters, while the postfix version takes a single integer value as
    parameter. Note that the integer value is not used by the operator. Its value
    is undefined (however, it is usually set to zero) and is always ignored. It is
    present only to distinguish between the prefix and postfix cases:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 增量运算符已被前缀和后缀版本的 `operator++` 所取代。它们之间的区别在于，前缀版本不接收任何参数，而后缀版本接收一个整数参数作为参数。请注意，整数参数不会被运算符使用。它的值是未定义的（然而，通常设置为零）并且总是被忽略。它的存在只是为了区分前缀和后缀情况：
- en: '[PRE103]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The `decrease` operator also comes in a prefix and a postfix version, and works
    in a way similar to the `increase` operator:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`decrease` 运算符也有前缀和后缀版本，其工作方式与 `increase` 运算符类似：'
- en: '[PRE104]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The dereference operator also comes in two versions. The first version is constant
    and returns a value. The second version is not constant and returns a reference
    to the value, instead of the value itself. In this way, the first version can
    be called on a constant object, in which case we are not allowed to change its
    value. The second version can be called on a non-constant object only, we can
    change the value by assigning a new value to the value returned by the method:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 取引用运算符也有两种版本。第一种是常量版本，返回一个值。第二种版本不是常量版本，返回对值的引用，而不是值本身。这样，第一种版本可以在常量对象上调用，在这种情况下，我们不允许更改其值。第二种版本只能在非常量对象上调用，我们可以通过将新值赋给方法返回的值来更改值：
- en: '[PRE105]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'There are three constructors of the `ReverseIterator` class. The first constructor
    is a default constructor, the second constructor is initialized with a `Cell`
    pointer, and the third constructor is a `copy` constructor. It takes a reference
    to another `ReverseIterator` object, and initializes the `Cell` pointer:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReverseIterator` 类有三个构造函数。第一个构造函数是一个默认构造函数，第二个构造函数使用一个 `Cell` 指针进行初始化，第三个构造函数是一个
    `copy` 构造函数。它接受另一个 `ReverseIterator` 对象的引用，并初始化 `Cell` 指针：'
- en: '[PRE106]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The equality operator initializes the `Cell` pointer with the `Cell` pointer
    of the given `ReverseIterator` object reference:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 等于运算符使用给定 `ReverseIterator` 对象引用的 `Cell` 指针初始化 `Cell` 指针：
- en: '[PRE107]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Two reverse iterators are equal if their cell pointers point at the same cell:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 两个反向迭代器相等，如果它们的单元格指针指向相同的单元格：
- en: '[PRE108]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The difference between the increase and decrease operators of the `Iterator`
    and `ReverseIterator` classes is that in `Iterator` the increment operators calls
    next and the `decrement` operators call `previous` in `Cell`. In `ReverseIterator`
    it is the other way around: the increment operators call `previous` and the decrement
    operators call `next`. As the names implies: `Iterator` iterates forward, while
    `ReverseIterator` iterates backwards:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator` 和 `ReverseIterator` 类的增量运算符和减量运算符之间的区别在于，在 `Iterator` 中，增量运算符调用
    `next`，而 `decrement` 运算符调用 `Cell` 中的 `previous`。在 `ReverseIterator` 中情况相反：增量运算符调用
    `previous`，而减量运算符调用 `next`。正如其名称所暗示的：`Iterator` 向前迭代，而 `ReverseIterator` 向后迭代：'
- en: '[PRE109]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The default constructor of `LinkedList` initializes the list to become empty,
    with the pointer to the first and last cell set to null:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList`的默认构造函数将列表初始化为空，第一个和最后一个单元格的指针设置为null：'
- en: '[PRE110]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The assignment operator copies the values of the given list, in the same way
    as the non-template method:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值操作符以与非模板方法相同的方式复制给定列表的值：
- en: '[PRE111]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Note that we use the reference version of the `next` method, which allows us
    to assign values to the method call. Since `next` returns a reference to the next
    pointer of the cell, we can assign value of `newCellPtr` to that pointer:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`next`方法的引用版本，这允许我们将值分配给方法调用。由于`next`返回单元格下一个指针的引用，我们可以将`newCellPtr`的值分配给该指针：
- en: '[PRE112]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The destructor simply calls the `clear` method, which goes through the linked
    list and deletes every cell:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数简单地调用`clear`方法，该方法遍历链表并删除每个单元格：
- en: '[PRE113]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'When the cells are deleted, the pointer to the first and last cell is set to
    null:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当单元格被删除时，第一个和最后一个单元格的指针被设置为null：
- en: '[PRE114]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Two lists are equal if they have the same size, and if their cells hold the
    same values:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个列表具有相同的大小，并且它们的单元格包含相同的值，则这两个列表相等：
- en: '[PRE115]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The `add` method adds a cell with a new value at the end of the list, as shown
    in the following example:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`方法在列表末尾添加一个具有新值的单元格，如下例所示：'
- en: '[PRE116]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The second version of `add` adds the given list at the end of the list, as
    shown in the following example:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`的第二个版本将给定的列表添加到列表的末尾，如下例所示：'
- en: '[PRE117]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The `insert` method adds a value or a list at the given position:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert`方法在给定位置添加一个值或一个列表：'
- en: '[PRE118]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The `erase` and `remove` methods remove a value of a sub-list from the list:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`erase`和`remove`方法从列表中移除子列表的值：'
- en: '[PRE119]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The input stream operator first reads the `size` of the list, and then the
    values themselves:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 输入流操作符首先读取列表的`size`，然后读取值本身：
- en: '[PRE120]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The output stream operator writes the list on the given stream, surrounded
    by brackets and with the values separated by commas:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 输出流操作符将列表写入给定的流中，列表被括号包围，并且值之间用逗号分隔：
- en: '[PRE121]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: We test the `LinkedList` class by letting the user input a list that we iterate
    automatically with the `for` statement, as well as manually with forward and backward
    iterators.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过让用户输入一个列表，然后自动使用`for`语句以及手动使用前向和后向迭代器来迭代该列表，来测试`LinkedList`类。
- en: '**Main.cpp:**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp:**'
- en: '[PRE122]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Note that it is possible to use the `for` statement directly on the list since
    the extended list holds the `begin` method, which returns an iterator with the
    prefix increment (`++`) and dereference (`*`) operators:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可以直接在列表上使用`for`语句，因为扩展的列表包含`begin`方法，该方法返回一个具有前缀增量（`++`）和解除引用（`*`）操作符的迭代器：
- en: '[PRE123]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'We can also iterate through the list manually with the `begin` and `end` methods
    of the `Iterator` class:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`Iterator`类的`begin`和`end`方法手动遍历列表：
- en: '[PRE124]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'With the `rbegin` and `rend` methods and the `ReverseIterator` class we iterate
    from its end to its beginning. Note that we still use increment (`++`) rather
    than decrement (`--`), even though we iterate through the list backwards:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`rbegin`和`rend`方法以及`ReverseIterator`类，我们可以从其末尾迭代到其开头。注意，我们仍然使用增量（`++`）而不是减量（`--`），尽管我们正在反向遍历列表：
- en: '[PRE125]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The extended Set class
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展的`Set`类
- en: 'The `Set` class of this section has been extended in three ways compared to
    the version of the earlier section:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个章节的版本相比，本节中的`Set`类在三个方面进行了扩展：
- en: The set is stored as an ordered list, which makes some of the methods more efficient
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合被存储为有序列表，这使得一些方法更有效
- en: The class is a template; it may store values of arbitrary types as long as those
    types support ordering
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类是一个模板；只要这些类型支持排序，它就可以存储任意类型的值
- en: The class has operator overloading, which (hopefully) makes it easier and more
    intuitive to use
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类具有操作符重载，这（希望）使得它更容易且更直观地使用
- en: In C++ it is possible to define our own types with the `typedef` keyword. We
    define `Iterator` of `Set` to be the same iterator as in `LinkedList`. In the
    earlier section, `Iterator` was a free-standing class that we could reuse when
    working with sets. However, in this section, `Iterator` is an inner class. Otherwise,
    `LinkedList` could not be accessed when handling sets since `Set` inherits `LinkedList`
    privately. Remember that when we inherit privately, all methods and fields of
    the base class become private in the subclass.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，我们可以使用 `typedef` 关键字定义自己的类型。我们将 `Set` 的 `Iterator` 定义为与 `LinkedList`
    中的相同迭代器。在前面的小节中，`Iterator` 是一个独立的类，我们可以在处理集合时重用它。然而，在本节中，`Iterator` 是一个内部类。否则，在处理集合时无法访问
    `LinkedList`，因为 `Set` 是私有继承 `LinkedList` 的。记住，当我们私有继承时，基类的所有方法和字段都成为子类的私有成员。
- en: '**Set.h:**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**Set.h:**'
- en: '[PRE126]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'We replace the `equal` and `notEqual` methods with overloaded operators for
    comparison. In this way, it is possible to compare two sets in the same way as
    when comparing, for instance, two integers:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用重载的比较运算符替换 `equal` 和 `notEqual` 方法。这样，就可以像比较两个整数一样比较两个集合：
- en: '[PRE127]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'We replace the `unionSet`, `intersection`, and `difference` methods with the
    operators for addition, multiplication, and subtraction:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用加法、乘法和减法运算符替换 `unionSet`、`intersection` 和 `difference` 方法：
- en: '[PRE128]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The `merge` function is called by the set methods to perform efficient merging
    of sets. Since it is a function rather than a method, it must have its own template
    marking:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge` 函数由集合方法调用以执行集合的高效合并。由于它是一个函数而不是方法，它必须有自己的模板标记：'
- en: '[PRE129]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Similar to the preceding `LinkedList` class, we replace the `read` and `write`
    methods with overloaded stream operators. Since they also are functions rather
    than methods, they also need their own template markings:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的 `LinkedList` 类类似，我们用重载的流运算符替换 `read` 和 `write` 方法。由于它们也是函数而不是方法，它们也需要自己的模板标记：
- en: '[PRE130]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The constructors look pretty much the same, compared to the non-template versions:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 与非模板版本相比，构造函数看起来几乎相同：
- en: '[PRE131]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'When testing whether two sets are equal, we can just simply call the equality
    operator in `LinkedList` since the sets of this section are ordered:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试两个集合是否相等时，我们可以直接在 `LinkedList` 中调用等号运算符，因为本节中的集合是有序的：
- en: '[PRE132]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Similar to the earlier classes, we test whether two sets are not equal by calling
    `equal`. However, in this class, we use the equality operator explicitly by comparing
    the own object (by using the `this` pointer) with the given set:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的类类似，我们通过调用 `equal` 来测试两个集合是否不相等。然而，在这个类中，我们通过使用 `this` 指针比较自身对象（对象本身）与给定的集合来显式使用等号运算符：
- en: '[PRE133]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Union, intersection, and difference
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并集、交集和差集
- en: 'We replace the `unionSet`, `intersection`, and `difference` methods with the
    addition, subtraction, and multiplication operators. They all call `merge`, with
    the sets and different values for the `addLeft`, `addEqual`, and `addRight` parameters.
    In case of union, all three of them are `true`, which means that values present
    in the left-hand set only, or in both sets, or in the right-hand set only shall
    be included in the union set:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用加法、减法和乘法运算符替换 `unionSet`、`intersection` 和 `difference` 方法。它们都调用 `merge`，并为
    `addLeft`、`addEqual` 和 `addRight` 参数提供不同的集合和值。在并集的情况下，这三个都是 `true`，这意味着应包含左手集合中仅存在的值、两个集合都存在的值或右手集合中仅存在的值：
- en: '[PRE134]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'In case of intersection, only `addEqual` is `true`, which means that the values
    present in both sets, but not values present in only one of the sets, shall be
    included in the intersection set. Take a look at the following example:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在交集的情况下，只有 `addEqual` 是 `true`，这意味着应包含两个集合中存在的值，但不包含只存在于一个集合中的值，在交集集中。看看以下示例：
- en: '[PRE135]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'In case of difference, only `addLeft` is true, which means that only the values
    present in the left-hand set, but not in both the sets or the right-hand set only,
    shall be included in the difference set:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有差异，只有 `addLeft` 是 `true`，这意味着只有左手集合中存在但不在两个集合或右手集合中存在的值应包含在差集中：
- en: '[PRE136]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The `merge` method takes two sets and the three Boolean values `addLeft`, `addEqual`,
    and `addRight`. If `addLeft` is true, values present in the left-hand set only
    are added to the resulting set, if `addEqual` is true, values present in both
    sets are added, and if `rightAdd` is `true`, values present in the right-hand
    set only are added:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge` 方法接受两个集合和三个布尔值 `addLeft`、`addEqual` 和 `addRight`。如果 `addLeft` 是 `true`，则将左手集合中存在的值添加到结果集中；如果
    `addEqual` 是 `true`，则将两个集合中存在的值添加；如果 `rightAdd` 是 `true`，则将右手集合中仅存在的值添加：'
- en: '[PRE137]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The `while` statement keeps iterating while there are values left in both the
    left-hand set and right-hand set:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`语句在左侧集合和右侧集合中还有值时持续迭代：'
- en: '[PRE138]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'If the left-hand value is smaller, it is added to the resulting set if `addLeft`
    is `true`. Then the iterator for the left-hand set is incremented:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左侧值较小，如果`addLeft`为`true`，则将其添加到结果集合中。然后增加左侧集合的迭代器：
- en: '[PRE139]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'If the right-hand value is smaller, it is added to the resulting set if `addRight`
    is `true`. Then the iterator for the right-hand set is incremented:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果右侧值较小，如果`addRight`为`true`，则将其添加到结果集合中。然后增加右侧集合的迭代器：
- en: '[PRE140]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Finally, if the values are equal, one of them (but not both, since there are
    no duplicates in a set) is added and both iterators are incremented:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果值相等，其中一个（但不是两个，因为集合中没有重复项）被添加，并且两个迭代器都增加：
- en: '[PRE141]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'If `addLeft` is `true`, all remaining values of the left-hand set, if any,
    are added to the resulting set:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`addLeft`为`true`，则将左侧集合的所有剩余值（如果有）添加到结果集合中：
- en: '[PRE142]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'If `addRight` is `true`, all remaining values of the right-hand set, if any,
    are added to the resulting set:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`addRight`为`true`，则将右侧集合的所有剩余值（如果有）添加到结果集合中：
- en: '[PRE143]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Finally, the resulting set is returned using the following:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用以下方式返回结果集合：
- en: '[PRE144]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'When performing the union operator to this set and another set, we simply call
    the addition operator. Note that we return our own object by using the `this`
    pointer:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当对这个集合和另一个集合执行并集操作时，我们只需调用加法操作符。注意，我们通过使用`this`指针返回自己的对象：
- en: '[PRE145]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'In the same way, we call the multiplication and subtraction operators when
    performing intersection and difference on this set and another set. Look at the
    following example:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 以相同的方式，我们在对集合和另一个集合执行交集和差集操作时调用乘法和减法操作符。查看以下示例：
- en: '[PRE146]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'When reading a set, the number of values of the set is input, and then the
    values themselves are input. This function is very similar to its counterpart
    in the `LinkedList` class. However, in order to avoid duplicates, we call the
    compound addition operator (`+=`) instead of the `add` method:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 读取集合时，首先输入集合的值数，然后输入值本身。这个函数与`LinkedList`类中的对应函数非常相似。然而，为了避免重复，我们调用复合加法操作符(`+=`)而不是`add`方法：
- en: '[PRE147]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'When writing a set we enclose the value in brackets ("`{`" and "`}`") instead
    of squares ("`[`" and "`]`"), as in the list case:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写集合时，我们将值放在括号中（"{"和"}"），而不是方括号中（"["和"]"），就像列表的情况一样：
- en: '[PRE148]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: We test the set by letting the user input two sets, which we iterate manually
    with iterators and automatically with the `for` statement. We also evaluate the
    union, intersection, and difference between the sets.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过让用户输入两个集合来测试集合，我们手动使用迭代器和自动使用`for`语句迭代。我们还评估集合之间的并集、交集和差集。
- en: '**Main.cpp:**'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp:**'
- en: '[PRE149]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'When we execute the program, the output is displayed in a command window:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行程序时，输出显示在命令窗口中：
- en: '![](img/85e15c8f-935f-43a7-b872-d7cde0f81a6a.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/85e15c8f-935f-43a7-b872-d7cde0f81a6a.png)'
- en: Advanced searching and sorting
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级搜索和排序
- en: We looked at linear search in the earlier section. In this section, we will
    look at binary search. The binary search algorithm looks for the value in the
    middle of the list, and then performs the search with half of the list. In this
    way, it has *O(log[2]n) *since it splits the list in half in each iteration.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中讨论了线性搜索。在本节中，我们将讨论二分搜索。二分搜索算法在列表中间查找值，然后使用列表的一半进行搜索。因此，它具有*O(log2n)*，因为它在每次迭代中都将列表分成两半。
- en: '**Search.h:**'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**Search.h:**'
- en: '[PRE150]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: The merge sort algorithm
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 归并排序算法
- en: The merge sort algorithm divides the list into two equal sublists, sorts the
    sublists by recursive calls (a recursive call occurs when a method or function
    calls itself), and then merges the sorted sublist in a way similar to the `merge`
    method of the extended version of the `Set` class in the earlier section.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 归并排序算法将列表分为两个相等的子列表，通过递归调用（方法或函数调用自身时发生递归调用）对子列表进行排序，然后以类似于前面章节中扩展版本的`Set`类中的`merge`方法的方式合并排序后的子列表。
- en: '**Sort.h:**'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sort.h:**'
- en: '[PRE151]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'The `merge` method of this section is reusing the idea of `merge` in the extended
    `Set` class earlier in this chapter:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的`merge`方法重用了本章前面扩展`Set`类中`merge`的想法：
- en: '[PRE152]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: The quick sort algorithm
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速排序算法
- en: 'The quick sort algorithm selects the first value (called the **pivot value**)
    and then places all values less than the pivot value in the smaller sublist, and
    all values greater or equal to the pivot value in the larger sublist. Then the
    two lists are sorted by recursive calls and then just concatenated together. Let''s
    look at the following example:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序算法选择第一个值（称为**基准值**），然后将所有小于基准值的值放在较小的子列表中，所有大于或等于基准值的值放在较大的子列表中。然后通过递归调用对两个列表进行排序，然后将它们连接起来。让我们看看以下示例：
- en: '[PRE153]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: The merge sort algorithm is balanced in a way that it always divides the list
    into two equal parts and sorts them. The algorithm must iterate through the list
    once to divide them into two sublists and sorts the sublists. Given a list of
    values, it must iterate through its *n* values and divide the list *log[2]n* times.
    Therefore, merge sort *O(n log[2]n)*.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 归并排序算法在平衡方面做得很好，它总是将列表分成两个相等的部分并对其进行排序。算法必须遍历列表一次以将它们分成两个子列表并对子列表进行排序。给定一个值列表，它必须遍历其*n*个值并将列表分成*log[2]n*次。因此，归并排序*O(n
    log[2]n)*。
- en: 'The quick sort algorithm, on the other hand, is, in the worst case (if the
    list is already sorted), no better than insert, select, or bubble sort: *O(n²)*.
    However, it is fast in the average case.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序算法，另一方面，在最坏的情况下（如果列表已经排序），并不比插入、选择或冒泡排序好：*O(n²)*。然而，在平均情况下，它很快。
- en: Summary
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have created classes for the abstract datatypes list and
    set. A list is an ordered structure with a beginning and an end, while a set is
    an unordered structure.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为抽象数据类型列表和集合创建了类。列表是一个有序结构，有开始和结束，而集合是一个无序结构。
- en: We started off with rather simple versions where the list had separate classes
    for the cell and iterator. Then we created a more advanced version where we used
    templates and operator overloading. We also placed the cell and iterator classes
    inside the list class. Finally, we introduced overloaded reference methods.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从相对简单的版本开始，其中列表有单独的单元格和迭代器类。然后我们创建了一个更高级的版本，其中我们使用了模板和运算符重载。我们还把单元格和迭代器类放在列表类内部。最后，我们引入了重载引用方法。
- en: In the same way, we started by creating a rather simple and ineffective version
    of the set class. Then we created a more advanced version with templates and operator
    overloading, where we stored the values in order to be able to perform the union,
    intersection, and difference operations in a more effective way.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们首先创建了一个相对简单且效率较低的集合类版本。然后我们创建了一个更高级的版本，其中我们使用了模板和运算符重载，以便能够更有效地执行并集、交集和差集操作。
- en: Moreover, we have implemented the linear and binary search algorithms. The linear
    search works on every unordered sequence, but it is rather ineffective. The binary
    search is more effective, but it only works on ordered sequences.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还实现了线性搜索和二分搜索算法。线性搜索适用于每个无序序列，但效率较低。二分搜索更有效，但它只适用于有序序列。
- en: Finally, we looked into sorting algorithms. We started with the simple but rather
    ineffective insert, select, and bubble sort algorithms. Then we continued with
    the more advanced and effective merge and quick sort algorithms.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了排序算法。我们从简单但效率较低的插入、选择和冒泡排序算法开始。然后我们继续使用更高级和有效的归并排序和快速排序算法。
- en: In the next chapter, we will start to build a library management system.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始构建一个图书馆管理系统。
