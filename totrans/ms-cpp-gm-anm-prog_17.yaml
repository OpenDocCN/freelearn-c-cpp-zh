- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding Simple Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to *Chapter 13*! In the previous chapter, we created a separate octree
    to enhance collision detection, allowing us to detect collisions between instances
    and level geometry in a quick and computationally cheap way. Then we added simple
    gravity to the application to keep the instances on the ground of the map, eventually
    resulting in the instances walking on the level floor and small hills. Finally,
    we used inverse kinematics on the feet of the instances to keep both feet on the
    ground when climbing hills or sloped areas of a map.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will add pathfinding and navigation. We start with a brief
    overview of methods used for navigation in computer games, followed by an exploration
    and the implementation of the A* path-finding algorithm. Next, we will add navigation
    targets to the application, enabling a simple way to place path destinations in
    the virtual world. At the end of the chapter, we will implement the navigation
    toward the waypoints, allowing the instances to walk or run toward a defined target.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of different ways to navigate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The A* path-finding algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding navigation targets to the map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating instances to a target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example code for this chapter is available in the `chapter13` folder, in
    the `01_opengl_navigation` subfolder for OpenGL and the `02_vulkan_navigation`
    subfolder for Vulkan.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of different ways to navigate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pathfinding and navigation have been used in video games for much longer than
    one might think. Let’s explore a couple of navigation methods.
  prefs: []
  type: TYPE_NORMAL
- en: Distance-based navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the oldest games using a simple algorithm to mimic intelligent behavior
    for enemies is **Pac-Man** by **Namco**. Each of the four ghosts (Blinky, Pinky,
    Inky, and Clyde) has a slightly different kind of “character,” created only by
    the target point of the ghost’s movement.
  prefs: []
  type: TYPE_NORMAL
- en: While the red ghost (Blinky) is chasing Pac-Man directly, the pink ghost (Pinky)
    and the blue ghost (Inky) will try to get in front of Pac-Man, effectively trying
    to surround the player. The fourth ghost (the orange Clyde) has “a mind of its
    own” and switches between chasing the player and running away.
  prefs: []
  type: TYPE_NORMAL
- en: 'The decision about the new path to choose is made only at the intersections
    in the game’s maze and is based entirely on the distance to the target tile for
    all possible ways at the intersection. The game does not use more advanced look-ahead
    path planning, sometimes leading to a bad decision. *Figure 13.1* shows such a
    decision situation at an intersection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22428_13_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Navigation decision of the red ghost in Pac-Man'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 13.1*, the green box is the field triggering a decision to go left
    or right and the two dashed green lines are the direct distances to the red-outlined
    target tile. Even though the right path is shorter, the left path will be chosen
    due to the shorter decision distance on the left, creating erratic behavior of
    the ghost. A link is available in the *Additional resources* section with in-depth
    information about the internals of ghost navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Simple distance-based navigation is still used in games today, for instance,
    to find the spot where an enemy could intercept the player, based on the speed
    and direction of both entities. Planning the path to the player is then done with
    a graph-based navigation algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Graph-based navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a graph, search algorithms use the nodes of a graph to describe locations
    on a game map and the edges to describe the connections between the nodes. By
    building a graph of the map, the shortest path between two locations can be found
    in an organized manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several graph algorithms are used in navigation. The most common ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Depth-First Search** (**DFS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Breadth-First Search** (**BFS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dijkstra’s algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A* (pronounced “A star”)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DFS and BFS algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both of these are simple algorithms. While DFS traverses the graph “depth-first,”
    from the start node to the most distant node, BFS visits the nearest nodes first,
    advancing in “rings” to the next nodes. *Figure 13.2* shows an example graph made
    of six nodes named A to F:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22428_13_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: BFS and DFS'
  prefs: []
  type: TYPE_NORMAL
- en: The BFS algorithm on the left side of *Figure 13.2* starts with the closest
    nodes (B, C, and D) after the root node (A) and then traverses to nodes E and
    F. The DFS algorithm on the right side of *Figure 13.2* traverses child node D
    and D’s child node (F) first, advancing to nodes C and E, and, finally, to node
    B.
  prefs: []
  type: TYPE_NORMAL
- en: Dijkstra’s algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dijkstra’s algorithm adds weights to the edges of a graph. The weights can be
    seen as costs or distances to travel from one node to another, depending on the
    problem to solve. Dijkstra’s algorithm traverses the entire graph, building a
    table containing the shortest paths from a start node to all other nodes of the
    graph.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 13.3* shows the starting graph and the result after all steps of the
    algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22428_13_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: A graph and the shortest distances from A to all other nodes'
  prefs: []
  type: TYPE_NORMAL
- en: By using Dijkstra’s algorithm, any weighted graph can be traversed to find the
    paths with the lowest costs (or distances) from one node to all other nodes, but
    the algorithm must be rerun for every start node. For a full description of the
    algorithm, a link in the *Additional resources* section is provided showing the
    steps of finding the shortest distances for the graph in *Figure 13.3*.
  prefs: []
  type: TYPE_NORMAL
- en: A* algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A* uses Dijkstra’s algorithm as a basis, but two additions are made:'
  prefs: []
  type: TYPE_NORMAL
- en: A so-called **heuristic** is added to each node, stating the estimated distance
    from each node to the target node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The algorithm searches from a start node to a specified target node and usually
    terminates when the target node has been reached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By combining the distance from the start node to a node and the estimated distance
    from the same node to the target node and using the shortest sum while traversing
    to the next node, A* does a directed search toward the target node. So, instead
    of doing an undirected search like BFS or DFS, A* always heads in the direction
    of the target node. We will discuss A* in depth in the *The A* path-finding algorithm*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: One drawback of the algorithms in this section is that they have to recreate
    the entire path if the target is not static. For dynamic targets, algorithms like
    LPA*, D*, or D*-Lite could deliver better results. Also, several other path-finding
    algorithms have been created since the introduction of A*, aiming for special
    environments like in robotics, or to further optimize the outcome path-finding
    process, like in Theta*.
  prefs: []
  type: TYPE_NORMAL
- en: Before exploring A*, let’s look at another popular navigation type in video
    games, using triangles or other polygons to describe the walkable area for bots
    and NPCs, and also take a short look at machine learning as an alternative version
    to create navigation data.
  prefs: []
  type: TYPE_NORMAL
- en: Mesh-based navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simple games like Pac-Man and many strategy games use distance-based navigation
    by dividing the world into a grid, usually built from rectangular or hexagonal
    structures. But the needs of three-dimensional games (like an open world) or first-
    and third-person exploration and fighting games are different. Due to overlapping
    parts of the virtual world, a three-dimensional structure is needed to be able
    to guide computer-controlled characters through the map.
  prefs: []
  type: TYPE_NORMAL
- en: Most games with three-dimensional maps use either navigation meshes, area awareness,
    or a combination of both.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation meshes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Navigation meshes** (also called **NavMeshes**) were introduced in games
    around the year 2000\. A navigation mesh is an additional data structure made
    of polygons (triangles in most implementations), overlaying the level geometry.
    The polygons in a navigation mesh mark the walkable area of a level, omitting
    any objects and structures a computer-controlled character could collide with.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By using a navigation mesh, a bot or NPC can walk around in the virtual world
    while avoiding costly collision checks with static level geometry if the character
    stays on the navigation mesh. Only if the character can leave the navigation mesh
    are collision checks required. In combination with a graph-based algorithm like
    A*, fine-grained control of the behavior of computer-controlled characters is
    possible. A link to a comprehensive introduction to pathfinding with navigation
    meshes is available in the *Additional resources* section. *Figure 13.4* shows
    a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22428_13_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.4: Navigation mesh with start (green), target (red), and path from
    start to target'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 13.4*, the top picture shows the shortest possible path from the
    starting triangle (green) to the target triangle (red) by using the next vertex
    in a line of sight to the next sharp corner of the mesh.
  prefs: []
  type: TYPE_NORMAL
- en: In comparison, the path in the middle picture uses the triangle centers as graph
    nodes for the path-finding algorithm, and the bottom picture uses the inner triangle
    edges as graph nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The path’s quality depends on the mesh and which part or parts of a triangle
    will be used for the graph node. Combinations of the methods in *Figure 13.4*
    are possible, so both the center and the middle of triangle edges could be used
    as graph nodes. The resulting path can also be smoothed by skipping to the next
    directly visible node and by using splines for the curves.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that if the edge navigation mesh is too close to walls or borders in
    a narrow passage, an instance may collide with the walls, generating additional
    movement corrections or leading to an impassable part of the mesh. Static obstacles
    in a level should also be bypassed at a safe distance.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, use the distance between the edges and the center of the
    axis-aligned bounding box of an instance as the minimum distance between the edges
    of the navigation mesh and the adjacent level geometry. By keeping the instance
    away from walls at any time, no collision can occur during normal navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a navigation mesh from level data
  prefs: []
  type: TYPE_NORMAL
- en: Usually, a navigation mesh will be created by hand and added to the level data.
    But we need a solution for levels found on the internet, so we will do a shortcut
    in the code and use the same upward-facing triangles as “possibly walkable ground”
    that are used for the detection if the instance collides with the level ground.
  prefs: []
  type: TYPE_NORMAL
- en: In combination with adjacency relations between all ground triangles, an estimation
    of the walkable area in the level can be achieved. A couple of enhancements to
    the ground area creation code are available as tasks in the *Practical sessions*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using navigation meshes, two kinds of navigation are possible: free roaming
    through the virtual world and patrolling between waypoints.'
  prefs: []
  type: TYPE_NORMAL
- en: Free navigation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With free navigation, any point on a map can be a target point for the start
    and destination. Moving from one part of the level to another may be costly to
    calculate; in the worst case, the entire mesh must be checked during pathfinding.
    Also, the path of the character may be entirely different between two path plannings,
    depending on the exact position of the start and target.
  prefs: []
  type: TYPE_NORMAL
- en: Waypoint navigation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A better approach for mesh-based navigation is to define waypoints on the navigation
    mesh that are visible to each other. For instance, every door in a group of rooms
    will be a waypoint or every fork in the road. When a bot moves through the virtual
    world, a waypoint is set as the next target after reaching the desired waypoint.
    If the player is spotted and then lost, the bot can return to the nearest waypoint.
    By making sure that the computer-controlled character can always “see” at least
    one waypoint, path planning to that next waypoint becomes cheap and easy to calculate.
  prefs: []
  type: TYPE_NORMAL
- en: Area awareness system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 1999, **id Software** used a system called **area awareness** in **Quake
    III Arena**. Instead of two-dimensional graphs, a simplified three-dimensional
    representation of the levels was created, containing all information about the
    level structure, other bots, and the player.
  prefs: []
  type: TYPE_NORMAL
- en: The bots can traverse the awareness areas not only by walking, jumping, or swimming
    but also by using a teleporter, a jump pad, or even by doing a rocket jump. With
    such a large repertoire of actions, a bot can easily follow the player around
    in the level or try to cut off the player’s path.
  prefs: []
  type: TYPE_NORMAL
- en: A full description of the area awareness system is available in a link to a
    PDF document in the *Additional resources* section.
  prefs: []
  type: TYPE_NORMAL
- en: Using machine learning to generate navigation data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A more recent way to create navigation data for computer-controlled characters
    is machine learning, mostly in the form of so-called **reinforced learning**.
    During reinforced learning, an agent representing the character explores the virtual
    world on its own in a large amount of “trial-and-error” style rounds, but with
    added rewards for achieving a defined task or a punishment for failing to complete
    the task.
  prefs: []
  type: TYPE_NORMAL
- en: Such a task could be something like “Reach a defined target point with maximum
    health,” “Don’t fall off the level,” or “Complete the level in minimum time.”
    By taking the rewards and punishments of previous explorations into account, the
    agent optimizes its behavior to maximize rewards and minimize punishments. When
    the data generated by these agents is used in games, the enemies can utilize the
    strategies from machine learning to appear even more natural when moving around
    in the virtual world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two challenges of machine learning are making the usage time- and cost-expensive:'
  prefs: []
  type: TYPE_NORMAL
- en: Goals, rewards, and punishments must be clearly defined and adjusted during
    the calculations. Even if we humans think that the goals and rewards are well-defined,
    the machine learning algorithm could find unexpected ways to maximize rewards.
    A failure in the setup may result in discarding the data and doing a complete
    restart of the entire machine learning cycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since machine learning is exploring the virtual world by trial and error, progress
    is non-deterministic and may happen only in insignificant amounts. Even for simple
    tasks, thousands of game rounds must be played to achieve the desired results
    while the game is running. Creating a complex AI that explores big levels of the
    game may need a significant amount of computational resources, leading to excessive
    development costs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though machine learning may produce better results than algorithm-based
    navigation, it is recommended to check the trade-offs between possible improvements
    and additional costs. A link to a video showing the progress of letting a machine
    learn how to drive a car is available in the *Additional resources* section.
  prefs: []
  type: TYPE_NORMAL
- en: After the short round-up of navigation methods, let’s dive into the A* algorithm
    next.
  prefs: []
  type: TYPE_NORMAL
- en: The A* path-finding algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The A* algorithm was published in 1968 in the earlier days of computing. A*
    is the result of the path planning for an AI-controlled mobile robot called **Shakey**.
    The robot was developed at the Stanford Research Institute. Its software included
    computer vision and natural language processing, and it was able to do simple
    tasks like driving to a place in the lab on its own, without describing every
    single action in advance. A link is available in the *Additional resources* section
    with more details about the project and the robot.
  prefs: []
  type: TYPE_NORMAL
- en: But what makes A* different from Dijkstra’s algorithm?
  prefs: []
  type: TYPE_NORMAL
- en: Estimating the distance to the target
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Dijkstra’s algorithm only uses the weights between nodes, A* adds a heuristic
    value to every node. The heuristic function calculates an estimated cost of the
    cheapest path from every node to the selected target. In many cases, such as for
    large worlds and many nodes, calculating the minimal costs between every pair
    of nodes is computationally expensive, so an “educated guess” for the costs is
    cheaper to calculate and also good enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the heuristics function, any distance calculation function can be used.
    In most cases, either the so-called **L1 norm** will be used, known as the **Manhattan
    distance**, or the **L2 norm**, known as the **Euclidean distance**. *Figure 13.5*
    shows the idea behind both distance calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22428_13_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.5: Manhattan and Euclidean distances from start to target'
  prefs: []
  type: TYPE_NORMAL
- en: The Manhattan distance is modeled after the path of a taxicab in Manhattan.
    The streets are organized in parallel lines, crossing at an angle of 90 degrees.
    Like a cab in Manhattan, the blue paths in *Figure 13.5* can only use the grid
    lines between the start and the target. It also does not matter whether we use
    straight, direct lines, as in the dark blue path, or a staircase version, like
    the light blue path; the distance for both paths is identical.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the Euclidean distance for the green path in *Figure 13.5* is calculated
    by using the Pythagorean theorem. This means squaring the lengths of the distances
    in both directions, summing up the squares, and calculating the square root of
    the sum.
  prefs: []
  type: TYPE_NORMAL
- en: Whether Manhattan distance, Euclidean distance, or any other distance calculation
    will be used for the heuristics function of A* heavily depends on the needs of
    the application. For instance, obstacles, hills, or enemies in a game map may
    need to be considered when estimating the distances. An intuitive way to find
    the best function is by drawing the paths for every heuristic function and a set
    of combinations for the start and target node and comparing the results.
  prefs: []
  type: TYPE_NORMAL
- en: By using the heuristic value to the target node, A* tries to minimize the costs
    of the path to the target for every iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing path costs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In every iteration, A* uses the sum of the known costs of the path *from the
    start* node and the estimated costs *to the target* node for every neighbor of
    the current node to calculate the minimal costs to reach the target node. Then,
    the algorithm chooses the neighboring node with the minimum costs, makes that
    neighboring node the current node, and starts the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, A* saves a reference to the current node in each visited neighboring
    node if the overall cost from the start to the target over this neighbor is minimal
    among all neighboring nodes. Storing the parent node in a node allows backtracking
    to the best path from target to source after the target node has been reached.
  prefs: []
  type: TYPE_NORMAL
- en: To visualize the algorithm, let’s step through a small example.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the A*algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 13.6* shows a graph with nodes A, B, C, and D, plus the heuristics
    table from every node to the desired target node, D. The start node, in this case,
    is node A.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22428_13_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: A graph to traverse plus estimated distances to the target node,
    D'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can immediately see the shortest path from node A to node D: ABCD. But for
    the computer, the A* algorithm must walk through the nodes to find this path.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first iteration, we visit the neighbors of node A, as shown in *Figure
    13.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22428_13_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.7: Visiting nodes B and C'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we calculate the estimated distance as the sum of the known distance from
    A and the heuristic value of each node. The sum for node B is lower, so we proceed
    to node B. We also remember the parent node for B since A is the direct predecessor
    of B.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we look at all neighbors of node B, as shown in *Figure 13.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22428_13_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.8: Visiting nodes C and D'
  prefs: []
  type: TYPE_NORMAL
- en: We do the same calculations for node C and sum up the costs from A to B, B to
    C, and the heuristic from C to D. In an optimized version of A*, our search could
    be already over since we reached the target node, D.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we continue here by checking the remaining neighbors of node D in case
    there is an even shorter path available. So, we update the parent node of nodes
    C and D, and visit node C as the last yet unvisited neighbor of node D, as shown
    in *Figure 13.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22428_13_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.9: The shortest path from A to D is ABCD'
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, the path to node D via nodes B and C is much shorter than the path via
    B. So, we set node C as the new parent node for node D. After all the neighboring
    nodes of the target node D have been visited, A* has fulfilled its job to find
    a path from node A to node D.
  prefs: []
  type: TYPE_NORMAL
- en: 'By backtracking the parent nodes, we get the path from the target to the start.
    By reversing the node order, we now have the shortest path from the start to the
    target: ABCD.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, even in this very simple example, A* cares about the total estimated
    costs to the target when choosing the node to proceed with. If the algorithm learns
    about a shorter distance while working on a node, the parent node used to backtrack
    the best path is also updated. In the *Additional resources* section, a link to
    a website with a deep dive into A* is available.
  prefs: []
  type: TYPE_NORMAL
- en: After an overview of the algorithm, let’s add the path-finding code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing A*-based navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we will not have a simple two-dimensional terrain in most maps, a two-dimensional
    grid for navigation cannot be used. Instead, we will use a navigation mesh to
    find a path from a source object to a target object in the virtual world.
  prefs: []
  type: TYPE_NORMAL
- en: As already stated in the *Navigation meshes* section, creating the meshes is
    at least a partially manual job, depending on the editor used to create the game
    map. Some editors can create a navigation mesh based on the map’s elements, but
    in most cases, the generated mesh must be corrected manually. The navigation mesh
    must be stored on the same map as the rest of the level data or in a separate
    data file.
  prefs: []
  type: TYPE_NORMAL
- en: To support both in-map and separate navigation mesh, the path-finding class
    is kept modular when it comes to the walkable ground meshes. For instance, if
    your navigation mesh is saved with a special name in the map file, you could import
    the navigation polygons and their adjacency properties into the path-finding class.
    You also have to import the navigation triangles into a separate triangle octree
    and do an additional ray-to-triangle intersection to find both the ground-level
    triangle and the navigation mesh triangle. The A* path-finding algorithm has also
    been implemented as a separate method, allowing you to easily add other algorithms
    or a different heuristics function.
  prefs: []
  type: TYPE_NORMAL
- en: In the example code in this chapter, we will use the same idea as for the ground-level
    detection and use the normal of each mesh triangle to decide whether it is walkable
    or not. This method will result in having all upward-facing triangles in the navigation
    mesh, even if the triangles may be unreachable by any instance. But to demonstrate
    the general idea of pathfinding and navigation in a game map, creating a navigation
    mesh from the ground triangles of the map is sufficient and delivers reasonable
    results.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the Euclidean distance to calculate the distance between nodes and
    for the heuristic function, as the triangles in the map are most probably not
    arranged in a rectangular grid. To speed up the distance calculations, we will
    extend the mesh triangle data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the mesh triangles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MeshTriangle` struct is defined in the `OGLRenderData.h` file for OpenGL
    and in the `VkRenderData.h` file for Vulkan. At the end of the `MeshTriangle`
    struct, we add the two new arrays, `edges` and `edgeLengths`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the `edges` array, we store the three edges of each triangle. We order the
    edges by using the same winding as the original triangles. As we will need the
    lengths of the edges during the calculation of any adjacent triangles, we store
    the length of each edge in the corresponding `edgeLengths` element.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can jump directly into the implementation of the path-finding class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the path-finding class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The path-finding class (named `PathFinder`) will reside in the `tools` folder
    where all other helper classes created in the previous chapters are stored, like
    `AABB` or `IKSolver`. To keep the naming consistent, the header file is named
    `PathFinder.h` and the implementation will go into the `PathFinder.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of the `PathFinder.h` header, right after all the `#include` directives,
    we add two `struct` entries. The first new struct is named `NavTriangle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We don’t reuse `MeshTriangle` here as we need a couple of different variables.
    While `index`, the `points` array, and the `normal` vector are the same, we also
    need to store the world position of the center of each triangle in the `center`
    variable and the surrounding triangles in `neighborTris`. The instance will navigate
    from one triangle center to the next, and the triangles stored in `neighborTris`
    are used to find the triangle with the shortest distance to the target.
  prefs: []
  type: TYPE_NORMAL
- en: For the neighbor triangles, `std::unordered_set` has been chosen over a plain
    `std::vector` to have an automatic removal for duplicate entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second struct is called `NavData` and contains the data for the A* algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the `triIndex` variable, we store the triangle index of the corresponding
    `NavTriangle`. By using the index, we can do a simple lookup to find triangle
    data like position or neighbor triangles. As soon as we visit a neighboring node
    of a triangle, we add the index of the triangle with the shortest path so far
    to `prevTriIndex`, allowing us to backtrack the shortest path at the end of the
    pathfinding run.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining three variables (`distanceFromSource`, `heuristicToDest`, and
    `distanceToDest`) are the workhorses of the A* algorithm. Here we store the aggregated
    distance from the source to the current node, the result of the heuristic function
    for the distance between the current node and the target, and the sum of both
    distances. By comparing the values of `distanceToDest` for all neighboring nodes,
    A* chooses the next node toward the target node.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the two new structs, the `PathFinder` class is declared, starting with
    the two public methods, `generateGroundTriangles()` and `findPath()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By calling `generateGroundTriangles()`, all upward-facing triangles in the triangle
    octree are located and the neighbor information for each “walkable” triangle is
    created. Once the ground data is ready, `findPath()` can be used to find a path
    from the start triangle to the target triangle. The result of `findPath()` is
    the path found by A* as a vector of triangle indices to step on, ordered from
    the start triangle to the target triangle, or an empty vector if no valid path
    exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also in the `PathFinder` class is the `private` member called `mNavTriangles`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We store the calculated ground triangles in the `mNavTriangles` map. A mapping
    between the index and the triangle data is used for fast access by using the triangle
    index, also stored as part of a `NavData` element.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s step through the ground triangle generation code next.
  prefs: []
  type: TYPE_NORMAL
- en: Generating ground triangles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ground triangles are generated by utilizing the triangle octree generated
    by the renderer. Since we will make a lot of requests to the triangle octree,
    it will be given as the second parameter in the `generateGroundTriangles()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'After clearing any previously generated navigation triangles, we get all triangles
    from the octree by a query with the world boundaries given as the third parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we loop over all level triangles to find the subset of upward-facing triangles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Comparing the dot product of a triangle’s normal and an upward-facing vector
    with the cosine of the `rdMaxLevelGroundSlopeAngle` value is known from the collision
    detection in [*Chapter 12*](Chapter_12.xhtml). If the current triangle fulfills
    the check, we add it to the `groundTris` vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next to the ground triangles in `groundTris`, we fill the `NavTriangle` named
    `navTri` with minimal data and add `navTri` to the `mNavTriangles` map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We use different sets of data in the `groundTris` vector and the `mNavTriangles`
    map here since a query to the triangle octree returns a vector of `MeshTriangles`
    but we maintain a better fitting map of `NavTriangles` for the ground triangles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can iterate over all ground triangles and query the triangle octree
    for all colliding triangles in the level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This query works well as, in [*Chapter 12*](Chapter_12.xhtml), we had to make
    the bounding box of every triangle in the `generateLevelOctree()` method of the
    renderer classes `OGLRenderer` or `VkRenderer` a bit bigger to avoid a size of
    zero in any of the three dimensions. With this minimal size change, the bounding
    boxes of adjacent triangles in the level data are colliding now, and the triangle
    octree returns all neighbor triangles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we get a reference to the same ground triangle in the `mNavTriangles`
    map and iterate over all triangles reported by the octree query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using a reference for the ground triangle is important because we will update
    the neighbor triangles directly on the `NavTriangle` object in the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'And even though these two nested loops look awful, the overall computation
    time is still small because the octree query reports only a small number of neighbor
    triangles. We can even sort out more triangles by simple checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The query for colliding triangles may also report the ground triangle we are
    currently inspecting, so we return immediately if we find it in the results. We
    also remove all triangles not facing upward from the list of possible neighbors
    as we are only interested in adjacent ground triangles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case of triangulation errors made by `Assimp`, we also need to check if
    the peer triangle is in `mNavTriangles`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we find a valid neighbor triangle, we get the neighbor triangle from the
    `mNavTriangles` map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can do a loop over all three vertices of both triangles to check
    for adjacency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the loop, we calculate the distance of every vertex from the edges of
    the other triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: By calculating the distance from all vertices to every edge of the other triangle,
    we can detect if the triangles share a vertex or a side, or if a vertex of one
    triangle is on the edge of the other triangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the distance is small enough, we add the index of the current peer triangle
    to the set of neighbor triangles of the currently inspected ground triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: After the `generateGroundTriangles()` method has finished the calculations,
    the `mNavTriangles` map contains all possibly “walkable” ground triangles, and
    for every triangle, a list of triangles sharing at least a side or a vertex.
  prefs: []
  type: TYPE_NORMAL
- en: A note on the navigation mesh quality
  prefs: []
  type: TYPE_NORMAL
- en: 'The quality of the generated ground triangle mesh heavily depends on the map:
    Since the upward-facing triangles in the map may not form a perfect triangle mesh
    that shares vertices between triangles, the generated ground triangles in the
    `mNavTriangles` map may contain more neighbors than a separate navigation mesh
    would have. More triangles in a level usually also bring better quality here.'
  prefs: []
  type: TYPE_NORMAL
- en: With a navigation mesh of ground triangles at hand, we can go for the A* algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Finding a path between two ground triangles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The implementation of the `findPath()` method follows the A* algorithm and should
    be easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We start by extracting the center points of the target and start triangles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We will need the center point to calculate the distances between the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create two sets called `navOpenList` and `navClosedList` and a map
    named `navPoints`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the `navOpenList` variable, we store all neighbors of nodes that are candidates
    for the next iteration, and in `navClosedList`, we save all nodes that were already
    fully explored. The `navPoints` map contains data about all known nodes, like
    the distances and the parent node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to the first iteration of the A* algorithm, we set the `currentIndex`
    variable to the start triangle and create the navigation data for the start triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The distance to the target point is calculated as Euclidean distance by using
    a call to `glm::distance` and the distance to the start point is set to zero as
    we are still at the start point. We also add the start node to both the list of
    open nodes and the map containing the navigation data.
  prefs: []
  type: TYPE_NORMAL
- en: Running the main loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the main loop of the A* algorithm, we start a `while` loop that ends if
    we hit the target triangle. The loop is *not* guaranteed to end at some point
    in time (for instance, if the target triangle is outside of the reachable mesh),
    so we will need to add an exit condition at the end of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For every loop iteration, we extract the current triangle from the `mNavTriangles`
    map and get the center point in world coordinates and the neighbor triangles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we loop over all neighbor triangles and extract the center point of the
    triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If the neighboring node is not fully explored and not even visited yet, we
    continue inside the two `if` conditions and add the node to the open list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As a reminder, the closed list contains all fully explored nodes, and the open
    list contains all known neighbors but not yet fully explored nodes of any of the
    nodes (even already closed nodes). At this point, we know that this is a new node
    to visit, so we create new navigation data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For the distance calculation, we get the distance from the current index (our
    parent node) and add the distance between the two nodes to the distance from the
    source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As the last step of the code block, we add the new navigation data to the `navPoints`
    map that contains data about all currently known nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the neighboring node is already in the list of open nodes, we check if we
    need to update the existing navigation data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we get a reference to the navigation data to be able to update the information
    in place. For the existing navigation point, we calculate the new estimated distance
    from the known distance to the source and the heuristic value to the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If the new path through this node is shorter than the previously known path,
    we update the navigation data to reflect the new, shorter path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After all neighboring nodes have been checked, we add the current node to the
    closed list, marking it as fully explored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If our open list becomes empty, we return an empty vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We check for an empty open list before going on since the next step involves
    a loop over all elements of the open list.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the best node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we have collected all the new nodes and updated the distances of all existing
    nodes, we need to find the node with the shortest combined distance from start
    to target. We will use a priority queue here to minimize the costs to access the
    node having the smallest distance. The priority queue will sort all nodes according
    to a comparison function into a tree structure and allow accessing the largest
    or smallest node as the topmost element.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create the comparison function for the priority queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: By default, a priority uses `std::less` as a comparison function, resulting
    in a queue with the maximum value as the top element. But by using the `cmp` function,
    we will have the minimum distance to the destination as the top element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can fill the queue by pushing all triangles in the open list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we declare an empty navigation data variable and extract the index with
    the minimum distance from the queue by a call to `top()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The new triangle index will be used for the next loop of `while`, looping until
    the target triangle has been found as the triangle with the minimal distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final step for the A* algorithm, we erase the node from the open list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Once we have found the target triangle, the outer `while` loop ends, and we
    can collect and return the shortest path
  prefs: []
  type: TYPE_NORMAL
- en: Backtracking the shortest path
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we have saved the parent node with the shortest distance so far in the
    navigation data for every triangle, we just need to follow the chain along the
    parent nodes, starting from the target node until we hit the start node. The start
    node is marked by a parent node of `-1`, so we know when to stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a new vector named `foundPath` and store `currentIndex` in
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The main `while` loop ends when `currentIndex` is identical to the requested
    `targetIndex`, so we could use any of the two variables here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we get the navigation data of the current triangle and loop over all
    parents until we hit the start triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As we started the backtracking at the target triangle and ended on the start
    triangle, the order of the triangles in `foundPath` is also from target to start.
    To fix the order, we reverse the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we return the reversed path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We can call `findPath()` now with any combination of start and target triangles
    and get a path back if such a path exists. If no path from start to target exists,
    `findPath()` returns an empty vector by the check for the empty open list.
  prefs: []
  type: TYPE_NORMAL
- en: The starting point of the pathfinding is known; it’s the instance. But what
    about the target? Let’s add some configurable navigation targets to the virtual
    world.
  prefs: []
  type: TYPE_NORMAL
- en: Adding navigation targets to the map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start, let us imagine which properties a possible navigation target
    must have:'
  prefs: []
  type: TYPE_NORMAL
- en: It should come in any shape and number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be easy to select and move around.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be placed anywhere on the ground.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideally, it should be able to move by itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, our ideal target is a model instance! And since we already have all the
    ingredients for this list, implementing navigation targets becomes easy.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting model and instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we add a new Boolean variable named `msUseAsNavigationTarget` to the
    `ModelSettings` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AssimpModel` class also needs two simple `public` methods named `setAsNavigationTarget()`
    and `isNavigationTarget()` to set and query the new variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `UserInterface` class, a checkbox will be added to set the state of
    a model with a simple mouse click. *Figure 13.10* shows the **Models** layout
    with the new checkbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22428_13_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.10: The Models part of the UI with the new navigation target checkbox'
  prefs: []
  type: TYPE_NORMAL
- en: By setting the **Use as NavTarget** checkbox in *Figure 13.10*, we can control
    whether or not a model should be used as a navigation target.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the instances, we add the five variables to the `InstanceSettings` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: To control the navigation on a per-instance basis, `isNavigationEnabled` is
    used. The two variables `isPathTargetInstance` and `isPathToTarget` should not
    need an explanation; their names state what they are for. In `isPathStartTriangleIndex`,
    the index of the triangle is saved where the instance currently resides, and `isPathTargetTriangleIndex`
    is filled with the triangle index of the target instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `AssimpInstance` class, simple `public` setter and getter methods for
    the new variables are added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the **Instances** collapsing header of the `UserInterface` class, a couple
    of new controls are added too:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22428_13_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.11: New navigation controls for the instances'
  prefs: []
  type: TYPE_NORMAL
- en: When checking the **Enable Navigation** checkbox, the remaining parts of the
    navigation controls are enabled. If any navigation target model exists, the **Nav
    Targets** combo box is populated with the indices of the instances, allowing us
    the set the instance number to use as the target. In the case that a target was
    set, **Nav Target** shows the index of the current target, or `-1` if no target
    was selected. To find the target without switching instances, `Center Target`
    can be pressed, centering the target in the middle of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the combo box with the navigation targets, a callback named `getNavTargetsCallback`
    will be added to the `Callbacks.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding method in the renderer class files `OGLRenderer.cpp` and
    `VkRenderer.cpp` is called `getNavTargets()` and collects the indices of all instances
    from models enabled as navigation targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We loop over all models, and if the model is not a navigation target, we continue
    with the next model. If the model is marked as a navigation target, we store all
    indices in a vector named `targets` and return the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: To place the targets on the ground, we also need gravity to apply.
  prefs: []
  type: TYPE_NORMAL
- en: Adding gravity for non-animated instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gravity is currently only affecting any animated instances since we needed them
    to stay on the ground for collision detection and inverse kinematics in [*Chapter
    12*](Chapter_12.xhtml). Thanks to keeping the code for animated and non-animated
    models mostly similar, adding gravity for non-animated instances is done with
    only a couple of small changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, copy the entire code block with the `mLevelCollisionTimer.start()` and
    `mLevelCollisionTimer()` calls below the call that adds the current instance to
    the instance octree, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add a call to `updateInstancePosition()` below the new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, move the retrieval of the matrix containing the world transforms from
    the start of the block after the instance position update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: That’s all!
  prefs: []
  type: TYPE_NORMAL
- en: Now the gravity and ground collisions are also calculated for non-animated instances,
    the instance position is updated, and the most recent world transforms are collected
    and added to the `mWorldPosMatrices` array, which is then uploaded to a Shader
    Storage Buffer Object.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading the new model and instance data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Storing the new values in the YAML configuration file and restoring the settings
    should need no further explanation. The Boolean to use a model as a navigation
    target is stored in the `ModelSettings` struct and all new path-finding and navigation
    variables for the instance are stored in the `InstanceSettings` struct. Adding
    the new values to the YAML emitter and parser is only a matter of copying and
    pasting. The YAML configuration version should be updated, too, to reflect the
    new values.
  prefs: []
  type: TYPE_NORMAL
- en: We have ground triangles, a path-finding algorithm, and the start and target
    points of a path. What’s left is the logic to make an instance follow the path.
    So, let’s add the last part now.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating instances to a target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To calculate or update the path to the target instance, we need to add more
    code to the renderer. We start by adding the code to compute the actual path from
    an instance to the target position.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the path to the target
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best place for the path update code is in the loop over all animated instances
    in the `draw()` call of the renderer class `OGLRenderer.cpp` or `VKRenderer.cpp`,
    right after the ground and collision detection code that was just copied for the
    non-animated instances. We have the final world position of the instance available,
    including any gravity updates, and can use this position as the starting point
    of the path-finding algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we check if navigation is enabled for the instance and get the instance
    index of the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we do a sanity check of the target instance to avoid a crash when accessing
    the `micAssimpInstances` vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, extract the index of the triangle the target is currently on plus the
    world position of the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As the target instance may move by itself or may be moved by the user, the target
    triangle index must be retrieved before every path update. This triangle index
    update ensures that the instance is following the target, regardless of the target
    being a static waypoint or another instance that roams around in the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we check if both the current instance and the target instance have a valid
    ground triangle and if we or the target moved away from the saved triangle. Only
    if all conditions are met do we recalculate the path at all, avoiding costly computations
    when no changes to the source or target occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of any changes, we adjust the start and the target triangle of
    the current instance. With the most recent data for the triangles, we can call
    `findPath()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The result may be empty if no valid path has been found. In that case, we disable
    the navigation of the instance and invalidate the target instance by setting it
    to `-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If the path was valid, we set the path indices in the instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the path will only update on changes, we get the saved or just updated
    path of the instance now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid awkward movement when starting or ending the path to a target, we
    remove the start and target triangles from the instance path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The path is created between the center of the ground triangle the instance is
    currently standing on to the ground triangle the target resides. If the instance
    is already closer than the triangle center, the path would point backward, and
    the instance may never leave the current ground triangle. We could also remove
    the elements in the `PathFinder` class, but if we want to use the data generated
    in `findPath()` anywhere else, the triangles may be needed. So, we cut off the
    triangle indices here.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the last step for pathfinding, we rotate the instance toward the next path
    point or the target, depending on whether we have a path left in `pathToTarget`
    or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The call to `getTriangleCenter()` of the `PathFinder` class returns the center
    of the requested triangle in world coordinates. This center point is then fed
    into the `rotateTo()` method of the instance, so let’s look at the implementation
    of the rotation method next.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating the instance to reach the target
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new `public` method called `rotateTo()` must be added to the `AssimpInstance`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we check if the instance walks or runs right now. Rotating the instance
    while standing idle on the ground may look strange:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we get the rotation vector of the current instance and the vector from
    our position toward the target position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We are only interested in a rotation around the Y axis, so we use the two-dimensional
    rotation vector of the instance and reduce the vector to the target and also to
    the values of the X and Z dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the two vectors `myRotation` and `toTarget`, we can calculate the
    angle between the two vectors via the dot product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we calculate a quaternion containing the rotation between the two
    vectors, extract the Euler angles, and use the `y` element of the angle to rotate
    the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The multiplication with `deltaTime` makes the instance rotation smooth since
    the angle in every frame is small. The initial comparison of the `angleDiff` value
    makes sure we have a small “dead zone” left, leading to fewer rotations if the
    path is nearly straight and avoiding oscillations in case the rotation oversteers
    a bit.
  prefs: []
  type: TYPE_NORMAL
- en: If the target is moving around in the level, the dead zone also reduces the
    number of corrections when the path of the instance is recreated. By carefully
    tuning the amount of oversteering and the dead zone angle, a chasing instance
    will behave more naturally since both parameters could reduce the number of directional
    changes while following the target.
  prefs: []
  type: TYPE_NORMAL
- en: To make the calculated path visible, we should also add a visual output for
    the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: Adding debug lines for the path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drawing the path to the screen is astonishingly easy. Next to adding a control
    Boolean named `rdDrawInstancePaths` to the `OGLRenderData` struct for OpenGL,
    respective to the `VkRenderData` struct for Vulkan, a new line mesh in the renderer
    and a checkbox in the `UserInterface` class, creating the lines between all path
    points is easy. The best place for the new code is after the code added in the
    *Calculating the path to the target* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we check if we should create the lines at all and if we have a valid
    target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we set the desired color and a height offset for the path and create
    a vertex to draw the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the world position of the current instance as the starting point
    for the lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have a valid path, we extract the world position of the first triangle
    center of the path as the second point for the first line. Since we already removed
    the starting triangle, the line will be drawn to the next triangle in the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a new temporary line mesh and retrieve the vertices of the
    path segments by calling `getAsLineMesh()` of the `PathFinder` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The helper method `getAsLineMesh()` just extracts the center points of the ground
    triangles on the path, adds the desired offset to the world position of the vertices,
    and creates lines from the vertices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we add the last position as a possible starting point for the last line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final step for the line creation, we add the world position of the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: If the path is empty after removing the first and/or last element, we skip the
    code inside the `if` condition and draw only a line from our own position to the
    target. This happens only if we have a valid target, and the start and target
    triangles are directly next to each other. If an error occurs during pathfinding
    and the path is empty, we reset the target instance, and the line is no longer
    drawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw the created lines, a new `private` method called `drawInstancePaths()`
    is created in the renderer class `OGLRendere.cpp` or `VkRender.cpp` that just
    sends the lines to the shader. After enabling the navigation debug draw by enabling
    the **Enable Navigation** checkbox under the **Navigation** header and the **Draw
    Instance Path** checkbox under the **Levels** header, navigation paths for the
    instances will be drawn as green lines, similar to *Figure 13.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22428_13_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.12: Debug lines showing the path of the instances'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 13.12*, the model of a traffic cone was added and marked as a navigation
    target. Then, the instances were instructed to walk to their desired targets.
  prefs: []
  type: TYPE_NORMAL
- en: The jagged paths between the instances and the targets are a result of large
    ground triangles in the selected level map. Since the instances are moving from
    triangle center to triangle center, the paths have larger angles as the distances
    between the center points are quite large. A level with smaller ground triangles
    will have much smoother paths for the instances.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we implemented a simple path-finding navigation. After an overview
    of methods to allow computer-controlled instances to navigate in a game map, we
    explored and implemented the A* path-finding algorithm, supported by a custom
    navigation mesh creation. Then, we modified models to use them as navigation targets
    in the virtual world and enabled instances to use instances of the special models
    as path targets. As the last step, we added navigation to the instances, allowing
    them to walk or run toward a random target.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and last chapter of the book, we will take a step back from the
    implementation side and take a look at different ways to enhance immersion and
    visual quality. We will start with the audible side and discuss methods and tools
    to add sound effects and music to the application. Then, we will check out ideas
    to fill the world with more life, followed by a discussion about ideas to enhance
    the visuals in the virtual world. We will look at quests and interactions between
    instances and, finally, explore the impact of daytime and weather changes.
  prefs: []
  type: TYPE_NORMAL
- en: Practical sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some additions you could make to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Smooth the path even with large ground triangles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By looking up the next couple of path segments, it may be possible to create
    an average of the segments. For sharper turns, the transitions between the triangles
    could be smoothed by using splines.
  prefs: []
  type: TYPE_NORMAL
- en: Clean up the generated triangle neighbor list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right now, the list of adjacent triangles is quite large. This fact can be seen
    when the neighbor mesh debug drawing for a level is activated. Try to find a solution
    to include only triangles sharing parts of an edge.
  prefs: []
  type: TYPE_NORMAL
- en: Add a minimum distance between walls and path lines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the generated ground triangles, some of the center positions may be so close
    to a wall that the instance will collide when following the path. In some cases,
    the paths even go through edges of level geometry when the triangles are seen
    as adjacent. When creating the ground triangles, try to find the outlines of the
    mesh and reduce the size by a configurable amount.
  prefs: []
  type: TYPE_NORMAL
- en: Use the instance AABB to detect narrow passages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some maps may have passages where the navigation needs to be exact. In the absence
    of a real navigation mesh, you could try to use the bounding box of the instance
    along the path to find possible collisions and adjust the path to avoid a collision
    with the level structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advanced difficulty: Create a navigation mesh in an editor and load that mesh.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are confident working with a tool like Blender, you could try to create
    a navigation mesh as a separate mesh of a level, or even as a separate file, saved
    next to the level file. Then, load the navigation mesh into the `PathFinder` class
    to have a collision-free ground for the instances.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ghost navigation in Pac-Man: [https://gameinternals.com/understanding-pac-man-ghost-behavior](https://gameinternals.com/understanding-pac-man-ghost-behavior)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dijkstra’s algorithm: [https://graphicmaths.com/computer-science/graph-theory/dijkstras-algorithm/](https://graphicmaths.com/computer-science/graph-theory/dijkstras-algorithm/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Quake III Arena’s area awareness system: [http://www.kbs.twi.tudelft.nl/docs/MSc/2001/Waveren_Jean-Paul_van/thesis.pdf](http://www.kbs.twi.tudelft.nl/docs/MSc/2001/Waveren_Jean-Paul_van/thesis.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Navigation meshes: [https://www.gamedev.net/tutorials/programming/artificial-intelligence/navigation-meshes-and-pathfinding-r4880/](https://www.gamedev.net/tutorials/programming/artificial-intelligence/navigation-meshes-and-pathfinding-r4880/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Shakey the Robot: [https://www.sri.com/hoi/shakey-the-robot/](https://www.sri.com/hoi/shakey-the-robot/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Introduction to A*: [https://www.redblobgames.com/pathfinding/a-star/introduction.html](https://www.redblobgames.com/pathfinding/a-star/introduction.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using A* with navigation meshes: [https://medium.com/@mscansian/a-with-navigation-meshes-246fd9e72424](https://medium.com/@mscansian/a-with-navigation-meshes-246fd9e72424)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Navigation meshes in Unreal Engine: [https://dev.epicgames.com/documentation/en-us/unreal-engine/basic-navigation-in-unreal-engine](https://dev.epicgames.com/documentation/en-us/unreal-engine/basic-navigation-in-unreal-engine)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementing A* in an Unreal Engine project: [https://www.youtube.com/watch?v=xakl29fupCA](https://www.youtube.com/watch?v=xakl29fupCA)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Training an unbeatable AI in Trackmania: [https://www.youtube.com/watch?v=Dw3BZ6O_8LY](https://www.youtube.com/watch?v=Dw3BZ6O_8LY)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Recast Navigation: [https://github.com/recastnavigation/recastnavigation](https://github.com/recastnavigation/recastnavigation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optimization for Smooth Paths: [https://www.gameaipro.com/GameAIPro3/GameAIPro3_Chapter20_Optimization_for_Smooth_Paths.pdf](https://www.gameaipro.com/GameAIPro3/GameAIPro3_Chapter20_Optimization_for_Smooth_Paths.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Toward More Realistic Pathfinding: [https://www.gamedeveloper.com/programming/toward-more-realistic-pathfinding](https://www.gamedeveloper.com/programming/toward-more-realistic-pathfinding)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/cppgameanimation](https://packt.link/cppgameanimation)'
  prefs: []
  type: TYPE_NORMAL
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/QR_code_Discord.png)'
  prefs: []
  type: TYPE_IMG
