# 提高代码性能

在本章中，我们将学习如何加快任何 C 程序的执行速度。我们将学习如何在 CPU 寄存器中保存频繁使用的内容，以及如何更快地从用户那里获取输入。我们还将学习如何在 C 程序中应用循环展开。

以下是本章我们将要处理的菜谱：

+   在 C 代码中使用`register`关键字以获得更好的效率

+   在 C 中更快地获取输入

+   应用循环展开以获得更快的速度

让我们从第一个菜谱开始。

# 在 C 代码中使用`register`关键字以获得更好的效率

使用寄存器时的访问时间比从任何内存变量中访问内容低得多。因此，为了利用这一点，任何程序中频繁使用的内容都保存在寄存器中。使用`register`关键字来指示需要保存在这些寄存器中的内容。

在这个菜谱中，我们将找出指定距离租车所需的费用。租车费用不仅取决于距离，还取决于车型，即汽车是否有**空调**（**AC**）。

# 如何操作...

使用寄存器变量查找指定距离和指定车型汽车总租金的步骤如下：

1.  用户被要求输入计划旅程的距离。

1.  用户被要求指定汽车的类型，即汽车是否应该有空调。

1.  定义了两个寄存器变量，分别表示空调和非空调汽车的每公里租金。

1.  定义了一个额外的寄存器变量，用于表示服务税百分比。

1.  根据用户选择的车型，距离值乘以相应的寄存器变量以找出总金额。

1.  服务税被计算并加到总金额上。服务税百分比是从相应的寄存器变量中获取的。

1.  汽车总租金显示在屏幕上。

使用寄存器变量计算指定车型和行程长度的汽车总租金的程序如下：

```cpp
//tourvehicle.c

#include <stdio.h> 
#include <string.h> 

int main() { 
    int distance;
    char car_type[20]; 
    register int Acperkm,Nonacperkm,servicetax; 
    float carRent, totalrent; 

    printf("How many kilometers? "); 
    scanf("%d", &distance); 
    printf("AC car or non AC ac/non? "); 
    scanf("%s", car_type); 
    Acperkm=3; 
    Nonacperkm=2; 
    servicetax=1; 
    if(strcmp(car_type, "ac")==0) 
        carRent=distance*Acperkm; 
    else 
        carRent=distance*Nonacperkm; 
    totalrent=carRent + (carRent*servicetax/100); 
    printf("The total rent for the car will be $ %.2f\n",totalrent); 
    return 0; 
}
```

现在，让我们深入了解代码，以更好地理解它。

# 它是如何工作的...

用户被要求指定需要租用多少公里。用户输入的值被分配给`distance`变量。之后，用户被要求指定他们想要租用的车型：空调车或非空调车。用户输入的选项被分配给`car_type`变量。定义了三个寄存器变量，分别命名为`Acperkm`、`Nonacperkm`和`servicetax`。

因为寄存器变量更靠近 CPU，与从内存变量访问内容相比，它们的访问时间非常低，所以寄存器变量用于那些在计算中频繁需要的值。三个寄存器变量`Acperkm`、`Nonacperkm`和`servicetax`分别初始化为 3、2 和 1，以表示 AC 车的费用是每公里 3 美元，非 AC 车的费用是每公里 2 美元。服务税假定为总金额的 1%。

通过字符串比较来确定用户指定的车型。如果选定的车型是 AC 车，`distance`变量和`Acperkm`寄存器变量的值将被相乘。

同样，如果选定的车型是非 AC 车，`distance`和`Nonacperkm`变量的值将被相乘。乘法的结果将被分配给`carRent`变量。然后，在这个总额上加上 1%的服务税，以计算出总租金。然后，在屏幕上显示指定距离和车型下汽车的租金总额。

程序使用 GCC 编译，如下面的截图所示。因为没有在编译时出现错误，这意味着`tourvehicle.c`程序已成功编译成 EXE 文件，即`tourvehicle.exe`。在执行文件时，用户将被提示输入租车所需的公里数。用户还将被要求指定所需的车型。然后程序显示汽车的租金总额，如截图所示：

![图片](img/9fb9c91b-a0a1-4c7a-83b8-95b09bb6454a.png)

图 15.1

哇！我们已经成功使用寄存器变量来加速 C 语言中的处理。现在让我们继续下一个菜谱！

# 在 C 语言中更快地获取输入

在这个菜谱中，我们将学习如何从用户那里更快地获取输入。我们将要求用户输入一个数字，输入的数字将在屏幕上显示。为此，我们将使用`getchar_unlocked()`函数。

`getchar_unlocked()`函数与`getchar()`函数的工作方式类似，不同之处在于它不是线程安全的。因此，它忽略了某些输入约束，所以比`getchar()`快得多。它用于在仅使用单个线程处理输入和其他流的情况下获取长输入数据。

# 如何做到这一点...

使用快速输入方法从用户那里获取数字的步骤如下：

1.  用户被要求输入一个数字。

1.  用户将要输入的数字将通过`getchar_unlocked()`函数接受。该函数一次只接受一个数字。

1.  用户输入的值首先会被检查以确保它仅是一个数字。如果不是，用户将被要求重新输入值。

1.  如果用户输入的值是一个数字，它的 ASCII 值被保存在变量中。这是因为`getchar_unlocked()`将输入值的 ASCII 值赋给变量。

1.  从输入值的 ASCII 码中减去 48，将其转换为用户实际输入的数字。

1.  如果输入的数字是用户输入的第一个数字，那么它将被简单地赋给另一个变量。但如果它不是第一个数字，那么变量中现有的数字乘以 10，然后将新数字加到变量上。

1.  *步骤 2*至*7*会重复进行，直到用户按下*Enter*键，对用户输入的每一位数字进行操作。

1.  变量中的数字是用户实际输入的数字，因此显示在屏幕上。

使用快速输入技术输入数字的程序如下：

```cpp
//fastinp.c

#include <stdio.h> 

int getdata() { 
    char cdigit = getchar_unlocked(); 
    int cnumb = 0; 
    while(cdigit<'0' || cdigit>'9') cdigit = getchar_unlocked(); 
    while(cdigit >='0' && cdigit <='9') { 
        cnumb = 10 * cnumb + cdigit - 48; 
        cdigit = getchar_unlocked(); 
    } 
    return cnumb; 
} 

int main() 
{ 
    int numb; 
    printf("Enter a number "); 
    numb=getdata(); 
    printf("The number entered is %d\n",numb); 
    return 0; 
}
```

现在，让我们深入了解代码，以更好地理解它。

# 它是如何工作的...

用户被要求输入一个数字。调用用户定义的`getdata()`函数，并将函数返回的值赋给`numb`变量，然后该变量被显示在屏幕上。`getdata`函数会不断请求输入数字的每一位，并在按下*Enter*键时返回该数字。

假设用户想要输入`20`。在`getdata`函数中，调用`getchar_unlocked()`函数。因此，在输入第一个数字 2（数字 20 的一部分）时，它将被赋给`cdigit`变量，该变量是字符数据类型。2 的 ASCII 值是 50，所以实际上将 50 赋给`cdigit`变量。

在继续之前，我们确保用户输入的值是一个数字，而不是字符或其他符号。如果用户输入的不是数字，则再次调用`getchar_unlocked()`函数，要求用户输入有效的数字。如果输入的值是数字，则从其 ASCII 值中减去 48 以将其转换为实际值。这是因为 2 的 ASCII 值是 50；从 50 中减去 48，结果是 2，这是用户实际输入的数字。2 的值被赋给`cnumb`变量。

由于数字 20 的下一位是 0，因此调用`getchar_unlocked()`函数，并将值 0 赋给`cdigit`变量。再次检查用户输入的值是否为数字，而不是其他。0 的 ASCII 值是 48。从 0 的 ASCII 值中减去 48，使其值变为 0。`cnumb`变量中的当前值是 2，然后将其乘以 10，并将`cdigit`的值加到结果中。这次计算的结果将是 20，并将其赋给`cnumb`变量。`cnumb`变量中的值返回到主函数以显示。

简而言之，无论用户输入的是哪个数字，其 ASCII 值都会被分配给变量，并从该数字的 ASCII 值中减去数值 48，以将其转换为用户实际输入的数字。

程序使用 GCC 编译，如下面的截图所示。因为没有错误出现在编译过程中，这意味着`fastinp.c`程序已经成功编译成 EXE 文件，`fastinp.exe`。在执行文件时，用户被提示输入一个数字。该数字使用快速输入技术接受。在输入所有数字后，当用户按下*Enter*键时，输入的数字将显示在屏幕上，如下面的截图所示：

![](img/6fde6641-6ea1-4041-8752-3f6cd84bb150.png)

图 15.2

Voilà！我们已经成功配置了 C 语言中数字的快速输入。现在让我们继续下一个菜谱！

# 应用循环展开以获得更快的速度

在这个菜谱中，我们将学习如何使用循环展开技术打印用户输入限制的从 1 到限制的数字序列之和。循环展开意味着减少或从程序中移除循环以减少运行循环时的开销。基本上，为了运行一个循环，操作系统必须管理两个开销——第一个开销是维护循环计数，第二个开销是进行条件分支。循环展开有助于避免这两个开销。让我们看看它是如何做到的。

# 如何做到这一点...

使用循环展开技术求前*n*个数字序列之和的步骤如下：

1.  将用于存储序列数加和的`sum`变量初始化为 0。

1.  用户被要求输入一个限制，即希望求和的数字序列的上限。用户输入的值被分配给`limit`变量。

1.  我们需要找到一个在 9 到 1 之间的数字，它能完美地整除`limit`变量中的值。为了找到这个数字，我们设置一个从 9 到 1 的`for`循环。

1.  在`for`循环中，`limit`变量中的值被除以`for`循环变量。

1.  如果`limit`变量中的数字可以被`for`循环变量整除，则`for`循环将中断。

1.  如果`limit`变量中的数字不能被`for`循环变量整除，则循环将使用减少的值执行下一次迭代，即使用值 8。重复这些步骤，直到`limit`变量中的值能被`for`循环变量完美整除。

1.  一旦我们得到了可以整除 limit 的整数，我们就将`for`循环的数量减少那个整数，即，将`for`循环的增量设置为那个整数值。

1.  在`for`循环中，使用了一个`while`循环，该循环将数字序列添加到`sum`变量中。

1.  最后，将`sum`变量中数字序列的加和显示在屏幕上。

使用循环展开技术打印数字序列和的程序如下：

```cpp
//loopunrolling.c

#include <stdio.h> 

int main() { 
    int sum,i,limit,rem,quot,incr,x, count; 
    sum = 0; 
    printf("Enter limit "); 
    scanf("%d", &limit); 
    for(i=9;i>=1;i--) 
    { 
        rem=limit % i; 
        if (rem==0) break; 
    } 
    incr=i; 
    count=0; 
    for(i=1;i<=limit; i+=incr) 
    { 
        x=0; 
        while(x<incr) 
        { 
            sum += i+x; 
            x++; 
        } 
        count++; 
    }
    printf("The sum of first %d sequence numbers is %d\n",limit, sum);
    printf("The loop executed for %d number of times\n",count);
    return 0; 
}
```

现在，让我们深入了解代码，以更好地理解它。

# 它是如何工作的...

这个程序找出用户输入的上限值以内的序列数字之和。程序会要求用户输入上限值，用户输入的值被分配给 `limit` 变量。为了加和序列数字，我们将使用一个 `for` 循环。为了进行循环展开或减少循环的迭代次数，我们找到可以整除上限的整数。也就是说，我们将 `limit` 变量中的值除以从 9 到 1 的整数。一旦我们得到可以整除上限的整数，我们就减少 `for` 循环的次数。

假设用户输入了一个上限值 40，并将其分配给 `limit` 变量。设置一个 `for` 循环从 9 到 1 运行，并且从 9 到 1 的每个值都将用来尝试除以 `limit` 变量中的值。在任何除法中，如果余数为 0，则 `for` 循环将中断；否则，将执行下一个迭代，并使用减少的值。目前，`limit` 变量中的值是 40，第一次迭代的 `i` 值是 9。40 除以 9 的余数是一个非零值，所以 `for` 循环的下一个迭代将从下一个减少的值开始，即 8。

因为，当 40 除以 8 时，你得到一个余数为 0，`for` 循环将中断，控制将跳转到 `for` 循环后的下一个语句。那时的 `i` 值是 8，所以 8 的值被分配给 `incr` 变量。也就是说，`for` 循环将以 8 的增量增加。这也意味着我们通过减少 `for` 循环的迭代次数 8 倍来应用循环展开。换句话说，`for` 循环将被设置为从 1 运行到上限 40，每次迭代后增加 8。

在第一次迭代中，`i` 的值为 1。用于计算数字序列加和的 `sum` 变量被初始化为 0。`i` 的值被加到 `sum` 变量上。正如之前所说的，`for` 循环的下一个迭代将 `i` 的值增加 8。所以，在 `for` 循环内部，使用了一个 `while` 循环。在 `while` 循环内部，使用了一个变量 `x`，它从 0 执行到 `incr` 变量的值（即，直到 8 的值）。换句话说，`while` 循环将把从 1 到 8 的数字序列加到 `sum` 变量中。

一旦计算并分配了数字序列前八个值的总和到`sum`变量，`for`循环的下一个迭代将从`i`的值增加至 9 开始。再次在`for`循环内，`while`循环将执行以计算从 9 到 16 的数字序列的总和。同样，`for`循环的下一个迭代将`i`的值增加到 17。这个过程会一直持续到`for`循环完成。简而言之，`for`循环被展开到`incr`变量所赋的值。最后，数字序列的总和在屏幕上显示。

程序使用 GCC 编译，如下面的截图所示。因为没有错误出现在编译过程中，这意味着`loopunrolling.c`程序已经成功编译成 EXE 文件，名为`loopunrolling.exe`。在执行文件时，用户将被提示输入想要计算数字序列总和的上限。程序不仅会打印数字序列的总和，还会打印出计算总和所需的循环迭代次数，如下面的截图所示：

![截图](img/e620d676-79ab-408a-8c1e-b2142318be78.png)

图 15.3

Voilà! 我们已经成功执行了循环展开以生成更快的结果。
