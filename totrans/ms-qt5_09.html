<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9.  Keeping Your Sanity with Multithreading </h1></div></div></div><p>In previous chapters, we managed to always write code without ever relying on threads. It is time to face the beast and truly understand how threading works in Qt. In this chapter, you will develop a multithreaded application that displays a Mandelbrot fractal. It is a heavy computational process that will bring tears to your CPU cores.</p><p>In the example project, the user can see the Mandelbrot fractal, zoom in the picture, and pan around to discover the magic of fractals.</p><p>The chapter covers the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Deep understanding of the <code class="literal">QThread</code> framework</li><li class="listitem">Overview of all the available threading technologies in Qt</li><li class="listitem">Using a <code class="literal">QThreadPool</code> class to dispatch jobs and aggregate the results</li><li class="listitem">How to synchronize threads and minimize sharing states</li><li class="listitem">Low-level drawing to optimize the performances</li><li class="listitem">Common threading pitfalls and challenges</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec83"/>Discovering QThread</h1></div></div></div><p>Qt provides a sophisticated threading system. We assume you already know threading basics and the associated issues (deadlocks, threads synchronization, resource sharing, and so on) and we will focus on how Qt implements it.</p><p>The <code class="literal">QThread</code> is the central class of the Qt threading system. A <code class="literal">QThread</code> instance manages one thread of execution within the program.</p><p>You can subclass <code class="literal">QThread</code> to override the <code class="literal">run()</code> function, which will be executed in the <code class="literal">QThread</code> framework. Here is how you can create and start a <code class="literal">QThread</code>:</p><pre class="programlisting">QThread thread; 
thread.start(); 
</pre><p>The <code class="literal">start()</code> function calling will automatically call the <code class="literal">run()</code> function of the thread and emit the <code class="literal">started()</code> signal. Only at this point will the new thread of execution be created. When <code class="literal">run()</code> is completed, the <code class="literal">thread</code> object will emit the <code class="literal">finished()</code> signal.</p><p>This brings us to a fundamental aspect of <code class="literal">QThread</code>: it works seamlessly with the signal/slot mechanism. Qt is an event-driven framework, where a main event loop (or the GUI loop) processes events (user input, graphical, and so on) to refresh the UI.</p><p>Each <code class="literal">QThread</code> comes with its own event loop that can process events outside the main loop. If not overridden, <code class="literal">run()</code> calls the <code class="literal">QThread::exec()</code> function, which starts the <code class="literal">thread</code> object's event loop. You can also override <code class="literal">QThread</code> and call yourself <code class="literal">exec()</code>, like so:</p><pre class="programlisting">class Thread : public QThread 
{ 
Q_OBJECT 
protected: 
    void run()  
    { 
      Object* myObject = new Object(); 
        connect(myObject, &amp;Object::started,  
                this, &amp;Thread::doWork); 
        exec(); 
    } 
 
private slots: 
    void doWork(); 
}; 
</pre><p>The <code class="literal">started()</code>signal will be processed by the <code class="literal">Thread</code> event loop only upon the <code class="literal">exec()</code> call. It will block and wait until <code class="literal">QThread::exit()</code> is called.</p><p>A crucial thing to note is that a thread event loop delivers events for all <code class="literal">QObjects</code> that are living in that thread. This includes all objects created in that thread or moved to that thread. This is referred to as the thread affinity of an object. Let's see an example:</p><pre class="programlisting">class Thread : public QThread 
{ 
    Thread() : 
        mObject(new QObject()) 
    { 
    } 
private : 
    QObject* myObject; 
}; 
 
// Somewhere in MainWindow 
Thread thread; 
thread.start(); 
</pre><p>In this snippet, <code class="literal">myObject</code> is constructed in <code class="literal">Thread</code> class's constructor, which is created in turn in <code class="literal">MainWindow</code>. At this point, <code class="literal">thread</code> is living in the GUI thread. Hence, <code class="literal">myObject</code> is also living in the GUI thread.</p><div><h3 class="title"><a id="note42"/>Note</h3><p>An object created before a <code class="literal">QCoreApplication</code> object has no thread affinity. As a consequence, no event will be dispatched to it.</p></div><p>It is great to be able to handle signals and slots in our own <code class="literal">QThread</code>, but how can we control signals across multiple threads? A classic example is a long-running process that is executed in a separate thread that has to notify the UI to update some state:</p><pre class="programlisting">class Thread : public QThread 
{ 
    Q_OBJECT 
    void run() { 
        // long running operation 
        emit result("I &lt;3 threads"); 
    } 
signals: 
    void result(QString data); 
}; 
 
// Somewhere in MainWindow 
Thread* thread = new Thread(this); 
connect(thread, &amp;Thread::result, this, &amp;MainWindow::handleResult); 
connect(thread, &amp;Thread::finished, thread, &amp;QObject::deleteLater); 
thread-&gt;start(); 
</pre><p>Intuitively, we assume that the first <code class="literal">connect</code> sends the signal across multiple threads (to have results available in <code class="literal">MainWindow::handleResult</code>), whereas the second <code class="literal">connect</code> should work on thread's event loop only.</p><p>Fortunately, this is the case due to a default argument in the <code class="literal">connect()</code> function signature: the connection type. Let's see the complete signature:</p><pre class="programlisting">QObject::connect( 
    const QObject *sender, const char *signal,  
    const QObject *receiver, const char *method,  
    Qt::ConnectionType type = Qt::AutoConnection) 
</pre><p>The <code class="literal">type</code> keyword takes <code class="literal">Qt::AutoConnection</code> as a default value. Let's review the possible values of the <code class="literal">Qt::ConectionType enum</code> as the official Qt documentation states:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">Qt::AutoConnection</code>: If the receiver lives in the thread that emits the signal, <code class="literal">Qt::DirectConnection</code> is used. Otherwise, <code class="literal">Qt::QueuedConnection</code> is used. The connection type is determined when the signal is emitted.</li><li class="listitem"><code class="literal">Qt::DirectConnection</code>: This slot is invoked immediately when the signal is emitted. The slot is executed in the signaling thread.</li><li class="listitem"><code class="literal">Qt::QueuedConnection</code>: This slot is invoked when control returns to the event loop of the receiver's thread. The slot is executed in the receiver's thread.</li><li class="listitem"><code class="literal">Qt::BlockingQueuedConnection</code>: This is the same as <code class="literal">Qt::QueuedConnection</code>, except that the signaling thread blocks until the slot returns. This connection must not be used if the receiver lives in the signaling thread, or else the application will deadlock.</li><li class="listitem"><code class="literal">Qt::UniqueConnection</code>: This is a flag that can be combined with any one of the previous connection types, using a bitwise OR. When <code class="literal">Qt::UniqueConnection</code> is set, <code class="literal">QObject::connect()</code> will fail if the connection already exists (that is, if the same signal is already connected to the same slot for the same pair of objects).</li></ul></div><p>When using <code class="literal">Qt::AutoConnection</code>, the final <code class="literal">ConnectionType</code> is resolved only when the signal is effectively emitted. If you look again at our example, at the first <code class="literal">connect()</code>:</p><pre class="programlisting">connect(thread, &amp;Thread::result,  
        this, &amp;MainWindow::handleResult); 
</pre><p>When <code class="literal">result()</code> is emitted, Qt will look at the <code class="literal">handleResult()</code> thread affinity, which is different from the thread affinity of the <code class="literal">result()</code> signal. The <code class="literal">thread</code> object is living in <code class="literal">MainWindow</code> (remember that it has been created in <code class="literal">MainWindow</code>), but the <code class="literal">result()</code> signal has been emitted in the <code class="literal">run()</code> function, which is running in a different thread of execution. As a result, a <code class="literal">Qt::QueuedConnection</code> slot will be used.</p><p>We can now take a look at the second <code class="literal">connect()</code>:</p><pre class="programlisting">connect(thread, &amp;Thread::finished, thread, &amp;QObject::deleteLater); 
</pre><p>Here, <code class="literal">deleteLater()</code> and <code class="literal">finished()</code> live in the same thread; therefore, a <code class="literal">Qt::DirectConnection</code> slot will be used.</p><p>It is crucial that you understand that Qt does not care about the emitting object thread affinity, it looks only at the signal "context of execution".</p><p>Loaded with this knowledge, we can take another look at our first <code class="literal">QThread</code> class example to have a full understanding of this system:</p><pre class="programlisting">class Thread : public QThread 
{ 
Q_OBJECT 
protected: 
    void run()  
    { 
        Object* myObject = new Object(); 
        connect(myObject, &amp;Object::started,  
                this, &amp;Thread::doWork); 
        exec(); 
    } 
 
private slots: 
    void doWork(); 
}; 
</pre><p>When the <code class="literal">Object::started()</code> function is emitted, a <code class="literal">Qt::QueuedConnection</code> slot will be used. This is where your brain freezes. The <code class="literal">Thread::doWork()</code> function lives in another thread than <code class="literal">Object::started()</code>, which has been created in <code class="literal">run()</code>. If Thread has been instantiated in the UI thread, this is where <code class="literal">doWork()</code> would have belonged.</p><p>This system is powerful, but complex. To make things simpler, Qt favors the worker model. It splits the threading plumbing from the real processing. Here is an example:</p><pre class="programlisting">class Worker : public QObject 
{ 
    Q_OBJECT 
public slots: 
    void doWork()  
    { 
        emit result("workers are the best"); 
    } 
 
signals: 
    void result(QString data); 
}; 
 
// Somewhere in MainWindow 
QThread* thread = new Thread(this); 
Worker* worker = new Worker(); 
worker-&gt;moveToThread(thread); 
 
connect(thread, &amp;QThread::finished,  
        worker, &amp;QObject::deleteLater); 
connect(this, &amp;MainWindow::startWork,  
        worker, &amp;Worker::doWork); 
connect(worker, &amp;Worker::resultReady,  
        this, handleResult); 
 
thread-&gt;start(); 
 
// later on, to stop the thread 
thread-&gt;quit(); 
thread-&gt;wait(); 
</pre><p>We start by creating a <code class="literal">Worker</code> class that has:</p><div><ul class="itemizedlist"><li class="listitem">A <code class="literal">doWork()</code> slot that will have the content of our old <code class="literal">QThread::run()</code></li><li class="listitem">A <code class="literal">result()</code> signal that will emit the resulting data</li></ul></div><p>Next in the <code class="literal">MainWindow</code> class, we create a simple <code class="literal">thread</code> object and an instance of <code class="literal">Worker</code>. The <code class="literal">worker-&gt;moveToThread(thread)</code> is where the magic happens. It changes the affinity of the <code class="literal">worker</code> object. The <code class="literal">worker</code> now lives in the <code class="literal">thread</code> object.</p><p>You can only push an object from your current thread to another thread. Conversely, you cannot pull an object that lives in another thread. You cannot change the thread affinity of an object if the object does not live in your thread. Once <code class="literal">thread-&gt;start()</code> is executed, we cannot call <code class="literal">worker-&gt;moveToThread(this)</code> unless we are doing it from this new thread.</p><p>After that, we do three <code class="literal">connect()</code>:</p><div><ol class="orderedlist arabic"><li class="listitem">We handle the <code class="literal">worker</code> life cycle by reaping it when the thread is finished. This signal will use a <code class="literal">Qt::DirectConnection</code>.</li><li class="listitem">We start the <code class="literal">Worker::doWork()</code> upon a possible UI event. This signal will use a <code class="literal">Qt::QueuedConnection</code>.</li><li class="listitem">We process the resulting data in the UI thread with <code class="literal">handleResult()</code>. This signal will use a <code class="literal">Qt::QueuedConnection</code>.</li></ol><div></div><p>To sum up, <code class="literal">QThread</code> can be either subclassed or used in conjunction with a <code class="literal">worker</code> class. Generally, the worker approach is favored because it separates more cleanly the threading affinity plumbing from the actual operation you want to execute in parallel.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec84"/>Flying over Qt multithreading technologies</h1></div></div></div><p>Built upon <code class="literal">QThread</code>, several threading technologies are available in Qt. First, to synchronize threads, the usual approach is to use a mutual exclusion (mutex) to have a mutual exclusion for a given resource. Qt provides it by means of the <code class="literal">QMutex</code> class. Its usage is straightforward:</p><pre class="programlisting">QMutex mutex; 
int number = 1; 
 
mutex.lock(); 
number *= 2; 
mutex.unlock(); 
</pre><p>From the <code class="literal">mutex.lock()</code> instruction, any other thread trying to lock the <code class="literal">mutex</code> will wait until <code class="literal">mutex.unlock()</code> has been called.</p><p>The locking/unlocking mechanism is error-prone in complex code. You can easily forget to unlock a mutex in a specific exit condition, causing a deadlock. To simplify this situation, Qt provides a <code class="literal">QMutexLocker</code> that should be used where the <code class="literal">QMutex</code> needs to be locked:</p><pre class="programlisting">QMutex mutex; 
QMutexLocker locker(&amp;mutex); 
 
int number = 1; 
number *= 2; 
if (overlyComplicatedCondition) { 
    return; 
} else if (notSoSimple) { 
    return; 
} 
</pre><p>The <code class="literal">mutex</code> is locked when the <code class="literal">locker</code> object is created and will be unlocked when the <code class="literal">locker</code> object is destroyed; for example, when it goes out of scope. This is the case for every condition we stated where the <code class="literal">return</code> statement appears. It makes the code simpler and more readable.</p><p>You may need to create and destroy threads frequently, as managing <code class="literal">QThread</code> instances by hand can become cumbersome. For this, you can use the <code class="literal">QThreadPool</code> class, which manages a pool of reusable <code class="literal">QThreads</code>.</p><p>To execute code within threads managed by a <code class="literal">QThreadPool</code> class, you will use a pattern very close to the worker we covered earlier. The main difference is that the processing class has to extend the <code class="literal">QRunnable</code> class. Here is how it looks:</p><pre class="programlisting">class Job : public QRunnable 
{ 
    void run() 
    { 
        // long running operation 
    } 
} 
 
Job* job = new Job(); 
QThreadPool::globalInstance()-&gt;start(job); 
</pre><p>Just override the <code class="literal">run()</code> function and ask <code class="literal">QThreadPool</code> to execute your job in a separate thread. The <code class="literal">QThreadPool::globalInstance()</code> is a static helper function that gives you access to an application global instance. You can create your own <code class="literal">QThreadPool</code> if you need to have finer control over the <code class="literal">QThreadPool</code> life cycle.</p><p>Note that the <code class="literal">QThreadPool::start()</code> function takes the ownership of <code class="literal">job</code> and will automatically delete it when <code class="literal">run()</code> finishes. Watch out, this does not change the thread affinity like <code class="literal">QObject::moveToThread()</code> does with workers! A <code class="literal">QRunnable</code> class cannot be reused, it has to be a freshly baked instance.</p><p>If you fire up several jobs, <code class="literal">QThreadPool</code> automatically allocates the ideal number of threads based on the core count of your CPU. The maximum number of threads that the <code class="literal">QThreadPool</code> class can start can be retrieved with <code class="literal">QThreadPool::maxThreadCount()</code>.</p><div><h3 class="title"><a id="tip43"/>Tip</h3><p>If you need to manage threads by hand, but you want to base it on the number of cores of your CPU, you can use the handy static function, <code class="literal">QThreadPool::idealThreadCount()</code>.</p></div><p>Another approach to multi-threaded development is available with the Qt Concurrent framework. It is a higher-level API that avoids the use of mutexes/lock/wait conditions and promotes the distribution of the processing among CPU cores.</p><p>Qt Concurrent relies on the <code class="literal">QFuture</code> class to execute a function and expects a result later on:</p><pre class="programlisting">void longRunningFunction(); 
QFuture&lt;void&gt; future = QtConcurrent::run(longRunningFunction); 
</pre><p>The <code class="literal">longRunningFunction()</code> function will be executed in a separated thread obtained from the default <code class="literal">QThreadPool</code> class.</p><p>To pass parameters to a <code class="literal">QFuture</code> class and retrieve the result of the operation, use the following code:</p><pre class="programlisting">QImage processGrayscale(QImage&amp; image); 
QImage lenna; 
 
QFuture&lt;QImage&gt; future = QtConcurrent::run(processGrayscale, 
    lenna); 
 
QImage grayscaleLenna = future.result(); 
</pre><p>Here we pass <code class="literal">lenna</code> as a parameter to the <code class="literal">processGrayscale()</code> function. Because we want a <code class="literal">QImage</code> as a result, we declare the <code class="literal">QFuture</code> class with the template type, <code class="literal">QImage</code>. After that, <code class="literal">future.result()</code> blocks the current thread and waits for the operation to be completed to return the final <code class="literal">QImage</code>.</p><p>To avoid blocking, <code class="literal">QFutureWatcher</code> comes to the rescue:</p><pre class="programlisting">QFutureWatcher&lt;QImage&gt; watcher; 
connect(&amp;watcher, &amp;QFutureWatcher::finished,  
        this, &amp;QObject::handleGrayscale); 
 
QImage processGrayscale(QImage&amp; image); 
QImage lenna; 
QFuture&lt;QImage&gt; future = QtConcurrent::run(processImage, lenna); 
watcher.setFuture(future); 
</pre><p>We start by declaring a <code class="literal">QFutureWatcher</code> class with the template argument matching the one used for <code class="literal">QFuture</code>. Then simply connect the <code class="literal">QFutureWatcher::finished</code> signal to the slot you want to be called when the operation has been completed.</p><p>The last step is to tell the <code class="literal">watcher</code> object to watch the future object with <code class="literal">watcher.setFuture(future)</code>. This statement looks almost like it comes from a science-fiction movie.</p><p>Qt Concurrent also provides a <code class="literal">MapReduce</code> and <code class="literal">FilterReduce</code> implementation. The <code class="literal">MapReduce</code> is a programming model that basically does two things:</p><div><ul class="itemizedlist"><li class="listitem">Maps or distributes the processing of the dataset among multiple cores of the CPU</li><li class="listitem">Reduces or aggregates the results to provide it to the caller</li></ul></div><p>This technique was first promoted by Google to be able to process huge datasets within a cluster of CPUs.</p><p>Here is an example of a simple map operation:</p><pre class="programlisting">QList images = ...; 
 
QImage processGrayscale(QImage&amp; image); 
QFuture&lt;void&gt; future = QtConcurrent::mapped( 
                                     images, processGrayscale); 
</pre><p>Instead of <code class="literal">QtConcurrent::run()</code>, we use the mapped function that takes a list and the function to apply to each element in a different thread each time. The <code class="literal">images</code> list is modified in place, so there is no need to declare <code class="literal">QFuture</code> with a template type.</p><p>The operation can be made to block by using <code class="literal">QtConcurrent::blockingMapped()</code> instead of <code class="literal">QtConcurrent::mapped()</code>.</p><p>Finally, a <code class="literal">MapReduce</code> operation looks like this:</p><pre class="programlisting">QList images = ...; 
 
QImage processGrayscale(QImage&amp; image); 
void combineImage(QImage&amp; finalImage, const QImage&amp; inputImage); 
 
QFuture&lt;void&gt; future = QtConcurrent::mappedReduced( 
                                            images,  
                                            processGrayscale,  
                                            combineImage); 
</pre><p>Here we added a <code class="literal">combineImage()</code> function that will be called for each result returned by the map function, <code class="literal">processGrayscale()</code>. It will merge the intermediate data, <code class="literal">inputImage</code>, into the <code class="literal">finalImage</code>. This function is called only once at a time per thread, so there is no need to use a mutex to lock the result variable.</p><p>The <code class="literal">FilterReduce</code> follows exactly the same pattern; the filter function simply allows you to filter the input list instead of transforming it.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec85"/>Architecting the Mandelbrot project</h1></div></div></div><p>The example project of this chapter is the multi-threaded calculation of a Mandelbrot fractal. The user will see the fractal and will be able to pan and zoom in that window.</p><p>Before diving into the code, we have to have a broad understanding of a fractal and how we are going to achieve its calculation.</p><p>The Mandelbrot fractal is a numerical set that works with complex numbers (a + bi). Each pixel is associated with a value calculated through iterations. If this iterated value diverges towards infinity then the pixel is out of the Mandelbrot set. If not, then the pixel is inside the Mandelbrot set. A visual representation of the Mandelbrot fractal looks like this:</p><div><img src="img/image00428.jpeg" alt="Architecting the Mandelbrot project"/></div><p style="clear:both; height: 1em;"> </p><p>Every black pixel in this image tends to diverge to an infinite value, whereas white pixels are bounded to a finite value. The white pixels belong to the Mandelbrot set.</p><p>What makes it interesting from a multi-threaded perspective, is that to determine if the pixel belongs or not to the Mandelbrot set, we have to iterate on a formula to be able to hypothesize its divergence or not. The more iterations we perform, the safer we are in claiming "yes, this pixel is in the Mandelbrot set, it is a white pixel".</p><p>Even more fun, we can take any value in the graphical plot and always apply the Mandelbrot formula to deduce if the pixel should be black or white. As a consequence, you can zoom endlessly inside the graphics of your fractal. There are only two main limitations:</p><div><ul class="itemizedlist"><li class="listitem">The power of your CPU hinders the picture generation speed.</li><li class="listitem">The floating number precision of your CPU architecture limits the zoom. If you keep zooming, you will get visual artifacts because the scale factor can only handle 15 to 17 significant digits.</li></ul></div><p>The architecture of the application has to be carefully designed. Because we are working with threads, it is very easy to cause deadlock, starve threads, or even worse, freeze the UI.</p><p>We really want to maximize the use of the CPU. To do so, we will execute as many threads as possible on each core. Each thread will be responsible for calculating a part of the Mandelbrot set before giving back its result.</p><p>The architecture of the application is as follows:</p><div><img src="img/image00429.jpeg" alt="Architecting the Mandelbrot project"/></div><p style="clear:both; height: 1em;"> </p><p>The application is divided into three parts:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">MandelbrotWidget</code>: This requests a picture to display. It handles the drawing and the user interaction. This object lives in the UI thread.</li><li class="listitem"><code class="literal">MandelbrotCalculator</code>: This handles the picture requests and aggregates the resulting <code class="literal">JobResults</code> before sending it back to <code class="literal">MandelbrotWidget</code>. This object lives in its own thread.</li><li class="listitem"><code class="literal">Job</code>: This calculates a part of the final picture before transmitting the result back to <code class="literal">MandelbrotCalculator</code>. Each job lives in its own thread.</li></ul></div><p>The <code class="literal">MandelbrotCalculator</code> thread will use a <code class="literal">QThreadPool</code> class to dispatch jobs in their own thread. This will scale perfectly according to your CPU cores. Each job will calculate a single line of the final picture before sending it back to <code class="literal">MandelbrotCalculator</code> through a <code class="literal">JobResult</code> object.</p><p>The <code class="literal">MandelbrotCalculator</code> thread is really the orchestrator of the calculation. Consider a user that zooms in the picture before the calculation is complete; <code class="literal">MandelbrotWidget</code> will request a new picture to <code class="literal">MandelbrotCalculator</code>, which in turn has to cancel all the current jobs before dispatching new jobs.</p><p>We will add a last constraint to this project: it has to be mutex free. Mutexes are very convenient tools, but they force threads to wait for each other and are error-prone. To do this, we will rely on multiple concepts and technologies provided by Qt: multi-threaded signal/slots, implicit sharing, and so on.</p><p>By minimizing the sharing state between our threads, we will be able to let them execute as fast as they possibly can. That is why we are here, to burn some CPU cores, right?</p><p>Now that the broad picture is clearer, we can start the implementation. Create a new <strong>Qt Widget Application</strong> project named <code class="literal">ch09-mandelbrot-threadpool</code>. Remember to add the <code class="literal">CONFIG += c++14</code> to the <code class="literal">.pro</code> file.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec86"/>Defining a Job class with QRunnable</h1></div></div></div><p>Let's dive into the project's core. To speed up the Mandelbrot picture generation, we will split the whole computation into multiple jobs. A <code class="literal">Job</code> is a request of a task. Depending on your CPU architecture, several jobs will be executed simultaneously. A <code class="literal">Job</code> class produces a <code class="literal">JobResult</code> function containing result values. In our project, a <code class="literal">Job</code> class generates values for one line of the complete picture. For example, an image resolution of 800 x 600 requires 600 jobs, each one generating 800 values.</p><p>Please create a C++ header file called <code class="literal">JobResult.h</code>:</p><pre class="programlisting">#include &lt;QSize&gt; 
#include &lt;QVector&gt; 
#include &lt;QPointF&gt; 
 
struct JobResult 
{ 
    JobResult(int valueCount = 1) : 
        areaSize(0, 0), 
        pixelPositionY(0), 
        moveOffset(0, 0), 
        scaleFactor(0.0), 
        values(valueCount) 
    { 
    } 
 
    QSize areaSize; 
    int pixelPositionY; 
    QPointF moveOffset; 
    double scaleFactor; 
 
    QVector&lt;int&gt; values; 
}; 
</pre><p>This structure contains two parts:</p><div><ul class="itemizedlist"><li class="listitem">Input data (<code class="literal">areaSize</code>, <code class="literal">pixelPositionY</code>, ...)</li><li class="listitem">Result <code class="literal">values</code> generated by a <code class="literal">Job</code> class</li></ul></div><p>We can now create the <code class="literal">Job</code> class itself. Create a C++ class <code class="literal">Job</code> using the next snippet of <code class="literal">Job.h</code> for the content:</p><pre class="programlisting">#include &lt;QObject&gt; 
#include &lt;QRunnable&gt; 
 
#include "JobResult.h" 
     
class Job : public QObject, public QRunnable 
{ 
    Q_OBJECT 
public: 
    Job(QObject *parent = 0); 
    void run() override; 
}; 
</pre><p>This <code class="literal">Job </code>class is a <code class="literal">QRunnable</code>, so we can override <code class="literal">run()</code> to implement the Mandelbrot picture algorithm. As you can see, <code class="literal">Job</code> also inherits from <code class="literal">QObject</code>, allowing us to use the signal/slot feature of Qt. The algorithm requires some input data. Update your <code class="literal">Job.h</code> like this:</p><pre class="programlisting">#include &lt;QObject&gt; 
#include &lt;QRunnable&gt; 
#include &lt;QPointF&gt; 
#include &lt;QSize&gt; 
#include &lt;QAtomicInteger&gt; 
     
class Job : public QObject, public QRunnable 
{ 
    Q_OBJECT 
public: 
    Job(QObject *parent = 0); 
    void run() override; 
 
    void setPixelPositionY(int value); 
    void setMoveOffset(const QPointF&amp; value); 
    void setScaleFactor(double value); 
    void setAreaSize(const QSize&amp; value); 
    void setIterationMax(int value); 
 
private: 
    int mPixelPositionY; 
    QPointF mMoveOffset; 
    double mScaleFactor; 
    QSize mAreaSize; 
    int mIterationMax; 
}; 
</pre><p>Let's talk about these variables:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">mPixelPositionY</code> variable is the picture height index. Because each <code class="literal">Job</code> generates data only for one picture line, we need this information.</li><li class="listitem">The <code class="literal">mMoveOffset</code> variable is the Mandelbrot origin offset. The user can pan the picture, so the origin will not always be (0, 0).</li><li class="listitem">The <code class="literal">mScaleFactor</code> variable is the Mandelbrot scale value. The user can also zoom into the picture.</li><li class="listitem">The <code class="literal">mAreaSize</code> variable is the final picture size in a pixel.</li><li class="listitem">The <code class="literal">mIterationMax</code> variable is the count of iterations allowed to determine the Mandelbrot result for one pixel.</li></ul></div><p>We can now add a signal, <code class="literal">jobCompleted()</code>, and the abort feature to <code class="literal">Job.h</code>:</p><pre class="programlisting">#include &lt;QObject&gt; 
#include &lt;QRunnable&gt; 
#include &lt;QPointF&gt; 
#include &lt;QSize&gt; 
#include &lt;QAtomicInteger&gt; 
 
#include "JobResult.h" 
 
class Job : public QObject, public QRunnable 
{ 
    Q_OBJECT 
public: 
    ... 
signals: 
    void jobCompleted(JobResult jobResult); 
 
public slots: 
    void abort(); 
 
private: 
    QAtomicInteger&lt;bool&gt; mAbort; 
    ... 
}; 
</pre><p>The <code class="literal">jobCompleted()</code> signal will be emitted when the algorithm is over. The <code class="literal">jobResult</code> parameter contains result values. The <code class="literal">abort()</code> slot will allow us to stop the job updating the <code class="literal">mIsAbort</code> flag value. Notice that <code class="literal">mAbort</code> is not a classic <code class="literal">bool</code>, but a <code class="literal">QAtomicInteger&lt;bool&gt;</code>. This Qt cross-platform type allows us to perform atomic operations without interruption. You could use a mutex or another synchronization mechanism to do the job, but using an atomic variable is a fast way to safely update and access a variable from different threads.</p><p>It is time to switch to the implementation part with <code class="literal">Job.cpp</code>. Here is the <code class="literal">Job</code> class's constructor:</p><pre class="programlisting">#include "Job.h" 
 
Job::Job(QObject* parent) : 
    QObject(parent), 
    mAbort(false), 
    mPixelPositionY(0), 
    mMoveOffset(0.0, 0.0), 
    mScaleFactor(0.0), 
    mAreaSize(0, 0), 
    mIterationMax(1) 
{ 
} 
</pre><p>This is a classic initialization; do not forget to call the <code class="literal">QObject</code> constructor.</p><p>We can now implement the <code class="literal">run()</code> function:</p><pre class="programlisting">void Job::run() 
{ 
    JobResult jobResult(mAreaSize.width()); 
    jobResult.areaSize = mAreaSize; 
    jobResult.pixelPositionY = mPixelPositionY; 
    jobResult.moveOffset = mMoveOffset; 
    jobResult.scaleFactor = mScaleFactor; 
    ... 
} 
</pre><p>In this first part, we initialize a <code class="literal">JobResult</code> variable. The width of the area size is used to construct <code class="literal">JobResult::values</code> as a <code class="literal">QVector</code> with the correct initial size. Other input data is copied from <code class="literal">Job</code> to <code class="literal">JobResult</code> to let the receiver of <code class="literal">JobResult</code> get the result with the context input data.</p><p>Then we can update the <code class="literal">run()</code> function with the Mandelbrot algorithm:</p><pre class="programlisting">void Job::run() 
{ 
   ... 
    double imageHalfWidth = mAreaSize.width() / 2.0; 
    double imageHalfHeight = mAreaSize.height() / 2.0; 
    for (int imageX = 0; imageX &lt; mAreaSize.width(); ++imageX) { 
        int iteration = 0; 
        double x0 = (imageX - imageHalfWidth)  
                  * mScaleFactor + mMoveOffset.x(); 
        double y0 = (mPixelPositionY - imageHalfHeight)  
                  * mScaleFactor - mMoveOffset.y(); 
        double x = 0.0; 
        double y = 0.0; 
        do { 
            if (mAbort.load()) { 
                return; 
            } 
 
            double nextX = (x * x) - (y * y) + x0; 
            y = 2.0 * x * y + y0; 
            x = nextX; 
            iteration++; 
 
        } while(iteration &lt; mIterationMax 
                &amp;&amp; (x * x) + (y * y) &lt; 4.0); 
 
        jobResult.values[imageX] = iteration; 
    } 
 
    emit jobCompleted(jobResult); 
} 
</pre><p>The Mandelbrot algorithm itself is beyond the scope of this book. But you have to understand the main purpose of this <code class="literal">run()</code> function. Let's break it down:</p><div><ul class="itemizedlist"><li class="listitem">The for loop iterates over all <code class="literal">x</code> positions of pixels over one line</li><li class="listitem">The pixel position is converted into complex plane coordinates</li><li class="listitem">If the trial count exceeds the maximum authorized iteration, the algorithm ends with <code class="literal">iteration</code> to the <code class="literal">mIterationMax</code> value</li><li class="listitem">If the Mandelbrot check condition is true, the algorithm ends with <code class="literal">iteration &lt; mIterationMax</code></li><li class="listitem">In any case, for each pixel, the iteration count is stored in <code class="literal">values</code> of <code class="literal">JobResult</code></li><li class="listitem">Finally, the <code class="literal">jobCompleted()</code> signal is emitted with result values of this algorithm</li><li class="listitem">We perform an atomic read with <code class="literal">mAbort.load()</code>; notice that if the return value is <code class="literal">true</code>, the algorithm is aborted and nothing is emitted</li></ul></div><p>The last function is the <code class="literal">abort()</code> slot:</p><pre class="programlisting">void Job::abort() 
{ 
    mAbort.store(true); 
} 
</pre><p>This method performs an atomic write of the value, <code class="literal">true</code>. The atomic mechanism ensures that we can call <code class="literal">abort()</code> from multiple threads without disrupting the <code class="literal">mAbort</code> read in the <code class="literal">run()</code> function.</p><p>In our case, <code class="literal">run()</code> lives in the thread affected by the <code class="literal">QThreadPool</code> (we will cover it soon), while the <code class="literal">abort()</code> slot will be called in the <code class="literal">MandelbrotCalculator</code> thread context.</p><p>You might want to secure the operations on <code class="literal">mAbort</code> with a <code class="literal">QMutex</code>. However, keep in mind that locking and unlocking a mutex can become a costly operation if you do it often. Using a <code class="literal">QAtomicInteger</code> class here presents only the advantages: the access to <code class="literal">mAbort</code> is thread-safe and we avoid an expensive lock.</p><p>The end of the <code class="literal">Job</code> implementation only contains setter functions. Please refer to the complete source code if you have any doubt.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec87"/>Using QThreadPool in MandelbrotCalculator</h1></div></div></div><p>Now that our <code class="literal">Job</code> class is ready to be used, we need to create a class to manage the jobs. Please create a new class, <code class="literal">MandelbrotCalculator</code>. Let's see what we need in the file, <code class="literal">MandelbrotCalculator.h</code>:</p><pre class="programlisting">#include &lt;QObject&gt; 
#include &lt;QSize&gt; 
#include &lt;QPointF&gt; 
#include &lt;QElapsedTimer&gt; 
#include &lt;QList&gt; 
 
#include "JobResult.h" 
 
class Job; 
 
class MandelbrotCalculator : public QObject 
{ 
    Q_OBJECT 
public: 
    explicit MandelbrotCalculator(QObject *parent = 0); 
    void init(QSize imageSize); 
 
private: 
    QPointF mMoveOffset; 
    double mScaleFactor; 
    QSize mAreaSize; 
    int mIterationMax; 
    int mReceivedJobResults; 
    QList&lt;JobResult&gt; mJobResults; 
    QElapsedTimer mTimer; 
}; 
</pre><p>We have already discussed <code class="literal">mMoveOffset</code>, <code class="literal">mScaleFactor</code>, <code class="literal">mAreaSize</code>, and <code class="literal">mIterationMax</code> in the previous section. We also have some new variables:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">mReceivedJobResults</code> variable is the count of the <code class="literal">JobResult</code> received, which was sent by the jobs</li><li class="listitem">The <code class="literal">mJobResults</code> variable is a list that contains received <code class="literal">JobResult</code></li><li class="listitem">The <code class="literal">mTimer</code> variable calculates the elapsed time to run all jobs for a requested picture</li></ul></div><p>Now that you get a better picture of all member variables, we can add the signals, slots, and private methods. Update your <code class="literal">MandelbrotCalculator.h</code> file:</p><pre class="programlisting">... 
class MandelbrotCalculator : public QObject 
{ 
    Q_OBJECT 
public: 
    explicit MandelbrotCalculator(QObject *parent = 0); 
    void init(QSize imageSize); 
 
signals: 
    void pictureLinesGenerated(QList&lt;JobResult&gt; jobResults); 
    void abortAllJobs(); 
 
public slots: 
    void generatePicture(QSize areaSize, QPointF moveOffset, 
                         double scaleFactor, int iterationMax); 
    void process(JobResult jobResult); 
 
private: 
    Job* createJob(int pixelPositionY); 
    void clearJobs(); 
 
private: 
    ... 
}; 
</pre><p>Here are the roles of these:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">generatePicture()</code>: This slot is used by the caller to request a new Mandelbrot picture. This function prepares and starts jobs.</li><li class="listitem"><code class="literal">process()</code>: This slot handles results generated by the jobs.</li><li class="listitem"><code class="literal">pictureLinesGenerated()</code>: This signal is regularly triggered to dispatch results.</li><li class="listitem"><code class="literal">abortAllJobs()</code>: This signal is used to abort all active jobs.</li><li class="listitem"><code class="literal">createJob()</code>: This is a helper function to create and configure a new job.</li><li class="listitem"><code class="literal">clearJobs()</code>: This slot removes queued jobs and aborts active jobs.</li></ul></div><p>The header file is completed and we can now perform the implementation. Here is the beginning of the <code class="literal">MandelbrotCalculator.cpp</code> implementation:</p><pre class="programlisting">#include &lt;QDebug&gt; 
#include &lt;QThreadPool&gt; 
 
#include "Job.h" 
 
const int JOB_RESULT_THRESHOLD = 10; 
 
MandelbrotCalculator::MandelbrotCalculator(QObject *parent) 
    : QObject(parent), 
      mMoveOffset(0.0, 0.0), 
      mScaleFactor(0.005), 
      mAreaSize(0, 0), 
      mIterationMax(10), 
      mReceivedJobResults(0), 
      mJobResults(), 
      mTimer() 
{ 
} 
</pre><p>As always, we are using the initializer list with default values for our member variables. The role of <code class="literal">JOB_RESULT_THRESHOLD</code> will be covered soon. Here is the <code class="literal">generatePicture()</code> slot:</p><pre class="programlisting">void MandelbrotCalculator::generatePicture(QSize areaSize, QPointF moveOffset, double scaleFactor, int iterationMax) 
{ 
    if (areaSize.isEmpty()) { 
        return; 
    } 
 
    mTimer.start(); 
    clearJobs(); 
 
    mAreaSize = areaSize; 
    mMoveOffset = moveOffset; 
    mScaleFactor = scaleFactor; 
    mIterationMax = iterationMax; 
 
    for(int pixelPositionY = 0; 
        pixelPositionY &lt; mAreaSize.height(); pixelPositionY++) { 
        QThreadPool::globalInstance()-&gt; 
            start(createJob(pixelPositionY)); 
    } 
} 
</pre><p>If the <code class="literal">areaSize</code> dimension is 0x0, we have nothing to do. If the request is valid, we can start <code class="literal">mTimer</code> to track the whole generation duration. Each new picture generation will first cancel existing jobs by calling <code class="literal">clearJobs()</code>. Then we set our member variables with the ones provided. Finally, we create a new <code class="literal">Job</code> class for each vertical picture line. The <code class="literal">createJob()</code> function that returns a <code class="literal">Job*</code> value will be covered soon.</p><p>The <code class="literal">QThreadPool::globalInstance()</code> is a static function that gives us the optimal global thread pool depending on the core count of our CPU. Even if we call <code class="literal">start()</code> for all the <code class="literal">Job</code> classes, only the firsts starts immediately. Others are added to the pool queue waiting for an available thread.</p><p>Let's see now how a <code class="literal">Job</code> class is created with the <code class="literal">createJob()</code> function:</p><pre class="programlisting">Job* MandelbrotCalculator::createJob(int pixelPositionY) 
{ 
    Job* job = new Job(); 
 
    job-&gt;setPixelPositionY(pixelPositionY); 
    job-&gt;setMoveOffset(mMoveOffset); 
    job-&gt;setScaleFactor(mScaleFactor); 
    job-&gt;setAreaSize(mAreaSize); 
    job-&gt;setIterationMax(mIterationMax); 
 
    connect(this, &amp;MandelbrotCalculator::abortAllJobs, 
            job, &amp;Job::abort); 
 
    connect(job, &amp;Job::jobCompleted, 
            this, &amp;MandelbrotCalculator::process); 
 
    return job; 
} 
</pre><p>As you can see, the jobs are allocated on the heap. This operation takes some time in the <code class="literal">MandelbrotCalculator</code> thread. But the results are worth it; the overhead is being compensated by the multi-threading system. Notice that when we call <code class="literal">QThreadPool::start()</code>, the thread pool takes ownership of the <code class="literal">job</code>. As a consequence, it will be deleted by the thread pool when <code class="literal">Job::run()</code> ends. We set the input data of the <code class="literal">Job</code> class required by the Mandelbrot algorithm.</p><p>Then two connections are performed:</p><div><ul class="itemizedlist"><li class="listitem">Emitting our <code class="literal">abortAllJobs()</code> signal will call the <code class="literal">abort()</code> slot of all jobs</li><li class="listitem">Our <code class="literal">process()</code> slot is executed each time a <code class="literal">Job</code> completes its task</li></ul></div><p>Finally, the <code class="literal">Job</code> pointer is returned to the caller, in our case, the <code class="literal">generatePicture()</code> slot.</p><p>The last helper function is <code class="literal">clearJobs()</code>. Add it to your <code class="literal">MandelbrotCalculator.cpp</code>:</p><pre class="programlisting">void MandelbrotCalculator::clearJobs() 
{ 
    mReceivedJobResults = 0; 
    emit abortAllJobs(); 
    QThreadPool::globalInstance()-&gt;clear(); 
} 
</pre><p>The counter of received job results is reset. We emit our signal to abort all active jobs. Finally, we remove queued jobs waiting for an available thread in the thread pool.</p><p>The last function of this class is <code class="literal">process()</code>, and is maybe the most important function. Update your code with the following snippet:</p><pre class="programlisting">void MandelbrotCalculator::process(JobResult jobResult) 
{ 
    if (jobResult.areaSize != mAreaSize || 
            jobResult.moveOffset != mMoveOffset || 
            jobResult.scaleFactor != mScaleFactor) { 
        return; 
    } 
 
    mReceivedJobResults++; 
    mJobResults.append(jobResult); 
 
    if (mJobResults.size() &gt;= JOB_RESULT_THRESHOLD || 
            mReceivedJobResults == mAreaSize.height()) { 
        emit pictureLinesGenerated(mJobResults); 
        mJobResults.clear(); 
    } 
 
    if (mReceivedJobResults == mAreaSize.height()) { 
        qDebug() &lt;&lt; "Generated in " &lt;&lt; mTimer.elapsed() &lt;&lt; " ms"; 
    } 
} 
</pre><p>This slot will be called each time a job completes its task. The first thing to check is that the current <code class="literal">JobResult</code> is still valid with the current input data. When a new picture is requested, we clear the jobs queue and abort the active jobs. However, if an old <code class="literal">JobResult</code> is still sent to this <code class="literal">process()</code> slot, we must ignore it.</p><p>After that, we can increment the <code class="literal">mReceivedJobResults</code> counter and append this <code class="literal">JobResult</code> to our member queue, <code class="literal">mJobResults</code>. The calculator waits to get <code class="literal">JOB_RESULT_THRESHOLD</code> (that is, 10) results before dispatching them by emitting the <code class="literal">pictureLinesGenerated()</code> signal. You can try to tweak this value with caution:</p><div><ul class="itemizedlist"><li class="listitem">A lower value, for example 1, will dispatch each line of data to the widget as soon as the calculator gets it. But the widget will be slower than the calculator to handle each line. Moreover, you will flood the widget event loop.</li><li class="listitem">A higher value relieves the widget event loop. But the user will wait longer before seeing something happening. A continuous partial frame update gives a better user experience.</li></ul></div><p>Also notice that when the event is dispatched, the <code class="literal">QList</code> class with the job result is sent by copy. But Qt performs implicit sharing with <code class="literal">QList</code>, so we only send a shallow copy not a costly deep copy. Then we clear the current <code class="literal">QList</code> of the calculator.</p><p>Finally, if the processed <code class="literal">JobResult</code> is the last one in the area, we display a debug message with the elapsed time since the user call, <code class="literal">generatePicture()</code>.</p><div><h3 class="title"><a id="tip44"/>Tip</h3><p><strong>Qt tip</strong></p><p>You can set the thread count used by the <code class="literal">QThreadPool</code> class with <code class="literal">setMaxThreadCount(x)</code> where <code class="literal">x</code> is the thread count.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec88"/>Displaying the fractal with MandelbrotWidget</h1></div></div></div><p>Here we are, the Mandelbrot algorithm is done and the multi-threading system is ready to compute complex fractals over all your CPU cores. We can now create the widget that will convert all <code class="literal">JobResult</code> to display a pretty picture. Create a new C++ class called <code class="literal">MandelbrotWidget</code>. For this widget, we will handle the painting ourselves. Thus, we do not need any <code class="literal">.ui</code><code class="literal">Qt Designer Form</code> file. Let's begin with the <code class="literal">MandelbrotWidget.h </code>file:</p><pre class="programlisting">#include &lt;memory&gt; 
 
#include &lt;QWidget&gt; 
#include &lt;QPoint&gt; 
#include &lt;QThread&gt; 
#include &lt;QList&gt; 
 
#include "MandelbrotCalculator.h" 
 
class QResizeEvent; 
 
class MandelbrotWidget : public QWidget 
{ 
    Q_OBJECT 
 
public: 
    explicit MandelbrotWidget(QWidget *parent = 0); 
    ~MandelbrotWidget(); 
 
private: 
    MandelbrotCalculator mMandelbrotCalculator; 
    QThread mThreadCalculator; 
    double mScaleFactor; 
    QPoint mLastMouseMovePosition; 
    QPointF mMoveOffset; 
    QSize mAreaSize; 
    int mIterationMax; 
    std::unique_ptr&lt;QImage&gt; mImage; 
}; 
</pre><p>You should recognize some known variable names such as <code class="literal">mScaleFactor</code>, <code class="literal">mMoveOffset</code>, <code class="literal">mAreaSize</code>, or <code class="literal">mIterationMax</code>. We have already covered them in the <code class="literal">JobResult</code> and <code class="literal">Job</code> implementation. Here are the real new ones:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">mMandelbrotCalculator</code> variable is our multi-threaded <code class="literal">Job</code> manager. The widget will do requests to it and wait for results.</li><li class="listitem">The <code class="literal">mThreadCalculator</code> variable allows the Mandelbrot calculator to run in its own thread.</li><li class="listitem">The <code class="literal">mLastMouseMovePosition</code> variable is used by the widget to handle user events for the pan feature.</li><li class="listitem">The <code class="literal">mImage</code> variable is the current picture displayed by the widget. It is a <code class="literal">unique_ptr</code> pointer, so <code class="literal">MandelbrotWidget</code> is the owner of <code class="literal">mImage</code>.</li></ul></div><p>We can now add the functions. Update your code like this:</p><pre class="programlisting">class MandelbrotWidget : public QWidget 
{ 
... 
public slots: 
    void processJobResults(QList&lt;JobResult&gt; jobResults); 
 
signals: 
    void requestPicture(QSize areaSize, QPointF moveOffset, double scaleFactor, int iterationMax); 
 
protected: 
    void paintEvent(QPaintEvent*) override; 
    void resizeEvent(QResizeEvent* event) override; 
    void wheelEvent(QWheelEvent* event) override; 
    void mousePressEvent(QMouseEvent* event) override; 
    void mouseMoveEvent(QMouseEvent* event) override; 
 
private: 
    QRgb generateColorFromIteration(int iteration); 
 
private: 
    ... 
}; 
</pre><p>Before we dive into the implementation, let's talk about these functions:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">processJobResults()</code> function will handle the <code class="literal">JobResult</code> list dispatched by <code class="literal">MandelbrotCalculator</code>.</li><li class="listitem">The <code class="literal">requestPicture()</code> signal is emitted each time the user changes the input data (offset, scale, or area size).</li><li class="listitem">The <code class="literal">paintEvent()</code> function draws the widget with the current <code class="literal">mImage</code>.</li><li class="listitem">The <code class="literal">resizeEvent()</code> function resizes the Mandelbrot area size when the user resizes the window.</li><li class="listitem">The <code class="literal">wheelEvent()</code> function handles the user mouse wheel event to apply a scale factor.</li><li class="listitem">The <code class="literal">mousePressEvent()</code> function and <code class="literal">mouseMoveEvent()</code> retrieve user mouse events to move the Mandelbrot picture.</li><li class="listitem">The <code class="literal">generateColorFromIteration()</code> is a helper function to colorize the Mandelbrot picture. The iteration value by pixel is converted into a color value.</li></ul></div><p>We can now implement the <code class="literal">MandelbrotWidget</code> class. Here is the beginning of the <code class="literal">MandelbrotWidget.cpp</code> file:</p><pre class="programlisting">#include "MandelbrotWidget.h" 
 
#include &lt;QResizeEvent&gt; 
#include &lt;QImage&gt; 
#include &lt;QPainter&gt; 
#include &lt;QtMath&gt; 
 
const int ITERATION_MAX = 4000; 
const double DEFAULT_SCALE = 0.005; 
const double DEFAULT_OFFSET_X = -0.74364390249094747; 
const double DEFAULT_OFFSET_Y = 0.13182589977450967; 
 
MandelbrotWidget::MandelbrotWidget(QWidget *parent) : 
    QWidget(parent), 
    mMandelbrotCalculator(), 
    mThreadCalculator(this), 
    mScaleFactor(DEFAULT_SCALE), 
    mLastMouseMovePosition(), 
    mMoveOffset(DEFAULT_OFFSET_X, DEFAULT_OFFSET_Y), 
    mAreaSize(), 
    mIterationMax(ITERATION_MAX) 
{ 
    mMandelbrotCalculator.moveToThread(&amp;mThreadCalculator); 
 
    connect(this, &amp;MandelbrotWidget::requestPicture, 
        &amp;mMandelbrotCalculator, 
        &amp;MandelbrotCalculator::generatePicture); 
 
    connect(&amp;mMandelbrotCalculator, 
        &amp;MandelbrotCalculator::pictureLinesGenerated, 
        this, &amp;MandelbrotWidget::processJobResults); 
 
    mThreadCalculator.start(); 
} 
</pre><p>At the top of the snippet, we set some constant default values. Feel free to tweak these values if you want a different view when you start the application. The first thing the constructor does is to change the thread affinity of the <code class="literal">mMandelbrotCalculator</code> class. In this way, processing performed by the calculator (creating and starting jobs, aggregating job results, and clearing jobs) does not disturb the UI thread. Then we perform connections with the signal and slot of <code class="literal">MandelbrotCalculator</code>. Because the widget and the calculator have a different thread affinity, the connection will be automatically a <code class="literal">Qt::QueuedConnection</code> slot. Finally, we can start the thread of <code class="literal">mThreadCalculator</code>. We can now add the destructor:</p><pre class="programlisting">MandelbrotWidget::~MandelbrotWidget() 
{  
    mThreadCalculator.quit(); 
    mThreadCalculator.wait(1000); 
    if (!mThreadCalculator.isFinished()) { 
        mThreadCalculator.terminate(); 
    } 
} 
</pre><p>We need to request the calculator thread to quit. When the calculator thread event loop handles our request, the thread will return a code 0. We wait 1,000 ms for the thread to end. We can continue this implementation with all the cases that request a new picture. Here is the <code class="literal">resizeEvent()</code> slot:</p><pre class="programlisting">void MandelbrotWidget::resizeEvent(QResizeEvent* event) 
{ 
    mAreaSize = event-&gt;size(); 
 
    mImage = std::make_unique&lt;QImage&gt;(mAreaSize, 
        QImage::Format_RGB32); 
    mImage-&gt;fill(Qt::black); 
 
    emit requestPicture(mAreaSize, mMoveOffset, mScaleFactor, 
        mIterationMax); 
} 
</pre><p>We update <code class="literal">mAreaSize</code> with the new widget size. Then, a new black <code class="literal">QImage</code> is created with the correct dimensions. Finally, we request a picture computation to <code class="literal">MandelbrotCalculator</code>. Let's see how the mouse wheel is handled:</p><pre class="programlisting">void MandelbrotWidget::wheelEvent(QWheelEvent* event) 
{ 
    int delta = event-&gt;delta(); 
    mScaleFactor *= qPow(0.75, delta / 120.0); 
    emit requestPicture(mAreaSize, mMoveOffset, mScaleFactor, 
        mIterationMax); 
} 
</pre><p>The mouse wheel value can be retrieved from <code class="literal">QWheelEvent::delta()</code>. We use a power function to apply a coherent value on <code class="literal">mScaleFactor</code> and we request an updated picture. We can now implement the pan feature:</p><pre class="programlisting">void MandelbrotWidget::mousePressEvent(QMouseEvent* event) 
{ 
    if (event-&gt;buttons() &amp; Qt::LeftButton) { 
        mLastMouseMovePosition = event-&gt;pos(); 
    } 
} 
</pre><p>The first function stores the mouse position where the user begins the move gesture. Then the next function will use <code class="literal">mLastMouseMovePosition</code> to create an offset:</p><pre class="programlisting">void MandelbrotWidget::mouseMoveEvent(QMouseEvent* event) 
{ 
    if (event-&gt;buttons() &amp; Qt::LeftButton) { 
        QPointF offset = event-&gt;pos() - mLastMouseMovePosition; 
        mLastMouseMovePosition = event-&gt;pos(); 
        offset.setY(-offset.y()); 
        mMoveOffset += offset * mScaleFactor; 
        emit requestPicture(mAreaSize, mMoveOffset, mScaleFactor, 
            mIterationMax); 
    } 
} 
</pre><p>The difference between the new and the old mouse position gives us the pan offset. Notice that we invert a y-axis value because the mouse event is in a top-left referential, whereas the Mandelbrot algorithm relies on a bottom-left referential. Finally, we request a picture with updated input values. We covered all the user events that emit a <code class="literal">requestPicture()</code> signal. Let's see now how we handle <code class="literal">JobResult</code> dispatched by <code class="literal">MandelbrotCalculator</code>:</p><pre class="programlisting">void MandelbrotWidget::processJobResults(QList&lt;JobResult&gt; jobResults) 
{ 
    int yMin = height(); 
    int yMax = 0; 
 
    for(JobResult&amp; jobResult : jobResults) { 
 
        if (mImage-&gt;size() != jobResult.areaSize) { 
            continue; 
        } 
 
        int y = jobResult.pixelPositionY; 
        QRgb* scanLine =  
            reinterpret_cast&lt;QRgb*&gt;(mImage-&gt;scanLine(y)); 
 
        for (int x = 0; x &lt; mAreaSize.width(); ++x) { 
            scanLine[x] = 
                generateColorFromIteration(jobResult.values[x]); 
        } 
 
        if (y &lt; yMin) { 
            yMin = y; 
        } 
 
        if (y &gt; yMax) { 
            yMax = y; 
        } 
    } 
 
    repaint(0, yMin, 
            width(), yMax); 
} 
</pre><p>The calculator sends us a <code class="literal">QList</code> of <code class="literal">JobResult</code>. For each one, we need to check if the concerned area size is still valid. We directly update the pixel colors of <code class="literal">mImage</code>. The <code class="literal">scanLine()</code> function returns a pointer on the pixel data. It is a fast way to update a <code class="literal">QImage</code> pixel color. The <code class="literal">JobResult</code> function contains the iteration count, and our helper function, <code class="literal">generateColorFromIteration()</code>, returns a RGB value depending on the iteration value. A complete repaint of the widget is not necessary, because we only update several lines of the <code class="literal">QImage</code>. Thus, we repaint only the updated region.</p><p>Here is how we convert an iteration value in an RGB value:</p><pre class="programlisting">QRgb MandelbrotWidget::generateColorFromIteration(int iteration) 
{ 
    if (iteration == mIterationMax) { 
        return qRgb(50, 50, 255); 
    } 
 
    return qRgb(0, 0, (255.0 * iteration / mIterationMax)); 
} 
</pre><p>Colorizing a Mandelbrot is an art on its own. We implement here a simple linear interpolation on the blue channel. A nice Mandelbrot picture depends on the maximum iteration per pixel and its color technique. Feel free to enhance it like you want!</p><p>Here we are, the last but not least function, <code class="literal">paintEvent()</code>:</p><pre class="programlisting">void MandelbrotWidget::paintEvent(QPaintEvent* event) 
{ 
    QPainter painter(this); 
    painter.save(); 
 
    QRect imageRect = event-&gt;region().boundingRect(); 
    painter.drawImage(imageRect, *mImage, imageRect); 
 
    painter.setPen(Qt::white); 
 
    painter.drawText(10, 20, QString("Size: %1 x %2") 
        .arg(mImage-&gt;width()) 
        .arg(mImage-&gt;height())); 
 
    painter.drawText(10, 35, QString("Offset: %1 x %2") 
        .arg(mMoveOffset.x()) 
        .arg(mMoveOffset.y())); 
 
    painter.drawText(10, 50, QString("Scale: %1") 
        .arg(mScaleFactor)); 
 
    painter.drawText(10, 65, QString("Max iteration: %1") 
        .arg(ITERATION_MAX)); 
 
    painter.restore(); 
} 
</pre><p>We must override this function because we handle the widget drawing by ourselves. The first thing to do is to draw the updated region of the image. The <code class="literal">QPaintEvent</code> object contains the region that needs to be updated. The <code class="literal">QPainter</code> class makes the drawing easy. Finally, we draw some information texts of the current input data in white. You now have a complete overview of the progressive picture display line by line. Let's sum up the workflow of this feature:</p><div><ol class="orderedlist arabic"><li class="listitem">Each <code class="literal">Job::run()</code> generates a <code class="literal">JobResult</code> object.</li><li class="listitem">The <code class="literal">MandelbrotCalculator::process()</code> signal aggregates the <code class="literal">JobResult</code> object and dispatches them by groups (by default, 10).</li><li class="listitem">The <code class="literal">MandelbrotWidget::processJobResults()</code> signal updates only concerned lines of the picture and requests a partial repaint of the widget.</li><li class="listitem">The <code class="literal">MandelbrotWidget::paintEvent()</code> signal only redraws the picture with the new values.</li></ol><div></div><p>This feature causes a little overhead, but the user experience is smoother. Indeed, the application reacts quickly to the user events: the first lines are updated almost immediately. The user does not have to wait for the full picture generation to see something happening.</p><p>The widget is ready; do not forget to add it to <code class="literal">MainWindow</code>. Promoting a custom widget should be an easy task for you now. If you have any doubt, check <a class="link" title="Chapter 4.  Conquering the Desktop UI" href="part0040.xhtml#aid-164MG2">Chapter 4</a>, <em>Conquering the Desktop UI</em>, or the complete source code of this chapter. You should now be able to display and navigate into your multi-threaded Mandelbrot set!</p><p>If you start the application, you should see something like this:</p><div><img src="img/image00430.jpeg" alt="Displaying the fractal with MandelbrotWidget"/></div><p style="clear:both; height: 1em;"> </p><p>Try to zoom now and pan into the Mandelbrot set. You should find some funny places like this one:</p><div><img src="img/image00431.jpeg" alt="Displaying the fractal with MandelbrotWidget"/></div><p style="clear:both; height: 1em;"> </p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec89"/>Summary</h1></div></div></div><p>You discovered how a <code class="literal">QThread</code> class works and learned how to efficiently use tools provided by Qt to create a powerful multi-threaded application. Your Mandelbrot application is able to use all cores of your CPU to compute a picture quickly.</p><p>Creating a multi-threaded application presents a lot of pitfalls (deadlock, event loop flood, orphan threads, overhead, and so on). The application architecture is important. If you are able to isolate the heavy code that you want to parallelize, everything should go well. Nevertheless, the user experience is of primary importance; you will sometimes have to accept a little overhead if your application gives the user a smoother feeling.</p><p>In the next chapter, we will see several ways to implement an IPC (Inter-Process Communication) between applications. The project example will enhance your current Mandelbrot application with a TCP/IP socket system. So the Mandelbrot generator will compute pictures over several CPU cores from multiple computers!</p></div></body></html>