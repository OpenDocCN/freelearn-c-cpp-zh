<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer021">
<h1 class="chapter-number" id="_idParaDest-82"><a id="_idTextAnchor188"/>4</h1>
<h1 id="_idParaDest-83"><a id="_idTextAnchor189"/>Indirect Addressing – References</h1>
<p>This chapter will examine how to utilize references in C++. References can often, but not always, be used as an alternative to pointers for indirect addressing. Though you have prior experience with indirect addressing from our last chapter using pointers, we will start at the beginning to understand C++ references.</p>
<p>References, like pointers, are a language feature you must be able to utilize with ease. Many other languages use references for indirect addressing without requiring the thorough understanding that C++ imposes to correctly utilize both pointers and references. Just as with pointers, you will see references frequently used throughout code from other programmers. You may be pleased that using references will provide notational ease when writing applications compared to pointers.</p>
<p>Unfortunately, references cannot be used as a substitute for pointers in all situations requiring indirect addressing. Therefore, a thorough understanding of indirect addressing using both pointers and references is a necessity in C++ to create successful and maintainable code.</p>
<p>The goal of this chapter will be to complement your understanding of indirect addressing using pointers with knowing how to use C++ references as an alternative. Understanding both techniques of indirect addressing will enable you to be a better programmer, to easily understand and modify others’ code, as well as to write original, mature, and competent C++ code yourself.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Reference basics – declaring, initializing, accessing, and referencing existing objects</li>
<li>Using references with functions as arguments and as return values</li>
<li>Using the <strong class="source-inline">const</strong> qualifier with references</li>
<li>Understanding underlying implementation, and when references cannot be utilized</li>
</ul>
<p>By the end of this chapter, you will understand how to declare, initialize, and access references; you will understand how to reference existing objects in memory. You will be able to use references as arguments to functions, and understand how they may be used as return values from functions.</p>
<p>You will also fathom how the <strong class="source-inline">const</strong> qualifier may apply to references as variables and be utilized with both a function’s parameters and return type. You will be able to distinguish when references can be used in lieu of pointers, and in which situations they cannot provide a substitute for pointers. These skills will be necessary in order to move forward with the next chapters in the book successfully.</p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor190"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter04">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter04</a>. Each full program example can be found in the GitHub under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <strong class="source-inline">Chapter04</strong> in a file named <strong class="source-inline">Chp4-Ex1.cpp</strong> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3ptaMRK">https://bit.ly/3ptaMRK</a>.</p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor191"/>Understanding reference basics</h1>
<p>In this section, we will revisit reference basics as well as introduce operators applicable to references, such as the reference operator <strong class="source-inline">&amp;</strong>. We will employ the reference operator (<strong class="source-inline">&amp;</strong>) to establish a <a id="_idIndexMarker235"/>reference to the existing variable. Like pointer variables, reference variables refer to memory that is defined elsewhere. </p>
<p>Using reference variables allows us to use a more straightforward notation than the notation that pointers use when using indirectly accessed memory. Many programmers appreciate the clarity in the notation of a reference versus a pointer variable. But, behind the scenes, memory must always be properly allocated and released; some portion of memory that is referenced may come from the heap. The programmer will undoubtedly need to deal with pointers for some portion of their overall code.</p>
<p>We will discern when references and pointers are interchangeable, and when they are not. Let’s get started with the basic notation for declaring and using reference variables.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor192"/>Declaring, initializing, and accessing references</h2>
<p>Let’s begin with the meaning of a reference variable. A C++ <strong class="bold">reference</strong> is an alias or a means for <a id="_idIndexMarker236"/>referring to another variable. A reference is specified using the reference operator <strong class="source-inline">&amp;</strong>. A reference must be initialized (at declaration) and may never be assigned to reference another object. The reference and the initializer <a id="_idIndexMarker237"/>must be of the same type. Since the reference and the object being referenced share the same memory, either variable may be used <a id="_idIndexMarker238"/>to modify the contents of the shared memory location.</p>
<p>A reference variable, behind the scenes, can be compared to a pointer variable in that it holds the address of the variable that it is referencing. Unlike a pointer variable, any usage of the reference variable automatically dereferences the variable to go to the address that it contains; the dereference operator <strong class="source-inline">*</strong> is simply not needed with references. Dereferencing is automatic and implied with each use of a reference variable. </p>
<p>Let’s take a look at an example illustrating reference basics:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex1.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;
using std::endl;
int main()
{
    int x = 10;
    int *p = new int;   // allocate memory for ptr variable
    *p = 20;            // dereference and assign value 
    <strong class="bold">int &amp;refInt1 = x;</strong>  // reference to an intege<a id="_idTextAnchor193"/>r
    <strong class="bold">int &amp;refInt2 = *p;</strong> // also a reference to an integer
    cout &lt;&lt; x &lt;&lt; " " &lt;&lt; *p &lt;&lt; " ";
    cout &lt;&lt; refInt1 &lt;&lt; " " &lt;&lt; refInt2 &lt;&lt; endl;
    x++;      // updates x and <strong class="bold">refInt1</strong>
    (*p)++;   // updates *p and <strong class="bold">refInt2</strong>
    cout &lt;&lt; x &lt;&lt; " " &lt;&lt; *p &lt;&lt; " ";
    cout &lt;&lt; <strong class="bold">refInt1</strong> &lt;&lt; " " &lt;&lt; <strong class="bold">refInt2</strong> &lt;&lt; endl;
    <strong class="bold">refInt1++;</strong>    // updates refInt1 and x
    <strong class="bold">refInt2++;</strong>    // updates refInt2 and *p
    cout &lt;&lt; x &lt;&lt; " " &lt;&lt; *p &lt;&lt; " ";
    cout &lt;&lt; <strong class="bold">refInt1</strong> &lt;&lt; " " &lt;&lt; <strong class="bold">refInt2</strong> &lt;&lt; endl;
    delete p;       // relinquish p's memory
    return 0;
}</pre>
<p>In the <a id="_idIndexMarker239"/>preceding example, we first declare and initialize <strong class="source-inline">int x = 10;</strong> and then declare and allocate <strong class="source-inline">int *p = new int;</strong>. We then <a id="_idIndexMarker240"/>assign the integer value <strong class="source-inline">20</strong> to <strong class="source-inline">*p.</strong> </p>
<p>Next, we <a id="_idIndexMarker241"/>declare and initialize two reference variables, <strong class="source-inline">refInt1</strong> and <strong class="source-inline">refInt2</strong>. In the first reference declaration and initialization, <strong class="source-inline">int &amp;refInt1 = x;</strong>, we establish <strong class="source-inline">refInt1</strong> to refer to the variable <strong class="source-inline">x</strong>. It helps to read the reference declaration from right to left. Here, we are saying to use <strong class="source-inline">x</strong> to initialize <strong class="source-inline">refInt1</strong>, which is a reference (<strong class="source-inline">&amp;</strong>) to an integer. Notice that both the initializer, <strong class="source-inline">x</strong>, is an integer and that <strong class="source-inline">refInt1</strong> is declared to be a reference to an integer; their types match. This is important. The code will not compile if the types differ. Likewise, the declaration and initialization <strong class="source-inline">int &amp;refInt2 = *p;</strong> also establishes <strong class="source-inline">refInt2</strong> as a reference to an integer. Which one? The one pointed to by <strong class="source-inline">p</strong>. This is why <strong class="source-inline">p</strong> is dereferenced using <strong class="source-inline">*</strong> to go to the integer i<a id="_idTextAnchor194"/>tself.</p>
<p>Now, we print out <strong class="source-inline">x</strong>, <strong class="source-inline">*p</strong>, <strong class="source-inline">refInt1</strong>, and <strong class="source-inline">refInt2</strong>; we can verify that <strong class="source-inline">x</strong> and <strong class="source-inline">refInt1</strong> have the same value of <strong class="source-inline">10</strong>, and <strong class="source-inline">*p</strong> and <strong class="source-inline">refInt2</strong> also have the same value of <strong class="source-inline">20</strong>.</p>
<p>Next, using <a id="_idIndexMarker242"/>the original variables, we increment both <strong class="source-inline">x</strong> and <strong class="source-inline">*p</strong> by one. Not only does this increment the values of <strong class="source-inline">x</strong> and <strong class="source-inline">*p</strong>, but the values <a id="_idIndexMarker243"/>of <strong class="source-inline">refInt1</strong> and <strong class="source-inline">refInt2</strong>. Repeating the printing <a id="_idIndexMarker244"/>of these four values, we again notice that <strong class="source-inline">x</strong> and <strong class="source-inline">refInt1</strong> have the value of <strong class="source-inline">11</strong>, while <strong class="source-inline">*p</strong> and <strong class="source-inline">refInt2</strong> have the value of <strong class="source-inline">21</strong>.</p>
<p>Finally, we use the reference variables to increment the shared memory. We increment both <strong class="source-inline">refInt1</strong> and <strong class="source-inline">*refint2</strong> by one and this also increments the values of the original variables <strong class="source-inline">x</strong> and <strong class="source-inline">*p</strong>. This is because the memory is one and the same between the original variable and the reference to that variable. That is, the reference can be thought of as an alias to the original variable. We conclude the program by again printing out the four variables.</p>
<p>Here is the output:</p>
<p class="source-code">10 20 10 20</p>
<p class="source-code">11 21 11 21</p>
<p class="source-code">12 <a id="_idTextAnchor195"/>22 12 22</p>
<p class="callout-heading">Important note</p>
<p class="callout">Remember, a reference variable must be initialized to the variable it will refer to. The reference may never be assigned to another variable. More precisely, we cannot rebind the reference to another entity. The reference and its initializer must be the same type.</p>
<p>Now that we have a handle on how to declare simple references, let’s take a more complete look at referencing existing objects, such as those to user defin<a id="_idTextAnchor196"/>ed types.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor197"/>Referencing existing objects of user defined types </h2>
<p>Should a reference to an object of a <strong class="source-inline">struct</strong> or <strong class="source-inline">class</strong> type be defined, the object being <a id="_idIndexMarker245"/>referenced is simply accessed using the <strong class="source-inline">.</strong> (member selection) operator. Again, it is not necessary (such as it is with pointers) to first use the dereference operator to go to the object being referenced before choosing the desired member.</p>
<p>Let’s take <a id="_idIndexMarker246"/>a look at an example in which we reference a user defined type:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex2.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;
using std::endl;
using std::string;
class Student    // very simple class – we will add to it 
{                // in our next chapter
public:
    string name;
    float gpa;
};
int main()
{
    Student s1;
    <strong class="bold">Student &amp;sRef = s1;</strong>  // establish a reference to s1
    s1.name = "Katje Katz";   // fill in the data
    s1.gpa = 3.75;
    cout &lt;&lt; s1.name &lt;&lt; " has GPA: " &lt;&lt; s1.gpa &lt;&lt; endl; 
    cout &lt;&lt; <strong class="bold">sRef.name</strong> &lt;&lt; " has GPA: " &lt;&lt; <strong class="bold">sRef.gpa</strong> &lt;&lt; endl; 
    <strong class="bold">sRef.name</strong> = "George Katz";  // change the data
    <strong class="bold">sRef.gpa</strong> = 3.25;
    cout &lt;&lt; s1.name &lt;&lt; " has GPA: " &lt;&lt; s1.gpa &lt;&lt; endl; 
    cout &lt;&lt; <strong class="bold">sRef.name</strong> &lt;&lt; " has GPA: " &lt;&lt; <strong class="bold">sRef.gpa</strong> &lt;&lt; endl; 
    return 0;
}</pre>
<p>In the <a id="_idIndexMarker247"/>first part of this program, we define a user defined type, <strong class="source-inline">Student</strong>, using a <strong class="source-inline">class</strong>. Next, we declare a variable <strong class="source-inline">s1</strong> of type <strong class="source-inline">Student</strong> using <strong class="source-inline">Student s1;</strong>. Now, we declare and initialize a reference to a <strong class="source-inline">Student</strong> using <strong class="source-inline">Student &amp;sRef = s1;</strong>. Here, we declare <strong class="source-inline">sRef</strong> to reference a specific <strong class="source-inline">Student</strong>, namely <strong class="source-inline">s1</strong>. Notice that both <strong class="source-inline">s1</strong> is of type <strong class="source-inline">Student</strong> and the reference type of <strong class="source-inline">sRef</strong> is also that of type <strong class="source-inline">Student</strong>.</p>
<p>Now, we load some initial data into <strong class="source-inline">s1.name</strong> and <strong class="source-inline">s1.gpa</strong> using two simple assignments. Consequently, this alters the value of <strong class="source-inline">sRef</strong> since <strong class="source-inline">s1</strong> and <strong class="source-inline">sRef</strong> refer to the same memory. That is, <strong class="source-inline">sRef</strong> is an alias for <strong class="source-inline">s1</strong>.</p>
<p>We print out various data members for <strong class="source-inline">s1</strong> and <strong class="source-inline">sRef</strong> and notice that they contain the same values. </p>
<p>Now, we load new values into <strong class="source-inline">sRef.name</strong> and <strong class="source-inline">sRef.gpa</strong> using assignments. Similarly, we print out various data members for <strong class="source-inline">s1</strong> and <strong class="source-inline">sRef</strong> and notice that again, the values for both have changed. Again, we can see that they reference the <a id="_idTextAnchor198"/>same memory.</p>
<p>The output to accompany this program is as follows:</p>
<p class="source-code">Katje Katz has GPA: 3.75</p>
<p class="source-code">Katje Katz has GPA: 3.75</p>
<p class="source-code">George Katz has GPA: 3.25</p>
<p class="source-code">George Katz has GPA: 3.25</p>
<p>Let’s now <a id="_idIndexMarker248"/>move forward with our understanding of references by considering their usage <a id="_idTextAnchor199"/>in functions.</p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor200"/>Using references with functions</h1>
<p>So far, we have minimally demonstrated references by using them to establish an alias for an existing variable. Instead, let’s put forth a meaningful use of references, such as when they are used in function calls. We know most functions in C++ will take arguments, and we have seen many examples in the previous <a id="_idIndexMarker249"/>chapters illustrating function prototypes and function definitions. Now, let’s augment our understanding of functions by passing references as arguments to functions, and using references as return values from functions.</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor201"/>Passing references as arguments to functions</h2>
<p>References may be used as arguments to functions to achieve call-by-reference, rather than call-by-value, parameter passing. References can alleviate the need for pointer notation <a id="_idIndexMarker250"/>in the scope of the function in question as well as in the call to that function. Object or <strong class="source-inline">.</strong> (member selection) notation is used to access <strong class="source-inline">struct</strong> or <strong class="source-inline">class</strong> members for formal parameters that are references.</p>
<p>In order to <a id="_idIndexMarker251"/>modify the contents of a variable passed as an argument to a function, a reference (or pointer) to that argument must be used as a function parameter. Just as with a pointer, when a reference is passed to a function, a copy of the address representing the reference is passed to the function. However, within the function, any usage of a formal parameter that is a reference will automatically and implicitly be dereferenced, allowing the user to use object rather than pointer notation. As with passing a pointer variable, passing a reference variable to a function will allow the memory referenced by that parameter to be modified. </p>
<p>When examining a function call (apart from its prototype), it will not be obvious whether an object passed to that function is passed by value or by reference. That is, whether the entire object will be copied on the stack or whether a reference to that object will instead be passed on the stack. This is because object notation is used when manipulating references, and the function calls for these two scenarios will use the same syntax.</p>
<p>Diligent use of function prototypes will solve the mystery of what a function definition looks like and whether its arguments are objects or references to objects. Remember, a function definition may be defined in a separate file from any calls to that function, and not be easily available to view. Note that this ambiguity does not come up with pointers specified in a function call; it is immediately obvious that an address is being sent to a function based on how the variable is declared.  </p>
<p>Let’s take <a id="_idIndexMarker252"/>a few minutes to understand an example illustrating passing references as arguments to functions. Here, we will <a id="_idIndexMarker253"/>begin by examining three functions, which contribute to the following ful<a id="_idTextAnchor202"/>l program example:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex3.cpp</a></p>
<pre class="source-code">
void AddOne(<strong class="bold">int &amp;arg</strong>)   // These two fns. are overloaded
{
    arg++;
}
void AddOne(int *arg)   // Overloaded function definition
{
    (*arg)++;
}
void Display(<strong class="bold">int &amp;arg</strong>)  // Function parameter establishes 
                       // a reference to arg
{
    cout &lt;&lt; arg &lt;&lt; " " &lt;&lt; flush;
}</pre>
<p>Examining the previous functions, notice that <strong class="source-inline">AddOne(int &amp;arg)</strong> takes a reference to an <strong class="source-inline">int</strong> as a formal parameter, while <strong class="source-inline">AddOne(int *arg)</strong> takes a pointer to an <strong class="source-inline">int</strong> as a formal parameter. These functions are overloaded. The types of their actual parameters will determine which version is called.</p>
<p>Now let’s <a id="_idIndexMarker254"/>consider <strong class="source-inline">Display(int &amp;arg)</strong>. This function takes a reference to an integer. Notice that object (not pointer) notation is used to print <strong class="source-inline">arg</strong> within this function’s definition. </p>
<p>Now, let’s <a id="_idIndexMarker255"/>examine the remainder of this program:</p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;
using std::flush;
<strong class="bold">void AddOne(int &amp;);</strong>    // function prototypes
void AddOne(int *);
<strong class="bold">void Display(int &amp;);</strong>
int main()
{
    int x = 10, *y = nullptr;
    y = new int;    // allocate y's memory
    *y = 15;        // dereference y to assign a value
    <strong class="bold">Display(x);</strong>
    <strong class="bold">Display(*y);</strong>
 
    <strong class="bold">AddOne(x);</strong>    // calls ref. version (with an object) 
    <strong class="bold">AddOne(*y);</strong>   // also calls reference version 
    <strong class="bold">Display(x);</strong>   // Based on prototype, we see we are 
    <strong class="bold">Display(*y);</strong>  // passing by ref. Without prototype, 
                  // we may have guessed it was by value.
    AddOne(&amp;x);   // calls pointer version
    AddOne(y);    // also calls pointer version
    <strong class="bold">Display(x);</strong>
    <strong class="bold">Display(*y);</strong>
    delete y;     // relinquish y's memory
    return 0;
}</pre>
<p>Notice the <a id="_idIndexMarker256"/>function prototypes at the top <a id="_idIndexMarker257"/>of this program segment. They will match the function definitions in the previous segment of code. Now, in the <strong class="source-inline">main()</strong> function, we declare and initialize <strong class="source-inline">int x = 10;</strong> and declare a pointer <strong class="source-inline">int *y;</strong>. We allocate the memory for <strong class="source-inline">y</strong> using <strong class="source-inline">new()</strong> and then assign a value by dereferencing the pointer with <strong class="source-inline">*y = 15;</strong>. We print out the respective values of <strong class="source-inline">x</strong> and <strong class="source-inline">*y</strong> as a baseline using successi<a id="_idTextAnchor203"/><a id="_idTextAnchor204"/>ve calls to <strong class="source-inline">Display()</strong>.</p>
<p>Next, we call <strong class="source-inline">AddOne(x)</strong> followed by <strong class="source-inline">AddOne(*y)</strong>. Variable <strong class="source-inline">x</strong> is declared to be an integer and <strong class="source-inline">*y</strong> refers to the integer pointed to by <strong class="source-inline">y</strong>. In both cases, we are passing integers as actual parameters to the version of the overloaded function with the signature <strong class="source-inline">void AddOne(int &amp;);</strong>. In both cases, the formal parameters will be changed in the function, as we are passing by reference. We can verify this when their respective values are next printed using successive calls to <strong class="source-inline">Display()</strong>. Note that in the function call <strong class="source-inline">AddOne(x);</strong>, the reference to the actual parameter <strong class="source-inline">x</strong> is established by the formal parameter <strong class="source-inline">arg</strong> (in the function’s parameter list) at the time of the function call. </p>
<p>In comparison, we then call <strong class="source-inline">AddOne(&amp;x);</strong> followed by <strong class="source-inline">AddOne(y);</strong>. In both cases, we are calling the overloaded version of this function with the signature <strong class="source-inline">void AddOne(int *);</strong>. In each case, we are passing a copy of an address as the actual parameter to the function. Naturally, <strong class="source-inline">&amp;x</strong> is the address of variable <strong class="source-inline">x</strong>, so this works. Likewise, <strong class="source-inline">y</strong> itself is an address – it is declared as a pointer variable. We again verify that their respective values are again changed with two calls to <strong class="source-inline">Display()</strong>.</p>
<p>Notice, in each call to <strong class="source-inline">Display()</strong>, we pass an object of type <strong class="source-inline">int</strong>. Looking at the function call alone, we cannot determine whether this function will take an <strong class="source-inline">int</strong> as an actual parameter (which would imply the value could not be changed), or an <strong class="source-inline">int &amp;</strong> as an actual parameter (which would imply that the value could be modified). Either of these is <a id="_idIndexMarker258"/>a possibility. However, by looking <a id="_idIndexMarker259"/>at the function prototype, we can clearly see that this function takes an <strong class="source-inline">int &amp;</strong> as a parameter, and from this, we understand that the parameter may likely be modified. This is one of the many reasons function prototypes are helpful. </p>
<p>Here is the output for the full program example:</p>
<p class="source-code">10 15 11 16 12 17</p>
<p>Now, let’s add to our discussion of using references with functions by using references as return values from functions.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor205"/>Using references as return values from functions</h2>
<p>Functions <a id="_idIndexMarker260"/>may return references <a id="_idIndexMarker261"/>to data via their return statements. We will see a requirement to return data by reference when we overload operators for user defined types in <a href="B19087_12.xhtml#_idTextAnchor526"><em class="italic">Chapter 12</em></a>, <em class="italic">Friends and Operator Overloading</em>. With operator overloading, returning a value from a function using a pointer will not be an option to preserve the operator’s original syntax. We must return a reference (or a reference qualified with <strong class="source-inline">const</strong>); this will also allow overloaded operators to enjoy cascaded use. Additionally, understanding how to return objects by reference will be useful as we explore the C++ Standard Template Library in <a href="B19087_14.xhtml#_idTextAnchor595"><em class="italic">Chapter 14</em></a>, <em class="italic">Understanding STL Basics</em>.</p>
<p>When returning a reference via the return statement of a function, be sure that the memory that is referred to will persist after the function call is completed. Do <strong class="bold">not</strong> return a reference to a local variable defined on the stack within the function; this memory will be popped off the stack the moment the function completes. </p>
<p>Since we cannot return a reference to a local variable within the function, and since returning a reference to an external variable is pointless, you may ask where the data that we return a reference to will reside. This data will inevitably be on the heap. Heap memory will exist past the extent of the function call. In most circumstances, the heap memory will have been allocated elsewhere; however, on rare occasions, the memory may have been allocated within this function. In this unusual situation, you must remember to relinquish the allocated heap memory when it is no longer required.</p>
<p>Deleting <a id="_idIndexMarker262"/>heap memory through a reference (versus pointer) variable will require you to use the address-of operator, <strong class="source-inline">&amp;</strong>, to pass <a id="_idIndexMarker263"/>the required address to operator <strong class="source-inline">delete()</strong>. Even though reference variables contain the address of the object they are referencing, the use of a reference identifier is always in its dereferenced state. It is <strong class="bold">rare</strong> that the need may arise to delete memory using a reference variable; we will discuss a meaningful (yet rare) example in <a href="B19087_10.xhtml#_idTextAnchor454"><em class="italic">Chapter 10</em></a>, <em class="italic">Implementing Association, A<a id="_idTextAnchor206"/>ggregation, and Composition</em>.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The following example illustrates syntactically how to return a reference from a function, which you will utilize when we overload operators to allow their cascaded use, for example. However, it is not recommended to use references to return newly allocated heap memory (in most cases, the heap memory will have been allocated elsewhere). It is a common convention to use references to signal to other programmers that there is no need for memory management for that variable. Nevertheless, rare scenarios for such deletions via references may be seen in existing code (as with the aforementioned rare usage with associations), so it is useful to see how such a rare deletion may be done.</p>
<p>Let’s see an example to illustrate the mechanics of using a reference as a <a id="_idTextAnchor207"/>return value from a function:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex4.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex4.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using <a id="_idTextAnchor208"/>std::cout;
using std::endl;
<strong class="bold">int &amp;CreateId();</strong>  // function prototype
         <a id="_idTextAnchor209"/>         
int main()    
{
    <strong class="bold">int &amp;id1 = CreateId();</strong>  // reference established
    <strong class="bold">int &amp;id2 = CreateId();</strong>
    cout &lt;&lt; "Id1: " &lt;&lt; id1 &lt;&lt; " Id2: " &lt;&lt; id2 &lt;&lt; endl;
    delete &amp;id1; // Here, '&amp;' is address-of, not reference
    delete &amp;id2; // to calculate address to pass delete()
    return 0;  // It is unusual to delete in fashion shown,
}          // using the addr. of a ref. Also, deleting in 
           // a diff. scope than alloc. can be error prone
<strong class="bold">int &amp;CreateId()</strong>   // Function returns a reference to an int
{
    static int count = 100;  // initialize with first id 
    int *memory = new int;
    *memory = count++;  // use count as id, then increment
    <strong class="bold">return *memory;</strong>
}</pre>
<p>In this <a id="_idIndexMarker264"/>example, we see <strong class="source-inline">int &amp;CreateId();</strong> prototyped <a id="_idIndexMarker265"/>towards the top of the program. This tells us that <strong class="source-inline">CreateId()</strong> will return a reference to an integer. The return value must be used to initialize a variable of type <strong class="source-inline">int &amp;</strong>. </p>
<p>Toward the bottom of the program, we see the function definition for <strong class="source-inline">CreateId()</strong>. Notice that this function first declares a <strong class="source-inline">static</strong> counter, which is initialized exactly once to <strong class="source-inline">100</strong>. Because this local variable is <strong class="source-inline">static</strong>, it will preserve its value from function call to function call. We then increment this counter by one a few lines later. The static variable, <strong class="source-inline">count</strong>, will be used as a basis to generate a unique ID. </p>
<p>Next, in <strong class="source-inline">CreateId()</strong>, we allocate space for an integer on the heap and point to it using the local variable <strong class="source-inline">memory</strong>. We then load <strong class="source-inline">*memory</strong> with the value of <strong class="source-inline">count</strong> and then increase <strong class="source-inline">count</strong> for the next time we enter this function. We then use <strong class="source-inline">*memory</strong> as the return value of this function. Notice that <strong class="source-inline">*memory</strong> is an integer (the one pointed to on the heap by the variable <strong class="source-inline">memory</strong>). When we return it from the function, it is returned <a id="_idIndexMarker266"/>as a reference to that integer. When <a id="_idIndexMarker267"/>returning a reference from a function, always ensure that the memory that is referenced exists beyond the extent of the function.</p>
<p>Now, let’s look at our <strong class="source-inline">main()</strong> function. Here, we initialize a reference variable <strong class="source-inline">id1 </strong>with the return value of our first call to <strong class="source-inline">CreateId()</strong> in the following function call and initialization: <strong class="source-inline">int &amp;id1 = CreateId();</strong>. Note that the reference <strong class="source-inline">id1</strong> must be initialized when it is declared, and we have met that requirement with the aforementioned line of code.</p>
<p>We repeat this process with <strong class="source-inline">id2</strong>, initializing this reference with the return value of <strong class="source-inline">CreateId()</strong>. We then print both <strong class="source-inline">id1</strong> and <strong class="source-inline">id2</strong>. By printing both <strong class="source-inline">id1</strong> and <strong class="source-inline">id2</strong>, you can see that each ID variable has its own memory and maintains its own data values.</p>
<p>Next, we must remember to deallocate the memory that <strong class="source-inline">CreateId()</strong> allocated on our behalf. We must use operator <strong class="source-inline">delete()</strong>. Wait, operator <strong class="source-inline">delete()</strong> expects a pointer to the memory that will be deleted. Variables <strong class="source-inline">id1</strong> and <strong class="source-inline">id2</strong> are both references, not pointers. True, they each contain an address because each is inherently implemented as a pointer, but any use of their respective identifiers is always in a dereferenced state. To circumvent this dilemma, we simply take the address of reference variables <strong class="source-inline">id1</strong> and <strong class="source-inline">id2</strong> prior to calling <strong class="source-inline">delete()</strong>, such as <strong class="source-inline">delete &amp;id1;</strong>. It is <strong class="bold">rare</strong> that you would need to delete memory via a reference variable, but now you know how to do so should the need arise.</p>
<p>The output for this example is as follows:</p>
<p class="source-code">Id1: 100 Id2: 101</p>
<p>Now that we understand how references can be used within parameters to functions and as return values from functions, let’s move forward by exam<a id="_idTextAnchor210"/>ining further reference nuances.</p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor211"/>Using the const qualifier with references</h1>
<p>The <strong class="source-inline">const</strong> qualifier can be used to qualify the data in which references are initialized or <em class="italic">refer to</em>. We can also use <strong class="source-inline">const</strong> qualified references as arguments to functions and as return values from functions. </p>
<p>It is important <a id="_idIndexMarker268"/>to understand that a reference <a id="_idIndexMarker269"/>is implemented as a constant pointer in C++. That is, the address contained within the reference variable is a fixed address. This explains why a reference variable must be initialized to the object to which it will refer, and may not later be updated using an assignment. This also explains why constant qualifying the reference itself (and not just the data that it refers to) does not make sense. This variety of <strong class="source-inline">const</strong> qualification is already implied with its underlying implementation.</p>
<p>Let’s take a look at these various scenarios using <strong class="source-inline">const</strong> with references.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor212"/>Using references to constant objects</h2>
<p>The <strong class="source-inline">const</strong> qualifier can be used to indicate that the data to which references are initialized are <a id="_idIndexMarker270"/>unmodifiable. In this fashion, the alias <a id="_idIndexMarker271"/>always refers to a fixed piece of memory, and the value of that variable may not be changed using the alias itself. The reference, once specified as constant, implies that neither the reference nor its value may be changed. Again, the reference itself may not be changed due to its underlying implementation as a constant qualified pointer. A <strong class="source-inline">const</strong> qualified reference may not be used as an <em class="italic">l-value</em> in any assignment. </p>
<p class="callout-heading">Note</p>
<p class="callout">Recall, an <strong class="bold">l-value</strong> is a value <a id="_idIndexMarker272"/>that can be modified and that occurs on the left-hand side of an assignment.</p>
<p>Let’s introduce a simple example to understand the situation:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex5.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with<span id="_idTextAnchor213"/>-CPP/blob/main/Chapter04/Chp4-Ex5.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;
using std::endl;
int main()
{
   int x = 5;
   <strong class="bold">const int &amp;refInt = x;</strong>
   cout &lt;&lt; x &lt;&lt; " " &lt;&lt; <strong class="bold">refInt</strong> &lt;&lt; endl;
   <strong class="bold">// refInt = 6;  // Illegal -- refInt is const</strong> 
   x = 7;   <strong class="bold">// we can inadvertently change refInt</strong>
   cout &lt;&lt; x &lt;&lt; " " &lt;&lt; <strong class="bold">refInt</strong> &lt;&lt; endl;
   return 0;
}</pre>
<p>In the previous example, notice that we declare <strong class="source-inline">int x = 5;</strong> and then we establish a constant reference <a id="_idIndexMarker273"/>to that integer with the declaration: <strong class="source-inline">const int &amp;refInt = x;</strong>. Next, we print out both values for a baseline <a id="_idIndexMarker274"/>and notice that they are identical. This makes sense; they reference the same integer memory.</p>
<p>Next, in the commented-out piece of code, <strong class="source-inline">//refInt = 6;</strong>, we try to modify the data that the reference refers to. Because <strong class="source-inline">refInt</strong> is qualified as <strong class="source-inline">const</strong>, this is illegal; this is the reason why we commented out this line of code.</p>
<p>However, on the following line of code, we assign <strong class="source-inline">x</strong> a value of <strong class="source-inline">7</strong>. Since <strong class="source-inline">refInt</strong> refers to this same memory, its value will also be modified. Wait, isn’t <strong class="source-inline">refInt</strong> constant? Yes, by qualifying <strong class="source-inline">refInt</strong> as <strong class="source-inline">const</strong>, we are indicating that its value will not be modified using the identifier <strong class="source-inline">refInt</strong>. This memory can still be modified using <strong class="source-inline">x</strong>.</p>
<p>But wait, isn’t this a problem? No, if <strong class="source-inline">refInt</strong> truly wants to refer to something unmodifiable, it can instead initialize itself with a <strong class="source-inline">const int</strong>, not an <strong class="source-inline">int</strong>. This subtle point is something to remember in C++ so you can write code for exactly the scenario you intend <a id="_idIndexMarker275"/>to have, understanding the significance <a id="_idIndexMarker276"/>and consequences of each choice.</p>
<p>The output for this example is as follows:</p>
<p class="source-code">5 5</p>
<p class="source-code">7 7</p>
<p>Next, let’s see a variation on the <strong class="source-inline">const</strong> qualification theme.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor214"/>Using pointers to constant objects as function arguments and as return types from functions</h2>
<p>Using <strong class="source-inline">const</strong> qualification with function parameters cannot just allow the speed of passing <a id="_idIndexMarker277"/>an argument by reference, but <a id="_idIndexMarker278"/>the safety of passing an argument by value. It is a useful feature in C++.</p>
<p>A <a id="_idIndexMarker279"/>function that takes <a id="_idIndexMarker280"/>a reference to an object as a parameter often has less overhead than a comparable version of the function that takes a copy of an object as a parameter. This most notably occurs when the object type that would be otherwise copied on the stack is large. Passing a reference as a formal parameter is speedier, yet permits the actual parameter to be potentially modified in the scope of the function. Passing a reference to a constant object as a function argument provides both speed and safety for the argument in question. The reference qualified as <strong class="source-inline">const</strong> in the parameter list simply may not be an <em class="italic">l-value</em> in the scope of the function in question. </p>
<p>The same benefit of <strong class="source-inline">const</strong> qualified references exists for the return value from a function. Constant qualifying the data referenced insists that the caller of the function must also store the return value in a reference to a constant object, ensuring the object may not be modified.</p>
<p>Let’s <a id="_idIndexMarker281"/>take <a id="_idIndexMarker282"/>a look <a id="_idIndexMarker283"/>at an <a id="_idIndexMarker284"/>example:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex6.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex6.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;
using std::cin;
using std::endl;
struct collection
{
    int x;
    float y;
};
<strong class="bold">void Update(collection &amp;);</strong>   // function prototypes
<strong class="bold">void Print(const collection &amp;);</strong>
int main()
{
    collection collect1, *collect2 = nullptr;
    collect2 = new collection;  // allocate mem. from heap
    <strong class="bold">Update(collect1);</strong>  // a ref to the object is passed
    <strong class="bold">Update(*collect2);</strong> // same here: *collect2 is an object
    <strong class="bold">Print(collect1);</strong>  
    <strong class="bold">Print(*collect2);</strong>
    delete collect2;   // delete heap memory
    return 0;
}
<strong class="bold">void Update(collection &amp;c)</strong>
{
    cout &lt;&lt; "Enter &lt;int&gt; and &lt;float&gt; members: ";
    cin &gt;&gt; c.x &gt;&gt; c.y;
}
    
<strong class="bold">void Print(const collection &amp;c)</strong>
{
    cout &lt;&lt; "x member: " &lt;&lt; c.x;
    cout &lt;&lt; "   y member: " &lt;&lt; c.y &lt;&lt; endl;
}</pre>
<p>In <a id="_idIndexMarker285"/>this example, we first define <a id="_idIndexMarker286"/>a simple <strong class="source-inline">struct</strong> <strong class="source-inline">collection</strong> with data members <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong>. Next, we prototype <strong class="source-inline">Update(collection &amp;);</strong> and <strong class="source-inline">Print(const collection &amp;);</strong>. Notice that <strong class="source-inline">Print()</strong> constant qualifies the data being referenced as the input parameter. This means <a id="_idIndexMarker287"/>that this function <a id="_idIndexMarker288"/>will enjoy the speed of passing this parameter by reference, and the safety of passing the parameter by value.</p>
<p>Notice, towards the end of the program, we see the definitions for both <strong class="source-inline">Update()</strong> and <strong class="source-inline">Print()</strong>. Both take references as arguments, however, the parameter to <strong class="source-inline">Print()</strong> is constant qualified: <strong class="source-inline">void Print(const collection &amp;);</strong>. Notice that both functions use the <strong class="source-inline">.</strong> (member selection) notation within each function body to access the relevant data members.</p>
<p>In <strong class="source-inline">main()</strong>, we declare two variables, <strong class="source-inline">collect1</strong> of type <strong class="source-inline">collection</strong>, and <strong class="source-inline">collect2</strong>, which is a pointer to a <strong class="source-inline">collection</strong> (and whose memory is subsequently allocated). We call <strong class="source-inline">Update()</strong> for both <strong class="source-inline">collect1</strong> and <strong class="source-inline">*collect2</strong>, and in each case, a reference to the applicable object is passed to the <strong class="source-inline">Update()</strong> function. In the case of <strong class="source-inline">collect2</strong>, which is a pointer variable, the actual parameter must first dereference <strong class="source-inline">*collect2</strong> to go to the object being referenced before calling this function.</p>
<p>Finally, in <strong class="source-inline">main()</strong>, we call <strong class="source-inline">Print()</strong> successively for both <strong class="source-inline">collect1</strong> and <strong class="source-inline">*collect2</strong>. Here, <strong class="source-inline">Print()</strong> will reference each object serving as a formal parameter as <a id="_idIndexMarker289"/>constant qualified referenced <a id="_idIndexMarker290"/>data, ensuring <a id="_idIndexMarker291"/>that no <a id="_idIndexMarker292"/>modifications of either input parameter are possible within the scope of the <strong class="source-inline">Print<a id="_idTextAnchor215"/>()</strong> function.</p>
<p>Here is the output to accompany our example:</p>
<p class="source-code">Enter x and y members: 33 23.77</p>
<p class="source-code">Enter x and y members: 10 12.11</p>
<p class="source-code">x member: 33   y member: 23.77</p>
<p class="source-code">x member: 10   y member: 12.11</p>
<p>Now that we have an understanding of when <strong class="source-inline">const</strong> qualified references are useful, let’s take a look at when we can use references in lieu of pointers, and when we cannot.</p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor216"/>Realizing underlying implementation and restrictions</h1>
<p>References <a id="_idIndexMarker293"/>can ease the notation required for indirect referencing. However, there are situations in which references simply cannot take the place of pointers. To understand these situations, it is useful to review the underlying implementation of a reference in C++. </p>
<p>References are implemented as constant pointers, hence they must be initialized. Once initialized, references may not refer to a different object (though the value of the object being referenced can be changed). </p>
<p>To understand the implementation, let’s consider a sample reference declaration: <strong class="source-inline">int &amp;intVar = x;</strong>. From an implementation aspect, it is as though the former variable declaration is instead declared as <strong class="source-inline">int *const intVar = &amp;x;</strong>. Note that the <strong class="source-inline">&amp;</strong> symbol shown on the left-hand side of an initialization takes on the meaning of reference, whereas the <strong class="source-inline">&amp;</strong> symbol shown on the right-hand side of an initialization or assignment implies address-of. These two declarations illustrate how a reference is defined versus its underlying implementation.</p>
<p>Even though <a id="_idIndexMarker294"/>a reference is implemented as a constant pointer, the usage of the reference variable is as if the underlying constant pointer has been dereferenced. For this reason, you cannot initialize a reference with a <strong class="source-inline">nullptr</strong> – not only can a <strong class="source-inline">nullptr</strong> not be dereferenced but since references can only be initialized and not reset, the opportunity would be lost to establish the reference variable to refer to a meaningful object. This also holds true for references to pointers. </p>
<p>Next, let’s understand in which situations we cannot use references.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor217"/>Understanding when we must use pointers instead of references</h2>
<p>Based on the underlying implementation of references (as <strong class="source-inline">const</strong> pointers), most of the restrictions for reference <a id="_idIndexMarker295"/>usage make sense. For example, references to references are generally not allowed; each level of indirection would need to be initialized upfront and that often takes multiple steps, such as when using pointers. However, we <a id="_idIndexMarker296"/>will see <strong class="bold">r-value references</strong> (<strong class="source-inline">&amp;&amp;</strong>) in <a href="B19087_15.xhtml#_idTextAnchor655"><em class="italic">Chapter 15</em></a>, <em class="italic">Testing Classes and Components</em>, where we will examine various <em class="italic">move</em> operations. Arrays of references are also not permitted (each element would need to be initialized immediately); nonetheless, arrays of pointers are always an option. Also, pointers to references are not permitted; however, references to pointers are permitted (as are pointers to pointers). </p>
<p>Let’s take a look at the mechanics of an interesting allowable reference case that we have not yet explored:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex7.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex7.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;   
using std::cout;
using std::endl;
int main()
{
    int *ptr = new int;
    *ptr = 20;
    <strong class="bold">int *&amp;refPtr = ptr;</strong>  // establish a reference to a ptr
    cout &lt;&lt; *ptr &lt;&lt; " " &lt;&lt; <strong class="bold">*refPtr</strong> &lt;&lt; endl; 
    delete ptr;
    return 0;
}</pre>
<p>In this <a id="_idIndexMarker297"/>example, we declare <strong class="source-inline">int *ptr;</strong> and then allocate the memory for <strong class="source-inline">ptr</strong> (consolidated on one line). We then assign a value of <strong class="source-inline">20</strong> to <strong class="source-inline">*p</strong>.</p>
<p>Next, we declare <strong class="source-inline">int *&amp;refPtr = ptr;</strong>, which is a reference to a pointer of type <strong class="source-inline">int</strong>. It helps to read the declaration from right to left. As such, we use <strong class="source-inline">ptr</strong> to initialize <strong class="source-inline">refPtr</strong>, which is a reference to a pointer to an <strong class="source-inline">int</strong>. In this case, the two types match; <strong class="source-inline">ptr</strong> is a pointer to an <strong class="source-inline">int</strong>, so <strong class="source-inline">refPtr</strong> must also then reference a pointer to an <strong class="source-inline">int</strong>. We then print out the value of both <strong class="source-inline">*ptr</strong> and <strong class="source-inline">*refPtr</strong> and can see that they are the same.</p>
<p>Here is the output to accompany our program:</p>
<p class="source-code">20 20</p>
<p>With this example, we have seen yet another interesting use of references. We also understand the restrictions placed upon using references, all of which are driven by their underlying implementation.</p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor218"/>Summary</h1>
<p>In this chapter, we have learned numerous aspects of C++ references. We have taken the time to understand reference basics, such as declaring and initializing reference variables to existing objects, as well as how to access reference components for basic and user defined types.</p>
<p>We have seen how to utilize references in a meaningful fashion with functions, both as input parameters and as a return value. We have also seen when it is reasonable to apply the <strong class="source-inline">const</strong> qualifier to references, as well as seen how this concept can be combined with parameters and return values from functions. Lastly, we have seen the underlying implementation of references. This has helped explain some of the restrictions references encompass, as well as understand which cases of indirect addressing will require the use of pointers instead of references. </p>
<p>As with pointers, all of the skills using references from this chapter will be used freely in the upcoming chapters. C++ allows programmers to have a more convenient notation for indirect addressing using references; however, programmers are expected to utilize either for indirect addressing with relative ease. </p>
<p>Finally, you are now ready to move forward to <a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Classes in Detail</em>, in which we begin the object-oriented features of C++. This is what we have been waiting for; let’s g<a id="_idTextAnchor219"/>et started!</p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor220"/>Questions</h1>
<ol>
<li>Modify and augment your C++ program from <a href="B19087_03.xhtml#_idTextAnchor118"><em class="italic">Chapter 3</em></a>, <em class="italic">Indirect Addressing – Pointers</em>, <em class="italic">Question 1</em> as follows:<ol><li>Overload your <strong class="source-inline">ReadData()</strong> function with a version that accepts a <strong class="source-inline">Student &amp;</strong> parameter to allow <strong class="source-inline">firstName</strong>, <strong class="source-inline">lastName</strong>, <strong class="source-inline">currentCourseEnrolled</strong>, and <strong class="source-inline">gpa</strong> to be entered from the keyboard within the function.</li><li>Replace the <strong class="source-inline">Print()</strong> function that takes a <strong class="source-inline">Student</strong> from your previous solution to instead take a <strong class="source-inline">const</strong> <strong class="source-inline">Student &amp;</strong> as a parameter for <strong class="source-inline">Print()</strong>.</li><li>Create variables of type <strong class="source-inline">Student</strong> and of type <strong class="source-inline">Student *</strong> in <strong class="source-inline">main()</strong>. Now, call the various versions of <strong class="source-inline">ReadData()</strong>, and <strong class="source-inline">Print()</strong>. Do the pointer variables necessarily need to call the versions of these functions that accept pointers, and do the non-pointer variables necessarily need to call the versions of these functions that accept references? Why or why not?</li></ol></li>
</ol>
</div>
<div>
<div id="_idContainer022">
</div>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer023">
<h1 id="_idParaDest-98"><a id="_idTextAnchor221"/>Part 2: Implementing Object-Oriented Concepts in C++</h1>
<p>The goal of this part is to understand how to implement OO designs using both C++ language features and proven programming techniques. C++ can be used for many paradigms of coding; programmers must strive to program in an OO fashion in C++ (it’s not automatic). This is the largest section of the book, as understanding how to map language features and implementation techniques to OO concepts is paramount. </p>
<p>The initial chapter in this section explores classes in great detail, beginning by describing the OO concepts of encapsulation and information hiding. Language features such as member functions, the <strong class="source-inline">this</strong> pointer, access regions in detail, constructors in detail (including the copy constructor, the member initialization list, and in-class initialization), destructor, qualifiers on member functions (<strong class="source-inline">const</strong>, <strong class="source-inline">static</strong>, and <strong class="source-inline">inline</strong>), and qualifiers on data members (<strong class="source-inline">const </strong>and <strong class="source-inline">static</strong>) are examined in depth. </p>
<p>The next chapter in this section tackles single inheritance basics with the OO concepts of generalization and specialization, detailing inherited constructors through the member initialization list, the order of construction and destruction, and understanding inherited access regions. Final classes are explored. This chapter pushes deeper by exploring public versus protected and private base classes and how these language features change the OO meaning of inheritance.</p>
<p>The subsequent chapter delves into the OO concept of polymorphism with respect to understanding the concept as well as its implementation in C++ using virtual functions. The <strong class="source-inline">virtual</strong>, <strong class="source-inline">override</strong>, and <strong class="source-inline">final</strong> keywords are explored. Dynamic binding of an operation to a specific method is examined. The virtual function table is explored to explain runtime binding. </p>
<p>The next chapter explains abstract classes in detail, pairing the OO concept with its implementation using pure virtual functions. The OO concept of an interface (not explicitly in C++) is introduced and a method for implementation is reviewed. Casting up and down the inheritance hierarchy completes this chapter.</p>
<p>The next chapter explores multiple inheritance and the potential issues that may arise from using this feature. Virtual base classes are detailed as well as the OO concept of a discriminator to help determine whether multiple inheritance is the best design for a given scenario or if another may exist.</p>
<p>The final chapter in this section introduces the concepts of association, aggregation, and composition and how to implement these common object relationships using pointers or references, sets of pointers, or embedded objects.</p>
<p>This part comprises the following chapters:</p>
<ul>
<li><a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Classes in Detail</em></li>
<li><a href="B19087_06.xhtml#_idTextAnchor314"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Hierarchies with Single Inheritance</em></li>
<li><a href="B19087_07.xhtml#_idTextAnchor366"><em class="italic">Chapter 7</em></a>, <em class="italic">Utilizing Dynamic Binding through Polymorphism</em></li>
<li><a href="B19087_08.xhtml#_idTextAnchor399"><em class="italic">Chapter 8</em></a>, <em class="italic">Mastering Abstract Classes</em></li>
<li><a href="B19087_09.xhtml#_idTextAnchor426"><em class="italic">Chapter 9</em></a>, <em class="italic">Exploring Multiple Inheritance</em></li>
<li><a href="B19087_10.xhtml#_idTextAnchor454"><em class="italic">Chapter 10</em></a>, <em class="italic">Implementing Association, Aggregation, and Composition</em></li>
</ul>
</div>
<div>
<div id="_idContainer024">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer025">
</div>
</div>
<div class="Content" id="_idContainer026">
</div>
<div class="Basic-Text-Frame" id="_idContainer027">
<p class="hidden">Part 2: Implementing Object-Oriented Concepts in C++</p>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer028">
</div>
</div>
</div></body></html>