<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-82"><a id="_idTextAnchor188"/>4</h1>
<h1 id="_idParaDest-83"><a id="_idTextAnchor189"/>Indirect Addressing – References</h1>
<p>This chapter will examine how to utilize references in C++. References can often, but not always, be used as an alternative to pointers for indirect addressing. Though you have prior experience with indirect addressing from our last chapter using pointers, we will start at the beginning to understand C++ references.</p>
<p>References, like pointers, are a language feature you must be able to utilize with ease. Many other languages use references for indirect addressing without requiring the thorough understanding that C++ imposes to correctly utilize both pointers and references. Just as with pointers, you will see references frequently used throughout code from other programmers. You may be pleased that using references will provide notational ease when writing applications compared to pointers.</p>
<p>Unfortunately, references cannot be used as a substitute for pointers in all situations requiring indirect addressing. Therefore, a thorough understanding of indirect addressing using both pointers and references is a necessity in C++ to create successful and maintainable code.</p>
<p>The goal of this chapter will be to complement your understanding of indirect addressing using pointers with knowing how to use C++ references as an alternative. Understanding both techniques of indirect addressing will enable you to be a better programmer, to easily understand and modify others’ code, as well as to write original, mature, and competent C++ code yourself.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Reference basics – declaring, initializing, accessing, and referencing existing objects</li>
<li>Using references with functions as arguments and as return values</li>
<li>Using the <code>const</code> qualifier with references</li>
<li>Understanding underlying implementation, and when references cannot be utilized</li>
</ul>
<p>By the end of this chapter, you will understand how to declare, initialize, and access references; you will understand how to reference existing objects in memory. You will be able to use references as arguments to functions, and understand how they may be used as return values from functions.</p>
<p>You will also fathom how the <code>const</code> qualifier may apply to references as variables and be utilized with both a function’s parameters and return type. You will be able to distinguish when references can be used in lieu of pointers, and in which situations they cannot provide a substitute for pointers. These skills will be necessary in order to move forward with the next chapters in the book successfully.</p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor190"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter04">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter04</a>. Each full program example can be found in the GitHub under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <code>Chapter04</code> in a file named <code>Chp4-Ex1.cpp</code> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3ptaMRK">https://bit.ly/3ptaMRK</a>.</p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor191"/>Understanding reference basics</h1>
<p>In this section, we will revisit reference basics as well as introduce operators applicable to references, such as the reference operator <code>&amp;</code>. We will employ the reference operator (<code>&amp;</code>) to establish a <a id="_idIndexMarker235"/>reference to the existing variable. Like pointer variables, reference variables refer to memory that is defined elsewhere. </p>
<p>Using reference variables allows us to use a more straightforward notation than the notation that pointers use when using indirectly accessed memory. Many programmers appreciate the clarity in the notation of a reference versus a pointer variable. But, behind the scenes, memory must always be properly allocated and released; some portion of memory that is referenced may come from the heap. The programmer will undoubtedly need to deal with pointers for some portion of their overall code.</p>
<p>We will discern when references and pointers are interchangeable, and when they are not. Let’s get started with the basic notation for declaring and using reference variables.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor192"/>Declaring, initializing, and accessing references</h2>
<p>Let’s begin with the meaning of a reference variable. A C++ <code>&amp;</code>. A reference must be initialized (at declaration) and may never be assigned to reference another object. The reference and the initializer <a id="_idIndexMarker237"/>must be of the same type. Since the reference and the object being referenced share the same memory, either variable may be used <a id="_idIndexMarker238"/>to modify the contents of the shared memory location.</p>
<p>A reference variable, behind the scenes, can be compared to a pointer variable in that it holds the address of the variable that it is referencing. Unlike a pointer variable, any usage of the reference variable automatically dereferences the variable to go to the address that it contains; the dereference operator <code>*</code> is simply not needed with references. Dereferencing is automatic and implied with each use of a reference variable. </p>
<p>Let’s take a look at an example illustrating reference basics:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex1.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;
using std::endl;
int main()
{
    int x = 10;
    int *p = new int;   // allocate memory for ptr variable
    *p = 20;            // dereference and assign value 
    <strong class="bold">int &amp;refInt1 = x;</strong>  // reference to an intege<a id="_idTextAnchor193"/>r
    <strong class="bold">int &amp;refInt2 = *p;</strong> // also a reference to an integer
    cout &lt;&lt; x &lt;&lt; " " &lt;&lt; *p &lt;&lt; " ";
    cout &lt;&lt; refInt1 &lt;&lt; " " &lt;&lt; refInt2 &lt;&lt; endl;
    x++;      // updates x and <strong class="bold">refInt1</strong>
    (*p)++;   // updates *p and <strong class="bold">refInt2</strong>
    cout &lt;&lt; x &lt;&lt; " " &lt;&lt; *p &lt;&lt; " ";
    cout &lt;&lt; <strong class="bold">refInt1</strong> &lt;&lt; " " &lt;&lt; <strong class="bold">refInt2</strong> &lt;&lt; endl;
    <strong class="bold">refInt1++;</strong>    // updates refInt1 and x
    <strong class="bold">refInt2++;</strong>    // updates refInt2 and *p
    cout &lt;&lt; x &lt;&lt; " " &lt;&lt; *p &lt;&lt; " ";
    cout &lt;&lt; <strong class="bold">refInt1</strong> &lt;&lt; " " &lt;&lt; <strong class="bold">refInt2</strong> &lt;&lt; endl;
    delete p;       // relinquish p's memory
    return 0;
}</pre>
<p>In the <a id="_idIndexMarker239"/>preceding example, we first declare and initialize <code>int x = 10;</code> and then declare and allocate <code>int *p = new int;</code>. We then <a id="_idIndexMarker240"/>assign the integer value <code>20</code> to <code>*p.</code> </p>
<p>Next, we <a id="_idIndexMarker241"/>declare and initialize two reference variables, <code>refInt1</code> and <code>refInt2</code>. In the first reference declaration and initialization, <code>int &amp;refInt1 = x;</code>, we establish <code>refInt1</code> to refer to the variable <code>x</code>. It helps to read the reference declaration from right to left. Here, we are saying to use <code>x</code> to initialize <code>refInt1</code>, which is a reference (<code>&amp;</code>) to an integer. Notice that both the initializer, <code>x</code>, is an integer and that <code>refInt1</code> is declared to be a reference to an integer; their types match. This is important. The code will not compile if the types differ. Likewise, the declaration and initialization <code>int &amp;refInt2 = *p;</code> also establishes <code>refInt2</code> as a reference to an integer. Which one? The one pointed to by <code>p</code>. This is why <code>p</code> is dereferenced using <code>*</code> to go to the integer i<a id="_idTextAnchor194"/>tself.</p>
<p>Now, we print out <code>x</code>, <code>*p</code>, <code>refInt1</code>, and <code>refInt2</code>; we can verify that <code>x</code> and <code>refInt1</code> have the same value of <code>10</code>, and <code>*p</code> and <code>refInt2</code> also have the same value of <code>20</code>.</p>
<p>Next, using <a id="_idIndexMarker242"/>the original variables, we increment both <code>x</code> and <code>*p</code> by one. Not only does this increment the values of <code>x</code> and <code>*p</code>, but the values <a id="_idIndexMarker243"/>of <code>refInt1</code> and <code>refInt2</code>. Repeating the printing <a id="_idIndexMarker244"/>of these four values, we again notice that <code>x</code> and <code>refInt1</code> have the value of <code>11</code>, while <code>*p</code> and <code>refInt2</code> have the value of <code>21</code>.</p>
<p>Finally, we use the reference variables to increment the shared memory. We increment both <code>refInt1</code> and <code>*refint2</code> by one and this also increments the values of the original variables <code>x</code> and <code>*p</code>. This is because the memory is one and the same between the original variable and the reference to that variable. That is, the reference can be thought of as an alias to the original variable. We conclude the program by again printing out the four variables.</p>
<p>Here is the output:</p>
<pre>10 20 10 20
11 21 11 21
12 <a id="_idTextAnchor195"/>22 12 22</pre>
<p class="callout-heading">Important note</p>
<p class="callout">Remember, a reference variable must be initialized to the variable it will refer to. The reference may never be assigned to another variable. More precisely, we cannot rebind the reference to another entity. The reference and its initializer must be the same type.</p>
<p>Now that we have a handle on how to declare simple references, let’s take a more complete look at referencing existing objects, such as those to user defin<a id="_idTextAnchor196"/>ed types.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor197"/>Referencing existing objects of user defined types </h2>
<p>Should a reference to an object of a <code>struct</code> or <code>class</code> type be defined, the object being <a id="_idIndexMarker245"/>referenced is simply accessed using the <code>.</code> (member selection) operator. Again, it is not necessary (such as it is with pointers) to first use the dereference operator to go to the object being referenced before choosing the desired member.</p>
<p>Let’s take <a id="_idIndexMarker246"/>a look at an example in which we reference a user defined type:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex2.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;
using std::endl;
using std::string;
class Student    // very simple class – we will add to it 
{                // in our next chapter
public:
    string name;
    float gpa;
};
int main()
{
    Student s1;
    <strong class="bold">Student &amp;sRef = s1;</strong>  // establish a reference to s1
    s1.name = "Katje Katz";   // fill in the data
    s1.gpa = 3.75;
    cout &lt;&lt; s1.name &lt;&lt; " has GPA: " &lt;&lt; s1.gpa &lt;&lt; endl; 
    cout &lt;&lt; <strong class="bold">sRef.name</strong> &lt;&lt; " has GPA: " &lt;&lt; <strong class="bold">sRef.gpa</strong> &lt;&lt; endl; 
    <strong class="bold">sRef.name</strong> = "George Katz";  // change the data
    <strong class="bold">sRef.gpa</strong> = 3.25;
    cout &lt;&lt; s1.name &lt;&lt; " has GPA: " &lt;&lt; s1.gpa &lt;&lt; endl; 
    cout &lt;&lt; <strong class="bold">sRef.name</strong> &lt;&lt; " has GPA: " &lt;&lt; <strong class="bold">sRef.gpa</strong> &lt;&lt; endl; 
    return 0;
}</pre>
<p>In the <a id="_idIndexMarker247"/>first part of this program, we define a user defined type, <code>Student</code>, using a <code>class</code>. Next, we declare a variable <code>s1</code> of type <code>Student</code> using <code>Student s1;</code>. Now, we declare and initialize a reference to a <code>Student</code> using <code>Student &amp;sRef = s1;</code>. Here, we declare <code>sRef</code> to reference a specific <code>Student</code>, namely <code>s1</code>. Notice that both <code>s1</code> is of type <code>Student</code> and the reference type of <code>sRef</code> is also that of type <code>Student</code>.</p>
<p>Now, we load some initial data into <code>s1.name</code> and <code>s1.gpa</code> using two simple assignments. Consequently, this alters the value of <code>sRef</code> since <code>s1</code> and <code>sRef</code> refer to the same memory. That is, <code>sRef</code> is an alias for <code>s1</code>.</p>
<p>We print out various data members for <code>s1</code> and <code>sRef</code> and notice that they contain the same values. </p>
<p>Now, we load new values into <code>sRef.name</code> and <code>sRef.gpa</code> using assignments. Similarly, we print out various data members for <code>s1</code> and <code>sRef</code> and notice that again, the values for both have changed. Again, we can see that they reference the <a id="_idTextAnchor198"/>same memory.</p>
<p>The output to accompany this program is as follows:</p>
<pre>Katje Katz has GPA: 3.75
Katje Katz has GPA: 3.75
George Katz has GPA: 3.25
George Katz has GPA: 3.25</pre>
<p>Let’s now <a id="_idIndexMarker248"/>move forward with our understanding of references by considering their usage <a id="_idTextAnchor199"/>in functions.</p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor200"/>Using references with functions</h1>
<p>So far, we have minimally demonstrated references by using them to establish an alias for an existing variable. Instead, let’s put forth a meaningful use of references, such as when they are used in function calls. We know most functions in C++ will take arguments, and we have seen many examples in the previous <a id="_idIndexMarker249"/>chapters illustrating function prototypes and function definitions. Now, let’s augment our understanding of functions by passing references as arguments to functions, and using references as return values from functions.</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor201"/>Passing references as arguments to functions</h2>
<p>References may be used as arguments to functions to achieve call-by-reference, rather than call-by-value, parameter passing. References can alleviate the need for pointer notation <a id="_idIndexMarker250"/>in the scope of the function in question as well as in the call to that function. Object or <code>.</code> (member selection) notation is used to access <code>struct</code> or <code>class</code> members for formal parameters that are references.</p>
<p>In order to <a id="_idIndexMarker251"/>modify the contents of a variable passed as an argument to a function, a reference (or pointer) to that argument must be used as a function parameter. Just as with a pointer, when a reference is passed to a function, a copy of the address representing the reference is passed to the function. However, within the function, any usage of a formal parameter that is a reference will automatically and implicitly be dereferenced, allowing the user to use object rather than pointer notation. As with passing a pointer variable, passing a reference variable to a function will allow the memory referenced by that parameter to be modified. </p>
<p>When examining a function call (apart from its prototype), it will not be obvious whether an object passed to that function is passed by value or by reference. That is, whether the entire object will be copied on the stack or whether a reference to that object will instead be passed on the stack. This is because object notation is used when manipulating references, and the function calls for these two scenarios will use the same syntax.</p>
<p>Diligent use of function prototypes will solve the mystery of what a function definition looks like and whether its arguments are objects or references to objects. Remember, a function definition may be defined in a separate file from any calls to that function, and not be easily available to view. Note that this ambiguity does not come up with pointers specified in a function call; it is immediately obvious that an address is being sent to a function based on how the variable is declared.  </p>
<p>Let’s take <a id="_idIndexMarker252"/>a few minutes to understand an example illustrating passing references as arguments to functions. Here, we will <a id="_idIndexMarker253"/>begin by examining three functions, which contribute to the following ful<a id="_idTextAnchor202"/>l program example:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex3.cpp</a></p>
<pre class="source-code">
void AddOne(<strong class="bold">int &amp;arg</strong>)   // These two fns. are overloaded
{
    arg++;
}
void AddOne(int *arg)   // Overloaded function definition
{
    (*arg)++;
}
void Display(<strong class="bold">int &amp;arg</strong>)  // Function parameter establishes 
                       // a reference to arg
{
    cout &lt;&lt; arg &lt;&lt; " " &lt;&lt; flush;
}</pre>
<p>Examining the previous functions, notice that <code>AddOne(int &amp;arg)</code> takes a reference to an <code>int</code> as a formal parameter, while <code>AddOne(int *arg)</code> takes a pointer to an <code>int</code> as a formal parameter. These functions are overloaded. The types of their actual parameters will determine which version is called.</p>
<p>Now let’s <a id="_idIndexMarker254"/>consider <code>Display(int &amp;arg)</code>. This function takes a reference to an integer. Notice that object (not pointer) notation is used to print <code>arg</code> within this function’s definition. </p>
<p>Now, let’s <a id="_idIndexMarker255"/>examine the remainder of this program:</p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;
using std::flush;
<strong class="bold">void AddOne(int &amp;);</strong>    // function prototypes
void AddOne(int *);
<strong class="bold">void Display(int &amp;);</strong>
int main()
{
    int x = 10, *y = nullptr;
    y = new int;    // allocate y's memory
    *y = 15;        // dereference y to assign a value
    <strong class="bold">Display(x);</strong>
    <strong class="bold">Display(*y);</strong>
 
    <strong class="bold">AddOne(x);</strong>    // calls ref. version (with an object) 
    <strong class="bold">AddOne(*y);</strong>   // also calls reference version 
    <strong class="bold">Display(x);</strong>   // Based on prototype, we see we are 
    <strong class="bold">Display(*y);</strong>  // passing by ref. Without prototype, 
                  // we may have guessed it was by value.
    AddOne(&amp;x);   // calls pointer version
    AddOne(y);    // also calls pointer version
    <strong class="bold">Display(x);</strong>
    <strong class="bold">Display(*y);</strong>
    delete y;     // relinquish y's memory
    return 0;
}</pre>
<p>Notice the <a id="_idIndexMarker256"/>function prototypes at the top <a id="_idIndexMarker257"/>of this program segment. They will match the function definitions in the previous segment of code. Now, in the <code>main()</code> function, we declare and initialize <code>int x = 10;</code> and declare a pointer <code>int *y;</code>. We allocate the memory for <code>y</code> using <code>new()</code> and then assign a value by dereferencing the pointer with <code>*y = 15;</code>. We print out the respective values of <code>x</code> and <code>*y</code> as a baseline using successi<a id="_idTextAnchor203"/><a id="_idTextAnchor204"/>ve calls to <code>Display()</code>.</p>
<p>Next, we call <code>AddOne(x)</code> followed by <code>AddOne(*y)</code>. Variable <code>x</code> is declared to be an integer and <code>*y</code> refers to the integer pointed to by <code>y</code>. In both cases, we are passing integers as actual parameters to the version of the overloaded function with the signature <code>void AddOne(int &amp;);</code>. In both cases, the formal parameters will be changed in the function, as we are passing by reference. We can verify this when their respective values are next printed using successive calls to <code>Display()</code>. Note that in the function call <code>AddOne(x);</code>, the reference to the actual parameter <code>x</code> is established by the formal parameter <code>arg</code> (in the function’s parameter list) at the time of the function call. </p>
<p>In comparison, we then call <code>AddOne(&amp;x);</code> followed by <code>AddOne(y);</code>. In both cases, we are calling the overloaded version of this function with the signature <code>void AddOne(int *);</code>. In each case, we are passing a copy of an address as the actual parameter to the function. Naturally, <code>&amp;x</code> is the address of variable <code>x</code>, so this works. Likewise, <code>y</code> itself is an address – it is declared as a pointer variable. We again verify that their respective values are again changed with two calls to <code>Display()</code>.</p>
<p>Notice, in each call to <code>Display()</code>, we pass an object of type <code>int</code>. Looking at the function call alone, we cannot determine whether this function will take an <code>int</code> as an actual parameter (which would imply the value could not be changed), or an <code>int &amp;</code> as an actual parameter (which would imply that the value could be modified). Either of these is <a id="_idIndexMarker258"/>a possibility. However, by looking <a id="_idIndexMarker259"/>at the function prototype, we can clearly see that this function takes an <code>int &amp;</code> as a parameter, and from this, we understand that the parameter may likely be modified. This is one of the many reasons function prototypes are helpful. </p>
<p>Here is the output for the full program example:</p>
<pre>10 15 11 16 12 17</pre>
<p>Now, let’s add to our discussion of using references with functions by using references as return values from functions.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor205"/>Using references as return values from functions</h2>
<p>Functions <a id="_idIndexMarker260"/>may return references <a id="_idIndexMarker261"/>to data via their return statements. We will see a requirement to return data by reference when we overload operators for user defined types in <a href="B19087_12.xhtml#_idTextAnchor526"><em class="italic">Chapter 12</em></a>, <em class="italic">Friends and Operator Overloading</em>. With operator overloading, returning a value from a function using a pointer will not be an option to preserve the operator’s original syntax. We must return a reference (or a reference qualified with <code>const</code>); this will also allow overloaded operators to enjoy cascaded use. Additionally, understanding how to return objects by reference will be useful as we explore the C++ Standard Template Library in <a href="B19087_14.xhtml#_idTextAnchor595"><em class="italic">Chapter 14</em></a>, <em class="italic">Understanding STL Basics</em>.</p>
<p>When returning a reference via the return statement of a function, be sure that the memory that is referred to will persist after the function call is completed. Do <strong class="bold">not</strong> return a reference to a local variable defined on the stack within the function; this memory will be popped off the stack the moment the function completes. </p>
<p>Since we cannot return a reference to a local variable within the function, and since returning a reference to an external variable is pointless, you may ask where the data that we return a reference to will reside. This data will inevitably be on the heap. Heap memory will exist past the extent of the function call. In most circumstances, the heap memory will have been allocated elsewhere; however, on rare occasions, the memory may have been allocated within this function. In this unusual situation, you must remember to relinquish the allocated heap memory when it is no longer required.</p>
<p>Deleting <a id="_idIndexMarker262"/>heap memory through a reference (versus pointer) variable will require you to use the address-of operator, <code>&amp;</code>, to pass <a id="_idIndexMarker263"/>the required address to operator <code>delete()</code>. Even though reference variables contain the address of the object they are referencing, the use of a reference identifier is always in its dereferenced state. It is <strong class="bold">rare</strong> that the need may arise to delete memory using a reference variable; we will discuss a meaningful (yet rare) example in <a href="B19087_10.xhtml#_idTextAnchor454"><em class="italic">Chapter 10</em></a>, <em class="italic">Implementing Association, A<a id="_idTextAnchor206"/>ggregation, and Composition</em>.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The following example illustrates syntactically how to return a reference from a function, which you will utilize when we overload operators to allow their cascaded use, for example. However, it is not recommended to use references to return newly allocated heap memory (in most cases, the heap memory will have been allocated elsewhere). It is a common convention to use references to signal to other programmers that there is no need for memory management for that variable. Nevertheless, rare scenarios for such deletions via references may be seen in existing code (as with the aforementioned rare usage with associations), so it is useful to see how such a rare deletion may be done.</p>
<p>Let’s see an example to illustrate the mechanics of using a reference as a <a id="_idTextAnchor207"/>return value from a function:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex4.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex4.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using <a id="_idTextAnchor208"/>std::cout;
using std::endl;
<strong class="bold">int &amp;CreateId();</strong>  // function prototype
         <a id="_idTextAnchor209"/>         
int main()    
{
    <strong class="bold">int &amp;id1 = CreateId();</strong>  // reference established
    <strong class="bold">int &amp;id2 = CreateId();</strong>
    cout &lt;&lt; "Id1: " &lt;&lt; id1 &lt;&lt; " Id2: " &lt;&lt; id2 &lt;&lt; endl;
    delete &amp;id1; // Here, '&amp;' is address-of, not reference
    delete &amp;id2; // to calculate address to pass delete()
    return 0;  // It is unusual to delete in fashion shown,
}          // using the addr. of a ref. Also, deleting in 
           // a diff. scope than alloc. can be error prone
<strong class="bold">int &amp;CreateId()</strong>   // Function returns a reference to an int
{
    static int count = 100;  // initialize with first id 
    int *memory = new int;
    *memory = count++;  // use count as id, then increment
    <strong class="bold">return *memory;</strong>
}</pre>
<p>In this <a id="_idIndexMarker264"/>example, we see <code>int &amp;CreateId();</code> prototyped <a id="_idIndexMarker265"/>towards the top of the program. This tells us that <code>CreateId()</code> will return a reference to an integer. The return value must be used to initialize a variable of type <code>int &amp;</code>. </p>
<p>Toward the bottom of the program, we see the function definition for <code>CreateId()</code>. Notice that this function first declares a <code>static</code> counter, which is initialized exactly once to <code>100</code>. Because this local variable is <code>static</code>, it will preserve its value from function call to function call. We then increment this counter by one a few lines later. The static variable, <code>count</code>, will be used as a basis to generate a unique ID. </p>
<p>Next, in <code>CreateId()</code>, we allocate space for an integer on the heap and point to it using the local variable <code>memory</code>. We then load <code>*memory</code> with the value of <code>count</code> and then increase <code>count</code> for the next time we enter this function. We then use <code>*memory</code> as the return value of this function. Notice that <code>*memory</code> is an integer (the one pointed to on the heap by the variable <code>memory</code>). When we return it from the function, it is returned <a id="_idIndexMarker266"/>as a reference to that integer. When <a id="_idIndexMarker267"/>returning a reference from a function, always ensure that the memory that is referenced exists beyond the extent of the function.</p>
<p>Now, let’s look at our <code>main()</code> function. Here, we initialize a reference variable <code>id1 </code>with the return value of our first call to <code>CreateId()</code> in the following function call and initialization: <code>int &amp;id1 = CreateId();</code>. Note that the reference <code>id1</code> must be initialized when it is declared, and we have met that requirement with the aforementioned line of code.</p>
<p>We repeat this process with <code>id2</code>, initializing this reference with the return value of <code>CreateId()</code>. We then print both <code>id1</code> and <code>id2</code>. By printing both <code>id1</code> and <code>id2</code>, you can see that each ID variable has its own memory and maintains its own data values.</p>
<p>Next, we must remember to deallocate the memory that <code>CreateId()</code> allocated on our behalf. We must use operator <code>delete()</code>. Wait, operator <code>delete()</code> expects a pointer to the memory that will be deleted. Variables <code>id1</code> and <code>id2</code> are both references, not pointers. True, they each contain an address because each is inherently implemented as a pointer, but any use of their respective identifiers is always in a dereferenced state. To circumvent this dilemma, we simply take the address of reference variables <code>id1</code> and <code>id2</code> prior to calling <code>delete()</code>, such as <code>delete &amp;id1;</code>. It is <strong class="bold">rare</strong> that you would need to delete memory via a reference variable, but now you know how to do so should the need arise.</p>
<p>The output for this example is as follows:</p>
<pre>Id1: 100 Id2: 101</pre>
<p>Now that we understand how references can be used within parameters to functions and as return values from functions, let’s move forward by exam<a id="_idTextAnchor210"/>ining further reference nuances.</p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor211"/>Using the const qualifier with references</h1>
<p>The <code>const</code> qualifier can be used to qualify the data in which references are initialized or <em class="italic">refer to</em>. We can also use <code>const</code> qualified references as arguments to functions and as return values from functions. </p>
<p>It is important <a id="_idIndexMarker268"/>to understand that a reference <a id="_idIndexMarker269"/>is implemented as a constant pointer in C++. That is, the address contained within the reference variable is a fixed address. This explains why a reference variable must be initialized to the object to which it will refer, and may not later be updated using an assignment. This also explains why constant qualifying the reference itself (and not just the data that it refers to) does not make sense. This variety of <code>const</code> qualification is already implied with its underlying implementation.</p>
<p>Let’s take a look at these various scenarios using <code>const</code> with references.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor212"/>Using references to constant objects</h2>
<p>The <code>const</code> qualifier can be used to indicate that the data to which references are initialized are <a id="_idIndexMarker270"/>unmodifiable. In this fashion, the alias <a id="_idIndexMarker271"/>always refers to a fixed piece of memory, and the value of that variable may not be changed using the alias itself. The reference, once specified as constant, implies that neither the reference nor its value may be changed. Again, the reference itself may not be changed due to its underlying implementation as a constant qualified pointer. A <code>const</code> qualified reference may not be used as an <em class="italic">l-value</em> in any assignment. </p>
<p class="callout-heading">Note</p>
<p class="callout">Recall, an <strong class="bold">l-value</strong> is a value <a id="_idIndexMarker272"/>that can be modified and that occurs on the left-hand side of an assignment.</p>
<p>Let’s introduce a simple example to understand the situation:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex5.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex5.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;
using std::endl;
int main()
{
   int x = 5;
   <strong class="bold">const int &amp;refInt = x;</strong>
   cout &lt;&lt; x &lt;&lt; " " &lt;&lt; <strong class="bold">refInt</strong> &lt;&lt; endl;
   <strong class="bold">// refInt = 6;  // Illegal -- refInt is const</strong> 
   x = 7;   <strong class="bold">// we can inadvertently change refInt</strong>
   cout &lt;&lt; x &lt;&lt; " " &lt;&lt; <strong class="bold">refInt</strong> &lt;&lt; endl;
   return 0;
}</pre>
<p>In the previous example, notice that we declare <code>int x = 5;</code> and then we establish a constant reference <a id="_idIndexMarker273"/>to that integer with the declaration: <code>const int &amp;refInt = x;</code>. Next, we print out both values for a baseline <a id="_idIndexMarker274"/>and notice that they are identical. This makes sense; they reference the same integer memory.</p>
<p>Next, in the commented-out piece of code, <code>//refInt = 6;</code>, we try to modify the data that the reference refers to. Because <code>refInt</code> is qualified as <code>const</code>, this is illegal; this is the reason why we commented out this line of code.</p>
<p>However, on the following line of code, we assign <code>x</code> a value of <code>7</code>. Since <code>refInt</code> refers to this same memory, its value will also be modified. Wait, isn’t <code>refInt</code> constant? Yes, by qualifying <code>refInt</code> as <code>const</code>, we are indicating that its value will not be modified using the identifier <code>refInt</code>. This memory can still be modified using <code>x</code>.</p>
<p>But wait, isn’t this a problem? No, if <code>refInt</code> truly wants to refer to something unmodifiable, it can instead initialize itself with a <code>const int</code>, not an <code>int</code>. This subtle point is something to remember in C++ so you can write code for exactly the scenario you intend <a id="_idIndexMarker275"/>to have, understanding the significance <a id="_idIndexMarker276"/>and consequences of each choice.</p>
<p>The output for this example is as follows:</p>
<pre>5 5
7 7</pre>
<p>Next, let’s see a variation on the <code>const</code> qualification theme.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor214"/>Using pointers to constant objects as function arguments and as return types from functions</h2>
<p>Using <code>const</code> qualification with function parameters cannot just allow the speed of passing <a id="_idIndexMarker277"/>an argument by reference, but <a id="_idIndexMarker278"/>the safety of passing an argument by value. It is a useful feature in C++.</p>
<p>A <a id="_idIndexMarker279"/>function that takes <a id="_idIndexMarker280"/>a reference to an object as a parameter often has less overhead than a comparable version of the function that takes a copy of an object as a parameter. This most notably occurs when the object type that would be otherwise copied on the stack is large. Passing a reference as a formal parameter is speedier, yet permits the actual parameter to be potentially modified in the scope of the function. Passing a reference to a constant object as a function argument provides both speed and safety for the argument in question. The reference qualified as <code>const</code> in the parameter list simply may not be an <em class="italic">l-value</em> in the scope of the function in question. </p>
<p>The same benefit of <code>const</code> qualified references exists for the return value from a function. Constant qualifying the data referenced insists that the caller of the function must also store the return value in a reference to a constant object, ensuring the object may not be modified.</p>
<p>Let’s <a id="_idIndexMarker281"/>take <a id="_idIndexMarker282"/>a look <a id="_idIndexMarker283"/>at an <a id="_idIndexMarker284"/>example:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex6.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex6.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;
using std::cin;
using std::endl;
struct collection
{
    int x;
    float y;
};
<strong class="bold">void Update(collection &amp;);</strong>   // function prototypes
<strong class="bold">void Print(const collection &amp;);</strong>
int main()
{
    collection collect1, *collect2 = nullptr;
    collect2 = new collection;  // allocate mem. from heap
    <strong class="bold">Update(collect1);</strong>  // a ref to the object is passed
    <strong class="bold">Update(*collect2);</strong> // same here: *collect2 is an object
    <strong class="bold">Print(collect1);</strong>  
    <strong class="bold">Print(*collect2);</strong>
    delete collect2;   // delete heap memory
    return 0;
}
<strong class="bold">void Update(collection &amp;c)</strong>
{
    cout &lt;&lt; "Enter &lt;int&gt; and &lt;float&gt; members: ";
    cin &gt;&gt; c.x &gt;&gt; c.y;
}
    
<strong class="bold">void Print(const collection &amp;c)</strong>
{
    cout &lt;&lt; "x member: " &lt;&lt; c.x;
    cout &lt;&lt; "   y member: " &lt;&lt; c.y &lt;&lt; endl;
}</pre>
<p>In <a id="_idIndexMarker285"/>this example, we first define <a id="_idIndexMarker286"/>a simple <code>struct</code> <code>collection</code> with data members <code>x</code> and <code>y</code>. Next, we prototype <code>Update(collection &amp;);</code> and <code>Print(const collection &amp;);</code>. Notice that <code>Print()</code> constant qualifies the data being referenced as the input parameter. This means <a id="_idIndexMarker287"/>that this function <a id="_idIndexMarker288"/>will enjoy the speed of passing this parameter by reference, and the safety of passing the parameter by value.</p>
<p>Notice, towards the end of the program, we see the definitions for both <code>Update()</code> and <code>Print()</code>. Both take references as arguments, however, the parameter to <code>Print()</code> is constant qualified: <code>void Print(const collection &amp;);</code>. Notice that both functions use the <code>.</code> (member selection) notation within each function body to access the relevant data members.</p>
<p>In <code>main()</code>, we declare two variables, <code>collect1</code> of type <code>collection</code>, and <code>collect2</code>, which is a pointer to a <code>collection</code> (and whose memory is subsequently allocated). We call <code>Update()</code> for both <code>collect1</code> and <code>*collect2</code>, and in each case, a reference to the applicable object is passed to the <code>Update()</code> function. In the case of <code>collect2</code>, which is a pointer variable, the actual parameter must first dereference <code>*collect2</code> to go to the object being referenced before calling this function.</p>
<p>Finally, in <code>main()</code>, we call <code>Print()</code> successively for both <code>collect1</code> and <code>*collect2</code>. Here, <code>Print()</code> will reference each object serving as a formal parameter as <a id="_idIndexMarker289"/>constant qualified referenced <a id="_idIndexMarker290"/>data, ensuring <a id="_idIndexMarker291"/>that no <a id="_idIndexMarker292"/>modifications of either input parameter are possible within the scope of the <code>Print<a id="_idTextAnchor215"/>()</code> function.</p>
<p>Here is the output to accompany our example:</p>
<pre>Enter x and y members: 33 23.77
Enter x and y members: 10 12.11
x member: 33   y member: 23.77
x member: 10   y member: 12.11</pre>
<p>Now that we have an understanding of when <code>const</code> qualified references are useful, let’s take a look at when we can use references in lieu of pointers, and when we cannot.</p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor216"/>Realizing underlying implementation and restrictions</h1>
<p>References <a id="_idIndexMarker293"/>can ease the notation required for indirect referencing. However, there are situations in which references simply cannot take the place of pointers. To understand these situations, it is useful to review the underlying implementation of a reference in C++. </p>
<p>References are implemented as constant pointers, hence they must be initialized. Once initialized, references may not refer to a different object (though the value of the object being referenced can be changed). </p>
<p>To understand the implementation, let’s consider a sample reference declaration: <code>int &amp;intVar = x;</code>. From an implementation aspect, it is as though the former variable declaration is instead declared as <code>int *const intVar = &amp;x;</code>. Note that the <code>&amp;</code> symbol shown on the left-hand side of an initialization takes on the meaning of reference, whereas the <code>&amp;</code> symbol shown on the right-hand side of an initialization or assignment implies address-of. These two declarations illustrate how a reference is defined versus its underlying implementation.</p>
<p>Even though <a id="_idIndexMarker294"/>a reference is implemented as a constant pointer, the usage of the reference variable is as if the underlying constant pointer has been dereferenced. For this reason, you cannot initialize a reference with a <code>nullptr</code> – not only can a <code>nullptr</code> not be dereferenced but since references can only be initialized and not reset, the opportunity would be lost to establish the reference variable to refer to a meaningful object. This also holds true for references to pointers. </p>
<p>Next, let’s understand in which situations we cannot use references.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor217"/>Understanding when we must use pointers instead of references</h2>
<p>Based on the underlying implementation of references (as <code>const</code> pointers), most of the restrictions for reference <a id="_idIndexMarker295"/>usage make sense. For example, references to references are generally not allowed; each level of indirection would need to be initialized upfront and that often takes multiple steps, such as when using pointers. However, we <a id="_idIndexMarker296"/>will see <code>&amp;&amp;</code>) in <a href="B19087_15.xhtml#_idTextAnchor655"><em class="italic">Chapter 15</em></a>, <em class="italic">Testing Classes and Components</em>, where we will examine various <em class="italic">move</em> operations. Arrays of references are also not permitted (each element would need to be initialized immediately); nonetheless, arrays of pointers are always an option. Also, pointers to references are not permitted; however, references to pointers are permitted (as are pointers to pointers). </p>
<p>Let’s take a look at the mechanics of an interesting allowable reference case that we have not yet explored:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex7.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter04/Chp4-Ex7.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;   
using std::cout;
using std::endl;
int main()
{
    int *ptr = new int;
    *ptr = 20;
    <strong class="bold">int *&amp;refPtr = ptr;</strong>  // establish a reference to a ptr
    cout &lt;&lt; *ptr &lt;&lt; " " &lt;&lt; <strong class="bold">*refPtr</strong> &lt;&lt; endl; 
    delete ptr;
    return 0;
}</pre>
<p>In this <a id="_idIndexMarker297"/>example, we declare <code>int *ptr;</code> and then allocate the memory for <code>ptr</code> (consolidated on one line). We then assign a value of <code>20</code> to <code>*p</code>.</p>
<p>Next, we declare <code>int *&amp;refPtr = ptr;</code>, which is a reference to a pointer of type <code>int</code>. It helps to read the declaration from right to left. As such, we use <code>ptr</code> to initialize <code>refPtr</code>, which is a reference to a pointer to an <code>int</code>. In this case, the two types match; <code>ptr</code> is a pointer to an <code>int</code>, so <code>refPtr</code> must also then reference a pointer to an <code>int</code>. We then print out the value of both <code>*ptr</code> and <code>*refPtr</code> and can see that they are the same.</p>
<p>Here is the output to accompany our program:</p>
<pre>20 20</pre>
<p>With this example, we have seen yet another interesting use of references. We also understand the restrictions placed upon using references, all of which are driven by their underlying implementation.</p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor218"/>Summary</h1>
<p>In this chapter, we have learned numerous aspects of C++ references. We have taken the time to understand reference basics, such as declaring and initializing reference variables to existing objects, as well as how to access reference components for basic and user defined types.</p>
<p>We have seen how to utilize references in a meaningful fashion with functions, both as input parameters and as a return value. We have also seen when it is reasonable to apply the <code>const</code> qualifier to references, as well as seen how this concept can be combined with parameters and return values from functions. Lastly, we have seen the underlying implementation of references. This has helped explain some of the restrictions references encompass, as well as understand which cases of indirect addressing will require the use of pointers instead of references. </p>
<p>As with pointers, all of the skills using references from this chapter will be used freely in the upcoming chapters. C++ allows programmers to have a more convenient notation for indirect addressing using references; however, programmers are expected to utilize either for indirect addressing with relative ease. </p>
<p>Finally, you are now ready to move forward to <a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Classes in Detail</em>, in which we begin the object-oriented features of C++. This is what we have been waiting for; let’s g<a id="_idTextAnchor219"/>et started!</p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor220"/>Questions</h1>
<ol>
<li>Modify and augment your C++ program from <a href="B19087_03.xhtml#_idTextAnchor118"><em class="italic">Chapter 3</em></a>, <em class="italic">Indirect Addressing – Pointers</em>, <em class="italic">Question 1</em> as follows:<ol><li>Overload your <code>ReadData()</code> function with a version that accepts a <code>Student &amp;</code> parameter to allow <code>firstName</code>, <code>lastName</code>, <code>currentCourseEnrolled</code>, and <code>gpa</code> to be entered from the keyboard within the function.</li><li>Replace the <code>Print()</code> function that takes a <code>Student</code> from your previous solution to instead take a <code>const</code> <code>Student &amp;</code> as a parameter for <code>Print()</code>.</li><li>Create variables of type <code>Student</code> and of type <code>Student *</code> in <code>main()</code>. Now, call the various versions of <code>ReadData()</code>, and <code>Print()</code>. Do the pointer variables necessarily need to call the versions of these functions that accept pointers, and do the non-pointer variables necessarily need to call the versions of these functions that accept references? Why or why not?</li></ol></li>
</ol>
</div>
<div><div></div>
</div>
</div>

<div><div><h1 id="_idParaDest-98"><a id="_idTextAnchor221"/>Part 2: Implementing Object-Oriented Concepts in C++</h1>
<p>The goal of this part is to understand how to implement OO designs using both C++ language features and proven programming techniques. C++ can be used for many paradigms of coding; programmers must strive to program in an OO fashion in C++ (it’s not automatic). This is the largest section of the book, as understanding how to map language features and implementation techniques to OO concepts is paramount. </p>
<p>The initial chapter in this section explores classes in great detail, beginning by describing the OO concepts of encapsulation and information hiding. Language features such as member functions, the <code>this</code> pointer, access regions in detail, constructors in detail (including the copy constructor, the member initialization list, and in-class initialization), destructor, qualifiers on member functions (<code>const</code>, <code>static</code>, and <code>inline</code>), and qualifiers on data members (<code>const </code>and <code>static</code>) are examined in depth. </p>
<p>The next chapter in this section tackles single inheritance basics with the OO concepts of generalization and specialization, detailing inherited constructors through the member initialization list, the order of construction and destruction, and understanding inherited access regions. Final classes are explored. This chapter pushes deeper by exploring public versus protected and private base classes and how these language features change the OO meaning of inheritance.</p>
<p>The subsequent chapter delves into the OO concept of polymorphism with respect to understanding the concept as well as its implementation in C++ using virtual functions. The <code>virtual</code>, <code>override</code>, and <code>final</code> keywords are explored. Dynamic binding of an operation to a specific method is examined. The virtual function table is explored to explain runtime binding. </p>
<p>The next chapter explains abstract classes in detail, pairing the OO concept with its implementation using pure virtual functions. The OO concept of an interface (not explicitly in C++) is introduced and a method for implementation is reviewed. Casting up and down the inheritance hierarchy completes this chapter.</p>
<p>The next chapter explores multiple inheritance and the potential issues that may arise from using this feature. Virtual base classes are detailed as well as the OO concept of a discriminator to help determine whether multiple inheritance is the best design for a given scenario or if another may exist.</p>
<p>The final chapter in this section introduces the concepts of association, aggregation, and composition and how to implement these common object relationships using pointers or references, sets of pointers, or embedded objects.</p>
<p>This part comprises the following chapters:</p>
<ul>
<li><a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Classes in Detail</em></li>
<li><a href="B19087_06.xhtml#_idTextAnchor314"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Hierarchies with Single Inheritance</em></li>
<li><a href="B19087_07.xhtml#_idTextAnchor366"><em class="italic">Chapter 7</em></a>, <em class="italic">Utilizing Dynamic Binding through Polymorphism</em></li>
<li><a href="B19087_08.xhtml#_idTextAnchor399"><em class="italic">Chapter 8</em></a>, <em class="italic">Mastering Abstract Classes</em></li>
<li><a href="B19087_09.xhtml#_idTextAnchor426"><em class="italic">Chapter 9</em></a>, <em class="italic">Exploring Multiple Inheritance</em></li>
<li><a href="B19087_10.xhtml#_idTextAnchor454"><em class="italic">Chapter 10</em></a>, <em class="italic">Implementing Association, Aggregation, and Composition</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div></div>
<div><p class="hidden">Part 2: Implementing Object-Oriented Concepts in C++</p>
</div>
<div><div></div>
</div>
</div></body></html>