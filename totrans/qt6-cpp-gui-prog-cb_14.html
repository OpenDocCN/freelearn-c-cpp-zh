<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-284"><a id="_idTextAnchor284"/>14</h1>
<h1 id="_idParaDest-285"><a id="_idTextAnchor285"/>Performance Optimization</h1>
<p>Qt 6 is known for its optimized performance. However, performance issues may still occur if your code is poorly written. There are many ways we can identify these issues and fix them before releasing the software to our users.</p>
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Optimizing forms and C++</li>
<li>Profiling and optimizing QML</li>
<li>Rendering and animation</li>
</ul>
<h1 id="_idParaDest-286"><a id="_idTextAnchor286"/>Technical requirements</h1>
<p>The technical requirements for this chapter include Qt 6.6.1 MinGW 64 bit, Qt Creator 12.0.2, and Windows 11. All the code used in this chapter can be downloaded from the following GitHub repository at <a href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter14">https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter14</a>.</p>
<h1 id="_idParaDest-287"><a id="_idTextAnchor287"/>Optimizing forms and C++</h1>
<p>It’s <a id="_idIndexMarker931"/>very important to learn how to optimize your form-based Qt 6 applications that are built with C++. The best way to do that is to learn how to measure and compare the different methods that are used and decide which one works the best for you.</p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor288"/>How to do it…</h2>
<p>Let’s get started by following these steps:</p>
<ol>
<li>Let’s<a id="_idIndexMarker932"/> create a <code>mainwindow.cpp</code>. After that, add the following headers to the top of the source code:<pre class="source-code">
#include &lt;QPushButton&gt;
#include &lt;QGridLayout&gt;
#include &lt;QMessageBox&gt;
#include &lt;QElapsedTimer&gt;
#include &lt;QDebug&gt;</pre></li> <li>Create a <code>QGridLayout</code> object and set its parent to <code>centralWidget</code>:<pre class="source-code">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);
    <code>QElapsedTimer</code> object. We will be using this to measure the performance of our next operation:<pre class="source-code">
    QElapsedTimer* time = new QElapsedTimer;
    time-&gt;start();</pre></li> <li>We will use two loops to add 600 push buttons to our grid layout and connect all of them to a lambda function when clicked. We will then measure the elapsed time and print out the result, as follows:<pre class="source-code">
    for (int i = 0; i &lt; 40; ++i) {
        for (int j = 0; j &lt; 15; ++j) {
            QPushButton* newWidget = new QPushButton();
            newWidget-&gt;setText("Button");
            layout-&gt;addWidget(newWidget, i, j);
            connect(newWidget, QPushButton::clicked, [this]() {
            QMessageBox::information(this, "Clicked", "Button has been clicked!");
            });
        }
    }
    qDebug() &lt;&lt; "Test GUI:" &lt;&lt; time-&gt;elapsed() &lt;&lt; "msec";</pre></li> <li>If we <a id="_idIndexMarker933"/>build and run the project now, we will see a window filled with lots of buttons. When we click on one of them, a message box will pop up on the screen. It only took around nine milliseconds on my computer to create and lay out all of the 600 buttons on the main window. There is also no performance issue when we move the window around or resize it, which is quite impressive. It proves that Qt 6 can handle this pretty well. However, please be aware that your users might be using older machines, and you might want to be extra careful when designing your user interface:</li>
</ol>
<div><div><img alt="Figure 14.1 – Spawn 600 buttons on a Qt window" src="img/B20976_14_001.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – Spawn 600 buttons on a Qt window</p>
<ol>
<li value="6">Let’s<a id="_idIndexMarker934"/> add a style sheet to each of the buttons, like so:<pre class="source-code">
QPushButton* newWidget = new QPushButton();
newWidget-&gt;setText("Button");
newWidget-&gt;setStyleSheet("background-color: blue; color: white;");
layout-&gt;addWidget(newWidget, i, j);</pre></li> <li>Build and run the program again. This time, it took roughly 75 milliseconds to set up the GUI. This means that the style sheet does have some impact on the performance of your program:</li>
</ol>
<div><div><img alt="Figure 14.2 – Apply the style sheet to all 600 buttons" src="img/B20976_14_002.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – Apply the style sheet to all 600 buttons</p>
<ol>
<li value="8">Once you <a id="_idIndexMarker935"/>are done with that, let’s do some performance tests on different types of C++ containers. Open up <code>main.cpp</code> and add the following headers:<pre class="source-code">
#include "mainwindow.h"
#include &lt;QApplication&gt;
#include &lt;QDebug&gt;
#include &lt;QElapsedTimer&gt;
#include &lt;vector&gt;
#include &lt;QVector&gt;</pre></li> <li>Create<a id="_idIndexMarker936"/> a <code>testArray()</code> function before the <code>main()</code> function:<pre class="source-code">
int testArray(int count) {
    int sum = 0;
    int *myarray = new int[count];
    for (int i = 0; i &lt; count; ++i)
        myarray[i] = i;
    for (int j = 0; j &lt; count; ++j)
        sum += myarray[j];
    delete [] myarray;
    return sum;
}</pre></li> <li>Create another function called <code>testVector()</code>, as follows:<pre class="source-code">
int testVector(int count) {
    int sum = 0;
    std::vector&lt;int&gt; myarray;
    for (int i = 0; i &lt; count; ++i)
        myarray.push_back(i);
    for (int j = 0; j &lt; count; ++j)
        sum += myarray.at(j);
    return sum;
}</pre></li> <li>Once you are done with that, proceed to create yet another function called <code>testQtVector()</code>:<pre class="source-code">
int testQtVector(int count) {
    int sum = 0;
    QVector&lt;int&gt; myarray;
    for (int i = 0; i &lt; count; ++i)
        myarray.push_back(i);
    for (int j = 0; j &lt; count; ++j)
        sum += myarray.at(j);
    return sum;
}</pre></li> <li>Inside <a id="_idIndexMarker937"/>the <code>main()</code> function, define a <code>QElapsedTimer</code> object and an integer variable called <code>lastElapse</code>:<pre class="source-code">
int main(int argc, char *argv[]) {
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    <strong class="bold">QElapsedTimer* time = new QElapsedTimer;</strong>
    <strong class="bold">time-&gt;start();</strong>
    <strong class="bold">int lastElapse = 0;</strong></pre></li> <li>We will call the three functions we created in the previous steps to test their performance:<pre class="source-code">
    int result = testArray(100000000);
    qDebug() &lt;&lt; "Array:" &lt;&lt; (time-&gt;elapsed() - lastElapse) &lt;&lt; "msec";
    lastElapse = time-&gt;elapsed();
    int result2 = testVector(100000000);
    qDebug() &lt;&lt; "STL vector:" &lt;&lt; (time-&gt;elapsed() - lastElapse) &lt;&lt; "msec";
    lastElapse = time-&gt;elapsed();
    int result3 = testQtVector(100000000);
    qDebug() &lt;&lt; "Qt vector:" &lt;&lt; (time-&gt;elapsed() - lastElapse) &lt;&lt; "msec";
    lastElapse = time-&gt;elapsed();</pre></li> <li>Build and run the program now; we will see the performance differences between these containers. On my computer, the array took 650 milliseconds to execute, while the STL vector took roughly 3,830 milliseconds, and the Qt vector took around 5,400 milliseconds to execute.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">As a result, the array is still the container that yields the best performance, despite its lack of features compared to the other two. Surprisingly, Qt’s own vector class works slightly slower than the vector container provided by the C++ standard library.</p>
<h2 id="_idParaDest-289"><a id="_idTextAnchor289"/>How it works…</h2>
<p>When <a id="_idIndexMarker938"/>creating a <strong class="bold">Qt Widgets Application</strong> project, try to do the following to improve performance:</p>
<ul>
<li>Avoid adding too many pages to a stacked widget and filling them with widgets, as Qt needs to find all of them recursively during the rendering process and event handling, which will highly impact the program’s performance.</li>
<li>Do note that the <code>QWidget</code> class uses the Raster Engine, a software renderer, to render the widgets instead of using the GPU. However, it is lightweight enough to keep the performance good most of the time. Alternatively, you could consider using QML for your program’s GUI instead, since it is fully hardware accelerated.</li>
<li>Turn off <strong class="bold">mouseTracking</strong>, <strong class="bold">tabletTracking</strong>, and other event catching for your widgets if they do not need it. This tracking and catchings adds to the CPU usage costs of your program:</li>
</ul>
<div><div><img alt="Figure 14.3 – Disable mouseTracking and tabletTracking for optimization" src="img/B20976_14_003.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – Disable mouseTracking and tabletTracking for optimization</p>
<ul>
<li>Keep <a id="_idIndexMarker939"/>your style sheets as simple as possible. A large style sheet needs a longer time for Qt to parse the information into the rendering system, which will also impact performance.</li>
<li>Different C++ containers produce different speeds, as we showed in the preceding example. Surprisingly, Qt’s vector container is slightly slower than STL’s (the C++ standard library) vector container. Overall, the good old C++ array is still the fastest, but does not provide sorting functionality. Use what is best for your requirements.</li>
<li>For large operations, use <em class="italic">asynchronous</em> methods whenever possible as it will not stall the main process and will keep your program running smoothly.</li>
<li><em class="italic">Multi-threading</em> is<a id="_idIndexMarker940"/> really good for running different operations in parallel event loops. However, it can also become quite ugly if not done right, for example, creating and destroying threads frequently, or with inter-thread communications that are not planned well.</li>
<li>Try to avoid using the web engine unless absolutely necessary. This is because embedding a full web browser on your program is really heavy overkill, especially for a small application. You can consider using QML instead of making a hybrid application if you want to create user interface-centric software.</li>
<li>By <a id="_idIndexMarker941"/>doing performance tests as we did in the preceding example project, you can easily determine which method is the best choice for your project and how to make your program perform better.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">In Qt 5, we can use the <code>QTime</code> class to do the test as seen in this section. However, functions such as <code>start()</code> and <code>elapsed()</code> have been deprecated from the <code>QTime</code> class in Qt 6. Since Qt 6, the player must use <code>QElapsedTimer</code> to handle this.</p>
<h1 id="_idParaDest-290"><a id="_idTextAnchor290"/>Profiling and optimizing QML</h1>
<p>The QML engine in Qt 6 took advantage of hardware acceleration to make its rendering capability and performance superior to the old widgets user interface. However, this does not mean that you do not need to worry about optimization, because small performance issues may snowball into bigger problems over time and cause damage to your product’s reputation.</p>
<h2 id="_idParaDest-291"><a id="_idTextAnchor291"/>How to do it…</h2>
<p>Follow these steps to start profiling<a id="_idIndexMarker942"/> and optimizing<a id="_idIndexMarker943"/> a QML application:</p>
<ol>
<li>Let’s create a <strong class="bold">Qt Quick </strong><strong class="bold">Application</strong> project:</li>
</ol>
<div><div><img alt="Figure 14.4 – Create a Qt Quick Application project" src="img/B20976_14_004.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4 – Create a Qt Quick Application project</p>
<ol>
<li value="2">Then, go <a id="_idIndexMarker944"/>to <strong class="bold">Analyze | QML Profiler</strong> and<a id="_idIndexMarker945"/> run the <strong class="bold">QML </strong><strong class="bold">Profiler</strong> tool:</li>
</ol>
<div><div><img alt="Figure 14.5 – Run the QML Profiler to check the QML performance" src="img/B20976_14_005.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.5 – Run the QML Profiler to check the QML performance</p>
<ol>
<li value="3">Your Qt Quick project will then be run by the QML Profiler. The <strong class="bold">QML Profiler</strong> window will also appear under the code editor. Click the <strong class="bold">Stop</strong> button located at the top bar of the <strong class="bold">QML Profiler</strong> window after the program has passed the test point, which in this case meant successfully creating the empty window:</li>
</ol>
<div><div><img alt="Figure 14.6 – Stop the QML Profiler by pressing the button with the red rectangle icon" src="img/B20976_14_006.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.6 – Stop the QML Profiler by pressing the button with the red rectangle icon</p>
<ol>
<li value="4">After you<a id="_idIndexMarker946"/> stop the profiler analysis, a timeline will be <a id="_idIndexMarker947"/>displayed in the <strong class="bold">Timeline</strong> tab under the <strong class="bold">QML Profiler</strong> window. There are four tabs that you can switch between, namely <strong class="bold">Timeline</strong>, <strong class="bold">Flame Graph</strong>, <strong class="bold">Quick3D Frame</strong>, and <strong class="bold">Statistics</strong>, at the bottom of the <strong class="bold">QML </strong><strong class="bold">Profiler</strong> window:</li>
</ol>
<div><div><img alt="Figure 14.7 – You can look at different data on different tabs" src="img/B20976_14_007.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.7 – You can look at different data on different tabs</p>
<ol>
<li value="5">Let’s check out the <strong class="bold">Timeline</strong> tab. We can see six different categories under the timeline display: <strong class="bold">Scene Graph</strong>, <strong class="bold">Memory Usage</strong>, <strong class="bold">Input Events</strong>, <strong class="bold">Compiling</strong>, <strong class="bold">Creating</strong>, and <strong class="bold">Binding</strong>. These categories give us an overview of the different stages and processes of our program throughout its execution. We can also see some colorful bars displayed on the timeline. Let’s click on one of the bars under the <strong class="bold">Creating</strong> category that says <strong class="bold">QtQuick/Window</strong>. Once clicked, we will see the total duration for this operation and the location of the code displayed in a rectangular window located at the top of the QML Profiler window:</li>
</ol>
<div><div><img alt="Figure 14.8 – The Timeline tab" src="img/B20976_14_008.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.8 – The Timeline tab</p>
<ol>
<li value="6">Once you are<a id="_idIndexMarker948"/> done with that, let’s move on and open up <a id="_idIndexMarker949"/>the <strong class="bold">Flame Graph</strong> tab instead. Under the <strong class="bold">Flame Graph</strong> tab, you will see the visualization of the total time, memory, and allocation of your application in the form of percentages. You can switch between total time, memory, and allocation by clicking on the selection box that’s located at the top-right corner of the <strong class="bold">QML </strong><strong class="bold">Profiler</strong> window:</li>
</ol>
<div><div><img alt="Figure 14.9 – The Flame Graph tab" src="img/B20976_14_009.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.9 – The Flame Graph tab</p>
<ol>
<li value="7">Not only <a id="_idIndexMarker950"/>that, you will also see the percentage value <a id="_idIndexMarker951"/>displayed on your QML code editor:</li>
</ol>
<div><div><img alt="Figure 14.10 – Percentage values are shown on the right" src="img/B20976_14_010.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.10 – Percentage values are shown on the right</p>
<ol>
<li value="8">Open up the <strong class="bold">Quick3D Frame</strong> category under the <strong class="bold">QML Profiler</strong> window. This tab is where you check the performance of 3D rendering. It is currently empty because we are not doing any 3D rendering.</li>
<li>Next, let’s open up the <strong class="bold">Statistics</strong> category. This tab basically shows us information about the processes in table form:</li>
</ol>
<div><div><img alt="Figure 14.11 – The Statistics tab" src="img/B20976_14_011.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.11 – The Statistics tab</p>
<h2 id="_idParaDest-292"><a id="_idTextAnchor292"/>How it works…</h2>
<p>This is similar to what we did in the previous example project that used C++ and widgets except, this time, it is automatically analyzed by the <strong class="bold">QML Profiler</strong> tool that’s provided by Qt 6.</p>
<p>The QML Profiler not only produces the total time used for running a specific process, but also displays the memory allocation, the execution timeline of your application, and other information that gives you insight into the performance of your software.</p>
<p>By looking at the data that was analyzed by the QML Profiler, you will be able to find out which part of your code slows down the program, allowing you to fix any problems quickly.</p>
<p>There are<a id="_idIndexMarker952"/> some rules that you need to be aware of when writing <a id="_idIndexMarker953"/>QML to avoid performance bottlenecks. For instance, type conversion can sometimes be expensive, especially between types that are not closely matched (string to number, for example). Small issues like this will likely snowball into bottlenecks as your project grows larger over time.</p>
<p>Other than that, try not to use <code>id</code> for an item lookup multiple times in blocks of code that are run often, as in the following example:</p>
<pre class="source-code">
Item {
    width: 400
    height: 400
    Rectangle {
    id: rect
    anchors.fill: parent
    color: "green"
    }
    Component.onCompleted: {
        for (var i = 0; i &lt; 1000; ++i) {
            console.log("red", rect.color.r);
            console.log("green", rect.color.g);
            console.log("blue", rect.color.b);
            console.log("alpha", rect.color.a);
        }
    }</pre> <p>Instead, we can use a variable to cache the data and avoid multiple look-ups on the same item over and over again:</p>
<pre class="source-code">
Component.onCompleted: {
    var rectColor = rect.color;
    for (var i = 0; i &lt; 1000; ++i) {
        console.log("red", rectColor.r);
        console.log("green", rectColor.g);
        console.log("blue", rectColor.b);
        console.log("alpha", rectColor.a);
    }
}</pre> <p>Besides, if you<a id="_idIndexMarker954"/> change the property of a binding expression, especially<a id="_idIndexMarker955"/> in a loop, Qt will be forced to re-evaluate it repeatedly. This will cause some performance issues. Instead of doing this, the user should follow the next code snippet:</p>
<pre class="source-code">
Item {
    id: myItem
    width: 400
    height: 400
    property int myValue: 0
    Text {
        anchors.fill: parent
        text: myItem.myValue.toString()
    }
    Component.onCompleted: {
        for (var i = 0; i &lt; 1000; ++i) {
            myValue += 1;
        }
    }
}</pre> <p>Instead, we can <a id="_idIndexMarker956"/>use a temporary variable for storing the data of <code>myValue</code>, then <a id="_idIndexMarker957"/>apply the final result back to <code>myValue</code> once the loop has been completed:</p>
<pre class="source-code">
Component.onCompleted: {
    var temp = myValue;
    for (var i = 0; i &lt; 1000; ++i) {
        temp += 1;
    }
    myValue = temp;
}</pre> <p>Consider using an anchor to position your UI items instead of using bindings. Item positioning with bindings is really slow and inefficient, although it allows for maximum flexibility.</p>
<h1 id="_idParaDest-293"><a id="_idTextAnchor293"/>Rendering and animation</h1>
<p>When it <a id="_idIndexMarker958"/>comes to an application that renders graphics and <a id="_idIndexMarker959"/>animation, good performance is critical. Users can easily notice performance issues when graphics are not animated smoothly on screen. In the following example, we will look at how we can further optimize a graphics-heavy Qt Quick application.</p>
<h2 id="_idParaDest-294"><a id="_idTextAnchor294"/>How to do it…</h2>
<p>To<a id="_idIndexMarker960"/> learn how to<a id="_idIndexMarker961"/> render animation in QML, follow this example:</p>
<ol>
<li>Create a <code>tux.png</code> to our project’s resources:</li>
</ol>
<div><div><img alt="Figure 14.12 – Include main.qml and tux.png into your project resources" src="img/B20976_14_012.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.12 – Include main.qml and tux.png into your project resources</p>
<ol>
<li value="2">Open up <code>650</code> x <code>650</code>. We will also add <code>id</code> to the <code>window</code> item and name it <code>window</code>:<pre class="source-code">
Window {
    id: window
    visible: true
    width: 650
    height: 650</pre></li> <li>Add the following code inside the <code>window</code> item:<pre class="source-code">
    property int frame: 0;
    onAfterRendering: { frame++; }
    Timer {
    id: timer
    interval: 1000
    running: true
    repeat: true
    onTriggered: { frame = 0; }
}</pre></li> <li>Right<a id="_idIndexMarker962"/> after <a id="_idIndexMarker963"/>that, add <code>Repeater</code> and <code>Image</code> under it:<pre class="source-code">
    Repeater {
        model: 10
        delegate:
        Image {
        id: tux
        source: "tux.png"
        sourceSize.width: 50
        sourceSize.height: 60
        width: 50
        height: 60
        smooth: false
        antialiasing: false
        asynchronous: true</pre></li> <li>We will proceed and add the following code:<pre class="source-code">
        property double startX: Math.random() * 600;
        property double startY: Math.random() * 600;
        property double endX: Math.random() * 600;
        property double endY: Math.random() * 600;
        property double speed: Math.random() * 3000 + 1000;
        RotationAnimation on rotation{
        loops: Animation.Infinite
        from: 0
        to: 360
        duration: Math.random() * 3000 + 1000;
}</pre></li> <li>Once<a id="_idIndexMarker964"/> you are <a id="_idIndexMarker965"/>done with that, add the following code below the previous code:<pre class="source-code">
    SequentialAnimation {
        running: true
        loops: Animation.Infinite
        ParallelAnimation {
        NumberAnimation {
        target: tux
        property: "x"
        from: startX
        to: endX
        duration: speed
        easing.type: Easing.InOutQuad
    }</pre></li> <li>The preceding code animates the <code>x</code> property of the image. We need another <code>NumberAnimation</code> property to animate the <code>y</code> property:<pre class="source-code">
    NumberAnimation {
        target: tux
        property: "y"
        from: startY
        to: endY
        duration: speed
        easing.type: Easing.InOutQuad
    }
}</pre></li> <li>After that, we<a id="_idIndexMarker966"/> repeat the entire code of <code>ParallelAnimation</code>, except this time, we <a id="_idIndexMarker967"/>swap the <code>from</code> and <code>to</code> values, like so:<pre class="source-code">
    ParallelAnimation {
        NumberAnimation {
            target: tux
            property: "x"
            from: endX
            to: startX
            duration: speed
            easing.type: Easing.InOutQuad
        }</pre></li> <li>The same goes for <code>NumberAnimation</code> for the <code>y</code> property:<pre class="source-code">
        NumberAnimation {
            target: tux
            property: "y"
            from: endY
            to: startY
            duration: speed
            easing.type: Easing.InOutQuad
        }
    }</pre></li> <li>Then, we <a id="_idIndexMarker968"/>add a <code>Text</code> item for displaying the frame rate of our <a id="_idIndexMarker969"/>application:<pre class="source-code">
Text {
    property int frame: 0
    color: "red"
    text: "FPS: 0 fps"
    x: 20
    y: 20
    font.pointSize: 20</pre></li> <li>Let’s add <code>Timer</code> under <code>Text</code> and update the frame rate to display every second:<pre class="source-code">
    Timer {
        id: fpsTimer
        repeat: true
        interval: 1000
        running: true
        onTriggered: {
        parent.text = "FPS: " + frame + " fps"
        }
    }
}</pre></li> <li>If we build and run the program now, we will be able to see several penguins moving around the screen with a steady 60 fps:</li>
</ol>
<div><div><img alt="Figure 14.13 – 10 penguins floating around the window" src="img/B20976_14_013.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.13 – 10 penguins floating around the window</p>
<ol>
<li value="13">Let’s go <a id="_idIndexMarker970"/>back to our code and change the <code>model</code> property<a id="_idIndexMarker971"/> of the <code>Repeater</code> item to <code>10000</code>. Build and run the program again; you should see that your window is full of moving penguins and that the frame rate has significantly dropped to roughly 39 fps, which is not too bad, considering the amount of penguins we have:</li>
</ol>
<div><div><img alt="Figure 14.14 – 10,000 penguins floating around the window" src="img/B20976_14_014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.14 – 10,000 penguins floating around the window</p>
<ol>
<li value="14">Next, let’s <a id="_idIndexMarker972"/>go back to our source code and comment out both <a id="_idIndexMarker973"/>of the <code>sourceSize</code> properties. We also set the <code>smooth</code> and <code>antialiasing</code> properties to <code>false</code>, while setting the <code>asynchronous</code> property to <code>false</code>:<pre class="source-code">
Image {
    id: tux
    source: "tux.png"
    <strong class="bold">//sourceSize.width: 50</strong>
    <strong class="bold">//sourceSize.height: 60</strong>
    width: 50
    height: 60
    <strong class="bold">smooth: true</strong>
    <strong class="bold">antialiasing: false</strong>
    <strong class="bold">asynchronous: false</strong></pre></li> <li>Let’s build<a id="_idIndexMarker974"/> and run the program again. This time, the frame rate<a id="_idIndexMarker975"/> dropped slightly to 32 fps, but the penguins look smoother and are of better quality, even when moving:</li>
</ol>
<div><div><img alt="Figure 14.15 – Our penguins look much smoother now without slowing down too much" src="img/B20976_14_015.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.15 – Our penguins look much smoother now without slowing down too much</p>
<h2 id="_idParaDest-295"><a id="_idTextAnchor295"/>How it works…</h2>
<p>The <a id="_idIndexMarker976"/>QML engine that powers Qt Quick applications is very optimized and <a id="_idIndexMarker977"/>powerful when it comes to rendering animated graphics on screen. However, there are still some tips that we can follow to make it even faster.</p>
<p>Try and make use of the built-in features provided by Qt 6 instead of implementing your own, such as <code>Repeater</code>, <code>NumberAnimation</code>, and <code>SequentialAnimation</code>. This is because Qt 6 developers have put great effort into optimizing these features so that you don’t have to.</p>
<p>The <code>sourceSize</code> properties tell Qt to resize the image before loading it into memory so that large images do not use more memory than necessary.</p>
<p>The <code>smooth</code> property, when enabled, tells Qt to filter the image to make look it smoother when scaled or transformed from its natural size. It will not make any difference if the image is rendered at the same as its <code>sourceSize</code> value. This property will impact the performance of your application on some older hardware.</p>
<p>The <code>antialiasing</code> property tells Qt to remove the aliasing artifacts around the edge of the image and make it look smoother. This property will also impact the performance of your program.</p>
<p>The <code>asynchronous</code> property tells Qt to load the image under a low-priority thread, which means that your program will not stall when loading huge image files.</p>
<p>We used the frame rate to indicate the performance of our program. Since <code>onAfterRendering</code> always gets called on every frame, we can then accumulate the frame variable on every render. Then, we used <code>Timer</code> to reset the frame value every second.</p>
<p>Finally, we displayed the value on screen using a <code>Text</code> item.</p>
</div>
</body></html>