<html><head></head><body>
<div id="_idContainer256">
<h1 class="chapter-number" id="_idParaDest-284"><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.1.1">14</span></h1>
<h1 id="_idParaDest-285"><a id="_idTextAnchor285"/><span class="koboSpan" id="kobo.2.1">Performance Optimization</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Qt 6 is known for its optimized performance. </span><span class="koboSpan" id="kobo.3.2">However, performance issues may still occur if your code is poorly written. </span><span class="koboSpan" id="kobo.3.3">There are many ways we can identify these issues and fix them before releasing the software to </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">our users.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following recipes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Optimizing forms </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">and C++</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Profiling and </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">optimizing QML</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Rendering </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">and animation</span></span></li>
</ul>
<h1 id="_idParaDest-286"><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.13.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.14.1">The technical requirements for this chapter include Qt 6.6.1 MinGW 64 bit, Qt Creator 12.0.2, and Windows 11. </span><span class="koboSpan" id="kobo.14.2">All the code used in this chapter can be downloaded from the following GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">at </span></span><a href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter14"><span class="No-Break"><span class="koboSpan" id="kobo.16.1">https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter14</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.17.1">.</span></span></p>
<h1 id="_idParaDest-287"><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.18.1">Optimizing forms and C++</span></h1>
<p><span class="koboSpan" id="kobo.19.1">It’s </span><a id="_idIndexMarker931"/><span class="koboSpan" id="kobo.20.1">very important to learn how to optimize your form-based Qt 6 applications that are built with C++. </span><span class="koboSpan" id="kobo.20.2">The best way to do that is to learn how to measure and compare the different methods that are used and decide which one works the best </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">for you.</span></span></p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor288"/><span class="koboSpan" id="kobo.22.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.23.1">Let’s get started by following </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.25.1">Let’s</span><a id="_idIndexMarker932"/><span class="koboSpan" id="kobo.26.1"> create a </span><strong class="bold"><span class="koboSpan" id="kobo.27.1">Qt Widgets Application</span></strong><span class="koboSpan" id="kobo.28.1"> project and open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">mainwindow.cpp</span></strong><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">After that, add the following headers to the top of the </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">source code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.32.1">
#include &lt;QPushButton&gt;
#include &lt;QGridLayout&gt;
#include &lt;QMessageBox&gt;
#include &lt;QElapsedTimer&gt;
#include &lt;QDebug&gt;</span></pre></li> <li><span class="koboSpan" id="kobo.33.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">QGridLayout</span></strong><span class="koboSpan" id="kobo.35.1"> object and set its parent </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.37.1">centralWidget</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.39.1">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);
    </span><strong class="bold"><span class="koboSpan" id="kobo.40.1">QGridLayout *layout = new QGridLayout(ui-&gt;centralWidget);</span></strong></pre></li> <li><span class="koboSpan" id="kobo.41.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">QElapsedTimer</span></strong><span class="koboSpan" id="kobo.43.1"> object. </span><span class="koboSpan" id="kobo.43.2">We will be using this to measure the performance of our </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">next operation:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.45.1">
    QElapsedTimer* time = new QElapsedTimer;
    time-&gt;start();</span></pre></li> <li><span class="koboSpan" id="kobo.46.1">We will use two loops to add 600 push buttons to our grid layout and connect all of them to a lambda function when clicked. </span><span class="koboSpan" id="kobo.46.2">We will then measure the elapsed time and print out the result, </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.48.1">
    for (int i = 0; i &lt; 40; ++i) {
        for (int j = 0; j &lt; 15; ++j) {
            QPushButton* newWidget = new QPushButton();
            newWidget-&gt;setText("Button");
            layout-&gt;addWidget(newWidget, i, j);
            connect(newWidget, QPushButton::clicked, [this]() {
            QMessageBox::information(this, "Clicked", "Button has been clicked!");
            });
        }
    }
    qDebug() &lt;&lt; "Test GUI:" &lt;&lt; time-&gt;elapsed() &lt;&lt; "msec";</span></pre></li> <li><span class="koboSpan" id="kobo.49.1">If we </span><a id="_idIndexMarker933"/><span class="koboSpan" id="kobo.50.1">build and run the project now, we will see a window filled with lots of buttons. </span><span class="koboSpan" id="kobo.50.2">When we click on one of them, a message box will pop up on the screen. </span><span class="koboSpan" id="kobo.50.3">It only took around nine milliseconds on my computer to create and lay out all of the 600 buttons on the main window. </span><span class="koboSpan" id="kobo.50.4">There is also no performance issue when we move the window around or resize it, which is quite impressive. </span><span class="koboSpan" id="kobo.50.5">It proves that Qt 6 can handle this pretty well. </span><span class="koboSpan" id="kobo.50.6">However, please be aware that your users might be using older machines, and you might want to be extra careful when designing your </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">user interface:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer241">
<span class="koboSpan" id="kobo.52.1"><img alt="Figure 14.1 – Spawn 600 buttons on a Qt window" src="image/B20976_14_001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.53.1">Figure 14.1 – Spawn 600 buttons on a Qt window</span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.54.1">Let’s</span><a id="_idIndexMarker934"/><span class="koboSpan" id="kobo.55.1"> add a style sheet to each of the buttons, </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">like so:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.57.1">
QPushButton* newWidget = new QPushButton();
newWidget-&gt;setText("Button");
newWidget-&gt;setStyleSheet("background-color: blue; color: white;");
layout-&gt;addWidget(newWidget, i, j);</span></pre></li> <li><span class="koboSpan" id="kobo.58.1">Build and run the program again. </span><span class="koboSpan" id="kobo.58.2">This time, it took roughly 75 milliseconds to set up the GUI. </span><span class="koboSpan" id="kobo.58.3">This means that the style sheet does have some impact on the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">your program:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer242">
<span class="koboSpan" id="kobo.60.1"><img alt="Figure 14.2 – Apply the style sheet to all 600 buttons" src="image/B20976_14_002.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.61.1">Figure 14.2 – Apply the style sheet to all 600 buttons</span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.62.1">Once you </span><a id="_idIndexMarker935"/><span class="koboSpan" id="kobo.63.1">are done with that, let’s do some performance tests on different types of C++ containers. </span><span class="koboSpan" id="kobo.63.2">Open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">main.cpp</span></strong><span class="koboSpan" id="kobo.65.1"> and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">following headers:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.67.1">
#include "mainwindow.h"
#include &lt;QApplication&gt;
#include &lt;QDebug&gt;
#include &lt;QElapsedTimer&gt;
#include &lt;vector&gt;
#include &lt;QVector&gt;</span></pre></li> <li><span class="koboSpan" id="kobo.68.1">Create</span><a id="_idIndexMarker936"/><span class="koboSpan" id="kobo.69.1"> a </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">testArray()</span></strong><span class="koboSpan" id="kobo.71.1"> function before the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">main()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.73.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.74.1">
int testArray(int count) {
    int sum = 0;
    int *myarray = new int[count];
    for (int i = 0; i &lt; count; ++i)
        myarray[i] = i;
    for (int j = 0; j &lt; count; ++j)
        sum += myarray[j];
    delete [] myarray;
    return sum;
}</span></pre></li> <li><span class="koboSpan" id="kobo.75.1">Create another function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">testVector()</span></strong><span class="koboSpan" id="kobo.77.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.79.1">
int testVector(int count) {
    int sum = 0;
    std::vector&lt;int&gt; myarray;
    for (int i = 0; i &lt; count; ++i)
        myarray.push_back(i);
    for (int j = 0; j &lt; count; ++j)
        sum += myarray.at(j);
    return sum;
}</span></pre></li> <li><span class="koboSpan" id="kobo.80.1">Once you are done with that, proceed to create yet another function </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">testQtVector()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.84.1">
int testQtVector(int count) {
    int sum = 0;
    QVector&lt;int&gt; myarray;
    for (int i = 0; i &lt; count; ++i)
        myarray.push_back(i);
    for (int j = 0; j &lt; count; ++j)
        sum += myarray.at(j);
    return sum;
}</span></pre></li> <li><span class="koboSpan" id="kobo.85.1">Inside </span><a id="_idIndexMarker937"/><span class="koboSpan" id="kobo.86.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">main()</span></strong><span class="koboSpan" id="kobo.88.1"> function, define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">QElapsedTimer</span></strong><span class="koboSpan" id="kobo.90.1"> object and an integer variable </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">lastElapse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.94.1">
int main(int argc, char *argv[]) {
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">QElapsedTimer* time = new QElapsedTimer;</span></strong><span class="koboSpan" id="kobo.96.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">time-&gt;start();</span></strong><span class="koboSpan" id="kobo.98.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.99.1">int lastElapse = 0;</span></strong></pre></li> <li><span class="koboSpan" id="kobo.100.1">We will call the three functions we created in the previous steps to test </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">their performance:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.102.1">
    int result = testArray(100000000);
    qDebug() &lt;&lt; "Array:" &lt;&lt; (time-&gt;elapsed() - lastElapse) &lt;&lt; "msec";
    lastElapse = time-&gt;elapsed();
    int result2 = testVector(100000000);
    qDebug() &lt;&lt; "STL vector:" &lt;&lt; (time-&gt;elapsed() - lastElapse) &lt;&lt; "msec";
    lastElapse = time-&gt;elapsed();
    int result3 = testQtVector(100000000);
    qDebug() &lt;&lt; "Qt vector:" &lt;&lt; (time-&gt;elapsed() - lastElapse) &lt;&lt; "msec";
    lastElapse = time-&gt;elapsed();</span></pre></li> <li><span class="koboSpan" id="kobo.103.1">Build and run the program now; we will see the performance differences between these containers. </span><span class="koboSpan" id="kobo.103.2">On my computer, the array took 650 milliseconds to execute, while the STL vector took roughly 3,830 milliseconds, and the Qt vector took around 5,400 milliseconds </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">to execute.</span></span></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.105.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.106.1">As a result, the array is still the container that yields the best performance, despite its lack of features compared to the other two. </span><span class="koboSpan" id="kobo.106.2">Surprisingly, Qt’s own vector class works slightly slower than the vector container provided by the C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">standard library.</span></span></p>
<h2 id="_idParaDest-289"><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.108.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.109.1">When </span><a id="_idIndexMarker938"/><span class="koboSpan" id="kobo.110.1">creating a </span><strong class="bold"><span class="koboSpan" id="kobo.111.1">Qt Widgets Application</span></strong><span class="koboSpan" id="kobo.112.1"> project, try to do the following to </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">improve performance:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.114.1">Avoid adding too many pages to a stacked widget and filling them with widgets, as Qt needs to find all of them recursively during the rendering process and event handling, which will highly impact the </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">program’s performance.</span></span></li>
<li><span class="koboSpan" id="kobo.116.1">Do note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">QWidget</span></strong><span class="koboSpan" id="kobo.118.1"> class uses the Raster Engine, a software renderer, to render the widgets instead of using the GPU. </span><span class="koboSpan" id="kobo.118.2">However, it is lightweight enough to keep the performance good most of the time. </span><span class="koboSpan" id="kobo.118.3">Alternatively, you could consider using QML for your program’s GUI instead, since it is fully </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">hardware accelerated.</span></span></li>
<li><span class="koboSpan" id="kobo.120.1">Turn off </span><strong class="bold"><span class="koboSpan" id="kobo.121.1">mouseTracking</span></strong><span class="koboSpan" id="kobo.122.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.123.1">tabletTracking</span></strong><span class="koboSpan" id="kobo.124.1">, and other event catching for your widgets if they do not need it. </span><span class="koboSpan" id="kobo.124.2">This tracking and catchings adds to the CPU usage costs of </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">your program:</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer243">
<span class="koboSpan" id="kobo.126.1"><img alt="Figure 14.3 – Disable mouseTracking and tabletTracking for optimization" src="image/B20976_14_003.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.127.1">Figure 14.3 – Disable mouseTracking and tabletTracking for optimization</span></p>
<ul>
<li><span class="koboSpan" id="kobo.128.1">Keep </span><a id="_idIndexMarker939"/><span class="koboSpan" id="kobo.129.1">your style sheets as simple as possible. </span><span class="koboSpan" id="kobo.129.2">A large style sheet needs a longer time for Qt to parse the information into the rendering system, which will also </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">impact performance.</span></span></li>
<li><span class="koboSpan" id="kobo.131.1">Different C++ containers produce different speeds, as we showed in the preceding example. </span><span class="koboSpan" id="kobo.131.2">Surprisingly, Qt’s vector container is slightly slower than STL’s (the C++ standard library) vector container. </span><span class="koboSpan" id="kobo.131.3">Overall, the good old C++ array is still the fastest, but does not provide sorting functionality. </span><span class="koboSpan" id="kobo.131.4">Use what is best for </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">your requirements.</span></span></li>
<li><span class="koboSpan" id="kobo.133.1">For large operations, use </span><em class="italic"><span class="koboSpan" id="kobo.134.1">asynchronous</span></em><span class="koboSpan" id="kobo.135.1"> methods whenever possible as it will not stall the main process and will keep your program </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">running smoothly.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.137.1">Multi-threading</span></em><span class="koboSpan" id="kobo.138.1"> is</span><a id="_idIndexMarker940"/><span class="koboSpan" id="kobo.139.1"> really good for running different operations in parallel event loops. </span><span class="koboSpan" id="kobo.139.2">However, it can also become quite ugly if not done right, for example, creating and destroying threads frequently, or with inter-thread communications that are not </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">planned well.</span></span></li>
<li><span class="koboSpan" id="kobo.141.1">Try to avoid using the web engine unless absolutely necessary. </span><span class="koboSpan" id="kobo.141.2">This is because embedding a full web browser on your program is really heavy overkill, especially for a small application. </span><span class="koboSpan" id="kobo.141.3">You can consider using QML instead of making a hybrid application if you want to create user </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">interface-centric software.</span></span></li>
<li><span class="koboSpan" id="kobo.143.1">By </span><a id="_idIndexMarker941"/><span class="koboSpan" id="kobo.144.1">doing performance tests as we did in the preceding example project, you can easily determine which method is the best choice for your project and how to make your program </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">perform better.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.146.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.147.1">In Qt 5, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">QTime</span></strong><span class="koboSpan" id="kobo.149.1"> class to do the test as seen in this section. </span><span class="koboSpan" id="kobo.149.2">However, functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">start()</span></strong><span class="koboSpan" id="kobo.151.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">elapsed()</span></strong><span class="koboSpan" id="kobo.153.1"> have been deprecated from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">QTime</span></strong><span class="koboSpan" id="kobo.155.1"> class in Qt 6. </span><span class="koboSpan" id="kobo.155.2">Since Qt 6, the player must use </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">QElapsedTimer</span></strong><span class="koboSpan" id="kobo.157.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">handle this.</span></span></p>
<h1 id="_idParaDest-290"><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.159.1">Profiling and optimizing QML</span></h1>
<p><span class="koboSpan" id="kobo.160.1">The QML engine in Qt 6 took advantage of hardware acceleration to make its rendering capability and performance superior to the old widgets user interface. </span><span class="koboSpan" id="kobo.160.2">However, this does not mean that you do not need to worry about optimization, because small performance issues may snowball into bigger problems over time and cause damage to your </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">product’s reputation.</span></span></p>
<h2 id="_idParaDest-291"><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.162.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.163.1">Follow these steps to start profiling</span><a id="_idIndexMarker942"/><span class="koboSpan" id="kobo.164.1"> and optimizing</span><a id="_idIndexMarker943"/><span class="koboSpan" id="kobo.165.1"> a </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">QML application:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.167.1">Let’s create a </span><strong class="bold"><span class="koboSpan" id="kobo.168.1">Qt Quick </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.169.1">Application</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.170.1"> project:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer244">
<span class="koboSpan" id="kobo.171.1"><img alt="Figure 14.4 – Create a Qt Quick Application project" src="image/B20976_14_004.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.172.1">Figure 14.4 – Create a Qt Quick Application project</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.173.1">Then, go </span><a id="_idIndexMarker944"/><span class="koboSpan" id="kobo.174.1">to </span><strong class="bold"><span class="koboSpan" id="kobo.175.1">Analyze | QML Profiler</span></strong><span class="koboSpan" id="kobo.176.1"> and</span><a id="_idIndexMarker945"/><span class="koboSpan" id="kobo.177.1"> run the </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">QML </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.179.1">Profiler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.180.1"> tool:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer245">
<span class="koboSpan" id="kobo.181.1"><img alt="Figure 14.5 – Run the QML Profiler to check the QML performance" src="image/B20976_14_005.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.182.1">Figure 14.5 – Run the QML Profiler to check the QML performance</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.183.1">Your Qt Quick project will then be run by the QML Profiler. </span><span class="koboSpan" id="kobo.183.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.184.1">QML Profiler</span></strong><span class="koboSpan" id="kobo.185.1"> window will also appear under the code editor. </span><span class="koboSpan" id="kobo.185.2">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.186.1">Stop</span></strong><span class="koboSpan" id="kobo.187.1"> button located at the top bar of the </span><strong class="bold"><span class="koboSpan" id="kobo.188.1">QML Profiler</span></strong><span class="koboSpan" id="kobo.189.1"> window after the program has passed the test point, which in this case meant successfully creating the </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">empty window:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer246">
<span class="koboSpan" id="kobo.191.1"><img alt="Figure 14.6 – Stop the QML Profiler by pressing the button with the red rectangle icon" src="image/B20976_14_006.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.192.1">Figure 14.6 – Stop the QML Profiler by pressing the button with the red rectangle icon</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.193.1">After you</span><a id="_idIndexMarker946"/><span class="koboSpan" id="kobo.194.1"> stop the profiler analysis, a timeline will be </span><a id="_idIndexMarker947"/><span class="koboSpan" id="kobo.195.1">displayed in the </span><strong class="bold"><span class="koboSpan" id="kobo.196.1">Timeline</span></strong><span class="koboSpan" id="kobo.197.1"> tab under the </span><strong class="bold"><span class="koboSpan" id="kobo.198.1">QML Profiler</span></strong><span class="koboSpan" id="kobo.199.1"> window. </span><span class="koboSpan" id="kobo.199.2">There are four tabs that you can switch between, namely </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">Timeline</span></strong><span class="koboSpan" id="kobo.201.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">Flame Graph</span></strong><span class="koboSpan" id="kobo.203.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">Quick3D Frame</span></strong><span class="koboSpan" id="kobo.205.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">Statistics</span></strong><span class="koboSpan" id="kobo.207.1">, at the bottom of the </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">QML </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.209.1">Profiler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.210.1"> window:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer247">
<span class="koboSpan" id="kobo.211.1"><img alt="Figure 14.7 – You can look at different data on different tabs" src="image/B20976_14_007.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.212.1">Figure 14.7 – You can look at different data on different tabs</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.213.1">Let’s check out the </span><strong class="bold"><span class="koboSpan" id="kobo.214.1">Timeline</span></strong><span class="koboSpan" id="kobo.215.1"> tab. </span><span class="koboSpan" id="kobo.215.2">We can see six different categories under the timeline display: </span><strong class="bold"><span class="koboSpan" id="kobo.216.1">Scene Graph</span></strong><span class="koboSpan" id="kobo.217.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.218.1">Memory Usage</span></strong><span class="koboSpan" id="kobo.219.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.220.1">Input Events</span></strong><span class="koboSpan" id="kobo.221.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.222.1">Compiling</span></strong><span class="koboSpan" id="kobo.223.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.224.1">Creating</span></strong><span class="koboSpan" id="kobo.225.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.226.1">Binding</span></strong><span class="koboSpan" id="kobo.227.1">. </span><span class="koboSpan" id="kobo.227.2">These categories give us an overview of the different stages and processes of our program throughout its execution. </span><span class="koboSpan" id="kobo.227.3">We can also see some colorful bars displayed on the timeline. </span><span class="koboSpan" id="kobo.227.4">Let’s click on one of the bars under the </span><strong class="bold"><span class="koboSpan" id="kobo.228.1">Creating</span></strong><span class="koboSpan" id="kobo.229.1"> category that says </span><strong class="bold"><span class="koboSpan" id="kobo.230.1">QtQuick/Window</span></strong><span class="koboSpan" id="kobo.231.1">. </span><span class="koboSpan" id="kobo.231.2">Once clicked, we will see the total duration for this operation and the location of the code displayed in a rectangular window located at the top of the QML </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">Profiler window:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer248">
<span class="koboSpan" id="kobo.233.1"><img alt="Figure 14.8 – The Timeline tab" src="image/B20976_14_008.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.234.1">Figure 14.8 – The Timeline tab</span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.235.1">Once you are</span><a id="_idIndexMarker948"/><span class="koboSpan" id="kobo.236.1"> done with that, let’s move on and open up </span><a id="_idIndexMarker949"/><span class="koboSpan" id="kobo.237.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.238.1">Flame Graph</span></strong><span class="koboSpan" id="kobo.239.1"> tab instead. </span><span class="koboSpan" id="kobo.239.2">Under the </span><strong class="bold"><span class="koboSpan" id="kobo.240.1">Flame Graph</span></strong><span class="koboSpan" id="kobo.241.1"> tab, you will see the visualization of the total time, memory, and allocation of your application in the form of percentages. </span><span class="koboSpan" id="kobo.241.2">You can switch between total time, memory, and allocation by clicking on the selection box that’s located at the top-right corner of the </span><strong class="bold"><span class="koboSpan" id="kobo.242.1">QML </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.243.1">Profiler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.244.1"> window:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer249">
<span class="koboSpan" id="kobo.245.1"><img alt="Figure 14.9 – The Flame Graph tab" src="image/B20976_14_009.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.246.1">Figure 14.9 – The Flame Graph tab</span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.247.1">Not only </span><a id="_idIndexMarker950"/><span class="koboSpan" id="kobo.248.1">that, you will also see the percentage value </span><a id="_idIndexMarker951"/><span class="koboSpan" id="kobo.249.1">displayed on your QML </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">code editor:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer250">
<span class="koboSpan" id="kobo.251.1"><img alt="Figure 14.10 – Percentage values are shown on the right" src="image/B20976_14_010.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.252.1">Figure 14.10 – Percentage values are shown on the right</span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.253.1">Open up the </span><strong class="bold"><span class="koboSpan" id="kobo.254.1">Quick3D Frame</span></strong><span class="koboSpan" id="kobo.255.1"> category under the </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">QML Profiler</span></strong><span class="koboSpan" id="kobo.257.1"> window. </span><span class="koboSpan" id="kobo.257.2">This tab is where you check the performance of 3D rendering. </span><span class="koboSpan" id="kobo.257.3">It is currently empty because we are not doing any </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">3D rendering.</span></span></li>
<li><span class="koboSpan" id="kobo.259.1">Next, let’s open up the </span><strong class="bold"><span class="koboSpan" id="kobo.260.1">Statistics</span></strong><span class="koboSpan" id="kobo.261.1"> category. </span><span class="koboSpan" id="kobo.261.2">This tab basically shows us information about the processes in </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">table form:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer251">
<span class="koboSpan" id="kobo.263.1"><img alt="Figure 14.11 – The Statistics tab" src="image/B20976_14_011.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.264.1">Figure 14.11 – The Statistics tab</span></p>
<h2 id="_idParaDest-292"><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.265.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.266.1">This is similar to what we did in the previous example project that used C++ and widgets except, this time, it is automatically analyzed by the </span><strong class="bold"><span class="koboSpan" id="kobo.267.1">QML Profiler</span></strong><span class="koboSpan" id="kobo.268.1"> tool that’s provided by </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">Qt 6.</span></span></p>
<p><span class="koboSpan" id="kobo.270.1">The QML Profiler not only produces the total time used for running a specific process, but also displays the memory allocation, the execution timeline of your application, and other information that gives you insight into the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">your software.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">By looking at the data that was analyzed by the QML Profiler, you will be able to find out which part of your code slows down the program, allowing you to fix any </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">problems quickly.</span></span></p>
<p><span class="koboSpan" id="kobo.274.1">There are</span><a id="_idIndexMarker952"/><span class="koboSpan" id="kobo.275.1"> some rules that you need to be aware of when writing </span><a id="_idIndexMarker953"/><span class="koboSpan" id="kobo.276.1">QML to avoid performance bottlenecks. </span><span class="koboSpan" id="kobo.276.2">For instance, type conversion can sometimes be expensive, especially between types that are not closely matched (string to number, for example). </span><span class="koboSpan" id="kobo.276.3">Small issues like this will likely snowball into bottlenecks as your project grows larger </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">Other than that, try not to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">id</span></strong><span class="koboSpan" id="kobo.280.1"> for an item lookup multiple times in blocks of code that are run often, as in the </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.282.1">
Item {
    width: 400
    height: 400
    Rectangle {
    id: rect
    anchors.fill: parent
    color: "green"
    }
    Component.onCompleted: {
        for (var i = 0; i &lt; 1000; ++i) {
            console.log("red", rect.color.r);
            console.log("green", rect.color.g);
            console.log("blue", rect.color.b);
            console.log("alpha", rect.color.a);
        }
    }</span></pre> <p><span class="koboSpan" id="kobo.283.1">Instead, we can use a variable to cache the data and avoid multiple look-ups on the same item over and </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">over again:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.285.1">
Component.onCompleted: {
    var rectColor = rect.color;
    for (var i = 0; i &lt; 1000; ++i) {
        console.log("red", rectColor.r);
        console.log("green", rectColor.g);
        console.log("blue", rectColor.b);
        console.log("alpha", rectColor.a);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.286.1">Besides, if you</span><a id="_idIndexMarker954"/><span class="koboSpan" id="kobo.287.1"> change the property of a binding expression, especially</span><a id="_idIndexMarker955"/><span class="koboSpan" id="kobo.288.1"> in a loop, Qt will be forced to re-evaluate it repeatedly. </span><span class="koboSpan" id="kobo.288.2">This will cause some performance issues. </span><span class="koboSpan" id="kobo.288.3">Instead of doing this, the user should follow the next </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.290.1">
Item {
    id: myItem
    width: 400
    height: 400
    property int myValue: 0
    Text {
        anchors.fill: parent
        text: myItem.myValue.toString()
    }
    Component.onCompleted: {
        for (var i = 0; i &lt; 1000; ++i) {
            myValue += 1;
        }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.291.1">Instead, we can </span><a id="_idIndexMarker956"/><span class="koboSpan" id="kobo.292.1">use a temporary variable for storing the data of </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">myValue</span></strong><span class="koboSpan" id="kobo.294.1">, then </span><a id="_idIndexMarker957"/><span class="koboSpan" id="kobo.295.1">apply the final result back to </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">myValue</span></strong><span class="koboSpan" id="kobo.297.1"> once the loop has </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">been completed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.299.1">
Component.onCompleted: {
    var temp = myValue;
    for (var i = 0; i &lt; 1000; ++i) {
        temp += 1;
    }
    myValue = temp;
}</span></pre> <p><span class="koboSpan" id="kobo.300.1">Consider using an anchor to position your UI items instead of using bindings. </span><span class="koboSpan" id="kobo.300.2">Item positioning with bindings is really slow and inefficient, although it allows for </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">maximum flexibility.</span></span></p>
<h1 id="_idParaDest-293"><a id="_idTextAnchor293"/><span class="koboSpan" id="kobo.302.1">Rendering and animation</span></h1>
<p><span class="koboSpan" id="kobo.303.1">When it </span><a id="_idIndexMarker958"/><span class="koboSpan" id="kobo.304.1">comes to an application that renders graphics and </span><a id="_idIndexMarker959"/><span class="koboSpan" id="kobo.305.1">animation, good performance is critical. </span><span class="koboSpan" id="kobo.305.2">Users can easily notice performance issues when graphics are not animated smoothly on screen. </span><span class="koboSpan" id="kobo.305.3">In the following example, we will look at how we can further optimize a graphics-heavy Qt </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">Quick application.</span></span></p>
<h2 id="_idParaDest-294"><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.307.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.308.1">To</span><a id="_idIndexMarker960"/><span class="koboSpan" id="kobo.309.1"> learn how to</span><a id="_idIndexMarker961"/><span class="koboSpan" id="kobo.310.1"> render animation in QML, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">this example:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.312.1">Create a </span><strong class="bold"><span class="koboSpan" id="kobo.313.1">Qt Quick Application</span></strong><span class="koboSpan" id="kobo.314.1"> project. </span><span class="koboSpan" id="kobo.314.2">Then, right-click on the </span><strong class="bold"><span class="koboSpan" id="kobo.315.1">Resources</span></strong><span class="koboSpan" id="kobo.316.1"> icon under our project panel and add </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">tux.png</span></strong><span class="koboSpan" id="kobo.318.1"> to our </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">project’s resources:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer252">
<span class="koboSpan" id="kobo.320.1"><img alt="Figure 14.12 – Include main.qml and tux.png into your project resources" src="image/B20976_14_012.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.321.1">Figure 14.12 – Include main.qml and tux.png into your project resources</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.322.1">Open up </span><strong class="bold"><span class="koboSpan" id="kobo.323.1">main.qml</span></strong><span class="koboSpan" id="kobo.324.1"> and change the window size to </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">650</span></strong><span class="koboSpan" id="kobo.326.1"> x </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">650</span></strong><span class="koboSpan" id="kobo.328.1">. </span><span class="koboSpan" id="kobo.328.2">We will also add </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">id</span></strong><span class="koboSpan" id="kobo.330.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">window</span></strong><span class="koboSpan" id="kobo.332.1"> item and name </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">window</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.336.1">
Window {
    id: window
    visible: true
    width: 650
    height: 650</span></pre></li> <li><span class="koboSpan" id="kobo.337.1">Add the following code inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">window</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.339.1"> item:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.340.1">
    property int frame: 0;
    onAfterRendering: { frame++; }
    Timer {
    id: timer
    interval: 1000
    running: true
    repeat: true
    onTriggered: { frame = 0; }
}</span></pre></li> <li><span class="koboSpan" id="kobo.341.1">Right</span><a id="_idIndexMarker962"/><span class="koboSpan" id="kobo.342.1"> after </span><a id="_idIndexMarker963"/><span class="koboSpan" id="kobo.343.1">that, add </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">Repeater</span></strong><span class="koboSpan" id="kobo.345.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">Image</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.347.1">under it:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.348.1">
    Repeater {
        model: 10
        delegate:
        Image {
        id: tux
        source: "tux.png"
        sourceSize.width: 50
        sourceSize.height: 60
        width: 50
        height: 60
        smooth: false
        antialiasing: false
        asynchronous: true</span></pre></li> <li><span class="koboSpan" id="kobo.349.1">We will proceed and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.351.1">
        property double startX: Math.random() * 600;
        property double startY: Math.random() * 600;
        property double endX: Math.random() * 600;
        property double endY: Math.random() * 600;
        property double speed: Math.random() * 3000 + 1000;
        RotationAnimation on rotation{
        loops: Animation.Infinite
        from: 0
        to: 360
        duration: Math.random() * 3000 + 1000;
}</span></pre></li> <li><span class="koboSpan" id="kobo.352.1">Once</span><a id="_idIndexMarker964"/><span class="koboSpan" id="kobo.353.1"> you are </span><a id="_idIndexMarker965"/><span class="koboSpan" id="kobo.354.1">done with that, add the following code below the </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">previous code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.356.1">
    SequentialAnimation {
        running: true
        loops: Animation.Infinite
        ParallelAnimation {
        NumberAnimation {
        target: tux
        property: "x"
        from: startX
        to: endX
        duration: speed
        easing.type: Easing.InOutQuad
    }</span></pre></li> <li><span class="koboSpan" id="kobo.357.1">The preceding code animates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">x</span></strong><span class="koboSpan" id="kobo.359.1"> property of the image. </span><span class="koboSpan" id="kobo.359.2">We need another </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">NumberAnimation</span></strong><span class="koboSpan" id="kobo.361.1"> property to animate the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">y</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.363.1"> property:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.364.1">
    NumberAnimation {
        target: tux
        property: "y"
        from: startY
        to: endY
        duration: speed
        easing.type: Easing.InOutQuad
    }
}</span></pre></li> <li><span class="koboSpan" id="kobo.365.1">After that, we</span><a id="_idIndexMarker966"/><span class="koboSpan" id="kobo.366.1"> repeat the entire code of </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">ParallelAnimation</span></strong><span class="koboSpan" id="kobo.368.1">, except this time, we </span><a id="_idIndexMarker967"/><span class="koboSpan" id="kobo.369.1">swap the </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">from</span></strong><span class="koboSpan" id="kobo.371.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">to</span></strong><span class="koboSpan" id="kobo.373.1"> values, </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">like so:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.375.1">
    ParallelAnimation {
        NumberAnimation {
            target: tux
            property: "x"
            from: endX
            to: startX
            duration: speed
            easing.type: Easing.InOutQuad
        }</span></pre></li> <li><span class="koboSpan" id="kobo.376.1">The same goes for </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">NumberAnimation</span></strong><span class="koboSpan" id="kobo.378.1"> for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">y</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.380.1"> property:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.381.1">
        NumberAnimation {
            target: tux
            property: "y"
            from: endY
            to: startY
            duration: speed
            easing.type: Easing.InOutQuad
        }
    }</span></pre></li> <li><span class="koboSpan" id="kobo.382.1">Then, we </span><a id="_idIndexMarker968"/><span class="koboSpan" id="kobo.383.1">add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">Text</span></strong><span class="koboSpan" id="kobo.385.1"> item for displaying the frame rate of </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">our </span></span><span class="No-Break"><a id="_idIndexMarker969"/></span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">application:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.388.1">
Text {
    property int frame: 0
    color: "red"
    text: "FPS: 0 fps"
    x: 20
    y: 20
    font.pointSize: 20</span></pre></li> <li><span class="koboSpan" id="kobo.389.1">Let’s add </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">Timer</span></strong><span class="koboSpan" id="kobo.391.1"> under </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">Text</span></strong><span class="koboSpan" id="kobo.393.1"> and update the frame rate to display </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">every second:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.395.1">
    Timer {
        id: fpsTimer
        repeat: true
        interval: 1000
        running: true
        onTriggered: {
        parent.text = "FPS: " + frame + " fps"
        }
    }
}</span></pre></li> <li><span class="koboSpan" id="kobo.396.1">If we build and run the program now, we will be able to see several penguins moving around the screen with a steady </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">60 fps:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer253">
<span class="koboSpan" id="kobo.398.1"><img alt="Figure 14.13 – 10 penguins floating around the window" src="image/B20976_14_013.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.399.1">Figure 14.13 – 10 penguins floating around the window</span></p>
<ol>
<li value="13"><span class="koboSpan" id="kobo.400.1">Let’s go </span><a id="_idIndexMarker970"/><span class="koboSpan" id="kobo.401.1">back to our code and change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">model</span></strong><span class="koboSpan" id="kobo.403.1"> property</span><a id="_idIndexMarker971"/><span class="koboSpan" id="kobo.404.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">Repeater</span></strong><span class="koboSpan" id="kobo.406.1"> item to </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">10000</span></strong><span class="koboSpan" id="kobo.408.1">. </span><span class="koboSpan" id="kobo.408.2">Build and run the program again; you should see that your window is full of moving penguins and that the frame rate has significantly dropped to roughly 39 fps, which is not too bad, considering the amount of penguins </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">we have:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer254">
<span class="koboSpan" id="kobo.410.1"><img alt="Figure 14.14 – 10,000 penguins floating around the window" src="image/B20976_14_014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.411.1">Figure 14.14 – 10,000 penguins floating around the window</span></p>
<ol>
<li value="14"><span class="koboSpan" id="kobo.412.1">Next, let’s </span><a id="_idIndexMarker972"/><span class="koboSpan" id="kobo.413.1">go back to our source code and comment out both </span><a id="_idIndexMarker973"/><span class="koboSpan" id="kobo.414.1">of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">sourceSize</span></strong><span class="koboSpan" id="kobo.416.1"> properties. </span><span class="koboSpan" id="kobo.416.2">We also set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">smooth</span></strong><span class="koboSpan" id="kobo.418.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">antialiasing</span></strong><span class="koboSpan" id="kobo.420.1"> properties to </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">false</span></strong><span class="koboSpan" id="kobo.422.1">, while setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">asynchronous</span></strong><span class="koboSpan" id="kobo.424.1"> property </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.428.1">
Image {
    id: tux
    source: "tux.png"
    </span><strong class="bold"><span class="koboSpan" id="kobo.429.1">//sourceSize.width: 50</span></strong><span class="koboSpan" id="kobo.430.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.431.1">//sourceSize.height: 60</span></strong><span class="koboSpan" id="kobo.432.1">
    width: 50
    height: 60
    </span><strong class="bold"><span class="koboSpan" id="kobo.433.1">smooth: true</span></strong><span class="koboSpan" id="kobo.434.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.435.1">antialiasing: false</span></strong><span class="koboSpan" id="kobo.436.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.437.1">asynchronous: false</span></strong></pre></li> <li><span class="koboSpan" id="kobo.438.1">Let’s build</span><a id="_idIndexMarker974"/><span class="koboSpan" id="kobo.439.1"> and run the program again. </span><span class="koboSpan" id="kobo.439.2">This time, the frame rate</span><a id="_idIndexMarker975"/><span class="koboSpan" id="kobo.440.1"> dropped slightly to 32 fps, but the penguins look smoother and are of better quality, even </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">when moving:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer255">
<span class="koboSpan" id="kobo.442.1"><img alt="Figure 14.15 – Our penguins look much smoother now without slowing down too much" src="image/B20976_14_015.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.443.1">Figure 14.15 – Our penguins look much smoother now without slowing down too much</span></p>
<h2 id="_idParaDest-295"><a id="_idTextAnchor295"/><span class="koboSpan" id="kobo.444.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.445.1">The </span><a id="_idIndexMarker976"/><span class="koboSpan" id="kobo.446.1">QML engine that powers Qt Quick applications is very optimized and </span><a id="_idIndexMarker977"/><span class="koboSpan" id="kobo.447.1">powerful when it comes to rendering animated graphics on screen. </span><span class="koboSpan" id="kobo.447.2">However, there are still some tips that we can follow to make it </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">even faster.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">Try and make use of the built-in features provided by Qt 6 instead of implementing your own, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">Repeater</span></strong><span class="koboSpan" id="kobo.451.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">NumberAnimation</span></strong><span class="koboSpan" id="kobo.453.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">SequentialAnimation</span></strong><span class="koboSpan" id="kobo.455.1">. </span><span class="koboSpan" id="kobo.455.2">This is because Qt 6 developers have put great effort into optimizing these features so that you don’t </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">have to.</span></span></p>
<p><span class="koboSpan" id="kobo.457.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">sourceSize</span></strong><span class="koboSpan" id="kobo.459.1"> properties tell Qt to resize the image before loading it into memory so that large images do not use more memory </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">than necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">smooth</span></strong><span class="koboSpan" id="kobo.463.1"> property, when enabled, tells Qt to filter the image to make look it smoother when scaled or transformed from its natural size. </span><span class="koboSpan" id="kobo.463.2">It will not make any difference if the image is rendered at the same as its </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">sourceSize</span></strong><span class="koboSpan" id="kobo.465.1"> value. </span><span class="koboSpan" id="kobo.465.2">This property will impact the performance of your application on some </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">older hardware.</span></span></p>
<p><span class="koboSpan" id="kobo.467.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">antialiasing</span></strong><span class="koboSpan" id="kobo.469.1"> property tells Qt to remove the aliasing artifacts around the edge of the image and make it look smoother. </span><span class="koboSpan" id="kobo.469.2">This property will also impact the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">your program.</span></span></p>
<p><span class="koboSpan" id="kobo.471.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">asynchronous</span></strong><span class="koboSpan" id="kobo.473.1"> property tells Qt to load the image under a low-priority thread, which means that your program will not stall when loading huge </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">image files.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">We used the frame rate to indicate the performance of our program. </span><span class="koboSpan" id="kobo.475.2">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">onAfterRendering</span></strong><span class="koboSpan" id="kobo.477.1"> always gets called on every frame, we can then accumulate the frame variable on every render. </span><span class="koboSpan" id="kobo.477.2">Then, we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">Timer</span></strong><span class="koboSpan" id="kobo.479.1"> to reset the frame value </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">every second.</span></span></p>
<p><span class="koboSpan" id="kobo.481.1">Finally, we displayed the value on screen using a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">Text</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.483.1"> item.</span></span></p>
</div>
</body></html>