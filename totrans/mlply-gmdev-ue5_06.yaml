- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Replicating Properties Over the Network
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网络上复制属性
- en: Replication is an important concept when it comes to creating multiplayer games
    with Unreal Engine. In particular, **property replication** allows for the synchronization
    of objects between multiple players, letting them interact in a shared environment.
    This feature also handles things such as character movement and physics calculations,
    ensuring everyone has a consistent experience and view of the game world, regardless
    of the platform type, and that no one has an advantage due to cheating or latency
    issues.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用虚幻引擎创建多人游戏时，复制是一个重要的概念。特别是，**属性复制**允许在多个玩家之间同步对象，使他们能够在共享环境中交互。此功能还处理诸如角色移动和物理计算等问题，确保每个人都能获得一致的游戏世界体验和视角，无论平台类型如何，并且没有人因作弊或延迟问题而获得优势。
- en: In this chapter, you’ll start working on replication, mainly focusing on property
    replication of your character skills. Next, starting from the base pickup you
    created in the last chapter, you’ll implement a coin pickup that will grant the
    character experience points that will give the character a level-up during gameplay.
    Finally, you’ll apply replication by updating a simple user interface that will
    show the character experience points and level.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将开始处理复制，主要关注角色技能的属性复制。接下来，从上一章中创建的基础拾取开始，你将实现一个硬币拾取，这将授予角色经验点，在游戏过程中使角色升级。最后，你将通过更新一个简单的用户界面来应用复制，该界面将显示角色的经验点和等级。
- en: At the end of this chapter, you will have a good grasp of how an Actor replicates
    in a multiplayer setting and the properties that come with it. Essentially, you’ll
    understand how Actors behave and operate in a multi-player environment.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将很好地掌握在多人设置中Actor如何复制以及与之相关的属性。基本上，你将了解Actor在多人环境中的行为和操作。
- en: 'In the next sections, I will present the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我将介绍以下主题：
- en: Adding character stats
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加角色统计数据
- en: Understanding property replication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解属性复制
- en: Handling characters level-ups
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理角色等级提升
- en: Adding a HUD to the game
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为游戏添加HUD
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the topics presented in this chapter, you should have completed the
    previous ones and understood their content.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中介绍的主题，你应该已经完成了前面的内容，并理解了它们的内容。
- en: 'Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the `.zip` project files provided in this book’s
    companion project repository:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你希望从本书的配套仓库开始编写代码，你可以下载本书配套项目仓库中提供的`.zip`项目文件：
- en: '[https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5).'
- en: You can download the files that are up to date with the end of the last chapter
    by clicking the `Unreal Shadows –` `Chapter 05``End` link.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击`Unreal Shadows –` `第五章``结束`链接下载与最后一章结尾同步的文件。
- en: Adding character stats
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加角色统计数据
- en: 'Before introducing property replication and implementing it in the project,
    our thief hero needs to be ready for such a big step: that’s why I’ll guide you
    through the creation of a set of statistics that will be plugged into the Character
    class.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍属性复制并在项目中实现它之前，我们的盗贼英雄需要为这样一个大步做好准备：这就是为什么我会引导你创建一组将被插入到角色类中的统计数据。
- en: 'The first thing to do is to define your character stats. In particular, you
    will need the following data:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首件事是定义你的角色统计数据。特别是，你需要以下数据：
- en: A walk and a sprint speed, to handle the different paces of your character during
    gameplay
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行走和冲刺速度，以处理游戏过程中角色的不同步伐
- en: A damage multiplier to manage more powerful hits whenever the character levels
    up
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个伤害倍数，用于管理角色升级时的更强大打击
- en: A level-up value to check whenever the character has reached the next level
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查角色是否达到下一个等级时需要提升的等级值
- en: A stealth multiplier that will handle how much noise the character makes when
    walking or sprinting
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个潜行倍数，将处理角色在行走或冲刺时产生的噪音
- en: You may have noticed that your character has no health – that is because this
    is a stealth game and players will have to move carefully through the dungeon.
    Once they are discovered, they won’t have the option of facing a swarm of undead
    lackeys in this particular game! As a consequence, gameplay will be more focused
    on defeating enemies from a distance or slipping silently away from them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到你的角色没有生命值 – 这是因为这是一个潜行游戏，玩家将不得不小心翼翼地穿过地牢。一旦被发现，他们在这个特定游戏中将没有面对一群不死随从的选项！因此，游戏玩法将更多地集中在从远处击败敌人或悄悄地从他们身边溜走。
- en: With the previous information, you’ll create a data structure containing all
    the data points for initializing the character, and then you’ll create a data
    table that will let you manage the experience your thief will gain during gameplay.
    So, let’s get started.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的信息，你将创建一个包含初始化角色所需的所有数据点的数据结构，然后你将创建一个数据表，让你可以管理玩家在游戏过程中获得的经验。所以，让我们开始吧。
- en: Creating the stats structure
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建统计结构
- en: To begin, you need to create a structure that will include all the aforementioned
    statistics. As this is not a class, you won’t need to create it from Unreal Engine
    Editor but from the IDE instead.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要创建一个结构，它将包括所有上述统计数据。由于这不是一个类，你不需要从Unreal Engine编辑器创建它，而是从IDE创建。
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Non-class entities cannot be made directly from within Unreal Editor.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 无法在Unreal编辑器内部直接创建非类实体。
- en: 'Open your IDE and create a file in your `UnrealShadows_LOTL` | `Source` | `UnrealShadows_LOTL`
    folder called `US_CharacterStats.h` (as this is a data structure, you won’t need
    a `.cpp` file). Then, open the file and insert the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的集成开发环境（IDE），在你的`UnrealShadows_LOTL` | `Source` | `UnrealShadows_LOTL`文件夹中创建一个名为`US_CharacterStats.h`的文件（因为这是一个数据结构，你不需要`.cpp`文件）。然后，打开该文件并插入以下代码：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `include` section is self-explanatory – after that, along with the standard
    C++ `struct` keyword to declare a structure, you will notice an `USTRUCT()` declaration
    instead of `UCLASS()` and an `F` prefix on the structure name (i.e., `FUS_CharacterStats`).
    This is the standard method to declare a structure in Unreal Engine. Then, in
    order to let Unreal Editor create data tables from this structure (more on this
    in a few moments), the `FTableRowBase` type is extended.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`include`部分是自解释的 – 之后，除了标准的C++ `struct`关键字来声明结构外，你还会注意到一个`USTRUCT()`声明而不是`UCLASS()`，以及结构名称前的`F`前缀（即`FUS_CharacterStats`）。这是在Unreal
    Engine中声明结构的标准方法。然后，为了使Unreal编辑器能够从该结构创建数据表（稍后将有更多介绍），扩展了`FTableRowBase`类型。'
- en: Inside the structure declaration, we are just adding a list of properties –
    all of them are marked `BlueprintReadWrite` to let Blueprints access and modify
    the data, and `EditAnywhere` to let you edit the values inside the data table
    you are going to create in the next steps.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构声明内部，我们只是添加了一个属性列表 – 所有这些属性都被标记为`BlueprintReadWrite`，以便蓝图访问和修改数据，以及`EditAnywhere`，以便你可以在下一步创建的数据表中编辑值。
- en: Creating a stats data table
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建统计数据表
- en: Now you have created a data structure for your character and are ready to create
    the actual data from it. In Unreal Engine, we will use a `UObject` property –
    including asset references from the projects, such as materials or textures.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经为你的角色创建了一个数据结构，并准备好从它创建实际的数据。在Unreal Engine中，我们将使用`UObject`属性 – 包括来自项目的资产引用，例如材料或纹理。
- en: 'To create your character data table, see the following steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建你的角色数据表，请按照以下步骤操作：
- en: Open your `Blueprints` folder in the Content Browser.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中打开你的`Blueprints`文件夹。
- en: Compile your project in order to make the C++ structure available in the Editor.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的项目，以便在编辑器中可用C++结构。
- en: Right-click in the Content Browser and select **Miscellaneous** | **Data Table**.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中右键单击并选择**杂项** | **数据表**。
- en: 'In the **Pick Row Structure** pop-up window, select **US_CharacterStats** from
    the drop-down menu, as depicted in *Figure 6**.1*:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**选择行结构**弹出窗口中，从下拉菜单中选择**US_CharacterStats**，如图*图6.1*所示：
- en: '![Figure 6.1 – The data table creation panel](img/Figure_06_01_B18203.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 数据表创建面板](img/Figure_06_01_B18203.jpg)'
- en: Figure 6.1 – The data table creation panel
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 数据表创建面板
- en: Click the `US_CharacterStats`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`US_CharacterStats`。
- en: 'Double-click on the newly created asset to open it. You will get an empty dataset
    as shown in *Figure 6**.2*:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击新创建的资产以打开它。你将得到一个如*图6.2*所示的空数据集：
- en: '![Figure 6.2 – The empty data table](img/Figure_06_02_B18203.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 空数据表](img/Figure_06_02_B18203.jpg)'
- en: Figure 6.2 – The empty data table
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 空数据表
- en: Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'A data table can also be generated by importing a `.csv` or `.json` file into
    your project. Additionally, Unreal Engine will let you easily export your project
    tables in `.csv` and `.json` formats. For more information about the importing
    and exporting processes, check the official documentation linked here: [https://docs.unrealengine.com/5.1/en-US/data-driven-gameplay-elements-in-unreal-engine/](https://docs.unrealengine.com/5.1/en-US/data-driven-gameplay-elements-in-unreal-engine/).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过将`.csv`或`.json`文件导入到项目中生成数据表。此外，虚幻引擎将允许您轻松地将项目表导出为`.csv`和`.json`格式。有关导入和导出过程的更多信息，请参阅此处链接的官方文档：[https://docs.unrealengine.com/5.1/en-US/data-driven-gameplay-elements-in-unreal-engine/](https://docs.unrealengine.com/5.1/en-US/data-driven-gameplay-elements-in-unreal-engine/)。
- en: With your table open, it’s time to add some data rows organized by character
    levels – you do want to let your character grow when they gain enough experience,
    don’t you?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的表格打开时，是时候添加一些按角色级别组织的数据行 - 您当然希望角色在获得足够经验时能够成长，不是吗？
- en: 'Let’s start by adding a single row for your character base level:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为角色的基础级别添加一行：
- en: Click on the **Add** button in the **Table** panel.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**表格**面板中点击**添加**按钮。
- en: The `level_01`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`level_01`。'
- en: You are now ready to set some stats for the first experience level of your character.
    Look for the `250,0`
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以为角色的第一个经验级别设置一些统计数据。寻找`250,0`
- en: '`800,0`'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`800,0`'
- en: '`1,0`'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`1,0`'
- en: '`10`'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`10`'
- en: '`1,0`'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`1,0`'
- en: 'The final result should be the same as the settings shown in *Figure 6**.3*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应与*图6**.3*中显示的设置相同：
- en: '![Figure 6.3 – Settings for the level_01 character](img/Figure_06_03_B18203.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – level_01角色的设置](img/Figure_06_03_B18203.jpg)'
- en: Figure 6.3 – Settings for the level_01 character
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – level_01角色的设置
- en: 'We are going to add a couple more levels to handle the experience growth of
    the character during gameplay. Repeat the same steps as before, but call the two
    new rows `level_02` and `level_03` respectively. Then use the following values
    for the **level_02** row:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加几个更多级别来处理游戏中的角色经验增长。重复之前的步骤，但将两个新行分别命名为`level_02`和`level_03`。然后为`**level_02**`行使用以下值：
- en: '`275,0`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`275,0`'
- en: '`850,0`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`850,0`'
- en: '`1,1`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1,1`'
- en: '`25`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`25`'
- en: '`1,5`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1,5`'
- en: 'And add the following values for the **level_03** row:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为`**level_03**`行添加以下值：
- en: '`300,0`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`300,0`'
- en: '`900,0`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`900,0`'
- en: '`1,0`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1,0`'
- en: '`50`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`50`'
- en: '`2`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`'
- en: These are purely indicative values – you are free to tweak them to suit your
    own needs and add as many additional levels as you wish.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些纯粹是指示性值 - 您可以根据自己的需求进行调整，并添加尽可能多的附加级别。
- en: Now that you have added a dataset for your character’s experience, you are ready
    to read the info included directly from your code. That’s why I need you to go
    back to the `US_Character.h` header file to add the data table declaration.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经为角色的经验添加了数据集，您就可以直接从代码中读取包含的信息了。这就是为什么我需要您回到`US_Character.h`头文件中添加数据表声明的原因。
- en: Reading the data table from the character
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从角色读取数据表
- en: 'In this section, you are going to add the data table to the character in order
    to read its values depending on the experience level. The first thing to do is
    to add a reference to the `US_Character.h` header file. So, in the `private` section
    of the header file, after all the existing declarations, add this code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将向角色添加数据表，以便根据经验水平读取其值。首先要做的事情是添加对`US_Character.h`头文件的引用。因此，在头文件的`private`部分，在所有现有声明之后，添加以下代码：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first declaration will let you reference the data table directly from the
    child Blueprint Classes, while the structure declaration will let you reference
    a single row from the data table and use it as the character statistics.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项声明将允许您直接从子蓝图类中引用数据表，而结构声明将允许您从数据表中引用单行并将其用作角色统计数据。
- en: 'After that, you will need to create a function that will allow the system to
    update the current level of the character. In the `public` section, add the following
    method declaration:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您需要创建一个函数，允许系统更新角色的当前级别。在`public`部分，添加以下方法声明：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The last thing you need to add to the class header is a getter function for
    the stats structure. Still in the `public` section, just before the last closing
    bracket, add the following line of code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要添加到类头文件中的最后一件事是用于统计结构的获取器函数。仍然在`public`部分，在最后一个闭合括号之前，添加以下代码行：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can now save this file and open `US_Character.cpp` to handle the data retrieval.
    At the top of the file, add the `include` declarations for the classes you’ll
    be using in a moment:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以保存此文件并打开`US_Character.cpp`以处理数据检索。在文件顶部，添加你将要使用的类的`include`声明：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, implement the `UpdateCharacterStats()` method by adding the following
    code at the end of the file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过在文件末尾添加以下代码来实现`UpdateCharacterStats()`方法：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, first we check that the data table is referenced (you’ll add
    it later, from the character Blueprint) and then use the `GetAllRows<T>()` method
    to fetch all the table rows into a local array (i.e., the `CharacterStatsRows`
    variable). If there is at least one row in the data table, we get the one corresponding
    to the level of the character minus 1 (i.e., for a level 1 character, we will
    get the row number 0). Notice, as well, the `FMath::Clamp()` method, which guarantees
    we are not trying to get a level value that’s higher than the available rows in
    the dataset.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，首先我们检查数据表是否被引用（你稍后将从角色蓝图添加它），然后使用`GetAllRows<T>()`方法将所有表行检索到本地数组中（即`CharacterStatsRows`变量）。如果数据表中至少有一行，我们获取对应于角色等级减1的行（即对于1级角色，我们将获取行号0）。请注意，还有`FMath::Clamp()`方法，它保证我们不会尝试获取高于数据集中可用行数的等级值。
- en: After that, we retrieve the `WalkSpeed` column from the row and assign its value
    to the `MaxWalkSpeed` property of the character movement component – this means
    that, if there is a data table assigned, your character will start the game with
    a value from the dataset and not from the constructor.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们从行中检索`WalkSpeed`列并将其值分配给角色的移动组件的`MaxWalkSpeed`属性——这意味着，如果有数据表分配，你的角色将以数据集中的值开始游戏，而不是从构造函数开始。
- en: 'You are now ready to update your character stats to level 1 – something you
    are about to do in the `BeginPlay()` function. To do so, inside the `BeginPlay()`
    function, and just before the closing bracket, add this code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你准备好将角色的统计数据更新到1级——你将在`BeginPlay()`函数中执行此操作。为此，在`BeginPlay()`函数中，并在括号关闭之前，添加以下代码：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The last thing you need to do is to update the two sprint methods that, at
    the moment, are using hardcoded values but need to use the data table stats. To
    do so, search for the `SprintStart()` method and find the following line:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的最后一件事是更新两个使用硬编码值但需要使用数据表统计信息的冲刺方法。为此，搜索`SprintStart()`方法并找到以下行：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, change it to the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其更改为以下代码：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s do the same with the `SprintEnd()` method, which should be positioned
    just after the previous one. Find the following line:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`SprintEnd()`方法做同样的事情，它应该位于上一个方法之后。找到以下行：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then change it using the following code block:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下代码块进行更改：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In both cases, the code is self-explanatory – we just check that there is valid
    data referenced in the character stats and assign the sprint or walk speed to
    the character movement component.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，代码都是自解释的——我们只是检查在角色统计数据中是否有有效的数据引用，并将冲刺或行走速度分配给角色移动组件。
- en: Now save your file and compile the project, just to be sure that everything
    is fine and ready for the next step.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存你的文件并编译项目，只是为了确保一切正常且为下一步做好准备。
- en: Your character is now ready to accept the data table we created at the beginning
    of this chapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你的角色现在准备好接受我们在本章开头创建的数据表。
- en: Adding the data table to the character
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据表添加到角色中
- en: 'To add the data table asset to the character, switch back to Unreal Editor
    and follow these steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据表资产添加到角色中，切换回Unreal编辑器并按照以下步骤操作：
- en: Open the **BP_Character** Blueprint.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**BP_Character**蓝图。
- en: Select the **Class Defaults** tab and, in the **Details** panel, look for the
    **Character** **Data** category.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**类默认值**选项卡，然后在**详细信息**面板中查找**字符****数据**类别。
- en: In the **Character Data Table** attribute, click on the drop-down menu and select
    **DT_CharacterStats**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**角色数据表**属性中，点击下拉菜单并选择**DT_CharacterStats**。
- en: Your character is now ready to use the statistics from the dataset – even though
    the poor thief is locked into a level 1 experience level, later on, you will set
    them free in the dungeon and see how they fare!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你的角色现在可以使用数据集中的统计数据了——即使这个可怜的小偷被锁定在1级经验等级中，稍后你将在地牢中释放他们，看看他们的表现如何！
- en: 'Test the game to check that everything works properly. Just remember what I
    said in the previous chapter: movement is still buggy as the client and the server
    are trying to force the character to conform to different speed values, but you
    are nearing the solution.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 测试游戏以检查一切是否正常工作。只需记住我在上一章中提到的话：由于客户端和服务器试图强制角色符合不同的速度值，移动仍然存在bug，但你正接近解决方案。
- en: So, in this section, you have improved the character by adding some statistics
    retrieved from a data table and using them to initialize some properties. At the
    moment, you have just used the movement ones, but don’t be afraid! Once the character
    is completed, everything will fall into place.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本节中，你通过添加从数据表中检索的一些统计数据并使用它们来初始化一些属性来改进了角色。目前，你只使用了移动属性，但不要害怕！一旦角色完成，一切都将各就各位。
- en: In the upcoming section, we’ll dive into the topic of property replication in
    Unreal – something that will come in handy when it’s time to level up your character
    and something you’ll be doing by the end of this chapter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入研究虚幻中的属性复制主题——当需要提升角色等级时，这将很有用，你将在本章结束时完成这项工作。
- en: Understanding property replication
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解属性复制
- en: 'As stated before, property replication allows for the synchronization of objects
    in an Unreal multiplayer environment. It should be noted that, as the server is
    authoritative, updates will never be sent by the client. Obviously, the client
    may (politely) ask the server to change a property value, and the server will
    behave accordingly. Additionally, property replication acts as a reliable service:
    consequently, the Actor on the client will have the same value as the server sooner
    or later.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，属性复制允许在虚幻多人环境中同步对象。需要注意的是，由于服务器是权威的，更新永远不会由客户端发送。显然，客户端可能会（礼貌地）请求服务器更改属性值，服务器将相应地行事。此外，属性复制充当一个可靠的服务：因此，客户端的Actor最终将与服务器上的值相同。
- en: This means that if you’re trying to modify, from the client, a property that
    is replicated, any changes you make to that property will only be temporary. You
    should be already familiar with this topic as the character’s movement logic,
    at the moment, is a bit buggy – we are trying to make the character run from the
    client, but the server is blocking our commands as soon as the network is updated.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你试图从客户端修改一个复制的属性，你对该属性所做的任何更改都将是临时的。你应该已经熟悉这个主题，因为目前角色的移动逻辑有点buggy——我们试图让客户端的角色运行，但一旦网络更新，服务器就会阻止我们的命令。
- en: This is happening because, as soon as the server sends an update to the client
    with a new value for that property, any changes that you made locally on the client
    will be overwritten and replaced with the new, correct value from the server.
    Consequently, if the server does not update frequently, it may take a while for
    the client to be notified about the new, correct value.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，一旦服务器向客户端发送更新，包含该属性新值的更新，你在客户端本地所做的任何更改都将被覆盖并替换为来自服务器的新、正确的值。因此，如果服务器更新不频繁，客户端可能需要一段时间才能通知到新的、正确的值。
- en: Fixing that nasty bug is something we will be doing in [*Chapter 7*](B18203_07.xhtml#_idTextAnchor147),
    *Using Remote Procedure Calls (RPCs)*, where you’ll need to learn how to call
    a function from the client to the server. The main focus of this chapter, however,
    is to understand how to replicate properties. So, without further ado, let’s check
    how things work under the hood!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 修复那个讨厌的bug是我们将在[*第7章*](B18203_07.xhtml#_idTextAnchor147)中进行的，*使用远程过程调用（RPCs）*，在那里你需要学习如何从客户端调用函数到服务器。然而，本章的主要焦点是理解如何复制属性。所以，无需多言，让我们来看看内部是如何运作的！
- en: Enabling property replication
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用属性复制
- en: In order for a property to be replicated, you need to set up a few things. First
    of all, in the Actor constructor that will contain the property, you will need
    to set the `bReplicates` flag to `true`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使属性能够复制，你需要设置一些事情。首先，在将包含属性的Actor构造函数中，你需要将`bReplicates`标志设置为`true`。
- en: Note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A class or Blueprint extending from `APawn` or `ACharacter` will have the `bReplicates`
    property set to `true` by default, while a regular Actor won’t.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从`APawn`或`ACharacter`扩展的类或蓝图将默认将`bReplicates`属性设置为`true`，而常规Actor则不会。
- en: 'Then, the property that should be replicated will need to have the `Replicated`
    specifier added to the `UPROPERTY()` macro. As an example, you can replicate the
    score for your character with the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，需要复制的属性需要在`UPROPERTY()`宏中添加`Replicated`指定符。例如，你可以使用以下代码来复制你角色的分数：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you are in need of a callback function to be executed when a property is
    updated, you can use `ReplicatedUsing=[FunctionName]` instead – this attribute
    will let you specify a function that will be executed when an update is sent to
    the client. For example, if you want to execute a method called `OnRep_Score()`
    whenever your character score is replicated, you will write something similar
    to the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个在属性更新时执行的回调函数，你可以使用`ReplicatedUsing=[FunctionName]`代替——这个属性将允许你指定一个在更新发送到客户端时将被执行的函数。例如，如果你想在你角色的分数被复制时执行名为`OnRep_Score()`的方法，你将编写类似于以下代码的内容：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You will then need to implement the `OnRep_Score()` method in the same class;
    this function must declare the `UFUNCTION()` macro.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要在同一类中实现`OnRep_Score()`方法；这个函数必须声明`UFUNCTION()`宏。
- en: 'Once all the replication properties are properly decorated by the previous
    attributes, they need to be declared inside the `AActor::GetLifetimeReplicatedProps()`
    function by using the `DOREPLIFETIME()` macro. Using the previous score example,
    you will need to declare the `Score` property by using the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有复制属性都通过之前的属性正确装饰，它们需要在`AActor::GetLifetimeReplicatedProps()`函数内部使用`DOREPLIFETIME()`宏进行声明。使用之前的分数示例，你需要使用以下代码来声明`Score`属性：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After a property is registered for replication, it cannot be unregistered,
    as Unreal Engine will optimize data storage to reduce the computation time: this
    means that, by default, you will not have much control over how a property replicates.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 属性注册复制后，无法取消注册，因为虚幻引擎将优化数据存储以减少计算时间：这意味着默认情况下，你将无法对属性的复制有太多控制。
- en: Luckily, you can use the `DOREPLIFETIME_CONDITION()` macro instead, which will
    let you add an additional condition for more precise control over replication.
    Values for these conditions are predefined – one example is `COND_OwnerOnly`,
    which will only send data to the Actor’s owner (we will use this value later in
    the chapter). As another example, if you need even more fine-grained control in
    property replication, you can use the `DOREPLIFETIME_ACTIVE_OVERRIDE()` macro,
    which will let you use your own conditions defined inside the Actor.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以使用`DOREPLIFETIME_CONDITION()`宏代替，这将允许你添加一个额外的条件以更精确地控制复制。这些条件的值是预定义的——一个例子是`COND_OwnerOnly`，它只会将数据发送给Actor的所有者（我们将在本章后面使用这个值）。作为另一个例子，如果你需要在属性复制中拥有更精细的控制，你可以使用`DOREPLIFETIME_ACTIVE_OVERRIDE()`宏，这将允许你使用Actor内部定义的自己的条件。
- en: The major downside of using additional conditions for replication is performance,
    as the engine will need to do additional checks before replicating a property
    – this means that it is advisable to use the `DOREPLIFETIME()` macro in situations
    where no pressing requirements dictate the use of an alternative option.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用额外的条件进行复制的最大缺点是性能，因为引擎在复制属性之前需要执行额外的检查——这意味着在没有任何迫切要求指定使用替代选项的情况下，建议使用`DOREPLIFETIME()`宏。
- en: Now that you understand how an object can be replicated, it’s time for me to
    introduce how objects are referenced across the network.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何复制一个对象，是时候介绍如何在网络上引用对象了。
- en: Referencing Actors and components over the network
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在网络上引用Actor和组件
- en: Sooner or later, you will need to reference an Actor or a component from your
    code – this means that, in a multiplayer game, you will need to know whether the
    reference can be replicated or not. Simply put, an Actor or a component can be
    referenced over the network only if it is supported for networking.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 总有一天，你需要从你的代码中引用一个Actor或组件——这意味着在多人游戏中，你需要知道这个引用是否可以被复制。简单来说，一个Actor或组件只有在支持网络的情况下才能在网络上被引用。
- en: 'There are some simple rules that will help you determine whether your object
    can be referenced over the network:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些简单的规则可以帮助你确定你的对象是否可以在网络上被引用：
- en: If an Actor is replicated, it can also be replicated as a reference
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个Actor被复制，它也可以作为引用被复制
- en: If a component is replicated, it can also be replicated as a reference
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个组件被复制，它也可以作为引用被复制
- en: Non-replicated Actors and components need to be stably named in order to be
    replicated as references
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要稳定命名的非复制的Actors和组件，以便作为引用进行复制
- en: Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An object that is **stably named** means that an entity that will be present
    in both the server and the client that has the same name. For instance, an Actor
    is stably named if it was not spawned during gameplay but was loaded directly
    in the level from a package.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**稳定命名**的对象意味着一个实体将在服务器和客户端都存在，并且具有相同的名称。例如，如果一个Actor在游戏过程中没有被生成，而是直接从包中加载到级别中，那么它就是一个稳定命名的Actor。
- en: This section has provided you with an introduction to the fundamental concepts
    of network replication in Unreal Engine, explaining how it interacts with Actors
    and components. If you feel a bit lost about too much theory, don’t be afraid!
    You’ll be taking all that theory and transforming it into a tangible, working
    example by creating a level-up system for your character.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 本节为您提供了关于Unreal Engine中网络复制的根本概念的介绍，解释了它是如何与Actors和组件交互的。如果你觉得理论太多而感到有些迷茫，不要害怕！你将通过创建角色的等级提升系统，将所有这些理论转化为一个具体、可工作的示例。
- en: Handling character level-ups
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理角色等级提升
- en: As I previously mentioned, in this section, you are going to level up your hero’s
    experience and skills. As usual, you’ll be dabbling in code magic to make it happen!
    After all, you are programming a fantasy game.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，在本节中，你将提升你英雄的经验值和技能。像往常一样，你将运用代码魔法来实现它！毕竟，你正在编写一个幻想游戏。
- en: I know it might seem like a good idea to write your code inside the Character
    class but trust me when I say that there’s actually a much better spot for it.
    That is the `PlayerState` class, which we incidentally have already set for this
    occasion – a while ago, I asked you to create the `US_PlayerState` class and now
    is the time to add some valuable code in it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你可能觉得在Character类内部编写代码是个好主意，但请相信我，实际上有一个更好的地方。那就是`PlayerState`类，我们碰巧已经为这次场合设置了它——之前，我让你创建`US_PlayerState`类，现在就是时候在其中添加一些有价值的代码了。
- en: As introduced in *Chapter 4*, *Setting Up Your First Multiplayer Environment*,
    `PlayerState` is a class that holds information about a player’s game state and
    exists on both the server and clients. As we need to synchronize experience points
    and levels for the character, this is the ideal location to place everything.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如在*第4章*中介绍的，*设置您的第一个多人游戏环境*，`PlayerState`是一个包含玩家游戏状态信息的类，存在于服务器和客户端上。由于我们需要同步角色的经验值和等级，这是放置所有内容的理想位置。
- en: What we need to do here is to keep track of experience points and, as soon as
    the character reaches a new level, broadcast the information across the network
    and update the character statistics.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里需要做的是跟踪经验值，一旦角色达到新的等级，就通过网络广播信息并更新角色统计数据。
- en: But first, the most important thing is to have a clear idea of what we are going
    to do.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，最重要的是要有一个清晰的思路，知道我们打算做什么。
- en: Planning ahead
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提前规划
- en: As the `PlayerState` class will keep important information about the character,
    it’s mandatory to think ahead about what you want to achieve and how to get to
    that point – this means we have to plan exactly what we will be adding to this
    class.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`PlayerState`类将保存有关角色的重要信息，因此必须提前考虑你想要实现的目标以及如何达到那个目标——这意味着我们必须确切地规划我们将要添加到这个类中的内容。
- en: 'Here are some of the main features this gameplay framework class will implement:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个游戏框架类将实现的一些主要功能：
- en: Keeping track of the character’s current level and experience points
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪角色的当前等级和经验值
- en: Synchronizing the aforementioned properties over the network
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络上同步上述属性
- en: Updating the Character class whenever the player levels up
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家等级提升时更新角色类
- en: Broadcasting events whenever the character gets some experience points or levels
    up
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当角色获得一些经验值或等级提升时广播事件
- en: As a starting point, in the next subsection, we’ll start by declaring the required
    properties and functions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 作为起点，在下一个子节中，我们将首先声明所需的属性和函数。
- en: Declaring PlayerState properties and functions
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明`PlayerState`属性和函数
- en: In the following steps, we are going to define the main properties that will
    let the character level up whenever they have enough experience – this means we
    will need to track the thief’s experience points and level. Additionally, whenever
    values change, we will replicate these properties over the network and notify
    this event to each registered Actor in the game.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将定义主要属性，以便角色在获得足够经验时能够升级——这意味着我们需要跟踪盗贼的经验点和等级。此外，每当值发生变化时，我们将在网络上复制这些属性，并将此事件通知游戏中注册的每个Actor。
- en: 'So, let’s start by opening the `US_PlayerState.h` file and adding the following
    code in the `protected` section:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先打开`US_PlayerState.h`文件，并在`protected`部分添加以下代码：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the first thing we have done is declare the two properties `Xp`
    (short for experience points) and `CharacterLevel`; both can be modified in Unreal’s
    `EditDefaultsOnly` attribute, but `BlueprintsReadOnly` makes them non-modifiable
    in a Blueprint, to keep all the level-up logic inside the C++ source code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们首先声明了两个属性`Xp`（代表经验点）和`CharacterLevel`；它们都可以在Unreal的`EditDefaultsOnly`属性中进行修改，但`BlueprintsReadOnly`使它们在蓝图不可修改，以保持所有升级逻辑都在C++源代码中。
- en: As an additional attribute, we use the `ReplicatedUsing` attribute, which I
    introduced in the previous section. This will let us execute a function whenever
    a property is updated – in this case, we have set `OnRep_Xp` for the `Xp` property
    and `OnRep_CharacterLevelUp` for `CharacterLevel`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为附加属性，我们使用`ReplicatedUsing`属性，我在上一节中介绍了它。这将使我们能够在属性更新时执行函数——在这种情况下，我们为`Xp`属性设置了`OnRep_Xp`，为`CharacterLevel`设置了`OnRep_CharacterLevelUp`。
- en: 'Next, create a `public` section in your header file and add this code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在你的头文件中创建一个`public`部分，并添加以下代码：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function will let us assign new experience points to the `PlayerState`.
    We need to make it `BlueprintCallable` in order to use this function from our
    Blueprints – for instance, from a pickup.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将使我们能够为新`PlayerState`分配新的经验点。我们需要将其设置为`BlueprintCallable`，以便从我们的蓝图（例如，从拾取物品）中使用此函数。
- en: 'Just after that, add this declaration:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，添加以下声明：
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As explained in the previous section, we need to override this method in order
    to declare the properties that will be replicated (more on this in a moment).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们需要重写此方法以声明将要复制的属性（更多内容将在稍后介绍）。
- en: All the necessary setup for implementing replication in our two properties has
    been completed, but a few additional elements still need to be incorporated to
    ensure everything works properly. We need to broadcast some information whenever
    these properties change – this will come in handy when you implement a user interface
    later in this chapter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 实现我们两个属性复制的所有必要设置已经完成，但仍需添加一些额外的元素以确保一切正常工作。我们需要在属性更改时广播一些信息——当你在本章的稍后部分实现用户界面时，这将很有用。
- en: To implement such functionality, you’ll be using **delegates**. You may be already
    familiar with this topic in C++, but you should be aware that, in Unreal Engine,
    a delegate provides a way to call member functions on C++ objects in a generic,
    type-safe manner through dedicated macros.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此类功能，你将使用**委托**。你可能已经熟悉这个话题在C++中的使用，但你应该知道，在Unreal Engine中，委托提供了一种以通用、类型安全的方式通过专用宏在C++对象上调用成员函数的方法。
- en: Note
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want more information about the types of delegates supported by Unreal
    Engine and how they can be used in your project, check out the official documentation,
    which can be found here: [https://docs.unrealengine.com/5.1/en-US/delegates-and-lamba-functions-in-unreal-engine/](https://docs.unrealengine.com/5.1/en-US/delegates-and-lamba-functions-in-unreal-engine/).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于Unreal Engine支持的类型和如何在项目中使用它们的信息，请查看官方文档，可以在以下链接找到：[https://docs.unrealengine.com/5.1/en-US/delegates-and-lamba-functions-in-unreal-engine/](https://docs.unrealengine.com/5.1/en-US/delegates-and-lamba-functions-in-unreal-engine/)。
- en: 'As we want broadcast events for the two properties, we will be declaring two
    delegates – one for each property. At the beginning of the header file, just before
    the `UCLASS()` declaration, add the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要为两个属性广播事件，我们将声明两个委托——一个用于每个属性。在头文件的开头，在`UCLASS()`声明之前，添加以下代码：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These two lines are pretty similar – they both declare a `Broadcast()` method
    to notify every listener of changes in your system. We will use these features
    in our Blueprint classes to bind events and react accordingly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行代码非常相似——它们都声明了一个`Broadcast()`方法来通知系统中的每个监听器发生变化。我们将在我们的蓝图类中使用这些功能来绑定事件并相应地做出反应。
- en: 'Let’s declare our `delegate` function. Create a `protected` section, and add
    the following two lines of code, which will be used to broadcast the events:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明我们的`delegate`函数。创建一个`protected`部分，并添加以下两行代码，这些代码将用于广播事件：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As their purpose is self-explanatory, I guess it’s time stop talking and start
    writing down the implementation!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的目的不言自明，我想现在是时候停止说话，开始写下实现代码了！
- en: Implementing the PlayerState logic
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现玩家状态（PlayerState）逻辑
- en: Now that all the properties and methods have been declared, you are going to
    implement the PlayerState logic – whenever the character gains some experience,
    you should check whether it has reached enough points to level up. Experience
    points gained and level-ups should be broadcast to the system, in order to keep
    everything synchronized.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有属性和方法都已声明，你将实现玩家状态（PlayerState）逻辑——每当角色获得一些经验时，你应该检查它是否达到了升级所需的足够点数。获得的经验点和升级应该广播到系统中，以保持一切同步。
- en: 'Start by opening the `US_PlayerState.cpp` file and adding the required `include`
    declarations:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开`US_PlayerState.cpp`文件并添加所需的`include`声明：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, add the implementation for the `GetLifetimeReplicatedProps()` method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为`GetLifetimeReplicatedProps()`方法添加实现：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, we are using the `DOREPLIFETIME_CONDITION()` macro, introduced
    in the previous section, to declare that the `Xp` and `CharacterLevel` properties
    should be replicated – in this case, we just want the property to be replicated
    on the owning player of the character (i.e., in the player’s client), and we do
    so by using the `COND_OwnerOnly` flag.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在使用上一节中引入的`DOREPLIFETIME_CONDITION()`宏来声明`Xp`和`CharacterLevel`属性应该被复制——在这种情况下，我们只想让属性在拥有角色的玩家（即玩家的客户端）上被复制，我们通过使用`COND_OwnerOnly`标志来实现这一点。
- en: 'Next, add the implementation for the `AddXp()` method using the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下代码为`AddXp()`方法添加实现：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, whenever we receive an experience point update, we simply add the value
    to the character pool (i.e., the `Xp` property). Next, we ascertain that the character
    is an `AUS_Character` type through a cast and, if the cast is successful, we retrieve
    its statistics to check whether it should level up. If the check is successful,
    we simply increase the character level and call the `UpdateCharacterStats()` method
    to make the thief update the skill row. As we change the values for the properties,
    we then broadcast the new value to all listeners. A couple of (temporary) debug
    messages complete the code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每当收到经验点更新时，我们只需将值添加到角色池（即`Xp`属性）中。接下来，我们通过强制转换为`AUS_Character`类型来确认角色类型，如果转换成功，我们检索其统计数据以检查是否应该升级。如果检查成功，我们简单地增加角色等级并调用`UpdateCharacterStats()`方法来让盗贼更新技能行。当我们更改属性值时，然后向所有听众广播新的值。一些（暂时的）调试信息完成了代码。
- en: 'The PlayerState is now almost finished – we just need to broadcast the values
    to the clients whenever values are updated from the server side. To do so, add
    this last block of code to the file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家状态（PlayerState）现在几乎完成了——我们只需要在服务器端更新值时向客户端广播这些值。为此，将以下代码块添加到文件中：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The broadcast call is self-explanatory – every registered Actor will receive
    the notification, along with the new value for the `Xp` and `CharacterLevel` properties.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 广播调用是显而易见的——每个注册的Actor都会收到通知，包括`Xp`和`CharacterLevel`属性的新的值。
- en: So, in the preceding steps, you have successfully developed a fully operational
    replication system that effectively manages the character experience gained and
    skill development. I’m aware that the task at hand may feel daunting and even
    sometimes counter-intuitive, but with time and practice, you can rest assured
    that everything will become easier and more manageable!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在之前的步骤中，你已经成功开发了一个完全可操作的复制系统，该系统能够有效管理获得的角色经验和技能发展。我知道手头的任务可能感觉令人畏惧，甚至有时感觉反直觉，但随着时间和实践，你可以放心，一切都会变得更容易、更易于管理！
- en: 'There’s still something missing in our game: actual experience points. Let’s
    not waste any time and work on adding an item that our character can use to gain
    experience points. In the next steps, you’ll be creating some coins, starting
    with the previously created `US_BasePickup` class, to grant your thief the much-desired
    experience.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中还有一些东西缺失：实际的经验点。让我们不要浪费时间，着手添加一个角色可以使用以获得经验点的物品。在接下来的步骤中，你将创建一些金币，从之前创建的`US_BasePickup`类开始，以赋予你的盗贼渴望的经验。
- en: Adding coin pickups to the level
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将金币收集添加到关卡中
- en: So, we are ready to create some coins that will be used in the game to add experience
    points to the character – this will be a simple Blueprint that will be spawned
    whenever enemies are killed or that will be available in the level.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们准备好创建一些将在游戏中使用以增加角色经验值的硬币 – 这将是一个简单的蓝图，每当敌人被杀死或该级别可用时都会生成。
- en: 'To do this, go back to Unreal Editor and compile the project, in order to update
    it with all your improvements. Then, navigate to the `Blueprints` folder and complete
    the following steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，请返回Unreal编辑器并编译项目，以便更新所有改进。然后，导航到`Blueprints`文件夹并完成以下步骤：
- en: Right-click in the Content Browser and select **Blueprint Class** | **US_BasePickup**
    to create a new Blueprint from it.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中右键点击并选择**蓝图类** | **US_BasePickup**，从它创建一个新的蓝图。
- en: Name the Blueprint `BP_GoldCoinPickup` and double-click on it to open it.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将蓝图命名为`BP_GoldCoinPickup`，双击它以打开它。
- en: In the **Components** panel, select the **Mesh** component and assign to the
    **Static Mesh** attribute the **coin** static mesh. Change its scale to **2**,
    in order to make it more visible in the game.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**组件**面板中，选择**网格**组件，并将其分配给**静态网格**属性，设置为**硬币**静态网格。将其比例改为**2**，以便在游戏中更明显。
- en: 'Your Blueprint should now be similar to the one shown in *Figure 6**.4*:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您的蓝图现在应该类似于**图6.4**所示：
- en: '![Figure 6.4 – The gold coin Blueprint](img/Figure_06_04_B18203.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 金币蓝图](img/Figure_06_04_B18203.jpg)'
- en: Figure 6.4 – The gold coin Blueprint
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 金币蓝图
- en: 'Now that the pickup has a base shape, it’s time to add some code logic to make
    things fully functional. Open the **Event Graph** tab and take the following steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在拾取项已经有了基础形状，是时候添加一些代码逻辑来使它完全功能化了。打开**事件图**选项卡，按照以下步骤操作：
- en: Create a variable of type **Integer** and call it **EarnedXp**, giving it a
    default value of **5**.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类型为**整数**的变量，命名为**获得经验值**，并为其设置默认值**5**。
- en: Right-click in the canvas and look for **Event Pickup**, adding it to the graph.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在画布上右键点击，查找**事件拾取**，并将其添加到图中。
- en: Add a **Cast To US_PlayerState** node and connect its incoming execution pin
    to the outgoing execution pin of the event.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**转换为US_PlayerState**节点，并将其输入执行引脚连接到事件的输出执行引脚。
- en: Click and drag from the **Owning Character** pin of the **Event** node and,
    after releasing the button, add a **Get PlayerState** node from the options that
    appear.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**拥有角色**的**事件**引脚点击并拖动，在释放按钮后，从出现的选项中选择添加一个**获取玩家状态**节点。
- en: Connect the **PlayerState** outgoing pin to the **Object** pin of the **Cast**
    node.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**PlayerState**的输出引脚连接到**Cast**节点的**对象**引脚。
- en: Click and drag from the outgoing **As Us PlayerState** pin to create an **Add**
    **Xp** node.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**As Us PlayerState**的输出引脚点击并拖动以创建一个**添加经验值**节点。
- en: Connect the success execution pin of the cast node to the incoming execution
    pin of the **Add** **Xp** node.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Cast**节点的成功执行引脚连接到**添加经验值**节点的输入执行引脚。
- en: Drag a **Get Earned Xp** node from the **Variables** section into the canvas
    and connect its pin to the **Value** pin of the **Add** **Xp** node.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**变量**部分拖动一个**获取获得经验值**节点到画布中，并将其引脚连接到**添加经验值**节点的**值**引脚。
- en: Finally, add a **Destroy Actor** node and connect it to the outgoing execution
    pin of the **Add** **Xp** node.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个**销毁演员**节点并将其连接到**添加经验值**节点的输出执行引脚。
- en: 'The final result of the graph is shown in *Figure 6**.5*:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图的最终结果如**图6.5**所示：
- en: '![Figure 6.5 – The Coin Event graph](img/Figure_06_05_B18203.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 硬币事件图](img/Figure_06_05_B18203.jpg)'
- en: Figure 6.5 – The Coin Event graph
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 硬币事件图
- en: As you can see, the visual scripting code is quite straightforward – whenever
    a character picks up a coin, its PlayerState will be updated with the experience
    points granted by it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，视觉脚本代码相当简单 – 每当角色捡起硬币时，其PlayerState将更新为它授予的经验值。
- en: To test the game, just drag a bunch of coins inside your level and play the
    game. Every time a character picks up a coin, you should see a display message,
    and when the character has enough experience, you should get another message,
    the level-up one.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试游戏，只需将一堆硬币拖放到您的级别中并玩游戏。每次角色捡起硬币时，您应该看到一个显示消息，当角色获得足够的经验时，您应该得到另一个消息，即升级消息。
- en: It should be noted that, in the previous code, the pickup event will be called
    both on the client and on the server – this is something that should not be done
    as it may provoke issues in your game. Luckily, in this case, the PlayerState
    will correctly handle the data, so we don’t have to worry about it. You will learn
    how to handle trickier situations in [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125),
    *Replicating Properties* *O**ver* *the Network*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，在之前的代码中，拾取事件将在客户端和服务器上同时调用——这是不应该做的事情，因为它可能会在你的游戏中引发问题。幸运的是，在这种情况下，PlayerState
    将正确处理数据，所以我们不必担心。你将在 [*第6章*](B18203_06.xhtml#_idTextAnchor125) 中学习如何处理更复杂的情况，*在网络中复制属性*。
- en: As an extra exercise, you can add a floating animation to the coin, just like
    you did for the spell book in [*Chapter 5*](B18203_05.xhtml#_idTextAnchor107),
    *Managing Actors in a* *Multiplayer Environment*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的练习，你可以给硬币添加一个浮动动画，就像你在 [*第5章*](B18203_05.xhtml#_idTextAnchor107) 中为法术书所做的，*在多人环境中管理演员*。
- en: Adding coin subclasses
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加硬币子类
- en: 'As an optional step, you can create different coin pickups with different values
    for experience points. Here’s how to do so:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 作为可选步骤，你可以创建具有不同经验值的不同硬币拾取。以下是这样做的方法：
- en: Right-click on `BP_SilverCoinPickup`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 `BP_SilverCoinPickup`。
- en: Assign a value of **3** to **Earned Xp** and **MI_Metal** as the mesh material.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Earned Xp** 和 **MI_Metal** 的值设置为 **3** 作为网格材质。
- en: To provide your character with various items to search for, repeat this step
    as many times as you desire. This will grant your character a diverse set of treasures
    to seek out.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你的角色有各种物品去寻找，你可以重复此步骤多次。这将赋予你的角色一个多样化的宝藏去寻找。
- en: In this section, you have created a level-up system for your thief hero. With
    the help of replication, a character will get the correct level-up notification
    upon reaching enough experience points. At the moment, this can be achieved by
    collecting coin pickups around the level – later on, you’ll spawn treasure upon
    defeating those nasty Lichlord minions!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你已经为你的盗贼英雄创建了一个升级系统。借助复制的帮助，当角色达到足够经验值时，将获得正确的升级通知。目前，这可以通过收集关卡周围的硬币拾取来实现——稍后，你将在击败那些讨厌的巫妖领主小兵时生成宝藏！
- en: In the next section, I will guide you through the creation of a simple UI that
    will show the character level and the experience points that have been gained;
    you’ll perform this task by listening to PlayerState notifications and reacting
    accordingly.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将指导你创建一个简单的用户界面，该界面将显示角色的等级和获得的经验值；你将通过监听玩家状态通知并相应地做出反应来完成此任务。
- en: Adding a HUD to the game
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向游戏中添加 HUD
- en: In this section, you will create a **Heads Up Display** (**HUD**) for the game
    that will assist in monitoring the player character’s progress during the game.
    As you may already know, the best way to create such information is through the
    **Unreal Motion Graphics** (**UMG**) system – a GUI-based editor that allows developers
    to create user interface elements for their game, such as menus, HUDs, and other
    display screens. You’ll be using this system to create the HUD widget with the
    relative info.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将为游戏创建一个 **抬头显示** (**HUD**)，以帮助在游戏过程中监控玩家角色的进度。正如你可能已经知道的，创建此类信息的最佳方式是通过
    **Unreal 动作图形** (**UMG**) 系统——这是一个基于 GUI 的编辑器，允许开发者为他们游戏创建用户界面元素，如菜单、HUD 和其他显示屏幕。你将使用此系统来创建带有相对信息的
    HUD 小部件。
- en: What we need to show at the moment is quite simple – one set of text showing
    the character’s experience points and another set showing the level.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们需要显示的内容相当简单——一组显示角色经验值的文本和另一组显示等级的文本。
- en: Let’s start by creating the Blueprint and the visual elements.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建蓝图和视觉元素。
- en: Creating the Widget Blueprint
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建小部件蓝图
- en: 'To create the Widget Blueprint, within Unreal Editor, take the following steps:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建小部件蓝图，在 Unreal 编辑器中，请执行以下步骤：
- en: Open your `Blueprints` folder, right-click on the Content Browser, and select
    `WB_HUD` and double-click on the asset to open it.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的 `Blueprints` 文件夹，右键点击内容浏览器，选择 `WB_HUD` 并双击资产以打开它。
- en: Drag a **Canvas** element from the **Palette** tab into the **Designer** view.
    This canvas will act as the main container for your visual elements.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Palette** 选项卡拖动一个 **Canvas** 元素到 **Designer** 视图中。这个画布将作为你的视觉元素的主要容器。
- en: Drag a **Text** element into the previously added **Canvas** and call it **XpLabel**.
    Make sure that the **Is Variable** field in the **Details** panel is checked to
    expose this element in the graph you’ll be using later.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**Text**元素拖入之前添加的**Canvas**中，并将其命名为**XpLabel**。确保在**Details**面板中勾选**Is Variable**字段，以便在稍后使用的图中暴露此元素。
- en: Position the label somewhere on the canvas that suits your needs; in my case,
    I opted for the top-left corner of the screen.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标签放置在画布上适合你需求的位置；在我的情况下，我选择了屏幕的左上角。
- en: Drag another **Text** element into the **Canvas** instance and call it **CharacterLevelLabel**.
    Again, make sure that the **Is Variable** field in the **Details** panel is checked
    to expose this element in the graph you’ll be using later.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将另一个**Text**元素拖入之前添加的**Canvas**实例中，并将其命名为**CharacterLevelLabel**。再次确保在**Details**面板中勾选**Is
    Variable**字段，以便在稍后使用的图中暴露此元素。
- en: Position the label somewhere on the canvas that suits your needs; in my case,
    I opted for the top-right corner of the screen.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标签放置在画布上适合你需求的位置；在我的情况下，我选择了屏幕的右上角。
- en: 'The final result of your HUD should be similar to *Figure 6**.6*:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你的HUD最终结果应该类似于*图6**.6*：
- en: '![Figure 6.6 – The HUD designer panel](img/Figure_06_06_B18203.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – HUD设计面板](img/Figure_06_06_B18203.jpg)'
- en: Figure 6.6 – The HUD designer panel
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – HUD设计面板
- en: Now that you have created the widget, it’s time to add some Visual Scripting
    code to make it fully functional.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了小部件，是时候添加一些Visual Scripting代码来使其完全功能化了。
- en: Adding code logic to the Widget Blueprint
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向Widget蓝图添加代码逻辑
- en: In the following steps, you’ll add some code logic to the Blueprint, in order
    to listen to events from the PlayerState and react accordingly.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，你将在蓝图上添加一些代码逻辑，以便监听PlayerState的事件并相应地做出反应。
- en: Creating a custom event for the experience points label
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为经验值标签创建自定义事件
- en: 'Let’s start by creating a custom event that will update the experience points
    label. To do this, open the **Graph** panel of your widget and take the following
    steps:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个自定义事件，该事件将更新经验值标签。为此，打开你的小部件的**Graph**面板并执行以下步骤：
- en: Create a custom event and call it `OnXpChanged_Event`.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个自定义事件，并将其命名为`OnXpChanged_Event`。
- en: Select it and, in the `NewXp`.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择它，在`NewXp`。
- en: From the **MyBlueprint** panel, drag a getter node for **XpLabel**.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**MyBlueprint**面板中，拖动一个**XpLabel**的获取节点。
- en: From the **XpLabel** outgoing pin, click and drag, adding a **SetText (****Text)**
    node.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**XpLabel**输出引脚，点击并拖动，添加一个**SetText (****Text)**节点。
- en: Connect the **OnXpChanged_Event** execution pin to the incoming **SetText (Text)**
    execution pin.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**OnXpChanged_Event**执行引脚连接到传入的**SetText (Text)**执行引脚。
- en: Connect the **New Xp** pin of the **Event** node to the **In Text** pin of the
    **SetText (Text)** node. This operation will automatically add a **To Text (Integer)**
    node converter.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Event**节点的**New Xp**引脚连接到**SetText (Text)**节点的**In Text**引脚。此操作将自动添加一个**To
    Text (Integer)**节点转换器。
- en: 'The final result of this piece of code is shown in *Figure 6**.7*:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的最终结果显示在*图6**.7*中：
- en: '![Figure 6.7 – The Xp custom event](img/Figure_06_07_B18203.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – Xp自定义事件](img/Figure_06_07_B18203.jpg)'
- en: Figure 6.7 – The Xp custom event
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – Xp自定义事件
- en: 'As an additional, optional step, you may want to add an `Experience Points`
    (for example, `Experience` `Points: 150`).'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '作为额外的、可选步骤，你可能想要添加一个`经验值`（例如，`经验` `值: 150`）。'
- en: Now that you have a custom event to handle the experience points label, it’s
    time to do the same for the character level.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个自定义事件来处理经验值标签，是时候为角色等级做同样的事情了。
- en: Creating a custom event for the character level label
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为角色等级标签创建自定义事件
- en: 'Let’s now create a custom event that will update the character level label:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个自定义事件，该事件将更新角色等级标签：
- en: Create a custom event and call it `OnCharacterLevelUp_Event`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个自定义事件，并将其命名为`OnCharacterLevelUp_Event`。
- en: Select it and, in the `NewLevel`.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择它，在`NewLevel`。
- en: From the **MyBlueprint** panel, drag a getter node for **CharacterLevelLabel**.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**MyBlueprint**面板中，拖动一个**CharacterLevelLabel**的获取节点。
- en: From the **CharacterLevelLabel** outgoing pin, click and drag and, after releasing
    the mouse button, select a **SetText (Text)** node from the options that appear.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**CharacterLevelLabel**输出引脚，点击并拖动，在释放鼠标按钮后，从出现的选项中选择一个**SetText (Text)**节点。
- en: Connect the **OnLevelLabelChanged_Event** execution pin to the incoming **SetText
    (Text)** execution pin.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**OnLevelLabelChanged_Event**执行引脚连接到传入的**SetText (Text)**执行引脚。
- en: Connect the **New Level** pin of the **Event** node to the **In Text** pin of
    the **SetText (Text)** node. This operation will automatically add a **To Text
    (Integer)** node converter.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**事件**节点的**新关卡**引脚连接到**setText (Text)**节点的**In Text**引脚。此操作将自动添加一个**To Text
    (Integer)**节点转换器。
- en: 'The final result of this piece of code is shown in *Figure 6**.8*:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的最终结果显示在*图6.8*中：
- en: '![Figure 6.8 – The character level custom event](img/Figure_06_08_B18203.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8 – 角色等级自定义事件](img/Figure_06_08_B18203.jpg)'
- en: Figure 6.8 – The character level custom event
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 角色等级自定义事件
- en: 'Just like the previous label, you may want to use the `Level:` (for example,
    `Level: 1`).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '就像之前的标签一样，你可能想使用`Level:`（例如，`Level: 1`）。'
- en: Now that you have a custom event to handle the character level label, it’s time
    to bind these events to the notifications broadcast by the PlayerState.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了处理角色等级标签的自定义事件，是时候将这些事件绑定到PlayerState广播的通知上了。
- en: Binding to PlayerState events
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定到PlayerState事件
- en: 'In this final step of the Widget Blueprint, you will bind the previously created
    events to the PlayerState, in order to update the HUD every time an update notification
    is dispatched:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在Widget蓝图的这个最终步骤中，你将绑定之前创建的事件到PlayerState，以便在每次更新通知分发时更新HUD：
- en: Add an **Event on Initialized** node to the graph. This node is executed only
    once during the game (i.e., when the object has been initialized) and is the best
    place to add bindings.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图中添加一个**初始化事件**节点。此节点在游戏过程中仅执行一次（即，当对象已初始化时），是添加绑定操作的最佳位置。
- en: Connect the event to a **Delay** node with **Duration** equal to **0,2**. As
    the PlayerState won’t be available at initialization time, waiting until it is
    available is a quick solution to solve the issue.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将事件连接到一个**Delay**节点，其**Duration**设置为**0,2**。由于PlayerState在初始化时不可用，等待它可用是快速解决问题的方法。
- en: Add a **Branch** node and connect its incoming execution pin to the **Completed**
    execution pin of the **Delay** node. Connect the **False** execution pin of the
    **Branch** node to the incoming execution pin of the **Delay** node; this will
    create a loop that will go on until the PlayerState has been properly initialized.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Branch**节点，并将其输入执行引脚连接到**Delay**节点的**Completed**执行引脚。将**Branch**节点的**False**执行引脚连接到**Delay**节点的输入执行引脚；这将创建一个循环，直到PlayerState被正确初始化。
- en: Now we are going to recover the PlayerState from the player owning this widget.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将从这个widget的拥有者恢复PlayerState。
- en: Add a **Get Owning Player** node to the graph. This node returns the player
    that is controlling (i.e., owns) the HUD.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图中添加一个**获取拥有玩家**节点。此节点返回控制（即，拥有）HUD的玩家。
- en: From the **Return Value** pin of this node, click and drag to create a **Get**
    **PlayerState** node.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从此节点的**返回值**引脚，点击并拖动以创建一个**Get PlayerState**节点。
- en: From the `US_PlayerState` class, we are pretty sure that we are going to recover
    that type of PlayerState, so we don’t need to worry about validation.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`US_PlayerState`类，我们相当确信我们将恢复那种类型的PlayerState，因此我们不需要担心验证。
- en: Connect the **Success** pin of the **Cast To US_PlayerState** node to the **Condition**
    pin of the **Branch** node.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Cast To US_PlayerState**节点的**Success**引脚连接到**Branch**节点的**Condition**引脚。
- en: From the outgoing `PlayerState`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输出的`PlayerState`。
- en: Connect the **True** execution pin of the **Branch** node to the incoming **Set
    PlayerState** execution pin.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Branch**节点的**True**执行引脚连接到**Set PlayerState**的输入执行引脚。
- en: 'The visual scripting code created so far is shown in *Figure 6**.9*:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止创建的可视化脚本代码显示在*图6.9*中：
- en: '![Figure 6.9 – The first part of the PlayerState binding](img/Figure_06_09_B18203.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9 – PlayerState绑定的第一部分](img/Figure_06_09_B18203.jpg)'
- en: Figure 6.9 – The first part of the PlayerState binding
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – PlayerState绑定的第一部分
- en: Now that you have a reference to the PlayerState, it’s time to bind the custom
    events to the delegate you created in the previous sections.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了`PlayerState`的引用，是时候将自定义事件绑定到之前章节中创建的委托上了。
- en: From the outgoing pin of the `US_PlayerState` class.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`US_PlayerState`类的输出引脚。
- en: Connect the outgoing execution pin of **Set PlayerState** to the incoming execution
    pin of the **Bind Event to On Xp** **Changed** node.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Set PlayerState**的输出执行引脚连接到**Bind Event to On Xp Changed**节点的输入执行引脚。
- en: From the **Event** pin of the bind node, click and drag to add a **Create Event**
    node. This node has a drop-down menu – here, select **OnXpChanged_Event (NewXp)**,
    which will execute the **OnXpChanged_Event** custom event whenever the system
    receives the corresponding notification from the PlayerState.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从绑定节点的**Event**引脚，点击并拖动以添加一个**Create Event**节点。此节点有一个下拉菜单 – 在这里，选择**OnXpChanged_Event
    (NewXp)**，这将执行**OnXpChanged_Event**自定义事件，每当系统从PlayerState接收到相应的通知时。
- en: Connect the outgoing execution pin of the **Bind** **Event to On Xp Changed**
    node to an **On Xp Changed Event** node; this will call the event upon initialization,
    to update the HUD.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Bind Event to On Xp Changed**节点的输出执行引脚连接到一个**On Xp Changed Event**节点；这将初始化时调用事件，以更新HUD。
- en: From the **Variables** section, drag a **Get PlayerState** node and from it,
    create a **Get Xp** node. Connect the outgoing pin of the **Get Xp** node to the
    **New Xp** pin of the **On Xp Changed** **Event** node.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Variables**部分，拖动一个**Get PlayerState**节点，并从它创建一个**Get Xp**节点。将**Get Xp**节点的输出引脚连接到**On
    Xp Changed Event**节点的**New Xp**引脚。
- en: 'This portion of the Visual Scripting code is shown in *Figure 6**.10*:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分的Visual Scripting代码如*图 6.10*所示：
- en: '![Figure 6.10 – The second part of the PlayerState binding](img/Figure_06_10_B18203.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 – PlayerState 绑定的第二部分](img/Figure_06_10_B18203.jpg)'
- en: Figure 6.10 – The second part of the PlayerState binding
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – PlayerState 绑定的第二部分
- en: The last part of the binding phase is almost identical to the steps you have
    just taken, with the exception that we are creating a binding for the player level.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定阶段的最后部分几乎与您刚刚采取的步骤相同，只是我们现在为玩家等级创建绑定。
- en: From the outgoing pin of the **On Xp Changed Event** node, click and drag to
    create a **Bind Event to On Character Level** **Up** node.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**On Xp Changed Event**节点的输出引脚，点击并拖动以创建一个**Bind Event to On Character Level
    Up** **Up**节点。
- en: Drag a **Get PlayerState** node from the **Variables** section and connect it
    to the **Target** pin of the **Bind Event to On Character Level** **Up** node.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Variables**部分拖动一个**Get PlayerState**节点并将其连接到**Bind Event to On Character
    Level Up**节点的**Target**引脚。
- en: From the **Event** pin of the **Bind** **Event to On Character Level Up** node,
    click and drag to add a **Create Event** node. From the drop-down menu, select
    **OnCharacterLevelUp_Event (NewLevel)**. This selection will execute the **OnCharacterLevelUp_Event**
    custom event whenever the system receives the corresponding notification from
    the PlayerState.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Bind Event to On Character Level Up**节点的**Event**引脚，点击并拖动以添加一个**Create Event**节点。从下拉菜单中选择**OnCharacterLevelUp_Event
    (NewLevel)**。此选择将在系统从PlayerState接收到相应的通知时执行**OnCharacterLevelUp_Event**自定义事件。
- en: Connect the outgoing execution pin of the **Bind** node to an **On Character
    Level Up Event** node; this will call the event upon initialization, to update
    the HUD.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Bind**节点的输出执行引脚连接到一个**On Character Level Up Event**节点；这将初始化时调用事件，以更新HUD。
- en: From the **Variables** section, drag a **Get PlayerState** node to create a
    **Get Character Level** node. Connect the outgoing pin of the **Get Character
    Level** node to the **New Level** pin of the **On Character Level Up** **Event**
    node.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Variables**部分，拖动一个**Get PlayerState**节点以创建一个**Get Character Level**节点。将**Get
    Character Level**节点的输出引脚连接到**On Character Level Up Event**节点的**New Level**引脚。
- en: 'This final part of the graph is shown in *Figure 6**.11*:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此图的最后一部分如*图 6.11*所示：
- en: '![Figure 6.11 – The final part of the PlayerState binding](img/Figure_06_11_B18203.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11 – PlayerState 绑定的最后一部分](img/Figure_06_11_B18203.jpg)'
- en: Figure 6.11 – The final part of the PlayerState binding
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – PlayerState 绑定的最后一部分
- en: You have finally created all the bindings to listen to any PlayerState notifications
    and update the HUD accordingly. It’s now time to add the final step – showing
    the HUD in-game.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建好了所有用于监听任何PlayerState通知并相应更新HUD的绑定。现在是时候添加最后一步 – 在游戏中显示HUD。
- en: Adding the HUD to the character
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将HUD添加到角色上
- en: Now you will add the HUD to the player viewport. If you are already familiar
    with Unreal Engine user interfaces in standalone games, you may already know how
    things work.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将添加HUD到玩家视图中。如果你已经熟悉独立游戏中的Unreal Engine用户界面，你可能已经知道如何操作。
- en: However, you should be aware that, in a multiplayer environment, a user interface
    widget should be attached to the game viewport only if the character is controlled
    locally (i.e., is the owning client). If you don’t check whether the character
    creating the widget is controlled locally, you will create a widget for each character
    spawned in the level – including those controlled by other players and replicated
    in the client. Having a cluttered mess of superimposed HUDs is obviously something
    you don’t want to have in your game!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你应该意识到，在多人环境中，只有当角色由本地控制（即拥有客户端）时，用户界面小部件才应该附加到游戏视图中。如果你没有检查创建小部件的角色是否由本地控制，你将为级别中生成的每个角色创建一个小部件——包括由其他玩家控制并在客户端复制的角色。显然，在游戏中出现杂乱无章的叠加HUD不是你想要看到的情况！
- en: 'To add the HUD to the character, follow these steps:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要将HUD添加到角色，请按照以下步骤操作：
- en: Start by finding the **BP_Character** Blueprint and opening it.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，找到**BP_Character**蓝图并打开它。
- en: In the Event Graph, find the **Begin Play** event. Then, add a **Branch** node
    to the execution pin of the event.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件图中，找到**开始播放**事件。然后，将一个**分支**节点添加到事件的执行引脚。
- en: Connect the **Condition** pin of the **Branch** node to an **Is Locally Controlled**
    node – this will guarantee we are attaching the HUD only to the character controlled
    by the client.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**分支**节点的**条件**引脚连接到一个**本地控制**节点——这将确保我们只将HUD附加到由客户端控制的角色。
- en: From the **True** execution pin of the **Branch** node, create a **Create Widget**
    node. From the **Class** drop-down menu, choose **WB_HUD** to select our HUD.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**分支**节点的**True**执行引脚创建一个**创建小部件**节点。从**类**下拉菜单中选择**WB_HUD**以选择我们的HUD。
- en: Connect the outgoing execution pin of the **Create Widget** node to an **Add
    to Viewport** node. Connect the **Return Value** pin to the **Target** pin.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**创建小部件**节点的输出执行引脚连接到**添加到视图**节点。将**返回值**引脚连接到**目标**引脚。
- en: 'The final result of the graph can be seen in *Figure 6**.12*:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图表的最终结果可以在*图6**.12*中看到：
- en: '![Figure 6.12 – Adding the HUD to the viewport](img/Figure_06_12_B18203.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图6.12 – 将HUD添加到视图中](img/Figure_06_12_B18203.jpg)'
- en: Figure 6.12 – Adding the HUD to the viewport
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 – 将HUD添加到视图中
- en: The previous Visual Scripting code is pretty easy to understand, but it is important
    to mention that the viewport is only added to the character controlled by the
    client, as having multiple HUDs overlaying each other would not be desirable!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的视觉脚本代码相当容易理解，但重要的是要提到，视口只添加到由客户端控制的角色，因为多个HUD重叠并不是理想的情况！
- en: Now that everything has been properly set, you are going to test your game to
    see how it works!
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都已经设置妥当，你将测试你的游戏以查看它的工作情况！
- en: Testing the game
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试游戏
- en: 'To test the game, start playing it as a listen server and check that everything
    works fine. In particular, you should see the following behaviors:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试游戏，请以监听服务器的形式开始玩游戏，并检查一切是否正常工作。特别是，你应该看到以下行为：
- en: At the start of the game, the HUD should show 0 experience points and the character
    level equal to 1
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏开始时，HUD应显示0经验值和角色等级等于1
- en: Every time a character picks a coin up, the HUD should update the total experience
    points
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当角色捡起一枚硬币时，HUD应更新总经验值
- en: If the target experience points are reached, the player should level up and
    the HUD will show the new level
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果达到目标经验值，玩家应升级，并且HUD将显示新的等级
- en: 'The final result should be pretty similar to the one shown in *Figure 6**.13*:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应该与*图6**.13*中显示的相当相似：
- en: '![Figure 6.13 – The Final HUD](img/Figure_06_13_B18203.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图6.13 – 最终HUD](img/Figure_06_13_B18203.jpg)'
- en: Figure 6.13 – The Final HUD
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13 – 最终HUD
- en: 'If everything goes according to plan, you’re all set to embark on the next
    exciting chapter of the Lichlord multiplayer epic: client-server communication!'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按计划进行，你就可以开始进入Lichlord多人史诗的下一章：客户端-服务器通信了！
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, I have introduced you to one of the most important topics
    in the Unreal Engine multiplayer framework: replication.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我向您介绍了虚幻引擎多人框架中最重要的话题之一：复制。
- en: As a first step, you created some statistics for the player, in order to make
    your gameplay more flexible. You did this through structures and data tables –
    a topic that will come in handy even if you are developing a standalone game.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，你为玩家创建了一些统计数据，以便使你的游戏玩法更加灵活。你是通过结构和数据表来做到这一点的——即使你在开发独立游戏，这个话题也会很有用。
- en: Next, I explained the topic of property replication and how to apply it to your
    project. Once the main concepts were defined, you started using them on the PlayerState,
    in order to keep track of the character’s progress during gameplay.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我解释了属性复制的主题以及如何将其应用到你的项目中。一旦主要概念被定义，你开始在使用它们在PlayerState中，以便在游戏过程中跟踪角色的进度。
- en: As a last step, you created a HUD to show this progress to the player. Replication
    is mostly important here as each client should get its own updates and show them
    to the player.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，你创建了一个HUD来向玩家展示进度。在这里，复制功能尤为重要，因为每个客户端都应该获得自己的更新并将其展示给玩家。
- en: In the next chapter, you’ll dive deeper into the mystical realm of replication,
    flexing your skills in the delicate art of calling methods from client to server
    and back again like it’s nobody’s business.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将深入神秘复制的领域，展示你在从客户端到服务器以及返回的微妙艺术中运用技能，仿佛这并非难事。
- en: Get ready to take things to the next level – we’re about to climb the staircase
    of multiplayer development, two steps at a time!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好将事物提升到下一个层次——我们将一步步攀登多人游戏开发的阶梯，每次前进两步！
