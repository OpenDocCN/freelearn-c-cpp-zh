- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Replicating Properties Over the Network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Replication is an important concept when it comes to creating multiplayer games
    with Unreal Engine. In particular, **property replication** allows for the synchronization
    of objects between multiple players, letting them interact in a shared environment.
    This feature also handles things such as character movement and physics calculations,
    ensuring everyone has a consistent experience and view of the game world, regardless
    of the platform type, and that no one has an advantage due to cheating or latency
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll start working on replication, mainly focusing on property
    replication of your character skills. Next, starting from the base pickup you
    created in the last chapter, you’ll implement a coin pickup that will grant the
    character experience points that will give the character a level-up during gameplay.
    Finally, you’ll apply replication by updating a simple user interface that will
    show the character experience points and level.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you will have a good grasp of how an Actor replicates
    in a multiplayer setting and the properties that come with it. Essentially, you’ll
    understand how Actors behave and operate in a multi-player environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next sections, I will present the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding character stats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding property replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling characters level-ups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a HUD to the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the topics presented in this chapter, you should have completed the
    previous ones and understood their content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the `.zip` project files provided in this book’s
    companion project repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5).'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the files that are up to date with the end of the last chapter
    by clicking the `Unreal Shadows –` `Chapter 05``End` link.
  prefs: []
  type: TYPE_NORMAL
- en: Adding character stats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before introducing property replication and implementing it in the project,
    our thief hero needs to be ready for such a big step: that’s why I’ll guide you
    through the creation of a set of statistics that will be plugged into the Character
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is to define your character stats. In particular, you
    will need the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: A walk and a sprint speed, to handle the different paces of your character during
    gameplay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A damage multiplier to manage more powerful hits whenever the character levels
    up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A level-up value to check whenever the character has reached the next level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stealth multiplier that will handle how much noise the character makes when
    walking or sprinting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may have noticed that your character has no health – that is because this
    is a stealth game and players will have to move carefully through the dungeon.
    Once they are discovered, they won’t have the option of facing a swarm of undead
    lackeys in this particular game! As a consequence, gameplay will be more focused
    on defeating enemies from a distance or slipping silently away from them.
  prefs: []
  type: TYPE_NORMAL
- en: With the previous information, you’ll create a data structure containing all
    the data points for initializing the character, and then you’ll create a data
    table that will let you manage the experience your thief will gain during gameplay.
    So, let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the stats structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To begin, you need to create a structure that will include all the aforementioned
    statistics. As this is not a class, you won’t need to create it from Unreal Engine
    Editor but from the IDE instead.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Non-class entities cannot be made directly from within Unreal Editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your IDE and create a file in your `UnrealShadows_LOTL` | `Source` | `UnrealShadows_LOTL`
    folder called `US_CharacterStats.h` (as this is a data structure, you won’t need
    a `.cpp` file). Then, open the file and insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `include` section is self-explanatory – after that, along with the standard
    C++ `struct` keyword to declare a structure, you will notice an `USTRUCT()` declaration
    instead of `UCLASS()` and an `F` prefix on the structure name (i.e., `FUS_CharacterStats`).
    This is the standard method to declare a structure in Unreal Engine. Then, in
    order to let Unreal Editor create data tables from this structure (more on this
    in a few moments), the `FTableRowBase` type is extended.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the structure declaration, we are just adding a list of properties –
    all of them are marked `BlueprintReadWrite` to let Blueprints access and modify
    the data, and `EditAnywhere` to let you edit the values inside the data table
    you are going to create in the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a stats data table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you have created a data structure for your character and are ready to create
    the actual data from it. In Unreal Engine, we will use a `UObject` property –
    including asset references from the projects, such as materials or textures.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create your character data table, see the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your `Blueprints` folder in the Content Browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile your project in order to make the C++ structure available in the Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the Content Browser and select **Miscellaneous** | **Data Table**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Pick Row Structure** pop-up window, select **US_CharacterStats** from
    the drop-down menu, as depicted in *Figure 6**.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The data table creation panel](img/Figure_06_01_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The data table creation panel
  prefs: []
  type: TYPE_NORMAL
- en: Click the `US_CharacterStats`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click on the newly created asset to open it. You will get an empty dataset
    as shown in *Figure 6**.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The empty data table](img/Figure_06_02_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – The empty data table
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A data table can also be generated by importing a `.csv` or `.json` file into
    your project. Additionally, Unreal Engine will let you easily export your project
    tables in `.csv` and `.json` formats. For more information about the importing
    and exporting processes, check the official documentation linked here: [https://docs.unrealengine.com/5.1/en-US/data-driven-gameplay-elements-in-unreal-engine/](https://docs.unrealengine.com/5.1/en-US/data-driven-gameplay-elements-in-unreal-engine/).'
  prefs: []
  type: TYPE_NORMAL
- en: With your table open, it’s time to add some data rows organized by character
    levels – you do want to let your character grow when they gain enough experience,
    don’t you?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by adding a single row for your character base level:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Add** button in the **Table** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `level_01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are now ready to set some stats for the first experience level of your character.
    Look for the `250,0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`800,0`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1,0`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`10`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1,0`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final result should be the same as the settings shown in *Figure 6**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Settings for the level_01 character](img/Figure_06_03_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Settings for the level_01 character
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to add a couple more levels to handle the experience growth of
    the character during gameplay. Repeat the same steps as before, but call the two
    new rows `level_02` and `level_03` respectively. Then use the following values
    for the **level_02** row:'
  prefs: []
  type: TYPE_NORMAL
- en: '`275,0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`850,0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1,1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`25`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1,5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And add the following values for the **level_03** row:'
  prefs: []
  type: TYPE_NORMAL
- en: '`300,0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`900,0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1,0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`50`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are purely indicative values – you are free to tweak them to suit your
    own needs and add as many additional levels as you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have added a dataset for your character’s experience, you are ready
    to read the info included directly from your code. That’s why I need you to go
    back to the `US_Character.h` header file to add the data table declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the data table from the character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, you are going to add the data table to the character in order
    to read its values depending on the experience level. The first thing to do is
    to add a reference to the `US_Character.h` header file. So, in the `private` section
    of the header file, after all the existing declarations, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first declaration will let you reference the data table directly from the
    child Blueprint Classes, while the structure declaration will let you reference
    a single row from the data table and use it as the character statistics.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you will need to create a function that will allow the system to
    update the current level of the character. In the `public` section, add the following
    method declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing you need to add to the class header is a getter function for
    the stats structure. Still in the `public` section, just before the last closing
    bracket, add the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now save this file and open `US_Character.cpp` to handle the data retrieval.
    At the top of the file, add the `include` declarations for the classes you’ll
    be using in a moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement the `UpdateCharacterStats()` method by adding the following
    code at the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, first we check that the data table is referenced (you’ll add
    it later, from the character Blueprint) and then use the `GetAllRows<T>()` method
    to fetch all the table rows into a local array (i.e., the `CharacterStatsRows`
    variable). If there is at least one row in the data table, we get the one corresponding
    to the level of the character minus 1 (i.e., for a level 1 character, we will
    get the row number 0). Notice, as well, the `FMath::Clamp()` method, which guarantees
    we are not trying to get a level value that’s higher than the available rows in
    the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we retrieve the `WalkSpeed` column from the row and assign its value
    to the `MaxWalkSpeed` property of the character movement component – this means
    that, if there is a data table assigned, your character will start the game with
    a value from the dataset and not from the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are now ready to update your character stats to level 1 – something you
    are about to do in the `BeginPlay()` function. To do so, inside the `BeginPlay()`
    function, and just before the closing bracket, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing you need to do is to update the two sprint methods that, at
    the moment, are using hardcoded values but need to use the data table stats. To
    do so, search for the `SprintStart()` method and find the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s do the same with the `SprintEnd()` method, which should be positioned
    just after the previous one. Find the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then change it using the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, the code is self-explanatory – we just check that there is valid
    data referenced in the character stats and assign the sprint or walk speed to
    the character movement component.
  prefs: []
  type: TYPE_NORMAL
- en: Now save your file and compile the project, just to be sure that everything
    is fine and ready for the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Your character is now ready to accept the data table we created at the beginning
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the data table to the character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add the data table asset to the character, switch back to Unreal Editor
    and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **BP_Character** Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Class Defaults** tab and, in the **Details** panel, look for the
    **Character** **Data** category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Character Data Table** attribute, click on the drop-down menu and select
    **DT_CharacterStats**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your character is now ready to use the statistics from the dataset – even though
    the poor thief is locked into a level 1 experience level, later on, you will set
    them free in the dungeon and see how they fare!
  prefs: []
  type: TYPE_NORMAL
- en: 'Test the game to check that everything works properly. Just remember what I
    said in the previous chapter: movement is still buggy as the client and the server
    are trying to force the character to conform to different speed values, but you
    are nearing the solution.'
  prefs: []
  type: TYPE_NORMAL
- en: So, in this section, you have improved the character by adding some statistics
    retrieved from a data table and using them to initialize some properties. At the
    moment, you have just used the movement ones, but don’t be afraid! Once the character
    is completed, everything will fall into place.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, we’ll dive into the topic of property replication in
    Unreal – something that will come in handy when it’s time to level up your character
    and something you’ll be doing by the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding property replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As stated before, property replication allows for the synchronization of objects
    in an Unreal multiplayer environment. It should be noted that, as the server is
    authoritative, updates will never be sent by the client. Obviously, the client
    may (politely) ask the server to change a property value, and the server will
    behave accordingly. Additionally, property replication acts as a reliable service:
    consequently, the Actor on the client will have the same value as the server sooner
    or later.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that if you’re trying to modify, from the client, a property that
    is replicated, any changes you make to that property will only be temporary. You
    should be already familiar with this topic as the character’s movement logic,
    at the moment, is a bit buggy – we are trying to make the character run from the
    client, but the server is blocking our commands as soon as the network is updated.
  prefs: []
  type: TYPE_NORMAL
- en: This is happening because, as soon as the server sends an update to the client
    with a new value for that property, any changes that you made locally on the client
    will be overwritten and replaced with the new, correct value from the server.
    Consequently, if the server does not update frequently, it may take a while for
    the client to be notified about the new, correct value.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing that nasty bug is something we will be doing in [*Chapter 7*](B18203_07.xhtml#_idTextAnchor147),
    *Using Remote Procedure Calls (RPCs)*, where you’ll need to learn how to call
    a function from the client to the server. The main focus of this chapter, however,
    is to understand how to replicate properties. So, without further ado, let’s check
    how things work under the hood!
  prefs: []
  type: TYPE_NORMAL
- en: Enabling property replication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for a property to be replicated, you need to set up a few things. First
    of all, in the Actor constructor that will contain the property, you will need
    to set the `bReplicates` flag to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A class or Blueprint extending from `APawn` or `ACharacter` will have the `bReplicates`
    property set to `true` by default, while a regular Actor won’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the property that should be replicated will need to have the `Replicated`
    specifier added to the `UPROPERTY()` macro. As an example, you can replicate the
    score for your character with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are in need of a callback function to be executed when a property is
    updated, you can use `ReplicatedUsing=[FunctionName]` instead – this attribute
    will let you specify a function that will be executed when an update is sent to
    the client. For example, if you want to execute a method called `OnRep_Score()`
    whenever your character score is replicated, you will write something similar
    to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You will then need to implement the `OnRep_Score()` method in the same class;
    this function must declare the `UFUNCTION()` macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all the replication properties are properly decorated by the previous
    attributes, they need to be declared inside the `AActor::GetLifetimeReplicatedProps()`
    function by using the `DOREPLIFETIME()` macro. Using the previous score example,
    you will need to declare the `Score` property by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After a property is registered for replication, it cannot be unregistered,
    as Unreal Engine will optimize data storage to reduce the computation time: this
    means that, by default, you will not have much control over how a property replicates.'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, you can use the `DOREPLIFETIME_CONDITION()` macro instead, which will
    let you add an additional condition for more precise control over replication.
    Values for these conditions are predefined – one example is `COND_OwnerOnly`,
    which will only send data to the Actor’s owner (we will use this value later in
    the chapter). As another example, if you need even more fine-grained control in
    property replication, you can use the `DOREPLIFETIME_ACTIVE_OVERRIDE()` macro,
    which will let you use your own conditions defined inside the Actor.
  prefs: []
  type: TYPE_NORMAL
- en: The major downside of using additional conditions for replication is performance,
    as the engine will need to do additional checks before replicating a property
    – this means that it is advisable to use the `DOREPLIFETIME()` macro in situations
    where no pressing requirements dictate the use of an alternative option.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how an object can be replicated, it’s time for me to
    introduce how objects are referenced across the network.
  prefs: []
  type: TYPE_NORMAL
- en: Referencing Actors and components over the network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sooner or later, you will need to reference an Actor or a component from your
    code – this means that, in a multiplayer game, you will need to know whether the
    reference can be replicated or not. Simply put, an Actor or a component can be
    referenced over the network only if it is supported for networking.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some simple rules that will help you determine whether your object
    can be referenced over the network:'
  prefs: []
  type: TYPE_NORMAL
- en: If an Actor is replicated, it can also be replicated as a reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a component is replicated, it can also be replicated as a reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-replicated Actors and components need to be stably named in order to be
    replicated as references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: An object that is **stably named** means that an entity that will be present
    in both the server and the client that has the same name. For instance, an Actor
    is stably named if it was not spawned during gameplay but was loaded directly
    in the level from a package.
  prefs: []
  type: TYPE_NORMAL
- en: This section has provided you with an introduction to the fundamental concepts
    of network replication in Unreal Engine, explaining how it interacts with Actors
    and components. If you feel a bit lost about too much theory, don’t be afraid!
    You’ll be taking all that theory and transforming it into a tangible, working
    example by creating a level-up system for your character.
  prefs: []
  type: TYPE_NORMAL
- en: Handling character level-ups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I previously mentioned, in this section, you are going to level up your hero’s
    experience and skills. As usual, you’ll be dabbling in code magic to make it happen!
    After all, you are programming a fantasy game.
  prefs: []
  type: TYPE_NORMAL
- en: I know it might seem like a good idea to write your code inside the Character
    class but trust me when I say that there’s actually a much better spot for it.
    That is the `PlayerState` class, which we incidentally have already set for this
    occasion – a while ago, I asked you to create the `US_PlayerState` class and now
    is the time to add some valuable code in it.
  prefs: []
  type: TYPE_NORMAL
- en: As introduced in *Chapter 4*, *Setting Up Your First Multiplayer Environment*,
    `PlayerState` is a class that holds information about a player’s game state and
    exists on both the server and clients. As we need to synchronize experience points
    and levels for the character, this is the ideal location to place everything.
  prefs: []
  type: TYPE_NORMAL
- en: What we need to do here is to keep track of experience points and, as soon as
    the character reaches a new level, broadcast the information across the network
    and update the character statistics.
  prefs: []
  type: TYPE_NORMAL
- en: But first, the most important thing is to have a clear idea of what we are going
    to do.
  prefs: []
  type: TYPE_NORMAL
- en: Planning ahead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the `PlayerState` class will keep important information about the character,
    it’s mandatory to think ahead about what you want to achieve and how to get to
    that point – this means we have to plan exactly what we will be adding to this
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the main features this gameplay framework class will implement:'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping track of the character’s current level and experience points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing the aforementioned properties over the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the Character class whenever the player levels up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broadcasting events whenever the character gets some experience points or levels
    up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a starting point, in the next subsection, we’ll start by declaring the required
    properties and functions.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring PlayerState properties and functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following steps, we are going to define the main properties that will
    let the character level up whenever they have enough experience – this means we
    will need to track the thief’s experience points and level. Additionally, whenever
    values change, we will replicate these properties over the network and notify
    this event to each registered Actor in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s start by opening the `US_PlayerState.h` file and adding the following
    code in the `protected` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the first thing we have done is declare the two properties `Xp`
    (short for experience points) and `CharacterLevel`; both can be modified in Unreal’s
    `EditDefaultsOnly` attribute, but `BlueprintsReadOnly` makes them non-modifiable
    in a Blueprint, to keep all the level-up logic inside the C++ source code.
  prefs: []
  type: TYPE_NORMAL
- en: As an additional attribute, we use the `ReplicatedUsing` attribute, which I
    introduced in the previous section. This will let us execute a function whenever
    a property is updated – in this case, we have set `OnRep_Xp` for the `Xp` property
    and `OnRep_CharacterLevelUp` for `CharacterLevel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a `public` section in your header file and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This function will let us assign new experience points to the `PlayerState`.
    We need to make it `BlueprintCallable` in order to use this function from our
    Blueprints – for instance, from a pickup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just after that, add this declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As explained in the previous section, we need to override this method in order
    to declare the properties that will be replicated (more on this in a moment).
  prefs: []
  type: TYPE_NORMAL
- en: All the necessary setup for implementing replication in our two properties has
    been completed, but a few additional elements still need to be incorporated to
    ensure everything works properly. We need to broadcast some information whenever
    these properties change – this will come in handy when you implement a user interface
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To implement such functionality, you’ll be using **delegates**. You may be already
    familiar with this topic in C++, but you should be aware that, in Unreal Engine,
    a delegate provides a way to call member functions on C++ objects in a generic,
    type-safe manner through dedicated macros.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want more information about the types of delegates supported by Unreal
    Engine and how they can be used in your project, check out the official documentation,
    which can be found here: [https://docs.unrealengine.com/5.1/en-US/delegates-and-lamba-functions-in-unreal-engine/](https://docs.unrealengine.com/5.1/en-US/delegates-and-lamba-functions-in-unreal-engine/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we want broadcast events for the two properties, we will be declaring two
    delegates – one for each property. At the beginning of the header file, just before
    the `UCLASS()` declaration, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: These two lines are pretty similar – they both declare a `Broadcast()` method
    to notify every listener of changes in your system. We will use these features
    in our Blueprint classes to bind events and react accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s declare our `delegate` function. Create a `protected` section, and add
    the following two lines of code, which will be used to broadcast the events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As their purpose is self-explanatory, I guess it’s time stop talking and start
    writing down the implementation!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the PlayerState logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that all the properties and methods have been declared, you are going to
    implement the PlayerState logic – whenever the character gains some experience,
    you should check whether it has reached enough points to level up. Experience
    points gained and level-ups should be broadcast to the system, in order to keep
    everything synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by opening the `US_PlayerState.cpp` file and adding the required `include`
    declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the implementation for the `GetLifetimeReplicatedProps()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are using the `DOREPLIFETIME_CONDITION()` macro, introduced
    in the previous section, to declare that the `Xp` and `CharacterLevel` properties
    should be replicated – in this case, we just want the property to be replicated
    on the owning player of the character (i.e., in the player’s client), and we do
    so by using the `COND_OwnerOnly` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the implementation for the `AddXp()` method using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, whenever we receive an experience point update, we simply add the value
    to the character pool (i.e., the `Xp` property). Next, we ascertain that the character
    is an `AUS_Character` type through a cast and, if the cast is successful, we retrieve
    its statistics to check whether it should level up. If the check is successful,
    we simply increase the character level and call the `UpdateCharacterStats()` method
    to make the thief update the skill row. As we change the values for the properties,
    we then broadcast the new value to all listeners. A couple of (temporary) debug
    messages complete the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PlayerState is now almost finished – we just need to broadcast the values
    to the clients whenever values are updated from the server side. To do so, add
    this last block of code to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The broadcast call is self-explanatory – every registered Actor will receive
    the notification, along with the new value for the `Xp` and `CharacterLevel` properties.
  prefs: []
  type: TYPE_NORMAL
- en: So, in the preceding steps, you have successfully developed a fully operational
    replication system that effectively manages the character experience gained and
    skill development. I’m aware that the task at hand may feel daunting and even
    sometimes counter-intuitive, but with time and practice, you can rest assured
    that everything will become easier and more manageable!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s still something missing in our game: actual experience points. Let’s
    not waste any time and work on adding an item that our character can use to gain
    experience points. In the next steps, you’ll be creating some coins, starting
    with the previously created `US_BasePickup` class, to grant your thief the much-desired
    experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding coin pickups to the level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, we are ready to create some coins that will be used in the game to add experience
    points to the character – this will be a simple Blueprint that will be spawned
    whenever enemies are killed or that will be available in the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, go back to Unreal Editor and compile the project, in order to update
    it with all your improvements. Then, navigate to the `Blueprints` folder and complete
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the Content Browser and select **Blueprint Class** | **US_BasePickup**
    to create a new Blueprint from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the Blueprint `BP_GoldCoinPickup` and double-click on it to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Components** panel, select the **Mesh** component and assign to the
    **Static Mesh** attribute the **coin** static mesh. Change its scale to **2**,
    in order to make it more visible in the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your Blueprint should now be similar to the one shown in *Figure 6**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – The gold coin Blueprint](img/Figure_06_04_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – The gold coin Blueprint
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the pickup has a base shape, it’s time to add some code logic to make
    things fully functional. Open the **Event Graph** tab and take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a variable of type **Integer** and call it **EarnedXp**, giving it a
    default value of **5**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the canvas and look for **Event Pickup**, adding it to the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Cast To US_PlayerState** node and connect its incoming execution pin
    to the outgoing execution pin of the event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag from the **Owning Character** pin of the **Event** node and,
    after releasing the button, add a **Get PlayerState** node from the options that
    appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **PlayerState** outgoing pin to the **Object** pin of the **Cast**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag from the outgoing **As Us PlayerState** pin to create an **Add**
    **Xp** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the success execution pin of the cast node to the incoming execution
    pin of the **Add** **Xp** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **Get Earned Xp** node from the **Variables** section into the canvas
    and connect its pin to the **Value** pin of the **Add** **Xp** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, add a **Destroy Actor** node and connect it to the outgoing execution
    pin of the **Add** **Xp** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final result of the graph is shown in *Figure 6**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The Coin Event graph](img/Figure_06_05_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – The Coin Event graph
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the visual scripting code is quite straightforward – whenever
    a character picks up a coin, its PlayerState will be updated with the experience
    points granted by it.
  prefs: []
  type: TYPE_NORMAL
- en: To test the game, just drag a bunch of coins inside your level and play the
    game. Every time a character picks up a coin, you should see a display message,
    and when the character has enough experience, you should get another message,
    the level-up one.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that, in the previous code, the pickup event will be called
    both on the client and on the server – this is something that should not be done
    as it may provoke issues in your game. Luckily, in this case, the PlayerState
    will correctly handle the data, so we don’t have to worry about it. You will learn
    how to handle trickier situations in [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125),
    *Replicating Properties* *O**ver* *the Network*.
  prefs: []
  type: TYPE_NORMAL
- en: As an extra exercise, you can add a floating animation to the coin, just like
    you did for the spell book in [*Chapter 5*](B18203_05.xhtml#_idTextAnchor107),
    *Managing Actors in a* *Multiplayer Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: Adding coin subclasses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an optional step, you can create different coin pickups with different values
    for experience points. Here’s how to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on `BP_SilverCoinPickup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign a value of **3** to **Earned Xp** and **MI_Metal** as the mesh material.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To provide your character with various items to search for, repeat this step
    as many times as you desire. This will grant your character a diverse set of treasures
    to seek out.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have created a level-up system for your thief hero. With
    the help of replication, a character will get the correct level-up notification
    upon reaching enough experience points. At the moment, this can be achieved by
    collecting coin pickups around the level – later on, you’ll spawn treasure upon
    defeating those nasty Lichlord minions!
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, I will guide you through the creation of a simple UI that
    will show the character level and the experience points that have been gained;
    you’ll perform this task by listening to PlayerState notifications and reacting
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a HUD to the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will create a **Heads Up Display** (**HUD**) for the game
    that will assist in monitoring the player character’s progress during the game.
    As you may already know, the best way to create such information is through the
    **Unreal Motion Graphics** (**UMG**) system – a GUI-based editor that allows developers
    to create user interface elements for their game, such as menus, HUDs, and other
    display screens. You’ll be using this system to create the HUD widget with the
    relative info.
  prefs: []
  type: TYPE_NORMAL
- en: What we need to show at the moment is quite simple – one set of text showing
    the character’s experience points and another set showing the level.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating the Blueprint and the visual elements.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Widget Blueprint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the Widget Blueprint, within Unreal Editor, take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your `Blueprints` folder, right-click on the Content Browser, and select
    `WB_HUD` and double-click on the asset to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **Canvas** element from the **Palette** tab into the **Designer** view.
    This canvas will act as the main container for your visual elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **Text** element into the previously added **Canvas** and call it **XpLabel**.
    Make sure that the **Is Variable** field in the **Details** panel is checked to
    expose this element in the graph you’ll be using later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the label somewhere on the canvas that suits your needs; in my case,
    I opted for the top-left corner of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag another **Text** element into the **Canvas** instance and call it **CharacterLevelLabel**.
    Again, make sure that the **Is Variable** field in the **Details** panel is checked
    to expose this element in the graph you’ll be using later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the label somewhere on the canvas that suits your needs; in my case,
    I opted for the top-right corner of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final result of your HUD should be similar to *Figure 6**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – The HUD designer panel](img/Figure_06_06_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – The HUD designer panel
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have created the widget, it’s time to add some Visual Scripting
    code to make it fully functional.
  prefs: []
  type: TYPE_NORMAL
- en: Adding code logic to the Widget Blueprint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following steps, you’ll add some code logic to the Blueprint, in order
    to listen to events from the PlayerState and react accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom event for the experience points label
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start by creating a custom event that will update the experience points
    label. To do this, open the **Graph** panel of your widget and take the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a custom event and call it `OnXpChanged_Event`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select it and, in the `NewXp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **MyBlueprint** panel, drag a getter node for **XpLabel**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **XpLabel** outgoing pin, click and drag, adding a **SetText (****Text)**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **OnXpChanged_Event** execution pin to the incoming **SetText (Text)**
    execution pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **New Xp** pin of the **Event** node to the **In Text** pin of the
    **SetText (Text)** node. This operation will automatically add a **To Text (Integer)**
    node converter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final result of this piece of code is shown in *Figure 6**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – The Xp custom event](img/Figure_06_07_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – The Xp custom event
  prefs: []
  type: TYPE_NORMAL
- en: 'As an additional, optional step, you may want to add an `Experience Points`
    (for example, `Experience` `Points: 150`).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a custom event to handle the experience points label, it’s
    time to do the same for the character level.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom event for the character level label
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s now create a custom event that will update the character level label:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a custom event and call it `OnCharacterLevelUp_Event`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select it and, in the `NewLevel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **MyBlueprint** panel, drag a getter node for **CharacterLevelLabel**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **CharacterLevelLabel** outgoing pin, click and drag and, after releasing
    the mouse button, select a **SetText (Text)** node from the options that appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **OnLevelLabelChanged_Event** execution pin to the incoming **SetText
    (Text)** execution pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **New Level** pin of the **Event** node to the **In Text** pin of
    the **SetText (Text)** node. This operation will automatically add a **To Text
    (Integer)** node converter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final result of this piece of code is shown in *Figure 6**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – The character level custom event](img/Figure_06_08_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – The character level custom event
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the previous label, you may want to use the `Level:` (for example,
    `Level: 1`).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a custom event to handle the character level label, it’s time
    to bind these events to the notifications broadcast by the PlayerState.
  prefs: []
  type: TYPE_NORMAL
- en: Binding to PlayerState events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this final step of the Widget Blueprint, you will bind the previously created
    events to the PlayerState, in order to update the HUD every time an update notification
    is dispatched:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an **Event on Initialized** node to the graph. This node is executed only
    once during the game (i.e., when the object has been initialized) and is the best
    place to add bindings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the event to a **Delay** node with **Duration** equal to **0,2**. As
    the PlayerState won’t be available at initialization time, waiting until it is
    available is a quick solution to solve the issue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Branch** node and connect its incoming execution pin to the **Completed**
    execution pin of the **Delay** node. Connect the **False** execution pin of the
    **Branch** node to the incoming execution pin of the **Delay** node; this will
    create a loop that will go on until the PlayerState has been properly initialized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we are going to recover the PlayerState from the player owning this widget.
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Get Owning Player** node to the graph. This node returns the player
    that is controlling (i.e., owns) the HUD.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Return Value** pin of this node, click and drag to create a **Get**
    **PlayerState** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `US_PlayerState` class, we are pretty sure that we are going to recover
    that type of PlayerState, so we don’t need to worry about validation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Success** pin of the **Cast To US_PlayerState** node to the **Condition**
    pin of the **Branch** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the outgoing `PlayerState`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **True** execution pin of the **Branch** node to the incoming **Set
    PlayerState** execution pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The visual scripting code created so far is shown in *Figure 6**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – The first part of the PlayerState binding](img/Figure_06_09_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – The first part of the PlayerState binding
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a reference to the PlayerState, it’s time to bind the custom
    events to the delegate you created in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: From the outgoing pin of the `US_PlayerState` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the outgoing execution pin of **Set PlayerState** to the incoming execution
    pin of the **Bind Event to On Xp** **Changed** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Event** pin of the bind node, click and drag to add a **Create Event**
    node. This node has a drop-down menu – here, select **OnXpChanged_Event (NewXp)**,
    which will execute the **OnXpChanged_Event** custom event whenever the system
    receives the corresponding notification from the PlayerState.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the outgoing execution pin of the **Bind** **Event to On Xp Changed**
    node to an **On Xp Changed Event** node; this will call the event upon initialization,
    to update the HUD.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Variables** section, drag a **Get PlayerState** node and from it,
    create a **Get Xp** node. Connect the outgoing pin of the **Get Xp** node to the
    **New Xp** pin of the **On Xp Changed** **Event** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This portion of the Visual Scripting code is shown in *Figure 6**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – The second part of the PlayerState binding](img/Figure_06_10_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – The second part of the PlayerState binding
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the binding phase is almost identical to the steps you have
    just taken, with the exception that we are creating a binding for the player level.
  prefs: []
  type: TYPE_NORMAL
- en: From the outgoing pin of the **On Xp Changed Event** node, click and drag to
    create a **Bind Event to On Character Level** **Up** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **Get PlayerState** node from the **Variables** section and connect it
    to the **Target** pin of the **Bind Event to On Character Level** **Up** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Event** pin of the **Bind** **Event to On Character Level Up** node,
    click and drag to add a **Create Event** node. From the drop-down menu, select
    **OnCharacterLevelUp_Event (NewLevel)**. This selection will execute the **OnCharacterLevelUp_Event**
    custom event whenever the system receives the corresponding notification from
    the PlayerState.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the outgoing execution pin of the **Bind** node to an **On Character
    Level Up Event** node; this will call the event upon initialization, to update
    the HUD.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Variables** section, drag a **Get PlayerState** node to create a
    **Get Character Level** node. Connect the outgoing pin of the **Get Character
    Level** node to the **New Level** pin of the **On Character Level Up** **Event**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This final part of the graph is shown in *Figure 6**.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – The final part of the PlayerState binding](img/Figure_06_11_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – The final part of the PlayerState binding
  prefs: []
  type: TYPE_NORMAL
- en: You have finally created all the bindings to listen to any PlayerState notifications
    and update the HUD accordingly. It’s now time to add the final step – showing
    the HUD in-game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the HUD to the character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you will add the HUD to the player viewport. If you are already familiar
    with Unreal Engine user interfaces in standalone games, you may already know how
    things work.
  prefs: []
  type: TYPE_NORMAL
- en: However, you should be aware that, in a multiplayer environment, a user interface
    widget should be attached to the game viewport only if the character is controlled
    locally (i.e., is the owning client). If you don’t check whether the character
    creating the widget is controlled locally, you will create a widget for each character
    spawned in the level – including those controlled by other players and replicated
    in the client. Having a cluttered mess of superimposed HUDs is obviously something
    you don’t want to have in your game!
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the HUD to the character, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by finding the **BP_Character** Blueprint and opening it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Event Graph, find the **Begin Play** event. Then, add a **Branch** node
    to the execution pin of the event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Condition** pin of the **Branch** node to an **Is Locally Controlled**
    node – this will guarantee we are attaching the HUD only to the character controlled
    by the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **True** execution pin of the **Branch** node, create a **Create Widget**
    node. From the **Class** drop-down menu, choose **WB_HUD** to select our HUD.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the outgoing execution pin of the **Create Widget** node to an **Add
    to Viewport** node. Connect the **Return Value** pin to the **Target** pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final result of the graph can be seen in *Figure 6**.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Adding the HUD to the viewport](img/Figure_06_12_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Adding the HUD to the viewport
  prefs: []
  type: TYPE_NORMAL
- en: The previous Visual Scripting code is pretty easy to understand, but it is important
    to mention that the viewport is only added to the character controlled by the
    client, as having multiple HUDs overlaying each other would not be desirable!
  prefs: []
  type: TYPE_NORMAL
- en: Now that everything has been properly set, you are going to test your game to
    see how it works!
  prefs: []
  type: TYPE_NORMAL
- en: Testing the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test the game, start playing it as a listen server and check that everything
    works fine. In particular, you should see the following behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: At the start of the game, the HUD should show 0 experience points and the character
    level equal to 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time a character picks a coin up, the HUD should update the total experience
    points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the target experience points are reached, the player should level up and
    the HUD will show the new level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final result should be pretty similar to the one shown in *Figure 6**.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – The Final HUD](img/Figure_06_13_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – The Final HUD
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything goes according to plan, you’re all set to embark on the next
    exciting chapter of the Lichlord multiplayer epic: client-server communication!'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, I have introduced you to one of the most important topics
    in the Unreal Engine multiplayer framework: replication.'
  prefs: []
  type: TYPE_NORMAL
- en: As a first step, you created some statistics for the player, in order to make
    your gameplay more flexible. You did this through structures and data tables –
    a topic that will come in handy even if you are developing a standalone game.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I explained the topic of property replication and how to apply it to your
    project. Once the main concepts were defined, you started using them on the PlayerState,
    in order to keep track of the character’s progress during gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: As a last step, you created a HUD to show this progress to the player. Replication
    is mostly important here as each client should get its own updates and show them
    to the player.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll dive deeper into the mystical realm of replication,
    flexing your skills in the delicate art of calling methods from client to server
    and back again like it’s nobody’s business.
  prefs: []
  type: TYPE_NORMAL
- en: Get ready to take things to the next level – we’re about to climb the staircase
    of multiplayer development, two steps at a time!
  prefs: []
  type: TYPE_NORMAL
