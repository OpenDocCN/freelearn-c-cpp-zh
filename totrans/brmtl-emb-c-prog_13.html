<html><head></head><body>
<div><div><div><h1 id="_idParaDest-217" class="chapter-number"><a id="_idTextAnchor371"/>13</h1>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor372"/>Inter-Integrated Circuit (I2C)</h1>
			<p>In this chapter, we will learn about the <a id="_idTextAnchor373"/><strong class="bold">Inter-Integrated Circuit</strong> (<strong class="bold">I2C</strong>) communication protocol. We will begin by exploring the fundamental principles of the I2C protocol, covering its modes of operation, addressing methods, and the communication process. Then, we will examine the key registers of the I2C peripheral in STM32 microcontrollers and apply this knowledge to develop a bare-metal I2C driver.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li><a id="_idTextAnchor374"/>An overview of the I2C protocol</li>
				<li>The STM32 I2C peripheral</li>
				<li>Developing the I2C Driver</li>
			</ul>
			<p>By the end of this chapter, you will have a solid grasp of the I2C protocol and be equipped with the skills to develop bare-metal drivers for I2C.</p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor375"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</a>.</p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor376"/>An overview of the I2C protocol</h1>
			<p>I2C <a id="_idIndexMarker923"/>is another commonly used protocol. Let’s explore what it is, its key features, how it works, and its data format.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor377"/>What is I2C?</h2>
			<p>I2C <a id="_idIndexMarker924"/>is a <em class="italic">multi-master</em>, multi-slave, packet-switched, single-ended, serial communication bus invented by Philips Semiconductor (now NXP Semiconductors). It’s designed for short-distance communication within a single device or between multiple devices on the same board. I2C is known for its simplicity and ease of use, making it a popular choice for communication between microcontrollers and other ICs. Let’s see its key features.</p>
			<h3>The key features of I2C</h3>
			<p>I2C has a number of unique features, which makes it ideal for various applications in embedded systems:</p>
			<ul>
				<li><strong class="bold">A two-wire interface</strong>: I2C uses only two <a id="_idIndexMarker925"/>wires, <strong class="bold">Serial Data</strong> (<strong class="bold">SDA</strong>) and <strong class="bold">Serial Clock</strong> (<strong class="bold">SCL</strong>), which<a id="_idIndexMarker926"/> simplifies the wiring and reduces the number of pins required on the<a id="_idIndexMarker927"/> microcontroller.</li>
				<li><strong class="bold">Multi-master and multi-slave</strong>: Multiple master devices can initiate communication <a id="_idIndexMarker928"/>on the bus, and multiple slave devices can respond. This <a id="_idIndexMarker929"/>flexibility allows for complex communication setups. The I2C protocol supports up to 128 devices with 7-bit addressing, although the practical limit is 119 due to reserved addresses. With 10-bit addressing, the protocol theoretically allows for 1,024 devices, but again, reserved addresses reduce the practical maximum slightly. The 10-bit mode, while less common, enables a higher number of devices on the same bus.</li>
				<li><strong class="bold">Addressable devices</strong>: Each<a id="_idIndexMarker930"/> device on the I2C bus has a unique address, enabling the master to communicate with specific slaves.</li>
				<li><strong class="bold">Synchronous communication</strong>: The SCL line provides the clock signal, ensuring that data is<a id="_idIndexMarker931"/> transferred synchronously between devices.</li>
				<li><strong class="bold">Speed variants</strong>: I2C <a id="_idIndexMarker932"/>supports various speed modes, including standard mode (100 kHz), fast mode (400 kHz), fast mode plus (1 MHz), and high-speed mode (3.4 MHz), catering to different speed requirements.</li>
				<li><strong class="bold">Simple and low-cost</strong>: The <a id="_idIndexMarker933"/>protocol’s simplicity and minimal hardware requirements make it cost-effective and easy to implement.</li>
			</ul>
			<p>Let’s look at the I2C interface.</p>
			<h3>The I2C interface</h3>
			<p>The I2C interface consists of two main lines:</p>
			<ul>
				<li><strong class="bold">Serial Data (SDA)</strong>: This<a id="_idIndexMarker934"/> line carries the data being transferred between devices. It’s a bidirectional line, meaning that both the master and slave can send and receive data.</li>
				<li><strong class="bold">Serial Clock (SCL)</strong>: This<a id="_idIndexMarker935"/> line carries the clock signal generated by the master device. It synchronizes the data transfer between the master and t<a id="_idTextAnchor378"/><a id="_idTextAnchor379"/>he slave.</li>
			</ul>
			<div><div><img src="img/B21914_13_1.jpg" alt="Figure 13.1: The I2C interface – multiple slaves" width="1617" height="648"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1: The I2C interface – multiple slaves</p>
			<p>These two lines are connected to all devices on the bus, with pull-up resistors to ensure that the lines are pulled to a high state when idle. Let’s see how it works.</p>
			<h3>How I2C works</h3>
			<p>Understanding how<a id="_idIndexMarker936"/> I2C works involves looking at the <strong class="bold">roles</strong> of master and slave devices, the <strong class="bold">addressing scheme</strong>, and the <strong class="bold">communication process</strong>.</p>
			<p>The following are the roles and addressing scheme:</p>
			<ul>
				<li><strong class="bold">Master device</strong>: The <a id="_idIndexMarker937"/>master device initiates communication and generates a clock signal. It controls the flow of data and can address multiple slaves.</li>
				<li><strong class="bold">Slave device</strong>: The<a id="_idIndexMarker938"/> slave device responds to the master’s commands and performs the requested operations. Each slave has a unique <strong class="bold">7-bit </strong>or <strong class="bold">10-bit address</strong> that the master uses to identify it.</li>
			</ul>
			<p>The communication process is as follows:</p>
			<ol>
				<li><strong class="bold">A start condition</strong>: Communication <a id="_idIndexMarker939"/>begins with the master<a id="_idIndexMarker940"/> generating a start condition. This involves pulling the SDA line low while the SCL line is high.</li>
				<li><strong class="bold">Address frame</strong>: The <a id="_idIndexMarker941"/>master sends the address of the target slave device, followed by a read/write bit indicating the operation type (0 for write and 1 for read).</li>
				<li><strong class="bold">Acknowledge (ACK) bit</strong>: The <a id="_idIndexMarker942"/>addressed slave responds with an ACK bit by pulling the SDA line low during the next clock pulse.</li>
				<li><strong class="bold">Data Frames</strong>: Data is <a id="_idIndexMarker943"/>transferred in 8-bit frames. Each byte is followed by an ACK bit from the receiver.</li>
				<li><strong class="bold">A stop condition</strong>: The <a id="_idIndexMarker944"/>master ends the communication by generating<a id="_idIndexMarker945"/> a stop condition, which involves pulling the SDA line high while the SCL line is high.</li>
			</ol>
			<div><div><img src="img/B21914_13_2.jpg" alt="Figure 13.2: The I2C packet" width="1491" height="169"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2: The I2C packet</p>
			<p>Before we proceed to the next section, let’s take a moment to touch on the I2C data transfer, using an example.</p>
			<p>Let’s begin by revisiting the <a id="_idIndexMarker946"/>role of the data frame and the start condition:</p>
			<ul>
				<li><strong class="bold">Data frames</strong>: Data <a id="_idIndexMarker947"/>is transferred in <strong class="bold">8-bit bytes</strong>. After each byte, the receiver sends an ACK bit to confirm successful reception.</li>
				<li><strong class="bold">Repeated start condition</strong>: If the master needs to communicate with another slave or continue communication without releasing the bus, it can generate a <strong class="bold">repeated start condition</strong> instead of a<a id="_idIndexMarker948"/> stop condition.</li>
			</ul>
			<p>Let’s see the data transfer:</p>
			<ul>
				<li><strong class="bold">Write operation</strong>: The <a id="_idIndexMarker949"/>master sends a <strong class="bold">start condition</strong>, the <strong class="bold">address frame </strong>with<a id="_idIndexMarker950"/> the <strong class="bold">write bit</strong>, and the <strong class="bold">data frames</strong>. Each <a id="_idIndexMarker951"/>data byte is followed by an ACK bit from <a id="_idIndexMarker952"/>the slave.</li>
				<li><strong class="bold">Read operation</strong>: The<a id="_idIndexMarker953"/> master sends a start condition, the address frame with<a id="_idIndexMarker954"/> the <strong class="bold">read bit</strong>, and then reads the data frames from the slave. Each data byte is acknowledged by the master with an ACK bit, except for the<a id="_idIndexMarker955"/> last byte, which is followed by<a id="_idIndexMarker956"/> a <strong class="bold">NACK</strong> to indicate the end of the read operation.</li>
			</ul>
			<p>For a better understanding, let’s analyze <em class="italic">Figures 13.3</em> to <em class="italic">13.6</em>, starting with the start and stop conditions.</p>
			<div><div><img src="img/B21914_13_3.jpg" alt="Figure 13.3: The start condition" width="367" height="491"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3: The start condition</p>
			<p>The following is the stop condition:</p>
			<div><div><img src="img/B21914_13_4.jpg" alt="Figure 13.4: The stop condition" width="431" height="619"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4: The stop condition</p>
			<p>The start <a id="_idIndexMarker957"/>condition occurs when the master device pulls the SDA line low while the SCL line remains high. This sequence signals all devices on the I2C bus that a communication session is about to begin, allowing the master to claim the bus for its intended operations. Without a valid start condition, the I²C communication cannot commence.</p>
			<p>Conversely, the stop condition signals the end of communication. The master device releases the SDA line to a high state while the SCL line is high, indicating that the communication session is complete and the bus is now free for other devices. The proper use of stop conditions is essential for ensuring that no devices remain active on the bus, which could lead to conflicts or communication errors.</p>
			<p>Next, let’s see how the I2C protocol distinguishes between zeros and ones.</p>
			<div><div><img src="img/B21914_13_5.jpg" alt="Figure 13.5: The data transmission process" width="851" height="606"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5: The data transmission process</p>
			<p><em class="italic">Figure 13</em><em class="italic">.5</em> illustrates the<a id="_idIndexMarker958"/> data transmission process. Data is sent bit by bit, synchronized<a id="_idIndexMarker959"/> with the clock pulses on the SCL line. As shown, each bit of data is placed on the SDA line while the SCL line is low. When the SCL line transitions to high, the state of the SDA line is read by the receiving device. This particular figure shows the transmission of <strong class="bold">1</strong>, followed by a <strong class="bold">0</strong>.</p>
			<p>Finally, let’s examine the complete packet and how it interacts with the SDA and SCL lines.</p>
			<div><div><img src="img/B21914_13_6.jpg" alt="Figure 13.6: The complete packet" width="1484" height="700"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6: The complete packet</p>
			<p><em class="italic">Figure 13</em><em class="italic">.6</em> provides a<a id="_idIndexMarker960"/> comprehensive view of a complete I²C communication packet, showcasing the relationship between the SDA and SCL lines throughout the transaction. The communication begins with a start condition, where the SDA line is pulled low while the SCL line remains high, signaling the initiation of a new communication sequence.</p>
			<p>Following the start condition, the address frame is transmitted. This frame contains the 7-bit address of the target device, followed by the <strong class="bold">read/write</strong> (<strong class="bold">R/W</strong>) bit<a id="_idIndexMarker961"/> that indicates whether the master intends to read from or write to the slave device. The address frame is then acknowledged by the slave device with an ACK bit, confirming that it is ready to proceed with the communication.</p>
			<p>After the address frame, the data frame is transmitted. The data is sent in 8-bit bytes, with each bit being placed on the SDA line while the SCL line clocks each bit in sync. After each byte of data, the receiving device responds with another ACK bit, ensuring that the data was received correctly.</p>
			<p>The communication concludes with a stop condition, where the SDA line is released to go high while the SCL line is also high. This signals the end of the communication session, freeing the bus for other potential communications. This complete cycle, from start to stop, forms the backbone of data exchange in the I²C protocol, ensuring structured and<a id="_idIndexMarker962"/> reliable communication between devices.</p>
			<p>This concludes our overview of the I2C protocol. In the next section, we shall analyze the I2C peripheral in the STM32F4 microcontroller.</p>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor380"/>The STM32F4 I2C peripherals</h1>
			<p>Depending on the specific model of STM32F4 you are working with, you can typically find up to three I2C peripherals labeled I2C1, I2C2, and I2C3. These peripherals enable the microcontroller to communicate with I2C-compatible devices using the standard two-wire interface.</p>
			<p>The I2C peripherals in<a id="_idIndexMarker963"/> STM32F4 microcontrollers come packed with features that enhance their versatility and performance:</p>
			<ul>
				<li><strong class="bold">Multi-master and multi-slave capabilities</strong>: Each I2C peripheral can operate as both master and slave, supporting multiple master configurations where more than one master device can control the bus</li>
				<li><strong class="bold">Standard, fast, and fast mode plus</strong>: The peripherals support multiple speed modes, including <strong class="bold">standard mode</strong> (100 kHz), <strong class="bold">fast mode</strong> (400 kHz), and <strong class="bold">fast mode plus</strong> (1 MHz), allowing for flexibility in communication speed</li>
				<li><strong class="bold">10-bit addressing</strong>: In addition to standard <strong class="bold">7-bit addressing</strong>, the I2C peripherals also support <strong class="bold">10-bit addressing</strong>, enabling communication with a broader range of devices</li>
				<li><strong class="bold">Dual addressing mode</strong>: Each I2C peripheral can be configured to respond to two different addresses, useful for complex multi-device setups</li>
				<li><strong class="bold">DMA support</strong>: <strong class="bold">Direct Memory Access</strong> (<strong class="bold">DMA</strong>) support is<a id="_idIndexMarker964"/> available, enabling efficient data transfer without CPU intervention</li>
			</ul>
			<p>Let’s examine the key registers of this peripheral.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor381"/>The key I2C registers</h2>
			<p>Configuring the I2C peripheral on an STM32 microcontroller involves several key registers that control various aspects of its operation.</p>
			<p>Each register has specific bits that need to be set correctly to ensure proper functionality. Let’s break down the main registers we’ll be working with, starting with <strong class="bold">Control </strong><strong class="bold">Register 1</strong>.</p>
			<h3>I2C Control Register 1 (I2C_CR1)</h3>
			<p><code>I2C_CR1</code> is one of the primary<a id="_idIndexMarker965"/> control registers used to configure the I2C peripheral’s basic operational settings. It provides options to <strong class="bold">enable the peripheral</strong>, manage the start and stop conditions, and control the acknowledge feature.</p>
			<p>The key bits in<a id="_idIndexMarker966"/> this register include the following:</p>
			<ul>
				<li><strong class="bold">Peripheral enable (PE)</strong>: This bit enables or disables the I2C peripheral. Setting this bit to 1 turns on the I2C peripheral, while clearing it turns it off.</li>
				<li><code>START</code> condition, initiating communication.</li>
				<li><code>STOP</code> condition, terminating communication.</li>
				<li><strong class="bold">Acknowledge enable (ACK)</strong>: When set, this bit enables the ACK after each byte received.</li>
				<li><strong class="bold">Acknowledge/PEC position (POS)</strong>: This bit controls the position of the ACK bit.</li>
				<li><strong class="bold">Software reset (SWRST)</strong>: Setting this bit resets the I2C peripheral.</li>
			</ul>
			<p>You can find detailed information about this register on <em class="italic">page 492</em> of the STM32F4 reference manual (RM0383). Next, let’s look at I2C <strong class="bold">Control </strong><strong class="bold">Register 2</strong>.</p>
			<h3>I2C Control Register 2 (I2C_CR2)</h3>
			<p><code>I2C_CR2</code> is another crucial control <a id="_idIndexMarker967"/>register that handles different aspects of I2C operation, including <strong class="bold">clock frequency</strong>, <strong class="bold">interrupt</strong> enable, and <strong class="bold">DMA</strong> control. Key bits in this<a id="_idIndexMarker968"/> register include the following:</p>
			<ul>
				<li><strong class="bold">FREQ[5:0] (peripheral clock frequency)</strong>: These bits set the I2C peripheral clock frequency in MHz</li>
				<li><strong class="bold">DMAEN (DMA requests enable)</strong>: When set, this bit enables the DMA requests for the I2C peripheral</li>
			</ul>
			<p>You can find detailed information about this register on <em class="italic">page 494</em> of the STM32F4 reference manual (RM0383). Next, let’s look at the I2C <strong class="bold">Clock </strong><strong class="bold">Control Register</strong>.</p>
			<h3>I2C Clock Control Register (I2C_CCR)</h3>
			<p><code>I2C_CCR</code> configures the clock control <a id="_idIndexMarker969"/>settings for standard, fast, and fast mode <a id="_idIndexMarker970"/>plus operations. Key bits in this register include the following:</p>
			<ul>
				<li><strong class="bold">CCR[11:0] (clock control)</strong>: These bits set the clock control value, determining the I2C clock speed</li>
				<li><strong class="bold">DUTY (fast mode duty cycle)</strong>: This bit selects the duty cycle for fast mode</li>
				<li><strong class="bold">F/S (I2C master mode selection)</strong>: This bit selects between standard mode (0) and fast mode (1)</li>
			</ul>
			<p>You can find detailed information about this register on <em class="italic">page 502</em> of the STM32F4 reference manual (RM0383). The next register is the I2C Rise Time Register.</p>
			<h3>I2C TRISE register (I2C_TRISE)</h3>
			<p><code>I2C_TRISE</code> configures the maximum <a id="_idIndexMarker971"/>rise time for the I2C signals, en<a id="_idTextAnchor382"/>suring compliance with I2C specifications. This register has only one field – <strong class="bold">TRISE[5:0] (maximum rise time)</strong>. These bits set the maximum rise time for the SDA and SCL signals in nanoseconds.</p>
			<p>The final register is the I2C <strong class="bold">Data Register</strong>.</p>
			<h3>I2C Data Register (I2C_DR)</h3>
			<p><code>I2C_DR</code> is the data register used<a id="_idIndexMarker972"/> for both <strong class="bold">transmitting</strong> and <strong class="bold">receiving</strong> data. Data written to this register is transmitted, and data received from the bus is stored in this register. This register has only one field – <strong class="bold">DR[7:0] (8-bit data register)</strong>: This register holds the 8-bit data to be transmitted or the data received from the bus.</p>
			<p>With these registers in mind, we’re now ready to develop the I2C driver. Let’s do that in the next section.</p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor383"/>Developing the I2C driver</h1>
			<p>Let’s develop the I2C driver. Create a <a id="_idIndexMarker973"/>copy of your previous project in your IDE and rename this copied project <code>I2C</code>. Next, create a new file named <code>i2c.c</code> in the <code>Src</code> folder and another file named <code>i2c.h</code> in the <code>Inc</code> folder.</p>
			<h3>The initialization function</h3>
			<p>Let’s populate the <code>i2c.c</code> file, starting <a id="_idIndexMarker974"/>with the macros and initialization function:</p>
			<pre class="source-code">
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">#define</strong>     GPIOBEN            (1U&lt;&lt;1)
<strong class="bold">#define</strong>     I2C1EN            (1U&lt;&lt;21)
<strong class="bold">#define</strong>     I2C_100KHZ            80
<strong class="bold">#define</strong>     SD_MODE_MAX_RISE_TIME    17
<strong class="bold">#define</strong>    CR1_PE            (1U&lt;&lt;0)
<strong class="bold">#define</strong>    SR2_BUSY            (1U&lt;&lt;1)
<strong class="bold">#define</strong>    CR1_START            (1U&lt;&lt;8)
<strong class="bold">#define</strong>    SR1_SB            (1U&lt;&lt;0)
<strong class="bold">#define</strong>    SR1_ADDR            (1U&lt;&lt;1)
<strong class="bold">#define</strong>    SR1_TXE            (1U&lt;&lt;7)
<strong class="bold">#define</strong>    CR1_ACK            (1U&lt;&lt;10)
<strong class="bold">#define</strong>    CR1_STOP            (1U&lt;&lt;9)
<strong class="bold">#define</strong>    SR1_RXNE            (1U&lt;&lt;6)
<strong class="bold">#define</strong>    SR1_BTF            (1U&lt;&lt;2)
/*
 * PB8 ---- SCL
 * PB9 ----- SDA
 * */
<strong class="bold">void i2c1_init</strong>(<strong class="bold">void</strong>)
{
    /*Enable clock access to GPIOB*/
     RCC-&gt;AHB1ENR |=GPIOBEN;
    /*Set PB8 and PB9 mode to alternate function*/
    GPIOB-&gt;MODER &amp;=~(1U&lt;&lt;16);
    GPIOB-&gt;MODER |=(1U&lt;&lt;17);
    GPIOB-&gt;MODER &amp;=~(1U&lt;&lt;18);
    GPIOB-&gt;MODER |=(1U&lt;&lt;19);
    /*Set PB8 and PB9 output type to  open drain*/
    GPIOB-&gt;OTYPER |=(1U&lt;&lt;8);
    GPIOB-&gt;OTYPER |=(1U&lt;&lt;9);
    /*Enable Pull-up for PB8 and PB9*/
    GPIOB-&gt;PUPDR |=(1U&lt;&lt;16);
    GPIOB-&gt;PUPDR &amp;=~(1U&lt;&lt;17);
    GPIOB-&gt;PUPDR |=(1U&lt;&lt;18);
    GPIOB-&gt;PUPDR &amp;=~(1U&lt;&lt;19);
    /*Set PB8 and PB9 alternate function type to I2C (AF4)*/
    GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;0);
    GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;1);
    GPIOB-&gt;AFR[1] |=(1U&lt;&lt;2);
    GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;3);
    GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;4);
    GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;5);
    GPIOB-&gt;AFR[1] |=(1U&lt;&lt;6);
    GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;7);
    /*Enable clock access to I2C1*/
     RCC-&gt;APB1ENR |= I2C1EN;
    /*Enter reset mode  */
    I2C1-&gt;CR1 |= (1U&lt;&lt;15);
    /*Come out of reset mode  */
    I2C1-&gt;CR1 &amp;=~(1U&lt;&lt;15);
    /*Set Peripheral clock frequency*/
    I2C1-&gt;CR2 = (1U&lt;&lt;4);   //16 <strong class="bold">Mhz</strong>
    /*Set I2C to standard mode, 100kHz clock */
    I2C1-&gt;CCR = I2C_100KHZ;
    /*Set rise time */
    I2C1-&gt;TRISE = SD_MODE_MAX_RISE_TIME;
    /*Enable I2C1 module */
    I2C1-&gt;CR1 |= CR1_PE;
}</pre>			<p>Let’s <a id="_idIndexMarker975"/>break down what we have so far:</p>
			<pre class="source-code">
RCC-&gt;AHB1ENR |= GPIOBEN;</pre>			<p>This line enables the clock for GPIOB by setting the corresponding bit.</p>
			<pre class="source-code">
GPIOB-&gt;MODER &amp;=~(1U&lt;&lt;16);
GPIOB-&gt;MODER |=(1U&lt;&lt;17);
GPIOB-&gt;MODER &amp;=~(1U&lt;&lt;18);
GPIOB-&gt;MODER |=(1U&lt;&lt;19);</pre>			<p>These lines configure <code>PB8</code> and <code>PB9</code> pins to an alternate function mode for I2C.</p>
			<pre class="source-code">
GPIOB-&gt;OTYPER |=(1U&lt;&lt;8);
GPIOB-&gt;OTYPER |=(1U&lt;&lt;9);</pre>			<p>These <a id="_idIndexMarker976"/>lines configure the pins as <strong class="bold">open-drain</strong>, which is required for I2C communication.</p>
			<pre class="source-code">
GPIOB-&gt;PUPDR |=(1U&lt;&lt;16);
GPIOB-&gt;PUPDR &amp;=~(1U&lt;&lt;17);
GPIOB-&gt;PUPDR |=(1U&lt;&lt;18);
GPIOB-&gt;PUPDR &amp;=~(1U&lt;&lt;19);</pre>			<p>These lines<a id="_idIndexMarker977"/> enable <strong class="bold">pull-up resistors</strong> for the I2C pins.</p>
			<pre class="source-code">
GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;0);
GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;1);
GPIOB-&gt;AFR[1] |=(1U&lt;&lt;2);
GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;3);
GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;4);
GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;5);
GPIOB-&gt;AFR[1] |=(1U&lt;&lt;6);
GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;7);</pre>			<p>These lines configure the <code>I2C1</code>.</p>
			<pre class="source-code">
 RCC-&gt;APB1ENR |= I2C1EN;</pre>			<p>This line enables the clock for the I2C1 peripheral.</p>
			<pre class="source-code">
I2C1-&gt;CR1 |= (1U&lt;&lt;15);
I2C1-&gt;CR1 &amp;=~(1U&lt;&lt;15);</pre>			<p>These lines <strong class="bold">reset</strong> the I2C1 peripheral.</p>
			<pre class="source-code">
I2C1-&gt;CR2 = (1U&lt;&lt;4);</pre>			<p>This configures the I2C1 clock.</p>
			<pre class="source-code">
 I2C1-&gt;CCR = I2C_100KHZ;</pre>			<p>This line sets the clock control register for 100 kHz standard mode, using the macro we defined.</p>
			<pre class="source-code">
I2C1-&gt;TRISE = SD_MODE_MAX_RISE_TIME;</pre>			<p>This line sets the rise time for the I2C signals using the macro we defined. The TRISE register specifies the maximum time the signal is allowed to take to transition from a low to a high state on the I2C bus. Setting this value correctly is important to ensure that the I2C communication adheres to the timing requirements of the I2C standard, which helps maintain <a id="_idIndexMarker978"/>reliable and stable communication.</p>
			<pre class="source-code">
I2C1-&gt;CR1 |= CR1_PE;</pre>			<p>This line enables the I2C1 peripheral by setting the PE bit. Next, we will add and analyze the function to read a byte from an I2C slave device.</p>
			<h3>The read function</h3>
			<p>Let’s<a id="_idIndexMarker979"/> analyze the <code>read</code> function:</p>
			<pre class="source-code">
<strong class="bold">void i2c1_byte_read</strong>(<strong class="bold">char</strong> saddr, <strong class="bold">char</strong> maddr, <strong class="bold">char</strong>* data) {
      <strong class="bold">volatile int</strong> tmp;
      /* Wait until bus not busy */
      <strong class="bold">while</strong> (I2C1-&gt;SR2 &amp; (SR2_BUSY)){}
      /* Generate start */
      I2C1-&gt;CR1 |= CR1_START;
      /* Wait until start flag is set */
      <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; (SR1_SB))){}
      /* Transmit slave address + Write */
      I2C1-&gt;DR = saddr &lt;&lt; 1;
      /* Wait until <strong class="bold">addr</strong> flag is set */
      <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; (SR1_ADDR))){}
      /* Clear <strong class="bold">addr</strong> flag */
      tmp = I2C1-&gt;SR2;
      /* Send memory address */
      I2C1-&gt;DR = maddr;
      /*Wait until transmitter empty */
      <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; SR1_TXE)){}
     /*Generate restart */
     I2C1-&gt;CR1 |= CR1_START;
      /* Wait until start flag is set */
      <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; SR1_SB)){}
     /* Transmit slave address + Read */
     I2C1-&gt;DR = saddr &lt;&lt; 1 | 1;
     /* Wait until <strong class="bold">addr</strong> flag is set */
     <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; (SR1_ADDR))){}
    /* Disable Acknowledge */
    I2C1-&gt;CR1 &amp;= ~CR1_ACK;
    /* Clear <strong class="bold">addr</strong> flag */
    tmp = I2C1-&gt;SR2;
    /* Generate stop after data received */
    I2C1-&gt;CR1 |= CR1_STOP;
    /* Wait until RXNE flag is set */
    <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; SR1_RXNE)){}
    /* Read data from DR */
      *data++ = I2C1-&gt;DR;
}</pre>			<p>Let’s break down what<a id="_idTextAnchor384"/> we have so far:</p>
			<ul>
				<li><code>while (I2C1-&gt;SR2 &amp; (SR2_BUSY)){}</code>: This line waits for the I2C bu<a id="_idTextAnchor385"/>s to be free by checking the state of the <code>BUSY</code> bit in I2C Status Register 2.</li>
				<li><code>I2C1-&gt;CR1 |= CR1_START;</code>: This line initiates a start condition <a id="_idTextAnchor386"/>on the I2C bus.</li>
				<li><code>while (!(I2C1-&gt;SR1 &amp; (SR1_SB))){}</code>: This line waits until the start condition is acknowledged by checking the <code>SB</code> bit in I2C Status Register 1.</li>
				<li><code>I2C1-&gt;DR = saddr &lt;&lt; 1;</code>: This line sends the slave address with the write bit. The 7-bit address of the device is left-shifted by 1 bit to make room for the R/W bit in<a id="_idIndexMarker980"/> the <code>saddr</code> left by 1, we prepare the address for a subsequent write operation to the<a id="_idTextAnchor387"/> slave device.</li>
				<li><code>while (!(I2C1-&gt;SR1 &amp; (SR1_ADDR))){}</code>: This line waits until the <a id="_idTextAnchor388"/>address is acknowledged by checking the <code>ADDR</code> bit in I2C Status Register 1.</li>
				<li> <code>tmp = I2C1-&gt;SR2;</code>: This line clears the address flag by simply reading I2C Status Register 2.</li>
				<li><code>2C1-&gt;DR = maddr;</code>: Here, we send the memory address to read from the slave device.</li>
				<li><code>while (!(I2C1-&gt;SR1 &amp; SR1_TXE)){}</code>: This line waits until the data register is empty by reading the<a id="_idIndexMarker981"/> transmit buffer empty (<code>TXE</code>) bit in I2C Status Register 1.</li>
				<li><code>I2C1-&gt;CR1 |= CR1_START;</code>: This line initiates<a id="_idIndexMarker982"/> a <strong class="bold">restart condition</strong> on the I2C bus.</li>
				<li><code>while (!(I2C1-&gt;SR1 &amp; SR1_SB)){}</code>: Here, we wait until the restart condition is acknowledged by checking the <code>SB</code> bit in I2C Status Register 1.</li>
				<li><code>I2C1-&gt;DR = saddr &lt;&lt; 1 | 1;</code>: This line prepares the I2C data register for a read operation by setting up the 7-bit I2C address of the slave device and appending the R/W bit. Specifically, <code>saddr &lt;&lt; 1</code> shifts the 7-bit address left by one bit to make room for the LSB, which is then set to 1 using the bitwise <code>OR </code>operator (| 1). This final value, with the LSB set to 1, indicates a read operation when loaded into the I2C1 <strong class="bold">data register</strong> (<strong class="bold">DR</strong>). Hence, this line configures the I2C peripheral to<a id="_idIndexMarker983"/> initiate communication with the slave device, requesting to read data from it.</li>
				<li><code>while (!(I2C1-&gt;SR1 &amp; (SR1_ADDR))){}</code>: This line waits until the address is acknowledged.</li>
				<li><code>I2C1-&gt;CR1 &amp;= ~CR1_ACK;</code>: This line disables the acknowledge bit to prepare for a stop condition.</li>
				<li><code>tmp = I2<a id="_idTextAnchor389"/>C1-&gt;SR2;</code>: This line clears the address flag by reading I2C Status Register 2.</li>
				<li><code>I2C1-&gt;CR1 |= CR1_STOP;</code>: This initiates a stop condition on the I2C bus.</li>
				<li><code>while (!(I2C1-&gt;SR1 &amp; SR1_RXNE)){}</code>: This line waits until the receive buffer is not empty by reading<a id="_idIndexMarker984"/> the <code>RXNE</code>) flag in I2C Status Register 1. This flag indicates that new data has been received and i<a id="_idTextAnchor390"/>s available in the data register.</li>
				<li><code> *data++ = I2C1-&gt;DR;</code>: This line is responsible for storing the received byte of data from the I2C DR in the memory location pointed to by the <code>data</code> pointer.</li>
			</ul>
			<p>Next, we have a function to read multiple bytes from the slave device:</p>
			<pre class="source-code">
<strong class="bold">void i2c1_burst_read</strong>(<strong class="bold">char</strong> saddr, <strong class="bold">char</strong> maddr, <strong class="bold">int</strong> n, <strong class="bold">char</strong>* data) {
    <strong class="bold">volatile int</strong> tmp;
     /* Wait until bus not busy */
     <strong class="bold">while</strong> (I2C1-&gt;SR2 &amp; (SR2_BUSY)){}
     /* Generate start */
     I2C1-&gt;CR1 |= CR1_START;
     /* Wait until start flag is set */
     <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; SR1_SB)){}
     /* Transmit slave address + Write */
     I2C1-&gt;DR = saddr &lt;&lt; 1;
     /* Wait until <strong class="bold">addr</strong> flag is set */
     <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; SR1_ADDR)){}
    /* Clear <strong class="bold">addr</strong> flag */
     tmp = I2C1-&gt;SR2;
    /* Wait until transmitter empty */
    <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; SR1_TXE)){}
    /*Send memory address */
    I2C1-&gt;DR = maddr;
    /*Wait until transmitter empty */
    <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; SR1_TXE)){}
    /*Generate restart */
    I2C1-&gt;CR1 |= CR1_START;
    /* Wait until start flag is set */
    <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; SR1_SB)){}
    /* Transmit slave address + Read */
    I2C1-&gt;DR = saddr &lt;&lt; 1 | 1;
    /* Wait until <strong class="bold">addr</strong> flag is set */
    <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; (SR1_ADDR))){}
    /* Clear <strong class="bold">addr</strong> flag */
    tmp = I2C1-&gt;SR2;
    /* Enable Acknowledge */
      I2C1-&gt;CR1 |=  CR1_ACK;
    <strong class="bold">while</strong>(n &gt; 0U)
    {
        /*if one byte*/
        <strong class="bold">if</strong>(n == 1U)
        {
            /* Disable Acknowledge */
            I2C1-&gt;CR1 &amp;= ~CR1_ACK;
            /* Generate Stop */
            I2C1-&gt;CR1 |= CR1_STOP;
            /* Wait for RXNE flag set */
            <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; SR1_RXNE)){}
            /* Read data from DR */
            *data++ = I2C1-&gt;DR;
            <strong class="bold">break</strong>;
        }
        <strong class="bold">else</strong>
        {
           /* Wait until RXNE flag is set */
           <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; SR1_RXNE)){}
           /* Read data from DR */
           (*data++) = I2C1-&gt;DR;
           n--;
        }
    }
}</pre>			<p>This function<a id="_idIndexMarker985"/> reads multiple bytes of data from a specified memory address in the I2C slave device. Here’s a breakdown of what it does:</p>
			<ol>
				<li><strong class="bold">Waits for bus availability</strong>: The function starts by ensuring that the I2C bus is not busy, waiting until it is free to initiate communication.</li>
				<li><strong class="bold">Generates a start condition</strong>: It generates a start condition to begin communication with the slave device.</li>
				<li><strong class="bold">Transmits a slave address for write</strong>: The function sends the slave device address with a write bit, indicating that it will initially write data to specify the memory address.</li>
				<li><strong class="bold">Waits for the address flag and clears it</strong>: It waits for the address flag to be set and then clears it by reading the SR2 register.</li>
				<li><strong class="bold">Transmits the memory address</strong>: The memory address from which to start reading is sent to the slave device.</li>
				<li><strong class="bold">Generates a restart condition</strong>: A repeated start condition is generated to switch the communication mode from write to read.</li>
				<li><strong class="bold">Transmits a slave address for read</strong>: The function sends the slave address with a read bit, indicating that it will read data from the slave device.</li>
				<li><strong class="bold">Waits for the address flag and clears it</strong>: Again, it waits for the address flag to be set and clears it by reading the SR2 register.</li>
				<li><strong class="bold">Enables acknowledge</strong>: The acknowledge bit is set.</li>
				<li><code>RXNE</code> flag to indicate that data is ready, reads the data into the buffer, and decrements<a id="_idIndexMarker986"/> the byte counter</li></ul></li>
			</ol>
			<p>Finally, we add the function to write data to the slave device.</p>
			<h3>The write function</h3>
			<p>Let’s break down the<a id="_idIndexMarker987"/> function to write multiple bytes to the slave device:</p>
			<pre class="source-code">
<strong class="bold">void i2c1_burst_write</strong>(<strong class="bold">char</strong> saddr, <strong class="bold">char</strong> maddr, <strong class="bold">int</strong> n, <strong class="bold">char</strong>* data) {
    <strong class="bold">volatile int</strong> tmp;
    /* Wait until bus not busy */
    <strong class="bold">while</strong> (I2C1-&gt;SR2 &amp; (SR2_BUSY)){}
    /* Generate start */
    I2C1-&gt;CR1 |= CR1_START;
    /* Wait until start flag is set */
    <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; (SR1_SB))){}
    /* Transmit slave address */
    I2C1-&gt;DR = saddr &lt;&lt; 1;
    /* Wait until <strong class="bold">addr</strong> flag is set */
    <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; (SR1_ADDR))){}
    /* Clear <strong class="bold">addr</strong> flag */
    tmp = I2C1-&gt;SR2;
    /* Wait until data register empty */
    <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; (SR1_TXE))){}
    /* Send memory address */
    I2C1-&gt;DR = maddr;
    <strong class="bold">for</strong> (<strong class="bold">int</strong> i = 0; i &lt; n; i++) {
     /* Wait until data register empty */
        <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; (SR1_TXE))){}
      /* Transmit memory address */
      I2C1-&gt;DR = *data++;
    }
    /* Wait until transfer finished */
    <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; (SR1_BTF))){}
    /* Generate stop */
    I2C1-&gt;CR1 |= CR1_STOP;
}</pre>			<p>This function<a id="_idIndexMarker988"/> writes <strong class="bold">multiple bytes</strong> of data to a specific memory address in the I2C slave device. The function begins by waiting for the I2C bus to be free, ensuring that there is no ongoing communication. It then generates a start condition to initiate communication with the slave device. The slave address is transmitted with a write bit, and then the function waits for the address flag to be set and cleared by reading the SR2 register. After ensuring the data register is empty, it sends the memory address where the data writing should begin. The function enters a loop to transmit each byte of data, waiting for the data register to empty before each byte is sent. Once all bytes have been transmitted, it waits for the byte transfer to finish and then generates a stop condition to end the communication.</p>
			<p>Our next task is to populate the <code>i2c.h</code> file.</p>
			<h3>The header file</h3>
			<p>Here is the code for the header file:</p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> I2C_H_
<strong class="bold">#define</strong> I2C_H_
<strong class="bold">void i2c1_init</strong>(<strong class="bold">void</strong>);
<strong class="bold">void i2c1_byte_read</strong>(<strong class="bold">char</strong> saddr, <strong class="bold">char</strong> maddr, <strong class="bold">char</strong>* data);
<strong class="bold">void i2c1_burst_read</strong>(<strong class="bold">char</strong> saddr, <strong class="bold">char</strong> maddr, <strong class="bold">int</strong> n, <strong class="bold">char</strong>* data);
<strong class="bold">void i2c1_burst_write</strong>(<strong class="bold">char</strong> saddr, <strong class="bold">char</strong> maddr, <strong class="bold">int</strong> n, <strong class="bold">char</strong>* data);
<strong class="bold">#endif</strong></pre>			<p>Let’s update our driver for the adxl345 device to use the I2C driver we developed.</p>
			<h3>The ADXL345 I2C driver</h3>
			<p>Update<a id="_idIndexMarker989"/> the <a id="_idIndexMarker990"/>current <code>adxl345.c</code> in the <code>Src</code> folder:</p>
			<pre class="source-code">
<strong class="bold">#include</strong> "adxl345.h"
// Variable to store single byte of data
<strong class="bold">char</strong> data;
// Buffer to store multiple bytes of data from the ADXL345
uint8_t data_buffer[6];
<strong class="bold">void adxl_read_address</strong> (uint8_t reg)
{
     i2c1_byte_read( ADXL345_DEVICE_ADDR, reg, &amp;data);
}
<strong class="bold">void adxl_write</strong> (uint8_t reg, <strong class="bold">char</strong> value)
{
    <strong class="bold">char</strong> data[1];
    data[0] = value;
    i2c1_burst_write( ADXL345_DEVICE_ADDR, reg,1, data) ;
}
<strong class="bold">void adxl_read_values</strong> (uint8_t reg)
{
    // Read 6 bytes into <strong class="bold">wthe</strong> data buffer
    i2c1_burst_read(ADXL345_DEVICE_ADDR, reg, 6,(<strong class="bold">char</strong> *)data_buffer);
}
<strong class="bold">void adxl_init</strong> (<strong class="bold">void</strong>)
{
    /*Enable I2C*/
    i2c1_init();
    /*Read the DEVID, this should return 0xE5*/
    adxl_read_address(ADXL345_REG_DEVID);
    /*Set data format range to +-4g*/
    adxl_write (ADXL345_REG_DATA_FORMAT, ADXL345_RANGE_4G);
    /*Reset all bits*/
    adxl_write (ADXL345_REG_POWER_CTL, ADXL345_RESET);
    /*Configure power control measure bit*/
    adxl_write (ADXL345_REG_POWER_CTL, ADXL345_MEASURE_BIT);
}</pre>			<p>Here is a<a id="_idIndexMarker991"/> breakdown<a id="_idIndexMarker992"/> of the code:</p>
			<ul>
				<li>The <code>adxl_read_address</code> function reads a single byte of data from a specified register in the ADXL345 accelerometer. It uses the <code>i2c1_byte_read</code> function to communicate over the I2C bus, fetching the data from the register identified by the <code>reg</code> parameter and storing it in the <code>data</code> variable.</li>
				<li>The <code>adxl_write</code> function writes a single byte of data to a specific register in the ADXL345. It prepares a single-element array, containing the value to be written, and then uses <code>i2c1_burst_write</code> to send this data to the register specified by the <code>reg</code> parameter, over the I2C interface.</li>
				<li>The <code>adxl_read_values</code> function reads a block of data from the ADXL345 – specifically, <code>i2c1_burst_read</code> to pull this data, starting from the register specified by the <code>reg</code> parameter, and stores it in <code>data_buffer</code> for further processing.</li>
				<li>The <code>adxl_init</code> function initializes the ADXL345 accelerometer. It first enables I2C communication by calling <code>i2c1_init</code>, and then it checks the device’s identity by reading the <code>DEVID</code> register. Following this, it configures the data format to a range of <code>±4g</code>, resets the power control register, and finally, sets the power control register to start measuring acceleration.</li>
			</ul>
			<p>Next, we update<a id="_idIndexMarker993"/> the <a id="_idIndexMarker994"/>current <code>adxl345.h</code> in the <code>Inc</code> folder:</p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> ADXL345_H_
<strong class="bold">#define</strong> ADXL345_H_
<strong class="bold">#include</strong> "i2c.h"
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#define</strong>   ADXL345_REG_DEVID                (0x00)
<strong class="bold">#define</strong>   ADXL345_DEVICE_ADDR            (0x53)
<strong class="bold">#define</strong>   ADXL345_REG_DATA_FORMAT           (0x31)
<strong class="bold">#define</strong>   ADXL345_REG_POWER_CTL             (0x2D)
<strong class="bold">#define</strong>   ADXL345_REG_DATA_START            (0x32)
<strong class="bold">#define</strong>   ADXL345_REG_DATA_FORMAT           (0x31)
<strong class="bold">#define</strong>       ADXL345_RANGE_4G                (0x01)
<strong class="bold">#define</strong>       ADXL345_RESET                    (0x00)
<strong class="bold">#define</strong>    ADXL345_MEASURE_BIT                    (0x08)
<strong class="bold">void adxl_init</strong>(<strong class="bold">void</strong>);
<strong class="bold">void adxl_read_values</strong>(uint8_t reg);
<code>main.c</code> file.</p>
			<h3>The main function</h3>
			<p>Update<a id="_idIndexMarker995"/> your <code>main.c</code> file, as shown here:</p>
			<pre class="source-code">
<strong class="bold">#include</strong> &lt;stdio.h&gt;
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">#include</strong> "uart.h"
<strong class="bold">#include</strong> "adxl345.h"
//Variables for storing accelerometer data
int16_t accel_x, accel_y, accel_z;
<strong class="bold">double</strong> accel_x_g, accel_y_g, accel_z_g;
<strong class="bold">extern</strong> uint8_t data_buffer[6];
<strong class="bold">int main</strong>(<strong class="bold">void</strong>)
{
    uart_init();
    // Initialize the ADXL345 accelerometer
    adxl_init();
    <strong class="bold">while</strong> (1)
    {
        // Read accelerometer data starting from the data start 
        // register
        adxl_read_values(ADXL345_REG_DATA_START);
        // Combine high and low bytes to form the accelerometer data
        accel_x = (int16_t)((data_buffer[1] &lt;&lt; 8) | data_buffer[0]);
        accel_y = (int16_t)((data_buffer[3] &lt;&lt; 8) | data_buffer[2]);
        accel_z = (int16_t)((data_buffer[5] &lt;&lt; 8) | data_buffer[4]);
        // Convert raw data to g values
        accel_x_g = accel_x * 0.0078;
        accel_y_g = accel_y * 0.0078;
        accel_z_g = accel_z * 0.0078;
        <strong class="bold">printf</strong>("accel_x : %d accel_y : %d  accel_z : %d\n\
        r",accel_x,accel_y,accel_z);
    }
    <strong class="bold">return</strong> 0;
}</pre>			<p>It’s time<a id="_idIndexMarker996"/> to test the project. To do so, compile the code and run it on your microcontroller. Open RealTerm or another serial terminal application, and then configure it with the appropriate port and baud rate to view the debug messages. Press the black push button on the development board to reset the microcontroller. You should see the <em class="italic">X</em>, <em class="italic">Y</em>, and <em class="italic">Z</em> accelerometer values continuously being printed. Try moving the accelerometer to see how the values change significantly.</p>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor391"/>Summary</h1>
			<p>In this chapter, we learned about the I2C communication protocol. We began by discussing the fundamental principles of the I2C protocol, including its modes of operation, addressing schemes, and the step-by-step communication process.</p>
			<p>We then delved into the specifics of the STM32 I2C peripheral, highlighting key registers such as Control Register 1 (<strong class="bold">I2C_CR1</strong>), Control Register 2 (<strong class="bold">I2C_CR2</strong>), the Clock Control Register (<strong class="bold">I2C_CCR</strong>), and the Data Register (<strong class="bold">I2C_DR</strong>).</p>
			<p>Finally, we applied this theoretical knowledge to develop a bare-metal I2C driver. This driver allows us to initialize the I2C peripheral, perform both single-byte and burst data transfers, and handle communication with an external device such as the ADXL345 accelerometer.</p>
			<p>In the next chapter, we will learn about interrupts, a critical feature in modern microcontrollers that enables responsive and efficient handling of real-time events.</p>
		</div>
	</div>
</div>
</body></html>