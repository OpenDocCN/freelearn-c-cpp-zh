<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer116">
			<h1 id="_idParaDest-217" class="chapter-number"><a id="_idTextAnchor371"/>13</h1>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor372"/>Inter-Integrated Circuit (I2C)</h1>
			<p>In this chapter, we will learn about the <a id="_idTextAnchor373"/><strong class="bold">Inter-Integrated Circuit</strong> (<strong class="bold">I2C</strong>) communication protocol. We will begin by exploring the fundamental principles of the I2C protocol, covering its modes of operation, addressing methods, and the communication process. Then, we will examine the key registers of the I2C peripheral in STM32 microcontrollers and apply this knowledge to develop a bare-metal <span class="No-Break">I2C driver.</span></p>
			<p>In this chapter, we will cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li><a id="_idTextAnchor374"/>An overview of the <span class="No-Break">I2C protocol</span></li>
				<li>The STM32 <span class="No-Break">I2C peripheral</span></li>
				<li>Developing the <span class="No-Break">I2C Driver</span></li>
			</ul>
			<p>By the end of this chapter, you will have a solid grasp of the I2C protocol and be equipped with the skills to develop bare-metal drivers <span class="No-Break">for I2C.</span></p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor375"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming"><span class="No-Break">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor376"/>An overview of the I2C protocol</h1>
			<p>I2C <a id="_idIndexMarker923"/>is another commonly used protocol. Let’s explore what it is, its key features, how it works, and its <span class="No-Break">data format.</span></p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor377"/>What is I2C?</h2>
			<p>I2C <a id="_idIndexMarker924"/>is a <em class="italic">multi-master</em>, multi-slave, packet-switched, single-ended, serial communication bus invented by Philips Semiconductor (now NXP Semiconductors). It’s designed for short-distance communication within a single device or between multiple devices on the same board. I2C is known for its simplicity and ease of use, making it a popular choice for communication between microcontrollers and other ICs. Let’s see its <span class="No-Break">key features.</span></p>
			<h3>The key features of I2C</h3>
			<p>I2C has a number of unique features, which makes it ideal for various applications in <span class="No-Break">embedded systems:</span></p>
			<ul>
				<li><strong class="bold">A two-wire interface</strong>: I2C uses only two <a id="_idIndexMarker925"/>wires, <strong class="bold">Serial Data</strong> (<strong class="bold">SDA</strong>) and <strong class="bold">Serial Clock</strong> (<strong class="bold">SCL</strong>), which<a id="_idIndexMarker926"/> simplifies the wiring and reduces the number of pins required on <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker927"/></span><span class="No-Break"> microcontroller.</span></li>
				<li><strong class="bold">Multi-master and multi-slave</strong>: Multiple master devices can initiate communication <a id="_idIndexMarker928"/>on the bus, and multiple slave devices can respond. This <a id="_idIndexMarker929"/>flexibility allows for complex communication setups. The I2C protocol supports up to 128 devices with 7-bit addressing, although the practical limit is 119 due to reserved addresses. With 10-bit addressing, the protocol theoretically allows for 1,024 devices, but again, reserved addresses reduce the practical maximum slightly. The 10-bit mode, while less common, enables a higher number of devices on the <span class="No-Break">same bus.</span></li>
				<li><strong class="bold">Addressable devices</strong>: Each<a id="_idIndexMarker930"/> device on the I2C bus has a unique address, enabling the master to communicate with <span class="No-Break">specific slaves.</span></li>
				<li><strong class="bold">Synchronous communication</strong>: The SCL line provides the clock signal, ensuring that data is<a id="_idIndexMarker931"/> transferred synchronously <span class="No-Break">between devices.</span></li>
				<li><strong class="bold">Speed variants</strong>: I2C <a id="_idIndexMarker932"/>supports various speed modes, including standard mode (100 kHz), fast mode (400 kHz), fast mode plus (1 MHz), and high-speed mode (3.4 MHz), catering to different <span class="No-Break">speed requirements.</span></li>
				<li><strong class="bold">Simple and low-cost</strong>: The <a id="_idIndexMarker933"/>protocol’s simplicity and minimal hardware requirements make it cost-effective and easy <span class="No-Break">to implement.</span></li>
			</ul>
			<p>Let’s look at the <span class="No-Break">I2C interface.</span></p>
			<h3>The I2C interface</h3>
			<p>The I2C interface consists of two <span class="No-Break">main lines:</span></p>
			<ul>
				<li><strong class="bold">Serial Data (SDA)</strong>: This<a id="_idIndexMarker934"/> line carries the data being transferred between devices. It’s a bidirectional line, meaning that both the master and slave can send and <span class="No-Break">receive data.</span></li>
				<li><strong class="bold">Serial Clock (SCL)</strong>: This<a id="_idIndexMarker935"/> line carries the clock signal generated by the master device. It synchronizes the data transfer between the master and <span class="No-Break">t<a id="_idTextAnchor378"/><a id="_idTextAnchor379"/>he slave.</span></li>
			</ul>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B21914_13_1.jpg" alt="Figure 13.1: The I2C interface – multiple slaves" width="1617" height="648"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1: The I2C interface – multiple slaves</p>
			<p>These two lines are connected to all devices on the bus, with pull-up resistors to ensure that the lines are pulled to a high state when idle. Let’s see how <span class="No-Break">it works.</span></p>
			<h3>How I2C works</h3>
			<p>Understanding how<a id="_idIndexMarker936"/> I2C works involves looking at the <strong class="bold">roles</strong> of master and slave devices, the <strong class="bold">addressing scheme</strong>, and the <span class="No-Break"><strong class="bold">communication process</strong></span><span class="No-Break">.</span></p>
			<p>The following are the roles and <span class="No-Break">addressing scheme:</span></p>
			<ul>
				<li><strong class="bold">Master device</strong>: The <a id="_idIndexMarker937"/>master device initiates communication and generates a clock signal. It controls the flow of data and can address <span class="No-Break">multiple slaves.</span></li>
				<li><strong class="bold">Slave device</strong>: The<a id="_idIndexMarker938"/> slave device responds to the master’s commands and performs the requested operations. Each slave has a unique <strong class="bold">7-bit </strong>or <strong class="bold">10-bit address</strong> that the master uses to <span class="No-Break">identify it.</span></li>
			</ul>
			<p>The communication process is <span class="No-Break">as follows:</span></p>
			<ol>
				<li><strong class="bold">A start condition</strong>: Communication <a id="_idIndexMarker939"/>begins with the master<a id="_idIndexMarker940"/> generating a start condition. This involves pulling the SDA line low while the SCL line <span class="No-Break">is high.</span></li>
				<li><strong class="bold">Address frame</strong>: The <a id="_idIndexMarker941"/>master sends the address of the target slave device, followed by a read/write bit indicating the operation type (0 for write and 1 <span class="No-Break">for read).</span></li>
				<li><strong class="bold">Acknowledge (ACK) bit</strong>: The <a id="_idIndexMarker942"/>addressed slave responds with an ACK bit by pulling the SDA line low during the next <span class="No-Break">clock pulse.</span></li>
				<li><strong class="bold">Data Frames</strong>: Data is <a id="_idIndexMarker943"/>transferred in 8-bit frames. Each byte is followed by an ACK bit from <span class="No-Break">the receiver.</span></li>
				<li><strong class="bold">A stop condition</strong>: The <a id="_idIndexMarker944"/>master ends the communication by generating<a id="_idIndexMarker945"/> a stop condition, which involves pulling the SDA line high while the SCL line <span class="No-Break">is high.</span></li>
			</ol>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/B21914_13_2.jpg" alt="Figure 13.2: The I2C packet" width="1491" height="169"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2: The I2C packet</p>
			<p>Before we proceed to the next section, let’s take a moment to touch on the I2C data transfer, using <span class="No-Break">an example.</span></p>
			<p>Let’s begin by revisiting the <a id="_idIndexMarker946"/>role of the data frame and the <span class="No-Break">start condition:</span></p>
			<ul>
				<li><strong class="bold">Data frames</strong>: Data <a id="_idIndexMarker947"/>is transferred in <strong class="bold">8-bit bytes</strong>. After each byte, the receiver sends an ACK bit to confirm <span class="No-Break">successful reception.</span></li>
				<li><strong class="bold">Repeated start condition</strong>: If the master needs to communicate with another slave or continue communication without releasing the bus, it can generate a <strong class="bold">repeated start condition</strong> instead of a<a id="_idIndexMarker948"/> <span class="No-Break">stop condition.</span></li>
			</ul>
			<p>Let’s see the <span class="No-Break">data transfer:</span></p>
			<ul>
				<li><strong class="bold">Write operation</strong>: The <a id="_idIndexMarker949"/>master sends a <strong class="bold">start condition</strong>, the <strong class="bold">address frame </strong>with<a id="_idIndexMarker950"/> the <strong class="bold">write bit</strong>, and the <strong class="bold">data frames</strong>. Each <a id="_idIndexMarker951"/>data byte is followed by an ACK bit from <a id="_idIndexMarker952"/><span class="No-Break">the slave.</span></li>
				<li><strong class="bold">Read operation</strong>: The<a id="_idIndexMarker953"/> master sends a start condition, the address frame with<a id="_idIndexMarker954"/> the <strong class="bold">read bit</strong>, and then reads the data frames from the slave. Each data byte is acknowledged by the master with an ACK bit, except for the<a id="_idIndexMarker955"/> last byte, which is followed by<a id="_idIndexMarker956"/> a <strong class="bold">NACK</strong> to indicate the end of the <span class="No-Break">read operation.</span></li>
			</ul>
			<p>For a better understanding, let’s analyze <em class="italic">Figures 13.3</em> to <em class="italic">13.6</em>, starting with the start and <span class="No-Break">stop conditions.</span></p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B21914_13_3.jpg" alt="Figure 13.3: The start condition" width="367" height="491"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3: The start condition</p>
			<p>The following is the <span class="No-Break">stop condition:</span></p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/B21914_13_4.jpg" alt="Figure 13.4: The stop condition" width="431" height="619"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4: The stop condition</p>
			<p>The start <a id="_idIndexMarker957"/>condition occurs when the master device pulls the SDA line low while the SCL line remains high. This sequence signals all devices on the I2C bus that a communication session is about to begin, allowing the master to claim the bus for its intended operations. Without a valid start condition, the I²C communication <span class="No-Break">cannot commence.</span></p>
			<p>Conversely, the stop condition signals the end of communication. The master device releases the SDA line to a high state while the SCL line is high, indicating that the communication session is complete and the bus is now free for other devices. The proper use of stop conditions is essential for ensuring that no devices remain active on the bus, which could lead to conflicts or <span class="No-Break">communication errors.</span></p>
			<p>Next, let’s see how the I2C protocol distinguishes between zeros <span class="No-Break">and ones.</span></p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B21914_13_5.jpg" alt="Figure 13.5: The data transmission process" width="851" height="606"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5: The data transmission process</p>
			<p><span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.5</em> illustrates the<a id="_idIndexMarker958"/> data transmission process. Data is sent bit by bit, synchronized<a id="_idIndexMarker959"/> with the clock pulses on the SCL line. As shown, each bit of data is placed on the SDA line while the SCL line is low. When the SCL line transitions to high, the state of the SDA line is read by the receiving device. This particular figure shows the transmission of <strong class="bold">1</strong>, followed by <span class="No-Break">a </span><span class="No-Break"><strong class="bold">0</strong></span><span class="No-Break">.</span></p>
			<p>Finally, let’s examine the complete packet and how it interacts with the SDA and <span class="No-Break">SCL lines.</span></p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/B21914_13_6.jpg" alt="Figure 13.6: The complete packet" width="1484" height="700"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6: The complete packet</p>
			<p><span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.6</em> provides a<a id="_idIndexMarker960"/> comprehensive view of a complete I²C communication packet, showcasing the relationship between the SDA and SCL lines throughout the transaction. The communication begins with a start condition, where the SDA line is pulled low while the SCL line remains high, signaling the initiation of a new <span class="No-Break">communication sequence.</span></p>
			<p>Following the start condition, the address frame is transmitted. This frame contains the 7-bit address of the target device, followed by the <strong class="bold">read/write</strong> (<strong class="bold">R/W</strong>) bit<a id="_idIndexMarker961"/> that indicates whether the master intends to read from or write to the slave device. The address frame is then acknowledged by the slave device with an ACK bit, confirming that it is ready to proceed with <span class="No-Break">the communication.</span></p>
			<p>After the address frame, the data frame is transmitted. The data is sent in 8-bit bytes, with each bit being placed on the SDA line while the SCL line clocks each bit in sync. After each byte of data, the receiving device responds with another ACK bit, ensuring that the data was <span class="No-Break">received correctly.</span></p>
			<p>The communication concludes with a stop condition, where the SDA line is released to go high while the SCL line is also high. This signals the end of the communication session, freeing the bus for other potential communications. This complete cycle, from start to stop, forms the backbone of data exchange in the I²C protocol, ensuring structured and<a id="_idIndexMarker962"/> reliable communication <span class="No-Break">between devices.</span></p>
			<p>This concludes our overview of the I2C protocol. In the next section, we shall analyze the I2C peripheral in the <span class="No-Break">STM32F4 microcontroller.</span></p>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor380"/>The STM32F4 I2C peripherals</h1>
			<p>Depending on the specific model of STM32F4 you are working with, you can typically find up to three I2C peripherals labeled I2C1, I2C2, and I2C3. These peripherals enable the microcontroller to communicate with I2C-compatible devices using the standard <span class="No-Break">two-wire interface.</span></p>
			<p>The I2C peripherals in<a id="_idIndexMarker963"/> STM32F4 microcontrollers come packed with features that enhance their versatility <span class="No-Break">and performance:</span></p>
			<ul>
				<li><strong class="bold">Multi-master and multi-slave capabilities</strong>: Each I2C peripheral can operate as both master and slave, supporting multiple master configurations where more than one master device can control <span class="No-Break">the bus</span></li>
				<li><strong class="bold">Standard, fast, and fast mode plus</strong>: The peripherals support multiple speed modes, including <strong class="bold">standard mode</strong> (100 kHz), <strong class="bold">fast mode</strong> (400 kHz), and <strong class="bold">fast mode plus</strong> (1 MHz), allowing for flexibility in <span class="No-Break">communication speed</span></li>
				<li><strong class="bold">10-bit addressing</strong>: In addition to standard <strong class="bold">7-bit addressing</strong>, the I2C peripherals also support <strong class="bold">10-bit addressing</strong>, enabling communication with a broader range <span class="No-Break">of devices</span></li>
				<li><strong class="bold">Dual addressing mode</strong>: Each I2C peripheral can be configured to respond to two different addresses, useful for complex <span class="No-Break">multi-device setups</span></li>
				<li><strong class="bold">DMA support</strong>: <strong class="bold">Direct Memory Access</strong> (<strong class="bold">DMA</strong>) support is<a id="_idIndexMarker964"/> available, enabling efficient data transfer without <span class="No-Break">CPU intervention</span></li>
			</ul>
			<p>Let’s examine the key registers of <span class="No-Break">this peripheral.</span></p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor381"/>The key I2C registers</h2>
			<p>Configuring the I2C peripheral on an STM32 microcontroller involves several key registers that control various aspects of <span class="No-Break">its operation.</span></p>
			<p>Each register has specific bits that need to be set correctly to ensure proper functionality. Let’s break down the main registers we’ll be working with, starting with <strong class="bold">Control </strong><span class="No-Break"><strong class="bold">Register 1</strong></span><span class="No-Break">.</span></p>
			<h3>I2C Control Register 1 (I2C_CR1)</h3>
			<p><strong class="source-inline">I2C_CR1</strong> is one of the primary<a id="_idIndexMarker965"/> control registers used to configure the I2C peripheral’s basic operational settings. It provides options to <strong class="bold">enable the peripheral</strong>, manage the start and stop conditions, and control the <span class="No-Break">acknowledge feature.</span></p>
			<p>The key bits in<a id="_idIndexMarker966"/> this register include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Peripheral enable (PE)</strong>: This bit enables or disables the I2C peripheral. Setting this bit to 1 turns on the I2C peripheral, while clearing it turns <span class="No-Break">it off.</span></li>
				<li><strong class="bold">Start generation (START)</strong>: Setting this bit generates a <strong class="source-inline">START</strong> condition, <span class="No-Break">initiating communication.</span></li>
				<li><strong class="bold">Stop generation (STOP)</strong>: Setting this bit generates a <strong class="source-inline">STOP</strong> condition, <span class="No-Break">terminating communication.</span></li>
				<li><strong class="bold">Acknowledge enable (ACK)</strong>: When set, this bit enables the ACK after each <span class="No-Break">byte received.</span></li>
				<li><strong class="bold">Acknowledge/PEC position (POS)</strong>: This bit controls the position of the <span class="No-Break">ACK bit.</span></li>
				<li><strong class="bold">Software reset (SWRST)</strong>: Setting this bit resets the <span class="No-Break">I2C peripheral.</span></li>
			</ul>
			<p>You can find detailed information about this register on <em class="italic">page 492</em> of the STM32F4 reference manual (RM0383). Next, let’s look at I2C <strong class="bold">Control </strong><span class="No-Break"><strong class="bold">Register 2</strong></span><span class="No-Break">.</span></p>
			<h3>I2C Control Register 2 (I2C_CR2)</h3>
			<p><strong class="source-inline">I2C_CR2</strong> is another crucial control <a id="_idIndexMarker967"/>register that handles different aspects of I2C operation, including <strong class="bold">clock frequency</strong>, <strong class="bold">interrupt</strong> enable, and <strong class="bold">DMA</strong> control. Key bits in this<a id="_idIndexMarker968"/> register include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">FREQ[5:0] (peripheral clock frequency)</strong>: These bits set the I2C peripheral clock frequency <span class="No-Break">in MHz</span></li>
				<li><strong class="bold">DMAEN (DMA requests enable)</strong>: When set, this bit enables the DMA requests for the <span class="No-Break">I2C peripheral</span></li>
			</ul>
			<p>You can find detailed information about this register on <em class="italic">page 494</em> of the STM32F4 reference manual (RM0383). Next, let’s look at the I2C <strong class="bold">Clock </strong><span class="No-Break"><strong class="bold">Control Register</strong></span><span class="No-Break">.</span></p>
			<h3>I2C Clock Control Register (I2C_CCR)</h3>
			<p><strong class="source-inline">I2C_CCR</strong> configures the clock control <a id="_idIndexMarker969"/>settings for standard, fast, and fast mode <a id="_idIndexMarker970"/>plus operations. Key bits in this register include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">CCR[11:0] (clock control)</strong>: These bits set the clock control value, determining the I2C <span class="No-Break">clock speed</span></li>
				<li><strong class="bold">DUTY (fast mode duty cycle)</strong>: This bit selects the duty cycle for <span class="No-Break">fast mode</span></li>
				<li><strong class="bold">F/S (I2C master mode selection)</strong>: This bit selects between standard mode (0) and fast <span class="No-Break">mode (1)</span></li>
			</ul>
			<p>You can find detailed information about this register on <em class="italic">page 502</em> of the STM32F4 reference manual (RM0383). The next register is the I2C Rise <span class="No-Break">Time Register.</span></p>
			<h3>I2C TRISE register (I2C_TRISE)</h3>
			<p><strong class="source-inline">I2C_TRISE</strong> configures the maximum <a id="_idIndexMarker971"/>rise time for the I2C signals, en<a id="_idTextAnchor382"/>suring compliance with I2C specifications. This register has only one field – <strong class="bold">TRISE[5:0] (maximum rise time)</strong>. These bits set the maximum rise time for the SDA and SCL signals <span class="No-Break">in nanoseconds.</span></p>
			<p>The final register is the I2C <span class="No-Break"><strong class="bold">Data Register</strong></span><span class="No-Break">.</span></p>
			<h3>I2C Data Register (I2C_DR)</h3>
			<p><strong class="source-inline">I2C_DR</strong> is the data register used<a id="_idIndexMarker972"/> for both <strong class="bold">transmitting</strong> and <strong class="bold">receiving</strong> data. Data written to this register is transmitted, and data received from the bus is stored in this register. This register has only one field – <strong class="bold">DR[7:0] (8-bit data register)</strong>: This register holds the 8-bit data to be transmitted or the data received from <span class="No-Break">the bus.</span></p>
			<p>With these registers in mind, we’re now ready to develop the I2C driver. Let’s do that in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor383"/>Developing the I2C driver</h1>
			<p>Let’s develop the I2C driver. Create a <a id="_idIndexMarker973"/>copy of your previous project in your IDE and rename this copied project <strong class="source-inline">I2C</strong>. Next, create a new file named <strong class="source-inline">i2c.c</strong> in the <strong class="source-inline">Src</strong> folder and another file named <strong class="source-inline">i2c.h</strong> in the <span class="No-Break"><strong class="source-inline">Inc</strong></span><span class="No-Break"> folder.</span></p>
			<h3>The initialization function</h3>
			<p>Let’s populate the <strong class="source-inline">i2c.c</strong> file, starting <a id="_idIndexMarker974"/>with the macros and <span class="No-Break">initialization function:</span></p>
			<pre class="source-code">
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">#define</strong>     GPIOBEN            (1U&lt;&lt;1)
<strong class="bold">#define</strong>     I2C1EN            (1U&lt;&lt;21)
<strong class="bold">#define</strong>     I2C_100KHZ            80
<strong class="bold">#define</strong>     SD_MODE_MAX_RISE_TIME    17
<strong class="bold">#define</strong>    CR1_PE            (1U&lt;&lt;0)
<strong class="bold">#define</strong>    SR2_BUSY            (1U&lt;&lt;1)
<strong class="bold">#define</strong>    CR1_START            (1U&lt;&lt;8)
<strong class="bold">#define</strong>    SR1_SB            (1U&lt;&lt;0)
<strong class="bold">#define</strong>    SR1_ADDR            (1U&lt;&lt;1)
<strong class="bold">#define</strong>    SR1_TXE            (1U&lt;&lt;7)
<strong class="bold">#define</strong>    CR1_ACK            (1U&lt;&lt;10)
<strong class="bold">#define</strong>    CR1_STOP            (1U&lt;&lt;9)
<strong class="bold">#define</strong>    SR1_RXNE            (1U&lt;&lt;6)
<strong class="bold">#define</strong>    SR1_BTF            (1U&lt;&lt;2)
/*
 * PB8 ---- SCL
 * PB9 ----- SDA
 * */
<strong class="bold">void i2c1_init</strong>(<strong class="bold">void</strong>)
{
    /*Enable clock access to GPIOB*/
     RCC-&gt;AHB1ENR |=GPIOBEN;
    /*Set PB8 and PB9 mode to alternate function*/
    GPIOB-&gt;MODER &amp;=~(1U&lt;&lt;16);
    GPIOB-&gt;MODER |=(1U&lt;&lt;17);
    GPIOB-&gt;MODER &amp;=~(1U&lt;&lt;18);
    GPIOB-&gt;MODER |=(1U&lt;&lt;19);
    /*Set PB8 and PB9 output type to  open drain*/
    GPIOB-&gt;OTYPER |=(1U&lt;&lt;8);
    GPIOB-&gt;OTYPER |=(1U&lt;&lt;9);
    /*Enable Pull-up for PB8 and PB9*/
    GPIOB-&gt;PUPDR |=(1U&lt;&lt;16);
    GPIOB-&gt;PUPDR &amp;=~(1U&lt;&lt;17);
    GPIOB-&gt;PUPDR |=(1U&lt;&lt;18);
    GPIOB-&gt;PUPDR &amp;=~(1U&lt;&lt;19);
    /*Set PB8 and PB9 alternate function type to I2C (AF4)*/
    GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;0);
    GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;1);
    GPIOB-&gt;AFR[1] |=(1U&lt;&lt;2);
    GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;3);
    GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;4);
    GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;5);
    GPIOB-&gt;AFR[1] |=(1U&lt;&lt;6);
    GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;7);
    /*Enable clock access to I2C1*/
     RCC-&gt;APB1ENR |= I2C1EN;
    /*Enter reset mode  */
    I2C1-&gt;CR1 |= (1U&lt;&lt;15);
    /*Come out of reset mode  */
    I2C1-&gt;CR1 &amp;=~(1U&lt;&lt;15);
    /*Set Peripheral clock frequency*/
    I2C1-&gt;CR2 = (1U&lt;&lt;4);   //16 <strong class="bold">Mhz</strong>
    /*Set I2C to standard mode, 100kHz clock */
    I2C1-&gt;CCR = I2C_100KHZ;
    /*Set rise time */
    I2C1-&gt;TRISE = SD_MODE_MAX_RISE_TIME;
    /*Enable I2C1 module */
    I2C1-&gt;CR1 |= CR1_PE;
}</pre>			<p>Let’s <a id="_idIndexMarker975"/>break down what we have <span class="No-Break">so far:</span></p>
			<pre class="source-code">
RCC-&gt;AHB1ENR |= GPIOBEN;</pre>			<p>This line enables the clock for GPIOB by setting the <span class="No-Break">corresponding bit.</span></p>
			<pre class="source-code">
GPIOB-&gt;MODER &amp;=~(1U&lt;&lt;16);
GPIOB-&gt;MODER |=(1U&lt;&lt;17);
GPIOB-&gt;MODER &amp;=~(1U&lt;&lt;18);
GPIOB-&gt;MODER |=(1U&lt;&lt;19);</pre>			<p>These lines configure <strong class="source-inline">PB8</strong> and <strong class="source-inline">PB9</strong> pins to an alternate function mode <span class="No-Break">for I2C.</span></p>
			<pre class="source-code">
GPIOB-&gt;OTYPER |=(1U&lt;&lt;8);
GPIOB-&gt;OTYPER |=(1U&lt;&lt;9);</pre>			<p>These <a id="_idIndexMarker976"/>lines configure the pins as <strong class="bold">open-drain</strong>, which is required for <span class="No-Break">I2C communication.</span></p>
			<pre class="source-code">
GPIOB-&gt;PUPDR |=(1U&lt;&lt;16);
GPIOB-&gt;PUPDR &amp;=~(1U&lt;&lt;17);
GPIOB-&gt;PUPDR |=(1U&lt;&lt;18);
GPIOB-&gt;PUPDR &amp;=~(1U&lt;&lt;19);</pre>			<p>These lines<a id="_idIndexMarker977"/> enable <strong class="bold">pull-up resistors</strong> for the <span class="No-Break">I2C pins.</span></p>
			<pre class="source-code">
GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;0);
GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;1);
GPIOB-&gt;AFR[1] |=(1U&lt;&lt;2);
GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;3);
GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;4);
GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;5);
GPIOB-&gt;AFR[1] |=(1U&lt;&lt;6);
GPIOB-&gt;AFR[1] &amp;=~(1U&lt;&lt;7);</pre>			<p>These lines configure the <strong class="bold">alternate function</strong> for the pins <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">I2C1</strong></span><span class="No-Break">.</span></p>
			<pre class="source-code">
 RCC-&gt;APB1ENR |= I2C1EN;</pre>			<p>This line enables the clock for the <span class="No-Break">I2C1 peripheral.</span></p>
			<pre class="source-code">
I2C1-&gt;CR1 |= (1U&lt;&lt;15);
I2C1-&gt;CR1 &amp;=~(1U&lt;&lt;15);</pre>			<p>These lines <strong class="bold">reset</strong> the <span class="No-Break">I2C1 peripheral.</span></p>
			<pre class="source-code">
I2C1-&gt;CR2 = (1U&lt;&lt;4);</pre>			<p>This configures the <span class="No-Break">I2C1 clock.</span></p>
			<pre class="source-code">
 I2C1-&gt;CCR = I2C_100KHZ;</pre>			<p>This line sets the clock control register for 100 kHz standard mode, using the macro <span class="No-Break">we defined.</span></p>
			<pre class="source-code">
I2C1-&gt;TRISE = SD_MODE_MAX_RISE_TIME;</pre>			<p>This line sets the rise time for the I2C signals using the macro we defined. The TRISE register specifies the maximum time the signal is allowed to take to transition from a low to a high state on the I2C bus. Setting this value correctly is important to ensure that the I2C communication adheres to the timing requirements of the I2C standard, which helps maintain <a id="_idIndexMarker978"/>reliable and <span class="No-Break">stable communication.</span></p>
			<pre class="source-code">
I2C1-&gt;CR1 |= CR1_PE;</pre>			<p>This line enables the I2C1 peripheral by setting the PE bit. Next, we will add and analyze the function to read a byte from an I2C <span class="No-Break">slave device.</span></p>
			<h3>The read function</h3>
			<p>Let’s<a id="_idIndexMarker979"/> analyze the <span class="No-Break"><strong class="source-inline">read</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
<strong class="bold">void i2c1_byte_read</strong>(<strong class="bold">char</strong> saddr, <strong class="bold">char</strong> maddr, <strong class="bold">char</strong>* data) {
      <strong class="bold">volatile int</strong> tmp;
      /* Wait until bus not busy */
      <strong class="bold">while</strong> (I2C1-&gt;SR2 &amp; (SR2_BUSY)){}
      /* Generate start */
      I2C1-&gt;CR1 |= CR1_START;
      /* Wait until start flag is set */
      <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; (SR1_SB))){}
      /* Transmit slave address + Write */
      I2C1-&gt;DR = saddr &lt;&lt; 1;
      /* Wait until <strong class="bold">addr</strong> flag is set */
      <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; (SR1_ADDR))){}
      /* Clear <strong class="bold">addr</strong> flag */
      tmp = I2C1-&gt;SR2;
      /* Send memory address */
      I2C1-&gt;DR = maddr;
      /*Wait until transmitter empty */
      <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; SR1_TXE)){}
     /*Generate restart */
     I2C1-&gt;CR1 |= CR1_START;
      /* Wait until start flag is set */
      <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; SR1_SB)){}
     /* Transmit slave address + Read */
     I2C1-&gt;DR = saddr &lt;&lt; 1 | 1;
     /* Wait until <strong class="bold">addr</strong> flag is set */
     <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; (SR1_ADDR))){}
    /* Disable Acknowledge */
    I2C1-&gt;CR1 &amp;= ~CR1_ACK;
    /* Clear <strong class="bold">addr</strong> flag */
    tmp = I2C1-&gt;SR2;
    /* Generate stop after data received */
    I2C1-&gt;CR1 |= CR1_STOP;
    /* Wait until RXNE flag is set */
    <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; SR1_RXNE)){}
    /* Read data from DR */
      *data++ = I2C1-&gt;DR;
}</pre>			<p>Let’s break down what<a id="_idTextAnchor384"/> we have <span class="No-Break">so far:</span></p>
			<ul>
				<li><strong class="source-inline">while (I2C1-&gt;SR2 &amp; (SR2_BUSY)){}</strong>: This line waits for the I2C bu<a id="_idTextAnchor385"/>s to be free by checking the state of the <strong class="source-inline">BUSY</strong> bit in I2C Status <span class="No-Break">Register 2.</span></li>
				<li><strong class="source-inline">I2C1-&gt;CR1 |= CR1_START;</strong>: This line initiates a start condition <a id="_idTextAnchor386"/>on the <span class="No-Break">I2C bus.</span></li>
				<li><strong class="source-inline">while (!(I2C1-&gt;SR1 &amp; (SR1_SB))){}</strong>: This line waits until the start condition is acknowledged by checking the <strong class="source-inline">SB</strong> bit in I2C Status <span class="No-Break">Register 1.</span></li>
				<li><strong class="source-inline">I2C1-&gt;DR = saddr &lt;&lt; 1;</strong>: This line sends the slave address with the write bit. The 7-bit address of the device is left-shifted by 1 bit to make room for the R/W bit in<a id="_idIndexMarker980"/> the <strong class="bold">least significant bit</strong> (<strong class="bold">LSB</strong>) position. By only shifting <strong class="source-inline">saddr</strong> left by 1, we prepare the address for a subsequent write operation to the<a id="_idTextAnchor387"/> <span class="No-Break">slave device.</span></li>
				<li><strong class="source-inline">while (!(I2C1-&gt;SR1 &amp; (SR1_ADDR))){}</strong>: This line waits until the <a id="_idTextAnchor388"/>address is acknowledged by checking the <strong class="source-inline">ADDR</strong> bit in I2C Status <span class="No-Break">Register 1.</span></li>
				<li> <strong class="source-inline">tmp = I2C1-&gt;SR2;</strong>: This line clears the address flag by simply reading I2C Status <span class="No-Break">Register 2.</span></li>
				<li><strong class="source-inline">2C1-&gt;DR = maddr;</strong>: Here, we send the memory address to read from the <span class="No-Break">slave device.</span></li>
				<li><strong class="source-inline">while (!(I2C1-&gt;SR1 &amp; SR1_TXE)){}</strong>: This line waits until the data register is empty by reading the<a id="_idIndexMarker981"/> transmit buffer empty (<strong class="source-inline">TXE</strong>) bit in I2C Status <span class="No-Break">Register 1.</span></li>
				<li><strong class="source-inline">I2C1-&gt;CR1 |= CR1_START;</strong>: This line initiates<a id="_idIndexMarker982"/> a <strong class="bold">restart condition</strong> on the <span class="No-Break">I2C bus.</span></li>
				<li><strong class="source-inline">while (!(I2C1-&gt;SR1 &amp; SR1_SB)){}</strong>: Here, we wait until the restart condition is acknowledged by checking the <strong class="source-inline">SB</strong> bit in I2C Status <span class="No-Break">Register 1.</span></li>
				<li><strong class="source-inline">I2C1-&gt;DR = saddr &lt;&lt; 1 | 1;</strong>: This line prepares the I2C data register for a read operation by setting up the 7-bit I2C address of the slave device and appending the R/W bit. Specifically, <strong class="source-inline">saddr &lt;&lt; 1</strong> shifts the 7-bit address left by one bit to make room for the LSB, which is then set to 1 using the bitwise <strong class="source-inline">OR </strong>operator (| 1). This final value, with the LSB set to 1, indicates a read operation when loaded into the I2C1 <strong class="bold">data register</strong> (<strong class="bold">DR</strong>). Hence, this line configures the I2C peripheral to<a id="_idIndexMarker983"/> initiate communication with the slave device, requesting to read data <span class="No-Break">from it.</span></li>
				<li><strong class="source-inline">while (!(I2C1-&gt;SR1 &amp; (SR1_ADDR))){}</strong>: This line waits until the address <span class="No-Break">is acknowledged.</span></li>
				<li><strong class="source-inline">I2C1-&gt;CR1 &amp;= ~CR1_ACK;</strong>: This line disables the acknowledge bit to prepare for a <span class="No-Break">stop condition.</span></li>
				<li><strong class="source-inline">tmp = I2<a id="_idTextAnchor389"/>C1-&gt;SR2;</strong>: This line clears the address flag by reading I2C Status <span class="No-Break">Register 2.</span></li>
				<li><strong class="source-inline">I2C1-&gt;CR1 |= CR1_STOP;</strong>: This initiates a stop condition on the <span class="No-Break">I2C bus.</span></li>
				<li><strong class="source-inline">while (!(I2C1-&gt;SR1 &amp; SR1_RXNE)){}</strong>: This line waits until the receive buffer is not empty by reading<a id="_idIndexMarker984"/> the <strong class="bold">Receive Buffer Register Not Empty</strong> (<strong class="source-inline">RXNE</strong>) flag in I2C Status Register 1. This flag indicates that new data has been received and i<a id="_idTextAnchor390"/>s available in the <span class="No-Break">data register.</span></li>
				<li><strong class="source-inline"> *data++ = I2C1-&gt;DR;</strong>: This line is responsible for storing the received byte of data from the I2C DR in the memory location pointed to by the <span class="No-Break"><strong class="source-inline">data</strong></span><span class="No-Break"> pointer.</span></li>
			</ul>
			<p>Next, we have a function to read multiple bytes from the <span class="No-Break">slave device:</span></p>
			<pre class="source-code">
<strong class="bold">void i2c1_burst_read</strong>(<strong class="bold">char</strong> saddr, <strong class="bold">char</strong> maddr, <strong class="bold">int</strong> n, <strong class="bold">char</strong>* data) {
    <strong class="bold">volatile int</strong> tmp;
     /* Wait until bus not busy */
     <strong class="bold">while</strong> (I2C1-&gt;SR2 &amp; (SR2_BUSY)){}
     /* Generate start */
     I2C1-&gt;CR1 |= CR1_START;
     /* Wait until start flag is set */
     <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; SR1_SB)){}
     /* Transmit slave address + Write */
     I2C1-&gt;DR = saddr &lt;&lt; 1;
     /* Wait until <strong class="bold">addr</strong> flag is set */
     <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; SR1_ADDR)){}
    /* Clear <strong class="bold">addr</strong> flag */
     tmp = I2C1-&gt;SR2;
    /* Wait until transmitter empty */
    <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; SR1_TXE)){}
    /*Send memory address */
    I2C1-&gt;DR = maddr;
    /*Wait until transmitter empty */
    <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; SR1_TXE)){}
    /*Generate restart */
    I2C1-&gt;CR1 |= CR1_START;
    /* Wait until start flag is set */
    <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; SR1_SB)){}
    /* Transmit slave address + Read */
    I2C1-&gt;DR = saddr &lt;&lt; 1 | 1;
    /* Wait until <strong class="bold">addr</strong> flag is set */
    <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; (SR1_ADDR))){}
    /* Clear <strong class="bold">addr</strong> flag */
    tmp = I2C1-&gt;SR2;
    /* Enable Acknowledge */
      I2C1-&gt;CR1 |=  CR1_ACK;
    <strong class="bold">while</strong>(n &gt; 0U)
    {
        /*if one byte*/
        <strong class="bold">if</strong>(n == 1U)
        {
            /* Disable Acknowledge */
            I2C1-&gt;CR1 &amp;= ~CR1_ACK;
            /* Generate Stop */
            I2C1-&gt;CR1 |= CR1_STOP;
            /* Wait for RXNE flag set */
            <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; SR1_RXNE)){}
            /* Read data from DR */
            *data++ = I2C1-&gt;DR;
            <strong class="bold">break</strong>;
        }
        <strong class="bold">else</strong>
        {
           /* Wait until RXNE flag is set */
           <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; SR1_RXNE)){}
           /* Read data from DR */
           (*data++) = I2C1-&gt;DR;
           n--;
        }
    }
}</pre>			<p>This function<a id="_idIndexMarker985"/> reads multiple bytes of data from a specified memory address in the I2C slave device. Here’s a breakdown of what <span class="No-Break">it does:</span></p>
			<ol>
				<li><strong class="bold">Waits for bus availability</strong>: The function starts by ensuring that the I2C bus is not busy, waiting until it is free to <span class="No-Break">initiate communication.</span></li>
				<li><strong class="bold">Generates a start condition</strong>: It generates a start condition to begin communication with the <span class="No-Break">slave device.</span></li>
				<li><strong class="bold">Transmits a slave address for write</strong>: The function sends the slave device address with a write bit, indicating that it will initially write data to specify the <span class="No-Break">memory address.</span></li>
				<li><strong class="bold">Waits for the address flag and clears it</strong>: It waits for the address flag to be set and then clears it by reading the <span class="No-Break">SR2 register.</span></li>
				<li><strong class="bold">Transmits the memory address</strong>: The memory address from which to start reading is sent to the <span class="No-Break">slave device.</span></li>
				<li><strong class="bold">Generates a restart condition</strong>: A repeated start condition is generated to switch the communication mode from write <span class="No-Break">to read.</span></li>
				<li><strong class="bold">Transmits a slave address for read</strong>: The function sends the slave address with a read bit, indicating that it will read data from the <span class="No-Break">slave device.</span></li>
				<li><strong class="bold">Waits for the address flag and clears it</strong>: Again, it waits for the address flag to be set and clears it by reading the <span class="No-Break">SR2 register.</span></li>
				<li><strong class="bold">Enables acknowledge</strong>: The acknowledge bit <span class="No-Break">is set.</span></li>
				<li><strong class="bold">Reads a data loop</strong>: The function enters a loop to read the specified number <span class="No-Break">of bytes:</span><ul><li><strong class="bold">A single-byte read</strong>: If only one byte is left to read, the acknowledge bit is cleared, a stop condition is generated, and the data is read into <span class="No-Break">the buffer</span></li><li><strong class="bold">A multiple-byte read</strong>: If more than one byte is to be read, it waits for the <strong class="source-inline">RXNE</strong> flag to indicate that data is ready, reads the data into the buffer, and decrements<a id="_idIndexMarker986"/> the <span class="No-Break">byte counter</span></li></ul></li>
			</ol>
			<p>Finally, we add the function to write data to the <span class="No-Break">slave device.</span></p>
			<h3>The write function</h3>
			<p>Let’s break down the<a id="_idIndexMarker987"/> function to write multiple bytes to the <span class="No-Break">slave device:</span></p>
			<pre class="source-code">
<strong class="bold">void i2c1_burst_write</strong>(<strong class="bold">char</strong> saddr, <strong class="bold">char</strong> maddr, <strong class="bold">int</strong> n, <strong class="bold">char</strong>* data) {
    <strong class="bold">volatile int</strong> tmp;
    /* Wait until bus not busy */
    <strong class="bold">while</strong> (I2C1-&gt;SR2 &amp; (SR2_BUSY)){}
    /* Generate start */
    I2C1-&gt;CR1 |= CR1_START;
    /* Wait until start flag is set */
    <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; (SR1_SB))){}
    /* Transmit slave address */
    I2C1-&gt;DR = saddr &lt;&lt; 1;
    /* Wait until <strong class="bold">addr</strong> flag is set */
    <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; (SR1_ADDR))){}
    /* Clear <strong class="bold">addr</strong> flag */
    tmp = I2C1-&gt;SR2;
    /* Wait until data register empty */
    <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; (SR1_TXE))){}
    /* Send memory address */
    I2C1-&gt;DR = maddr;
    <strong class="bold">for</strong> (<strong class="bold">int</strong> i = 0; i &lt; n; i++) {
     /* Wait until data register empty */
        <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; (SR1_TXE))){}
      /* Transmit memory address */
      I2C1-&gt;DR = *data++;
    }
    /* Wait until transfer finished */
    <strong class="bold">while</strong> (!(I2C1-&gt;SR1 &amp; (SR1_BTF))){}
    /* Generate stop */
    I2C1-&gt;CR1 |= CR1_STOP;
}</pre>			<p>This function<a id="_idIndexMarker988"/> writes <strong class="bold">multiple bytes</strong> of data to a specific memory address in the I2C slave device. The function begins by waiting for the I2C bus to be free, ensuring that there is no ongoing communication. It then generates a start condition to initiate communication with the slave device. The slave address is transmitted with a write bit, and then the function waits for the address flag to be set and cleared by reading the SR2 register. After ensuring the data register is empty, it sends the memory address where the data writing should begin. The function enters a loop to transmit each byte of data, waiting for the data register to empty before each byte is sent. Once all bytes have been transmitted, it waits for the byte transfer to finish and then generates a stop condition to end <span class="No-Break">the communication.</span></p>
			<p>Our next task is to populate the <span class="No-Break"><strong class="source-inline">i2c.h</strong></span><span class="No-Break"> file.</span></p>
			<h3>The header file</h3>
			<p>Here is the code for the <span class="No-Break">header file:</span></p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> I2C_H_
<strong class="bold">#define</strong> I2C_H_
<strong class="bold">void i2c1_init</strong>(<strong class="bold">void</strong>);
<strong class="bold">void i2c1_byte_read</strong>(<strong class="bold">char</strong> saddr, <strong class="bold">char</strong> maddr, <strong class="bold">char</strong>* data);
<strong class="bold">void i2c1_burst_read</strong>(<strong class="bold">char</strong> saddr, <strong class="bold">char</strong> maddr, <strong class="bold">int</strong> n, <strong class="bold">char</strong>* data);
<strong class="bold">void i2c1_burst_write</strong>(<strong class="bold">char</strong> saddr, <strong class="bold">char</strong> maddr, <strong class="bold">int</strong> n, <strong class="bold">char</strong>* data);
<strong class="bold">#endif</strong></pre>			<p>Let’s update our driver for the adxl345 device to use the I2C driver <span class="No-Break">we developed.</span></p>
			<h3>The ADXL345 I2C driver</h3>
			<p>Update<a id="_idIndexMarker989"/> the <a id="_idIndexMarker990"/>current <strong class="source-inline">adxl345.c</strong> in the <span class="No-Break"><strong class="source-inline">Src</strong></span><span class="No-Break"> folder:</span></p>
			<pre class="source-code">
<strong class="bold">#include</strong> "adxl345.h"
// Variable to store single byte of data
<strong class="bold">char</strong> data;
// Buffer to store multiple bytes of data from the ADXL345
uint8_t data_buffer[6];
<strong class="bold">void adxl_read_address</strong> (uint8_t reg)
{
     i2c1_byte_read( ADXL345_DEVICE_ADDR, reg, &amp;data);
}
<strong class="bold">void adxl_write</strong> (uint8_t reg, <strong class="bold">char</strong> value)
{
    <strong class="bold">char</strong> data[1];
    data[0] = value;
    i2c1_burst_write( ADXL345_DEVICE_ADDR, reg,1, data) ;
}
<strong class="bold">void adxl_read_values</strong> (uint8_t reg)
{
    // Read 6 bytes into <strong class="bold">wthe</strong> data buffer
    i2c1_burst_read(ADXL345_DEVICE_ADDR, reg, 6,(<strong class="bold">char</strong> *)data_buffer);
}
<strong class="bold">void adxl_init</strong> (<strong class="bold">void</strong>)
{
    /*Enable I2C*/
    i2c1_init();
    /*Read the DEVID, this should return 0xE5*/
    adxl_read_address(ADXL345_REG_DEVID);
    /*Set data format range to +-4g*/
    adxl_write (ADXL345_REG_DATA_FORMAT, ADXL345_RANGE_4G);
    /*Reset all bits*/
    adxl_write (ADXL345_REG_POWER_CTL, ADXL345_RESET);
    /*Configure power control measure bit*/
    adxl_write (ADXL345_REG_POWER_CTL, ADXL345_MEASURE_BIT);
}</pre>			<p>Here is a<a id="_idIndexMarker991"/> breakdown<a id="_idIndexMarker992"/> of <span class="No-Break">the code:</span></p>
			<ul>
				<li>The <strong class="source-inline">adxl_read_address</strong> function reads a single byte of data from a specified register in the ADXL345 accelerometer. It uses the <strong class="source-inline">i2c1_byte_read</strong> function to communicate over the I2C bus, fetching the data from the register identified by the <strong class="source-inline">reg</strong> parameter and storing it in the <span class="No-Break"><strong class="source-inline">data</strong></span><span class="No-Break"> variable.</span></li>
				<li>The <strong class="source-inline">adxl_write</strong> function writes a single byte of data to a specific register in the ADXL345. It prepares a single-element array, containing the value to be written, and then uses <strong class="source-inline">i2c1_burst_write</strong> to send this data to the register specified by the <strong class="source-inline">reg</strong> parameter, over the <span class="No-Break">I2C interface.</span></li>
				<li>The <strong class="source-inline">adxl_read_values</strong> function reads a block of data from the ADXL345 – specifically, <strong class="bold">6 bytes</strong>, which is the size required to capture the accelerometer’s <em class="italic">X</em>, <em class="italic">Y</em>, and <em class="italic">Z</em> axis data. It uses <strong class="source-inline">i2c1_burst_read</strong> to pull this data, starting from the register specified by the <strong class="source-inline">reg</strong> parameter, and stores it in <strong class="source-inline">data_buffer</strong> for <span class="No-Break">further processing.</span></li>
				<li>The <strong class="source-inline">adxl_init</strong> function initializes the ADXL345 accelerometer. It first enables I2C communication by calling <strong class="source-inline">i2c1_init</strong>, and then it checks the device’s identity by reading the <strong class="source-inline">DEVID</strong> register. Following this, it configures the data format to a range of <strong class="source-inline">±4g</strong>, resets the power control register, and finally, sets the power control register to start <span class="No-Break">measuring acceleration.</span></li>
			</ul>
			<p>Next, we update<a id="_idIndexMarker993"/> the <a id="_idIndexMarker994"/>current <strong class="source-inline">adxl345.h</strong> in the <span class="No-Break"><strong class="source-inline">Inc</strong></span><span class="No-Break"> folder:</span></p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> ADXL345_H_
<strong class="bold">#define</strong> ADXL345_H_
<strong class="bold">#include</strong> "i2c.h"
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#define</strong>   ADXL345_REG_DEVID                (0x00)
<strong class="bold">#define</strong>   ADXL345_DEVICE_ADDR            (0x53)
<strong class="bold">#define</strong>   ADXL345_REG_DATA_FORMAT           (0x31)
<strong class="bold">#define</strong>   ADXL345_REG_POWER_CTL             (0x2D)
<strong class="bold">#define</strong>   ADXL345_REG_DATA_START            (0x32)
<strong class="bold">#define</strong>   ADXL345_REG_DATA_FORMAT           (0x31)
<strong class="bold">#define</strong>       ADXL345_RANGE_4G                (0x01)
<strong class="bold">#define</strong>       ADXL345_RESET                    (0x00)
<strong class="bold">#define</strong>    ADXL345_MEASURE_BIT                    (0x08)
<strong class="bold">void adxl_init</strong>(<strong class="bold">void</strong>);
<strong class="bold">void adxl_read_values</strong>(uint8_t reg);
<strong class="bold">#endif</strong></pre>			<p>We are now ready to test the driver inside the <span class="No-Break"><strong class="source-inline">main.c</strong></span><span class="No-Break"> file.</span></p>
			<h3>The main function</h3>
			<p>Update<a id="_idIndexMarker995"/> your <strong class="source-inline">main.c</strong> file, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
<strong class="bold">#include</strong> &lt;stdio.h&gt;
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">#include</strong> "uart.h"
<strong class="bold">#include</strong> "adxl345.h"
//Variables for storing accelerometer data
int16_t accel_x, accel_y, accel_z;
<strong class="bold">double</strong> accel_x_g, accel_y_g, accel_z_g;
<strong class="bold">extern</strong> uint8_t data_buffer[6];
<strong class="bold">int main</strong>(<strong class="bold">void</strong>)
{
    uart_init();
    // Initialize the ADXL345 accelerometer
    adxl_init();
    <strong class="bold">while</strong> (1)
    {
        // Read accelerometer data starting from the data start 
        // register
        adxl_read_values(ADXL345_REG_DATA_START);
        // Combine high and low bytes to form the accelerometer data
        accel_x = (int16_t)((data_buffer[1] &lt;&lt; 8) | data_buffer[0]);
        accel_y = (int16_t)((data_buffer[3] &lt;&lt; 8) | data_buffer[2]);
        accel_z = (int16_t)((data_buffer[5] &lt;&lt; 8) | data_buffer[4]);
        // Convert raw data to g values
        accel_x_g = accel_x * 0.0078;
        accel_y_g = accel_y * 0.0078;
        accel_z_g = accel_z * 0.0078;
        <strong class="bold">printf</strong>("accel_x : %d accel_y : %d  accel_z : %d\n\
        r",accel_x,accel_y,accel_z);
    }
    <strong class="bold">return</strong> 0;
}</pre>			<p>It’s time<a id="_idIndexMarker996"/> to test the project. To do so, compile the code and run it on your microcontroller. Open RealTerm or another serial terminal application, and then configure it with the appropriate port and baud rate to view the debug messages. Press the black push button on the development board to reset the microcontroller. You should see the <em class="italic">X</em>, <em class="italic">Y</em>, and <em class="italic">Z</em> accelerometer values continuously being printed. Try moving the accelerometer to see how the values <span class="No-Break">change significantly.</span></p>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor391"/>Summary</h1>
			<p>In this chapter, we learned about the I2C communication protocol. We began by discussing the fundamental principles of the I2C protocol, including its modes of operation, addressing schemes, and the step-by-step <span class="No-Break">communication process.</span></p>
			<p>We then delved into the specifics of the STM32 I2C peripheral, highlighting key registers such as Control Register 1 (<strong class="bold">I2C_CR1</strong>), Control Register 2 (<strong class="bold">I2C_CR2</strong>), the Clock Control Register (<strong class="bold">I2C_CCR</strong>), and the Data <span class="No-Break">Register (</span><span class="No-Break"><strong class="bold">I2C_DR</strong></span><span class="No-Break">).</span></p>
			<p>Finally, we applied this theoretical knowledge to develop a bare-metal I2C driver. This driver allows us to initialize the I2C peripheral, perform both single-byte and burst data transfers, and handle communication with an external device such as the <span class="No-Break">ADXL345 accelerometer.</span></p>
			<p>In the next chapter, we will learn about interrupts, a critical feature in modern microcontrollers that enables responsive and efficient handling of <span class="No-Break">real-time events.</span></p>
		</div>
	</div>
</div>
</body></html>