["```cpp\nQT = core gui\nTARGET = triangle\nTEMPLATE = app \n```", "```cpp\nclass SimpleGLWindow : public QOpenGLWindow,\n                       protected QOpenGLFunctions_1_1 \n{\npublic:\n    SimpleGLWindow(QWindow *parent = 0) :\n        QOpenGLWindow(NoPartialUpdate, parent) {\n    }\nprotected:\n    void initializeGL() {\n        if (!initializeOpenGLFunctions()) {\n            qFatal(\"initializeOpenGLFunctions failed\");\n        }\n        glClearColor(1, 1, 1, 0);\n    } \n};\n```", "```cpp\nvoid SimpleGLWindow::paintGL() {\n    glClear(GL_COLOR_BUFFER_BIT);\n    glViewport(0, 0, width(), height());\n    glBegin(GL_TRIANGLES);\n    {\n        glColor3f(1, 0, 0);\n        glVertex3f( 0.0f, 1.0f, 0.0f);\n        glColor3f(0, 1, 0);\n        glVertex3f( 1.0f, -1.0f, 0.0f);\n        glColor3f(0, 0, 1);\n        glVertex3f(-1.0f, -1.0f, 0.0f);\n    }\n    glEnd();\n}\n```", "```cpp\nint main(int argc, char **argv) {\n    QGuiApplication app(argc, argv);\n    SimpleGLWindow window;\n    window.resize(600, 400);\n    window.show();\n    return app.exec();\n} \n```", "```cpp\nQSurfaceFormat fmt = format();\nfmt.setSamples(16); // multisampling set to 16\nsetFormat(fmt);\n```", "```cpp\nclass AbstractGLScene : protected QOpenGLFunctions_1_1 {\npublic:\n    AbstractGLScene(QOpenGLWindow *window = nullptr) {\n        m_window = window;\n    }\n    QOpenGLWindow* window() const { return m_window; }\n    QOpenGLContext* context() {\n       return m_window ? m_window->context() : nullptr;\n    }\n    const QOpenGLContext* context() const {\n        return m_window ? m_window->context() : nullptr;\n    }\nprivate:\n    QOpenGLWindow *m_window = nullptr;\n}; \n```", "```cpp\nSceneGLWindow::SceneGLWindow(QWindow *parent) : \n    QOpenGLWindow(NoPartialUpdate, parent)\n{\n}\n```", "```cpp\nvoid SceneGLWindow::initializeGL() {\n    if(m_scene) {\n        m_scene->initialize();\n    }\n}\nvoid SceneGLWindow::paintGL() {\n    if(m_scene) {\n        m_scene->paint();\n    }\n}\n```", "```cpp\nvoid CubeGLScene::initializeTexture() {\n    m_texture = new QOpenGLTexture(m_textureImage.mirrored());\n    m_texture->setMinificationFilter(QOpenGLTexture::LinearMipMapLinear);\n    m_texture->setMagnificationFilter(QOpenGLTexture::Linear);\n} \n```", "```cpp\nvoid CubeGLScene::initialize() {\n    AbstractGLScene::initialize();\n    m_initialized = true;\n    if(!m_textureImage.isNull()) {\n        initializeTexture();\n    }\n    glClearColor(1, 1, 1, 0);\n    glShadeModel(GL_SMOOTH);\n} \n```", "```cpp\nstruct TexturedPoint {\n    QVector3D coord;\n    QVector2D uv;\n    TexturedPoint(const QVector3D& pcoord = QVector3D(),\n                  const QVector2D& puv = QVector2D()) :\n        coord(pcoord), uv(puv) {\n    }\n}; \n```", "```cpp\nvoid CubeGLScene::initializeCubeData() {\n    m_data = {\n        // FRONT FACE\n        {{-0.5, -0.5,  0.5}, {0, 0}}, {{ 0.5, -0.5,  0.5}, {1, 0}},\n        {{ 0.5,  0.5,  0.5}, {1, 1}}, {{-0.5,  0.5,  0.5}, {0, 1}},\n\n        // TOP FACE\n        {{-0.5,  0.5,  0.5}, {0, 0}}, {{ 0.5,  0.5,  0.5}, {1, 0}},\n        {{ 0.5,  0.5, -0.5}, {1, 1}}, {{-0.5,  0.5, -0.5}, {0, 1}},\n        //...\n    };\n} \n```", "```cpp\n  void CubeGLScene::paint() {\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glViewport(0, 0, window()->width(), window()->height());\n    glLoadIdentity();\n\n    glRotatef(45, 1.0, 0.0, 0.0);\n    glRotatef(45, 0.0, 1.0, 0.0);\n\n    glEnable(GL_DEPTH_TEST);\n    glEnable(GL_CULL_FACE);\n    glCullFace(GL_BACK);\n    paintCube();\n} \n```", "```cpp\nvoid CubeGLScene::paintCube() {\n    if(m_texture) {\n        m_texture->bind();\n    }\n    glEnable(GL_TEXTURE_2D);\n    glBegin(GL_QUADS);\n    for(const TexturedPoint &point: m_data) {\n        glTexCoord2d(point.uv.x(), point.uv.y());\n        glVertex3f(point.coord.x(), point.coord.y(), point.coord.z());\n    }\n    glEnd();\n    glDisable(GL_TEXTURE_2D);\n} \n```", "```cpp\nint main(int argc, char **argv) {\n    QGuiApplication app(argc, argv);\n    SceneGLWindow window;\n    QSurfaceFormat fmt;\n    fmt.setSamples(16);\n    window.setFormat(fmt);\n    CubeGLScene scene(&window);\n    window.setScene(&scene);\n    scene.setTexture(QImage(\":/texture.jpg\"));\n    window.resize(600, 600);\n    window.show();\n    return app.exec();\n} \n```", "```cpp\nQPropertyAnimation animation(&scene, \"angle\");\nanimation.setStartValue(0);\nanimation.setEndValue(359);\nanimation.setDuration(5000);\nanimation.setLoopCount(-1);\nanimation.start();\n```", "```cpp\nQOpenGLShader vertexShader(QOpenGLShader::Vertex);\nvertexShader.compileSourceCode(\n    \"uniform vec4 color;\\n\"\n    \"uniform highp mat4 matrix;\\n\"\n    \"void main(void) { gl_Position = gl_Vertex * matrix; }\"\n);\n```", "```cpp\nQOpenGLShader fragmentShader(QOpenGLShader::Fragment);\nfragmentShader.compileSourceCode(\n    \"uniform vec4 color;\\n\"\n    \"void main(void) { gl_FragColor = color; }\"\n);\n```", "```cpp\nQOpenGLShaderProgram program(context);\nprogram.addShader(&vertexShader);\nprogram.addShader(&fragmentShader);\nprogram.link(); \n```", "```cpp\nprogram.bind();\nQMatrix4x4 matrix = /* ... */;\nQColor color = Qt::red;\nprogram.setUniformValue(\"matrix\", matrix);\nprogram.setUniformValue(\"color\", color); \n```", "```cpp\nglBegin(GL_TRIANGLE_STRIP);\n//...\nglEnd(); \n```", "```cpp\nclass ShaderGLScene : public QObject, public AbstractGLScene {\n    Q_OBJECT\npublic:\n    ShaderGLScene(SceneGLWindow *window);\n    void initialize();\n    void paint();\nprotected:\n    void initializeObjectData();\nprivate:\n    struct ScenePoint {\n        QVector3D coords;\n        QVector3D normal;\n        ScenePoint(const QVector3D &c = QVector3D(),\n                   const QVector3D &n = QVector3D()) :\n            coords(c), normal(n)\n        {\n        }\n    };\n    QOpenGLShaderProgram m_shader;\n    QMatrix4x4 m_modelMatrix;\n    QMatrix4x4 m_viewMatrix;\n    QMatrix4x4 m_projectionMatrix;\n    QVector<ScenePoint> m_data;\n}; \n```", "```cpp\nuniform highp mat4 modelViewMatrix;\nuniform highp mat3 normalMatrix;\nuniform highp mat4 projectionMatrix;\nuniform highp mat4 mvpMatrix;\n\nattribute highp vec4 Vertex;\nattribute mediump vec3 Normal;\n\nvarying mediump vec3 N;\nvarying highp vec3 v;\n\nvoid main(void) {\n    N = normalize(normalMatrix * Normal);\n    v = vec3(modelViewMatrix * Vertex);\n    gl_Position = mvpMatrix * Vertex;\n} \n```", "```cpp\nstruct Material {\n    lowp vec3 ka;\n    lowp vec3 kd;\n    lowp vec3 ks;\n    lowp float shininess;\n};\n\nstruct Light {\n    lowp vec4 position;\n    lowp vec3 intensity;\n};\n\nuniform Material mat;\n\nuniform Light light;\n\nvarying mediump vec3 N;\nvarying highp vec3 v;\n\nvoid main(void) {\n    vec3 n = normalize(N);\n    vec3 L = normalize(light.position.xyz - v);\n    vec3 E = normalize(-v);\n    vec3 R = normalize(reflect(-L, n));\n\n    float LdotN = dot(L, n);\n    float diffuse = max(LdotN, 0.0);\n    vec3 spec = vec3(0, 0, 0);\n\n    if(LdotN > 0.0) {\n        float RdotE = max(dot(R, E), 0.0);\n        spec = light.intensity * pow(RdotE, mat.shininess);\n    }\n    vec3 color = light.intensity * (mat.ka + mat.kd * diffuse + mat.ks * spec);\n    gl_FragColor = vec4(color, 1.0);\n}\n```", "```cpp\nvoid initialize() {\n    AbstractGLScene::initialize();\n    glClearColor(0, 0, 0, 0);\n    //...\n}\n```", "```cpp\nm_shader.addShaderFromSourceFile(QOpenGLShader::Vertex, \":/phong.vert\");\nm_shader.addShaderFromSourceFile(QOpenGLShader::Fragment, \":/phong.frag\");\nm_shader.link();\n```", "```cpp\nm_shader.bind();\nm_shader.setAttributeArray(\"Vertex\", GL_FLOAT,\n                           &m_data[0].coords, 3, sizeof(ScenePoint));\nm_shader.enableAttributeArray(\"Vertex\");\n\nm_shader.setAttributeArray(\"Normal\", GL_FLOAT,\n                           &m_data[0].normal, 3, sizeof(ScenePoint));\nm_shader.enableAttributeArray(\"Normal\");\n\nm_shader.setUniformValue(\"mat.ka\", QVector3D(0.1, 0, 0.0));\nm_shader.setUniformValue(\"mat.kd\", QVector3D(0.7, 0.0, 0.0));\nm_shader.setUniformValue(\"mat.ks\", QVector3D(1.0, 1.0, 1.0));\nm_shader.setUniformValue(\"mat.shininess\", 128.0f);\n\nm_shader.setUniformValue(\"light.position\", QVector3D(2, 1, 1));\nm_shader.setUniformValue(\"light.intensity\", QVector3D(1, 1, 1));\n```", "```cpp\nvoid ShaderGLScene::paint() {\n    m_projectionMatrix.setToIdentity();\n    float aspectRatio = qreal(window()->width()) / window()->height();\n    m_projectionMatrix.perspective(90, aspectRatio, 0.5, 40);\n\n    m_viewMatrix.setToIdentity();\n    QVector3D eye(0, 0, 2);\n    QVector3D center(0, 0, 0);\n    QVector3D up(0, 1, 0);\n    m_viewMatrix.lookAt(eye, center, up);\n    //...\n}\n```", "```cpp\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\nglViewport(0, 0, window()->width(), window()->height());\nglEnable(GL_DEPTH_TEST);\nglEnable(GL_CULL_FACE);\nglCullFace(GL_BACK); \n```", "```cpp\nm_modelMatrix.setToIdentity();\nm_modelMatrix.rotate(45, 0, 1, 0);\nQMatrix4x4 modelViewMatrix = m_viewMatrix * m_modelMatrix;\npaintObject(modelViewMatrix);\n```", "```cpp\nvoid ShaderGLScene::paintObject(const QMatrix4x4& mvMatrix) {\n    m_shader.bind();\n    m_shader.setUniformValue(\"projectionMatrix\", m_projectionMatrix);\n    m_shader.setUniformValue(\"modelViewMatrix\", mvMatrix);\n    m_shader.setUniformValue(\"mvpMatrix\", m_projectionMatrix*mvMatrix);\n    m_shader.setUniformValue(\"normalMatrix\", mvMatrix.normalMatrix());\n    glDrawArrays(GL_TRIANGLES, 0, m_data.size());\n} \n```", "```cpp\nShaderGLScene::ShaderGLScene(SceneGLWindow *window) :\n    AbstractGLScene(window), m_vertexBuffer(QOpenGLBuffer::VertexBuffer)\n{ /* ... */ }\n```", "```cpp\nm_vertexBuffer.setUsagePattern(QOpenGLBuffer::StaticDraw);\n```", "```cpp\nm_vertexBuffer.create();\nm_vertexBuffer.bind();\n```", "```cpp\nm_vertexBuffer.allocate(m_data.constData(),\n                        m_data.count() * sizeof(ScenePoint));\n```", "```cpp\nScenePoint *buffer = static_cast<ScenePoint*>(\n    vbo.map(QOpenGLBuffer::WriteOnly));\nassert(buffer != nullptr);\nfor(int i = 0; i < vbo.size(); ++i) {\n    buffer[i] = ...;\n}\nvbo.unmap(); \n```", "```cpp\nvbo.write(0, m_data.constData(), m_data.size() * sizeof(ScenePoint));\n```", "```cpp\nvbo.bind();\nm_shader.setAttributeBuffer(\"Vertex\", GL_FLOAT,\n                            0, 3, sizeof(ScenePoint));\nm_shader.enableAttributeArray(\"Vertex\");\nm_shader.setAttributeBuffer(\"Normal\", GL_FLOAT,\n                            sizeof(QVector3D), 3, sizeof(ScenePoint));\nm_shader.enableAttributeArray(\"Normal\");\n```", "```cpp\nclass MyWindow : public QOpenGLWindow {\nprotected:\n    QOpenGLFunctions_4_5_Core *glFunctions45;\n    QOpenGLFunctions_3_3_Core *glFunctions33;\n    void initializeGL()\n    {\n        glFunctions33 = context()->versionFunctions<QOpenGLFunctions_3_3_Core>();\n        glFunctions45 = context()->versionFunctions<QOpenGLFunctions_4_5_Core>();\n    }\n    void paintGL() {\n        if (glFunctions45) {\n            // OpenGL 4.5 rendering\n            // glFunctions45->...\n        } else if (glFunctions33) {\n            // OpenGL 3.3 rendering\n            // glFunctions33->...\n        } else {\n            qFatal(\"unsupported OpenGL version\");\n        }\n    }\n};\n```", "```cpp\nMyWindow window;\nQSurfaceFormat format = window.format();\nformat.setVersion(4, 0);\nformat.setProfile(QSurfaceFormat::CoreProfile);\nwindow.setFormat(format);\nwindow.show();\n```", "```cpp\n#include <QGuiApplication>\n#include <vulkan/vulkan.h>\n#include <QVulkanInstance>\nint main(int argc, char *argv[]) {\n    QGuiApplication app(argc, argv);\n    QVulkanInstance vulkan;\n    return app.exec();\n}\n```", "```cpp\nQT += gui\nCONFIG += c++11\nDEFINES += QT_DEPRECATED_WARNINGS\nSOURCES += main.cpp\n```", "```cpp\nQVulkanWindowRenderer *MyWindow::createRenderer() {\n    return new MyRenderer(this);\n}\n```", "```cpp\nMyRenderer::MyRenderer(QVulkanWindow *window)\n{\n    m_window = window;\n}\nvoid MyRenderer::startNextFrame() {\n    m_window->frameReady();\n}\n```", "```cpp\nint main(int argc, char *argv[]) {\n    QGuiApplication app(argc, argv);\n    QVulkanInstance vulkan;\n    if (!vulkan.create()) {\n        qFatal(\"Failed to create Vulkan instance: %d\", vulkan.errorCode()); \n    }\n    MyWindow window;\n    window.resize(1024, 768);\n    window.setVulkanInstance(&vulkan);\n    window.show();\n    return app.exec();\n}\n```", "```cpp\nvoid MyRenderer::initResources()\n{\n    VkDevice device = m_window->device();\n    m_devFuncs = m_window->vulkanInstance()->deviceFunctions(device);\n    //...\n}\n```", "```cpp\nvoid MyRenderer::startNextFrame()\n{\n    m_hue += 0.005f;\n    if (m_hue > 1.0f) {\n        m_hue = 0.0f;\n    }\n    QColor color = QColor::fromHslF(m_hue, 1, 0.5);\n    //...\n}\n```", "```cpp\n  VkClearValue clearValues[2];\n  memset(clearValues, 0, sizeof(clearValues));\n  clearValues[0].color = {\n      static_cast<float>(color.redF()),\n      static_cast<float>(color.greenF()),\n      static_cast<float>(color.blueF()),\n      1.0f\n  };\n  clearValues[1].depthStencil = { 1.0f, 0 };\n```", "```cpp\nVkRenderPassBeginInfo info;\nmemset(&info, 0, sizeof(info));\ninfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;\ninfo.renderPass = m_window->defaultRenderPass();\ninfo.framebuffer = m_window->currentFramebuffer();\nconst QSize imageSize = m_window->swapChainImageSize();\ninfo.renderArea.extent.width = imageSize.width();\ninfo.renderArea.extent.height = imageSize.height();\ninfo.clearValueCount = 2;\ninfo.pClearValues = clearValues;\n```", "```cpp\nVkCommandBuffer commandBuffer = m_window->currentCommandBuffer();\nm_devFuncs->vkCmdBeginRenderPass(commandBuffer, &info,\n                                 VK_SUBPASS_CONTENTS_INLINE);\nm_devFuncs->vkCmdEndRenderPass(commandBuffer);\nm_window->frameReady();\nm_window->requestUpdate();\n```", "```cpp\nQLoggingCategory::setFilterRules(QStringLiteral(\"qt.vulkan=true\"));\n```", "```cpp\nvulkan.setLayers({ \"VK_LAYER_LUNARG_standard_validation\" });\n```", "```cpp\ninfo.renderArea.extent.width = -5; // invalid\n```", "```cpp\nvkDebug: CORE: 4: Cannot execute a render pass with renderArea not within the bound of the framebuffer. RenderArea: x 0, y 0, width -5, height 768\\. Framebuffer: width 1024, height 768.\n```", "```cpp\nQVulkanInstance vulkan;\nvulkan.setFlags(QVulkanInstance::NoDebugOutputRedirect);\n```", "```cpp\nQWidget widget;\nQVBoxLayout* layout = new QVBoxLayout(&widget);\nlayout->addWidget(new QLabel(\"Scene\"), 0);\nQWidget* container = QWidget::createWindowContainer(&window, &widget);\nlayout->addWidget(container, 1);\nwidget.resize(600, 600);\nwidget.show();\n```"]