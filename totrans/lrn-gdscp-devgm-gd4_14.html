<html><head></head><body>
		<div id="_idContainer313">
			<h1 class="chapter-number" id="_idParaDest-325"><a id="_idTextAnchor721"/>14</h1>
			<h1 id="_idParaDest-326"><a id="_idTextAnchor722"/>Advanced Programming Patterns</h1>
			<p>Although computer science as a scientific field is pretty new, being less than 80 years old, many smart people have studied it. This means that most programming problems have already been encountered in one way or another. These are problems such as how to connect parts of a program without them being hardwired or how to create and destroy thousands of objects, such as bullets for example, without slowing down <span class="No-Break">a game.</span></p>
			<p>These smart people, often called software architects, came up with smart <a id="_idIndexMarker815"/>solutions that solve these problems in an elegant manner. Then, they realized that they could generalize these solutions into a sort of recipe, a template that others could use too. This is what we call a programming pattern. In this chapter, we’ll learn what programming patterns are exactly and have a look at the three most used patterns in <span class="No-Break">game development.</span></p>
			<p>The bigger your vocabulary of programming patterns, the easier it will be for you to solve your own problems and communicate your ideas <span class="No-Break">to others.</span></p>
			<p>In this chapter, we will cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>The basics of <span class="No-Break">programming patterns</span></li>
				<li>The <span class="No-Break">Event Bus</span></li>
				<li><span class="No-Break">Object Pooling</span></li>
				<li><span class="No-Break">State Machines</span></li>
			</ul>
			<h1 id="_idParaDest-327"><a id="_idTextAnchor723"/>Technical requirements</h1>
			<p>As with every chapter, you can find the final code on the GitHub repository in the subfolder for this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter14"><span class="No-Break">https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter14</span></a><span class="No-Break">.</span></p>
			<p>You can find the code required for implementing Object Pooling in our game <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter14-objectpool"><span class="No-Break">https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter14-objectpool</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-328"><a id="_idTextAnchor724"/>What are programming patterns?</h1>
			<p>I’ll be honest – we are not the first<a id="_idIndexMarker816"/> people to create games, or to write software for that matter. But this is actually a good thing; it means that many others before us encountered the same problems that we might have too. They thought up solutions to these problems in one way or another, and we can now make use of these solutions in our own games <span class="No-Break">and software.</span></p>
			<p><strong class="bold">Programming patterns</strong>, or software design patterns, are descriptions or templates that tell us how we can solve certain problems while programming. They are not completely implemented solutions; they just give us directions on how we could tackle whatever we are trying to solve. A programming pattern tells us how we can organize our code for <span class="No-Break">different outcomes.</span></p>
			<p>To express these patterns, there are different parts<a id="_idIndexMarker817"/> that <span class="No-Break">are important:</span></p>
			<ul>
				<li><strong class="bold">The name</strong>: How the pattern <span class="No-Break">is called.</span></li>
				<li><strong class="bold">The problem</strong>: What the pattern is trying <span class="No-Break">to solve.</span></li>
				<li><strong class="bold">The solution</strong>: How the pattern <span class="No-Break">will work.</span></li>
			</ul>
			<p>Other than just providing a solution, programming patterns also give us a means to talk about our software. Communicating what we did can be hard when, as in software development, every problem can be tackled in a multitude of different ways. Design patterns give us a way of talking about the solution without going too deep into the <span class="No-Break">actual implementation.</span></p>
			<p>Lastly, if we structure our code according to one or multiple patterns, we know what to expect. We know how the code will react to new changes and communicate to other parts of a program. This helps us to understand how we can make changes, be it solving a bug, adding new functionality, or rewriting <span class="No-Break">old code.</span></p>
			<p class="callout-heading">Rewriting old code</p>
			<p class="callout">Sometimes, you will find<a id="_idIndexMarker818"/> that the way you solved a problem is not fast, extensible, or sufficient enough. At this point, you can choose to rewrite some code. We call this <span class="No-Break">refactoring code.</span></p>
			<p>Believe it or not, anything can be a pattern, and you could have been using an existing pattern, even if you didn’t <span class="No-Break">realize it.</span></p>
			<p>However, it is not as simple as picking any pattern and forcing it into our game’s code. We should carefully consider whether to use one pattern or another. When we use a certain pattern that is ill-fitting for the problem we are trying to solve and actually makes our software<a id="_idIndexMarker819"/> worse, we call that <span class="No-Break">an </span><span class="No-Break"><strong class="bold">anti-pattern</strong></span><span class="No-Break">.</span></p>
			<p>In the interest of not overextending this chapter, the code examples will function more as an introduction and demonstration of how a pattern can be used. We will not implement all the patterns in our game as this would require too much text for some. The real goal of this chapter<a id="_idIndexMarker820"/> is to make you aware of the most useful <span class="No-Break">programming patterns.</span></p>
			<p>Let’s get started with our first pattern – the <span class="No-Break">Event Bus.</span></p>
			<h1 id="_idParaDest-329"><a id="_idTextAnchor725"/>Exploring the Event Bus</h1>
			<p>The first programming pattern<a id="_idIndexMarker821"/> we’ll look at is the <strong class="bold">Event Bus</strong>. It will help us to decouple code, meaning that two pieces of code don’t need to rely on each other too much while still being able <span class="No-Break">to communicate.</span></p>
			<p>Let’s take a look at what problem the Event Bus pattern tries <span class="No-Break">to solve.</span></p>
			<h2 id="_idParaDest-330"><a id="_idTextAnchor726"/>The problem</h2>
			<p>If we decouple different classes<a id="_idIndexMarker822"/> and parts of our code, they are easier to reuse later on. We did this earlier, in <a href="B19358_09.xhtml#_idTextAnchor590"><span class="No-Break"><em class="italic">Chapter 9</em></span></a> for example, with the signals that we can connect provided by Godot Engine. The piece of code that publishes the signal does not care about who is listening or wants to receive <span class="No-Break">that signal.</span></p>
			<p>But signals only work very locally, and using them globally can turn out to be a challenge. The classic example is an achievement system. Achievements are little rewards that a player gets when accomplishing certain tasks within a game. These could even be linked to external achievement systems like the ones from Steam or PlayStation Network. The tasks necessary to unlock these achievements are often bound to very different systems within the game – “<em class="italic">defeat the end boss,</em>” “<em class="italic">jump 250 times,</em>” “<em class="italic">play backwards for 2 minutes,</em>” and so on. Because of this variation in different achievements, the achievement system needs to get information from many different parts of the code. However, we don’t want to access the achievement system directly from within the code of each system or vice versa, as this would create a hard dependency for the achievement system to be present at all times. On the Nintendo Switch, for example, there<a id="_idIndexMarker823"/> is no achievement system, so all of this achievement code would <span class="No-Break">be useless.</span></p>
			<p>Now that we know what kind of problem we are trying to solve, let’s dive into the solution that is the <span class="No-Break">Event Bus.</span></p>
			<h2 id="_idParaDest-331"><a id="_idTextAnchor727"/>The solution</h2>
			<p>This is where the Event Bus pattern<a id="_idIndexMarker824"/> comes in. It’s a class we autoload, where other pieces of code can subscribe to or publish events. The basic structure looks <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer307">
					<img alt="Figure 14.1 – The basic structure of how the Event Bus works" src="image/B19358_14_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – The basic structure of how the Event Bus works</p>
			<p>It is very similar to signals, but this time on a global scale. Let’s look at a very <span class="No-Break">simple example:</span></p>
			<pre class="source-code">
extends Node
var _observers: Dictionary = {}
func subscribe(event_name: String, callback: Callable):
   if not event_name in _observers:
      _observers[event_name] = []
   _observers[event_name].append(callback)
func publish(event_name: String):
   if not event_name in _observers:
      return
   for callable: Callable in _observers[event_name]:
      callable.call()</pre>			<p>Add this previous script<a id="_idIndexMarker825"/> to the project’s autoloads, as we did for the highscore manager in <a href="B19358_10.xhtml#_idTextAnchor632"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, so that we can access <span class="No-Break">it globally.</span></p>
			<p>Let’s assume a very simplistic example of a boss fight, where we have one node that has a script that looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
extends Node
func _ready():
   while randf() &lt; 0.99:
      print("You're still fighting the boss!")
   print("The boss dies x.x")
   <strong class="bold">EventBus.publish("killed_boss")</strong></pre>			<p>You can see that we just compare a random value until that value is bigger than 0.99, which should average around 100 tries. Ultimately, the boss battle is over, and we publish an event to the Event Bus that is <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">killed_boss</strong></span><span class="No-Break">.</span></p>
			<p>Now, we can create a little achievement system and subscribe to this event, to be notified when the boss battle <span class="No-Break">is over:</span></p>
			<pre class="source-code">
extends Node
func _ready():
   <strong class="bold">EventBus.subscribe("killed_boss", on_boss_killed)</strong>
func on_boss_killed():
   print("Achievement Unlocked: Kill the Boss")</pre>			<p>Add this script as an autoload, named <strong class="source-inline">AchievementSystem</strong>, and then you can run the project. In the console, you’ll see that it <span class="No-Break">works perfectly:</span></p>
			<pre class="source-code">
You're fighting the boss!
...
You're fighting the boss!
The boss dies x.x
Achievement Unlocked: Kill the Boss</pre>			<p>The signals, which are default in Godot, and the Event Bus patterns are both close cousins of the Observer pattern. The big difference between signals and the Event Bus is that with signals, you can only subscribe to one specific entity, such as when we subscribe to one enemy’s <strong class="source-inline">died</strong> signal to signify that the enemy died, whereas an Event Bus is global. It doesn’t matter what node or object threw the event; everyone who is subscribed to the event will get notified, such as when any node (it doesn’t matter which) throws the <strong class="source-inline">game_over</strong> event to signify that the game ended. The Observer pattern and all its different forms<a id="_idIndexMarker826"/> are <span class="No-Break">widely known.</span></p>
			<p class="callout-heading">Learn more</p>
			<p class="callout">Learn more about <a id="_idIndexMarker827"/>the Observer pattern <span class="No-Break">here: </span><a href="https://gameprogrammingpatterns.com/observer.html"><span class="No-Break">https://gameprogrammingpatterns.com/observer.html</span></a><span class="No-Break">.</span></p>
			<p>The Event Bus programming pattern is ideal for decoupling your code. Let’s now explore a pattern that has a completely different purpose, namely optimizing <span class="No-Break">load times.</span></p>
			<h1 id="_idParaDest-332"><a id="_idTextAnchor728"/>Understanding Object Pooling</h1>
			<p>The second programming pattern<a id="_idIndexMarker828"/> we’ll see is Object Pooling. The purpose of this pattern is to keep up the frame rate of our game while still being able to create and destroy many objects or nodes. Let’s take a deeper dive into what we are trying to solve – that is, <span class="No-Break">the problem.</span></p>
			<h2 id="_idParaDest-333"><a id="_idTextAnchor729"/>The problem</h2>
			<p>In some games, we want to be able to spawn<a id="_idIndexMarker829"/> and remove objects really quickly. In the little game that we have constructed over the course of the book, for example, we want to be able to spawn and remove projectiles and arrows fast and reliably. With the rates our arrows are being shot at now, this is not a big issue, but it could become one if we increased this rate, especially in multiplayer. Creating new nodes – for example, by using the <strong class="source-inline">instantiate()</strong> function we saw in <a href="B19358_10.xhtml#_idTextAnchor632"><span class="No-Break"><em class="italic">Chapter 10</em></span></a> and adding them to the scene tree – is pretty slow. The game needs to load the scene file from disk and then allocate new memory every time we create a new node. Then, when the node gets freed, the game has to free up that <span class="No-Break">memory again.</span></p>
			<p>To optimize this process, we can use an Object Pool, which we will discuss in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-334"><a id="_idTextAnchor730"/>The solution</h2>
			<p>Theses loading problems<a id="_idIndexMarker830"/> can be solved by the Object Pooling pattern. Object Pooling basically means that we keep a list, also called a pool, of already initialized<a id="_idIndexMarker831"/> nodes somewhere. For example, with a bunch of arrows, when we need an arrow, we can simple take one from this list. When it is not needed anymore, we return it to that list so that it can be reused <span class="No-Break">later on.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer308">
					<img alt="Figure 14.2 – Any class that wants an instance can ask the Object Pool" src="image/B19358_14_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – Any class that wants an instance can ask the Object Pool</p>
			<p>Because we do not actually delete<a id="_idIndexMarker832"/> or remove the arrow node from the scene tree, we will need to make sure, through code, that the node stops working in the background when it is supposed to be stored away in the Object Pool. When an object is in use, we say it is alive because it lives within the game. When it is in the Object Pool, it is dead because it is not in use anymore. When we want to return a live object to the pool, we say that it <span class="No-Break">gets killed.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer309">
					<img alt="Figure 14.3 – The Object Pool sets an instance as alive. When the instance is dead, it returns to the pool" src="image/B19358_14_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – The Object Pool sets an instance as alive. When the instance is dead, it returns to the pool</p>
			<p>Here is an example of what an Object Pool’s script could <span class="No-Break">look like:</span></p>
			<pre class="source-code">
class_name ObjectPool extends Object
var _pool: Array
func _init(scene: PackedScene, pool_size: int, root_node: Node):
   for _i in pool_size:
      var new_node: Node = scene.instantiate()
      _pool.append(new_node)
      new_node.died.connect(kill_node.bind(new_node))
      root_node.add_child(new_node)
func kill_node(node: Node):
   node.set_dead()
   _pool.append(node)
func get_dead_node() -&gt; Node:
   if _pool.is_empty():
      return null
   var node: Node = _pool.pop_back()
   node.set_alive()
   return node
func free_nodes():
     for node in _pool:
            node.queue_free()</pre>			<p>You can see that we keep an array, called <strong class="source-inline">_pool</strong>, which will contain all of our dead nodes. First, we create a number of objects within the <strong class="source-inline">_init()</strong> function of type <strong class="source-inline">scene</strong> and add these new objects as children to <strong class="source-inline">root_node</strong>, which we can pass to this <strong class="source-inline">_init()</strong> function. The number of objects we populate the pool with is defined <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">pool_size</strong></span><span class="No-Break">.</span></p>
			<p>In the <strong class="source-inline">_init()</strong> function, we also connect to the <strong class="source-inline">died</strong> signal of each node using the <strong class="source-inline">kill_node()</strong> function. This means that the node, when it dies, needs to emit the <strong class="source-inline">died</strong> signal. The <strong class="source-inline">kill_node()</strong> function, in turn, will call the <strong class="source-inline">set_dead()</strong> function on that node. This function should disable the node and will be different for each kind of node, so we need to implement that later on in the definition of the node script itself. After this, the node is returned to <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">_pool</strong></span><span class="No-Break">.</span></p>
			<p>You can also see that I called a function called <strong class="source-inline">bind()</strong> on the <strong class="source-inline">kill_node</strong> callable – <strong class="source-inline">kill_node.bind(new_node)</strong>. This binds arguments to <strong class="source-inline">Callable</strong>, which means that if the signal is emitted and this <strong class="source-inline">Callable</strong> gets called, the arguments we bind here are given to the <strong class="source-inline">kill_node()</strong> function. This way, we know what object is being killed in the <span class="No-Break"><strong class="source-inline">set_dead()</strong></span><span class="No-Break"> function.</span></p>
			<p>When we need an instance from the pool, we call the <strong class="source-inline">get_dead_node()</strong> function, which will first check whether there are still objects in the pool; if not, we return nothing. If there are still objects in the pool, we remove the first element from e <strong class="source-inline">_pool</strong>, set it as alive, and then <span class="No-Break">return it.</span></p>
			<p>Lastly, we implemented a <strong class="source-inline">free_nodes()</strong> function<a id="_idIndexMarker833"/> that frees all the nodes that are present in the pool. This way, we can free them all conveniently when we stop <span class="No-Break">the game.</span></p>
			<h2 id="_idParaDest-335"><a id="_idTextAnchor731"/>Implementing the Object Pool in our game</h2>
			<p>Let’s implement the Object Pool<a id="_idIndexMarker834"/> in our own game! The obvious nodes<a id="_idIndexMarker835"/> to pool from our Vampire Survivor like game are the projectile and the enemy. We’ll use a pool to deal with the projectiles here. You can always take a stab at making an Object Pool that deals with <span class="No-Break">the enemies:</span></p>
			<p>Create a script, <strong class="source-inline">object_pool.gd</strong>, that has the exact content of the script from the previous section. Save it under a new <span class="No-Break">folder, </span><span class="No-Break"><strong class="source-inline">parts/object_pool</strong></span><span class="No-Break">.</span></p>
			<p>Let’s prepare the <strong class="source-inline">projectile.gd</strong> script so that it can be in <span class="No-Break">a pool:</span></p>
			<ol>
				<li>At the top, add a new custom signal, <strong class="source-inline">died</strong>. This will be called when the projectile can go back into <span class="No-Break">the pool.</span><pre class="source-code">
signal died</pre></li>				<li>Then, add two<a id="_idIndexMarker836"/> functions, <strong class="source-inline">set_alive()</strong> and <strong class="source-inline">set_dead()</strong>, which we call <a id="_idIndexMarker837"/>from the <span class="No-Break">Object Pool:</span><pre class="source-code">
func set_alive():
   if multiplayer.is_server():
      set_physics_process(true)
      _enemy_detection_area.monitoring = true
   show()
func set_dead():
   set_physics_process(false)
   _enemy_detection_area.set_deferred("monitoring", false)
   hide()</pre><p class="list-inset">The <strong class="source-inline">set_alive</strong> function turns on the <strong class="source-inline">_physics_process</strong> and the collision detection for the projectile, but only if this code is run from the server. Then it shows the projectile, no matter if we are running from the server or not so that everyone can see it. The <strong class="source-inline">set_dead</strong> function undoes all these changes to make sure the projectile is unusable <span class="No-Break">while dead.</span></p></li>			</ol>
			<p class="callout-heading">Important note</p>
			<p class="callout">We use the <strong class="source-inline">set_deferred()</strong> function on the <strong class="source-inline">_enemy_detection_area</strong> to set <strong class="source-inline">monitoring</strong> to <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> because this change has to be incorporated by the physics engine and we need to wait until all physics calculations for that frame are executed. The <strong class="source-inline">set_deferred()</strong> function sets the value to our desired value at the end of the <span class="No-Break">current frame.</span></p>
			<ol>
				<li value="3">Now, replace the original <strong class="source-inline">_ready()</strong> function with the one in the next code snipper which makes sure new instances don’t start acting when they are created and put into the <span class="No-Break">scene tree:</span><pre class="source-code">
func _ready():
   set_dead()</pre></li>				<li>Lastly, replace<a id="_idIndexMarker838"/> the mentions of <strong class="source-inline">queue_free()</strong> with <strong class="source-inline">died.emit()</strong> because<a id="_idIndexMarker839"/> the Object Pool will manage how the node <span class="No-Break">gets created:</span><pre class="source-code">
func _physics_process(delta: float):
   if not is_instance_valid(target):
      <strong class="bold">died.emit()</strong>
      return
   # Rest of _physics_process
func _on_enemy_detection_area_body_entered(body: Node2D) -&gt; void:
   body.get_hit()
   <strong class="bold">died.emit()</strong></pre></li>				<li>Next, let’s change the <strong class="source-inline">main.gd</strong> script to have an Object Pool <span class="No-Break">of projectiles.</span><p class="list-inset">At the top, add a <strong class="source-inline">projectile_pool</strong> variable and preload the <span class="No-Break"><strong class="source-inline">projectile.tscn</strong></span><span class="No-Break"> scene:</span></p><pre class="source-code">
var projectile_pool: ObjectPool
var projectile_scene: PackedScene = preload("res://parts/projectile/projectile.tscn")</pre></li>				<li>Now, we only want to initialize this variable when we run from the server. The server will manage all the projectiles. Add the following line <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">_ready()</strong></span><span class="No-Break">:</span><pre class="source-code">
Func _ready():
   # ...
   if multiplayer.is_server():
      # Code for server setup
      <strong class="bold">projectile_pool = ObjectPool.new(projectile_scene, 50, self)</strong></pre></li>				<li>The Object Pool<a id="_idIndexMarker840"/> will not free itself when we close<a id="_idIndexMarker841"/> the game, so we will have to do that manually in the <strong class="source-inline">_exit_tree()</strong> function of the <span class="No-Break">main script:</span><pre class="source-code">
func _exit_tree():
   if projectile_pool:
      projectile_pool.free_nodes()
      projectile_pool.free()</pre></li>			</ol>
			<p class="callout-heading">Important note</p>
			<p class="callout">Nodes in the scene tree will be freed automatically when we close the game. But objects that are not inside of the tree, like our <strong class="source-inline">projectile_pool</strong> or nodes we take out of the scene tree, are not managed by the same process. So, we need to manage when to delete <span class="No-Break">them ourselves.</span></p>
			<ol>
				<li value="8">Lastly, we’ll need to update the <strong class="source-inline">player.gd</strong> script to access the Object Pool for a projectile and set its target and position. Replace the original way we created a new projectile with <span class="No-Break">this code:</span><pre class="source-code">
func _on_shoot_timer_timeout():
   # Shooting code to select a target enemy
   var new_projectile: Projectile = get_parent().projectile_pool.get_dead_node()
   if new_ projectile:
      new_projectile.target = closest_enemy
      new_projectile.position = global_position</pre></li>			</ol>
			<p>This is all we need<a id="_idIndexMarker842"/> to do to implement <a id="_idIndexMarker843"/>our Object Pool in our multiplayer game. When you look at the <strong class="bold">Remote Tree</strong> while running the game, you’ll<a id="_idIndexMarker844"/> see that 50 projectiles have been created at the start, ready to be launched by <span class="No-Break">the players.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer310">
					<img alt="Figure 14.4 – 50 projectiles are created, ready to be used" src="image/B19358_14_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4 – 50 projectiles are created, ready to be used</p>
			<p>That’s it for the Object Pool pattern. It is very useful to keep frame rates in check when you need lots of objects to spawn and disappear often. Let’s look at yet another completely different pattern in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-336"><a id="_idTextAnchor732"/>Working with State Machines</h1>
			<p>Games are massive pieces of code<a id="_idIndexMarker845"/> that can get quite complex. To lower the complexity of code, we can try to separate different pieces so that they only perform one action very well. That is exactly what we are going to do with a State Machine. Let’s first start with a better <span class="No-Break">problem statement.</span></p>
			<h2 id="_idParaDest-337"><a id="_idTextAnchor733"/>The problem</h2>
			<p>Agents, such as the player<a id="_idIndexMarker846"/> or enemies, often have to operate in very different scenarios. In a platformer game, such as <strong class="bold">Super Mario Bros</strong> for example, the character needs<a id="_idIndexMarker847"/> to be able to walk, run, jump, dive, wall slide, fly, and so on. This is a lot of different kinds of code. If we try to fit this into one big class for the player, we’ll end up with a jumble of code that is very hard to understand, debug, <span class="No-Break">or extend.</span></p>
			<p>Ultimately, we want our game’s code to be easily understood and maintained. That’s why we will learn about the State Machine in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor734"/>The solution</h2>
			<p>A great way to combat this complexity<a id="_idIndexMarker848"/> is by separating the behavior for each of these wanted behaviors (walking, jumping, etc.) into different files and classes. This is exactly what the State Machine pattern does. The State Machine swaps out part or the complete behavior of an object with a different behavior, depending on the state it <span class="No-Break">is in.</span></p>
			<p>Each of the behaviors we identified earlier (walking, jumping, etc.) is defined as a totally independent state that alters the behavior of the agent and is saved in a <span class="No-Break">separate file.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer311">
					<img alt="Figure 14.5 – An example of how states could connect with each other" src="image/B19358_14_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.5 – An example of how states could connect with each other</p>
			<p>The State Machine can only have one active state at one time. This rule makes sure that we don’t mix up behaviors <span class="No-Break">or code.</span></p>
			<p>Each of these states knows<a id="_idIndexMarker849"/> which other states it can transition to. This transition gets triggered from the code of that state by asking the State Machine directly <span class="No-Break">to transition.</span></p>
			<p>Now that we have a surface-level idea of what a State Machine can do, let’s quickly list all the things it should do. The State Machine should do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Have a list of all <span class="No-Break">possible states</span></li>
				<li>Designate one <span class="No-Break">active state</span></li>
				<li>Be able to transition from one state <span class="No-Break">to another</span></li>
				<li>Update the current active state and provide it with <span class="No-Break">direct input</span></li>
			</ul>
			<p>With that in mind, let’s take a look at the code for the actual State <span class="No-Break">Machine itself:</span></p>
			<pre class="source-code">
class_name StateMachine extends Node
@export var starting_state: String
var states: Dictionary
var current_state: State
func _ready():
   for child in get_children():
      states[child.name] = child
      child.state_machine = self
   if not starting_state.is_empty:
      transition_to(starting_state)
func transition(state_name: String):
   if current_state:
      current_state.exit()
   current_state = states[state_name]
   current_state.enter()
func _physics_process(delta: float):
   if not current_state: return
   current_state.process(delta)
func _input(event: InputEvent):
   if not current_state: return
   current_state.input(event)</pre>			<p>You can see that in the <strong class="source-inline">_ready()</strong> function, we scan <a id="_idIndexMarker850"/>all the children of the State Machine and add it to a dictionary of <strong class="source-inline">states</strong>. This dictionary will help us to quickly look up states when we need them in the <strong class="source-inline">transition()</strong> function. This also means that we will add each state as a child node to the State Machine itself, <span class="No-Break">like so:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer312">
					<img alt="Figure 14.6 – The State Machine with each state as a child node" src="image/B19358_14_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.6 – The State Machine with each state as a child node</p>
			<p>At the end of the <strong class="source-inline">_ready()</strong> function, we transition to <strong class="source-inline">starting_state</strong>, which is an export variable that we can use to set the initial state of the <span class="No-Break">State Machine.</span></p>
			<p>In the <strong class="source-inline">transition()</strong> function that is used to transition to a new state, we first check whether we have <strong class="source-inline">current_state</strong>; if we do, we’ll first have to call the <strong class="source-inline">exit()</strong> function on it to make sure it can clean itself up. After that, we use  <strong class="source-inline">state_name</strong>, which is provided as an argument to look up the next state, assign it as <strong class="source-inline">current_state</strong>, and call the <strong class="source-inline">enter()</strong> function <span class="No-Break">on it.</span></p>
			<p>The <strong class="source-inline">_physics_process()</strong> and <strong class="source-inline">_input()</strong> methods are used to directly feed into the <strong class="source-inline">process()</strong> and <strong class="source-inline">input()</strong> functions of <strong class="source-inline">current_state</strong>, if there is a <span class="No-Break">current state.</span></p>
			<p>Now, let’s have a look at the <strong class="source-inline">state</strong> <span class="No-Break">class itself:</span></p>
			<pre class="source-code">
class_name State extends Node
var _state_machine: StateMachine
func enter():
   pass
func exit():
   pass
func process(delta: float):
   pass
func input(event: InputEvent):
   pass</pre>			<p>The state class is a simple skeleton with functions that we have to implement when we inherit from it. This means that if we have a jump state, for example, we’ll need to make sure that the <strong class="source-inline">enter()</strong>, <strong class="source-inline">exit()</strong>, <strong class="source-inline">input()</strong> and <strong class="source-inline">process()</strong> functions all work as they should during the jumping behavior of <span class="No-Break">our character.</span></p>
			<p>If we want to go from one state to another, we can simply use <strong class="source-inline">_state_machine.transition()</strong> from within the state and provide the name of the state we want to <span class="No-Break">transition to.</span></p>
			<p>We can now create specialized<a id="_idIndexMarker851"/> states and connect them through code, by calling the <strong class="source-inline">transition()</strong> function on the <span class="No-Break"><strong class="source-inline">_state_machine</strong></span><span class="No-Break"> object.</span></p>
			<h2 id="_idParaDest-339"><a id="_idTextAnchor735"/>An example state</h2>
			<p>Let’s take a quick<a id="_idIndexMarker852"/> look at an example state, <strong class="source-inline">Walk</strong>, for the player. This is the state when the player moves <span class="No-Break">freely around:</span></p>
			<pre class="source-code">
extends State
var _player: Player = owner
@export var max_speed: float = 500.0
@export var acceleration: float = 2500.0
@export var deceleration: float = 1500.0
func process(delta: float):
   var input_direction: Vector2 = Input.get_vector("move_left", "move_right", "move_up", "move_down")
   if input_direction != Vector2.ZERO:
   _player.velocity = _player.velocity.move_toward(input_direction * max_speed, acceleration * delta)
   else:
      _player.velocity = _player.velocity.move_toward(Vector2.ZERO, deceleration * delta)
   _player.move_and_slide()
func input(event: InputEvent):
   if event.is_action_pressed("jump"):
      _state_machine.transition("Jump")</pre>			<p>You can see we extend the <strong class="source-inline">State</strong> script<a id="_idIndexMarker853"/> from earlier. Then, we implement the <strong class="source-inline">process()</strong> function to do our movement calculations, which are specific to walking around, and the <strong class="source-inline">input()</strong> function to detect when we want to transition from this state to the <span class="No-Break"><strong class="source-inline">Jump</strong></span><span class="No-Break"> state.</span></p>
			<p>We don’t need to override every function from the <strong class="source-inline">State</strong> script, just the ones that we need, which in this case are the <strong class="source-inline">process()</strong> and <span class="No-Break"><strong class="source-inline">input()</strong></span><span class="No-Break"> functions.</span></p>
			<p>State Machines, in one way or another, are used in almost every game you ever played. It is a very important concept to understand. They abstract complex behavior into separate classes that are easy<a id="_idIndexMarker854"/> to understand <span class="No-Break">and maintain.</span></p>
			<p>Let’s conclude the chapter with some <span class="No-Break">additional exercises.</span></p>
			<h1 id="_idParaDest-340"><a id="_idTextAnchor736"/>Additional exercises – Sharpening the axe</h1>
			<ol>
				<li>The implementation of our Event Bus makes it possible to subscribe to an event, but not to unsubscribe when the receiver doesn’t want to be subscribed anymore. Implement an <strong class="source-inline">unsubscribe()</strong> function that unsubscribes a <strong class="source-inline">Callable</strong> from <span class="No-Break">an event:</span><pre class="source-code">
func unsubscribe(event_name: String, callback: Callable):
   # Your code</pre></li>				<li>The Object Pool we have implemented returns nothing when we try to call <strong class="source-inline">get_dead_node()</strong> while the pool is empty. A smarter way of dealing with this would be to create a new object, basically extending the Object Pool on the fly. Create a new function, <strong class="source-inline">get_dead_node_or_create_new()</strong>, in such a way that when the pool is empty, it creates a new object that is correctly connected and returned to the pool when <span class="No-Break">it dies.</span></li>
			</ol>
			<h1 id="_idParaDest-341"><a id="_idTextAnchor737"/>Summary</h1>
			<p>After learning how to program and make a game, we finally took a step back and learned about higher-level patterns that help us structure our project and code nicely. First, we learned about what programming patterns are in general. Then, we learned about the Event Bus, Object Pool, and State Machine patterns that can help us in different ways. These three are some of the widely used patterns in gaming and are applied outside of game <span class="No-Break">development too.</span></p>
			<p>From here, you can start to investigate more niche programming patterns, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Components, also known as </strong><span class="No-Break"><strong class="bold">Composition</strong></span><span class="No-Break">: </span><a href="https://gameprogrammingpatterns.com/component.html"><span class="No-Break">https://gameprogrammingpatterns.com/component.html</span></a></li>
				<li><span class="No-Break"><strong class="bold">Commands</strong></span><span class="No-Break">: </span><a href="https://gameprogrammingpatterns.com/command.html"><span class="No-Break">https://gameprogrammingpatterns.com/command.html</span></a></li>
				<li><strong class="bold">Service </strong><span class="No-Break"><strong class="bold">Locators</strong></span><span class="No-Break">: </span><a href="https://gameprogrammingpatterns.com/service-locator.html"><span class="No-Break">https://gameprogrammingpatterns.com/service-locator.html</span></a></li>
			</ul>
			<p>In the next chapter, we’ll look at the filesystem and learn how to save the state of our game so that our players can start<a id="_idTextAnchor738"/> a game from where they <span class="No-Break">left off.</span></p>
			<h1 id="_idParaDest-342"><a id="_idTextAnchor739"/>Quiz time</h1>
			<ul>
				<li>Programming patterns are standardized ways of solving problems in a program or game. What is the advantage of <span class="No-Break">knowing them?</span></li>
				<li>Any piece of code can be considered as a pattern. But when we call something an anti-pattern, does this mean that it works in <span class="No-Break">our favor?</span></li>
				<li>The Signals and Event Bus patterns are very similar because, in both, we subscribe to events, but what is their <span class="No-Break">fundamental difference?</span></li>
				<li>Why would we use an Object Pool pattern in <span class="No-Break">our game?</span></li>
				<li>What is the line of code with which we can transition from one state to another using the State <span class="No-Break">Machine pattern?</span></li>
			</ul>
		</div>
	</body></html>