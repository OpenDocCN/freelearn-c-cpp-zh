<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-325"><a id="_idTextAnchor721"/>14</h1>
			<h1 id="_idParaDest-326"><a id="_idTextAnchor722"/>Advanced Programming Patterns</h1>
			<p>Although computer science as a scientific field is pretty new, being less than 80 years old, many smart people have studied it. This means that most programming problems have already been encountered in one way or another. These are problems such as how to connect parts of a program without them being hardwired or how to create and destroy thousands of objects, such as bullets for example, without slowing down a game.</p>
			<p>These smart people, often called software architects, came up with smart <a id="_idIndexMarker815"/>solutions that solve these problems in an elegant manner. Then, they realized that they could generalize these solutions into a sort of recipe, a template that others could use too. This is what we call a programming pattern. In this chapter, we’ll learn what programming patterns are exactly and have a look at the three most used patterns in game development.</p>
			<p>The bigger your vocabulary of programming patterns, the easier it will be for you to solve your own problems and communicate your ideas to others.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li>The basics of programming patterns</li>
				<li>The Event Bus</li>
				<li>Object Pooling</li>
				<li>State Machines</li>
			</ul>
			<h1 id="_idParaDest-327"><a id="_idTextAnchor723"/>Technical requirements</h1>
			<p>As with every chapter, you can find the final code on the GitHub repository in the subfolder for this chapter: <a href="https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter14">https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter14</a>.</p>
			<p>You can find the code required for implementing Object Pooling in our game here: <a href="https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter14-objectpool">https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter14-objectpool</a>.</p>
			<h1 id="_idParaDest-328"><a id="_idTextAnchor724"/>What are programming patterns?</h1>
			<p>I’ll be honest – we are not the first<a id="_idIndexMarker816"/> people to create games, or to write software for that matter. But this is actually a good thing; it means that many others before us encountered the same problems that we might have too. They thought up solutions to these problems in one way or another, and we can now make use of these solutions in our own games and software.</p>
			<p><strong class="bold">Programming patterns</strong>, or software design patterns, are descriptions or templates that tell us how we can solve certain problems while programming. They are not completely implemented solutions; they just give us directions on how we could tackle whatever we are trying to solve. A programming pattern tells us how we can organize our code for different outcomes.</p>
			<p>To express these patterns, there are different parts<a id="_idIndexMarker817"/> that are important:</p>
			<ul>
				<li><strong class="bold">The name</strong>: How the pattern is called.</li>
				<li><strong class="bold">The problem</strong>: What the pattern is trying to solve.</li>
				<li><strong class="bold">The solution</strong>: How the pattern will work.</li>
			</ul>
			<p>Other than just providing a solution, programming patterns also give us a means to talk about our software. Communicating what we did can be hard when, as in software development, every problem can be tackled in a multitude of different ways. Design patterns give us a way of talking about the solution without going too deep into the actual implementation.</p>
			<p>Lastly, if we structure our code according to one or multiple patterns, we know what to expect. We know how the code will react to new changes and communicate to other parts of a program. This helps us to understand how we can make changes, be it solving a bug, adding new functionality, or rewriting old code.</p>
			<p class="callout-heading">Rewriting old code</p>
			<p class="callout">Sometimes, you will find<a id="_idIndexMarker818"/> that the way you solved a problem is not fast, extensible, or sufficient enough. At this point, you can choose to rewrite some code. We call this refactoring code.</p>
			<p>Believe it or not, anything can be a pattern, and you could have been using an existing pattern, even if you didn’t realize it.</p>
			<p>However, it is not as simple as picking any pattern and forcing it into our game’s code. We should carefully consider whether to use one pattern or another. When we use a certain pattern that is ill-fitting for the problem we are trying to solve and actually makes our software<a id="_idIndexMarker819"/> worse, we call that an <strong class="bold">anti-pattern</strong>.</p>
			<p>In the interest of not overextending this chapter, the code examples will function more as an introduction and demonstration of how a pattern can be used. We will not implement all the patterns in our game as this would require too much text for some. The real goal of this chapter<a id="_idIndexMarker820"/> is to make you aware of the most useful programming patterns.</p>
			<p>Let’s get started with our first pattern – the Event Bus.</p>
			<h1 id="_idParaDest-329"><a id="_idTextAnchor725"/>Exploring the Event Bus</h1>
			<p>The first programming pattern<a id="_idIndexMarker821"/> we’ll look at is the <strong class="bold">Event Bus</strong>. It will help us to decouple code, meaning that two pieces of code don’t need to rely on each other too much while still being able to communicate.</p>
			<p>Let’s take a look at what problem the Event Bus pattern tries to solve.</p>
			<h2 id="_idParaDest-330"><a id="_idTextAnchor726"/>The problem</h2>
			<p>If we decouple different classes<a id="_idIndexMarker822"/> and parts of our code, they are easier to reuse later on. We did this earlier, in <a href="B19358_09.xhtml#_idTextAnchor590"><em class="italic">Chapter 9</em></a> for example, with the signals that we can connect provided by Godot Engine. The piece of code that publishes the signal does not care about who is listening or wants to receive that signal.</p>
			<p>But signals only work very locally, and using them globally can turn out to be a challenge. The classic example is an achievement system. Achievements are little rewards that a player gets when accomplishing certain tasks within a game. These could even be linked to external achievement systems like the ones from Steam or PlayStation Network. The tasks necessary to unlock these achievements are often bound to very different systems within the game – “<em class="italic">defeat the end boss,</em>” “<em class="italic">jump 250 times,</em>” “<em class="italic">play backwards for 2 minutes,</em>” and so on. Because of this variation in different achievements, the achievement system needs to get information from many different parts of the code. However, we don’t want to access the achievement system directly from within the code of each system or vice versa, as this would create a hard dependency for the achievement system to be present at all times. On the Nintendo Switch, for example, there<a id="_idIndexMarker823"/> is no achievement system, so all of this achievement code would be useless.</p>
			<p>Now that we know what kind of problem we are trying to solve, let’s dive into the solution that is the Event Bus.</p>
			<h2 id="_idParaDest-331"><a id="_idTextAnchor727"/>The solution</h2>
			<p>This is where the Event Bus pattern<a id="_idIndexMarker824"/> comes in. It’s a class we autoload, where other pieces of code can subscribe to or publish events. The basic structure looks like this:</p>
			<div><div><img alt="Figure 14.1 – The basic structure of how the Event Bus works" src="img/B19358_14_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – The basic structure of how the Event Bus works</p>
			<p>It is very similar to signals, but this time on a global scale. Let’s look at a very simple example:</p>
			<pre class="source-code">
extends Node
var _observers: Dictionary = {}
func subscribe(event_name: String, callback: Callable):
   if not event_name in _observers:
      _observers[event_name] = []
   _observers[event_name].append(callback)
func publish(event_name: String):
   if not event_name in _observers:
      return
   for callable: Callable in _observers[event_name]:
      callable.call()</pre>			<p>Add this previous script<a id="_idIndexMarker825"/> to the project’s autoloads, as we did for the highscore manager in <a href="B19358_10.xhtml#_idTextAnchor632"><em class="italic">Chapter 10</em></a>, so that we can access it globally.</p>
			<p>Let’s assume a very simplistic example of a boss fight, where we have one node that has a script that looks like this:</p>
			<pre class="source-code">
extends Node
func _ready():
   while randf() &lt; 0.99:
      print("You're still fighting the boss!")
   print("The boss dies x.x")
   <code>killed_boss</code>.</p>
			<p>Now, we can create a little achievement system and subscribe to this event, to be notified when the boss battle is over:</p>
			<pre class="source-code">
extends Node
func _ready():
   <strong class="bold">EventBus.subscribe("killed_boss", on_boss_killed)</strong>
func on_boss_killed():
   print("Achievement Unlocked: Kill the Boss")</pre>			<p>Add this script as an autoload, named <code>AchievementSystem</code>, and then you can run the project. In the console, you’ll see that it works perfectly:</p>
			<pre class="source-code">
You're fighting the boss!
...
You're fighting the boss!
The boss dies x.x
Achievement Unlocked: Kill the Boss</pre>			<p>The signals, which are default in Godot, and the Event Bus patterns are both close cousins of the Observer pattern. The big difference between signals and the Event Bus is that with signals, you can only subscribe to one specific entity, such as when we subscribe to one enemy’s <code>died</code> signal to signify that the enemy died, whereas an Event Bus is global. It doesn’t matter what node or object threw the event; everyone who is subscribed to the event will get notified, such as when any node (it doesn’t matter which) throws the <code>game_over</code> event to signify that the game ended. The Observer pattern and all its different forms<a id="_idIndexMarker826"/> are widely known.</p>
			<p class="callout-heading">Learn more</p>
			<p class="callout">Learn more about <a id="_idIndexMarker827"/>the Observer pattern here: <a href="https://gameprogrammingpatterns.com/observer.html">https://gameprogrammingpatterns.com/observer.html</a>.</p>
			<p>The Event Bus programming pattern is ideal for decoupling your code. Let’s now explore a pattern that has a completely different purpose, namely optimizing load times.</p>
			<h1 id="_idParaDest-332"><a id="_idTextAnchor728"/>Understanding Object Pooling</h1>
			<p>The second programming pattern<a id="_idIndexMarker828"/> we’ll see is Object Pooling. The purpose of this pattern is to keep up the frame rate of our game while still being able to create and destroy many objects or nodes. Let’s take a deeper dive into what we are trying to solve – that is, the problem.</p>
			<h2 id="_idParaDest-333"><a id="_idTextAnchor729"/>The problem</h2>
			<p>In some games, we want to be able to spawn<a id="_idIndexMarker829"/> and remove objects really quickly. In the little game that we have constructed over the course of the book, for example, we want to be able to spawn and remove projectiles and arrows fast and reliably. With the rates our arrows are being shot at now, this is not a big issue, but it could become one if we increased this rate, especially in multiplayer. Creating new nodes – for example, by using the <code>instantiate()</code> function we saw in <a href="B19358_10.xhtml#_idTextAnchor632"><em class="italic">Chapter 10</em></a> and adding them to the scene tree – is pretty slow. The game needs to load the scene file from disk and then allocate new memory every time we create a new node. Then, when the node gets freed, the game has to free up that memory again.</p>
			<p>To optimize this process, we can use an Object Pool, which we will discuss in the next section.</p>
			<h2 id="_idParaDest-334"><a id="_idTextAnchor730"/>The solution</h2>
			<p>Theses loading problems<a id="_idIndexMarker830"/> can be solved by the Object Pooling pattern. Object Pooling basically means that we keep a list, also called a pool, of already initialized<a id="_idIndexMarker831"/> nodes somewhere. For example, with a bunch of arrows, when we need an arrow, we can simple take one from this list. When it is not needed anymore, we return it to that list so that it can be reused later on.</p>
			<div><div><img alt="Figure 14.2 – Any class that wants an instance can ask the Object Pool" src="img/B19358_14_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – Any class that wants an instance can ask the Object Pool</p>
			<p>Because we do not actually delete<a id="_idIndexMarker832"/> or remove the arrow node from the scene tree, we will need to make sure, through code, that the node stops working in the background when it is supposed to be stored away in the Object Pool. When an object is in use, we say it is alive because it lives within the game. When it is in the Object Pool, it is dead because it is not in use anymore. When we want to return a live object to the pool, we say that it gets killed.</p>
			<div><div><img alt="Figure 14.3 – The Object Pool sets an instance as alive. When the instance is dead, it returns to the pool" src="img/B19358_14_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – The Object Pool sets an instance as alive. When the instance is dead, it returns to the pool</p>
			<p>Here is an example of what an Object Pool’s script could look like:</p>
			<pre class="source-code">
class_name ObjectPool extends Object
var _pool: Array
func _init(scene: PackedScene, pool_size: int, root_node: Node):
   for _i in pool_size:
      var new_node: Node = scene.instantiate()
      _pool.append(new_node)
      new_node.died.connect(kill_node.bind(new_node))
      root_node.add_child(new_node)
func kill_node(node: Node):
   node.set_dead()
   _pool.append(node)
func get_dead_node() -&gt; Node:
   if _pool.is_empty():
      return null
   var node: Node = _pool.pop_back()
   node.set_alive()
   return node
func free_nodes():
     for node in _pool:
            node.queue_free()</pre>			<p>You can see that we keep an array, called <code>_pool</code>, which will contain all of our dead nodes. First, we create a number of objects within the <code>_init()</code> function of type <code>scene</code> and add these new objects as children to <code>root_node</code>, which we can pass to this <code>_init()</code> function. The number of objects we populate the pool with is defined by <code>pool_size</code>.</p>
			<p>In the <code>_init()</code> function, we also connect to the <code>died</code> signal of each node using the <code>kill_node()</code> function. This means that the node, when it dies, needs to emit the <code>died</code> signal. The <code>kill_node()</code> function, in turn, will call the <code>set_dead()</code> function on that node. This function should disable the node and will be different for each kind of node, so we need to implement that later on in the definition of the node script itself. After this, the node is returned to the <code>_pool</code>.</p>
			<p>You can also see that I called a function called <code>bind()</code> on the <code>kill_node</code> callable – <code>kill_node.bind(new_node)</code>. This binds arguments to <code>Callable</code>, which means that if the signal is emitted and this <code>Callable</code> gets called, the arguments we bind here are given to the <code>kill_node()</code> function. This way, we know what object is being killed in the <code>set_dead()</code> function.</p>
			<p>When we need an instance from the pool, we call the <code>get_dead_node()</code> function, which will first check whether there are still objects in the pool; if not, we return nothing. If there are still objects in the pool, we remove the first element from e <code>_pool</code>, set it as alive, and then return it.</p>
			<p>Lastly, we implemented a <code>free_nodes()</code> function<a id="_idIndexMarker833"/> that frees all the nodes that are present in the pool. This way, we can free them all conveniently when we stop the game.</p>
			<h2 id="_idParaDest-335"><a id="_idTextAnchor731"/>Implementing the Object Pool in our game</h2>
			<p>Let’s implement the Object Pool<a id="_idIndexMarker834"/> in our own game! The obvious nodes<a id="_idIndexMarker835"/> to pool from our Vampire Survivor like game are the projectile and the enemy. We’ll use a pool to deal with the projectiles here. You can always take a stab at making an Object Pool that deals with the enemies:</p>
			<p>Create a script, <code>object_pool.gd</code>, that has the exact content of the script from the previous section. Save it under a new folder, <code>parts/object_pool</code>.</p>
			<p>Let’s prepare the <code>projectile.gd</code> script so that it can be in a pool:</p>
			<ol>
				<li>At the top, add a new custom signal, <code>died</code>. This will be called when the projectile can go back into the pool.<pre class="source-code">
signal died</pre></li>				<li>Then, add two<a id="_idIndexMarker836"/> functions, <code>set_alive()</code> and <code>set_dead()</code>, which we call <a id="_idIndexMarker837"/>from the Object Pool:<pre class="source-code">
func set_alive():
   if multiplayer.is_server():
      set_physics_process(true)
      _enemy_detection_area.monitoring = true
   show()
func set_dead():
   set_physics_process(false)
   _enemy_detection_area.set_deferred("monitoring", false)
   hide()</pre><p class="list-inset">The <code>set_alive</code> function turns on the <code>_physics_process</code> and the collision detection for the projectile, but only if this code is run from the server. Then it shows the projectile, no matter if we are running from the server or not so that everyone can see it. The <code>set_dead</code> function undoes all these changes to make sure the projectile is unusable while dead.</p></li>			</ol>
			<p class="callout-heading">Important note</p>
			<p class="callout">We use the <code>set_deferred()</code> function on the <code>_enemy_detection_area</code> to set <code>monitoring</code> to <code>true</code> or <code>false</code> because this change has to be incorporated by the physics engine and we need to wait until all physics calculations for that frame are executed. The <code>set_deferred()</code> function sets the value to our desired value at the end of the current frame.</p>
			<ol>
				<li value="3">Now, replace the original <code>_ready()</code> function with the one in the next code snipper which makes sure new instances don’t start acting when they are created and put into the scene tree:<pre class="source-code">
func _ready():
   set_dead()</pre></li>				<li>Lastly, replace<a id="_idIndexMarker838"/> the mentions of <code>queue_free()</code> with <code>died.emit()</code> because<a id="_idIndexMarker839"/> the Object Pool will manage how the node gets created:<pre class="source-code">
func _physics_process(delta: float):
   if not is_instance_valid(target):
      <strong class="bold">died.emit()</strong>
      return
   # Rest of _physics_process
func _on_enemy_detection_area_body_entered(body: Node2D) -&gt; void:
   body.get_hit()
   <code>main.gd</code> script to have an Object Pool of projectiles.<p class="list-inset">At the top, add a <code>projectile_pool</code> variable and preload the <code>projectile.tscn</code> scene:</p><pre class="source-code">
var projectile_pool: ObjectPool
var projectile_scene: PackedScene = preload("res://parts/projectile/projectile.tscn")</pre></li>				<li>Now, we only want to initialize this variable when we run from the server. The server will manage all the projectiles. Add the following line to <code>_ready()</code>:<pre class="source-code">
Func _ready():
   # ...
   if multiplayer.is_server():
      # Code for server setup
      <code>_exit_tree()</code> function of the main script:<pre class="source-code">
func _exit_tree():
   if projectile_pool:
      projectile_pool.free_nodes()
      projectile_pool.free()</pre></li>			</ol>
			<p class="callout-heading">Important note</p>
			<p class="callout">Nodes in the scene tree will be freed automatically when we close the game. But objects that are not inside of the tree, like our <code>projectile_pool</code> or nodes we take out of the scene tree, are not managed by the same process. So, we need to manage when to delete them ourselves.</p>
			<ol>
				<li value="8">Lastly, we’ll need to update the <code>player.gd</code> script to access the Object Pool for a projectile and set its target and position. Replace the original way we created a new projectile with this code:<pre class="source-code">
func _on_shoot_timer_timeout():
   # Shooting code to select a target enemy
   var new_projectile: Projectile = get_parent().projectile_pool.get_dead_node()
   if new_ projectile:
      new_projectile.target = closest_enemy
      new_projectile.position = global_position</pre></li>			</ol>
			<p>This is all we need<a id="_idIndexMarker842"/> to do to implement <a id="_idIndexMarker843"/>our Object Pool in our multiplayer game. When you look at the <strong class="bold">Remote Tree</strong> while running the game, you’ll<a id="_idIndexMarker844"/> see that 50 projectiles have been created at the start, ready to be launched by the players.</p>
			<div><div><img alt="Figure 14.4 – 50 projectiles are created, ready to be used" src="img/B19358_14_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4 – 50 projectiles are created, ready to be used</p>
			<p>That’s it for the Object Pool pattern. It is very useful to keep frame rates in check when you need lots of objects to spawn and disappear often. Let’s look at yet another completely different pattern in the next section.</p>
			<h1 id="_idParaDest-336"><a id="_idTextAnchor732"/>Working with State Machines</h1>
			<p>Games are massive pieces of code<a id="_idIndexMarker845"/> that can get quite complex. To lower the complexity of code, we can try to separate different pieces so that they only perform one action very well. That is exactly what we are going to do with a State Machine. Let’s first start with a better problem statement.</p>
			<h2 id="_idParaDest-337"><a id="_idTextAnchor733"/>The problem</h2>
			<p>Agents, such as the player<a id="_idIndexMarker846"/> or enemies, often have to operate in very different scenarios. In a platformer game, such as <strong class="bold">Super Mario Bros</strong> for example, the character needs<a id="_idIndexMarker847"/> to be able to walk, run, jump, dive, wall slide, fly, and so on. This is a lot of different kinds of code. If we try to fit this into one big class for the player, we’ll end up with a jumble of code that is very hard to understand, debug, or extend.</p>
			<p>Ultimately, we want our game’s code to be easily understood and maintained. That’s why we will learn about the State Machine in the next section.</p>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor734"/>The solution</h2>
			<p>A great way to combat this complexity<a id="_idIndexMarker848"/> is by separating the behavior for each of these wanted behaviors (walking, jumping, etc.) into different files and classes. This is exactly what the State Machine pattern does. The State Machine swaps out part or the complete behavior of an object with a different behavior, depending on the state it is in.</p>
			<p>Each of the behaviors we identified earlier (walking, jumping, etc.) is defined as a totally independent state that alters the behavior of the agent and is saved in a separate file.</p>
			<div><div><img alt="Figure 14.5 – An example of how states could connect with each other" src="img/B19358_14_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.5 – An example of how states could connect with each other</p>
			<p>The State Machine can only have one active state at one time. This rule makes sure that we don’t mix up behaviors or code.</p>
			<p>Each of these states knows<a id="_idIndexMarker849"/> which other states it can transition to. This transition gets triggered from the code of that state by asking the State Machine directly to transition.</p>
			<p>Now that we have a surface-level idea of what a State Machine can do, let’s quickly list all the things it should do. The State Machine should do the following:</p>
			<ul>
				<li>Have a list of all possible states</li>
				<li>Designate one active state</li>
				<li>Be able to transition from one state to another</li>
				<li>Update the current active state and provide it with direct input</li>
			</ul>
			<p>With that in mind, let’s take a look at the code for the actual State Machine itself:</p>
			<pre class="source-code">
class_name StateMachine extends Node
@export var starting_state: String
var states: Dictionary
var current_state: State
func _ready():
   for child in get_children():
      states[child.name] = child
      child.state_machine = self
   if not starting_state.is_empty:
      transition_to(starting_state)
func transition(state_name: String):
   if current_state:
      current_state.exit()
   current_state = states[state_name]
   current_state.enter()
func _physics_process(delta: float):
   if not current_state: return
   current_state.process(delta)
func _input(event: InputEvent):
   if not current_state: return
   current_state.input(event)</pre>			<p>You can see that in the <code>_ready()</code> function, we scan <a id="_idIndexMarker850"/>all the children of the State Machine and add it to a dictionary of <code>states</code>. This dictionary will help us to quickly look up states when we need them in the <code>transition()</code> function. This also means that we will add each state as a child node to the State Machine itself, like so:</p>
			<div><div><img alt="Figure 14.6 – The State Machine with each state as a child node" src="img/B19358_14_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.6 – The State Machine with each state as a child node</p>
			<p>At the end of the <code>_ready()</code> function, we transition to <code>starting_state</code>, which is an export variable that we can use to set the initial state of the State Machine.</p>
			<p>In the <code>transition()</code> function that is used to transition to a new state, we first check whether we have <code>current_state</code>; if we do, we’ll first have to call the <code>exit()</code> function on it to make sure it can clean itself up. After that, we use  <code>state_name</code>, which is provided as an argument to look up the next state, assign it as <code>current_state</code>, and call the <code>enter()</code> function on it.</p>
			<p>The <code>_physics_process()</code> and <code>_input()</code> methods are used to directly feed into the <code>process()</code> and <code>input()</code> functions of <code>current_state</code>, if there is a current state.</p>
			<p>Now, let’s have a look at the <code>state</code> class itself:</p>
			<pre class="source-code">
class_name State extends Node
var _state_machine: StateMachine
func enter():
   pass
func exit():
   pass
func process(delta: float):
   pass
func input(event: InputEvent):
   pass</pre>			<p>The state class is a simple skeleton with functions that we have to implement when we inherit from it. This means that if we have a jump state, for example, we’ll need to make sure that the <code>enter()</code>, <code>exit()</code>, <code>input()</code> and <code>process()</code> functions all work as they should during the jumping behavior of our character.</p>
			<p>If we want to go from one state to another, we can simply use <code>_state_machine.transition()</code> from within the state and provide the name of the state we want to transition to.</p>
			<p>We can now create specialized<a id="_idIndexMarker851"/> states and connect them through code, by calling the <code>transition()</code> function on the <code>_state_machine</code> object.</p>
			<h2 id="_idParaDest-339"><a id="_idTextAnchor735"/>An example state</h2>
			<p>Let’s take a quick<a id="_idIndexMarker852"/> look at an example state, <code>Walk</code>, for the player. This is the state when the player moves freely around:</p>
			<pre class="source-code">
extends State
var _player: Player = owner
@export var max_speed: float = 500.0
@export var acceleration: float = 2500.0
@export var deceleration: float = 1500.0
func process(delta: float):
   var input_direction: Vector2 = Input.get_vector("move_left", "move_right", "move_up", "move_down")
   if input_direction != Vector2.ZERO:
   _player.velocity = _player.velocity.move_toward(input_direction * max_speed, acceleration * delta)
   else:
      _player.velocity = _player.velocity.move_toward(Vector2.ZERO, deceleration * delta)
   _player.move_and_slide()
func input(event: InputEvent):
   if event.is_action_pressed("jump"):
      _state_machine.transition("Jump")</pre>			<p>You can see we extend the <code>State</code> script<a id="_idIndexMarker853"/> from earlier. Then, we implement the <code>process()</code> function to do our movement calculations, which are specific to walking around, and the <code>input()</code> function to detect when we want to transition from this state to the <code>Jump</code> state.</p>
			<p>We don’t need to override every function from the <code>State</code> script, just the ones that we need, which in this case are the <code>process()</code> and <code>input()</code> functions.</p>
			<p>State Machines, in one way or another, are used in almost every game you ever played. It is a very important concept to understand. They abstract complex behavior into separate classes that are easy<a id="_idIndexMarker854"/> to understand and maintain.</p>
			<p>Let’s conclude the chapter with some additional exercises.</p>
			<h1 id="_idParaDest-340"><a id="_idTextAnchor736"/>Additional exercises – Sharpening the axe</h1>
			<ol>
				<li>The implementation of our Event Bus makes it possible to subscribe to an event, but not to unsubscribe when the receiver doesn’t want to be subscribed anymore. Implement an <code>unsubscribe()</code> function that unsubscribes a <code>Callable</code> from an event:<pre class="source-code">
func unsubscribe(event_name: String, callback: Callable):
   # Your code</pre></li>				<li>The Object Pool we have implemented returns nothing when we try to call <code>get_dead_node()</code> while the pool is empty. A smarter way of dealing with this would be to create a new object, basically extending the Object Pool on the fly. Create a new function, <code>get_dead_node_or_create_new()</code>, in such a way that when the pool is empty, it creates a new object that is correctly connected and returned to the pool when it dies.</li>
			</ol>
			<h1 id="_idParaDest-341"><a id="_idTextAnchor737"/>Summary</h1>
			<p>After learning how to program and make a game, we finally took a step back and learned about higher-level patterns that help us structure our project and code nicely. First, we learned about what programming patterns are in general. Then, we learned about the Event Bus, Object Pool, and State Machine patterns that can help us in different ways. These three are some of the widely used patterns in gaming and are applied outside of game development too.</p>
			<p>From here, you can start to investigate more niche programming patterns, such as the following:</p>
			<ul>
				<li><strong class="bold">Components, also known as </strong><strong class="bold">Composition</strong>: <a href="https://gameprogrammingpatterns.com/component.html">https://gameprogrammingpatterns.com/component.html</a></li>
				<li><strong class="bold">Commands</strong>: <a href="https://gameprogrammingpatterns.com/command.html">https://gameprogrammingpatterns.com/command.html</a></li>
				<li><strong class="bold">Service </strong><strong class="bold">Locators</strong>: <a href="https://gameprogrammingpatterns.com/service-locator.html">https://gameprogrammingpatterns.com/service-locator.html</a></li>
			</ul>
			<p>In the next chapter, we’ll look at the filesystem and learn how to save the state of our game so that our players can start<a id="_idTextAnchor738"/> a game from where they left off.</p>
			<h1 id="_idParaDest-342"><a id="_idTextAnchor739"/>Quiz time</h1>
			<ul>
				<li>Programming patterns are standardized ways of solving problems in a program or game. What is the advantage of knowing them?</li>
				<li>Any piece of code can be considered as a pattern. But when we call something an anti-pattern, does this mean that it works in our favor?</li>
				<li>The Signals and Event Bus patterns are very similar because, in both, we subscribe to events, but what is their fundamental difference?</li>
				<li>Why would we use an Object Pool pattern in our game?</li>
				<li>What is the line of code with which we can transition from one state to another using the State Machine pattern?</li>
			</ul>
		</div>
	</body></html>