- en: The Basics of GLSL Shaders
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GLSL着色器的基础
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Diffuse and per-vertex shading with a single point light source
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个点光源进行漫反射和顶点着色
- en: Implementing the Phong reflection model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Phong反射模型
- en: Using functions in shaders
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在着色器中使用函数
- en: Implementing two-sided shading
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现双面着色
- en: Implementing flat shading
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现平面着色
- en: Using subroutines to select shader functionality
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用子程序选择着色器功能
- en: Discarding fragments to create a perforated look
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛弃片段以创建带有孔洞的外观
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Shaders were first added into OpenGL in version 2.0, introducing programmability
    into the formerly fixed-function OpenGL pipeline. Shaders give us the power to
    implement custom rendering algorithms and provide us with a greater degree of
    flexibility in the implementation of those techniques. With shaders, we can run
    custom code directly on the GPU, providing us with the opportunity to leverage
    the high degree of parallelism available with modern GPUs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器最初是在OpenGL的2.0版本中添加的，这为之前固定功能的OpenGL管道引入了可编程性。着色器赋予我们实现自定义渲染算法的能力，并在这些技术的实现上提供了更大的灵活性。有了着色器，我们可以在GPU上直接运行自定义代码，这为我们利用现代GPU提供的并行度提供了机会。
- en: Shaders are implemented using the **OpenGL Shading Language** (**GLSL**). GLSL
    is syntactically similar to C, which should make it easier for experienced OpenGL
    programmers to learn. Due to the nature of this text, I won't present a thorough
    introduction to GLSL here. Instead, if you're new to GLSL, reading through these
    recipes should help you to learn the language through example. If you are already
    comfortable with GLSL, but don't have experience with version 4.x, you'll see
    how to implement these techniques by utilizing the newer API. However, before
    we jump into GLSL programming, let's take a quick look at how vertex and fragment
    shaders fit within the OpenGL pipeline.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器使用**OpenGL着色语言**（**GLSL**）实现。GLSL在语法上类似于C，这应该会使有经验的OpenGL程序员更容易学习。由于本文的性质，我不会在这里提供一个详尽的GLSL介绍。相反，如果你是GLSL的新手，阅读这些食谱应该能帮助你通过示例学习这门语言。如果你已经熟悉GLSL，但没有4.x版本的经验，你将看到如何通过利用新的API来实现这些技术。然而，在我们深入GLSL编程之前，让我们快速看一下顶点着色器和片段着色器如何在OpenGL管道中定位。
- en: Vertex and fragment shaders
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点和片段着色器
- en: 'In OpenGL Version 4.3 and above, there are six shader stages/types: vertex,
    geometry, tessellation control, tessellation evaluation, fragment, and compute.
    In this chapter, we''ll focus only on the vertex and fragment stages. In [Chapter
    7](fab663d4-e210-417c-aa3b-2c4c307ec913.xhtml), *Using Geometry and Tessellation
    Shaders*, I''ll provide some recipes for working with the geometry and tessellation
    shaders, and in [Chapter 11](d67e01c8-8212-4d49-937f-6b1c62a57744.xhtml), *Using
    Compute Shaders*, I''ll focus specifically on compute shaders.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL 4.3及以上版本中，有六个着色器阶段/类型：顶点、几何、曲面细分控制、曲面细分评估、片段和计算。在本章中，我们将仅关注顶点和片段阶段。在[第7章](fab663d4-e210-417c-aa3b-2c4c307ec913.xhtml)
    *使用几何和曲面细分着色器* 中，我将提供一些使用几何和曲面细分着色器的食谱，而在[第11章](d67e01c8-8212-4d49-937f-6b1c62a57744.xhtml)
    *使用计算着色器* 中，我将专门关注计算着色器。
- en: 'Shaders are fundamental parts of the modern OpenGL pipeline. The following
    block diagram shows a simplified view of the OpenGL pipeline with only the vertex
    and fragment shaders installed:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器是现代OpenGL管道的基本部分。以下块图显示了仅安装了顶点和片段着色器的简化OpenGL管道视图：
- en: '![](img/9b21bf23-b73d-4288-a641-55bfea8b9842.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9b21bf23-b73d-4288-a641-55bfea8b9842.png)'
- en: 'Vertex data is sent down the pipeline and arrives at the vertex shader via
    shader input variables. The vertex shader''s input variables correspond to the
    vertex attributes (refer to the *Sending data to a shader using vertex attributes
    and vertex buffer objects* recipe in [Chapter 2](15752c1f-eee7-4117-9632-f08f84a9405d.xhtml),
    *Working with GLSL Programs*). In general, a shader receives its input via programmer-defined
    input variables, and the data for those variables comes either from the main OpenGL
    application or previous pipeline stages (other shaders). For example, a fragment
    shader''s input variables might be fed from the output variables of the vertex
    shader. Data can also be provided to any shader stage using uniform variables
    (refer to the *Sending data to a shader using uniform variables* recipe in [Chapter
    2](15752c1f-eee7-4117-9632-f08f84a9405d.xhtml), *Working with GLSL Programs*).
    These are used for information that changes less often than vertex attributes
    (for example, matrices, light position, and other settings). The following diagram
    shows a simplified view of the relationships between input and output variables
    when there are two shaders active (vertex and fragment):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点数据通过管线发送，并通过着色器输入变量到达顶点着色器。顶点着色器的输入变量对应于顶点属性（参考第2章中的*使用顶点属性和顶点缓冲对象向着色器发送数据*配方，*使用GLSL程序工作*）。一般来说，着色器通过程序员定义的输入变量接收输入，这些变量的数据要么来自主OpenGL应用程序，要么来自之前的管线阶段（其他着色器）。例如，片段着色器的输入变量可能来自顶点着色器的输出变量。数据也可以通过统一变量（参考第2章中的*使用统一变量向着色器发送数据*配方，*使用GLSL程序工作*）提供给任何着色器阶段。这些用于比顶点属性更少变化的信息（例如，矩阵、光位置和其他设置）。以下图显示了有两个活动着色器（顶点和片段）时输入和输出变量之间关系的简化视图：
- en: '![](img/6ae9550c-eb4e-4582-877f-c31256676587.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ae9550c-eb4e-4582-877f-c31256676587.png)'
- en: The vertex shader is executed once for each vertex, in parallel. The data corresponding
    to the position of the vertex must be transformed into clip space coordinates
    and assigned to the output variable `gl_Position` before the vertex shader finishes
    execution. The vertex shader can send other information down the pipeline using
    shader output variables. For example, the vertex shader might also compute the
    color associated with the vertex. That color would be passed to later stages via
    an appropriate output variable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器为每个顶点执行一次，并行执行。在顶点着色器完成执行之前，必须将对应顶点位置的数据转换成裁剪空间坐标，并分配给输出变量 `gl_Position`。顶点着色器可以使用着色器输出变量将其他信息发送到管线中。例如，顶点着色器也可能计算与顶点相关的颜色。这种颜色将通过适当的输出变量传递到后续阶段。
- en: Between the vertex and fragment shader, vertices are assembled into primitives,
    clipping takes place, and the viewport transformation is applied (among other
    operations). The rasterization process then takes place and the polygon is filled
    (if necessary). The fragment shader is executed once for each fragment of the
    polygon being rendered (typically in parallel). Data provided from the vertex
    shader is (by default) interpolated in a perspective correct manner, and provided
    to the fragment shader via shader input variables. The fragment shader determines
    the appropriate color for the pixel and sends it to the frame buffer using output
    variables. The depth information is handled automatically, but can be modified
    by the fragment shader if desired.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器和片段着色器之间，顶点被组装成原语，进行裁剪，并应用视口变换（以及其他操作）。然后进行光栅化过程，并填充多边形（如果需要）。片段着色器为渲染的多边形的每个片段执行一次（通常并行）。从顶点着色器提供的数据默认情况下以透视正确的方式进行插值，并通过着色器输入变量提供给片段着色器。片段着色器确定像素的适当颜色，并通过输出变量将其发送到帧缓冲区。深度信息自动处理，但可以根据需要由片段着色器修改。
- en: Learning the basics first
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首先学习基础知识
- en: Programmable shaders give us tremendous power and flexibility. A good place
    to start is to learn how to implement a simple, common reflection model known
    as the **Phong reflection model**. It is a good basis for building upon.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 可编程着色器为我们提供了巨大的力量和灵活性。一个不错的起点是学习如何实现一个简单的、常见的反射模型，称为**Phong反射模型**。这是一个很好的基础。
- en: In this chapter, we'll look at the basic techniques for implementing the Phong
    model. We'll modify it in a few simple ways, including two-sided rendering and
    flat shading. Along the way, we'll also see some examples of other GLSL features
    such as functions, subroutines, and the `discard` keyword.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨实现Phong模型的基本技术。我们将对其进行一些简单的修改，包括双面渲染和平滑着色。在这个过程中，我们还将看到一些其他GLSL特性的示例，如函数、子程序和`discard`关键字。
- en: Diffuse and per-vertex shading with a single point light source
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单个点光源进行漫反射和顶点着色
- en: 'Before learning the full Phong reflection model, we''ll start with just one
    part: diffuse reflection. It is a simple reflection model that makes the assumption
    that the surface exhibits purely diffuse reflection. That is to say that the surface
    appears to scatter light in all directions equally, regardless of direction.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习完整的Phong反射模型之前，我们将从仅一个部分开始：漫反射。这是一个简单的反射模型，它假设表面表现出纯漫反射。也就是说，表面看起来以相同的方式向所有方向散射光线，而不管方向如何。
- en: Incoming light strikes the surface and penetrates slightly before being reradiated
    in all directions. Of course, the incoming light interacts with the surface before
    it is scattered, causing some wavelengths to be fully or partially absorbed and
    others to be scattered. A typical example of a diffuse surface is a surface that
    has been painted with a matte paint. The surface has a dull look with no shine
    at all.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 入射光撞击表面并略微穿透后向所有方向重新辐射。当然，入射光在散射之前会与表面相互作用，导致某些波长的光被完全或部分吸收，而其他波长的光被散射。一个典型的漫反射表面例子是涂有哑光漆的表面。该表面看起来很暗淡，没有任何光泽。
- en: 'The following image shows a torus rendered with diffuse shading:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了使用漫反射着色渲染的环面：
- en: '![](img/477790cd-0263-4bb5-9123-a9770f48abb9.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/477790cd-0263-4bb5-9123-a9770f48abb9.png)'
- en: 'The mathematical model for diffuse reflection involves two vectors: the direction
    from the surface point to the light source (**s**), and the normal vector at the
    surface point (**n**). The vectors are represented in the following diagram:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 漫反射的数学模型涉及两个向量：从表面点到光源的方向（**s**），以及表面点的法向量（**n**）。这两个向量在以下图中表示：
- en: '![](img/7b05ab82-3db9-46b0-a1a9-f0aacd3c81ea.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7b05ab82-3db9-46b0-a1a9-f0aacd3c81ea.png)'
- en: 'The amount of incoming light (or radiance) per unit area that strikes a surface
    is dependent on the orientation of the surface with respect to the light source.
    The physics of the situation tells us that the amount of radiation per unit area
    is maximal when the light arrives along the direction of the normal vector, and
    zero when the light is perpendicular to the normal vector. In between, it is proportional
    to the cosine of the angle between the direction towards the light source and
    the normal vector. So, since the dot product is proportional to the cosine of
    the angle between two vectors, we can express the amount of radiation striking
    the surface as the product of the light intensity and the dot product of *s* and
    *n*, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 单位面积上撞击表面的入射光（或辐射度）的量取决于表面相对于光源的朝向。该情况下的物理学告诉我们，当光线沿着法向量方向到达时，单位面积上的辐射量最大，而当光线垂直于法向量时为零。在两者之间，它与光线方向与法向量之间角度的余弦值成正比。因此，由于点积与两个向量之间角度的余弦值成正比，我们可以将撞击表面的辐射量表示为光强度与**s**和**n**的点积的乘积，如下所示：
- en: '![](img/b6b510f6-32fc-4f53-a48e-2fb4c995e299.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b6b510f6-32fc-4f53-a48e-2fb4c995e299.png)'
- en: '*L[d]* is the intensity of the light source, and the vectors **s** and **n**
    are assumed to be normalized.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*L[d]*是光源的强度，向量**s**和**n**被假定为归一化的。'
- en: The dot product of two unit vectors is equal to the cosine of the angle between
    them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 两个单位向量的点积等于它们之间角度的余弦值。
- en: 'As stated previously, some of the incoming light is absorbed before it is reemitted.
    We can model this interaction by using a reflection coefficient (*K[d]*), which
    represents the fraction of the incoming light that is scattered. This is sometimes
    called the **diffuse reflectivity**, or the diffuse reflection coefficient. The
    diffuse reflectivity becomes a scaling factor, so the intensity of the outgoing
    light can be expressed as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一些入射光在重新发射之前被吸收。我们可以通过使用反射系数（*K[d]*）来模拟这种相互作用，它表示散射的入射光的比例。这有时被称为**漫反射率**或漫反射系数。漫反射率成为一个缩放因子，因此出射光的强度可以表示如下：
- en: '![](img/42dcb457-527b-4407-b8ec-d1f7538bd691.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/42dcb457-527b-4407-b8ec-d1f7538bd691.png)'
- en: Because this model depends only on the direction towards the light source and
    the normal to the surface, not on the direction towards the viewer, we have a
    model that represents uniform (omnidirectional) scattering.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个模型只依赖于指向光源的方向和表面的法线，而不依赖于指向观察者的方向，所以我们有一个表示均匀（全向）散射的模型。
- en: In this recipe, we'll evaluate this equation at each vertex in the vertex shader
    and interpolate the resulting color across the face. We'll use uniform variables
    for the *K[d]* and *L[d]* terms as well as the light position.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将在顶点着色器中的每个顶点上评估这个方程，并在面上插值得到的颜色。我们将使用统一变量为 *K[d]* 和 *L[d]* 项以及光源位置。
- en: In this and the following recipes, light intensities and material reflectivity
    coefficients are represented by three-component (RGB) vectors. Therefore, the
    equations should be treated as component-wise operations, applied to each of the
    three components separately. Luckily, the GLSL will make this nearly transparent
    because the necessary operators operate component-wise on vector variables.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个和接下来的配方中，光强度和材料反射率系数由三组件（RGB）向量表示。因此，这些方程应被视为逐分量操作，分别应用于三个分量。幸运的是，GLSL 将使这一点几乎透明，因为必要的运算符在向量变量上逐分量操作。
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start with an OpenGL application that provides the vertex position in attribute
    location 0, and the vertex normal in attribute location 1 (refer to the *Sending
    data to a shader using vertex attributes and vertex buffer objects* recipe in
    [Chapter 2](15752c1f-eee7-4117-9632-f08f84a9405d.xhtml), *Working with GLSL Programs*).
    The OpenGL application should also provide the standard transformation matrices
    (projection, modelview, and normal) via uniform variables.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个提供顶点位置在属性位置 0 和顶点法线在属性位置 1 的 OpenGL 应用程序开始（请参阅[第2章](15752c1f-eee7-4117-9632-f08f84a9405d.xhtml)，*使用
    GLSL 程序工作*中的*使用顶点属性和顶点缓冲对象向着色器发送数据*配方）。OpenGL 应用程序还应通过统一变量提供标准变换矩阵（投影、模型视图和法线）。
- en: The light position (in camera coordinates), `Kd`, and `Ld` should also be provided
    by the OpenGL application via uniform variables. Note that `Kd` and `Ld` are of
    type `vec3`. We can use `vec3` to store an RGB color as well as a vector or point.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 光源位置（在相机坐标系中），`Kd` 和 `Ld` 也应由 OpenGL 应用程序通过统一变量提供。注意，`Kd` 和 `Ld` 是 `vec3` 类型。我们可以使用
    `vec3` 来存储 RGB 颜色以及一个向量或点。
- en: How to do it...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a shader pair that implements diffuse shading, take the following
    steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个实现漫反射着色的着色器对，请按照以下步骤操作：
- en: 'The vertex shader computes the diffuse reflection equation and sends the result
    to the fragment shader via the output variable `LightIntensity`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点着色器计算漫反射方程，并通过输出变量 `LightIntensity` 将结果发送到片段着色器：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The fragment shader simply applies the color to the fragment:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 片段着色器简单地将颜色应用到片段上：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Compile and link both shaders within the OpenGL application and install the
    shader program prior to rendering. See [Chapter 1](3b817a9a-28a1-4be7-936c-b982b4dfacdf.xhtml),
    *Getting Started with GLSL*, for details about compiling, linking, and installing
    shaders.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 OpenGL 应用程序中编译和链接这两个着色器，并在渲染之前安装着色器程序。有关编译、链接和安装着色器的详细信息，请参阅[第1章](3b817a9a-28a1-4be7-936c-b982b4dfacdf.xhtml)，*开始使用
    GLSL*。
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The vertex shader does all of the work in this example. The diffuse reflection
    is computed in camera coordinates by first transforming the normal vector using
    the normal matrix, normalizing, and storing the result in `tnorm`. Note that the
    normalization here may not be necessary if your normal vectors are already normalized
    and the normal matrix does not do any scaling.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，顶点着色器完成了所有的工作。漫反射是在相机坐标系中通过首先使用法线矩阵变换法线向量，归一化，并将结果存储在 `tnorm` 中来计算的。请注意，如果您的法线向量已经归一化且法线矩阵不执行任何缩放，则这里的归一化可能不是必需的。
- en: The normal matrix is the inverse transpose of the upper-left 3x3 portion of
    the model-view matrix. We use the inverse transpose because normal vectors transform
    differently than the vertex position. For a more thorough discussion of the normal
    matrix, and the reasons why, see any introductory computer graphics textbook (a
    good choice would be *Computer Graphics with OpenGL* by Hearn and Baker). If your
    model-view matrix does not include any nonuniform scaling, then one can use the
    upper-left 3 x 3 of the model-view matrix in place of the normal matrix to transform
    your normal vectors. However, if your model-view matrix does include (uniform)
    scaling, you'll still need to (re)normalize your normal vectors after transforming
    them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正交矩阵是模型视图矩阵左上角3x3部分的逆转。我们使用逆转是因为法向量与顶点位置变换的方式不同。关于正交矩阵的更详细讨论以及原因，请参阅任何计算机图形学入门教材（一个不错的选择是Hearn和Baker合著的《OpenGL计算机图形学》）。如果你的模型视图矩阵不包含任何非均匀缩放，那么可以使用模型视图矩阵左上角的3x3部分来代替正交矩阵以变换你的法向量。然而，如果你的模型视图矩阵包含（均匀）缩放，那么在变换后你仍然需要（重新）归一化你的法向量。
- en: The next step converts the vertex position to camera coordinates by transforming
    it with the model-view matrix. Then, we compute the direction toward the light
    source by subtracting the vertex position from the light position and storing
    the result in `s`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将顶点位置转换为相机坐标，通过使用模型视图矩阵变换它。然后，我们通过从顶点位置减去光位置来计算指向光源的方向，并将结果存储在`s`中。
- en: Next, we compute the scattered light intensity using the equation described
    previously and store the result in the output variable `LightIntensity`. Note
    the use of the `max` function here. If the dot product is less than zero, then
    the angle between the normal vector and the light direction is greater than 90
    degrees. This means that the incoming light is coming from inside the surface.
    Since such a situation would mean that no radiation reaches the surface, and the
    dot product would produce negative values, we use a value of `0.0`. However, you
    may decide that you want to properly light both sides of your surface, in which
    case the normal vector needs to be reversed for those situations where the light
    is striking the back side of the surface (refer to the *Implementing two-sided
    shading* recipe in this chapter).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用之前描述的方程计算散射光强度，并将结果存储在输出变量`LightIntensity`中。注意这里`max`函数的使用。如果点积小于零，则法向量与光方向之间的角度大于90度。这意味着入射光是从表面内部来的。由于这种情况意味着没有辐射到达表面，点积会产生负值，所以我们使用`0.0`的值。然而，你可能决定你想正确地照亮表面的两侧，在这种情况下，当光击中表面的背面时，需要反转法向量（参考本章中的*实现双面着色*配方）。
- en: Finally, we convert the vertex position to clip space coordinates by multiplying
    it with the model-view projection matrix, (which is *projection * view * model*)
    and store the result in the built-in output variable `gl_Position`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过乘以模型视图投影矩阵（即*投影 * 视图 * 模型）将顶点位置转换为裁剪空间坐标，并将结果存储在内置输出变量`gl_Position`中。
- en: The subsequent stage of the OpenGL pipeline expects that the vertex position
    will be provided in clip space coordinates in the output variable `gl_Position`.
    This variable does not directly correspond to any input variable in the fragment
    shader, but is used by the OpenGL pipeline in the primitive assembly, clipping,
    and rasterization stages that follow the vertex shader. It is important that we
    always provide a valid value for this variable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL管道的后续阶段期望顶点位置以裁剪空间坐标的形式提供在输出变量`gl_Position`中。这个变量并不直接对应于片元着色器中的任何输入变量，但它被OpenGL管道在后续的原始装配、裁剪和光栅化阶段使用。我们始终提供一个有效的值对于这个变量是很重要的。
- en: Since `LightIntensity` is an output variable from the vertex shader, its value
    is interpolated across the face and passed into the fragment shader. The fragment
    shader then simply assigns the value to the output fragment.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`LightIntensity`是顶点着色器的输出变量，其值在面之间插值，并传递到片元着色器。然后，片元着色器简单地将该值赋给输出片元。
- en: There's more...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Diffuse shading is a technique that models only a very limited range of surfaces.
    It is best used for surfaces that have a *matte* appearance. Additionally, with
    the technique used previously, the dark areas may look a bit too dark. In fact,
    those areas that are not directly illuminated are completely black. In real scenes,
    there is typically some light that has been reflected about the room that brightens
    these surfaces. In the following recipes, we'll look at ways to model more surface
    types, as well as providing some light for those dark parts of the surface.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 漫射着色是一种仅模拟非常有限范围的表面技术的技巧。它最适合用于具有*哑光*外观的表面。此外，使用之前的技术，暗区可能看起来有点太暗。实际上，那些没有直接照亮的区域是完全黑色的。在真实场景中，通常有一些光线在房间内反射，从而照亮这些表面。在接下来的菜谱中，我们将探讨模拟更多表面类型的方法，并为表面上的暗部提供一些光线。
- en: See also
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter03/scenediffuse.cpp` file in the example code
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter03/scenediffuse.cpp`文件
- en: The *Sending data to a shader using uniform variables* recipe in [Chapter 2](15752c1f-eee7-4117-9632-f08f84a9405d.xhtml),
    *Working with GLSL Programs*
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](15752c1f-eee7-4117-9632-f08f84a9405d.xhtml)中的*使用统一变量将数据发送到着色器*菜谱，*使用GLSL程序*'
- en: The *Compiling a shader* recipe in [Chapter 1](3b817a9a-28a1-4be7-936c-b982b4dfacdf.xhtml),
    *Getting Started with GLSL*
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](3b817a9a-28a1-4be7-936c-b982b4dfacdf.xhtml)中的*编译着色器*菜谱，*开始使用GLSL*'
- en: The *Linking a shader program* recipe in [Chapter 1](3b817a9a-28a1-4be7-936c-b982b4dfacdf.xhtml),
    *Getting Started with GLSL*
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](3b817a9a-28a1-4be7-936c-b982b4dfacdf.xhtml)中的*链接着色器程序*菜谱，*开始使用GLSL*'
- en: The *Sending data to a shader using vertex attributes and vertex buffer objects*
    recipe in [Chapter 2](15752c1f-eee7-4117-9632-f08f84a9405d.xhtml), *Working with
    GLSL Programs*
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](15752c1f-eee7-4117-9632-f08f84a9405d.xhtml)中的*使用顶点属性和顶点缓冲对象将数据发送到着色器*菜谱，*使用GLSL程序*'
- en: Implementing the Phong reflection model
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Phong反射模型
- en: 'In this recipe, we''ll implement the well-known Phong reflection model. The
    OpenGL fixed-function pipeline''s default shading technique was very similar to
    the one presented here.  It models the light-surface interaction as a combination
    of three components: ambient, diffuse, and specular. The **ambient** component
    is intended to model light that has been reflected so many times that it appears
    to be emanating uniformly from all directions. The **diffuse** component was discussed
    in the previous recipe, and represents omnidirectional reflection. The **specular**
    component models the shininess of the surface and represents glossy reflection
    around a preferred direction. Combining these three components together can model
    a nice (but limited) variety of surface types. This shading model is called the
    **Phong reflection model** (or **Phong shading model**), after graphics researcher Bui
    Tuong Phong.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将实现著名的Phong反射模型。OpenGL固定功能管道的默认着色技术非常类似于这里所展示的。它将光与表面的相互作用建模为三个组件的组合：环境、漫射和镜面。**环境**组件旨在模拟经过多次反射的光，它看起来似乎从所有方向均匀地发出。**漫射**组件在前一个菜谱中已讨论过，代表全向反射。**镜面**组件模拟表面的光泽度，并代表围绕一个优选方向的光滑反射。将这三个组件组合在一起可以模拟一个很好的（但有限的）表面类型多样性。这种着色模型被称为**Phong反射模型**（或**Phong着色模型**），以图形研究员Bui
    Tuong Phong的名字命名。
- en: 'An example of a torus rendered with the Phong shading model is shown in the
    following image:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了使用Phong着色模型渲染的环面示例：
- en: '![](img/3dd29349-b614-4337-845e-045460c4dbad.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3dd29349-b614-4337-845e-045460c4dbad.png)'
- en: 'The Phong model is implemented as the sum of three components: ambient, diffuse,
    and specular. The ambient component represents light that illuminates all surfaces
    equally and reflects equally in all directions. It is used to help brighten some
    of the darker areas within a scene. Since it does not depend on the incoming or
    outgoing directions of the light, it can be modeled simply by multiplying the
    light source intensity (*L[a]*) by the surface reflectivity (*K[a]*):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Phong模型被实现为三个组件的总和：环境、漫射和镜面。环境组件代表照亮所有表面并均匀反射到所有方向的光。它用于帮助照亮场景中的一些较暗区域。由于它不依赖于光线的入射或出射方向，它可以简单地通过将光源强度（*L[a]*）乘以表面反射率（*K[a]*）来模拟：
- en: '![](img/1a820503-2e84-49ca-a4cc-4808a8eaa91a.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1a820503-2e84-49ca-a4cc-4808a8eaa91a.png)'
- en: 'The diffuse component models a rough surface that scatters light in all directions
    (see* Diffuse and per-vertex shading with a single point light source* recipe
    in this chapter). The diffuse contribution is given by the following equation:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 扩散分量模拟了一个粗糙表面，该表面向所有方向散射光线（参见本章中的*单点光源的扩散和顶点着色*配方）。扩散贡献由以下方程给出：
- en: '![](img/c9d6c8dd-395b-403e-8d6f-f9cf54ab9556.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c9d6c8dd-395b-403e-8d6f-f9cf54ab9556.png)'
- en: 'The specular component is used for modeling the shininess of a surface. When
    a surface has a glossy shine to it, the light is reflected off of the surface,
    scattered around some preferred direction. We model this so that the reflected
    light is strongest in the direction of perfect (mirror-like) reflection. The physics
    of the situation tells us that for perfect reflection, the angle of incidence
    is the same as the angle of reflection and that the vectors are coplanar with
    the surface normal, as shown in the following diagram:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 镜面分量用于模拟表面的光泽。当表面具有光泽时，光线从表面反射，并在某些优选方向上散射。我们这样模拟，使得反射光在完美（镜面）反射的方向上最强。该情况下的物理学告诉我们，对于完美反射，入射角等于反射角，并且矢量与表面法线共面，如下面的图所示：
- en: '![](img/7a401c95-2047-452b-828a-d3693931d9ec.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a401c95-2047-452b-828a-d3693931d9ec.png)'
- en: 'In the preceding diagram, **r** represents the direction of pure reflection
    corresponding to the incoming light vector (**-s**), and **n** is the surface
    normal. We can compute **r** by using the following equation:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，**r** 代表与入射光矢量（**-s**）相对应的纯反射方向，而 **n** 是表面法线。我们可以通过以下方程计算 **r**：
- en: '![](img/034eb641-c42d-438b-beb0-8b4d18f2a215.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/034eb641-c42d-438b-beb0-8b4d18f2a215.png)'
- en: 'To model specular reflection, we need to compute the following (normalized)
    vectors: the direction toward the light source (**s**), the vector of perfect
    reflection (**r**), the vector toward the viewer (**v**), and the surface normal
    (**n**). These vectors are represented in the following diagram:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟镜面反射，我们需要计算以下（归一化）矢量：指向光源的方向（**s**）、完美反射的矢量（**r**）、指向观察者的矢量（**v**）和表面法线（**n**）。这些矢量在以下图中表示：
- en: '![](img/81a67689-22a4-41fc-9ecd-5451330197cd.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/81a67689-22a4-41fc-9ecd-5451330197cd.png)'
- en: 'We would like the reflection to be maximal when the viewer is aligned with
    the vector **r**, and to fall off quickly as the viewer moves farther away from
    alignment with **r**. This can be modeled using the cosine of the angle between
    **v** and **r** raised to some power (**f**):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望当观察者与矢量 **r** 对齐时，反射最大，而当观察者远离与 **r** 对齐时，反射迅速减弱。这可以通过使用 **v** 和 **r** 之间角度的余弦值提高到某个幂（**f**）来模拟：
- en: '![](img/4cb2ff7c-8609-4f5c-87c8-2f9c94d4d970.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4cb2ff7c-8609-4f5c-87c8-2f9c94d4d970.png)'
- en: (Recall that the dot product is proportional to the cosine of the angle between
    the vectors involved.) The larger the power, the faster the value drops toward
    zero as the angle between **v** and **r** increases. Again, similar to the other
    components, we also introduce a specular light intensity term (*L[s]*) and reflectivity
    term (*K[s]*). It is common to set the *K[s]* term to some grayscale value (for
    example, (0.8, 0.8, 0.8)), since glossy reflection is not (generally) wavelength
    dependent.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: （回忆一下，点积与涉及矢量之间的角度的余弦值成正比。）功率越大，当 **v** 和 **r** 之间的角度增大时，值向零下降的速度越快。同样，与其他分量一样，我们也引入了镜面光强度项（*L[s]*）和反射率项（*K[s]*）。通常将
    *K[s]* 项设置为某种灰度值（例如，(0.8, 0.8, 0.8)），因为光泽反射（通常）与波长无关。
- en: The specular component creates **specular highlights** (bright spots) that are
    typical of glossy surfaces. The larger the power of *f* in the equation, the smaller
    the specular highlight and the shinier the surface. The value for *f* is typically
    chosen to be somewhere between 1 and 200.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 镜面分量创建典型的光泽表面的**镜面高光**（亮斑）。方程中 *f* 的幂越大，镜面高光越小，表面越光滑。*f* 的值通常选择在 1 到 200 之间。
- en: 'Putting all of this together by simply summing the three terms, we have the
    following shading equation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地将这三个项相加，我们得到以下着色方程：
- en: '![](img/fb91f8d1-8b54-4c2c-93fe-df8b866a44d1.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb91f8d1-8b54-4c2c-93fe-df8b866a44d1.png)'
- en: In the following code, we'll evaluate this equation in the vertex shader, and
    interpolate the color across the polygon.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将在顶点着色器中评估此方程，并在多边形上插值颜色。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the OpenGL application, provide the vertex position in location 0 and the
    vertex normal in location 1\. The light position and the other configurable terms
    for our lighting equation are uniform variables in the vertex shader and their
    values must be set from the OpenGL application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL应用程序中，将顶点位置提供在位置0，将顶点法线提供在位置1。光的位置和我们的光照方程的其他可配置项是顶点着色器中的统一变量，它们的值必须从OpenGL应用程序中设置。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To create a shader pair that implements the Phong reflection model, take the
    following steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个实现Phong反射模型的着色器对，请按照以下步骤操作：
- en: 'The vertex shader computes the Phong reflection model at the vertex position
    and sends the result to the fragment shader:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点着色器在顶点位置计算Phong反射模型，并将结果发送到片段着色器：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The fragment shader simply applies the color to the fragment:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 片段着色器只是将颜色应用到片段上：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Compile and link both shaders within the OpenGL application, and install the
    shader program prior to rendering.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenGL应用程序中编译和链接两个着色器，并在渲染之前安装着色器程序。
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The vertex shader computes the shading equation in eye coordinates. It begins
    by transforming the vertex normal into camera coordinates and normalizing, then
    storing the result in `n`. The vertex position is also transformed into camera
    coordinates and stored in `camCoords`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器在眼坐标中计算着色方程。它首先将顶点法线转换到相机坐标系并归一化，然后将结果存储在`n`中。顶点位置也转换到相机坐标系并存储在`camCoords`中。
- en: The ambient component is computed and stored in the variable `ambient`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 计算并存储环境分量在变量`ambient`中。
- en: Next, we compute the normalized direction towards the light source (`s`). This
    is done by subtracting the vertex position in camera coordinates from the light
    position and normalizing the result.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算指向光源的归一化方向（`s`）。这是通过从相机坐标系中的顶点位置减去光的位置并归一化结果来完成的。
- en: The dot product of `s` and `n` is computed next. As in the preceding recipe,
    we use the built-in function `max` to limit the range of values to between zero
    and one. The result is stored in the variable named `sDotN`, and is used to compute
    the diffuse component. The resulting value for the diffuse component is stored
    in the variable `diffuse`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来计算`s`和`n`的点积。与前面的配方一样，我们使用内置函数`max`将值的范围限制在零和一之间。结果存储在名为`sDotN`的变量中，并用于计算漫反射分量。漫反射分量的结果存储在变量`diffuse`中。
- en: Before computing the specular component, we check the value of `sDotN`. If `sDotN` is
    zero, then there is no light reaching the surface, so there is no point in computing
    the specular component, as its value must be zero. Otherwise, if `sDotN` is greater
    than zero, we compute the specular component using the equation presented earlier.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算镜面分量之前，我们检查`sDotN`的值。如果`sDotN`为零，则没有光线到达表面，因此没有必要计算镜面分量，因为它的值必须是零。否则，如果`sDotN`大于零，我们使用前面提出的方程计算镜面分量。
- en: If we did not check `sDotN` before computing the specular component, it is possible
    that some specular highlights could appear on faces that are facing away from
    the light source. This is clearly an unrealistic and undesirable result. Another
    way to solve this problem is to multiply both the specular and diffuse components
    by `sDotN` (instead of only the diffuse component as we are doing now). This is
    actually somewhat more physically accurate, but is not part of the traditional
    Phong model.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在计算镜面分量之前没有检查`sDotN`，那么可能在背对光源的面出现一些镜面高光。这显然是一个不现实且不希望的结果。另一种解决这个问题的方法是将镜面和漫反射分量都乘以`sDotN`（而不是像我们现在这样只乘以漫反射分量）。这实际上更符合物理规律，但不是传统Phong模型的一部分。
- en: The direction toward the viewer (`v`) is the negation of the position (normalized)
    because in camera coordinates the viewer is at the origin.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 观众的方向（`v`）是位置（归一化）的否定，因为在相机坐标系中，观众位于原点。
- en: We compute the direction of pure reflection by calling the GLSL built-in function
    `reflect`, which reflects the first argument about the second. We don't need to
    normalize the result because the two vectors involved are already normalized.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用GLSL内置函数`reflect`来计算纯反射的方向，该函数将第一个参数关于第二个参数反射。我们不需要归一化结果，因为涉及的这两个向量已经归一化了。
- en: When computing the specular component, we use the built-in function `max` to
    limit the range of values of the dot product to between zero and one, and the
    function `pow` raises the dot product to the power of the `Shininess` exponent
    (corresponding to *f* in our lighting equation).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算镜面分量时，我们使用内置函数`max`将点积的值限制在零和一之间，而函数`pow`将点积提升到`Shininess`指数的幂（对应于我们光照方程中的*f*）。
- en: The sum of the three components is then stored in the output variable `LightIntensity`.
    This value will be associated with the vertex and passed down the pipeline. Before
    reaching the fragment shader, its value will be interpolated in a perspective
    correct manner across the face of the polygon.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将三个分量的和存储在输出变量`LightIntensity`中。此值将与顶点相关联并传递到管道中。在到达片段着色器之前，其值将以透视正确的方式在多边形的面上进行插值。
- en: Finally, the vertex shader transforms the position into clip coordinates, and
    assigns the result to the built-in output variable `gl_Position` (refer to the
    D*iffuse and per-vertex shading with a single point light source* recipe in this
    chapter).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，顶点着色器将位置转换为裁剪坐标，并将结果分配给内置输出变量`gl_Position`（参考本章中的“使用单个点光源进行漫反射和逐顶点着色”配方）。
- en: The fragment shader simply applies the interpolated value of `LightIntensity`
    to the output fragment by storing it in the shader output variable `FragColor`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器简单地将`LightIntensity`插值后的值应用到输出片段上，通过将其存储在着色器输出变量`FragColor`中。
- en: There's more...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Phong reflection model works quite well, but has some drawbacks. A slight
    change to the model, introduced by James Blinn, is more commonly used in practice.
    The Blinn-Phong model replaces the vector of pure reflection with the so-called
    *halfway vector*, and produces specular highlights that have been shown to be
    more realistic. This model is discussed in *The Blinn-Phong reflection model* recipe
    in [Chapter 4](343fbd70-0012-4449-afe6-a724b330b441.xhtml), *Lighting and Shading*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Phong反射模型工作得相当好，但也有一些缺点。James Blinn对该模型进行的一小改动在实践中更常用。Blinn-Phong模型用所谓的**半程向量**替换了纯反射向量，并产生了更真实的光泽高光。该模型在[第4章](343fbd70-0012-4449-afe6-a724b330b441.xhtml)的“Blinn-Phong反射模型”配方中进行了讨论，位于“光照与着色”部分。
- en: Using a nonlocal viewer
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用非局部观察者
- en: We can avoid the extra normalization needed to compute the vector towards the
    viewer (`v`) by using a so-called **nonlocal viewer**. Instead of computing the
    direction toward the origin, we simply use the constant vector (0, 0, 1) for all
    vertices. Of course, it is not accurate, but in practice the visual results are
    very similar, often visually indistinguishable, saving us one normalization.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用所谓的**非局部观察者**来避免计算指向观察者的向量（`v`）所需的额外归一化。我们不是计算指向原点的方向，而是简单地为所有顶点使用常量向量（0，0，1）。当然，这并不准确，但在实践中，视觉结果非常相似，通常在视觉上无法区分，这为我们节省了一次归一化。
- en: Per-vertex versus per-fragment
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐顶点与逐片段
- en: Since the shading equation is computed within the vertex shader, we refer to
    this as **per-vertex shading**. Per-vertex shading is also called **Gouraud shading**.
    One of the disadvantages of this is that specular highlights can be warped or
    lost, due to the fact that the shading equation is not evaluated at each point
    across the face.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于着色方程是在顶点着色器内计算的，我们将其称为**逐顶点着色**。逐顶点着色也称为**Gouraud着色**。这种方法的缺点之一是镜面高光可能会扭曲或丢失，因为着色方程并没有在多边形面上的每个点进行评估。
- en: For example, a specular highlight that should appear in the middle of a polygon
    might not appear at all when per-vertex shading is used, because of the fact that
    the shading equation is only computed at the vertices where the specular component
    is near zero. In the *Using per-fragment shading for improved realism* recipe
    of [Chapter 4](343fbd70-0012-4449-afe6-a724b330b441.xhtml), *Lighting and Shading*,
    we'll look at the changes needed to move the shading computation into the fragment
    shader, producing more realistic results.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个应该在多边形中间出现的镜面高光，当使用逐顶点着色时可能根本不会出现，这是因为着色方程仅在镜面分量接近零的顶点处计算。在[第4章](343fbd70-0012-4449-afe6-a724b330b441.xhtml)的“使用逐片段着色以增强真实感”配方中，我们将在“光照与着色”部分查看将着色计算移动到片段着色器所需的更改，以产生更真实的结果。
- en: Directional lights
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方向性光源
- en: We can also avoid the need to compute a light direction (`s`) for each vertex
    if we assume a directional light. A **directional light source** is one that has
    no position, only a direction. Instead of computing the direction towards the
    source for each vertex, a constant vector is used, which represents the direction
    towards the remote light source. This is a good way to model lighting from distant
    sources such as sunlight. We'll look at an example of this in the *Shading with
    a directional light source* recipe of [Chapter 4](343fbd70-0012-4449-afe6-a724b330b441.xhtml),
    *Lighting and Shading*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设存在一个方向性光源，我们也可以避免为每个顶点计算一个光方向（`s`）。一个**方向性光源**没有位置，只有方向。我们不需要为每个顶点计算指向源的方向，而是使用一个常量向量，它表示指向远程光源的方向。这是一种模拟来自远距离光源（如阳光）照明的良好方法。我们将在第4章的*使用方向性光源进行着色*配方中看到这个例子，*光照与着色*。
- en: Light attenuation with distance
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 距离衰减
- en: You might think that this shading model is missing one important component.
    It doesn't take into account the effect of the distance to the light source. In
    fact, it is known that the intensity of radiation from a source falls off in proportion
    to the inverse square of the distance from the source. So why not include this
    in our model?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这个着色模型缺少一个重要的组件。它没有考虑到光源距离的影响。事实上，已知从源发出的辐射强度与源距离的平方成反比。那么为什么不在我们的模型中包含这个呢？
- en: It would be fairly simple to do so, however, the visual results are often less
    than appealing. It tends to exaggerate the distance effects and create unrealistic-looking
    images. Remember, our equation is just an approximation of the physics involved
    and is not a truly realistic model, so it is not surprising that adding a term
    based on a strict physical law produces unrealistic results.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做相当简单，但视觉结果往往不尽如人意。它往往会夸大距离效果，并创建出看起来不真实的效果。记住，我们的方程只是对涉及的物理的近似，并不是一个真正现实的模型，所以基于严格的物理定律添加的项产生不真实的结果并不令人惊讶。
- en: In the OpenGL fixed-function pipeline, it was possible to turn on distance attenuation
    using the `glLight` function. If desired, it would be straightforward to add a
    few uniform variables to our shader to produce the same effect.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL固定功能管道中，可以使用`glLight`函数打开距离衰减。如果需要，可以简单地添加几个统一变量到我们的着色器中，以产生相同的效果。
- en: See also
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter03/scenephong.cpp` file in the example code
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter03/scenephong.cpp`文件
- en: The *Shading with a directional light source* recipe in [Chapter 4](343fbd70-0012-4449-afe6-a724b330b441.xhtml),
    **Lighting and Shading**
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4章中*使用方向性光源进行着色*配方，**光照与着色**。
- en: The *Using per-fragment shading for improved realism* recipe in [Chapter 4](343fbd70-0012-4449-afe6-a724b330b441.xhtml),
    *Lighting and Shading*
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4章中*使用每片段着色提高真实感*配方，*光照与着色*。
- en: The *Using the Blinn-Phong model* recipe in [Chapter 4](343fbd70-0012-4449-afe6-a724b330b441.xhtml), *Lighting
    and Shading*
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4章中*使用Blinn-Phong模型*配方，*光照与着色*。
- en: Using functions in shaders
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在着色器中使用函数
- en: The GLSL supports functions that are syntactically similar to C functions. However,
    the calling conventions are somewhat different. In the following example, we'll
    revisit the Phong shader using functions to help provide abstractions for the
    major steps.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL支持与C函数语法相似的函数。然而，调用约定有所不同。在下面的例子中，我们将使用函数重新审视Phong着色器，以帮助提供主要步骤的抽象。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As with previous recipes, provide the vertex position at attribute location
    0 and the vertex normal at attribute location 1\. Uniform variables for all of
    the Phong coefficients should be set from the OpenGL side, as well as the light
    position and the standard matrices.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的配方一样，在属性位置0提供顶点位置，在属性位置1提供顶点法线。所有Phong系数的统一变量应从OpenGL端设置，以及光的位置和标准矩阵。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The vertex shader is nearly identical to the one from the previous recipe,
    except that the Phong model is evaluated within a function, and we add another
    function to convert the position and the normal to camera coordinates:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器几乎与之前的配方相同，除了Phong模型在函数内评估，我们添加另一个函数将位置和法线转换为相机坐标：
- en: '[PRE4]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The fragment shader has no changes from the previous recipe.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器与之前的配方没有变化。
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In GLSL functions, the parameter evaluation strategy is **call by value-return** (also
    called **call by copy-restore** or **call by value-result**). Parameter variables
    can be qualified with `in`, `out`, or `inout`. Arguments corresponding to input
    parameters (those qualified with `in` or `inout`) are copied into the parameter
    variable at call time, and output parameters (those qualified with `out` or `inout`)
    are copied back to the corresponding argument before the function returns. If
    a parameter variable does not have any of the three qualifiers, the default qualifier
    is `in`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在GLSL函数中，参数评估策略是**按值返回调用**（也称为**按值复制-恢复**或**按值结果**）。参数变量可以用`in`、`out`或`inout`进行限定。对应于输入参数（用`in`或`inout`限定的参数）在调用时复制到参数变量中，输出参数（用`out`或`inout`限定的参数）在函数返回前复制回相应的参数。如果一个参数变量没有这三个限定符中的任何一个，则默认限定符是`in`。
- en: We've created two functions in the vertex shader. The first, named `getCamSpace`,
    transforms the vertex position and vertex normal into camera coordinates, and
    returns them via output parameters. In the `main` function, we create two uninitialized
    variables (`camNorm` and `camPosition`) to store the results, and then call the
    function with the variables as the function's arguments. The function stores the
    results into the parameter variables (`n` and `position`) which are copied into
    the arguments before the function returns.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在顶点着色器中创建了两个函数。第一个，命名为`getCamSpace`，将顶点位置和顶点法线转换成相机坐标，并通过输出参数返回它们。在`main`函数中，我们创建了两个未初始化的变量（`camNorm`和`camPosition`）来存储结果，然后以变量作为函数参数调用该函数。函数将结果存储到参数变量（`n`和`position`）中，这些变量在函数返回前被复制到参数中。
- en: The second function, `phongModel`, uses only input parameters. The function
    receives the eye-space position and normal, and computes the result of the Phong
    reflection model. The result is returned by the function and stored in the shader
    output variable `LightIntensity`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数`phongModel`仅使用输入参数。该函数接收眼睛空间的位置和法线，并计算Phong反射模型的结果。结果由函数返回并存储在着色器输出变量`LightIntensity`中。
- en: There's more...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: Since it makes no sense to read from an output parameter variable, output parameters
    should only be written to within the function. Their value is undefined.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从输出参数变量读取没有意义，输出参数只应在函数内部进行写入。它们的值是未定义的。
- en: Within a function, writing to an input-only parameter (qualified with `in`)
    is allowed. The function's copy of the argument is modified, and changes are not
    reflected in the argument.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，允许写入仅输入参数（用`in`限定）。函数的参数副本被修改，并且更改不会反映在参数中。
- en: The const qualifier
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`const`限定符'
- en: The additional qualifier `const` can be used with input-only parameters (not
    with `out` or `inout`). This qualifier makes the input parameter read-only, so
    it cannot be written to within the function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将`const`限定符与仅输入参数（不是`out`或`inout`）一起使用。此限定符使输入参数为只读，因此在函数内部不能对其进行写入。
- en: Function overloading
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数重载
- en: Functions can be overloaded by creating multiple functions with the same name,
    but with a different number and/or type of parameters. As with many languages,
    two overloaded functions may not differ in return type only.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建具有相同名称但参数数量和/或类型不同的多个函数，可以重载函数。与许多语言一样，两个重载的函数可能不仅仅在返回类型上有所不同。
- en: Passing arrays or structures to a function
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数组或结构传递给函数
- en: It should be noted that when passing arrays or structures to functions, they
    are passed by value. If a large array or structure is passed, it can incur a large
    copy operation, which may not be desired. It would be a better choice to declare
    these variables in the global scope.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，当将数组或结构传递给函数时，它们是按值传递的。如果传递大数组或结构，可能会进行大量的复制操作，这可能不是所希望的。将这些变量声明在全局作用域中会是一个更好的选择。
- en: See also
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter03/shader/function.vert.glsl` and `chapter03/shader/function.frag.glsl` files
    in the example code
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter03/shader/function.vert.glsl`和`chapter03/shader/function.frag.glsl`文件
- en: The *Implementing the Phong reflection model* recipe
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现Phong反射模型*的配方'
- en: Implementing two-sided shading
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现双面着色
- en: When rendering a mesh that is completely closed, the back faces of polygons
    are hidden. However, if a mesh contains holes, it might be the case that the back
    faces would become visible. In this case, the polygons may be shaded incorrectly
    due to the fact that the normal vector is pointing in the wrong direction. To
    properly shade those back faces, one needs to invert the normal vector and compute
    the lighting equations based on the inverted normal.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染一个完全封闭的网格时，多边形的背面会被隐藏。然而，如果一个网格包含孔洞，背面可能会变得可见。在这种情况下，由于法向量指向错误的方向，多边形可能会被错误着色。为了正确着色这些背面，需要反转法向量并基于反转后的法向量计算光照方程。
- en: 'The following image shows a teapot with the lid removed. On the left, the Phong
    model is used. On the right, the Phong model is augmented with the two-sided rendering
    technique discussed in this recipe:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了一个去掉盖子的茶壶。在左侧，使用Phong模型。在右侧，Phong模型增加了本配方中讨论的双面渲染技术：
- en: '![](img/f09a8b43-dc22-49e7-8435-999064553601.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f09a8b43-dc22-49e7-8435-999064553601.png)'
- en: In this recipe, we'll look at an example that uses the Phong model discussed
    in the previous recipes, augmented with the ability to correctly shade back faces.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将查看一个示例，该示例使用前面配方中讨论的Phong模型，并增加了正确着色背面面的能力。
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The vertex position should be provided in attribute location 0 and the vertex
    normal in attribute location 1\. As in the previous examples, the lighting parameters
    must be provided to the shader via uniform variables.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点位置应提供在属性位置0，顶点法向量在属性位置1。与前面的示例一样，必须通过统一变量将光照参数提供给着色器。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To implement a shader pair that uses the Phong reflection model with two-sided
    lighting, take the following steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个使用具有双面光照的Phong反射模型的着色器对，请按照以下步骤操作：
- en: 'The vertex shader is similar to the one in the previous recipe, except that
    it computes the Phong equation twice. First, without any change to the normal
    vector, and again with the normal inverted. The results are stored in output variables
    `FrontColor` and `BackColor`, respectively:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点着色器与前面的配方类似，但它计算了两次Phong方程。首先，不改变法向量，然后再次反转法向量。结果分别存储在输出变量`FrontColor`和`BackColor`中：
- en: '[PRE5]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The fragment shader chooses which color to use based on the value of the built-in `gl_FrontFacing` variable:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 片段着色器根据内置变量`gl_FrontFacing`的值选择使用哪种颜色：
- en: '[PRE6]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the vertex shader, we compute the lighting equation using both the vertex
    normal and the inverted version, and pass each color to the fragment shader. The
    fragment shader chooses and applies the appropriate color depending on the orientation
    of the face.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器中，我们使用顶点法向量和反转后的版本来计算光照方程，并将每个颜色传递给片段着色器。片段着色器根据面的方向选择并应用适当的颜色。
- en: The evaluation of the reflection model is placed within a function named `phongModel`.
    The function is called twice, first using the normal vector (transformed into
    camera coordinates), and second using the inverted normal vector. The combined
    results are stored in `FrontColor` and `BackColor`, respectively.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 反射模型的评估被放置在一个名为`phongModel`的函数中。该函数被调用两次，首先使用法向量（转换为相机坐标），然后使用反转后的法向量。组合结果分别存储在`FrontColor`和`BackColor`中。
- en: There are a few aspects of the shading model that are independent of the orientation
    of the normal vector (such as the ambient component). One could optimize this
    code by rewriting it so that the redundant calculations are only done once. However,
    in this recipe, we compute the entire shading model twice in the interest of making
    things clear and readable.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 着色模型的一些方面（如环境分量）与法向量的方向无关。可以通过重写代码来优化此代码，以便冗余计算只进行一次。然而，在这个配方中，为了使事情清晰易读，我们两次计算整个着色模型。
- en: In the fragment shader, we determine which color to apply based on the value
    of the built-in variable `gl_FrontFacing`.  This is a Boolean value that indicates
    whether the fragment is part of a front- or back-facing polygon. Note that this
    determination is based on the **winding** of the polygon, and not the normal vector.
    (A polygon is said to have counterclockwise winding if the vertices are specified
    in counterclockwise order, as viewed from the front side of the polygon.) By default,
    when rendering, if the order of the vertices appear on the screen in a counterclockwise
    order, it indicates a front-facing polygon, however, we can change this by calling
    `glFrontFace` from the OpenGL program.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，我们根据内置变量 `gl_FrontFacing` 的值来确定应用哪种颜色。这是一个布尔值，表示片段是否是正面或背面多边形的一部分。请注意，这种判断是基于多边形的**方向**，而不是法向量。（如果一个多边形的顶点按逆时针顺序指定，从多边形的前面看，则称该多边形为逆时针方向。）默认情况下，在渲染时，如果顶点的顺序在屏幕上以逆时针顺序出现，则表示这是一个正面多边形；然而，我们可以通过从
    OpenGL 程序中调用 `glFrontFace` 来改变这一点。
- en: There's more...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the vertex shader, we determine the front side of the polygon by the direction
    of the normal vector, and in the fragment shader, the determination is based on
    the polygon's winding. For this to work properly, the normal vector must be defined
    appropriately for the face determined by the setting of `glFrontFace`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器中，我们通过法向量的方向来确定多边形的正面，而在片段着色器中，判断是基于多边形的方向。为了正确工作，必须适当地为 `glFrontFace`
    设置确定的表面定义法向量。
- en: An alternative choice for this recipe would be to determine whether the face
    being shaded is a front or back face first in the vertex shader, and send only
    a single result to the fragment shader. One way to do this would be to compute
    the dot product between a vector pointing towards the camera (the origin in camera
    coordinates), and the normal. If the dot product is negative, then the normal
    must be pointing away from the viewer, meaning that the viewer is seeing the back
    side of the face.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方的一个替代选择是在顶点着色器中首先确定正在着色的表面是正面还是背面，然后只将单个结果发送到片段着色器。一种方法是通过计算指向摄像机的向量（在摄像机坐标中的原点）与法向量的点积。如果点积为负，则表示法向量必须是指向观察者的，这意味着观察者看到的是表面的背面。
- en: 'In which case, we invert the normal. Specifically, we could change the main
    function in the vertex shader as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要反转法向量。具体来说，我们可以将顶点着色器中的主函数更改如下：
- en: '[PRE7]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, we only need a single output variable to send to the fragment
    shader (`Color`, in the preceding code), and the fragment shader simply applies
    the color to the fragment. In this version, there's no need to check the value
    of `gl_FrontFacing` in the fragment shader.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只需要一个输出变量发送到片段着色器（在前面代码中的 `Color`），片段着色器只需将颜色应用到片段上。在这个版本中，在片段着色器中不需要检查
    `gl_FrontFacing` 的值。
- en: In this version, the only thing that is used to determine whether or not it
    is a front face is the normal vector. The polygon winding is not used. If the
    normals at the vertices of a polygon are not parallel (which is often the case
    for curved shapes), then it may be the case that some vertices are treated as
    *front* and others are treated as *back*. This has the potential of producing
    unwanted artifacts as the color is blended across the face. It would be better
    to compute all of the reflection model in the fragment shader, as is common practice
    these days. See the *Using per-fragment shading for improved realism* recipe in [Chapter
    4](343fbd70-0012-4449-afe6-a724b330b441.xhtml), *Lighting and Shading*, for details
    about per-fragment shading.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，用来确定是否为正面多边形的唯一因素是法向量。不使用多边形方向。如果一个多边形的顶点法线不平行（对于弯曲形状通常是这种情况），那么可能某些顶点被处理为**正面**，而其他顶点被处理为**背面**。这可能导致在表面颜色混合时产生不希望出现的伪影。最好是像现在常见的做法一样，在片段着色器中计算整个反射模型。有关逐片段着色的详细信息，请参阅第
    4 章*使用逐片段着色提高真实感*的配方，*光照与着色*。
- en: Using two-sided rendering for debugging
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用双面渲染进行调试
- en: 'It can sometimes be useful to visually determine which faces are front-facing
    and which are back-facing (based on winding). For example, when working with arbitrary
    meshes, polygons may not be specified using the appropriate winding. As another
    example, when developing a mesh procedurally, it can sometimes be helpful to determine
    which faces have proper winding in order to help with debugging. We can easily
    tweak our fragment shader to help us solve these kinds of problems by mixing a
    solid color with all back (or front) faces. For example, we could change the `else`
    clause within our fragment shader to the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，通过视觉确定哪些面是正面和哪些是背面（基于环绕顺序）可能很有用。例如，当处理任意网格时，多边形可能没有使用适当的环绕顺序指定。作为另一个例子，当以程序方式开发网格时，有时确定哪些面具有适当的环绕顺序可能有助于调试。我们可以轻松调整我们的片段着色器，通过将纯色与所有背面（或正面）混合来帮助我们解决这类问题。例如，我们可以在片段着色器中的`else`子句中更改如下：
- en: '[PRE8]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This would mix a solid red color with all back faces, helping them stand out,
    as shown in the following image. In the image, back faces are mixed with 70 percent
    red, as shown in the preceding code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将混合一个纯红色与所有背面，使它们突出，如下面的图像所示。在图像中，背面与70%的红色混合，如前面的代码所示：
- en: '![](img/b57cf931-dad2-40a2-97fb-df90eeb9a5e6.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b57cf931-dad2-40a2-97fb-df90eeb9a5e6.png)'
- en: See also
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter03/scenetwoside.cpp` file in the example code
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter03/scenetwoside.cpp`文件
- en: The *Implementing the Phong reflection model* recipe
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现Phong反射模型*配方'
- en: '*Using per-fragment shading for improved realism* in [Chapter 4](343fbd70-0012-4449-afe6-a724b330b441.xhtml), *Lighting
    and Shading*'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在第四章*（343fbd70-0012-4449-afe6-a724b330b441.xhtml）*光照和着色*中，*如何实现使用每个片段着色提高现实感*'
- en: Implementing flat shading
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现平面着色
- en: Per-vertex shading involves computation of the shading model at each vertex
    and associating the result (a color) with that vertex. The colors are then interpolated
    across the face of the polygon to produce a smooth shading effect. This is also
    referred to as **Gouraud shading**. In earlier versions of OpenGL, this per-vertex
    shading with color interpolation was the default shading technique.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每个顶点着色涉及在每个顶点计算着色模型，并将结果（颜色）与该顶点关联。然后，颜色在多边形的面上进行插值，以产生平滑的着色效果。这也被称为**Gouraud着色**。在OpenGL的早期版本中，这种带有颜色插值的每个顶点着色是默认的着色技术。
- en: It is sometimes desirable to use a single color for each polygon so that there
    is no variation of color across the face of the polygon, causing each polygon
    to have a flat appearance. This can be useful in situations where the shape of
    the object warrants such a technique, perhaps because the faces really are intended
    to look flat, or to help visualize the locations of the polygons in a complex
    mesh. Using a single color for each polygon is commonly called **flat shading**.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，为了使每个多边形使用单一颜色，以便在整个多边形面上没有颜色变化，从而使每个多边形看起来是平面的，这可能是有用的。这在物体形状需要这种技术的情况下可能很有用，例如，因为面确实打算看起来是平面的，或者有助于在复杂网格中可视化多边形的定位。每个多边形使用单一颜色通常称为**平面着色**。
- en: 'The following image shows a mesh rendered with the Phong reflection model.
    On the left, Gouraud shading is used. On the right, flat shading is used:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了使用Phong反射模型渲染的网格。在左侧，使用Gouraud着色。在右侧，使用平面着色：
- en: '![](img/0316c524-3878-496c-9a90-008e3f9963f3.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0316c524-3878-496c-9a90-008e3f9963f3.png)'
- en: In earlier versions of OpenGL, flat shading was enabled by calling the function
    `glShadeModel` with the argument `GL_FLAT`, in which case the computed color of
    the last vertex of each polygon was used across the entire face.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL的早期版本中，通过调用`glShadeModel`函数并使用参数`GL_FLAT`来启用平面着色，在这种情况下，每个多边形的最后一个顶点的计算颜色在整个面上使用。
- en: In OpenGL 4, flat shading is facilitated by the interpolation qualifiers available
    for shader input/output variables.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL 4中，平面着色通过着色器输入/输出变量的可用插值限定符得到简化。
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To modify the Phong reflection model to use flat shading, take the following
    steps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Phong反射模型修改为使用平面着色，请执行以下步骤：
- en: 'Use the same vertex shader as in the Phong example provided earlier. Change
    the output variable `LightIntensity` as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与前面提供的Phong示例相同的顶点着色器。按照以下方式更改输出变量`LightIntensity`：
- en: '[PRE9]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Change the corresponding variable in the fragment shader to use the `flat`
    qualifier:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将片段着色器中的相应变量更改为使用`flat`限定符：
- en: '[PRE10]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Compile and link both shaders within the OpenGL application, and install the
    shader program prior to rendering.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenGL应用程序中编译和链接两个着色器，并在渲染之前安装着色程序。
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Flat shading is enabled by qualifying the vertex output variable (and its corresponding
    fragment input variable) with the `flat` qualifier. This qualifier indicates that
    no interpolation of the value is to be done before it reaches the fragment shader.
    The value presented to the fragment shader will be the one corresponding to the
    result of the invocation of the vertex shader for either the first or last vertex
    of the polygon. This vertex is called the **provoking vertex**, and can be configured
    using the OpenGL function `glProvokingVertex`. For example, the following call:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `flat` 修饰符来指定顶点输出变量（及其对应的片段输入变量），启用平面着色。此修饰符表示在值到达片段着色器之前不应进行插值。提供给片段着色器的值将是与多边形的第一个或最后一个顶点的顶点着色器调用结果相对应的值。这个顶点被称为
    **触发顶点**，可以使用OpenGL函数 `glProvokingVertex` 进行配置。例如，以下调用：
- en: '[PRE11]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Indicates that the first vertex should be used as the value for the flat-shaded
    variable. The `GL_LAST_VERTEX_CONVENTION` argument indicates that the last vertex
    should be used. The default value is `GL_LAST_VERTEX_CONVENTION`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 表示第一个顶点应作为平面着色变量的值。`GL_LAST_VERTEX_CONVENTION` 参数表示应使用最后一个顶点。默认值是 `GL_LAST_VERTEX_CONVENTION`。
- en: See also
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter03/sceneflat.cpp` file in the example code
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的 `chapter03/sceneflat.cpp` 文件
- en: The *Implementing the Phong reflection model* recipe
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现Phong反射模型* 的配方'
- en: Using subroutines to select shader functionality
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用子例程选择着色器功能
- en: In GLSL, a subroutine is a mechanism for binding a function call to one of a
    set of possible function definitions based on the value of a variable. In many
    ways, it is similar to function pointers in C. A uniform variable serves as the
    pointer and is used to invoke the function. The value of this variable can be
    set from the OpenGL side, thereby binding it to one of a few possible definitions.
    The subroutine's function definitions need not have the same name, but must have
    the same number and type of parameters and the same return type.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在GLSL中，子例程是一种将函数调用绑定到一组可能的函数定义之一（基于变量的值）的机制。在许多方面，它类似于C中的函数指针。统一变量作为指针，用于调用函数。该变量的值可以从OpenGL端设置，从而将其绑定到几个可能的定义之一。子例程的函数定义不需要具有相同的名称，但必须具有相同数量和类型的参数以及相同的返回类型。
- en: Subroutines therefore provide a way to select alternative implementations at
    runtime without swapping shader programs and/or recompiling, or using the `if`
    statements along with a uniform variable. For example, a single shader could be
    written to provide several shading algorithms intended for use on different objects
    within the scene. When rendering the scene, rather than swapping shader programs
    or using a conditional statement, we can simply change the subroutine's uniform
    variable to choose the appropriate shading algorithm as each object is rendered.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，子例程提供了一种在运行时选择替代实现的方法，而无需交换着色程序和/或重新编译，或使用与统一变量一起的 `if` 语句。例如，可以编写一个着色器，提供几个用于场景中不同对象的着色算法。在渲染场景时，而不是交换着色程序或使用条件语句，我们可以简单地更改子例程的统一变量，以在每个对象渲染时选择适当的着色算法。
- en: Since performance is crucial in shader programs, avoiding a conditional statement
    or a shader swap may be valuable. With subroutines, we can implement the functionality
    of a conditional statement or shader swap without the computational overhead.
    However, modern drivers do a good job of handling conditionals, so the benefits of
    subroutines over conditionals is not always clear-cut. Depending on the condition,
    conditional statements based on uniform variables can be as efficient as subroutines.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于着色程序中的性能至关重要，避免条件语句或着色程序交换可能很有价值。使用子例程，我们可以实现条件语句或着色程序交换的功能，而无需计算开销。然而，现代驱动程序在处理条件语句方面做得很好，因此子例程相对于条件语句的优势并不总是明确的。根据条件，基于统一变量的条件语句可以与子例程一样高效。
- en: In this example, we'll demonstrate the use of subroutines by rendering a teapot
    twice. The first teapot will be rendered with the full Phong reflection model
    described earlier. The second teapot will be rendered with diffuse shading only.
    A subroutine uniform will be used to choose between the two shading techniques.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将通过渲染茶壶两次来演示子例程的使用。第一个茶壶将使用前面描述的完整Phong反射模型进行渲染。第二个茶壶将只使用漫反射着色。将使用子例程统一变量来在两种着色技术之间进行选择。
- en: '**Subroutines are not supported in SPIR-V**. Therefore, their use should probably
    be avoided. Since SPIR-V is evidently the future of shaders in OpenGL, subroutines
    should be considered deprecated.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**SPIR-V不支持子例程**。因此，可能应该避免使用它们。由于SPIR-V显然是OpenGL中着色器的未来，子例程应被视为已弃用。'
- en: 'In the following image, we can see an example of a rendering that was created
    using subroutines. The teapot on the left is rendered with the full Phong reflection model,
    and the teapot on the right is rendered with diffuse shading only. A subroutine
    is used to switch between shader functionality:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，我们可以看到一个使用子例程创建的渲染示例。左边的茶壶使用完整的Phong反射模型进行渲染，而右边的茶壶仅使用漫反射着色进行渲染。子例程用于在着色器功能之间切换：
- en: '![](img/c0c7d649-c7a9-4d04-9e24-6581420ee598.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0c7d649-c7a9-4d04-9e24-6581420ee598.png)'
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As with the previous recipes, provide the vertex position at attribute location
    0 and the vertex normal at attribute location 1\. Uniform variables for all of
    the Phong coefficients should be set from the OpenGL side, as well as the light
    position and the standard matrices.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的食谱一样，在属性位置0提供顶点位置，在属性位置1提供顶点法线。所有Phong系数的统一变量应从OpenGL端设置，以及光的位置和标准矩阵。
- en: We'll assume that, in the OpenGL application, the `programHandle` variable contains
    the handle to the shader program object.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设在OpenGL应用程序中，`programHandle`变量包含着色器程序对象的句柄。
- en: How to do it...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a shader program that uses a subroutine to switch between pure-diffuse
    and Phong, take the following steps:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个使用子例程在纯漫反射和Phong之间切换的着色器程序，请执行以下步骤：
- en: 'Set up the vertex shader with a subroutine uniform variable, and two functions
    of the subroutine type:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用子例程统一变量设置顶点着色器，并声明两个子例程类型的函数：
- en: '[PRE12]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The fragment shader is the same as the one in* The Phong reflection model* recipe.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 片段着色器与*《Phong反射模型》*食谱中的相同。
- en: In the OpenGL application, compile and link the shaders into a shader program,
    and install the program into the OpenGL pipeline.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenGL应用程序中，编译和链接着色器到着色器程序中，并将程序安装到OpenGL管道中。
- en: 'Within the render function of the OpenGL application, use the following code:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenGL应用程序的渲染函数中，使用以下代码：
- en: '[PRE13]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this example, the subroutine is defined within the vertex shader. The first
    step involves declaring the subroutine type, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，子例程是在顶点着色器中定义的。第一步是声明子例程类型，如下所示：
- en: '[PRE14]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This defines a new subroutine type with the name `shadeModelType`. The syntax
    is very similar to a function prototype, in that it defines a name, a parameter
    list, and a return type. As with function prototypes, the parameter names are
    optional.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个名为`shadeModelType`的新子例程类型。其语法与函数原型非常相似，因为它定义了一个名称、一个参数列表和一个返回类型。与函数原型一样，参数名称是可选的。
- en: 'After creating the new subroutine type, we declare a uniform variable of that
    type named `shadeModel`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新的子例程类型后，我们声明一个名为`shadeModel`的该类型统一变量：
- en: '[PRE15]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This variable serves as our function pointer and will be assigned to one of
    the two possible functions in the OpenGL application.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此变量作为我们的函数指针，并将分配给OpenGL应用程序中的两个可能函数之一。
- en: 'We declare two functions to be part of the subroutine by prefixing their definition
    with the subroutine qualifier:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在函数定义前加上子例程限定符来声明两个函数是子例程的一部分：
- en: '[PRE16]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This indicates that the function matches the subroutine type, and therefore
    its header must match the one in the subroutine type definition. We use this prefix
    for the definition of the functions `phongModel` and `diffuseOnly`. The `diffuseOnly`
    function computes the diffuse shading equation, and the `phongModel` function
    computes the complete Phong reflection equation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示该函数与子例程类型匹配，因此其头文件必须与子例程类型定义中的头文件相匹配。我们使用此前缀来定义`phongModel`和`diffuseOnly`函数。`diffuseOnly`函数计算漫反射着色方程，而`phongModel`函数计算完整的Phong反射方程。
- en: 'We call one of the two subroutine functions by utilizing the subroutine uniform
    `shadeModel` within the main function:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在主函数中利用子例程统一的`shadeModel`来调用这两个子例程函数之一：
- en: '[PRE17]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Again, this call will be bound to one of the two functions depending on the
    value of the subroutine uniform `shadeModel`, which we will set within the OpenGL
    application.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这个调用将绑定到两个函数之一，具体取决于子例程统一变量`shadeModel`的值，我们将在OpenGL应用程序中设置它。
- en: 'Within the render function of the OpenGL application, we assign a value to
    the subroutine uniform with the following two steps:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL应用程序的渲染函数中，我们通过以下两个步骤给子例程统一变量赋值：
- en: First, we query for the index of each subroutine function using `glGetSubroutineIndex`.
    The first argument is the program handle. The second is the shader stage. In this
    case, the subroutine is defined within the vertex shader, so we use `GL_VERTEX_SHADER`
    here. The third argument is the name of the subroutine. We query for each function
    individually and store the indexes in the variables `phongIndex` and `diffuseIndex`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用`glGetSubroutineIndex`查询每个子例程函数的索引。第一个参数是程序句柄。第二个是着色器阶段。在这种情况下，子例程是在顶点着色器中定义的，所以我们在这里使用`GL_VERTEX_SHADER`。第三个参数是子例程的名称。我们单独查询每个函数，并将索引存储在变量`phongIndex`和`diffuseIndex`中。
- en: Second, we select the appropriate subroutine function. To do so, we need to
    set the value of the subroutine uniform `shadeModel` by calling `glUniformSubroutinesuiv`.
    This function is designed for setting multiple subroutine uniforms at once. In
    our case, of course, we are setting only a single uniform. The first argument
    is the shader stage (`GL_VERTEX_SHADER`), the second is the number of uniforms
    being set, and the third is a pointer to an array of subroutine function indexes.
    Since we are setting a single uniform, we simply provide the address of the `GLuint`
    variable containing the index, rather than a true array of values. Of course,
    we would use an array if multiple uniforms were being set. In general, the array
    of values provided as the third argument is assigned to subroutine uniform variables
    in the following way. The i^(th) element of the array is assigned to the subroutine
    uniform variable with index i. Since we have provided only a single value, we
    are setting the subroutine uniform at index zero.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二，我们选择合适的子例程函数。为此，我们需要通过调用`glUniformSubroutinesuiv`来设置子例程的统一变量`shadeModel`的值。这个函数是为了一次性设置多个子例程统一变量而设计的。在我们的情况下，当然我们只设置了一个统一变量。第一个参数是着色器阶段（`GL_VERTEX_SHADER`），第二个是设置的统一变量数量，第三个是指向包含子例程函数索引数组的指针。由于我们只设置了一个统一变量，我们只需提供包含索引的`GLuint`变量的地址，而不是一个真正的值数组。当然，如果设置了多个统一变量，我们会使用一个数组。一般来说，提供的第三个参数的值数组以以下方式分配给子例程统一变量。数组的第i个元素分配给索引为i的子例程统一变量。由于我们只提供了一个值，我们正在设置索引为零的子例程统一变量。
- en: You may be wondering, "How do we know that our subroutine uniform is located
    at index zero? We didn't query for the index before calling `glUniformSubroutinesuiv`!"
    The reason that this code works is that we are relying on the fact that OpenGL
    will always number the indexes of the subroutines consecutively starting at zero.
    If we had multiple subroutine uniforms, we could (and should) query for their
    indexes using `glGetSubroutineUniformLocation`, and then order our array appropriately.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“我们怎么知道我们的子例程统一变量位于索引零？我们在调用`glUniformSubroutinesuiv`之前没有查询索引！”这个代码之所以能工作，是因为我们依赖于OpenGL将始终从零开始连续编号子例程的索引。如果我们有多个子例程统一变量，我们可以（并且应该）使用`glGetSubroutineUniformLocation`查询它们的索引，然后适当地排序我们的数组。
- en: '`glUniformSubroutinesuiv` requires us to set `all` subroutine uniform variables
    at once, in a single call. This is so that they can be validated by OpenGL in
    a single burst.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`glUniformSubroutinesuiv`要求我们一次性设置所有子例程统一变量，在一个调用中。这样OpenGL就可以在单个爆发中验证它们。'
- en: There's more...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Unfortunately, subroutine bindings get reset when a shader program is unbound
    (switched out) from the pipeline by calling `glUseProgram` or another technique.
    This requires us to call `glUniformSubroutinsuiv` each time that we activate a
    shader program.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当通过调用`glUseProgram`或其他技术从管道中解绑（切换）着色器程序时，子例程绑定会被重置。这要求我们每次激活着色器程序时都调用`glUniformSubroutinesuiv`。
- en: 'A subroutine function defined in a shader can match more than one subroutine
    type. The subroutine qualifier can contain a comma-separated list of subroutine
    types. For example, if a subroutine matched the types `type1` and `type2`, we
    could use the following qualifier:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在着色器中定义的子例程函数可以匹配多个子例程类型。子例程限定符可以包含由逗号分隔的子例程类型列表。例如，如果一个子例程匹配类型`type1`和`type2`，我们可以使用以下限定符：
- en: '[PRE18]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This would allow us to use subroutine uniforms of differing types to refer to
    the same subroutine function.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们使用不同类型的子例程统一变量来引用相同的子例程函数。
- en: See also
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter03/scenesubroutine.cpp` file in the example code
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter03/scenesubroutine.cpp`文件
- en: '*T**he Phong reflection model* recipe'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*菲涅耳反射模型*的配方'
- en: The *Diffuse and per-vertex shading with a single point light source* recipe
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个点光源的*漫反射和顶点着色*配方
- en: Discarding fragments to create a perforated look
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 丢弃片段以创建带有孔洞的外观
- en: Fragment shaders can make use of the `discard` keyword to *throw away* fragments.
    Use of this keyword causes the fragment shader to stop execution, without writing
    anything (including depth) to the output buffer. This provides a way to create
    holes in polygons without using blending. In fact, since fragments are completely
    discarded, there is no dependence on the order in which objects are drawn, saving
    us the trouble of doing any depth sorting that might have been necessary if blending
    was used.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器可以利用`discard`关键字来*丢弃*片段。使用此关键字会导致片段着色器停止执行，而不会将任何内容（包括深度）写入输出缓冲区。这提供了一种在不使用混合的情况下在多边形中创建孔的方法。实际上，由于片段被完全丢弃，因此不依赖于对象绘制的顺序，从而节省了我们可能需要进行的任何深度排序的麻烦。
- en: 'In this recipe, we''ll draw a teapot, and use the `discard` keyword to remove
    fragments selectively, based on texture coordinates. The result will look like
    the following image:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将绘制一个茶壶，并使用`discard`关键字根据纹理坐标选择性地移除片段。结果将看起来像以下图像：
- en: '![](img/600677f4-55bc-481a-9449-b37c1b2bb767.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/600677f4-55bc-481a-9449-b37c1b2bb767.png)'
- en: Getting ready
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The vertex position, normal, and texture coordinates must be provided to the
    vertex shader from the OpenGL application. The position should be provided at
    location 0, the normal at location 1, and the texture coordinates at location
    2\. As in the previous examples, the lighting parameters must be set from the
    OpenGL application via the appropriate uniform variables.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点位置、法线和纹理坐标必须从OpenGL应用程序提供给顶点着色器。位置应提供在位置0，法线在位置1，纹理坐标在位置2。与之前的示例一样，光照参数必须通过适当的统一变量从OpenGL应用程序设置。
- en: How to do it...
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a shader program that discards fragments based on a square lattice
    (as in the preceding image):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个基于正方形晶格（如图像所示）丢弃片段的着色程序：
- en: 'In the vertex shader, we use two-sided lighting, and include the texture coordinate:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶点着色器中，我们使用双面光照，并包含纹理坐标：
- en: '[PRE19]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the fragment shader, discard the fragment based on a certain condition by
    using the `discard` keyword:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在片段着色器中，使用`discard`关键字根据一定条件丢弃片段：
- en: '[PRE20]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Compile and link both shaders within the OpenGL application, and install the
    shader program prior to rendering.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenGL应用程序中编译和链接这两个着色器，并在渲染之前安装着色程序。
- en: How it works...
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Since we will be discarding some parts of the teapot, we will be able to see
    through the teapot to the other side. This will cause the back sides of some polygons
    to become visible. Therefore, we need to compute the lighting equation appropriately
    for both sides of each face. We'll use the same technique presented earlier in
    the two-sided shading recipe.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将丢弃茶壶的一些部分，我们将能够透过茶壶看到另一侧。这将导致一些多边形的背面变得可见。因此，我们需要为每个面的两侧适当地计算光照方程。我们将使用之前在双面着色配方中介绍过的相同技术。
- en: The vertex shader is essentially the same as in the two-sided shading recipe,
    with the main difference being the addition of the texture coordinate. To manage
    the texture coordinate, we have an additional input variable, `VertexTexCoord`,
    that corresponds to attribute location 2\. The value of this input variable is
    passed directly on to the fragment shader unchanged via the output variable `TexCoord`.
    The Phong reflection model is calculated twice, once using the given normal vector,
    storing the result in `FrontColor`, and again using the reversed normal, storing
    that result in `BackColor`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器基本上与双面着色配方相同，主要区别在于增加了纹理坐标。为了管理纹理坐标，我们有一个额外的输入变量，`VertexTexCoord`，它对应于属性位置2。这个输入变量的值直接通过输出变量`TexCoord`传递给片段着色器，且不进行任何改变。波恩反射模型被计算两次，一次使用给定的法向量，将结果存储在`FrontColor`中，再次使用反转的法向量，将结果存储在`BackColor`中。
- en: In the fragment shader, we calculate whether or not the fragment should be discarded
    based on a simple technique designed to produce the lattice-like pattern shown
    in the preceding image. We first scale the texture coordinate by the arbitrary
    scaling factor `scale`. This corresponds to the number of lattice rectangles per
    unit (scaled) texture coordinate. We then compute the fractional part of each
    component of the scaled texture coordinate using the built-in function `fract`.
    Each component is compared to 0.2 using the built-in the `greaterThan` function, and
    the result is stored in the Boolean vector `toDiscard`. The `greaterThan` function
    compares the two vectors component-wise, and stores the Boolean results in the
    corresponding components of the return value.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，我们通过一种简单技术计算是否应该丢弃片段，该技术旨在产生前一幅图像中显示的类似晶格的图案。我们首先将纹理坐标乘以任意缩放因子`scale`。这对应于每个单位（缩放）纹理坐标中的晶格矩形数量。然后，我们使用内置函数`fract`计算缩放纹理坐标每个分量的分数部分。每个分量使用内置的`greaterThan`函数与0.2进行比较，并将结果存储在布尔向量`toDiscard`中。`greaterThan`函数逐分量比较两个向量，并将布尔结果存储在返回值的相应分量中。
- en: If both components of the vector `toDiscard` are true, then the fragment lies
    within the inside of each lattice frame, and therefore we wish to discard this
    fragment. We can use the built-in function `all` to help with this check. The
    function `all` will return true if all of the components of the parameter vector
    are true. If the function returns true, we execute the `discard` statement to
    reject the fragment.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向量`toDiscard`的两个分量都为真，则该片段位于每个晶格框架的内部，因此我们希望丢弃这个片段。我们可以使用内置函数`all`来帮助进行此检查。如果参数向量的所有分量都为真，则`all`函数将返回true。如果函数返回true，则执行`discard`语句以拒绝该片段。
- en: In the `else` branch, we color the fragment based on the orientation of the
    polygon, as in the *Implementing two-sided shading* recipe presented earlier.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在`else`分支中，我们根据多边形的朝向对片段进行着色，正如之前介绍的**实现双面着色**配方中所述。
- en: See also
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter03/scenediscard.cpp` recipe in the example code
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter03/scenediscard.cpp`配方
- en: The *Implementing two-sided shading* recipe in this chapter
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中实现的**双面着色**配方
