- en: C++ as an Embedded Language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++作为嵌入式语言
- en: 'When it comes to embedded development on resource-restricted systems, it is
    still common to consider only C and ASM as viable choices, accompanied by the
    thought that C++ has a larger footprint than C, or adds a significant amount of
    complexity. In this chapter, we will look at all of these issues in detail and
    consider the merits of C++ as an embedded programming language:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到资源受限系统上的嵌入式开发时，仍然普遍认为只有C和ASM是可行的选择，伴随着这样的想法：C++的占用空间比C大，或者增加了显著复杂性。在本章中，我们将详细探讨所有这些问题，并考虑C++作为嵌入式编程语言的优点：
- en: C++ relative to C
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对于C，C++
- en: Advantages of C++ as a multi-paradigm language
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++作为多范式语言的优点
- en: Compatibility with existing C and ASM
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与现有的C和ASM的兼容性
- en: Changes with C++11, C++14, and C++17
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++11、C++14和C++17的变化
- en: C++ relative to C
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相对于C，C++
- en: The lineages of C and C++ both trace their lineage back to the ALGOL programming
    language, which saw its first version in 1958 (ALGOL 58), followed by updates
    in 1960 and 1968\. ALGOL introduced the concept of imperative programming—a programming
    style in which statements explicitly tell the machine how to make changes to data
    for output and control flow.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++的谱系都追溯到ALGOL编程语言，该语言在1958年（ALGOL 58）首次出现，随后在1960年和1968年进行了更新。ALGOL引入了命令式编程的概念——一种编程风格，其中语句明确告诉机器如何更改数据以进行输出和控制流。
- en: A paradigm that emerges rather naturally from imperative programming is the
    use of procedures. We will start with an example, to introduce the terminology.
    Procedures are synonymous to sub-routines and functions. They identify the groups
    of statements and make them self-contained, which has the effects of confining
    the reach of these statements to the limited scope of the section they are contained
    within, creating hierarchy and consequentially introducing these procedures as
    new, more abstract statements. Heavy use of this procedural programming style
    finds its place in so-called structured programming, alongside loop and branching
    control structures.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令式编程中自然出现的范式是过程的使用。我们将从一个例子开始，引入术语。过程与子程序和函数同义。它们标识语句组，使它们自成体系，这有助于将这些语句的范围限制在它们所包含的部分的有限范围内，创建层次结构，并因此将这些过程作为新的、更抽象的语句引入。这种过程式编程风格的过度使用在所谓的结构化编程中找到了其位置，与循环和分支控制结构并列。
- en: Over time, structured and modular programming styles were introduced as techniques
    to improve the development, quality and maintainability of application code. The
    C language is an imperative, structured programming language due to its use of
    statements, control structures and functions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，结构化和模块化编程风格被引入作为提高应用代码开发、质量和可维护性的技术。C语言由于其使用语句、控制结构和函数，是一种命令式、结构化编程语言。
- en: 'Take, for example, the standard Hello World example in C:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以C中的标准Hello World示例为例：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The entry point of any C (and C++) application is the `main()` function (procedure).
    In the first statement line of this function, we call another procedure (`printf()`),
    which contains its own statements and possibly calls other blocks of statements
    in the form of additional functions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 任何C（和C++）应用的入口点是`main()`函数（过程）。在这个函数的第一条语句行中，我们调用另一个过程（`printf()`），它包含自己的语句，并可能以其他函数的形式调用其他语句块。
- en: This way we have already made use of procedural programming by implementing
    a `main()` logical block (the `main()` function), which is called as needed. While
    the `main()` function will just be called once, the procedural style is found
    again in the `printf()` statement, which calls the statements elsewhere in the
    application without having to copy them explicitly. Applying procedural programming
    makes it much easier to maintain the resulting code, and create libraries of code
    that we can use across a number of applications, while maintaining only a single
    code base.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们已经通过实现一个`main()`逻辑块（即`main()`函数）来利用了过程式编程，该函数按需调用。虽然`main()`函数只会被调用一次，但在`printf()`语句中又发现了过程式风格的再次出现，该语句在应用的其他地方调用语句，而无需显式地复制它们。应用过程式编程使得维护生成的代码变得容易得多，并创建我们可以跨多个应用使用的代码库，同时只需维护单个代码库。
- en: 'In 1979, Bjarne Stroustrup started work on *C with Classes*, for which he took
    the existing programming paradigms of C and added elements from other languages,
    in particular Simula (object-oriented programming: both imperative and structured)
    and ML (generic programming, in the form of templates). It would also offer the
    speed of the **Basic Combined Programming Language** (**BCPL**), without restricting
    the developer to its restrictive low-level focus.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1979 年，Bjarne Stroustrup 开始了 *C with Classes* 的工作，他借鉴了 C 的现有编程范式，并从其他语言中添加了元素，特别是
    Simula（面向对象编程：既可以是命令式也可以是结构化）和 ML（泛型编程，以模板的形式）。它还将提供 **Basic Combined Programming
    Language**（**BCPL**）的速度，而不限制开发者对其限制性的低级关注点。
- en: The resulting multi-paradigm language was renamed to **C++** in 1983, while
    adding additional features not found in C, including operator and function overloading,
    virtual functions, references, and starting the development of a standalone compiler
    for this C++ language.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 结果产生的多范式语言在 1983 年被更名为 **C++**，同时增加了 C 中没有的额外特性，包括操作符和函数重载、虚函数、引用，并开始为这种 C++
    语言开发独立的编译器。
- en: 'The essential goal of C++ has remained to provide practical solutions to real-world
    issues. Additionally, it has always been the intention for C++ to be a better
    C, hence the name. Stroustrup himself defines a number of rules (as noted in *Evolving
    C++ 1991-2006*) that drive the development of C++ to this day, including the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的基本目标始终是提供针对现实世界问题的实用解决方案。此外，C++ 总是旨在成为一个更好的 C，因此得名。Stroustrup 本身定义了一系列规则（如
    *Evolving C++ 1991-2006* 中所述），这些规则至今仍在推动 C++ 的发展，包括以下内容：
- en: C++'s evolution must be driven by real problems
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 的发展必须由实际问题驱动
- en: Every feature must have a reasonably obvious implementation
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个特性都必须有一个合理明显的实现
- en: C++ is a language, not a complete system
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 是一种语言，而不是一个完整的系统
- en: Don't try to force people to use a specific programming style
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要试图强迫人们使用特定的编程风格
- en: No implicit violations of the static type system
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不存在对静态类型系统的隐式违反
- en: Provide as good support for user-defined types as for built-in types
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户定义的类型提供与内置类型一样好的支持
- en: Leave no room for a lower-level language below C++ (except assembler)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++ 之下不留任何低级语言的余地（除汇编器外）
- en: What you don't use, you don't pay for (zero-overhead rule)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用的东西，你不必为此付费（零开销规则）
- en: If in doubt, provide means for manual control
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有疑问，提供手动控制手段
- en: The differences relative to C obviously goes beyond object-oriented programming.
    Despite the lingering impression that C++ is just a set of extensions to C, it
    has for a long time been its own language, adding a strict type system (compared
    to C's weak type system at that time), more powerful programming paradigms, and
    features not found in C. Its compatibility with C can therefore be seen more as
    coincidence, with C being the right language at the right time to be used as a
    foundation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C 相比，差异显然超出了面向对象编程。尽管人们仍然认为 C++ 只是 C 的一系列扩展，但它已经很长时间成为了一种独立的语言，增加了严格的类型系统（与当时
    C 的弱类型系统相比）、更强大的编程范式和 C 中没有的特性。因此，它与 C 的兼容性更多是巧合，C 在正确的时间成为了作为基础的正确语言。
- en: The problem with Simula at the time was that it was too slow for general use,
    and BCPL was too low-level. C, being a relatively new language at the time, provided
    the right middle ground between features and performance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当时 Simula 的问题在于它对于通用使用来说太慢，而 BCPL 则太低级。C 在当时是一种相对较新的语言，提供了在特性和性能之间的正确平衡。
- en: C++ as an embedded language
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 作为嵌入式语言
- en: 'Around 1983 when C++ had just been conceived and got its name, popular personal
    computer systems for a general audience, as well as businesses, had specifications
    like ones listed in the following table:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在 1983 年，当 C++ 刚被构想并命名时，面向大众的个人计算机系统以及企业，其规格如以下表格所示：
- en: '| **System** | **CPU** | **Clock speed (MHz)** | **RAM (KB)** | **ROM (KB)**
    | **Storage (KB)** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **系统** | **CPU** | **时钟速度 (MHz)** | **RAM (KB)** | **ROM (KB)** | **存储 (KB)**
    |'
- en: '| BBC Micro | 6502 (B+ 6512A) | 2 | 16-128 | 32-128 | Max 1,280 (ADFS floppy)Max
    20 MB (hard drive) |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| BBC Micro | 6502 (B+ 6512A) | 2 | 16-128 | 32-128 | 最大 1,280 (ADFS 软盘) 最大
    20 MB (硬盘) |'
- en: '| MSX | Zilog Z80 | 3.58 | 8-128 | 32 | 720 (floppy) |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| MSX | Zilog Z80 | 3.58 | 8-128 | 32 | 720 (软盘) |'
- en: '| Commodore 64 | 6510 | ~1 | 64 | 20 | 1,000 (tape)170 (floppy) |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| Commodore 64 | 6510 | ~1 | 64 | 20 | 1,000 (磁带) 170 (软盘) |'
- en: '| Sinclair ZX81 | Zilog Z80 | 3.58 | 1 | 8 | 15 (cartridge) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| Sinclair ZX81 | Zilog Z80 | 3.58 | 1 | 8 | 15 (卡带) |'
- en: '| IBM PC | Intel 8080 | 4.77 | 16-256 | 8 | 360 (floppy) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| IBM PC | Intel 8080 | 4.77 | 16-256 | 8 | 360 (软盘) |'
- en: 'Now compare these computer systems to a recent 8-bit **microcontroller** (**MCU**)
    such as the AVR ATMega 2560 with the following specifications:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将这些计算机系统与近期的一款8位**微控制器**（**MCU**）如AVR ATMega 2560进行比较，其规格如下：
- en: 16 MHz clock speed
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16 MHz时钟速度
- en: 8 KB RAM
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8 KB RAM
- en: 256 KB ROM (program)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 256 KB ROM（程序）
- en: 4 KB ROM (data)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 KB ROM（数据）
- en: The ATMega 2560 was launched in 2005 and is among the more powerful 8-bit MCUs
    available nowadays. Its features stack up favorably against the 1980s computer
    systems, but on top of that the MCU does not rely on any external memory components.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ATMega 2560于2005年发布，是当今更强大的8位MCU之一。其特性与20世纪80年代的计算机系统相比具有优势，而且MCU不依赖于任何外部存储组件。
- en: The MCU core clock speed is significantly faster these days thanks to improved
    silicon IC manufacturing processes which also provide smaller chip sizes, high
    throughput, and thus lower cost and what's more, 1980s architectures commonly
    took 2 to 5 clock cycles to retrieve, decode, execute an instruction and store
    the result as opposed to the single-cycle execution performance of the AVR.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于硅IC制造工艺的改进，这些改进也提供了更小的芯片尺寸、高吞吐量和更低的成本，现在的MCU核心时钟速度显著更快。此外，与20世纪80年代的架构相比，这些架构通常需要2到5个时钟周期来检索、解码、执行指令并将结果存储，而AVR则具有单周期执行性能。
- en: Current MCU (Static) RAM limitations are mostly due to cost and power constraints
    yet can be easily circumvented for most MCUs using external RAM chips, along with
    adding low-cost flash-based or other mass storage devices.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当前MCU（静态）RAM的限制主要由于成本和功耗，但对于大多数MCU来说，可以通过使用外部RAM芯片以及添加基于闪存的或其他大容量存储设备来轻松克服。
- en: 'Systems like the **Commodore 64** (**C64**) were routinely programmed in C,
    in addition to the built-in BASIC interpreter (in a built-in ROM). A well-known
    C development environment for the Commodore 64 was Power C published by Spinnaker:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于**Commodore 64**（**C64**）的系统通常用C语言编程，除了内置的BASIC解释器（内置ROM）。Commodore 64的一个著名的C开发环境是Spinnaker出版的Power
    C：
- en: '![](img/68f27296-883d-413d-9ab1-22a01b44e154.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68f27296-883d-413d-9ab1-22a01b44e154.png)'
- en: Power C was one brand of productivity software aimed at C developers. It came
    on a single, double-sided floppy disk and allowed you to write C code in an editor,
    then compile it with the included compiler, linker, header files, and libraries
    to produce executables for the system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Power C是针对C开发者的一种生产力软件品牌。它包含在一个单面双面的软盘上，允许你在编辑器中编写C代码，然后使用包含的编译器、链接器、头文件和库来编译系统可执行文件。
- en: Many more of such compiler collections existed back then, targeting a variety
    of systems, showing the rich ecosystem that existed for software development.
    Among these, C++ was of course a newcomer. The first edition of Stroustrup's *The
    C++ Programming Language* was only being published in 1985, yet initially without
    a solid implementation of the language to go with it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 那时候存在许多这样的编译器集合，针对各种系统，展示了当时软件开发所存在的丰富生态系统。在这些集合中，C++当然是一个新来者。斯特劳斯特鲁普的《C++编程语言》第一版仅在1985年出版，而且最初并没有与之配套的稳定语言实现。
- en: Commercial support for C++ however began to appear rapidly, with major development
    environments such as Borland C++ 1.0 being released in 1987 and updated to 2.0
    in 1991\. Development environments like these got used in particular on the IBM
    PC and its myriad of clones where no preferred development language such as BASIC
    existed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，C++的商业支持开始迅速出现，1987年发布了Borland C++ 1.0，并在1991年更新到2.0。这类开发环境特别用于IBM PC及其众多克隆机，在这些机器上没有像BASIC这样的首选开发语言。
- en: While C++ began its life as an unofficial standard in 1985, it wasn't until
    1989 and the release of the *The C++ Programming Language* in its second edition
    as an authoritative work that C++ reached roughly the level of features equal
    to what would first be then standardized by an ISO working group as ISO/IEC 14882:1998,
    commonly known as C++98\. Still it can be said that C++ saw significant development
    and adoption before the advent of the Motorola 68040 in 1990 and Intel 486DX in
    1992, which bumped processing power above the 20 MIPS mark.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然1985年C++开始作为一个非官方标准，但直到1989年，随着第二版《C++编程语言》的发布，作为权威著作，C++才大致达到了ISO/IEC 14882:1998标准化的水平，通常称为C++98。尽管如此，可以说在1990年摩托罗拉68040和1992年英特尔486DX出现之前，C++经历了显著的发展和采用，这些处理器将处理能力提升到了20
    MIPS以上。
- en: Now that we have considered early hardware specifications and the evolution of
    C++ alongside C and other languages of the time intended to be used on the relatively
    limited systems that existed back then, it seems plausible that C++ is more than
    capable of running on such hardware, and by extension on modern-day microcontrollers.
    However, it also seems necessary to ask to what extent the complexity added to
    C++ since then has impacted memory or computing performance requirements.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经考虑了早期的硬件规范以及C++与C和其他当时打算用于相对有限系统的语言的演变，这似乎表明C++完全能够在这样的硬件上运行，进而扩展到现代微控制器。然而，似乎也有必要询问自那时以来添加到C++中的复杂性在多大程度上影响了内存或计算性能要求。
- en: C++ language features
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++语言特性
- en: We previously took a look at the explicit nature of changes to data and system
    state that defines imperative programming as opposed to declarative programming,
    where instead of manipulating data in a loop such functionality could be declared
    as mapping an operator to some data, thus spelling out the functionality, not
    the specific order of operations. But why should programming languages necessarily
    be a choice between imperative and declarative paradigms?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前曾探讨过数据系统和状态变化的显式性质，这定义了命令式编程与声明式编程的不同，在声明式编程中，而不是在循环中操作数据，这种功能可以声明为将运算符映射到某些数据上，从而明确功能，而不是操作的具体顺序。但为什么编程语言必须在命令式和声明式范式之间做出选择呢？
- en: In fact, one of the main distinguishing features of C++ is its multi-paradigm
    nature making use of both imperative and declarative paradigms. With the inclusion
    of object-oriented, generic, and functional programming into C++ in addition to
    C's procedural programming, it would seem natural to assume that this would all
    have to come at a cost, whether in terms of higher CPU usage or more RAM and/or
    ROM consumed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，C++的一个主要区别特征是其多范式性质，它结合了命令式和声明式范式。在将面向对象、泛型和函数式编程纳入C++，以及C的过程式编程之外，似乎很自然地假设这都会带来一定的成本，无论是更高的CPU使用率还是更多的RAM和/或ROM消耗。
- en: However, as we learned earlier in this chapter, C++ language features are ultimately
    built upon the C language, and as such there should in turn be little or no overhead
    relative to implementing a similar constructs in plain C. To resolve this conundrum
    and to investigate the validity of the low-overhead hypothesis, we'll now take
    a detailed look at a number of C++ language features, and how they are ultimately
    implemented, with their corresponding cost in binary and memory size.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们在本章早期所学的，C++语言特性最终是基于C语言构建的，因此相对于在纯C语言中实现类似结构，应该几乎没有开销。为了解决这个难题并调查低开销假设的有效性，我们现在将详细研究许多C++语言特性，以及它们最终是如何实现的，以及它们在二进制和内存大小上的相应成本。
- en: 'Some of the examples that focus specifically on C++ as a low-level embedded
    language are taken with permission from Rud Merriam''s Code Craft series, as published
    on Hackaday: [https://hackaday.io/project/8238-embedding-c](https://hackaday.io/project/8238-embedding-c).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一些专注于C++作为底层嵌入式语言的示例是在Hackaday上发布的Rud Merriam的《Code Craft》系列中获得的许可，[https://hackaday.io/project/8238-embedding-c](https://hackaday.io/project/8238-embedding-c)。
- en: Namespaces
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: Namespaces are a way to introduce additional levels of scope into an application.
    As we saw in the earlier section on classes, these are a compiler-level concept.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是向应用程序中引入额外作用域层次的一种方式。正如我们在关于类的早期部分所看到的，这些是编译器级别的概念。
- en: The main use lies in modularizing code, dividing it into logical segments in
    cases where classes are not the most obvious solution, or where you want to explicitly
    sort classes into a particular category using a namespace. This way, you can also
    avoid name and type collisions between similarly named classes, types, and enumerations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 主要用途在于模块化代码，在类不是最明显解决方案的情况下，或者当你想明确地将类分类到特定类别时，可以将代码划分为逻辑段。这样，你还可以避免具有相似名称的类、类型和枚举之间的名称和类型冲突。
- en: Strongly typed
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强类型
- en: Type information is necessary to test for proper access to and interpretation
    of data. A big feature in C++ that's relative to C is the inclusion of a strong
    type system. This means that many type checks performed by the compiler are significantly
    more strict than what would be allowed with C, which is a weakly typed language.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 类型信息对于测试对数据的正确访问和解释是必要的。C++相对于C的一个大特性是包含了一个强类型系统。这意味着编译器执行的许多类型检查比C语言（一种弱类型语言）所允许的要严格得多。
- en: 'This is mostly apparent when looking at this legal C code, which will generate
    an error when compiled as C++:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这在查看以下合法的C代码时尤为明显，当作为C++编译时将产生错误：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, they can also be written in the following way:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它们也可以按照以下方式编写：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'C++ forbids implicit casts, requiring these examples to be written as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: C++禁止隐式转换，要求这些示例按照以下方式编写：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'They can also be written in the following way:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以按照以下方式编写：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we explicitly specify the type we are casting to, we can rest assured that
    during compile time any type casts do what we expect them to do.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们明确指定了要转换到的类型，我们可以确信在编译时任何类型转换都会按照我们的预期执行。
- en: 'Similarly, the compiler will also complain and throw an error if we were to
    try to assign to a variable with a `const` qualifier from a reference without
    this qualifier:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果尝试将没有`const`修饰符的引用赋值给具有`const`修饰符的变量，编译器也会抱怨并抛出错误：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To work around this, you are required to explicitly cast the following conversion:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你需要显式地转换以下转换：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Performing an explicit cast like this is definitely possible and valid. It may
    also cause immense issues and headaches later on when using this reference to
    modify the contents of the supposedly constant value. By the time you find yourself
    writing code like the preceding, however, it can reasonably be assumed that you
    are aware of the implications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这种显式转换绝对是可能的，并且是有效的。但它也可能在稍后使用此引用修改所谓常量值的内时引起巨大的问题和头疼。然而，当你发现自己正在编写前面那样的代码时，可以合理地假设你已经意识到了其影响。
- en: Such enforcement of explicit types has the significant benefit of making static
    analysis far more useful and effective than it is in a weakly typed language.
    This, in turn, benefits run-time safety, as any conversions and assignments are
    most likely to be safe and without unexpected side effects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种显式类型强制的好处是使静态分析比在弱类型语言中更有用和有效。这反过来又有利于运行时安全性，因为任何转换和赋值都最有可能安全且没有意外的副作用。
- en: As a type system is predominantly a feature of the compiler rather than any
    kind of run-time code, with (optional) run-time type information as an exception.
    The overhead of having a strongly typed type system in C++ is noticed only at
    compile time, as more strict checks have to be performed on each variable assignment,
    operation, and conversion.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型系统主要是编译器的特性，而不是任何类型的运行时代码（除了作为异常的运行时类型信息），在C++中拥有强类型类型系统的开销仅在编译时才会注意到，因为必须在每个变量赋值、操作和转换上执行更严格的检查。
- en: Type conversions
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换
- en: A type conversion occurs whenever a value is assigned to a compatible variable,
    which is not the exact same type as the value. Whenever a rule for conversion
    exists, this conversion can be done implicitly, otherwise an explicit hint (cast)
    can be provided to the compiler to invoke a specific rule where ambiguity exists.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个值被赋给一个兼容的变量，而这个变量不是与值完全相同的类型时，就会发生类型转换。每当存在转换规则时，这种转换可以隐式地进行，否则可以提供显式的提示（转换）给编译器，以调用存在歧义时的特定规则。
- en: 'Whereas C only has implicit and explicit type casting, C++ expands on this
    with a number of template-based functions, allowing you to cast both regular types
    and objects (classes) in a variety of ways:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与C语言只有隐式和显式类型转换不同，C++通过一系列基于模板的函数扩展了这一点，允许你以各种方式转换常规类型和对象（类）：
- en: '`dynamic_cast <new_type>` (expression)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dynamic_cast <new_type>` (表达式)'
- en: '`reinterpret_cast <new_type>` (expression)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reinterpret_cast <new_type>` (表达式)'
- en: '`static_cast <new_type>` (expression)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static_cast <new_type>` (表达式)'
- en: '`const_cast <new_type>` (expression)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const_cast <new_type>` (表达式)'
- en: Here, `dynamic_cast` guarantees that the resulting object is valid, relying
    on **runtime type information** (**RTTI**) (see the later section on it) for this.
    A `static_cast` is similar, but does not validate the resulting object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`dynamic_cast`保证了结果对象的有效性，依赖于**运行时类型信息**（**RTTI**）（参见后面的章节）来实现这一点。`static_cast`与之类似，但不验证结果对象。
- en: Next, `reinterpret_cast` can cast anything to anything, even unrelated classes.
    Whether this conversion makes sense is left to the developer, much like with a
    regular explicit conversion.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`reinterpret_cast`可以将任何类型转换为任何类型，甚至是不相关的类。这种转换是否有意义取决于开发者，就像常规的显式转换一样。
- en: Finally, a `const_cast` is interesting in that it either sets or removes the
    `const` status of a value, which can be useful when you need a non-`const` version
    of a value for just one function. This does, however, also circumvent the type
    safety system and should be used very cautiously.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`const_cast` 很有趣，因为它可以设置或移除一个值的 `const` 状态，这在你需要为单个函数提供一个非 `const` 版本的值时非常有用。然而，这也绕过了类型安全系统，应该非常谨慎地使用。
- en: Classes
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: '**Object-oriented programming** (**OOP**) has been around since the days of
    Simula, which was known for being a slow language. This led Bjarne Stroustrup
    to base his OOP implementation on the fast and efficient C programming language.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）自 Simula 时代以来一直存在，Simula 以其运行速度慢而闻名。这导致 Bjarne Stroustrup
    将他的 OOP 实现基于快速高效的 C 编程语言。'
- en: C++ uses C-style language constructs to implement objects. This becomes obvious
    when we take a look at C++ code and its corresponding C code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 使用 C 风格的语言结构来实现对象。当我们查看 C++ 代码及其对应的 C 代码时，这一点变得很明显。
- en: 'When looking at a C++ class, we see its typical structure:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看 C++ 类时，我们看到它的典型结构：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This class is also inside of a namespace (which we will look at in more detail
    in a later section), a redefinition of the `unsigned char` type, a namespace-global
    variable definition, and finally the class definition itself, including a private
    and public section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类也位于一个命名空间内（我们将在后面的章节中更详细地探讨），重新定义了 `unsigned char` 类型，定义了一个命名空间全局变量，最后是类的定义本身，包括私有和公共部分。
- en: This C++ code defines a number of different scopes, starting with the namespace
    and ending with the class. The class itself adds scopes in the sense of its public,
    protected, and private access levels.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 C++ 代码定义了多个不同的作用域，从命名空间开始，到类结束。类本身在其公共、受保护和私有访问级别上增加了作用域。
- en: 'The same code can be implemented in regular C as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的代码可以用常规 C 语言实现如下：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `using` keyword is similar to `typedef`, making for a direct mapping there.
    We use a `const` instead of a `#define`. An `enum` is essentially the same between
    C and C++, only that C++'s compiler doesn't require the explicit marking of an
    `enum` when used as a type. The same is true for structs when it comes to simplifying
    the C++ code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`using` 关键字与 `typedef` 类似，因此在这里有直接的映射。我们使用 `const` 而不是 `#define`。`enum` 在 C
    和 C++ 中基本上是相同的，只是 C++ 的编译器在使用 `enum` 作为类型时不需要显式标记。对于简化 C++ 代码来说，这也是相同的。'
- en: The C++ class itself is implemented in C as a `struct` containing the class
    variables. When the class instance is created, it essentially means that an instance
    of this `struct` is initialized. A pointer to this `struct` instance is then passed
    with each call of a function that is part of the C++ class.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 类本身是用 C 语言实现的，它是一个包含类变量的 `struct`。当创建类实例时，这实际上意味着初始化了这个 `struct` 的一个实例。然后，这个
    `struct` 实例的指针会随着 C++ 类中每个函数的调用而传递。
- en: What these basic examples show us is that there is no runtime overhead for any
    of the C++ features we used compared to the C-based code. The namespace, class
    access levels (public, private, and protected), and similar are only used by the
    compiler to validate the code that is being compiled.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本示例向我们展示的是，与基于 C 的代码相比，我们使用的任何 C++ 功能都没有运行时开销。命名空间、类访问级别（公共、私有和受保护）以及类似功能仅由编译器用于验证正在编译的代码。
- en: A nice feature of the C++ code is that, despite the identical performance, it
    requires less code, while also allowing you to define strict interface access
    levels and have a destructor class method that gets called when the class is destroyed,
    allowing you to automatically clean up allocated resources.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 代码的一个优点是，尽管性能相同，但它需要的代码更少，同时允许你定义严格的接口访问级别，并在类被销毁时调用析构函数，从而自动清理分配的资源。
- en: 'Using the C++ class follows this pattern:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C++ 类遵循以下模式：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This compares to the C version like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 C 版本相比如下：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using the C++ class isn't very different from using the C-style method. Not
    having to do the manual passing of the allocated `struct` instance for each functional
    call, but instead calling a class method, is probably the biggest difference.
    This instance is still available in the form of the `this` pointer, which points
    to the class instance.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C++ 类与使用 C 风格的方法没有太大区别。不需要在每次功能调用时手动传递分配的 `struct` 实例，而是调用类方法，这可能是最大的区别。这个实例仍然以
    `this` 指针的形式存在，它指向类实例。
- en: While the C++ example uses a namespace and embedded enumeration in the `RingBuffer`
    class, these are just optional features. One can still use global enumerations,
    or in the scope of a namespace, or have many layers of namespaces. This is very
    much determined by the requirements of the application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管C++示例在`RingBuffer`类中使用了命名空间和内嵌枚举，但这些只是可选特性。一个人仍然可以使用全局枚举，或者在命名空间的作用域内，或者有多个命名空间层。这很大程度上取决于应用程序的需求。
- en: 'As for the cost of using classes, versions of the examples in this section
    were compiled for the aforementioned Code Craft series for both the Arduino UNO
    (ATMega328 MCU) and Arduino Due (AT91SAM3X8E MCU) development boards, giving the
    following file sizes for the compiled code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用类别的成本，本节中的示例版本是为之前提到的《代码工艺》系列中的Arduino UNO（ATMega328 MCU）和Arduino Due（AT91SAM3X8E
    MCU）开发板编译的，以下为编译后的代码文件大小：
- en: '|  | **Uno** | **Due** |  |  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|  | **Uno** | **Due** |  |  |'
- en: '| **C** | **C++** | **C** | **C++** |  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **C** | **C++** | **C** | **C++** |  |'
- en: '| **Global scope data** | 614 | 652 | 11,184 | 11,196 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **全局作用域数据** | 614 | 652 | 11,184 | 11,196 |'
- en: '| **Main scope data** | 664 | 664 | 11,200 | 11,200 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **主作用域数据** | 664 | 664 | 11,200 | 11,200 |'
- en: '| **Four instances** | 638 | 676 | 11,224 | 11,228 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **四个实例** | 638 | 676 | 11,224 | 11,228 |'
- en: Optimization settings for these code file sizes were set to `-O2`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为这些代码文件大小设置的优化设置是`-O2`。
- en: Here, we can see that C++ code is identical to C code once compiled, except
    when we perform initialization of the global class instance, on account of the
    added code to perform this initialization for us, amounting to 38 bytes for the
    Uno.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，一旦编译，C++代码与C代码相同，除非我们在初始化全局类实例时执行初始化，因为为此添加的代码，对于UNO来说，总共是38字节。
- en: 'Since only one instance of this code has to exist, this is a constant cost
    we only have to pay once: in the first and last line, we have one and four class
    instances or their equivalent, respectively, yet there is only an additional 38
    bytes in the Uno firmware. For the Due firmware, we can see something similar,
    though not as clearly defined. This difference is likely affected by some other
    settings or optimizations.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个代码只需要存在一个实例，这是一个我们只需要支付一次的固定成本：在第一行和最后一行，我们有一个和四个类实例或它们的等效物，但在UNO固件中只有额外的38字节。对于Due固件，我们可以看到类似的情况，尽管不是那么明显。这种差异可能受到某些其他设置或优化的影响。
- en: What this tells us is that sometimes we don't want to have the compiler initialize
    a class for us, but we should do it ourselves if we need those last few bytes
    of ROM or RAM. Most of the time this will not be an issue, however.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，有时我们不想让编译器为我们初始化一个类，但如果我们需要那些最后的几个ROM或RAM字节，我们应该自己来做。然而，这种情况通常不会成为问题。
- en: Inheritance
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: In addition to allowing you to organize code into objects, classes also allow
    for classes to serve as a template for other classes through the use of polymorphism.
    In C++, we can combine the properties of any number of classes into a new class,
    giving it custom properties and methods as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许你将代码组织成对象外，类还允许通过使用多态，使类成为其他类的模板。在C++中，我们可以将任意数量的类的属性组合成一个新的类，给它自定义的属性和方法。
- en: This is a very effective way to create **user-defined types** (**UDTs**), especially
    when combined with operator overloading to use common operators to define operations
    for addition, subtraction, and so on for the UDT.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种创建**用户定义类型**（**UDTs**）的有效方法，特别是当与运算符重载结合使用时，可以使用常见的运算符来定义UDT的操作，如加法、减法等。
- en: 'Inheritance in C++ follows the following pattern:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的继承遵循以下模式：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we declare a class, `B`, which derives from class `A`. This allows us
    to use any public methods defined in class A on an instance of class B, as if
    they were defined in the latter to begin with.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个类，`B`，它从类`A`派生。这允许我们使用在类A中定义的任何公共方法，在类B的实例上，就像它们一开始就在后者中定义一样。
- en: All of this seems fairly easy to understand, even if things can get a bit confusing
    the moment we start deriving from more than one base class. However, with proper
    planning and design, polymorphism can be a very powerful tool.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都相当容易理解，即使当我们开始从多个基类派生时，事情可能会变得有些混乱。然而，通过适当的规划和设计，多态可以是一个非常强大的工具。
- en: Unfortunately, none of this answers the question of how much overhead the use
    of polymorphism adds to our code. We saw earlier that C++ classes by themselves
    add no overhead during runtime, yet by deriving from one or more base classes,
    the resulting code would be expected to be significantly more complex.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这些都未能回答使用多态给我们的代码增加多少开销的问题。我们之前看到，C++类本身在运行时不会增加开销，但是通过从一个或多个基类派生，预期的代码将变得更加复杂。
- en: Fortunately, this is not the case. Much like with simple classes, the resulting
    derived classes are simple amalgamations of the base structs that underlie the
    class implementations. The inheritance process itself, along with the validation
    that comes with it, is primarily a compiler-time issue, bringing with it various
    benefits for the developer.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，情况并非如此。与简单的类类似，由此产生的派生类是底层类实现所基于的基结构的简单组合。继承过程本身以及随之而来的验证主要是编译时的问题，为开发者带来了各种好处。
- en: Virtual base classes
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚基类
- en: At times, it doesn't make a lot of sense for a base class to have an implementation
    for a class method, yet at the same time we wish to force any derived classes
    to implement that method. The answer to this problem is virtual methods.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，基类为类方法实现一个实现并没有太多意义，但与此同时，我们希望强制任何派生类实现该方法。这个问题的答案是虚方法。
- en: 'Take the following class definition:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下类定义：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we try to derive from this class, we must implement these two class methods
    or get a compiler error. Since both of the methods in the base class are virtual,
    the entire base class is referred to as a virtual base class. This is particularly
    useful for when you wish to define an interface that can be implemented by a range
    of different classes, yet keep the convenience of having just one user-defined
    type to refer to.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试从这个类派生，我们必须实现这两个类方法，否则会得到编译器错误。由于基类中的两个方法都是虚的，整个基类被称为虚基类。这在当你希望定义一个可以被一系列不同类实现的接口，同时保持只有一个用户定义类型可以引用的便利性时特别有用。
- en: 'Internally, virtual methods like these are implemented using `vtables`, which
    is short for *virtual table*. This is a data structure containing, for each virtual
    method, a memory address (pointer) pointing to an implementation of that method:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，像这样的虚方法是通过使用`vtables`（虚拟表）来实现的，这是虚拟表的简称。这是一个数据结构，它包含每个虚方法的一个内存地址（指针），该指针指向该方法的实现：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can compare the performance impact of this level of indirection relative
    to C-style code and classes with direct method calls. The Code Craft article on
    the timing of virtual functions ([https://hackaday.com/2015/11/13/code-craft-embedding-c-timing-virtual-functions/](https://hackaday.com/2015/11/13/code-craft-embedding-c-timing-virtual-functions/))
    describes such an approach, with interesting findings:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这种间接级别与C风格代码和具有直接方法调用的类在性能影响上的比较。Code Craft文章关于虚函数的计时([https://hackaday.com/2015/11/13/code-craft-embedding-c-timing-virtual-functions/](https://hackaday.com/2015/11/13/code-craft-embedding-c-timing-virtual-functions/))描述了这种方法，并有一些有趣的发现：
- en: '|  | `Uno` | `Due` |  |  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|  | `Uno` | `Due` |  |  |'
- en: '| `Os` | `O2` | `Os` | `O2` |  |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `Os` | `O2` | `Os` | `O2` |  |'
- en: '| **C function call** | 10.4 | 10.2 | 3.7 | 3.6 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **C函数调用** | 10.4 | 10.2 | 3.7 | 3.6 |'
- en: '| **C++ direct call** | 10.4 | 10.3 | 3.8 | 3.8 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| **C++直接调用** | 10.4 | 10.3 | 3.8 | 3.8 |'
- en: '| **C++ virtual call** | 11.1 | 10.9 | 3.9 | 3.8 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| **C++虚函数调用** | 11.1 | 10.9 | 3.9 | 3.8 |'
- en: '| **Multiple C calls** | 110.4 | 106.3 | 39.4 | 35.5 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **多次C函数调用** | 110.4 | 106.3 | 39.4 | 35.5 |'
- en: '| **C function pointer calls** | 105.7 | 102.9 | 38.6 | 34.9 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **C函数指针调用** | 105.7 | 102.9 | 38.6 | 34.9 |'
- en: '| **C++ virtual calls** | 103.2 | 100.4 | 39.5 | 35.2 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| **C++虚函数调用** | 103.2 | 100.4 | 39.5 | 35.2 |'
- en: All times listed here are in microseconds.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的所有时间都是以微秒为单位的。
- en: 'The same two Arduino development boards are used for this test as for the one
    comparing compile output size between C code and C++ classes. Two different optimization
    levels are used to compare the impact of such compiler settings: -Os optimizes
    for the size of the resulting binary in terms of bytes, where as the `-O2` setting
    optimizes for speed in a more aggressive manner than the `-O1` optimization level.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与比较C代码和C++类编译输出大小的测试一样，这个测试使用了相同的两个Arduino开发板。使用了两种不同的优化级别来比较这种编译设置的影响：`-Os`优化结果二进制文件的大小（以字节为单位），而`-O2`设置以比`-O1`优化级别更激进的方式优化速度。
- en: From these timings, we can say for sure that the level of indirection introduced
    by the virtual methods is measurable, although not dramatic, adding a whole 0.7
    microseconds on the ATMega328 of the Arduino Uno development board, and about
    0.1 microseconds on the faster ARM-based board.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些时间测量中，我们可以肯定地说，虚方法引入的间接层是可测量的，尽管不是非常显著，在Arduino Uno开发板上的ATMega328上增加了整整0.7微秒，而在更快的基于ARM的板上大约增加了0.1微秒。
- en: Even in absolute terms, the use of virtual class methods does not carry enough
    of a performance penalty to truly reconsider its use unless performance is paramount,
    and this is primarily the case on slower MCUs. The faster the MCU's CPU, the less
    severe the impact of its use will be.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在绝对意义上，使用虚类方法并不足以带来足够的性能损失，以至于真正需要重新考虑其使用，除非性能至关重要，而这主要是在较慢的MCU上。MCU的CPU越快，其使用的影响就越小。
- en: Function inlining
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数内联
- en: The inline keyword in C++ is a hint to the compiler to let it know that we would
    like each call to a function whose name is preceded by this keyword to result
    in that function's implementation instead of being copied to the location of the
    call, thus skipping the overhead of a function call.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的inline关键字是向编译器的一个提示，告知我们希望每个以该关键字开头名称的函数调用都直接执行该函数的实现，而不是将其复制到调用位置，从而跳过函数调用的开销。
- en: This is a compile-time optimization, which only adds the size of the function
    implementation to the compiler output, once for each distinct call to the inline
    function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个编译时优化，它只将函数实现的大小添加到编译器输出中，对于每个不同的内联函数调用只添加一次。
- en: Runtime type information
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时类型信息
- en: The main purpose of RTTI is to allow the use of safe typecasting, like with
    the `dynamic_cast<>` operator. As RTTI involves storing additional information
    for each polymorphic class, it has a certain amount of overhead.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: RTTI的主要目的是允许使用安全类型转换，例如使用`dynamic_cast<>`运算符。由于RTTI涉及为每个多态类存储额外的信息，因此它有一定的开销。
- en: This is a runtime feature, as the name gives away, and thus can be disabled
    if you don't need the features it provides. Disabling RTTI is common practice
    on some embedded platforms, especially as it is rarely used on low-resource platforms,
    such as 8-bit MCUs.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个运行时特性，正如其名称所暗示的，因此如果你不需要它提供的功能，可以将其禁用。在某些嵌入式平台上，禁用RTTI是一种常见的做法，尤其是在低资源平台（如8位MCU）上，因为RTTI很少被使用。
- en: Exception handling
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: Exceptions are commonly used on desktop platforms, providing a way to generate
    exceptions for error conditions, which can be caught and handled in try/catch
    blocks.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 异常在桌面平台上通常被广泛使用，提供了一种生成异常以处理错误条件的方法，这些异常可以在try/catch块中被捕获和处理。
- en: While exception support isn't expensive by itself, an exception being generated
    is relatively expensive, requiring a significant amount of CPU time and RAM to
    prepare and handle the exception. You have to also make sure to catch every exception,
    or risk having the application terminate without clear cause.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然异常支持本身并不昂贵，但生成异常相对较贵，需要大量的CPU时间和RAM来准备和处理异常。你还得确保捕获每一个异常，否则可能会面临应用程序在没有明显原因的情况下终止的风险。
- en: Exceptions versus the checking of return code for a method being called is something
    that has to be decided on a case-by-case basis, and can also be a matter of personal
    preference. It requires a quite different programming style, which may not work
    for everyone.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理与调用方法返回码检查之间的区别需要根据具体情况来决定，也可能是个人的偏好问题。这需要一种相当不同的编程风格，可能并不适合所有人。
- en: Templates
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: It's often thought that templates in C++ are very heavy, and carry a severe
    penalty for using them. This completely misses the point of templates, which is
    that templates are merely meant to be used as a shorthand method for automating
    the generation of nearly identical code from a single template – hence the name.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常常认为C++中的模板非常重，使用它们会带来严重的性能损失。这完全忽略了模板的本质，即模板仅仅是为了作为一个简写方法，用于从单个模板自动生成几乎相同的代码——因此得名。
- en: What this effectively means is that for any function or class template we define,
    the compiler will generate an inline implementation of the template each time
    the template is referenced.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上意味着，对于任何定义的函数或类模板，编译器都会在每次引用模板时生成模板的内置实现。
- en: 'This is a pattern we commonly see in the C++ **standard template library**
    (**STL**), which, as the name suggests, makes heavy use of templates. Take, for
    example, a data structure like a humble map:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们经常在 C++ **标准模板库**（**STL**）中看到的一种模式，正如其名所示，它大量使用了模板。以一个像地图这样的数据结构为例：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What happens here is that the singular template for an `std::map` is taken by
    the compiler, along with the template parameters we provide within the sharp brackets,
    filling in the template and writing an inline implementation in its spot.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，编译器取走了 `std::map` 的单一模板，以及我们在尖括号内提供的模板参数，填充模板，并在其位置写入内联实现。
- en: Effectively, we get the same implementation as if we had written the entire
    data structure implementation by hand just for those two types. Since the alternative
    would be to write every implementation by hand for every conceivable built-in
    type and additional user-defined type, the use of a generic template saves us
    a lot of time, without sacrificing performance.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们得到了与手动编写整个数据结构实现相同的实现，专门针对这两种类型。由于替代方案是手动为每个可能的可实现内置类型和额外用户定义类型编写实现，因此使用泛型模板可以节省我们大量时间，而不会牺牲性能。
- en: The standard template library
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准模板库
- en: The standard library for C++ (STL) contains a comprehensive and ever-growing
    collection of functions, classes, and more that allows for common tasks to be
    performed without having to rely on external libraries. The STL string class is
    very popular, and allows you to safely handle strings without having to deal with
    null terminators and anything similar.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的标准库（STL）包含了一个全面且不断增长的函数、类等集合，允许执行常见任务而无需依赖外部库。STL 字符串类非常受欢迎，允许你安全地处理字符串，而无需处理空终止符等类似问题。
- en: Most embedded platforms support all or at least a significant part of the STL,
    barring limitations on available RAM and the like that prevent the implementation
    of full hash tables and other complex data structures. Many embedded STL implementations
    contain optimizations for the target platform, minimizing RAM and CPU usage.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数嵌入式平台支持 STL 的全部或至少大部分，除了对可用 RAM 等的限制，这阻止了完整哈希表和其他复杂数据结构的实现。许多嵌入式 STL 实现针对目标平台进行了优化，最小化了
    RAM 和 CPU 的使用。
- en: Maintainability
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性
- en: In the preceding sections, we have seen a number of features that C++ offers,
    and the viability of using them on a resource-limited platform. A big advantage
    of using C++ is the reduction in code size you can accomplish through the use
    of templates, along with the organization and modularization of a code base using
    classes, namespaces, and the like.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了 C++ 提供的许多特性，以及它们在资源受限平台上的可行性。使用 C++ 的一大优势是通过使用模板，可以减少代码大小，同时使用类、命名空间等对代码库进行组织和模块化。
- en: By striving for a more modular approach in your code, with clear interfaces
    between modules, it becomes more feasible to reuse code between projects. It also
    simplifies the maintenance of code by making the function of a particular section
    of code clearer and providing clear targets for unit and integration testing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在代码中追求更模块化的方法，模块间有清晰的接口，代码在项目间的重用变得更加可行。这也有助于简化代码的维护，因为这样做可以使代码特定部分的函数更清晰，并为单元和集成测试提供明确的目标。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we tackled the big question of why you would wish to use C++
    for embedded development. We saw that, due to the courtesy of C++'s development,
    it is highly optimized for resource-constrained platforms, while providing a large
    number of features essential to project management and organization.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了为什么你想在嵌入式开发中使用 C++ 的重大问题。我们看到了，由于 C++ 的开发特性，它高度优化了资源受限平台，同时提供了大量对项目管理和组织至关重要的特性。
- en: The reader should, at this point, be able to describe C++'s main features and
    provide concrete examples of each. When writing C++ code, the reader will have
    a clear idea of the cost of a particular language feature, being able to reason
    why one implementation of a section of code is preferable to another implementation,
    based on both space and RAM constraints.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，读者应该能够描述 C++ 的主要特性，并为每个特性提供具体的例子。在编写 C++ 代码时，读者将清楚地了解特定语言特性的成本，能够根据空间和内存限制，推理出为什么某个代码段的实现比另一个实现更可取。
- en: In the next chapter, we will take a look at the development process for embedded
    Linux and similar systems, based on **single-board computers** (**SBCs**) and
    similar.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨基于**单板计算机**（**SBCs**）及其类似系统的嵌入式Linux和类似系统的开发过程。
