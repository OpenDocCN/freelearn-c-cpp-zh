<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer160">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 class="chapterTitle" id="_idParaDest-681"><span class="koboSpan" id="kobo.2.1">Exploring Testing Frameworks</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">Testing the code is an important part of software development. </span><span class="koboSpan" id="kobo.3.2">Although there is no support for testing in the C++ standard, there are a large variety of frameworks for unit testing C++ code. </span><span class="koboSpan" id="kobo.3.3">The purpose of this chapter is to get you started with several modern and widely used testing frameworks that enable you to write portable testing code. </span><span class="koboSpan" id="kobo.3.4">The frameworks that will be covered in this chapter are </span><strong class="keyWord"><span class="koboSpan" id="kobo.4.1">Boost.Test</span></strong><span class="koboSpan" id="kobo.5.1">, </span><strong class="keyWord"><span class="koboSpan" id="kobo.6.1">Google Test</span></strong><span class="koboSpan" id="kobo.7.1">, and </span><strong class="keyWord"><span class="koboSpan" id="kobo.8.1">Catch2</span></strong><span class="koboSpan" id="kobo.9.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.10.1">This chapter includes the following recipes:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Getting started with Boost.Test</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">Writing and invoking tests with Boost.Test</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Asserting with Boost.Test</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.14.1">Using test fixtures with Boost.Test</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.15.1">Controlling output with Boost.Test</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Getting started with Google Test</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.17.1">Writing and invoking tests with Google Test</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.18.1">Asserting with Google Test</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.19.1">Using test fixtures with Google Test</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.20.1">Controlling output with Google Test</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.21.1">Getting started with Catch2</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.22.1">Writing and invoking tests with Catch2</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.23.1">Asserting with Catch2</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.24.1">Controlling output with Catch2</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.25.1">These three frameworks were chosen due to their wide use, rich capabilities, the ease with which they can be used to write and execute tests, their extensibility, and their customization. </span><span class="koboSpan" id="kobo.25.2">The following table shows a short comparison of the features of these three libraries:</span></p>
<table class="table-container" id="table001-7">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.26.1">Feature</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.27.1">Boost.Test</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.28.1">Google Test</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.29.1">Catch2 (v3)</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.30.1">Easy to install</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.31.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.32.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.33.1">Yes</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.34.1">Header-only</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.35.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.36.1">No</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.37.1">No</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.38.1">Compiled library</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.39.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.40.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.41.1">Yes</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.42.1">Easy to write tests</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.43.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.44.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.45.1">Yes</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.46.1">Automatic test registration</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.47.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.48.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.49.1">Yes</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.50.1">Supports test suites</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.51.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.52.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.53.1">No (indirectly with tags)</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.54.1">Supports fixtures</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.55.1">Yes (setup/teardown)</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.56.1">Yes (setup/teardown)</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.57.1">Yes (multiple ways)</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.58.1">Rich set of asserts</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.59.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.60.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.61.1">Yes</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.62.1">Non-fatal asserts</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.63.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.64.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.65.1">Yes</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.66.1">Multiple output formats</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.67.1">Yes (includes HRF, XML)</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.68.1">Yes (includes HRF, XML)</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.69.1">Yes (includes HRF, XML)</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.70.1">Filtering of test execution</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.71.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.72.1">Yes</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.73.1">Yes</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.74.1">License</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.75.1">Boost</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.76.1">Apache 2.0</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.77.1">Boost</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.78.1">Table 11.1: Comparison of features for Boost.Test, Google Test, and Catch2</span></p>
<p class="normal"><span class="koboSpan" id="kobo.79.1">All these features will be discussed in detail for each framework. </span><span class="koboSpan" id="kobo.79.2">This chapter has a symmetric structure, with 4 5 recipes dedicated to each testing framework. </span><span class="koboSpan" id="kobo.79.3">The first framework to look at is Boost.Test.</span></p>
<h1 class="heading-1" id="_idParaDest-682"><span class="koboSpan" id="kobo.80.1">Getting started with Boost.Test</span></h1>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.81.1">Boost.Test</span></strong><span class="koboSpan" id="kobo.82.1"> is</span><a id="_idIndexMarker1311"/><span class="koboSpan" id="kobo.83.1"> one of the oldest and most popular C++ testing frameworks. </span><span class="koboSpan" id="kobo.83.2">It provides an easy-to-use set of APIs for writing tests and organizing them into test cases and test suites. </span><span class="koboSpan" id="kobo.83.3">It has good support for asserting, exception handling, fixtures, and other important features required for a testing framework.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.84.1">Throughout the next few recipes, we will explore the most important features it has that enable you to write unit tests. </span><span class="koboSpan" id="kobo.84.2">In this recipe, we will see how to install the framework and create a simple test project.</span></p>
<h2 class="heading-2" id="_idParaDest-683"><span class="koboSpan" id="kobo.85.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.86.1">The Boost.Test framework has a macro-based API. </span><span class="koboSpan" id="kobo.86.2">Although you only need to use the supplied macros for writing tests, a good understanding of macros is recommended if you want to use the framework well.</span></p>
<h2 class="heading-2" id="_idParaDest-684"><span class="koboSpan" id="kobo.87.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.88.1">In order to set up </span><a id="_idIndexMarker1312"/><span class="koboSpan" id="kobo.89.1">your environment to use Boost.Test, do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.90.1">Download the latest</span><a id="_idIndexMarker1313"/><span class="koboSpan" id="kobo.91.1"> version of the Boost library from </span><a href="http://www.boost.org/"><span class="url"><span class="koboSpan" id="kobo.92.1">http://www.boost.org/</span></span></a><span class="koboSpan" id="kobo.93.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.94.1">Unzip the content of the archive.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.95.1">Build the library using the provided tools and scripts in order to use either the static or shared library variant. </span><span class="koboSpan" id="kobo.95.2">This step is not necessary if you plan to use the header-only version of the library.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.96.1">On Linux systems, the library can also be installed using package management tools. </span><span class="koboSpan" id="kobo.96.2">For instance, on Ubuntu, you can </span><a id="_idIndexMarker1314"/><span class="koboSpan" id="kobo.97.1">use </span><strong class="keyWord"><span class="koboSpan" id="kobo.98.1">app-get</span></strong><span class="koboSpan" id="kobo.99.1"> to install</span><a id="_idIndexMarker1315"/><span class="koboSpan" id="kobo.100.1"> the libboost-test-dev package containing the Boost.Test library as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.101.1">sudo apt-get install libboost-test-dev
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.102.1">It is recommended that you consult the online documentation of the library for installation steps on various systems.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.103.1">To create your first test program using the header-only variant of the Boost.Test library, do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.104.1">Create a new, empty C++ project.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.105.1">Do the necessary setup specific to the development environment you are using to make the Boost </span><code class="inlineCode"><span class="koboSpan" id="kobo.106.1">main</span></code><span class="koboSpan" id="kobo.107.1"> folder available to the project for including header files.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.108.1">Add a new source file to the project with the following content:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.109.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.110.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.111.1"> BOOST_TEST_MODULE My first test module</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.112.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.113.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.114.1">&lt;boost/test/included/unit_test.hpp&gt;</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.115.1">BOOST_AUTO_TEST_CASE</span></span><span class="koboSpan" id="kobo.116.1">(first_test_function)
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.117.1">int</span></span><span class="koboSpan" id="kobo.118.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.119.1">42</span></span><span class="koboSpan" id="kobo.120.1">;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.121.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.122.1">(a &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.123.1">0</span></span><span class="koboSpan" id="kobo.124.1">);
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.125.1">If you want to</span><a id="_idIndexMarker1316"/><span class="koboSpan" id="kobo.126.1"> link against the shared library version, then also define the </span><code class="inlineCode"><span class="koboSpan" id="kobo.127.1">BOOST_TEST_DYN_LINK</span></code><span class="koboSpan" id="kobo.128.1"> macro.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.129.1">Build and run the project.</span></li>
</ol>
<h2 class="heading-2" id="_idParaDest-685"><span class="koboSpan" id="kobo.130.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.131.1">The Boost.Test library can </span><a id="_idIndexMarker1317"/><span class="koboSpan" id="kobo.132.1">be downloaded, along with other Boost libraries, from </span><a href="http://www.boost.org/"><span class="url"><span class="koboSpan" id="kobo.133.1">http://www.boost.org/</span></span></a><span class="koboSpan" id="kobo.134.1">. </span><span class="koboSpan" id="kobo.134.2">In this edition of the book, I used version 1.83, but the features discussed in these recipes will probably be available for many future versions. </span><span class="koboSpan" id="kobo.134.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.135.1">Test</span></code><span class="koboSpan" id="kobo.136.1"> library comes in three variants:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.137.1">Single header</span></strong><span class="koboSpan" id="kobo.138.1">: This </span><a id="_idIndexMarker1318"/><span class="koboSpan" id="kobo.139.1">enables you to write test programs without building the library; you just need to include a single header. </span><span class="koboSpan" id="kobo.139.2">Its limitation is that you can only have a single translation unit for the module; however, you can still split the module into multiple header files so that you can separate different test suites into different files.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.140.1">Static library</span></strong><span class="koboSpan" id="kobo.141.1">: This </span><a id="_idIndexMarker1319"/><span class="koboSpan" id="kobo.142.1">enables you to split a module across different translation units, but the library needs to be built first as a static library.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.143.1">Shared library</span></strong><span class="koboSpan" id="kobo.144.1">: This </span><a id="_idIndexMarker1320"/><span class="koboSpan" id="kobo.145.1">enables the same scenario as that of the static library. </span><span class="koboSpan" id="kobo.145.2">However, it has the advantage that, for programs with many test modules, this library is linked only once, and not once for each module, resulting in a smaller binary size. </span><span class="koboSpan" id="kobo.145.3">However, in this case, the shared library must be available at runtime.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.146.1">For simplicity, we</span><a id="_idIndexMarker1321"/><span class="koboSpan" id="kobo.147.1"> will use the single-header variant in this book. </span><span class="koboSpan" id="kobo.147.2">In the case of static and shared library variants, you’d need to build the library. </span><span class="koboSpan" id="kobo.147.3">The downloaded archive contains scripts for building the library. </span><span class="koboSpan" id="kobo.147.4">However, the exact steps vary, depending on the platform and the compiler; they will not be covered here but are available online.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.148.1">There are several terms and concepts that you need to understand in order to use the library:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.149.1">Test module</span></strong><span class="koboSpan" id="kobo.150.1"> is a program that performs tests. </span><span class="koboSpan" id="kobo.150.2">There are two types of modules: </span><strong class="keyWord"><span class="koboSpan" id="kobo.151.1">single-file</span></strong><span class="koboSpan" id="kobo.152.1"> (when you use the single-header variant) and </span><strong class="keyWord"><span class="koboSpan" id="kobo.153.1">multifile</span></strong><span class="koboSpan" id="kobo.154.1"> (when you use either the static or shared variant).</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.155.1">Test assertion</span></strong><span class="koboSpan" id="kobo.156.1"> is a condition that is checked by a test module.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.157.1">Test case</span></strong><span class="koboSpan" id="kobo.158.1"> is a group of one or more test assertions that is independently executed and monitored by a test module so that if it fails or leaks uncaught exceptions, the execution of other tests will not be stopped.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.159.1">Test suite</span></strong><span class="koboSpan" id="kobo.160.1"> is a collection of one or more test cases or test suites.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.161.1">Test unit</span></strong><span class="koboSpan" id="kobo.162.1"> is either a test case or a test suite.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.163.1">Test tree</span></strong><span class="koboSpan" id="kobo.164.1"> is a hierarchical structure of test units. </span><span class="koboSpan" id="kobo.164.2">In this structure, test cases are leaves and test suites are non-leaves.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.165.1">Test runner</span></strong><span class="koboSpan" id="kobo.166.1"> is a component that, given a test tree, performs the necessary initialization, execution of tests, and results reporting.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.167.1">Test report</span></strong><span class="koboSpan" id="kobo.168.1"> is the report produced by the test runner from executing the tests.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.169.1">Test log</span></strong><span class="koboSpan" id="kobo.170.1"> is the recording of all the events that occur during the execution of the test module.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.171.1">Test setup</span></strong><span class="koboSpan" id="kobo.172.1"> is the part of the test module responsible for the initialization of the framework, construction of the test tree, and individual test case setups.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.173.1">Test cleanup</span></strong><span class="koboSpan" id="kobo.174.1"> is a part of the test module responsible for cleanup operations.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.175.1">Test fixture</span></strong><span class="koboSpan" id="kobo.176.1"> is a pair of setup and cleanup operations that are invoked for multiple test units in order to avoid repetitive code.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.177.1">With these concepts defined, it is possible to explain the sample code listed earlier:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><code class="inlineCode"><span class="koboSpan" id="kobo.178.1">#define BOOST_TEST_MODULE My first test module</span></code><span class="koboSpan" id="kobo.179.1"> defines a stub for module initialization and sets a name for the main test suite. </span><span class="koboSpan" id="kobo.179.2">This must be defined before you include any library header.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.180.1">#include &lt;boost/test/included/unit_test.hpp&gt;</span></code><span class="koboSpan" id="kobo.181.1"> includes the single-header library, which</span><a id="_idIndexMarker1322"/><span class="koboSpan" id="kobo.182.1"> includes all the other necessary headers.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.183.1">BOOST_AUTO_TEST_CASE(first_test_function)</span></code><span class="koboSpan" id="kobo.184.1"> declares a test case without parameters (</span><code class="inlineCode"><span class="koboSpan" id="kobo.185.1">first_test_function</span></code><span class="koboSpan" id="kobo.186.1">) and automatically registers it to be included in the test tree as part of the enclosing test suite. </span><span class="koboSpan" id="kobo.186.2">In this example, the test suite is the main test suite defined by </span><code class="inlineCode"><span class="koboSpan" id="kobo.187.1">BOOST_TEST_MODULE</span></code><span class="koboSpan" id="kobo.188.1">.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.189.1">BOOST_TEST(true);</span></code><span class="koboSpan" id="kobo.190.1"> performs a test assertion.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.191.1">The output of executing this test module is as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.192.1">Running 1 test case...
</span><span class="koboSpan" id="kobo.192.2">*** No errors detected
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-686"><span class="koboSpan" id="kobo.193.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.194.1">If you don’t want the library to generate the </span><code class="inlineCode"><span class="koboSpan" id="kobo.195.1">main()</span></code><span class="koboSpan" id="kobo.196.1"> function but want to write it yourself, then you need to define a couple more macros – </span><code class="inlineCode"><span class="koboSpan" id="kobo.197.1">BOOST_TEST_NO_MAIN</span></code><span class="koboSpan" id="kobo.198.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.199.1">BOOST_TEST_ALTERNATIVE_INIT_API</span></code><span class="koboSpan" id="kobo.200.1"> – before you include any of the library headers. </span><span class="koboSpan" id="kobo.200.2">Then, in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.201.1">main()</span></code><span class="koboSpan" id="kobo.202.1"> function that you supply, invoke the default test runner called </span><code class="inlineCode"><span class="koboSpan" id="kobo.203.1">unit_test_main()</span></code><span class="koboSpan" id="kobo.204.1"> by providing the default initialization function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.205.1">init_unit_test()</span></code><span class="koboSpan" id="kobo.206.1"> as an argument, as shown in the following code snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.207.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.208.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.209.1"> BOOST_TEST_MODULE My first test module</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.210.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.211.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.212.1"> BOOST_TEST_NO_MAIN</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.213.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.214.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.215.1"> BOOST_TEST_ALTERNATIVE_INIT_API</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.216.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.217.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.218.1">&lt;boost/test/included/unit_test.hpp&gt;</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.219.1">BOOST_AUTO_TEST_CASE</span></span><span class="koboSpan" id="kobo.220.1">(first_test_function)
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.221.1">int</span></span><span class="koboSpan" id="kobo.222.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.223.1">42</span></span><span class="koboSpan" id="kobo.224.1">;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.225.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.226.1">(a &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.227.1">0</span></span><span class="koboSpan" id="kobo.228.1">);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.229.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.230.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.231.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.232.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.233.1"> argc, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.234.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.235.1">* argv[])</span></span><span class="koboSpan" id="kobo.236.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.237.1">return</span></span><span class="koboSpan" id="kobo.238.1"> boost::unit_test::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.239.1">unit_test_main</span></span><span class="koboSpan" id="kobo.240.1">(init_unit_test, argc, argv);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.241.1">It is also possible to customize the initialization function of the test runner. </span><span class="koboSpan" id="kobo.241.2">In this case, you must remove the definition of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.242.1">BOOST_TEST_MODULE</span></code><span class="koboSpan" id="kobo.243.1"> macro and instead write an initialization function that takes no arguments and returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.244.1">bool</span></code><span class="koboSpan" id="kobo.245.1"> value:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.246.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.247.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.248.1"> BOOST_TEST_NO_MAIN</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.249.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.250.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.251.1"> BOOST_TEST_ALTERNATIVE_INIT_API</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.252.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.253.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.254.1">&lt;boost/test/included/unit_test.hpp&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.255.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.256.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.257.1">&lt;iostream&gt;</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.258.1">BOOST_AUTO_TEST_CASE</span></span><span class="koboSpan" id="kobo.259.1">(first_test_function)
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.260.1">int</span></span><span class="koboSpan" id="kobo.261.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.262.1">42</span></span><span class="koboSpan" id="kobo.263.1">;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.264.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.265.1">(a &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.266.1">0</span></span><span class="koboSpan" id="kobo.267.1">);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.268.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.269.1">custom_init_unit_test</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.270.1">()</span></span><span class="koboSpan" id="kobo.271.1">
{
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.272.1">"test runner custom init\n"</span></span><span class="koboSpan" id="kobo.273.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.274.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.275.1">true</span></span><span class="koboSpan" id="kobo.276.1">;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.277.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.278.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.279.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.280.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.281.1"> argc, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.282.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.283.1">* argv[])</span></span><span class="koboSpan" id="kobo.284.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.285.1">return</span></span><span class="koboSpan" id="kobo.286.1"> boost::unit_test::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.287.1">unit_test_main</span></span><span class="koboSpan" id="kobo.288.1">(
    custom_init_unit_test, argc, argv);
}
</span></code></pre>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.289.1">It is possible to customize the initialization function without writing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.290.1">main()</span></code><span class="koboSpan" id="kobo.291.1"> function yourself. </span><span class="koboSpan" id="kobo.291.2">In this case, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.292.1">BOOST_TEST_NO_MAIN</span></code><span class="koboSpan" id="kobo.293.1"> macro should not be defined and the initialization function should be called </span><code class="inlineCode"><span class="koboSpan" id="kobo.294.1">init_unit_test()</span></code><span class="koboSpan" id="kobo.295.1">.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-687"><span class="koboSpan" id="kobo.296.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.297.1">Writing and invoking tests with Boost.Test</span></em><span class="koboSpan" id="kobo.298.1">, to see how to create test suites and test cases using the single-header version of the Boost.Test library, as well as how to run tests</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-688"><span class="koboSpan" id="kobo.299.1">Writing and invoking tests with Boost.Test</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.300.1">The library provides both an automatic and manual way of registering test cases and test suites to be executed by the test runner. </span><span class="koboSpan" id="kobo.300.2">Automatic registration is the simplest way because it enables you to construct a test tree just by declaring test units. </span><span class="koboSpan" id="kobo.300.3">In this recipe, we will see how to create test suites and test cases using the single-header version of the library, as well as how to run tests.</span></p>
<h2 class="heading-2" id="_idParaDest-689"><span class="koboSpan" id="kobo.301.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.302.1">To exemplify </span><a id="_idIndexMarker1323"/><span class="koboSpan" id="kobo.303.1">the creation of test suites and test cases, we will use the following class, which represents a three-dimensional point. </span><span class="koboSpan" id="kobo.303.2">This implementation contains methods for accessing the properties of a point, comparison operators, a stream </span><a id="_idIndexMarker1324"/><span class="koboSpan" id="kobo.304.1">output operator, and a method for modifying the position of a point:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.305.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.306.1">point3d</span></span><span class="koboSpan" id="kobo.307.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.308.1">int</span></span><span class="koboSpan" id="kobo.309.1"> x_;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.310.1">int</span></span><span class="koboSpan" id="kobo.311.1"> y_;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.312.1">int</span></span><span class="koboSpan" id="kobo.313.1"> z_;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.314.1">public</span></span><span class="koboSpan" id="kobo.315.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.316.1">point3d</span></span><span class="koboSpan" id="kobo.317.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.318.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.319.1">const</span></span><span class="koboSpan" id="kobo.320.1"> x = </span><span class="hljs-number"><span class="koboSpan" id="kobo.321.1">0</span></span><span class="koboSpan" id="kobo.322.1">, 
          </span><span class="hljs-type"><span class="koboSpan" id="kobo.323.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.324.1">const</span></span><span class="koboSpan" id="kobo.325.1"> y = </span><span class="hljs-number"><span class="koboSpan" id="kobo.326.1">0</span></span><span class="koboSpan" id="kobo.327.1">, 
          </span><span class="hljs-type"><span class="koboSpan" id="kobo.328.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.329.1">const</span></span><span class="koboSpan" id="kobo.330.1"> z = </span><span class="hljs-number"><span class="koboSpan" id="kobo.331.1">0</span></span><span class="koboSpan" id="kobo.332.1">):</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.333.1">x_</span></span><span class="koboSpan" id="kobo.334.1">(x), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.335.1">y_</span></span><span class="koboSpan" id="kobo.336.1">(y), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.337.1">z_</span></span><span class="koboSpan" id="kobo.338.1">(z) {}
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.339.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.340.1">x</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.341.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.342.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.343.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.344.1">return</span></span><span class="koboSpan" id="kobo.345.1"> x_; }
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.346.1">point3d&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.347.1">x</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.348.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.349.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.350.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.351.1"> x)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.352.1">{ x_ = x; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.353.1">return</span></span><span class="koboSpan" id="kobo.354.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.355.1">this</span></span><span class="koboSpan" id="kobo.356.1">; }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.357.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.358.1">y</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.359.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.360.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.361.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.362.1">return</span></span><span class="koboSpan" id="kobo.363.1"> y_; }
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.364.1">point3d&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.365.1">y</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.366.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.367.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.368.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.369.1"> y)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.370.1">{ y_ = y; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.371.1">return</span></span><span class="koboSpan" id="kobo.372.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.373.1">this</span></span><span class="koboSpan" id="kobo.374.1">; }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.375.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.376.1">z</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.377.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.378.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.379.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.380.1">return</span></span><span class="koboSpan" id="kobo.381.1"> z_; }
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.382.1">point3d&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.383.1">z</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.384.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.385.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.386.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.387.1"> z)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.388.1">{ z_ = z; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.389.1">return</span></span><span class="koboSpan" id="kobo.390.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.391.1">this</span></span><span class="koboSpan" id="kobo.392.1">; }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.393.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.394.1">operator</span></span><span class="koboSpan" id="kobo.395.1">==(point3d </span><span class="hljs-type"><span class="koboSpan" id="kobo.396.1">const</span></span><span class="koboSpan" id="kobo.397.1"> &amp; pt) </span><span class="hljs-type"><span class="koboSpan" id="kobo.398.1">const</span></span><span class="koboSpan" id="kobo.399.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.400.1">return</span></span><span class="koboSpan" id="kobo.401.1"> x_ == pt.x_ &amp;&amp; y_ == pt.y_ &amp;&amp; z_ == pt.z_;
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.402.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.403.1">operator</span></span><span class="koboSpan" id="kobo.404.1">!=(point3d </span><span class="hljs-type"><span class="koboSpan" id="kobo.405.1">const</span></span><span class="koboSpan" id="kobo.406.1"> &amp; pt) </span><span class="hljs-type"><span class="koboSpan" id="kobo.407.1">const</span></span><span class="koboSpan" id="kobo.408.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.409.1">return</span></span><span class="koboSpan" id="kobo.410.1"> !(*</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.411.1">this</span></span><span class="koboSpan" id="kobo.412.1"> == pt);
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.413.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.414.1">operator</span></span><span class="koboSpan" id="kobo.415.1">&lt;(point3d </span><span class="hljs-type"><span class="koboSpan" id="kobo.416.1">const</span></span><span class="koboSpan" id="kobo.417.1"> &amp; pt) </span><span class="hljs-type"><span class="koboSpan" id="kobo.418.1">const</span></span><span class="koboSpan" id="kobo.419.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.420.1">return</span></span><span class="koboSpan" id="kobo.421.1"> x_ &lt; pt.x_ || y_ &lt; pt.y_ || z_ &lt; pt.z_;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.422.1">friend</span></span><span class="koboSpan" id="kobo.423.1"> std::ostream&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.424.1">operator</span></span><span class="koboSpan" id="kobo.425.1">&lt;&lt;(std::ostream&amp; stream, 
                                  point3d </span><span class="hljs-type"><span class="koboSpan" id="kobo.426.1">const</span></span><span class="koboSpan" id="kobo.427.1"> &amp; pt)
  {
    stream &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.428.1">"("</span></span><span class="koboSpan" id="kobo.429.1"> &lt;&lt; pt.x_ &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.430.1">","</span></span><span class="koboSpan" id="kobo.431.1"> &lt;&lt; pt.y_ &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.432.1">","</span></span><span class="koboSpan" id="kobo.433.1"> &lt;&lt; pt.z_ &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.434.1">")"</span></span><span class="koboSpan" id="kobo.435.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.436.1">return</span></span><span class="koboSpan" id="kobo.437.1"> stream;
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.438.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.439.1">offset</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.440.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.441.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.442.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.443.1"> offsetx, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.444.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.445.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.446.1"> offsety, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.447.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.448.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.449.1"> offsetz)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.450.1">{
    x_ += offsetx;
    y_ += offsety;
    z_ += offsetz;
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.451.1">static</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.452.1"> point3d </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.453.1">origin</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.454.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.455.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.456.1">return</span></span><span class="koboSpan" id="kobo.457.1"> point3d{}; }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.458.1">Before</span><a id="_idIndexMarker1325"/><span class="koboSpan" id="kobo.459.1"> you </span><a id="_idIndexMarker1326"/><span class="koboSpan" id="kobo.460.1">go any further, notice that the test cases in this recipe contain erroneous tests on purpose so that they produce failures.</span></p>
<h2 class="heading-2" id="_idParaDest-690"><span class="koboSpan" id="kobo.461.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.462.1">Use the following macros to create test units:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.463.1">To create a test suite, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.464.1">BOOST_AUTO_TEST_SUITE(name)</span></code><span class="koboSpan" id="kobo.465.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.466.1">BOOST_AUTO_TEST_SUITE_END()</span></code><span class="koboSpan" id="kobo.467.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.468.1">BOOST_AUTO_TEST_SUITE</span></span><span class="koboSpan" id="kobo.469.1">(test_construction)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.470.1">// test cases </span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.471.1">BOOST_AUTO_TEST_SUITE_END</span></span><span class="koboSpan" id="kobo.472.1">()
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.473.1">To create a test case, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.474.1">BOOST_AUTO_TEST_CASE(name)</span></code><span class="koboSpan" id="kobo.475.1">. </span><span class="koboSpan" id="kobo.475.2">Test cases are defined between </span><code class="inlineCode"><span class="koboSpan" id="kobo.476.1">BOOST_AUTO_TEST_SUITE(name)</span></code><span class="koboSpan" id="kobo.477.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.478.1">BOOST_AUTO_TEST_SUITE_END()</span></code><span class="koboSpan" id="kobo.479.1">, as shown in the following code snippet:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.480.1">BOOST_AUTO_TEST_CASE</span></span><span class="koboSpan" id="kobo.481.1">(test_constructor)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.482.1">auto</span></span><span class="koboSpan" id="kobo.483.1"> p = point3d{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.484.1">1</span></span><span class="koboSpan" id="kobo.485.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.486.1">2</span></span><span class="koboSpan" id="kobo.487.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.488.1">3</span></span><span class="koboSpan" id="kobo.489.1"> };
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.490.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.491.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.492.1">x</span></span><span class="koboSpan" id="kobo.493.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.494.1">1</span></span><span class="koboSpan" id="kobo.495.1">);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.496.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.497.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.498.1">y</span></span><span class="koboSpan" id="kobo.499.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.500.1">2</span></span><span class="koboSpan" id="kobo.501.1">);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.502.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.503.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.504.1">z</span></span><span class="koboSpan" id="kobo.505.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.506.1">4</span></span><span class="koboSpan" id="kobo.507.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.508.1">// will fail</span></span><span class="koboSpan" id="kobo.509.1">
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.510.1">BOOST_AUTO_TEST_CASE</span></span><span class="koboSpan" id="kobo.511.1">(test_origin)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.512.1">auto</span></span><span class="koboSpan" id="kobo.513.1"> p = point3d::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.514.1">origin</span></span><span class="koboSpan" id="kobo.515.1">();
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.516.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.517.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.518.1">x</span></span><span class="koboSpan" id="kobo.519.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.520.1">0</span></span><span class="koboSpan" id="kobo.521.1">);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.522.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.523.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.524.1">y</span></span><span class="koboSpan" id="kobo.525.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.526.1">0</span></span><span class="koboSpan" id="kobo.527.1">);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.528.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.529.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.530.1">z</span></span><span class="koboSpan" id="kobo.531.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.532.1">0</span></span><span class="koboSpan" id="kobo.533.1">);
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.534.1">To</span><a id="_idIndexMarker1327"/><span class="koboSpan" id="kobo.535.1"> create </span><a id="_idIndexMarker1328"/><span class="koboSpan" id="kobo.536.1">a nested test suite, define a test suite inside another test suite:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.537.1">BOOST_AUTO_TEST_SUITE</span></span><span class="koboSpan" id="kobo.538.1">(test_operations)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.539.1">BOOST_AUTO_TEST_SUITE</span></span><span class="koboSpan" id="kobo.540.1">(test_methods)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.541.1">BOOST_AUTO_TEST_CASE</span></span><span class="koboSpan" id="kobo.542.1">(test_offset)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.543.1">auto</span></span><span class="koboSpan" id="kobo.544.1"> p = point3d{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.545.1">1</span></span><span class="koboSpan" id="kobo.546.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.547.1">2</span></span><span class="koboSpan" id="kobo.548.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.549.1">3</span></span><span class="koboSpan" id="kobo.550.1"> };
  p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.551.1">offset</span></span><span class="koboSpan" id="kobo.552.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.553.1">1</span></span><span class="koboSpan" id="kobo.554.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.555.1">1</span></span><span class="koboSpan" id="kobo.556.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.557.1">1</span></span><span class="koboSpan" id="kobo.558.1">);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.559.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.560.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.561.1">x</span></span><span class="koboSpan" id="kobo.562.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.563.1">2</span></span><span class="koboSpan" id="kobo.564.1">);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.565.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.566.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.567.1">y</span></span><span class="koboSpan" id="kobo.568.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.569.1">3</span></span><span class="koboSpan" id="kobo.570.1">);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.571.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.572.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.573.1">z</span></span><span class="koboSpan" id="kobo.574.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.575.1">3</span></span><span class="koboSpan" id="kobo.576.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.577.1">// will fail</span></span><span class="koboSpan" id="kobo.578.1">
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.579.1">BOOST_AUTO_TEST_SUITE_END</span></span><span class="koboSpan" id="kobo.580.1">()
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.581.1">BOOST_AUTO_TEST_SUITE_END</span></span><span class="koboSpan" id="kobo.582.1">()
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.583.1">To add decorators to a test unit, add an additional parameter to the test unit’s macros. </span><span class="koboSpan" id="kobo.583.2">Decorators could include description, label, precondition, dependency, fixture, and so on. </span><span class="koboSpan" id="kobo.583.3">Refer to the following code snippet, which illustrates this:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.584.1">BOOST_AUTO_TEST_SUITE</span></span><span class="koboSpan" id="kobo.585.1">(test_operations)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.586.1">BOOST_AUTO_TEST_SUITE</span></span><span class="koboSpan" id="kobo.587.1">(test_operators)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.588.1">BOOST_AUTO_TEST_CASE</span></span><span class="koboSpan" id="kobo.589.1">(
  test_equal, 
  *boost::unit_test::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.590.1">description</span></span><span class="koboSpan" id="kobo.591.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.592.1">"test operator=="</span></span><span class="koboSpan" id="kobo.593.1">)
  *boost::unit_test::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.594.1">label</span></span><span class="koboSpan" id="kobo.595.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.596.1">"opeq"</span></span><span class="koboSpan" id="kobo.597.1">))
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.598.1">auto</span></span><span class="koboSpan" id="kobo.599.1"> p1 = point3d{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.600.1">1</span></span><span class="koboSpan" id="kobo.601.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.602.1">2</span></span><span class="koboSpan" id="kobo.603.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.604.1">3</span></span><span class="koboSpan" id="kobo.605.1"> };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.606.1">auto</span></span><span class="koboSpan" id="kobo.607.1"> p2 = point3d{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.608.1">1</span></span><span class="koboSpan" id="kobo.609.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.610.1">2</span></span><span class="koboSpan" id="kobo.611.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.612.1">3</span></span><span class="koboSpan" id="kobo.613.1"> };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.614.1">auto</span></span><span class="koboSpan" id="kobo.615.1"> p3 = point3d{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.616.1">3</span></span><span class="koboSpan" id="kobo.617.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.618.1">2</span></span><span class="koboSpan" id="kobo.619.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.620.1">1</span></span><span class="koboSpan" id="kobo.621.1"> };
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.622.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.623.1">(p1 == p2);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.624.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.625.1">(p1 == p3); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.626.1">// will fail</span></span><span class="koboSpan" id="kobo.627.1">
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.628.1">BOOST_AUTO_TEST_CASE</span></span><span class="koboSpan" id="kobo.629.1">(
  test_not_equal, 
  *boost::unit_test::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.630.1">description</span></span><span class="koboSpan" id="kobo.631.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.632.1">"test operator!="</span></span><span class="koboSpan" id="kobo.633.1">)
  *boost::unit_test::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.634.1">label</span></span><span class="koboSpan" id="kobo.635.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.636.1">"opeq"</span></span><span class="koboSpan" id="kobo.637.1">)
  *boost::unit_test::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.638.1">depends_on</span></span><span class="koboSpan" id="kobo.639.1">(
    </span><span class="hljs-string"><span class="koboSpan" id="kobo.640.1">"test_operations/test_operators/test_equal"</span></span><span class="koboSpan" id="kobo.641.1">))
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.642.1">auto</span></span><span class="koboSpan" id="kobo.643.1"> p1 = point3d{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.644.1">1</span></span><span class="koboSpan" id="kobo.645.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.646.1">2</span></span><span class="koboSpan" id="kobo.647.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.648.1">3</span></span><span class="koboSpan" id="kobo.649.1"> };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.650.1">auto</span></span><span class="koboSpan" id="kobo.651.1"> p2 = point3d{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.652.1">3</span></span><span class="koboSpan" id="kobo.653.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.654.1">2</span></span><span class="koboSpan" id="kobo.655.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.656.1">1</span></span><span class="koboSpan" id="kobo.657.1"> };
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.658.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.659.1">(p1 != p2);
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.660.1">BOOST_AUTO_TEST_CASE</span></span><span class="koboSpan" id="kobo.661.1">(test_less)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.662.1">auto</span></span><span class="koboSpan" id="kobo.663.1"> p1 = point3d{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.664.1">1</span></span><span class="koboSpan" id="kobo.665.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.666.1">2</span></span><span class="koboSpan" id="kobo.667.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.668.1">3</span></span><span class="koboSpan" id="kobo.669.1"> };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.670.1">auto</span></span><span class="koboSpan" id="kobo.671.1"> p2 = point3d{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.672.1">1</span></span><span class="koboSpan" id="kobo.673.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.674.1">2</span></span><span class="koboSpan" id="kobo.675.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.676.1">3</span></span><span class="koboSpan" id="kobo.677.1"> };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.678.1">auto</span></span><span class="koboSpan" id="kobo.679.1"> p3 = point3d{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.680.1">3</span></span><span class="koboSpan" id="kobo.681.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.682.1">2</span></span><span class="koboSpan" id="kobo.683.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.684.1">1</span></span><span class="koboSpan" id="kobo.685.1"> };
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.686.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.687.1">(!(p1 &lt; p2));
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.688.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.689.1">(p1 &lt; p3);
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.690.1">BOOST_AUTO_TEST_SUITE_END</span></span><span class="koboSpan" id="kobo.691.1">()
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.692.1">BOOST_AUTO_TEST_SUITE_END</span></span><span class="koboSpan" id="kobo.693.1">()
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.694.1">To execute</span><a id="_idIndexMarker1329"/><span class="koboSpan" id="kobo.695.1"> the tests, do</span><a id="_idIndexMarker1330"/><span class="koboSpan" id="kobo.696.1"> the following (notice that the command line is Windows-specific, but it should be trivial to replace that with the one specific to Linux or macOS):</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.697.1">To execute the entire test tree, run the program (the test module) without any parameters:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.698.1">chapter11bt_02.exe
Running 6 test cases...
</span><span class="koboSpan" id="kobo.698.2">f:/chapter11bt_02/main.cpp(12): error: in "test_construction/test_
constructor": check p.z() == 4 has failed [3 != 4]
f:/chapter11bt_02/main.cpp(35): error: in "test_operations/test_
methods/test_offset": check p.z() == 3 has failed [4 != 3]
f:/chapter11bt_02/main.cpp(55): error: in "test_operations/test_
operators/test_equal": check p1 == p3 has failed [(1,2,3) != 
(3,2,1)]
*** 3 failures are detected in the test module "Testing point 3d"
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.699.1">To execute a </span><a id="_idIndexMarker1331"/><span class="koboSpan" id="kobo.700.1">single test suite, run the program with the argument </span><code class="inlineCode"><span class="koboSpan" id="kobo.701.1">run_test</span></code><span class="koboSpan" id="kobo.702.1">, specifying the path of the test suite:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.703.1">chapter11bt_02.exe --run_test=test_construction
Running 2 test cases...
</span><span class="koboSpan" id="kobo.703.2">f:/chapter11bt_02/main.cpp(12): error: in "test_construction/test_
constructor": check p.z() == 4 has failed [3 != 4]
*** 1 failure is detected in the test module "Testing point 3d"
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.704.1">To </span><a id="_idIndexMarker1332"/><span class="koboSpan" id="kobo.705.1">execute a single test case, run the program with the argument </span><code class="inlineCode"><span class="koboSpan" id="kobo.706.1">run_test</span></code><span class="koboSpan" id="kobo.707.1">, specifying the path of the test case:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.708.1">chapter11bt_02.exe --run_test=test_construction/test_origin
Running 1 test case...
</span><span class="koboSpan" id="kobo.708.2">*** No errors detected
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.709.1">To execute a collection of test suites and test cases defined under the same label, run the program with the argument </span><code class="inlineCode"><span class="koboSpan" id="kobo.710.1">run_test</span></code><span class="koboSpan" id="kobo.711.1">, specifying the label name prefixed with </span><code class="inlineCode"><span class="koboSpan" id="kobo.712.1">@</span></code><span class="koboSpan" id="kobo.713.1">:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.714.1">chapter11bt_02.exe --run_test=@opeq
Running 2 test cases...
</span><span class="koboSpan" id="kobo.714.2">f:/chapter11bt_02/main.cpp(56): error: in "test_operations/test_
operators/test_equal": check p1 == p3 has failed [(1,2,3) != 
(3,2,1)]
*** 1 failure is detected in the test module "Testing point 3d"
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-691"><span class="koboSpan" id="kobo.715.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.716.1">A test tree is a</span><a id="_idIndexMarker1333"/><span class="koboSpan" id="kobo.717.1"> hierarchy of test cases and test suites, which also includes the fixtures and additional dependencies. </span><span class="koboSpan" id="kobo.717.2">A test suite can </span><a id="_idIndexMarker1334"/><span class="koboSpan" id="kobo.718.1">contain one or more test cases and other nested test suites as well. </span><span class="koboSpan" id="kobo.718.2">Test suites are similar to namespaces in the sense that they can be stopped and restarted multiple times in the same file or in different files. </span><span class="koboSpan" id="kobo.718.3">Automatic registration of test suites is done with the macros </span><code class="inlineCode"><span class="koboSpan" id="kobo.719.1">BOOST_AUTO_TEST_SUITE</span></code><span class="koboSpan" id="kobo.720.1">, which requires a name, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.721.1">BOOST_AUTO_TEST_SUITE_END</span></code><span class="koboSpan" id="kobo.722.1">. </span><span class="koboSpan" id="kobo.722.2">Automatic registration of test cases is done with </span><code class="inlineCode"><span class="koboSpan" id="kobo.723.1">BOOST_AUTO_TEST_CASE</span></code><span class="koboSpan" id="kobo.724.1">. </span><span class="koboSpan" id="kobo.724.2">Test units (whether they’re cases or suites) become members of the closest test suite. </span><span class="koboSpan" id="kobo.724.3">Test units defined at the file scope level become members of the master test suite - the implicit test suite created with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.725.1">BOOST_TEST_MODULE</span></code><span class="koboSpan" id="kobo.726.1"> declaration.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.727.1">Both test suites and test cases can be decorated with a series of attributes that affect how test units will be processed during the execution of the test module. </span><span class="koboSpan" id="kobo.727.2">The currently supported decorators are as follows:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.728.1">depends_on</span></code><span class="koboSpan" id="kobo.729.1">: This indicates a dependency between the current test unit and a designated test unit.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.730.1">description</span></code><span class="koboSpan" id="kobo.731.1">: This provides a semantic description of a test unit.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.732.1">enabled</span></code><span class="koboSpan" id="kobo.733.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.734.1">disabled</span></code><span class="koboSpan" id="kobo.735.1">: These set the default run status of a test unit to either </span><code class="inlineCode"><span class="koboSpan" id="kobo.736.1">true</span></code><span class="koboSpan" id="kobo.737.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.738.1">false</span></code><span class="koboSpan" id="kobo.739.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.740.1">enable_if&lt;bool&gt;</span></code><span class="koboSpan" id="kobo.741.1">: This sets the default run status of a test unit to either </span><code class="inlineCode"><span class="koboSpan" id="kobo.742.1">true</span></code><span class="koboSpan" id="kobo.743.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.744.1">false</span></code><span class="koboSpan" id="kobo.745.1">, depending on the evaluation of a compile-time expression.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.746.1">expected_failures</span></code><span class="koboSpan" id="kobo.747.1">: This indicates the expected failures for a test unit.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.748.1">fixture</span></code><span class="koboSpan" id="kobo.749.1">: This specifies a pair of functions (startup and cleanup) to be called before and after the execution of a test unit.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.750.1">label</span></code><span class="koboSpan" id="kobo.751.1">: With this, you can associate a test unit with a label. </span><span class="koboSpan" id="kobo.751.2">The same label can be used for multiple test units, and a test unit can have multiple labels.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.752.1">precondition</span></code><span class="koboSpan" id="kobo.753.1">: This associates a predicate with a test unit, which is used at runtime to determine the run status of the test unit.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.754.1">timeout</span></code><span class="koboSpan" id="kobo.755.1">: Specifies a timeout for a unit test, in wall-clock time. </span><span class="koboSpan" id="kobo.755.2">If the test lasts longer than the specified timeout, the test fails.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.756.1">tolerance</span></code><span class="koboSpan" id="kobo.757.1">: This decorator specifies the default comparison tolerance for the floating-point type FTP in the decorated test unit.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.758.1">If the execution of a</span><a id="_idIndexMarker1335"/><span class="koboSpan" id="kobo.759.1"> test case results in an unhandled exception, the framework will catch the exception and terminate the execution of the test case with a failure. </span><span class="koboSpan" id="kobo.759.2">However, the framework provides several macros to test whether a particular piece of code raises, or does not raise, exceptions. </span><span class="koboSpan" id="kobo.759.3">For more information, see the next recipe, </span><em class="italic"><span class="koboSpan" id="kobo.760.1">Asserting with Boost.Test</span></em><span class="koboSpan" id="kobo.761.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.762.1">The test units that compose the module’s test tree can be executed entirely or partially. </span><span class="koboSpan" id="kobo.762.2">In both cases, to execute the test units, execute the (binary) program, which represents the test module. </span><span class="koboSpan" id="kobo.762.3">To execute only some of the test units, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.763.1">--run_test</span></code><span class="koboSpan" id="kobo.764.1"> command-line option (or </span><code class="inlineCode"><span class="koboSpan" id="kobo.765.1">--t</span></code><span class="koboSpan" id="kobo.766.1"> if you want to use a shorter name). </span><span class="koboSpan" id="kobo.766.2">This option allows you to filter the test units and specify either a path or a label. </span><span class="koboSpan" id="kobo.766.3">A path consists of a sequence of test suite and/or test case names, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.767.1">test_construction</span></code><span class="koboSpan" id="kobo.768.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.769.1">test_operations</span></code><span class="koboSpan" id="kobo.770.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.771.1">test_methods</span></code><span class="koboSpan" id="kobo.772.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.773.1">test_offset</span></code><span class="koboSpan" id="kobo.774.1">. </span><span class="koboSpan" id="kobo.774.2">A label is a name defined with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.775.1">label</span></code><span class="koboSpan" id="kobo.776.1"> decorator and is prefixed with </span><code class="inlineCode"><span class="koboSpan" id="kobo.777.1">@</span></code><span class="koboSpan" id="kobo.778.1"> for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.779.1">run_test</span></code><span class="koboSpan" id="kobo.780.1"> parameter. </span><span class="koboSpan" id="kobo.780.2">This parameter is repeatable, which means you can specify multiple filters on it.</span></p>
<h2 class="heading-2" id="_idParaDest-692"><span class="koboSpan" id="kobo.781.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.782.1">Getting started with Boost.Test</span></em><span class="koboSpan" id="kobo.783.1">, to learn how to install the Boost.Test framework and how to create a simple test project</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.784.1">Asserting with Boost.Test</span></em><span class="koboSpan" id="kobo.785.1">, to explore the rich set of assertion macros from the Boost.Test library</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-693"><span class="koboSpan" id="kobo.786.1">Asserting with Boost.Test</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.787.1">A test </span><a id="_idIndexMarker1336"/><span class="koboSpan" id="kobo.788.1">case contains one or more tests. </span><span class="koboSpan" id="kobo.788.2">The Boost.Test library provides a series of APIs in the form of macros to write tests. </span><span class="koboSpan" id="kobo.788.3">In the previous recipe, you learned a bit about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.789.1">BOOST_TEST</span></code><span class="koboSpan" id="kobo.790.1"> macro, which is the most important and widely used macro in the library. </span><span class="koboSpan" id="kobo.790.2">In this recipe, we will discuss how the </span><code class="inlineCode"><span class="koboSpan" id="kobo.791.1">BOOST_TEST</span></code><span class="koboSpan" id="kobo.792.1"> macro can be used in further detail.</span></p>
<h2 class="heading-2" id="_idParaDest-694"><span class="koboSpan" id="kobo.793.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.794.1">You should </span><a id="_idIndexMarker1337"/><span class="koboSpan" id="kobo.795.1">now be familiar with writing test suites and test cases, a topic we covered in the previous recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-695"><span class="koboSpan" id="kobo.796.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.797.1">The following list shows some of the most commonly used APIs for performing tests:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.798.1">BOOST_TEST</span></code><span class="koboSpan" id="kobo.799.1">, in its plain form, is used for most tests:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.800.1">int</span></span><span class="koboSpan" id="kobo.801.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.802.1">2</span></span><span class="koboSpan" id="kobo.803.1">, b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.804.1">4</span></span><span class="koboSpan" id="kobo.805.1">;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.806.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.807.1">(a == b);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.808.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.809.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.810.1">4.201</span></span><span class="koboSpan" id="kobo.811.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.812.1">4.200</span></span><span class="koboSpan" id="kobo.813.1">);
std::string s1{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.814.1">"sample"</span></span><span class="koboSpan" id="kobo.815.1"> };
std::string s2{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.816.1">"text"</span></span><span class="koboSpan" id="kobo.817.1"> };
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.818.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.819.1">(s1 == s2, </span><span class="hljs-string"><span class="koboSpan" id="kobo.820.1">"not equal"</span></span><span class="koboSpan" id="kobo.821.1">);
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.822.1">BOOST_TEST</span></code><span class="koboSpan" id="kobo.823.1">, along with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.824.1">tolerance()</span></code><span class="koboSpan" id="kobo.825.1"> manipulator, is used to indicate the tolerance of floating-point comparisons:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.826.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.827.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.828.1">4.201</span></span><span class="koboSpan" id="kobo.829.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.830.1">4.200</span></span><span class="koboSpan" id="kobo.831.1">, boost::test_tools::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.832.1">tolerance</span></span><span class="koboSpan" id="kobo.833.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.834.1">0.001</span></span><span class="koboSpan" id="kobo.835.1">));
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.836.1">BOOST_TEST</span></code><span class="koboSpan" id="kobo.837.1">, along with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.838.1">per_element()</span></code><span class="koboSpan" id="kobo.839.1"> manipulator, is used to perform an element-wise comparison of containers (even of different types):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.840.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.841.1">int</span></span><span class="koboSpan" id="kobo.842.1">&gt; v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.843.1">1</span></span><span class="koboSpan" id="kobo.844.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.845.1">2</span></span><span class="koboSpan" id="kobo.846.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.847.1">3</span></span><span class="koboSpan" id="kobo.848.1"> };
std::list&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.849.1">short</span></span><span class="koboSpan" id="kobo.850.1">&gt; l{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.851.1">1</span></span><span class="koboSpan" id="kobo.852.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.853.1">2</span></span><span class="koboSpan" id="kobo.854.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.855.1">3</span></span><span class="koboSpan" id="kobo.856.1"> };
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.857.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.858.1">(v == l, boost::test_tools::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.859.1">per_element</span></span><span class="koboSpan" id="kobo.860.1">());
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.861.1">BOOST_TEST</span></code><span class="koboSpan" id="kobo.862.1">, along with the ternary operator and compound statements using the logical </span><code class="inlineCode"><span class="koboSpan" id="kobo.863.1">||</span></code><span class="koboSpan" id="kobo.864.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.865.1">&amp;&amp;</span></code><span class="koboSpan" id="kobo.866.1">, requires an extra set of parentheses:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.867.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.868.1">((a &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.869.1">0</span></span><span class="koboSpan" id="kobo.870.1"> ? </span><span class="hljs-literal"><span class="koboSpan" id="kobo.871.1">true</span></span><span class="koboSpan" id="kobo.872.1"> : </span><span class="hljs-literal"><span class="koboSpan" id="kobo.873.1">false</span></span><span class="koboSpan" id="kobo.874.1">));
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.875.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.876.1">((a &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.877.1">2</span></span><span class="koboSpan" id="kobo.878.1"> &amp;&amp; b &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.879.1">5</span></span><span class="koboSpan" id="kobo.880.1">));
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.881.1">BOOST_ERROR</span></code><span class="koboSpan" id="kobo.882.1"> is used to unconditionally fail a test and produce a message in the report. </span><span class="koboSpan" id="kobo.882.2">This is equivalent to </span><code class="inlineCode"><span class="koboSpan" id="kobo.883.1">BOOST_TEST(false, message)</span></code><span class="koboSpan" id="kobo.884.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.885.1">BOOST_ERROR</span></span><span class="koboSpan" id="kobo.886.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.887.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.888.1">this test will fail"</span></span><span class="koboSpan" id="kobo.889.1">);
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.890.1">BOOST_TEST_WARN</span></code><span class="koboSpan" id="kobo.891.1"> is used to produce a warning in the report in case a test is failing, without increasing the number of encountered errors and stopping the execution of the test case:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.892.1">BOOST_TEST_WARN</span></span><span class="koboSpan" id="kobo.893.1">(a == </span><span class="hljs-number"><span class="koboSpan" id="kobo.894.1">4</span></span><span class="koboSpan" id="kobo.895.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.896.1">"something is not right"</span></span><span class="koboSpan" id="kobo.897.1">);
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.898.1">BOOST_TEST_REQUIRE</span></code><span class="koboSpan" id="kobo.899.1"> is used to ensure that test case pre-conditions are met; the execution of the test case is stopped otherwise:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.900.1">BOOST_TEST_REQUIRE</span></span><span class="koboSpan" id="kobo.901.1">(a == </span><span class="hljs-number"><span class="koboSpan" id="kobo.902.1">4</span></span><span class="koboSpan" id="kobo.903.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.904.1">"this is critical"</span></span><span class="koboSpan" id="kobo.905.1">);
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.906.1">BOOST_FAIL</span></code><span class="koboSpan" id="kobo.907.1"> is used to unconditionally stop the execution of the test case, increase the number of encountered errors, and produce a message in the report. </span><span class="koboSpan" id="kobo.907.2">This is equivalent to </span><code class="inlineCode"><span class="koboSpan" id="kobo.908.1">BOOST_TEST_REQUIRE(false, message)</span></code><span class="koboSpan" id="kobo.909.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.910.1">BOOST_FAIL</span></span><span class="koboSpan" id="kobo.911.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.912.1">"must be implemented"</span></span><span class="koboSpan" id="kobo.913.1">);
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.914.1">BOOST_IS_DEFINED</span></code><span class="koboSpan" id="kobo.915.1"> is used to check whether a particular preprocessor symbol is </span><a id="_idIndexMarker1338"/><span class="koboSpan" id="kobo.916.1">defined at runtime. </span><span class="koboSpan" id="kobo.916.2">It is used together with </span><code class="inlineCode"><span class="koboSpan" id="kobo.917.1">BOOST_TEST</span></code><span class="koboSpan" id="kobo.918.1"> to perform validation and logging:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.919.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.920.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.921.1">BOOST_IS_DEFINED</span></span><span class="koboSpan" id="kobo.922.1">(UNICODE));
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-696"><span class="koboSpan" id="kobo.923.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.924.1">The library defines a variety of macros and manipulators for performing test assertions. </span><span class="koboSpan" id="kobo.924.2">The most commonly used one is </span><code class="inlineCode"><span class="koboSpan" id="kobo.925.1">BOOST_TEST</span></code><span class="koboSpan" id="kobo.926.1">. </span><span class="koboSpan" id="kobo.926.2">This macro simply evaluates an expression; if it fails, it increases the error count but continues the execution of the test case. </span><span class="koboSpan" id="kobo.926.3">It has three variants actually:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.927.1">BOOST_TEST_CHECK</span></code><span class="koboSpan" id="kobo.928.1"> is the same as </span><code class="inlineCode"><span class="koboSpan" id="kobo.929.1">BOOST_TEST</span></code><span class="koboSpan" id="kobo.930.1"> and is used to perform checks, as described in the previous section.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.931.1">BOOST_TEST_WARN</span></code><span class="koboSpan" id="kobo.932.1"> is used for assertions meant to provide information, without increasing the error count and stopping the execution of the test case.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.933.1">BOOST_TEST_REQUIRE</span></code><span class="koboSpan" id="kobo.934.1"> is intended to ensure that pre-conditions that are required for test cases to continue execution are met. </span><span class="koboSpan" id="kobo.934.2">Upon failure, this macro increases the error count and stops the execution of the test case.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.935.1">The general form of the test macro is </span><code class="inlineCode"><span class="koboSpan" id="kobo.936.1">BOOST_TEST(statement)</span></code><span class="koboSpan" id="kobo.937.1">. </span><span class="koboSpan" id="kobo.937.2">This macro provides rich and flexible reporting capabilities. </span><span class="koboSpan" id="kobo.937.3">By default, it shows not only the statement but also the value of the operands, to enable quick identification of the failure’s cause.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.938.1">However, the user could provide an alternative failure description; in this scenario, the message is logged in the test report:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.939.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.940.1">(a == b);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.941.1">// error: in "regular_tests": check a == b has failed [2 != 4]</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.942.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.943.1">(a == b, </span><span class="hljs-string"><span class="koboSpan" id="kobo.944.1">"not equal"</span></span><span class="koboSpan" id="kobo.945.1">);
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.946.1">// error: in "regular_tests": not equal</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.947.1">This macro also</span><a id="_idIndexMarker1339"/><span class="koboSpan" id="kobo.948.1"> allows you to control the comparison process with special support for the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.949.1">The first is a floating-point comparison, where tolerance can be defined to test equality.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.950.1">Secondly, it supports a container’s comparison using several methods: default comparison (using the overloaded operator ==), per-element comparison, and lexicographic comparison (using the lexicographical order). </span><span class="koboSpan" id="kobo.950.2">Per-element comparison enables the comparison of different types of containers (such as vector and list) in the order given by the forward iterators of the container; it also takes into account the size of the container (meaning that it first tests the sizes and, only if they are equal, continues with the comparison of the elements).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.951.1">Lastly, it supports bitwise comparison of the operands. </span><span class="koboSpan" id="kobo.951.2">Upon failure, the framework reports the index of the bit where the comparison failed.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.952.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.953.1">BOOST_TEST</span></code><span class="koboSpan" id="kobo.954.1"> macro does have some limitations. </span><span class="koboSpan" id="kobo.954.2">It cannot be used with compound statements that use a comma, because such statements would be intercepted and handled by the preprocessor or the ternary operator, and compound statements using the logical operators </span><code class="inlineCode"><span class="koboSpan" id="kobo.955.1">||</span></code><span class="koboSpan" id="kobo.956.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.957.1">&amp;&amp;</span></code><span class="koboSpan" id="kobo.958.1">. </span><span class="koboSpan" id="kobo.958.2">The latter cases have a workaround: a second pair of parentheses, as in </span><code class="inlineCode"><span class="koboSpan" id="kobo.959.1">BOOST_TEST((statement))</span></code><span class="koboSpan" id="kobo.960.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.961.1">Several macros are available for testing whether a particular exception is raised during the evaluation of an expression. </span><span class="koboSpan" id="kobo.961.2">In the following list, </span><code class="inlineCode"><span class="koboSpan" id="kobo.962.1">&lt;level&gt;</span></code><span class="koboSpan" id="kobo.963.1"> is either </span><code class="inlineCode"><span class="koboSpan" id="kobo.964.1">CHECK</span></code><span class="koboSpan" id="kobo.965.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.966.1">WARN</span></code><span class="koboSpan" id="kobo.967.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.968.1">REQUIRE</span></code><span class="koboSpan" id="kobo.969.1">:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.970.1">BOOST_&lt;level&gt;_NO_THROW(expr)</span></code><span class="koboSpan" id="kobo.971.1"> checks whether an exception is raised from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.972.1">expr</span></code><span class="koboSpan" id="kobo.973.1"> expression. </span><span class="koboSpan" id="kobo.973.2">Any exception raised during the evaluation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.974.1">expr</span></code><span class="koboSpan" id="kobo.975.1"> is caught by this assertion and is not propagated to the test body. </span><span class="koboSpan" id="kobo.975.2">If any exception occurs, the assertion fails.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.976.1">BOOST_&lt;level&gt;_THROW(expr, exception_type)</span></code><span class="koboSpan" id="kobo.977.1"> checks whether an exception of </span><code class="inlineCode"><span class="koboSpan" id="kobo.978.1">exception_type</span></code><span class="koboSpan" id="kobo.979.1"> is raised from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.980.1">expr</span></code><span class="koboSpan" id="kobo.981.1"> expression. </span><span class="koboSpan" id="kobo.981.2">If the expression </span><code class="inlineCode"><span class="koboSpan" id="kobo.982.1">expr</span></code><span class="koboSpan" id="kobo.983.1"> does not raise any exception, then the assertion fails. </span><span class="koboSpan" id="kobo.983.2">Exceptions of types other than </span><code class="inlineCode"><span class="koboSpan" id="kobo.984.1">exception_type</span></code><span class="koboSpan" id="kobo.985.1"> are not caught by this assertion and can be propagated to the test body. </span><span class="koboSpan" id="kobo.985.2">Uncaught exceptions in a test case are caught by the execution monitor, but they result in failed test cases.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.986.1">BOOST_&lt;level&gt;_EXCEPTION(expr, exception_type, predicate)</span></code><span class="koboSpan" id="kobo.987.1"> checks whether an exception of </span><code class="inlineCode"><span class="koboSpan" id="kobo.988.1">exception_type</span></code><span class="koboSpan" id="kobo.989.1"> is raised from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.990.1">expr</span></code><span class="koboSpan" id="kobo.991.1"> expression. </span><span class="koboSpan" id="kobo.991.2">If so, it passes the expression to the predicate for further examination. </span><span class="koboSpan" id="kobo.991.3">If no exception is raised or an exception of a type different than </span><code class="inlineCode"><span class="koboSpan" id="kobo.992.1">exception_type</span></code><span class="koboSpan" id="kobo.993.1"> is raised, then the assertion behaves like </span><code class="inlineCode"><span class="koboSpan" id="kobo.994.1">BOOST_&lt;level&gt;_THROW</span></code><span class="koboSpan" id="kobo.995.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.996.1">This recipe</span><a id="_idIndexMarker1340"/><span class="koboSpan" id="kobo.997.1"> discussed only the most common APIs for testing and their typical usage. </span><span class="koboSpan" id="kobo.997.2">However, the library provides many more APIs. </span><span class="koboSpan" id="kobo.997.3">For further reference, check the online documentation. </span><span class="koboSpan" id="kobo.997.4">For version 1.83, refer to </span><a href="https://www.boost.org/doc/libs/1_83_0/libs/test/doc/html/index.html"><span class="url"><span class="koboSpan" id="kobo.998.1">https://www.boost.org/doc/libs/1_83_0/libs/test/doc/html/index.html</span></span></a><span class="koboSpan" id="kobo.999.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-697"><span class="koboSpan" id="kobo.1000.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1001.1">Writing and invoking tests with Boost.Test</span></em><span class="koboSpan" id="kobo.1002.1">, to see how to create test suites and test cases using the single-header version of the Boost.Test library, as well as how to run tests</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-698"><span class="koboSpan" id="kobo.1003.1">Using fixtures in Boost.Test</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1004.1">The larger a test module is </span><a id="_idIndexMarker1341"/><span class="koboSpan" id="kobo.1005.1">and the more similar the test cases are, the more likely it is to have test cases that require the same setup, cleanup, and maybe the same data. </span><span class="koboSpan" id="kobo.1005.2">A component that contains these is called a </span><strong class="keyWord"><span class="koboSpan" id="kobo.1006.1">test fixture</span></strong><span class="koboSpan" id="kobo.1007.1"> or </span><strong class="keyWord"><span class="koboSpan" id="kobo.1008.1">test context</span></strong><span class="koboSpan" id="kobo.1009.1">. </span><span class="koboSpan" id="kobo.1009.2">Fixtures</span><a id="_idIndexMarker1342"/><span class="koboSpan" id="kobo.1010.1"> are important to establish a well-defined environment for running tests so </span><a id="_idIndexMarker1343"/><span class="koboSpan" id="kobo.1011.1">that the results are repeatable. </span><span class="koboSpan" id="kobo.1011.2">Examples can include copying a specific set of files to some location before executing the tests and deleting them after, or loading data from a particular data source.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1012.1">Boost.Test provides several ways to define test fixtures for a test case, test suite, or module (globally). </span><span class="koboSpan" id="kobo.1012.2">In this recipe, we will look at how fixtures work.</span></p>
<h2 class="heading-2" id="_idParaDest-699"><span class="koboSpan" id="kobo.1013.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1014.1">The examples in </span><a id="_idIndexMarker1344"/><span class="koboSpan" id="kobo.1015.1">this recipe use the following classes and functions for specifying test unit fixtures:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1016.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1017.1">global_fixture</span></span><span class="koboSpan" id="kobo.1018.1">
{
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1019.1">global_fixture</span></span><span class="koboSpan" id="kobo.1020.1">()  { </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1021.1">BOOST_TEST_MESSAGE</span></span><span class="koboSpan" id="kobo.1022.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1023.1">"global setup"</span></span><span class="koboSpan" id="kobo.1024.1">); }
   ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1025.1">global_fixture</span></span><span class="koboSpan" id="kobo.1026.1">() { </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1027.1">BOOST_TEST_MESSAGE</span></span><span class="koboSpan" id="kobo.1028.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1029.1">"global cleanup"</span></span><span class="koboSpan" id="kobo.1030.1">); }
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.1031.1">int</span></span><span class="koboSpan" id="kobo.1032.1"> g{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.1033.1">1</span></span><span class="koboSpan" id="kobo.1034.1"> };
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1035.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1036.1">standard_fixture</span></span><span class="koboSpan" id="kobo.1037.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1038.1">standard_fixture</span></span><span class="koboSpan" id="kobo.1039.1">()  {</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1040.1">BOOST_TEST_MESSAGE</span></span><span class="koboSpan" id="kobo.1041.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1042.1">"setup"</span></span><span class="koboSpan" id="kobo.1043.1">);}
  ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1044.1">standard_fixture</span></span><span class="koboSpan" id="kobo.1045.1">() {</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1046.1">BOOST_TEST_MESSAGE</span></span><span class="koboSpan" id="kobo.1047.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1048.1">"cleanup"</span></span><span class="koboSpan" id="kobo.1049.1">);}
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1050.1">int</span></span><span class="koboSpan" id="kobo.1051.1"> n {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1052.1">42</span></span><span class="koboSpan" id="kobo.1053.1">};
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1054.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1055.1">extended_fixture</span></span><span class="koboSpan" id="kobo.1056.1">
{
  std::string name;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1057.1">int</span></span><span class="koboSpan" id="kobo.1058.1">         data;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1059.1">extended_fixture</span></span><span class="koboSpan" id="kobo.1060.1">(std::string </span><span class="hljs-type"><span class="koboSpan" id="kobo.1061.1">const</span></span><span class="koboSpan" id="kobo.1062.1"> &amp; n = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1063.1">""</span></span><span class="koboSpan" id="kobo.1064.1">) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1065.1">name</span></span><span class="koboSpan" id="kobo.1066.1">(n), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1067.1">data</span></span><span class="koboSpan" id="kobo.1068.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1069.1">0</span></span><span class="koboSpan" id="kobo.1070.1">) 
  {
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1071.1">BOOST_TEST_MESSAGE</span></span><span class="koboSpan" id="kobo.1072.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1073.1">"setup "</span></span><span class="koboSpan" id="kobo.1074.1">+ name);
  }
  ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1075.1">extended_fixture</span></span><span class="koboSpan" id="kobo.1076.1">()
  {
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1077.1">BOOST_TEST_MESSAGE</span></span><span class="koboSpan" id="kobo.1078.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1079.1">"cleanup "</span></span><span class="koboSpan" id="kobo.1080.1">+ name);
  }
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1081.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1082.1">fixture_setup</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1083.1">()</span></span><span class="koboSpan" id="kobo.1084.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1085.1">BOOST_TEST_MESSAGE</span></span><span class="koboSpan" id="kobo.1086.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1087.1">"fixture setup"</span></span><span class="koboSpan" id="kobo.1088.1">);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1089.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1090.1">fixture_cleanup</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1091.1">()</span></span><span class="koboSpan" id="kobo.1092.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1093.1">BOOST_TEST_MESSAGE</span></span><span class="koboSpan" id="kobo.1094.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1095.1">"fixture cleanup"</span></span><span class="koboSpan" id="kobo.1096.1">);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1097.1">The first </span><a id="_idIndexMarker1345"/><span class="koboSpan" id="kobo.1098.1">two are classes whose constructors represent the setup function and the destructors represent the teardown function. </span><span class="koboSpan" id="kobo.1098.2">At the end of the sample, there is a pair of functions, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1099.1">fixture_setup()</span></code><span class="koboSpan" id="kobo.1100.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1101.1">fixture_cleanup()</span></code><span class="koboSpan" id="kobo.1102.1">, that represent functions for a test’s setup and cleanup.</span></p>
<h2 class="heading-2" id="_idParaDest-700"><span class="koboSpan" id="kobo.1103.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1104.1">Use the following methods to define test fixtures for one or multiple test units:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1105.1">To define a fixture for a particular test case, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1106.1">BOOST_FIXTURE_TEST_CASE</span></code><span class="koboSpan" id="kobo.1107.1"> macro:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1108.1">BOOST_FIXTURE_TEST_CASE</span></span><span class="koboSpan" id="kobo.1109.1">(test_case, extended_fixture)
{
  data++;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1110.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.1111.1">(data == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1112.1">1</span></span><span class="koboSpan" id="kobo.1113.1">);
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1114.1">To define a fixture for all the test cases in a test suite, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1115.1">BOOST_FIXTURE_TEST_SUITE</span></code><span class="koboSpan" id="kobo.1116.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1117.1">BOOST_FIXTURE_TEST_SUITE</span></span><span class="koboSpan" id="kobo.1118.1">(suite1, extended_fixture)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1119.1">BOOST_AUTO_TEST_CASE</span></span><span class="koboSpan" id="kobo.1120.1">(case1)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1121.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.1122.1">(data == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1123.1">0</span></span><span class="koboSpan" id="kobo.1124.1">);
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1125.1">BOOST_AUTO_TEST_CASE</span></span><span class="koboSpan" id="kobo.1126.1">(case2)
{
  data++;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1127.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.1128.1">(data == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1129.1">1</span></span><span class="koboSpan" id="kobo.1130.1">);
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1131.1">BOOST_AUTO_TEST_SUITE_END</span></span><span class="koboSpan" id="kobo.1132.1">()
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1133.1">To define a fixture for all the test units in a test suite, except for one or several test units, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1134.1">BOOST_FIXTURE_TEST_SUITE</span></code><span class="koboSpan" id="kobo.1135.1">. </span><span class="koboSpan" id="kobo.1135.2">You can overwrite it to a particular test unit with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1136.1">BOOST_FIXTURE_TEST_CASE</span></code><span class="koboSpan" id="kobo.1137.1"> for a test case and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1138.1">BOOST_FIXTURE_TEST_SUITE</span></code><span class="koboSpan" id="kobo.1139.1"> for a nested test suite:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1140.1">BOOST_FIXTURE_TEST_SUITE</span></span><span class="koboSpan" id="kobo.1141.1">(suite2, extended_fixture)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1142.1">BOOST_AUTO_TEST_CASE</span></span><span class="koboSpan" id="kobo.1143.1">(case1)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1144.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.1145.1">(data == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1146.1">0</span></span><span class="koboSpan" id="kobo.1147.1">);
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1148.1">BOOST_FIXTURE_TEST_CASE</span></span><span class="koboSpan" id="kobo.1149.1">(case2, standard_fixture)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1150.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.1151.1">(n == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1152.1">42</span></span><span class="koboSpan" id="kobo.1153.1">);
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1154.1">BOOST_AUTO_TEST_SUITE_END</span></span><span class="koboSpan" id="kobo.1155.1">()
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1156.1">To</span><a id="_idIndexMarker1346"/><span class="koboSpan" id="kobo.1157.1"> define more than a single fixture for a test case or test suite, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1158.1">boost::unit_test::fixture</span></code><span class="koboSpan" id="kobo.1159.1"> with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1160.1">BOOST_AUTO_TEST_SUITE</span></code><span class="koboSpan" id="kobo.1161.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1162.1">BOOST_AUTO_TEST_CASE</span></code><span class="koboSpan" id="kobo.1163.1"> macros:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1164.1">BOOST_AUTO_TEST_CASE</span></span><span class="koboSpan" id="kobo.1165.1">(test_case_multifix,
  * boost::unit_test::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1166.1">fixture</span></span><span class="koboSpan" id="kobo.1167.1">&lt;extended_fixture&gt;(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1168.1">string</span></span><span class="koboSpan" id="kobo.1169.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1170.1">"fix1"</span></span><span class="koboSpan" id="kobo.1171.1">))
  * boost::unit_test::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1172.1">fixture</span></span><span class="koboSpan" id="kobo.1173.1">&lt;extended_fixture&gt;(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1174.1">string</span></span><span class="koboSpan" id="kobo.1175.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1176.1">"fix2"</span></span><span class="koboSpan" id="kobo.1177.1">))
  * boost::unit_test::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1178.1">fixture</span></span><span class="koboSpan" id="kobo.1179.1">&lt;standard_fixture&gt;())
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1180.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.1181.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1182.1">true</span></span><span class="koboSpan" id="kobo.1183.1">);
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1184.1">To use free functions as setup and teardown operations in the case of a fixture, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1185.1">boost::unit_test::fixture</span></code><span class="koboSpan" id="kobo.1186.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1187.1">BOOST_AUTO_TEST_CASE</span></span><span class="koboSpan" id="kobo.1188.1">(test_case_funcfix,
  * boost::unit_test::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1189.1">fixture</span></span><span class="koboSpan" id="kobo.1190.1">(&amp;fixture_setup, &amp;fixture_cleanup))
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1191.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.1192.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1193.1">true</span></span><span class="koboSpan" id="kobo.1194.1">);
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1195.1">To define a fixture for the module, use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1196.1">BOOST_GLOBAL_FIXTURE</span></code><span class="koboSpan" id="kobo.1197.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1198.1">BOOST_GLOBAL_FIXTURE</span></span><span class="koboSpan" id="kobo.1199.1">(global_fixture);
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-701"><span class="koboSpan" id="kobo.1200.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1201.1">The library supports a </span><a id="_idIndexMarker1347"/><span class="koboSpan" id="kobo.1202.1">couple of fixture models:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1203.1">A </span><strong class="keyWord"><span class="koboSpan" id="kobo.1204.1">class model</span></strong><span class="koboSpan" id="kobo.1205.1">, where</span><a id="_idIndexMarker1348"/><span class="koboSpan" id="kobo.1206.1"> the constructor acts as the setup function and the destructor as the cleanup function. </span><span class="koboSpan" id="kobo.1206.2">An extended model allows the constructor to have one parameter. </span><span class="koboSpan" id="kobo.1206.3">In the preceding example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1207.1">standard_fixture</span></code><span class="koboSpan" id="kobo.1208.1"> implemented the first model and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1209.1">extended_fixture</span></code><span class="koboSpan" id="kobo.1210.1"> implemented the second model.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1211.1">A </span><strong class="keyWord"><span class="koboSpan" id="kobo.1212.1">pair of free functions</span></strong><span class="koboSpan" id="kobo.1213.1">: one </span><a id="_idIndexMarker1349"/><span class="koboSpan" id="kobo.1214.1">that defines the setup and the other, which is optional, that implements the cleanup code. </span><span class="koboSpan" id="kobo.1214.2">In the preceding example, we came across these when discussing </span><code class="inlineCode"><span class="koboSpan" id="kobo.1215.1">fixture_setup()</span></code><span class="koboSpan" id="kobo.1216.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1217.1">fixture_cleanup()</span></code><span class="koboSpan" id="kobo.1218.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1219.1">Fixtures implemented as classes can also have data members, and these members are made available to the test unit. </span><span class="koboSpan" id="kobo.1219.2">If a fixture is defined for a test suite, it is available implicitly to all the test units that are grouped under this test suite. </span><span class="koboSpan" id="kobo.1219.3">However, it is possible that test units contained in such a test suite could redefine the fixture. </span><span class="koboSpan" id="kobo.1219.4">In this case, the fixture defined in the closest scope is the one available to the test unit.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1220.1">It is possible to define multiple fixtures for a test unit. </span><span class="koboSpan" id="kobo.1220.2">However, this is done with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1221.1">boost::unit_test::fixture()</span></code><span class="koboSpan" id="kobo.1222.1"> decorator, not with macros. </span><span class="koboSpan" id="kobo.1222.2">The test suite and test case are defined, in this case, with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1223.1">BOOST_TEST_SUITE</span></code><span class="koboSpan" id="kobo.1224.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.1225.1">BOOST_AUTO_TEST_SUITE</span></code><span class="koboSpan" id="kobo.1226.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1227.1">BOOST_TEST_CASE</span></code><span class="koboSpan" id="kobo.1228.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.1229.1">BOOST_AUTO_TEST_CASE</span></code><span class="koboSpan" id="kobo.1230.1"> macros. </span><span class="koboSpan" id="kobo.1230.2">Multiple </span><code class="inlineCode"><span class="koboSpan" id="kobo.1231.1">fixture()</span></code><span class="koboSpan" id="kobo.1232.1"> decorators can be composed together with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1233.1">operator *</span></code><span class="koboSpan" id="kobo.1234.1">, as seen in the previous section. </span><span class="koboSpan" id="kobo.1234.2">The purpose of this decorator is to define a setup and a teardown function to be called before and after the execution of the test unit. </span><span class="koboSpan" id="kobo.1234.3">It comes in several forms, either with a pair of functions or with a class where the constructor and destructor play the role of the setup/teardown functions. </span><span class="koboSpan" id="kobo.1234.4">A drawback, or perhaps misleading part, of using the fixture decorator with a class that contains member data is that these members will not be available for the test units.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1235.1">A new fixture object is constructed for each test case when it is executed, and the object is destroyed at the end of the test case.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1236.1">The fixture state is not shared among different test cases. </span><span class="koboSpan" id="kobo.1236.2">Therefore, the constructor and destructor are called once for each test case. </span><span class="koboSpan" id="kobo.1236.3">You must make sure these special functions do not contain code that is supposed to be executed only once per module. </span><span class="koboSpan" id="kobo.1236.4">If this is the case, you should set a global fixture for the entire module.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1237.1">A global fixture</span><a id="_idIndexMarker1350"/><span class="koboSpan" id="kobo.1238.1"> uses the generic test class model (the model with the default constructor); you can define any number of global fixtures (allowing you to organize setup and cleanup by category, if necessary). </span><span class="koboSpan" id="kobo.1238.2">Global fixtures are defined with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1239.1">BOOST_GLOBAL_FIXTURE</span></code><span class="koboSpan" id="kobo.1240.1"> macro, and they have to be defined at the test file scope (not inside any test unit). </span><span class="koboSpan" id="kobo.1240.2">Their purpose is to define setup and teardown functions, represented by the constructor and destructor of a class. </span><span class="koboSpan" id="kobo.1240.3">If the class also defines other members, such as data, these are not available in the test units:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1241.1">BOOST_GLOBAL_FIXTURE</span></span><span class="koboSpan" id="kobo.1242.1">(global_fixture);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1243.1">BOOST_AUTO_TEST_CASE</span></span><span class="koboSpan" id="kobo.1244.1">(test_case_globals)
{
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1245.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.1246.1">(g == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1247.1">1</span></span><span class="koboSpan" id="kobo.1248.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1249.1">// error, g not accessible</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1250.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.1251.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1252.1">true</span></span><span class="koboSpan" id="kobo.1253.1">);
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-702"><span class="koboSpan" id="kobo.1254.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1255.1">Writing and invoking tests with Boost.Test</span></em><span class="koboSpan" id="kobo.1256.1">, to see how to create test suites and test cases using the single-header version of the Boost.Test library, as well as how to run tests</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-703"><span class="koboSpan" id="kobo.1257.1">Controlling output with Boost.Test</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1258.1">The framework provides us with the ability to customize what is shown in the test log and test report </span><a id="_idIndexMarker1351"/><span class="koboSpan" id="kobo.1259.1">and then format the </span><a id="_idIndexMarker1352"/><span class="koboSpan" id="kobo.1260.1">results. </span><span class="koboSpan" id="kobo.1260.2">Currently, there are two that are supported: a </span><strong class="keyWord"><span class="koboSpan" id="kobo.1261.1">human-readable format</span></strong><span class="koboSpan" id="kobo.1262.1"> (or </span><strong class="keyWord"><span class="koboSpan" id="kobo.1263.1">HRF</span></strong><span class="koboSpan" id="kobo.1264.1">) and XML (also with a JUNIT format for the test log). </span><span class="koboSpan" id="kobo.1264.2">However, it is possible to create and add your own format.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1265.1">A human-readable format is any form of encoding data that can be naturally read by humans. </span><span class="koboSpan" id="kobo.1265.2">Text, whether encoded as ASCII or Unicode, is used for this purpose.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1266.1">The </span><a id="_idIndexMarker1353"/><span class="koboSpan" id="kobo.1267.1">configuration of what is shown in the output can be done both at runtime, through command-line switches, and at compile time, through various APIs. </span><span class="koboSpan" id="kobo.1267.2">During the execution of the tests, the framework collects all the events in a log. </span><span class="koboSpan" id="kobo.1267.3">At the end, it produces a report that represents a summary of the execution with different levels of detail. </span><span class="koboSpan" id="kobo.1267.4">In the case of a failure, the report contains detailed information about the location and the cause, including actual and expected values. </span><span class="koboSpan" id="kobo.1267.5">This helps developers quickly identify the error. </span><span class="koboSpan" id="kobo.1267.6">In this recipe, we will see how to control what is written in the log and the report and in which format; we do this using the command-line options at runtime.</span></p>
<h2 class="heading-2" id="_idParaDest-704"><span class="koboSpan" id="kobo.1268.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1269.1">For the examples presented in this recipe, we will use the following test module:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.1270.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1271.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.1272.1"> BOOST_TEST_MODULE Controlling output</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.1273.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1274.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.1275.1">&lt;boost/test/included/unit_test.hpp&gt;</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1276.1">BOOST_AUTO_TEST_CASE</span></span><span class="koboSpan" id="kobo.1277.1">(test_case)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1278.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.1279.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.1280.1">true</span></span><span class="koboSpan" id="kobo.1281.1">);
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1282.1">BOOST_AUTO_TEST_SUITE</span></span><span class="koboSpan" id="kobo.1283.1">(test_suite)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1284.1">BOOST_AUTO_TEST_CASE</span></span><span class="koboSpan" id="kobo.1285.1">(test_case)
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1286.1">int</span></span><span class="koboSpan" id="kobo.1287.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1288.1">42</span></span><span class="koboSpan" id="kobo.1289.1">;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1290.1">BOOST_TEST</span></span><span class="koboSpan" id="kobo.1291.1">(a == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1292.1">0</span></span><span class="koboSpan" id="kobo.1293.1">);
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1294.1">BOOST_AUTO_TEST_SUITE_END</span></span><span class="koboSpan" id="kobo.1295.1">()
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1296.1">The next section presents how to control the test log and the test report’s output through command-line options.</span></p>
<h2 class="heading-2" id="_idParaDest-705"><span class="koboSpan" id="kobo.1297.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1298.1">To control the test log’s output, do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1299.1">Use either the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1300.1">--log_format=&lt;format&gt;</span></code><span class="koboSpan" id="kobo.1301.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1302.1">-f &lt;format&gt;</span></code><span class="koboSpan" id="kobo.1303.1"> command-line option to specify the log format. </span><span class="koboSpan" id="kobo.1303.2">The possible formats are </span><code class="inlineCode"><span class="koboSpan" id="kobo.1304.1">HRF</span></code><span class="koboSpan" id="kobo.1305.1"> (the default value), </span><code class="inlineCode"><span class="koboSpan" id="kobo.1306.1">XML</span></code><span class="koboSpan" id="kobo.1307.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1308.1">JUNIT</span></code><span class="koboSpan" id="kobo.1309.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1310.1">Use either the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1311.1">--log_level=&lt;level&gt;</span></code><span class="koboSpan" id="kobo.1312.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1313.1">-l &lt;level&gt;</span></code><span class="koboSpan" id="kobo.1314.1"> command-line option to specify the log level. </span><span class="koboSpan" id="kobo.1314.2">The possible log levels include </span><code class="inlineCode"><span class="koboSpan" id="kobo.1315.1">error</span></code><span class="koboSpan" id="kobo.1316.1"> (default for HRF and XML), </span><code class="inlineCode"><span class="koboSpan" id="kobo.1317.1">warning</span></code><span class="koboSpan" id="kobo.1318.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1319.1">all</span></code><span class="koboSpan" id="kobo.1320.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1321.1">success</span></code><span class="koboSpan" id="kobo.1322.1"> (the default for JUNIT).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1323.1">Use either the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1324.1">--log_sink=&lt;stream or file name&gt;</span></code><span class="koboSpan" id="kobo.1325.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1326.1">-k &lt;stream or file name&gt;</span></code><span class="koboSpan" id="kobo.1327.1"> command-line option to specify the location where the framework should write the test log. </span><span class="koboSpan" id="kobo.1327.2">The possible options are </span><code class="inlineCode"><span class="koboSpan" id="kobo.1328.1">stdout</span></code><span class="koboSpan" id="kobo.1329.1"> (default for HRF and XML), </span><code class="inlineCode"><span class="koboSpan" id="kobo.1330.1">stderr</span></code><span class="koboSpan" id="kobo.1331.1">, or an arbitrary filename (default for JUNIT).</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1332.1">To control the </span><a id="_idIndexMarker1354"/><span class="koboSpan" id="kobo.1333.1">test report’s output, do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1334.1">Use either the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1335.1">--report_format=&lt;format&gt;</span></code><span class="koboSpan" id="kobo.1336.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1337.1">-m &lt;format&gt;</span></code><span class="koboSpan" id="kobo.1338.1"> command-line option to specify the report format. </span><span class="koboSpan" id="kobo.1338.2">The possible formats are </span><code class="inlineCode"><span class="koboSpan" id="kobo.1339.1">HRF</span></code><span class="koboSpan" id="kobo.1340.1"> (the default value) and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1341.1">XML</span></code><span class="koboSpan" id="kobo.1342.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1343.1">Use either the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1344.1">--report_level=&lt;format&gt;</span></code><span class="koboSpan" id="kobo.1345.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1346.1">-r &lt;format&gt;</span></code><span class="koboSpan" id="kobo.1347.1"> command-line option to specify the report level. </span><span class="koboSpan" id="kobo.1347.2">The possible formats are </span><code class="inlineCode"><span class="koboSpan" id="kobo.1348.1">confirm</span></code><span class="koboSpan" id="kobo.1349.1"> (the default value), </span><code class="inlineCode"><span class="koboSpan" id="kobo.1350.1">no</span></code><span class="koboSpan" id="kobo.1351.1"> (for no report), </span><code class="inlineCode"><span class="koboSpan" id="kobo.1352.1">short</span></code><span class="koboSpan" id="kobo.1353.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1354.1">detailed</span></code><span class="koboSpan" id="kobo.1355.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1356.1">Use either the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1357.1">--report_sink=&lt;stream or file name&gt;</span></code><span class="koboSpan" id="kobo.1358.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1359.1">-e &lt;stream or file name&gt;</span></code><span class="koboSpan" id="kobo.1360.1"> command-line option to specify the location where the framework should write the report log. </span><span class="koboSpan" id="kobo.1360.2">The possible options are </span><code class="inlineCode"><span class="koboSpan" id="kobo.1361.1">stderr</span></code><span class="koboSpan" id="kobo.1362.1"> (the default value), </span><code class="inlineCode"><span class="koboSpan" id="kobo.1363.1">stdout</span></code><span class="koboSpan" id="kobo.1364.1">, or an arbitrary filename.</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-706"><span class="koboSpan" id="kobo.1365.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1366.1">When you run the test module from a console/terminal, you see both the test log and test report, with the test report following the test log. </span><span class="koboSpan" id="kobo.1366.2">For the test module shown earlier, the default output is as follows. </span><span class="koboSpan" id="kobo.1366.3">The first three lines represent the test log, while the last line represents the test report:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1367.1">Running 2 test cases...
</span><span class="koboSpan" id="kobo.1367.2">f:/chapter11bt_05/main.cpp(14): error: in "test_suite/test_case": 
check a == 0 has failed [42 != 0]
*** 1 failure is detected in the test module "Controlling output"
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1368.1">The content of both the test log and test report can be made available in several formats. </span><span class="koboSpan" id="kobo.1368.2">The default is HRF; however, the framework also supports XML, and for the test log, the JUNIT format. </span><span class="koboSpan" id="kobo.1368.3">This is a format intended for automated tools, such as continuous </span><a id="_idIndexMarker1355"/><span class="koboSpan" id="kobo.1369.1">build or integration tools. </span><span class="koboSpan" id="kobo.1369.2">Apart from these options, you can implement your own format for the test log by implementing your own class derived from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1370.1">boost::unit_test::unit_test_log_formatter</span></code><span class="koboSpan" id="kobo.1371.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1372.1">The following example shows how to format the test log (the first example) and the test report (the second example) using XML (each highlighted in bold):</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1373.1">chapter11bt_05.exe -f XML
</span><span class="code-highlight"><strong class="hljs-con-slc"><span class="koboSpan" id="kobo.1374.1">&lt;TestLog&gt;&lt;Error file="f:/chapter11bt_05/main.cpp" </span></strong></span>
<span class="code-highlight"><strong class="hljs-con-slc"><span class="koboSpan" id="kobo.1375.1">line="14"&gt;&lt;![CDATA[check a == 0 has failed [42 != 0]]]&gt;</span></strong></span>
<span class="code-highlight"><strong class="hljs-con-slc"><span class="koboSpan" id="kobo.1376.1">&lt;/Error&gt;&lt;/TestLog&gt;</span></strong></span><span class="koboSpan" id="kobo.1377.1">
*** 1 failure is detected in the test module "Controlling output"
chapter11bt_05.exe -m XML
Running 2 test cases...
</span><span class="koboSpan" id="kobo.1377.2">f:/chapter11bt_05/main.cpp(14): error: in "test_suite/test_case": 
check a == 0 has failed [42 != 0]
</span><span class="code-highlight"><strong class="hljs-con-slc"><span class="koboSpan" id="kobo.1378.1">&lt;TestResult&gt;&lt;TestSuite name="Controlling output" result="failed" </span></strong></span>
<span class="code-highlight"><strong class="hljs-con-slc"><span class="koboSpan" id="kobo.1379.1">assertions_passed="1" assertions_failed="1" warnings_failed="0" </span></strong></span>
<span class="code-highlight"><strong class="hljs-con-slc"><span class="koboSpan" id="kobo.1380.1">expected_failures="0" test_cases_passed="1" </span></strong></span>
<span class="code-highlight"><strong class="hljs-con-slc"><span class="koboSpan" id="kobo.1381.1">test_cases_passed_with_warnings="0" test_cases_failed="1" </span></strong></span>
<span class="code-highlight"><strong class="hljs-con-slc"><span class="koboSpan" id="kobo.1382.1">test_cases_skipped="0" test_cases_aborted="0"&gt;&lt;/TestSuite&gt;</span></strong></span><span class="koboSpan" id="kobo.1383.1">
&lt;/TestResult&gt;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1384.1">The log or report level represents the verbosity of the output. </span><span class="koboSpan" id="kobo.1384.2">The possible values of the verbosity level of a log are shown in the following table, ordered from the lowest to the highest level. </span><span class="koboSpan" id="kobo.1384.3">A higher level in the table includes all the messages of the levels above it:</span></p>
<table class="table-container" id="table002-6">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1385.1">Level</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1386.1">Messages that are reported</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1387.1">nothing</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1388.1">Nothing is logged.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1389.1">fatal_error</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1390.1">System or user fatal errors and all the messages describing failed assertions at the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1391.1">REQUIRE</span></code><span class="koboSpan" id="kobo.1392.1"> level (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1393.1">BOOST_TEST_REQUIRE</span></code><span class="koboSpan" id="kobo.1394.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1395.1">BOOST_REQUIRE_</span></code><span class="koboSpan" id="kobo.1396.1">).</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1397.1">system_error</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1398.1">System non-fatal errors.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1399.1">cpp_exception</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1400.1">Uncaught C++ exceptions.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1401.1">error</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1402.1">Failed assertion at the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1403.1">CHECK</span></code><span class="koboSpan" id="kobo.1404.1"> level (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1405.1">BOOST_TEST</span></code><span class="koboSpan" id="kobo.1406.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1407.1">BOOST_CHECK_</span></code><span class="koboSpan" id="kobo.1408.1">).</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1409.1">warning</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1410.1">Failed assertion at the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1411.1">WARN</span></code><span class="koboSpan" id="kobo.1412.1"> level (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1413.1">BOOST_TEST_WARN</span></code><span class="koboSpan" id="kobo.1414.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1415.1">BOOST_WARN_</span></code><span class="koboSpan" id="kobo.1416.1">).</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1417.1">message</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1418.1">Messages generated by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1419.1">BOOST_TEST_MESSAGE</span></code><span class="koboSpan" id="kobo.1420.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1421.1">test_suite</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1422.1">Notification at the start and finish states of each test unit.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1423.1">all</span></code><span class="koboSpan" id="kobo.1424.1"> / </span><code class="inlineCode"><span class="koboSpan" id="kobo.1425.1">success</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1426.1">All the messages, including passed assertions.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.1427.1">Table 11.2: Possible values for the verbosity level of logs</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1428.1">The available </span><a id="_idIndexMarker1356"/><span class="koboSpan" id="kobo.1429.1">formats of the test report are described in the following table:</span></p>
<table class="table-container" id="table003-6">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1430.1">Level</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1431.1">Description</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1432.1">no</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1433.1">No report is produced.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1434.1">confirm</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1435.1">Passing test</span></strong><span class="koboSpan" id="kobo.1436.1">:</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1437.1">*** No errors detected.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1438.1">Skipped test</span></strong><span class="koboSpan" id="kobo.1439.1">:</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1440.1">*** The &lt;name&gt; test suite was skipped; see the standard output for details.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1441.1">Aborted test</span></strong><span class="koboSpan" id="kobo.1442.1">:</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1443.1">*** The &lt;name&gt; test suite was aborted; see the standard output for details.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1444.1">Failed test without failed assertions</span></strong><span class="koboSpan" id="kobo.1445.1">:</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1446.1">*** Errors were detected in the &lt;name&gt; test suite; see the standard output for details.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1447.1">Failed test</span></strong><span class="koboSpan" id="kobo.1448.1">:</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1449.1">*** N failures are detected in the &lt;name&gt; test suite.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1450.1">Failed test with some failures expected</span></strong><span class="koboSpan" id="kobo.1451.1">:</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1452.1">*** N failures are detected (M failures are expected) in the &lt;name&gt; test suite.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1453.1">detailed</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1454.1">Results are reported in a hierarchical fashion (each test unit is reported as part of the parent test unit), but only relevant information appears. </span><span class="koboSpan" id="kobo.1454.2">Test cases that do not have failing assertions do not produce entries in the report.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1455.1">The test case/suite &lt;name&gt; has passed/was skipped/was aborted/has failed with:</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1456.1">N assertions out of M passed</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1457.1">N assertions out of M failed</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1458.1">N warnings out of M failed</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1459.1">X failures expected</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1460.1">short</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1461.1">Similar to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1462.1">detailed</span></code><span class="koboSpan" id="kobo.1463.1">, but this reports information only to the master test suite.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.1464.1">Table 11.3: Available formats for a test report</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1465.1">The standard </span><a id="_idIndexMarker1357"/><span class="koboSpan" id="kobo.1466.1">output stream (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1467.1">stdout</span></code><span class="koboSpan" id="kobo.1468.1">) is the default location where the test log is written, and the standard error stream (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1469.1">stderr</span></code><span class="koboSpan" id="kobo.1470.1">) is the default location of the test report. </span><span class="koboSpan" id="kobo.1470.2">However, both the test log and test report can be redirected to another stream or file.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1471.1">In addition to these options, it is possible to specify a separate file for reporting memory leaks using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1472.1">--report_memory_leaks_to=&lt;file name&gt;</span></code><span class="koboSpan" id="kobo.1473.1"> command-line option. </span><span class="koboSpan" id="kobo.1473.2">If this option is not present and memory leaks are detected, they are reported to the standard error stream.</span></p>
<h2 class="heading-2" id="_idParaDest-707"><span class="koboSpan" id="kobo.1474.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1475.1">In addition to the options discussed in this recipe, the framework provides additional compile-time APIs for controlling the output. </span><span class="koboSpan" id="kobo.1475.2">For a comprehensive description of these APIs, as well as the features described in this recipe, check the framework documentation at </span><a href="https://www.boost.org/doc/libs/1_83_0/libs/test/doc/html/index.html"><span class="url"><span class="koboSpan" id="kobo.1476.1">https://www.boost.org/doc/libs/1_83_0/libs/test/doc/html/index.html</span></span></a><span class="koboSpan" id="kobo.1477.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-708"><span class="koboSpan" id="kobo.1478.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1479.1">Writing and invoking tests with Boost.Test</span></em><span class="koboSpan" id="kobo.1480.1">, to see how to create test suites and test cases using the single-header version of the Boost.Test library, as well as how to run tests</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1481.1">Asserting with Boost.Test</span></em><span class="koboSpan" id="kobo.1482.1">, to explore the rich set of assertion macros from the Boost.Test library</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-709"><span class="koboSpan" id="kobo.1483.1">Getting started with Google Test</span></h1>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1484.1">Google Test</span></strong><span class="koboSpan" id="kobo.1485.1"> is </span><a id="_idIndexMarker1358"/><span class="koboSpan" id="kobo.1486.1">one of the most widely used testing frameworks for C++. </span><span class="koboSpan" id="kobo.1486.2">The </span><strong class="keyWord"><span class="koboSpan" id="kobo.1487.1">Chromium</span></strong><span class="koboSpan" id="kobo.1488.1"> projects and the </span><strong class="keyWord"><span class="koboSpan" id="kobo.1489.1">LLVM</span></strong><span class="koboSpan" id="kobo.1490.1"> compiler </span><a id="_idIndexMarker1359"/><span class="koboSpan" id="kobo.1491.1">are among the projects </span><a id="_idIndexMarker1360"/><span class="koboSpan" id="kobo.1492.1">that are using it for unit testing. </span><span class="koboSpan" id="kobo.1492.2">Google Test enables developers to write unit tests on multiple platforms using multiple compilers. </span><span class="koboSpan" id="kobo.1492.3">Google Test is a portable, lightweight framework that has a simple yet comprehensive API for writing tests using asserts; here, tests are grouped into test suites and test suites into test programs.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1493.1">The framework provides useful features, such as repeating a test a number of times and breaking a test to invoke the debugger at the first failure. </span><span class="koboSpan" id="kobo.1493.2">Its assertions work regardless of whether exceptions are enabled or not. </span><span class="koboSpan" id="kobo.1493.3">The next recipe will cover the most important features of the framework. </span><span class="koboSpan" id="kobo.1493.4">This recipe will show you how to install the framework and set up your first testing project.</span></p>
<h2 class="heading-2" id="_idParaDest-710"><span class="koboSpan" id="kobo.1494.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1495.1">The Google Test framework, just like Boost.Test, has a macro-based API. </span><span class="koboSpan" id="kobo.1495.2">Although you only need to use the supplied macros for writing tests, a good understanding of macros is recommended in order to use the framework well.</span></p>
<h2 class="heading-2" id="_idParaDest-711"><span class="koboSpan" id="kobo.1496.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1497.1">In order to </span><a id="_idIndexMarker1361"/><span class="koboSpan" id="kobo.1498.1">set up your environment to use Google Test, do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1499.1">Clone or download the Git repository from </span><a href="https://github.com/google/googletest"><span class="url"><span class="koboSpan" id="kobo.1500.1">https://github.com/google/googletest</span></span></a><span class="koboSpan" id="kobo.1501.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1502.1">If you selected to download it, once you’ve done so, unzip the content of the archive.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1503.1">Build the framework using the provided build scripts.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1504.1">To create your first test program using Google Test, do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1505.1">Create a new empty C++ project.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1506.1">Do the necessary setup specific to the development environment you are using to make the framework’s headers folder (called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1507.1">include</span></code><span class="koboSpan" id="kobo.1508.1">) available to the project for including header files.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1509.1">Link the project to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1510.1">gtest</span></code><span class="koboSpan" id="kobo.1511.1"> shared library.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1512.1">Add a new source file to the project with the following content:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.1513.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1514.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.1515.1">&lt;gtest/gtest.h&gt;</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1516.1">TEST</span></span><span class="koboSpan" id="kobo.1517.1">(FirstTestSuite, FirstTest)
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1518.1">int</span></span><span class="koboSpan" id="kobo.1519.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1520.1">42</span></span><span class="koboSpan" id="kobo.1521.1">;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1522.1">ASSERT_TRUE</span></span><span class="koboSpan" id="kobo.1523.1">(a &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1524.1">0</span></span><span class="koboSpan" id="kobo.1525.1">);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1526.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1527.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1528.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1529.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1530.1"> argc, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1531.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1532.1"> **argv)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1533.1">
{
  testing::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1534.1">InitGoogleTest</span></span><span class="koboSpan" id="kobo.1535.1">(&amp;argc, argv);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1536.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1537.1">RUN_ALL_TESTS</span></span><span class="koboSpan" id="kobo.1538.1">();
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1539.1">Build and run the project.</span></li>
</ol>
<h2 class="heading-2" id="_idParaDest-712"><span class="koboSpan" id="kobo.1540.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1541.1">The Google Test framework </span><a id="_idIndexMarker1362"/><span class="koboSpan" id="kobo.1542.1">provides a simple and easy-to-use set of macros for creating tests and writing assertions. </span><span class="koboSpan" id="kobo.1542.2">The structure of the test is also simplified compared to other testing frameworks, such as Boost.Test. </span><span class="koboSpan" id="kobo.1542.3">Tests are grouped into test suites and test suites into test programs.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1543.1">It is important to mention several aspects related to terminology. </span><span class="koboSpan" id="kobo.1543.2">Traditionally, Google Test did not use the term </span><strong class="keyWord"><span class="koboSpan" id="kobo.1544.1">test suite</span></strong><span class="koboSpan" id="kobo.1545.1">. </span><span class="koboSpan" id="kobo.1545.2">A </span><strong class="keyWord"><span class="koboSpan" id="kobo.1546.1">test case</span></strong><span class="koboSpan" id="kobo.1547.1"> in Google Test was basically a test suite and equivalent to the test suites in Boost.Test. </span><span class="koboSpan" id="kobo.1547.2">On the other hand, a </span><strong class="keyWord"><span class="koboSpan" id="kobo.1548.1">test function</span></strong><span class="koboSpan" id="kobo.1549.1"> was equivalent to a test case. </span><span class="koboSpan" id="kobo.1549.2">Because this has led to confusion, Google Test has adhered to the common terminology, used by the </span><strong class="keyWord"><span class="koboSpan" id="kobo.1550.1">International Software Testing Qualifications Board</span></strong><span class="koboSpan" id="kobo.1551.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.1552.1">ISTQB</span></strong><span class="koboSpan" id="kobo.1553.1">), of test cases and test suites and has started to replace this throughout its code and documentation. </span><span class="koboSpan" id="kobo.1553.2">In this book, we will use these terms.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1554.1">The framework provides a rich set of assertions, both fatal and non-fatal, great support for exception handling, and the ability to customize the way tests are executed and how the output should be generated. </span><span class="koboSpan" id="kobo.1554.2">However, unlike with the Boost.Test library, the test suites in Google Test cannot contain other test suites, but only test functions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1555.1">Documentation for the framework is available on the project’s page at GitHub. </span><span class="koboSpan" id="kobo.1555.2">For this edition of this book, I used Google Test framework version 1.14, but the code presented here works with previous versions of the framework and is expected to also work with future versions of the framework. </span><span class="koboSpan" id="kobo.1555.3">The sample code shown in the </span><em class="italic"><span class="koboSpan" id="kobo.1556.1">How to do it…</span></em><span class="koboSpan" id="kobo.1557.1"> section contains the</span><a id="_idIndexMarker1363"/><span class="koboSpan" id="kobo.1558.1"> following parts:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><code class="inlineCode"><span class="koboSpan" id="kobo.1559.1">#include &lt;gtest/gtest.h&gt;</span></code><span class="koboSpan" id="kobo.1560.1"> includes the main header of the framework.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.1561.1">TEST(FirstTestSuite, FirstTest)</span></code><span class="koboSpan" id="kobo.1562.1"> declares a test called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1563.1">FirstTest</span></code><span class="koboSpan" id="kobo.1564.1"> as part of a test suite called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1565.1">FirstTestSuite</span></code><span class="koboSpan" id="kobo.1566.1">. </span><span class="koboSpan" id="kobo.1566.2">These names must be valid C++ identifiers but are not allowed to contain underscores. </span><span class="koboSpan" id="kobo.1566.3">The actual name of a test function is composed through concatenation with an underscore from the name of the test suite and the test name. </span><span class="koboSpan" id="kobo.1566.4">For our example, the name is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1567.1">FirstTestSuite_FirstTest</span></code><span class="koboSpan" id="kobo.1568.1">. </span><span class="koboSpan" id="kobo.1568.2">Tests from different test suites may have the same individual name. </span><span class="koboSpan" id="kobo.1568.3">A test function has no arguments and returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.1569.1">void</span></code><span class="koboSpan" id="kobo.1570.1">. </span><span class="koboSpan" id="kobo.1570.2">Multiple tests can be grouped with the same test suite.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.1571.1">ASSERT_TRUE(a &gt; 0);</span></code><span class="koboSpan" id="kobo.1572.1"> is an assertion macro that yields a fatal error and returns from the current function in case the condition evaluates to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1573.1">false</span></code><span class="koboSpan" id="kobo.1574.1">. </span><span class="koboSpan" id="kobo.1574.2">The framework defines many more assertion macros, which we will see in the </span><em class="italic"><span class="koboSpan" id="kobo.1575.1">Asserting with Google Test</span></em><span class="koboSpan" id="kobo.1576.1"> recipe.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.1577.1">testing::InitGoogleTest(&amp;argc, argv);</span></code><span class="koboSpan" id="kobo.1578.1"> initializes the framework and must be called before </span><code class="inlineCode"><span class="koboSpan" id="kobo.1579.1">RUN_ALL_TESTS()</span></code><span class="koboSpan" id="kobo.1580.1">.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.1581.1">return RUN_ALL_TESTS();</span></code><span class="koboSpan" id="kobo.1582.1"> automatically detects and calls all the tests defined with either the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1583.1">TEST()</span></code><span class="koboSpan" id="kobo.1584.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1585.1">TEST_F()</span></code><span class="koboSpan" id="kobo.1586.1"> macro. </span><span class="koboSpan" id="kobo.1586.2">The return value returned from the macro is used as the return value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1587.1">main()</span></code><span class="koboSpan" id="kobo.1588.1"> function. </span><span class="koboSpan" id="kobo.1588.2">This is important because the automated testing service determines the result of a test program according to the value returned from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1589.1">main()</span></code><span class="koboSpan" id="kobo.1590.1"> function, not the output printed to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1591.1">stdout</span></code><span class="koboSpan" id="kobo.1592.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1593.1">stderr</span></code><span class="koboSpan" id="kobo.1594.1"> streams. </span><span class="koboSpan" id="kobo.1594.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1595.1">RUN_ALL_TESTS()</span></code><span class="koboSpan" id="kobo.1596.1"> macro must be called only once; calling it multiple times is not supported because it conflicts with some advanced features of the framework.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1597.1">Executing this test program will provide the following result:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1598.1">[==========] Running 1 test from 1 test suite.
</span><span class="koboSpan" id="kobo.1598.2">[----------] Global test environment set-up.
</span><span class="koboSpan" id="kobo.1598.3">[----------] 1 test from FirstTestCase
[ RUN      ] FirstTestCase.FirstTestFunction
[       OK ] FirstTestCase.FirstTestFunction (1 ms)
[----------] 1 test from FirstTestCase (1 ms total)
[----------] Global test environment tear-down
[==========] 1 test from 1 test suite ran. </span><span class="koboSpan" id="kobo.1598.4">(2 ms total)
[  PASSED  ] 1 test.
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1599.1">For many test programs, the content of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1600.1">main()</span></code><span class="koboSpan" id="kobo.1601.1"> function is identical to the one shown in </span><a id="_idIndexMarker1364"/><span class="koboSpan" id="kobo.1602.1">this recipe, in the example from the </span><em class="italic"><span class="koboSpan" id="kobo.1603.1">How to do it...</span></em><span class="koboSpan" id="kobo.1604.1"> section. </span><span class="koboSpan" id="kobo.1604.2">To avoid writing such a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1605.1">main()</span></code><span class="koboSpan" id="kobo.1606.1"> function, the framework provides a basic implementation that you can use by linking your program with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1607.1">gtest_main</span></code><span class="koboSpan" id="kobo.1608.1"> shared library.</span></p>
<h2 class="heading-2" id="_idParaDest-713"><span class="koboSpan" id="kobo.1609.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1610.1">The Google Test framework can also be used with other testing frameworks. </span><span class="koboSpan" id="kobo.1610.2">You can write tests using another testing framework, such as Boost.Test or CppUnit, and use the Google Test assertion macros. </span><span class="koboSpan" id="kobo.1610.3">To do so, set the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1611.1">throw_on_failure</span></code><span class="koboSpan" id="kobo.1612.1"> flag, either from the code or command line, with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1613.1">--gtest_throw_on_failure</span></code><span class="koboSpan" id="kobo.1614.1"> argument. </span><span class="koboSpan" id="kobo.1614.2">Alternatively, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1615.1">GTEST_THROW_ON_FAILURE</span></code><span class="koboSpan" id="kobo.1616.1"> environment variable and initialize the framework, as shown in the following code snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.1617.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1618.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.1619.1">"gtest/gtest.h"</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1620.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1621.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1622.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1623.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1624.1"> argc, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1625.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1626.1">** argv)</span></span><span class="koboSpan" id="kobo.1627.1">
{
  testing::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1628.1">GTEST_FLAG</span></span><span class="koboSpan" id="kobo.1629.1">(throw_on_failure) = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1630.1">true</span></span><span class="koboSpan" id="kobo.1631.1">;
  testing::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1632.1">InitGoogleTest</span></span><span class="koboSpan" id="kobo.1633.1">(&amp;argc, argv);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1634.1">When you enable the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1635.1">throw_on_failure</span></code><span class="koboSpan" id="kobo.1636.1"> option, assertions that fail will print an error message and throw an exception, which will be caught by the host testing framework and treated as a failure. </span><span class="koboSpan" id="kobo.1636.2">If exceptions are not enabled, then a failed Google Test assertion will tell your program to exit with a non-zero code, which again will be treated as a failure by the host testing framework.</span></p>
<h2 class="heading-2" id="_idParaDest-714"><span class="koboSpan" id="kobo.1637.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1638.1">Writing and invoking tests with Google Test</span></em><span class="koboSpan" id="kobo.1639.1">, to see how to create tests and test suites using the Google Test library, as well as how to run tests</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1640.1">Asserting with Google Test</span></em><span class="koboSpan" id="kobo.1641.1">, to explore the various assertion macros from the Google Test library</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-715"><span class="koboSpan" id="kobo.1642.1">Writing and invoking tests with Google Test</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1643.1">In the previous recipe, we had a glimpse of what it takes to write simple tests with the Google Test framework. </span><span class="koboSpan" id="kobo.1643.2">Multiple tests can be grouped into a test suite and one or more test suites grouped into </span><a id="_idIndexMarker1365"/><span class="koboSpan" id="kobo.1644.1">a test program. </span><span class="koboSpan" id="kobo.1644.2">In this recipe, we will see how to create and run tests.</span></p>
<h2 class="heading-2" id="_idParaDest-716"><span class="koboSpan" id="kobo.1645.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1646.1">For the sample code in this recipe, we’ll use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1647.1">point3d</span></code><span class="koboSpan" id="kobo.1648.1"> class we discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.1649.1">Writing and invoking tests with Boost.Test</span></em><span class="koboSpan" id="kobo.1650.1"> recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-717"><span class="koboSpan" id="kobo.1651.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1652.1">Use the </span><a id="_idIndexMarker1366"/><span class="koboSpan" id="kobo.1653.1">following macros to create tests:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1654.1">TEST(TestSuiteName, TestName)</span></code><span class="koboSpan" id="kobo.1655.1"> defines a test called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1656.1">TestName</span></code><span class="koboSpan" id="kobo.1657.1"> as part of a test suite called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1658.1">TestSuiteName</span></code><span class="koboSpan" id="kobo.1659.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1660.1">TEST</span></span><span class="koboSpan" id="kobo.1661.1">(TestConstruction, TestConstructor)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1662.1">auto</span></span><span class="koboSpan" id="kobo.1663.1"> p = point3d{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.1664.1">1</span></span><span class="koboSpan" id="kobo.1665.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.1666.1">2</span></span><span class="koboSpan" id="kobo.1667.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.1668.1">3</span></span><span class="koboSpan" id="kobo.1669.1"> };
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1670.1">ASSERT_EQ</span></span><span class="koboSpan" id="kobo.1671.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1672.1">x</span></span><span class="koboSpan" id="kobo.1673.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.1674.1">1</span></span><span class="koboSpan" id="kobo.1675.1">);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1676.1">ASSERT_EQ</span></span><span class="koboSpan" id="kobo.1677.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1678.1">x</span></span><span class="koboSpan" id="kobo.1679.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.1680.1">2</span></span><span class="koboSpan" id="kobo.1681.1">);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1682.1">ASSERT_EQ</span></span><span class="koboSpan" id="kobo.1683.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1684.1">x</span></span><span class="koboSpan" id="kobo.1685.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.1686.1">3</span></span><span class="koboSpan" id="kobo.1687.1">);
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1688.1">TEST</span></span><span class="koboSpan" id="kobo.1689.1">(TestConstruction, TestOrigin)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1690.1">auto</span></span><span class="koboSpan" id="kobo.1691.1"> p = point3d::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1692.1">origin</span></span><span class="koboSpan" id="kobo.1693.1">();
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1694.1">ASSERT_EQ</span></span><span class="koboSpan" id="kobo.1695.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1696.1">x</span></span><span class="koboSpan" id="kobo.1697.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.1698.1">0</span></span><span class="koboSpan" id="kobo.1699.1">);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1700.1">ASSERT_EQ</span></span><span class="koboSpan" id="kobo.1701.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1702.1">x</span></span><span class="koboSpan" id="kobo.1703.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.1704.1">0</span></span><span class="koboSpan" id="kobo.1705.1">);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1706.1">ASSERT_EQ</span></span><span class="koboSpan" id="kobo.1707.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1708.1">x</span></span><span class="koboSpan" id="kobo.1709.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.1710.1">0</span></span><span class="koboSpan" id="kobo.1711.1">);
}
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1712.1">TEST_F(TestSuiteWithFixture, TestName)</span></code><span class="koboSpan" id="kobo.1713.1"> defines a test called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1714.1">TestName</span></code><span class="koboSpan" id="kobo.1715.1"> as part of a test suite, using a fixture called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1716.1">TestSuiteWithFixture</span></code><span class="koboSpan" id="kobo.1717.1">. </span><span class="koboSpan" id="kobo.1717.2">You’ll find details about how this works in the </span><em class="italic"><span class="koboSpan" id="kobo.1718.1">Using test fixtures with Google Test</span></em><span class="koboSpan" id="kobo.1719.1"> recipe.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1720.1">To execute the tests, do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1721.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1722.1">RUN_ALL_TESTS()</span></code><span class="koboSpan" id="kobo.1723.1"> macro to run all the tests defined in the test program. </span><span class="koboSpan" id="kobo.1723.2">This must be called only once from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1724.1">main()</span></code><span class="koboSpan" id="kobo.1725.1"> function after the framework has been initialized.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1726.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1727.1">--gtest_filter=&lt;filter&gt;</span></code><span class="koboSpan" id="kobo.1728.1"> command-line option to filter the tests to run.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1729.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1730.1">--gtest_repeat=&lt;count&gt;</span></code><span class="koboSpan" id="kobo.1731.1"> command-line option to repeat the selected tests the specified number of times.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1732.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1733.1">--gtest_break_on_failure</span></code><span class="koboSpan" id="kobo.1734.1"> command-line option to attach the debugger to debug the test program when the first test fails.</span></li>
</ol>
<h2 class="heading-2" id="_idParaDest-718"><span class="koboSpan" id="kobo.1735.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1736.1">There are </span><a id="_idIndexMarker1367"/><span class="koboSpan" id="kobo.1737.1">several macros available for defining tests (as part of a test case). </span><span class="koboSpan" id="kobo.1737.2">The </span><a id="_idIndexMarker1368"/><span class="koboSpan" id="kobo.1738.1">most common ones are </span><code class="inlineCode"><span class="koboSpan" id="kobo.1739.1">TEST</span></code><span class="koboSpan" id="kobo.1740.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1741.1">TEST_F</span></code><span class="koboSpan" id="kobo.1742.1">. </span><span class="koboSpan" id="kobo.1742.2">The latter is used with fixtures, which will be discussed in detail in the </span><em class="italic"><span class="koboSpan" id="kobo.1743.1">Using test fixtures with Google Test</span></em><span class="koboSpan" id="kobo.1744.1"> recipe. </span><span class="koboSpan" id="kobo.1744.2">Other macros for defining tests are </span><code class="inlineCode"><span class="koboSpan" id="kobo.1745.1">TYPED_TEST</span></code><span class="koboSpan" id="kobo.1746.1"> for writing typed tests and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1747.1">TYPED_TEST_P</span></code><span class="koboSpan" id="kobo.1748.1"> for writing type-parameterized tests. </span><span class="koboSpan" id="kobo.1748.2">However, these are more advanced topics and are beyond the scope of this book. </span><span class="koboSpan" id="kobo.1748.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1749.1">TEST</span></code><span class="koboSpan" id="kobo.1750.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1751.1">TEST_F</span></code><span class="koboSpan" id="kobo.1752.1"> macros take two arguments: the first is the name of the test suite and the second is the name of the test. </span><span class="koboSpan" id="kobo.1752.2">These two arguments form the full name of a test, and they must be valid C++ identifiers; they should not contain underscores, though. </span><span class="koboSpan" id="kobo.1752.3">Different test suites can contain tests with the same name (because the full name is still unique). </span><span class="koboSpan" id="kobo.1752.4">Both macros automatically register the tests with the framework; therefore, no explicit input is required from the user to do this.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1753.1">A test can either fail or succeed. </span><span class="koboSpan" id="kobo.1753.2">A test fails if an assertion fails or an uncaught exception occurs. </span><span class="koboSpan" id="kobo.1753.3">Except for these two instances, the test always succeeds.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1754.1">To invoke the test, call </span><code class="inlineCode"><span class="koboSpan" id="kobo.1755.1">RUN_ALL_TESTS()</span></code><span class="koboSpan" id="kobo.1756.1">. </span><span class="koboSpan" id="kobo.1756.2">However, you can do this only once in a test program and only after the framework has been initialized with a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1757.1">testing::InitGoogleTest()</span></code><span class="koboSpan" id="kobo.1758.1">. </span><span class="koboSpan" id="kobo.1758.2">This macro runs all the tests in the test program. </span><span class="koboSpan" id="kobo.1758.3">However, it is possible that you select only some tests to run. </span><span class="koboSpan" id="kobo.1758.4">You can do this either by setting up an environment variable called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1759.1">GTEST_FILTER</span></code><span class="koboSpan" id="kobo.1760.1"> with the appropriate filter or by passing the filter as a command-line argument with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1761.1">--gtest_filter</span></code><span class="koboSpan" id="kobo.1762.1"> flag. </span><span class="koboSpan" id="kobo.1762.2">If either of these two are present, the framework only runs the tests whose full name matches the filter. </span><span class="koboSpan" id="kobo.1762.3">The filter may include wildcards: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1763.1">*</span></code><span class="koboSpan" id="kobo.1764.1"> to match any string and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1765.1">?</span></code><span class="koboSpan" id="kobo.1766.1"> symbol to match any character. </span><span class="koboSpan" id="kobo.1766.2">Negative patterns (what should be omitted) are introduced with a hyphen (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1767.1">-</span></code><span class="koboSpan" id="kobo.1768.1">). </span><span class="koboSpan" id="kobo.1768.2">The following are examples of filters:</span></p>
<table class="table-container" id="table004-5">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1769.1">Filter</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1770.1">Description</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1771.1">--gtest_filter=*</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1772.1">Run all the tests</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1773.1">--gtest_filter=TestConstruction.*</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1774.1">Run all the tests from the test suite called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1775.1">TestConstruction</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1776.1">--gtest_filter=TestOperations.*-TestOperations.TestLess</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1777.1">Run all the tests from the test suite called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1778.1">TestOperations</span></code><span class="koboSpan" id="kobo.1779.1">, except for a test called </span><code class="inlineCode"><span class="koboSpan" id="kobo.1780.1">TestLess</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1781.1">--gtest_filter=*Operations*:*Construction*</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1782.1">Run all the tests whose full names contain either </span><code class="inlineCode"><span class="koboSpan" id="kobo.1783.1">Operations</span></code><span class="koboSpan" id="kobo.1784.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1785.1">Construction</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1786.1">--gtest_filter=Test?</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1787.1">Run all tests whose names have 5 characters and start with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1788.1">Test</span></code><span class="koboSpan" id="kobo.1789.1">, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1790.1">TestA</span></code><span class="koboSpan" id="kobo.1791.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1792.1">Test0</span></code><span class="koboSpan" id="kobo.1793.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1794.1">Test_</span></code><span class="koboSpan" id="kobo.1795.1">.</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1796.1">--gtest_filter=Test??</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1797.1">Run all tests whose names have 6 characters and start with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1798.1">Test</span></code><span class="koboSpan" id="kobo.1799.1">, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1800.1">TestAB</span></code><span class="koboSpan" id="kobo.1801.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1802.1">Test00</span></code><span class="koboSpan" id="kobo.1803.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1804.1">Test_Z</span></code><span class="koboSpan" id="kobo.1805.1">.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.1806.1">Table 11.4: Examples of filters</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1807.1">The </span><a id="_idIndexMarker1369"/><span class="koboSpan" id="kobo.1808.1">following listing is the output of a test program containing the</span><a id="_idIndexMarker1370"/><span class="koboSpan" id="kobo.1809.1"> tests shown earlier when invoked with the command-line argument </span><code class="inlineCode"><span class="koboSpan" id="kobo.1810.1">--gtest_filter=TestConstruction.*-TestConstruction.TestConstructor</span></code><span class="koboSpan" id="kobo.1811.1">:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1812.1">Note: Google Test filter = TestConstruction.*-TestConstruction.TestConstructor
[==========] Running 1 test from 1 test suite.
</span><span class="koboSpan" id="kobo.1812.2">[----------] Global test environment set-up.
</span><span class="koboSpan" id="kobo.1812.3">[----------] 1 test from TestConstruction
[ RUN      ] TestConstruction.TestOrigin
[       OK ] TestConstruction.TestOrigin (0 ms)
[----------] 1 test from TestConstruction (0 ms total)
[----------] Global test environment tear-down
[==========] 1 test from 1 test suite ran. </span><span class="koboSpan" id="kobo.1812.4">(2 ms total)
[  PASSED  ] 1 test.
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1813.1">It is possible for you to disable some of the tests by prefixing either the name of a test with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1814.1">DISABLED_</span></code><span class="koboSpan" id="kobo.1815.1"> or the name of a test suite with the same identifier, in which case all the tests in the test suite will be disabled. </span><span class="koboSpan" id="kobo.1815.2">This is exemplified here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1816.1">TEST</span></span><span class="koboSpan" id="kobo.1817.1">(TestConstruction, DISABLED_TestConversionConstructor) 
{ </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1818.1">/* ... </span><span class="koboSpan" id="kobo.1818.2">*/</span></span><span class="koboSpan" id="kobo.1819.1"> }
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1820.1">TEST</span></span><span class="koboSpan" id="kobo.1821.1">(DISABLED_TestComparisons, TestEquality) 
{ </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1822.1">/* ... </span><span class="koboSpan" id="kobo.1822.2">*/</span></span><span class="koboSpan" id="kobo.1823.1"> }
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1824.1">TEST</span></span><span class="koboSpan" id="kobo.1825.1">(DISABLED_TestComparisons, TestInequality)
{ </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1826.1">/* ... </span><span class="koboSpan" id="kobo.1826.2">*/</span></span><span class="koboSpan" id="kobo.1827.1"> }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1828.1">None of these</span><a id="_idIndexMarker1371"/><span class="koboSpan" id="kobo.1829.1"> tests will be executed. </span><span class="koboSpan" id="kobo.1829.2">However, you will receive a report in the output stating that you have a number of disabled tests.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1830.1">Keep in mind</span><a id="_idIndexMarker1372"/><span class="koboSpan" id="kobo.1831.1"> that this feature is only meant for temporarily disabling tests. </span><span class="koboSpan" id="kobo.1831.2">This is useful when you need to perform some code changes that make tests fail and you don’t have time to fix them right away. </span><span class="koboSpan" id="kobo.1831.3">Therefore, this feature should be used judiciously.</span></p>
<h2 class="heading-2" id="_idParaDest-719"><span class="koboSpan" id="kobo.1832.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1833.1">Getting started with Google Test</span></em><span class="koboSpan" id="kobo.1834.1">, to learn how to install the Google Test framework and how to create a simple test project</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1835.1">Asserting with Google Test</span></em><span class="koboSpan" id="kobo.1836.1">, to explore the various assertion macros from the Google Test library</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1837.1">Using test fixtures with Google Test</span></em><span class="koboSpan" id="kobo.1838.1">, to learn how to define test fixtures when using the Google Test library</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-720"><span class="koboSpan" id="kobo.1839.1">Asserting with Google Test</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1840.1">The </span><a id="_idIndexMarker1373"/><span class="koboSpan" id="kobo.1841.1">Google Test framework provides a rich set of both fatal and non-fatal assertion macros, which resemble function calls, to verify the tested code. </span><span class="koboSpan" id="kobo.1841.2">When these assertions fail, the framework displays the source file, line number, and relevant error message (including custom error messages) to help developers quickly identify the failed code. </span><span class="koboSpan" id="kobo.1841.3">We have already seen some simple examples of how to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1842.1">ASSERT_TRUE</span></code><span class="koboSpan" id="kobo.1843.1"> macro; in this recipe, we will look at other available macros.</span></p>
<h2 class="heading-2" id="_idParaDest-721"><span class="koboSpan" id="kobo.1844.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1845.1">Use the following macros to verify the tested code:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1846.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1847.1">ASSERT_TRUE(condition)</span></code><span class="koboSpan" id="kobo.1848.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1849.1">EXPECT_TRUE(condition)</span></code><span class="koboSpan" id="kobo.1850.1"> to check whether the condition is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1851.1">true</span></code><span class="koboSpan" id="kobo.1852.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1853.1">ASSERT_FALSE(condition)</span></code><span class="koboSpan" id="kobo.1854.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1855.1">EXPECT_FALSE(condition)</span></code><span class="koboSpan" id="kobo.1856.1"> to check whether the condition is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1857.1">false</span></code><span class="koboSpan" id="kobo.1858.1">, as shown in the following code:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1859.1">EXPECT_TRUE</span></span><span class="koboSpan" id="kobo.1860.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1861.1">2</span></span><span class="koboSpan" id="kobo.1862.1"> + </span><span class="hljs-number"><span class="koboSpan" id="kobo.1863.1">2</span></span><span class="koboSpan" id="kobo.1864.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1865.1">2</span></span><span class="koboSpan" id="kobo.1866.1"> * </span><span class="hljs-number"><span class="koboSpan" id="kobo.1867.1">2</span></span><span class="koboSpan" id="kobo.1868.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1869.1">EXPECT_FALSE</span></span><span class="koboSpan" id="kobo.1870.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1871.1">1</span></span><span class="koboSpan" id="kobo.1872.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1873.1">2</span></span><span class="koboSpan" id="kobo.1874.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1875.1">ASSERT_TRUE</span></span><span class="koboSpan" id="kobo.1876.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1877.1">2</span></span><span class="koboSpan" id="kobo.1878.1"> + </span><span class="hljs-number"><span class="koboSpan" id="kobo.1879.1">2</span></span><span class="koboSpan" id="kobo.1880.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1881.1">2</span></span><span class="koboSpan" id="kobo.1882.1"> * </span><span class="hljs-number"><span class="koboSpan" id="kobo.1883.1">2</span></span><span class="koboSpan" id="kobo.1884.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1885.1">ASSERT_FALSE</span></span><span class="koboSpan" id="kobo.1886.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1887.1">1</span></span><span class="koboSpan" id="kobo.1888.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1889.1">2</span></span><span class="koboSpan" id="kobo.1890.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1891.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1892.1">ASSERT_XX(val1, val2)</span></code><span class="koboSpan" id="kobo.1893.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1894.1">EXPECT_XX(val1, val2)</span></code><span class="koboSpan" id="kobo.1895.1"> to compare two values, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.1896.1">XX</span></code><span class="koboSpan" id="kobo.1897.1"> is one of the following: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1898.1">EQ(val1 == val2)</span></code><span class="koboSpan" id="kobo.1899.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1900.1">NE(val1 != val2)</span></code><span class="koboSpan" id="kobo.1901.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1902.1">LT(val1 &lt; val2)</span></code><span class="koboSpan" id="kobo.1903.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1904.1">LE(val1 &lt;= val2)</span></code><span class="koboSpan" id="kobo.1905.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1906.1">GT(val1 &gt; val2)</span></code><span class="koboSpan" id="kobo.1907.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1908.1">GE(val1 &gt;= val2)</span></code><span class="koboSpan" id="kobo.1909.1">. </span><span class="koboSpan" id="kobo.1909.2">This is illustrated in the following code:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1910.1">auto</span></span><span class="koboSpan" id="kobo.1911.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1912.1">42</span></span><span class="koboSpan" id="kobo.1913.1">, b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1914.1">10</span></span><span class="koboSpan" id="kobo.1915.1">;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1916.1">EXPECT_EQ</span></span><span class="koboSpan" id="kobo.1917.1">(a, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1918.1">42</span></span><span class="koboSpan" id="kobo.1919.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1920.1">EXPECT_NE</span></span><span class="koboSpan" id="kobo.1921.1">(a, b);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1922.1">EXPECT_LT</span></span><span class="koboSpan" id="kobo.1923.1">(b, a);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1924.1">EXPECT_LE</span></span><span class="koboSpan" id="kobo.1925.1">(b, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1926.1">11</span></span><span class="koboSpan" id="kobo.1927.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1928.1">EXPECT_GT</span></span><span class="koboSpan" id="kobo.1929.1">(a, b);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1930.1">EXPECT_GE</span></span><span class="koboSpan" id="kobo.1931.1">(b, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1932.1">10</span></span><span class="koboSpan" id="kobo.1933.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1934.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1935.1">ASSERT_STRXX(str1, str2)</span></code><span class="koboSpan" id="kobo.1936.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1937.1">EXPECT_STRXX(str1, str2)</span></code><span class="koboSpan" id="kobo.1938.1"> to compare two</span><a id="_idIndexMarker1374"/><span class="koboSpan" id="kobo.1939.1"> null-terminated strings, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.1940.1">XX</span></code><span class="koboSpan" id="kobo.1941.1"> is one of the following: </span><code class="inlineCode"><span class="koboSpan" id="kobo.1942.1">EQ</span></code><span class="koboSpan" id="kobo.1943.1"> (the strings have the same content), </span><code class="inlineCode"><span class="koboSpan" id="kobo.1944.1">NE</span></code><span class="koboSpan" id="kobo.1945.1"> (the strings don’t have the same content), </span><code class="inlineCode"><span class="koboSpan" id="kobo.1946.1">CASEEQ</span></code><span class="koboSpan" id="kobo.1947.1"> (the strings have the same content with the case ignored), and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1948.1">CASENE</span></code><span class="koboSpan" id="kobo.1949.1"> (the strings don’t have the same content with the case ignored). </span><span class="koboSpan" id="kobo.1949.2">This is illustrated in the following code snippet:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1950.1">auto</span></span><span class="koboSpan" id="kobo.1951.1"> str = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1952.1">"sample"</span></span><span class="koboSpan" id="kobo.1953.1">;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1954.1">EXPECT_STREQ</span></span><span class="koboSpan" id="kobo.1955.1">(str, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1956.1">"sample"</span></span><span class="koboSpan" id="kobo.1957.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1958.1">EXPECT_STRNE</span></span><span class="koboSpan" id="kobo.1959.1">(str, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1960.1">"simple"</span></span><span class="koboSpan" id="kobo.1961.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1962.1">ASSERT_STRCASEEQ</span></span><span class="koboSpan" id="kobo.1963.1">(str, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1964.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1965.1">SAMPLE"</span></span><span class="koboSpan" id="kobo.1966.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1967.1">ASSERT_STRCASENE</span></span><span class="koboSpan" id="kobo.1968.1">(str, </span><span class="hljs-string"><span class="koboSpan" id="kobo.1969.1">"SIMPLE"</span></span><span class="koboSpan" id="kobo.1970.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1971.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1972.1">ASSERT_FLOAT_EQ(val1, val2)</span></code><span class="koboSpan" id="kobo.1973.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1974.1">EXPECT_FLOAT_EQ(val1, val2)</span></code><span class="koboSpan" id="kobo.1975.1"> to check whether two </span><code class="inlineCode"><span class="koboSpan" id="kobo.1976.1">float</span></code><span class="koboSpan" id="kobo.1977.1"> values are almost equal, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1978.1">ASSERT_DOUBLE_EQ(val1, val2)</span></code><span class="koboSpan" id="kobo.1979.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.1980.1">EXPECT_DOUBLE_EQ(val1, val2)</span></code><span class="koboSpan" id="kobo.1981.1"> to check whether two </span><code class="inlineCode"><span class="koboSpan" id="kobo.1982.1">double</span></code><span class="koboSpan" id="kobo.1983.1"> values are almost equal; they should differ by at most 4 </span><strong class="keyWord"><span class="koboSpan" id="kobo.1984.1">ULP</span></strong><span class="koboSpan" id="kobo.1985.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.1986.1">units in the last place</span></strong><span class="koboSpan" id="kobo.1987.1">). </span><span class="koboSpan" id="kobo.1987.2">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1988.1">ASSERT_NEAR(val1, val2, abserr)</span></code><span class="koboSpan" id="kobo.1989.1"> to check whether the difference between the two values is not greater than the specified absolute value:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1990.1">EXPECT_FLOAT_EQ</span></span><span class="koboSpan" id="kobo.1991.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1992.1">1.9999999f</span></span><span class="koboSpan" id="kobo.1993.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1994.1">1.9999998f</span></span><span class="koboSpan" id="kobo.1995.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1996.1">ASSERT_FLOAT_EQ</span></span><span class="koboSpan" id="kobo.1997.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1998.1">1.9999999f</span></span><span class="koboSpan" id="kobo.1999.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2000.1">1.9999998f</span></span><span class="koboSpan" id="kobo.2001.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2002.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2003.1">ASSERT_THROW(statement, exception_type)</span></code><span class="koboSpan" id="kobo.2004.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2005.1">EXPECT_THROW(statement, exception_type)</span></code><span class="koboSpan" id="kobo.2006.1"> to check whether the statement </span><a id="_idIndexMarker1375"/><span class="koboSpan" id="kobo.2007.1">throws an exception of the specified type, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2008.1">ASSERT_ANY_THROW(statement)</span></code><span class="koboSpan" id="kobo.2009.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2010.1">EXPECT_ANY_THROW(statement)</span></code><span class="koboSpan" id="kobo.2011.1"> to check whether the statement throws an exception of any type, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2012.1">ASSERT_NO_THROW(statement)</span></code><span class="koboSpan" id="kobo.2013.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2014.1">EXPECT_NO_THROW(statement)</span></code><span class="koboSpan" id="kobo.2015.1"> to check whether the statement throws any exception:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2016.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2017.1">function_that_throws</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2018.1">()</span></span><span class="koboSpan" id="kobo.2019.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2020.1">throw</span></span><span class="koboSpan" id="kobo.2021.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2022.1">runtime_error</span></span><span class="koboSpan" id="kobo.2023.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2024.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2025.1">error"</span></span><span class="koboSpan" id="kobo.2026.1">);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2027.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2028.1">function_no_throw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2029.1">()</span></span><span class="koboSpan" id="kobo.2030.1">
{
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2031.1">TEST</span></span><span class="koboSpan" id="kobo.2032.1">(TestAssertions, Exceptions)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2033.1">EXPECT_THROW</span></span><span class="koboSpan" id="kobo.2034.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2035.1">function_that_throws</span></span><span class="koboSpan" id="kobo.2036.1">(), std::runtime_error);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2037.1">EXPECT_ANY_THROW</span></span><span class="koboSpan" id="kobo.2038.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2039.1">function_that_throws</span></span><span class="koboSpan" id="kobo.2040.1">());
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2041.1">EXPECT_NO_THROW</span></span><span class="koboSpan" id="kobo.2042.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2043.1">function_no_throw</span></span><span class="koboSpan" id="kobo.2044.1">());
  
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2045.1">ASSERT_THROW</span></span><span class="koboSpan" id="kobo.2046.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2047.1">function_that_throws</span></span><span class="koboSpan" id="kobo.2048.1">(), std::runtime_error);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2049.1">ASSERT_ANY_THROW</span></span><span class="koboSpan" id="kobo.2050.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2051.1">function_that_throws</span></span><span class="koboSpan" id="kobo.2052.1">());
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2053.1">ASSERT_NO_THROW</span></span><span class="koboSpan" id="kobo.2054.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2055.1">function_no_throw</span></span><span class="koboSpan" id="kobo.2056.1">());
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2057.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2058.1">ASSERT_PRED1(pred, val)</span></code><span class="koboSpan" id="kobo.2059.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2060.1">EXPECT_PRED1(pred, val)</span></code><span class="koboSpan" id="kobo.2061.1"> to check whether </span><code class="inlineCode"><span class="koboSpan" id="kobo.2062.1">pred(val)</span></code><span class="koboSpan" id="kobo.2063.1"> returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.2064.1">true</span></code><span class="koboSpan" id="kobo.2065.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2066.1">ASSERT_PRED2(pred, val1, val2)</span></code><span class="koboSpan" id="kobo.2067.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2068.1">EXPECT_PRED2(pred, val1, val2)</span></code><span class="koboSpan" id="kobo.2069.1"> to check whether </span><code class="inlineCode"><span class="koboSpan" id="kobo.2070.1">pred(val1, val2)</span></code><span class="koboSpan" id="kobo.2071.1"> returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.2072.1">true</span></code><span class="koboSpan" id="kobo.2073.1">, and so </span><a id="_idIndexMarker1376"/><span class="koboSpan" id="kobo.2074.1">on; use this for </span><em class="italic"><span class="koboSpan" id="kobo.2075.1">n</span></em><span class="koboSpan" id="kobo.2076.1">-ary predicate functions or functors:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2077.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2078.1">is_positive</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2079.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2080.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2081.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2082.1"> val)</span></span><span class="koboSpan" id="kobo.2083.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2084.1">return</span></span><span class="koboSpan" id="kobo.2085.1"> val != </span><span class="hljs-number"><span class="koboSpan" id="kobo.2086.1">0</span></span><span class="koboSpan" id="kobo.2087.1">;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2088.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2089.1">is_double</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2090.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2091.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2092.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2093.1"> val1, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2094.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2095.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2096.1"> val2)</span></span><span class="koboSpan" id="kobo.2097.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2098.1">return</span></span><span class="koboSpan" id="kobo.2099.1"> val2 + val2 == val1;
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2100.1">TEST</span></span><span class="koboSpan" id="kobo.2101.1">(TestAssertions, Predicates)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2102.1">EXPECT_PRED1</span></span><span class="koboSpan" id="kobo.2103.1">(is_positive, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2104.1">42</span></span><span class="koboSpan" id="kobo.2105.1">);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2106.1">EXPECT_PRED2</span></span><span class="koboSpan" id="kobo.2107.1">(is_double, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2108.1">42</span></span><span class="koboSpan" id="kobo.2109.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2110.1">21</span></span><span class="koboSpan" id="kobo.2111.1">);
  
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2112.1">ASSERT_PRED1</span></span><span class="koboSpan" id="kobo.2113.1">(is_positive, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2114.1">42</span></span><span class="koboSpan" id="kobo.2115.1">);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2116.1">ASSERT_PRED2</span></span><span class="koboSpan" id="kobo.2117.1">(is_double, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2118.1">42</span></span><span class="koboSpan" id="kobo.2119.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2120.1">21</span></span><span class="koboSpan" id="kobo.2121.1">);
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2122.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2123.1">ASSERT_HRESULT_SUCCEEDED(expr)</span></code><span class="koboSpan" id="kobo.2124.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2125.1">EXPECT_HRESULT_SUCCEEDED(expr)</span></code><span class="koboSpan" id="kobo.2126.1"> to check whether </span><code class="inlineCode"><span class="koboSpan" id="kobo.2127.1">expr</span></code><span class="koboSpan" id="kobo.2128.1"> is a success </span><code class="inlineCode"><span class="koboSpan" id="kobo.2129.1">HRESULT</span></code><span class="koboSpan" id="kobo.2130.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2131.1">ASSERT_HRESULT_FAILED(expr)</span></code><span class="koboSpan" id="kobo.2132.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2133.1">EXPECT_HRESULT_FAILED(expr)</span></code><span class="koboSpan" id="kobo.2134.1"> to check whether </span><code class="inlineCode"><span class="koboSpan" id="kobo.2135.1">expr</span></code><span class="koboSpan" id="kobo.2136.1"> is a failure </span><code class="inlineCode"><span class="koboSpan" id="kobo.2137.1">HRESULT</span></code><span class="koboSpan" id="kobo.2138.1">. </span><span class="koboSpan" id="kobo.2138.2">These assertions are intended to be used on Windows.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2139.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2140.1">FAIL()</span></code><span class="koboSpan" id="kobo.2141.1"> to generate a fatal failure and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2142.1">ADD_FAILURE()</span></code><span class="koboSpan" id="kobo.2143.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2144.1">ADD_FAILURE_AT(filename, line)</span></code><span class="koboSpan" id="kobo.2145.1"> to generate non-fatal failures:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.2146.1">ADD_FAILURE</span></span><span class="koboSpan" id="kobo.2147.1">();
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2148.1">ADD_FAILURE_AT</span></span><span class="koboSpan" id="kobo.2149.1">(__FILE__, __LINE__);
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-722"><span class="koboSpan" id="kobo.2150.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2151.1">All these asserts are available in two versions:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2152.1">ASSERT_*</span></code><span class="koboSpan" id="kobo.2153.1">: This generates fatal failures, preventing further execution of the current test function.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2154.1">EXPECT_*</span></code><span class="koboSpan" id="kobo.2155.1">: This generates non-fatal failures, which means that the execution of the test function continues, even if the assertion fails.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2156.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2157.1">EXPECT_*</span></code><span class="koboSpan" id="kobo.2158.1"> assertion if not meeting the condition is not a critical error or if you want the test function to continue, in order to get as many error messages as possible. </span><span class="koboSpan" id="kobo.2158.2">In other cases, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2159.1">ASSERT_*</span></code><span class="koboSpan" id="kobo.2160.1"> version of the test assertions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2161.1">You will find details about the assertions presented here in the framework’s online documentation, which is available on GitHub at </span><a href="https://github.com/google/googletest"><span class="url"><span class="koboSpan" id="kobo.2162.1">https://github.com/google/googletest</span></span></a><span class="koboSpan" id="kobo.2163.1">; this is where the project is located. </span><span class="koboSpan" id="kobo.2163.2">A special note on floating-point comparison is, however, necessary. </span><span class="koboSpan" id="kobo.2163.3">Due to round-offs (fractional parts cannot be represented as a finite sum of the inverse powers of two), floating-point values do </span><a id="_idIndexMarker1377"/><span class="koboSpan" id="kobo.2164.1">not match exactly. </span><span class="koboSpan" id="kobo.2164.2">Therefore, a comparison should be done within a relative error bound. </span><span class="koboSpan" id="kobo.2164.3">The macros </span><code class="inlineCode"><span class="koboSpan" id="kobo.2165.1">ASSERT_EQ</span></code><span class="koboSpan" id="kobo.2166.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.2167.1">EXPECT_EQ</span></code><span class="koboSpan" id="kobo.2168.1"> are not suitable for comparing floating points, and the framework provides another set of assertions. </span><code class="inlineCode"><span class="koboSpan" id="kobo.2169.1">ASSERT_FLOAT_EQ</span></code><span class="koboSpan" id="kobo.2170.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.2171.1">ASSERT_DOUBLE_EQ</span></code><span class="koboSpan" id="kobo.2172.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2173.1">EXPECT_FLOAT_EQ</span></code><span class="koboSpan" id="kobo.2174.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.2175.1">EXPECT_DOUBLE_EQ</span></code><span class="koboSpan" id="kobo.2176.1"> perform a comparison with a default error of 4 ULP.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.2177.1">ULP is a unit of measurement for the spacing between floating-point numbers, that is, the value the least significant digit represents if it is 1. </span><span class="koboSpan" id="kobo.2177.2">For more information on this, read the </span><em class="italic"><span class="koboSpan" id="kobo.2178.1">Comparing Floating Point Numbers, 2012 Edition</span></em><span class="koboSpan" id="kobo.2179.1"> article by Bruce Dawson: </span><a href="https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/"><span class="url"><span class="koboSpan" id="kobo.2180.1">https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/</span></span></a><span class="koboSpan" id="kobo.2181.1">.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-723"><span class="koboSpan" id="kobo.2182.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2183.1">Writing and invoking tests with Google Test</span></em><span class="koboSpan" id="kobo.2184.1">, to see how to create tests and test suites using the Google Test library, as well as how to run tests</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-724"><span class="koboSpan" id="kobo.2185.1">Using test fixtures with Google Test</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2186.1">The</span><a id="_idIndexMarker1378"/><span class="koboSpan" id="kobo.2187.1"> framework provides support for using fixtures as reusable components for all the tests that are part of a test suite. </span><span class="koboSpan" id="kobo.2187.2">It also provides support for setting up the global environment in which the tests will run. </span><span class="koboSpan" id="kobo.2187.3">In this recipe, you will find stepwise instructions on how to define and use test fixtures, as well as to set up the test environment.</span></p>
<h2 class="heading-2" id="_idParaDest-725"><span class="koboSpan" id="kobo.2188.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2189.1">You should now be familiar with writing and invoking tests using the Google Test framework, a topic that was covered earlier in this chapter, specifically in the </span><em class="italic"><span class="koboSpan" id="kobo.2190.1">Writing and invoking tests with Google Test</span></em><span class="koboSpan" id="kobo.2191.1"> recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-726"><span class="koboSpan" id="kobo.2192.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2193.1">To create and use a test fixture, do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.2194.1">Create a class derived from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2195.1">testing::Test</span></code><span class="koboSpan" id="kobo.2196.1"> class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2197.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2198.1">TestFixture</span></span><span class="koboSpan" id="kobo.2199.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2200.1">public</span></span><span class="koboSpan" id="kobo.2201.1"> testing::Test
{
};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2202.1">Use the </span><a id="_idIndexMarker1379"/><span class="koboSpan" id="kobo.2203.1">constructor to initialize the fixture and the destructor to clean it up:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2204.1">protected</span></span><span class="koboSpan" id="kobo.2205.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2206.1">TestFixture</span></span><span class="koboSpan" id="kobo.2207.1">()
  {
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2208.1">"constructing fixture\n"</span></span><span class="koboSpan" id="kobo.2209.1">;
    data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2210.1">resize</span></span><span class="koboSpan" id="kobo.2211.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2212.1">10</span></span><span class="koboSpan" id="kobo.2213.1">);
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2214.1">iota</span></span><span class="koboSpan" id="kobo.2215.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2216.1">begin</span></span><span class="koboSpan" id="kobo.2217.1">(data), std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2218.1">end</span></span><span class="koboSpan" id="kobo.2219.1">(data), </span><span class="hljs-number"><span class="koboSpan" id="kobo.2220.1">1</span></span><span class="koboSpan" id="kobo.2221.1">);
  }
  ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2222.1">TestFixture</span></span><span class="koboSpan" id="kobo.2223.1">()
  {
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2224.1">"destroying fixture\n"</span></span><span class="koboSpan" id="kobo.2225.1">;
  }
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2226.1">Alternatively, you can override the virtual methods </span><code class="inlineCode"><span class="koboSpan" id="kobo.2227.1">SetUp()</span></code><span class="koboSpan" id="kobo.2228.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2229.1">TearDown()</span></code><span class="koboSpan" id="kobo.2230.1"> for the same purpose.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2231.1">Add member data and functions to the class to make them available to the tests:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2232.1">protected</span></span><span class="koboSpan" id="kobo.2233.1">:
  std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2234.1">int</span></span><span class="koboSpan" id="kobo.2235.1">&gt; data;
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2236.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2237.1">TEST_F</span></code><span class="koboSpan" id="kobo.2238.1"> macro to define tests using fixtures, and specify the fixture class name as the test suite name:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.2239.1">TEST_F</span></span><span class="koboSpan" id="kobo.2240.1">(TestFixture, TestData)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2241.1">ASSERT_EQ</span></span><span class="koboSpan" id="kobo.2242.1">(data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2243.1">size</span></span><span class="koboSpan" id="kobo.2244.1">(), </span><span class="hljs-number"><span class="koboSpan" id="kobo.2245.1">10</span></span><span class="koboSpan" id="kobo.2246.1">);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2247.1">ASSERT_EQ</span></span><span class="koboSpan" id="kobo.2248.1">(data[</span><span class="hljs-number"><span class="koboSpan" id="kobo.2249.1">0</span></span><span class="koboSpan" id="kobo.2250.1">], </span><span class="hljs-number"><span class="koboSpan" id="kobo.2251.1">1</span></span><span class="koboSpan" id="kobo.2252.1">);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2253.1">ASSERT_EQ</span></span><span class="koboSpan" id="kobo.2254.1">(data[data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2255.1">size</span></span><span class="koboSpan" id="kobo.2256.1">()</span><span class="hljs-number"><span class="koboSpan" id="kobo.2257.1">-1</span></span><span class="koboSpan" id="kobo.2258.1">], data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2259.1">size</span></span><span class="koboSpan" id="kobo.2260.1">());
}
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.2261.1">To customize</span><a id="_idIndexMarker1380"/><span class="koboSpan" id="kobo.2262.1"> the setup of the environment for running tests, do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.2263.1">Create a class derived from </span><code class="inlineCode"><span class="koboSpan" id="kobo.2264.1">testing::Environment</span></code><span class="koboSpan" id="kobo.2265.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2266.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2267.1">TestEnvironment</span></span><span class="koboSpan" id="kobo.2268.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2269.1">public</span></span><span class="koboSpan" id="kobo.2270.1"> testing::Environment
{
};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2271.1">Override the virtual methods </span><code class="inlineCode"><span class="koboSpan" id="kobo.2272.1">SetUp()</span></code><span class="koboSpan" id="kobo.2273.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2274.1">TearDown()</span></code><span class="koboSpan" id="kobo.2275.1"> to perform setup and cleanup operations:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2276.1">public</span></span><span class="koboSpan" id="kobo.2277.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2278.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2279.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2280.1">SetUp</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2281.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2282.1">override</span></span><span class="hljs-function"> </span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2283.1">{
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2284.1">"environment setup\n"</span></span><span class="koboSpan" id="kobo.2285.1">;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2286.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2287.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2288.1">TearDown</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2289.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2290.1">override</span></span><span class="hljs-function"> </span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2291.1">{
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2292.1">"environment cleanup\n"</span></span><span class="koboSpan" id="kobo.2293.1">;
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2294.1">int</span></span><span class="koboSpan" id="kobo.2295.1"> n{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2296.1">42</span></span><span class="koboSpan" id="kobo.2297.1"> };
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2298.1">Register the environment with a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2299.1">testing::AddGlobalTestEnvironment()</span></code><span class="koboSpan" id="kobo.2300.1"> before calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.2301.1">RUN_ALL_TESTS()</span></code><span class="koboSpan" id="kobo.2302.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2303.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2304.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2305.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2306.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2307.1"> argc, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2308.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2309.1"> **argv)</span></span><span class="koboSpan" id="kobo.2310.1">
{
  testing::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2311.1">InitGoogleTest</span></span><span class="koboSpan" id="kobo.2312.1">(&amp;argc, argv);
  testing::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2313.1">AddGlobalTestEnvironment</span></span><span class="koboSpan" id="kobo.2314.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2315.1">new</span></span><span class="koboSpan" id="kobo.2316.1"> TestEnvironment{});
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2317.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2318.1">RUN_ALL_TESTS</span></span><span class="koboSpan" id="kobo.2319.1">();
} 
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-727"><span class="koboSpan" id="kobo.2320.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2321.1">Text fixtures enable users to share data configurations between multiple tests. </span><span class="koboSpan" id="kobo.2321.2">Fixture objects are not shared between tests. </span><span class="koboSpan" id="kobo.2321.3">A different fixture object is created for each test that is associated with the text function. </span><span class="koboSpan" id="kobo.2321.4">The following operations are performed by the framework for each test coming from a fixture:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.2322.1">Create a new fixture object.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2323.1">Call its </span><code class="inlineCode"><span class="koboSpan" id="kobo.2324.1">SetUp()</span></code><span class="koboSpan" id="kobo.2325.1"> virtual method.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2326.1">Run the test.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2327.1">Call the fixture’s </span><code class="inlineCode"><span class="koboSpan" id="kobo.2328.1">TearDown()</span></code><span class="koboSpan" id="kobo.2329.1"> virtual method.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2330.1">Destroy the fixture object.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.2331.1">You can set </span><a id="_idIndexMarker1381"/><span class="koboSpan" id="kobo.2332.1">up and clean the fixture objects in two ways: by using the constructor and destructor, or by using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2333.1">SetUp()</span></code><span class="koboSpan" id="kobo.2334.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2335.1">TearDown()</span></code><span class="koboSpan" id="kobo.2336.1"> virtual methods. </span><span class="koboSpan" id="kobo.2336.2">In most cases, the former way is preferred. </span><span class="koboSpan" id="kobo.2336.3">The use of virtual methods is suitable in several cases, though:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2337.1">When the teardown operation throws an exception, as exceptions are not allowed to leave destructors.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2338.1">If you are required to use assertion macros during cleanup and you use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2339.1">--gtest_throw_on_failure</span></code><span class="koboSpan" id="kobo.2340.1"> flag, which determines the macros to be thrown upon a failure occurring.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2341.1">If you need to call virtual methods (which might be overridden in a derived class), as virtual calls should not be invoked from the constructor or destructor.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2342.1">Tests that use fixtures must be defined using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2343.1">TEST_F</span></code><span class="koboSpan" id="kobo.2344.1"> macro (where </span><code class="inlineCode"><span class="koboSpan" id="kobo.2345.1">_F</span></code><span class="koboSpan" id="kobo.2346.1"> stands for fixture). </span><span class="koboSpan" id="kobo.2346.2">Trying to declare them using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2347.1">TEST</span></code><span class="koboSpan" id="kobo.2348.1"> macro will generate compiler errors.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2349.1">The environments in which tests are run can also be customized. </span><span class="koboSpan" id="kobo.2349.2">The mechanism is similar to test fixtures: you derive from the base </span><code class="inlineCode"><span class="koboSpan" id="kobo.2350.1">testing::Environment</span></code><span class="koboSpan" id="kobo.2351.1"> class and override the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2352.1">SetUp()</span></code><span class="koboSpan" id="kobo.2353.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2354.1">TearDown()</span></code><span class="koboSpan" id="kobo.2355.1"> virtual functions. </span><span class="koboSpan" id="kobo.2355.2">Instances of these derived environment classes must be registered with the framework with a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2356.1">testing::AddGlobalTestEnvironment()</span></code><span class="koboSpan" id="kobo.2357.1">; however, this has to be done before you run the tests. </span><span class="koboSpan" id="kobo.2357.2">You can register as many instances as you want, in which case the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2358.1">SetUp()</span></code><span class="koboSpan" id="kobo.2359.1"> method is called for the objects in the order they were registered and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2360.1">TearDown()</span></code><span class="koboSpan" id="kobo.2361.1"> method is called in reverse order. </span><span class="koboSpan" id="kobo.2361.2">You must pass dynamically instantiated objects to this function. </span><span class="koboSpan" id="kobo.2361.3">The framework takes ownership of the objects and deletes them before the program terminates; therefore, do not delete them yourself.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2362.1">Environment objects are not available to the tests, nor intended to provide data to the tests. </span><span class="koboSpan" id="kobo.2362.2">Their purpose is to customize the global environment for running the tests.</span></p>
<h2 class="heading-2" id="_idParaDest-728"><span class="koboSpan" id="kobo.2363.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2364.1">Writing and invoking tests with Google Test</span></em><span class="koboSpan" id="kobo.2365.1">, to see how to create tests and test suites using the Google Test library, as well as how to run tests</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-729"><span class="koboSpan" id="kobo.2366.1">Controlling output with Google Test</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2367.1">By default, the </span><a id="_idIndexMarker1382"/><span class="koboSpan" id="kobo.2368.1">output of a Google Test program goes to the standard stream, printed in a human-readable format. </span><span class="koboSpan" id="kobo.2368.2">The framework provides several options for customizing the output, including printing XML to a disk file in a JUNIT-based format. </span><span class="koboSpan" id="kobo.2368.3">This recipe will explore the options available to control the output.</span></p>
<h2 class="heading-2" id="_idParaDest-730"><span class="koboSpan" id="kobo.2369.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2370.1">For the purpose of this recipe, let’s consider the following test program:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.2371.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2372.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.2373.1">&lt;gtest/gtest.h&gt;</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.2374.1">TEST</span></span><span class="koboSpan" id="kobo.2375.1">(Sample, Test)
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2376.1">auto</span></span><span class="koboSpan" id="kobo.2377.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2378.1">42</span></span><span class="koboSpan" id="kobo.2379.1">;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2380.1">ASSERT_EQ</span></span><span class="koboSpan" id="kobo.2381.1">(a, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2382.1">0</span></span><span class="koboSpan" id="kobo.2383.1">);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2384.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2385.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2386.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2387.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2388.1"> argc, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2389.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2390.1"> **argv)</span></span><span class="koboSpan" id="kobo.2391.1">
{
  testing::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2392.1">InitGoogleTest</span></span><span class="koboSpan" id="kobo.2393.1">(&amp;argc, argv);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2394.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2395.1">RUN_ALL_TESTS</span></span><span class="koboSpan" id="kobo.2396.1">();
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2397.1">Its output is as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2398.1">[==========] Running 1 test from 1 test suite.
</span><span class="koboSpan" id="kobo.2398.2">[----------] Global test environment set-up.
</span><span class="koboSpan" id="kobo.2398.3">[----------] 1 test from Sample
[ RUN      ] Sample.Test
f:\chapter11gt_05\main.cpp(6): error: Expected equality of these values:
  a
    Which is: 42
  0
[  FAILED  ] Sample.Test (1 ms)
[----------] 1 test from Sample (1 ms total)
[----------] Global test environment tear-down
[==========] 1 test from 1 test suite ran. </span><span class="koboSpan" id="kobo.2398.4">(3 ms total)
[  PASSED  ] 0 tests.
</span><span class="koboSpan" id="kobo.2398.5">[  FAILED  ] 1 test, listed below:
[  FAILED  ] Sample.Test
 1 FAILED TEST
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2399.1">We will use this simple testing program to demonstrate the various options we can use to control the program’s output, which are exemplified in the following section.</span></p>
<h2 class="heading-2" id="_idParaDest-731"><span class="koboSpan" id="kobo.2400.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2401.1">To control the </span><a id="_idIndexMarker1383"/><span class="koboSpan" id="kobo.2402.1">output of a test program, you can:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2403.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2404.1">--gtest_output</span></code><span class="koboSpan" id="kobo.2405.1"> command-line option or the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2406.1">GTEST_OUTPUT</span></code><span class="koboSpan" id="kobo.2407.1"> environment variable with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2408.1">xml:filepath</span></code><span class="koboSpan" id="kobo.2409.1"> string to specify the location of a file where the XML report is to be written:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2410.1">chapter11gt_05.exe --gtest_output=xml:report.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;testsuites tests="1" failures="1" disabled="0" errors="0" 
            time="0.007" timestamp="2020-05-18T19:00:17" 
            name="AllTests"&gt;
  &lt;testsuite name="Sample" tests="1" failures="1" disabled="0" 
             errors="0" time="0.002"
             timestamp="2020-05-18T19:00:17"&gt;
    &lt;testcase name="Test" status="run" result="completed" time="0"
              timestamp="2020-05-18T19:00:17" classname="Sample"&gt;
      &lt;failure message="f:\chapter11gt_05\main.cpp:6&amp;#x0A;Expected equality of these values:&amp;#x0A;  a&amp;#x0A;    Which is: 42&amp;#x0A;  0&amp;#x0A;" type=""&gt;&lt;![CDATA[f:\chapter11gt_05\main.cpp:6
Expected equality of these values:
  a
    Which is: 42
  0
]]&gt;&lt;/failure&gt; 
    &lt;/testcase&gt;
  &lt;/testsuite&gt;
&lt;/testsuites&gt;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2411.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2412.1">--gtest_color</span></code><span class="koboSpan" id="kobo.2413.1"> command-line option or the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2414.1">GTEST_COLOR</span></code><span class="koboSpan" id="kobo.2415.1"> environment variable and specify either </span><code class="inlineCode"><span class="koboSpan" id="kobo.2416.1">auto</span></code><span class="koboSpan" id="kobo.2417.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2418.1">yes</span></code><span class="koboSpan" id="kobo.2419.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2420.1">no</span></code><span class="koboSpan" id="kobo.2421.1"> to indicate whether the report should be printed to a terminal using colors or not:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2422.1">chapter11gt_05.exe --gtest_color=no
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2423.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2424.1">--gtest_print_time</span></code><span class="koboSpan" id="kobo.2425.1"> command-line option or the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2426.1">GTEST_PRINT_TIME</span></code><span class="koboSpan" id="kobo.2427.1"> environment variable with the value </span><code class="inlineCode"><span class="koboSpan" id="kobo.2428.1">0</span></code><span class="koboSpan" id="kobo.2429.1"> to suppress the printing </span><a id="_idIndexMarker1384"/><span class="koboSpan" id="kobo.2430.1">time each test takes to execute:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2431.1">chapter11gt_05.exe --gtest_print_time=0
[==========] Running 1 test from 1 test suite.
</span><span class="koboSpan" id="kobo.2431.2">[----------] Global test environment set-up.
</span><span class="koboSpan" id="kobo.2431.3">[----------] 1 test from Sample
[ RUN      ] Sample.Test
f:\chapter11gt_05\main.cpp(6): error: Expected equality of these values:
  a
    Which is: 42
  0
[  FAILED  ] Sample.Test
[----------] Global test environment tear-down
[==========] 1 test from 1 test suite ran.
</span><span class="koboSpan" id="kobo.2431.4">[  PASSED  ] 0 tests.
</span><span class="koboSpan" id="kobo.2431.5">[  FAILED  ] 1 test, listed below:
[  FAILED  ] Sample.Test
 1 FAILED TEST
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-732"><span class="koboSpan" id="kobo.2432.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2433.1">Generating a report in an XML format does not affect the human-readable report printed to the terminal. </span><span class="koboSpan" id="kobo.2433.2">The output path can indicate either a file, a directory (in which case a file with the name of the executable is created – if it already exists from a previous run, it creates a file with a new name by suffixing it with a number), or nothing, in which case the report is written to a file called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2434.1">test_detail.xml</span></code><span class="koboSpan" id="kobo.2435.1"> in the current directory.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2436.1">The XML </span><a id="_idIndexMarker1385"/><span class="koboSpan" id="kobo.2437.1">report format is based on the JUNITReport Ant task and contains the following main elements:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2438.1">&lt;testsuites&gt;</span></code><span class="koboSpan" id="kobo.2439.1">: This is the root element and it corresponds to the entire test program.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2440.1">&lt;testsuite&gt;</span></code><span class="koboSpan" id="kobo.2441.1">: This corresponds to a test suite.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.2442.1">&lt;testcase&gt;</span></code><span class="koboSpan" id="kobo.2443.1">: This corresponds to a test function, as Google Test functions are equivalent to test cases in other frameworks.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2444.1">By default, the framework reports the time it takes for each test to execute. </span><span class="koboSpan" id="kobo.2444.2">This feature can be suppressed using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2445.1">--gtest_print_time</span></code><span class="koboSpan" id="kobo.2446.1"> command-line option or the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2447.1">GTEST_PRINT_TIME</span></code><span class="koboSpan" id="kobo.2448.1"> environment variable, as shown earlier.</span></p>
<h2 class="heading-2" id="_idParaDest-733"><span class="koboSpan" id="kobo.2449.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2450.1">Writing and invoking tests with Google Test</span></em><span class="koboSpan" id="kobo.2451.1">, to see how to create tests and test suites using the Google Test library, as well as how to run tests</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2452.1">Using test fixtures with Google Test</span></em><span class="koboSpan" id="kobo.2453.1">, to learn how to define test fixtures when using the Google Test library</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-734"><span class="koboSpan" id="kobo.2454.1">Getting started with Catch2</span></h1>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2455.1">Catch2</span></strong><span class="koboSpan" id="kobo.2456.1"> is a</span><a id="_idIndexMarker1386"/><span class="koboSpan" id="kobo.2457.1"> multiparadigm testing framework for C++ and Objective-C. </span><span class="koboSpan" id="kobo.2457.2">The name Catch2 follows on from Catch, the first version of the framework, which stands for </span><strong class="keyWord"><span class="koboSpan" id="kobo.2458.1">C++ Automated Test Cases in Headers</span></strong><span class="koboSpan" id="kobo.2459.1">. </span><span class="koboSpan" id="kobo.2459.2">It enables developers to write tests using either the traditional style </span><a id="_idIndexMarker1387"/><span class="koboSpan" id="kobo.2460.1">of test functions grouped in test cases or the </span><strong class="keyWord"><span class="koboSpan" id="kobo.2461.1">behavior-driven development</span></strong><em class="italic"> </em><span class="koboSpan" id="kobo.2462.1">(</span><strong class="keyWord"><span class="koboSpan" id="kobo.2463.1">BDD</span></strong><span class="koboSpan" id="kobo.2464.1">) style with </span><em class="italic"><span class="koboSpan" id="kobo.2465.1">given-when-then</span></em><span class="koboSpan" id="kobo.2466.1"> sections. </span><span class="koboSpan" id="kobo.2466.2">Tests are self-registered and the framework provides several assertion macros; out of these, two are used the most: one fatal (namely, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2467.1">REQUIRE</span></code><span class="koboSpan" id="kobo.2468.1">) and one non-fatal (namely, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2469.1">CHECK</span></code><span class="koboSpan" id="kobo.2470.1">). </span><span class="koboSpan" id="kobo.2470.2">They perform expression decomposition of both the left-hand and right-hand side values, which are logged in case of failure. </span><span class="koboSpan" id="kobo.2470.3">Unlike its first version, Catch2 no</span><a id="_idIndexMarker1388"/><span class="koboSpan" id="kobo.2471.1"> longer supports C++03. </span><span class="koboSpan" id="kobo.2471.2">The current version of Catch2 is v3, which has some significant changes when compared to Catch2 v2, such as the library is no longer a single-header library but works as a regular library (that needs to be compiled), and requires a C++14 compiler.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2472.1">For the remaining recipes of this chapter, we will learn how to write unit tests using Catch2 version 3.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-735"><span class="koboSpan" id="kobo.2473.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2474.1">The Catch2 test framework has a macro-based API. </span><span class="koboSpan" id="kobo.2474.2">Although you only need to use the supplied macros for writing tests, a good understanding of macros is recommended if you want to use the framework well.</span></p>
<h2 class="heading-2" id="_idParaDest-736"><span class="koboSpan" id="kobo.2475.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2476.1">In order to set up your</span><a id="_idIndexMarker1389"/><span class="koboSpan" id="kobo.2477.1"> environment to use the Catch2 testing framework, do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.2478.1">Clone or download the Git repository from </span><a href="https://github.com/catchorg/Catch2"><span class="url"><span class="koboSpan" id="kobo.2479.1">https://github.com/catchorg/Catch2</span></span></a><span class="koboSpan" id="kobo.2480.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2481.1">Once you’ve downloaded the repository, unzip the content of the archive.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.2482.1">To use the v3 version of Catch 2, you have two options:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2483.1">Use library merged (amalgamated) header and source files in your test project. </span><span class="koboSpan" id="kobo.2483.2">These files are called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2484.1">catch_amalgamated.hpp</span></code><span class="koboSpan" id="kobo.2485.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2486.1">catch_amalgamated.cpp</span></code><span class="koboSpan" id="kobo.2487.1">. </span><span class="koboSpan" id="kobo.2487.2">They are located in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2488.1">extras</span></code><span class="koboSpan" id="kobo.2489.1"> folder of the Catch2 library, and you can copy them into your test project if you want. </span><span class="koboSpan" id="kobo.2489.2">The advantage of this is that you don’t have to deal with CMake scripts, at the expense of increased build times.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2490.1">Use CMake to add Catch2 as a static library for your project.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2491.1">To create your first test program using Catch2 and its amalgamated files, do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.2492.1">Create a new empty C++ project.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2493.1">Copy the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2494.1">catch_amalgamated.hpp</span></code><span class="koboSpan" id="kobo.2495.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2496.1">catch_amalgamated.cpp</span></code><span class="koboSpan" id="kobo.2497.1"> files from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2498.1">extras</span></code><span class="koboSpan" id="kobo.2499.1"> folder of the Catch2 library to your test project.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2500.1">Add the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2501.1">catch_amalgamated.cpp</span></code><span class="koboSpan" id="kobo.2502.1"> source file to your project, to be compiled along with your other source files (containing tests).</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2503.1">Add a new source file to the project with the following content:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.2504.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2505.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.2506.1">"catch_amalgamated.hpp"</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.2507.1">TEST_CASE</span></span><span class="koboSpan" id="kobo.2508.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2509.1">"first_test_case"</span></span><span class="koboSpan" id="kobo.2510.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2511.1">"[learn][catch]"</span></span><span class="koboSpan" id="kobo.2512.1">)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2513.1">SECTION</span></span><span class="koboSpan" id="kobo.2514.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2515.1">"first_test_function"</span></span><span class="koboSpan" id="kobo.2516.1">)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2517.1">auto</span></span><span class="koboSpan" id="kobo.2518.1"> i{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2519.1">42</span></span><span class="koboSpan" id="kobo.2520.1"> };
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2521.1">REQUIRE</span></span><span class="koboSpan" id="kobo.2522.1">(i == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2523.1">42</span></span><span class="koboSpan" id="kobo.2524.1">);
  }
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2525.1">Build and run the project.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.2526.1">To create</span><a id="_idIndexMarker1390"/><span class="koboSpan" id="kobo.2527.1"> your first test program with Catch2 using the CMake integration, do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.2528.1">Open a console/command prompt and change the directory to the location of the cloned/unzipped Catch2 files.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2529.1">Build the library using the commands shown below. </span><span class="koboSpan" id="kobo.2529.2">On a Unix system, run:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2530.1">cmake -Bbuild -H. </span><span class="koboSpan" id="kobo.2530.2">-DBUILD_TESTING=OFF
sudo cmake --build build/ --target instal
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2531.1">On a Windows system, execute the following commands from a command prompt running with administrative privileges:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2532.1">cmake -Bbuild -H. </span><span class="koboSpan" id="kobo.2532.2">-DBUILD_TESTING=OFF
cmake --build build/ --target instal
</span></code></pre> </li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="3"><span class="koboSpan" id="kobo.2533.1">Create a new folder (called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2534.1">Test</span></code><span class="koboSpan" id="kobo.2535.1">) for a C++ testing project.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.2536.1">Add a new source file (called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2537.1">main.cpp</span></code><span class="koboSpan" id="kobo.2538.1">) to this folder with the following content:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.2539.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2540.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.2541.1">&lt;catch2/catch_test_macros.hpp&gt;</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.2542.1">TEST_CASE</span></span><span class="koboSpan" id="kobo.2543.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2544.1">"first_test_case"</span></span><span class="koboSpan" id="kobo.2545.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2546.1">"[learn][catch]"</span></span><span class="koboSpan" id="kobo.2547.1">)
{
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2548.1">SECTION</span></span><span class="koboSpan" id="kobo.2549.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2550.1">"first_test_function"</span></span><span class="koboSpan" id="kobo.2551.1">)
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2552.1">auto</span></span><span class="koboSpan" id="kobo.2553.1"> i{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2554.1">42</span></span><span class="koboSpan" id="kobo.2555.1"> };
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2556.1">REQUIRE</span></span><span class="koboSpan" id="kobo.2557.1">(i == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2558.1">42</span></span><span class="koboSpan" id="kobo.2559.1">);
   }
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2560.1">Add a new </span><code class="inlineCode"><span class="koboSpan" id="kobo.2561.1">CMakeLists.txt</span></code><span class="koboSpan" id="kobo.2562.1"> CMake file to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2563.1">Test</span></code><span class="koboSpan" id="kobo.2564.1"> folder with the following content:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2565.1">find_package(Catch2 </span><span class="hljs-number"><span class="koboSpan" id="kobo.2566.1">3</span></span><span class="koboSpan" id="kobo.2567.1"> REQUIRED)
add_executable(Test main.cpp)
target_link_libraries(Test PRIVATE Catch2::Catch2WithMain)
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.2568.1">Run </span><code class="inlineCode"><span class="koboSpan" id="kobo.2569.1">cmake.exe</span></code><span class="koboSpan" id="kobo.2570.1"> to generate/build your project.</span></li>
</ol>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2571.1">There are different ways to set up your project using CMake. </span><span class="koboSpan" id="kobo.2571.2">In this recipe, I provided a minimal example that works, which you can also find with the source files from the GitHub repo. </span><span class="koboSpan" id="kobo.2571.3">Readers experienced with CMake may find better approaches than the one provided here. </span><span class="koboSpan" id="kobo.2571.4">You can learn more about CMake from online resources.</span></p>
</div>
<h2 class="heading-2" id="_idParaDest-737"><span class="koboSpan" id="kobo.2572.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2573.1">Catch2 enables</span><a id="_idIndexMarker1391"/><span class="koboSpan" id="kobo.2574.1"> developers to write test cases as self-registered functions; it can even provide a default implementation for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2575.1">main()</span></code><span class="koboSpan" id="kobo.2576.1"> function so that you can focus on testing code and writing less setup code. </span><span class="koboSpan" id="kobo.2576.2">Test cases are divided into sections that are run in isolation. </span><span class="koboSpan" id="kobo.2576.3">The </span><a id="_idIndexMarker1392"/><span class="koboSpan" id="kobo.2577.1">framework does not adhere to the style of the </span><strong class="keyWord"><span class="koboSpan" id="kobo.2578.1">setup-test-teardown</span></strong><span class="koboSpan" id="kobo.2579.1"> architecture. </span><span class="koboSpan" id="kobo.2579.2">Instead, the test case sections (or rather the innermost ones, since sections can be nested) are the units of testing that are executed, along with their enclosing sections. </span><span class="koboSpan" id="kobo.2579.3">This makes the need for fixtures obsolete because data and setup and teardown code can be reused on multiple levels.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2580.1">Test cases and sections are identified using strings, not identifiers (as in most testing frameworks). </span><span class="koboSpan" id="kobo.2580.2">Test cases can also be tagged so that tests can be executed or listed based on tags. </span><span class="koboSpan" id="kobo.2580.3">Test results are printed in a textual human-readable format; however, they can also be exported to XML, using either a Catch2-specific schema or a JUNIT ANT schema for easy integration with continuous delivery systems. </span><span class="koboSpan" id="kobo.2580.4">The execution of the tests can be parameterized to break upon failure (on Windows and macOS) so that you can attach a debugger and inspect the program.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2581.1">The framework is easy to install and use. </span><span class="koboSpan" id="kobo.2581.2">There are two alternatives, as seen in the </span><em class="italic"><span class="koboSpan" id="kobo.2582.1">How to do it…</span></em><span class="koboSpan" id="kobo.2583.1"> section:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2584.1">Using</span><a id="_idIndexMarker1393"/><span class="koboSpan" id="kobo.2585.1"> the amalgamated files </span><code class="inlineCode"><span class="koboSpan" id="kobo.2586.1">catch_amalgamated.hpp</span></code><span class="koboSpan" id="kobo.2587.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2588.1">catch_amalgamated_cpp</span></code><span class="koboSpan" id="kobo.2589.1">. </span><span class="koboSpan" id="kobo.2589.2">These are a merging of all the header and source files. </span><span class="koboSpan" id="kobo.2589.3">The advantage of using them is that you do not have to worry about building the Catch2 library. </span><span class="koboSpan" id="kobo.2589.4">You only have to copy these files to your desired location (typically inside your project), include the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2590.1">catch_amalgamated</span></code><span class="koboSpan" id="kobo.2591.1">.hpp header in your files that contain tests, and build </span><code class="inlineCode"><span class="koboSpan" id="kobo.2592.1">catch_amalgamated.cpp</span></code><span class="koboSpan" id="kobo.2593.1"> alongside the rest of your source files. </span><span class="koboSpan" id="kobo.2593.2">The disadvantage of using this approach is increased build times.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2594.1">Using Catch2 as a static library. </span><span class="koboSpan" id="kobo.2594.2">This requires you to build the library before using it. </span><span class="koboSpan" id="kobo.2594.3">You can either add the header and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2595.1">lib</span></code><span class="koboSpan" id="kobo.2596.1"> files explicitly to your project, or you can use CMake for this purpose. </span><span class="koboSpan" id="kobo.2596.2">This approach provides the advantage of reduced build times.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2597.1">The sample code shown in the previous section has the following parts:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><code class="inlineCode"><span class="koboSpan" id="kobo.2598.1">#include "catch_amalgamated.hpp"</span></code><span class="koboSpan" id="kobo.2599.1"> includes the amalgamated header of the library that is a merging of all the library headers. </span><span class="koboSpan" id="kobo.2599.2">On the other hand, if you’re using the build version, you only need to include the particular headers that you need, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2600.1">&lt;catch2/catch_test_macros.hpp&gt;</span></code><span class="koboSpan" id="kobo.2601.1">. </span><span class="koboSpan" id="kobo.2601.2">You can include </span><code class="inlineCode"><span class="koboSpan" id="kobo.2602.1">&lt;cathc2/catch_all.hpp&gt;</span></code><span class="koboSpan" id="kobo.2603.1"> but this will include all the library headers, which is not advisable. </span><span class="koboSpan" id="kobo.2603.2">In general, you should only include the headers that you need.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.2604.1">TEST_CASE("first_test_case", "[learn][catch]")</span></code><span class="koboSpan" id="kobo.2605.1"> defines a test case called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2606.1">first_test_case</span></code><span class="koboSpan" id="kobo.2607.1">, which has two associated tags: </span><code class="inlineCode"><span class="koboSpan" id="kobo.2608.1">learn</span></code><span class="koboSpan" id="kobo.2609.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2610.1">catch</span></code><span class="koboSpan" id="kobo.2611.1">. </span><span class="koboSpan" id="kobo.2611.2">Tags are used to select either running or just listing test cases. </span><span class="koboSpan" id="kobo.2611.3">Multiple test cases can be tagged with the same tags.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.2612.1">SECTION("first_test_function")</span></code><span class="koboSpan" id="kobo.2613.1"> defines a section, that is, a test function, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2614.1">first_test_function</span></code><span class="koboSpan" id="kobo.2615.1">, as part of the outer test case.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.2616.1">REQUIRE(i == 42);</span></code><span class="koboSpan" id="kobo.2617.1"> is an assertion that tells the test to fail if the condition is not satisfied.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.2618.1">The output of running this program is as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2619.1">=========================================================
All tests </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2620.1">passed</span></span><span class="koboSpan" id="kobo.2621.1"> (</span><span class="hljs-number"><span class="koboSpan" id="kobo.2622.1">1</span></span><span class="koboSpan" id="kobo.2623.1"> assertion in </span><span class="hljs-number"><span class="koboSpan" id="kobo.2624.1">1</span></span><span class="koboSpan" id="kobo.2625.1"> test cases)
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-738"><span class="koboSpan" id="kobo.2626.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2627.1">As mentioned previously, the </span><a id="_idIndexMarker1394"/><span class="koboSpan" id="kobo.2628.1">framework enables us to write tests using the BDD style with </span><em class="italic"><span class="koboSpan" id="kobo.2629.1">give-when-then</span></em><span class="koboSpan" id="kobo.2630.1"> sections. </span><span class="koboSpan" id="kobo.2630.2">This was made possible using several aliases: </span><code class="inlineCode"><span class="koboSpan" id="kobo.2631.1">SCENARIO</span></code><span class="koboSpan" id="kobo.2632.1"> for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2633.1">TEST_CASE</span></code><span class="koboSpan" id="kobo.2634.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2635.1">GIVE</span></code><span class="koboSpan" id="kobo.2636.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2637.1">WHEN</span></code><span class="koboSpan" id="kobo.2638.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2639.1">AND_WHEN</span></code><span class="koboSpan" id="kobo.2640.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2641.1">THEN</span></code><span class="koboSpan" id="kobo.2642.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2643.1">AND_THEN</span></code><span class="koboSpan" id="kobo.2644.1"> for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2645.1">SECTION</span></code><span class="koboSpan" id="kobo.2646.1">. </span><span class="koboSpan" id="kobo.2646.2">Using this style, we can rewrite the test shown earlier, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.2647.1">SCENARIO</span></span><span class="koboSpan" id="kobo.2648.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2649.1">"first_scenario"</span></span><span class="koboSpan" id="kobo.2650.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2651.1">"[learn][catch]"</span></span><span class="koboSpan" id="kobo.2652.1">)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2653.1">GIVEN</span></span><span class="koboSpan" id="kobo.2654.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2655.1">"an integer"</span></span><span class="koboSpan" id="kobo.2656.1">)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2657.1">auto</span></span><span class="koboSpan" id="kobo.2658.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2659.1">0</span></span><span class="koboSpan" id="kobo.2660.1">;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2661.1">WHEN</span></span><span class="koboSpan" id="kobo.2662.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2663.1">"assigned a value"</span></span><span class="koboSpan" id="kobo.2664.1">)
    {
      i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2665.1">42</span></span><span class="koboSpan" id="kobo.2666.1">;
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2667.1">THEN</span></span><span class="koboSpan" id="kobo.2668.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2669.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2670.1">the value can be read back"</span></span><span class="koboSpan" id="kobo.2671.1">)
      {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2672.1">REQUIRE</span></span><span class="koboSpan" id="kobo.2673.1">(i == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2674.1">42</span></span><span class="koboSpan" id="kobo.2675.1">);
      }
    }
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2676.1">When executed successfully, the program prints the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2677.1">=========================================================
All tests passed (1 assertion in 1 test cases)
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2678.1">However, upon failure (let’s suppose we got the wrong condition: </span><code class="inlineCode"><span class="koboSpan" id="kobo.2679.1">i == 0</span></code><span class="koboSpan" id="kobo.2680.1">), the expression that failed, as well as the values on the left-hand and right-hand sides, are printed in the output, as shown in the following snippet:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2681.1">---------------------------------------------------------------
f:\chapter11ca_01\main.cpp(11)
...............................................................
</span><span class="koboSpan" id="kobo.2681.2">f:\chapter11ca_01\main.cpp(13): FAILED:
  REQUIRE( i == 0 )
with expansion:
  42 == 0
===============================================================
test cases: 1 | 1 failed
assertions: 1 | 1 failed
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2682.1">The output presented </span><a id="_idIndexMarker1395"/><span class="koboSpan" id="kobo.2683.1">here, as well as in other snippets throughout the following recipes, has been slightly trimmed or compressed from the actual console output to make it easier to list within the pages of this book.</span></p>
<h2 class="heading-2" id="_idParaDest-739"><span class="koboSpan" id="kobo.2684.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2685.1">Writing and invoking tests with Catch2</span></em><span class="koboSpan" id="kobo.2686.1">, to see how to create tests with the Catch2 library, either using the traditional style based on test cases or the BDD style with scenarios, as well as how to run tests</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2687.1">Asserting with Catch2</span></em><span class="koboSpan" id="kobo.2688.1">, to explore the various assertion macros from the Catch2 library</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-740"><span class="koboSpan" id="kobo.2689.1">Writing and invoking tests with Catch2</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2690.1">The Catch2 framework enables you to write tests using either the traditional style of test cases and test functions or the BDD style with scenarios and </span><em class="italic"><span class="koboSpan" id="kobo.2691.1">given-when-then</span></em><span class="koboSpan" id="kobo.2692.1"> sections. </span><span class="koboSpan" id="kobo.2692.2">Tests </span><a id="_idIndexMarker1396"/><span class="koboSpan" id="kobo.2693.1">are defined as separate sections of a test case and can be nested as deep as you want. </span><span class="koboSpan" id="kobo.2693.2">Whichever style you prefer, tests are defined with only two base macros. </span><span class="koboSpan" id="kobo.2693.3">This recipe will show what these macros are and how they work.</span></p>
<h2 class="heading-2" id="_idParaDest-741"><span class="koboSpan" id="kobo.2694.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2695.1">To write tests using the</span><a id="_idIndexMarker1397"/><span class="koboSpan" id="kobo.2696.1"> traditional style, with test cases and test functions, do this:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2697.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2698.1">TEST_CASE</span></code><span class="koboSpan" id="kobo.2699.1"> macro to define a test case with a name (as a string), and optionally, a list of its associated tags:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.2700.1">TEST_CASE</span></span><span class="koboSpan" id="kobo.2701.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2702.1">"test construction"</span></span><span class="koboSpan" id="kobo.2703.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2704.1">"[create]"</span></span><span class="koboSpan" id="kobo.2705.1">)
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2706.1">// define sections here</span></span><span class="koboSpan" id="kobo.2707.1">
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2708.1">Use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2709.1">SECTION</span></code><span class="koboSpan" id="kobo.2710.1"> macro to define a test function inside a test case, with the name as a string:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.2711.1">TEST_CASE</span></span><span class="koboSpan" id="kobo.2712.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2713.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2714.1">test construction"</span></span><span class="koboSpan" id="kobo.2715.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2716.1">"[create]"</span></span><span class="koboSpan" id="kobo.2717.1">)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2718.1">SECTION</span></span><span class="koboSpan" id="kobo.2719.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2720.1">"test constructor"</span></span><span class="koboSpan" id="kobo.2721.1">)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2722.1">auto</span></span><span class="koboSpan" id="kobo.2723.1"> p = point3d{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2724.1">1</span></span><span class="koboSpan" id="kobo.2725.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.2726.1">2</span></span><span class="koboSpan" id="kobo.2727.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.2728.1">3</span></span><span class="koboSpan" id="kobo.2729.1"> };
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2730.1">REQUIRE</span></span><span class="koboSpan" id="kobo.2731.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2732.1">x</span></span><span class="koboSpan" id="kobo.2733.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2734.1">1</span></span><span class="koboSpan" id="kobo.2735.1">);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2736.1">REQUIRE</span></span><span class="koboSpan" id="kobo.2737.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2738.1">y</span></span><span class="koboSpan" id="kobo.2739.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2740.1">2</span></span><span class="koboSpan" id="kobo.2741.1">);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2742.1">REQUIRE</span></span><span class="koboSpan" id="kobo.2743.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2744.1">z</span></span><span class="koboSpan" id="kobo.2745.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2746.1">4</span></span><span class="koboSpan" id="kobo.2747.1">);
  }
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2748.1">Define </span><a id="_idIndexMarker1398"/><span class="koboSpan" id="kobo.2749.1">nested sections if you want to reuse the setup and teardown code or organize your tests in a hierarchical structure:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.2750.1">TEST_CASE</span></span><span class="koboSpan" id="kobo.2751.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2752.1">"test operations"</span></span><span class="koboSpan" id="kobo.2753.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.2754.1">"[modify]"</span></span><span class="koboSpan" id="kobo.2755.1">)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2756.1">SECTION</span></span><span class="koboSpan" id="kobo.2757.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2758.1">"test methods"</span></span><span class="koboSpan" id="kobo.2759.1">)
  {
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2760.1">SECTION</span></span><span class="koboSpan" id="kobo.2761.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2762.1">"test offset"</span></span><span class="koboSpan" id="kobo.2763.1">)
    {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2764.1">auto</span></span><span class="koboSpan" id="kobo.2765.1"> p = point3d{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.2766.1">1</span></span><span class="koboSpan" id="kobo.2767.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.2768.1">2</span></span><span class="koboSpan" id="kobo.2769.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.2770.1">3</span></span><span class="koboSpan" id="kobo.2771.1"> };
      p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2772.1">offset</span></span><span class="koboSpan" id="kobo.2773.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2774.1">1</span></span><span class="koboSpan" id="kobo.2775.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2776.1">1</span></span><span class="koboSpan" id="kobo.2777.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2778.1">1</span></span><span class="koboSpan" id="kobo.2779.1">);
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2780.1">REQUIRE</span></span><span class="koboSpan" id="kobo.2781.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2782.1">x</span></span><span class="koboSpan" id="kobo.2783.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2784.1">2</span></span><span class="koboSpan" id="kobo.2785.1">);
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2786.1">REQUIRE</span></span><span class="koboSpan" id="kobo.2787.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2788.1">y</span></span><span class="koboSpan" id="kobo.2789.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2790.1">3</span></span><span class="koboSpan" id="kobo.2791.1">);
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2792.1">REQUIRE</span></span><span class="koboSpan" id="kobo.2793.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2794.1">z</span></span><span class="koboSpan" id="kobo.2795.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2796.1">3</span></span><span class="koboSpan" id="kobo.2797.1">);
    }
  }
}
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2798.1">To write tests </span><a id="_idIndexMarker1399"/><span class="koboSpan" id="kobo.2799.1">using the BDD style, do this:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2800.1">Define scenarios using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2801.1">SCENARIO</span></code><span class="koboSpan" id="kobo.2802.1"> macro, specifying a name for it:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.2803.1">SCENARIO</span></span><span class="koboSpan" id="kobo.2804.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2805.1">"modify existing object"</span></span><span class="koboSpan" id="kobo.2806.1">)
{
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2807.1">// define sections here</span></span><span class="koboSpan" id="kobo.2808.1">
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2809.1">Define nested sections inside the scenario using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2810.1">GIVEN</span></code><span class="koboSpan" id="kobo.2811.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2812.1">WHEN</span></code><span class="koboSpan" id="kobo.2813.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2814.1">THEN</span></code><span class="koboSpan" id="kobo.2815.1"> macros, specifying a name for each of them:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.2816.1">SCENARIO</span></span><span class="koboSpan" id="kobo.2817.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2818.1">"modify existing object"</span></span><span class="koboSpan" id="kobo.2819.1">)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2820.1">GIVEN</span></span><span class="koboSpan" id="kobo.2821.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2822.1">"a default constructed point"</span></span><span class="koboSpan" id="kobo.2823.1">)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2824.1">auto</span></span><span class="koboSpan" id="kobo.2825.1"> p = point3d{};
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2826.1">REQUIRE</span></span><span class="koboSpan" id="kobo.2827.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2828.1">x</span></span><span class="koboSpan" id="kobo.2829.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2830.1">0</span></span><span class="koboSpan" id="kobo.2831.1">);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2832.1">REQUIRE</span></span><span class="koboSpan" id="kobo.2833.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2834.1">y</span></span><span class="koboSpan" id="kobo.2835.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2836.1">0</span></span><span class="koboSpan" id="kobo.2837.1">);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2838.1">REQUIRE</span></span><span class="koboSpan" id="kobo.2839.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2840.1">z</span></span><span class="koboSpan" id="kobo.2841.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2842.1">0</span></span><span class="koboSpan" id="kobo.2843.1">);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2844.1">WHEN</span></span><span class="koboSpan" id="kobo.2845.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2846.1">"increased with 1 unit on all dimensions"</span></span><span class="koboSpan" id="kobo.2847.1">)
    {
      p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2848.1">offset</span></span><span class="koboSpan" id="kobo.2849.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2850.1">1</span></span><span class="koboSpan" id="kobo.2851.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2852.1">1</span></span><span class="koboSpan" id="kobo.2853.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2854.1">1</span></span><span class="koboSpan" id="kobo.2855.1">);
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2856.1">THEN</span></span><span class="koboSpan" id="kobo.2857.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.2858.1">"all coordinates are equal to 1"</span></span><span class="koboSpan" id="kobo.2859.1">)
      {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2860.1">REQUIRE</span></span><span class="koboSpan" id="kobo.2861.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2862.1">x</span></span><span class="koboSpan" id="kobo.2863.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2864.1">1</span></span><span class="koboSpan" id="kobo.2865.1">);
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2866.1">REQUIRE</span></span><span class="koboSpan" id="kobo.2867.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2868.1">y</span></span><span class="koboSpan" id="kobo.2869.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2870.1">1</span></span><span class="koboSpan" id="kobo.2871.1">);
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2872.1">REQUIRE</span></span><span class="koboSpan" id="kobo.2873.1">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2874.1">z</span></span><span class="koboSpan" id="kobo.2875.1">() == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2876.1">1</span></span><span class="koboSpan" id="kobo.2877.1">);
      }
    }
  }
}
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2878.1">To execute</span><a id="_idIndexMarker1400"/><span class="koboSpan" id="kobo.2879.1"> the </span><a id="_idIndexMarker1401"/><span class="koboSpan" id="kobo.2880.1">tests, do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2881.1">To execute all the tests from your program (except hidden ones), run the test program without any command-line arguments (from the ones described in the following code).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2882.1">To execute only a specific set of test cases, provide a filter as a command-line argument. </span><span class="koboSpan" id="kobo.2882.2">This can contain test case names, wildcards, tag names, and tag expressions:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2883.1">chapter11ca_02.exe "test construction"
test construction
   test constructor
-------------------------------------------------
f:\chapter11ca_02\main.cpp(7)
.................................................
</span><span class="koboSpan" id="kobo.2883.2">f:\chapter11ca_02\main.cpp(12): FAILED:
  REQUIRE( p.z() == 4 )
with expansion:
  3 == 4
=================================================
test cases: 1 | 1 failed
assertions: 6 | 5 passed | 1 failed
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2884.1">To execute only a particular section (or set of sections), use the command-line argument </span><code class="inlineCode"><span class="koboSpan" id="kobo.2885.1">--section</span></code><span class="koboSpan" id="kobo.2886.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2887.1">-c</span></code><span class="koboSpan" id="kobo.2888.1"> with the section name (can be used multiple times for multiple sections):
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2889.1">chapter11ca_02.exe "test construction" --section "test origin"
Filters: test construction
==================================================
All tests passed (3 assertions in 1 test case)
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2890.1">To </span><a id="_idIndexMarker1402"/><span class="koboSpan" id="kobo.2891.1">specify the order in which test cases should be run, use the </span><a id="_idIndexMarker1403"/><span class="koboSpan" id="kobo.2892.1">command-line argument </span><code class="inlineCode"><span class="koboSpan" id="kobo.2893.1">--order</span></code><span class="koboSpan" id="kobo.2894.1"> with one of the following values: </span><code class="inlineCode"><span class="koboSpan" id="kobo.2895.1">decl</span></code><span class="koboSpan" id="kobo.2896.1"> (for the order of declaration), </span><code class="inlineCode"><span class="koboSpan" id="kobo.2897.1">lex</span></code><span class="koboSpan" id="kobo.2898.1"> (for lexicographic ordering by name), or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2899.1">rand</span></code><span class="koboSpan" id="kobo.2900.1"> (for a random order determined with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2901.1">std::random_shuffle()</span></code><span class="koboSpan" id="kobo.2902.1">). </span><span class="koboSpan" id="kobo.2902.2">Here’s an illustration of this:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2903.1">chapter11ca_02.exe --order lex
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-742"><span class="koboSpan" id="kobo.2904.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2905.1">Test cases are self-registered and do not require any additional work from the developer to set the test program, other than defining the test cases and test functions. </span><span class="koboSpan" id="kobo.2905.2">Test functions are defined as sections of test cases (using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2906.1">SECTION</span></code><span class="koboSpan" id="kobo.2907.1"> macro), and they can be nested.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2908.1">There is no limit to the depth of section nesting. </span><span class="koboSpan" id="kobo.2908.2">Test cases and test functions, which, from here on, will be referred to as sections, form a tree structure, with the test cases on the root nodes and the most inner sections as leaves. </span><span class="koboSpan" id="kobo.2908.3">When the test program runs, it is the leaf sections that are executed. </span><span class="koboSpan" id="kobo.2908.4">Each leaf section is executed in isolation from the other leaf sections. </span><span class="koboSpan" id="kobo.2908.5">However, the execution path starts at the root test case and continues downward, toward the innermost section. </span><span class="koboSpan" id="kobo.2908.6">All of the code that’s encountered on the path is executed entirely for each run. </span><span class="koboSpan" id="kobo.2908.7">This means that when multiple sections share common code (from a parent section or the test case), the same code is executed once for each section, without any data being shared between executions. </span><span class="koboSpan" id="kobo.2908.8">This has the effect that it eliminates the need for a special fixture approach on the one hand. </span><span class="koboSpan" id="kobo.2908.9">On the other hand, it enables multiple fixtures for each section (everything that is encountered up in the path), a feature that many testing frameworks lack.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2909.1">The BDD style of writing test cases is powered by the same two macros, namely, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2910.1">TEST_CASE</span></code><span class="koboSpan" id="kobo.2911.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2912.1">SECTION</span></code><span class="koboSpan" id="kobo.2913.1">, and the ability to test sections. </span><span class="koboSpan" id="kobo.2913.2">In fact, the macro </span><code class="inlineCode"><span class="koboSpan" id="kobo.2914.1">SCENARIO</span></code><span class="koboSpan" id="kobo.2915.1"> is a redefinition of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2916.1">TEST_CASE</span></code><span class="koboSpan" id="kobo.2917.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2918.1">GIVEN</span></code><span class="koboSpan" id="kobo.2919.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2920.1">WHEN</span></code><span class="koboSpan" id="kobo.2921.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2922.1">AND_WHEN</span></code><span class="koboSpan" id="kobo.2923.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2924.1">THEN</span></code><span class="koboSpan" id="kobo.2925.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2926.1">AND_THEN</span></code><span class="koboSpan" id="kobo.2927.1"> are redefinitions of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2928.1">SECTION</span></code><span class="koboSpan" id="kobo.2929.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.2930.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2931.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.2932.1"> SCENARIO( ... </span><span class="koboSpan" id="kobo.2932.2">) TEST_CASE( </span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2933.1">"Scenario: "</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.2934.1"> __VA_ARGS__ )</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.2935.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2936.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.2937.1"> GIVEN(desc)     INTERNAL_CATCH_DYNAMIC_SECTION(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2938.1">"    Given: "</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.2939.1"> &lt;&lt; desc)</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.2940.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2941.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.2942.1"> AND_GIVEN(desc) INTERNAL_CATCH_DYNAMIC_SECTION(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2943.1">"And given: "</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.2944.1"> &lt;&lt; desc)</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.2945.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2946.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.2947.1"> WHEN(desc)      INTERNAL_CATCH_DYNAMIC_SECTION(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2948.1">"     When: "</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.2949.1"> &lt;&lt; desc)</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.2950.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2951.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.2952.1"> AND_WHEN(desc)  INTERNAL_CATCH_DYNAMIC_SECTION(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2953.1">" And when: "</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.2954.1"> &lt;&lt; desc)</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.2955.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2956.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.2957.1"> THEN(desc)      INTERNAL_CATCH_DYNAMIC_SECTION(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2958.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2959.1">     Then: "</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.2960.1"> &lt;&lt; desc)</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.2961.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2962.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.2963.1"> AND_THEN(desc)  INTERNAL_CATCH_DYNAMIC_SECTION(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2964.1">"      And: "</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.2965.1"> &lt;&lt; desc)</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2966.1">When you </span><a id="_idIndexMarker1404"/><span class="koboSpan" id="kobo.2967.1">execute </span><a id="_idIndexMarker1405"/><span class="koboSpan" id="kobo.2968.1">a test program, all defined tests are run. </span><span class="koboSpan" id="kobo.2968.2">This, however, excludes hidden tests, which are specified either using a name that starts with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2969.1">./</span></code><span class="koboSpan" id="kobo.2970.1"> or a tag that starts with a period. </span><span class="koboSpan" id="kobo.2970.2">It is possible to force the running of hidden tests too by providing the command-line argument </span><code class="inlineCode"><span class="koboSpan" id="kobo.2971.1">[.]</span></code><span class="koboSpan" id="kobo.2972.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2973.1">[hide]</span></code><span class="koboSpan" id="kobo.2974.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2975.1">It is possible to filter the test cases to execute. </span><span class="koboSpan" id="kobo.2975.2">This can be done using either the name or the tags. </span><span class="koboSpan" id="kobo.2975.3">The following table displays some of the possible options:</span></p>
<table class="table-container" id="table005-4">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2976.1">Argument</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.2977.1">Description</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2978.1">"test construction"</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2979.1">The test case called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2980.1">test construction</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2981.1">test*</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2982.1">All test cases that start with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2983.1">test</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2984.1">~"test construction"</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2985.1">All test cases, except the one called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2986.1">test construction</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2987.1">~*equal*</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2988.1">All test cases, except those that contain the word </span><code class="inlineCode"><span class="koboSpan" id="kobo.2989.1">equal</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2990.1">a* ~ab* abc</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2991.1">All tests that start with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2992.1">a</span></code><span class="koboSpan" id="kobo.2993.1">, except those that start with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2994.1">ab</span></code><span class="koboSpan" id="kobo.2995.1">, except </span><code class="inlineCode"><span class="koboSpan" id="kobo.2996.1">abc</span></code><span class="koboSpan" id="kobo.2997.1">, which is included</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.2998.1">[modify]</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.2999.1">All test cases tagged with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3000.1">[modify]</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3001.1">[modify],[compare][op]</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.3002.1">All test cases that are tagged with either </span><code class="inlineCode"><span class="koboSpan" id="kobo.3003.1">[modify]</span></code><span class="koboSpan" id="kobo.3004.1"> or both </span><code class="inlineCode"><span class="koboSpan" id="kobo.3005.1">[compare]</span></code><span class="koboSpan" id="kobo.3006.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3007.1">[op]</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.3008.1">-#sourcefile</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.3009.1">All tests from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3010.1">sourcefile.cpp</span></code><span class="koboSpan" id="kobo.3011.1"> file</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.3012.1">Table 11.5: Examples of filters for the test cases to be executed</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3013.1">The execution of </span><a id="_idIndexMarker1406"/><span class="koboSpan" id="kobo.3014.1">particular test functions is also possible by specifying one or</span><a id="_idIndexMarker1407"/><span class="koboSpan" id="kobo.3015.1"> more section names with the command-line argument </span><code class="inlineCode"><span class="koboSpan" id="kobo.3016.1">--section</span></code><span class="koboSpan" id="kobo.3017.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3018.1">-c</span></code><span class="koboSpan" id="kobo.3019.1">. </span><span class="koboSpan" id="kobo.3019.2">However, wildcards are not supported for this option. </span><span class="koboSpan" id="kobo.3019.3">If you specify a section to run, be aware that the entire test path from the root test case to the selected section will be executed. </span><span class="koboSpan" id="kobo.3019.4">Moreover, if you do not specify a test case or a set of test cases first, then all the test cases will be executed, though only the matching sections within them.</span></p>
<h2 class="heading-2" id="_idParaDest-743"><span class="koboSpan" id="kobo.3020.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3021.1">Getting started with Catch2</span></em><span class="koboSpan" id="kobo.3022.1">, to learn how to install the Catch2 framework and how to create a simple test project</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3023.1">Asserting with Catch2</span></em><span class="koboSpan" id="kobo.3024.1">, to explore the various assertion macros from the Catch2 library</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-744"><span class="koboSpan" id="kobo.3025.1">Asserting with Catch2</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3026.1">Unlike other</span><a id="_idIndexMarker1408"/><span class="koboSpan" id="kobo.3027.1"> testing frameworks, Catch2 does not provide a large set of assertion macros. </span><span class="koboSpan" id="kobo.3027.2">It has two main macros: </span><code class="inlineCode"><span class="koboSpan" id="kobo.3028.1">REQUIRE</span></code><span class="koboSpan" id="kobo.3029.1">, which produces a fatal error, stopping the execution of the test case upon failure, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3030.1">CHECK</span></code><span class="koboSpan" id="kobo.3031.1">, which produces a non-fatal error upon failure, continuing the execution of the test case. </span><span class="koboSpan" id="kobo.3031.2">Several additional macros are defined; in this recipe, we will see how to put them to work.</span></p>
<h2 class="heading-2" id="_idParaDest-745"><span class="koboSpan" id="kobo.3032.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3033.1">You should now be familiar with writing test cases and test functions using Catch2, a topic we covered in the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.3034.1">Writing and invoking tests with Catch2</span></em><span class="koboSpan" id="kobo.3035.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-746"><span class="koboSpan" id="kobo.3036.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3037.1">The following list contains the available options for asserting with the Catch2 framework:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3038.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3039.1">CHECK(expr)</span></code><span class="koboSpan" id="kobo.3040.1"> to check whether </span><code class="inlineCode"><span class="koboSpan" id="kobo.3041.1">expr</span></code><span class="koboSpan" id="kobo.3042.1"> evaluates to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3043.1">true</span></code><span class="koboSpan" id="kobo.3044.1">, continuing the execution in case of failure, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3045.1">REQUIRE(expr)</span></code><span class="koboSpan" id="kobo.3046.1"> to make sure that </span><code class="inlineCode"><span class="koboSpan" id="kobo.3047.1">expr</span></code><span class="koboSpan" id="kobo.3048.1"> evaluates to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3049.1">true</span></code><span class="koboSpan" id="kobo.3050.1">, stopping the execution of the test in case of failure:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.3051.1">int</span></span><span class="koboSpan" id="kobo.3052.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3053.1">42</span></span><span class="koboSpan" id="kobo.3054.1">;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3055.1">CHECK</span></span><span class="koboSpan" id="kobo.3056.1">(a == </span><span class="hljs-number"><span class="koboSpan" id="kobo.3057.1">42</span></span><span class="koboSpan" id="kobo.3058.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3059.1">REQUIRE</span></span><span class="koboSpan" id="kobo.3060.1">(a == </span><span class="hljs-number"><span class="koboSpan" id="kobo.3061.1">42</span></span><span class="koboSpan" id="kobo.3062.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3063.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3064.1">CHECK_FALSE(expr)</span></code><span class="koboSpan" id="kobo.3065.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3066.1">REQUIRE_FALSE(expr)</span></code><span class="koboSpan" id="kobo.3067.1"> to make sure that </span><code class="inlineCode"><span class="koboSpan" id="kobo.3068.1">expr</span></code><span class="koboSpan" id="kobo.3069.1"> evaluates</span><a id="_idIndexMarker1409"/><span class="koboSpan" id="kobo.3070.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3071.1">false</span></code><span class="koboSpan" id="kobo.3072.1"> and produces either a non-fatal or fatal error in case of failure:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.3073.1">int</span></span><span class="koboSpan" id="kobo.3074.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3075.1">42</span></span><span class="koboSpan" id="kobo.3076.1">;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3077.1">CHECK_FALSE</span></span><span class="koboSpan" id="kobo.3078.1">(a &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.3079.1">100</span></span><span class="koboSpan" id="kobo.3080.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3081.1">REQUIRE_FALSE</span></span><span class="koboSpan" id="kobo.3082.1">(a &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.3083.1">100</span></span><span class="koboSpan" id="kobo.3084.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3085.1">Use floating-point matchers, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3086.1">WithinAbs</span></code><span class="koboSpan" id="kobo.3087.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3088.1">WithinRel</span></code><span class="koboSpan" id="kobo.3089.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3090.1">WithinUPL</span></code><span class="koboSpan" id="kobo.3091.1">, to compare floating-point numbers (this is preferred over the obsolete </span><code class="inlineCode"><span class="koboSpan" id="kobo.3092.1">Approx</span></code><span class="koboSpan" id="kobo.3093.1"> class):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3094.1">double a = 42.5;
CHECK_THAT(42.0, Catch::Matchers::WithinAbs(a, 0.5));
REQUIRE_THAT(42.0, Catch::Matchers::WithinAbs(a, 0.5));
CHECK_THAT(42.0, Catch::Matchers::WithinRel(a, 0.02));
REQUIRE_THAT(42.0, Catch::Matchers::WithinRel(a, 0.02));
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3095.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3096.1">CHECK_NOTHROW(expr)</span></code><span class="koboSpan" id="kobo.3097.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.3098.1">REQUIRE_NOTHROW(expr)</span></code><span class="koboSpan" id="kobo.3099.1"> to verify that </span><code class="inlineCode"><span class="koboSpan" id="kobo.3100.1">expr</span></code><span class="koboSpan" id="kobo.3101.1"> does not throw any error, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3102.1">CHECK_THROWS(expr)</span></code><span class="koboSpan" id="kobo.3103.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.3104.1">REQUIRE_THROWS(expr)</span></code><span class="koboSpan" id="kobo.3105.1"> to verify that </span><code class="inlineCode"><span class="koboSpan" id="kobo.3106.1">expr</span></code><span class="koboSpan" id="kobo.3107.1"> does throw an error of any type, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3108.1">CHECK_THROWS_AS(expr, exctype)</span></code><span class="koboSpan" id="kobo.3109.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.3110.1">REQUIRE_THROWS_AS(expr, exctype)</span></code><span class="koboSpan" id="kobo.3111.1"> to verify that </span><code class="inlineCode"><span class="koboSpan" id="kobo.3112.1">expr</span></code><span class="koboSpan" id="kobo.3113.1"> throws an exception of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.3114.1">exctype</span></code><span class="koboSpan" id="kobo.3115.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3116.1">CHECK_THROWS_WITH(expression, string or string matcher)</span></code><span class="koboSpan" id="kobo.3117.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.3118.1">REQUIRE_THROWS_WITH(expression, string or string matcher)</span></code><span class="koboSpan" id="kobo.3119.1"> to verify that </span><code class="inlineCode"><span class="koboSpan" id="kobo.3120.1">expr</span></code><span class="koboSpan" id="kobo.3121.1"> throws an expression whose description matches the specified string:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.3122.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3123.1">function_that_throws</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3124.1">()</span></span><span class="koboSpan" id="kobo.3125.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3126.1">throw</span></span><span class="koboSpan" id="kobo.3127.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3128.1">runtime_error</span></span><span class="koboSpan" id="kobo.3129.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3130.1">"error"</span></span><span class="koboSpan" id="kobo.3131.1">);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.3132.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3133.1">function_no_throw</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3134.1">()</span></span><span class="koboSpan" id="kobo.3135.1">
{
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3136.1">SECTION</span></span><span class="koboSpan" id="kobo.3137.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3138.1">"expressions"</span></span><span class="koboSpan" id="kobo.3139.1">)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3140.1">CHECK_NOTHROW</span></span><span class="koboSpan" id="kobo.3141.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3142.1">function_no_throw</span></span><span class="koboSpan" id="kobo.3143.1">());
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3144.1">REQUIRE_NOTHROW</span></span><span class="koboSpan" id="kobo.3145.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3146.1">function_no_throw</span></span><span class="koboSpan" id="kobo.3147.1">());
  
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3148.1">CHECK_THROWS</span></span><span class="koboSpan" id="kobo.3149.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3150.1">function_that_throws</span></span><span class="koboSpan" id="kobo.3151.1">());
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3152.1">REQUIRE_THROWS</span></span><span class="koboSpan" id="kobo.3153.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3154.1">function_that_throws</span></span><span class="koboSpan" id="kobo.3155.1">());
  
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3156.1">CHECK_THROWS_AS</span></span><span class="koboSpan" id="kobo.3157.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3158.1">function_that_throws</span></span><span class="koboSpan" id="kobo.3159.1">(), std::runtime_error);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3160.1">REQUIRE_THROWS_AS</span></span><span class="koboSpan" id="kobo.3161.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3162.1">function_that_throws</span></span><span class="koboSpan" id="kobo.3163.1">(), std::runtime_error);
  
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3164.1">CHECK_THROWS_WITH</span></span><span class="koboSpan" id="kobo.3165.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3166.1">function_that_throws</span></span><span class="koboSpan" id="kobo.3167.1">(), </span><span class="hljs-string"><span class="koboSpan" id="kobo.3168.1">"error"</span></span><span class="koboSpan" id="kobo.3169.1">);
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3170.1">REQUIRE_THROWS_WITH</span></span><span class="koboSpan" id="kobo.3171.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3172.1">function_that_throws</span></span><span class="koboSpan" id="kobo.3173.1">(), 
          Catch::Matchers::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3174.1">ContainsSubstring</span></span><span class="koboSpan" id="kobo.3175.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3176.1">"error"</span></span><span class="koboSpan" id="kobo.3177.1">));
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3178.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3179.1">CHECK_THAT(value, matcher expression)</span></code><span class="koboSpan" id="kobo.3180.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.3181.1">REQUIRE_THAT(expr, matcher expression)</span></code><span class="koboSpan" id="kobo.3182.1"> to check whether the given matcher expression evaluates</span><a id="_idIndexMarker1410"/><span class="koboSpan" id="kobo.3183.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3184.1">true</span></code><span class="koboSpan" id="kobo.3185.1"> for the specified value:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3186.1">std::string text = </span><span class="hljs-string"><span class="koboSpan" id="kobo.3187.1">"this is an example"</span></span><span class="koboSpan" id="kobo.3188.1">;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3189.1">CHECK_THAT</span></span><span class="koboSpan" id="kobo.3190.1">(
  text,
  Catch::Matchers::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3191.1">ContainsSubstring</span></span><span class="koboSpan" id="kobo.3192.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3193.1">"EXAMPLE"</span></span><span class="koboSpan" id="kobo.3194.1">, Catch::CaseSensitive::No));
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3195.1">REQUIRE_THAT</span></span><span class="koboSpan" id="kobo.3196.1">(
  text,
  Catch::Matchers::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3197.1">StartsWith</span></span><span class="koboSpan" id="kobo.3198.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3199.1">"this"</span></span><span class="koboSpan" id="kobo.3200.1">) &amp;&amp; 
  Catch::Matchers::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3201.1">ContainsSubstring</span></span><span class="koboSpan" id="kobo.3202.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3203.1">"an"</span></span><span class="koboSpan" id="kobo.3204.1">));
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3205.1">Use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3206.1">FAIL(message)</span></code><span class="koboSpan" id="kobo.3207.1"> to report </span><code class="inlineCode"><span class="koboSpan" id="kobo.3208.1">message</span></code><span class="koboSpan" id="kobo.3209.1"> and fail the test case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3210.1">WARN(message)</span></code><span class="koboSpan" id="kobo.3211.1"> to log the message without stopping the execution of the test case, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3212.1">INFO(message)</span></code><span class="koboSpan" id="kobo.3213.1"> to log the message to a buffer and only report it with the next assertion that would fail.</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-747"><span class="koboSpan" id="kobo.3214.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3215.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3216.1">REQUIRE</span></code><span class="koboSpan" id="kobo.3217.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.3218.1">CATCH</span></code><span class="koboSpan" id="kobo.3219.1"> family </span><a id="_idIndexMarker1411"/><span class="koboSpan" id="kobo.3220.1">of macros decompose the expression into its left- and right-hand side terms and, upon failure, report the location of the failure (source file and line), the expression, and the values on the left- and right-hand sides:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3221.1">f:\chapter11ca_03\main.cpp(19): FAILED:
  REQUIRE( a == 1 )
with expansion:
  42 == 1
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3222.1">However, these macros do not support complex expressions composed using logical operators, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3223.1">&amp;&amp;</span></code><span class="koboSpan" id="kobo.3224.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3225.1">||</span></code><span class="koboSpan" id="kobo.3226.1">. </span><span class="koboSpan" id="kobo.3226.2">The following example is an error:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.3227.1">REQUIRE</span></span><span class="koboSpan" id="kobo.3228.1">(a &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.3229.1">10</span></span><span class="koboSpan" id="kobo.3230.1"> || a %</span><span class="hljs-number"><span class="koboSpan" id="kobo.3231.1">2</span></span><span class="koboSpan" id="kobo.3232.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.3233.1">0</span></span><span class="koboSpan" id="kobo.3234.1">);   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3235.1">// error</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3236.1">The solution for this is to create a variable to hold the result of the expression evaluation and use it in the assertion macros. </span><span class="koboSpan" id="kobo.3236.2">In this case, however, the ability to print the expansion of the elements of the expression is lost:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3237.1">auto</span></span><span class="koboSpan" id="kobo.3238.1"> expr = a &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.3239.1">10</span></span><span class="koboSpan" id="kobo.3240.1"> || a % </span><span class="hljs-number"><span class="koboSpan" id="kobo.3241.1">2</span></span><span class="koboSpan" id="kobo.3242.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.3243.1">0</span></span><span class="koboSpan" id="kobo.3244.1">;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3245.1">REQUIRE</span></span><span class="koboSpan" id="kobo.3246.1">(expr);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3247.1">An alternative is to use another set of parentheses. </span><span class="koboSpan" id="kobo.3247.2">However, this too stops the decomposition from working:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.3248.1">REQUIRE</span></span><span class="koboSpan" id="kobo.3249.1">((a &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.3250.1">10</span></span><span class="koboSpan" id="kobo.3251.1"> || a %</span><span class="hljs-number"><span class="koboSpan" id="kobo.3252.1">2</span></span><span class="koboSpan" id="kobo.3253.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.3254.1">0</span></span><span class="koboSpan" id="kobo.3255.1">)); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3256.1">// OK</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3257.1">Two sets of assertions, namely </span><code class="inlineCode"><span class="koboSpan" id="kobo.3258.1">CHECK_THAT</span></code><span class="koboSpan" id="kobo.3259.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.3260.1">REQUIRE_THAT</span></code><span class="koboSpan" id="kobo.3261.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3262.1">CHECK_THROWS_WITH</span></code><span class="koboSpan" id="kobo.3263.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.3264.1">REQUIRE_THROWS_WITH</span></code><span class="koboSpan" id="kobo.3265.1">, work with matchers. </span><span class="koboSpan" id="kobo.3265.2">Matchers are extensible and composable components that perform value matching. </span><span class="koboSpan" id="kobo.3265.3">The framework provides several matchers, including for:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3266.1">Strings: </span><code class="inlineCode"><span class="koboSpan" id="kobo.3267.1">StartsWith</span></code><span class="koboSpan" id="kobo.3268.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3269.1">EndsWith</span></code><span class="koboSpan" id="kobo.3270.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3271.1">ContainsSubstring</span></code><span class="koboSpan" id="kobo.3272.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3273.1">Equals</span></code><span class="koboSpan" id="kobo.3274.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3275.1">Matches</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3276.1">std::vector</span></code><span class="koboSpan" id="kobo.3277.1">: </span><code class="inlineCode"><span class="koboSpan" id="kobo.3278.1">Contains</span></code><span class="koboSpan" id="kobo.3279.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3280.1">VectorContains</span></code><span class="koboSpan" id="kobo.3281.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3282.1">Equals</span></code><span class="koboSpan" id="kobo.3283.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3284.1">UnorderedEquals</span></code><span class="koboSpan" id="kobo.3285.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3286.1">Approx</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3287.1">Floating-point values: </span><code class="inlineCode"><span class="koboSpan" id="kobo.3288.1">WithinAbs</span></code><span class="koboSpan" id="kobo.3289.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3290.1">WithinULP</span></code><span class="koboSpan" id="kobo.3291.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3292.1">WithinRel</span></code><span class="koboSpan" id="kobo.3293.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3294.1">IsNaN</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3295.1">Range-like types (included from version 3.0.1): </span><code class="inlineCode"><span class="koboSpan" id="kobo.3296.1">IsEmpty</span></code><span class="koboSpan" id="kobo.3297.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3298.1">SizeIs</span></code><span class="koboSpan" id="kobo.3299.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3300.1">Contains</span></code><span class="koboSpan" id="kobo.3301.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3302.1">AllMatch</span></code><span class="koboSpan" id="kobo.3303.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3304.1">AnyMatch</span></code><span class="koboSpan" id="kobo.3305.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3306.1">NoneMatch</span></code><span class="koboSpan" id="kobo.3307.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3308.1">AllTrue</span></code><span class="koboSpan" id="kobo.3309.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3310.1">AnyTrue</span></code><span class="koboSpan" id="kobo.3311.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3312.1">NoneTrue</span></code><span class="koboSpan" id="kobo.3313.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3314.1">RangeEquals</span></code><span class="koboSpan" id="kobo.3315.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3316.1">UnorderedRangeEquals</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3317.1">Exceptions: </span><code class="inlineCode"><span class="koboSpan" id="kobo.3318.1">Message</span></code><span class="koboSpan" id="kobo.3319.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3320.1">MessageMatches</span></code></li>
</ul>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.3321.1">The difference between </span><code class="inlineCode"><span class="koboSpan" id="kobo.3322.1">Contains()</span></code><span class="koboSpan" id="kobo.3323.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3324.1">VectorContains()</span></code><span class="koboSpan" id="kobo.3325.1"> is that </span><code class="inlineCode"><span class="koboSpan" id="kobo.3326.1">Contains()</span></code><span class="koboSpan" id="kobo.3327.1"> searches for a vector in another vector and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3328.1">VectorContains()</span></code><span class="koboSpan" id="kobo.3329.1"> searches for a single element inside a vector.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.3330.1">As mentioned in</span><a id="_idIndexMarker1412"/><span class="koboSpan" id="kobo.3331.1"> the previous list, there are several matchers that target floating-point numbers. </span><span class="koboSpan" id="kobo.3331.2">These matchers are:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3332.1">WithinAbs()</span></code><span class="koboSpan" id="kobo.3333.1">: Creates a matcher that accepts a floating-point number that is less than or equal to a target number with a specified margin (a percentage given as a number between 0 and 1):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3334.1">REQUIRE_THAT(42.0, WithinAbs(42.5, 0.5));
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3335.1">WithinRel()</span></code><span class="koboSpan" id="kobo.3336.1">: Creates a matcher that accepts a floating-point number that is approximatively equal to a target with a given tolerance:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3337.1">REQUIRE_THAT(42.0, WithinRel(42.4, 0.01));
</span></code></pre>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3338.1">WithinULP()</span></code><span class="koboSpan" id="kobo.3339.1">: Creates a matcher that accepts a floating-point number that is no more than the given ULP away from the target:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3340.1">REQUIRE_THAT(42.0, WithinRel(target, 4));
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3341.1">These matchers can also be combined together, as exemplified below:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3342.1">REQUIRE_THAT(a,
  Catch::Matchers::WithinRel(42.0, 0.001) ||
  Catch::Matchers::WithinAbs(42.0, 0.000001));
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3343.1">An obsolete way of comparing floating-point numbers is represented by the class called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3344.1">Approx</span></code><span class="koboSpan" id="kobo.3345.1">, in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3346.1">Catch</span></code><span class="koboSpan" id="kobo.3347.1"> namespace. </span><span class="koboSpan" id="kobo.3347.2">This class overloads the equality/inequality and comparison operators with values through which a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3348.1">double</span></code><span class="koboSpan" id="kobo.3349.1"> value can be constructed. </span><span class="koboSpan" id="kobo.3349.2">The margin by which the two values can either differ or be considered equal can be specified as a percentage of the given value. </span><span class="koboSpan" id="kobo.3349.3">This is set using the member function </span><code class="inlineCode"><span class="koboSpan" id="kobo.3350.1">epsilon()</span></code><span class="koboSpan" id="kobo.3351.1">. </span><span class="koboSpan" id="kobo.3351.2">The value must be between 0 and 1 (for example, the value of 0.05 is 5 percent). </span><span class="koboSpan" id="kobo.3351.3">The default value of epsilon is set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3352.1">std::numeric_limits&lt;float&gt;::epsilon()*100</span></code><span class="koboSpan" id="kobo.3353.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3354.1">You can create your own matchers, either to extend the existing framework capabilities or to work with your own types. </span><span class="koboSpan" id="kobo.3354.2">There are two ways to create custom matches: the old v2 way, and the new v3 way.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3355.1">To create a</span><a id="_idIndexMarker1413"/><span class="koboSpan" id="kobo.3356.1"> custom matcher the old way, there are two things that are necessary:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.3357.1">A matcher class derived from </span><code class="inlineCode"><span class="koboSpan" id="kobo.3358.1">Catch::MatcherBase&lt;T&gt;</span></code><span class="koboSpan" id="kobo.3359.1">, where </span><code class="inlineCode"><span class="koboSpan" id="kobo.3360.1">T</span></code><span class="koboSpan" id="kobo.3361.1"> is the type being compared. </span><span class="koboSpan" id="kobo.3361.2">There are two virtual functions that must be overridden: </span><code class="inlineCode"><span class="koboSpan" id="kobo.3362.1">match()</span></code><span class="koboSpan" id="kobo.3363.1">, which takes a value to match and returns a Boolean indicating whether the match was successful, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3364.1">describe()</span></code><span class="koboSpan" id="kobo.3365.1">, which takes no arguments but returns a string describing the matcher.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.3366.1">A builder function that is called from the test code.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.3367.1">The following example defines a matcher for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3368.1">point3d</span></code><span class="koboSpan" id="kobo.3369.1"> class, which we have seen throughout this chapter, to check whether a given 3D point lies on a line in the three-dimensional space:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3370.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3371.1">OnTheLine</span></span><span class="koboSpan" id="kobo.3372.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3373.1">public</span></span><span class="koboSpan" id="kobo.3374.1"> Catch::Matchers::MatcherBase&lt;point3d&gt;
{
  point3d </span><span class="hljs-type"><span class="koboSpan" id="kobo.3375.1">const</span></span><span class="koboSpan" id="kobo.3376.1"> p1;
  point3d </span><span class="hljs-type"><span class="koboSpan" id="kobo.3377.1">const</span></span><span class="koboSpan" id="kobo.3378.1"> p2;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3379.1">public</span></span><span class="koboSpan" id="kobo.3380.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3381.1">OnTheLine</span></span><span class="koboSpan" id="kobo.3382.1">(point3d </span><span class="hljs-type"><span class="koboSpan" id="kobo.3383.1">const</span></span><span class="koboSpan" id="kobo.3384.1"> &amp; p1, point3d </span><span class="hljs-type"><span class="koboSpan" id="kobo.3385.1">const</span></span><span class="koboSpan" id="kobo.3386.1"> &amp; p2):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3387.1">p1</span></span><span class="koboSpan" id="kobo.3388.1">(p1), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3389.1">p2</span></span><span class="koboSpan" id="kobo.3390.1">(p2)
  {}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3391.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3392.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3393.1">match</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3394.1">(point3d </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3395.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3396.1"> &amp; p)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3397.1">const</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3398.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.3399.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3400.1">auto</span></span><span class="koboSpan" id="kobo.3401.1"> rx = p2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3402.1">x</span></span><span class="koboSpan" id="kobo.3403.1">() - p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3404.1">x</span></span><span class="koboSpan" id="kobo.3405.1">() != </span><span class="hljs-number"><span class="koboSpan" id="kobo.3406.1">0</span></span><span class="koboSpan" id="kobo.3407.1"> ? 
             </span><span class="koboSpan" id="kobo.3407.2">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3408.1">x</span></span><span class="koboSpan" id="kobo.3409.1">() - p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3410.1">x</span></span><span class="koboSpan" id="kobo.3411.1">()) / (p2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3412.1">x</span></span><span class="koboSpan" id="kobo.3413.1">() - p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3414.1">x</span></span><span class="koboSpan" id="kobo.3415.1">()) : </span><span class="hljs-number"><span class="koboSpan" id="kobo.3416.1">0</span></span><span class="koboSpan" id="kobo.3417.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3418.1">auto</span></span><span class="koboSpan" id="kobo.3419.1"> ry = p2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3420.1">y</span></span><span class="koboSpan" id="kobo.3421.1">() - p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3422.1">y</span></span><span class="koboSpan" id="kobo.3423.1">() != </span><span class="hljs-number"><span class="koboSpan" id="kobo.3424.1">0</span></span><span class="koboSpan" id="kobo.3425.1"> ? 
             </span><span class="koboSpan" id="kobo.3425.2">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3426.1">y</span></span><span class="koboSpan" id="kobo.3427.1">() - p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3428.1">y</span></span><span class="koboSpan" id="kobo.3429.1">()) / (p2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3430.1">y</span></span><span class="koboSpan" id="kobo.3431.1">() - p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3432.1">y</span></span><span class="koboSpan" id="kobo.3433.1">()) : </span><span class="hljs-number"><span class="koboSpan" id="kobo.3434.1">0</span></span><span class="koboSpan" id="kobo.3435.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3436.1">auto</span></span><span class="koboSpan" id="kobo.3437.1"> rz = p2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3438.1">z</span></span><span class="koboSpan" id="kobo.3439.1">() - p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3440.1">z</span></span><span class="koboSpan" id="kobo.3441.1">() != </span><span class="hljs-number"><span class="koboSpan" id="kobo.3442.1">0</span></span><span class="koboSpan" id="kobo.3443.1"> ? 
             </span><span class="koboSpan" id="kobo.3443.2">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3444.1">z</span></span><span class="koboSpan" id="kobo.3445.1">() - p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3446.1">z</span></span><span class="koboSpan" id="kobo.3447.1">()) / (p2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3448.1">z</span></span><span class="koboSpan" id="kobo.3449.1">() - p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3450.1">z</span></span><span class="koboSpan" id="kobo.3451.1">()) : </span><span class="hljs-number"><span class="koboSpan" id="kobo.3452.1">0</span></span><span class="koboSpan" id="kobo.3453.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3454.1">return</span></span><span class="koboSpan" id="kobo.3455.1"> 
      Catch::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3456.1">Approx</span></span><span class="koboSpan" id="kobo.3457.1">(rx).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3458.1">epsilon</span></span><span class="koboSpan" id="kobo.3459.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3460.1">0.01</span></span><span class="koboSpan" id="kobo.3461.1">) == ry &amp;&amp;
      Catch::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3462.1">Approx</span></span><span class="koboSpan" id="kobo.3463.1">(ry).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3464.1">epsilon</span></span><span class="koboSpan" id="kobo.3465.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3466.1">0.01</span></span><span class="koboSpan" id="kobo.3467.1">) == rz;
  }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3468.1">protected</span></span><span class="koboSpan" id="kobo.3469.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3470.1">virtual</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3471.1"> std::string </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3472.1">describe</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3473.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3474.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.3475.1">{
    std::ostringstream ss;
    ss &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3476.1">"on the line between "</span></span><span class="koboSpan" id="kobo.3477.1"> &lt;&lt; p1 &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3478.1">" and "</span></span><span class="koboSpan" id="kobo.3479.1"> &lt;&lt; p2;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3480.1">return</span></span><span class="koboSpan" id="kobo.3481.1"> ss.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3482.1">str</span></span><span class="koboSpan" id="kobo.3483.1">();
  }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3484.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3485.1"> OnTheLine </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3486.1">IsOnTheLine</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3487.1">(point3d </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3488.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3489.1"> &amp; p1, point3d </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3490.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3491.1"> &amp; p2)</span></span><span class="koboSpan" id="kobo.3492.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3493.1">return</span></span><span class="koboSpan" id="kobo.3494.1"> OnTheLine {p1, p2};
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3495.1">To create a</span><a id="_idIndexMarker1414"/><span class="koboSpan" id="kobo.3496.1"> custom matcher the new way, you need the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.3497.1">A matcher class derived from </span><code class="inlineCode"><span class="koboSpan" id="kobo.3498.1">Catch::Matchers::MatcherGenericBase</span></code><span class="koboSpan" id="kobo.3499.1">. </span><span class="koboSpan" id="kobo.3499.2">This class has to implement two methods: </span><code class="inlineCode"><span class="koboSpan" id="kobo.3500.1">bool match(…) const</span></code><span class="koboSpan" id="kobo.3501.1">, which performs the matching, and an overriding of the virtual function </span><code class="inlineCode"><span class="koboSpan" id="kobo.3502.1">string describe() const</span></code><span class="koboSpan" id="kobo.3503.1">, which takes no arguments but returns a string describing the matcher. </span><span class="koboSpan" id="kobo.3503.2">Although these are very similar to the functions used in the old style, there is a key difference: the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3504.1">match()</span></code><span class="koboSpan" id="kobo.3505.1"> function has no requirements on the way its argument is passed. </span><span class="koboSpan" id="kobo.3505.2">This means it can take an argument by value or mutating reference. </span><span class="koboSpan" id="kobo.3505.3">In addition, it can also be a function template. </span><span class="koboSpan" id="kobo.3505.4">The advantage is that it enables writing more complex matchers, such as matchers that can compare range-like types.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.3506.1">A builder function that is called from the test code.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.3507.1">The same matcher that compares </span><code class="inlineCode"><span class="koboSpan" id="kobo.3508.1">point3d</span></code><span class="koboSpan" id="kobo.3509.1"> values written in the new style looks as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3510.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3511.1">OnTheLine</span></span><span class="koboSpan" id="kobo.3512.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3513.1">public</span></span><span class="koboSpan" id="kobo.3514.1"> Catch::Matchers::MatcherGenericBase
{
   point3d </span><span class="hljs-type"><span class="koboSpan" id="kobo.3515.1">const</span></span><span class="koboSpan" id="kobo.3516.1"> p1;
   point3d </span><span class="hljs-type"><span class="koboSpan" id="kobo.3517.1">const</span></span><span class="koboSpan" id="kobo.3518.1"> p2;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3519.1">public</span></span><span class="koboSpan" id="kobo.3520.1">:
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3521.1">OnTheLine</span></span><span class="koboSpan" id="kobo.3522.1">(point3d </span><span class="hljs-type"><span class="koboSpan" id="kobo.3523.1">const</span></span><span class="koboSpan" id="kobo.3524.1">&amp; p1, point3d </span><span class="hljs-type"><span class="koboSpan" id="kobo.3525.1">const</span></span><span class="koboSpan" id="kobo.3526.1">&amp; p2) :
      </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3527.1">p1</span></span><span class="koboSpan" id="kobo.3528.1">(p1), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3529.1">p2</span></span><span class="koboSpan" id="kobo.3530.1">(p2)
   {
   }
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.3531.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3532.1">match</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3533.1">(point3d </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3534.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3535.1">&amp; p)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3536.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.3537.1">{
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3538.1">auto</span></span><span class="koboSpan" id="kobo.3539.1"> rx = p2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3540.1">x</span></span><span class="koboSpan" id="kobo.3541.1">() - p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3542.1">x</span></span><span class="koboSpan" id="kobo.3543.1">() != </span><span class="hljs-number"><span class="koboSpan" id="kobo.3544.1">0</span></span><span class="koboSpan" id="kobo.3545.1"> ? 
                </span><span class="koboSpan" id="kobo.3545.2">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3546.1">x</span></span><span class="koboSpan" id="kobo.3547.1">() - p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3548.1">x</span></span><span class="koboSpan" id="kobo.3549.1">()) / (p2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3550.1">x</span></span><span class="koboSpan" id="kobo.3551.1">() - p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3552.1">x</span></span><span class="koboSpan" id="kobo.3553.1">()) : </span><span class="hljs-number"><span class="koboSpan" id="kobo.3554.1">0</span></span><span class="koboSpan" id="kobo.3555.1">;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3556.1">auto</span></span><span class="koboSpan" id="kobo.3557.1"> ry = p2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3558.1">y</span></span><span class="koboSpan" id="kobo.3559.1">() - p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3560.1">y</span></span><span class="koboSpan" id="kobo.3561.1">() != </span><span class="hljs-number"><span class="koboSpan" id="kobo.3562.1">0</span></span><span class="koboSpan" id="kobo.3563.1"> ? 
                </span><span class="koboSpan" id="kobo.3563.2">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3564.1">y</span></span><span class="koboSpan" id="kobo.3565.1">() - p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3566.1">y</span></span><span class="koboSpan" id="kobo.3567.1">()) / (p2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3568.1">y</span></span><span class="koboSpan" id="kobo.3569.1">() - p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3570.1">y</span></span><span class="koboSpan" id="kobo.3571.1">()) : </span><span class="hljs-number"><span class="koboSpan" id="kobo.3572.1">0</span></span><span class="koboSpan" id="kobo.3573.1">;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3574.1">auto</span></span><span class="koboSpan" id="kobo.3575.1"> rz = p2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3576.1">z</span></span><span class="koboSpan" id="kobo.3577.1">() - p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3578.1">z</span></span><span class="koboSpan" id="kobo.3579.1">() != </span><span class="hljs-number"><span class="koboSpan" id="kobo.3580.1">0</span></span><span class="koboSpan" id="kobo.3581.1"> ? 
                </span><span class="koboSpan" id="kobo.3581.2">(p.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3582.1">z</span></span><span class="koboSpan" id="kobo.3583.1">() - p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3584.1">z</span></span><span class="koboSpan" id="kobo.3585.1">()) / (p2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3586.1">z</span></span><span class="koboSpan" id="kobo.3587.1">() - p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3588.1">z</span></span><span class="koboSpan" id="kobo.3589.1">()) : </span><span class="hljs-number"><span class="koboSpan" id="kobo.3590.1">0</span></span><span class="koboSpan" id="kobo.3591.1">;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3592.1">return</span></span><span class="koboSpan" id="kobo.3593.1">
         Catch::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3594.1">Approx</span></span><span class="koboSpan" id="kobo.3595.1">(rx).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3596.1">epsilon</span></span><span class="koboSpan" id="kobo.3597.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3598.1">0.01</span></span><span class="koboSpan" id="kobo.3599.1">) == ry &amp;&amp;
         Catch::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3600.1">Approx</span></span><span class="koboSpan" id="kobo.3601.1">(ry).</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3602.1">epsilon</span></span><span class="koboSpan" id="kobo.3603.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3604.1">0.01</span></span><span class="koboSpan" id="kobo.3605.1">) == rz;
   }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3606.1">protected</span></span><span class="koboSpan" id="kobo.3607.1">:
   </span><span class="hljs-function"><span class="koboSpan" id="kobo.3608.1">std::string </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3609.1">describe</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3610.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3611.1">const</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3612.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.3613.1">{
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.3614.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3615.1">ifdef</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.3616.1"> __cpp_lib_format</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3617.1">return</span></span><span class="koboSpan" id="kobo.3618.1"> std::format(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3619.1">"on the line between ({},{},{}) and ({},{},{})"</span></span><span class="koboSpan" id="kobo.3620.1">, p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3621.1">x</span></span><span class="koboSpan" id="kobo.3622.1">(), p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3623.1">y</span></span><span class="koboSpan" id="kobo.3624.1">(), p1.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3625.1">z</span></span><span class="koboSpan" id="kobo.3626.1">(), p2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3627.1">x</span></span><span class="koboSpan" id="kobo.3628.1">(), p2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3629.1">y</span></span><span class="koboSpan" id="kobo.3630.1">(), p2.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3631.1">z</span></span><span class="koboSpan" id="kobo.3632.1">());
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.3633.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3634.1">else</span></span><span class="koboSpan" id="kobo.3635.1">
      std::ostringstream ss;
      ss &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3636.1">"on the line between "</span></span><span class="koboSpan" id="kobo.3637.1"> &lt;&lt; p1 &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3638.1">" and "</span></span><span class="koboSpan" id="kobo.3639.1"> &lt;&lt; p2;
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3640.1">return</span></span><span class="koboSpan" id="kobo.3641.1"> ss.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3642.1">str</span></span><span class="koboSpan" id="kobo.3643.1">();
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.3644.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3645.1">endif</span></span><span class="koboSpan" id="kobo.3646.1">
   }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3647.1">The following test </span><a id="_idIndexMarker1415"/><span class="koboSpan" id="kobo.3648.1">case contains an example of how to use this custom matcher:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.3649.1">TEST_CASE</span></span><span class="koboSpan" id="kobo.3650.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3651.1">"matchers"</span></span><span class="koboSpan" id="kobo.3652.1">)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3653.1">SECTION</span></span><span class="koboSpan" id="kobo.3654.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3655.1">"point origin"</span></span><span class="koboSpan" id="kobo.3656.1">)
  {
    point3d p { </span><span class="hljs-number"><span class="koboSpan" id="kobo.3657.1">2</span></span><span class="koboSpan" id="kobo.3658.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.3659.1">2</span></span><span class="koboSpan" id="kobo.3660.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.3661.1">2</span></span><span class="koboSpan" id="kobo.3662.1"> };
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3663.1">REQUIRE_THAT</span></span><span class="koboSpan" id="kobo.3664.1">(p, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3665.1">IsOnTheLine</span></span><span class="koboSpan" id="kobo.3666.1">(point3d{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3667.1">0</span></span><span class="koboSpan" id="kobo.3668.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.3669.1">0</span></span><span class="koboSpan" id="kobo.3670.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.3671.1">0</span></span><span class="koboSpan" id="kobo.3672.1"> }, point3d{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3673.1">3</span></span><span class="koboSpan" id="kobo.3674.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.3675.1">3</span></span><span class="koboSpan" id="kobo.3676.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.3677.1">3</span></span><span class="koboSpan" id="kobo.3678.1"> }));
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3679.1">This test ensures that the point </span><code class="inlineCode"><span class="koboSpan" id="kobo.3680.1">{2,2,2}</span></code><span class="koboSpan" id="kobo.3681.1"> lies on the line defined by the points </span><code class="inlineCode"><span class="koboSpan" id="kobo.3682.1">{0,0,0}</span></code><span class="koboSpan" id="kobo.3683.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3684.1">{3,3,3}</span></code><span class="koboSpan" id="kobo.3685.1"> by using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3686.1">IsOnTheLine()</span></code><span class="koboSpan" id="kobo.3687.1"> custom matcher implemented previously.</span></p>
<h2 class="heading-2" id="_idParaDest-748"><span class="koboSpan" id="kobo.3688.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3689.1">Writing and invoking tests with Catch2</span></em><span class="koboSpan" id="kobo.3690.1">, to see how to create tests with the Catch2 library, either using the traditional style based on test cases or the BDD style with scenarios, as well as how to run tests</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-749"><span class="koboSpan" id="kobo.3691.1">Controlling output with Catch2</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3692.1">As with </span><a id="_idIndexMarker1416"/><span class="koboSpan" id="kobo.3693.1">other testing frameworks discussed in this book, Catch2 reports the results of a test program’s execution in a human-readable format to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3694.1">stdout</span></code><span class="koboSpan" id="kobo.3695.1"> standard stream. </span><span class="koboSpan" id="kobo.3695.2">Additional options are supported, such as reporting using XML format or writing to a file. </span><span class="koboSpan" id="kobo.3695.3">In this recipe, we will look at the main options available for controlling the output when using Catch2.</span></p>
<h2 class="heading-2" id="_idParaDest-750"><span class="koboSpan" id="kobo.3696.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3697.1">To exemplify the way the test program’s execution output could be modified, use the following test cases:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.3698.1">TEST_CASE</span></span><span class="koboSpan" id="kobo.3699.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3700.1">"case1"</span></span><span class="koboSpan" id="kobo.3701.1">)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3702.1">SECTION</span></span><span class="koboSpan" id="kobo.3703.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3704.1">"function1"</span></span><span class="koboSpan" id="kobo.3705.1">)
  {
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3706.1">REQUIRE</span></span><span class="koboSpan" id="kobo.3707.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.3708.1">true</span></span><span class="koboSpan" id="kobo.3709.1">);
  }
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3710.1">TEST_CASE</span></span><span class="koboSpan" id="kobo.3711.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3712.1">"case2"</span></span><span class="koboSpan" id="kobo.3713.1">)
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3714.1">SECTION</span></span><span class="koboSpan" id="kobo.3715.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3716.1">"function2"</span></span><span class="koboSpan" id="kobo.3717.1">)
  {
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3718.1">REQUIRE</span></span><span class="koboSpan" id="kobo.3719.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.3720.1">false</span></span><span class="koboSpan" id="kobo.3721.1">);
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3722.1">The output of running these two test cases is as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3723.1">----------------------------------------------------------
case2
  function2
----------------------------------------------------------
f:\chapter11ca_04\main.cpp(14)
..........................................................
</span><span class="koboSpan" id="kobo.3723.2">f:\chapter11ca_04\main.cpp(16): FAILED:
  REQUIRE( false )
==========================================================
test cases: 2 | 1 passed | 1 failed
assertions: 2 | 1 passed | 1 failed
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3724.1">In the following section, we’ll explore some of the various options for controlling the output of a Catch2 test program.</span></p>
<h2 class="heading-2" id="_idParaDest-751"><span class="koboSpan" id="kobo.3725.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3726.1">To control the</span><a id="_idIndexMarker1417"/><span class="koboSpan" id="kobo.3727.1"> output of a test program when using Catch2, you can:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3728.1">Use the command-line argument </span><code class="inlineCode"><span class="koboSpan" id="kobo.3729.1">-r</span></code><span class="koboSpan" id="kobo.3730.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3731.1">--reporter &lt;reporter&gt;</span></code><span class="koboSpan" id="kobo.3732.1"> to specify the reporter used to format and structure the results. </span><span class="koboSpan" id="kobo.3732.2">The default options supplied with the framework are </span><code class="inlineCode"><span class="koboSpan" id="kobo.3733.1">console</span></code><span class="koboSpan" id="kobo.3734.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3735.1">compact</span></code><span class="koboSpan" id="kobo.3736.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3737.1">xml</span></code><span class="koboSpan" id="kobo.3738.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3739.1">junit</span></code><span class="koboSpan" id="kobo.3740.1">:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3741.1">chapter11ca_04.exe -r junit
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;testsuites&gt;
  &lt;testsuite name="chapter11ca_04.exe" errors="0" 
             failures="1"
             tests="2" hostname="tbd" 
             time="0.002039" 
             timestamp="2020-05-02T21:17:04Z"&gt;
    &lt;testcase classname="case1" name="function1" 
              time="0.00016"/&gt;
    &lt;testcase classname="case2" 
              name="function2" time="0.00024"&gt;
      &lt;failure message="false" type="REQUIRE"&gt;
        at f:\chapter11ca_04\main.cpp(16)
      &lt;/failure&gt;
    &lt;/testcase&gt;
    &lt;system-out/&gt;
    &lt;system-err/&gt;
  &lt;/testsuite&gt;
&lt;/testsuites&gt;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3742.1">Use the command-line argument </span><code class="inlineCode"><span class="koboSpan" id="kobo.3743.1">-s</span></code><span class="koboSpan" id="kobo.3744.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3745.1">--success</span></code><span class="koboSpan" id="kobo.3746.1"> to display the results of successful test cases too:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3747.1">chapter11ca_04.exe -s
--------------------------------------------------
case1
  function1
--------------------------------------------------
f:\chapter11ca_04\main.cpp(6)
..................................................
</span><span class="koboSpan" id="kobo.3747.2">f:\chapter11ca_04\main.cpp(8):
PASSED:
  REQUIRE( true )
--------------------------------------------------
case2
  function2
--------------------------------------------------
f:\chapter11ca_04\main.cpp(14)
..................................................
</span><span class="koboSpan" id="kobo.3747.3">f:\chapter11ca_04\main.cpp(16): 
FAILED:
  REQUIRE( false )
==================================================
test cases: 2 | 1 passed | 1 failed
assertions: 2 | 1 passed | 1 failed
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3748.1">Use the </span><a id="_idIndexMarker1418"/><span class="koboSpan" id="kobo.3749.1">command-line argument </span><code class="inlineCode"><span class="koboSpan" id="kobo.3750.1">-o</span></code><span class="koboSpan" id="kobo.3751.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3752.1">--out &lt;filename&gt;</span></code><span class="koboSpan" id="kobo.3753.1"> to send all of the output to a file instead of the standard stream:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3754.1">chapter11ca_04.exe -o test_report.log
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3755.1">Use the command-line argument </span><code class="inlineCode"><span class="koboSpan" id="kobo.3756.1">-d</span></code><span class="koboSpan" id="kobo.3757.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3758.1">--durations &lt;yes/no&gt;</span></code><span class="koboSpan" id="kobo.3759.1"> to display the time that it takes each test case to execute:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3760.1">chapter11ca_04.exe -d yes
0.000 s: scenario1
0.000 s: case1
--------------------------------------------------
case2
   scenario2
--------------------------------------------------
f:\chapter11ca_04\main.cpp(14)
..................................................
</span><span class="koboSpan" id="kobo.3760.2">f:\chapter11ca_04\main.cpp(16): 
FAILED:
  REQUIRE( false )
0.003 s: scenario2
0.000 s: case2
0.000 s: case2
==================================================
test cases: 2 | 1 passed | 1 failed
assertions: 2 | 1 passed | 1 failed
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-752"><span class="koboSpan" id="kobo.3761.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3762.1">Apart from</span><a id="_idIndexMarker1419"/><span class="koboSpan" id="kobo.3763.1"> the human-readable format used, by default, for reporting the results of the test program execution, the Catch2 framework supports two XML formats:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3764.1">A Catch2-specific XML format (specified with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3765.1">-r xml</span></code><span class="koboSpan" id="kobo.3766.1">)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3767.1">A JUNIT-like XML format, following the structure of the JUNIT ANT task (specified with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3768.1">-r junit</span></code><span class="koboSpan" id="kobo.3769.1">)</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3770.1">The former reporter streams the XML content as unit tests are executed and results are available. </span><span class="koboSpan" id="kobo.3770.2">It can be used as input to an XSLT transformation to generate an HTML report for the instance. </span><span class="koboSpan" id="kobo.3770.3">The latter reporter needs to gather all of the program execution data in order to structure the report before printing it. </span><span class="koboSpan" id="kobo.3770.4">The JUNIT XML format is useful for being consumed by third-party tools, such as a continuous integration server.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3771.1">Several additional reporters are provided in standalone headers. </span><span class="koboSpan" id="kobo.3771.2">They need to be included in the source code of the test program (all the headers of the additional reporters have the name format as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3772.1">catch_reporter_*.hpp</span></code><span class="koboSpan" id="kobo.3773.1">). </span><span class="koboSpan" id="kobo.3773.2">These additional available reporters are:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.3774.1">TeamCity</span></strong><span class="koboSpan" id="kobo.3775.1"> reporter (specified with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3776.1">-r teamcity</span></code><span class="koboSpan" id="kobo.3777.1">), which writes TeamCity service messages to the standard output stream. </span><span class="koboSpan" id="kobo.3777.2">It is suitable only for integration with TeamCity. </span><span class="koboSpan" id="kobo.3777.3">It is a streamed reporter; data is written as it is available.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.3778.1">Automake</span></strong><span class="koboSpan" id="kobo.3779.1"> reporter (specified with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3780.1">-r automake</span></code><span class="koboSpan" id="kobo.3781.1">), which writes the meta tags expected by </span><code class="inlineCode"><span class="koboSpan" id="kobo.3782.1">automake</span></code><span class="koboSpan" id="kobo.3783.1"> via </span><code class="inlineCode"><span class="koboSpan" id="kobo.3784.1">make check</span></code><span class="koboSpan" id="kobo.3785.1">.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.3786.1">Test Anything Protocol</span></strong><span class="koboSpan" id="kobo.3787.1"> (or </span><strong class="keyWord"><span class="koboSpan" id="kobo.3788.1">TAP</span></strong><span class="koboSpan" id="kobo.3789.1">, for short) reporter (specified with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3790.1">-r tap</span></code><span class="koboSpan" id="kobo.3791.1">).</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.3792.1">SonarQube</span></strong><span class="koboSpan" id="kobo.3793.1"> reporter (specified with </span><code class="inlineCode"><span class="koboSpan" id="kobo.3794.1">-r sonarqube</span></code><span class="koboSpan" id="kobo.3795.1">), which writes using the SonarQube generic test data XML format.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3796.1">The following example shows how to include the TeamCity header file in order to produce the report using the TeamCity reporter:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.3797.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3798.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.3799.1">&lt;catch2/catch_test_macros.hpp&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.3800.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3801.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.3802.1">&lt;catch2/reporters/catch_reporter_teamcity.hpp&gt;</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3803.1">The default </span><a id="_idIndexMarker1420"/><span class="koboSpan" id="kobo.3804.1">target of the test report is the standard stream </span><code class="inlineCode"><span class="koboSpan" id="kobo.3805.1">stdout</span></code><span class="koboSpan" id="kobo.3806.1"> (even data written explicitly to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3807.1">stderr</span></code><span class="koboSpan" id="kobo.3808.1"> ends up being redirected to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3809.1">stdout</span></code><span class="koboSpan" id="kobo.3810.1">). </span><span class="koboSpan" id="kobo.3810.2">However, it is possible that the output is written to a file instead. </span><span class="koboSpan" id="kobo.3810.3">These formatting options can be combined. </span><span class="koboSpan" id="kobo.3810.4">Take a look at the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.3811.1">chapter11ca_04.exe -r junit -o test_report.xml
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3812.1">This command specifies that the report should use the JUNIT XML format and be saved to a file called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3813.1">test_report.xml</span></code><span class="koboSpan" id="kobo.3814.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-753"><span class="koboSpan" id="kobo.3815.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3816.1">Getting started with Catch2</span></em><span class="koboSpan" id="kobo.3817.1">, to learn how to install the Catch2 framework and how to create a simple test project</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3818.1">Writing and invoking tests with Catch2</span></em><span class="koboSpan" id="kobo.3819.1">, to see how to create tests with the Catch2 library, either using the traditional style based on test cases or the BDD style with scenarios, as well as how to run tests</span></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.3820.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3821.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="Chapter_11.xhtml"><span class="url"><span class="koboSpan" id="kobo.3822.1">https://discord.gg/7xRaTCeEhx</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.3823.1"><img alt="" src="../Images/QR_Code2659294082093549796.png"/></span></p>
</div>
</body></html>