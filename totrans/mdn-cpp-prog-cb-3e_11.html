<html><head></head><body>
<div><h1 class="chapterNumber">11</h1>
<h1 class="chapterTitle" id="_idParaDest-681">Exploring Testing Frameworks</h1>
<p class="normal">Testing the code is an important part of software development. Although there is no support for testing in the C++ standard, there are a large variety of frameworks for unit testing C++ code. The purpose of this chapter is to get you started with several modern and widely used testing frameworks that enable you to write portable testing code. The frameworks that will be covered in this chapter are <strong class="keyWord">Boost.Test</strong>, <strong class="keyWord">Google Test</strong>, and <strong class="keyWord">Catch2</strong>.</p>
<p class="normal">This chapter includes the following recipes:</p>
<ul>
<li class="bulletList">Getting started with Boost.Test</li>
<li class="bulletList">Writing and invoking tests with Boost.Test</li>
<li class="bulletList">Asserting with Boost.Test</li>
<li class="bulletList">Using test fixtures with Boost.Test</li>
<li class="bulletList">Controlling output with Boost.Test</li>
<li class="bulletList">Getting started with Google Test</li>
<li class="bulletList">Writing and invoking tests with Google Test</li>
<li class="bulletList">Asserting with Google Test</li>
<li class="bulletList">Using test fixtures with Google Test</li>
<li class="bulletList">Controlling output with Google Test</li>
<li class="bulletList">Getting started with Catch2</li>
<li class="bulletList">Writing and invoking tests with Catch2</li>
<li class="bulletList">Asserting with Catch2</li>
<li class="bulletList">Controlling output with Catch2</li>
</ul>
<p class="normal">These three frameworks were chosen due to their wide use, rich capabilities, the ease with which they can be used to write and execute tests, their extensibility, and their customization. The following table shows a short comparison of the features of these three libraries:</p>
<table class="table-container" id="table001-7">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Feature</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Boost.Test</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Google Test</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Catch2 (v3)</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Easy to install</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Header-only</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">No</p>
</td>
<td class="table-cell">
<p class="normal">No</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Compiled library</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Easy to write tests</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Automatic test registration</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Supports test suites</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">No (indirectly with tags)</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Supports fixtures</p>
</td>
<td class="table-cell">
<p class="normal">Yes (setup/teardown)</p>
</td>
<td class="table-cell">
<p class="normal">Yes (setup/teardown)</p>
</td>
<td class="table-cell">
<p class="normal">Yes (multiple ways)</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Rich set of asserts</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Non-fatal asserts</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Multiple output formats</p>
</td>
<td class="table-cell">
<p class="normal">Yes (includes HRF, XML)</p>
</td>
<td class="table-cell">
<p class="normal">Yes (includes HRF, XML)</p>
</td>
<td class="table-cell">
<p class="normal">Yes (includes HRF, XML)</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Filtering of test execution</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
<td class="table-cell">
<p class="normal">Yes</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">License</p>
</td>
<td class="table-cell">
<p class="normal">Boost</p>
</td>
<td class="table-cell">
<p class="normal">Apache 2.0</p>
</td>
<td class="table-cell">
<p class="normal">Boost</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 11.1: Comparison of features for Boost.Test, Google Test, and Catch2</p>
<p class="normal">All these features will be discussed in detail for each framework. This chapter has a symmetric structure, with 4 5 recipes dedicated to each testing framework. The first framework to look at is Boost.Test.</p>
<h1 class="heading-1" id="_idParaDest-682">Getting started with Boost.Test</h1>
<p class="normal"><strong class="keyWord">Boost.Test</strong> is<a id="_idIndexMarker1311"/> one of the oldest and most popular C++ testing frameworks. It provides an easy-to-use set of APIs for writing tests and organizing them into test cases and test suites. It has good support for asserting, exception handling, fixtures, and other important features required for a testing framework.</p>
<p class="normal">Throughout the next few recipes, we will explore the most important features it has that enable you to write unit tests. In this recipe, we will see how to install the framework and create a simple test project.</p>
<h2 class="heading-2" id="_idParaDest-683">Getting ready</h2>
<p class="normal">The Boost.Test framework has a macro-based API. Although you only need to use the supplied macros for writing tests, a good understanding of macros is recommended if you want to use the framework well.</p>
<h2 class="heading-2" id="_idParaDest-684">How to do it...</h2>
<p class="normal">In order to set up <a id="_idIndexMarker1312"/>your environment to use Boost.Test, do the following:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Download the latest<a id="_idIndexMarker1313"/> version of the Boost library from <a href="http://www.boost.org/">http://www.boost.org/</a>.</li>
<li class="numberedList">Unzip the content of the archive.</li>
<li class="numberedList">Build the library using the provided tools and scripts in order to use either the static or shared library variant. This step is not necessary if you plan to use the header-only version of the library.</li>
</ol>
<p class="normal">On Linux systems, the library can also be installed using package management tools. For instance, on Ubuntu, you can <a id="_idIndexMarker1314"/>use <strong class="keyWord">app-get</strong> to install<a id="_idIndexMarker1315"/> the libboost-test-dev package containing the Boost.Test library as follows:</p>
<pre class="programlisting con"><code class="hljs-con">sudo apt-get install libboost-test-dev
</code></pre>
<div><p class="normal">It is recommended that you consult the online documentation of the library for installation steps on various systems.</p>
</div>
<p class="normal">To create your first test program using the header-only variant of the Boost.Test library, do the following:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Create a new, empty C++ project.</li>
<li class="numberedList">Do the necessary setup specific to the development environment you are using to make the Boost <code class="inlineCode">main</code> folder available to the project for including header files.</li>
<li class="numberedList">Add a new source file to the project with the following content:
        <pre class="programlisting code"><code class="hljs-code">#define BOOST_TEST_MODULE My first test module
#include &lt;boost/test/included/unit_test.hpp&gt;
BOOST_AUTO_TEST_CASE(first_test_function)
{
  int a = 42;
  BOOST_TEST(a &gt; 0);
}
</code></pre>
</li>
<li class="numberedList">If you want to<a id="_idIndexMarker1316"/> link against the shared library version, then also define the <code class="inlineCode">BOOST_TEST_DYN_LINK</code> macro.</li>
<li class="numberedList">Build and run the project.</li>
</ol>
<h2 class="heading-2" id="_idParaDest-685">How it works...</h2>
<p class="normal">The Boost.Test library can <a id="_idIndexMarker1317"/>be downloaded, along with other Boost libraries, from <a href="http://www.boost.org/">http://www.boost.org/</a>. In this edition of the book, I used version 1.83, but the features discussed in these recipes will probably be available for many future versions. The <code class="inlineCode">Test</code> library comes in three variants:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Single header</strong>: This <a id="_idIndexMarker1318"/>enables you to write test programs without building the library; you just need to include a single header. Its limitation is that you can only have a single translation unit for the module; however, you can still split the module into multiple header files so that you can separate different test suites into different files.</li>
<li class="bulletList"><strong class="keyWord">Static library</strong>: This <a id="_idIndexMarker1319"/>enables you to split a module across different translation units, but the library needs to be built first as a static library.</li>
<li class="bulletList"><strong class="keyWord">Shared library</strong>: This <a id="_idIndexMarker1320"/>enables the same scenario as that of the static library. However, it has the advantage that, for programs with many test modules, this library is linked only once, and not once for each module, resulting in a smaller binary size. However, in this case, the shared library must be available at runtime.</li>
</ul>
<p class="normal">For simplicity, we<a id="_idIndexMarker1321"/> will use the single-header variant in this book. In the case of static and shared library variants, you’d need to build the library. The downloaded archive contains scripts for building the library. However, the exact steps vary, depending on the platform and the compiler; they will not be covered here but are available online.</p>
<p class="normal">There are several terms and concepts that you need to understand in order to use the library:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Test module</strong> is a program that performs tests. There are two types of modules: <strong class="keyWord">single-file</strong> (when you use the single-header variant) and <strong class="keyWord">multifile</strong> (when you use either the static or shared variant).</li>
<li class="bulletList"><strong class="keyWord">Test assertion</strong> is a condition that is checked by a test module.</li>
<li class="bulletList"><strong class="keyWord">Test case</strong> is a group of one or more test assertions that is independently executed and monitored by a test module so that if it fails or leaks uncaught exceptions, the execution of other tests will not be stopped.</li>
<li class="bulletList"><strong class="keyWord">Test suite</strong> is a collection of one or more test cases or test suites.</li>
<li class="bulletList"><strong class="keyWord">Test unit</strong> is either a test case or a test suite.</li>
<li class="bulletList"><strong class="keyWord">Test tree</strong> is a hierarchical structure of test units. In this structure, test cases are leaves and test suites are non-leaves.</li>
<li class="bulletList"><strong class="keyWord">Test runner</strong> is a component that, given a test tree, performs the necessary initialization, execution of tests, and results reporting.</li>
<li class="bulletList"><strong class="keyWord">Test report</strong> is the report produced by the test runner from executing the tests.</li>
<li class="bulletList"><strong class="keyWord">Test log</strong> is the recording of all the events that occur during the execution of the test module.</li>
<li class="bulletList"><strong class="keyWord">Test setup</strong> is the part of the test module responsible for the initialization of the framework, construction of the test tree, and individual test case setups.</li>
<li class="bulletList"><strong class="keyWord">Test cleanup</strong> is a part of the test module responsible for cleanup operations.</li>
<li class="bulletList"><strong class="keyWord">Test fixture</strong> is a pair of setup and cleanup operations that are invoked for multiple test units in order to avoid repetitive code.</li>
</ul>
<p class="normal">With these concepts defined, it is possible to explain the sample code listed earlier:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><code class="inlineCode">#define BOOST_TEST_MODULE My first test module</code> defines a stub for module initialization and sets a name for the main test suite. This must be defined before you include any library header.</li>
<li class="numberedList"><code class="inlineCode">#include &lt;boost/test/included/unit_test.hpp&gt;</code> includes the single-header library, which<a id="_idIndexMarker1322"/> includes all the other necessary headers.</li>
<li class="numberedList"><code class="inlineCode">BOOST_AUTO_TEST_CASE(first_test_function)</code> declares a test case without parameters (<code class="inlineCode">first_test_function</code>) and automatically registers it to be included in the test tree as part of the enclosing test suite. In this example, the test suite is the main test suite defined by <code class="inlineCode">BOOST_TEST_MODULE</code>.</li>
<li class="numberedList"><code class="inlineCode">BOOST_TEST(true);</code> performs a test assertion.</li>
</ol>
<p class="normal">The output of executing this test module is as follows:</p>
<pre class="programlisting con"><code class="hljs-con">Running 1 test case...
*** No errors detected
</code></pre>
<h2 class="heading-2" id="_idParaDest-686">There’s more...</h2>
<p class="normal">If you don’t want the library to generate the <code class="inlineCode">main()</code> function but want to write it yourself, then you need to define a couple more macros – <code class="inlineCode">BOOST_TEST_NO_MAIN</code> and <code class="inlineCode">BOOST_TEST_ALTERNATIVE_INIT_API</code> – before you include any of the library headers. Then, in the <code class="inlineCode">main()</code> function that you supply, invoke the default test runner called <code class="inlineCode">unit_test_main()</code> by providing the default initialization function called <code class="inlineCode">init_unit_test()</code> as an argument, as shown in the following code snippet:</p>
<pre class="programlisting code"><code class="hljs-code">#define BOOST_TEST_MODULE My first test module
#define BOOST_TEST_NO_MAIN
#define BOOST_TEST_ALTERNATIVE_INIT_API
#include &lt;boost/test/included/unit_test.hpp&gt;
BOOST_AUTO_TEST_CASE(first_test_function)
{
  int a = 42;
  BOOST_TEST(a &gt; 0);
}
int main(int argc, char* argv[])
{
  return boost::unit_test::unit_test_main(init_unit_test, argc, argv);
}
</code></pre>
<p class="normal">It is also possible to customize the initialization function of the test runner. In this case, you must remove the definition of the <code class="inlineCode">BOOST_TEST_MODULE</code> macro and instead write an initialization function that takes no arguments and returns a <code class="inlineCode">bool</code> value:</p>
<pre class="programlisting code"><code class="hljs-code">#define BOOST_TEST_NO_MAIN
#define BOOST_TEST_ALTERNATIVE_INIT_API
#include &lt;boost/test/included/unit_test.hpp&gt;
#include &lt;iostream&gt;
BOOST_AUTO_TEST_CASE(first_test_function)
{
  int a = 42;
  BOOST_TEST(a &gt; 0);
}
bool custom_init_unit_test()
{
  std::cout &lt;&lt; "test runner custom init\n";
  return true;
}
int main(int argc, char* argv[])
{
  return boost::unit_test::unit_test_main(
    custom_init_unit_test, argc, argv);
}
</code></pre>
<div><p class="normal">It is possible to customize the initialization function without writing the <code class="inlineCode">main()</code> function yourself. In this case, the <code class="inlineCode">BOOST_TEST_NO_MAIN</code> macro should not be defined and the initialization function should be called <code class="inlineCode">init_unit_test()</code>.</p>
</div>
<h2 class="heading-2" id="_idParaDest-687">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Writing and invoking tests with Boost.Test</em>, to see how to create test suites and test cases using the single-header version of the Boost.Test library, as well as how to run tests</li>
</ul>
<h1 class="heading-1" id="_idParaDest-688">Writing and invoking tests with Boost.Test</h1>
<p class="normal">The library provides both an automatic and manual way of registering test cases and test suites to be executed by the test runner. Automatic registration is the simplest way because it enables you to construct a test tree just by declaring test units. In this recipe, we will see how to create test suites and test cases using the single-header version of the library, as well as how to run tests.</p>
<h2 class="heading-2" id="_idParaDest-689">Getting ready</h2>
<p class="normal">To exemplify <a id="_idIndexMarker1323"/>the creation of test suites and test cases, we will use the following class, which represents a three-dimensional point. This implementation contains methods for accessing the properties of a point, comparison operators, a stream <a id="_idIndexMarker1324"/>output operator, and a method for modifying the position of a point:</p>
<pre class="programlisting code"><code class="hljs-code">class point3d
{
  int x_;
  int y_;
  int z_;
public:
  point3d(int const x = 0, 
          int const y = 0, 
          int const z = 0):x_(x), y_(y), z_(z) {}
  int x() const { return x_; }
  point3d&amp; x(int const x) { x_ = x; return *this; }
  int y() const { return y_; }
  point3d&amp; y(int const y) { y_ = y; return *this; }
  int z() const { return z_; }
  point3d&amp; z(int const z) { z_ = z; return *this; }
  bool operator==(point3d const &amp; pt) const
  {
    return x_ == pt.x_ &amp;&amp; y_ == pt.y_ &amp;&amp; z_ == pt.z_;
  }
  bool operator!=(point3d const &amp; pt) const
  {
    return !(*this == pt);
  }
  bool operator&lt;(point3d const &amp; pt) const
  {
    return x_ &lt; pt.x_ || y_ &lt; pt.y_ || z_ &lt; pt.z_;
  }
  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, 
                                  point3d const &amp; pt)
  {
    stream &lt;&lt; "(" &lt;&lt; pt.x_ &lt;&lt; "," &lt;&lt; pt.y_ &lt;&lt; "," &lt;&lt; pt.z_ &lt;&lt; ")";
    return stream;
  }
  void offset(int const offsetx, int const offsety, int const offsetz)
 {
    x_ += offsetx;
    y_ += offsety;
    z_ += offsetz;
  }
  static point3d origin() { return point3d{}; }
};
</code></pre>
<p class="normal">Before<a id="_idIndexMarker1325"/> you <a id="_idIndexMarker1326"/>go any further, notice that the test cases in this recipe contain erroneous tests on purpose so that they produce failures.</p>
<h2 class="heading-2" id="_idParaDest-690">How to do it...</h2>
<p class="normal">Use the following macros to create test units:</p>
<ul>
<li class="bulletList">To create a test suite, use <code class="inlineCode">BOOST_AUTO_TEST_SUITE(name)</code> and <code class="inlineCode">BOOST_AUTO_TEST_SUITE_END()</code>:
        <pre class="programlisting code"><code class="hljs-code">BOOST_AUTO_TEST_SUITE(test_construction)
// test cases 
BOOST_AUTO_TEST_SUITE_END()
</code></pre>
</li>
<li class="bulletList">To create a test case, use <code class="inlineCode">BOOST_AUTO_TEST_CASE(name)</code>. Test cases are defined between <code class="inlineCode">BOOST_AUTO_TEST_SUITE(name)</code> and <code class="inlineCode">BOOST_AUTO_TEST_SUITE_END()</code>, as shown in the following code snippet:
        <pre class="programlisting code"><code class="hljs-code">BOOST_AUTO_TEST_CASE(test_constructor)
{
  auto p = point3d{ 1,2,3 };
  BOOST_TEST(p.x() == 1);
  BOOST_TEST(p.y() == 2);
  BOOST_TEST(p.z() == 4); // will fail
}
BOOST_AUTO_TEST_CASE(test_origin)
{
  auto p = point3d::origin();
  BOOST_TEST(p.x() == 0);
  BOOST_TEST(p.y() == 0);
  BOOST_TEST(p.z() == 0);
}
</code></pre>
</li>
<li class="bulletList">To<a id="_idIndexMarker1327"/> create <a id="_idIndexMarker1328"/>a nested test suite, define a test suite inside another test suite:
        <pre class="programlisting code"><code class="hljs-code">BOOST_AUTO_TEST_SUITE(test_operations)
BOOST_AUTO_TEST_SUITE(test_methods)
BOOST_AUTO_TEST_CASE(test_offset)
{
  auto p = point3d{ 1,2,3 };
  p.offset(1, 1, 1);
  BOOST_TEST(p.x() == 2);
  BOOST_TEST(p.y() == 3);
  BOOST_TEST(p.z() == 3); // will fail
}
BOOST_AUTO_TEST_SUITE_END()
BOOST_AUTO_TEST_SUITE_END()
</code></pre>
</li>
<li class="bulletList">To add decorators to a test unit, add an additional parameter to the test unit’s macros. Decorators could include description, label, precondition, dependency, fixture, and so on. Refer to the following code snippet, which illustrates this:
        <pre class="programlisting code"><code class="hljs-code">BOOST_AUTO_TEST_SUITE(test_operations)
BOOST_AUTO_TEST_SUITE(test_operators)
BOOST_AUTO_TEST_CASE(
  test_equal, 
  *boost::unit_test::description("test operator==")
  *boost::unit_test::label("opeq"))
{
  auto p1 = point3d{ 1,2,3 };
  auto p2 = point3d{ 1,2,3 };
  auto p3 = point3d{ 3,2,1 };
  BOOST_TEST(p1 == p2);
  BOOST_TEST(p1 == p3); // will fail
}
BOOST_AUTO_TEST_CASE(
  test_not_equal, 
  *boost::unit_test::description("test operator!=")
  *boost::unit_test::label("opeq")
  *boost::unit_test::depends_on(
    "test_operations/test_operators/test_equal"))
{
  auto p1 = point3d{ 1,2,3 };
  auto p2 = point3d{ 3,2,1 };
  BOOST_TEST(p1 != p2);
}
BOOST_AUTO_TEST_CASE(test_less)
{
  auto p1 = point3d{ 1,2,3 };
  auto p2 = point3d{ 1,2,3 };
  auto p3 = point3d{ 3,2,1 };
  BOOST_TEST(!(p1 &lt; p2));
  BOOST_TEST(p1 &lt; p3);
}
BOOST_AUTO_TEST_SUITE_END()
BOOST_AUTO_TEST_SUITE_END()
</code></pre>
</li>
</ul>
<p class="normal">To execute<a id="_idIndexMarker1329"/> the tests, do<a id="_idIndexMarker1330"/> the following (notice that the command line is Windows-specific, but it should be trivial to replace that with the one specific to Linux or macOS):</p>
<ul>
<li class="bulletList">To execute the entire test tree, run the program (the test module) without any parameters:
        <pre class="programlisting con"><code class="hljs-con">chapter11bt_02.exe
Running 6 test cases...
f:/chapter11bt_02/main.cpp(12): error: in "test_construction/test_
constructor": check p.z() == 4 has failed [3 != 4]
f:/chapter11bt_02/main.cpp(35): error: in "test_operations/test_
methods/test_offset": check p.z() == 3 has failed [4 != 3]
f:/chapter11bt_02/main.cpp(55): error: in "test_operations/test_
operators/test_equal": check p1 == p3 has failed [(1,2,3) != 
(3,2,1)]
*** 3 failures are detected in the test module "Testing point 3d"
</code></pre>
</li>
<li class="bulletList">To execute a <a id="_idIndexMarker1331"/>single test suite, run the program with the argument <code class="inlineCode">run_test</code>, specifying the path of the test suite:
        <pre class="programlisting con"><code class="hljs-con">chapter11bt_02.exe --run_test=test_construction
Running 2 test cases...
f:/chapter11bt_02/main.cpp(12): error: in "test_construction/test_
constructor": check p.z() == 4 has failed [3 != 4]
*** 1 failure is detected in the test module "Testing point 3d"
</code></pre>
</li>
<li class="bulletList">To <a id="_idIndexMarker1332"/>execute a single test case, run the program with the argument <code class="inlineCode">run_test</code>, specifying the path of the test case:
        <pre class="programlisting con"><code class="hljs-con">chapter11bt_02.exe --run_test=test_construction/test_origin
Running 1 test case...
*** No errors detected
</code></pre>
</li>
<li class="bulletList">To execute a collection of test suites and test cases defined under the same label, run the program with the argument <code class="inlineCode">run_test</code>, specifying the label name prefixed with <code class="inlineCode">@</code>:
        <pre class="programlisting con"><code class="hljs-con">chapter11bt_02.exe --run_test=@opeq
Running 2 test cases...
f:/chapter11bt_02/main.cpp(56): error: in "test_operations/test_
operators/test_equal": check p1 == p3 has failed [(1,2,3) != 
(3,2,1)]
*** 1 failure is detected in the test module "Testing point 3d"
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-691">How it works...</h2>
<p class="normal">A test tree is a<a id="_idIndexMarker1333"/> hierarchy of test cases and test suites, which also includes the fixtures and additional dependencies. A test suite can <a id="_idIndexMarker1334"/>contain one or more test cases and other nested test suites as well. Test suites are similar to namespaces in the sense that they can be stopped and restarted multiple times in the same file or in different files. Automatic registration of test suites is done with the macros <code class="inlineCode">BOOST_AUTO_TEST_SUITE</code>, which requires a name, and <code class="inlineCode">BOOST_AUTO_TEST_SUITE_END</code>. Automatic registration of test cases is done with <code class="inlineCode">BOOST_AUTO_TEST_CASE</code>. Test units (whether they’re cases or suites) become members of the closest test suite. Test units defined at the file scope level become members of the master test suite - the implicit test suite created with the <code class="inlineCode">BOOST_TEST_MODULE</code> declaration.</p>
<p class="normal">Both test suites and test cases can be decorated with a series of attributes that affect how test units will be processed during the execution of the test module. The currently supported decorators are as follows:</p>
<ul>
<li class="bulletList"><code class="inlineCode">depends_on</code>: This indicates a dependency between the current test unit and a designated test unit.</li>
<li class="bulletList"><code class="inlineCode">description</code>: This provides a semantic description of a test unit.</li>
<li class="bulletList"><code class="inlineCode">enabled</code> / <code class="inlineCode">disabled</code>: These set the default run status of a test unit to either <code class="inlineCode">true</code> or <code class="inlineCode">false</code>.</li>
<li class="bulletList"><code class="inlineCode">enable_if&lt;bool&gt;</code>: This sets the default run status of a test unit to either <code class="inlineCode">true</code> or <code class="inlineCode">false</code>, depending on the evaluation of a compile-time expression.</li>
<li class="bulletList"><code class="inlineCode">expected_failures</code>: This indicates the expected failures for a test unit.</li>
<li class="bulletList"><code class="inlineCode">fixture</code>: This specifies a pair of functions (startup and cleanup) to be called before and after the execution of a test unit.</li>
<li class="bulletList"><code class="inlineCode">label</code>: With this, you can associate a test unit with a label. The same label can be used for multiple test units, and a test unit can have multiple labels.</li>
<li class="bulletList"><code class="inlineCode">precondition</code>: This associates a predicate with a test unit, which is used at runtime to determine the run status of the test unit.</li>
<li class="bulletList"><code class="inlineCode">timeout</code>: Specifies a timeout for a unit test, in wall-clock time. If the test lasts longer than the specified timeout, the test fails.</li>
<li class="bulletList"><code class="inlineCode">tolerance</code>: This decorator specifies the default comparison tolerance for the floating-point type FTP in the decorated test unit.</li>
</ul>
<p class="normal">If the execution of a<a id="_idIndexMarker1335"/> test case results in an unhandled exception, the framework will catch the exception and terminate the execution of the test case with a failure. However, the framework provides several macros to test whether a particular piece of code raises, or does not raise, exceptions. For more information, see the next recipe, <em class="italic">Asserting with Boost.Test</em>.</p>
<p class="normal">The test units that compose the module’s test tree can be executed entirely or partially. In both cases, to execute the test units, execute the (binary) program, which represents the test module. To execute only some of the test units, use the <code class="inlineCode">--run_test</code> command-line option (or <code class="inlineCode">--t</code> if you want to use a shorter name). This option allows you to filter the test units and specify either a path or a label. A path consists of a sequence of test suite and/or test case names, such as <code class="inlineCode">test_construction</code> or <code class="inlineCode">test_operations</code>/<code class="inlineCode">test_methods</code>/<code class="inlineCode">test_offset</code>. A label is a name defined with the <code class="inlineCode">label</code> decorator and is prefixed with <code class="inlineCode">@</code> for the <code class="inlineCode">run_test</code> parameter. This parameter is repeatable, which means you can specify multiple filters on it.</p>
<h2 class="heading-2" id="_idParaDest-692">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Getting started with Boost.Test</em>, to learn how to install the Boost.Test framework and how to create a simple test project</li>
<li class="bulletList"><em class="italic">Asserting with Boost.Test</em>, to explore the rich set of assertion macros from the Boost.Test library</li>
</ul>
<h1 class="heading-1" id="_idParaDest-693">Asserting with Boost.Test</h1>
<p class="normal">A test <a id="_idIndexMarker1336"/>case contains one or more tests. The Boost.Test library provides a series of APIs in the form of macros to write tests. In the previous recipe, you learned a bit about the <code class="inlineCode">BOOST_TEST</code> macro, which is the most important and widely used macro in the library. In this recipe, we will discuss how the <code class="inlineCode">BOOST_TEST</code> macro can be used in further detail.</p>
<h2 class="heading-2" id="_idParaDest-694">Getting ready</h2>
<p class="normal">You should <a id="_idIndexMarker1337"/>now be familiar with writing test suites and test cases, a topic we covered in the previous recipe.</p>
<h2 class="heading-2" id="_idParaDest-695">How to do it...</h2>
<p class="normal">The following list shows some of the most commonly used APIs for performing tests:</p>
<ul>
<li class="bulletList"><code class="inlineCode">BOOST_TEST</code>, in its plain form, is used for most tests:
        <pre class="programlisting code"><code class="hljs-code">int a = 2, b = 4;
BOOST_TEST(a == b);
BOOST_TEST(4.201 == 4.200);
std::string s1{ "sample" };
std::string s2{ "text" };
BOOST_TEST(s1 == s2, "not equal");
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">BOOST_TEST</code>, along with the <code class="inlineCode">tolerance()</code> manipulator, is used to indicate the tolerance of floating-point comparisons:
        <pre class="programlisting code"><code class="hljs-code">BOOST_TEST(4.201 == 4.200, boost::test_tools::tolerance(0.001));
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">BOOST_TEST</code>, along with the <code class="inlineCode">per_element()</code> manipulator, is used to perform an element-wise comparison of containers (even of different types):
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v{ 1,2,3 };
std::list&lt;short&gt; l{ 1,2,3 };
BOOST_TEST(v == l, boost::test_tools::per_element());
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">BOOST_TEST</code>, along with the ternary operator and compound statements using the logical <code class="inlineCode">||</code> or <code class="inlineCode">&amp;&amp;</code>, requires an extra set of parentheses:
        <pre class="programlisting code"><code class="hljs-code">BOOST_TEST((a &gt; 0 ? true : false));
BOOST_TEST((a &gt; 2 &amp;&amp; b &lt; 5));
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">BOOST_ERROR</code> is used to unconditionally fail a test and produce a message in the report. This is equivalent to <code class="inlineCode">BOOST_TEST(false, message)</code>:
        <pre class="programlisting code"><code class="hljs-code">BOOST_ERROR("this test will fail");
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">BOOST_TEST_WARN</code> is used to produce a warning in the report in case a test is failing, without increasing the number of encountered errors and stopping the execution of the test case:
        <pre class="programlisting code"><code class="hljs-code">BOOST_TEST_WARN(a == 4, "something is not right");
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">BOOST_TEST_REQUIRE</code> is used to ensure that test case pre-conditions are met; the execution of the test case is stopped otherwise:
        <pre class="programlisting code"><code class="hljs-code">BOOST_TEST_REQUIRE(a == 4, "this is critical");
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">BOOST_FAIL</code> is used to unconditionally stop the execution of the test case, increase the number of encountered errors, and produce a message in the report. This is equivalent to <code class="inlineCode">BOOST_TEST_REQUIRE(false, message)</code>:
        <pre class="programlisting code"><code class="hljs-code">BOOST_FAIL("must be implemented");
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">BOOST_IS_DEFINED</code> is used to check whether a particular preprocessor symbol is <a id="_idIndexMarker1338"/>defined at runtime. It is used together with <code class="inlineCode">BOOST_TEST</code> to perform validation and logging:
        <pre class="programlisting code"><code class="hljs-code">BOOST_TEST(BOOST_IS_DEFINED(UNICODE));
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-696">How it works...</h2>
<p class="normal">The library defines a variety of macros and manipulators for performing test assertions. The most commonly used one is <code class="inlineCode">BOOST_TEST</code>. This macro simply evaluates an expression; if it fails, it increases the error count but continues the execution of the test case. It has three variants actually:</p>
<ul>
<li class="bulletList"><code class="inlineCode">BOOST_TEST_CHECK</code> is the same as <code class="inlineCode">BOOST_TEST</code> and is used to perform checks, as described in the previous section.</li>
<li class="bulletList"><code class="inlineCode">BOOST_TEST_WARN</code> is used for assertions meant to provide information, without increasing the error count and stopping the execution of the test case.</li>
<li class="bulletList"><code class="inlineCode">BOOST_TEST_REQUIRE</code> is intended to ensure that pre-conditions that are required for test cases to continue execution are met. Upon failure, this macro increases the error count and stops the execution of the test case.</li>
</ul>
<p class="normal">The general form of the test macro is <code class="inlineCode">BOOST_TEST(statement)</code>. This macro provides rich and flexible reporting capabilities. By default, it shows not only the statement but also the value of the operands, to enable quick identification of the failure’s cause.</p>
<p class="normal">However, the user could provide an alternative failure description; in this scenario, the message is logged in the test report:</p>
<pre class="programlisting code"><code class="hljs-code">BOOST_TEST(a == b);
// error: in "regular_tests": check a == b has failed [2 != 4]
BOOST_TEST(a == b, "not equal");
// error: in "regular_tests": not equal
</code></pre>
<p class="normal">This macro also<a id="_idIndexMarker1339"/> allows you to control the comparison process with special support for the following:</p>
<ul>
<li class="bulletList">The first is a floating-point comparison, where tolerance can be defined to test equality.</li>
<li class="bulletList">Secondly, it supports a container’s comparison using several methods: default comparison (using the overloaded operator ==), per-element comparison, and lexicographic comparison (using the lexicographical order). Per-element comparison enables the comparison of different types of containers (such as vector and list) in the order given by the forward iterators of the container; it also takes into account the size of the container (meaning that it first tests the sizes and, only if they are equal, continues with the comparison of the elements).</li>
<li class="bulletList">Lastly, it supports bitwise comparison of the operands. Upon failure, the framework reports the index of the bit where the comparison failed.</li>
</ul>
<p class="normal">The <code class="inlineCode">BOOST_TEST</code> macro does have some limitations. It cannot be used with compound statements that use a comma, because such statements would be intercepted and handled by the preprocessor or the ternary operator, and compound statements using the logical operators <code class="inlineCode">||</code> and <code class="inlineCode">&amp;&amp;</code>. The latter cases have a workaround: a second pair of parentheses, as in <code class="inlineCode">BOOST_TEST((statement))</code>.</p>
<p class="normal">Several macros are available for testing whether a particular exception is raised during the evaluation of an expression. In the following list, <code class="inlineCode">&lt;level&gt;</code> is either <code class="inlineCode">CHECK</code>, <code class="inlineCode">WARN</code>, or <code class="inlineCode">REQUIRE</code>:</p>
<ul>
<li class="bulletList"><code class="inlineCode">BOOST_&lt;level&gt;_NO_THROW(expr)</code> checks whether an exception is raised from the <code class="inlineCode">expr</code> expression. Any exception raised during the evaluation of <code class="inlineCode">expr</code> is caught by this assertion and is not propagated to the test body. If any exception occurs, the assertion fails.</li>
<li class="bulletList"><code class="inlineCode">BOOST_&lt;level&gt;_THROW(expr, exception_type)</code> checks whether an exception of <code class="inlineCode">exception_type</code> is raised from the <code class="inlineCode">expr</code> expression. If the expression <code class="inlineCode">expr</code> does not raise any exception, then the assertion fails. Exceptions of types other than <code class="inlineCode">exception_type</code> are not caught by this assertion and can be propagated to the test body. Uncaught exceptions in a test case are caught by the execution monitor, but they result in failed test cases.</li>
<li class="bulletList"><code class="inlineCode">BOOST_&lt;level&gt;_EXCEPTION(expr, exception_type, predicate)</code> checks whether an exception of <code class="inlineCode">exception_type</code> is raised from the <code class="inlineCode">expr</code> expression. If so, it passes the expression to the predicate for further examination. If no exception is raised or an exception of a type different than <code class="inlineCode">exception_type</code> is raised, then the assertion behaves like <code class="inlineCode">BOOST_&lt;level&gt;_THROW</code>.</li>
</ul>
<p class="normal">This recipe<a id="_idIndexMarker1340"/> discussed only the most common APIs for testing and their typical usage. However, the library provides many more APIs. For further reference, check the online documentation. For version 1.83, refer to <a href="https://www.boost.org/doc/libs/1_83_0/libs/test/doc/html/index.html">https://www.boost.org/doc/libs/1_83_0/libs/test/doc/html/index.html</a>.</p>
<h2 class="heading-2" id="_idParaDest-697">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Writing and invoking tests with Boost.Test</em>, to see how to create test suites and test cases using the single-header version of the Boost.Test library, as well as how to run tests</li>
</ul>
<h1 class="heading-1" id="_idParaDest-698">Using fixtures in Boost.Test</h1>
<p class="normal">The larger a test module is <a id="_idIndexMarker1341"/>and the more similar the test cases are, the more likely it is to have test cases that require the same setup, cleanup, and maybe the same data. A component that contains these is called a <strong class="keyWord">test fixture</strong> or <strong class="keyWord">test context</strong>. Fixtures<a id="_idIndexMarker1342"/> are important to establish a well-defined environment for running tests so <a id="_idIndexMarker1343"/>that the results are repeatable. Examples can include copying a specific set of files to some location before executing the tests and deleting them after, or loading data from a particular data source.</p>
<p class="normal">Boost.Test provides several ways to define test fixtures for a test case, test suite, or module (globally). In this recipe, we will look at how fixtures work.</p>
<h2 class="heading-2" id="_idParaDest-699">Getting ready</h2>
<p class="normal">The examples in <a id="_idIndexMarker1344"/>this recipe use the following classes and functions for specifying test unit fixtures:</p>
<pre class="programlisting code"><code class="hljs-code">struct global_fixture
{
   global_fixture()  { BOOST_TEST_MESSAGE("global setup"); }
   ~global_fixture() { BOOST_TEST_MESSAGE("global cleanup"); }
   int g{ 1 };
};
struct standard_fixture
{
  standard_fixture()  {BOOST_TEST_MESSAGE("setup");}
  ~standard_fixture() {BOOST_TEST_MESSAGE("cleanup");}
  int n {42};
};
struct extended_fixture
{
  std::string name;
  int         data;
  extended_fixture(std::string const &amp; n = "") : name(n), data(0) 
  {
    BOOST_TEST_MESSAGE("setup "+ name);
  }
  ~extended_fixture()
  {
    BOOST_TEST_MESSAGE("cleanup "+ name);
  }
};
void fixture_setup()
{
  BOOST_TEST_MESSAGE("fixture setup");
}
void fixture_cleanup()
{
  BOOST_TEST_MESSAGE("fixture cleanup");
}
</code></pre>
<p class="normal">The first <a id="_idIndexMarker1345"/>two are classes whose constructors represent the setup function and the destructors represent the teardown function. At the end of the sample, there is a pair of functions, <code class="inlineCode">fixture_setup()</code> and <code class="inlineCode">fixture_cleanup()</code>, that represent functions for a test’s setup and cleanup.</p>
<h2 class="heading-2" id="_idParaDest-700">How to do it...</h2>
<p class="normal">Use the following methods to define test fixtures for one or multiple test units:</p>
<ul>
<li class="bulletList">To define a fixture for a particular test case, use the <code class="inlineCode">BOOST_FIXTURE_TEST_CASE</code> macro:
        <pre class="programlisting code"><code class="hljs-code">BOOST_FIXTURE_TEST_CASE(test_case, extended_fixture)
{
  data++;
  BOOST_TEST(data == 1);
}
</code></pre>
</li>
<li class="bulletList">To define a fixture for all the test cases in a test suite, use <code class="inlineCode">BOOST_FIXTURE_TEST_SUITE</code>:
        <pre class="programlisting code"><code class="hljs-code">BOOST_FIXTURE_TEST_SUITE(suite1, extended_fixture)
BOOST_AUTO_TEST_CASE(case1)
{
  BOOST_TEST(data == 0);
}
BOOST_AUTO_TEST_CASE(case2)
{
  data++;
  BOOST_TEST(data == 1);
}
BOOST_AUTO_TEST_SUITE_END()
</code></pre>
</li>
<li class="bulletList">To define a fixture for all the test units in a test suite, except for one or several test units, use <code class="inlineCode">BOOST_FIXTURE_TEST_SUITE</code>. You can overwrite it to a particular test unit with <code class="inlineCode">BOOST_FIXTURE_TEST_CASE</code> for a test case and <code class="inlineCode">BOOST_FIXTURE_TEST_SUITE</code> for a nested test suite:
        <pre class="programlisting code"><code class="hljs-code">BOOST_FIXTURE_TEST_SUITE(suite2, extended_fixture)
BOOST_AUTO_TEST_CASE(case1)
{
  BOOST_TEST(data == 0);
}
BOOST_FIXTURE_TEST_CASE(case2, standard_fixture)
{
  BOOST_TEST(n == 42);
}
BOOST_AUTO_TEST_SUITE_END()
</code></pre>
</li>
<li class="bulletList">To<a id="_idIndexMarker1346"/> define more than a single fixture for a test case or test suite, use <code class="inlineCode">boost::unit_test::fixture</code> with the <code class="inlineCode">BOOST_AUTO_TEST_SUITE</code> and <code class="inlineCode">BOOST_AUTO_TEST_CASE</code> macros:
        <pre class="programlisting code"><code class="hljs-code">BOOST_AUTO_TEST_CASE(test_case_multifix,
  * boost::unit_test::fixture&lt;extended_fixture&gt;(std::string("fix1"))
  * boost::unit_test::fixture&lt;extended_fixture&gt;(std::string("fix2"))
  * boost::unit_test::fixture&lt;standard_fixture&gt;())
{
  BOOST_TEST(true);
}
</code></pre>
</li>
<li class="bulletList">To use free functions as setup and teardown operations in the case of a fixture, use <code class="inlineCode">boost::unit_test::fixture</code>:
        <pre class="programlisting code"><code class="hljs-code">BOOST_AUTO_TEST_CASE(test_case_funcfix,
  * boost::unit_test::fixture(&amp;fixture_setup, &amp;fixture_cleanup))
{
  BOOST_TEST(true);
}
</code></pre>
</li>
<li class="bulletList">To define a fixture for the module, use <code class="inlineCode">BOOST_GLOBAL_FIXTURE</code>:
        <pre class="programlisting code"><code class="hljs-code">BOOST_GLOBAL_FIXTURE(global_fixture);
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-701">How it works...</h2>
<p class="normal">The library supports a <a id="_idIndexMarker1347"/>couple of fixture models:</p>
<ul>
<li class="bulletList">A <strong class="keyWord">class model</strong>, where<a id="_idIndexMarker1348"/> the constructor acts as the setup function and the destructor as the cleanup function. An extended model allows the constructor to have one parameter. In the preceding example, <code class="inlineCode">standard_fixture</code> implemented the first model and <code class="inlineCode">extended_fixture</code> implemented the second model.</li>
<li class="bulletList">A <strong class="keyWord">pair of free functions</strong>: one <a id="_idIndexMarker1349"/>that defines the setup and the other, which is optional, that implements the cleanup code. In the preceding example, we came across these when discussing <code class="inlineCode">fixture_setup()</code> and <code class="inlineCode">fixture_cleanup()</code>.</li>
</ul>
<p class="normal">Fixtures implemented as classes can also have data members, and these members are made available to the test unit. If a fixture is defined for a test suite, it is available implicitly to all the test units that are grouped under this test suite. However, it is possible that test units contained in such a test suite could redefine the fixture. In this case, the fixture defined in the closest scope is the one available to the test unit.</p>
<p class="normal">It is possible to define multiple fixtures for a test unit. However, this is done with the <code class="inlineCode">boost::unit_test::fixture()</code> decorator, not with macros. The test suite and test case are defined, in this case, with the <code class="inlineCode">BOOST_TEST_SUITE</code>/<code class="inlineCode">BOOST_AUTO_TEST_SUITE</code> and <code class="inlineCode">BOOST_TEST_CASE</code>/<code class="inlineCode">BOOST_AUTO_TEST_CASE</code> macros. Multiple <code class="inlineCode">fixture()</code> decorators can be composed together with <code class="inlineCode">operator *</code>, as seen in the previous section. The purpose of this decorator is to define a setup and a teardown function to be called before and after the execution of the test unit. It comes in several forms, either with a pair of functions or with a class where the constructor and destructor play the role of the setup/teardown functions. A drawback, or perhaps misleading part, of using the fixture decorator with a class that contains member data is that these members will not be available for the test units.</p>
<p class="normal">A new fixture object is constructed for each test case when it is executed, and the object is destroyed at the end of the test case.</p>
<div><p class="normal">The fixture state is not shared among different test cases. Therefore, the constructor and destructor are called once for each test case. You must make sure these special functions do not contain code that is supposed to be executed only once per module. If this is the case, you should set a global fixture for the entire module.</p>
</div>
<p class="normal">A global fixture<a id="_idIndexMarker1350"/> uses the generic test class model (the model with the default constructor); you can define any number of global fixtures (allowing you to organize setup and cleanup by category, if necessary). Global fixtures are defined with the <code class="inlineCode">BOOST_GLOBAL_FIXTURE</code> macro, and they have to be defined at the test file scope (not inside any test unit). Their purpose is to define setup and teardown functions, represented by the constructor and destructor of a class. If the class also defines other members, such as data, these are not available in the test units:</p>
<pre class="programlisting code"><code class="hljs-code">BOOST_GLOBAL_FIXTURE(global_fixture);
BOOST_AUTO_TEST_CASE(test_case_globals)
{
   BOOST_TEST(g == 1); // error, g not accessible
BOOST_TEST(true);
}
</code></pre>
<h2 class="heading-2" id="_idParaDest-702">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Writing and invoking tests with Boost.Test</em>, to see how to create test suites and test cases using the single-header version of the Boost.Test library, as well as how to run tests</li>
</ul>
<h1 class="heading-1" id="_idParaDest-703">Controlling output with Boost.Test</h1>
<p class="normal">The framework provides us with the ability to customize what is shown in the test log and test report <a id="_idIndexMarker1351"/>and then format the <a id="_idIndexMarker1352"/>results. Currently, there are two that are supported: a <strong class="keyWord">human-readable format</strong> (or <strong class="keyWord">HRF</strong>) and XML (also with a JUNIT format for the test log). However, it is possible to create and add your own format.</p>
<div><p class="normal">A human-readable format is any form of encoding data that can be naturally read by humans. Text, whether encoded as ASCII or Unicode, is used for this purpose.</p>
</div>
<p class="normal">The <a id="_idIndexMarker1353"/>configuration of what is shown in the output can be done both at runtime, through command-line switches, and at compile time, through various APIs. During the execution of the tests, the framework collects all the events in a log. At the end, it produces a report that represents a summary of the execution with different levels of detail. In the case of a failure, the report contains detailed information about the location and the cause, including actual and expected values. This helps developers quickly identify the error. In this recipe, we will see how to control what is written in the log and the report and in which format; we do this using the command-line options at runtime.</p>
<h2 class="heading-2" id="_idParaDest-704">Getting ready</h2>
<p class="normal">For the examples presented in this recipe, we will use the following test module:</p>
<pre class="programlisting code"><code class="hljs-code">#define BOOST_TEST_MODULE Controlling output
#include &lt;boost/test/included/unit_test.hpp&gt;
BOOST_AUTO_TEST_CASE(test_case)
{
  BOOST_TEST(true);
}
BOOST_AUTO_TEST_SUITE(test_suite)
BOOST_AUTO_TEST_CASE(test_case)
{
  int a = 42;
  BOOST_TEST(a == 0);
}
BOOST_AUTO_TEST_SUITE_END()
</code></pre>
<p class="normal">The next section presents how to control the test log and the test report’s output through command-line options.</p>
<h2 class="heading-2" id="_idParaDest-705">How to do it...</h2>
<p class="normal">To control the test log’s output, do the following:</p>
<ul>
<li class="bulletList">Use either the <code class="inlineCode">--log_format=&lt;format&gt;</code> or <code class="inlineCode">-f &lt;format&gt;</code> command-line option to specify the log format. The possible formats are <code class="inlineCode">HRF</code> (the default value), <code class="inlineCode">XML</code>, and <code class="inlineCode">JUNIT</code>.</li>
<li class="bulletList">Use either the <code class="inlineCode">--log_level=&lt;level&gt;</code> or <code class="inlineCode">-l &lt;level&gt;</code> command-line option to specify the log level. The possible log levels include <code class="inlineCode">error</code> (default for HRF and XML), <code class="inlineCode">warning</code>, <code class="inlineCode">all</code>, and <code class="inlineCode">success</code> (the default for JUNIT).</li>
<li class="bulletList">Use either the <code class="inlineCode">--log_sink=&lt;stream or file name&gt;</code> or <code class="inlineCode">-k &lt;stream or file name&gt;</code> command-line option to specify the location where the framework should write the test log. The possible options are <code class="inlineCode">stdout</code> (default for HRF and XML), <code class="inlineCode">stderr</code>, or an arbitrary filename (default for JUNIT).</li>
</ul>
<p class="normal">To control the <a id="_idIndexMarker1354"/>test report’s output, do the following:</p>
<ul>
<li class="bulletList">Use either the <code class="inlineCode">--report_format=&lt;format&gt;</code> or <code class="inlineCode">-m &lt;format&gt;</code> command-line option to specify the report format. The possible formats are <code class="inlineCode">HRF</code> (the default value) and <code class="inlineCode">XML</code>.</li>
<li class="bulletList">Use either the <code class="inlineCode">--report_level=&lt;format&gt;</code> or <code class="inlineCode">-r &lt;format&gt;</code> command-line option to specify the report level. The possible formats are <code class="inlineCode">confirm</code> (the default value), <code class="inlineCode">no</code> (for no report), <code class="inlineCode">short</code>, and <code class="inlineCode">detailed</code>.</li>
<li class="bulletList">Use either the <code class="inlineCode">--report_sink=&lt;stream or file name&gt;</code> or <code class="inlineCode">-e &lt;stream or file name&gt;</code> command-line option to specify the location where the framework should write the report log. The possible options are <code class="inlineCode">stderr</code> (the default value), <code class="inlineCode">stdout</code>, or an arbitrary filename.</li>
</ul>
<h2 class="heading-2" id="_idParaDest-706">How it works...</h2>
<p class="normal">When you run the test module from a console/terminal, you see both the test log and test report, with the test report following the test log. For the test module shown earlier, the default output is as follows. The first three lines represent the test log, while the last line represents the test report:</p>
<pre class="programlisting con"><code class="hljs-con">Running 2 test cases...
f:/chapter11bt_05/main.cpp(14): error: in "test_suite/test_case": 
check a == 0 has failed [42 != 0]
*** 1 failure is detected in the test module "Controlling output"
</code></pre>
<p class="normal">The content of both the test log and test report can be made available in several formats. The default is HRF; however, the framework also supports XML, and for the test log, the JUNIT format. This is a format intended for automated tools, such as continuous <a id="_idIndexMarker1355"/>build or integration tools. Apart from these options, you can implement your own format for the test log by implementing your own class derived from <code class="inlineCode">boost::unit_test::unit_test_log_formatter</code>.</p>
<p class="normal">The following example shows how to format the test log (the first example) and the test report (the second example) using XML (each highlighted in bold):</p>
<pre class="programlisting con"><code class="hljs-con">chapter11bt_05.exe -f XML
<strong class="hljs-con-slc">&lt;TestLog&gt;&lt;Error file="f:/chapter11bt_05/main.cpp" </strong>
<strong class="hljs-con-slc">line="14"&gt;&lt;![CDATA[check a == 0 has failed [42 != 0]]]&gt;</strong>
<strong class="hljs-con-slc">&lt;/Error&gt;&lt;/TestLog&gt;</strong>
*** 1 failure is detected in the test module "Controlling output"
chapter11bt_05.exe -m XML
Running 2 test cases...
f:/chapter11bt_05/main.cpp(14): error: in "test_suite/test_case": 
check a == 0 has failed [42 != 0]
<strong class="hljs-con-slc">&lt;TestResult&gt;&lt;TestSuite name="Controlling output" result="failed" </strong>
<strong class="hljs-con-slc">assertions_passed="1" assertions_failed="1" warnings_failed="0" </strong>
<strong class="hljs-con-slc">expected_failures="0" test_cases_passed="1" </strong>
<strong class="hljs-con-slc">test_cases_passed_with_warnings="0" test_cases_failed="1" </strong>
<strong class="hljs-con-slc">test_cases_skipped="0" test_cases_aborted="0"&gt;&lt;/TestSuite&gt;</strong>
&lt;/TestResult&gt;
</code></pre>
<p class="normal">The log or report level represents the verbosity of the output. The possible values of the verbosity level of a log are shown in the following table, ordered from the lowest to the highest level. A higher level in the table includes all the messages of the levels above it:</p>
<table class="table-container" id="table002-6">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Level</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Messages that are reported</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">nothing</code></p>
</td>
<td class="table-cell">
<p class="normal">Nothing is logged.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">fatal_error</code></p>
</td>
<td class="table-cell">
<p class="normal">System or user fatal errors and all the messages describing failed assertions at the <code class="inlineCode">REQUIRE</code> level (such as <code class="inlineCode">BOOST_TEST_REQUIRE</code> and <code class="inlineCode">BOOST_REQUIRE_</code>).</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">system_error</code></p>
</td>
<td class="table-cell">
<p class="normal">System non-fatal errors.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">cpp_exception</code></p>
</td>
<td class="table-cell">
<p class="normal">Uncaught C++ exceptions.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">error</code></p>
</td>
<td class="table-cell">
<p class="normal">Failed assertion at the <code class="inlineCode">CHECK</code> level (<code class="inlineCode">BOOST_TEST</code> and <code class="inlineCode">BOOST_CHECK_</code>).</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">warning</code></p>
</td>
<td class="table-cell">
<p class="normal">Failed assertion at the <code class="inlineCode">WARN</code> level (<code class="inlineCode">BOOST_TEST_WARN</code> and <code class="inlineCode">BOOST_WARN_</code>).</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">message</code></p>
</td>
<td class="table-cell">
<p class="normal">Messages generated by <code class="inlineCode">BOOST_TEST_MESSAGE</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">test_suite</code></p>
</td>
<td class="table-cell">
<p class="normal">Notification at the start and finish states of each test unit.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">all</code> / <code class="inlineCode">success</code></p>
</td>
<td class="table-cell">
<p class="normal">All the messages, including passed assertions.</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 11.2: Possible values for the verbosity level of logs</p>
<p class="normal">The available <a id="_idIndexMarker1356"/>formats of the test report are described in the following table:</p>
<table class="table-container" id="table003-6">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Level</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Description</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">no</code></p>
</td>
<td class="table-cell">
<p class="normal">No report is produced.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">confirm</code></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Passing test</strong>:</p>
<p class="normal">*** No errors detected.</p>
<p class="normal"><strong class="keyWord">Skipped test</strong>:</p>
<p class="normal">*** The &lt;name&gt; test suite was skipped; see the standard output for details.</p>
<p class="normal"><strong class="keyWord">Aborted test</strong>:</p>
<p class="normal">*** The &lt;name&gt; test suite was aborted; see the standard output for details.</p>
<p class="normal"><strong class="keyWord">Failed test without failed assertions</strong>:</p>
<p class="normal">*** Errors were detected in the &lt;name&gt; test suite; see the standard output for details.</p>
<p class="normal"><strong class="keyWord">Failed test</strong>:</p>
<p class="normal">*** N failures are detected in the &lt;name&gt; test suite.</p>
<p class="normal"><strong class="keyWord">Failed test with some failures expected</strong>:</p>
<p class="normal">*** N failures are detected (M failures are expected) in the &lt;name&gt; test suite.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">detailed</code></p>
</td>
<td class="table-cell">
<p class="normal">Results are reported in a hierarchical fashion (each test unit is reported as part of the parent test unit), but only relevant information appears. Test cases that do not have failing assertions do not produce entries in the report.</p>
<p class="normal">The test case/suite &lt;name&gt; has passed/was skipped/was aborted/has failed with:</p>
<p class="normal">N assertions out of M passed</p>
<p class="normal">N assertions out of M failed</p>
<p class="normal">N warnings out of M failed</p>
<p class="normal">X failures expected</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">short</code></p>
</td>
<td class="table-cell">
<p class="normal">Similar to <code class="inlineCode">detailed</code>, but this reports information only to the master test suite.</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 11.3: Available formats for a test report</p>
<p class="normal">The standard <a id="_idIndexMarker1357"/>output stream (<code class="inlineCode">stdout</code>) is the default location where the test log is written, and the standard error stream (<code class="inlineCode">stderr</code>) is the default location of the test report. However, both the test log and test report can be redirected to another stream or file.</p>
<p class="normal">In addition to these options, it is possible to specify a separate file for reporting memory leaks using the <code class="inlineCode">--report_memory_leaks_to=&lt;file name&gt;</code> command-line option. If this option is not present and memory leaks are detected, they are reported to the standard error stream.</p>
<h2 class="heading-2" id="_idParaDest-707">There’s more...</h2>
<p class="normal">In addition to the options discussed in this recipe, the framework provides additional compile-time APIs for controlling the output. For a comprehensive description of these APIs, as well as the features described in this recipe, check the framework documentation at <a href="https://www.boost.org/doc/libs/1_83_0/libs/test/doc/html/index.html">https://www.boost.org/doc/libs/1_83_0/libs/test/doc/html/index.html</a>.</p>
<h2 class="heading-2" id="_idParaDest-708">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Writing and invoking tests with Boost.Test</em>, to see how to create test suites and test cases using the single-header version of the Boost.Test library, as well as how to run tests</li>
<li class="bulletList"><em class="italic">Asserting with Boost.Test</em>, to explore the rich set of assertion macros from the Boost.Test library</li>
</ul>
<h1 class="heading-1" id="_idParaDest-709">Getting started with Google Test</h1>
<p class="normal"><strong class="keyWord">Google Test</strong> is <a id="_idIndexMarker1358"/>one of the most widely used testing frameworks for C++. The <strong class="keyWord">Chromium</strong> projects and the <strong class="keyWord">LLVM</strong> compiler <a id="_idIndexMarker1359"/>are among the projects <a id="_idIndexMarker1360"/>that are using it for unit testing. Google Test enables developers to write unit tests on multiple platforms using multiple compilers. Google Test is a portable, lightweight framework that has a simple yet comprehensive API for writing tests using asserts; here, tests are grouped into test suites and test suites into test programs.</p>
<p class="normal">The framework provides useful features, such as repeating a test a number of times and breaking a test to invoke the debugger at the first failure. Its assertions work regardless of whether exceptions are enabled or not. The next recipe will cover the most important features of the framework. This recipe will show you how to install the framework and set up your first testing project.</p>
<h2 class="heading-2" id="_idParaDest-710">Getting ready</h2>
<p class="normal">The Google Test framework, just like Boost.Test, has a macro-based API. Although you only need to use the supplied macros for writing tests, a good understanding of macros is recommended in order to use the framework well.</p>
<h2 class="heading-2" id="_idParaDest-711">How to do it...</h2>
<p class="normal">In order to <a id="_idIndexMarker1361"/>set up your environment to use Google Test, do the following:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Clone or download the Git repository from <a href="https://github.com/google/googletest">https://github.com/google/googletest</a>.</li>
<li class="numberedList">If you selected to download it, once you’ve done so, unzip the content of the archive.</li>
<li class="numberedList">Build the framework using the provided build scripts.</li>
</ol>
<p class="normal">To create your first test program using Google Test, do the following:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Create a new empty C++ project.</li>
<li class="numberedList">Do the necessary setup specific to the development environment you are using to make the framework’s headers folder (called <code class="inlineCode">include</code>) available to the project for including header files.</li>
<li class="numberedList">Link the project to the <code class="inlineCode">gtest</code> shared library.</li>
<li class="numberedList">Add a new source file to the project with the following content:
        <pre class="programlisting code"><code class="hljs-code">#include &lt;gtest/gtest.h&gt;
TEST(FirstTestSuite, FirstTest)
{
  int a = 42;
  ASSERT_TRUE(a &gt; 0);
}
int main(int argc, char **argv) 
{
  testing::InitGoogleTest(&amp;argc, argv);
  return RUN_ALL_TESTS();
}
</code></pre>
</li>
<li class="numberedList">Build and run the project.</li>
</ol>
<h2 class="heading-2" id="_idParaDest-712">How it works...</h2>
<p class="normal">The Google Test framework <a id="_idIndexMarker1362"/>provides a simple and easy-to-use set of macros for creating tests and writing assertions. The structure of the test is also simplified compared to other testing frameworks, such as Boost.Test. Tests are grouped into test suites and test suites into test programs.</p>
<div><p class="normal">It is important to mention several aspects related to terminology. Traditionally, Google Test did not use the term <strong class="keyWord">test suite</strong>. A <strong class="keyWord">test case</strong> in Google Test was basically a test suite and equivalent to the test suites in Boost.Test. On the other hand, a <strong class="keyWord">test function</strong> was equivalent to a test case. Because this has led to confusion, Google Test has adhered to the common terminology, used by the <strong class="keyWord">International Software Testing Qualifications Board</strong> (<strong class="keyWord">ISTQB</strong>), of test cases and test suites and has started to replace this throughout its code and documentation. In this book, we will use these terms.</p>
</div>
<p class="normal">The framework provides a rich set of assertions, both fatal and non-fatal, great support for exception handling, and the ability to customize the way tests are executed and how the output should be generated. However, unlike with the Boost.Test library, the test suites in Google Test cannot contain other test suites, but only test functions.</p>
<p class="normal">Documentation for the framework is available on the project’s page at GitHub. For this edition of this book, I used Google Test framework version 1.14, but the code presented here works with previous versions of the framework and is expected to also work with future versions of the framework. The sample code shown in the <em class="italic">How to do it…</em> section contains the<a id="_idIndexMarker1363"/> following parts:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><code class="inlineCode">#include &lt;gtest/gtest.h&gt;</code> includes the main header of the framework.</li>
<li class="numberedList"><code class="inlineCode">TEST(FirstTestSuite, FirstTest)</code> declares a test called <code class="inlineCode">FirstTest</code> as part of a test suite called <code class="inlineCode">FirstTestSuite</code>. These names must be valid C++ identifiers but are not allowed to contain underscores. The actual name of a test function is composed through concatenation with an underscore from the name of the test suite and the test name. For our example, the name is <code class="inlineCode">FirstTestSuite_FirstTest</code>. Tests from different test suites may have the same individual name. A test function has no arguments and returns <code class="inlineCode">void</code>. Multiple tests can be grouped with the same test suite.</li>
<li class="numberedList"><code class="inlineCode">ASSERT_TRUE(a &gt; 0);</code> is an assertion macro that yields a fatal error and returns from the current function in case the condition evaluates to <code class="inlineCode">false</code>. The framework defines many more assertion macros, which we will see in the <em class="italic">Asserting with Google Test</em> recipe.</li>
<li class="numberedList"><code class="inlineCode">testing::InitGoogleTest(&amp;argc, argv);</code> initializes the framework and must be called before <code class="inlineCode">RUN_ALL_TESTS()</code>.</li>
<li class="numberedList"><code class="inlineCode">return RUN_ALL_TESTS();</code> automatically detects and calls all the tests defined with either the <code class="inlineCode">TEST()</code> or <code class="inlineCode">TEST_F()</code> macro. The return value returned from the macro is used as the return value of the <code class="inlineCode">main()</code> function. This is important because the automated testing service determines the result of a test program according to the value returned from the <code class="inlineCode">main()</code> function, not the output printed to the <code class="inlineCode">stdout</code> or <code class="inlineCode">stderr</code> streams. The <code class="inlineCode">RUN_ALL_TESTS()</code> macro must be called only once; calling it multiple times is not supported because it conflicts with some advanced features of the framework.</li>
</ol>
<p class="normal">Executing this test program will provide the following result:</p>
<pre class="programlisting con"><code class="hljs-con">[==========] Running 1 test from 1 test suite.
[----------] Global test environment set-up.
[----------] 1 test from FirstTestCase
[ RUN      ] FirstTestCase.FirstTestFunction
[       OK ] FirstTestCase.FirstTestFunction (1 ms)
[----------] 1 test from FirstTestCase (1 ms total)
[----------] Global test environment tear-down
[==========] 1 test from 1 test suite ran. (2 ms total)
[  PASSED  ] 1 test.
</code></pre>
<p class="normal">For many test programs, the content of the <code class="inlineCode">main()</code> function is identical to the one shown in <a id="_idIndexMarker1364"/>this recipe, in the example from the <em class="italic">How to do it...</em> section. To avoid writing such a <code class="inlineCode">main()</code> function, the framework provides a basic implementation that you can use by linking your program with the <code class="inlineCode">gtest_main</code> shared library.</p>
<h2 class="heading-2" id="_idParaDest-713">There’s more...</h2>
<p class="normal">The Google Test framework can also be used with other testing frameworks. You can write tests using another testing framework, such as Boost.Test or CppUnit, and use the Google Test assertion macros. To do so, set the <code class="inlineCode">throw_on_failure</code> flag, either from the code or command line, with the <code class="inlineCode">--gtest_throw_on_failure</code> argument. Alternatively, use the <code class="inlineCode">GTEST_THROW_ON_FAILURE</code> environment variable and initialize the framework, as shown in the following code snippet:</p>
<pre class="programlisting code"><code class="hljs-code">#include "gtest/gtest.h"
int main(int argc, char** argv)
{
  testing::GTEST_FLAG(throw_on_failure) = true;
  testing::InitGoogleTest(&amp;argc, argv);
}
</code></pre>
<p class="normal">When you enable the <code class="inlineCode">throw_on_failure</code> option, assertions that fail will print an error message and throw an exception, which will be caught by the host testing framework and treated as a failure. If exceptions are not enabled, then a failed Google Test assertion will tell your program to exit with a non-zero code, which again will be treated as a failure by the host testing framework.</p>
<h2 class="heading-2" id="_idParaDest-714">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Writing and invoking tests with Google Test</em>, to see how to create tests and test suites using the Google Test library, as well as how to run tests</li>
<li class="bulletList"><em class="italic">Asserting with Google Test</em>, to explore the various assertion macros from the Google Test library</li>
</ul>
<h1 class="heading-1" id="_idParaDest-715">Writing and invoking tests with Google Test</h1>
<p class="normal">In the previous recipe, we had a glimpse of what it takes to write simple tests with the Google Test framework. Multiple tests can be grouped into a test suite and one or more test suites grouped into <a id="_idIndexMarker1365"/>a test program. In this recipe, we will see how to create and run tests.</p>
<h2 class="heading-2" id="_idParaDest-716">Getting ready</h2>
<p class="normal">For the sample code in this recipe, we’ll use the <code class="inlineCode">point3d</code> class we discussed in the <em class="italic">Writing and invoking tests with Boost.Test</em> recipe.</p>
<h2 class="heading-2" id="_idParaDest-717">How to do it...</h2>
<p class="normal">Use the <a id="_idIndexMarker1366"/>following macros to create tests:</p>
<ul>
<li class="bulletList"><code class="inlineCode">TEST(TestSuiteName, TestName)</code> defines a test called <code class="inlineCode">TestName</code> as part of a test suite called <code class="inlineCode">TestSuiteName</code>:
        <pre class="programlisting code"><code class="hljs-code">TEST(TestConstruction, TestConstructor)
{
  auto p = point3d{ 1,2,3 };
  ASSERT_EQ(p.x(), 1);
  ASSERT_EQ(p.x(), 2);
  ASSERT_EQ(p.x(), 3);
}
TEST(TestConstruction, TestOrigin)
{
  auto p = point3d::origin();
  ASSERT_EQ(p.x(), 0);
  ASSERT_EQ(p.x(), 0);
  ASSERT_EQ(p.x(), 0);
}
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">TEST_F(TestSuiteWithFixture, TestName)</code> defines a test called <code class="inlineCode">TestName</code> as part of a test suite, using a fixture called <code class="inlineCode">TestSuiteWithFixture</code>. You’ll find details about how this works in the <em class="italic">Using test fixtures with Google Test</em> recipe.</li>
</ul>
<p class="normal">To execute the tests, do the following:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Use the <code class="inlineCode">RUN_ALL_TESTS()</code> macro to run all the tests defined in the test program. This must be called only once from the <code class="inlineCode">main()</code> function after the framework has been initialized.</li>
<li class="numberedList">Use the <code class="inlineCode">--gtest_filter=&lt;filter&gt;</code> command-line option to filter the tests to run.</li>
<li class="numberedList">Use the <code class="inlineCode">--gtest_repeat=&lt;count&gt;</code> command-line option to repeat the selected tests the specified number of times.</li>
<li class="numberedList">Use the <code class="inlineCode">--gtest_break_on_failure</code> command-line option to attach the debugger to debug the test program when the first test fails.</li>
</ol>
<h2 class="heading-2" id="_idParaDest-718">How it works...</h2>
<p class="normal">There are <a id="_idIndexMarker1367"/>several macros available for defining tests (as part of a test case). The <a id="_idIndexMarker1368"/>most common ones are <code class="inlineCode">TEST</code> and <code class="inlineCode">TEST_F</code>. The latter is used with fixtures, which will be discussed in detail in the <em class="italic">Using test fixtures with Google Test</em> recipe. Other macros for defining tests are <code class="inlineCode">TYPED_TEST</code> for writing typed tests and <code class="inlineCode">TYPED_TEST_P</code> for writing type-parameterized tests. However, these are more advanced topics and are beyond the scope of this book. The <code class="inlineCode">TEST</code> and <code class="inlineCode">TEST_F</code> macros take two arguments: the first is the name of the test suite and the second is the name of the test. These two arguments form the full name of a test, and they must be valid C++ identifiers; they should not contain underscores, though. Different test suites can contain tests with the same name (because the full name is still unique). Both macros automatically register the tests with the framework; therefore, no explicit input is required from the user to do this.</p>
<p class="normal">A test can either fail or succeed. A test fails if an assertion fails or an uncaught exception occurs. Except for these two instances, the test always succeeds.</p>
<p class="normal">To invoke the test, call <code class="inlineCode">RUN_ALL_TESTS()</code>. However, you can do this only once in a test program and only after the framework has been initialized with a call to <code class="inlineCode">testing::InitGoogleTest()</code>. This macro runs all the tests in the test program. However, it is possible that you select only some tests to run. You can do this either by setting up an environment variable called <code class="inlineCode">GTEST_FILTER</code> with the appropriate filter or by passing the filter as a command-line argument with the <code class="inlineCode">--gtest_filter</code> flag. If either of these two are present, the framework only runs the tests whose full name matches the filter. The filter may include wildcards: <code class="inlineCode">*</code> to match any string and the <code class="inlineCode">?</code> symbol to match any character. Negative patterns (what should be omitted) are introduced with a hyphen (<code class="inlineCode">-</code>). The following are examples of filters:</p>
<table class="table-container" id="table004-5">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Filter</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Description</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">--gtest_filter=*</code></p>
</td>
<td class="table-cell">
<p class="normal">Run all the tests</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">--gtest_filter=TestConstruction.*</code></p>
</td>
<td class="table-cell">
<p class="normal">Run all the tests from the test suite called <code class="inlineCode">TestConstruction</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">--gtest_filter=TestOperations.*-TestOperations.TestLess</code></p>
</td>
<td class="table-cell">
<p class="normal">Run all the tests from the test suite called <code class="inlineCode">TestOperations</code>, except for a test called <code class="inlineCode">TestLess</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">--gtest_filter=*Operations*:*Construction*</code></p>
</td>
<td class="table-cell">
<p class="normal">Run all the tests whose full names contain either <code class="inlineCode">Operations</code> or <code class="inlineCode">Construction</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">--gtest_filter=Test?</code></p>
</td>
<td class="table-cell">
<p class="normal">Run all tests whose names have 5 characters and start with <code class="inlineCode">Test</code>, such as <code class="inlineCode">TestA</code>, <code class="inlineCode">Test0</code>, or <code class="inlineCode">Test_</code>.</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">--gtest_filter=Test??</code></p>
</td>
<td class="table-cell">
<p class="normal">Run all tests whose names have 6 characters and start with <code class="inlineCode">Test</code>, such as <code class="inlineCode">TestAB</code>, <code class="inlineCode">Test00</code>, or <code class="inlineCode">Test_Z</code>.</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 11.4: Examples of filters</p>
<p class="normal">The <a id="_idIndexMarker1369"/>following listing is the output of a test program containing the<a id="_idIndexMarker1370"/> tests shown earlier when invoked with the command-line argument <code class="inlineCode">--gtest_filter=TestConstruction.*-TestConstruction.TestConstructor</code>:</p>
<pre class="programlisting con"><code class="hljs-con">Note: Google Test filter = TestConstruction.*-TestConstruction.TestConstructor
[==========] Running 1 test from 1 test suite.
[----------] Global test environment set-up.
[----------] 1 test from TestConstruction
[ RUN      ] TestConstruction.TestOrigin
[       OK ] TestConstruction.TestOrigin (0 ms)
[----------] 1 test from TestConstruction (0 ms total)
[----------] Global test environment tear-down
[==========] 1 test from 1 test suite ran. (2 ms total)
[  PASSED  ] 1 test.
</code></pre>
<p class="normal">It is possible for you to disable some of the tests by prefixing either the name of a test with <code class="inlineCode">DISABLED_</code> or the name of a test suite with the same identifier, in which case all the tests in the test suite will be disabled. This is exemplified here:</p>
<pre class="programlisting code"><code class="hljs-code">TEST(TestConstruction, DISABLED_TestConversionConstructor) 
{ /* ... */ }
TEST(DISABLED_TestComparisons, TestEquality) 
{ /* ... */ }
TEST(DISABLED_TestComparisons, TestInequality)
{ /* ... */ }
</code></pre>
<p class="normal">None of these<a id="_idIndexMarker1371"/> tests will be executed. However, you will receive a report in the output stating that you have a number of disabled tests.</p>
<p class="normal">Keep in mind<a id="_idIndexMarker1372"/> that this feature is only meant for temporarily disabling tests. This is useful when you need to perform some code changes that make tests fail and you don’t have time to fix them right away. Therefore, this feature should be used judiciously.</p>
<h2 class="heading-2" id="_idParaDest-719">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Getting started with Google Test</em>, to learn how to install the Google Test framework and how to create a simple test project</li>
<li class="bulletList"><em class="italic">Asserting with Google Test</em>, to explore the various assertion macros from the Google Test library</li>
<li class="bulletList"><em class="italic">Using test fixtures with Google Test</em>, to learn how to define test fixtures when using the Google Test library</li>
</ul>
<h1 class="heading-1" id="_idParaDest-720">Asserting with Google Test</h1>
<p class="normal">The <a id="_idIndexMarker1373"/>Google Test framework provides a rich set of both fatal and non-fatal assertion macros, which resemble function calls, to verify the tested code. When these assertions fail, the framework displays the source file, line number, and relevant error message (including custom error messages) to help developers quickly identify the failed code. We have already seen some simple examples of how to use the <code class="inlineCode">ASSERT_TRUE</code> macro; in this recipe, we will look at other available macros.</p>
<h2 class="heading-2" id="_idParaDest-721">How to do it...</h2>
<p class="normal">Use the following macros to verify the tested code:</p>
<ul>
<li class="bulletList">Use <code class="inlineCode">ASSERT_TRUE(condition)</code> or <code class="inlineCode">EXPECT_TRUE(condition)</code> to check whether the condition is <code class="inlineCode">true</code>, and <code class="inlineCode">ASSERT_FALSE(condition)</code> or <code class="inlineCode">EXPECT_FALSE(condition)</code> to check whether the condition is <code class="inlineCode">false</code>, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">EXPECT_TRUE(2 + 2 == 2 * 2);
EXPECT_FALSE(1 == 2);
ASSERT_TRUE(2 + 2 == 2 * 2);
ASSERT_FALSE(1 == 2);
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">ASSERT_XX(val1, val2)</code> or <code class="inlineCode">EXPECT_XX(val1, val2)</code> to compare two values, where <code class="inlineCode">XX</code> is one of the following: <code class="inlineCode">EQ(val1 == val2)</code>, <code class="inlineCode">NE(val1 != val2)</code>, <code class="inlineCode">LT(val1 &lt; val2)</code>, <code class="inlineCode">LE(val1 &lt;= val2)</code>, <code class="inlineCode">GT(val1 &gt; val2)</code>, or <code class="inlineCode">GE(val1 &gt;= val2)</code>. This is illustrated in the following code:
        <pre class="programlisting code"><code class="hljs-code">auto a = 42, b = 10;
EXPECT_EQ(a, 42);
EXPECT_NE(a, b);
EXPECT_LT(b, a);
EXPECT_LE(b, 11);
EXPECT_GT(a, b);
EXPECT_GE(b, 10);
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">ASSERT_STRXX(str1, str2)</code> or <code class="inlineCode">EXPECT_STRXX(str1, str2)</code> to compare two<a id="_idIndexMarker1374"/> null-terminated strings, where <code class="inlineCode">XX</code> is one of the following: <code class="inlineCode">EQ</code> (the strings have the same content), <code class="inlineCode">NE</code> (the strings don’t have the same content), <code class="inlineCode">CASEEQ</code> (the strings have the same content with the case ignored), and <code class="inlineCode">CASENE</code> (the strings don’t have the same content with the case ignored). This is illustrated in the following code snippet:
        <pre class="programlisting code"><code class="hljs-code">auto str = "sample";
EXPECT_STREQ(str, "sample");
EXPECT_STRNE(str, "simple");
ASSERT_STRCASEEQ(str, "SAMPLE");
ASSERT_STRCASENE(str, "SIMPLE");
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">ASSERT_FLOAT_EQ(val1, val2)</code> or <code class="inlineCode">EXPECT_FLOAT_EQ(val1, val2)</code> to check whether two <code class="inlineCode">float</code> values are almost equal, and <code class="inlineCode">ASSERT_DOUBLE_EQ(val1, val2)</code> or <code class="inlineCode">EXPECT_DOUBLE_EQ(val1, val2)</code> to check whether two <code class="inlineCode">double</code> values are almost equal; they should differ by at most 4 <strong class="keyWord">ULP</strong> (<strong class="keyWord">units in the last place</strong>). Use <code class="inlineCode">ASSERT_NEAR(val1, val2, abserr)</code> to check whether the difference between the two values is not greater than the specified absolute value:
        <pre class="programlisting code"><code class="hljs-code">EXPECT_FLOAT_EQ(1.9999999f, 1.9999998f);
ASSERT_FLOAT_EQ(1.9999999f, 1.9999998f);
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">ASSERT_THROW(statement, exception_type)</code> or <code class="inlineCode">EXPECT_THROW(statement, exception_type)</code> to check whether the statement <a id="_idIndexMarker1375"/>throws an exception of the specified type, <code class="inlineCode">ASSERT_ANY_THROW(statement)</code> or <code class="inlineCode">EXPECT_ANY_THROW(statement)</code> to check whether the statement throws an exception of any type, and <code class="inlineCode">ASSERT_NO_THROW(statement)</code> or <code class="inlineCode">EXPECT_NO_THROW(statement)</code> to check whether the statement throws any exception:
        <pre class="programlisting code"><code class="hljs-code">void function_that_throws()
{
  throw std::runtime_error("error");
}
void function_no_throw()
{
}
TEST(TestAssertions, Exceptions)
{
  EXPECT_THROW(function_that_throws(), std::runtime_error);
  EXPECT_ANY_THROW(function_that_throws());
  EXPECT_NO_THROW(function_no_throw());
  
  ASSERT_THROW(function_that_throws(), std::runtime_error);
  ASSERT_ANY_THROW(function_that_throws());
  ASSERT_NO_THROW(function_no_throw());
}
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">ASSERT_PRED1(pred, val)</code> or <code class="inlineCode">EXPECT_PRED1(pred, val)</code> to check whether <code class="inlineCode">pred(val)</code> returns <code class="inlineCode">true</code>, <code class="inlineCode">ASSERT_PRED2(pred, val1, val2)</code> or <code class="inlineCode">EXPECT_PRED2(pred, val1, val2)</code> to check whether <code class="inlineCode">pred(val1, val2)</code> returns <code class="inlineCode">true</code>, and so <a id="_idIndexMarker1376"/>on; use this for <em class="italic">n</em>-ary predicate functions or functors:
        <pre class="programlisting code"><code class="hljs-code">bool is_positive(int const val)
{
  return val != 0;
}
bool is_double(int const val1, int const val2)
{
  return val2 + val2 == val1;
}
TEST(TestAssertions, Predicates)
{
  EXPECT_PRED1(is_positive, 42);
  EXPECT_PRED2(is_double, 42, 21);
  
  ASSERT_PRED1(is_positive, 42);
  ASSERT_PRED2(is_double, 42, 21);
}
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">ASSERT_HRESULT_SUCCEEDED(expr)</code> or <code class="inlineCode">EXPECT_HRESULT_SUCCEEDED(expr)</code> to check whether <code class="inlineCode">expr</code> is a success <code class="inlineCode">HRESULT</code>, and <code class="inlineCode">ASSERT_HRESULT_FAILED(expr)</code> or <code class="inlineCode">EXPECT_HRESULT_FAILED(expr)</code> to check whether <code class="inlineCode">expr</code> is a failure <code class="inlineCode">HRESULT</code>. These assertions are intended to be used on Windows.</li>
<li class="bulletList">Use <code class="inlineCode">FAIL()</code> to generate a fatal failure and <code class="inlineCode">ADD_FAILURE()</code> or <code class="inlineCode">ADD_FAILURE_AT(filename, line)</code> to generate non-fatal failures:
        <pre class="programlisting code"><code class="hljs-code">ADD_FAILURE();
ADD_FAILURE_AT(__FILE__, __LINE__);
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-722">How it works...</h2>
<p class="normal">All these asserts are available in two versions:</p>
<ul>
<li class="bulletList"><code class="inlineCode">ASSERT_*</code>: This generates fatal failures, preventing further execution of the current test function.</li>
<li class="bulletList"><code class="inlineCode">EXPECT_*</code>: This generates non-fatal failures, which means that the execution of the test function continues, even if the assertion fails.</li>
</ul>
<p class="normal">Use the <code class="inlineCode">EXPECT_*</code> assertion if not meeting the condition is not a critical error or if you want the test function to continue, in order to get as many error messages as possible. In other cases, use the <code class="inlineCode">ASSERT_*</code> version of the test assertions.</p>
<p class="normal">You will find details about the assertions presented here in the framework’s online documentation, which is available on GitHub at <a href="https://github.com/google/googletest">https://github.com/google/googletest</a>; this is where the project is located. A special note on floating-point comparison is, however, necessary. Due to round-offs (fractional parts cannot be represented as a finite sum of the inverse powers of two), floating-point values do <a id="_idIndexMarker1377"/>not match exactly. Therefore, a comparison should be done within a relative error bound. The macros <code class="inlineCode">ASSERT_EQ</code>/<code class="inlineCode">EXPECT_EQ</code> are not suitable for comparing floating points, and the framework provides another set of assertions. <code class="inlineCode">ASSERT_FLOAT_EQ</code>/<code class="inlineCode">ASSERT_DOUBLE_EQ</code> and <code class="inlineCode">EXPECT_FLOAT_EQ</code>/<code class="inlineCode">EXPECT_DOUBLE_EQ</code> perform a comparison with a default error of 4 ULP.</p>
<div><p class="normal">ULP is a unit of measurement for the spacing between floating-point numbers, that is, the value the least significant digit represents if it is 1. For more information on this, read the <em class="italic">Comparing Floating Point Numbers, 2012 Edition</em> article by Bruce Dawson: <a href="https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/">https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/</a>.</p>
</div>
<h2 class="heading-2" id="_idParaDest-723">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Writing and invoking tests with Google Test</em>, to see how to create tests and test suites using the Google Test library, as well as how to run tests</li>
</ul>
<h1 class="heading-1" id="_idParaDest-724">Using test fixtures with Google Test</h1>
<p class="normal">The<a id="_idIndexMarker1378"/> framework provides support for using fixtures as reusable components for all the tests that are part of a test suite. It also provides support for setting up the global environment in which the tests will run. In this recipe, you will find stepwise instructions on how to define and use test fixtures, as well as to set up the test environment.</p>
<h2 class="heading-2" id="_idParaDest-725">Getting ready</h2>
<p class="normal">You should now be familiar with writing and invoking tests using the Google Test framework, a topic that was covered earlier in this chapter, specifically in the <em class="italic">Writing and invoking tests with Google Test</em> recipe.</p>
<h2 class="heading-2" id="_idParaDest-726">How to do it...</h2>
<p class="normal">To create and use a test fixture, do the following:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Create a class derived from the <code class="inlineCode">testing::Test</code> class:
        <pre class="programlisting code"><code class="hljs-code">class TestFixture : public testing::Test
{
};
</code></pre>
</li>
<li class="numberedList">Use the <a id="_idIndexMarker1379"/>constructor to initialize the fixture and the destructor to clean it up:
        <pre class="programlisting code"><code class="hljs-code">protected:
  TestFixture()
  {
    std::cout &lt;&lt; "constructing fixture\n";
    data.resize(10);
    std::iota(std::begin(data), std::end(data), 1);
  }
  ~TestFixture()
  {
    std::cout &lt;&lt; "destroying fixture\n";
  }
</code></pre>
</li>
<li class="numberedList">Alternatively, you can override the virtual methods <code class="inlineCode">SetUp()</code> and <code class="inlineCode">TearDown()</code> for the same purpose.</li>
<li class="numberedList">Add member data and functions to the class to make them available to the tests:
        <pre class="programlisting code"><code class="hljs-code">protected:
  std::vector&lt;int&gt; data;
</code></pre>
</li>
<li class="numberedList">Use the <code class="inlineCode">TEST_F</code> macro to define tests using fixtures, and specify the fixture class name as the test suite name:
        <pre class="programlisting code"><code class="hljs-code">TEST_F(TestFixture, TestData)
{
  ASSERT_EQ(data.size(), 10);
  ASSERT_EQ(data[0], 1);
  ASSERT_EQ(data[data.size()-1], data.size());
}
</code></pre>
</li>
</ol>
<p class="normal">To customize<a id="_idIndexMarker1380"/> the setup of the environment for running tests, do the following:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Create a class derived from <code class="inlineCode">testing::Environment</code>:
        <pre class="programlisting code"><code class="hljs-code">class TestEnvironment : public testing::Environment
{
};
</code></pre>
</li>
<li class="numberedList">Override the virtual methods <code class="inlineCode">SetUp()</code> and <code class="inlineCode">TearDown()</code> to perform setup and cleanup operations:
        <pre class="programlisting code"><code class="hljs-code">public:
  virtual void SetUp() override 
 {
    std::cout &lt;&lt; "environment setup\n";
  }
  virtual void TearDown() override 
 {
    std::cout &lt;&lt; "environment cleanup\n";
  }
  int n{ 42 };
</code></pre>
</li>
<li class="numberedList">Register the environment with a call to <code class="inlineCode">testing::AddGlobalTestEnvironment()</code> before calling <code class="inlineCode">RUN_ALL_TESTS()</code>:
        <pre class="programlisting code"><code class="hljs-code">int main(int argc, char **argv)
{
  testing::InitGoogleTest(&amp;argc, argv);
  testing::AddGlobalTestEnvironment(new TestEnvironment{});
  return RUN_ALL_TESTS();
} 
</code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-727">How it works...</h2>
<p class="normal">Text fixtures enable users to share data configurations between multiple tests. Fixture objects are not shared between tests. A different fixture object is created for each test that is associated with the text function. The following operations are performed by the framework for each test coming from a fixture:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Create a new fixture object.</li>
<li class="numberedList">Call its <code class="inlineCode">SetUp()</code> virtual method.</li>
<li class="numberedList">Run the test.</li>
<li class="numberedList">Call the fixture’s <code class="inlineCode">TearDown()</code> virtual method.</li>
<li class="numberedList">Destroy the fixture object.</li>
</ol>
<p class="normal">You can set <a id="_idIndexMarker1381"/>up and clean the fixture objects in two ways: by using the constructor and destructor, or by using the <code class="inlineCode">SetUp()</code> and <code class="inlineCode">TearDown()</code> virtual methods. In most cases, the former way is preferred. The use of virtual methods is suitable in several cases, though:</p>
<ul>
<li class="bulletList">When the teardown operation throws an exception, as exceptions are not allowed to leave destructors.</li>
<li class="bulletList">If you are required to use assertion macros during cleanup and you use the <code class="inlineCode">--gtest_throw_on_failure</code> flag, which determines the macros to be thrown upon a failure occurring.</li>
<li class="bulletList">If you need to call virtual methods (which might be overridden in a derived class), as virtual calls should not be invoked from the constructor or destructor.</li>
</ul>
<p class="normal">Tests that use fixtures must be defined using the <code class="inlineCode">TEST_F</code> macro (where <code class="inlineCode">_F</code> stands for fixture). Trying to declare them using the <code class="inlineCode">TEST</code> macro will generate compiler errors.</p>
<p class="normal">The environments in which tests are run can also be customized. The mechanism is similar to test fixtures: you derive from the base <code class="inlineCode">testing::Environment</code> class and override the <code class="inlineCode">SetUp()</code> and <code class="inlineCode">TearDown()</code> virtual functions. Instances of these derived environment classes must be registered with the framework with a call to <code class="inlineCode">testing::AddGlobalTestEnvironment()</code>; however, this has to be done before you run the tests. You can register as many instances as you want, in which case the <code class="inlineCode">SetUp()</code> method is called for the objects in the order they were registered and the <code class="inlineCode">TearDown()</code> method is called in reverse order. You must pass dynamically instantiated objects to this function. The framework takes ownership of the objects and deletes them before the program terminates; therefore, do not delete them yourself.</p>
<p class="normal">Environment objects are not available to the tests, nor intended to provide data to the tests. Their purpose is to customize the global environment for running the tests.</p>
<h2 class="heading-2" id="_idParaDest-728">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Writing and invoking tests with Google Test</em>, to see how to create tests and test suites using the Google Test library, as well as how to run tests</li>
</ul>
<h1 class="heading-1" id="_idParaDest-729">Controlling output with Google Test</h1>
<p class="normal">By default, the <a id="_idIndexMarker1382"/>output of a Google Test program goes to the standard stream, printed in a human-readable format. The framework provides several options for customizing the output, including printing XML to a disk file in a JUNIT-based format. This recipe will explore the options available to control the output.</p>
<h2 class="heading-2" id="_idParaDest-730">Getting ready</h2>
<p class="normal">For the purpose of this recipe, let’s consider the following test program:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;gtest/gtest.h&gt;
TEST(Sample, Test)
{
  auto a = 42;
  ASSERT_EQ(a, 0);
}
int main(int argc, char **argv)
{
  testing::InitGoogleTest(&amp;argc, argv);
  return RUN_ALL_TESTS();
}
</code></pre>
<p class="normal">Its output is as follows:</p>
<pre class="programlisting con"><code class="hljs-con">[==========] Running 1 test from 1 test suite.
[----------] Global test environment set-up.
[----------] 1 test from Sample
[ RUN      ] Sample.Test
f:\chapter11gt_05\main.cpp(6): error: Expected equality of these values:
  a
    Which is: 42
  0
[  FAILED  ] Sample.Test (1 ms)
[----------] 1 test from Sample (1 ms total)
[----------] Global test environment tear-down
[==========] 1 test from 1 test suite ran. (3 ms total)
[  PASSED  ] 0 tests.
[  FAILED  ] 1 test, listed below:
[  FAILED  ] Sample.Test
 1 FAILED TEST
</code></pre>
<p class="normal">We will use this simple testing program to demonstrate the various options we can use to control the program’s output, which are exemplified in the following section.</p>
<h2 class="heading-2" id="_idParaDest-731">How to do it...</h2>
<p class="normal">To control the <a id="_idIndexMarker1383"/>output of a test program, you can:</p>
<ul>
<li class="bulletList">Use the <code class="inlineCode">--gtest_output</code> command-line option or the <code class="inlineCode">GTEST_OUTPUT</code> environment variable with the <code class="inlineCode">xml:filepath</code> string to specify the location of a file where the XML report is to be written:
        <pre class="programlisting con"><code class="hljs-con">chapter11gt_05.exe --gtest_output=xml:report.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;testsuites tests="1" failures="1" disabled="0" errors="0" 
            time="0.007" timestamp="2020-05-18T19:00:17" 
            name="AllTests"&gt;
  &lt;testsuite name="Sample" tests="1" failures="1" disabled="0" 
             errors="0" time="0.002"
             timestamp="2020-05-18T19:00:17"&gt;
    &lt;testcase name="Test" status="run" result="completed" time="0"
              timestamp="2020-05-18T19:00:17" classname="Sample"&gt;
      &lt;failure message="f:\chapter11gt_05\main.cpp:6&amp;#x0A;Expected equality of these values:&amp;#x0A;  a&amp;#x0A;    Which is: 42&amp;#x0A;  0&amp;#x0A;" type=""&gt;&lt;![CDATA[f:\chapter11gt_05\main.cpp:6
Expected equality of these values:
  a
    Which is: 42
  0
]]&gt;&lt;/failure&gt; 
    &lt;/testcase&gt;
  &lt;/testsuite&gt;
&lt;/testsuites&gt;
</code></pre>
</li>
<li class="bulletList">Use the <code class="inlineCode">--gtest_color</code> command-line option or the <code class="inlineCode">GTEST_COLOR</code> environment variable and specify either <code class="inlineCode">auto</code>, <code class="inlineCode">yes</code>, or <code class="inlineCode">no</code> to indicate whether the report should be printed to a terminal using colors or not:
        <pre class="programlisting con"><code class="hljs-con">chapter11gt_05.exe --gtest_color=no
</code></pre>
</li>
<li class="bulletList">Use the <code class="inlineCode">--gtest_print_time</code> command-line option or the <code class="inlineCode">GTEST_PRINT_TIME</code> environment variable with the value <code class="inlineCode">0</code> to suppress the printing <a id="_idIndexMarker1384"/>time each test takes to execute:
        <pre class="programlisting con"><code class="hljs-con">chapter11gt_05.exe --gtest_print_time=0
[==========] Running 1 test from 1 test suite.
[----------] Global test environment set-up.
[----------] 1 test from Sample
[ RUN      ] Sample.Test
f:\chapter11gt_05\main.cpp(6): error: Expected equality of these values:
  a
    Which is: 42
  0
[  FAILED  ] Sample.Test
[----------] Global test environment tear-down
[==========] 1 test from 1 test suite ran.
[  PASSED  ] 0 tests.
[  FAILED  ] 1 test, listed below:
[  FAILED  ] Sample.Test
 1 FAILED TEST
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-732">How it works...</h2>
<p class="normal">Generating a report in an XML format does not affect the human-readable report printed to the terminal. The output path can indicate either a file, a directory (in which case a file with the name of the executable is created – if it already exists from a previous run, it creates a file with a new name by suffixing it with a number), or nothing, in which case the report is written to a file called <code class="inlineCode">test_detail.xml</code> in the current directory.</p>
<p class="normal">The XML <a id="_idIndexMarker1385"/>report format is based on the JUNITReport Ant task and contains the following main elements:</p>
<ul>
<li class="bulletList"><code class="inlineCode">&lt;testsuites&gt;</code>: This is the root element and it corresponds to the entire test program.</li>
<li class="bulletList"><code class="inlineCode">&lt;testsuite&gt;</code>: This corresponds to a test suite.</li>
<li class="bulletList"><code class="inlineCode">&lt;testcase&gt;</code>: This corresponds to a test function, as Google Test functions are equivalent to test cases in other frameworks.</li>
</ul>
<p class="normal">By default, the framework reports the time it takes for each test to execute. This feature can be suppressed using the <code class="inlineCode">--gtest_print_time</code> command-line option or the <code class="inlineCode">GTEST_PRINT_TIME</code> environment variable, as shown earlier.</p>
<h2 class="heading-2" id="_idParaDest-733">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Writing and invoking tests with Google Test</em>, to see how to create tests and test suites using the Google Test library, as well as how to run tests</li>
<li class="bulletList"><em class="italic">Using test fixtures with Google Test</em>, to learn how to define test fixtures when using the Google Test library</li>
</ul>
<h1 class="heading-1" id="_idParaDest-734">Getting started with Catch2</h1>
<p class="normal"><strong class="keyWord">Catch2</strong> is a<a id="_idIndexMarker1386"/> multiparadigm testing framework for C++ and Objective-C. The name Catch2 follows on from Catch, the first version of the framework, which stands for <strong class="keyWord">C++ Automated Test Cases in Headers</strong>. It enables developers to write tests using either the traditional style <a id="_idIndexMarker1387"/>of test functions grouped in test cases or the <strong class="keyWord">behavior-driven development</strong><em class="italic"> </em>(<strong class="keyWord">BDD</strong>) style with <em class="italic">given-when-then</em> sections. Tests are self-registered and the framework provides several assertion macros; out of these, two are used the most: one fatal (namely, <code class="inlineCode">REQUIRE</code>) and one non-fatal (namely, <code class="inlineCode">CHECK</code>). They perform expression decomposition of both the left-hand and right-hand side values, which are logged in case of failure. Unlike its first version, Catch2 no<a id="_idIndexMarker1388"/> longer supports C++03. The current version of Catch2 is v3, which has some significant changes when compared to Catch2 v2, such as the library is no longer a single-header library but works as a regular library (that needs to be compiled), and requires a C++14 compiler.</p>
<div><p class="normal">For the remaining recipes of this chapter, we will learn how to write unit tests using Catch2 version 3.</p>
</div>
<h2 class="heading-2" id="_idParaDest-735">Getting ready</h2>
<p class="normal">The Catch2 test framework has a macro-based API. Although you only need to use the supplied macros for writing tests, a good understanding of macros is recommended if you want to use the framework well.</p>
<h2 class="heading-2" id="_idParaDest-736">How to do it...</h2>
<p class="normal">In order to set up your<a id="_idIndexMarker1389"/> environment to use the Catch2 testing framework, do the following:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Clone or download the Git repository from <a href="https://github.com/catchorg/Catch2">https://github.com/catchorg/Catch2</a>.</li>
<li class="numberedList">Once you’ve downloaded the repository, unzip the content of the archive.</li>
</ol>
<p class="normal">To use the v3 version of Catch 2, you have two options:</p>
<ul>
<li class="bulletList">Use library merged (amalgamated) header and source files in your test project. These files are called <code class="inlineCode">catch_amalgamated.hpp</code> and <code class="inlineCode">catch_amalgamated.cpp</code>. They are located in the <code class="inlineCode">extras</code> folder of the Catch2 library, and you can copy them into your test project if you want. The advantage of this is that you don’t have to deal with CMake scripts, at the expense of increased build times.</li>
<li class="bulletList">Use CMake to add Catch2 as a static library for your project.</li>
</ul>
<p class="normal">To create your first test program using Catch2 and its amalgamated files, do the following:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Create a new empty C++ project.</li>
<li class="numberedList">Copy the <code class="inlineCode">catch_amalgamated.hpp</code> and <code class="inlineCode">catch_amalgamated.cpp</code> files from the <code class="inlineCode">extras</code> folder of the Catch2 library to your test project.</li>
<li class="numberedList">Add the <code class="inlineCode">catch_amalgamated.cpp</code> source file to your project, to be compiled along with your other source files (containing tests).</li>
<li class="numberedList">Add a new source file to the project with the following content:
        <pre class="programlisting code"><code class="hljs-code">#include "catch_amalgamated.hpp"
TEST_CASE("first_test_case", "[learn][catch]")
{
  SECTION("first_test_function")
  {
    auto i{ 42 };
    REQUIRE(i == 42);
  }
}
</code></pre>
</li>
<li class="numberedList">Build and run the project.</li>
</ol>
<p class="normal">To create<a id="_idIndexMarker1390"/> your first test program with Catch2 using the CMake integration, do the following:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Open a console/command prompt and change the directory to the location of the cloned/unzipped Catch2 files.</li>
<li class="numberedList">Build the library using the commands shown below. On a Unix system, run:
        <pre class="programlisting con"><code class="hljs-con">cmake -Bbuild -H. -DBUILD_TESTING=OFF
sudo cmake --build build/ --target instal
</code></pre>
<p class="normal">On a Windows system, execute the following commands from a command prompt running with administrative privileges:</p>
<pre class="programlisting con"><code class="hljs-con">cmake -Bbuild -H. -DBUILD_TESTING=OFF
cmake --build build/ --target instal
</code></pre> </li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="3">Create a new folder (called <code class="inlineCode">Test</code>) for a C++ testing project.</li>
<li class="numberedList">Add a new source file (called <code class="inlineCode">main.cpp</code>) to this folder with the following content:
        <pre class="programlisting code"><code class="hljs-code">#include &lt;catch2/catch_test_macros.hpp&gt;
TEST_CASE("first_test_case", "[learn][catch]")
{
   SECTION("first_test_function")
   {
      auto i{ 42 };
      REQUIRE(i == 42);
   }
}
</code></pre>
</li>
<li class="numberedList">Add a new <code class="inlineCode">CMakeLists.txt</code> CMake file to the <code class="inlineCode">Test</code> folder with the following content:
        <pre class="programlisting code"><code class="hljs-code">find_package(Catch2 3 REQUIRED)
add_executable(Test main.cpp)
target_link_libraries(Test PRIVATE Catch2::Catch2WithMain)
</code></pre>
</li>
<li class="numberedList">Run <code class="inlineCode">cmake.exe</code> to generate/build your project.</li>
</ol>
<div><p class="normal">There are different ways to set up your project using CMake. In this recipe, I provided a minimal example that works, which you can also find with the source files from the GitHub repo. Readers experienced with CMake may find better approaches than the one provided here. You can learn more about CMake from online resources.</p>
</div>
<h2 class="heading-2" id="_idParaDest-737">How it works...</h2>
<p class="normal">Catch2 enables<a id="_idIndexMarker1391"/> developers to write test cases as self-registered functions; it can even provide a default implementation for the <code class="inlineCode">main()</code> function so that you can focus on testing code and writing less setup code. Test cases are divided into sections that are run in isolation. The <a id="_idIndexMarker1392"/>framework does not adhere to the style of the <strong class="keyWord">setup-test-teardown</strong> architecture. Instead, the test case sections (or rather the innermost ones, since sections can be nested) are the units of testing that are executed, along with their enclosing sections. This makes the need for fixtures obsolete because data and setup and teardown code can be reused on multiple levels.</p>
<p class="normal">Test cases and sections are identified using strings, not identifiers (as in most testing frameworks). Test cases can also be tagged so that tests can be executed or listed based on tags. Test results are printed in a textual human-readable format; however, they can also be exported to XML, using either a Catch2-specific schema or a JUNIT ANT schema for easy integration with continuous delivery systems. The execution of the tests can be parameterized to break upon failure (on Windows and macOS) so that you can attach a debugger and inspect the program.</p>
<p class="normal">The framework is easy to install and use. There are two alternatives, as seen in the <em class="italic">How to do it…</em> section:</p>
<ul>
<li class="bulletList">Using<a id="_idIndexMarker1393"/> the amalgamated files <code class="inlineCode">catch_amalgamated.hpp</code> and <code class="inlineCode">catch_amalgamated_cpp</code>. These are a merging of all the header and source files. The advantage of using them is that you do not have to worry about building the Catch2 library. You only have to copy these files to your desired location (typically inside your project), include the <code class="inlineCode">catch_amalgamated</code>.hpp header in your files that contain tests, and build <code class="inlineCode">catch_amalgamated.cpp</code> alongside the rest of your source files. The disadvantage of using this approach is increased build times.</li>
<li class="bulletList">Using Catch2 as a static library. This requires you to build the library before using it. You can either add the header and <code class="inlineCode">lib</code> files explicitly to your project, or you can use CMake for this purpose. This approach provides the advantage of reduced build times.</li>
</ul>
<p class="normal">The sample code shown in the previous section has the following parts:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><code class="inlineCode">#include "catch_amalgamated.hpp"</code> includes the amalgamated header of the library that is a merging of all the library headers. On the other hand, if you’re using the build version, you only need to include the particular headers that you need, such as <code class="inlineCode">&lt;catch2/catch_test_macros.hpp&gt;</code>. You can include <code class="inlineCode">&lt;cathc2/catch_all.hpp&gt;</code> but this will include all the library headers, which is not advisable. In general, you should only include the headers that you need.</li>
<li class="numberedList"><code class="inlineCode">TEST_CASE("first_test_case", "[learn][catch]")</code> defines a test case called <code class="inlineCode">first_test_case</code>, which has two associated tags: <code class="inlineCode">learn</code> and <code class="inlineCode">catch</code>. Tags are used to select either running or just listing test cases. Multiple test cases can be tagged with the same tags.</li>
<li class="numberedList"><code class="inlineCode">SECTION("first_test_function")</code> defines a section, that is, a test function, called <code class="inlineCode">first_test_function</code>, as part of the outer test case.</li>
<li class="numberedList"><code class="inlineCode">REQUIRE(i == 42);</code> is an assertion that tells the test to fail if the condition is not satisfied.</li>
</ol>
<p class="normal">The output of running this program is as follows:</p>
<pre class="programlisting con"><code class="hljs-con">=========================================================
All tests passed (1 assertion in 1 test cases)
</code></pre>
<h2 class="heading-2" id="_idParaDest-738">There’s more...</h2>
<p class="normal">As mentioned previously, the <a id="_idIndexMarker1394"/>framework enables us to write tests using the BDD style with <em class="italic">give-when-then</em> sections. This was made possible using several aliases: <code class="inlineCode">SCENARIO</code> for <code class="inlineCode">TEST_CASE</code> and <code class="inlineCode">GIVE</code>, <code class="inlineCode">WHEN</code>, <code class="inlineCode">AND_WHEN</code>, <code class="inlineCode">THEN</code>, and <code class="inlineCode">AND_THEN</code> for <code class="inlineCode">SECTION</code>. Using this style, we can rewrite the test shown earlier, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">SCENARIO("first_scenario", "[learn][catch]")
{
  GIVEN("an integer")
  {
    auto i = 0;
    WHEN("assigned a value")
    {
      i = 42;
      THEN("the value can be read back")
      {
        REQUIRE(i == 42);
      }
    }
  }
}
</code></pre>
<p class="normal">When executed successfully, the program prints the following output:</p>
<pre class="programlisting con"><code class="hljs-con">=========================================================
All tests passed (1 assertion in 1 test cases)
</code></pre>
<p class="normal">However, upon failure (let’s suppose we got the wrong condition: <code class="inlineCode">i == 0</code>), the expression that failed, as well as the values on the left-hand and right-hand sides, are printed in the output, as shown in the following snippet:</p>
<pre class="programlisting con"><code class="hljs-con">---------------------------------------------------------------
f:\chapter11ca_01\main.cpp(11)
...............................................................
f:\chapter11ca_01\main.cpp(13): FAILED:
  REQUIRE( i == 0 )
with expansion:
  42 == 0
===============================================================
test cases: 1 | 1 failed
assertions: 1 | 1 failed
</code></pre>
<p class="normal">The output presented <a id="_idIndexMarker1395"/>here, as well as in other snippets throughout the following recipes, has been slightly trimmed or compressed from the actual console output to make it easier to list within the pages of this book.</p>
<h2 class="heading-2" id="_idParaDest-739">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Writing and invoking tests with Catch2</em>, to see how to create tests with the Catch2 library, either using the traditional style based on test cases or the BDD style with scenarios, as well as how to run tests</li>
<li class="bulletList"><em class="italic">Asserting with Catch2</em>, to explore the various assertion macros from the Catch2 library</li>
</ul>
<h1 class="heading-1" id="_idParaDest-740">Writing and invoking tests with Catch2</h1>
<p class="normal">The Catch2 framework enables you to write tests using either the traditional style of test cases and test functions or the BDD style with scenarios and <em class="italic">given-when-then</em> sections. Tests <a id="_idIndexMarker1396"/>are defined as separate sections of a test case and can be nested as deep as you want. Whichever style you prefer, tests are defined with only two base macros. This recipe will show what these macros are and how they work.</p>
<h2 class="heading-2" id="_idParaDest-741">How to do it...</h2>
<p class="normal">To write tests using the<a id="_idIndexMarker1397"/> traditional style, with test cases and test functions, do this:</p>
<ul>
<li class="bulletList">Use the <code class="inlineCode">TEST_CASE</code> macro to define a test case with a name (as a string), and optionally, a list of its associated tags:
        <pre class="programlisting code"><code class="hljs-code">TEST_CASE("test construction", "[create]")
{
  // define sections here
}
</code></pre>
</li>
<li class="bulletList">Use the <code class="inlineCode">SECTION</code> macro to define a test function inside a test case, with the name as a string:
        <pre class="programlisting code"><code class="hljs-code">TEST_CASE("test construction", "[create]")
{
  SECTION("test constructor")
  {
    auto p = point3d{ 1,2,3 };
    REQUIRE(p.x() == 1);
    REQUIRE(p.y() == 2);
    REQUIRE(p.z() == 4);
  }
}
</code></pre>
</li>
<li class="bulletList">Define <a id="_idIndexMarker1398"/>nested sections if you want to reuse the setup and teardown code or organize your tests in a hierarchical structure:
        <pre class="programlisting code"><code class="hljs-code">TEST_CASE("test operations", "[modify]")
{
  SECTION("test methods")
  {
    SECTION("test offset")
    {
      auto p = point3d{ 1,2,3 };
      p.offset(1, 1, 1);
      REQUIRE(p.x() == 2);
      REQUIRE(p.y() == 3);
      REQUIRE(p.z() == 3);
    }
  }
}
</code></pre>
</li>
</ul>
<p class="normal">To write tests <a id="_idIndexMarker1399"/>using the BDD style, do this:</p>
<ul>
<li class="bulletList">Define scenarios using the <code class="inlineCode">SCENARIO</code> macro, specifying a name for it:
        <pre class="programlisting code"><code class="hljs-code">SCENARIO("modify existing object")
{
  // define sections here
}
</code></pre>
</li>
<li class="bulletList">Define nested sections inside the scenario using the <code class="inlineCode">GIVEN</code>, <code class="inlineCode">WHEN</code>, and <code class="inlineCode">THEN</code> macros, specifying a name for each of them:
        <pre class="programlisting code"><code class="hljs-code">SCENARIO("modify existing object")
{
  GIVEN("a default constructed point")
  {
    auto p = point3d{};
    REQUIRE(p.x() == 0);
    REQUIRE(p.y() == 0);
    REQUIRE(p.z() == 0);
    WHEN("increased with 1 unit on all dimensions")
    {
      p.offset(1, 1, 1);
      THEN("all coordinates are equal to 1")
      {
        REQUIRE(p.x() == 1);
        REQUIRE(p.y() == 1);
        REQUIRE(p.z() == 1);
      }
    }
  }
}
</code></pre>
</li>
</ul>
<p class="normal">To execute<a id="_idIndexMarker1400"/> the <a id="_idIndexMarker1401"/>tests, do the following:</p>
<ul>
<li class="bulletList">To execute all the tests from your program (except hidden ones), run the test program without any command-line arguments (from the ones described in the following code).</li>
<li class="bulletList">To execute only a specific set of test cases, provide a filter as a command-line argument. This can contain test case names, wildcards, tag names, and tag expressions:
        <pre class="programlisting con"><code class="hljs-con">chapter11ca_02.exe "test construction"
test construction
   test constructor
-------------------------------------------------
f:\chapter11ca_02\main.cpp(7)
.................................................
f:\chapter11ca_02\main.cpp(12): FAILED:
  REQUIRE( p.z() == 4 )
with expansion:
  3 == 4
=================================================
test cases: 1 | 1 failed
assertions: 6 | 5 passed | 1 failed
</code></pre>
</li>
<li class="bulletList">To execute only a particular section (or set of sections), use the command-line argument <code class="inlineCode">--section</code> or <code class="inlineCode">-c</code> with the section name (can be used multiple times for multiple sections):
        <pre class="programlisting con"><code class="hljs-con">chapter11ca_02.exe "test construction" --section "test origin"
Filters: test construction
==================================================
All tests passed (3 assertions in 1 test case)
</code></pre>
</li>
<li class="bulletList">To <a id="_idIndexMarker1402"/>specify the order in which test cases should be run, use the <a id="_idIndexMarker1403"/>command-line argument <code class="inlineCode">--order</code> with one of the following values: <code class="inlineCode">decl</code> (for the order of declaration), <code class="inlineCode">lex</code> (for lexicographic ordering by name), or <code class="inlineCode">rand</code> (for a random order determined with <code class="inlineCode">std::random_shuffle()</code>). Here’s an illustration of this:
        <pre class="programlisting con"><code class="hljs-con">chapter11ca_02.exe --order lex
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-742">How it works...</h2>
<p class="normal">Test cases are self-registered and do not require any additional work from the developer to set the test program, other than defining the test cases and test functions. Test functions are defined as sections of test cases (using the <code class="inlineCode">SECTION</code> macro), and they can be nested.</p>
<p class="normal">There is no limit to the depth of section nesting. Test cases and test functions, which, from here on, will be referred to as sections, form a tree structure, with the test cases on the root nodes and the most inner sections as leaves. When the test program runs, it is the leaf sections that are executed. Each leaf section is executed in isolation from the other leaf sections. However, the execution path starts at the root test case and continues downward, toward the innermost section. All of the code that’s encountered on the path is executed entirely for each run. This means that when multiple sections share common code (from a parent section or the test case), the same code is executed once for each section, without any data being shared between executions. This has the effect that it eliminates the need for a special fixture approach on the one hand. On the other hand, it enables multiple fixtures for each section (everything that is encountered up in the path), a feature that many testing frameworks lack.</p>
<p class="normal">The BDD style of writing test cases is powered by the same two macros, namely, <code class="inlineCode">TEST_CASE</code> and <code class="inlineCode">SECTION</code>, and the ability to test sections. In fact, the macro <code class="inlineCode">SCENARIO</code> is a redefinition of <code class="inlineCode">TEST_CASE</code>, and <code class="inlineCode">GIVEN</code>, <code class="inlineCode">WHEN</code>, <code class="inlineCode">AND_WHEN</code>, <code class="inlineCode">THEN</code>, and <code class="inlineCode">AND_THEN</code> are redefinitions of <code class="inlineCode">SECTION</code>:</p>
<pre class="programlisting code"><code class="hljs-code">#define SCENARIO( ... ) TEST_CASE( "Scenario: " __VA_ARGS__ )
#define GIVEN(desc)     INTERNAL_CATCH_DYNAMIC_SECTION("    Given: " &lt;&lt; desc)
#define AND_GIVEN(desc) INTERNAL_CATCH_DYNAMIC_SECTION("And given: " &lt;&lt; desc)
#define WHEN(desc)      INTERNAL_CATCH_DYNAMIC_SECTION("     When: " &lt;&lt; desc)
#define AND_WHEN(desc)  INTERNAL_CATCH_DYNAMIC_SECTION(" And when: " &lt;&lt; desc)
#define THEN(desc)      INTERNAL_CATCH_DYNAMIC_SECTION("     Then: " &lt;&lt; desc)
#define AND_THEN(desc)  INTERNAL_CATCH_DYNAMIC_SECTION("      And: " &lt;&lt; desc)
</code></pre>
<p class="normal">When you <a id="_idIndexMarker1404"/>execute <a id="_idIndexMarker1405"/>a test program, all defined tests are run. This, however, excludes hidden tests, which are specified either using a name that starts with <code class="inlineCode">./</code> or a tag that starts with a period. It is possible to force the running of hidden tests too by providing the command-line argument <code class="inlineCode">[.]</code> or <code class="inlineCode">[hide]</code>.</p>
<p class="normal">It is possible to filter the test cases to execute. This can be done using either the name or the tags. The following table displays some of the possible options:</p>
<table class="table-container" id="table005-4">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Argument</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Description</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">"test construction"</code></p>
</td>
<td class="table-cell">
<p class="normal">The test case called <code class="inlineCode">test construction</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">test*</code></p>
</td>
<td class="table-cell">
<p class="normal">All test cases that start with <code class="inlineCode">test</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">~"test construction"</code></p>
</td>
<td class="table-cell">
<p class="normal">All test cases, except the one called <code class="inlineCode">test construction</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">~*equal*</code></p>
</td>
<td class="table-cell">
<p class="normal">All test cases, except those that contain the word <code class="inlineCode">equal</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">a* ~ab* abc</code></p>
</td>
<td class="table-cell">
<p class="normal">All tests that start with <code class="inlineCode">a</code>, except those that start with <code class="inlineCode">ab</code>, except <code class="inlineCode">abc</code>, which is included</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[modify]</code></p>
</td>
<td class="table-cell">
<p class="normal">All test cases tagged with <code class="inlineCode">[modify]</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">[modify],[compare][op]</code></p>
</td>
<td class="table-cell">
<p class="normal">All test cases that are tagged with either <code class="inlineCode">[modify]</code> or both <code class="inlineCode">[compare]</code> and <code class="inlineCode">[op]</code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">-#sourcefile</code></p>
</td>
<td class="table-cell">
<p class="normal">All tests from the <code class="inlineCode">sourcefile.cpp</code> file</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 11.5: Examples of filters for the test cases to be executed</p>
<p class="normal">The execution of <a id="_idIndexMarker1406"/>particular test functions is also possible by specifying one or<a id="_idIndexMarker1407"/> more section names with the command-line argument <code class="inlineCode">--section</code> or <code class="inlineCode">-c</code>. However, wildcards are not supported for this option. If you specify a section to run, be aware that the entire test path from the root test case to the selected section will be executed. Moreover, if you do not specify a test case or a set of test cases first, then all the test cases will be executed, though only the matching sections within them.</p>
<h2 class="heading-2" id="_idParaDest-743">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Getting started with Catch2</em>, to learn how to install the Catch2 framework and how to create a simple test project</li>
<li class="bulletList"><em class="italic">Asserting with Catch2</em>, to explore the various assertion macros from the Catch2 library</li>
</ul>
<h1 class="heading-1" id="_idParaDest-744">Asserting with Catch2</h1>
<p class="normal">Unlike other<a id="_idIndexMarker1408"/> testing frameworks, Catch2 does not provide a large set of assertion macros. It has two main macros: <code class="inlineCode">REQUIRE</code>, which produces a fatal error, stopping the execution of the test case upon failure, and <code class="inlineCode">CHECK</code>, which produces a non-fatal error upon failure, continuing the execution of the test case. Several additional macros are defined; in this recipe, we will see how to put them to work.</p>
<h2 class="heading-2" id="_idParaDest-745">Getting ready</h2>
<p class="normal">You should now be familiar with writing test cases and test functions using Catch2, a topic we covered in the previous recipe, <em class="italic">Writing and invoking tests with Catch2</em>.</p>
<h2 class="heading-2" id="_idParaDest-746">How to do it...</h2>
<p class="normal">The following list contains the available options for asserting with the Catch2 framework:</p>
<ul>
<li class="bulletList">Use <code class="inlineCode">CHECK(expr)</code> to check whether <code class="inlineCode">expr</code> evaluates to <code class="inlineCode">true</code>, continuing the execution in case of failure, and <code class="inlineCode">REQUIRE(expr)</code> to make sure that <code class="inlineCode">expr</code> evaluates to <code class="inlineCode">true</code>, stopping the execution of the test in case of failure:
        <pre class="programlisting code"><code class="hljs-code">int a = 42;
CHECK(a == 42);
REQUIRE(a == 42);
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">CHECK_FALSE(expr)</code> and <code class="inlineCode">REQUIRE_FALSE(expr)</code> to make sure that <code class="inlineCode">expr</code> evaluates<a id="_idIndexMarker1409"/> to <code class="inlineCode">false</code> and produces either a non-fatal or fatal error in case of failure:
        <pre class="programlisting code"><code class="hljs-code">int a = 42;
CHECK_FALSE(a &gt; 100);
REQUIRE_FALSE(a &gt; 100);
</code></pre>
</li>
<li class="bulletList">Use floating-point matchers, <code class="inlineCode">WithinAbs</code>, <code class="inlineCode">WithinRel</code>, and <code class="inlineCode">WithinUPL</code>, to compare floating-point numbers (this is preferred over the obsolete <code class="inlineCode">Approx</code> class):
        <pre class="programlisting code"><code class="hljs-code">double a = 42.5;
CHECK_THAT(42.0, Catch::Matchers::WithinAbs(a, 0.5));
REQUIRE_THAT(42.0, Catch::Matchers::WithinAbs(a, 0.5));
CHECK_THAT(42.0, Catch::Matchers::WithinRel(a, 0.02));
REQUIRE_THAT(42.0, Catch::Matchers::WithinRel(a, 0.02));
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">CHECK_NOTHROW(expr)</code>/<code class="inlineCode">REQUIRE_NOTHROW(expr)</code> to verify that <code class="inlineCode">expr</code> does not throw any error, <code class="inlineCode">CHECK_THROWS(expr)</code>/<code class="inlineCode">REQUIRE_THROWS(expr)</code> to verify that <code class="inlineCode">expr</code> does throw an error of any type, <code class="inlineCode">CHECK_THROWS_AS(expr, exctype)</code>/<code class="inlineCode">REQUIRE_THROWS_AS(expr, exctype)</code> to verify that <code class="inlineCode">expr</code> throws an exception of the type <code class="inlineCode">exctype</code>, or <code class="inlineCode">CHECK_THROWS_WITH(expression, string or string matcher)</code>/<code class="inlineCode">REQUIRE_THROWS_WITH(expression, string or string matcher)</code> to verify that <code class="inlineCode">expr</code> throws an expression whose description matches the specified string:
        <pre class="programlisting code"><code class="hljs-code">void function_that_throws()
{
  throw std::runtime_error("error");
}
void function_no_throw()
{
}
SECTION("expressions")
{
  CHECK_NOTHROW(function_no_throw());
  REQUIRE_NOTHROW(function_no_throw());
  
  CHECK_THROWS(function_that_throws());
  REQUIRE_THROWS(function_that_throws());
  
  CHECK_THROWS_AS(function_that_throws(), std::runtime_error);
  REQUIRE_THROWS_AS(function_that_throws(), std::runtime_error);
  
  CHECK_THROWS_WITH(function_that_throws(), "error");
  REQUIRE_THROWS_WITH(function_that_throws(), 
          Catch::Matchers::ContainsSubstring("error"));
}
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">CHECK_THAT(value, matcher expression)</code>/<code class="inlineCode">REQUIRE_THAT(expr, matcher expression)</code> to check whether the given matcher expression evaluates<a id="_idIndexMarker1410"/> to <code class="inlineCode">true</code> for the specified value:
        <pre class="programlisting code"><code class="hljs-code">std::string text = "this is an example";
CHECK_THAT(
  text,
  Catch::Matchers::ContainsSubstring("EXAMPLE", Catch::CaseSensitive::No));
REQUIRE_THAT(
  text,
  Catch::Matchers::StartsWith("this") &amp;&amp; 
  Catch::Matchers::ContainsSubstring("an"));
</code></pre>
</li>
<li class="bulletList">Use <code class="inlineCode">FAIL(message)</code> to report <code class="inlineCode">message</code> and fail the test case, <code class="inlineCode">WARN(message)</code> to log the message without stopping the execution of the test case, and <code class="inlineCode">INFO(message)</code> to log the message to a buffer and only report it with the next assertion that would fail.</li>
</ul>
<h2 class="heading-2" id="_idParaDest-747">How it works...</h2>
<p class="normal">The <code class="inlineCode">REQUIRE</code>/<code class="inlineCode">CATCH</code> family <a id="_idIndexMarker1411"/>of macros decompose the expression into its left- and right-hand side terms and, upon failure, report the location of the failure (source file and line), the expression, and the values on the left- and right-hand sides:</p>
<pre class="programlisting con"><code class="hljs-con">f:\chapter11ca_03\main.cpp(19): FAILED:
  REQUIRE( a == 1 )
with expansion:
  42 == 1
</code></pre>
<p class="normal">However, these macros do not support complex expressions composed using logical operators, such as <code class="inlineCode">&amp;&amp;</code> and <code class="inlineCode">||</code>. The following example is an error:</p>
<pre class="programlisting code"><code class="hljs-code">REQUIRE(a &lt; 10 || a %2 == 0);   // error
</code></pre>
<p class="normal">The solution for this is to create a variable to hold the result of the expression evaluation and use it in the assertion macros. In this case, however, the ability to print the expansion of the elements of the expression is lost:</p>
<pre class="programlisting code"><code class="hljs-code">auto expr = a &lt; 10 || a % 2 == 0;
REQUIRE(expr);
</code></pre>
<p class="normal">An alternative is to use another set of parentheses. However, this too stops the decomposition from working:</p>
<pre class="programlisting code"><code class="hljs-code">REQUIRE((a &lt; 10 || a %2 == 0)); // OK
</code></pre>
<p class="normal">Two sets of assertions, namely <code class="inlineCode">CHECK_THAT</code>/<code class="inlineCode">REQUIRE_THAT</code> and <code class="inlineCode">CHECK_THROWS_WITH</code>/<code class="inlineCode">REQUIRE_THROWS_WITH</code>, work with matchers. Matchers are extensible and composable components that perform value matching. The framework provides several matchers, including for:</p>
<ul>
<li class="bulletList">Strings: <code class="inlineCode">StartsWith</code>, <code class="inlineCode">EndsWith</code>, <code class="inlineCode">ContainsSubstring</code>, <code class="inlineCode">Equals</code>, and <code class="inlineCode">Matches</code></li>
<li class="bulletList"><code class="inlineCode">std::vector</code>: <code class="inlineCode">Contains</code>, <code class="inlineCode">VectorContains</code>, <code class="inlineCode">Equals</code>, <code class="inlineCode">UnorderedEquals</code>, and <code class="inlineCode">Approx</code></li>
<li class="bulletList">Floating-point values: <code class="inlineCode">WithinAbs</code>, <code class="inlineCode">WithinULP</code>, <code class="inlineCode">WithinRel</code>, and <code class="inlineCode">IsNaN</code></li>
<li class="bulletList">Range-like types (included from version 3.0.1): <code class="inlineCode">IsEmpty</code>, <code class="inlineCode">SizeIs</code>, <code class="inlineCode">Contains</code>, <code class="inlineCode">AllMatch</code>, <code class="inlineCode">AnyMatch</code>, <code class="inlineCode">NoneMatch</code>, <code class="inlineCode">AllTrue</code>, <code class="inlineCode">AnyTrue</code>, <code class="inlineCode">NoneTrue</code>, <code class="inlineCode">RangeEquals</code>, <code class="inlineCode">UnorderedRangeEquals</code></li>
<li class="bulletList">Exceptions: <code class="inlineCode">Message</code> and <code class="inlineCode">MessageMatches</code></li>
</ul>
<div><p class="normal">The difference between <code class="inlineCode">Contains()</code> and <code class="inlineCode">VectorContains()</code> is that <code class="inlineCode">Contains()</code> searches for a vector in another vector and <code class="inlineCode">VectorContains()</code> searches for a single element inside a vector.</p>
</div>
<p class="normal">As mentioned in<a id="_idIndexMarker1412"/> the previous list, there are several matchers that target floating-point numbers. These matchers are:</p>
<ul>
<li class="bulletList"><code class="inlineCode">WithinAbs()</code>: Creates a matcher that accepts a floating-point number that is less than or equal to a target number with a specified margin (a percentage given as a number between 0 and 1):
        <pre class="programlisting code"><code class="hljs-code">REQUIRE_THAT(42.0, WithinAbs(42.5, 0.5));
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">WithinRel()</code>: Creates a matcher that accepts a floating-point number that is approximatively equal to a target with a given tolerance:
        <pre class="programlisting code"><code class="hljs-code">REQUIRE_THAT(42.0, WithinRel(42.4, 0.01));
</code></pre>
</li>
<li class="bulletList"><code class="inlineCode">WithinULP()</code>: Creates a matcher that accepts a floating-point number that is no more than the given ULP away from the target:
        <pre class="programlisting code"><code class="hljs-code">REQUIRE_THAT(42.0, WithinRel(target, 4));
</code></pre>
</li>
</ul>
<p class="normal">These matchers can also be combined together, as exemplified below:</p>
<pre class="programlisting code"><code class="hljs-code">REQUIRE_THAT(a,
  Catch::Matchers::WithinRel(42.0, 0.001) ||
  Catch::Matchers::WithinAbs(42.0, 0.000001));
</code></pre>
<p class="normal">An obsolete way of comparing floating-point numbers is represented by the class called <code class="inlineCode">Approx</code>, in the <code class="inlineCode">Catch</code> namespace. This class overloads the equality/inequality and comparison operators with values through which a <code class="inlineCode">double</code> value can be constructed. The margin by which the two values can either differ or be considered equal can be specified as a percentage of the given value. This is set using the member function <code class="inlineCode">epsilon()</code>. The value must be between 0 and 1 (for example, the value of 0.05 is 5 percent). The default value of epsilon is set to <code class="inlineCode">std::numeric_limits&lt;float&gt;::epsilon()*100</code>.</p>
<p class="normal">You can create your own matchers, either to extend the existing framework capabilities or to work with your own types. There are two ways to create custom matches: the old v2 way, and the new v3 way.</p>
<p class="normal">To create a<a id="_idIndexMarker1413"/> custom matcher the old way, there are two things that are necessary:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">A matcher class derived from <code class="inlineCode">Catch::MatcherBase&lt;T&gt;</code>, where <code class="inlineCode">T</code> is the type being compared. There are two virtual functions that must be overridden: <code class="inlineCode">match()</code>, which takes a value to match and returns a Boolean indicating whether the match was successful, and <code class="inlineCode">describe()</code>, which takes no arguments but returns a string describing the matcher.</li>
<li class="numberedList">A builder function that is called from the test code.</li>
</ol>
<p class="normal">The following example defines a matcher for the <code class="inlineCode">point3d</code> class, which we have seen throughout this chapter, to check whether a given 3D point lies on a line in the three-dimensional space:</p>
<pre class="programlisting code"><code class="hljs-code">class OnTheLine : public Catch::Matchers::MatcherBase&lt;point3d&gt;
{
  point3d const p1;
  point3d const p2;
public:
  OnTheLine(point3d const &amp; p1, point3d const &amp; p2):
    p1(p1), p2(p2)
  {}
  virtual bool match(point3d const &amp; p) const override
 {
    auto rx = p2.x() - p1.x() != 0 ? 
             (p.x() - p1.x()) / (p2.x() - p1.x()) : 0;
    auto ry = p2.y() - p1.y() != 0 ? 
             (p.y() - p1.y()) / (p2.y() - p1.y()) : 0;
    auto rz = p2.z() - p1.z() != 0 ? 
             (p.z() - p1.z()) / (p2.z() - p1.z()) : 0;
    return 
      Catch::Approx(rx).epsilon(0.01) == ry &amp;&amp;
      Catch::Approx(ry).epsilon(0.01) == rz;
  }
protected:
  virtual std::string describe() const
 {
    std::ostringstream ss;
    ss &lt;&lt; "on the line between " &lt;&lt; p1 &lt;&lt; " and " &lt;&lt; p2;
    return ss.str();
  }
};
inline OnTheLine IsOnTheLine(point3d const &amp; p1, point3d const &amp; p2)
{
  return OnTheLine {p1, p2};
}
</code></pre>
<p class="normal">To create a<a id="_idIndexMarker1414"/> custom matcher the new way, you need the following:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">A matcher class derived from <code class="inlineCode">Catch::Matchers::MatcherGenericBase</code>. This class has to implement two methods: <code class="inlineCode">bool match(…) const</code>, which performs the matching, and an overriding of the virtual function <code class="inlineCode">string describe() const</code>, which takes no arguments but returns a string describing the matcher. Although these are very similar to the functions used in the old style, there is a key difference: the <code class="inlineCode">match()</code> function has no requirements on the way its argument is passed. This means it can take an argument by value or mutating reference. In addition, it can also be a function template. The advantage is that it enables writing more complex matchers, such as matchers that can compare range-like types.</li>
<li class="numberedList">A builder function that is called from the test code.</li>
</ol>
<p class="normal">The same matcher that compares <code class="inlineCode">point3d</code> values written in the new style looks as follows:</p>
<pre class="programlisting code"><code class="hljs-code">class OnTheLine : public Catch::Matchers::MatcherGenericBase
{
   point3d const p1;
   point3d const p2;
public:
   OnTheLine(point3d const&amp; p1, point3d const&amp; p2) :
      p1(p1), p2(p2)
   {
   }
   bool match(point3d const&amp; p) const
 {
      auto rx = p2.x() - p1.x() != 0 ? 
                (p.x() - p1.x()) / (p2.x() - p1.x()) : 0;
      auto ry = p2.y() - p1.y() != 0 ? 
                (p.y() - p1.y()) / (p2.y() - p1.y()) : 0;
      auto rz = p2.z() - p1.z() != 0 ? 
                (p.z() - p1.z()) / (p2.z() - p1.z()) : 0;
      return
         Catch::Approx(rx).epsilon(0.01) == ry &amp;&amp;
         Catch::Approx(ry).epsilon(0.01) == rz;
   }
protected:
   std::string describe() const override
 {
#ifdef __cpp_lib_format
return std::format("on the line between ({},{},{}) and ({},{},{})", p1.x(), p1.y(), p1.z(), p2.x(), p2.y(), p2.z());
#else
      std::ostringstream ss;
      ss &lt;&lt; "on the line between " &lt;&lt; p1 &lt;&lt; " and " &lt;&lt; p2;
      return ss.str();
#endif
   }
};
</code></pre>
<p class="normal">The following test <a id="_idIndexMarker1415"/>case contains an example of how to use this custom matcher:</p>
<pre class="programlisting code"><code class="hljs-code">TEST_CASE("matchers")
{
  SECTION("point origin")
  {
    point3d p { 2,2,2 };
    REQUIRE_THAT(p, IsOnTheLine(point3d{ 0,0,0 }, point3d{ 3,3,3 }));
  }
}
</code></pre>
<p class="normal">This test ensures that the point <code class="inlineCode">{2,2,2}</code> lies on the line defined by the points <code class="inlineCode">{0,0,0}</code> and <code class="inlineCode">{3,3,3}</code> by using the <code class="inlineCode">IsOnTheLine()</code> custom matcher implemented previously.</p>
<h2 class="heading-2" id="_idParaDest-748">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Writing and invoking tests with Catch2</em>, to see how to create tests with the Catch2 library, either using the traditional style based on test cases or the BDD style with scenarios, as well as how to run tests</li>
</ul>
<h1 class="heading-1" id="_idParaDest-749">Controlling output with Catch2</h1>
<p class="normal">As with <a id="_idIndexMarker1416"/>other testing frameworks discussed in this book, Catch2 reports the results of a test program’s execution in a human-readable format to the <code class="inlineCode">stdout</code> standard stream. Additional options are supported, such as reporting using XML format or writing to a file. In this recipe, we will look at the main options available for controlling the output when using Catch2.</p>
<h2 class="heading-2" id="_idParaDest-750">Getting ready</h2>
<p class="normal">To exemplify the way the test program’s execution output could be modified, use the following test cases:</p>
<pre class="programlisting code"><code class="hljs-code">TEST_CASE("case1")
{
  SECTION("function1")
  {
    REQUIRE(true);
  }
}
TEST_CASE("case2")
{
  SECTION("function2")
  {
    REQUIRE(false);
  }
}
</code></pre>
<p class="normal">The output of running these two test cases is as follows:</p>
<pre class="programlisting con"><code class="hljs-con">----------------------------------------------------------
case2
  function2
----------------------------------------------------------
f:\chapter11ca_04\main.cpp(14)
..........................................................
f:\chapter11ca_04\main.cpp(16): FAILED:
  REQUIRE( false )
==========================================================
test cases: 2 | 1 passed | 1 failed
assertions: 2 | 1 passed | 1 failed
</code></pre>
<p class="normal">In the following section, we’ll explore some of the various options for controlling the output of a Catch2 test program.</p>
<h2 class="heading-2" id="_idParaDest-751">How to do it…</h2>
<p class="normal">To control the<a id="_idIndexMarker1417"/> output of a test program when using Catch2, you can:</p>
<ul>
<li class="bulletList">Use the command-line argument <code class="inlineCode">-r</code> or <code class="inlineCode">--reporter &lt;reporter&gt;</code> to specify the reporter used to format and structure the results. The default options supplied with the framework are <code class="inlineCode">console</code>, <code class="inlineCode">compact</code>, <code class="inlineCode">xml</code>, and <code class="inlineCode">junit</code>:
        <pre class="programlisting con"><code class="hljs-con">chapter11ca_04.exe -r junit
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;testsuites&gt;
  &lt;testsuite name="chapter11ca_04.exe" errors="0" 
             failures="1"
             tests="2" hostname="tbd" 
             time="0.002039" 
             timestamp="2020-05-02T21:17:04Z"&gt;
    &lt;testcase classname="case1" name="function1" 
              time="0.00016"/&gt;
    &lt;testcase classname="case2" 
              name="function2" time="0.00024"&gt;
      &lt;failure message="false" type="REQUIRE"&gt;
        at f:\chapter11ca_04\main.cpp(16)
      &lt;/failure&gt;
    &lt;/testcase&gt;
    &lt;system-out/&gt;
    &lt;system-err/&gt;
  &lt;/testsuite&gt;
&lt;/testsuites&gt;
</code></pre>
</li>
<li class="bulletList">Use the command-line argument <code class="inlineCode">-s</code> or <code class="inlineCode">--success</code> to display the results of successful test cases too:
        <pre class="programlisting con"><code class="hljs-con">chapter11ca_04.exe -s
--------------------------------------------------
case1
  function1
--------------------------------------------------
f:\chapter11ca_04\main.cpp(6)
..................................................
f:\chapter11ca_04\main.cpp(8):
PASSED:
  REQUIRE( true )
--------------------------------------------------
case2
  function2
--------------------------------------------------
f:\chapter11ca_04\main.cpp(14)
..................................................
f:\chapter11ca_04\main.cpp(16): 
FAILED:
  REQUIRE( false )
==================================================
test cases: 2 | 1 passed | 1 failed
assertions: 2 | 1 passed | 1 failed
</code></pre>
</li>
<li class="bulletList">Use the <a id="_idIndexMarker1418"/>command-line argument <code class="inlineCode">-o</code> or <code class="inlineCode">--out &lt;filename&gt;</code> to send all of the output to a file instead of the standard stream:
        <pre class="programlisting con"><code class="hljs-con">chapter11ca_04.exe -o test_report.log
</code></pre>
</li>
<li class="bulletList">Use the command-line argument <code class="inlineCode">-d</code> or <code class="inlineCode">--durations &lt;yes/no&gt;</code> to display the time that it takes each test case to execute:
        <pre class="programlisting con"><code class="hljs-con">chapter11ca_04.exe -d yes
0.000 s: scenario1
0.000 s: case1
--------------------------------------------------
case2
   scenario2
--------------------------------------------------
f:\chapter11ca_04\main.cpp(14)
..................................................
f:\chapter11ca_04\main.cpp(16): 
FAILED:
  REQUIRE( false )
0.003 s: scenario2
0.000 s: case2
0.000 s: case2
==================================================
test cases: 2 | 1 passed | 1 failed
assertions: 2 | 1 passed | 1 failed
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-752">How it works...</h2>
<p class="normal">Apart from<a id="_idIndexMarker1419"/> the human-readable format used, by default, for reporting the results of the test program execution, the Catch2 framework supports two XML formats:</p>
<ul>
<li class="bulletList">A Catch2-specific XML format (specified with <code class="inlineCode">-r xml</code>)</li>
<li class="bulletList">A JUNIT-like XML format, following the structure of the JUNIT ANT task (specified with <code class="inlineCode">-r junit</code>)</li>
</ul>
<p class="normal">The former reporter streams the XML content as unit tests are executed and results are available. It can be used as input to an XSLT transformation to generate an HTML report for the instance. The latter reporter needs to gather all of the program execution data in order to structure the report before printing it. The JUNIT XML format is useful for being consumed by third-party tools, such as a continuous integration server.</p>
<p class="normal">Several additional reporters are provided in standalone headers. They need to be included in the source code of the test program (all the headers of the additional reporters have the name format as <code class="inlineCode">catch_reporter_*.hpp</code>). These additional available reporters are:</p>
<ul>
<li class="bulletList"><strong class="keyWord">TeamCity</strong> reporter (specified with <code class="inlineCode">-r teamcity</code>), which writes TeamCity service messages to the standard output stream. It is suitable only for integration with TeamCity. It is a streamed reporter; data is written as it is available.</li>
<li class="bulletList"><strong class="keyWord">Automake</strong> reporter (specified with <code class="inlineCode">-r automake</code>), which writes the meta tags expected by <code class="inlineCode">automake</code> via <code class="inlineCode">make check</code>.</li>
<li class="bulletList"><strong class="keyWord">Test Anything Protocol</strong> (or <strong class="keyWord">TAP</strong>, for short) reporter (specified with <code class="inlineCode">-r tap</code>).</li>
<li class="bulletList"><strong class="keyWord">SonarQube</strong> reporter (specified with <code class="inlineCode">-r sonarqube</code>), which writes using the SonarQube generic test data XML format.</li>
</ul>
<p class="normal">The following example shows how to include the TeamCity header file in order to produce the report using the TeamCity reporter:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;catch2/catch_test_macros.hpp&gt;
#include &lt;catch2/reporters/catch_reporter_teamcity.hpp&gt;
</code></pre>
<p class="normal">The default <a id="_idIndexMarker1420"/>target of the test report is the standard stream <code class="inlineCode">stdout</code> (even data written explicitly to <code class="inlineCode">stderr</code> ends up being redirected to <code class="inlineCode">stdout</code>). However, it is possible that the output is written to a file instead. These formatting options can be combined. Take a look at the following command:</p>
<pre class="programlisting con"><code class="hljs-con">chapter11ca_04.exe -r junit -o test_report.xml
</code></pre>
<p class="normal">This command specifies that the report should use the JUNIT XML format and be saved to a file called <code class="inlineCode">test_report.xml</code>.</p>
<h2 class="heading-2" id="_idParaDest-753">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Getting started with Catch2</em>, to learn how to install the Catch2 framework and how to create a simple test project</li>
<li class="bulletList"><em class="italic">Writing and invoking tests with Catch2</em>, to see how to create tests with the Catch2 library, either using the traditional style based on test cases or the BDD style with scenarios, as well as how to run tests</li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="Chapter_11.xhtml">https://discord.gg/7xRaTCeEhx</a></p>
<p class="normal"><img alt="" src="img/QR_Code2659294082093549796.png"/></p>
</div>
</body></html>