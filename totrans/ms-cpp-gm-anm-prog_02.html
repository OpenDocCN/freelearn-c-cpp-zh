<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer036" class="Basic-Text-Frame">
    <h1 class="chapterNumber">1</h1>
    <h1 id="_idParaDest-15" class="chapterTitle">Working with Open Asset Import Library</h1>
    <p class="normal">Welcome to <em class="italic">Mastering C++ Game Animations</em>! Are you the kind of person who looks at the animated models in a computer or console game, or a 3D animation tool, and asks yourself questions like:</p>
    <blockquote class="packt_quote">
      <p class="quote">How does this work? How do they do this? Could I do this myself, too?</p>
    </blockquote>
    <p class="normal">If so, this book will take you in the right direction to achieving this. In the next 14 chapters, you will learn how to create your own little game character model viewer.</p>
    <p class="normal">The book starts with loading a file using Open Asset Import Library, converting the data structures from the importer library into more efficient data structures for rendering, and rendering the character model with a simple OpenGL or Vulkan renderer. You will also learn how to optimize data updates and rendering by relocating computational load to the GPU in the form of GPU-based lookup tables and compute shaders.</p>
    <p class="normal">For the character animations, you will not only dive into normal animation blending but also be introduced to state-based animation control, additive animation blending to move the head independently of the rest of the body, and facial animations. You will also learn how to control the behavior of the instances by using a simplified version of behavior trees and implement interaction between the instances on the screen.</p>
    <p class="normal">To give a proper home to the game characters, you will learn how to load a game map into the application. Moving around in the game map will be enhanced by adding collision detection, inverse kinematics for the character feet, and simple navigation to let the instances run around fully on their own in the virtual world.</p>
    <p class="normal">In addition to the animations, features such as interactive selection by using the mouse, saving and loading the configuration to a file to allow working on larger virtual worlds, and handling different cameras in the virtual world are introduced. Also, a graphical, node-based configuration will be implemented, enabling you to change the behavior of the instances in a non-programming way.</p>
    <p class="normal">With all these steps combined, your virtual characters in the virtual world will come closer to real game characters.</p>
    <div class="note">
      <p class="normal">Join our community on Discord</p>
      <p class="normal"><img src="../Images/QR_code_Discord.png" alt="" width="150" height="150"/></p>
      <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://packt.link/cppgameanimation"><span class="url">https://packt.link/cppgameanimation</span></a>.</p>
    </div>
    <p class="normal">Every journey starts with the first step, so welcome to <a href=""><em class="italic">Chapter 1</em></a>! This chapter will set the foundation for the animation application, as you will get an insight into how to load a model file from your computer into the program, position the instance in the vast emptiness of the virtual world, and play the animations that are included in the file. By the end of this chapter, your game character model will be able to jump, run, or walk on the screen, maybe surrounded by non-animated models or other static objects.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Animating game characters – a primer</li>
      <li class="bulletList">What is Open Asset Import Library?</li>
      <li class="bulletList">Loading a model file</li>
      <li class="bulletList">Extending the UI with an Open File dialog</li>
      <li class="bulletList">Adding and removing model instances dynamically</li>
    </ul>
    <p class="normal">As we will use open source software and platform-independent libraries in this book, you should be able to compile and run the code “out of the box” on Windows and Linux. You will find a detailed list of the required software and libraries, plus their installation, in the following <em class="italic">Technical requirements</em> section.</p>
    <h1 id="_idParaDest-16" class="heading-1">Technical requirements</h1>
    <p class="normal">For this chapter, you will need the following:</p>
    <ul>
      <li class="bulletList">A PC with Windows or Linux, and the tools listed later in this section</li>
      <li class="bulletList">Git for source-code management</li>
      <li class="bulletList">A text editor (such as Notepad++ or Kate) or a full IDE (such as Visual Studio 2022 for Windows, or Eclipse/KDevelop for Linux)</li>
    </ul>
    <div class="note">
      <p class="normal">Important note</p>
      <p class="normal">A recent C++ compiler is required to compile the code. In the current CMake build system, C++17 is configured, but the code is known to work with newer C++ standards, up to and including C++26 (although the compiler must support those standards).</p>
    </div>
    <p class="normal">Now, let’s get the source code for this book and start unpacking the code.</p>
    <h2 id="_idParaDest-17" class="heading-2">Getting the source code and the basic tools</h2>
    <p class="normal">The code for this book is hosted on GitHub, which you can find here:</p>
    <p class="normal"><a href="https://github.com/PacktPublishing/Mastering-Cpp-Game-Animation-Programming"><span class="url">https://github.com/PacktPublishing/Mastering-Cpp-Game-Animation-Programming</span></a></p>
    <p class="normal">You need to install Git since the build system utilizes Git to download the third-party projects used in the examples.</p>
    <p class="normal">On Linux systems, use your package manager. For Ubuntu, the following line installs Git:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo apt install git
</code></pre>
    <p class="normal">On Windows, you can download Git here: <a href="https://git-scm.com/downloads"><span class="url">https://git-scm.com/downloads</span></a>.</p>
    <p class="normal">To unpack the code, you can use any of the following two methods.</p>
    <h3 id="_idParaDest-18" class="heading-3">Getting the code using Git</h3>
    <p class="normal">To get the code in the book, you should use Git. Using Git offers you additional features, such as creating a local branch for your changes, keeping track of your progress, and comparing your updates to the example code. Also, you can easily revert changes if you have broken the code during the exploration of the source code, or while working on the practical sessions at the end of each chapter.</p>
    <p class="normal">You can get a local checkout of the code in a specific location on your system either through the Git GUI, by cloning the repository in Visual Studio 2022, or by executing the following command in a CMD:</p>
    <pre class="programlisting con"><code class="hljs-con">git clone https://github.com/PacktPublishing/Mastering-Cpp-Game-Animation-Programming
</code></pre>
    <p class="normal">Please make sure that you use a path without spaces or special characters such as umlauts as this might confuse some compilers and development environments.</p>
    <h3 id="_idParaDest-19" class="heading-3">Getting the code as a ZIP file</h3>
    <p class="normal">Although Git is recommended, you can also download the code as a ZIP file from GitHub. You will need to unpack the ZIP file to a location of your choice on your system. Also, make sure that the path the ZIP file is unpacked to contains no spaces or special characters.</p>
    <p class="normal">Before we can use the code from the book, some tools and libraries must be installed. We will start with the Windows installation, followed by the Linux installation.</p>
    <h2 id="_idParaDest-20" class="heading-2">Installing the required tools and libraries for Windows</h2>
    <p class="normal">To compile the example code on a Windows machine, I recommend using Visual Studio 2022 as the IDE since it contains all you need for a quick start. Using other IDEs like Eclipse, Rider, or KDevelop is no problem as the build is managed by CMake, but you may need to install a C++ compiler like MSYS2 plus the compiler packages as an additional dependency.</p>
    <h3 id="_idParaDest-21" class="heading-3">Installing Visual Studio 2022 on Windows</h3>
    <p class="normal">If you want to use Visual Studio for the example files and don’t have it installed yet, download the free Community Edition of Visual Studio at <a href="https://visualstudio.microsoft.com/de/downloads/"><span class="url">https://visualstudio.microsoft.com/de/downloads/</span></a>.</p>
    <p class="normal">Then, follow these steps:</p>
    <ol>
      <li class="numberedList" value="1">Choose the <strong class="screenText">Desktop development with C++</strong> option so that the C++ compiler and the other required tools are installed on your machine:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B22428_01_01.png" alt="A screenshot of a computer  Description automatically generated" width="1046" height="271"/></figure>
    <p class="packt_figref">Figure 1.1: Installing the C++ desktop development in Visual Studio 2022</p>
    <ol>
      <li class="numberedList" value="2">Then, under <strong class="screenText">Individual components</strong>, also check the <strong class="screenText">C++ CMake tools for Windows</strong> option:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B22428_01_02.png" alt="A screenshot of a computer  Description automatically generated" width="735" height="306"/></figure>
    <p class="packt_figref">Figure 1.2: Check the box for CMake tools for Windows to be installed in Visual Studio 2022</p>
    <ol>
      <li class="numberedList" value="3">Finish the installation of Visual Studio, start it, and skip the initial project selection screen.</li>
    </ol>
    <h3 id="_idParaDest-22" class="heading-3">Enabling long path names on Windows</h3>
    <p class="normal">When using a fresh installation of Windows 10 or 11, the maximum path length for files is 260 characters. Depending on the location of the folder containing the code for the book, Visual Studio 2022 might run into errors caused by paths for temporary build folders exceeding the 260 characters limit.</p>
    <p class="normal">To enable long path names, the <strong class="keyWord">Windows Registry</strong> needs to be adjusted. A simple way is to create a text file with the <code class="inlineCode">.reg</code> extension, for instance, <code class="inlineCode">long-paths.reg</code>, and copy the following content to the file:</p>
    <pre class="programlisting code"><code class="hljs-code">Windows Registry Editor Version 5.00
 [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem]
 "LongPathsEnabled"=dword:00000001
</code></pre>
    <p class="normal">A double-click on the file will automatically start the <strong class="keyWord">Windows Registry Editor</strong> to import the settings to the Windows Registry. After confirming both the <strong class="keyWord">UAC</strong> dialog and the following warning dialogs by clicking <strong class="screenText">Yes</strong>, the Registry Editor will import the new settings.</p>
    <p class="normal">Now, reboot the PC to activate the long path names and continue with the installations.</p>
    <h3 id="_idParaDest-23" class="heading-3">Downloading Open Asset Import Library</h3>
    <p class="normal">For Windows, Open Asset Import Library must be built and installed from the source files. Clone the repository from <a href="https://github.com/assimp/assimp"><span class="url">https://github.com/assimp/assimp</span></a> in a new Visual Studio 2022 project, as shown in <em class="italic">Figure 1.3</em>:</p>
    <figure class="mediaobject"> <img src="../Images/B22428_01_03.png" alt="" width="1331" height="483"/></figure>
    <p class="packt_figref">Figure 1.3: Cloning the asset importer GitHub repository within Visual Studio 2022</p>
    <p class="normal">As an alternative, you can create a clone from a Git Bash, or via the Git GUI:</p>
    <pre class="programlisting con"><code class="hljs-con">git clone https://github.com/assimp/assimp
</code></pre>
    <h3 id="_idParaDest-24" class="heading-3">Configuring the build</h3>
    <p class="normal">We need to make a few adjustments to create a static library instead of a dynamic library. Using a static library makes the build process easier for us, as we don’t have to worry about an additional DLL file.</p>
    <p class="normal">To change the CMake settings, choose the following option after right-clicking on the <code class="inlineCode">CMakeLists.txt</code> file:</p>
    <figure class="mediaobject"><img src="../Images/B22428_01_04.png" alt="" width="896" height="220"/></figure>
    <p class="packt_figref">Figure 1.4: Changing the CMake settings for the asset importer</p>
    <p class="normal">In the <strong class="screenText">Configuration</strong> tab of Visual Studio 2022 that appears, change the configuration name to <code class="inlineCode">x64-RelWithDebInfo</code>, and change the configuration type to <code class="inlineCode">RelWithDebInfo</code>:</p>
    <figure class="mediaobject"><img src="../Images/B22428_01_05.png" alt="" width="813" height="469"/></figure>
    <p class="packt_figref">Figure 1.5: Modifying the current configuration of the asset importer</p>
    <p class="normal">By using <code class="inlineCode">RelWithDebInfo</code>, a release version with debug information will be created. The resulting executable will be optimized by the compiler, but the file still contains data to allow debugging the program in case of problems.</p>
    <p class="normal">Next, change the following settings in the CMake settings. You can use the search field on the bottom left, named <strong class="screenText">Filter variables...</strong>, to search for the specified setting:</p>
    <ul>
      <li class="bulletList">Disable building a shared library:</li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B22428_01_06.png" alt="" width="1316" height="366"/></figure>
    <p class="packt_figref">Figure 1.6: Switching the setting to create a static library</p>
    <ul>
      <li class="bulletList">Change the linking of the C runtime:</li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B22428_01_07.png" alt="" width="1297" height="367"/></figure>
    <p class="packt_figref">Figure 1.7: Linking the C runtime statically</p>
    <ul>
      <li class="bulletList">Remove the library suffix to create a file name without the compiler version:</li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B22428_01_08.png" alt="" width="1319" height="413"/></figure>
    <p class="packt_figref">Figure 1.8: Removing the suffix of the created file</p>
    <p class="normal">Next, select <strong class="screenText">Build</strong> and then <strong class="screenText">Install</strong> in the context menu of the <code class="inlineCode">CMakeLists.txt</code> file.</p>
    <p class="normal">After the installation is finished, the following folder structure will be generated:</p>
    <figure class="mediaobject"><img src="../Images/B22428_01_09.png" alt="" width="883" height="271"/></figure>
    <p class="packt_figref">Figure 1.9: Asset importer library and includes</p>
    <p class="normal">We have to make all the files discussed in this section available for all examples in the book. To do this, two options are available – copy the files to a fixed path or add an environment variable.</p>
    <h4 class="heading-4">Copying the Assimp files</h4>
    <p class="normal">First, create this folder on your computer:</p>
    <pre class="programlisting con"><code class="hljs-con">C:\Program Files\assimp
</code></pre>
    <p class="normal">Then, copy the two folders <code class="inlineCode">lib</code> and <code class="inlineCode">include</code> into it:</p>
    <figure class="mediaobject"><img src="../Images/B22428_01_10.png" alt="" width="1097" height="337"/></figure>
    <p class="packt_figref">Figure 1.10: The two folders have been copied to the Program Files folder</p>
    <p class="normal">The CMake search script for Assimp will try to find the static library and the header files in this folder.</p>
    <h4 class="heading-4">Adding an environment variable to help CMake find the files</h4>
    <p class="normal">As an alternative solution, you can create a folder on your PC wherever you want, for instance, to <code class="inlineCode">D:\assimp</code>. Then, copy the folders <code class="inlineCode">lib</code> and <code class="inlineCode">include</code> into the folder and set the environment variable <strong class="screenText">ASSIMP_ROOT</strong> to the location of the created folder:</p>
    <figure class="mediaobject"><img src="../Images/B22428_01_11.png" alt="A screenshot of a computer  Description automatically generated" width="952" height="185"/></figure>
    <p class="packt_figref">Figure 1.11: The environment variable ASSIMP_ROOT pointing to a folder on the PC</p>
    <p class="normal"><em class="italic">Please remember that you have to restart Visual Studio 2022 after setting the environment variable.</em></p>
    <h3 id="_idParaDest-25" class="heading-3">Installing the Vulkan SDK on Windows</h3>
    <p class="normal">For Vulkan support, you also need to have the Vulkan SDK installed. Get it here: <a href="https://vulkan.lunarg.com/sdk/home"><span class="url">https://vulkan.lunarg.com/sdk/home</span></a>.</p>
    <p class="normal">Do a default installation, and make sure to add <strong class="screenText">GLM headers.</strong> and <strong class="screenText">Vulkan Memory Allocator header.</strong>, as the CMake search scripts will use them if the Vulkan SDK is installed:</p>
    <figure class="mediaobject"><img src="../Images/B22428_01_12.png" alt="" width="900" height="496"/></figure>
    <p class="packt_figref">Figure 1.12: Adding GLM and VMA during Vulkan SDK installation</p>
    <p class="normal">Make sure to restart Visual Studio 2022 after installing the Vulkan SDK to allow detecting the Vulkan SDK header files and environment variables.</p>
    <h3 id="_idParaDest-26" class="heading-3">Compiling and starting the example code</h3>
    <p class="normal">Running the examples can be done in two different ways: following the book example by example or compiling all the code at once to browse all the examples.</p>
    <p class="normal">Compiling the code can be done using the following steps:</p>
    <ol>
      <li class="numberedList" value="1">To open an example project, choose <strong class="screenText">Open a local folder</strong> from the Visual Studio 2022 start screen or <strong class="screenText">Open CMake</strong> from the <strong class="screenText">File</strong> menu of Visual Studio 2022, then navigate to the folder with the example code you want to compile, or to the top-level folder of the example code if you want to compile all examples at once. Visual Studio will automatically detect and configure CMake in the selected folder for you. The last line of the output window should be as follows:
        <pre class="programlisting con-one"><code class="hljs-con"><span class="hljs-con-meta">1&gt; </span><span class="language-bash">CMake generation finished.</span>
</code></pre>
      </li>
      <li class="numberedList">This confirms the successful run of the CMake file generation.</li>
      <li class="numberedList">Now, set the startup item by right-clicking on the <code class="inlineCode">CMakeLists.txt</code> file – this step is required to build and run the project:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B22428_01_13.png" alt="" width="761" height="230"/></figure>
    <p class="packt_figref">Figure 1.13: Configuring the startup item in Visual Studio 2022</p>
    <ol>
      <li class="numberedList" value="4">After setting the startup item, we can build the current project. Right-click on the <code class="inlineCode">CMakeLists.txt</code> file and choose <strong class="screenText">Build</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B22428_01_14.png" alt="" width="643" height="268"/></figure>
    <p class="packt_figref">Figure 1.14: Build the project in Visual Studio 2022</p>
    <ol>
      <li class="numberedList" value="5">After the compilation succeeds, start the program in a non-debug build by using the unfilled green arrow:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B22428_01_15.png" alt="" width="834" height="208"/></figure>
    <p class="packt_figref">Figure 1.15: Start the compiled program without debugging in Visual Studio 2022</p>
    <p class="normal">If you are a Linux user, you can follow the explanation in the following section to get all the tools and libraries onto your system.</p>
    <h2 id="_idParaDest-27" class="heading-2">Installing the required tools and libraries for Linux</h2>
    <p class="normal">Modern Linux distributions already contain most of the tools needed to compile the example code for the book.</p>
    <h3 id="_idParaDest-28" class="heading-3">Downloading Open Asset Import Library</h3>
    <p class="normal">For the common Linux distributions, Assimp should be available from the package manager. For Ubuntu, you need to install the Assimp development package:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo apt install libassimp-dev
</code></pre>
    <h3 id="_idParaDest-29" class="heading-3">Installing a C++ compiler and the required libraries on Linux</h3>
    <p class="normal">If you use Ubuntu Linux, all required dependencies can be installed by using the integrated package manager. Use this command to install the packages for the OpenGL-based examples:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo apt install git gcc g++ cmake ninja-build
  libglew-dev libglm-dev libglfw3-dev zlib1g-dev
</code></pre>
    <p class="normal">To use Clang as a compiler, instead of GCC, you can use this command:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo apt install git llvm clang cmake ninja-build
  libglew-dev libglm-dev libglfw3-dev zlib1g-dev
</code></pre>
    <p class="normal">If you plan to build the Vulkan examples, these additional packages are required and should be installed to get the most out of the Vulkan code:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo apt install glslang-tools glslc libvulkan-dev vulkan-validationlayers
</code></pre>
    <p class="normal">If you want to use the latest Vulkan SDK instead of the Ubuntu version, you can download the package from the <strong class="screenText">LunarG</strong> website:</p>
    <p class="normal"><a href="https://vulkan.lunarg.com/sdk/home#linux"><span class="url">https://vulkan.lunarg.com/sdk/home#linux</span></a></p>
    <p class="normal">For other Linux distributions, the package manager and the names of the packages may differ. For instance, on an Arch-based system, this command line will install all required packages to build the OpenGL examples:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo pacman -S git cmake gcc ninja glew glm glfw assimp zlib
</code></pre>
    <p class="normal">For the Vulkan examples, these additional packages are required on Arch-based installations:</p>
    <pre class="programlisting con"><code class="hljs-con">sudo pacman –S vulkan-devel glslang
</code></pre>
    <h3 id="_idParaDest-30" class="heading-3">Compiling the examples via the command line on Linux</h3>
    <p class="normal">The examples can be compiled directly on the command line, without using an IDE or editor. To build a single example, change into the chapter and example subfolders of the folder containing the cloned repository, create a new subfolder named <code class="inlineCode">build</code>, and change into the new subfolder:</p>
    <pre class="programlisting con"><code class="hljs-con">$ cd chapter01/01_assimp_opengl
$ mkdir build &amp;&amp; cd build
</code></pre>
    <p class="normal">To compile all examples at once, create the <code class="inlineCode">build</code> folder in the top-level folder of the example code and then change into the new subfolder.</p>
    <p class="normal">Then, run CMake to create the files required to build the code with the <code class="inlineCode">ninja</code> build tool:</p>
    <pre class="programlisting con"><code class="hljs-con">$ cmake -G Ninja ..
</code></pre>
    <p class="normal">The two dots at the end are needed; CMake needs the path to the <code class="inlineCode">CMakeLists.txt</code> file.</p>
    <p class="normal">If you build a single example, let <code class="inlineCode">ninja</code> compile the code and run the generated executable file:</p>
    <pre class="programlisting con"><code class="hljs-con">$ ninja &amp;&amp; ./Main
</code></pre>
    <p class="normal">If all the required tools and libraries are installed and the compilation is successful, an application window should open.</p>
    <p class="normal">When building all examples at once, a new folder named <code class="inlineCode">bin</code> will be created inside the top-level folder, containing a subfolder for every chapter and in every chapter’s folder the two subfolders for the two examples of that chapter, similar to the source-code structures.</p>
    <p class="normal">In case of build errors, you need to check the requirements again.</p>
    <p class="normal">If you want to use an IDE, you can continue with the installation of Eclipse.</p>
    <h3 id="_idParaDest-31" class="heading-3">Installing Eclipse on Linux</h3>
    <p class="normal">If you want to compile the example code with the Eclipse IDE on Linux, some extra steps are required:</p>
    <ol>
      <li class="numberedList" value="1">Download and install <strong class="screenText">Eclipse IDE for C/C++ Developers</strong> from <a href="https://www.eclipse.org/downloads/packages/"><span class="url">https://www.eclipse.org/downloads/packages/</span></a>.</li>
      <li class="numberedList">After installing Eclipse, head to the marketplace under <strong class="screenText">Help</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B22428_01_16.png" alt="A screenshot of a computer  Description automatically generated" width="705" height="106"/></figure>
    <p class="packt_figref">Figure 1.16: Accessing the Eclipse marketplace</p>
    <ol>
      <li class="numberedList" value="3">Install the <strong class="screenText">cmake4eclipse</strong> and <strong class="screenText">CMake Editor</strong> packages. The first one enables CMake support in Eclipse, with all the features we need, and the second one adds syntax coloring to the CMake files. The extra colors make it more convenient to edit the files:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B22428_01_17.png" alt="" width="1514" height="677"/></figure>
    <p class="packt_figref">Figure 1.17: Installing the CMake Editor and cmake4eclipse</p>
    <p class="normal">Compiling and starting the example code can be done in the following steps:</p>
    <ol>
      <li class="numberedList" value="1">Select <strong class="screenText">Open Project from File System</strong> from the <strong class="screenText">File</strong> menu.</li>
      <li class="numberedList">Choose <strong class="screenText">Directory...</strong> and navigate to the folder with the source code:<ul>
          <li class="bulletList level-2">If you want to build all examples at once, select the top-level source folder, press <strong class="screenText">Deselect All</strong>, and select only the first project.</li>
          <li class="bulletList level-2">To build only a single example, you can either use <strong class="screenText">Deselect All</strong> on the top-level folder and select only the example you want to build, or you can descend into the folder for the specific example.</li>
        </ul>
      </li>
      <li class="numberedList">Click on <strong class="screenText">Finish</strong> to open the project.</li>
      <li class="numberedList">Next, choose <strong class="screenText">Build Project</strong> from the context of the project folder.</li>
      <li class="numberedList">You may need to switch the console output to show the current build messages. Use the small arrow with the tooltip <strong class="screenText">Display Selected Console</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B22428_01_18.png" alt="" width="1044" height="272"/></figure>
    <p class="packt_figref">Figure 1.18: Selecting the right output to see the build messages</p>
    <ol>
      <li class="numberedList" value="6">If Eclipse does not refresh the project content after the build, choose <strong class="screenText">Refresh</strong> from the context menu of the project folder, or press <em class="italic">F5</em>.</li>
      <li class="numberedList">Choose <strong class="screenText">Run As</strong>, and select the second option, <strong class="screenText">Local C/C++ application</strong>.</li>
      <li class="numberedList">Select the <strong class="screenText">Main</strong> executable from the window to run the program.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B22428_01_19.png" alt="" width="904" height="1056"/></figure>
    <p class="packt_figref">Figure 1.19: Choosing the Main executable to run the compiled application</p>
    <p class="normal">As the last step of the preparations, we look at the organization of the code in the GitHub repository of the book.</p>
    <h2 id="_idParaDest-32" class="heading-2">Code organization in this book</h2>
    <p class="normal">The code for every chapter is stored in the GitHub repository, in a separate folder with the relevant chapter number. The number uses two digits to get the ordering right. Inside each folder, one or more subfolders can be found. These subfolders contain the code of the chapter, depending on the progress of that specific chapter.</p>
    <p class="normal">For all chapters, we put the <code class="inlineCode">Main.cpp</code> class and the CMake configuration file, <code class="inlineCode">CMakeLists.txt</code>, into the project root folder. Inside the <code class="inlineCode">cmake</code> folder, helper scripts for CMake are stored. These files are required to find additional header and library files.</p>
    <p class="normal">All C++ classes are located inside folders, collecting the classes of the objects we create. The <code class="inlineCode">Window</code> class will be stored in the <code class="inlineCode">window</code> subfolder to hold all files related to the class itself, and the same applies to tools – the logger, the model classes, and the renderer-related classes. After you have all the required code and tools installed, let’s get a general idea of what game character animations are about.</p>
    <h1 id="_idParaDest-33" class="heading-1">Animating game characters – a primer</h1>
    <p class="normal">Moving a game character around in a virtual world with lots of different animations, changeable outfits, a collision detection system for other characters and the environment, and maybe even interaction with other characters looks nice and simple when playing a game.</p>
    <p class="normal">But the mathematics and techniques behind the smoothly animated game characters are extensive and complex. Every <a id="_idIndexMarker000"/>movement, animation, action, or state change of the character involves a long journey until the final image is rendered to the screen.</p>
    <p class="normal">Let’s look at a high-level explanation of animations first. If you already know the details, you can skip to the next section.</p>
    <h2 id="_idParaDest-34" class="heading-2">About nodes, bones, skeletal animation, and skinning</h2>
    <p class="normal">The building blocks of an animated three-dimensional character model are the so-called <strong class="keyWord">nodes</strong>. A node can be compared to<a id="_idIndexMarker001"/> a joint in the virtual body of the character, like the<a id="_idIndexMarker002"/> shoulder or hip.</p>
    <p class="normal">All nodes in the character model are connected in the form of a virtual skeleton, forming the <strong class="keyWord">bones</strong> of the model. By attaching <a id="_idIndexMarker003"/>child nodes to a node, modeling an arm with a <a id="_idIndexMarker004"/>hand and fingers, or a leg with a foot and toes – or even an entire human-like skeleton – is no problem. The starting point of the virtual skeleton is the so-called root node. The root node<a id="_idIndexMarker005"/> has no parent node and is used as the starting point for animations.</p>
    <p class="normal">Usually, the level of detail does not reach the details of a skeleton in a real-world object since many of the real bones are static or play only a minor role in muscle or pose changes during animation.</p>
    <p class="normal">The virtual skeleton of the character model can be animated by rotating nodes around their center point – and thus rotating the bone to all attached child nodes around the center point of this node. Just imagine raising your arm a bit: your upper arm will rotate around your shoulder joint, and the lower arm, hand, and finger<a id="_idIndexMarker006"/> follow the shoulder rotation. This kind of animation is called a <strong class="keyWord">skeletal animation</strong>.</p>
    <p class="normal">A character needs to be stored in a more or less natural pose in the file, which is called the reference pose, or <strong class="keyWord">bind pose</strong>. You will <a id="_idIndexMarker007"/>find most models in a <strong class="keyWord">T-pose</strong> where both arms create a horizontal line, and sometimes see the <strong class="keyWord">A-pose</strong>, where the position of the arms of the skeleton resembles <a id="_idIndexMarker008"/>the uppercase <a id="_idIndexMarker009"/>letter A.</p>
    <p class="normal">To animate a character, the transforms of each node between the position in the bind pose and the desired position in an animation pose need to be changed. Since the transformation of a node needs to be calculated in the local <a id="_idIndexMarker010"/>coordinates of that specific node, an <strong class="keyWord">inverse bind matrix</strong> per node <a id="_idIndexMarker011"/>exists to transform between local and world coordinates.</p>
    <p class="normal">The animations themselves are <a id="_idIndexMarker012"/>stored in animation <strong class="keyWord">clips</strong>. An animation clip does not contain node transforms for every possible time of the animation but only for specific time points. Only the node transforms at<a id="_idIndexMarker013"/> so-called <strong class="keyWord">key frames</strong> are stored in the animation clip data, resulting in less data usage. Node positions between two key frames are interpolated using linear interpolation for translation and scaling, and spherical linear interpolation (SLERP) for rotations.</p>
    <p class="normal">By using interpolation between two key frames, the skeleton can be brought into virtually any pose between the two stored poses. By interpolating between key frames or even interpolated poses of different animation clips, <strong class="keyWord">blending</strong> between the two poses can be achieved, Blending can be used to change the<a id="_idIndexMarker014"/> animation clip of a model without visual distortion, for instance, to create a smooth transition between a walking and a running animation clip.</p>
    <p class="normal">The virtual skin of a character <a id="_idIndexMarker015"/>model is called a <strong class="keyWord">mesh</strong>, and applying a mesh to a skeleton in the vertex shader of the <a id="_idIndexMarker016"/>rendering pipeline is called <strong class="keyWord">skinning</strong>. To give the virtual skin a natural appearance, every vertex<a id="_idIndexMarker017"/> of the mesh uses <strong class="keyWord">weights</strong> to handle the influence of surrounding nodes.</p>
    <p class="normal">These weights are used as a factor for node transforms: the higher the node weight, the more transforms of that node will be applied to the vertex, and vice versa. By using the node weights, the effects of expanding and compressing the skin and underlying muscles of the virtual body can be modeled with good precision.</p>
    <p class="normal">In the glTF file format, four weights per vertex are used, but other file formats with more weights also exist.</p>
    <p class="normal">There is a special kind of animation <a id="_idIndexMarker018"/>called a <strong class="keyWord">morph animation</strong>. In a morph animation, parts of a mesh are replaced, and the vertex positions can be interpolated between the different meshes. Morph animations are used to model facial expressions, updating only parts of a character model’s face instead of the entire model. By replacing only parts of the mesh but keeping the skeletal information unchanged, morph animations can be easily added to skeletal animations.</p>
    <p class="normal">Another form of animation is the so-called <strong class="keyWord">additive animation</strong>. Additive animations are some sort of mix between skeletal and morph <a id="_idIndexMarker019"/>animations: by adding the difference between the current pose and the bind pose to the skeletal animation clip, the animations of the additive clip are modeled on top of the skeletal animation, but only for the nodes that are changed in the additive animation clip.</p>
    <p class="normal">Additive animations are used to move only specific parts of a character independently of the main skeletal animation. For instance, the skeletal animation contains only the walking or running part of the body, while the additive animation clip changes only the head or hands. Now the character can move the head to look around, without the need to create walking and running animations containing all possible head movements.</p>
    <p class="normal">The combination of skeletal, morph, and additive animation enables us to build powerful and natural-looking characters for our virtual world, allowing the model to walk or run beside us, follow our movements with the head, and use facial morph animations to speak all at the same time.</p>
    <p class="normal">Now let us look at the general <a id="_idIndexMarker020"/>workflow for creating character model animations. We can divide the animation workflow into two parts: preparation and updates. While the preparation part is needed only once while loading the model, updates are usually made for every frame drawn to the screen.</p>
    <p class="normal">We will dive into the preparation process of the model first.</p>
    <h2 id="_idParaDest-35" class="heading-2">Preparing the data for efficient usage</h2>
    <p class="normal">Game character models are <a id="_idIndexMarker021"/>stored in single files, or as a collection of files, each for a specific purpose. For instance, model and texture data could reside in separate files, allowing artists to change the images independently of the model vertices.</p>
    <p class="normal">The following steps must be done in the application before the file in the model data can be used for animation and rendering:</p>
    <ol>
      <li class="numberedList" value="1">As the first step in the preparation phase, these files must be loaded into the memory of the computer. Depending on the implementation in the game, partial loading is possible, adding only the elements of the character model that are needed at a specific level, or in a specific part of the virtual world.</li>
      <li class="numberedList">Then, the data needs to be pre-processed. The representation of the data in the files on disk may be optimized in terms of saving space, but for efficient manipulation and rendering, a different kind of optimization is required.</li>
    </ol>
    <p class="normal-one">For example, different rendering APIs, like OpenGL, Vulkan, and DirectX, may need slightly different representations of vertex or texture data, or shader code to be uploaded to the GPU. Instead of storing the different versions in the model file, a generic representation may be used. The required adjustments or conversions will be done after loading.</p>
    <ol>
      <li class="numberedList" value="3">As the last step, static data like vertex data or textures will be uploaded to the GPU, and other static and variable data parts are stored in C++ classes and objects.</li>
    </ol>
    <p class="normal">At this point, the model is ready to use. With the first appearance of that character on the screen, a continuously running task of data updates is needed. These per-frame tasks are required for states that change at runtime, such as positions or animation poses.</p>
    <h2 id="_idParaDest-36" class="heading-2">Updating character data</h2>
    <p class="normal">Since the data of the character is split between main memory and GPU memory, the game or animation program must sample, extract, convert, and upload data for every single frame the character is drawn to the screen.</p>
    <p class="normal">For instance, the key-frame <a id="_idIndexMarker022"/>data of the animations needs to be updated according to the animation clip to be shown and the time since the last frame.</p>
    <p class="normal">The following steps must be done in every frame to create the pixels of a single model instance for a specific time point of a selected animation clip:</p>
    <ol>
      <li class="numberedList" value="1">Blending between different animation clips could be requested by the program flow, and additional animation parts may be needed, like additive blending for the head or the hands, or facial animations to allow a facial expression for the character. So, we extract rotation, translation, and scaling for all nodes at the specified replay time from all animation clips and combine the per-clip node transformsations into a final transformation matrix for every node.</li>
      <li class="numberedList">After the animation data is sampled and combined, the skeleton of the character needs to be adjusted. According to the animation data, every virtual bone must be translated, rotated, and scaled to reach the desired destination.</li>
      <li class="numberedList">Also, the world position of the character may need to be updated. World position changes can occur in different forms, like running around, jumping, or falling down. Knowing the exact position of all characters is an important part of the remaining steps.</li>
      <li class="numberedList">Once bone positions and the world position of the character have been determined, collision detection can run. The collision detection checks if the character intersects with other characters or environmental objects like the floor and walls, or even if the character was hit by a projectile. As a reaction to the collision detection results, adjustments to the character properties, like position, or animation clip may be triggered.</li>
      <li class="numberedList">Having the collision data at hand, inverse kinematics adjustments may run. Adjusting the skeleton data of the character could be needed to avoid character limbs intersecting with the wall or the floor, or to level the feet position on uneven ground.</li>
      <li class="numberedList">Now, the pure CPU part of the character update is nearly over. As a final step from the CPU side, the updated animation data is uploaded to the GPU and the render commands are issued. By storing the dynamic character data in the GPU, the rendering itself can run without much additional workload from the CPU.</li>
      <li class="numberedList">On the GPU, the vertex shader transforms the incoming vertex data according to the properties of the current view, like distances or perspective distortion. After other possible shader stages, the fragment shader receives the data from the rasterization stage of the GPU and draws the pixels to the output framebuffer.</li>
      <li class="numberedList">After all pixels of the level data, characters, and the HUD, as well as maybe additional debug data, have been sent to the GPU, the visible and the drawing buffers are swapped – at this point, the character appears on the screen, at the position and in the animated pose we expect to see.</li>
    </ol>
    <p class="normal">In between all these update steps, compute shaders may run on the GPU to calculate data. Running compute shaders allows the program to offload the calculations for multiple characters, freeing the CPU to work on other parts of the game.</p>
    <p class="normal">As you can see, a lot of work is needed until you see a game character running around in the virtual world. Let’s now start the<a id="_idIndexMarker023"/> journey into character animation with an overview of Open Asset Import Library.</p>
    <h1 id="_idParaDest-37" class="heading-1">What is Open Asset Import Library?</h1>
    <p class="normal"><strong class="keyWord">Open Asset Import Library</strong>, in short <strong class="keyWord">Assimp</strong>, is a cross-platform library to import and convert 3D model files. The different file <a id="_idIndexMarker024"/>formats are converted into a hierarchical data structure, enabling a programmer to support a wider range of model formats in a single, comprehensive way.</p>
    <p class="normal"><em class="italic">Figure 1.20</em> shows the key elements and their relationships:</p>
    <figure class="mediaobject"><img src="../Images/B22428_01_20.png" alt="" width="1650" height="881"/></figure>
    <p class="packt_figref">Figure 1.20: A simplified version of Assimp’s data structures</p>
    <p class="normal">Let us take a closer look at these data structures and their functions:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">aiScene</code> is the central element of Assimp’s data structure. The root node entry, all information about the polygonal meshes, the materials, and the animations are stored in the <code class="inlineCode">aiScene</code> element.</li>
      <li class="bulletList">The root node of <code class="inlineCode">aiScene</code> points to a structure called <code class="inlineCode">aiNode</code>. In every <code class="inlineCode">aiNode</code>, possible child nodes are stored, eventually creating a node tree. Also, a transform matrix resides in the <code class="inlineCode">aiNode</code> structure, defining the local transformation, relative to the parent node. This matrix is called the TRS matrix for the three possible transformations: translation, rotation, and scale, in this order. By combining the TRS transforms from the root node down to every node of the skeleton, the final world position of a node can be calculated only by using the world position of the root node and the local transformations of every node in the skeleton hierarchy.</li>
      <li class="bulletList">The node name is used in other structs, like the bones or the animations, to refer back to this specific node. For the vertices of the node, an index to the corresponding <code class="inlineCode">aiMesh</code> structure in <code class="inlineCode">aiScene</code> is stored here.</li>
      <li class="bulletList">All data that will be<a id="_idIndexMarker025"/> drawn on the screen is stored in <code class="inlineCode">aiMesh</code> structs. Every mesh consists of a number of so-called faces, usually triangles. For every vertex of every face, important data like the vertices, normals, and texture coordinates are stored directly in <code class="inlineCode">aiMesh</code>. The drawing order of the vertices is stored separately as indices in the other structures, allowing features like space-saving reuse of vertices.</li>
      <li class="bulletList">For animations, the model “skeleton” consists of bones, stored in <code class="inlineCode">aiBone</code> structs. Here, the offset matrix defines the offset between the position in mesh space and the bind pose in bone space (in the glTF file format, this is the “inverse bind matrix”). Additionally, ,several value pairs are stored for every vertex, each containing a node index and a weight value. In every pair, the weight value specifies the fraction of the nodes movement that is applied to the vertex.</li>
      <li class="bulletList">The position of every vertex in the <code class="inlineCode">Assimp</code> meshes can be bound to up to four bones, and the influence of each of these four bones on the final vertex position can be controlled by a weight value between <code class="inlineCode">0</code> and <code class="inlineCode">1</code>. The weight is used as a scaling factor for the transformations of the specified bone – a value of <code class="inlineCode">1</code> means that the vertex makes the same transformations as the bone, and for a value of <code class="inlineCode">0</code>, the vertex ignores the transforms of the bone.</li>
      <li class="bulletList">On the right side of <em class="italic">Figure 1.20</em>, the data for animations is shown. The <code class="inlineCode">aiAnimation</code> struct contains the animation channels for bones and meshes, the overall duration of the specific animation, and the number of frames per second for this animation.</li>
      <li class="bulletList">As an example for the animations, we will look at the <code class="inlineCode">aiNodeAnim</code> struct. This struct consists of key frames with rotations, translations, or scales to apply to a specific node. The node name in the <code class="inlineCode">aiNode</code> struct is used to find the corresponding bone to animate.</li>
    </ul>
    <p class="normal">Currently, more than 50 different file formats are known to Assimp. Some notable examples are listed here:</p>
    <ul>
      <li class="bulletList">Autodesk 3D Studio (<code class="inlineCode">.3ds</code>), AutoCAD (<code class="inlineCode">.dxf</code>), and FBX (<code class="inlineCode">.fbx</code>)</li>
      <li class="bulletList">Collada (<code class="inlineCode">.dae</code>) and glTF (<code class="inlineCode">.gltf</code> and <code class="inlineCode">.glb</code>), managed by the Khronos Group</li>
      <li class="bulletList">Wavefront vertices (<code class="inlineCode">.obj</code>) plus materials (<code class="inlineCode">.mat</code>)</li>
      <li class="bulletList">STL files, mostly known from 3D printing (<code class="inlineCode">.stl</code>)</li>
      <li class="bulletList">Game engine formats, i.e., from Quake (<code class="inlineCode">.md3</code>/<code class="inlineCode">.md5</code>), or Half-Life (<code class="inlineCode">.mdl</code>)</li>
    </ul>
    <p class="normal">Even though the number of formats is impressive, it needs to be stated that not all models you find can be imported into the application by using <code class="inlineCode">Assimp</code>.</p>
    <p class="normal">Several of these file formats are reverse-engineered from closed source applications, and only a subset of versions work. Other formats are open source, like Collada or glTF, but some of those formats are also constantly evolving. Also, not all new features have yet been implemented in <code class="inlineCode">Assimp</code>. So, even with a versatile asset import library like <code class="inlineCode">Assimp</code>, you may end up with a model that fails to be imported, produces “vertex garbage” on screen, or is missing some of its properties. Nevertheless, <code class="inlineCode">Assimp</code> is currently the best open source solution to load many different game and non-game 3D <a id="_idIndexMarker026"/>models into your own application.</p>
    <p class="normal">Loading a model file with <code class="inlineCode">Assimp</code> boils down to importing the <code class="inlineCode">aiScene</code> object of a file, checking for the existence of other data types, and importing that data into the application. In the next section, we will do a short walk-through of the steps to load a model file with <code class="inlineCode">Assimp</code>.</p>
    <p class="normal">The complete source code for the application can be found in the folder <code class="inlineCode">chapter01</code>, the subfolder <code class="inlineCode">01_opengl_assimp</code> for OpenGL, and the subfolder <code class="inlineCode">02_vulkan_assimp</code> for Vulkan.</p>
    <h1 id="_idParaDest-38" class="heading-1">Loading a model file</h1>
    <p class="normal">To load a model file with Open Asset Import Library, we must include the following three headers in the implementation file of <a id="_idIndexMarker027"/>the <code class="inlineCode">AssimpModel</code> model loading class in the <code class="inlineCode">model</code> folder:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">#</span><span class="hljs-keyword">include</span><span class="hljs-meta"> </span><span class="hljs-string">&lt;assimp/scene.h&gt;</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">include</span><span class="hljs-meta"> </span><span class="hljs-string">&lt;assimp/Importer.hpp&gt;</span>
<span class="hljs-meta">#</span><span class="hljs-keyword">include</span><span class="hljs-meta"> </span><span class="hljs-string">&lt;assimp/postprocess.h&gt;</span>
</code></pre>
    <p class="normal">Next, we create an <code class="inlineCode">Assimp::Importer</code> instance in the <code class="inlineCode">loadModel()</code> method, and use the importer to load a file from disk:</p>
    <pre class="programlisting code"><code class="hljs-code">  Assimp::Importer importer;
  <span class="hljs-type">const</span> aiScene *scene = importer.<span class="hljs-built_in">ReadFile</span>(modelFilename,
   aiProcess_Triangulate | aiProcess_GenNormals);
</code></pre>
    <p class="normal">We hand over the file name of the asset file we want to load, plus the two values <code class="inlineCode">aiProcess_Triangulate</code> and <code class="inlineCode">aiProcess_GenNormals</code> as optional postprocessing flags.</p>
    <p class="normal">The first flag, <code class="inlineCode">aiProcess_Triangulate</code>, instructs <code class="inlineCode">Assimp</code> to triangulate all polygons with more than three vertices, if those polygons exist in the file. Since our basic renderer only understands triangles, a polygon with more than three vertices would cause graphical errors.</p>
    <p class="normal">Using <code class="inlineCode">aiProcess_GenNormals</code> as the import flag ensures that all triangles have normal vectors. Default normal vectors pointing upward from the surface of the triangle will be created only if no normal vector is found. Existing normals are not changed by the flag.</p>
    <p class="normal">Next, we must check if the import was successful:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">if</span>(!scene || scene-&gt;mFlags &amp; AI_SCENE_FLAGS_INCOMPLETE ||
      !scene-&gt;mRootNode) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
</code></pre>
    <p class="normal">We assume a failed import if the scene pointer itself is a <code class="inlineCode">nullptr</code>, the scene is marked as incomplete by the importer, or the scene has no root node defined.</p>
    <p class="normal">After the model file has been<a id="_idIndexMarker028"/> loaded successfully, we will scan the model for embedded textures.</p>
    <h2 id="_idParaDest-39" class="heading-2">Loading embedded textures</h2>
    <p class="normal">Some model formats can <a id="_idIndexMarker029"/>embed the textures into the object file. If the function call to <code class="inlineCode">HasTextures()</code> returns <code class="inlineCode">true</code>, we loop over all textures of the model file.</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">if</span> (scene-&gt;<span class="hljs-built_in">HasTextures</span>()) {
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> numTextures = scene-&gt;mNumTextures;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; scene-&gt;mNumTextures; ++i) {
</code></pre>
    <p class="normal">Inside the loop, we extract the texture name, height, and width, as well as the pixel data of the texture. The texture name is only for information purposes, since the data is embedded into the model file, but having the name is helpful while debugging problems:</p>
    <pre class="programlisting code"><code class="hljs-code">      std::string texName =
        scene-&gt;mTextures[i]-&gt;mFilename.<span class="hljs-built_in">C_Str</span>();
      <span class="hljs-type">int</span> height = scene-&gt;mTextures[i]-&gt;mHeight;
      <span class="hljs-type">int</span> width = scene-&gt;mTextures[i]-&gt;mWidth;
      aiTexel* data = scene-&gt;mTextures[i]-&gt;pcData;
</code></pre>
    <p class="normal">Now, we create a shared pointer and try to import the texture data. If the import fails with an unexpected error, we stop loading the model:</p>
    <pre class="programlisting code"><code class="hljs-code">      std::shared_ptr&lt;Texture&gt; newTex =
        std::<span class="hljs-built_in">make_shared</span>&lt;Texture&gt;();
      <span class="hljs-keyword">if</span> (!newTex-&gt;<span class="hljs-built_in">loadTexture</span>(texName, data,
          width, height)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
</code></pre>
    <p class="normal">Embedded textures are references in the format <code class="inlineCode">*10</code> – a star plus the index number of the texture. So, we create the internal name and insert the shared pointer into a <code class="inlineCode">std::unordered_map</code>, mapping the texture name to our data object containing the texture data:</p>
    <pre class="programlisting code"><code class="hljs-code">      std::string internalTexName = <span class="hljs-string">"*"</span> + std::<span class="hljs-built_in">to_string</span>(i);
      mTextures.<span class="hljs-built_in">insert</span>({internalTexName, newTex});
  }
</code></pre>
    <p class="normal">In addition to any embedded textures, a placeholder texture will be added:</p>
    <pre class="programlisting code"><code class="hljs-code">  mPlaceholderTexture = std::<span class="hljs-built_in">make_shared</span>&lt;Texture&gt;();
  std::string placeholderTex = <span class="hljs-string">"textures/missing_tex.png"</span>;
  <span class="hljs-keyword">if</span> (!mPlaceholderTexture-&gt;<span class="hljs-built_in">loadTexture</span>(placeholderTex)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
</code></pre>
    <p class="normal">Placeholder textures for objects are common in many game engines, showing objects with missing textures, instead <a id="_idIndexMarker030"/>of a black object or random data from the GPU memory.</p>
    <h2 id="_idParaDest-40" class="heading-2">Parsing the node hierarchy</h2>
    <p class="normal">After checking for embedded <a id="_idIndexMarker031"/>textures, we continue by processing all nodes. Due to the hierarchical organization, we take a recursive approach here. As the first step, we create an object for the root node:</p>
    <pre class="programlisting code"><code class="hljs-code">  std::string rootNodeName = rootNode-&gt;mName.<span class="hljs-built_in">C_Str</span>();
  mRootNode = AssimpNode::<span class="hljs-built_in">createNode</span>(rootNodeName);
</code></pre>
    <p class="normal">An <code class="inlineCode">AssimpNode</code> object contains data about the position, rotation, and scaling of one of the model parts in the virtual world. This transformation data also includes the position, rotation, and scale of its parent node, moving all the nodes to their intended position.</p>
    <p class="normal">Then, this new root node will be used as the basis to collect all child nodes, grandchild nodes, and so on:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-built_in">processNode</span>(mRootNode, rootNode, scene, assetDirectory);
</code></pre>
    <p class="normal">Inside the <code class="inlineCode">processNode()</code> method, four tasks are done for every node:</p>
    <ul>
      <li class="bulletList">Collecting the mesh data itself, like vertex positions, normals, or texture coordinates</li>
      <li class="bulletList">Collecting external textures from materials</li>
      <li class="bulletList">Collecting bones for skeletal animations</li>
      <li class="bulletList">Descending into the hierarchy to process the child nodes of this node</li>
    </ul>
    <p class="normal">We start by iterating through all meshes of the node:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> numMeshes = aNode-&gt;mNumMeshes;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numMeshes; ++i) {
      aiMesh* modelMesh = scene-&gt;mMeshes[aNode-&gt;mMeshes[i]];
</code></pre>
    <p class="normal">The <code class="inlineCode">AssimpMesh</code> class contains the logic to extract vertex data, textures, and bones. We simply create a local <code class="inlineCode">mesh</code> instance and let the <code class="inlineCode">processMesh()</code> method do all the extraction work for us:</p>
    <pre class="programlisting code"><code class="hljs-code">      AssimpMesh mesh;
      mesh.<span class="hljs-built_in">processMesh</span>(modelMesh, scene, assetDirectory);
</code></pre>
    <p class="normal">After the Assimp mesh has been processed, we add the converted mesh data, the collected textures, and the bones to the data structures of the model itself:</p>
    <pre class="programlisting code"><code class="hljs-code">      mModelMeshes.<span class="hljs-built_in">emplace_back</span>(mesh.<span class="hljs-built_in">getMesh</span>());
      mTextures.<span class="hljs-built_in">merge</span>(mesh.<span class="hljs-built_in">getTextures</span>());
      std::vector&lt;std::shared_ptr&lt;AssimpBone&gt;&gt; flatBones =
        mesh.<span class="hljs-built_in">getBoneList</span>();
      mBoneList.<span class="hljs-built_in">insert</span>(mBoneList.<span class="hljs-built_in">end</span>(),
        flatBones.<span class="hljs-built_in">begin</span>(), flatBones.<span class="hljs-built_in">end</span>());
    }
  }
</code></pre>
    <p class="normal">Now, we store the current node in a node map and a node list:</p>
    <pre class="programlisting code"><code class="hljs-code">  mNodeMap.<span class="hljs-built_in">insert</span>({nodeName, node});
  mNodeList.<span class="hljs-built_in">emplace_back</span>(node);
</code></pre>
    <p class="normal">Saving the same node in two different data structures is needed to speed up the access during different phases of the program.</p>
    <p class="normal">The <code class="inlineCode">mNodeMap</code> contains the nodes in a <code class="inlineCode">std::unordered_map</code>, allowing us to access any node by its node name in constant time. But a huge disadvantage is that a <code class="inlineCode">std::unordered_map</code> does not preserve the insertion order by default. Using a <code class="inlineCode">std::map</code> would not help either since all entries of a <code class="inlineCode">std::map</code> will be sorted by the key in ascending order. We could solve the sorting issue by using a custom <a id="_idIndexMarker032"/>comparator function for the map, but since we are also accessing the nodes based on the index position, a second data structure will be used: the <code class="inlineCode">mNodeList</code>.</p>
    <p class="normal">In the <code class="inlineCode">mNodeList</code>, all nodes are stored in a flat but hierarchical order, guaranteeing us to access any of the nodes before its child nodes. This way, the <code class="inlineCode">mNodeList</code> is fast when it comes to updates that need to be done in all nodes. We can just iterate from start to end through the vector.</p>
    <p class="normal">At the end of <code class="inlineCode">processNode()</code>, we check for child nodes, and process any child nodes we find in a recursive manner:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> numChildren = aNode-&gt;mNumChildren;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numChildren; ++i) {
    std::string childName =
      aNode-&gt;mChildren[i]-&gt;mName.<span class="hljs-built_in">C_Str</span>();
    std::shared_ptr&lt;AssimpNode&gt; childNode =
      node-&gt;<span class="hljs-built_in">addChild</span>(childName);
    <span class="hljs-built_in">processNode</span>(childNode, aNod-&gt;mChildren[i],
      scene, assetDirectory);
  }
</code></pre>
    <p class="normal">After processing all nodes in the hierarchy, we have collected all meshes, textures, and skeletal data from the model.</p>
    <h2 id="_idParaDest-41" class="heading-2">Adding vertex buffers for the meshes</h2>
    <p class="normal">Back in the <code class="inlineCode">loadModel()</code> method, we create a combined vertex and index buffer object for every mesh, upload the extracted <a id="_idIndexMarker033"/>vertex data, and store the buffer in a <code class="inlineCode">std::vector</code> called <code class="inlineCode">mVertexBuffers</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> mesh : mModelMeshes) {
    VertexIndexBuffer buffer;
    buffer.<span class="hljs-built_in">init</span>();
    buffer.<span class="hljs-built_in">uploadData</span>(mesh.vertices, mesh.indices);
    mVertexBuffers.<span class="hljs-built_in">emplace_back</span>(buffer);
  }
</code></pre>
    <p class="normal">To draw the imported model, we can now simply iterate over the <code class="inlineCode">mModelMeshes</code> vector and use the <code class="inlineCode">drawIndirect()</code> call of the <code class="inlineCode">VertexIndexBuffer</code> class to draw all triangles of this specific mesh with only a single draw command. The method is called “indirect” because Assimp stores the model data internally as vertices plus indices, and we draw the triangles in the indirect mode, via the indices.</p>
    <p class="normal">In addition, an instanced version of the draw call is available, named <code class="inlineCode">drawIndirectInstanced()</code>. Instanced drawing allows us to draw several instances of the same mesh on different positions of the screen, but the workload of creating the extra triangles is done by the GPU, not the CPU.</p>
    <h2 id="_idParaDest-42" class="heading-2">Importing animations</h2>
    <p class="normal">As the last step of the<a id="_idIndexMarker034"/> model-loading process, we check for animations and iterate over the internal data structure of the animations in the model file:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> numAnims = scene-&gt;mNumAnimations;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numAnims; ++i) {
    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; animation = scene-&gt; mAnimations[i];
</code></pre>
    <p class="normal">For every animation we find, we create an object of the class <code class="inlineCode">AssimpAnimClip</code>, and add all channels of the current animation clip:</p>
    <pre class="programlisting code"><code class="hljs-code">    std::shared_ptr&lt;AssimpAnimClip&gt; animClip =
      std::<span class="hljs-built_in">make_shared</span>&lt;AssimpAnimClip&gt;();
    animClip-&gt;<span class="hljs-built_in">addChannels</span>(animation);
</code></pre>
    <p class="normal">Some models do not specify a name for the animation clip, so we set the name to the number of the clip if the name is empty:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> (animClip-&gt;<span class="hljs-built_in">getClipName</span>().<span class="hljs-built_in">empty</span>()) {
      animClip-&gt;<span class="hljs-built_in">setClipName</span>(std::<span class="hljs-built_in">to_string</span>(i));
    }
</code></pre>
    <p class="normal">Having distinctive clip names is a requirement for the UI to select the animations by name.</p>
    <p class="normal">Finally, we store the clips in the <code class="inlineCode">mAnimClips</code> vector:</p>
    <pre class="programlisting code"><code class="hljs-code">    mAnimClips.<span class="hljs-built_in">emplace_back</span>(animClip);
  }
</code></pre>
    <p class="normal">At this point, all relevant<a id="_idIndexMarker035"/> data of the model has been loaded, extracted, and converted. As stated at the end of the <em class="italic">What is Open Asset Import Library?</em> section, the quality of the imported data depends on various factors, particularly the compatibility with <code class="inlineCode">Assimp</code>.</p>
    <h2 id="_idParaDest-43" class="heading-2">Checking the code for all the details</h2>
    <p class="normal">You should take a look at the implementation of the other classes prefixed with “Assimp” in the <code class="inlineCode">model</code> folder, and the<a id="_idIndexMarker036"/> implementations of the extraction methods in these classes. In general, the methods simply read out the C-style data structures from <code class="inlineCode">Assimp</code>, constructing custom C++ classes. The data for the mesh is converted into GLM types, allowing us to do a simple upload to the GPU, instead of a time-consuming change at every draw.</p>
    <p class="normal">Now that we have the basics ready to open a model file, we run into a simple but essential problem: <em class="italic">The file name for the model file is hardcoded</em>.</p>
    <p class="normal">Rather than hardcode the path to our model file for loading, let’s add the ability to browse for a file. A simple way to load a specific model from a file into the application is with an “Open File” dialog, allowing us to choose the file we want to import. To achieve the seamless integration of such a dialog into the program, we will use an ImGui-based solution, instead of an OS-native dialog.</p>
    <h1 id="_idParaDest-44" class="heading-1">Extending the UI with an Open File dialog</h1>
    <p class="normal">ImGui can be used to create <a id="_idIndexMarker037"/>simple UIs like in our animation application, but the code can be also extended to build different <a id="_idIndexMarker038"/>kinds of tools. For our application, a dialog to choose a file on the system is helpful to load models at runtime, freeing us of hardcoding the model names in the code or using models as command-line parameters when starting the application.</p>
    <p class="normal">Various ImGui-based file dialogs exist; a nice and easy-to-integrate file dialog can be found in the GitHub repository of Stephane Cuillerdier at <a href="https://github.com/aiekick/ImGuiFileDialog"><span class="url">https://github.com/aiekick/ImGuiFileDialog</span></a>.</p>
    <p class="normal">For a simple integration of the file dialog, we will use CMake’s <code class="inlineCode">FetchContent</code> to download and build the code.</p>
    <h2 id="_idParaDest-45" class="heading-2">Integrating the file dialog into CMakeLists.txt</h2>
    <p class="normal">First, we add a<a id="_idIndexMarker039"/> new <code class="inlineCode">FetchContent</code> block into the <code class="inlineCode">CMakeLists.txt</code> file, right below the end of the ImGui fetching:</p>
    <pre class="programlisting code"><code class="hljs-code">FetchContent_Declare(
  filedialog
  GIT_REPOSITORY https://github.com/aiekick/ImGuiFileDialog
  GIT_TAG        v0.<span class="hljs-number">6.7</span>
  CONFIGURE_COMMAND <span class="hljs-string">""</span>
  <span class="hljs-keyword">BUILD_COMMAND</span> <span class="hljs-string">""</span>
)
</code></pre>
    <p class="normal">We “short-cut” the configure and build commands here, since we only want to have the source code available, instead of building a standalone version of the file dialog.</p>
    <p class="normal">Unfortunately, the initial configuration still needs the location of the ImGui headers. Since the <code class="inlineCode">FetchContent</code> block does not allow setting additional compiler options, we need a small hack to alter the value of the CMake property <code class="inlineCode">COMPILE_OPTIONS</code> during the fetch process.</p>
    <p class="normal">To do so, we save the<a id="_idIndexMarker040"/> current state of <code class="inlineCode">COMPILE_OPTIONS</code> in a new CMake variable called <code class="inlineCode">current_compile_options</code>. Then, we adjust the compile options to include the headers from the ImGui source folder in the search list:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">get_property</span>(current_compile_options DIRECTORY
  PROPERTY COMPILE_OPTIONS)
<span class="hljs-keyword">set_property</span>(DIRECTORY PROPERTY
  COMPILE_OPTIONS -I <span class="hljs-variable">${imgui_SOURCE_DIR}</span>)
</code></pre>
    <p class="normal">Now, we can trigger the download and initialization of the file dialog source:</p>
    <pre class="programlisting code"><code class="hljs-code">FetchContent_MakeAvailable(filedialog)
</code></pre>
    <p class="normal">To avoid further confusion in the build system, we set the <code class="inlineCode">COMPILE_OPTIONS</code> property back to its saved state, and also unset the variable we used to save the state:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">set_property</span>(DIRECTORY PROPERTY
  COMPILE_OPTIONS <span class="hljs-variable">${current_compile_options}</span>)
<span class="hljs-keyword">unset</span>(current_compile_options)
</code></pre>
    <p class="normal">In Visual Studio 2022, a new CMake configuration run is triggered automatically. In Eclipse, a new run of CMake must be triggered via the <strong class="screenText">Build Project</strong> option in the right-click context menu of the project.</p>
    <p class="normal">Including the functionality of the file dialog is easy; the UI class needs to be extended by only a couple of lines.</p>
    <h2 id="_idParaDest-46" class="heading-2">Using the ImGui file dialog</h2>
    <p class="normal">We can place the dialog<a id="_idIndexMarker041"/> code anywhere in the code of the <code class="inlineCode">createFrame()</code> method of the <code class="inlineCode">UserInterface</code> class in the <code class="inlineCode">UserInterface.cpp</code> file within<a id="_idIndexMarker042"/> the folder <code class="inlineCode">opengl</code>. First, we add an <code class="inlineCode">ImGui::Button</code> named <code class="inlineCode">"Import Model"</code>. This button will open a modal version of the dialog:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> (ImGui::<span class="hljs-built_in">Button</span>(<span class="hljs-string">"Import Model"</span>)) {
      IGFD::FileDialogConfig config;
      config.path = <span class="hljs-string">"</span><span class="hljs-string">."</span>;
      config.countSelectionMax = <span class="hljs-number">1</span>;
      config.flags = ImGuiFileDialogFlags_Modal;
      ImGuiFileDialog::<span class="hljs-built_in">Instance</span>()-&gt;<span class="hljs-built_in">OpenDialog</span>(
        <span class="hljs-string">"ChooseModelFile"</span>, <span class="hljs-string">"Choose Model File"</span>, <span class="hljs-string">".*"</span>,
        config);
    }
</code></pre>
    <p class="normal">This button configures a special <code class="inlineCode">FileDialogConfig</code> property of the file dialog. The <code class="inlineCode">config.path</code> entry sets the path to open to the current path where the executable was started, while <code class="inlineCode">countSelectionMax</code> tells <a id="_idIndexMarker043"/>the dialog to accept only a single file to be selected. Setting <code class="inlineCode">flags</code> to <code class="inlineCode">ImGuiFileDialogFlags_Modal</code> presents the file dialog on top of all other ImGui windows.</p>
    <p class="normal">When the flags are set, <code class="inlineCode">OpenDialog()</code> is called to open a dialog instance with the internal name <code class="inlineCode">"ChooseModelFile"</code> as the first parameter; the window title <code class="inlineCode">"Choose Model File"</code> as the second parameter; a filter to show all files, regardless of the file extensions, as the third parameter; and the configuration <a id="_idIndexMarker044"/>property as the last parameter.</p>
    <p class="normal">Setting the internal name of the dialog to open in the <code class="inlineCode">Display()</code> call allows us to define multiple open file dialogs, depending on the requirements of the program in the specific situation.</p>
    <p class="normal">Right after the button, the file dialog itself is defined:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> (ImGuiFileDialog::<span class="hljs-built_in">Instance</span>()-&gt;<span class="hljs-built_in">Display</span>(
        <span class="hljs-string">"</span><span class="hljs-string">ChooseModelFile"</span>)) {
      <span class="hljs-keyword">if</span> (ImGuiFileDialog::<span class="hljs-built_in">Instance</span>()-&gt;<span class="hljs-built_in">IsOk</span>()) {
      ...
      }
      ImGuiFileDialog::<span class="hljs-built_in">Instance</span>()-&gt;<span class="hljs-built_in">Close</span>();
    }
</code></pre>
    <p class="normal">The code for the file dialog follows the ImGui coding style. The first <code class="inlineCode">if</code> around the <code class="inlineCode">Display()</code> call returns <code class="inlineCode">true</code> if the dialog is shown, that is, after the above <code class="inlineCode">"Import Model"</code> button has been clicked. Then, the dialog code reacts by setting <code class="inlineCode">IsOk()</code> to <code class="inlineCode">true</code> after the <code class="inlineCode">"OK"</code> button of the dialog has been clicked, allowing us to insert actions to take on the selected file. The final <code class="inlineCode">Close()</code> call closes the dialog when a file has been selected.</p>
    <p class="normal">Before we check the return value of the file dialog, we take a look at the file extension filter. Showing all files could make it difficult to find the file we want to load.</p>
    <h2 id="_idParaDest-47" class="heading-2">Adding a filter to show only supported file types</h2>
    <p class="normal">The <code class="inlineCode">filter</code> field of the file dialog <a id="_idIndexMarker045"/>allows quite complex configurations, but we will check only three of them: a single filter, a group of extensions, and a regular expression-style filter.</p>
    <h3 id="_idParaDest-48" class="heading-3">Adding a single filter</h3>
    <p class="normal">The code in the <em class="italic">Using the ImGui file dialog</em> section already shows a single filter:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">".*"</span>
</code></pre>
    <p class="normal">This filter simply means “anything after the<a id="_idIndexMarker046"/> last dot of the file name,” so you will see all the visible files in the current folder.</p>
    <p class="normal">You can also specify a single extension here, and only files with this one extension are shown:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">".jpg"</span>
</code></pre>
    <div class="note">
      <p class="normal">Note on case sensitivity</p>
      <p class="normal">In Linux, filtering is case sensitive.</p>
      <p class="normal">So, the <code class="inlineCode">.jpg</code> filter will <em class="italic">not</em> show a file named <code class="inlineCode">IMAGE.JPG</code>!</p>
    </div>
    <h3 id="_idParaDest-49" class="heading-3">Adding a group of filters</h3>
    <p class="normal">Grouping file extensions into a single filter works by separating them with a comma:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">".jpg,.jpeg,.png"</span>
</code></pre>
    <p class="normal">However, this may not work<a id="_idIndexMarker047"/> as intended – you can still choose only one extension from the group, showing only files with the specific extension in the current folder. Allowing only one file extension from a group can be used for <strong class="screenText">Save File</strong> dialogs, forcing the user to choose a specific file format from a list of available formats.</p>
    <h3 id="_idParaDest-50" class="heading-3">Adding a regular expression-style filter</h3>
    <p class="normal">The most useful variant for the<a id="_idIndexMarker048"/> filter is the regular expression style:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">"Supported Types{.gltf,.glb,.obj,.fbx,.dae}"</span>
</code></pre>
    <p class="normal">Here, the string <code class="inlineCode">"Supported Types"</code> will be shown as a filter in the dialog, and all files with the file extension named in the curly braces are shown.</p>
    <p class="normal">You could also add multiple regular expression filters, separated by commas, to create a drop-down list of various file types. This line would enable you to choose between a couple of pictures, the textual and binary glTF formats, and all files:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">"Pictures{.jpg,.png},Models{.gltf,.glb},All Files{.*}"</span>
</code></pre>
    <p class="normal">Since the filter field of the <code class="inlineCode">OpenDialog()</code> call is a pointer to a character array, the filter list could even be created dynamically. Depending on the state of the program, the file types you want the user to select, and so on, you can present various filter options.</p>
    <p class="normal">Having the file dialog open with a (possibly limited) amount of file types presented to the user, let’s complete the code handling the file selected by the user.</p>
    <h2 id="_idParaDest-51" class="heading-2">Loading the model file</h2>
    <p class="normal">If a file was selected and the <code class="inlineCode">OK</code> button was pressed, or the file name was double-clicked, the name including the full <a id="_idIndexMarker049"/>path of the chosen file is available by calling <code class="inlineCode">GetFilePathName()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  std::string filePathName =
    ImGuiFileDialog::<span class="hljs-built_in">Instance</span>()-&gt;<span class="hljs-built_in">GetFilePathName</span>();
</code></pre>
    <p class="normal">For a clear separation of concerns, the UI code does not handle the loading process itself. Instead, a simple lambda-based callback is created, and we call this callback with the name of the model:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">if</span> (modInstData.<span class="hljs-built_in">miModelAddCallbackFunction</span>(
      filePathName)) {
    ...
  }
</code></pre>
    <p class="normal">The callback to add a new model is defined in the file <code class="inlineCode">ModelAndInstanceData.h</code> in the <code class="inlineCode">model</code> folder:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">using</span> modelAddCallback = std::function&lt;<span class="hljs-built_in">bool</span>(std::string)&gt;;
</code></pre>
    <p class="normal">During initialization of the renderer, the callback function is bound to the method <code class="inlineCode">addModel()</code> of the renderer class via a lambda:</p>
    <pre class="programlisting code"><code class="hljs-code">  mModelInstData.miModelAddCallbackFunction =
    [<span class="hljs-keyword">this</span>](std::string fileName) {
     <span class="hljs-keyword">return</span> <span class="hljs-built_in">addModel</span>(fileName);
   };
</code></pre>
    <p class="normal">Now, when a file has been selected, the renderer is doing all the “dirty work” of importing the new model, signaling back if the model import was successful.</p>
    <p class="normal">Right now, the return value of the callback only adjusts the position in the list of models. But it could be used to give feedback to the user – an error message popup can be presented if the model file could not be opened, or the same model file was already loaded.</p>
    <h2 id="_idParaDest-52" class="heading-2">Drawing the model to the screen</h2>
    <p class="normal">The process of drawing the<a id="_idIndexMarker050"/> model in the renderer is simple:</p>
    <ul>
      <li class="bulletList">Get the smart pointer that points to the <code class="inlineCode">Assimp</code> model.</li>
      <li class="bulletList">If the model is animated, update the animation with the delta time between the last frame and this frame, and collect the new bone matrices.</li>
      <li class="bulletList">If the model is not animated, simply get the node matrices of the instances.</li>
      <li class="bulletList">Upload the matrix data to the shader storage buffer on the shader.</li>
      <li class="bulletList">Issue a draw call to the graphics API.</li>
    </ul>
    <p class="normal">The custom classes handle all other steps required to draw the model, like uploading the vertex data or binding the correct texture for the mesh to draw next.</p>
    <p class="normal">Loading and drawing a single file is already cool. But to use the full power of <code class="inlineCode">Assimp</code>, we will allow adding and deleting different models and model instances at program runtime.</p>
    <h1 id="_idParaDest-53" class="heading-1">Adding and removing model instances dynamically</h1>
    <p class="normal">Supporting multiple instances from multiple models was done by creating the class <code class="inlineCode">AssimpInstance</code> in the <code class="inlineCode">model</code> folder. Every <code class="inlineCode">AssimpInstance</code> contains a smart pointer to access its base model, including the nodes and bones. Adding multiple instances of the same model requires one of two options to handle nodes and bones: using a copy of the node data structures in every instance or <a id="_idIndexMarker051"/>sharing the model’s nodes across all instances.</p>
    <p class="normal">To avoid the duplication of all nodes in every instance, we will reuse the nodes of the model during the calculation of each final node position for the frame.</p>
    <h2 id="_idParaDest-54" class="heading-2">Reusing the bones for the sake of simplicity</h2>
    <p class="normal">To calculate the nodes during<a id="_idIndexMarker052"/> animation in the <code class="inlineCode">updateAnimation()</code> method, we iterate the channels of the clip and use the model’s corresponding node:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; channel : animChannels) {
    std::string nodeNameToAnimate =
      channel-&gt;<span class="hljs-built_in">getTargetNodeName</span>();
    std::shared_ptr&lt;AssimpNode&gt; node =
      mAssimpModel-&gt;<span class="hljs-built_in">getNodeMap</span>().<span class="hljs-built_in">at</span>(nodeNameToAnimate);
</code></pre>
    <p class="normal">The position, rotation, or scale of every node change:</p>
    <pre class="programlisting code"><code class="hljs-code">    node-&gt;<span class="hljs-built_in">setRotation</span>(channel-&gt;<span class="hljs-built_in">getRotation</span>(
      mInstanceSettings.isAnimPlayTimePos));
    node-&gt;<span class="hljs-built_in">setScaling</span>(channel-&gt;<span class="hljs-built_in">getScaling</span>(
      mInstanceSettings.isAnimPlayTimePos));
    node-&gt;<span class="hljs-built_in">setTranslation</span>(channel-&gt;<span class="hljs-built_in">getTranslation</span>(
      mInstanceSettings.isAnimPlayTimePos));
  }
</code></pre>
    <p class="normal">For the root node, the local transformation of the instance is applied to the root transform matrix of the model:</p>
    <pre class="programlisting code"><code class="hljs-code">  mAssimpMode-&gt;<span class="hljs-built_in">getNodeMap</span>().<span class="hljs-built_in">at</span>(
      mAssimpModel→<span class="hljs-built_in">getBoneList</span>().<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>)-&gt;<span class="hljs-built_in">getBoneName</span>()
    -&gt;<span class="hljs-built_in">setRootTransformMatrix</span>(
    mLocalTransformMatrix *
    mAssimpModel-&gt;<span class="hljs-built_in">getRootTranformationMatrix</span>());
</code></pre>
    <p class="normal">Then, the node properties are used to generate the final position of the bone, using the stored offset matrix from the corresponding bone and the local transformation matrix of the node.</p>
    <p class="normal">First, we get the node corresponding to the bone of the model:</p>
    <pre class="programlisting code"><code class="hljs-code">  mBoneMatrices.<span class="hljs-built_in">clear</span>();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; bone : mAssimpModel-&gt;<span class="hljs-built_in">getBoneList</span>()) {
    std::string nodeName = bone-&gt;<span class="hljs-built_in">getBoneName</span>();
    std::shared_ptr&lt;AssimpNode&gt; node =
      mAssimpModel-&gt;<span class="hljs-built_in">getNodeMap</span>().<span class="hljs-built_in">at</span>(nodeName);
</code></pre>
    <p class="normal">Next, we update the matrix containing the translation, rotation, and scale properties of the node (hence the three letters <strong class="keyWord">TRS</strong> in the name):</p>
    <pre class="programlisting code"><code class="hljs-code">    node-&gt;<span class="hljs-built_in">updateTRSMatrix</span>();
</code></pre>
    <p class="normal">Calling <code class="inlineCode">updateTRSMatrix()</code> also retrieves the TRS matrix of the parent node and multiplies the local TRS matrix by the parent node’s TRS matrix. Combining the local TRS matrix with its parent node matrix makes sure that all nodes will inherit the transformations from all previous nodes in the model’s skeleton hierarchy.</p>
    <p class="normal">Finally, we multiply the TRS <a id="_idIndexMarker053"/>matrix of the current node by the bone offset matrix for the node to compute the final world position for every node:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> (mAssimpModel-&gt;<span class="hljs-built_in">getBoneOffsetMatrices</span>().<span class="hljs-built_in">count</span>(
        nodeName) &gt; <span class="hljs-number">0</span>) {
      mBoneMatrices.<span class="hljs-built_in">emplace_back</span>(
        mAssimpModel-&gt;<span class="hljs-built_in">getNodeMap</span>().<span class="hljs-built_in">at</span>(
        nodeName)-&gt;<span class="hljs-built_in">getTRSMatrix</span>() *
        mAssimpModel
-&gt;<span class="hljs-built_in">getBoneOffsetMatrices</span>().<span class="hljs-built_in">at</span>(nodeName));
      }
  }
</code></pre>
    <p class="normal">Reusing the model nodes works fine unless you plan to add a parallel (multi-threaded) calculation of instance animations: if more than one thread accesses the nodes of the model at the same time, at least one thread is modifying the node properties while other threads are reading the data, thus a so-called<a id="_idIndexMarker054"/> data race may occur, leading to a possible mix-up of the old and new data.</p>
    <p class="normal">So, when using a multi-threading version of the code, a local copy of the node list will be required. The additional node map can be generated from the node list with a simple iteration over the list, adding the nodes by their names to a map.</p>
    <h2 id="_idParaDest-55" class="heading-2">Storing instance-specific settings</h2>
    <p class="normal">The remaining per-instance <a id="_idIndexMarker055"/>settings are stored in the struct <code class="inlineCode">InstanceSettings</code>, defined in the file <code class="inlineCode">InstanceSettings.h</code> in the <code class="inlineCode">model</code> folder:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span> <span class="hljs-title">InstanceSettings</span> {
  glm::vec3 isWorldPosition = glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>);
  glm::vec3 isWorldRotation = glm::<span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>);
  <span class="hljs-type">float</span> isScale = <span class="hljs-number">1.0f</span>;
  <span class="hljs-type">bool</span> isSwapYZAxis = <span class="hljs-literal">false</span>;
  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> isAnimClipNr = <span class="hljs-number">0</span>;
  <span class="hljs-type">float</span> isAnimPlayTimePos = <span class="hljs-number">0.0f</span>;
  <span class="hljs-type">float</span> isAnimSpeedFactor = <span class="hljs-number">1.0f</span>;
};
</code></pre>
    <p class="normal">In the first three variables, <code class="inlineCode">isWorldPosition</code>, <code class="inlineCode">isWorldRotation</code>, and <code class="inlineCode">isScale</code>, the rotation, translation, and uniform scale of the instance are stored. The prefix <code class="inlineCode">is</code> does not mean “it is” in this context but is the abbreviation of the struct name to have distinct variable names.</p>
    <p class="normal">The fourth variable, <code class="inlineCode">isSwapYZAxis</code>, has been added for tools using a different coordinate system. While we are using the Y axis as the vertical axis, several tools used (and still use) a coordinate system where the Z axis is vertical, and the Y axis is one of the horizontal axes. To change the coordinate systems, a <a id="_idIndexMarker056"/>simple rotation matrix will be applied if <code class="inlineCode">isSwapYZAxis</code> is set to <code class="inlineCode">true</code>.</p>
    <p class="normal">The remaining three variables, <code class="inlineCode">isAnimClipNr</code>, <code class="inlineCode">isAnimPlayTimePos</code>, and <code class="inlineCode">isAnimSpeedFactor</code>, are also quite self-explanatory. These variables are used to control the animation parameters of the instance.</p>
    <p class="normal">Using the <code class="inlineCode">AssimpModel</code> and <code class="inlineCode">AsssimpInstance</code> classes will help us to develop a simple way to add and delete models and instances.</p>
    <h2 id="_idParaDest-56" class="heading-2">Dynamic model and instance management</h2>
    <p class="normal">The first building block of<a id="_idIndexMarker057"/> dynamic management is the struct <code class="inlineCode">ModelAndInstanceData</code>, defined in the file <code class="inlineCode">ModelAndInstanceData.h</code> in the <code class="inlineCode">model</code> folder. A variable of this struct is maintained by the renderer, used during the <code class="inlineCode">draw()</code> call, and also handed over to the UI:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">struct</span> <span class="hljs-title">ModelAndInstanceData</span> {
  std::vector&lt;std::shared_ptr&lt;AssimpModel&gt;&gt; miModelList{};
  <span class="hljs-type">int</span> miSelectedModel = <span class="hljs-number">0</span>;
</code></pre>
    <p class="normal">The first vector, <code class="inlineCode">miModelList</code>, contains all loaded models in the order of their addition. This list is shown in the UI as a list of currently loaded models. By using <code class="inlineCode">miSelectedModel</code>, we keep track of which model is selected in the UI.</p>
    <p class="normal">Next, we maintain two separate data structures for the instances:</p>
    <pre class="programlisting code"><code class="hljs-code">  std::vector&lt;std::shared_ptr&lt;AssimpInstance&gt;&gt;
    miAssimpInstances{};
  std::unordered_map&lt;std::string,
    std::vector&lt;std::shared_ptr&lt;AssimpInstance&gt;&gt;&gt;
  miAssimpInstancesPerModel{};
  <span class="hljs-type">int</span> miSelectedInstance = <span class="hljs-number">0</span>;
</code></pre>
    <p class="normal">The instance is stored in two different kinds of structures for the same reasons as the node map and node list – depending on the requirements, accessing the instances in one or the other data structure will be faster and/or simpler.</p>
    <p class="normal">The <code class="inlineCode">miAssimpInstances</code> is a normal <code class="inlineCode">std::vector</code>, where all instances of all models are stored. The instances vector is used to create the list of instances in the UI, retaining the order of addition. If instances or models are removed, the instances vector will be cleaned, still keeping the order of the remaining models.</p>
    <p class="normal">For <code class="inlineCode">miAssimpInstancesPerModel</code>, the reason is different. When we want to draw the models in the renderer, we need all instances of a specific model to collect the bone matrices for animated models, and the normal node matrices for non-animated models. Sorting or filtering the <code class="inlineCode">miAssimpInstances</code> vector <a id="_idIndexMarker058"/>on every draw call would be quite expensive on the CPU side, so the separate structure helps us here.</p>
    <p class="normal">At the end of the <code class="inlineCode">ModelAndInstanceData </code>struct, some callback variables are defined:</p>
    <pre class="programlisting code"><code class="hljs-code">  modelCheckCallback miModelCheckCallbackFunction;
  modelAddCallback miModelAddCallbackFunction;
  modelDeleteCallback miModelDeleteCallbackFunction;
  instanceAddCallback miInstanceAddCallbackFunction;
  instanceDeleteCallback miInstanceDeleteCallbackFunction;
};
</code></pre>
    <p class="normal">These callbacks are used to move the job of creating or deleting models and instances from the UI back to the renderer. The UI is not the right place to adjust the data structures for models and instances, so these tasks will be forwarded to the renderer.</p>
    <p class="normal">The callbacks themselves are C++-style function pointers, created with <code class="inlineCode">std::function</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">using</span> modelCheckCallback = std::function&lt;<span class="hljs-built_in">bool</span>(std::string)&gt;;
<span class="hljs-keyword">using</span> modelAddCallback = std::function&lt;<span class="hljs-built_in">bool</span>(std::string)&gt;;
<span class="hljs-keyword">using</span> modelDeleteCallback =
  std::function&lt;<span class="hljs-built_in">void</span>(std::string)&gt;;
<span class="hljs-keyword">using</span> instanceAddCallback =
 std::function&lt;std::<span class="hljs-built_in">shared_ptr</span>&lt;
 AssimpInstance&gt;(std::shared_ptr&lt;AssimpModel&gt;)&gt;;
<span class="hljs-keyword">using</span> instanceDeleteCallback =
  std::function&lt;<span class="hljs-built_in">void</span>(std::shared_ptr&lt;AssimpInstance&gt;)&gt;;
</code></pre>
    <p class="normal">Going back to the renderer, we look at the <code class="inlineCode">addModel()</code> method that is called from the UI, as mentioned in the section <em class="italic">Loading the model file</em>.</p>
    <p class="normal">The <code class="inlineCode">addModel()</code> method for the OpenGL renderer looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">bool</span><span class="hljs-function"> </span><span class="hljs-title">OGLRenderer::addModel</span><span class="hljs-params">(std::string modelFileName)</span><span class="hljs-function"> </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hasModel</span>(modelFileName)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
</code></pre>
    <p class="normal">First, we check if the model has been already loaded. To avoid confusion, a model file can be loaded only once. Having the exact same model file loaded twice (or more times) makes little sense.</p>
    <p class="normal">Now, we try to load the specified model file:</p>
    <pre class="programlisting code"><code class="hljs-code">  std::shared_ptr&lt;AssimpModel&gt; model =
    std::<span class="hljs-built_in">make_shared</span>&lt;AssimpModel&gt;();
  <span class="hljs-keyword">if</span> (!model-&gt;<span class="hljs-built_in">loadModel</span>(modelFileName)) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
</code></pre>
    <p class="normal">When the loading fails, the model also returns <code class="inlineCode">false</code> to the caller, even though the return value is not used currently.</p>
    <p class="normal">If the model file can be loaded, it will be placed into a <code class="inlineCode">std::vector</code> of models:</p>
    <pre class="programlisting code"><code class="hljs-code">  mModelInstData.miModelList.<span class="hljs-built_in">emplace_back</span>(model);
</code></pre>
    <p class="normal">From this list, the UI generates the combo box with the currently loaded model.</p>
    <p class="normal">We also add an instance <a id="_idIndexMarker059"/>of the model and return the information about a successfully loaded model to the caller:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-built_in">addInstance</span>(model);
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
</code></pre>
    <p class="normal">For a loaded model to be helpful, we need to create at least one instance, so we have something to render in the world. We use the already implemented way of creating a first instance, instead of having a separate solution.</p>
    <p class="normal">The <code class="inlineCode">addInstance()</code> method is also only a couple of lines long:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-function">std::shared_ptr&lt;AssimpInstance&gt;</span>
<span class="hljs-function">  </span><span class="hljs-title">OGLRenderer::addInstance</span><span class="hljs-params">(std::shared_ptr&lt;AssimpModel&gt;</span>
<span class="hljs-params">    model)</span><span class="hljs-function"> </span>{
</code></pre>
    <p class="normal">The signature of the method shows that we return the created instance to the caller. Even though the instance will be added to the internal data structures, getting the new instance from the method may be handy, i.e., when the instance should be further adjusted.</p>
    <p class="normal">First, we create a new smart pointer of an <code class="inlineCode">AssimpInstance</code> object:</p>
    <pre class="programlisting code"><code class="hljs-code">  std::shared_ptr&lt;AssimpInstance&gt; newInstance =
    std::<span class="hljs-built_in">make_shared</span>&lt;AssimpInstance&gt;(model);
</code></pre>
    <p class="normal">Here, the base model is given as the only parameter. The constructor of the <code class="inlineCode">AssimpInstance</code> class has three additional parameters with default values set: the initial position, rotation, and scale. Setting these parameters may be useful in the future, but to create a single instance, they can be omitted.</p>
    <p class="normal">Now, the new instance is inserted into two data structures, <code class="inlineCode">miAssimpInstances</code> and <code class="inlineCode">miAssimpInstancesPerModel</code>, of the struct <code class="inlineCode">ModelAndInstanceData</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">mModelInstData.miAssimpInstances.<span class="hljs-built_in">emplace_back</span>(newInstance);
mModelInstData.miAssimpInstancesPerModel[
  model-&gt;<span class="hljs-built_in">getModelFileName</span>()
  ].<span class="hljs-built_in">emplace_back</span>(newInstance);
</code></pre>
    <p class="normal">As the last steps, we update the triangle count shown in the UI and return the newly created instance</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-built_in">updateTriangleCount</span>();
  <span class="hljs-keyword">return</span> newInstance;
}
</code></pre>
    <p class="normal">Deleting models and<a id="_idIndexMarker060"/> instances follows broadly the same path. The UI triggers the action via the callback; the renderer searches for the instance, or the model and all instances of that model, and removes them from the data structures.</p>
    <h2 id="_idParaDest-57" class="heading-2">Drawing all instances</h2>
    <p class="normal">The process of drawing the instances of the <code class="inlineCode">Assimp</code> models has not changed much. We need to loop over all model instances, instead of just a<a id="_idIndexMarker061"/> single model. We use an “instanced” type of call to the graphics API that draws all instances of one <code class="inlineCode">Assimp</code> model directly on the GPU:</p>
    <ol>
      <li class="numberedList" value="1">Iterate over the <code class="inlineCode">miAssimpInstancesPerModel</code> map to find all instances of a specific model.</li>
      <li class="numberedList">If the model is animated, update the animation with the delta time between the last frame and this frame, and collect the new bone matrices.</li>
      <li class="numberedList">If the model is not animated, simply get the node matrices of the instances.</li>
      <li class="numberedList">Upload the matrix data to the shader storage buffer on the shader.</li>
      <li class="numberedList">Issue an instanced draw call to the graphics API.</li>
    </ol>
    <p class="normal">For <em class="italic">step 5</em> of the list, it is mandatory to have the exact count of the instances per model available as quickly as possible. The fastest way to get the number of instances is to measure the size of each vector in the <code class="inlineCode">miAssimpInstancesPerModel</code> map.</p>
    <p class="normal">If we use the unsorted <code class="inlineCode">miAssimpInstances</code> vector to draw the instances instead, collecting all instances of the same model type would require extra work. Iterating over the <code class="inlineCode">miAssimpInstances</code> vector to find all instances of the same model and adding these instances to temporary data structures costs precious time. This strategy would lower the maximum number of frames per second we could achieve. In order to use instanced draw calls, we need to process instances grouped by their associated model. So, we are drawing all instances by using the <code class="inlineCode">miAssimpInstancesPerModel</code> vector.</p>
    <p class="normal"><em class="italic">Figure 1.21</em> shows the application after loading the example model from the <code class="inlineCode">assets</code> folder and spawning a number of instances:</p>
    <figure class="mediaobject"><img src="../Images/B22428_01_21.png" alt="" width="1280" height="750"/></figure>
    <p class="packt_figref">Figure 1.21: Multiple instances of the example animated character model</p>
    <h1 id="_idParaDest-58" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we took the first steps toward mastering C++ game animation programming by using <strong class="keyWord">Open Asset Importer Library</strong>, or <code class="inlineCode">Assimp</code>. <code class="inlineCode">Assimp</code> enables us to simplify and accelerate the path to animating and rendering model instances.</p>
    <p class="normal">We started by looking at the general data structures of the <code class="inlineCode">Assimp</code> library, how to parse the different parts of a file, and in which order. Next, we added a nice ImGui-based file dialog to the code, allowing us to select files in an interactive manner, instead of having to hardcode one or more model files we wish to open. At the end of the chapter, we explored how to add or remove models and instances at runtime, enabling us to create a more “crowded” virtual world.</p>
    <p class="normal">In <a href="Chapter_2.xhtml"><em class="italic">Chapter 2</em></a>, we will move the computational load to calculate the model matrices from the CPU to the GPU, allowing us to have more CPU power left to do amazing things in our virtual world.</p>
    <h1 id="_idParaDest-59" class="heading-1">Practical sessions</h1>
    <p class="normal">You will see this section at the end of every chapter in the book. Here, I will add a bunch of suggestions and exercises that you can try out with the code on GitHub.</p>
    <p class="normal">You could try to do the following:</p>
    <ul>
      <li class="bulletList">Add more controls to the animations, like the play direction, one/time vs. loop play, or even ping-pong replay, alternating between forward and backward replay of the chosen animation.</li>
      <li class="bulletList">Add an animation slider that lets you choose to show the frame at some point in time of an animation.</li>
      <li class="bulletList">Search for model files on the internet. Try out which models work, or to which extent they work. You do not have to limit this search to game character models; you can also search for game maps in compatible formats, or 3D-printable objects. Remember to adjust the file dialog filter to show the additional file formats.</li>
    </ul>
    <h1 id="_idParaDest-60" class="heading-1">Additional resources</h1>
    <p class="normal">For further reading, please take a look at the following resources:</p>
    <ul>
      <li class="bulletList">Microsoft on path length limit: <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=registry"><span class="url">https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=registry</span></a></li>
      <li class="bulletList">Assimp GitHub repository: <a href="https://github.com/assimp/assimp"><span class="url">https://github.com/assimp/assimp</span></a></li>
      <li class="bulletList">Assimp documentation: <a href="https://assimp-docs.readthedocs.io/en/latest/"><span class="url">https://assimp-docs.readthedocs.io/en/latest/</span></a></li>
      <li class="bulletList">Learn OpenGL section on Assimp: <a href="https://learnopengl.com/Model-Loading/Assimp"><span class="url">https://learnopengl.com/Model-Loading/Assimp</span></a></li>
      <li class="bulletList">Skeletal animation tutorial: <a href="https://www.ogldev.org/www/tutorial38/tutorial38.html"><span class="url">https://www.ogldev.org/www/tutorial38/tutorial38.html</span></a></li>
    </ul>
  </div>
</div></div></body></html>