["```cpp\n  topLeft = point(100, 100); \n```", "```cpp\n  left = xCoordinate(topleft); \n  top = yCoordinate(topLeft); \n  bottomRight = point(left + 100, top + 100); \n```", "```cpp\n  SetPenStyle(DashLine); \n  SetBrushStyle(CrossPattern); \n```", "```cpp\n  SetPenColor(Black); \n  PurpleColor = color(128, 0, 128); \n  SetBrushColor(PurpleColor); \n  DrawRectangle(topLeft, bottomRight); \n```", "```cpp\n  SetFont(font(\"Times New Roman\", 12)); \n  SetHorizontalAlignment(AlignLeft); \n  SetVerticalAlignment(AlignTop); \n  DrawText(point(300, 150), \"Hello, DSL!\");\n```", "```cpp\nprogram -> instructionList \n```", "```cpp\ninstructionList -> instruction* \n```", "```cpp\ninstruction -> name = expression; \n             | SetPenColor(expression); \n             | SetPenStyle(expression); \n             | SetBrushColor(expression); \n             | SetBrushStyle(expression); \n             | SetFont(expression); \n             | SetHorizontalAlignment(expression); \n             | SetVerticalAlignment(expression); \n             | DrawLine(expression, expression); \n             | DrawRectangle(expression, expression); \n             | DrawEllipse(expression, expression); \n             | DrawText(expression, expression); \n```", "```cpp\nexpression -> mulDivExpression expressionRest \n```", "```cpp\nexpressionRest -> + mulDivExpression expressionRest \n                | - mulDivExpression expressionRest \n                | /* empty */ \n```", "```cpp\nmulDivExpression -> primaryExpression mulDivExpressionRest \nmulDivExpressionRest -> * primaryExpression mulDivExpressionRest \n                      | / primaryExpression mulDivExpressionRest \n                      | /* empty */ \n```", "```cpp\nprimaryExpression -> point(expression, expression) \n                   | xCoordinate(expression) \n                   | yCoordinate(expression) \n```", "```cpp\n                   | color(expression, expression, expression) \n                   | font(expression, expression) \n```", "```cpp\n                   | (expression) \n```", "```cpp\n                   | name \n                   | value\n```", "```cpp\n#ifndef ACTION_H \n#define ACTION_H \n\n#include \"Token.h\" \n#include \"Value.h\" \n\nclass Action { \n  public: \n    Action(TokenId actionId, const Value& value1 = Value(), \n           const Value& value2 = Value()); \n\n    Action(const Action& action); \n    Action operator=(const Action& action); \n\n    TokenId id() const {return m_actionId;} \n    const Value& value1() const {return m_value1;} \n    const Value& value2() const {return m_value2;} \n\n  private: \n    TokenId m_actionId; \n    Value m_value1, m_value2; \n}; \n\n#endif // ACTION_H \n```", "```cpp\n#include \"Action.h\"\n```", "```cpp\nAction::Action(TokenId actionId, \n               const Value& value1 /*= Value()*/, \n               const Value& value2 /*= Value()*/ ) \n  :m_actionId(actionId), \n   m_value1(value1), \n   m_value2(value2) { \n  // Empty. \n}  \n```", "```cpp\nSetPenColor(Aqua); \n```", "```cpp\n#ifndef COLOR_H \n#define COLOR_H \n\n#include <QWidget> \n\nextern QColor \n  Aqua, Black, Blue, Brown, Cyan, Gray, Green, Lime, Magenta, \n  Navyblue, Orange, Orchid, Pink, Purple, Red, Silver, Snow, \n  SteelBlue, SystemColor, Turquoise, Violet, White, Yellow; \n\n#endif // COLOR_H \n```", "```cpp\n#include \"Colors.h\"\n```", "```cpp\nQColor \n  Aqua(0, 255, 255), Black(0, 0, 0), Blue(0, 0, 255), \n  Brown(165, 42, 42), Cyan(0, 255, 255), Gray(127, 127, 127), \n  Green(0, 128, 0), Lime(0, 255, 0), Magenta(255, 0, 255), \n  Navyblue(159, 175, 223), Orange(255, 165, 0), \n  Orchid(218, 112, 214), Pink(255, 192, 203), \n  Purple(128, 0, 128), Red(255, 0, 0), Silver(192, 192, 192), \n  Snow(255, 250, 250),  SteelBlue(70, 130, 180), \n  SystemColor(0, 0, 0), Turquoise(64, 224, 208), \n  Violet(238, 130, 238), White(255, 255, 255), \n  Yellow(255, 255, 0); \n```", "```cpp\n#ifndef ERROR_H \n#define ERROR_H \n\n#include <QString> \n\nvoid error(const QString& message); \nvoid syntaxError(); \nvoid syntaxError(const QString& message); \nvoid semanticError(const QString& message); \nvoid check(bool condition, const QString& message); \n\n#endif // ERROR_H \n```", "```cpp\n#include <SStream> \n#include <Exception> \nusing namespace std; \n\n#include \"Error.h\" \n\nextern int g_lineNo = 1; \n\nvoid error(const QString& message) { \n  throw exception(message.toStdString().c_str()); \n} \n```", "```cpp\nvoid syntaxError() { \n  stringstream stringStream; \n  stringStream << \"Syntax error at line \" << g_lineNo << \".\"; \n```", "```cpp\n  error(stringStream.str().c_str()); \n} \n```", "```cpp\nvoid syntaxError(const QString& message) { \n  stringstream stringStream; \n  stringStream << \"Syntax error at line \" << g_lineNo \n               << \": \" << message.toStdString() << \".\"; \n  error(stringStream.str().c_str()); \n} \n```", "```cpp\nvoid semanticError(const QString& message) { \n  stringstream stringStream; \n  stringStream << \"Sematic error: \" \n               << message.toStdString() << \".\"; \n  error(stringStream.str().c_str()); \n}\n```", "```cpp\nvoid check(bool condition, const QString& message) { \n  if (!condition) { \n    semanticError(message); \n  } \n} \n```", "```cpp\n#ifndef VALUE_H \n#define VALUE_H \n\n#include <IOStream> \nusing namespace std; \n\n#include <QtWidgets> \n\nenum TypeId {NumericalTypeId, StringTypeId, ColorTypeId, \n             PenStyleTypeId, BrushStyleId, AlignmentTypeId, \n             FontTypeId, PointTypeId}; \n\nclass Value { \n  public: \n    Value(); \n    Value(double numericalValue); \n    Value(const QString& stringValue); \n    Value(const QPoint& pointValue); \n    Value(const QColor& colorValue); \n    Value(const QFont& fontValue); \n    Value(const Qt::PenStyle& penStyleValue); \n    Value(const Qt::BrushStyle& brushStyleValue); \n    Value(const Qt::AlignmentFlag& alignment); \n\n    Value(const Value& value); \n    Value& operator=(const Value& value); \n\n    bool isNumerical() const {return (m_typeId==NumericalTypeId);} \n    bool isString() const { return (m_typeId == StringTypeId); } \n    bool isColor() const { return (m_typeId == ColorTypeId); } \n    bool isFont() const { return (m_typeId == FontTypeId); } \n    bool isPoint() const { return (m_typeId == PointTypeId); } \n    bool isPenStyle() const {return (m_typeId == PenStyleTypeId);} \n    bool isBrushStyle() const {return (m_typeId == BrushStyleId);} \n    bool isAlignment() const {return (m_typeId==AlignmentTypeId);} \n\n    double numericalValue() const { return m_numericalValue; } \n    const QString& stringValue() const { return m_stringValue; } \n    const QColor& colorValue() const { return m_colorValue; } \n    const QFont& fontValue() const { return m_fontValue; } \n    const QPoint& pointValue() const { return m_pointValue; } \n    const Qt::PenStyle& penStyleValue() const \n                        { return m_penStyleValue; } \n    const Qt::BrushStyle& brushStyleValue() const \n                          { return m_brushStyleValue; } \n    const Qt::AlignmentFlag& alignmentValue() const \n                             { return m_alignmentValue; } \n\n  private: \n    TypeId m_typeId; \n    double m_numericalValue; \n    QString m_stringValue; \n    QPoint m_pointValue; \n    QColor m_colorValue; \n    QFont m_fontValue; \n    Qt::PenStyle m_penStyleValue; \n    Qt::BrushStyle m_brushStyleValue; \n    Qt::AlignmentFlag m_alignmentValue; \n}; \n\n#endif // VALUE_H \n```", "```cpp\n#include <CAssert> \nusing namespace std; \n\n#include \"Value.h\" \n\nValue::Value() { \n  // Empty. \n} \n```", "```cpp\nValue::Value(double numericalValue) \n :m_typeId(NumericalTypeId), \n  m_numericalValue(numericalValue) { \n  // Empty. \n} \n\nValue::Value(const QPoint& pointValue) \n :m_typeId(PointTypeId), \n  m_pointValue(pointValue) { \n  // Empty. \n} \n```", "```cpp\n#ifndef TOKEN_H \n#define TOKEN_H \n\n#include <QWidget> \n#include \"Value.h\" \n```", "```cpp\nenum TokenId {ColorId, DrawEllipseId, DrawLineId, \n              DrawRectangleId, DrawTextId, FontId,  \n              PointId, SetBrushColorId, SetBrushStyleId, \n              SetFontId, SetHorizontalAlignmentId, \n              SetPenColorId, SetPenStyleId, \n              SetVerticalAlignmentId, \n              XCoordinateId, YCoordinateId, \n```", "```cpp\n              AddId, SubtractId, MultiplyId, DivideId, \n```", "```cpp\n              LeftParenthesisId, RightParenthesisId, \n              AssignId, CommaId, SemicolonId, \n```", "```cpp\n              NameId, ValueId, EndOfFileId}; \n\nclass Token{ \n  public: \n    Token(); \n    Token(TokenId tokenId); \n    Token(TokenId tokenId, const QString& name); \n    Token(TokenId tokenId, const Value& value); \n```", "```cpp\n    TokenId id() const {return m_tokenId;} \n    const QString& name() const { return m_name; } \n    const Value& value() const { return m_value; } \n\n  private: \n    TokenId m_tokenId; \n    QString m_name; \n    Value m_value; \n}; \n\n#endif // TOKEN_H\n```", "```cpp\n#include \"Token.h\" \n```", "```cpp\nToken::Token() \n :m_tokenId(EndOfFileId) { \n  // Empty. \n} \n```", "```cpp\nToken::Token(TokenId tokenId) \n :m_tokenId(tokenId) { \n  // Empty. \n} \n```", "```cpp\nToken::Token(TokenId tokenId, const QString& name) \n :m_tokenId(tokenId), \n  m_name(name) { \n  // Empty. \n} \n\nToken::Token(TokenId tokenId, const Value& value) \n :m_tokenId(tokenId), \n  m_value(value) { \n  // Empty. \n} \n```", "```cpp\n#ifndef SCANNER_H \n#define SCANNER_H \n\n#include \"Token.h\" \n#include \"Colors.h\"\n```", "```cpp\nclass Scanner { \n  public: \n    static void init(); \n    Scanner(QString& buffer); \n```", "```cpp\n  public: \n    Token nextToken(); \n```", "```cpp\n  private: \n    QString m_buffer; \n    int m_bufferIndex = 0; \n```", "```cpp\n    static QMap<QString,TokenId> m_keywordMap; \n    static QMap<QString,Value> m_valueMap; \n    static QList<pair<QString,TokenId>> m_operatorList; \n}; \n\n#endif // SCANNER_H \n```", "```cpp\n#include <SStream> \n#include <IOStream> \n#include <Exception> \nusing namespace std; \n\n#include \"Error.h\" \n#include \"Scanner.h\" \n\nQMap<QString,Value> Scanner::m_valueMap; \nQMap<QString,TokenId> Scanner::m_keywordMap; \nQList<pair<QString, TokenId>> Scanner::m_operatorList; \n```", "```cpp\nextern int g_lineNo; \n```", "```cpp\n#define ADD_TO_OPERATOR_LIST(text, token)                      \n  m_operatorList.push_back(pair<QString,TokenId>(text, token)); \n\nvoid Scanner::init() { \n  ADD_TO_OPERATOR_LIST(\"+\", AddId) \n  ADD_TO_OPERATOR_LIST(\"-\", SubtractId) \n  ADD_TO_OPERATOR_LIST(\"*\", MultiplyId) \n  ADD_TO_OPERATOR_LIST(\"/\", DivideId) \n  ADD_TO_OPERATOR_LIST(\"(\", LeftParenthesisId) \n  ADD_TO_OPERATOR_LIST(\")\", RightParenthesisId) \n  ADD_TO_OPERATOR_LIST(\"=\", AssignId) \n  ADD_TO_OPERATOR_LIST(\",\", CommaId) \n  ADD_TO_OPERATOR_LIST(\";\", SemicolonId) \n```", "```cpp\n#define ADD_TO_KEYWORD_MAP(x) {                        \n  QString s(#x);                                       \n  m_keywordMap[s.toLower().left(s.length() - 2)] = x; } \n\n  ADD_TO_KEYWORD_MAP(ColorId) \n  ADD_TO_KEYWORD_MAP(DrawEllipseId) \n  ADD_TO_KEYWORD_MAP(DrawLineId) \n  ADD_TO_KEYWORD_MAP(DrawRectangleId) \n  ADD_TO_KEYWORD_MAP(DrawTextId) \n  ADD_TO_KEYWORD_MAP(FontId) \n  ADD_TO_KEYWORD_MAP(PointId) \n  ADD_TO_KEYWORD_MAP(SetBrushColorId) \n  ADD_TO_KEYWORD_MAP(SetBrushStyleId) \n  ADD_TO_KEYWORD_MAP(SetFontId) \n  ADD_TO_KEYWORD_MAP(SetHorizontalAlignmentId) \n  ADD_TO_KEYWORD_MAP(SetPenColorId) \n  ADD_TO_KEYWORD_MAP(SetPenStyleId) \n  ADD_TO_KEYWORD_MAP(SetVerticalAlignmentId) \n  ADD_TO_KEYWORD_MAP(XCoordinateId) \n  ADD_TO_KEYWORD_MAP(YCoordinateId) \n```", "```cpp\n#define ADD_TO_VALUE_MAP(x) {                           \n  QString s(#x);                                        \n  QString t = s.toLower();                              \n  int i = t.lastIndexOf(\"::\");                          \n  m_valueMap[(i == -1) ? t : t.mid(i + 2)] = Value(x); } \n```", "```cpp\n  ADD_TO_VALUE_MAP(Qt::AlignLeft) \n  ADD_TO_VALUE_MAP(Qt::AlignTop) \n\n  ADD_TO_VALUE_MAP(Qt::PenStyle::NoPen) \n  ADD_TO_VALUE_MAP(Qt::PenStyle::SolidLine) \n\n  ADD_TO_VALUE_MAP(Qt::BrushStyle::NoBrush) \n  ADD_TO_VALUE_MAP(Qt::BrushStyle::SolidPattern) \n\n  ADD_TO_VALUE_MAP(Aqua) \n  ADD_TO_VALUE_MAP(Black) \n} \n```", "```cpp\nScanner::Scanner(QString& buffer) \n :m_buffer(buffer) { \n  m_buffer.append(''); \n} \n```", "```cpp\nToken Scanner::nextToken() { \n  while (true) { \n    if (m_buffer[m_bufferIndex] == 'n') { \n      ++g_lineNo; \n      ++m_bufferIndex; \n    } \n```", "```cpp\n    else if (m_buffer[m_bufferIndex].isSpace()) { \n      ++m_bufferIndex; \n    } \n```", "```cpp\n    else if (m_buffer.indexOf(\"//\", m_bufferIndex) == \n             m_bufferIndex) { \n      while ((m_buffer[m_bufferIndex] != QChar('n')) && \n             (m_buffer[m_bufferIndex] != QChar(''))) { \n        ++m_bufferIndex; \n      } \n    } \n```", "```cpp\n    else { \n      break; \n    } \n  } \n```", "```cpp\n  if (m_buffer[m_bufferIndex] == QChar('')) { \n    return Token(EndOfFileId); \n  } \n```", "```cpp\n  for (const pair<QString,TokenId>& pair : m_operatorList) { \n    const QString& operatorText = pair.first; \n    TokenId tokenId = pair.second;\n```", "```cpp\n    if (m_buffer.indexOf(operatorText, m_bufferIndex) == \n        m_bufferIndex) { \n      m_bufferIndex += operatorText.length(); \n      return Token(tokenId); \n    } \n  } \n```", "```cpp\n  if (m_buffer[m_bufferIndex].isLetter() || \n      (m_buffer[m_bufferIndex] == '_')) { \n    int index = m_bufferIndex; \n```", "```cpp\n    while (m_buffer[index].isLetterOrNumber() || \n           (m_buffer[index] == '_')) { \n      ++index; \n    } \n```", "```cpp\n    int size = index - m_bufferIndex; \n    QString text = m_buffer.mid(m_bufferIndex, size).toLower(); \n    m_bufferIndex += size; \n```", "```cpp\n    if (m_keywordMap.contains(text)) { \n      return Token(m_keywordMap[text]); \n    } \n```", "```cpp\n    else if (m_valueMap.contains(text)) { \n      return Token(ValueId, m_valueMap[text]); \n    }\n```", "```cpp\n    else { \n      return Token(NameId, text); \n    } \n  } \n```", "```cpp\n  if (m_buffer[m_bufferIndex] == '\"') { \n    int index = m_bufferIndex + 1; \n\n    while (m_buffer[index] != '\"') { \n```", "```cpp\n      if (m_buffer[index] == QChar('')) { \n        syntaxError(\"unfinished string\"); \n      } \n\n      ++index; \n    } \n```", "```cpp\n    int size = index - m_bufferIndex + 1; \n    QString text = m_buffer.mid(m_bufferIndex, size); \n    m_bufferIndex += size; \n    return Token(ValueId, Value(text)); \n  } \n```", "```cpp\n  if (m_buffer[m_bufferIndex].isDigit()) { \n    int index = m_bufferIndex; \n\n    while (m_buffer[index].isDigit()) { \n      ++index; \n    }\n```", "```cpp\n    if (m_buffer[index] == '.') { \n      ++index; \n\n      while (m_buffer[index].isDigit()) { \n        ++index; \n      } \n    } \n```", "```cpp\n    int size = index - m_bufferIndex; \n    QString text = m_buffer.mid(m_bufferIndex, size); \n    m_bufferIndex += size; \n    return Token(ValueId, Value(text.toDouble())); \n  } \n```", "```cpp\n  syntaxError(); \n```", "```cpp\n  return Token(EndOfFileId); \n} \n```", "```cpp\n#ifndef PARSER_H \n#define PARSER_H \n\n#include \"Action.h\" \n#include \"Scanner.h\" \n```", "```cpp\nclass Parser { \n  public: \n    Parser(Scanner& m_scanner, QList<Action>& actionList); \n```", "```cpp\n  private: \n    void match(TokenId tokenId); \n```", "```cpp\n    void instructionList(); \n    void instruction(); \n```", "```cpp\n    Value expression(); \n    Value expressionRest(Value leftValue); \n    Value mulDivExpression(); \n    Value mulDivExpressionRest(Value leftValue); \n    Value primaryExpression(); \n    Value primaryExpression(); \n```", "```cpp\n    void checkType(TokenId operatorId, const Value& value); \n    void checkType(TokenId operatorId, const Value& leftValue, \n                   const Value& rightValue); \n    Value evaluate(TokenId operatorId, const Value& value); \n    Value evaluate(TokenId operatorId, const Value& leftValue, \n                   const Value& rightValue);\n```", "```cpp\n  private: \n    Token m_lookAHead; \n    Scanner& m_scanner; \n    QList<Action>& m_actionList; \n    QMap<QString,Value> m_assignMap;                                                                                                                                                                                                            }; \n\n#endif // PARSER_H \n```", "```cpp\n#include <CAssert> \nusing namespace std; \n\n#include \"Value.h\" \n#include \"Token.h\" \n#include \"Scanner.h\" \n#include \"Parser.h\" \n#include \"Error.h\" \n```", "```cpp\nParser::Parser(Scanner& m_scanner, QList<Action>& actionList) \n :m_scanner(m_scanner), \n  m_actionList(actionList) { \n  m_lookAHead = m_scanner.nextToken(); \n  instructionList(); \n  match(EndOfFileId); \n} \n```", "```cpp\nextern int g_lineNo;\n```", "```cpp\nvoid Parser::instructionList() { \n  while (m_lookAHead.id() != EndOfFileId) { \n    instruction(); \n  } \n} \n```", "```cpp\nvoid Parser::match(TokenId tokenId) { \n  if (m_lookAHead.id() != tokenId) { \n    syntaxError(); \n  } \n\n  m_lookAHead = m_scanner.nextToken(); \n} \n```", "```cpp\nvoid Parser::instruction() { \n  TokenId tokenId = m_lookAHead.id(); \n```", "```cpp\n  switch (tokenId) { \n    case NameId: { \n        QString assignName = m_lookAHead.name(); \n        match(NameId); \n        match(AssignId); \n        Value assignValue = expression(); \n        match(SemicolonId); \n```", "```cpp\n        check(!m_assignMap.contains(assignName), \n              \"the name \"\" + assignName + \"\" defined twiced\"); \n        m_assignMap[assignName] = assignValue; \n      } \n      break;\n```", "```cpp\n    case SetPenColorId: \n    case SetPenStyleId: \n    case SetBrushColorId: \n    case SetBrushStyleId: \n    case SetFontId: \n    case SetHorizontalAlignmentId: \n    case SetVerticalAlignmentId: { \n        match(tokenId); \n        match(LeftParenthesisId); \n        Value value = expression(); \n        match(RightParenthesisId); \n        match(SemicolonId); \n        checkType(tokenId, value); \n        m_actionList.push_back(Action(tokenId, value)); \n      } \n      break; \n```", "```cpp\n    case DrawLineId: \n    case DrawRectangleId: \n    case DrawEllipseId: \n    case DrawTextId: { \n        match(tokenId); \n        match(LeftParenthesisId); \n        Value firstValue = expression(); \n        match(CommaId); \n        Value secondValue = expression(); \n        match(RightParenthesisId); \n        match(SemicolonId); \n        checkType(tokenId, firstValue, secondValue); \n        m_actionList.push_back(Action(tokenId, firstValue, \n                                      secondValue)); \n      } \n      break; \n```", "```cpp\n    default: \n      syntaxError(); \n  } \n} \n```", "```cpp\nValue Parser::expression() { \n  Value leftValue = mulDivExpression (); \n  return expressionRest(leftValue); \n} \n```", "```cpp\nValue Parser::expressionRest(Value leftValue) { \n  TokenId tokenId = m_lookAHead.id(); \n\n  switch (tokenId) { \n    case AddId: \n    case SubtractId: { \n        match(tokenId); \n        Value rightValue = mulDivExpression(); \n        check(leftValue.isNumerical() && rightValue.isNumerical(), \n              \"non-numerical values in arithmetic expression\"); \n        Value resultValue = \n          evaluate(tokenId, leftValue, rightValue); \n        return expressionRest(resultValue); \n      } \n\n    default: \n      return leftValue; \n  } \n}\n```", "```cpp\nValue Parser::mulDivExpression() { \n  Value leftValue = primaryExpression(); \n  return mulDivExpressionRest(leftValue); \n} \n\nValue Parser::mulDivExpressionRest(Value leftValue) { \n  TokenId tokenId = m_lookAHead.id(); \n\n  switch (tokenId) { \n    case MultiplyId: \n    case DivideId: { \n        match(tokenId); \n        Value rightValue = primaryExpression(); \n        check(leftValue.isNumerical() && rightValue.isNumerical(), \n              \"non-numerical values in arithmetic expression\"); \n        Value resultValue = \n          evaluate(tokenId, leftValue, rightValue); \n        return mulDivExpressionRest (resultValue); \n      } \n\n    default: \n      return leftValue; \n  } \n} \n```", "```cpp\nValue Parser::primaryExpression() { \n  TokenId tokenId = m_lookAHead.id(); \n```", "```cpp\n  switch (tokenId) { \n    case XCoordinateId: \n    case YCoordinateId: { \n        match(tokenId); \n        match(LeftParenthesisId); \n        Value value = expression(); \n        match(RightParenthesisId); \n        check(value.isPoint(), \n              \"not a point in coordinate expression\"); \n        checkType(tokenId, value); \n        return evaluate(tokenId, value); \n      } \n      break; \n```", "```cpp\n    case PointId: { \n        match(PointId); \n        match(LeftParenthesisId); \n        Value xValue = expression(); \n        match(CommaId); \n        Value yValue = expression(); \n        match(RightParenthesisId); \n        check(xValue.isNumerical() && yValue.isNumerical(), \n              \"non-numerical values in point expression\"); \n        return Value(QPoint(xValue.numericalValue(), \n                            yValue.numericalValue())); \n    } \n```", "```cpp\n    case ColorId: { \n        match(ColorId); \n        match(LeftParenthesisId); \n        Value redValue = expression(); \n        match(CommaId); \n        Value greenValue = expression(); \n        match(CommaId); \n        Value blueValue = expression(); \n        match(RightParenthesisId); \n        check(redValue.isNumerical() && greenValue.isNumerical() \n              && blueValue.isNumerical(), \n              \"non-numerical values in color expression\"); \n        return Value(QColor(redValue.numericalValue(), \n                            greenValue.numericalValue(), \n                            blueValue.numericalValue())); \n      } \n```", "```cpp\n    case FontId: { \n        match(FontId); \n        match(LeftParenthesisId); \n        Value nameValue = expression(); \n        match(CommaId); \n        Value sizeValue = expression(); \n        match(RightParenthesisId); \n        check(nameValue.isString() && sizeValue.isNumerical(), \n              \"invalid types in font expression\"); \n        return Value(QFont(nameValue.stringValue(), \n                           sizeValue.numericalValue())); \n      } \n```", "```cpp\n    case LeftParenthesisId: { \n        match(LeftParenthesisId); \n        Value value = expression(); \n        match(RightParenthesisId); \n        return value; \n      } \n```", "```cpp\n    case NameId: { \n        QString lookupName = m_lookAHead.name(); \n        match(NameId); \n        check(m_assignMap.contains(lookupName ), \n              \"unknown name: \"\" + lookupName + \"\".\"); \n        return m_assignMap[lookupName ]; \n      } \n```", "```cpp\n    case ValueId: { \n        Value value = m_lookAHead.value(); \n        match(ValueId); \n        return value; \n      } \n```", "```cpp\n    default: \n      syntaxError(); \n      return Value(); \n  } \n} \n```", "```cpp\nvoid Parser::checkType(TokenId codeId, const Value& value) { \n  switch (codeId) { \n    case SetPenStyleId: \n      check(value.isPenStyle(), \"not a pen-style value\"); \n      break; \n\n    case SetBrushStyleId: \n      check(value.isBrushStyle(), \"not a brush-style value\"); \n      break; \n```", "```cpp\n    case SetPenColorId: \n    case SetBrushColorId: \n      check(value.isColor(), \"not a color value\"); \n      break; \n\n    case SetFontId: \n      check(value.isFont(), \"not a font value\"); \n      break; \n```", "```cpp\n    case SetHorizontalAlignmentId: \n    case SetVerticalAlignmentId: \n      check(value.isAlignment(), \"not an alignment value\"); \n      break; \n```", "```cpp\n    case XCoordinateId: \n    case YCoordinateId: \n      check(value.isPoint(), \"not a point value\"); \n      break; \n  } \n} \n```", "```cpp\nvoid Parser::checkType(TokenId codeId, const Value& leftValue, \n                       const Value& rightValue) { \n  switch (codeId) { \n    case DrawLineId: \n    case DrawRectangleId: \n    case DrawEllipseId: \n      check(leftValue.isPoint() && rightValue.isPoint(), \n            \"non-point values in draw expression\"); \n      break; \n```", "```cpp\n    case DrawTextId: \n      check(leftValue.isPoint() && rightValue.isString(), \n            \"invalid values in text-drawing expression\"); \n      break; \n  } \n} \n```", "```cpp\nValue Parser::evaluate(TokenId codeId, const Value& value) { \n  switch (codeId) { \n    case XCoordinateId: \n      return Value((double) value.pointValue().x()); \n\n    case YCoordinateId: \n      return Value((double) value.pointValue().y()); \n```", "```cpp\n    default: \n      assert(false); \n      return false; \n  } \n} \n```", "```cpp\nValue Parser::evaluate(TokenId codeId, const Value& leftValue, \n                          const Value& rightValue) { \n  double leftNumericalValue = leftValue.numericalValue(), \n         rightNumericalValue = rightValue.numericalValue(); \n\n  switch (codeId) { \n    case AddId: \n      return Value(leftNumericalValue + rightNumericalValue); \n\n    case SubtractId: \n      return Value(leftNumericalValue - rightNumericalValue); \n\n    case MultiplyId: \n      return Value(leftNumericalValue * rightNumericalValue); \n```", "```cpp\n    case DivideId: \n      if (rightNumericalValue == 0) { \n        semanticError(\"division by zero\"); \n      } \n\n      return Value(leftNumericalValue / rightNumericalValue); \n```", "```cpp\n    case PointId: \n      return Value(QPoint(leftNumericalValue, \n                          rightNumericalValue)); \n```", "```cpp\n    default: \n      assert(false); \n      return Value(); \n  } \n} \n```", "```cpp\n#ifndef MAINWIDGET_H \n#define MAINWIDGET_H \n\n#include <QWidget> \n#include <QtWidgets> \n#include \"Value.h\" \n#include \"Colors.h\" \n#include \"Action.h\" \n\nclass ViewerWidget : public QWidget { \n  Q_OBJECT \n```", "```cpp\n  public: \n    ViewerWidget(const QList<Action>& actionList, \n                 QWidget *parentWidget = nullptr); \n```", "```cpp\n    void paintEvent(QPaintEvent *eventPtr); \n```", "```cpp\n  private: \n    Qt::Alignment m_horizontalAlignment = Qt::AlignHCenter, \n                  m_verticalAlignment = Qt::AlignVCenter; \n    const QList<Action>& m_actionList; \n}; \n\n#endif // MAINWIDGET_H \n```", "```cpp\n#include <QtWidgets> \n#include \"ViewerWidget.h\" \n```", "```cpp\nViewerWidget::ViewerWidget(const QList<Action>& actionList, \n                           QWidget *parentWidget) \n :QWidget(parentWidget), \n  m_actionList(actionList) { \n  setWindowTitle(tr(\"Domain Specific Language\")); \n  resize(500, 300); \n} \n```", "```cpp\nvoid ViewerWidget::paintEvent(QPaintEvent* /*event*/) { \n  QPainter painter(this); \n\n  for (const Action& action : m_actionList) { \n    switch (action.id()) { \n```", "```cpp\n      case SetPenColorId: { \n          QColor penColor = action.value1().colorValue(); \n          QPen pen(penColor); \n          pen.setStyle(painter.pen().style()); \n          painter.setPen(pen); \n        } \n        break; \n\n      case SetPenStyleId: { \n          Qt::PenStyle penStyle = action.value1().penStyleValue(); \n          QPen pen(penStyle); \n          pen.setColor(painter.pen().color()); \n          painter.setPen(pen); \n        } \n        break; \n```", "```cpp\n      case SetBrushColorId: { \n          QColor brushColor = action.value1().colorValue(); \n          QBrush brush(brushColor); \n          brush.setStyle(painter.brush().style()); \n          painter.setBrush(brush); \n        } \n        break; \n\n      case SetBrushStyleId: { \n          Qt::BrushStyle brushStyle = \n            action.value1().brushStyleValue(); \n          QBrush brush(brushStyle); \n          brush.setColor(painter.brush().color()); \n          painter.setBrush(brush); \n        } \n        break; \n```", "```cpp\n      case SetFontId: { \n          QFont font = action.value1().fontValue(); \n          painter.setFont(font); \n        } \n        break; \n```", "```cpp\n      case SetHorizontalAlignmentId: \n        m_horizontalAlignment = action.value1().alignmentValue(); \n        break; \n\n      case SetVerticalAlignmentId: \n        m_verticalAlignment = action.value1().alignmentValue(); \n        break; \n```", "```cpp\n      case DrawLineId: \n        painter.drawLine(action.value1().pointValue(), \n                         action.value2().pointValue()); \n        break; \n\n      case DrawRectangleId: { \n          QRect rect(action.value1().pointValue(), \n                     action.value2().pointValue()); \n\n          painter.drawRect(rect); \n        } \n        break; \n\n      case DrawEllipseId: { \n          QRect rect(action.value1().pointValue(), \n                     action.value2().pointValue()); \n\n          painter.drawEllipse(rect); \n        } \n        break; \n```", "```cpp\n      case DrawTextId:  { \n          QPoint point = action.value1().pointValue(); \n          const QString& text = action.value2().stringValue(); \n          QFontMetrics metrics(painter.font()); \n          QSize size = metrics.size(0, text); \n```", "```cpp\n          switch (m_horizontalAlignment) { \n            case Qt::AlignHCenter: \n              point.rx() -= size.width() / 2; \n              break; \n\n            case Qt::AlignRight: \n              point.rx() -= size.width(); \n              break; \n          } \n```", "```cpp\n          switch (m_verticalAlignment) { \n            case Qt::AlignVCenter: \n              point.ry() -= size.height() / 2; \n              break; \n\n            case Qt::AlignBottom: \n              point.ry() -= size.height(); \n              break; \n          } \n\n          painter.drawText(point, text); \n        } \n        break; \n    } \n  } \n} \n```", "```cpp\n#include <QApplication> \n#include <QMessageBox> \n\n#include \"Action.h\" \n#include \"Error.h\" \n#include \"Scanner.h\" \n#include \"Parser.h\" \n#include \"ViewerWidget.h\" \n\nint main(int argc, char *argv[]) { \n  Scanner::init(); \n  QApplication application(argc, argv); \n\n  try { \n    QString path = \"C:\\Input.dsl\"; \n    QFile file(path); \n    if (!file.open(QIODevice::ReadOnly)) { \n      error(\"Cannot open file \"\" + path + \"\" for reading.\"); \n    } \n\n    QString buffer(file.readAll()); \n    Scanner scanner(buffer); \n\n    QList<Action> actionList; \n    Parser(scanner, actionList); \n\n    ViewerWidget mainWidget(actionList); \n    mainWidget.show(); \n    return application.exec(); \n  } \n```", "```cpp\n  catch (exception e) { \n    QMessageBox messageBox(QMessageBox::Information, \n                           QString(\"Error\"), QString(e.what())); \n    messageBox.exec(); \n  } \n} \n```"]