<html><head></head><body>
		<div><h1 id="_idParaDest-507" class="chapter-number"><a id="_idTextAnchor507"/>12</h1>
			<h1 id="_idParaDest-508"><a id="_idTextAnchor508"/>Manipulation and Transformation</h1>
			<p>This chapter discusses data manipulation techniques provided by the C++ <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>). These techniques of manipulating data structures, whether copying, generating new data, removing outdated entries, or performing advanced operations such as swapping or reversing, form a significant part of most applications. This chapter will expose you to many methods and nuances, allowing you to choose the right tool for your tasks. Accompanied by best practices, this chapter ensures you understand and apply these techniques efficiently.</p>
			<p>This chapter will cover the following main topics:</p>
			<ul>
				<li>Copying and moving in STL containers</li>
				<li>Exploring return value optimization</li>
				<li>Filling and generating in STL containers</li>
				<li>Removing and replacing in STL containers</li>
				<li>Swapping and reversing in STL containers</li>
				<li>Best practices</li>
			</ul>
			<h1 id="_idParaDest-509"><a id="_idTextAnchor509"/>Technical requirements</h1>
			<p>The code in this chapter can be found on GitHub:</p>
			<p><a href="https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL">https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL</a></p>
			<h1 id="_idParaDest-510"><a id="_idTextAnchor510"/>Copying and moving in STL containers</h1>
			<p>The STL in C++ is known <a id="_idIndexMarker765"/>for its robust data structures and algorithms. Among its most fundamental aspects are the operations of copying and moving containers. These operations are not only crucial for data manipulation but also play a significant role in the efficiency and performance of C++ applications. This section explores the nuances of copying and moving within the STL, exploring their semantics, implications on performance, and the strategic decision-making involved in choosing one over the other.</p>
			<h2 id="_idParaDest-511"><a id="_idTextAnchor511"/>Copying semantics in the STL</h2>
			<p><strong class="bold">Copying</strong>, in the <a id="_idIndexMarker766"/>most rudimentary sense, refers to creating a replica of an object. In the STL, when <a id="_idIndexMarker767"/>you copy a container, you duplicate its contents into a new one. One way to visualize this is to imagine photocopying a document. The original remains unchanged, and you have a new document with the same content.</p>
			<p>For instance, consider the following:</p>
			<pre class="source-code">
std::vector&lt;int&gt; original{1, 2, 3};
std::vector&lt;int&gt; duplicate(original); // Copy constructor</pre>			<p>The <code>duplicate</code> vector is now a replica of the original vector. Both containers are entirely independent; modifying one won’t affect the other. While this sounds straightforward, the devil is often in the detail. Copying can be an expensive operation, especially for large containers. Each element of the original container is duplicated, which might lead to performance pitfalls in applications where time efficiency is paramount.</p>
			<h2 id="_idParaDest-512"><a id="_idTextAnchor512"/>Moving semantics in the STL</h2>
			<p>Introduced in C++11, <strong class="bold">move semantics</strong> ushered a paradigm shift in managing resources. Instead<a id="_idIndexMarker768"/> of duplicating the content, moving transfers<a id="_idIndexMarker769"/> the <a id="_idIndexMarker770"/>ownership of resources from one object (the <em class="italic">source</em>) to another (the <em class="italic">destination</em>).</p>
			<p>Imagine you have a box of toys (<code>std::vector</code>). Instead of creating a new box and transferring toys one by one (copying), you simply hand over the box to someone else (moving). The original box is empty, and the other person owns all the toys.</p>
			<p>Here’s how it looks in the code:</p>
			<pre class="source-code">
std::vector&lt;int&gt; original{1, 2, 3};
std::vector&lt;int&gt; destination(std::move(original)); // Move constructor</pre>			<p>Post this operation, <code>destination</code> owns <a id="_idIndexMarker771"/>the data, while <code>original</code> is in a valid but unspecified <a id="_idIndexMarker772"/>state (often empty). This mechanism offers significant performance benefits, especially with large datasets, as it eliminates the overhead of duplicating data.</p>
			<h2 id="_idParaDest-513"><a id="_idTextAnchor513"/>Copying versus moving – a deliberate choice</h2>
			<p>Now, equipped <a id="_idIndexMarker773"/>with an understanding of both mechanics, the onus is on the developer to make an informed choice. Copying ensures data integrity <a id="_idIndexMarker774"/>as the original remains untouched. This is useful when the original data still plays a role in subsequent operations. However, if the original container’s data is disposable or you’re sure it won’t be needed afterward, opting for a move operation can dramatically enhance performance.</p>
			<p>Yet, caution is advised. The careless use of move semantics might lead to surprises, especially if one assumes data still resides in the source container. Always be conscious of the state of your objects after any operation.</p>
			<p>Here’s an example demonstrating the potential pitfalls of the careless use of move semantics:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
void printVector(const std::vector&lt;int&gt; &amp;vec,
                 const std::string &amp;name) {
  std::cout &lt;&lt; name &lt;&lt; ": ";
  for (int val : vec) { std::cout &lt;&lt; val &lt;&lt; " "; }
  std::cout &lt;&lt; "\n";
}
int main() {
  std::vector&lt;int&gt; source = {10, 20, 30, 40, 50};
  std::vector&lt;int&gt; destination = std::move(source);
  std::cout
      &lt;&lt; "Trying to access the 'source' vector after "
         "moving its data:\n";
  printVector(source, "Source");
  printVector(destination, "Destination");
  source.push_back(60);
  std::cout &lt;&lt; "After trying to add data to 'source' "
               "post-move:\n";
  printVector(source, "Source");
  return 0;
}</pre>			<p>The following<a id="_idIndexMarker775"/> is the <a id="_idIndexMarker776"/>output of the preceding code:</p>
			<pre class="console">
Trying to access the 'source' vector after moving its data:
Source:
Destination: 10 20 30 40 50
After trying to add data to 'source' post-move:
Source: 60</pre>			<p>As shown, the <code>source</code> vector is in a valid but unspecified state after moving data from <code>source</code> to <code>destination</code>. It’s empty, but operations such as <code>push_back</code> can still be performed. The key takeaway is that one should be aware of such states and not assume that the <code>source</code> container’s data is intact after a move.</p>
			<p>In essence, the <a id="_idIndexMarker777"/>power of the STL is magnified when the developer understands the nuances of its operations. Copying and moving are foundational pillars, determining<a id="_idIndexMarker778"/> how data is managed and how efficiently an application runs. As we venture deeper into manipulation and transformation techniques in subsequent sections, always keep these mechanics in mind. They often form the bedrock upon which advanced techniques are built.</p>
			<h1 id="_idParaDest-514"><a id="_idTextAnchor514"/>Exploring return value optimization</h1>
			<p><strong class="bold">Return value optimization </strong>(<strong class="bold">RVO</strong>) deserves special mention. Modern compilers optimize<a id="_idIndexMarker779"/> returning objects from functions, effectively transforming what looks like a copy into a move, making the operation highly efficient. This is a testament to the evolving nature of C++ and its inclination towards performance optimization.</p>
			<p>Here’s a code example to demonstrate the concept of RVO:</p>
			<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;vector&gt;
class Sample {
public:
  Sample() { std::cout &lt;&lt; "Constructor called!\n"; }
  Sample(const Sample &amp;) {
    std::cout &lt;&lt; "Copy Constructor called!\n";
  }
  Sample(Sample &amp;&amp;) noexcept {
    std::cout &lt;&lt; "Move Constructor called!\n";
  }
  ~Sample() { std::cout &lt;&lt; "Destructor called!\n"; }
};
Sample createSample() { return Sample(); }
int main() {
  std::cout &lt;&lt; "Creating object via function return:\n";
  Sample obj = createSample();
  return 0;
}</pre>			<p>In this <a id="_idIndexMarker780"/>code, when the function <code>createSample</code> is called, it returns a <code>Sample</code> object. Without RVO, we might expect a sequence of calls: <code>Constructor</code> -&gt; <code>Copy Constructor</code> (or <code>Move Constructor</code>) -&gt; <code>Destructor</code>. However, because of RVO, many modern compilers will optimize the creation so that only the constructor is called. The output typically would be as follows:</p>
			<pre class="console">
Creating object via function return:
Constructor called!
Destructor called!</pre>			<p>The absence of a call to the Copy Constructor (<code>Sample(const Sample&amp;)</code>) or Move Constructor (<code>Sample(Sample&amp;&amp;) noexcept</code>) indicates that RVO took place. The object was constructed directly in the memory location of <code>obj</code> without the need for additional copying or moving.</p>
			<p>Next, let’s explore efficient ways of automatically populating STL containers using the concepts of filling and generating elements.</p>
			<h1 id="_idParaDest-515"><a id="_idTextAnchor515"/>Filling and generating in STL containers</h1>
			<p>Populating<a id="_idIndexMarker781"/> containers and generating data within them is akin to molding clay into a sculpture. The data structure is your foundation, and the techniques to fill and <a id="_idIndexMarker782"/>generate data give life to your programs. As we continue to unearth the vast capabilities of the STL, this segment is dedicated to the pivotal techniques of <em class="italic">filling and generating</em> in STL containers. Let’s roll up our sleeves and dive into the art and science of crafting data structures with precision!</p>
			<h2 id="_idParaDest-516"><a id="_idTextAnchor516"/>Populating with static assignment</h2>
			<p>Imagine a <a id="_idIndexMarker783"/>scenario where you need a container filled with a specific value, be it zeroes, a particular character, or any other repeating pattern. The STL simplifies this with methods tailored for static assignments.</p>
			<p>For instance, the <code>std::vector</code> offers an overload of its constructor that allows you to specify a size and a default value:</p>
			<pre class="source-code">
std::vector&lt;int&gt; v(5, 2112);</pre>			<p>Such a method ensures uniformity of data, which is essential for operations that rely on homogeneous collections. This isn’t exclusive to vectors. Many STL containers provide similar functionalities, ensuring developers have the necessary tools for various contexts.</p>
			<h2 id="_idParaDest-517"><a id="_idTextAnchor517"/>Dynamic generation with the STL</h2>
			<p>While<a id="_idIndexMarker784"/> static assignment has its charm, more often, there’s a need for dynamic data generation. Whether it is for creating test cases, simulating scenarios, or any situation demanding a specific pattern, the STL doesn’t disappoint.</p>
			<p>The STL provides the <code>std::generate</code> and <code>std::generate_n</code> algorithms for these needs. These functions assign values to a container based on a generator function.</p>
			<p>Consider the following example:</p>
			<pre class="source-code">
std::vector&lt;int&gt; v(5);
std::generate(v.begin(), v.end(), [n = 0]() mutable { return n++; });</pre>			<p>Here, we’ve<a id="_idIndexMarker785"/> leveraged a lambda function to generate consecutive integers dynamically. This method offers unparalleled flexibility, allowing developers to generate data as simple as incrementing numbers or as complex as values based on intricate formulas or computations.</p>
			<h2 id="_idParaDest-518"><a id="_idTextAnchor518"/>Ensuring relevance and efficiency</h2>
			<p>Now, having <a id="_idIndexMarker786"/>the tools is only half the battle. Employing them effectively is where mastery shines. When filling and generating data, do the following:</p>
			<ul>
				<li><strong class="bold">Choose appropriately</strong>: Consider the data’s lifecycle. If the dataset remains static post-creation, static assignments are straightforward and efficient. However, for ever-evolving data, dynamic generation methods provide flexibility and adaptability.</li>
				<li><strong class="bold">Mind the size</strong>: Overpopulating can lead to memory inefficiencies, while underpopulating might result in incomplete operations or unexpected behaviors. Always be keenly aware of the size requirements.</li>
				<li><strong class="bold">Harness the power of lambdas</strong>: With C++11 and onward, lambdas concisely define quick functions. They are invaluable in dynamic generation, allowing for tailored functions without the verbosity of traditional function definitions.</li>
				<li><strong class="bold">Consider real-world contexts</strong>: Always relate to the problem at hand. If you’re populating a container to simulate real-world data, ensure that your filling and generating techniques mirror realistic scenarios. It’s not just about filling containers but filling them with purpose.</li>
			</ul>
			<p>To summarize, the ability to effectively fill and generate data in STL containers is a testament to the library’s robustness. Whether you’re aiming for uniformity with static assignments or seeking the dynamic flair of generated patterns, the STL is well-equipped to handle your needs. As we progress toward more intricate manipulations in the coming sections, always remember that data is the heart of your application. How you shape and nurture it often determines the rhythm and pulse of your programs.</p>
			<h1 id="_idParaDest-519"><a id="_idTextAnchor519"/>Removing and replacing in STL containers</h1>
			<p>In data manipulation using the C++ STL, we often find ourselves adding or viewing elements and engaging in curating them. As we peel the layers of this chapter, the art of <em class="italic">removing and replacing</em> emerges <a id="_idIndexMarker787"/>as an essential skill, striking the perfect balance between retaining the valuable and discarding the redundant. By mastering these operations, you can elevate your proficiency in handling STL containers, enhancing data relevance and overall efficiency.</p>
			<h2 id="_idParaDest-520"><a id="_idTextAnchor520"/>The essence of removal</h2>
			<p>When we dive<a id="_idIndexMarker788"/> into the rich waters of data storage in the STL, there’s an undeniable need for refining. Whether it is the removal of outdated records, anomalies, or any redundancies, the STL has powerful tools to assist you. One can<a id="_idIndexMarker789"/> pinpoint specific values or conditions for purging using functions such as erase and remove. For instance, with <code>std::remove</code>, it’s possible to relocate particular elements to the end of a sequence container, while <code>erase</code> can permanently eliminate them. It’s this tandem of operations that ensures a seamless cleanup.</p>
			<p>Yet, while removal operations are efficient, caution is essential. Mindlessly erasing elements can disturb container continuity and even impact performance. The key is to employ these operations judiciously and be constantly aware of iterator validity and potential reallocations, especially in dynamic containers such as <code>std::vector</code>.</p>
			<h2 id="_idParaDest-521"><a id="_idTextAnchor521"/>Replacement</h2>
			<p>Imagine<a id="_idIndexMarker790"/> having <a id="_idIndexMarker791"/>a collection of dated values or placeholder elements, and the need arises to update them. The STL doesn’t leave you stranded. Functions such as <code>std::replace</code> and <code>std::replace_if</code> are your allies in this endeavor. With <code>std::replace</code>, you can seamlessly swap old values with new ones throughout your collection. For more complex scenarios, where the replacement criteria aren’t just a simple value match, <code>std::replace_if</code> steps into the spotlight. <code>std::replace_if</code> allows conditions often expressed through lambdas or function objects to dictate the replacement.</p>
			<p>For a hands-on example, consider a collection where negative values are deemed errors and need updating. With <code>std::replace_if</code>, you can hunt down every negative value and replace it with a default or corrected value, all in a single, elegant line of code.</p>
			<p>Let’s look<a id="_idIndexMarker792"/> at an example of using <code>std::replace</code> and <code>std::replace_if</code>:</p>
			<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
  std::vector&lt;int&gt; values = {10, -1, 20, -2, 30};
  // Using std::replace to update a specific value
  std::replace(values.begin(), values.end(), -1,
               0); // Replace -1 with 0
  // Using std::replace_if to update based on a condition
  std::replace_if(
      values.begin(), values.end(),
      [](int value) {
        return value &lt; 0;
      },  // Lambda function for condition
      0); // Replace negative values with 0
  // Printing the updated collection
  for (int value : values) { std::cout &lt;&lt; value &lt;&lt; " "; }
  std::cout &lt;&lt; std::endl;
  return 0;
}</pre>			<p>Here is<a id="_idIndexMarker793"/> the example output:</p>
			<pre class="console">
10 0 20 0 30</pre>			<p>In this example, we use <code>std::replace</code> to find and replace a specific value (-1) with 0. We then use <code>std::replace_if</code> with a lambda function to identify negative values and replace them with 0. This example demonstrates the use of <code>std::replace</code> for simple, direct replacements and <code>std::replace_if</code> for more complex scenarios where a condition (such as identifying negative values) dictates the replacement.</p>
			<h2 id="_idParaDest-522"><a id="_idTextAnchor522"/>A balancing act</h2>
			<p>Balancing <a id="_idIndexMarker794"/>removal and replacement requires a sense of rhythm and balance. While it is tempting to curate aggressively, sometimes retaining specific data, even if outdated or redundant, can serve as a historical record or a point of reference. Therefore, always approach removal and replacement with a clear objective, ensuring data integrity, relevance, and efficiency aren’t compromised.</p>
			<p>In this section, we’ve honed the skill of curating and modifying collections, focusing on removing and replacing them. This process is pivotal, as it balances the retention of valuable data with the elimination of redundancy, enhancing both data relevance and container efficiency. We’ve explored the strategic use of functions such as <code>erase</code> and <code>remove</code> for precision in data refinement and the importance of cautious removal to maintain container integrity and performance. We learned about the replacement techniques using <code>std::replace</code> and <code>std::replace_if</code>, which are instrumental in updating collections, especially when dealing with complex conditions. These tools not only ensure the freshness and accuracy of data but also highlight the flexibility and power of the STL in data manipulation.</p>
			<p>Next, we approach swapping and reversing, demonstrating how to efficiently alter the order and positioning of elements within containers, a vital aspect of managing and manipulating data structures in C++.</p>
			<h1 id="_idParaDest-523"><a id="_idTextAnchor523"/>Swapping and reversing in STL containers</h1>
			<p>While we have<a id="_idIndexMarker795"/> traversed through adding, initializing, and refining our STL containers, there lies an equally intriguing domain where we maneuver and shuffle elements to align with our requirements. This section promises to take you on an expedition, showcasing the capabilities of the STL in repositioning and reshuffling elements while also touching upon intricate manipulations including deduplication and sampling.</p>
			<h2 id="_idParaDest-524"><a id="_idTextAnchor524"/>Swapping – the art of interchanging</h2>
			<p>In many<a id="_idIndexMarker796"/> real-world scenarios, the need arises to interchange content between containers. Whether for load balancing, data synchronization, or other computational tasks, the STL offers the swap function, an efficient and streamlined mechanism.</p>
			<p>For instance, the <code>std::swap</code> can be used with almost all STL containers. If you’ve two <code>std::vectors</code> and wish to exchange their contents, <code>std::swap</code> does the magic in constant time without any overhead of copying or moving individual elements. This efficiency is derived from the fact that underlying data pointers are swapped, not the actual content.</p>
			<h2 id="_idParaDest-525"><a id="_idTextAnchor525"/>Reversing – a glimpse from the end</h2>
			<p>Sometimes, looking<a id="_idIndexMarker797"/> at things from a different perspective<a id="_idIndexMarker798"/> brings clarity, and the same holds true for data. The STL provides the <code>std::reverse</code> algorithm, which inverts the order of elements within a container, offering a fresh view or aiding specific computational needs. Whether analyzing data trends or catering to a reverse chronological requirement, <code>std::reverse</code> ensures your containers can flip their sequence in linear time.</p>
			<h2 id="_idParaDest-526"><a id="_idTextAnchor526"/>Deduplication – singling out the unique</h2>
			<p>As our <a id="_idIndexMarker799"/>data grows, so does the likelihood of redundancies. However, the <a id="_idIndexMarker800"/>STL is well prepared to tackle such situations. The <code>std::unique</code> algorithm helps remove consecutive duplicates in a sorted sequence. While it does not delete the duplicates directly, it repositions them to the end of the container, making it convenient to erase them if needed. When paired with <code>std::sort</code>, <code>std::unique</code> becomes a potent tool in ensuring that your container retains only singular instances of every element.</p>
			<h2 id="_idParaDest-527"><a id="_idTextAnchor527"/>Sampling – a slice of the whole</h2>
			<p>On occasions, there’s <a id="_idIndexMarker801"/>a need to sample a subset from a more extensive collection. While the STL does not provide a direct <em class="italic">sample</em> function, one can derive a sample with a combination of other tools, like random shuffle algorithms. By randomly <a id="_idIndexMarker802"/>shuffling and then selecting the first <code>n</code> elements, you get a representative sample that can be used for testing, analysis, or any other purpose.</p>
			<p>Swapping, reversing, deduplication, and sampling are just glimpses into the expansive capabilities of the STL. They represent the dynamic nature of data and the myriad ways we might need to interact with it. As you continue your journey, remember that the STL is more than just tools and functions; it’s a suite designed to move, mold, and manage your data efficiently.</p>
			<h1 id="_idParaDest-528"><a id="_idTextAnchor528"/>Best practices</h1>
			<p>Let’s <a id="_idIndexMarker803"/>review optimal ways of implementing STL algorithms to ensure efficiency, maintain data integrity, and recognize the most apt methods suitable for diverse use cases.</p>
			<ul>
				<li><code>std::sort</code> is versatile but may not be optimal for partially sorted sequences, where <code>std::partial_sort </code>or <code>std::stable_sort</code> may prevail.</li>
				<li><strong class="bold">Prefer algorithms over hand-written loops</strong>: When confronted with tasks like searching or sorting, favor STL algorithms over hand-written loops as they are optimized and tested extensively, rendering them more reliable and often faster.</li>
				<li><code>const</code> wherever possible. It maintains data integrity and provides better interface insights, avoiding accidental modifications.</li>
				<li><code>std::copy_n</code> ensures no out-of-bound accesses compared to <code>std::copy</code>.</li>
				<li><code>std::count</code>.</li>
				<li><code>std::transform</code> would be more suited than <code>std::for_each</code>.</li>
				<li><code>std::vector::reserve</code> to preallocate memory. This practice avoids unnecessary reallocations, enhancing performance.</li>
				<li><code>std::set</code> for frequent lookups, can significantly optimize performance.</li>
				<li><code>std::move</code> help in achieving this.</li>
			</ul>
			<h1 id="_idParaDest-529"><a id="_idTextAnchor529"/>Summary</h1>
			<p>This chapter covered the essential techniques for altering and shaping data within STL containers. We began by understanding the nuances of copying and moving semantics in the STL, learning to make deliberate choices between copying versus moving elements depending on the context to optimize performance and resource management. We then explored RVO, a technique for optimizing compilers that removes redundant object copying.</p>
			<p>We then examined the methods for filling and generating container contents, which are vital to efficiently initializing and modifying large datasets. We covered the mechanisms for removing and replacing elements within containers, balancing the need for data integrity with performance. The chapter also introduced the operations of swapping and reversing elements, deduplication to eliminate duplicates, and sampling to create representative subsets of data. Throughout, we focused on best practices to ensure that these operations are executed with precision and efficiency.</p>
			<p>As we build more complex programs, we frequently encounter the need to manipulate large data sets. Proficiency in these operations enables the creation of more sophisticated and performant applications, making the information valuable and vital for modern C++ programming.</p>
			<p>In the next chapter, we will focus on basic and advanced numeric operations such as generating sequences, summing elements, and working with adjacent differences and inner products. We will also look at operations on sorted ranges, consolidating our understanding of how to apply STL algorithms to numerical data, thereby enhancing our toolkit for algorithmic problem-solving in C++. This next chapter will continue to build on the foundation laid by previous chapters, ensuring a cohesive and comprehensive understanding of the STL’s capabilities.</p>
		</div>
	</body></html>