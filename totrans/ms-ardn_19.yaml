- en: Creating a Robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I first started working with development boards like the Arduino, my initial
    goal was to build a robot. However, I had no idea where to start. I had so many
    questions, what is a good body style for the robot? What motors should I use?
    How do I power the robot? Do I need a separate power source for the motors? How
    does object avoidance work? This chapter is written to help answer a lot of these
    question for you and to show you that after reading the previous chapters in this
    book, you now have enough knowledge to design and build your own robot.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: How we can use what we learned in this book to create a fully-working robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A range of additional tips and hints that will help you with your projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the other projects we can build with the Arduino beyond this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will finish the chapter by challenging you to create your own project and
    then share it with us.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, unlike previous project chapters, we will not be designing
    and building a specific project. Instead, we will show you how you can take the
    knowledge that you gained in previous chapters and use it to design your own robot.
    We will also give you various tips and hints to help you avoid some of the mistakes
    that people make when they first started building robots.
  prefs: []
  type: TYPE_NORMAL
- en: When we started designing our first robot, the first thing that we did was to
    decide what the robot should do because we thought the whole robot design should
    revolve around the robot's purpose. That was a BIG mistake because the list of
    items for the robot to do was extensive. It was going to be a cross between R2-D2,
    Wall-E and Commander Data. It was going to be the most awesome robot ever and
    then, as you can probably guess, we got really overwhelmed and had to scale everything
    way back.
  prefs: []
  type: TYPE_NORMAL
- en: When initially designing your first few robots, you should start with either
    designing/buying the robot chassis (body) or figuring how the robot should move.
    It really is a chicken and egg dilemma here because what chassis you use really
    defines how the robot will move, but on the other hand, how the robot should move
    (or even not move at all) defines what type of chassis you need; therefore, I
    usually try to take both into account when designing robots.
  prefs: []
  type: TYPE_NORMAL
- en: Chassis and movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the easiest ways to get started building a robot is to purchase an off-the-shelf
    tank chassis. Some of these chassis even have the motors and motor controllers
    built in, or they are designed to work together, which makes it even easier to
    get started. The first robot that I built used the Rover 5 Tank Chassis and the
    Rover 5 Motor Controller Board, designed and manufactured by Dagu Electronics.
    Here is a photograph of my first robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01915329-0f3b-4bc1-a400-8c15c8819b44.png)'
  prefs: []
  type: TYPE_IMG
- en: All of the parts for this robot were bought including the top plate that the
    boards are connected too. Purchasing all of these parts can quickly get expensive,
    especially as you begin to add additional sensors and equipment to the robot.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are planning on building numerous robots, or even doing a lot of other
    prototyping with the Arduino, it is worth the money to purchase a 3D printer because
    rather than buying premade parts for the chassis, you can design and print your
    own. As an example, a little while ago I took the Rover 5 chassis back out and
    created another robot with it that I named BuddyBot. It was created using parts
    that I designed and printed, which enabled me to get the BuddyBot the look I wanted
    it to have. The following photograph show the front of the BuddyBot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53e20eef-9247-4dad-a695-1bbf78208ed1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can even print the entire chassis if you want. The following photograph
    shows two robot chassis that I designed and printed with my 3D printer. The chassis
    on the left is one where I printed the entire chassis, and the one on the right
    is an experimental chassis that I am designing. I also printed the Omni wheels
    for the chassis on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/852ced30-7477-47a5-9963-26ccf96731ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Chassis come in all shapes and sizes. Finding or designing the perfect one is
    usually one of the easiest parts of building your robot. The key is to make sure
    you have a chassis that can be expanded. If you notice, in the preceding photograph,
    the plates have long and narrow rectangular groves in them. These are designed
    so we can remove and add new parts very easily. You will notice that the little
    breadboards, on the left-hand robot in the preceding photograph, can be unscrewed
    and removed or moved to a different part of the robot very easily.
  prefs: []
  type: TYPE_NORMAL
- en: By designing the robot in a modular way, we can very quickly expand its functionality.
    You will want to avoid chassis that have limited expandability because, unless
    you are designing a robot for a particular function, you will always be thinking
    of new components and functionality that you would like to add to it.
  prefs: []
  type: TYPE_NORMAL
- en: We have talked a lot about chassis so far but what about defining how the robot
    will move? The Rover 5 chassis that I showed earlier in this chapter uses tank
    treads to move. The yellow robot that was in the previous photograph uses the
    standard and very cheap Arduino car motor and wheels (which is shown in the following
    photograph) while the experimental chassis uses Omni wheels that I printed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/445af25b-6610-424c-9348-c9dbfb43b3f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Using tank treads to move your robot gives you the ability to move on almost
    any terrain. However, they are more expensive than standard wheels/motors, and
    the chassis has to be designed for them as well. You also tend to need motors
    with higher torque, but we will talk about motors in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the Arduino car motor and wheel is a much cheaper option than the tank
    treads, however you are limiting your robot to indoor use unless you have a high-end
    chassis like the Bogie Runt Rover shown in the following photograph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b995a348-f401-4de8-9e86-bc01be06f0f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Bogie Runt Rover is a very nice chassis to work with, but I would definitely
    recommend having a 3D printer so you can print your own expansion parts for it.
  prefs: []
  type: TYPE_NORMAL
- en: Omni wheels are a very particular type of wheels that have small discs around
    the wheel that allow them to be pushed laterally because the small discs will
    spin, which reduces the friction. If you ask people that have used Omni wheels
    their opinion of them, the answers you receive will range the entire spectrum
    as some people absolutely hate them and think they are useless, while others love
    them.
  prefs: []
  type: TYPE_NORMAL
- en: You can also make robots that walk. These types of robots are beyond an introductory
    book like this, and I would recommend for your first couple of robots you stick
    with something that uses tank treads or wheels.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at motors and how we would power them.
  prefs: []
  type: TYPE_NORMAL
- en: Motors and power
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deciding what motor to use and how to power them can be one of the hardest
    decisions you make when you start building robots because there are so many choices.
    The following photograph shows some of the motors that I have used in my projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8bec30d-dd55-46e7-ae2a-d2c760705d5f.png)'
  prefs: []
  type: TYPE_IMG
- en: It can save you a lot of money to get used motors, and there are a number of
    ways that you can acquire them. I have bought numerous used remote-controlled
    cars and other electronics like old DVD players and removed the motors from them.
    That is where the two smallest motors shown in the preceding photograph came from;
    however, if you want more powerful motors, look at removing the motors from power
    drills. The largest motor in the preceding photograph came from an old Ryobi 12V
    drill.
  prefs: []
  type: TYPE_NORMAL
- en: When you first start building robots, I would recommend starting with the Arduino
    car motor. They are very easy to use and are designed to power robotic cars. They
    can also be powered by a wide range of power sources because they can handle voltages
    as low as 3V and as high as 12V. The recommended voltage range is 6V to 8V. However,
    I often use a 12V battery that has a maximum current of 1.3A to power these motors.
    When you purchase motors, make sure you read the specifications carefully to ensure
    the motor is rated for the power source you are using in your project.
  prefs: []
  type: TYPE_NORMAL
- en: To control the motors, you will want to use a motor controller. The L298 motor
    controller that we showed in [Chapter 15](ae9be0ca-807d-4a0a-b4e4-4f4fd07bd981.xhtml),
    *DC Motors and Motor Controllers*, is a perfect motor controller to start with.
    It handles a wide range of voltages from 5V up to 46V and current up to 2A. You
    can refer back to [Chapter 15](ae9be0ca-807d-4a0a-b4e4-4f4fd07bd981.xhtml), *DC
    Motors and Motor Controllers*, to see how to use this controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Powering the motors can be confusing at first especially when purchasing batteries.
    To begin with, you do not want to power the motors from the Arduino''s 5V power
    source. For small robotic projects, you can use AA batteries or a 9V battery.
    For chassis that can handle a larger battery, I would recommend getting a small
    12V battery like the Duracell Ultra 12V 1.3Ah one shown in the following photograph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3d49e99-e25b-4298-be38-1746ac5ef843.png)'
  prefs: []
  type: TYPE_IMG
- en: One critical factor when picking out the battery is the specifications of the
    motors and how many you will have. When you connect the motors, through the motor
    controllers, to the battery, you will be connecting them in parallel to each other.
    If you recall the comparison between series and parallel circuits in [Chapter
    3](de9d9edf-fdf1-410b-bb8a-98ef4b185166.xhtml), *Circuit Diagrams*, you will remember
    that in a parallel circuit each branch will have the maximum voltage that is output
    from the power source. However, the current will be divided up between the branches.
    This means that if our battery can produce 12V and 1.2A and we are attempting
    to power 6 motors, then each motor will have 12V and can draw 200mA (1.2A divided
    by 6) if each motor is rotating at the same speed. Therefore, the Duracell Ultra
    that was previously shown will be fine to power six Arduino car motors, but if
    you are looking at using larger motors you may need a battery with a larger capacity.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the Duracell battery was rated at 12V and 1.3Ah. Do
    not confuse the Ah rating with Amps. A battery is rated by the capacity, and 1.3Ah
    means that it can continuously supply 1.3A for 1 hour before you need to recharge
    it.
  prefs: []
  type: TYPE_NORMAL
- en: One good rule to use when picking up the battery that will power your robotic
    project is; it is better to have more power rather than less. This rule works
    great unless you take it to the extreme and try to use a 12V battery to power
    a little RC car that has two small motors.
  prefs: []
  type: TYPE_NORMAL
- en: With the L298 motor controller, we can control the speed and direction of the
    wheels, which enables us to steer robots with wheels or tank tracks. The robot
    will turn if the wheels or track on one side of the robot are rotating faster
    than the wheels or track on the other side. The higher the speed difference is
    between the two sides, the faster the robot will turn. You can also spin a robot
    in place by having the wheels or tracks on one side of the robot rotating in a
    forward direction while the wheels or track on the other is rotating in the reverse
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: Autonomous robot–obstacle avoidance and collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to build an autonomous robot, you will need to have some form of
    obstacle avoidance and collision detection with the logic that tells the robot
    how to move around obstacles. We showed how to use several obstacle avoidances
    and collision detection sensors in [Chapter 10](52e8daa7-b58a-4c75-ac23-13795fc1279d.xhtml),
    *Obstacle Avoidance and Collision Detection*, but the question may be how we develop
    logic to go around or avoid objects that are detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start to discuss the logic of obstacle avoidance, let''s take a look
    at the BuddyBot robot again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8adcbd4b-58fa-4603-a8e3-f5e7138327dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you look closely at the "eyes" on the BuddyBot, you may recognize them as
    the MaxSonar EZ1 Ultrasonic range finder that was discussed in [Chapter 10](52e8daa7-b58a-4c75-ac23-13795fc1279d.xhtml),
    *Obstacle Avoidance and Collision Detection*. To refresh your memory, the MaxSonar
    EZ1 works by sending an ultrasonic pulse in a particular direction. If there is
    an object in the path of the pulse, then it is reflected back in the form of an
    echo. The sensor determines the distance to the object by measuring the time it
    takes for the echo to be received. The following photograph shows what the MaxSonar
    EZ1 looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd1c6f84-3d97-4469-a26e-e384a3e8abe0.png)'
  prefs: []
  type: TYPE_IMG
- en: The BuddyBot uses two MaxSonar range finders to help with the obstacle avoidance
    logic. Let's see how this works. The first thing we need to do is to determine
    at what distance we want to start the obstacle avoidance logic. For example, we
    probably do not have to worry about avoiding obstacles that are five feet away
    if we are building a small robot that is moving around in a house. If we have
    a large robot that is moving around in a factory maybe five feet is a reasonable
    distance to start the obstacle avoidance logic at. The environment that the robot
    will be moving in plays a big part in designing the obstacle avoidance logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the correct distance to start the obstacle avoidance logic at is determined,
    we can then start building the logic. By using two sensors, we are able to determine
    at what angle the robot is approaching the object at. This next diagram shows
    the robot approaching an object at a slight angle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c523318-1b08-4648-a29e-c905b3b06193.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the robot approaches an object at an angle like this, we can compare the
    distance being reported by both range finders and determine that the object is
    closer to the left side of the robot. By determining that the left side of the
    robot is closer to the object, we can use some fundamental logic to tell the robot
    to turn right until the object is out of range, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95dfb92d-0e9b-40ac-97ce-58680eff0b3a.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the object is out of range, we can start moving forward again. This is
    very basic obstacle avoidance and does require constant polling of the rangefinder.
    For a cheaper option, because the MaxSonar rangefinders are fairly expensive as
    compared to other sensors, we could use the infrared obstacle avoidance sensor
    that is also described in [Chapter 10](52e8daa7-b58a-4c75-ac23-13795fc1279d.xhtml),
    *Obstacle Avoidance and Collision Detection*. The reason that I prefer the MaxSonar
    rangefinder is that the infrared radiation beam that is emitted from the IR sensor
    is a much narrower beam than the sound wave that is emitted from the MaxSonar
    rangefinder. With the wider beam from the rangefinder, it is less likely that
    we will miss objects that are slightly to the left/right or higher/lower than
    the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: You will also want to put crash sensors around the robot as well; these can
    be used to detect when the robot bumps into something. These work very well on
    the back of the robot to detect if the robot bumps into something while it is
    reversing. Obstacle avoidance can be a very complicated subject, one that is easy
    to get started in, as shown here, but can because very complex.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at how we can control a robot remotely.
  prefs: []
  type: TYPE_NORMAL
- en: Remotely controlling a robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The RF remote that we saw in [Chapter 18](0827eed0-09b6-40ed-acdd-f96c99070cc3.xhtml),
    *Remotely Controlling the Arduino*, is a much better choice for remotely controlling
    a robot than the IR remote because the RF remote does not need line of sight for
    the signal. The only issue with the RF remote is there usually is not enough buttons
    for everything we want our robots to do. This lack of buttons can be overcome
    by making the robot an autonomous robot where it can use object avoidance to move
    around on its own but then use the remote to tell the robot to perform a specific
    task. These tasks can include things like telling the robot to start/stop moving,
    play music through a speaker or to bring you a drink from the refrigerator.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of [Chapter 18](0827eed0-09b6-40ed-acdd-f96c99070cc3.xhtml), *Remotely
    Controlling the Arduino*, you were challenged to think outside the box for ways
    to remotely control a project other than using a wireless signal. Think about
    your answers to that challenge and see if you can use them to control a robot.
  prefs: []
  type: TYPE_NORMAL
- en: One of my favorite ways to control a robot is through voice recognition using
    the MOVI shield that we saw in [Chapter 14](1a9c14c7-bf3a-4e1a-9ac9-97aa54e8de9c.xhtml),
    *Speech Recognition and Voice Synthesizer*. With the MOVI shield, we can program
    in commands such as *turn right*, *turn left*, *stop*, or anything else you want
    your robot to do.
  prefs: []
  type: TYPE_NORMAL
- en: Another sensor that we can use is a sound sensor where we put three or four
    in a circular or square pattern around the robot, so it can detect the direction
    that the sound is coming from and then move in that direction. We could also use
    a single sound sensor to start or stop the robot when we clap or make some other
    loud noise.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how we can provide feedback to the user of the robot.
  prefs: []
  type: TYPE_NORMAL
- en: User feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We always want to provide some way to provide feedback to let us know what is
    going on with the robot. This is very handy when we are programming the robot
    for debugging purposes. If you recall the image of the BuddyBot from earlier in
    this chapter, the nose was lit up by a multicolor LEDs. The LED color indicated
    what the robot was supposed to be doing and if it detected obstacles on the left
    or right side. By seeing what color the LED was, I knew what the robot was supposed
    to be doing, and if it wasn't doing it, I knew something was wrong with the programming
    or hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Using multicolor LEDs is one of the easiest and quickest ways to add feedback
    from our robot. We can very quickly set different colors to indicate different
    activities. If we need to indicate multiple activities at the same time, we could
    add multiple LEDs without it costing much. I prefer multicolor LEDs to single-color
    ones because we can use different colors to indicate different things, while the
    single-color LEDs are either on or off, and therefore they can only indicate one
    item.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to provide feedback is with sounds. In [Chapter 12](afa4e27f-eafc-4eac-b792-8f550ac82b0d.xhtml),
    *Fun with Sound*, we saw how the Arduino could produce sound using various speakers.
    If you have ever used the Roomba or another autonomous robot vacuum, you are aware
    that when something is wrong, like the vacuum is stuck on something, it makes
    a sound to let the owner know that it is stuck. Playing a sound is another easy
    way to add feedback from the robot.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](5daf3c48-d927-436f-81ec-0b04d23d764f.xhtml), *Using LCD Displays*,
    we say how we could use LCD displays to relay messages from our project. Adding
    an LCD display enables your project to give precise information to the user. These
    can be in the form of words or images.
  prefs: []
  type: TYPE_NORMAL
- en: User feedback should be one of the first things you put into your project because
    it can be used to help with troubleshooting while you are developing your project.
    Now let's talk about how we can make things rotate.
  prefs: []
  type: TYPE_NORMAL
- en: Making things rotate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 16](8bb8e06e-4b6c-4855-9501-47e383f3c423.xhtml), *Servo Motors*,
    we saw how we could use a servo motor to open and close a robotic claw; however,
    a servo motor can do so much more than that. With a servo motor, as we saw with
    the robotic claw, we can rotate the motor to a specific angle. In the past, I
    have attached a MaxSonar Range Finder to a servo motor and pointed the sensor
    straight ahead. Then when the rangefinder detected an object in front of the robot,
    the servo would turn the rangefinder in different directions, so it could determine
    the best direction to move in. This enabled me to build an autonomous robot, with
    obstacle avoidance, using only a single rangefinder.
  prefs: []
  type: TYPE_NORMAL
- en: We could also attach a light source to a servo motor to make a rotating searchlight
    that will enable you to see where the robot is in the dark, or equally it is just
    a really cool addition to your robot with really no functional purpose.
  prefs: []
  type: TYPE_NORMAL
- en: An essential piece of advice I recommend is that when you first start creating
    robots you avoid attempting to attach a robotic arm to your robot. Robotic arms
    usually weigh too much for most small to medium robot chassis, and it takes a
    lot of programming to get them to move precisely where you want them to. I am
    not saying that you should not think about adding a robotic arm to your robot.
    However, it is a really advanced project that will take a lot of time to perfect.
  prefs: []
  type: TYPE_NORMAL
- en: Non-robotic projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are not into robots, there are still a lot of other projects that you
    can do with the Arduino. Let's take a look at a few of these.
  prefs: []
  type: TYPE_NORMAL
- en: Weather station
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 9](4334ea1c-5df5-4be7-a7c1-86592cb3aaa6.xhtml), *Environment Sensors*,
    we saw how to use numerous environmental sensors like the DHT-11 temperature/humid
    sensor and the rain sensor. We could use these sensors with any additional ones,
    like a wind speed sensor to develop a weather station. Just remember that you
    will need to put the Arduino and other electronic parts in a weatherproof container.
  prefs: []
  type: TYPE_NORMAL
- en: Smart thermostat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 9](4334ea1c-5df5-4be7-a7c1-86592cb3aaa6.xhtml), *Environment Sensors*,
    we saw how an Arduino could read the temperature and humidity with the DHT-11
    temperature/humidity sensor. If we connected a window or portable air conditioning
    unit or a humidifier to a relay board, as described in [Chapter 17](0cc53090-df80-4c8e-8cd1-4f42f779a053.xhtml),
    *Using a Relay*, we can tune the air conditioning unit and/or humidifier on or
    off automatically.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, using a relay board, you can turn almost any AC, powered device on
    or off depending on what various sensors read. For example, we could very easily
    create our own clapper clone by connecting a sound sensor to the Arduino and using
    the Arduino to turn a relay on or off each time it detects a loud sound.
  prefs: []
  type: TYPE_NORMAL
- en: Proximity sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 10](52e8daa7-b58a-4c75-ac23-13795fc1279d.xhtml), *Obstacle Avoidance
    and Collision Detection*, we saw how to use the MaxSonar rangefinder. If we attached
    the rangefinder to a servo motor, which we saw in [Chapter 16](8bb8e06e-4b6c-4855-9501-47e383f3c423.xhtml),
    *Servo Motors*, we could create a proximity sensor that could rotate up to 180
    degrees to monitor a large portion of a room. When the proximity first starts
    up, it would need to run through an initial cycle to map where the objects are,
    to begin with, and then monitor if anything changes after the initial run. If
    the proximity sensor does detect that something is closer than it should be, it
    could play an alarm through a speaker as described in [Chapter 12](afa4e27f-eafc-4eac-b792-8f550ac82b0d.xhtml),
    *Fun with Sound*.
  prefs: []
  type: TYPE_NORMAL
- en: These are just some of the projects that you can create with the Arduino. Now
    for your last challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I started learning how to use prototyping boards, like the Arduino, so I could
    build robots. You may want to build other projects like a weather station using
    the temperature, humidity and rain sensors, or maybe a security system using the
    motion sensor that is described in [Chapter 8](03634c50-cc88-4b10-8a3a-4054b67f0691.xhtml),
    *Motion Sensor*.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever you are interested in, I challenge you to make some super cool projects
    with the Arduino. Once you have finished, I would love to see pictures with descriptions
    of your project and will even post some of them on my blog giving the submitter
    credit for their project. If you have a video on YouTube of your project, I would
    love to see that as well. You can send your pictures, and descriptions to: `mastering.arduino@gmail.com`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first part of this book, we learned about the Arduino and basic electronics.
    These chapters were designed to give you, the reader, a basic understanding of
    how the Arduino worked and how you can safely attach electronic components to
    your Arduino without damaging yourself or the electronic components.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned about the development tools that we can use with the Arduino
    and how to program the Arduino. These chapters gave you a basic understanding
    of the development tools and also the Arduino programming language.
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter, we combined what we learned earlier in the book and showed
    how to connect various different components to the Arduino. These chapters were
    designed to show you a wide range of different components that interface with
    the Arduino in different ways. This will hopefully give you enough variety that
    when you purchase various sensors for your own project, you will understand how
    they interface with the Arduino even though they were not explicitly cover in
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two chapters, we will take a look at Bluetooth radios to see how
    we can implement two-way communication in our projects.
  prefs: []
  type: TYPE_NORMAL
