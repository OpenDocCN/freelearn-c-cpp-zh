<html><head></head><body>
		<div id="_idContainer136">
			<h1 class="chapterNumber">Chapter <a id="_idTextAnchor430"/>17</h1>
			<h1 id="_idParaDest-225" class="chapterTitle" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor431"/>Process Execution</h1>
			<p class="normal">We are now ready to talk about the software systems consisting of more than one process in their overall architecture. These systems are usually called multi-process or multiple-process systems. This chapter, together with the next chapter, is trying to cover the concepts of multi-processing and conduct a pros-and-cons analysis in order to compare it with multithreading, which we covered in <em class="italics">Chapter 15</em>, <em class="italics">Thread Execution</em>, and <em class="italics">Chapter 16</em>, <em class="italics">Thread Synchronization</em>.</p>
			<p class="normal">In this chapter, our focus is the available APIs and techniques to start a new process and how process execution actually happens, and in the next chapter, we'll go through concurrent environments consisting of more than one process. We are going to explain how various states can be shared among a number of processes and what common ways of accessing shared state in a multi-processing environment are.</p>
			<p class="normal">A proportion of this chapter is based on comparing multi-processing and multithreading environments. In addition, we briefly talk about single-host multi-processing systems and distributed multi-processing systems.<a id="_idTextAnchor432"/></p>
			<h1 id="_idParaDest-226" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor433"/>Process execution APIs</h1>
			<p class="normal">Every program is executed <a id="_idIndexMarker1158"/>as a process. Before we have a process, we just have an executable binary file that contains some memory segments and probably lots of machine-level instructions. Conversely, every process is an individual instance of a program being executed. Therefore, a single compiled program (or an executable binary file) can be executed multiple times through different processes. In fact, that's why our focus is on the processes in this chapter, rather than upon the programs themselves.</p>
			<p class="normal">In two previous chapters, we talked about threads in single-process software, but to follow our objective in this chapter, we are going to be talking about software with multiple processes. But first, we need to know how, and by using which API, a new process can be spawned.</p>
			<p class="normal">Note that our main focus is on executing processes in Unix-like operating systems since all of them follow the Unix onion architecture and expose very well-known and similar APIs. Other operating<a id="_idIndexMarker1159"/> systems can have their own ways for executing processes, but since most of them, more or less, follow the Unix onion architecture, we expect to see similar methods for process execution.</p>
			<p class="normal">In a Unix-like operating system, there are not many ways to execute a process at the system call level. If you remember the <em class="italics">kernel ring</em> from <em class="italics">Chapter 11</em>, <em class="italics">System Calls and Kernel</em>, it is the most inner<a id="_idIndexMarker1160"/> ring after the <em class="italics">hardware ring</em>, and it provides the <em class="italics">system call interface</em> to outer rings, <em class="italics">shell</em>, and <em class="italics">user</em>, in order to let them execute various kernel-specific functionalities. Two of these exposed system calls are dedicated to process creation and process execution; respectively, <code class="Code-In-Text--PACKT-">fork</code> and <code class="Code-In-Text--PACKT-">exec</code> (<code class="Code-In-Text--PACKT-">execve</code> in Linux though). In <em class="italics">process creation</em>, we spawn a new process, but in <em class="italics">process execution</em> we use an existing process as the host, and we replace it with a new program; therefore, no new process is spawned in process execution.</p>
			<p class="normal">As a result of using these systems calls, a program is always executed as a new process, but this process is not always spawned! The <code class="Code-In-Text--PACKT-">fork</code> system call spawns a new process while the <code class="Code-In-Text--PACKT-">exec</code> system call replaces the caller (the host) process with a new one. We talk about the differences between the <code class="Code-In-Text--PACKT-">fork</code> and <code class="Code-In-Text--PACKT-">exec</code> system calls later. Before that, let's see how these system calls are exposed to the outer rings.</p>
			<p class="normal">As we explained in <em class="italics">Chapter 10</em>, <em class="italics">Unix – History and Architecture</em>, we have two standards for Unix-like operating systems, specifically about the interface they should expose from their shell ring. These standards are <strong class="bold">Single Unix Specification</strong> (<strong class="bold">SUS</strong>) and <strong class="bold">POSIX</strong>. For more information regarding these standards, along with their similarities and differences, please refer to <em class="italics">Chapter 10</em>, <em class="italics">Unix – History and Architecture</em>.</p>
			<p class="normal">The interface that should be exposed from the shell ring is thoroughly specified in the POSIX interface, and indeed, there are parts in the standard that deal with process execution and process management.</p>
			<p class="normal">Therefore, we would expect to find headers and functions for process creation and process execution within POSIX. Such functions do indeed exist, and we find them in different headers that provide the desired functionality. Following is a list of POSIX functions responsible for process creation and process execution:</p>
			<ul>
				<li class="list">The function <code class="Code-In-Text--PACKT-">fork</code> that can be found in the <code class="Code-In-Text--PACKT-">unistd.h</code> header file is responsible for process creation.</li>
				<li class="list">The <code class="Code-In-Text--PACKT-">posix_spawn</code> and <code class="Code-In-Text--PACKT-">posix_spawnp</code> functions that can be found in the <code class="Code-In-Text--PACKT-">spawn.h</code> header file. These functions are responsible for process creation.</li>
				<li class="list">The group of <code class="Code-In-Text--PACKT-">exec*</code> functions, for example, <code class="Code-In-Text--PACKT-">execl</code> and <code class="Code-In-Text--PACKT-">execlp</code>, that can be found in the <code class="Code-In-Text--PACKT-">unistd.h</code> header file. These functions are responsible for process execution.</li>
			</ul>
			<p class="normal">Note that the preceding functions should not be mistaken for the <code class="Code-In-Text--PACKT-">fork</code> and <code class="Code-In-Text--PACKT-">exec</code> system calls. These<a id="_idIndexMarker1161"/> functions are part of the POSIX interface exposed from the shell ring while the system calls are exposed from the kernel ring. While most Unix-like operating systems are POSIX-compliant, we can have a non-Unix-like system that is also POSIX-compliant. Then, the preceding functions exist in that system, but the underlying mechanism for spawning a process can be different at the system call level.</p>
			<p class="normal">A tangible example is using Cygwin or MinGW to make Microsoft Windows POSIX-compliant. By installing these programs, you can write and compile standard C programs that are using the POSIX interface, and Microsoft Windows becomes partially POSIX-compliant, but there are no <code class="Code-In-Text--PACKT-">fork</code> or <code class="Code-In-Text--PACKT-">exec</code> system calls in Microsoft Windows! This is in fact very confusing and very important at the same time, and you should know that the shell ring does not necessarily expose the same interface that is exposed by the kernel ring.</p>
			<div>
				<div id="_idContainer130" class="note">
					<p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">You can find the implementation details of the <code class="Code-In-Text--PACKT-">fork</code> function in Cygwin here: <span class="url">https://github.com/openunix/cygwin/blob/master/winsup/cygwin/fork.cc</span>. Note that it<a id="_idIndexMarker1162"/> doesn't call the <code class="Code-In-Text--PACKT-">fork</code> system call that usually exists in Unix-like kernels; instead, it includes headers from the Win32 API and calls functions that are well-known functions regarding process creation and process management.</p>
				</div>
			</div>
			<p class="normal">According to the POSIX standard, the C standard library is not the only thing that is exposed from the shell ring on a Unix-like system. When using a Terminal, there are prewritten shell utility programs that are used to provide a complex usage of the C standard API. About the process creation, whenever the user enters a command in the Terminal, a new process is created.</p>
			<p class="normal">Even a simple <code class="Code-In-Text--PACKT-">ls</code> or <code class="Code-In-Text--PACKT-">sed</code> command spawns a new process that might only last less than a second. You should know that these utility programs are mostly written in C language and they are consuming the same exact POSIX interface which you would have been using when writing your own programs.</p>
			<p class="normal">Shell scripts are also executed in a separate process but in a slightly different fashion. We will discuss them in future sections on how a process is executed within a Unix-like system.</p>
			<p class="normal">Process creation happens in the kernel, especially in monolithic kernels. Whenever a user process spawns a new process or even a new thread, the request is received by the system call interface, and it gets passed down to the kernel ring. There, a new <em class="italics">task</em> is created for the<a id="_idIndexMarker1163"/> incoming request, either a process or a thread.</p>
			<p class="normal">Monolithic kernels like Linux or FreeBSD keep track of the tasks (process and threads) within their kernel, and this makes it reasonable to have processes being created in the kernel itself.</p>
			<p class="normal">Note that whenever a new task is created within the kernel, it is placed in the queue of the <em class="italics">task scheduler unit</em> and it might take a bit of time for it to obtain the CPU and begin execution.</p>
			<p class="normal">In order to create a new process, a parent process is needed. That's why every process has a parent. In fact, each process can have only one parent. The chain of parents and grandparents goes back to the first user process, which is usually called <em class="italics">init</em>, and the kernel process is its parent.</p>
			<p class="normal">It is the ancestor to all other processes within a Unix-like system and exists until the system shuts down. Regularly, the init process becomes the parent of all <em class="italics">orphan processes</em> that have had their parent processes terminated, so that no process can be left without a parent process.</p>
			<p class="normal">This parent-child relationship ends up in a big process tree. This tree can be examined by the command utility <em class="italics">pstree</em>. We are going<a id="_idIndexMarker1164"/> to show how to use this utility in future examples.</p>
			<p class="normal">Now, we know the API that can execute a new process, and we need to give some real C examples on how these methods actually work. We start with the fork API, which eventually calls the <code class="Code-In-Text--PACKT-">fork</code> syste<a id="_idTextAnchor434"/>m call.</p>
			<h2 id="_idParaDest-227" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor435"/>Process creation</h2>
			<p class="normal">As we mentioned in the<a id="_idIndexMarker1165"/> previous section, the fork API can be used to spawn a new process. We also explained that a new process can only be created as a child of a running process. Here, we see a few examples of how a process can fork a new child using the fork API.</p>
			<p class="normal">In order to spawn a new child process, a parent process needs to call the <code class="Code-In-Text--PACKT-">fork</code> function. The declaration of the <code class="Code-In-Text--PACKT-">fork</code> function can be included from the <code class="Code-In-Text--PACKT-">unistd.h</code> header file which is part of the POSIX headers.</p>
			<p class="normal">When the <code class="Code-In-Text--PACKT-">fork</code> function is called, an exact copy of the caller process (which is called the parent process) is created, and both processes continue to run concurrently starting from the very next<a id="_idIndexMarker1166"/> instruction after the <code class="Code-In-Text--PACKT-">fork</code> invocation statement. Note that the child (or forked) process inherits many things from the parent process including all the memory segments together with their content. Therefore, it has access to the same variables in the Data, Stack, and Heap segments, and also the program instructions found in the Text segment. We talk about other inherited things in the upcoming paragraphs, after talking about the example.</p>
			<p class="normal">Since we have two different processes now, the <code class="Code-In-Text--PACKT-">fork</code> function returns twice; once in the parent process and another time in the child process. In addition, the <code class="Code-In-Text--PACKT-">fork</code> function returns different values to each process. It returns 0 to the child process, and it returns the PID of the forked (or child) process to the parent process. <em class="italics">Example 17.1</em> shows how <code class="Code-In-Text--PACKT-">fork</code> works in one of its simplest usages:</p>
			<p class="snippet code">#include &lt;stdio.h&gt;</p>
			<p class="snippet code">#include &lt;unistd.h&gt;</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  printf("This is the parent process with process ID: %d\n",</p>
			<p class="snippet code">          getpid());</p>
			<p class="snippet code">  printf("Before calling fork() ...\n");</p>
			<p class="snippet code">  pid_t ret = fork();</p>
			<p class="snippet code">  if (ret) {</p>
			<p class="snippet code">    printf("The child process is spawned with PID: %d\n", ret);</p>
			<p class="snippet code">  } else {</p>
			<p class="snippet code">    printf("This is the child process with PID: %d\n", getpid());</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  printf("Type CTRL+C to exit ...\n");</p>
			<p class="snippet code">  while (1);</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 17-1 [ExtremeC_examples_chapter17_1.c]: Create a child process using the fork API</p>
			<p class="normal">In the preceding code box, we have used <code class="Code-In-Text--PACKT-">printf</code> to print out some logs in order to track the activity of the processes. As you see, we have invoked the <code class="Code-In-Text--PACKT-">fork</code> function in order to spawn a new process. As is apparent, it doesn't accept any argument, and therefore, its usage is very easy and straightforward.</p>
			<p class="normal">Upon calling the <code class="Code-In-Text--PACKT-">fork</code> function, a new process is forked (or cloned) from the caller process, which is now the parent process, and after that, they continue to work concurrently as two different processes.</p>
			<p class="normal">Surely, the call to the <code class="Code-In-Text--PACKT-">fork</code> function will cause further invocations on the system call level, and<a id="_idIndexMarker1167"/> only then, the responsible logic in the kernel can create a new forked process.</p>
			<p class="normal">Just before the <code class="Code-In-Text--PACKT-">return</code> statement, we have used an infinite loop to keep both processes running and prevent them from exiting. Note that the processes should reach this infinite loop eventually because they have exactly the same instructions in their Text segments.</p>
			<p class="normal">We want to keep the processes running intentionally in order to be able to see them in the list of processes shown by the <code class="Code-In-Text--PACKT-">pstree</code> and <code class="Code-In-Text--PACKT-">top</code> commands. Before that, we need to compile the preceding code and see how the new process is forked, as shown in <em class="italics">Shell Box 17-1</em>:</p>
			<p class="snippet shell"><strong class="highlight">$ gcc ExtremeC_examples_chapter17_1.c -o ex17_1.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ ./ex17_1.out</strong></p>
			<p class="snippet shell">This is the parent process with process ID: 10852</p>
			<p class="snippet shell">Before calling fork() …</p>
			<p class="snippet shell">The child process is spawned with PID: 10853</p>
			<p class="snippet shell">This is the child process with PID: 10853</p>
			<p class="snippet shell">Type CTRL+C to exit ...</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 17-1: Building and running example 17.1</p>
			<p class="normal">As you can see, the parent process prints its PID, and that is <code class="Code-In-Text--PACKT-">10852</code>. Note that the PID is going to change in each run. After forking the child process, the parent process prints the PID returned by the <code class="Code-In-Text--PACKT-">fork</code> function, and it is <code class="Code-In-Text--PACKT-">10853</code>.</p>
			<p class="normal">On the next line, the child process prints its PID, which is again <code class="Code-In-Text--PACKT-">10853</code> and it is in accordance with what the parent has received from the <code class="Code-In-Text--PACKT-">fork</code> function. And finally, both processes enter the infinite loop, giving us some time to observe them in the probing utilities.</p>
			<p class="normal">As you see in <em class="italics">Shell Box 17-1</em>, the forked process inherits the same <code class="Code-In-Text--PACKT-">stdout</code> file descriptor and the same terminal from its parent. Therefore, it can print to the same output that its parent writes to. A forked process inherits all the open file descriptors at the time of the <code class="Code-In-Text--PACKT-">fork</code> function call from its parent process.</p>
			<p class="normal">In addition, there are also other inherited attributes, which can be found in <code class="Code-In-Text--PACKT-">fork</code>'s manual pages. The <code class="Code-In-Text--PACKT-">fork</code>'s manual page for Linux can<a id="_idIndexMarker1168"/> be found here: <span class="url">http://man7.org/linux/man-pages/man2/fork.2.html</span>.</p>
			<p class="normal">If you open the link and look through the attributes, you are going to see that there are attributes that <a id="_idIndexMarker1169"/>are shared between the parent and forked processes, and there are other attributes that are different and specific to each process, for example, PID, parent PID, threads, and so on.</p>
			<p class="normal">The parent-child relationship between processes can be easily seen using a utility program like <code class="Code-In-Text--PACKT-">pstree</code>. Every process has a parent process, and all of the processes contribute to building a big tree. Remember that each process has exactly one parent, and a single process cannot have two parents.</p>
			<p class="normal">While the processes in the preceding example are stuck within their infinite loops, we can use the <code class="Code-In-Text--PACKT-">pstree</code> utility command to see the list of all processes within the system displayed as a tree. The following is the output of the <code class="Code-In-Text--PACKT-">pstree</code> usage in a Linux machine. Note that the <code class="Code-In-Text--PACKT-">pstree</code> command is installed on Linux systems by default, but it might need to be installed in other Unix-like operating systems:</p>
			<p class="snippet shell"><strong class="highlight">$ pstree -p</strong></p>
			<p class="snippet shell"><strong class="highlight">systemd(1)</strong>─┬─accounts-daemon(877)─┬─{accounts-daemon}(960)</p>
			<p class="snippet shell">           │                      └─{accounts-daemon}(997)</p>
			<p class="snippet shell">...</p>
			<p class="snippet shell">...</p>
			<p class="snippet shell">...</p>
			<p class="snippet shell">           ├─systemd-logind(819)</p>
			<p class="snippet shell">           ├─systemd-network(673)</p>
			<p class="snippet shell">           ├─systemd-resolve(701)</p>
			<p class="snippet shell">           ├─systemd-timesyn(500)───{systemd-timesyn}(550)</p>
			<p class="snippet shell">           ├─systemd-udevd(446)</p>
			<p class="snippet shell">           └─tmux: server(2083)─┬─<strong class="highlight">bash(2084)───pstree(13559)</strong></p>
			<p class="snippet shell">                                └─bash(2337)───<strong class="highlight">ex17_1.out(10852)───ex17_1.out(10853)</strong></p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 17-2: Use pstree to find the processes spawned as part of example 17.1</p>
			<p class="normal">As can be seen in the last line of <em class="italics">Shell Box 17-2</em>, we have two processes with PIDs <code class="Code-In-Text--PACKT-">10852</code> and <code class="Code-In-Text--PACKT-">10853</code> that are in the parent-child relationship. Note that process <code class="Code-In-Text--PACKT-">10852</code> has a parent with PID <code class="Code-In-Text--PACKT-">2337</code>, which is a <em class="italics">bash</em> process.</p>
			<p class="normal">It's interesting to note that on the line before the last line, we can see the <code class="Code-In-Text--PACKT-">pstree</code> process itself as the child of the bash process with PID <code class="Code-In-Text--PACKT-">2084</code>. Both of the bash processes belong to the same <em class="italics">tmux</em> terminal emulator with PID <code class="Code-In-Text--PACKT-">2083</code>.</p>
			<p class="normal">In Linux, the very first process is the <em class="italics">scheduler</em> process, which is part of the kernel image, and it has the PID 0. The<a id="_idIndexMarker1170"/> next process, which is usually called <em class="italics">init</em>, has the PID 1, and it is the first user process which is created by the scheduler process. It exists from system startup until its shutdown. All other user processes are directly or indirectly the children of the <code class="Code-In-Text--PACKT-">init</code> process. The processes which lose their parent processes become orphan processes, and they become abducted by the init process as its direct children.</p>
			<p class="normal">However, in the newer versions of almost all famous distributions of Linux, the init process has been replaced by the <em class="italics">systemd daemon</em>, and that's why you see <code class="Code-In-Text--PACKT-">systemd(1)</code> on the first line in <em class="italics">Shell Box 17-2</em>. The following link is a great source to read more about the differences between <code class="Code-In-Text--PACKT-">init</code> and <code class="Code-In-Text--PACKT-">systemd</code> and why Linux distro developers have made such a decision: <span class="url">https://www.tecmint.com/systemd-replaces-init-in-linux</span>.</p>
			<p class="normal">When using the fork API, the parent and forked processes are executed concurrently. This means that we should be able to detect some behaviors of concurrent systems.</p>
			<p class="normal">The best-known behavior that can be observed is some interleavings. If you are not familiar with this term or you have not heard it before, it is strongly recommended to have a read of <em class="italics">Chapter 13</em>, <em class="italics">Concurrency</em>, and <em class="italics">Chapter 14</em>, <em class="italics">Synchronization</em>.</p>
			<p class="normal">The following example, <em class="italics">example 17.2</em>, shows how the parent and forked processes can have non-deterministic interleavings. We are going to print some strings and observe how some various interleavings can happen in two successive runs:</p>
			<p class="snippet code">#include &lt;stdio.h&gt;</p>
			<p class="snippet code">#include &lt;unistd.h&gt;</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  pid_t ret = fork();</p>
			<p class="snippet code">  if (ret) {</p>
			<p class="snippet code">    for (size_t i = 0; i &lt; 5; i++) {</p>
			<p class="snippet code">      printf("AAA\n");</p>
			<p class="snippet code">      usleep(1);</p>
			<p class="snippet code">    }</p>
			<p class="snippet code">  } else {</p>
			<p class="snippet code">    for (size_t i = 0; i &lt; 5; i++) {</p>
			<p class="snippet code">      printf("BBBBBB\n");</p>
			<p class="snippet code">      usleep(1);</p>
			<p class="snippet code">    }</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 17-2 [ExtremeC_examples_chapter17_2.c]: Two processes that print some lines to the standard output</p>
			<p class="normal">The preceding code is very<a id="_idIndexMarker1171"/> similar to the code we wrote for <em class="italics">example 17.1</em>. It creates a forked process, and after that, the parent and forked processes print some lines of text to the standard output. The parent process prints <code class="Code-In-Text--PACKT-">AAA</code> 5 times, and the forked process prints <code class="Code-In-Text--PACKT-">BBBBBB</code> five times. The following is the output of the two consecutive runs of the same compiled executable:</p>
			<p class="snippet shell"><strong class="highlight">$ gcc ExtremeC_examples_chapter17_2.c -o ex17_2.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ ./ex17_2.out</strong></p>
			<p class="snippet shell">AAA</p>
			<p class="snippet shell">AAA</p>
			<p class="snippet shell">AAA</p>
			<p class="snippet shell">AAA</p>
			<p class="snippet shell">AAA</p>
			<p class="snippet shell">BBBBBB</p>
			<p class="snippet shell">BBBBBB</p>
			<p class="snippet shell">BBBBBB</p>
			<p class="snippet shell">BBBBBB</p>
			<p class="snippet shell">BBBBBB</p>
			<p class="snippet shell"><strong class="highlight">$ ./ex17_2.out</strong></p>
			<p class="snippet shell">AAA</p>
			<p class="snippet shell">AAA</p>
			<p class="snippet shell">BBBBBB</p>
			<p class="snippet shell">AAA</p>
			<p class="snippet shell">AAA</p>
			<p class="snippet shell">BBBBBB</p>
			<p class="snippet shell">BBBBBB</p>
			<p class="snippet shell">BBBBBB</p>
			<p class="snippet shell">AAA</p>
			<p class="snippet shell">BBBBBB</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 17-3: Output of two successive runs of example 17.2</p>
			<p class="normal">It is clear from the preceding output that we have different interleavings. This means we can be potentially suffering from a race condition here if we define our invariant constraint according<a id="_idIndexMarker1172"/> to what we see in the standard output. This would eventually lead to all the issues we faced while writing multithreaded code, and we need to use similar methods to overcome these issues. In the next chapter, we will discuss such solutions in <a id="_idTextAnchor436"/>greater detail.</p>
			<p class="normal">In the following section, we are going to talk about process execution and how it can be achieved using <code class="Code-In-Text--PACKT-">exec*</code> functions.</p>
			<h2 id="_idParaDest-228" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor437"/>Process execution</h2>
			<p class="normal">Another way to execute <a id="_idIndexMarker1173"/>a new process is by using the family of <code class="Code-In-Text--PACKT-">exec*</code> functions. This group of functions takes a different approach to execute a new process in comparison to the fork API. The philosophy behind <code class="Code-In-Text--PACKT-">exec*</code> functions is to create a simple base process first and then, at some point, load the target executable and<a id="_idIndexMarker1174"/> replace it as a new <em class="italics">process image</em> with the base process. A process image is the loaded version of a executable that has its memory segments allocated, and it is ready to be executed. In the future sections, we will discuss the different steps of loading an executable, and we will explain process images in greater depth.</p>
			<p class="normal">Therefore, while using the <code class="Code-In-Text--PACKT-">exec*</code> functions, no new process is created, and a process substitution happens. This is the most important difference between <code class="Code-In-Text--PACKT-">fork</code> and <code class="Code-In-Text--PACKT-">exec*</code> functions. Instead of forking a new process, the base process is totally substituted with a new set of memory segments and code instructions.</p>
			<p class="normal"><em class="italics">Code Box 17-3</em>, containing <em class="italics">example 17.3</em>, shows how the <code class="Code-In-Text--PACKT-">execvp</code> function, one of the functions in the family of <code class="Code-In-Text--PACKT-">exec*</code> functions, is used to start an echo process. The <code class="Code-In-Text--PACKT-">execvp</code> function is one of the functions in the group of <code class="Code-In-Text--PACKT-">exec*</code> functions that inherits the environment variable <code class="Code-In-Text--PACKT-">PATH</code> from the parent process and searches for the executables as the parent process did:</p>
			<p class="snippet code">#include &lt;stdio.h&gt;</p>
			<p class="snippet code">#include &lt;unistd.h&gt;</p>
			<p class="snippet code">#include &lt;string.h&gt;</p>
			<p class="snippet code">#include &lt;errno.h&gt;</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  char *args[] = {"echo", "Hello", "World!", 0};</p>
			<p class="snippet code">  execvp("echo", args);</p>
			<p class="snippet code">  printf("execvp() failed. Error: %s\n", strerror(errno));</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 17-3 [ExtremeC_examples_chapter17_3.c]: Demonstration of how execvp works</p>
			<p class="normal">As you see in the preceding code box, we have invoked the function <code class="Code-In-Text--PACKT-">execvp</code>. As we explained before, the <code class="Code-In-Text--PACKT-">execvp</code> function inherits the environment variable <code class="Code-In-Text--PACKT-">PATH</code>, together with the way it looks for the existing executables, from the base process. It accepts two arguments; the first is the name of the executable file or the script which should be loaded and executed, and the second is the list of arguments that should be passed to the executable.</p>
			<p class="normal">Note that we<a id="_idIndexMarker1175"/> are passing <code class="Code-In-Text--PACKT-">echo</code> and not an absolute path. Therefore, <code class="Code-In-Text--PACKT-">execvp</code> should locate the <code class="Code-In-Text--PACKT-">echo</code> executable first. These executable files can be anywhere in a Unix-like operating system, from <code class="Code-In-Text--PACKT-">/usr/bin</code> to <code class="Code-In-Text--PACKT-">/usr/local/bin</code> or even other places. The absolute location of the <code class="Code-In-Text--PACKT-">echo</code> can be found by going through all directory<a id="_idIndexMarker1176"/> paths found in the <code class="Code-In-Text--PACKT-">PATH</code> environment variable.</p>
			<div>
				<div id="_idContainer131" class="note">
					<p class="Information-Box--PACKT-">The <code class="Code-In-Text--PACKT-">exec*</code> functions can execute a range of executable files. Following is a list of some file formats that can be executed by <code class="Code-In-Text--PACKT-">exec*</code> functions:</p>
					<ul>
						<li class="Bullet-Within-Information-Box--PACKT-" lang="en-GB" xml:lang="en-GB">ELF executable files</li>
						<li class="Bullet-Within-Information-Box--PACKT-" lang="en-GB" xml:lang="en-GB">Script files with a <em class="italics">shebang</em> line indicating the <em class="italics">interpreter</em> of the script</li>
						<li class="Bullet-Within-Information-Box--PACKT-" lang="en-GB" xml:lang="en-GB">Traditional <code class="Code-In-Text--PACKT-">a.out</code> format binary files</li>
						<li class="Bullet-Within-Information-Box-End--PACKT-" lang="en-GB" xml:lang="en-GB">ELF FDPIC executable files</li>
					</ul>
				</div>
			</div>
			<p class="normal">After finding the <code class="Code-In-Text--PACKT-">echo</code> executable file, the <code class="Code-In-Text--PACKT-">execvp</code> does the rest. It calls the <code class="Code-In-Text--PACKT-">exec</code> (<code class="Code-In-Text--PACKT-">execve</code> in Linux) system call with a prepared set of arguments and subsequently, the kernel prepares a process image from the found executable file. When everything is ready, the kernel replaces the current process image with the prepared one, and the base process is gone forever. Now, the control returns to the new process, and it becomes executing from its <code class="Code-In-Text--PACKT-">main</code> function, just like a normal execution.</p>
			<p class="normal">As a result of this process, the <code class="Code-In-Text--PACKT-">printf</code> statement after the <code class="Code-In-Text--PACKT-">execvp</code> function call statement cannot be executed if the <code class="Code-In-Text--PACKT-">execvp</code> has been successful, because now we have a whole new process with new memory segments and new instructions. If the <code class="Code-In-Text--PACKT-">execvp</code> statement wasn't successful, then the <code class="Code-In-Text--PACKT-">printf</code> should have been executed, which is a sign for the failure of <code class="Code-In-Text--PACKT-">execvp</code> function call.</p>
			<p class="normal">Like we said before, we have a group of <code class="Code-In-Text--PACKT-">exec*</code> functions, and the <code class="Code-In-Text--PACKT-">execvp</code> function is only one of them. While all of them behave similarly, they have slight differences. Next, you can find a comparison of these functions:</p>
			<ul>
				<li class="list"><code class="Code-In-Text--PACKT-">execl(const char* path, const char* arg0, ..., NULL)</code>: Accepts an absolute path to the executable file and a series of arguments that should be passed to the new process. They must end with a null string, <code class="Code-In-Text--PACKT-">0</code> or <code class="Code-In-Text--PACKT-">NULL</code>. If we wanted to rewrite <em class="italics">example 17.3</em> using <code class="Code-In-Text--PACKT-">execl</code>, we would use <code class="Code-In-Text--PACKT-">execl("/usr/bin/echo", "echo", "Hello", "World", NULL)</code>.</li>
				<li class="list"><code class="Code-In-Text--PACKT-">execlp(const char* file, const char* arg0, ..., NULL)</code>: Accepts a relative path as its first argument, but since it has access to the <code class="Code-In-Text--PACKT-">PATH</code> environment variable, it can locate the executable file easily. Then, it accepts a series of arguments that should be passed to the new process. They must end with a null string, <code class="Code-In-Text--PACKT-">0</code> or <code class="Code-In-Text--PACKT-">NULL</code>. If we wanted to rewrite <em class="italics">example 17.3</em> using <code class="Code-In-Text--PACKT-">execlp</code>, we would use <code class="Code-In-Text--PACKT-">execlp("echo", "echo," "Hello," "World," NULL)</code>.</li>
				<li class="list"><code class="Code-In-Text--PACKT-">excele(const char* path, const char* arg0, ..., NULL, const char* env0, ..., NULL)</code>: Accepts an absolute path to the executable file as its first argument. Then, it accepts a series of arguments that should be passed to the<a id="_idIndexMarker1177"/> new process followed by a null string. Following that, it accepts a series of strings representing the environment variables. They must also end with a null string. If we wanted to rewrite <em class="italics">example 17.3</em> using <code class="Code-In-Text--PACKT-">execle</code>, we would use <code class="Code-In-Text--PACKT-">execle("/usr/bin/echo", "echo", "Hello", "World", NULL, "A=1", "B=2", NULL)</code>. Note that in this call we have passed two new environment variables, <code class="Code-In-Text--PACKT-">A</code> and <code class="Code-In-Text--PACKT-">B</code>, to the new process.</li>
				<li class="list"><code class="Code-In-Text--PACKT-">execv(const char* path, const char* args[])</code>: Accepts an absolute path to the executable file and an array of the arguments that should be passed to the new process. The last element in the array must be a null string, <code class="Code-In-Text--PACKT-">0</code> or <code class="Code-In-Text--PACKT-">NULL</code>. If we wanted to rewrite <em class="italics">example 17.3</em> using <code class="Code-In-Text--PACKT-">execl</code>, we would use <code class="Code-In-Text--PACKT-">execl("/usr/bin/echo", args)</code> in which <code class="Code-In-Text--PACKT-">args</code> is declared like this: <code class="Code-In-Text--PACKT-">char* args[] = {"echo", "Hello", "World", NULL}</code>.</li>
				<li class="list"><code class="Code-In-Text--PACKT-">execvp(const char* file, const char* args[])</code>: It accepts a relative path as its first argument, but since it has access to the <code class="Code-In-Text--PACKT-">PATH</code> environment variable, it can locate the executable file easily. Then, it accepts an array of the arguments that should be passed to the new process. The last element in the array must be a null string, <code class="Code-In-Text--PACKT-">0</code> or <code class="Code-In-Text--PACKT-">NULL</code>. This is the function that we used in <em class="italics">example 17.3</em>.</li>
			</ul>
			<p class="normal">When <code class="Code-In-Text--PACKT-">exec*</code> functions<a id="_idIndexMarker1178"/> are successful, the previous process is gone, and a new process is created instead. Therefore, there isn't a second process at all. For this reason, we cannot demonstrate interleavings as we did for the <code class="Code-In-Text--PACKT-">fork</code> API. In the next section, we compare the <code class="Code-In-Text--PACKT-">fork</code> API and the <code class="Code-In-Text--PACKT-">exec*</code> functions for executing a new program.</p>
			<h2 id="_idParaDest-229" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor438"/>Comparing process creation and process execution</h2>
			<p class="normal">Based on our discussion <a id="_idIndexMarker1179"/>and the given examples in previous sections, we can make the following comparison between the two methods used for executing a new program:</p>
			<ul>
				<li class="list">A successful invocation of the <code class="Code-In-Text--PACKT-">fork</code> function results in two separate processes; a parent process that has called the <code class="Code-In-Text--PACKT-">fork</code> function and a forked (or child) process. But a successful invocation of any <code class="Code-In-Text--PACKT-">exec*</code> function results in having the caller process substituted by a new process image and therefore no new process is created.</li>
				<li class="list">Calling the <code class="Code-In-Text--PACKT-">fork</code> function duplicates all memory contents of the parent process, and the forked process sees the same memory contents and variables. But calling the <code class="Code-In-Text--PACKT-">exec*</code> functions destroys the memory layout of the base process and creates a new layout based on the loaded executable.</li>
				<li class="list">A forked process has access to certain attributes of the parent process, for example, open file descriptors but using <code class="Code-In-Text--PACKT-">exec*</code> functions. The new process doesn't know anything about it, and it doesn't inherit anything from the base process.</li>
				<li class="list">In both APIs, we end up with a new process that has only one main thread. The threads in the parent process are not forked using the fork API.</li>
				<li class="list">The <code class="Code-In-Text--PACKT-">exec*</code> API can be used to run scripts and external executable files, but the <code class="Code-In-Text--PACKT-">fork</code> API can be used only to create a new process that is actuall<a id="_idTextAnchor439"/>y the same C program.</li>
			</ul>
			<p class="normal">In the next section, we'll talk about the steps that most kernels take to load and execute a new process. These steps and their details vary from one kernel to another, but we try to cover the general steps taken by most known kernels to execute a process.</p>
			<h1 id="_idParaDest-230" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor440"/>Process execution steps</h1>
			<p class="normal">To have a process <a id="_idIndexMarker1180"/>executed from an executable file, the user space and the kernel space take some general steps in most operating systems. As we noted in the previous section, executable files are mostly executable object files, for example, ELF, Mach, or script files that need an interpreter to execute them.</p>
			<p class="normal">From the user ring's point of view, a system call like <code class="Code-In-Text--PACKT-">exec</code> should be invoked. Note that we don't explain the <code class="Code-In-Text--PACKT-">fork</code> system call here because it is not actually an execution. It is more of a cloning operation of the currently running process.</p>
			<p class="normal">When the user space invokes the <code class="Code-In-Text--PACKT-">exec</code> system call, a new request for the execution of the executable file is created within the kernel. The kernel tries to find a handler for the specified executable file based on its type and according to that handler, it uses a <em class="italics">loader program</em> to load the contents of the executable file.</p>
			<p class="normal">Note that for the script files, the executable binary of the interpreter program that is usually specified in the <em class="italics">shebang line</em> on the first line of the script. The loader program has the following duties in order to execute a process:</p>
			<ul>
				<li class="list">It checks the execution<a id="_idIndexMarker1181"/> context and the permissions of the user that has requested the execution.</li>
				<li class="list">It allocates the memory for the new process from the main memory.</li>
				<li class="list">It copies the binary contents of the executable file into the allocated memory. This mostly involves the Data, and Text segments.</li>
				<li class="list">It allocates a memory region for the Stack segment and prepares the initial memory mappings.</li>
				<li class="list">The main thread and its Stack memory region are created.</li>
				<li class="list">It copies the command-line arguments as a <em class="italics">stack frame</em> on top of the Stack region of the main thread.</li>
				<li class="list">It initializes the vital registers that are needed for the execution.</li>
				<li class="list">It executes the first instruction of the program entry point.</li>
			</ul>
			<p class="normal">In the case of script files, the path to the script files is copied as the command-line argument of the interpreter process. The preceding general steps are taken by most kernels, but the implementation details can vary greatly from a kernel to another.</p>
			<p class="normal">For more information on a specific operating system, you need to go to its documentation or simply search for it on Google. The following articles from LWN are a great start for those seeking more details about the <a id="_idIndexMarker1182"/>pro<a href="https://lwn.net/Articles/631631/">cess execution in Linux: <span class="url">https:/</span></a><span class="url">/lwn.</span><a href="https://lwn.net/Articles/630727/"><span class="url">net/Articles/631631/</span> and <span class="url">https:/</span></a><span class="url">/lwn.net/Articles/630727/</span>.</p>
			<p class="normal">In the next section, we'll start to talk about concurrency-related topics. We prepare the ground for the next chapter, which is <a id="_idIndexMarker1183"/>going to talk about multi-processing-specific synchronization techniques in great depth. We start here by<a id="_idTextAnchor441"/> discussing shared states, which can be used in multi-process software systems.</p>
			<h1 id="_idParaDest-231" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor442"/>Shared states</h1>
			<p class="normal">As with threads, we can have some<a id="_idIndexMarker1184"/> shared states between processes. The only difference is that the threads are able to access the same memory space owned by their owner process, but processes cannot have that luxury. Therefore, other mechanisms should be employed to share a state among a number of processes.</p>
			<p class="normal">In this section, we are going to discuss these techniques and as part of this chapter, we focus on some of them that function as storage. In the first section, we will be discussing different techniques and trying to group them based on their nature.</p>
			<h2 id="_idParaDest-232" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor443"/>Sharing techniques</h2>
			<p class="normal">If you look at the ways you can share a state (a variable or an array) between two processes, it turns out that it can be done in a limited number of ways. Theoretically, there are two<a id="_idIndexMarker1185"/> main categories of sharing a state between a number of processes, but in a real computer system, each of these categories has some subcategories.</p>
			<p class="normal">You either have to put a<a id="_idIndexMarker1186"/> state in a "place" that can be accessed by a number of processes, or you must have your state <em class="italics">sent</em> or <em class="italics">transferred</em> as a message, signal, or event to<a id="_idIndexMarker1187"/> other processes. Similarly, you either have to <em class="italics">pull</em> or <em class="italics">retrieve</em> an existing state from a "place," or <em class="italics">receive</em> it as a message, signal, or event. The first approach <a id="_idIndexMarker1188"/>needs storage<a id="_idIndexMarker1189"/> or a <em class="italics">medium</em> like a memory <a id="_idIndexMarker1190"/>buffer or a filesystem, and the second approach requires you to have a messaging mechanism or a <em class="italics">channel</em> in place between the processes.</p>
			<p class="normal">As an example for the first approach, we can have a shared memory region as a medium with an array inside that can be accessed by a number of processes to read and modify the array. As an example for the second approach, we can have a computer network as the channel to allow some messages to be transmitted between a number of processes located on different hosts in that network.</p>
			<p class="normal">Our current discussion on how to share states between some processes is not in fact limited to just processes; it can be applied to threads as well. Threads can also have signaling between themselves to share a state or propagate an event.</p>
			<p class="normal">In different terminology, the techniques found in the first group that requires a <em class="italics">medium</em> such as storage to share states are called <em class="italics">pull-based</em> techniques. That's because the processes that want to read states have to <a id="_idIndexMarker1191"/>pull them from storage.</p>
			<p class="normal">The techniques in the second group that require a <em class="italics">channel</em> to transmit states are<a id="_idIndexMarker1192"/> called <em class="italics">push-based</em> techniques. That's because the states are pushed (or delivered) through the channel to the receiving <a id="_idIndexMarker1193"/>process and it doesn't need to pull them from a medium. We will be using these terms from now on to refer to these techniques.</p>
			<p class="normal">The variety in push-based techniques has led to various distributed architectures in the modern software industry. The pull-based techniques are considered to be legacy in comparison to push-based techniques, and you can see it in many enterprise applications where a single central database is used to share various states throughout the entire system.</p>
			<p class="normal">However, the push-based approach is gaining momentum these days and has led to techniques such as <em class="italics">event sourcing</em> and a number of other similar distributed approaches used for keeping all parts of a big software system consistent with each other without having all data stored in a central place.</p>
			<p class="normal">Between the two approaches discussed, we are particularly interested in the first approach throughout this chapter. We will focus more upon the second approach in <em class="italics">Chapter 19</em>, <em class="italics">Single-Host IPC and Sockets</em>, and <em class="italics">Chapter 20</em>, <em class="italics">Socket Programming</em>. In those chapters we are going to introduce the various channels available to transmit messages between processes as part of <strong class="bold">Inter-Process Communication</strong> (<strong class="bold">IPC</strong>) techniques. Only then will we be able to explore the various push-based techniques and give some real examples for the observed concurrency issues and the control mechanisms that can be employed.</p>
			<p class="normal">The following is a list of pull-based techniques that are supported by the POSIX standard and can be used widely in all POSIX-compliant operating systems:</p>
			<ul>
				<li class="list"><strong class="bold">Shared memory</strong>: This is <a id="_idIndexMarker1194"/>simply a region in the main memory that is shared and accessible to a number of processes, and they can use it to store variables and arrays just like an ordinary memory block. A shared memory object is not a file on disk, but it is the actual memory. It can exist as a standalone object in the operating system even when there is no process using it. Shared memory objects can be removed whether by a process when not needed anymore or by rebooting the system. Therefore, in terms of surviving reboots, shared memory objects can be thought of as temporary objects.</li>
				<li class="list"><strong class="bold">Filesystem</strong>: Processes can <a id="_idIndexMarker1195"/>use files to share states. This technique is one of the oldest techniques to share some states throughout a software system among a number of processes. Eventually, difficulties <a id="_idIndexMarker1196"/>with synchronizing access to the shared files, together with many other valid reasons, have led to the<a id="_idIndexMarker1197"/> invention of <strong class="bold">Database Management Systems</strong> (<strong class="bold">DBMSes</strong>), but still, the shared files are being used in certain use cases.</li>
				<li class="list"><strong class="bold">Network services</strong>: Once available to all processes, processes can use network storage or a network <a id="_idIndexMarker1198"/>service to store and retrieve a shared state. In this scenario, the processes do not know exactly what is going on behind the scenes. They just use a network service through a well-defined API that allows them to perform certain operations on a shared state. As some <a id="_idIndexMarker1199"/>examples, we can name <strong class="bold">Network Filesystems</strong> (<strong class="bold">NFS</strong>) or DBMSes. They offer network services that allow maintaining states through a well-defined model and a set of companion operations. To give a more specific example, we can mention <em class="italics">Relational DBMSes,</em> which allow <a id="_idIndexMarker1200"/>you to store your states in a re<a id="_idTextAnchor444"/>lational model through using SQL commands.</li>
			</ul>
			<p class="normal">In the following subsections, we will be discussing each of the above methods found as part of the POSIX interface. We start with POSIX shared memory, and we show how it can lead to familiar data races known from <em class="italics">Chapter 16</em>, <em class="italics">Thread Synchronization</em>.</p>
			<h2 id="_idParaDest-233" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor445"/>POSIX shared memory</h2>
			<p class="normal">Supported by POSIX standard, shared<a id="_idIndexMarker1201"/> memory is one of the widely used techniques to share a piece of information among a number of processes. Unlike threads that can access the same memory space, processes do not have this power and access to the memory of other processes is prohibited by the operating system. Therefore, we need a mechanism in order to share a portion of memory between two processes, and shared memory is exactly that technique.</p>
			<p class="normal">In the following examples, we go through the details of creating and using a shared memory object, and we start our discussion by creating a shared memory region. The following code shows how to create and populate a shared memory object within a POSIX-compliant system:</p>
			<p class="snippet code">#include &lt;stdio.h&gt;</p>
			<p class="snippet code">#include &lt;unistd.h&gt;</p>
			<p class="snippet code">#include &lt;fcntl.h&gt;</p>
			<p class="snippet code">#include &lt;errno.h&gt;</p>
			<p class="snippet code">#include &lt;string.h&gt;</p>
			<p class="snippet code">#include &lt;sys/mman.h&gt;</p>
			<p class="snippet code">#define SH_SIZE 16</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  int shm_fd = shm_open("/shm0", O_CREAT | O_RDWR, 0600);</p>
			<p class="snippet code">  if (shm_fd &lt; 0) {</p>
			<p class="snippet code">    fprintf(stderr, "ERROR: Failed to create shared memory: %s\n",</p>
			<p class="snippet code">        strerror(errno));</p>
			<p class="snippet code">    return 1;</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  fprintf(stdout, "Shared memory is created with fd: %d\n",</p>
			<p class="snippet code">          shm_fd);</p>
			<p class="snippet code">  if (ftruncate(shm_fd, SH_SIZE * sizeof(char)) &lt; 0) {</p>
			<p class="snippet code">    fprintf(stderr, "ERROR: Truncation failed: %s\n",</p>
			<p class="snippet code">            strerror(errno));</p>
			<p class="snippet code">    return 1;</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  fprintf(stdout, "The memory region is truncated.\n");</p>
			<p class="snippet code">  void* map = mmap(0, SH_SIZE, PROT_WRITE, MAP_SHARED, shm_fd, 0);</p>
			<p class="snippet code">  if (map == MAP_FAILED) {</p>
			<p class="snippet code">    fprintf(stderr, "ERROR: Mapping failed: %s\n",</p>
			<p class="snippet code">            strerror(errno));</p>
			<p class="snippet code">    return 1;</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  char* ptr = (char*)map;</p>
			<p class="snippet code">  ptr[0] = 'A';</p>
			<p class="snippet code">  ptr[1] = 'B';</p>
			<p class="snippet code">  ptr[2] = 'C';</p>
			<p class="snippet code">  ptr[3] = '\n';</p>
			<p class="snippet code">  ptr[4] = '\0';</p>
			<p class="snippet code">  while(1);</p>
			<p class="snippet code">  fprintf(stdout, "Data is written to the shared memory.\n");</p>
			<p class="snippet code">  if (munmap(ptr, SH_SIZE) &lt; 0) {</p>
			<p class="snippet code">    fprintf(stderr, "ERROR: Unmapping failed: %s\n",</p>
			<p class="snippet code">            strerror(errno));</p>
			<p class="snippet code">    return 1;</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  if (close(shm_fd) &lt; 0) {</p>
			<p class="snippet code">    fprintf(stderr, "ERROR: Closing shared memory failed: %s\n",</p>
			<p class="snippet code">        strerror(errno));</p>
			<p class="snippet code">    return 1;</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 17-4 [ExtremeC_examples_chapter17_4.c]: Creating and writing to a POSIX shared memory object</p>
			<p class="normal">The preceding code creates<a id="_idIndexMarker1202"/> a shared memory object named <code class="Code-In-Text--PACKT-">/shm0</code> with 16 bytes in it. Then it populates the shared memory with the literal <code class="Code-In-Text--PACKT-">ABC\n</code> and finally, it quits by <em class="italics">unmapping</em> the shared memory region. Note that the shared memory object remains in place even when the process quits. Future processes can open and read the same shared memory object over and over again. A shared memory object is destructed either by rebooting the system or by getting <em class="italics">unlinked</em> (removed) by a process.</p>
			<div>
				<div id="_idContainer132" class="note">
					<p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">In FreeBSD, the names of the shared memory objects should start with <code class="Code-In-Text--PACKT-">/</code>. This is not mandatory in Linux or macOS, but we did the same for both of them to remain compatible with FreeBSD.</p>
				</div>
			</div>
			<p class="normal">In the preceding code, we firstly open a shared memory object using the <code class="Code-In-Text--PACKT-">shm_open</code> function. It accepts a name and the modes that the shared memory object should be created with. <code class="Code-In-Text--PACKT-">O_CREAT</code> and <code class="Code-In-Text--PACKT-">O_RDWR</code> mean that the shared memory should be created, and it can be used for both reading and writing.</p>
			<p class="normal">Note the creation won't fail if the shared memory object already exists. The last argument indicates the permissions of the shared memory object. <code class="Code-In-Text--PACKT-">0600</code> means that it is available for reading and write operations performed by the processes that are initiated only by the owner of the shared memory object.</p>
			<p class="normal">On the following lines, we define the size of the shared memory region by truncating it using <code class="Code-In-Text--PACKT-">ftruncate</code> function. Note that this<a id="_idIndexMarker1203"/> is a necessary step if you're about to create a new shared memory object. For the preceding shared memory object, we have defined 16 bytes to be allocated and then truncated.</p>
			<p class="normal">As we proceed, we map the shared<a id="_idIndexMarker1204"/> memory object to a region accessible by the process using the <code class="Code-In-Text--PACKT-">mmap</code> function. As a result of this, we have a pointer to the mapped memory and that can be used to access the shared memory region behind. This is also a necessary step that makes the shared memory accessible to our C program.</p>
			<p class="normal">The function <code class="Code-In-Text--PACKT-">mmap</code> is usually used to map a file or a shared memory region (originally allocated from the kernel's memory space) to an address space that is accessible to the caller process. Then, the mapped address space can be accessed as a regular memory region using ordinary pointers.</p>
			<p class="normal">As you can see, the region is mapped as a writable region indicated by <code class="Code-In-Text--PACKT-">PROT_WRITE</code> and as a shared region among processes indicated by the <code class="Code-In-Text--PACKT-">MAP_SHARED</code> argument. <code class="Code-In-Text--PACKT-">MAP_SHARED</code> simply means any changes to the mapped area will be visible to other processes mapping the same region.</p>
			<p class="normal">Instead of <code class="Code-In-Text--PACKT-">MAP_SHARED</code>, we could have <code class="Code-In-Text--PACKT-">MAP_PRIVATE</code>; this means that the changes to the mapped region are<a id="_idIndexMarker1205"/> not propagated to other processes and are, rather, private to the mapper process. This usage is not common unless you want to use the shared memory inside a process only.</p>
			<p class="normal">After mapping the shared memory region, the preceding code writes a null-terminated string <code class="Code-In-Text--PACKT-">ABC\n</code> into the shared memory. Note the new line feed character at the end of the string. As the final steps, the process unmaps the shared memory region by calling the <code class="Code-In-Text--PACKT-">munmap</code> function and then it closes the file descriptor assigned to the shared memory object.</p>
			<div>
				<div id="_idContainer133" class="note">
					<p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">Every operating system offers a different way to create an <em class="italics">unnamed</em> or <em class="italics">anonymous shared memory</em> object. In FreeBSD, it is enough to pass <code class="Code-In-Text--PACKT-">SHM_ANON</code> as the path of the shared memory object to the <code class="Code-In-Text--PACKT-">shm_open</code> function. In Linux, one can create an anonymous file using a <code class="Code-In-Text--PACKT-">memfd_create</code> function instead of creating a shared memory object and <a id="_idIndexMarker1206"/>use the returned file descriptor to create a mapped region. An anonymous shared memory is private to the owner process and cannot be used to share states among a number of processes.</p>
				</div>
			</div>
			<p class="normal">The preceding code can be compiled on macOS, FreeBSD, and Linux systems. In Linux systems, shared memory objects can be seen inside the directory <code class="Code-In-Text--PACKT-">/dev/shm</code>. Note that this directory doesn't have a regular filesystem and those you see are not files on a disk device. Instead, <code class="Code-In-Text--PACKT-">/dev/shm</code> uses the <code class="Code-In-Text--PACKT-">shmfs</code> filesystem. It is meant to expose the temporary objects created inside the memory through a mounted directory, and it is only available in Linux.</p>
			<p class="normal">Let's compile and run <em class="italics">example 17.4</em> in Linux and examine the contents of the <code class="Code-In-Text--PACKT-">/dev/shm</code> directory. In Linux, it is mandatory to link the final binary with the <code class="Code-In-Text--PACKT-">rt</code> library in order to use shared memory facilities, and that's why you see the option <code class="Code-In-Text--PACKT-">-lrt</code> in the following shell box:</p>
			<p class="snippet shell"><strong class="highlight">$ ls /dev/shm</strong></p>
			<p class="snippet shell"><strong class="highlight">$ gcc ExtremeC_examples_chapter17_4.c -lrt -o ex17_4.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ ./ex17_4.out</strong></p>
			<p class="snippet shell">Shared memory is created with fd: 3</p>
			<p class="snippet shell">The memory region is truncated.</p>
			<p class="snippet shell">Data is written to the shared memory.</p>
			<p class="snippet shell"><strong class="highlight">$ ls /dev/shm</strong></p>
			<p class="snippet shell">shm0</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 17-4: Building and running example 17.4 and checking if the shared memory object is created</p>
			<p class="normal">As you can see on the first line, there are no shared memory objects in the <code class="Code-In-Text--PACKT-">/dev/shm</code> directory. On the second line, we build <em class="italics">example 17.4</em>, and on the third line, we execute the produced executable file. Then we check <code class="Code-In-Text--PACKT-">/dev/shm</code>, and we see that we've got a new shared memory object, <code class="Code-In-Text--PACKT-">shm0</code>, there.</p>
			<p class="normal">The output of the<a id="_idIndexMarker1207"/> program also confirms the creation of the shared memory object. Another important thing about the preceding shell box is the file descriptor <code class="Code-In-Text--PACKT-">3</code>, which is assigned to the shared memory object.</p>
			<p class="normal">For every file you open, a new file descriptor is opened in each process. This file is not necessarily on disk, and it can be a shared memory object, standard output, and so on. In each process, file descriptors start from 0 and go up to a maximum allowed number.</p>
			<p class="normal">Note that in each process, the file descriptors <code class="Code-In-Text--PACKT-">0</code>, <code class="Code-In-Text--PACKT-">1</code>, and <code class="Code-In-Text--PACKT-">2</code> are preassigned to the <code class="Code-In-Text--PACKT-">stdout</code>, <code class="Code-In-Text--PACKT-">stdin</code>, and <code class="Code-In-Text--PACKT-">stderr</code> streams, respectively. These file descriptors are opened for every new process before having its <code class="Code-In-Text--PACKT-">main</code> function run. That's basically why the shared memory object in the preceding example gets <code class="Code-In-Text--PACKT-">3</code> as its file descriptor.</p>
			<div>
				<div id="_idContainer134" class="note">
					<p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">On macOS systems, you can use the <code class="Code-In-Text--PACKT-">pics</code> utility to check<a id="_idIndexMarker1208"/> active IPC objects in the system. It can show you the active message queues and shared memories. It shows you the active semaphores as well.</p>
				</div>
			</div>
			<p class="normal">The <code class="Code-In-Text--PACKT-">/dev/shm</code> directory has another interesting property. You can use the <code class="Code-In-Text--PACKT-">cat</code> utility to see the contents of shared memory objects, but again this is only available in Linux. Let's use it on our created <code class="Code-In-Text--PACKT-">shm0</code> object. As you see in the following shell box, the contents of the shared memory object are displayed. It is the string <code class="Code-In-Text--PACKT-">ABC</code> plus a new line feed character <code class="Code-In-Text--PACKT-">\n</code>:</p>
			<p class="snippet shell"><strong class="highlight">$ cat /dev/shm/shm0</strong></p>
			<p class="snippet shell">ABC</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 17-5 Using the cat program to see the content of the shared memory object created as part of example 17.4</p>
			<p class="normal">As we explained before, a shared memory object exists as long as it is being used by at least one process. Even if one of the processes has already asked the operating system to delete (or <em class="italics">unlink</em>) the shared memory, it won't be actually deleted until the last process has used it. Even when there is no process unlinking a shared memory object, it would be deleted when a<a id="_idIndexMarker1209"/> reboot happens. Shared memory objects cannot survive reboots, and the processes should create them again in order to use them for communication.</p>
			<p class="normal">The following example shows how a process can open and read from an already existing shared memory object and how it can unlink it finally. <em class="italics">Example 17.5</em> reads from the shared memory object created in <em class="italics">example 17.4</em>. Therefore, it can be considered as complementary to what we did in <em class="italics">example 17.4</em>:</p>
			<p class="snippet code">#include &lt;stdio.h&gt;</p>
			<p class="snippet code">#include &lt;unistd.h&gt;</p>
			<p class="snippet code">#include &lt;fcntl.h&gt;</p>
			<p class="snippet code">#include &lt;errno.h&gt;</p>
			<p class="snippet code">#include &lt;string.h&gt;</p>
			<p class="snippet code">#include &lt;sys/mman.h&gt;</p>
			<p class="snippet code">#define SH_SIZE 16</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  int shm_fd = shm_open("/shm0", O_RDONLY, 0600);</p>
			<p class="snippet code">  if (shm_fd &lt; 0) {</p>
			<p class="snippet code">    fprintf(stderr, "ERROR: Failed to open shared memory: %s\n",</p>
			<p class="snippet code">        strerror(errno));</p>
			<p class="snippet code">    return 1;</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  fprintf(stdout, "Shared memory is opened with fd: %d\n", shm_fd);</p>
			<p class="snippet code">  void* map = mmap(0, SH_SIZE, PROT_READ, MAP_SHARED, shm_fd, 0);</p>
			<p class="snippet code">  if (map == MAP_FAILED) {</p>
			<p class="snippet code">    fprintf(stderr, "ERROR: Mapping failed: %s\n",</p>
			<p class="snippet code">            strerror(errno));</p>
			<p class="snippet code">    return 1;</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  char* ptr = (char*)map;</p>
			<p class="snippet code">  fprintf(stdout, "The contents of shared memory object: %s\n",</p>
			<p class="snippet code">          ptr);</p>
			<p class="snippet code">  if (munmap(ptr, SH_SIZE) &lt; 0) {</p>
			<p class="snippet code">    fprintf(stderr, "ERROR: Unmapping failed: %s\n",</p>
			<p class="snippet code">            strerror(errno));</p>
			<p class="snippet code">    return 1;</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  if (close(shm_fd) &lt; 0) {</p>
			<p class="snippet code">    fprintf(stderr, "ERROR: Closing shared memory fd filed: %s\n",</p>
			<p class="snippet code">        strerror(errno));</p>
			<p class="snippet code">    return 1;</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  if (shm_unlink("/shm0") &lt; 0) {</p>
			<p class="snippet code">    fprintf(stderr, "ERROR: Unlinking shared memory failed: %s\n",</p>
			<p class="snippet code">        strerror(errno));</p>
			<p class="snippet code">    return 1;</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 17-5 [ExtremeC_examples_chapter17_5.c]: Reading from the shared memory object created as part of example 17.4</p>
			<p class="normal">As the first statement in the <code class="Code-In-Text--PACKT-">main</code> function, we have opened an existing shared memory object named <code class="Code-In-Text--PACKT-">/shm0</code>. If there is no such shared memory object, we will generate an error. As you can see, we have opened the shared memory object as read-only, meaning that we are not going to write anything to the shared memory.</p>
			<p class="normal">On the following lines, we map the shared memory region. Again, we have indicated that the mapped region is read-only by passing the <code class="Code-In-Text--PACKT-">PROT_READ</code> argument. After that, we finally get a pointer to the shared memory region, and we use it to print its contents. When we're done with the<a id="_idIndexMarker1210"/> shared memory, we unmap the region. Following this, the assigned file descriptor is closed, and lastly the shared memory object is registered for removal by unlinking it through using the <code class="Code-In-Text--PACKT-">shm_unlink</code> function. </p>
			<p class="normal">After this point, when all other processes that are using the same shared memory are done with it, the shared memory object gets removed from the system. Note that the shared memory object exists as long as there is a process using it.</p>
			<p class="normal">The following is the output of running the preceding code. Note the contents of <code class="Code-In-Text--PACKT-">/dev/shm</code> before and after running <em class="italics">example 17.5</em>:</p>
			<p class="snippet shell"><strong class="highlight">$ ls /dev/shm</strong></p>
			<p class="snippet shell">shm0</p>
			<p class="snippet shell"><strong class="highlight">$ gcc ExtremeC_examples_chapter17_5.c -lrt -o ex17_5.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ ./ex17_5.out</strong></p>
			<p class="snippet shell">Shared memory is opened with fd: 3</p>
			<p class="snippet shell">The contents of the shared memory object: ABC</p>
			<p class="snippet shell"><strong class="highlight">$ ls /dev/shm</strong></p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 17-6: Reading from the shared memory object created in example 17.4 and finally removing it</p>
			<h3 id="_idParaDest-234" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor446"/>Data race example using shared memory</h3>
			<p class="normal">Now, it's time to demonstrate a<a id="_idIndexMarker1211"/> data race using the <a id="_idIndexMarker1212"/>combination of the fork API and shared memory. It would be analogous to the examples given in <em class="italics">Chapter 15</em>, <em class="italics">Thread Execution</em>, to demonstrate a data race among a number of threads.</p>
			<p class="normal">In <em class="italics">example 17.6</em>, we have a counter variable that is placed inside a shared memory region. The example forks a child process out of the main running process, and both of them try to increment the shared counter. The final output shows a clear data race over the shared counter:</p>
			<p class="snippet code">#include &lt;stdio.h&gt;</p>
			<p class="snippet code">#include &lt;stdint.h&gt;</p>
			<p class="snippet code">#include &lt;stdlib.h&gt;</p>
			<p class="snippet code">#include &lt;unistd.h&gt;</p>
			<p class="snippet code">#include &lt;fcntl.h&gt;</p>
			<p class="snippet code">#include &lt;errno.h&gt;</p>
			<p class="snippet code">#include &lt;string.h&gt;</p>
			<p class="snippet code">#include &lt;sys/mman.h&gt;</p>
			<p class="snippet code">#include &lt;sys/wait.h&gt;</p>
			<p class="snippet code">#define SH_SIZE 4</p>
			<p class="snippet code">// Shared file descriptor used to refer to the</p>
			<p class="snippet code">// shared memory object</p>
			<p class="snippet code">int shared_fd = -1;</p>
			<p class="snippet code">// The pointer to the shared counter</p>
			<p class="snippet code">int32_t* counter = NULL;</p>
			<p class="snippet code">void init_shared_resource() {</p>
			<p class="snippet code">  // Open the shared memory object</p>
			<p class="snippet code">  shared_fd = shm_open("/shm0", O_CREAT | O_RDWR, 0600);</p>
			<p class="snippet code">  if (shared_fd &lt; 0) {</p>
			<p class="snippet code">    fprintf(stderr, "ERROR: Failed to create shared memory: %s\n",</p>
			<p class="snippet code">        strerror(errno));</p>
			<p class="snippet code">    exit(1);</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  fprintf(stdout, "Shared memory is created with fd: %d\n",</p>
			<p class="snippet code">          shared_fd);</p>
			<p class="snippet code">}</p>
			<p class="snippet code">void shutdown_shared_resource() {</p>
			<p class="snippet code">  if (shm_unlink("/shm0") &lt; 0) {</p>
			<p class="snippet code">    fprintf(stderr, "ERROR: Unlinking shared memory failed: %s\n",</p>
			<p class="snippet code">        strerror(errno));</p>
			<p class="snippet code">    exit(1);</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">}</p>
			<p class="snippet code">void inc_counter() {</p>
			<p class="snippet code">  usleep(1);</p>
			<p class="snippet code">  int32_t temp = *counter;</p>
			<p class="snippet code">  usleep(1);</p>
			<p class="snippet code">  temp++;</p>
			<p class="snippet code">  usleep(1);</p>
			<p class="snippet code">  *counter = temp;</p>
			<p class="snippet code">  usleep(1);</p>
			<p class="snippet code">}</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  // Parent process needs to initialize the shared resource</p>
			<p class="snippet code">  init_shared_resource();</p>
			<p class="snippet code">  // Allocate and truncate the shared memory region</p>
			<p class="snippet code">  if (ftruncate(shared_fd, SH_SIZE * sizeof(char)) &lt; 0) {</p>
			<p class="snippet code">    fprintf(stderr, "ERROR: Truncation failed: %s\n",</p>
			<p class="snippet code">            strerror(errno));</p>
			<p class="snippet code">    return 1;</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  fprintf(stdout, "The memory region is truncated.\n");</p>
			<p class="snippet code">  // Map the shared memory and initialize the counter</p>
			<p class="snippet code">  void* map = mmap(0, SH_SIZE, PROT_WRITE,</p>
			<p class="snippet code">          MAP_SHARED, shared_fd, 0);</p>
			<p class="snippet code">  if (map == MAP_FAILED) {</p>
			<p class="snippet code">    fprintf(stderr, "ERROR: Mapping failed: %s\n",</p>
			<p class="snippet code">            strerror(errno));</p>
			<p class="snippet code">    return 1;</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  counter = (int32_t*)map;</p>
			<p class="snippet code">  *counter = 0;</p>
			<p class="snippet code">  // Fork a new process</p>
			<p class="snippet code">  pid_t pid = fork();</p>
			<p class="snippet code">  if (pid) { // The parent process</p>
			<p class="snippet code">    // Increment the counter</p>
			<p class="snippet code">    inc_counter();</p>
			<p class="snippet code">    fprintf(stdout, "The parent process sees the counter as %d.\n",</p>
			<p class="snippet code">        *counter);</p>
			<p class="snippet code">    // Wait for the child process to exit</p>
			<p class="snippet code">    int status = -1;</p>
			<p class="snippet code">    wait(&amp;status);</p>
			<p class="snippet code">    fprintf(stdout, "The child process finished with status %d.\n",</p>
			<p class="snippet code">        status);</p>
			<p class="snippet code">  } else { // The child process</p>
			<p class="snippet code">    // Incrmenet the counter</p>
			<p class="snippet code">    inc_counter();</p>
			<p class="snippet code">    fprintf(stdout, "The child process sees the counter as %d.\n",</p>
			<p class="snippet code">        *counter);</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  // Both processes should unmap shared memory region and close</p>
			<p class="snippet code">  // its file descriptor</p>
			<p class="snippet code">  if (munmap(counter, SH_SIZE) &lt; 0) {</p>
			<p class="snippet code">    fprintf(stderr, "ERROR: Unmapping failed: %s\n",</p>
			<p class="snippet code">            strerror(errno));</p>
			<p class="snippet code">    return 1;</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  if (close(shared_fd) &lt; 0) {</p>
			<p class="snippet code">    fprintf(stderr, "ERROR: Closing shared memory fd filed: %s\n",</p>
			<p class="snippet code">        strerror(errno));</p>
			<p class="snippet code">    return 1;</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  // Only parent process needs to shutdown the shared resource</p>
			<p class="snippet code">  if (pid) {</p>
			<p class="snippet code">    shutdown_shared_resource();</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 17-6 [ExtremeC_examples_chapter17_6.c]: Demonstration of a data race using a POSIX shared memory and the fork API</p>
			<p class="normal">There are three functions in the preceding code other than the <code class="Code-In-Text--PACKT-">main</code> function. The function <code class="Code-In-Text--PACKT-">init_shared_resource</code> creates the shared memory object. The reason that I've named this<a id="_idIndexMarker1213"/> function <code class="Code-In-Text--PACKT-">init_shared_resource</code> instead of <code class="Code-In-Text--PACKT-">init_shared_memory</code> is the fact that we could use another pull-based technique in the preceding example and having a general name for this function allows the <code class="Code-In-Text--PACKT-">main</code> function to remain unchanged in the future examples.</p>
			<p class="normal">The function <code class="Code-In-Text--PACKT-">shutdown_shared_resource</code> destructs the shared memory and unlinks it. In addition, the<a id="_idIndexMarker1214"/> function <code class="Code-In-Text--PACKT-">inc_counter</code> increments the shared counter by 1.</p>
			<p class="normal">The <code class="Code-In-Text--PACKT-">main</code> function truncates and maps the shared memory region just like we did in <em class="italics">example 17.4</em>. After having the shared memory region mapped, the forking logic beings. By calling the <code class="Code-In-Text--PACKT-">fork</code> function, a new process is spawned, and both processes (the forked process and the forking process) try to increment the counter by calling the <code class="Code-In-Text--PACKT-">inc_counter</code> function.</p>
			<p class="normal">When the parent process writes to the shared counter, it waits for the child process to finish, and only after that, it tries to unmap, close, and unlink the shared memory object. Note that the unmapping and the closure of the file descriptor happen in both processes, but only the parent process unlinks the shared memory object.</p>
			<p class="normal">As you can see as part of <em class="italics">Code Box 17-6</em>, we have used some unusual <code class="Code-In-Text--PACKT-">usleep</code> calls in the <code class="Code-In-Text--PACKT-">inc_counter</code> function. The reason is to force the scheduler to take back the CPU core from one process and give it to another process. Without these <code class="Code-In-Text--PACKT-">usleep</code> function calls, the CPU core is not usually transferred between the processes, and you cannot see the effect of different interleavings very often.</p>
			<p class="normal">One of the reasons for such an effect is having a small number of instructions in each process. If the<a id="_idIndexMarker1215"/> number of instructions per process increases significantly, one can see the non-deterministic behavior of interleavings even without sleep calls. As an example, having a loop in each process that counts for 10,000 times and increments the shared counter in each iteration is very <a id="_idIndexMarker1216"/>likely to reveal the data race. You can try this yourself.</p>
			<p class="normal">As the final note about the preceding code, the parent process creates and opens the shared memory object and assigns a file descriptor to it before forking the child process. The forked process doesn't open the shared memory object, but it can use the same file descriptor. The fact that all open file descriptors are inherited from the parent process helped the child process to continue and use the file descriptor, referring to the same shared memory object.</p>
			<p class="normal">The following in <em class="italics">Shell Box 17-7</em> is the output of running <em class="italics">example 17.6</em> for a number of times. As you can see, we have a clear data race over the shared counter. There are moments when the parent or the child process updates the counter without obtaining the latest modified value, and this results in printing <code class="Code-In-Text--PACKT-">1</code> by both processes:</p>
			<p class="snippet shell"><strong class="highlight">$ gcc ExtremeC_examples_chapter17_6 -o ex17_6.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ ./ex17_6.out</strong></p>
			<p class="snippet shell">Shared memory is created with fd: 3</p>
			<p class="snippet shell">The memory region is truncated.</p>
			<p class="snippet shell">The parent process sees the counter as 1.</p>
			<p class="snippet shell">The child process sees the counter as 2.</p>
			<p class="snippet shell">The child process finished with status 0.</p>
			<p class="snippet shell"><strong class="highlight">$ ./ex17_6</strong></p>
			<p class="snippet shell">...</p>
			<p class="snippet shell">...</p>
			<p class="snippet shell">...</p>
			<p class="snippet shell"><strong class="highlight">$ ./ex17_6.out</strong></p>
			<p class="snippet shell">Shared memory is created with fd: 3</p>
			<p class="snippet shell">The memory region is truncated.</p>
			<p class="snippet shell">The parent process sees the counter as 1.</p>
			<p class="snippet shell">The child process sees the<a id="_idTextAnchor447"/> counter as 1.</p>
			<p class="snippet shell">The child process finished with status 0.</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 17-7: Running example 17.6 and demonstration of the data race happening over the shared counter</p>
			<p class="normal">In this section, we showed how to create and use shared memory. We also demonstrated a<a id="_idIndexMarker1217"/> data race example and the way concurrent processes behave while accessing a shared memory region. In<a id="_idIndexMarker1218"/> the following section, we're going to talk about the filesystem as another widely used pull-based method to share a state among a number of processes.</p>
			<h2 id="_idParaDest-235" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor448"/>File system</h2>
			<p class="normal">POSIX exposes a similar API for <a id="_idIndexMarker1219"/>working with files in a filesystem. As long as the file descriptors are involved and they are used to refer to various system objects, the same API as that introduced for working with shared memory can be used.</p>
			<p class="normal">We use file descriptors to refer to actual files in a filesystem like <strong class="bold">ext4</strong>, together with shared memory, pipes, and so on; therefore, the same semantic for opening, reading, writing, mapping them to a local memory region, and so on can be employed. Therefore, we'd expect to see similar discussion and perhaps similar C code regarding the filesystem as we had for the shared memory. We see this in <em class="italics">example 17.7</em>.</p>
			<div>
				<div id="_idContainer135" class="note">
					<p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">We usually map file descriptors. There are some exceptional cases, however, where <em class="italics">socket descriptors</em> can be mapped. Socket<a id="_idIndexMarker1220"/> descriptors are similar to file descriptors but are used for network or Unix sockets. This link provides <a id="_idIndexMarker1221"/>an interesting use case for mapping the kernel buffer behind a TCP socket which is referred to as a <em class="italics">zero-copy receive mechanism</em>: <span class="url">https://lwn.net/Articles/752188/</span>.</p>
				</div>
			</div>
			<p class="normal">Note that it's correct that the API employed for using the filesystem is very similar to the one we used for shared <a id="_idIndexMarker1222"/>memory, but it doesn't mean that their implementation is similar as well. In fact, a file object in a filesystem backed by a hard disk is fundamentally different from a shared memory object. Let's briefly discuss some differences:</p>
			<ul>
				<li class="list">A shared memory <a id="_idIndexMarker1223"/>object is basically in the memory space of the kernel process while a file in a filesystem is located on a disk. At most, such a file has some allocated buffers for reading and writing operations.</li>
				<li class="list">The states written to shared memory are wiped out by rebooting the system, but the states written to a shared file, if it is backed by a hard disk or permanent storage, can be retained after the reboot.</li>
				<li class="list">Generally, accessing shared memory is far faster than accessing the filesystem.</li>
			</ul>
			<p class="normal">The following code is the same data race example that we gave for the shared memory in the previous section. Since the API used for the filesystem is pretty similar to the API we used for the shared memory, we only need to change two functions from <em class="italics">example 17.6</em>; <code class="Code-In-Text--PACKT-">init_shared_resource</code> and <code class="Code-In-Text--PACKT-">shutdown_shared_resource</code>. The rest will be the same. This is a great achievement that is accomplished by using the same POSIX API operating on the file descriptors. Let's get into the code:</p>
			<p class="snippet code">#include &lt;stdio.h&gt;</p>
			<p class="snippet code">#include &lt;stdint.h&gt;</p>
			<p class="snippet code">#include &lt;stdlib.h&gt;</p>
			<p class="snippet code">#include &lt;unistd.h&gt;</p>
			<p class="snippet code">#include &lt;fcntl.h&gt;</p>
			<p class="snippet code">#include &lt;errno.h&gt;</p>
			<p class="snippet code">#include &lt;string.h&gt;</p>
			<p class="snippet code">#include &lt;sys/mman.h&gt;</p>
			<p class="snippet code">#include &lt;sys/wait.h&gt;</p>
			<p class="snippet code">#define SH_SIZE 4</p>
			<p class="snippet code">// The shared file descriptor used to refer to the shared file</p>
			<p class="snippet code">int shared_fd = -1;</p>
			<p class="snippet code">// The pointer to the shared counter</p>
			<p class="snippet code">int32_t* counter = NULL;</p>
			<p class="snippet code">void init_shared_resource() {</p>
			<p class="snippet code">  // Open the file</p>
			<p class="snippet code">  shared_fd = open("data.bin", O_CREAT | O_RDWR, 0600);</p>
			<p class="snippet code">  if (shared_fd &lt; 0) {</p>
			<p class="snippet code">    fprintf(stderr, "ERROR: Failed to create the file: %s\n",</p>
			<p class="snippet code">        strerror(errno));</p>
			<p class="snippet code">    exit(1);</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  fprintf(stdout, "File is created and opened with fd: %d\n",</p>
			<p class="snippet code">          shared_fd);</p>
			<p class="snippet code">}</p>
			<p class="snippet code">void shutdown_shared_resource() {</p>
			<p class="snippet code">  if (remove("data.bin") &lt; 0) {</p>
			<p class="snippet code">    fprintf(stderr, "ERROR: Removing the file failed: %s\n",</p>
			<p class="snippet code">        strerror(errno));</p>
			<p class="snippet code">    exit(1);</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">}</p>
			<p class="snippet code">void inc_counter() {</p>
			<p class="snippet code">  ... As exmaple 17.6 ...</p>
			<p class="snippet code">}</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  ... As exmaple 17.6 ...</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 17-7 [ExtremeC_examples_chapter17_7.c]: Demonstration of a data race using regular files and the fork API </p>
			<p class="normal">As you see, the majority <a id="_idIndexMarker1224"/>of the preceding code is obtained from <em class="italics">example 17.6</em>. The rest is a substitute for using the <code class="Code-In-Text--PACKT-">open</code> and <code class="Code-In-Text--PACKT-">remove</code> functions instead of the <code class="Code-In-Text--PACKT-">shm_open</code> and <code class="Code-In-Text--PACKT-">shm_unlink</code> functions.</p>
			<p class="normal">Note that the file <code class="Code-In-Text--PACKT-">data.bin</code> is created in the current directory since we've not given an absolute path to the <code class="Code-In-Text--PACKT-">open</code> function. Running the preceding code also produces the same data race over the shared counter. It can be examined similarly to our approach for <em class="italics">example 17.6</em>.</p>
			<p class="normal">So far, we have seen that we can use shared memory and shared files to st<a id="_idTextAnchor449"/>ore a state and access it from a number <a id="_idIndexMarker1225"/>of processes concurrently. Now, it's time to talk about multithreading a<a id="_idTextAnchor450"/>nd multi-processing in a greater sen<a id="_idTextAnchor451"/>se and compare them thoroughly.</p>
			<h1 id="_idParaDest-236" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor452"/>Multithreading versus multi-processing</h1>
			<p class="normal">After discussing <a id="_idIndexMarker1226"/>multithreading and multi-processing in <em class="italics">Chapter 14</em>, <em class="italics">Synchronization</em>, together with concepts we have covered throughout the recent chapters, we are in a good position to compare them and give a high-level description of situations in which each of the approaches should be employed. Suppose that we are going to design a piece of software that aims to process a number of input requests concurrently. We discuss this in the context of three different situations. Let's start with the first one.</p>
			<h2 id="_idParaDest-237" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor453"/>Multithreading</h2>
			<p class="normal">The first situation is<a id="_idIndexMarker1227"/> when you can write a piece of software that has only one process, and all the requests go into the same process. All the logic should<a id="_idIndexMarker1228"/> be written as part of the same process, and as a result, you get a fat process that does everything in your system. Since this is single-process software, if you want to handle many requests concurrently, you need to do it in a multithreaded way by creating threads to handle multiple requests. Further, it can be a better design decision to <a id="_idIndexMarker1229"/>go for a <em class="italics">thread pool</em> that has a limited number of threads.</p>
			<p class="normal">There are the following considerations regarding concurrency and synchronization which should be taken care of. Note that we don't talk about using event loops or asynchronous I/O in this situation, while it can still be a valid alternative to multithreading.</p>
			<p class="normal">If the number of requests increases significantly, the limited number of threads within the thread pool should be increased to overcome the demand. This literally means upgrading the hardware and resources on the machine on which the main process is running. This is called <em class="italics">scaling up</em> or <em class="italics">vertical scaling</em>. It means that you upgrade the hardware you have on<a id="_idIndexMarker1230"/> a single machine to<a id="_idIndexMarker1231"/> be able to respond to more requests. In addition to the possible downtime that clients experience while upgrading to the new hardware (though it can be prevented), the upgrade is costly, and you have to do another scale up when the number of requests grows again.</p>
			<p class="normal">If processing the requests ends up in manipulating a shared state or a data store, synchronization techniques can be implemented easily, by knowing the fact that threads have access to the same memory space. Of course, this is needed whether they have a shared data structure that should be maintained or they have access to remote data storage that is not transactional.</p>
			<p class="normal">All the threads are running on the same machine, and thus they can use all the techniques used for sharing a state that we explained so far, used by both threads and processes. This is<a id="_idIndexMarker1232"/> a great fe<a id="_idTextAnchor454"/>ature and mitigates a lot of pain<a id="_idIndexMarker1233"/> when it comes to thread synchronization.</p>
			<p class="normal">Let's talk about the next situation, when we can have more than one process but all of them are on the same machine.</p>
			<h2 id="_idParaDest-238" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor455"/>Single-host multi-processing</h2>
			<p class="normal">In this situation, we write<a id="_idIndexMarker1234"/> a piece of software that has multiple processes, but all are deployed on a single machine. All of these processes can be either single-threaded, or they can have a thread pool inside that allows each of them to handle more than one request at a time.</p>
			<p class="normal">When the number<a id="_idIndexMarker1235"/> of requests increases, one can create new processes instead of creating more threads. This is usually called <em class="italics">scaling out</em> or <em class="italics">horizontal scaling</em>. When you have only one single machine, however, you must scale it up, or in other words, you must<a id="_idIndexMarker1236"/> upgrade its hardware. This can cause the same issues we mentioned for the scaling up of a multithreaded program in the previous subsection.</p>
			<p class="normal">When it comes to concurrency, the processes are being executed in a concurrent environment. They can only use the multi-processing ways of sharing a state or synchronizing the processes. Surely, it is not as convenient as writing multithreaded code. In additio<a id="_idTextAnchor456"/>n, processes can use both pull-based or push-based techniques to share states.</p>
			<p class="normal">Multi-processing on a single machine is not very effective, and it seems multithreading is more convenient when it comes to the effort of coding.</p>
			<p class="normal">The next subsection talks about the distributed multi-processing environment, which is the best design to create modern software.</p>
			<h2 id="_idParaDest-239" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor457"/>Distributed multi-processing</h2>
			<p class="normal">In the final situation, we<a id="_idIndexMarker1237"/> have written a program that is run as multiple processes, running on multiple hosts, all connected to each other through a network, and on a single host we can have more than one process running. The following features can be seen in such a deployment.</p>
			<p class="normal">When faced with significant growth in the number of requests, this system can be scaled out without limits. This is a great feature that enables you to use commodity hardware when you face such<a id="_idIndexMarker1238"/> high peaks. Using the clusters of commodity hardware instead of powerful servers was one of the ideas that enabled Google to run its <em class="italics">Page Rank</em> and <em class="italics">Map</em> <em class="italics">Reduce</em> algorithms on a cluster of machines.</p>
			<p class="normal">The techniques discussed in this chapter barely help because they have an important prerequisite: that all the <a id="_idIndexMarker1239"/>processes are running within the same machine. Therefore, a completely different set of algorithms and techniques should be employed to make the processes synchronized and make shared states available to all processes within the system. <em class="italics">Latency</em>, <em class="italics">fault tolerance</em>, <em class="italics">availability</em>, <em class="italics">data consistency</em>, and many more factors should be studied and tuned regarding such a distributed system.</p>
			<p class="normal">Processes on different hosts use network sockets to communicate in a push-based manner, but the processes on the same host may use local IPC techniques, for example, messa<a id="_idTextAnchor458"/>ge queues, shared memory, pipes, and so on, to transfer messages and share state.</p>
			<p class="normal">As a final word in this section, in the modern software industry, we prefer scaling out rather than scaling up. This will give rise to many new ideas and technologies for data storage, synchronization, message passing, and so on. It can even have an impact on the hardware design to make it suitable for horizontal scaling.</p>
			<h1 id="_idParaDest-240" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor459"/>Summary</h1>
			<p class="normal">In this chapter, we explored multi-processing systems and the various techniques that can be used to share a state among a number of processes. The following topics were covered in this chapter:</p>
			<ul>
				<li class="list">We introduced the POSIX APIs used for process execution. We explained how the <code class="Code-In-Text--PACKT-">fork</code> API and <code class="Code-In-Text--PACKT-">exec*</code> functions work.</li>
				<li class="list">We explained the steps that a kernel takes to execute a process.</li>
				<li class="list">We discussed the ways that a state can be shared among a number of processes.</li>
				<li class="list">We introduced the pull-based and push-based techniques as the two top-level categories for all other available techniques.</li>
				<li class="list">Shared memory and shared files on a filesystem are among common techniques to share a state in a pull-based manner.</li>
				<li class="list">We explained the differences and similarities of multithreading and multi-processing deployments and the concepts of vertical and horizontal scaling in a distributed software system.</li>
			</ul>
			<p class="normal">In the next chapter, we are going to talk about concurrency in single-host multi-processing environments. It will consist of discussions about concurrency issues and the ways to synchronize a number of processes in order to protect a shared resource. The topics are very similar to the ones you encountered in <em class="italics">Chapter 16</em>, <em class="italics">Thread Synchronization</em>, but their focus is on the processes rather than the threads.</p>
		</div>
</body></html>