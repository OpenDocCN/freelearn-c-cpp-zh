- en: Effects of lighting , Materials and Lightmaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed how to apply transformations and projections
    to objects. We also created multiple cubes and a `Camera` class to clearly view
    and navigate around those objects. In this chapter, we're going to look at lighting.
    Firstly, we're going to discuss the basics of colors with respect to our objects
    and the source of light. We'll also discuss creating a vertex shader and a fragment
    shader, like we had in the previous chapters for our object box. We'll be creating
    a shader for an actual light source such as a lamp. You'll also learn how to apply
    materials to your object cube and you will observe the effect light has on those
    materials.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of colors in lighting and lighting effects on objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effect of light on a type of material
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring lightmaps to implement the real-world effects of light on different
    materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lights... camera...action!!
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to all the code files for this chapter in the `Chapter04` folder
    on GitHub. The GitHub link can be found in the preface of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an object and a light source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, will discuss how to apply colors to your cube object. We'll
    also learn how to create shader files for light and for a source of light such
    as a lamp. And then we'll learn how to add the cube and the light source to our
    game world.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's begin by creating new shader files for the light and the lamp.
  prefs: []
  type: TYPE_NORMAL
- en: Creating lighting and lamp shader files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here we''ll learn how to create shader files for a light source and a lamp
    and explore the code that will go into the vertex shaders and the fragment shaders.
    Perform the following steps to learn how create these shader files:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, for rename `core.vs` and `core.frag` from the previous chapters
    to `lighting.vs` and `lighting.core`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s begin with the modifications to the code of these newly renamed
    files. First of all, we''ll modify `lighting.vs`. What we''re going to do here
    is get rid of the texture coordinate because we''re not going to render a texture
    in here, and we''ll also get rid of the `out texture` variable. Take a look at
    the following code to understand the changes made in the vertex shader for lighting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll go to `lighting.frag` and carry out the modifications as in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `objectColor`, the variable that we have added, will
    contain the color of the object itself, which is the cube in our example.
  prefs: []
  type: TYPE_NORMAL
- en: Save both the files, and now we'll create shader files for our lamp.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating shader files for the lamp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the following steps to see how to create lamp shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: Duplicate the files that we've updated in the preceding steps and rename them
    `lamp.vs` and `lamp.frag`, and we'll need to modify some code in these new files
    to create our light source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We won't be making any modifications to `lamp.vs` as we need the updated code
    as it is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to make some modifications to `lamp.frag`, so take a look at the highlighted
    terms in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The reason we have passed the value to `vec4` as `1.0f` is so that all the vector
    values should be set to `1.0f`, which is red, green, blue, and alpha at high intensity.
    So, it'll be fully on. If you have full red, full green, and full blue, you get
    white. Thus, our lamp will emit white light.
  prefs: []
  type: TYPE_NORMAL
- en: You might have done an experiment in high school where you get all the different
    colors of the rainbow on a circle, and if you spin it fast enough, the combined
    color looks white. It's a pretty cool experiment, and you probably could do that
    at home. It's worth checking that out, just in general, it's a fun thing to do.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we've got our shader files all set up for lighting and lamp we'll
    move on to our main code in the `main.cpp` file to add an object and light source
    to our game world.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the main code to implement a cube and a light source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have created new shader files for our project we''ll next work
    on our main code and add a colored cube and a light source to our game world.
    In this section, we''ll also take a look at how to reference our newly created
    shader files in the code. Here, we''ll work on the code from the previous chapter
    and make modifications to it. Perform the following steps to understand the changes
    made to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we''re going to do, before our `int main()`, is add `glm::vec3
    lightPos();`. So, this is going to be the position of the source of light in our
    world. We''ll pass following coordinates to the function `lightpos()`: `1.2f`,
    `1.0f`, and `2.0f`. The way this works is you have light emitting from a particular
    location, for example, if you load in a light bulb as a source and you place it
    at the defined location. The light bulb itself is a light source for our world.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we'll go to the section where we've defined our shader. As we've added
    new shaders to our project, we'll have to reference them in the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we''ve got a couple of shaders, what we''re going to do is duplicate
    the `Shader ourShader( );` function present in our code and rename it `lightingShader`
    and `lampShader`. Obviously, we''ll need to update the path mentioned so as to
    reference our lighting and lamp shader files. Have a look at the following highlighted
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, for the vertices, what we're going to do is remove all the texture coordinates
    present in our array. As we're not rendering any texture in this code and we only
    need the x, y, and z coordinates to describe our cube. You can refer to the updated
    vertices in the `main.cpp` file present in the `colours` folder in the `Chapter04`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we'll get rid of the `cubePositions []` array as we're going to be rendering
    a single cube in our world. This will make it easier for us to understand the
    effect of light on our object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, in the code, where we''ve defined our vertex buffer objects and vertex
    array objects, we''ll make the following modifications to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The reason we made this modification is we're going to have a vertex buffer
    object that we'll just reuse, but for the vertex array object, there'll be a different
    one for each individual shader and the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the position attribute, we''ll update the `5 * sizeof()` to `3 * size
    of()` as we no longer have five pieces of information in a row in the vertex array,
    which were the 3: *x*, *y*, and *z* coordinates and the two texture coordinates.
    Now, as we are no longer using texture cooordinates we only have *x*, *y*, and
    *z* coordinates in the array.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we'll get rid of the texture coordinate attribute because we're no longer
    loading textures in our code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then what we''re going to do is duplicate the vertex defining code, vertex
    binding code, and the position attribute code and paste in below the position
    attribute code. And in these duplicated lines of code we''ll make the following
    highlighted changes to add the light vertex array object to our main code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The next thing that we're going to do is get rid of the entire create and load
    texture code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the previous chapter, we had added the projection matrix within the loop
    and it was declared every single time the loop ran. Now, because we're getting
    the field of view using GetZoom we can't place the projection matrix in the loop.
    So, as a result, we might as well just get the projection matrix code out of the
    loop and paste it at start of the while loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modifications to the while loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s a few things that we need to change inside the while loop, so let''s
    take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we''re going to change the background color so we have a darker
    background so that the lighting that we are trying to implement will have more
    of effect on our object. So, we''ll make the following modifications to the `glClearColor
    ()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What we're going to do next is get rid of all the code from the point where
    we defined our bind texture code to the point where we define our draw container
    code and add the fresh code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, what we're going to do is use the corresponding shader to set the uniform
    objects and draw the object's code. First of all, what we're going to add `lightingShader.Use();`
    as we're handling the lighting shader of the box. Then we're going to create a
    `GLuint` variable, `objectColorLoc`, and to this we'll assign the value of function
    `glGetUniformLocation ()`, which will consists of parameter such as `lightingShader.Program`
    and `"objectColor"`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As usual, if you would like to know more details about what we're discussing,
    you can check out [learnopengl.com](http://learnopengl.com) and [open.gl](http://open.gl).
    They've got some well-written tutorials on there and they've got images to accompany
    those tutorials, and it's a great way of learning on top of these chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''re going to duplicate the preceding line of code and make the highlighted
    modifications to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Then we're going to add function `glUniform3f()`and to that we're uniforming
    the object color location. So, we'll pass the parameters as `objectColorLoc` and
    `1.0f`, `0.5f`, `0.31f`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These are obviously just arbitrary values that we have been determined, and
    they actually work well. Obviously in your future projects, when you''re not following
    the chapter, you can try experimenting with the values. We''ll just duplicate
    the preceding line of code and make the following highlighted changes to it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: And now we're going to create a camera transformation. So, we'll add the view
    matrix`glm::mat4 view;` to our code and then type `view = camera.GetViewMatrix`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we're going to get the uniform location for the model, view, and projection
    matrix. So, we're going to type `GLint modelLoc = glGetUniformLocation();` . And
    in there, we are going to pass `lightingShader.Program` and `model`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll just duplicate this preceding code a couple of times and make the highlighted
    changes to it, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: And now we're going to pass the matrices to the shader. So now, we just need
    to add `glUniformMatrix4fv();`. And to this function, we'll pass `viewLoc`, `1`,
    `GL_FALSE`, `glm::value_ptr()` and for the value pointer function, you just specify
    our 4x4 view matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Duplicate the preceding line of code, as we need to do the same for projection
    matrix. Check out the following code and the highlighted terms in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now what we''re going to do is draw the container using the container''s vertex
    attributes, simple stuff, we''ve covered this in previous chapters. If you want
    to review them, feel free. Take a look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we put 36\. The reason for this is, as there are a total
    of 36 vertices, 6 per side, and there are 6 sides to a cube, so we passed 36 in
    the function `glDrawArrays()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, what we''ll do is duplicate the code that we have described in the previous
    steps and paste it below the preceding code. Then we''ll carry out the following
    highlighted changes for the lamp shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, in `glm::vec3( 0.2f )` we added 0.2f as we wanted to
    scale it by `0.2f` on every axis. The reason we're scaling it is because we don't
    want our light source, our lamp, to be the same size as our cube. It's just the
    way we perceive the world. Generally speaking, a bulb is smaller than most things
    in the room that we perceive.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, the only thing we need to do is update `glDeleteVertexArrays()`. We''ll
    update that as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re now ready to run and see our masterpiece. Check the output on your window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d15334a-f35e-41fa-8437-e5ee6ce04d6f.png)'
  prefs: []
  type: TYPE_IMG
- en: We've got this sort of red-looking box and we've got our white light source.
    It doesn't look like it's really emitting any light, but this is just the basics.
    But this is a nice precursor to future sections, and just the future of creating
    really cool lighting effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we''re going to look at some really cool basic lighting
    that will make this look a lot better. So, we recommend you do an extra task in
    the code: figure out where you can change the color of our object and the light
    emitting object. So, that''s it for just basic colors in lighting within modern
    OpenGL.'
  prefs: []
  type: TYPE_NORMAL
- en: Lighting up objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll be looking at basics of lighting because so far, if you
    look at the results from our previous section, which just discussed colors, what
    we've got is the cube and the light source. At the moment, the entire color in
    the cube output just looks uniform. It almost doesn't look like a cube, a six-sided
    shape figure, and the lighting doesn't look very realistic too. Because realistically,
    in our example, the light source doesn't emit light onto our cube and there is
    no effect of light and shadow on the cube. So, in this section we'll discuss the
    basics of lighting and effect on the cube. We'll focus on improving the lighting
    system so we can have a more realistic effect.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get started. As usual, we'll begin making modifications to our shader
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following steps to understand the changes made to the shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: We're not going to be changing anything in the lamp shader files because we're
    happy with the actual light that's being emitted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, what you want to do is go to your lighting vertex shader and, essentially,
    change the way our cube perceives the light, and that will make the object look
    different. So, if you go to our lighting vertex shader, this doesn''t require
    many changes. Take a look at the following highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What are normals ?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, let''s first understand what normals are. So, normals are basically a direction.
    They''re perpendicular to a particular surface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d405d0c-d251-4523-a882-b91bc7c8613e.png)'
  prefs: []
  type: TYPE_IMG
- en: So, as you can see in the preceding diagram, the normals are at 90 degrees to
    the surface, and this is useful when calculating lighting because it determines
    the way light bounces off the surface, the way the surface reacts to light, and
    as a result, it looks a certain way. A powerful technique is to change the direction
    of the normals, which you can do (we'll be covering that in later sections) and
    that allows you to change the way that the light reacts to it, which makes the
    object look different. And what we can even do is have, let's say, a flat object,
    or a relatively flat object with a very low polygon count and by changing the
    normals, we can add the illusion of depth to it. That's the reason why when you
    play a game sometimes and you see some sort of object, especially when it's on
    a wall, it's relatively flat, but it looks like it has a bit of depth to it. If
    you're quite far away from it, it looks like it's got depth. When you go close,
    and especially when you look at it from an angle, it doesn't have depth anymore,
    or it has very little depth. And that's the limitation of this system. Obviously,
    if you want to get around that, you need to use some sort of tessellation technique
    that actually has real geometry. That's obviously a lot more expensive in terms
    of processing power. This is a lot cheaper in terms of processing power, so this
    is really preferred in the gaming industry, simply because you're not just drawing
    one sort of simple shape. You're drawing a whole heap of polygons, which this
    technique will allow you to reserve some processing power.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the lighting.frag shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow the below mentioned steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'So now that we''ve done this, we go to the lighting fragment shader and make
    the following highlighted changes to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we added `FragPos`, as those are going to be the fragment
    positions that we were sending out from the vertex shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we created uniform vector variables as follow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we added `lightPos` as we needed a vector for the light
    position because we are factoring the light position and the lighting will vary
    depending on what part of the surface you're looking at.
  prefs: []
  type: TYPE_NORMAL
- en: And in our main function there are three types of lighting techniques that we'll
    be using as shading techniques, and they will be ambient, diffuse, and specular.
    We'll discuss them in detail and also understand how to define them in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Ambient lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first one, which is ambient lighting, is just like the general lighting
    that's in a scene. It's not like the light from the sun, but it's general light
    that is always bouncing around the room. It doesn't have a particular origin or
    a position or direction. So that allows it to provide some basic sort of color,
    some basic property to your object. On top of that, you add diffuse lighting and
    specular lighting to make the object a unique and interesting object to make it
    look more like what it would in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin by adding `float ambientStrength`, and to that we will add value
    of `0.1f`. Feel free to change that value and see what happens, see the limitations
    of the variables as well. And then we''re going to add `vec3` for the ambient
    lighting. That variable is going to equal to `ambientStrength * lightColor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Diffuse lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we''re going to do diffuse lighting. Diffuse lighting takes into account
    the direction and the normal of the light. For example, imagine our cube, the
    corner which is nearer to the light source will be brighter compared to the corner
    that is furthest away. Essentially, what is diffuse lighting? It adjusts the actual
    position and the angle as well. It''s to do with the angle as well, so if you
    were to have a light source at 90 degrees, that would emit more light than, let''s
    say, one at 5 degrees, and 90 degrees would be shinier. That''s essentially what
    diffuse is. You don''t generally just have ambient, diffuse, or specular lighting.
    You have all three combined, at different intensities and different strengths,
    and that allows you to create a realistic effect called combined lighting, and
    this effect is very often known as Phong shading. You can read about it on the
    internet. Take a look at the following code for diffuse light:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we added `lightPos - FragPos`. The difference between
    these will tell you the direction in which the light is pointing. At the end of
    code we're always going to be factoring in the `lightColor` because at the end
    of the day, if we have a white light shining on something, we don't want it to
    be blue or red. It has to be what the light is. Obviously, it will vary depending
    on the actual material that is applied and the sort of properties of that object,
    but the actual light itself should be a light color.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've done diffuse lighting, we can go on to specular lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Specular lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To talk about specular lighting, imagine a snooker ball or a pool ball, for
    example, which has a little circle of light shining on it, it''s always that little
    shiny light on an object. Let''s take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now that we're done updating the shader files, we need to make a minor change
    in our `Camera.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: Minor change in Camera.h
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `Camera.h` file, we don''t have any sort of method to get the position
    of the camera. So, what we''ll do is, below `glfloat GetZoom()`, we''ll add the
    `glm::vec3 GetPosition ()` method and its simply going to return the position.
    Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Making changes to the main code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we just need to go to our `main.cpp` file and make modifications to our
    code. Take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In there, the first thing that we need to modify is this vertices array. At
    the moment, we have x, y, and z values for each of the vertices, and what we also
    need to include is the normal. You can refer to the updated vertices in the `main.cpp`
    file present in the `Basic Lighting` folder. For reference, just take a look at
    the vertices of one side of cube:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The three extra values that we have got in the preceding array are the direction
    of the normals. The normals will stay the same for every single face.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra task: Try figuring out which face each one of these normals applies to,
    and what is the direction once you''ve rendered it. Modify them, see what happens.
    Change some of these values, but keep some of them the same. See what happens.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve got all of that sorted, we just need to change a few things where
    we have defined our `VBO` and `boxVAO`. Wherever we have mentioned `boxVAO` we''ll
    replace it with `containerVAO`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the position attribute we will make the following highlighted changes, and
    similarly, we''ll also create our normal attribute. Take a look at the following
    highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As we've got six different pieces of value on each row of the vertices array,
    which is the reason why we updated 6 in our code. You will updated the similar
    value of `6` in the `lightVAO` position attribute too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where we are defining our lighting shader in the code, we''re using the object
    color location and the light color location. Now, what we also need to do is add
    the lighting position location and assign that to our shader program, and also
    add the view position location. So, what we''re going to do is duplicate the whole
    `GLint lightColorLoc` code twice and make the following updates to add the light
    position location and the view position location. We need to do a similar thing
    for `gluniform3f();` too. Take a look at the following highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Once we have got all of this updated, we'll leave rest of the code as it. As
    we don't have to make any modifications to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should actually be ready to run the code, but remember what it looked like
    in the previous section. The output that you got on your screen should look some
    what similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eda92d9c-4f80-46b6-bf1d-34621f6429c9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you may have noticed in the preceding image, the top-left side, by the top-left
    corner, looks a little brighter than the bottom left, and that''s because that''s
    where the light source is. And it''s definitely evident on the other sides of
    the cube and on the top. Just take a look at the top compared to other sides.
    Those sides are darker as they have hardly any light on their surfaces. You can
    check that out in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f22e1fe-fc8f-4de7-8686-f660c811c153.png)'
  prefs: []
  type: TYPE_IMG
- en: It's just, it's a lot more realistic than it was before. You'll also notice
    as you move across it, you will get to see the beautiful dynamic shading on our
    cube.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what we''re going to do now is go to the lighting fragment shader and change
    the `specularStrength` to `2.0f`. Just modify this stuff up, and just observe
    the output that will have, take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97f65da2-3a9e-497b-831a-e3425a5c72ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can already see the sort of impact that change of value in the code had
    on the intensity of light. Look at that shine. That''s the sort of shine that
    you get on a pool ball. Try experimenting with the value. If you change the value
    of `ambientStrength` to `0.5f` you''ll see a brighter cube:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/277ac086-96de-454a-9f26-3d2003c91835.png)'
  prefs: []
  type: TYPE_IMG
- en: This is almost looking more like a uniform color now, but it looks quite cool
    as well. Try experimenting by changing the values in your shader files and the
    main code.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing that we''ll try doing is to move the light position so you can
    actually sort of see what effect it has on our object. So, in our main code, at
    the start of while loop, we''ll add `lightPos.x -= 0.01f`, and we''re going to
    do the same for the z position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re not going to modify the y position because we sort of only want the
    light source to move along the horizon. You could make it move along the y axis
    as well; we recommend you do that. Try and make a circle around it. Save the changes
    and run the code. You''ll observe the following output on your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebea6b88-3895-4fbb-a98d-d842141e63f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we''ve got a light and as it''s getting further away, the top
    side is getting dark because it''s at a really obscure angle. As it''s getting
    further and further away, you will observe that the top side gets darker and darker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95c803f5-cbf7-4e45-acc2-1c05c3425228.png)'
  prefs: []
  type: TYPE_IMG
- en: As an extra task, we recommend trying to move the light as far as you can and
    observe the effect. It would be fantastic if you could get it to rotate around
    the object itself and try adding multiple lights. That will create an awesome
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: Materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to discuss materials in this section. So, let's first understand
    what a material is and why would you use it. In the real world, you have objects
    that are made out of different materials. You have objects that are made out of
    metals, wood, plastic, and other stuff. As a result, these materials, these objects,
    react differently to light depending on what they're made out of. Generally speaking,
    something that's made out of metal will be shinier than something that's made
    out of wood. Wood generally isn't shiny. Obviously, it is if you apply some sort
    of varnish to it, but again, that would be an additional layer to the object that's
    not wood. It'd be something more than wood that is applied on top of it that provides
    some sort of shine to it. You have glossy materials, and you have some more matte
    materials. Simply put, materials in OpenGL will allow us to create objects that
    react differently to light, and as a result, create more realistic and varied
    effects in our game or application. And that's why you would use it, to get a
    more varied and realistic representation of the objects you are trying to create.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get started...
  prefs: []
  type: TYPE_NORMAL
- en: As few prerequisites. This section is using the source code from the previous
    section, which was covering basic lighting. If you haven't got the code for that,
    feel free to check out the GitHub link in the preface for the code files. The
    other thing we want to mention is that these chapters are based on the work of
    learnopengl.com and open.gl. They're using a fantastic illustrations to explain
    what we're doing. Also, feel free to check out their pages because they've got
    some great information. They go into really great depth into the code that we
    have discussed in all the chapters. So, it's just a great way of enhancing the
    knowledge you already know.
  prefs: []
  type: TYPE_NORMAL
- en: What we're going to do in this section is make the cube cycle through various
    different materials. We'll begin by updating the shader files.
  prefs: []
  type: TYPE_NORMAL
- en: Updating shader files for Materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a look at the following steps
  prefs: []
  type: TYPE_NORMAL
- en: We won't make any changes to the vertex shader, that is, `lighting.vs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we''ll move onto the lighting fragment shader and in here, right at the
    top, we''re going to create a data type `struct` called `Material`. In there,
    we''re going to have three varibles `vec3`, which are going to be the `ambient`,
    the `diffuse`, the `specular`, and the `shininess` float, so we can easily change
    the intensity of the specular light. Take a look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''re going to create a datatype struct for Light. This is going to
    have a `vec3` of position and it''s going to have three more `vec3` for ambient,
    diffuse, and specular:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you want to know a bit more about what ambient, diffuse, and specular are,
    feel free to check out the previous the sections. Or, feel free to go to learnopengl.com
    and open.gl. These sites provide a lot of information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we''ll get rid of the `lightPos` because we have it within the preceding
    struct. We don''t want `objectColor`, and also we don''t want `lightColor` as
    well, because again, we''ve got it all within our struct. Then we''ll add `uniform
    Material material` and we also add `uniform Light light`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: And now, in `void main()`, what are we going to do ? For the ambient light,
    we'll get rid of the `ambientStrength` and we'll modify it as `Vec3 ambient =
    light.ambient * material.ambient`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And for the diffuse light, `vec3 lightDir`, we need to change that up a bit.
    Take a look at the highlighted terms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: And for the final diffuse calculation, all we need to do is change it up slightly.
    We need to add `light.diffuse` multiplied by `diff`, which was calculated here
    in the float variable, and `diff` multiplied by `material.diffuse`. We are factoring
    in material in every single part of our lighting, our shading, simply because
    that's what's important. That's the way that our actual object will look, or that
    part of the object, because we have different materials applied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In specular, we can get rid of `specularStrength` because we''ve got that in
    the previous code. Then we''ll update `float spec` for the shininess; we''ll add
    `material.shininess`. For `vec3 specular`, we are changing that up slightly. We''re
    going to add `light.specular * (spec * material.specular)`. And for the result,
    we''ll modify that as highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Save these changes, and now we are done updating the fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: Making changes to the main code to add materials to our object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the below mentioned steps to add materials to our object and observe
    the effects of light on it:'
  prefs: []
  type: TYPE_NORMAL
- en: If you go to `main.cpp`, what you want to do is actually go straight to the
    while loop, because everything outside of that should is fine and doesn't need
    any modification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, in lines of code below `lightingShader.Use();`, we'll get rid of `objectColorLoc`
    and `lightColorLoc`. We want `lightPosLoc`, but a parameter in it needs to be
    changed to `light.position` because we've updated that in our fragment shader.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `gluniform3f` you can get rid of `objectColorLoc` and `lightColorLoc`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we need to also set the light''s properties. For that, we''ll add `glm::vec3
    lightColor;` and we''ll add `lightColor.r = sin();`, and for `sin()`, this is
    where we''re going to have some framework-specific code. We''re just going to
    be pass `glfwGetTime()`, which just gets the amount of time that has passed since
    GLFW was initialized. We''ll just multiply `glfwGetTime()` by `2.0f`. We''ll duplicate
    this line of code, paste it below, and make the following highlighted modification
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: So now that we've set the light's properties, we need to actually do the diffuse
    color and the ambient color. So, we're going to add `glm::vec3 diffuseColor =
    lightColor * glm::vec3();`. And for `ver3()`, we're just going to provide a value
    of `0.5f`. This is just going to decrease the influence of the diffuse color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we're going to add `glm::vec3 ambientColor = diffuseColor * glm::vec3();`
    and over here, `vec3` is going to be `0.2f`, as this is just a low-intensity one.
    So try some experimenting by modifying these values and see what you come up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, what we need to add is `glUniform3f()` function and to that, we'll pass
    `glGetUniformLocation()` function and for this function now we're going to specify
    `lightingShader.Program` and `"light.ambient"`. Then we're going to pass `ambientColor.r`
    and similarly, we'll pass `ambientColor.g` and `ambientColor.b`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, what we''ll do is just duplicate the previously described code and make
    the following highlighted changes to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now we're going to set the material properties, and to do that, we're going
    to do the ambient, the diffuse, the specular, and the shininess of the material.
    So, you want to add `glUniform3f();` and to that, we'll pass `glGetUniformLocation()`,
    and to this function, we'll specify `lightingShader.Program` and the selected
    `material.ambient`. Then we'll pass some values. We're going to just put some
    explicit values as `1.0f`, `0.5f`, and `0.31f`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just copy and paste the previous code several times and make the following
    modifications as highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, while defining shininess we have added just 1 float value
    in `glUniform1f()` because the shininess wasn't a vector or an array, or anything
    like that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are all set with the code. So let''s run this code and check the output
    that we get on our screen. You might get a similar output on your window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79a6f756-ddd5-49dd-8106-7c41159bf02c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You''ll observe a color changing cube on your screen. It looks exactly the
    way we want, just beautiful. Try moving the light and observe the shadow effect
    on the surface of the cube:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/857c756f-b5d4-4227-b71b-9928afee774b.png)'
  prefs: []
  type: TYPE_IMG
- en: So that it's for using materials in OpenGL to add effects to our object.
  prefs: []
  type: TYPE_NORMAL
- en: Lightmaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s discuss lightmaps in this section. But first, let''s try to understand
    what a lighting map is. Well, in the real world, if you have, let''s say, a crate
    that is partly metal and partly wood, similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95dea043-fbfc-4160-a359-6d21283a2528.png)'
  prefs: []
  type: TYPE_IMG
- en: The wooden parts of it will react differently to the light compared to the metal
    parts. It might sound obvious, but OpenGL (or any other sort of 3D graphics API)
    doesn't have a concept of wood or metal or plastic, or anything else and as a
    result, we need to program that in. We need to use other techniques to help illustrate
    that visually as the wood should be less shiny than the metal parts of the crate.
    If you search on lighting maps, you'll get a bunch of information. You can create
    them in various tools. You can use Maya or Photoshop to create them. So, without
    further ado, let's get down to the coding.
  prefs: []
  type: TYPE_NORMAL
- en: Making modifications to shader files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the below mentioned steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what you want to do is go to the lighting vertex shader. We need to make
    a few modifications to this because we removed the ability to apply textures,
    and we didn''t do that in the last couple of sections. So, we need to add that
    again. Take a look at the following modification to understand the changes made
    to the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Save these changes, and now we need to do a modification to the fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `lighting. frag`, we''ll make the following changes to the code: We''ll
    get rid of all the code from the struct material and add fresh code to it. We''ll
    add `sampler2D diffuse` and `sampler2D specular`, and this is that specular lightmap
    that had the light part and the dark part on it. Then we''ll add `float shininess`.
    Shininess is always important:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For the input, we also need the texture coordinate. So we''ll add `in vec2
    TexCoords`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now, `void main ()` in vec3 ambient needs to change slightly because we are
    using a texture. So, what we need to do is just get rid of `material.ambient`
    and add `vec3()` and inside that, we want to specify `texture()`. Inside this
    method, we're going to pass `material.diffuse` and `TexCoords`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, for the diffuse light in the final calculation, `(diff * material.diffuse)`
    needs to change slightly, as we are using textures now. So, what we''re going
    to do is just get rid of the preceding term and add `light.diffuse * diff * vec3()`.
    To that, we''ll pass `texture()`, and in that, we''ll specify `material.diffuse`
    and `TexCoords`. The rest all is good. Let''s go down to specular now. In the
    final step, we just need to change it in a similar way to the previous one because
    we are using a texture now. Take a look at the following code to understand the
    description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: So, we're all done with the shaders now. We can actually get to main.cpp.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to the main code to implement lightmaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow the below mentioned steps to implement the lightmaps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the main code, the first thing you'll need to change is the vertices, because
    at the moment we've got position and we've got the normals as well. We also need
    to specify the texture coordinates because we now are using a texture. You can
    refer to the updated vertices in the `main.cpp` file inside the `Lighting Maps`
    folder. Copy and paste the updated vertices to our main code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, go to the location where we''re binding the vertex and creating the vertex
    pointers. As we have added a texture system to our code, we need to modify the
    vertex pointer and the normal attribute slightly. As we''ve got eight pieces of
    information in our vertices array, we''ll replace the 6 with 8\. We also need
    to duplicate the Normal attribute code, paste it, and modify it for the texture
    attribute. Take a look at the following code to understand the modifications made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now let's take a look at the lighting array. In the position attribute, change
    the 6 to 8 for a similar reason as mentioned in the previous code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You don''t have to necessarily do this before we do the projection, but we
    are going to. We''re just going to load the textures before we define our projection
    matrix. We''re going to create the diffuse and the specular maps as well, since
    you just load in two different textures. We''ve covered this before. So, we''ll
    add `GLuint`, `diffuseMap`, and `specularMap`. Then we''re adding `glGenTextures();`.
    And to that, we''ll pass the parameters for the `size` as `1`, and for the `pointer`
    we''re going to add `&diffuseMap` and copy and paste this code to save some time.
    We''ll make the following changes to the copied code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to create an int for the texture width and height.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then we are going to add `unsigned char *image`. This is essentially going
    to be the data of our image, because if you ever try to open up an image in some
    sort of text editor, you just get a bunch of characters. This is essentially what
    this is going to be storing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: So, now we're going to add the diffuse map. We'll begin by adding `image = SOIL_LOAD_IMAGE();`.
    To this, first of all, we need to specify the file path of the image, which is
    `res/images/container2.png`. For the width and the height parameters, we just
    specify the `&textureWidth` and `&textureHeight` that we created before, because
    this is passing it in a reference, and it'll actually modify the original variable
    right here. For channels, put 0\. For `force_channels`, just put `SOIL_LOAD_RGB`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And in the next line, we need to add `glBindTexture();`. The parameter we'll
    pass for the target is just `GL_TEXTURE_2D` and for the texture, we just specify
    `diffuseMap`, because that's the one we're using at the moment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, on the next line we need to add `glTexImage2D();`. The parameter we'll
    pass for the target is just `GL_TEXTURE_2D`. For the level, put `0`. For the internal
    format, this is just `Gl_RGB` because it's got no alpha. For the width, you just
    put `textureWidth` then `textureHeight`. For the border, put `0`. For the format,
    put `GL_RGB`. For the type, we're going to put `GL_UNSIGNED_BYTE`. For the `pixels`,
    just specify the image data, which is `image`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we're just going to generate the mipmap, so add `glGenerateMipmap();`,
    and to that, we're going to pass `GL_TEXTURE_2D`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then add `SOIL_free_image_data()`. Here, we'll just specify the image that we
    want to free.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we just need to specify the texture parameters in terms of the wrapping
    and the filtering. So, we'll add `glTextParameteri();`. For this, we'll pass the
    target parameter as `GL_TEXTURE_2D`. For the `name`, for what we're modifying,
    it is the wrap for now, so pass `GL_TEXTURE_WRAP_S a` and then pass `GL_REPEAT`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s just duplicate this code and paste it below. Check out the following
    code to understand the modifications we need to make:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we''re done with defining the diffuse map. What we''re going to do
    next is actually just duplicate all this code for the specular map because it''ll
    be a lot easier and because a lot of it''s going to stay the same. Take look at
    the following highlighted terms to understand the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, at the end we unbound texture by defining`glBindTexture(
    GL_TEXTURE_2D, 0 );`.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, we just need to set the texture units for the lighting shader. So,
    we''re going to add `lightingShader.Use();`and on the next line we are going to
    add `glUniform1i`, and we''re going to specify `glGetUniformLocation lightingShader.Program`.
    And we just need to pass `material.diffuse` and `o` This is all stuff that we
    did in the shader, so feel free to look at that again if you just need a quick
    reminder. We''re all good now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Modifying while loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can actually start coding stuff within the while loop:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to set the light''s properties. So, what we''re going to do is
    just get rid of all of the `lightColor` code and we''re going to add `glUniform3f();`.
    To that, we''ll pass `glGetUniformLocation()`, and to this, we''ll specify `lightingShader.Program`
    and we just need to specify the first aspect that we''re modifying, which is `light.
    ambient`, and we''re just going to put some hardcoded values in here: `0.2f`,
    `0.2f`, and `0.2f`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s duplicate this so we''ve got three instances of it and make following
    modifications to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'So now, let''s set the material properties as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to actually activate our textures, and bind them. So below `glUniformMatrix4fv();`
    we''ll add following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can copy and paste this for the binding of the specular texture map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we are now ready to run it. You might observe the following output
    on your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81ddc49a-458e-435e-90ed-e656ad019ca9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Move around the cube; you will see that as we''re moving, the lighting affects
    the shape in a different way because when we were looking at it head on, there
    wasn''t much of a shine. There''s a bit towards the top right; that''s when we''re
    moving. It''s realistically affecting our object. As you move the light around
    you can see that only the metal part of it is shining:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/937b2fdf-d5c8-4934-8c62-653474d0363c.png)'
  prefs: []
  type: TYPE_IMG
- en: Obviously, it depends on what sort of angle you're looking at the object from,
    because that's how it is in real life. So, that's it for lighting maps.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned to apply colors to our objects and create a light
    source such as a lamp in our game world. We then looked at the effects of light
    on the materials. We also understood the different types of lighting techniques:
    ambient, diffused, specular lighting. We explored the various materials and observed
    the effects of light on the materials. We concluded by learning about lightmaps
    in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss about the different sources of light such
    as directional light, point light and spot light and how to combine those in our
    game world.
  prefs: []
  type: TYPE_NORMAL
