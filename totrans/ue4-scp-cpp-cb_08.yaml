- en: 'Communication Between Classes and Interfaces: Part II'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exposing UInterface methods to Blueprint from a native base class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing UInterface functions in Blueprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating C++ UInterface function implementations that can be overridden in Blueprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling Blueprint-defined interface functions from C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will show you ways in which you can use your C++ UInterfaces through
    Blueprints. This can be very helpful in letting designers access code that you've
    written without requiring them to dive into the C++ code of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml),
    *UE4 Development Tools*.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing UInterface methods to Blueprint from a native base class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to define `UInterface` methods in C++ is great, but they should be
    accessible from Blueprint too. Otherwise, designers or others who are using Blueprint
    won't be able to interact with your `UInterface`. This recipe shows you how to
    make a function from an interface callable within the Blueprint system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a `UInterface` called `PostBeginPlay`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7539c4d4-019e-4c79-87e9-1b34d814759e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open `PostBeginPlay.h` in Visual Studio and update the `UINTERFACE` of `UPostBeginPlay` and
    add the following `virtual` method in `IPostBeginPlay`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide an implementation of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Actor` class called `APostBeginPlayTest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c6f5e0ca-46ef-4aa6-8dfc-742573723f0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Modify the class declaration so that it also inherits `IPostBeginPlay`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile your project. Inside the editor, drag an instance of `APostBeginPlayTest` into
    your level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b3bef66c-220a-4c6a-aafe-cb29f2950e87.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the instance selected in the World Outliner, click on Blueprints | Open
    Level Blueprint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ad526052-f410-46fe-b6e9-99a44dc869d4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside the Level Blueprint, right-click and Create a Reference to PostBeginPlayTest1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5f52943e-720b-45de-b7ce-a9aa47bb3a46.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that you can also use the drag-and-drop method we discussed in the *Inheriting
    UInterfaces from one another* recipe from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag away from the blue pin on the right-hand side of your actor reference,
    then search the context menu for `onpost` to see your new interface function.
    Click on it to insert a call to your native `UInterface` implementation from Blueprint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0a4d5096-348e-4d01-9996-1c1b4738061a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, connect the execution pin (white arrow) from the `BeginPlay` node
    to the execution pin for `OnPostBeginPlay`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cd60e61c-cce6-4569-9985-af0696055fac.png)'
  prefs: []
  type: TYPE_IMG
- en: When you play your level, you should see the message PostBeginPlay called visible
    on screen for a short amount of time, verifying that Blueprint has successfully
    accessed and called through to your native code implementation of the `UInterface`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `UINTERFACE`/`IInterface` pair function like they do in other recipes, with
    the `UInterface` containing reflection information and other data and the `IInterface` functioning
    as the actual interface class that can be inherited from.
  prefs: []
  type: TYPE_NORMAL
- en: The most significant element that allows the function inside `IInterface` to
    be exposed to Blueprint is the `UFUNCTION` specifier. `BlueprintCallable` marks
    this function as one that can be called from the Blueprint system.
  prefs: []
  type: TYPE_NORMAL
- en: Any functions exposed to Blueprint in any way require a `Category` value. This `Category` value
    specifies the heading under which the function will be listed in the context menu.
  prefs: []
  type: TYPE_NORMAL
- en: The function must also be marked `virtual` – this is so that a class that implements
    the interface via native code can override the implementations of the functions
    inside it. Without the `virtual` specifier, the Unreal Header Tool will give you
    an error, indicating that you have to either add `virtual` or `BlueprintImplementableEvent` as
    a `UFUNCTION` specifier.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is that without either of those, the interface function
    wouldn't be overridable in C++ (due to the absence of `virtual`) or Blueprint
    (because `BlueprintImplementableEvent` was missing). An interface that can't be
    overridden, but only inherited, has limited utility, so Epic have chosen not to
    support it within UInterfaces.
  prefs: []
  type: TYPE_NORMAL
- en: We then provide a default implementation of the `OnPostBeginPlay` function,
    which uses the `GEngine` pointer to display a debug message, confirming that the
    function was invoked.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to [Chapter 8](bded5c5b-3038-4d12-b03d-39218257492b.xhtml), *Communication
    Between Classes and Interfaces: Part II**,* for a number of recipes that show
    you how you can integrate your C++ classes with Blueprint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing UInterface functions in Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key advantages of UInterface in Unreal is the ability for users to
    implement `UInterface` functions in the editor. This means that the interface
    can be implemented strictly in Blueprint without needing any C++ code, which is
    helpful to designers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `UInterface` called `AttackAvoider`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/91241cc3-1b98-40c3-8d23-054321e24a96.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following function declaration to the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile your project. From the Content Browser, open the Content folder and
    then create a new Blueprint Class within the Editor by selecting Add New | Blueprint
    Class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9cf44734-02d1-4ebb-87e0-f1aa7cbc45f5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Base the class on Actor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/be3e694c-bcd6-4215-b045-1c160d2f7596.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Name the blueprint `AvoiderBlueprint` and then double-click on it to open the
    Blueprint Editor. From there, open Class Settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7b83d5a4-c153-433a-826b-a72e0d29a0b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Under the Details tab, click on the drop-down menu that says Add for Implemented
    Interfaces, and select AttackAvoider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5019f64b-074e-4432-b9f3-f48a1b693772.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Compile your Blueprint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8b5c7a09-df49-4876-af79-e9c5ff4b4c9f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the Event Graph by clicking on the Event Graph tab and then right-click
    within the graph and type `event attack`. Within the Context Sensitive menu, you
    should see Event Attack Incoming. Select it to place an event node in your graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b80d7c45-4c16-4648-b626-9e234aff316f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Drag this out from the execution pin on the new node and release. Type `print
    string` into the Context Sensitive menu to add a Print String node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6e86e174-4833-4ccc-aab1-d344fdb4f6c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Selecting the Print String node
  prefs: []
  type: TYPE_NORMAL
- en: You have now implemented a `UInterface` function within Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the event in action, drag the pin to the right of the Event BeginPlay event
    and call an Attack Incoming event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2a10d7b5-eb26-4f02-970a-af9a5d675ec0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Drag and drop an instance of your Blueprint class into the level and play the
    game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8621e029-18b4-4ca3-a875-bccd083bc7d9.png)'
  prefs: []
  type: TYPE_IMG
- en: If all went well, you should see the default message from Print String, or whatever
    you posted to happen when the event should happen!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `UINTERFACE`/`IInterface` are created in exactly the same way that we saw
    in the other recipes in this chapter. When we add a function to the interface,
    however, we use a new `UFUNCTION` specifier, `BlueprintImplementableEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: '`BlueprintImplementableEvent` tells the Unreal Header Tool to generate code
    that creates an empty stub function that can be implemented by Blueprint. We do
    not need to provide a default C++ implementation for the function.'
  prefs: []
  type: TYPE_NORMAL
- en: We implement the interface inside Blueprint, which exposes the function for
    us in a way that allows us to define its implementation in Blueprint. The autogenerated
    code that's created by the header tool forwards the calls to the `UInterface` function
    to our Blueprint implementation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Overriding C++ UInterface functions through Blueprints* recipe shows you
    how to define a default implementation for your `UInterface` function in C++,
    then optionally override it in Blueprint if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding C++ UInterface functions through Blueprints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like the previous recipe, UInterfaces are useful, but that utility is severely
    limited without their functionality being usable by designers.
  prefs: []
  type: TYPE_NORMAL
- en: The previous recipe, *Exposing UInterface methods to Blueprints from a native
    base class*, showed you how to call C++ `UInterface` functions from Blueprint;
    this recipe will show you how to replace the implementation of a `UInterface` function
    with your own custom Blueprint-only function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new interface called `Wearable` ( Creating both `IWearable` &  `UWearable`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5c357868-84cf-4094-9a7a-f75ac5064c56.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following functions to the header of the `IWearable` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: UE 4.20 and above does not allow us to create a default implementation for a
    function if it is defined in an interface class, so we will have to use UE's default
    empty implementation, which gives us the default value as a return for each function.
    This is because, in C# and other languages that have interfaces, they are not
    supposed to have a default implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `Actor` class called `Boots` inside the editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/db097867-0667-461f-ac7a-17516d5381dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add `#include "Wearable.h"` to the header file for `Boots` and modify the class
    declaration, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following implementation of the pure `virtual` functions that were
    created by our Interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you do not know how to do the following two steps, check out the previous
    recipe, *Implementing UInterface functions in Blueprint*.
  prefs: []
  type: TYPE_NORMAL
- en: Compile your script so that we will have access to the new functions we have
    created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Blueprint class called `Gloves` based on `Actor` by going to the
    Content Browser, opening the `Content` folder, and then right clicking and then
    selecting Blueprint Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Class Settings menu, under the Details tab, scroll down to the Implemented
    Interfaces property and click on the Add button and select `Wearable` as the interface
    that the `Gloves` actor will implement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6e0652ae-bd66-450b-9bc7-859d6ff1eae0.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding the Wearable interface
  prefs: []
  type: TYPE_NORMAL
- en: Afterwards, hit the Compile button in order to apply the change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the Event Graph and right-click it to create a new event. From the search
    bar, type in `on equip`, and you should see our event under the Add Event section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c02f936d-d293-45b9-97f2-60b24aa5a932.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This allows us to override the `OnEquip` function from the default implementation
    to do whatever we want. For instance, add a Print String node with the In String being
    set to `Gloves being worn`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aa9216fb-a775-41b3-854f-0bfdfdc6f958.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the Compile button and then you can close the Blueprint. Drag a copy
    of both `Gloves` and `Boots` into your level for testing purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once added, add the following blueprint code to your level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7e5b7e41-6f9a-4a02-9065-c8fa4ed3e74f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Verify that `Boots` performs the default behavior, but that `Gloves` performs
    the blueprint-defined behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/95bdce70-174c-418e-98fe-88231ed6b461.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe uses two `UFUNCTION` specifiers together: `BlueprintNativeEvent` and `BlueprintCallable`. `BlueprintCallable` has
    been shown in previous recipes, and is a way of marking your `UFUNCTION` as visible
    and invokable in the Blueprint Editor.
  prefs: []
  type: TYPE_NORMAL
- en: '`BlueprintNativeEvent` signifies a `UFUNCTION` that has a default C++ (native
    code) implementation, but is also overridable in Blueprint. It''s a combination
    of a virtual function, along with `BlueprintImplementableEvent`.'
  prefs: []
  type: TYPE_NORMAL
- en: For this mechanism to work, the Unreal Header Tool generates the body of your
    functions so that the Blueprint version of the function is called if it exists;
    otherwise, it dispatches the method call through to the native implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The `Boots` class implements `IWearable`, overriding the default functionality. In
    contrast, `Gloves` also implements `IWearable`, but has an overridden implementation
    for `OnEquip` defined in Blueprint. This can be verified when we use Level Blueprints to
    call `OnEquip` for the two actors.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Blueprint-defined interface functions from C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the previous recipes have focused on C++ being usable in Blueprint, such
    as being able to call functions from C++ in Blueprint, and override C++ functions
    with Blueprint, this recipe shows you the reverse: calling a Blueprint-defined
    interface function from C++.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `UInterface` called `Talker`  (Creating the `UTalker`/`ITalker` classes):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/246f7357-2422-4d79-a871-d740fc5f04bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following `UFUNCTION` implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new C++ class based on `StaticMeshActor`. Remember to check Show All
    Classes and find the class that way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d78ffdd9-291d-4c5e-900b-4afe7bb3b150.png).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking Next, name this new class `TalkingMesh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/89e67a4a-0978-4258-ba9c-0ef649ac5c8f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add `#include` and modify the class declaration to include the talker interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add the following functions to the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the implementation, add the following to `TalkingMesh.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new class based on `DefaultPawn` to function as our player character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7c9e20bd-ff72-4add-b845-251e8019f6d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you select Next, give the class a Name of `TalkingPawn` and select Create
    Class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/459b2a04-31ce-4d3b-8655-29fc0370b550.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following to our class header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'From the `TalkingPawn.cpp` file, make sure to include the following so that
    we have access to the `ITalker` and `UTalker` classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterwards implement the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `OnTalkOverlap`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile your scripts. Create a new `GameMode` and set `TalkingPawn` as the
    default pawn class for the player. The quickest way to do this is to go to Settings
    | World Settings and then, under GameMode Override, click on the + button. From
    there, expand the Selected GameMode option and under Default Pawn Class, select `TalkingPawn`.
    Refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6aca0461-7c62-4d54-bf82-4b8e96c8b0c9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Drag an instance of your `ATalkingMesh` class into the level. If you play the
    game now, you should be able to walk close to the mesh and see it display a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4b6e90fc-40da-46b1-b6b9-98cbbf90fba9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new Blueprint class based on `ATalkingMesh` by right-clicking on it
    from the Content Browser and selecting the appropriate option from the context
    menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fa84dd2a-1452-4c4c-a716-b9a32a62d245.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Name it `MyTalkingMesh` and select Create Blueprint Class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d4c82f32-2f65-4bb6-9c3f-29d9235c2bb6.png)'
  prefs: []
  type: TYPE_IMG
- en: Inside the Blueprint Editor, create an implementation for `StartTalking`. We
    can do this by going to the Event Graph and right-clicking within the graph. Then,
    in the search bar, we can type in `start talking`. Under Add Event, select the Event
    Start Talking option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/10bf1f2e-cf6a-4c8f-8247-a3b2472aed4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you would like to call the parent version of the event, you can right-click
    on the event node and select the Add call to parent function option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/45898ae1-509a-492e-b45b-9f3771054836.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Afterward, you can connect the events together. To do something different from
    the original, create a Print String node and display a new In String message,
    such as `I''m the overridden implementation in Blueprint`. The final version of
    the example will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e67f1e3d-201a-4a7a-ae37-b61e8c2558ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Compile your Blueprint. Afterwards, drag a copy of your new Blueprint into the
    level beside your `ATalkingMesh` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Walk up to the two actors and verify that your custom `Pawn` is correctly invoking
    either the default C++ implementation or the Blueprint implementation, as appropriate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ccd4ed7e-9285-4a9f-907d-8a2c011b9402.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As always, we create a new interface, and then add some function definitions
    to the `IInterface` class. We use the `BlueprintNativeEvent` specifier to indicate
    that we want to declare a default implementation in C++ that can then be overridden
    in Blueprint. We create a new class (inheriting from `StaticMeshActor` for convenience)
    and implement the interface on it.
  prefs: []
  type: TYPE_NORMAL
- en: In the implementation of the new class constructor, we load a static mesh and
    set our collision as usual. We then add an implementation for our interface function,
    which simply prints a message to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: If you were using this in a full-blown project, you could play animations, play
    audio, alter the user interface, and whatever else was necessary to start a conversation
    with your `Talker`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, though, we don't have anything to actually call `StartTalking` on
    our `Talker`. The simplest way to implement this is to create a new `Pawn` subclass
    (again, inheriting from `DefaultPawn` for convenience) that can start talking
    to any `Talker` actors that it collides with.
  prefs: []
  type: TYPE_NORMAL
- en: For this to work, we create a new `BoxComponent` to establish the radius at
    which we will trigger a conversation. As always, it is a `UPROPERTY`, so it won't
    get garbage collected. We also create the definition for a function that will
    get triggered when the new `BoxComponent` overlaps another `Actor` in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor for our `TalkingPawn` initializes the new `BoxComponent`, and
    sets its extents appropriately. The constructor also binds the `OnTalkOverlap` function
    as an event handler to handle collisions with our `BoxComponent`. It also attaches
    the box component to our `RootComponent` so that it moves with the rest of the
    player character as the player moves around the level.
  prefs: []
  type: TYPE_NORMAL
- en: Inside `OnTalkOverlap`, we need to check if the other actor, which is overlapping
    our box, implements the `Talker` interface. The most reliable way to do this is
    with the `ImplementsInterface` function in `UClass`. This function uses the class
    information that's generated by the Unreal Header Tool during compilation, and
    correctly handles both C++ and Blueprint-implemented interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: If the function returns `true`, we can use a special autogenerated function
    contained in our `IInterface` to invoke the interface method of our choice on
    our instance. This is a static method of the form `<IInterface>::Execute_<FunctionName>`.
    In our instance, our `IInterface` is `ITalker`, and the function is `StartTalking`,
    so the function we want to invoke is `ITalker::Execute_StartTalking()`.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we need this function is that, when an interface is implemented in
    Blueprint, the relationship isn't actually established at compile time. C++ is,
    therefore, not aware of the fact that the interface is implemented, and so we
    can't cast the Blueprint class to `IInterface` to call functions directly.
  prefs: []
  type: TYPE_NORMAL
- en: The `Execute_` functions take a pointer to the object that implements the interface
    and call a number of internal methods to invoke the desired function's Blueprint
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: When you play the level and walk around, the custom `Pawn` is constantly receiving
    notifications when its `BoxComponent` overlaps other objects. If they implement
    the `UTalker`/`ITalker` interface, the pawn then tries to invoke `StartTalking` on
    the `Actor` instance in question, which then prints the appropriate message on
    screen.
  prefs: []
  type: TYPE_NORMAL
