- en: 'Communication Between Classes and Interfaces: Part II'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和接口之间的通信：第二部分
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下菜谱：
- en: Exposing UInterface methods to Blueprint from a native base class
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本地基类将 UInterface 方法暴露给蓝图
- en: Implementing UInterface functions in Blueprint
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在蓝图中实现 UInterface 函数
- en: Creating C++ UInterface function implementations that can be overridden in Blueprint
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 C++ UInterface 函数实现，这些实现可以在蓝图中被覆盖
- en: Calling Blueprint-defined interface functions from C++
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 C++ 调用蓝图定义的接口函数
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter will show you ways in which you can use your C++ UInterfaces through
    Blueprints. This can be very helpful in letting designers access code that you've
    written without requiring them to dive into the C++ code of the project.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示如何通过蓝图使用您的 C++ UInterfaces。这可以帮助设计师访问您编写的代码，而无需他们深入研究项目的 C++ 代码。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml),
    *UE4 Development Tools*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要使用 Unreal Engine 4，并使用 Visual Studio 2017 作为 IDE。有关如何安装这两款软件及其要求的信息，请参阅
    [第 1 章](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml)，*UE4 开发工具*。
- en: Exposing UInterface methods to Blueprint from a native base class
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从本地基类将 UInterface 方法暴露给蓝图
- en: Being able to define `UInterface` methods in C++ is great, but they should be
    accessible from Blueprint too. Otherwise, designers or others who are using Blueprint
    won't be able to interact with your `UInterface`. This recipe shows you how to
    make a function from an interface callable within the Blueprint system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在 C++ 中定义 `UInterface` 方法很棒，但它们也应该可以从蓝图访问。否则，使用蓝图的设计师或其他人员将无法与您的 `UInterface`
    交互。这个菜谱向您展示了如何在蓝图系统中调用接口中的函数。
- en: How to do it...
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a `UInterface` called `PostBeginPlay`:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PostBeginPlay` 的 `UInterface`：
- en: '![](img/7539c4d4-019e-4c79-87e9-1b34d814759e.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7539c4d4-019e-4c79-87e9-1b34d814759e.png)'
- en: 'Open `PostBeginPlay.h` in Visual Studio and update the `UINTERFACE` of `UPostBeginPlay` and
    add the following `virtual` method in `IPostBeginPlay`:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中打开 `PostBeginPlay.h` 并更新 `UPostBeginPlay` 的 `UINTERFACE`，然后在
    `IPostBeginPlay` 中添加以下 `virtual` 方法：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Provide an implementation of the function:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供函数的实现：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a new `Actor` class called `APostBeginPlayTest`:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的名为 `APostBeginPlayTest` 的 `Actor` 类：
- en: '![](img/c6f5e0ca-46ef-4aa6-8dfc-742573723f0a.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c6f5e0ca-46ef-4aa6-8dfc-742573723f0a.png)'
- en: 'Modify the class declaration so that it also inherits `IPostBeginPlay`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改类声明，使其也继承 `IPostBeginPlay`：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Compile your project. Inside the editor, drag an instance of `APostBeginPlayTest` into
    your level:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的项目。在编辑器中，将 `APostBeginPlayTest` 的实例拖放到您的关卡中：
- en: '![](img/b3bef66c-220a-4c6a-aafe-cb29f2950e87.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b3bef66c-220a-4c6a-aafe-cb29f2950e87.png)'
- en: 'With the instance selected in the World Outliner, click on Blueprints | Open
    Level Blueprint:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在世界大纲中选中实例后，点击蓝prints | 打开关卡蓝图：
- en: '![](img/ad526052-f410-46fe-b6e9-99a44dc869d4.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad526052-f410-46fe-b6e9-99a44dc869d4.jpg)'
- en: 'Inside the Level Blueprint, right-click and Create a Reference to PostBeginPlayTest1:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关卡蓝图中，右键单击并创建对 PostBeginPlayTest1 的引用：
- en: '![](img/5f52943e-720b-45de-b7ce-a9aa47bb3a46.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5f52943e-720b-45de-b7ce-a9aa47bb3a46.png)'
- en: Note that you can also use the drag-and-drop method we discussed in the *Inheriting
    UInterfaces from one another* recipe from the previous chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您还可以使用我们在上一章的 *从彼此继承 UInterfaces* 菜单中讨论的拖放方法。
- en: 'Drag away from the blue pin on the right-hand side of your actor reference,
    then search the context menu for `onpost` to see your new interface function.
    Click on it to insert a call to your native `UInterface` implementation from Blueprint:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您演员引用的右侧蓝色推针拖动，然后在上下文菜单中搜索 `onpost` 以查看您的新接口函数。点击它以从蓝图插入对本地 `UInterface` 实现的调用：
- en: '![](img/0a4d5096-348e-4d01-9996-1c1b4738061a.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a4d5096-348e-4d01-9996-1c1b4738061a.png)'
- en: 'Finally, connect the execution pin (white arrow) from the `BeginPlay` node
    to the execution pin for `OnPostBeginPlay`:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 `BeginPlay` 节点的执行引脚（白色箭头）连接到 `OnPostBeginPlay` 的执行引脚：
- en: '![](img/cd60e61c-cce6-4569-9985-af0696055fac.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd60e61c-cce6-4569-9985-af0696055fac.png)'
- en: When you play your level, you should see the message PostBeginPlay called visible
    on screen for a short amount of time, verifying that Blueprint has successfully
    accessed and called through to your native code implementation of the `UInterface`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你播放你的关卡时，你应该在屏幕上看到消息“PostBeginPlay called”短暂可见，这证实蓝图已成功访问并通过你的原生代码实现的`UInterface`调用。
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `UINTERFACE`/`IInterface` pair function like they do in other recipes, with
    the `UInterface` containing reflection information and other data and the `IInterface` functioning
    as the actual interface class that can be inherited from.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`UINTERFACE`/`IInterface`对函数就像在其他菜谱中做的那样，其中`UInterface`包含反射信息和其它数据，而`IInterface`则作为可以继承的实际接口类。'
- en: The most significant element that allows the function inside `IInterface` to
    be exposed to Blueprint is the `UFUNCTION` specifier. `BlueprintCallable` marks
    this function as one that can be called from the Blueprint system.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 允许`IInterface`内部的函数暴露给蓝图的最重要元素是`UFUNCTION`指定符。`BlueprintCallable`标记此函数为可以从蓝图系统中调用的函数。
- en: Any functions exposed to Blueprint in any way require a `Category` value. This `Category` value
    specifies the heading under which the function will be listed in the context menu.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 任何以任何方式暴露给蓝图的功能都需要一个`Category`值。此`Category`值指定了函数将在上下文菜单中列出的标题下。
- en: The function must also be marked `virtual` – this is so that a class that implements
    the interface via native code can override the implementations of the functions
    inside it. Without the `virtual` specifier, the Unreal Header Tool will give you
    an error, indicating that you have to either add `virtual` or `BlueprintImplementableEvent` as
    a `UFUNCTION` specifier.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 函数还必须标记为`virtual`——这是为了让通过原生代码实现接口的类可以覆盖其内部的函数实现。如果没有`virtual`指定符，Unreal头文件工具会给你一个错误，表明你必须将`virtual`或`BlueprintImplementableEvent`作为`UFUNCTION`指定符添加。
- en: The reason for this is that without either of those, the interface function
    wouldn't be overridable in C++ (due to the absence of `virtual`) or Blueprint
    (because `BlueprintImplementableEvent` was missing). An interface that can't be
    overridden, but only inherited, has limited utility, so Epic have chosen not to
    support it within UInterfaces.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是如果没有其中任何一个，接口函数在C++（由于缺少`virtual`）或蓝图（因为缺少`BlueprintImplementableEvent`）中都不会是可覆盖的。一个不能被覆盖而只能被继承的接口功能有限，因此Epic选择不在UInterfaces中支持它。
- en: We then provide a default implementation of the `OnPostBeginPlay` function,
    which uses the `GEngine` pointer to display a debug message, confirming that the
    function was invoked.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后提供了一个`OnPostBeginPlay`函数的默认实现，该实现使用`GEngine`指针显示一个调试消息，确认函数已被调用。
- en: See also
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to [Chapter 8](bded5c5b-3038-4d12-b03d-39218257492b.xhtml), *Communication
    Between Classes and Interfaces: Part II**,* for a number of recipes that show
    you how you can integrate your C++ classes with Blueprint'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第8章，*类与接口之间的通信：第二部分*，了解一些菜谱，这些菜谱展示了你如何将你的C++类与蓝图集成。
- en: Implementing UInterface functions in Blueprint
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在蓝图中实现UInterface函数
- en: One of the key advantages of UInterface in Unreal is the ability for users to
    implement `UInterface` functions in the editor. This means that the interface
    can be implemented strictly in Blueprint without needing any C++ code, which is
    helpful to designers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: UInterface在Unreal中的一个关键优势是用户可以在编辑器中实现`UInterface`函数。这意味着接口可以完全在蓝图中进行实现，而无需任何C++代码，这对设计师来说很有帮助。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new `UInterface` called `AttackAvoider`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`UInterface`，命名为`AttackAvoider`：
- en: '![](img/91241cc3-1b98-40c3-8d23-054321e24a96.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/91241cc3-1b98-40c3-8d23-054321e24a96.png)'
- en: 'Add the following function declaration to the header:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数声明添加到头文件中：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Compile your project. From the Content Browser, open the Content folder and
    then create a new Blueprint Class within the Editor by selecting Add New | Blueprint
    Class:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的项目。从内容浏览器中打开内容文件夹，然后在编辑器中选择添加新项目 | 蓝图类来创建一个新的蓝图类：
- en: '![](img/9cf44734-02d1-4ebb-87e0-f1aa7cbc45f5.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9cf44734-02d1-4ebb-87e0-f1aa7cbc45f5.jpg)'
- en: 'Base the class on Actor:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`Actor`为基础创建类：
- en: '![](img/be3e694c-bcd6-4215-b045-1c160d2f7596.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/be3e694c-bcd6-4215-b045-1c160d2f7596.png)'
- en: 'Name the blueprint `AvoiderBlueprint` and then double-click on it to open the
    Blueprint Editor. From there, open Class Settings:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将蓝图命名为`AvoiderBlueprint`，然后双击它以打开蓝图编辑器。从那里，打开类设置：
- en: '![](img/7b83d5a4-c153-433a-826b-a72e0d29a0b2.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7b83d5a4-c153-433a-826b-a72e0d29a0b2.png)'
- en: 'Under the Details tab, click on the drop-down menu that says Add for Implemented
    Interfaces, and select AttackAvoider:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在详细信息标签页下，点击“实现接口”旁边的下拉菜单，选择“AttackAvoider”：
- en: '![](img/5019f64b-074e-4432-b9f3-f48a1b693772.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5019f64b-074e-4432-b9f3-f48a1b693772.jpg)'
- en: 'Compile your Blueprint:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的蓝图：
- en: '![](img/8b5c7a09-df49-4876-af79-e9c5ff4b4c9f.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b5c7a09-df49-4876-af79-e9c5ff4b4c9f.jpg)'
- en: 'Open the Event Graph by clicking on the Event Graph tab and then right-click
    within the graph and type `event attack`. Within the Context Sensitive menu, you
    should see Event Attack Incoming. Select it to place an event node in your graph:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击事件图标签页并右键点击图中的任意位置，输入`event attack`。在上下文相关菜单中，你应该能看到“事件攻击进入”。选择它以在你的图中放置一个事件节点：
- en: '![](img/b80d7c45-4c16-4648-b626-9e234aff316f.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b80d7c45-4c16-4648-b626-9e234aff316f.jpg)'
- en: 'Drag this out from the execution pin on the new node and release. Type `print
    string` into the Context Sensitive menu to add a Print String node:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新节点的执行引脚上拖出，释放。在上下文相关菜单中输入`print string`以添加一个打印字符串节点：
- en: '![](img/6e86e174-4833-4ccc-aab1-d344fdb4f6c8.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e86e174-4833-4ccc-aab1-d344fdb4f6c8.png)'
- en: Selecting the Print String node
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“打印字符串”节点
- en: You have now implemented a `UInterface` function within Blueprint.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经在蓝图内部实现了一个`UInterface`函数。
- en: 'To see the event in action, drag the pin to the right of the Event BeginPlay event
    and call an Attack Incoming event:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要看到事件的实际效果，将事件开始播放事件右侧的引脚拖到右边，并调用一个攻击进入事件：
- en: '![](img/2a10d7b5-eb26-4f02-970a-af9a5d675ec0.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a10d7b5-eb26-4f02-970a-af9a5d675ec0.png)'
- en: 'Drag and drop an instance of your Blueprint class into the level and play the
    game:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的蓝图类的一个实例拖放到关卡中并玩游戏：
- en: '![](img/8621e029-18b4-4ca3-a875-bccd083bc7d9.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8621e029-18b4-4ca3-a875-bccd083bc7d9.png)'
- en: If all went well, you should see the default message from Print String, or whatever
    you posted to happen when the event should happen!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会看到来自“打印字符串”的默认消息，或者当事件应该发生时你发布的任何消息！
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `UINTERFACE`/`IInterface` are created in exactly the same way that we saw
    in the other recipes in this chapter. When we add a function to the interface,
    however, we use a new `UFUNCTION` specifier, `BlueprintImplementableEvent`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`UINTERFACE`/`IInterface`的创建方式与本章其他食谱中看到的方式完全相同。然而，当我们向接口添加函数时，我们使用一个新的`UFUNCTION`指定符，即`BlueprintImplementableEvent`。'
- en: '`BlueprintImplementableEvent` tells the Unreal Header Tool to generate code
    that creates an empty stub function that can be implemented by Blueprint. We do
    not need to provide a default C++ implementation for the function.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlueprintImplementableEvent`告诉Unreal头文件工具生成代码，创建一个空占位函数，该函数可以被蓝图实现。我们不需要为该函数提供默认的C++实现。'
- en: We implement the interface inside Blueprint, which exposes the function for
    us in a way that allows us to define its implementation in Blueprint. The autogenerated
    code that's created by the header tool forwards the calls to the `UInterface` function
    to our Blueprint implementation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在蓝图内部实现接口，这样它就能以允许我们在蓝图内定义其实现的方式暴露函数。由头文件工具自动生成的代码将调用转发到我们的蓝图实现。
- en: See also
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Overriding C++ UInterface functions through Blueprints* recipe shows you
    how to define a default implementation for your `UInterface` function in C++,
    then optionally override it in Blueprint if necessary.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: “通过蓝图覆盖C++ UInterface函数”食谱展示了如何为你的`UInterface`函数在C++中定义默认实现，然后根据需要可选地在蓝图中进行覆盖。
- en: Overriding C++ UInterface functions through Blueprints
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过蓝图覆盖C++ UInterface函数
- en: Just like the previous recipe, UInterfaces are useful, but that utility is severely
    limited without their functionality being usable by designers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的食谱一样，U接口很有用，但如果没有设计师可以使用其功能，这种实用性就严重受限。
- en: The previous recipe, *Exposing UInterface methods to Blueprints from a native
    base class*, showed you how to call C++ `UInterface` functions from Blueprint;
    this recipe will show you how to replace the implementation of a `UInterface` function
    with your own custom Blueprint-only function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的食谱“从本地基类中暴露UInterface方法到蓝图”展示了如何从蓝图调用C++ `UInterface`函数；这个食谱将展示如何用你自己的自定义蓝图专用函数替换`UInterface`函数的实现。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create a new interface called `Wearable` ( Creating both `IWearable` &  `UWearable`):'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Wearable`的新接口（创建`IWearable`和`UWearable`）：
- en: '![](img/5c357868-84cf-4094-9a7a-f75ac5064c56.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c357868-84cf-4094-9a7a-f75ac5064c56.png)'
- en: 'Add the following functions to the header of the `IWearable` class:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数添加到`IWearable`类的头部：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: UE 4.20 and above does not allow us to create a default implementation for a
    function if it is defined in an interface class, so we will have to use UE's default
    empty implementation, which gives us the default value as a return for each function.
    This is because, in C# and other languages that have interfaces, they are not
    supposed to have a default implementation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: UE 4.20及以上版本不允许我们在接口类中定义函数的默认实现，因此我们必须使用UE的默认空实现，这将为每个函数提供默认值作为返回值。这是因为，在C#和其他有接口的语言中，它们不应该有默认实现。
- en: 'Create a new `Actor` class called `Boots` inside the editor:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中创建一个新的`Actor`类，名为`Boots`：
- en: '![](img/db097867-0667-461f-ac7a-17516d5381dc.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db097867-0667-461f-ac7a-17516d5381dc.png)'
- en: 'Add `#include "Wearable.h"` to the header file for `Boots` and modify the class
    declaration, as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`#include "Wearable.h"`添加到`Boots`的头文件中，并修改类声明，如下所示：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following implementation of the pure `virtual` functions that were
    created by our Interface:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下由我们的接口创建的纯`virtual`函数的实现：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you do not know how to do the following two steps, check out the previous
    recipe, *Implementing UInterface functions in Blueprint*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道如何执行以下两个步骤，请查看之前的配方，*在蓝图中实现UInterface函数*。
- en: Compile your script so that we will have access to the new functions we have
    created.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的脚本，以便我们可以访问我们创建的新函数。
- en: Create a new Blueprint class called `Gloves` based on `Actor` by going to the
    Content Browser, opening the `Content` folder, and then right clicking and then
    selecting Blueprint Class.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到内容浏览器，打开`Content`文件夹，然后右键单击并选择蓝图类，创建一个新的基于`Actor`的蓝图类`Gloves`。
- en: 'In the Class Settings menu, under the Details tab, scroll down to the Implemented
    Interfaces property and click on the Add button and select `Wearable` as the interface
    that the `Gloves` actor will implement:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Class Settings`菜单中，在`Details`选项卡下，滚动到`Implemented Interfaces`属性，并点击`Add`按钮，选择`Wearable`作为`Gloves`演员将实现的接口：
- en: '![](img/6e0652ae-bd66-450b-9bc7-859d6ff1eae0.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e0652ae-bd66-450b-9bc7-859d6ff1eae0.png)'
- en: Adding the Wearable interface
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 添加可穿戴接口
- en: Afterwards, hit the Compile button in order to apply the change.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击编译按钮以应用更改。
- en: 'Open the Event Graph and right-click it to create a new event. From the search
    bar, type in `on equip`, and you should see our event under the Add Event section:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开事件图，右键单击以创建一个新事件。在搜索栏中输入`on equip`，您应该在`Add Event`部分看到我们的事件：
- en: '![](img/c02f936d-d293-45b9-97f2-60b24aa5a932.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c02f936d-d293-45b9-97f2-60b24aa5a932.png)'
- en: 'This allows us to override the `OnEquip` function from the default implementation
    to do whatever we want. For instance, add a Print String node with the In String being
    set to `Gloves being worn`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这允许我们覆盖默认实现中的`OnEquip`函数，以执行我们想要的任何操作。例如，添加一个`Print String`节点，将`In String`设置为`Gloves
    being worn`：
- en: '![](img/aa9216fb-a775-41b3-854f-0bfdfdc6f958.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aa9216fb-a775-41b3-854f-0bfdfdc6f958.png)'
- en: Click on the Compile button and then you can close the Blueprint. Drag a copy
    of both `Gloves` and `Boots` into your level for testing purposes.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击编译按钮，然后您可以关闭蓝图。为了测试目的，将`Gloves`和`Boots`的副本拖入您的级别中。
- en: 'Once added, add the following blueprint code to your level:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加后，将以下蓝图代码添加到您的级别中：
- en: '![](img/7e5b7e41-6f9a-4a02-9065-c8fa4ed3e74f.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e5b7e41-6f9a-4a02-9065-c8fa4ed3e74f.png)'
- en: 'Verify that `Boots` performs the default behavior, but that `Gloves` performs
    the blueprint-defined behavior:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`Boots`执行默认行为，而`Gloves`执行蓝图定义的行为：
- en: '![](img/95bdce70-174c-418e-98fe-88231ed6b461.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95bdce70-174c-418e-98fe-88231ed6b461.png)'
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe uses two `UFUNCTION` specifiers together: `BlueprintNativeEvent` and `BlueprintCallable`. `BlueprintCallable` has
    been shown in previous recipes, and is a way of marking your `UFUNCTION` as visible
    and invokable in the Blueprint Editor.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方使用两个`UFUNCTION`指定符一起：`BlueprintNativeEvent`和`BlueprintCallable`。`BlueprintCallable`已在之前的配方中展示，是一种将`UFUNCTION`标记为在蓝图编辑器中可见和可调用的方法。
- en: '`BlueprintNativeEvent` signifies a `UFUNCTION` that has a default C++ (native
    code) implementation, but is also overridable in Blueprint. It''s a combination
    of a virtual function, along with `BlueprintImplementableEvent`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlueprintNativeEvent`表示一个具有默认C++（本地代码）实现但也可以在蓝图中被覆盖的`UFUNCTION`。它是虚拟函数和`BlueprintImplementableEvent`的组合。'
- en: For this mechanism to work, the Unreal Header Tool generates the body of your
    functions so that the Blueprint version of the function is called if it exists;
    otherwise, it dispatches the method call through to the native implementation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此机制工作，Unreal头文件工具生成函数的主体，以便如果存在，则调用函数的蓝图版本；否则，它将方法调用调度到本地实现。
- en: The `Boots` class implements `IWearable`, overriding the default functionality. In
    contrast, `Gloves` also implements `IWearable`, but has an overridden implementation
    for `OnEquip` defined in Blueprint. This can be verified when we use Level Blueprints to
    call `OnEquip` for the two actors.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boots`类实现了`IWearable`，覆盖了默认功能。相比之下，`Gloves`也实现了`IWearable`，但在蓝图中有覆盖的`OnEquip`实现。当我们使用关卡蓝图调用两个角色的`OnEquip`时，可以验证这一点。'
- en: Calling Blueprint-defined interface functions from C++
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从C++中调用蓝图定义的接口函数
- en: 'While the previous recipes have focused on C++ being usable in Blueprint, such
    as being able to call functions from C++ in Blueprint, and override C++ functions
    with Blueprint, this recipe shows you the reverse: calling a Blueprint-defined
    interface function from C++.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管之前的配方主要集中在C++在蓝图中的可用性上，例如在蓝图中调用C++函数以及用蓝图覆盖C++函数，但这个配方展示了相反的操作：从C++中调用蓝图定义的接口函数。
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new `UInterface` called `Talker`  (Creating the `UTalker`/`ITalker` classes):'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`UInterface`名为`Talker`（创建`UTalker`/`ITalker`类）：
- en: '![](img/246f7357-2422-4d79-a871-d740fc5f04bf.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/246f7357-2422-4d79-a871-d740fc5f04bf.png)'
- en: 'Add the following `UFUNCTION` implementation:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`UFUNCTION`实现：
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a new C++ class based on `StaticMeshActor`. Remember to check Show All
    Classes and find the class that way:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的基于`StaticMeshActor`的C++类。请记住检查“显示所有类”并以此方式找到该类：
- en: '![](img/d78ffdd9-291d-4c5e-900b-4afe7bb3b150.png).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/d78ffdd9-291d-4c5e-900b-4afe7bb3b150.png).'
- en: 'After clicking Next, name this new class `TalkingMesh`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“下一步”后，将新类命名为`TalkingMesh`：
- en: '![](img/89e67a4a-0978-4258-ba9c-0ef649ac5c8f.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89e67a4a-0978-4258-ba9c-0ef649ac5c8f.png)'
- en: 'Add `#include` and modify the class declaration to include the talker interface:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`#include`并修改类声明以包含谈话者接口：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, add the following functions to the class declaration:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要将以下函数添加到类声明中：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Within the implementation, add the following to `TalkingMesh.cpp`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现中，将以下内容添加到`TalkingMesh.cpp`中：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a new class based on `DefaultPawn` to function as our player character:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的基于`DefaultPawn`的类来作为我们的玩家角色：
- en: '![](img/7c9e20bd-ff72-4add-b845-251e8019f6d6.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7c9e20bd-ff72-4add-b845-251e8019f6d6.png)'
- en: 'Once you select Next, give the class a Name of `TalkingPawn` and select Create
    Class:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦选择“下一步”，给类命名为`TalkingPawn`并选择“创建类”：
- en: '![](img/459b2a04-31ce-4d3b-8655-29fc0370b550.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/459b2a04-31ce-4d3b-8655-29fc0370b550.png)'
- en: 'Add the following to our class header:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到我们的类头文件中：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'From the `TalkingPawn.cpp` file, make sure to include the following so that
    we have access to the `ITalker` and `UTalker` classes:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`TalkingPawn.cpp`文件中，确保包含以下内容，以便我们能够访问`ITalker`和`UTalker`类：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Afterwards implement the constructor:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后实现构造函数：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Implement `OnTalkOverlap`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`OnTalkOverlap`：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Compile your scripts. Create a new `GameMode` and set `TalkingPawn` as the
    default pawn class for the player. The quickest way to do this is to go to Settings
    | World Settings and then, under GameMode Override, click on the + button. From
    there, expand the Selected GameMode option and under Default Pawn Class, select `TalkingPawn`.
    Refer to the following screenshot:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的脚本。创建一个新的`GameMode`并将`TalkingPawn`设置为玩家的默认角色类。最快的方法是转到`设置 | 世界设置`，然后在`游戏模式覆盖`下点击加号按钮。从那里，展开所选游戏模式选项，在`默认角色类`下选择`TalkingPawn`。参考以下截图：
- en: '![](img/6aca0461-7c62-4d54-bf82-4b8e96c8b0c9.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6aca0461-7c62-4d54-bf82-4b8e96c8b0c9.png)'
- en: 'Drag an instance of your `ATalkingMesh` class into the level. If you play the
    game now, you should be able to walk close to the mesh and see it display a message:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的`ATalkingMesh`类实例拖入关卡。如果你现在玩游戏，你应该能够走近网格并看到它显示消息：
- en: '![](img/4b6e90fc-40da-46b1-b6b9-98cbbf90fba9.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4b6e90fc-40da-46b1-b6b9-98cbbf90fba9.png)'
- en: 'Create a new Blueprint class based on `ATalkingMesh` by right-clicking on it
    from the Content Browser and selecting the appropriate option from the context
    menu:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在内容浏览器中右键单击`ATalkingMesh`并从上下文菜单中选择适当的选项来创建一个新的蓝图类：
- en: '![](img/fa84dd2a-1452-4c4c-a716-b9a32a62d245.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa84dd2a-1452-4c4c-a716-b9a32a62d245.png)'
- en: 'Name it `MyTalkingMesh` and select Create Blueprint Class:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名为`MyTalkingMesh`并选择“创建蓝图类”：
- en: '![](img/d4c82f32-2f65-4bb6-9c3f-29d9235c2bb6.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d4c82f32-2f65-4bb6-9c3f-29d9235c2bb6.png)'
- en: Inside the Blueprint Editor, create an implementation for `StartTalking`. We
    can do this by going to the Event Graph and right-clicking within the graph. Then,
    in the search bar, we can type in `start talking`. Under Add Event, select the Event
    Start Talking option.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在蓝图编辑器内部，为`StartTalking`创建一个实现。我们可以通过进入事件图并在此图中右键单击来实现这一点。然后，在搜索栏中，我们可以输入`start
    talking`。在添加事件下，选择`Event Start Talking`选项。
- en: '![](img/10bf1f2e-cf6a-4c8f-8247-a3b2472aed4d.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/10bf1f2e-cf6a-4c8f-8247-a3b2472aed4d.png)'
- en: 'If you would like to call the parent version of the event, you can right-click
    on the event node and select the Add call to parent function option:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要调用事件的上层版本，你可以右键单击事件节点并选择“添加对父函数的调用”选项：
- en: '![](img/45898ae1-509a-492e-b45b-9f3771054836.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/45898ae1-509a-492e-b45b-9f3771054836.png)'
- en: 'Afterward, you can connect the events together. To do something different from
    the original, create a Print String node and display a new In String message,
    such as `I''m the overridden implementation in Blueprint`. The final version of
    the example will look as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你可以连接事件。要执行与原始不同的操作，创建一个`Print String`节点并显示一个新的`In String`消息，例如`I'm the overridden
    implementation in Blueprint`。示例的最终版本将如下所示：
- en: '![](img/e67f1e3d-201a-4a7a-ae37-b61e8c2558ca.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e67f1e3d-201a-4a7a-ae37-b61e8c2558ca.png)'
- en: Compile your Blueprint. Afterwards, drag a copy of your new Blueprint into the
    level beside your `ATalkingMesh` instance.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的蓝图。之后，将你的新蓝图的一个副本拖到你的`ATalkingMesh`实例旁边的级别中。
- en: 'Walk up to the two actors and verify that your custom `Pawn` is correctly invoking
    either the default C++ implementation or the Blueprint implementation, as appropriate:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 走到两个演员旁边，验证你的自定义`Pawn`是否正确调用了默认的C++实现或蓝图实现，具体取决于情况：
- en: '![](img/ccd4ed7e-9285-4a9f-907d-8a2c011b9402.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ccd4ed7e-9285-4a9f-907d-8a2c011b9402.png)'
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As always, we create a new interface, and then add some function definitions
    to the `IInterface` class. We use the `BlueprintNativeEvent` specifier to indicate
    that we want to declare a default implementation in C++ that can then be overridden
    in Blueprint. We create a new class (inheriting from `StaticMeshActor` for convenience)
    and implement the interface on it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 总是，我们创建一个新的接口，然后向`IInterface`类添加一些函数定义。我们使用`BlueprintNativeEvent`指定符来表示我们想要在C++中声明一个默认实现，然后可以在蓝图中进行覆盖。我们创建一个新的类（为了方便继承自`StaticMeshActor`）并在其上实现接口。
- en: In the implementation of the new class constructor, we load a static mesh and
    set our collision as usual. We then add an implementation for our interface function,
    which simply prints a message to the screen.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在新类构造函数的实现中，我们加载一个静态网格并设置我们的碰撞，就像平常一样。然后我们添加一个接口函数的实现，它只是将一条消息打印到屏幕上。
- en: If you were using this in a full-blown project, you could play animations, play
    audio, alter the user interface, and whatever else was necessary to start a conversation
    with your `Talker`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个完整的项目中使用这个功能，你可以播放动画、播放音频、更改用户界面，以及进行其他必要的操作来与你的`Talker`开始对话。
- en: At this point, though, we don't have anything to actually call `StartTalking` on
    our `Talker`. The simplest way to implement this is to create a new `Pawn` subclass
    (again, inheriting from `DefaultPawn` for convenience) that can start talking
    to any `Talker` actors that it collides with.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，此时我们还没有任何东西可以在我们的`Talker`上调用`StartTalking`。实现这一点最简单的方法是创建一个新的`Pawn`子类（再次，为了方便继承自`DefaultPawn`），它可以与它碰撞到的任何`Talker`演员开始交谈。
- en: For this to work, we create a new `BoxComponent` to establish the radius at
    which we will trigger a conversation. As always, it is a `UPROPERTY`, so it won't
    get garbage collected. We also create the definition for a function that will
    get triggered when the new `BoxComponent` overlaps another `Actor` in the scene.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这起作用，我们创建一个新的`BoxComponent`来建立触发对话的半径。像往常一样，它是一个`UPROPERTY`，所以它不会被垃圾回收。我们还为当新的`BoxComponent`与场景中的另一个`Actor`重叠时将被触发的一个函数创建了定义。
- en: The constructor for our `TalkingPawn` initializes the new `BoxComponent`, and
    sets its extents appropriately. The constructor also binds the `OnTalkOverlap` function
    as an event handler to handle collisions with our `BoxComponent`. It also attaches
    the box component to our `RootComponent` so that it moves with the rest of the
    player character as the player moves around the level.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`TalkingPawn`构造函数初始化新的`BoxComponent`，并适当地设置其范围。构造函数还绑定`OnTalkOverlap`函数作为事件处理程序来处理与我们的`BoxComponent`的碰撞。它还把盒子组件附加到我们的`RootComponent`上，这样当玩家在级别中移动时，它就会随着玩家角色一起移动。
- en: Inside `OnTalkOverlap`, we need to check if the other actor, which is overlapping
    our box, implements the `Talker` interface. The most reliable way to do this is
    with the `ImplementsInterface` function in `UClass`. This function uses the class
    information that's generated by the Unreal Header Tool during compilation, and
    correctly handles both C++ and Blueprint-implemented interfaces.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnTalkOverlap`内部，我们需要检查与我们盒子重叠的其他演员是否实现了`Talker`接口。最可靠的方法是使用`UClass`中的`ImplementsInterface`函数。此函数使用在编译期间由Unreal
    Header Tool生成的类信息，并且正确处理了C++和Blueprint实现的接口。
- en: If the function returns `true`, we can use a special autogenerated function
    contained in our `IInterface` to invoke the interface method of our choice on
    our instance. This is a static method of the form `<IInterface>::Execute_<FunctionName>`.
    In our instance, our `IInterface` is `ITalker`, and the function is `StartTalking`,
    so the function we want to invoke is `ITalker::Execute_StartTalking()`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数返回`true`，我们可以使用包含在我们的`IInterface`中的特殊自动生成函数来调用我们实例上选择的接口方法。这是一个形式为`<IInterface>::Execute_<FunctionName>`的静态方法。在我们的实例中，我们的`IInterface`是`ITalker`，函数是`StartTalking`，所以我们要调用的函数是`ITalker::Execute_StartTalking()`。
- en: The reason we need this function is that, when an interface is implemented in
    Blueprint, the relationship isn't actually established at compile time. C++ is,
    therefore, not aware of the fact that the interface is implemented, and so we
    can't cast the Blueprint class to `IInterface` to call functions directly.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这个函数的原因是，当接口在Blueprint中实现时，关系实际上并没有在编译时建立。因此，C++并不知道接口已被实现，所以我们不能将Blueprint类强制转换为`IInterface`来直接调用函数。
- en: The `Execute_` functions take a pointer to the object that implements the interface
    and call a number of internal methods to invoke the desired function's Blueprint
    implementation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Execute_`函数接受实现接口的对象的指针，并调用多个内部方法来调用所需函数的Blueprint实现。'
- en: When you play the level and walk around, the custom `Pawn` is constantly receiving
    notifications when its `BoxComponent` overlaps other objects. If they implement
    the `UTalker`/`ITalker` interface, the pawn then tries to invoke `StartTalking` on
    the `Actor` instance in question, which then prints the appropriate message on
    screen.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你播放关卡并在周围走动时，自定义的`Pawn`会不断接收到通知，当其`BoxComponent`与其他对象重叠时。如果它们实现了`UTalker`/`ITalker`接口，那么这个`Pawn`就会尝试在相关的`Actor`实例上调用`StartTalking`，然后屏幕上会打印出相应的信息。
