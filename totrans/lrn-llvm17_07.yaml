- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IR Generation for High-Level Language Constructs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: High-level languages today usually make use of aggregate data types and **object-oriented
    programming** (**OOP**) constructs. LLVM IR has some support for aggregate data
    types, and OOP constructs such as classes must be implemented on their own. Adding
    aggregate types raises the question of how the parameters of an aggregate type
    are passed. Different platforms have different rules, and this is also reflected
    in the IR. Complying with the calling convention also ensures that system functions
    can be called.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to translate aggregate data types and pointers
    to LLVM IR and how to pass parameters to a function in a system-compliant way.
    You will also learn how to implement classes and virtual functions in LLVM IR.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with arrays, structs, and pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the **application binary interface** **(****ABI)** right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating IR code for classes and virtual functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have acquired the knowledge to create LLVM
    IR for aggregate data types and OOP constructs. You will also know how to pass
    aggregate data types according to the rules of the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code used in this chapter can be found at [https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter05](https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Working with arrays, structs, and pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For almost all applications, basic types such as `INTEGER` are not sufficient.
    For example, to represent mathematical objects such as a matrix or a complex number,
    you must construct new data types based on existing ones. These new data types
    are generally known as **aggregate** or **composite**.
  prefs: []
  type: TYPE_NORMAL
- en: '`tinylang` type `ARRAY [10] OF INTEGER` or the C type `long[10]` is expressed
    in IR as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Structures are composites of different types. In programming languages, they
    are often expressed with named members. For example, in `tinylang`, a structure
    is written as `RECORD x: REAL; color: INTEGER; y: REAL; END;` and the same structure
    in C is `struct { float x; long color; float y; };`. In LLVM IR, only the type
    names are listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To access a member, a numerical index is used. Like arrays, the first element
    has an index number of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The members of this structure are arranged in memory according to the specification
    in the data layout string. For more information regarding the data layout string
    within LLVM, [*Chapter 4*](B19561_04.xhtml#_idTextAnchor068), *Basics of IR Code
    Generation*, describes these details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, if necessary, unused padding bytes are inserted. If you need to
    take control of the memory layout, then you can use a packed structure in which
    all elements have a 1-byte alignment. Within C, we utilize the `__packed__` attribute
    in the struct in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '`struct __attribute__((__packed__)) { float x; long long color; float` `y;
    }`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, the syntax within LLVM IR is slightly different and looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Loaded into a register, arrays, and structs are treated as a unit. It is not
    possible to refer to a single element of array-valued register `%x` as `%x[3]`,
    for example. This is due to the SSA form because it is not possible to tell if
    `%x[i]` and `%x[j]` refer to the same element or not. Instead, we need special
    instructions to extract and insert single-element values into an array. To read
    the second element, we use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also update an element such as the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Both instructions work on structures, too. For example, to access the `color`
    member from register `%pt`, you write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There exists an important limitation on both instructions: the index must be
    a constant. For structures, this is easily explainable. The index number is only
    a substitute for the name, and languages such as C have no notion of dynamically
    computing the name of a struct member. For arrays, it is simply that it can’t
    be implemented efficiently. Both instructions have value in specific cases when
    the number of elements is small and known. For example, a complex number could
    be modeled as an array of two floating-point numbers. It’s reasonable to pass
    this array around, and it is always clear which part of the array must be accessed
    during a computation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For general use in the front end, we have to resort to pointers to memory.
    All global values in LLVM are expressed as pointers. Let’s declare a `@arr` global
    variable as an array of eight `i64` elements. This is the equivalent of the `long
    arr[8]` C declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the second element of the array, an address calculation must be performed
    to determine the address of the indexed element. Then the value can then be loaded
    from that address and put into a function `@second`, this looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getelementptr` instruction is the workhorse for address calculations.
    As such, it needs some more explanation. The first operand, `[8 x i64]`, is the
    base type the instruction is operating on. The second operand, `ptr @arr`, specifies
    the base pointer. Please note the subtle difference here: we declared an array
    of eight elements, but because all global values are treated as pointers, we have
    a pointer to the array. In C syntax, we really work with `long (*arr)[8]`! The
    consequence is that we first have to dereference the pointer before we can index
    the element, such as `arr[0][1]` in C. The third operand, `i64 0`, dereferences
    the pointer, and the fourth operand, `i64 1`, is the element index. The result
    of this computation is the address of the indexed element. Please note that no
    memory is touched by this instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Except for structs, the index parameters do not need to be constant. Therefore,
    the `getelementptr` instruction can be used in a loop to retrieve the elements
    of an array. Structs are treated differently here: only constants can be used,
    and the type must be `i32`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this knowledge, arrays are easily integrated into the code generator from
    [*Chapter 4*](B19561_04.xhtml#_idTextAnchor068), *Basics of IR Code Generation*.
    The `convertType()` method must be extended to create the type. If the `Arr` variable
    holds the type denoter of an array, and assuming the number of elements within
    an array is an integer literal, we then can add the following to the `convertType()`
    method to handle arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This type can be used to declare global variables. For local variables, we
    need to allocate memory for the array. We do this in the first basic block of
    the procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To read and write an element, we have to generate the `getelementptr` instruction.
    This is added to the `emitExpr()` (reading a value) and `emitStmt()` (writing
    a value) methods. To read an element of an array, the value of the variable is
    read first. Then, the selectors of the variable are processed. For each index,
    the expression is evaluated and the value is stored. Based on this list, the address
    of the referenced element is calculated and the value is loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing to an array element uses the same code, with the exception that you
    do not generate a `load` instruction. Instead, you use the pointer as the target
    in a `store` instruction. For records, you use a similar approach. The selector
    for a record member contains the constant field index, named `Idx`. You convert
    this constant into a constant LLVM value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Then you can use value in the `Builder.CreateGEP()` methods as in for arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should know how to translate aggregate data types to LLVM IR. Passing
    values of those types in a system-compliant way requires some care, and you will
    learn to implement it correctly in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the application binary interface right
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the addition of arrays and records to the code generator, you can note
    that sometimes, the generated code does not execute as expected. The reason is
    that we have ignored the calling conventions of the platform so far. Each platform
    defines its own rules on how one function can call another function in the same
    program or library. These rules are summarized in the ABI documentation. Typical
    information includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Are machine registers used for parameter passing? If yes, which ones?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are aggregates such as arrays and structs passed to a function?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How are return values handled?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a wide variety in use. On some platforms, aggregates are always passed
    indirectly, meaning that a copy of the aggregate is placed on the stack and only
    a pointer to the copy is passed as a parameter. On other platforms, a small aggregate
    (say 128 or 256 bit wide) is passed in registers, and only above that threshold
    is indirect parameter passing used. Some platforms also use floating-point and
    vector registers for parameter passing, while others demand that floating-point
    values be passed in integer registers.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is all interesting low-level stuff. Unfortunately, it leaks
    into LLVM IR. At first, this is surprising. After all, we define the types of
    all parameters of a function in LLVM IR! It turns out that this is not enough.
    To understand this, let’s consider complex numbers. Some languages have built-in
    data types for complex numbers. For example, C99 has `float _Complex` (among others).
    Older versions of C do not have complex number types, but you can easily define
    `struct Complex { float re, im; }` and create arithmetic operations on this type.
    Both types can be mapped to the `{ float, float }` LLVM IR type.
  prefs: []
  type: TYPE_NORMAL
- en: If the ABI now states that values of a built-in, complex-number type are passed
    in two floating-point registers, but user-defined aggregates are always passed
    indirectly, then the information given with the function is not enough for LLVM
    to decide how to pass this particular parameter. The unfortunate consequence is
    that we need to provide more information to LLVM, and this information is highly
    ABI-specific.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to specify this information to LLVM: parameter attributes
    and type rewriting. What you need to use depends on the target platform and the
    code generator. The most commonly used parameter attributes are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`inreg` specifies that the parameter is passed in a register'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byval` specifies that the parameter is passed by value. The parameter must
    be a pointer type. A hidden copy is made of the pointed-to data, and this pointer
    is passed to the called function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zeroext` and `signext` specify that the passed integer value should be zero
    or sign extended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sret` specifies that this parameter holds a pointer to memory which is used
    to return an aggregate type from the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While all code generators support `zeroext`, `signext`, and `sret` attributes,
    only some support `inreg` and `byval`. An attribute can be added to the argument
    of a function with the `addAttr()` method. For example, to set the `inreg` attribute
    on argument `Arg`, you call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To set multiple attributes, you can use the `llvm::AttrBuilder` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way to provide additional information is to use type rewriting. With
    this approach, you disguise the original types. You can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Split the parameter. For example, instead of passing one complex argument, you
    can pass two floating-point arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cast the parameter into a different representation, such as passing a floating-point
    value through an integer register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To cast between types without changing the bits of the value, you use the `bitcast`
    instruction. The `bitcast` instruction can operate on simple data types such as
    integers and floating-point values. When floating-point values are passed via
    an integer register, the floating-point value must be cast to an integer. In LLVM,
    a 32-bit floating-point value is expressed as `float`, and a 32-bit bit integer
    is expressed as `i32`. The floating point value can be bitcasted to an integer
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, the `bitcast` instruction requires that both types have the same
    size.
  prefs: []
  type: TYPE_NORMAL
- en: Adding attributes to an argument or changing the type is not complicated. But
    how do you know what you need to implement? First of all, you should get an overview
    of the calling convention used on your target platform. For example, the ELF ABI
    on Linux is documented for each supported CPU platform, so you can look up the
    document and make yourself comfortable with it.
  prefs: []
  type: TYPE_NORMAL
- en: There is also documentation about the requirements of the LLVM code generators.
    The source of information is the clang implementation, which you can find at [https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/TargetInfo.cpp](https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/TargetInfo.cpp).
    This single file contains the ABI-specific actions for all supported platforms,
    and it is also where all information is collected.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned to generate the IR for function calls to be compliant
    with the ABI of your platform. The next section covers the different ways to create
    IR for classes and virtual functions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating IR code for classes and virtual functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many modern programming languages support object orientation using classes.
    A **class** is a high-level language construct, and in this section, we will explore
    how we can map a class construct into LLVM IR.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing single inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A class is a collection of data and methods. A class can inherit from another
    class, potentially adding more data fields and methods, or overriding existing
    virtual methods. Let’s illustrate this with classes in Oberon-2, which is also
    a good model for `tinylang`. A `Shape` class defines an abstract shape with a
    color and an area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetColor` method only returns the color number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The area of an abstract shape cannot be calculated, so this is an abstract
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Shape` type can be extended to represent a `Circle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For a circle, the area can be calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The type can also be queried at runtime. If the shape is a variable of type
    `Shape`, then we can formulate a type test in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The different syntax aside, this works much like it does in C++. One notable
    difference to C++ is that the Oberon-2 syntax makes the implicit `this` pointer
    explicit, calling it the receiver of a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic problems to solve are how to lay out a class in memory and how to
    implement the dynamic call of methods and run time-type checking. For the memory
    layout, this is quite easy. The `Shape` class has only one data member, and we
    can map it to a corresponding LLVM structure type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Circle` class adds another data member. The solution is to append the
    new data member at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The reason is that a class can have many sub-classes. With this strategy, the
    data member of the common base class always has the same memory offset and also
    uses the same index to access the field via the `getelementptr` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the dynamic call of a method, we must further extend the LLVM structure.
    If the `Area()` function is called on a `Shape` object, then the abstract method
    is called, causing the application to halt. If it is called on a `Circle` object,
    then the corresponding method to calculate the area of a circle is called. On
    the other hand, the `GetColor()` function can be called for objects of both classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic idea to implement this is to associate a table with function pointers
    with each object. Here, a table would have two entries: one for the `GetColor()`
    method and one for the `Area()` function. The `Shape` class and the `Circle` class
    each have such a table. The tables differ in the entry for the `Area()` function,
    which calls different code depending on the type of the object. This table is
    called the **virtual method table**, often abbreviated as **vtable**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The vtable alone is not useful. We must connect it with an object. To do so,
    we always add a pointer to the vtable as the first data member to the structure.
    At the LLVM level, this is what becomes of the `@``Shape` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `@Circle` type is similarly extended.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting memory structure is shown in *Figure 5**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Memory layout of the classes and the virtual method tables](img/B19561_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Memory layout of the classes and the virtual method tables
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of LLVM IR, the vtable for the `Shape` class can be visualized as
    the following, where the two pointers correspond to the `GetColor()` and `GetArea()`
    methods, as represented in *Figure 5**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@ShapeVTable = constant { ptr, ptr } { GetColor(),` `Area() }`'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, LLVM does not have void pointers. Pointers to bytes are used instead.
    With the introduction of the hidden `vtable` field, there is now also the need
    to have a way to initialize it. In C++, this is part of calling the constructor.
    In Oberon-2, the field is initialized automatically when the memory is allocated.
  prefs: []
  type: TYPE_NORMAL
- en: 'A dynamic call to a method is then executed with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the offset of the vtable pointer via the `getelementptr` instruction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the pointer to the vtable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the offset of the function in the vtable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the function pointer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Indirectly call the function via the pointer with the `call` instruction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can visualize the dynamic call to a virtual method, such as `Area()`, within
    LLVM IR, as well. First, we load a pointer from the corresponding designated location
    of the `Shape` class. The following load represents loading the pointer to the
    actual vtable for `Shape`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Following this, a `getelementptr` gets to the offset to call the `Area()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we load the function pointer to `Area()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `Area()` function is called through the pointer with the call,
    similar to the general steps that are highlighted previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, even in the case of a single inheritance, the LLVM IR that is
    generated can appear to be very verbose. Although the general procedure of generating
    a dynamic call to a method does not sound very efficient, most CPU architectures
    can perform this dynamic call with just two instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, to turn a function into a method, a reference to the object’s data
    is required. This is implemented by passing the pointer to the data as the first
    parameter of the method. In Oberon-2, this is the explicit receiver. In languages
    similar to C++, it is the implicit `this` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: With the vtable, we have a unique address in memory for each class. Does this
    help with the *runtime-type test*, too? The answer is that it helps only in a
    limited way. To illustrate the problem, let’s extend the class hierarchy with
    an `Ellipse` class, which inherits from the `Circle` class. This is not the classical
    *is-a* relationship in the mathematical sense.
  prefs: []
  type: TYPE_NORMAL
- en: If we have a `shape` variable of the `Shape` type, then we could implement the
    `shape IS Circle` type test as a comparison of the vtable pointer stored in the
    `shape` variable with the vtable pointer of the `Circle` class. This comparison
    only results in true if `shape` has the exact `Circle` type. However, if `shape`
    is indeed of the `Ellipse` type, then the comparison returns false, even if an
    object of the `Ellipse` type can be used in all places where only an object of
    the `Circle` type is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly, we need to do more. The solution is to extend the virtual method table
    with runtime-type information. How much information you need to store depends
    on the source language. To support the runtime-type check, it is enough to store
    a pointer to the vtable of the base class, which then looks like in *Figure 5**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Class and vtable layout supporting simple type tests](img/B19561_05_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Class and vtable layout supporting simple type tests
  prefs: []
  type: TYPE_NORMAL
- en: If the test fails as described earlier, then the test is repeated with the pointer
    to the vtable of the base class. This is repeated until the test yields true or,
    if there is no base class, false. In contrast to calling a dynamic function, the
    type test is a costly operation because, in the worst-case scenario, the inheritance
    hierarchy is walked up to the root class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you know the whole class hierarchy, then an efficient approach is possible:
    you number each member of the class hierarchy in a depth-first order. Then, the
    type test becomes compare-against-a-number or an interval, which can be done in
    constant time. In fact, that is the approach of LLVM’s own runtime-type test,
    which we learned about in the previous chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: To couple runtime-type information with the vtable is a design decision, either
    mandated by the source language or just as an implementation detail. For example,
    if you need detailed runtime-type information because the source language supports
    reflection at runtime, and you have data types without a vtable, then coupling
    both is not a good idea. In C++, the coupling results in the fact that a class
    with virtual functions (and therefore no vtable) has no runtime-type data attached
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Often, programming languages support interfaces which are a collection of virtual
    methods. Interfaces are important because they add a useful abstraction. We will
    look at possible implementations of interfaces in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Extending single inheritance with interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Languages such as **Java** support interfaces. An interface is a collection
    of abstract methods, comparable to a base class with no data members and only
    abstract methods defined. Interfaces pose an interesting problem because each
    class implementing an interface can have the corresponding method at a different
    position in the vtable. The reason is simply that the order of function pointers
    in the vtable is derived from the order of the functions in the class definition
    in the source language. The definition of the interface is independent of this,
    and different orders are the norm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the methods defined in an interface can have a different order, we
    attach a table for each implemented interface to the class. For each method of
    the interface, this table can specify either the index of the method in the vtable
    or a copy of the function pointer stored in the vtable. If a method is called
    on the interface, then the corresponding vtable of the interface is searched,
    the pointer to the function is fetched, and the method is called. Adding two `I1`
    and `I2` interfaces to the `Shape` class results in the following layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Layout of vtables for interfaces](img/B19561_05_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Layout of vtables for interfaces
  prefs: []
  type: TYPE_NORMAL
- en: 'The caveat lies in the fact that we have to find the right vtable. We can use
    an approach similar to the runtime-type test: we can perform a linear search through
    the list of interface vtables. We can assign a unique number to each interface
    (for example, a memory address) and identify this vtable using this number. The
    disadvantage of this scheme is obvious: calling a method through an interface
    takes much more time than calling the same method on the class. There is no easy
    mitigation for this problem.'
  prefs: []
  type: TYPE_NORMAL
- en: A good approach is to replace the linear search with a hash table. At compilation
    time, the interface that a class implements is known. Therefore, we can construct
    a perfect hash function, which maps the interface number to the vtable for the
    interface. A known unique number identifying an interface may be needed for the
    construction, so memory does not help, but there are other ways to compute a unique
    number. If the symbol names in the source are unique, then it is always possible
    to compute a cryptographic hash such as `MD5` of the symbol, and use the hash
    as the number. The calculation occurs at compile time and therefore has no runtime
    cost.
  prefs: []
  type: TYPE_NORMAL
- en: The result is much faster than the linear search and only takes constant time.
    Still, it involves several arithmetic operations on a number and is slower than
    the method call of a class type.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, interfaces also take part in runtime-type tests, making the list search
    even longer. Of course, if the hash-table approach is implemented, then it can
    also be used for the runtime-type test.
  prefs: []
  type: TYPE_NORMAL
- en: Some languages allow for more than one parent class. This has some interesting
    challenges for the implementation, and we will master this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding support for multiple inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple inheritance adds another challenge. If a class inherits from two or
    more base classes, then we need to combine the data members in such a way that
    they are still accessible from the methods. Like in the single inheritance case,
    the solution is to append all data members, including the hidden vtable pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Circle` class is not only a geometric shape but also a graphic object.
    To model this, we let the `Circle` class inherit from the `Shape` class and the
    `GraphicObj` class. In the class layout, the fields from the `Shape` class come
    first. Then, we append all fields of the `GraphicObj` class, including the hidden
    vtable pointer. After that, we add the new data members of the `Circle` class,
    resulting in the overall structure shown in *Figure 5**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 - Layout of classes and vtables with multiple inheritance](img/B19561_05_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 - Layout of classes and vtables with multiple inheritance
  prefs: []
  type: TYPE_NORMAL
- en: This approach has several implications. There can now be several pointers to
    the object. A pointer to the `Shape` or `Circle` class points to the top of the
    object, while a pointer to a `GraphicObj` class points to inside this object,
    the beginning of the embedded `GraphicObj` object. This has to be taken into account
    when comparing pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling a virtual method is also affected. If a method is defined in the `GraphicObj`
    class, then this method expects the class layout of the `GraphicObj` class. If
    this method is not overridden in the `Circle` class, then there a two possibilities.
    The easy case is if the method call is done with a pointer to a `GraphicObj` instance:
    in this case, you look up the address of the method in the vtable of the `GraphicObj`
    class and call the function. The more complicated case is if you call the method
    with a pointer to the `Circle` class. Again, you can look up the address of the
    method in the vtable of the `Circle` class. The called method expects a `this`
    pointer to be an instance of the `GraphicObj` class, so we have to adjust that
    pointer, too. We can do this because we know the offset of the `GraphicObj` class
    inside the `Circle` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a `GrapicObj` method is overridden in the `Circle` class, then nothing special
    needs to be done if the method is called through a pointer to the `Circle` class.
    However, if the method is called through a pointer to a `GraphicObj` instance,
    then we need to make another adjustment because the method needs a `this` pointer
    pointing to a `Circle` instance. At compilation time, we cannot compute this adjustment
    because we do not know whether or not this `GraphicObj` instance is part of a
    multiple inheritance hierarchy. To solve this, we store the adjustment we need
    to make to the `this` pointer before calling the method together with each function
    pointer in the vtable, as in *Figure 5**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – vtable with adjustments to the this pointer](img/B19561_05_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – vtable with adjustments to the this pointer
  prefs: []
  type: TYPE_NORMAL
- en: 'A method call now becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Look up the function pointer in the vtable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust the `this` pointer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This approach can also be used for implementing interfaces. As an interface
    only has methods, each implemented interface adds a new vtable pointer to the
    object. This is easier to implement and most likely faster, but it adds overhead
    to each object instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the worst case, if your class has a single 64-bit data field but implements
    10 interfaces, then your object requires 96 bytes in memory: eight bytes for the
    vtable pointer of the class itself, eight bytes for the data member, and 10 *
    8 bytes for the vtable pointers of each interface.'
  prefs: []
  type: TYPE_NORMAL
- en: To support meaningful comparisons to objects and to perform runtime-type tests,
    we need to normalize a pointer to an object first. If we add an additional field
    to the vtable, containing an offset to the top of the object, then we can always
    adjust the pointer to point to the real object. In the vtable of the `Circle`
    class, this offset is 0, but not in the vtable of the embedded `GraphicObj` class.
    Of course, whether this needs to be implemented depends on the semantics of the
    source language.
  prefs: []
  type: TYPE_NORMAL
- en: LLVM itself does not favor a special implementation of object-oriented features.
    As seen in this section, we can implement all approaches with the available LLVM
    data types. Additionally, as we have seen an example of LLVM IR with single inheritance,
    it is also worth noting that the IR can become more verbose when multiple inheritance
    is involved. If you want to try a new approach, then a good way is to do a prototype
    in C first. The required pointer manipulations are quickly translated to LLVM
    IR, but reasoning about the functionality is easier in a higher-level language.
  prefs: []
  type: TYPE_NORMAL
- en: With the knowledge acquired in this section, you can implement the lowering
    of all OOP constructs commonly found in programming languages into LLVM IR in
    your own code generator. You have recipes on how to represent single inheritance,
    single inheritance with interface, or multiple inheritance in memory, and also
    how to implement type tests and how to look up virtual functions, which are the
    core concepts of OOP languages.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to translate aggregate data types and pointers
    to LLVM IR code. You also learned about the intricacies of the application binary
    interface. Finally, you learned about the different approaches to translating
    classes and virtual functions to LLVM IR. With the knowledge of this chapter,
    you will be able to create an LLVM IR code generator for most real programming
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn some advanced techniques regarding IR generation.
    Exception handling is fairly common in modern programming languages, and LLVM
    has some support for it. Attaching type information to pointers can help with
    certain optimizations, so we will add this, too. Last but not least, the ability
    to debug an application is essential for many developers, so we will also add
    the generation of debugging metadata to our code generator.
  prefs: []
  type: TYPE_NORMAL
