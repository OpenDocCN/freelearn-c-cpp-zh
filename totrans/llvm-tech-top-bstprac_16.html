<html><head></head><body>
		<div id="_idContainer055">
			<h1 id="_idParaDest-176"><a id="_idTextAnchor185"/>Assessments</h1>
			<p>This section contains answers to the questions from all chapters.</p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor186"/>Chapter 6, Extending the Preprocessor</h1>
			<ol>
				<li>Most of the time tokens are harvested from the provided source code, but in some cases, tokens might be generated dynamically inside the <strong class="source-inline">Preprocessor</strong>. For example, the <strong class="source-inline">__LINE__</strong> built-in macro is expanded to the current line number, and the <strong class="source-inline">__DATE__</strong> macro is expanded to the current calendar date. How does Clang put that generated textual content into the <strong class="source-inline">SourceManager</strong>'s source code buffer? How does Clang assign <strong class="source-inline">SourceLocation</strong> to these tokens?<ul><li>Developers can leverage the <strong class="source-inline">clang::ScratchBuffer</strong> class to insert dynamic <strong class="source-inline">Token</strong> instances.</li></ul></li>
				<li>When we were talking about implementing a custom <strong class="source-inline">PragmaHandler</strong>, we were using <strong class="source-inline">Preprocessor::Lex</strong> to fetch tokens followed after the pragma name, until we hit the <strong class="source-inline">eod</strong> token type. Can we keep lexing <em class="italic">beyond</em> the <strong class="source-inline">eod</strong> token? What interesting thing will you do if you can consume arbitrary tokens follow after the <strong class="source-inline">#pragma</strong> directive?<ul><li>Yes, we can keep lexing beyond the <strong class="source-inline">eod</strong> token. It simply consumes the contents following the <strong class="source-inline">#pragma</strong> line. In this way, you can create a custom <strong class="source-inline">#pragma</strong> that allows you to write <em class="italic">arbitrary</em> content (below it) – for instance, writing programming languages that are not supported by Clang. Here is an example:<p class="source-code"><strong class="bold">#pragma</strong> <strong class="bold">javascript</strong> function</p><p class="source-code">const my_func = (arg) =&gt; {</p><p class="source-code">  console.log(`Hello ${arg}`);</p><p class="source-code">};</p><p>The preceding snippet showed how to create a custom <strong class="source-inline">#pragma</strong> that allows you to define a JavaScript function below it.</p></li></ul></li>
				<li>In the <strong class="source-inline">macro guard</strong> project from the <em class="italic">Developing custom preprocessor plugins and callbacks</em> section, the warning message has the format of <strong class="source-inline">[WARNING] In &lt;source location&gt;: ….</strong>. Apparently, this is not the typical compiler warning we see from <strong class="source-inline">Clang</strong>, which looks like <strong class="source-inline">&lt;source location&gt;: warning: …</strong>:<p class="source-code">./simple_warn.c:2:7: warning: unused variable 'y'…</p><p class="source-code">  int y = x + 1;</p><p class="source-code">      ^</p><p class="source-code">1 warning generated.</p><p>The <strong class="source-inline">warning</strong> string is even colored in supported terminals. How can we print a warning message like that? Is there an infrastructure in Clang for doing that?</p><ul><li>Developers can use the diagnostics framework in Clang to print messages like this. In the <em class="italic">Printing diagnostics messages</em> section of <a href="B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 7</em></a><em class="italic">, Handling AST</em>, we will show you some of the usages of this framework.</li></ul></li>
			</ol>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor187"/>Chapter 8, Working with Compiler Flags and Toolchains</h1>
			<ol>
				<li value="1">It is common to override the assembling and linking stage, since different platforms tend to support different assemblers and linkers. But is it possible to override the <em class="italic">compiling</em> stage (which is Clang)? If it is possible, how do we do it? What might be the possible reasons for people to do that?<ul><li>You can override the <strong class="source-inline">ToolChain::SelectTool</strong> method and provide an alternative <strong class="source-inline">Tool</strong> instance (which represents the compilation stage) according to the argument. Here is an example:<p class="source-code">Tool*</p><p class="source-code"><strong class="bold">MyToolChain::SelectTool(const JobAction &amp;JA)</strong> const override {</p><p class="source-code">  if (<strong class="bold">JA.getKind() == Action::CompileJobClass &amp;&amp;</strong></p><p class="source-code">      <strong class="bold">getTriple().getArch() == CUSTOM_HARDWARE</strong>)</p><p class="source-code">    return new <strong class="bold">MyCompiler</strong>(…);</p><p class="source-code">  …</p><p class="source-code">  // Run the default `SelectTool` otherwise</p><p class="source-code">  return ToolChain::SelectTool(JA);</p><p class="source-code">}</p><p>In the preceding snippet, we provided our own compiler instance –  <strong class="source-inline">MyCompiler</strong> – which is a class derived from <strong class="source-inline">Tool</strong>, if we are trying to compile the code for a certain hardware architecture.</p><p>Providing an alternative compiler instance is useful when your target platform (for example, the <strong class="source-inline">CUSTOM_HARDWARE</strong> in the preceding snippet) or input file is not supported by Clang, but you still want to use the <em class="italic">same</em> <strong class="source-inline">clang</strong> command-line interface for all the build jobs. For example, suppose you are trying to cross-compile the same projects to <em class="italic">multiple</em> different architectures, but some of them are not supported by Clang yet. Therefore, you can create a custom Clang toolchain and redirect the compilation job to an external compiler (for example, <strong class="source-inline">gcc</strong>) when the <strong class="source-inline">clang</strong> command-line tool is asked to build the project for those architectures.</p></li></ul></li>
				<li>When we were working on <strong class="source-inline">tools::zipline::Linker::ConstructJob</strong>, we simply use <strong class="source-inline">llvm_unreachable</strong> to bail out the compilation process if the user provides an unsupported compressor name through the <strong class="source-inline">-fuse-ld</strong> flag. Can we replace it with Clang's <strong class="bold">diagnostic</strong> framework that we learned about in <a href="B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 7</em></a>, <em class="italic">Handling AST</em>, to print out better messages?<ul><li>The <strong class="source-inline">Driver</strong> class provides a shortcut to access the diagnostic framework. Inside a derived class of <strong class="source-inline">Tool</strong>, you can use <strong class="source-inline">getToolChain().getDriver()</strong> to get a <strong class="source-inline">Driver</strong> instance, then print out the diagnostic message using the <strong class="source-inline">Driver::Diag</strong> method.</li></ul></li>
				<li>Just like we can use <strong class="source-inline">-Xclang</strong> to pass flags directly to the frontend, we can also pass assembler-specific or linker-specific flags directly to the assembler or linker using driver flags such as <strong class="source-inline">-Wa</strong> (for assembler) and <strong class="source-inline">-Wl</strong> (for linker). How do we consume those flags in our custom assembler and linker stages within Zipline?<ul><li>Inside the <strong class="source-inline">ConstructJob</strong> method, you can read the value of <strong class="source-inline">options::OPT_Wa_COMMA</strong> and <strong class="source-inline">options::OPT_Wl_COMMA</strong> to retrieve assembler- and linker-specific command line flags, respectively. Here is an example:<p class="source-code">void</p><p class="source-code"><strong class="bold">MyAssembler::ConstructJob</strong>(Compilation &amp;C,</p><p class="source-code">                          const JobAction &amp;JA,</p><p class="source-code">                          const InputInfo &amp;Output,</p><p class="source-code">                          const InputInfoList &amp;Inputs,</p><p class="source-code">                          const ArgList &amp;Args,</p><p class="source-code">                          const char *LinkingOutput)                           const {</p><p class="source-code">  if (Arg *A = Args.getLastArg(<strong class="bold">options::OPT_Wl_COMMA</strong>)) {</p><p class="source-code">    // `A` contains linker-specific flags</p><p class="source-code">    …</p><p class="source-code">  }</p><p class="source-code">  …</p><p class="source-code">}</p></li></ul></li>
			</ol>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor188"/>Chapter 9, Working with PassManager and AnalysisManager</h1>
			<ol>
				<li value="1">In the StrictOpt example in the <em class="italic">Writing a LLVM Pass for the new PassManager</em> section, how do we write a Pass without deriving the <strong class="source-inline">PassInfoMixin</strong> class?<ul><li>The <strong class="source-inline">PassInfoMixin</strong> class only defines a utility function for you, <strong class="source-inline">name</strong>, which returns the name of this Pass. Therefore, you can easily create one by yourself. Here is an example:<p class="source-code">struct MyPass {</p><p class="source-code">  <strong class="bold">static StringRef name() { return "MyPass"; }</strong></p><p class="source-code">  PreservedAnalyses run(Function&amp;, FunctionAnalysisManager&amp;);</p><p class="source-code">};</p></li></ul></li>
				<li>How do we develop custom instrumentation for the new PassManager? How do we do it without modifying the LLVM source tree? (Hint: Use the Pass plugin we learned in this chapter.)<ul><li>Pass instrumentation is a piece of code that runs before and/or after an LLVM Pass. This blog post shows an example of developing a custom Pass instrumentation via the Pass plugin: <a href="mailto:https://medium.com/@mshockwave/writing-pass-instrument-for-llvm-newpm-f17c57d3369f">https://medium.com/@mshockwave/writing-pass-instrument-for-llvm-newpm-f17c57d3369f</a>.</li></ul></li>
			</ol>
		</div>
	</body></html>