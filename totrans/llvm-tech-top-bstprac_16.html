<html><head></head><body>
		<div><h1 id="_idParaDest-176"><a id="_idTextAnchor185"/>Assessments</h1>
			<p>This section contains answers to the questions from all chapters.</p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor186"/>Chapter 6, Extending the Preprocessor</h1>
			<ol>
				<li>Most of the time tokens are harvested from the provided source code, but in some cases, tokens might be generated dynamically inside the <code>Preprocessor</code>. For example, the <code>__LINE__</code> built-in macro is expanded to the current line number, and the <code>__DATE__</code> macro is expanded to the current calendar date. How does Clang put that generated textual content into the <code>SourceManager</code>'s source code buffer? How does Clang assign <code>SourceLocation</code> to these tokens?<ul><li>Developers can leverage the <code>clang::ScratchBuffer</code> class to insert dynamic <code>Token</code> instances.</li></ul></li>
				<li>When we were talking about implementing a custom <code>PragmaHandler</code>, we were using <code>Preprocessor::Lex</code> to fetch tokens followed after the pragma name, until we hit the <code>eod</code> token type. Can we keep lexing <em class="italic">beyond</em> the <code>eod</code> token? What interesting thing will you do if you can consume arbitrary tokens follow after the <code>#pragma</code> directive?<ul><li>Yes, we can keep lexing beyond the <code>eod</code> token. It simply consumes the contents following the <code>#pragma</code> line. In this way, you can create a custom <code>#pragma</code> that allows you to write <em class="italic">arbitrary</em> content (below it) – for instance, writing programming languages that are not supported by Clang. Here is an example:<pre><code>#pragma</code> that allows you to define a JavaScript function below it.</p></li></ul></li>
				<li>In the <code>macro guard</code> project from the <em class="italic">Developing custom preprocessor plugins and callbacks</em> section, the warning message has the format of <code>[WARNING] In &lt;source location&gt;: ….</code>. Apparently, this is not the typical compiler warning we see from <code>Clang</code>, which looks like <code>&lt;source location&gt;: warning: …</code>:<pre>./simple_warn.c:2:7: warning: unused variable 'y'…
  int y = x + 1;
      ^
1 warning generated.</pre><p>The <code>warning</code> string is even colored in supported terminals. How can we print a warning message like that? Is there an infrastructure in Clang for doing that?</p><ul><li>Developers can use the diagnostics framework in Clang to print messages like this. In the <em class="italic">Printing diagnostics messages</em> section of <a href="B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 7</em></a><em class="italic">, Handling AST</em>, we will show you some of the usages of this framework.</li></ul></li>
			</ol>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor187"/>Chapter 8, Working with Compiler Flags and Toolchains</h1>
			<ol>
				<li value="1">It is common to override the assembling and linking stage, since different platforms tend to support different assemblers and linkers. But is it possible to override the <em class="italic">compiling</em> stage (which is Clang)? If it is possible, how do we do it? What might be the possible reasons for people to do that?<ul><li>You can override the <code>ToolChain::SelectTool</code> method and provide an alternative <code>Tool</code> instance (which represents the compilation stage) according to the argument. Here is an example:<pre>Tool*
<code>MyCompiler</code> – which is a class derived from <code>Tool</code>, if we are trying to compile the code for a certain hardware architecture.</p><p>Providing an alternative compiler instance is useful when your target platform (for example, the <code>CUSTOM_HARDWARE</code> in the preceding snippet) or input file is not supported by Clang, but you still want to use the <em class="italic">same</em> <code>clang</code> command-line interface for all the build jobs. For example, suppose you are trying to cross-compile the same projects to <em class="italic">multiple</em> different architectures, but some of them are not supported by Clang yet. Therefore, you can create a custom Clang toolchain and redirect the compilation job to an external compiler (for example, <code>gcc</code>) when the <code>clang</code> command-line tool is asked to build the project for those architectures.</p></li></ul></li>
				<li>When we were working on <code>tools::zipline::Linker::ConstructJob</code>, we simply use <code>llvm_unreachable</code> to bail out the compilation process if the user provides an unsupported compressor name through the <code>-fuse-ld</code> flag. Can we replace it with Clang's <code>Driver</code> class provides a shortcut to access the diagnostic framework. Inside a derived class of <code>Tool</code>, you can use <code>getToolChain().getDriver()</code> to get a <code>Driver</code> instance, then print out the diagnostic message using the <code>Driver::Diag</code> method.</li></ul></li>
				<li>Just like we can use <code>-Xclang</code> to pass flags directly to the frontend, we can also pass assembler-specific or linker-specific flags directly to the assembler or linker using driver flags such as <code>-Wa</code> (for assembler) and <code>-Wl</code> (for linker). How do we consume those flags in our custom assembler and linker stages within Zipline?<ul><li>Inside the <code>ConstructJob</code> method, you can read the value of <code>options::OPT_Wa_COMMA</code> and <code>options::OPT_Wl_COMMA</code> to retrieve assembler- and linker-specific command line flags, respectively. Here is an example:<pre>void
<strong class="bold">MyAssembler::ConstructJob</strong>(Compilation &amp;C,
                          const JobAction &amp;JA,
                          const InputInfo &amp;Output,
                          const InputInfoList &amp;Inputs,
                          const ArgList &amp;Args,
                          const char *LinkingOutput)                           const {
  if (Arg *A = Args.getLastArg(<strong class="bold">options::OPT_Wl_COMMA</strong>)) {
    // `A` contains linker-specific flags
    …
  }
  …
}</pre></li></ul></li>
			</ol>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor188"/>Chapter 9, Working with PassManager and AnalysisManager</h1>
			<ol>
				<li value="1">In the StrictOpt example in the <em class="italic">Writing a LLVM Pass for the new PassManager</em> section, how do we write a Pass without deriving the <code>PassInfoMixin</code> class?<ul><li>The <code>PassInfoMixin</code> class only defines a utility function for you, <code>name</code>, which returns the name of this Pass. Therefore, you can easily create one by yourself. Here is an example:<pre>struct MyPass {
  <strong class="bold">static StringRef name() { return "MyPass"; }</strong>
  PreservedAnalyses run(Function&amp;, FunctionAnalysisManager&amp;);
};</pre></li></ul></li>
				<li>How do we develop custom instrumentation for the new PassManager? How do we do it without modifying the LLVM source tree? (Hint: Use the Pass plugin we learned in this chapter.)<ul><li>Pass instrumentation is a piece of code that runs before and/or after an LLVM Pass. This blog post shows an example of developing a custom Pass instrumentation via the Pass plugin: <a href="mailto:https://medium.com/@mshockwave/writing-pass-instrument-for-llvm-newpm-f17c57d3369f">https://medium.com/@mshockwave/writing-pass-instrument-for-llvm-newpm-f17c57d3369f</a>.</li></ul></li>
			</ol>
		</div>
	</body></html>