<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Locomotion, Design, and Starting Our Project</h1>
                </header>
            
            <article>
                
<p>With our knowledge of the current state of VR <span>technology</span> and <span>game development</span>, we may now begin working on our first title. As we mentioned in <a href="926e8e71-f556-43b2-b4f8-47dc017c7a38.xhtml">Chapter 1</a>, <em>Introducing VR Technology in Unreal Engine 4</em>, <em>Server 17</em> puts the player in the role of an intrepid hacker in search of the truth in a corrupt dystopian future. Everyone has secrets, and some will pay big sums of money for the secrets of others. In design terms, this means we're going to create a puzzle game in which the player solves puzzles and uses different tools to crack open different puzzle boxes that represent computer servers on a network. Through the building of this simple game, we'll address all of the steps of VR game design with the goal of arming you with the tools and know-how to begin work on your own title. The first step in the process is design and, for that, I always turn to the Human-Centered Design process.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>The Human-Centered Design process</li>
<li>Choosing our locomotion method</li>
<li>Setting up new game files in Unreal Engine 4</li>
<li>Project setup</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Human-Centered Design process</h1>
                </header>
            
            <article>
                
<p><span>The <strong>Human-Centered Design</strong> (<strong>HCD</strong>) process is a flexible set of design principles that allows for the design of pretty much anything, from shoes, to cars, to software. Central to HCD is the principle that the designer is thinking of the end user at every step of the way. Would this decision make the product better for my user? Would making the color customizable delight my user and make them more likely to use my product? By asking these questions and thinking about your user, you're able to create a design that's more likely to be a success with its target audience.</span></p>
<p>The HCD process has the following steps:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/e4b8cc87-48ca-43dc-9a12-063009a6456e.png" style="width:14.67em;height:13.58em;" width="1243" height="1149"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The HCD process</div>
<ol>
<li><strong>Discovery</strong>: In this, we research the problem we're presented with and the target demographic interested in our solution. We search to see whether this is something that someone has attempted to solve before and if so what they tried. We reach out to our potential users to find people who will talk to us so we can discover what they need from a solution.</li>
<li><strong>Empathy</strong>: Here, we speak with as many potential users as possible to gather what they're looking for in a solution. We want to dig deep. Why is this something they want or need? Are there any connections back to a memory or an emotion? For example, nostalgia is a powerful longing for experiences related to a person's youth. It's also one of the strongest emotions that game developers like to touch on.</li>
<li><strong>Ideate</strong>: Once we know what our user wants, it's time to brainstorm! When we ideate, we want to come up with as many ideas as possible. No idea is too out there or crazy (as long as it benefits our user).</li>
<li><strong>Prototype</strong>: Once we settle on an idea, we want to build a quick and easy version to allow our user to try it. No fancy programming or incredible art here—we want to create a playable version of our game, quickly and cheaply.</li>
</ol>
<ol start="5">
<li><strong>Test</strong>: Put the prototype in front of the user and record the results! It's often at this point that a product may fail. This might be caused by a problem with the design or something that the user didn't understand or like. Record the data and learn from it!</li>
</ol>
<ol start="6">
<li><strong>Refine</strong>: With the user test data in hand, we go back to the ideate phase and try again. You'll likely go through this cycle several times before your game is complete, but if you're checking in with your user regularly and getting feedback from other designers and friends, you'll surely come up with the next killer app.</li>
</ol>
<p>For <em>Server 17</em>, our ideal user is someone who has never experienced VR before. They're interested in a simple, yet very immersive experience that leverages the unique abilities of VR. They may be fans of cyberpunk movies such as <em>Tron</em> and <em>Tron: Legacy</em> and the <em>Shadowrun</em> series of games. Nostalgia may also come into play when they think about their first experience with a new piece of gaming hardware. It's possible you have many friends who fit this profile that you can use as a reference while designing the game and we can also make use of online communities to gather further opinions. Once we've completed the <strong>Discovery</strong> and <strong>Empathy</strong> steps with a bit of research and some interviews with our user, we're now ready to make a few design decisions regarding locomotion, or the process of our player moving through our game world.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Choosing our locomotion method</h1>
                </header>
            
            <article>
                
<p>One of our goals as VR designers is to leverage the unique advantages of this new technology to create novel experiences that players want to play again and again. The technology is fantastic for making the player feel as if they're interacting in a living and breathing fantasy world they would otherwise not be able to inhabit. Using the hand controllers, our players can touch our world and interact with it in a very visceral sense. However, locomotion systems still haven't caught up to that level of immersion yet.</p>
<p>Player locomotion in VR is still in its infancy, and, as such, there's no one method that has been found to work well. Many methods have been tried. There are vehicle simulation games, where the player remains seated in a cockpit. There are action/adventure games where players run through a landscape using artificial methods such as a thumbstick or teleportation. Others attempt to maintain immersion by having the player stand within a small area with everything they need readily accessible, allowing the player to move around naturally but at the expense of an expansive environment. Each method of locomotion is a trade-off between giving the player an immersive, natural sensation and avoiding unpleasant feelings, such as VR sickness.</p>
<p> </p>
<p><span>During my time as a college professor, I had the opportunity to help my students to design a kayaking simulator for the local museum. The students devised a locomotion system that allowed the player to remain seated and use a paddle with an attached sensor to navigate their virtual craft down the river rapids. Though the system worked well in testing with their peers (it felt natural and worked well for me), we found that it had a profoundly negative affect on several of our users at the museum. One of our testers even had to leave work after testing our game. After asking the tester some questions, it was discovered that, although the paddle movement of our controller felt right, the realistic physics of the boat in the water made it impossible for them to play. Further questioning of the test group showed the students that this one tester wasn't the only player who had issues. In the end, they had to take some artistic license with the movement of the water to create a more enjoyable experience and learned that our user's experience and enjoyment was more important than realism. </span></p>
<p>While this lack of a best practice may be concerning to some, the designer in us all should see this as an exciting opportunity to innovate and create new systems that provide our players with the best gameplay possible. T<span>he variety of systems can be broken down into four major categories:</span></p>
<ul>
<li>Natural</li>
<li>Artificial</li>
<li>Cockpit</li>
<li>Physical (creative)</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Natural locomotion</h1>
                </header>
            
            <article>
                
<p>Not to be confused with the app of the same name, natural locomotion refers to a method of moving within VR that minimizes VR sickness by taking natural player movements, such as swinging arms and jumping, into the game world. We can see natural locomotion at work in the game <em>Tribe XR</em> as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/8db7f30c-fc76-412a-9dd0-8ec572963672.png" style="width:26.08em;height:14.67em;" width="1400" height="788"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Tribe XR is an up and coming DJ app that can teach you how to mix music with in-game lessons</div>
<p>This covers a variety of methods, but all seem to provide the player with a direct translation of their movement into player movement in the game. Though this method has been shown to limit player discomfort, it isn't without its drawbacks. This approach limits the player to the space covered by their system's sensors and requires designers to design with this in mind. This can mean designing the level specifically around the average playspace size and making sure that everything the player needs is well within reach. This method has been used in such games as <em>Job Simulator</em>, <em>Tribe VR</em>, and <em>Waltz of the Wizard</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Artificial locomotion</h1>
                </header>
            
            <article>
                
<p>Artificial locomotion is essentially the opposite of natural locomotion. This technique relies on more traditional game controls such as thumbsticks, touch pads, and other input methods to move the player around our game levels.</p>
<p>Despite being the best locomotion when porting traditional titles to VR (think <em>Skyrim VR</em> and <em>Fallout 4 VR</em>), artificial locomotion has the greatest chance of causing VR sickness due to vexation, or the disconnect between what our eyes are seeing and what the rest of the senses are experiencing. There are several techniques we can use to minimize this vexation. One way is to dynamically decrease the player's field of view while they're moving. This creates a very subtle effect that hides some of the player's peripheral vision when they're moving or turning. Another is to have the player accelerate at a consistent rate during movement. Consistent acceleration puts less pressure on the vestibular system—the portion of our brain that senses acceleration. The same principle can be applied to rotation. Consistent slow turning or snap turning can feel better to a player. The final technique I would like to mention is teleportation. Teleportation is a great way to allow a player to navigate large environments without VR sickness. However, this method doesn't feel very natural depending on the game's story and setting.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Cockpit locomotion </h1>
                </header>
            
            <article>
                
<p>Similar to natural locomotion, cockpit locomotion allows for very natural movement for games such as space sims, vehicle racing, and other games that have the player sitting in a vehicle.</p>
<p>By tricking the body into thinking that movement is similar to riding in a car, we can bypass many of the causes of VR sickness. The downside to this method is that it isn't applicable to most situations. Games that use this method successfully include <em>Elite: Dangerous</em>, <em>Star Trek Bridge Crew</em>, and <em>Archangel: Hellfire</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Physical locomotion</h1>
                </header>
            
            <article>
                
<p>Physical locomotion systems refer to unique movement control schemes that tend to be designed for the specific game experiences they're applied to. Because of this, they tend to be some of the most innovative ideas that we see in the VR space today.</p>
<p>This type of locomotion covers purpose built movement methods such as the kayak paddle system built by my students, as well as hand-over-hand climbing, running in place while swinging the controllers, swimming motions, and flying by moving the player's arms. Because the player is making specific arm or body movements, they tend to feel a very high rate of immersion while experiencing very little VR sickness. These systems aren't without disadvantages. Some players may find the movement silly or gimmicky. They're also not usually usable outside their specific game. Games that have successfully implemented this type of locomotion include <em>The Climb</em>, <em>Eagle Flight</em>, and the spell casting mechanic found in <em>Waltz of the Wizard</em>.</p>
<p>Taking into account what we know about our user (new to VR, looking for immersive and visceral experiences, and fans of cyberpunk), what type or types of locomotion would be best here? For the new user, natural locomotion seems as though it would work the best, since it tends to be intuitive and works well for maintaining immersion. So that we aren't limiting our level design to just the player's defined play space, we can also choose to integrate teleportation into our control scheme. Despite its drawback of not being immersive, I feel that the cyberspace setting of our game would actually support the player teleporting around the level.</p>
<p>With these design decisions made, it's time to launch <strong>Unreal Engine 4</strong> (<strong>UE4</strong>) and set up our project files!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up new game files in UE4</h1>
                </header>
            
            <article>
                
<p>UE4 is a versatile collection of tools that helps you to create the game of your dreams. To get you started down that path, Epic Games provides a collection of starter projects to jump-start your games by setting up some of the most important features for you. This often includes player character, sample weapons, and other necessary files. In this book, we'll begin creating files within the Virtual Reality Starter project so that we can make use of some of the basic art assets that this project provides. Beyond that, I'll show you how to create the blueprints we'll need from scratch. </p>
<div class="packt_tip">Every game or software project needs to stay organized and we use <strong>naming conventions</strong> to do just that. A naming convention is a naming scheme and folder structure that ensures that every filename is standardized so that anyone in a particular game team can read a filename and understand exactly what they're looking at. You may have noticed it while browsing through some of the project files inside UE4. Epic Games provides its naming convention on the Unreal Wiki at <a href="https://wiki.unrealengine.com/Assets_Naming_Convention">https://wiki.unrealengine.com/Assets_Naming_Convention</a>, and we'll be using it throughout this book.</div>
<p>Any new game in Unreal needs certain blueprints created to customize the project to fit our needs. These files include the following:</p>
<ul>
<li><kbd>GameMode</kbd></li>
<li><kbd>GameState</kbd></li>
<li><kbd>PlayerPawn</kbd></li>
</ul>
<p>But how do all of these files interact, and why do we need them? When UE4 launches a game, the engine creates two files to help it understand what the rules of the game are before it loads and levels or players. These are <kbd>GameMode</kbd> and <kbd>GameState</kbd>. <kbd>GameMode</kbd> contains the rules that make our game unique, such as the total number of players and how those players connect to the game, as well as default settings, such as the default player pawn, player controller, and game state. By creating our own game mode, we're taking the first step toward customizing our project. The <kbd>GameState</kbd> file that's loaded after the game starts is designed to track everything that's important to our game, such as scores, missions completed, and other elements that are relevant to the game as a whole. This isn't for things that are player-specific, as there is a different player state. I've often used this as a place to store data needed to build levels in a procedural generation game, for example. Lastly, we'll need a custom <kbd>PlayerPawn</kbd>. <kbd>PlayerPawn</kbd> is the player's physical representation in the game and is possessed by our player during the game.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Project setup</h1>
                </header>
            
            <article>
                
<p>Before we can start creating our custom project files, we need to let Unreal create our project base and begin to lay out our folder structure. This will keep our files organized as we build <em>Server 17</em>. </p>
<p><span>Start by opening Unreal Engine 4.20.2 and starting a new project:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/8d8d56d8-75be-4ce2-83f2-37f5d156b8a8.png" style="width:75.58em;height:52.50em;" width="1500" height="1043"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The screen you're greeted with when you first open UE4</div>
<p>Welcome to the new project window. From here, we'll create our project based on the UR template:</p>
<ol>
<li>Choose the new project tab from the top of the screen.</li>
<li>Select the <span class="packt_screen">Blueprint</span> section.</li>
<li>Choose the <span class="packt_screen">Virtual Reality</span> template near the bottom of the list.</li>
</ol>
<p class="mce-root"/>
<p> </p>
<ol start="4">
<li>Change the middle project setting to <span class="packt_screen">Scalable 3D or 2D</span>.</li>
<li>Ensure the project folder is in a space you can find easily. Change the name to <kbd>VRQuickStart</kbd>.</li>
</ol>
<p>Smack that <span class="packt_screen">Create Project</span> button, and let's continue! Now take a look at the interface:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d149918f-85d6-4a77-9a0f-be10565488ec.png" width="1950" height="1097"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Much of the interaction with the game engine takes place in the Content Browser</div>
<p><span>With our new project open, look around the interface and locate your <span class="packt_screen">Content Browser</span>:</span></p>
<ol>
<li>It's time to get organized. One of the first steps is to create our own project folder similar to the <kbd>VirtualReality</kbd> and <kbd>VirtualRealityBP</kbd> folders Epic Games uses. Right-click on the <kbd>Content</kbd> folder inside the <span class="packt_screen">Content Browser</span> and select <span class="packt_screen">New Folder</span> from the top of the list. Name the new folder <kbd>Server17</kbd>.</li>
<li>Click on our new folder to enter it. Right-click in the <span class="packt_screen">Content Browser</span> and select <span class="packt_screen">New Folder</span>. Name it <kbd>Blueprints</kbd>. This will be the home of our new blueprints.</li>
</ol>
<p>As we continue with development, we'll add several more folders to our file structure to help to contain and organize our files. Remember to stick to our naming convention as we go, as this will be a huge help later when you're adding team members or coming back to your project after a leave of absence.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating our custom Game Mode</h1>
                </header>
            
            <article>
                
<p>With our project base and our file structure established, let's create our first custom file: our <kbd>GameMode</kbd> file. Click on our new <kbd>Blueprints</kbd> folder, and right-click to bring up the menu. From the <span class="packt_screen">Create Basic Asset</span> section, choose <span class="packt_screen">Blueprint Class</span>. This will bring up the <span class="packt_screen">Pick Parent Class</span> menu, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d76237df-1cf6-4837-ac62-a006b5c06e30.png" style="width:32.92em;height:22.08em;" width="1659" height="1111"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">From the Pick Parent Class menu, we can create a new file that extends the functionality of a parent file</div>
<p>It's time to extend the basic <kbd>GameMode</kbd> class and tell our project to use our new file:</p>
<ol>
<li>From the <span class="packt_screen">Pick Parent Class</span> menu, we can extend any basic class that the engine has to offer. Click the <span class="packt_screen">Game Mode Base</span> button, and name the new file <kbd>S17GameMode</kbd>.</li>
<li>Simply creating <kbd>GameMode</kbd> isn't enough for the engine to recognize it within our project. To ensure that it's used, click on the <span class="packt_screen">Settings</span> button of the viewport and select <span class="packt_screen">Project</span> <span class="packt_screen">settings</span>.</li>
</ol>
<div style="padding-left: 90px" class="packt_tip">Alternately, we could have opened up the <span class="packt_screen">World Settings</span> and navigated down to the <span class="packt_screen">Game Mode</span> section of the menu, and then clicked the <em>+</em> button next to the <span class="packt_screen">GameMode Override</span>. Much like doing math or most creative pursuits, there's more than one way to create something inside Unreal. What I'm sharing are the methods and processes that I've learned in my career. If you find a different way or a better way to do any of the things that I talk about in this book, feel free to share them with me and the UE4 development community!</div>
<p style="padding-left: 60px">Check out the <span class="packt_screen">Project</span> <span class="packt_screen">settings</span> menu:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/cdc6b332-f61b-43a9-af0f-da44990607f5.png" style="width:84.33em;height:38.25em;" width="1535" height="695"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"> Project settings</div>
<ol start="3">
<li>Under the <span class="packt_screen">Project</span> section of the menu, select <span class="packt_screen">Maps &amp; Modes</span>. This section of the menu allows you to specify the default map that opens when the editor opens, as well as define the default <kbd>GameMode</kbd>.</li>
<li>In the <span class="packt_screen">Default Modes</span> section of the menu, use the <span class="packt_screen">Default GameMode</span> drop-down menu and select <span class="packt_screen">S17GameMode</span>.</li>
</ol>
<p>With the <span class="packt_screen">S17GameMode</span> set as our default, we can now begin to create the rest of our custom project files. We'll come back to the <span class="packt_screen">Projects</span> setting screen and change the defaults further once we have the rest of our pieces in place.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a GameState</h1>
                </header>
            
            <article>
                
<p>Where <kbd>GameMode</kbd> is great for setting our game specific rules and storing our mode defaults, <kbd>GameState</kbd> is there to store our important level-wide elements. Similar to when we created our <kbd>GameMode</kbd> class, we'll need to extend a <kbd>GameState</kbd> class as the base for our custom state. Let's go back to the <span class="packt_screen">Pick Parent Class</span> menu:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/a43ddc81-0aa8-4f9f-a082-03ba06919da4.png" style="width:38.83em;height:41.67em;" width="534" height="573"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Extending GameStateBase to create our custom GameState class</div>
<p>Yet, unlike our <kbd>GameMode</kbd>, we're going to extend the <kbd>GameStateBase</kbd> class, or the class from which all <kbd>GameState</kbd> files extend:</p>
<ol>
<li>Right-click in the <span class="packt_screen">Content Browser</span> and select the <span class="packt_screen">Blueprint Class</span> from the <span class="packt_screen">Create Basic Asset</span> section of the menu.</li>
<li>From the <span class="packt_screen">Pick Parent Class</span> menu, we're going to skip the top portion of the menu that lists many of the common extended classes and select the <span class="packt_screen">All Classes</span> collapsed menu.</li>
<li>This will show us all of the classes that we can extend within the engine. Use the search box to find the <span class="packt_screen">GameStateBase</span> and select it. Then, press the <span class="packt_screen">Select</span> button at the bottom of the menu.</li>
<li>Name our new game state <kbd>S17GameState</kbd>.</li>
</ol>
<div class="packt_infobox">A discussion of the interaction between <kbd>GameMode</kbd>, <kbd>GameState</kbd>, and individual <kbd>PlayerStates</kbd> in the context of single and multiplayer games.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a custom PlayerPawn</h1>
                </header>
            
            <article>
                
<p>Now that we have two different files to help with managing the information and variables that will be present in our level, it's time to build our <kbd>PlayerPawn</kbd>, or the physical representation of our player. <kbd>PlayerPawn</kbd> takes in information from the headset and hand controllers and translates that into movement and action within the game. Depending on how we choose to represent our player, there are several different directions we can go in:</p>
<ul>
<li><strong>First-person format</strong>: The player has no avatar. The hands and head float in the air.</li>
<li><strong>First person with arms</strong>: Using inverse kinematics, we're able to give the player arms that move with the location of the hand controllers. However, the head still floats.</li>
</ul>
<ul>
<li><strong>First person with full body</strong>: Similar to the first person with arms setup, this allows the player to be represented by a full body, with inverse kinematics used for both the hands and the head.</li>
<li><strong>Third person</strong>: A full third-person character with the player looking down on it from a camera set above and behind the player model. This option has been known to limit VR sickness but at the cost of immersion. This player setup has been successfully used in some games when used in conjunction with a first-person option—for example: the first-person view is used when the player is shooting and performing actions, but the third-person view is used when the player is moving.</li>
</ul>
<p>For <em>Server 17</em>, the player takes on the role of a cyberpunk hacker trying to break into a server to find encrypted file data to steal. Set in the future, and the player and the server interact inside a virtual environment created by the player's hacking hardware. For this reason, we can represent the player using the basic first-person format without sacrificing the experience. This method will also help with keeping our game optimized.</p>
<p>Though we could use the Motion Controller Pawn that's supplied with the template we're using, let's go ahead and create one from scratch. Start by creating a new <kbd>Pawn</kbd> class for us to use:</p>
<ol>
<li>Right-click in the <span class="packt_screen">Content Browser</span> within our <kbd>Blueprints</kbd> folder and select <span class="packt_screen">Blueprint Class</span> from the <span class="packt_screen">New Basic Asset</span> section of the menu.</li>
<li>We want to create a new <span class="packt_screen">Pawn</span> for our player to possess or to receive controller input data. Select <span class="packt_screen">Pawn</span> from the menu and name it <kbd>S17PlayerPawn</kbd>. Double-click the new <span class="packt_screen">Pawn</span> to open the interface, as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/bb41e610-aa1f-4a51-b49a-5a431e9b6da9.png" width="1950" height="1058"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The open Pawn class with components showing</div>
<ol start="3">
<li>First, we'll add a scene component to our player to act as a root object for our camera. In the top-left of the <span class="packt_screen">Blueprint</span> interface, in the <span class="packt_screen">Components</span> panel of the menu, click on the <span class="packt_screen">Add Component</span> button and search for a <span class="packt_screen">Scene Component</span>. Create it and name it <kbd>HMDRoot</kbd>.</li>
<li>It's time to add our player camera as a child of our new <span class="packt_screen">Scene</span> object. With <kbd>HMDRoot</kbd> selected, go back to the <span class="packt_screen">Add Component</span> button and find a <span class="packt_screen">Camera</span> object. Create it and name it <kbd>HMDCam</kbd>.</li>
<li>Now we need to create a way to track our player's motion controllers so that the hands of our player character move and act appropriately. With <kbd>HMDRoot</kbd> selected, create a <span class="packt_screen">Motion Controller</span> component with the <span class="packt_screen">Add Component</span> menu and name it <kbd>MotionController_L</kbd>.</li>
</ol>
<p> </p>
<ol start="6">
<li>Repeat the preceding steps to create another <span class="packt_screen">Motion Controller</span> component and name it <kbd>MotionController_R</kbd>. The <span class="packt_screen">Details</span> panel will look like this:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/3748807f-78bd-4a75-8ea4-a2d8a2f9085a.png" style="width:29.08em;height:49.75em;" width="1141" height="1950"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">MotionController_R settings</div>
<ol start="7">
<li>With our <span><kbd>MotionController_R</kbd> component selected, look over at the <span class="packt_screen">Details</span> panel and find the <span class="packt_screen">Motion Controller</span> section of the menu. Change the <span class="packt_screen">Motion Source</span> option to <span class="packt_screen">Right</span>.</span></li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Programming our custom PlayerPawn</h1>
                </header>
            
            <article>
                
<p>Let's move on to a bit of programming to ensure that our PlayerPawn is used and set up correctly for our player's hardware. Unreal needs to know where to set the Tracking Origin, or where to set the default height of the player, which can vary depending on your equipment. For the HTC Vive, the default is to target standing VR experiences by using a tracking origin set to the floor. The Oculus Rift, on the other hand, is set to target sitting VR experiences by default and uses an eye-level tracking origin. It might be easy to simply just set things up for the Vive, knowing that this is the platform we're targeting, but I want to create something that might be reusable outside just this project. We'll add the following to our PlayerPawn's Event Graph:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/e19ad995-eea0-4a5e-9be2-13f0fff1dbfa.png" width="1806" height="591"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">PlayerPawn Event Graph</div>
<p><span>To do this, we'll detect what hardware the player might be using and set the Tracking Origin based on our player's equipment:</span></p>
<ol>
<li>Click on the <span class="packt_screen">Event Graph</span> tab in the center of our <kbd>S17PlayerPawn</kbd> and drag an execute line out of the <span class="packt_screen">Event BeginPlay</span> node.</li>
<li>Drop it and select the <span class="packt_screen">Switch on Name</span> node. <span class="packt_screen">Switch on Name</span> is a flow-control node, which means that it restricts and directs the flow of execution through the blueprint. This node will direct the blueprint to set the tracking origin based on the HMD hardware found.</li>
</ol>
<ol start="3">
<li>Drag off the <span class="packt_screen">Selection</span> input on the <span class="packt_screen">Switch on Name</span> node. Use the search box to find <span class="packt_screen">Get</span> <span class="packt_screen">HMD Device Name</span>. This node represents a function designed to fetch the name of the player's HMD hardware.</li>
<li>On the <span><span class="packt_screen">Switch on Name</span> node, click the <span class="packt_screen">Add Pin</span> button two times. In the <span class="packt_screen">Details</span> panel, name the pins <span class="packt_screen">OculusHMD</span> and <span class="packt_screen">SteamVR</span>. Also in the <span class="packt_screen">Details</span> panel, turn off the option has <span class="packt_screen">Default Pin</span>.</span></li>
<li>Now let's set the criteria for each of our hardware options. Drag off the <span class="packt_screen">OculusHMD</span> pin and search for the <span class="packt_screen">Set Tracking Origin</span> node. Select it, and use the drop-down box on the node to select <span class="packt_screen">Eye Level</span> tracking.</li>
<li>Drag off the <span class="packt_screen">SteamVR</span> pin, and create another <span class="packt_screen">Set Tracking</span> origin node. This time, we'll set it to <span class="packt_screen">Floor Level</span> tracking.</li>
<li>Now click the <span class="packt_screen">Save</span> button, so you don't lose your work.</li>
</ol>
<p>With our tracking origin in place, we can now go back into our project settings and tell <kbd>S17GameMode</kbd> to use our <kbd>S17PlayerPawn</kbd> as our Default Player Pawn.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>At the beginning of this chapter, we learned one of the best ways to design with a particular type of user in mind: the HCD process. When using HCD, we always want to keep our player in mind as we make each design decision, ensuring that the game we create meets every one of our player's expectations and is a delight to play. This is our goal for <em>Server 17</em>. With a few of our design decisions in place, we then created our project and began to customize our files by creating our custom <kbd>GameMode</kbd>, <kbd>GameState</kbd>, and <kbd>PlayerPawn</kbd> files. </p>
<p>In the next chapter, we'll further flesh out the design for <em>Server 17</em> and look at the different types of gameplay that are popular in today's current VR market. Specifically, we'll focus on gameplay that takes advantage of the unique input methods and immersive qualities that VR has to offer and how we can apply those to our own game. In the end, we'll decide how our game will work and begin building those systems. Soon, we'll have a working prototype that we can show off to our players!</p>


            </article>

            
        </section>
    </div>



  </body></html>