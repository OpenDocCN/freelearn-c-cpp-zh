["```cpp\nQTcpServer* tcpServer = new QTcpServer(this); \ntcpServer->listen(QHostAddress::Any, 5000); \n\nconnect(tcpServer, &QTcpServer::newConnection, [tcpServer] { \n    QTcpSocket *tcpSocket = tcpServer->nextPendingConnection(); \n    QByteArray response = QString(\"Hello\").toLatin1(); \n    tcpSocket->write(response); \n    tcpSocket->disconnectFromHost(); \n    qDebug() << \"Send response and close the socket\"; \n}); \n\n```", "```cpp\nQTcpSocket *tcpSocket = new QTcpSocket(this); \ntcpSocket->connectToHost(\"127.0.0.1\", 5000); \n\nconnect(tcpSocket, &QTcpSocket::connected, [tcpSocket] { \n    qDebug() << \"connected\"; \n}); \nconnect(tcpSocket, &QTcpSocket::readyRead, [tcpSocket] { \n    qDebug() << QString::fromLatin1(tcpSocket->readAll()); \n}); \nconnect(tcpSocket, &QTcpSocket::disconnected, [tcpSocket] { \n    qDebug() << \"disconnected\"; \n}); \n\n```", "```cpp\nQString sharedMessage(\"Hello\"); \nQByteArray sharedData = sharedMessage.toLatin1(); \n\nQSharedMemory* sharedMemory = new QSharedMemory( \n    \"sharedMemoryKey\", this); \nsharedMemory->create(sharedMessage.size()); \n\nsharedMemory->lock(); \n\nmemcpy(sharedMemory->data(), \n       sharedData.data(), \n       sharedData.size()); \n\nsharedMemory->unlock(); \n\n```", "```cpp\nQSharedMemory* sharedMemory = new QSharedMemory( \n    \"sharedMemoryKey\", this); \nsharedMemory->attach(); \n\nsharedMemory->lock(); \n\nQByteArray sharedData(sharedMemory->size(), '\\0'); \n\nmemcpy(sharedData.data(), \n       sharedMemory->data(), \n       sharedMemory->size()); \nsharedMemory->unlock(); \n\nQString sharedMessage = QString::fromLatin1(sharedData); \nqDebug() << sharedMessage; \n\nsharedMemory->detach(); \n\n```", "```cpp\nQTextStream out(stdout); \nQTextStream in(stdin); \n\nout << QString(\"Please enter your name:\\n\"); \nout.flush(); \n\nQString name = in.readLine(); \n\nout << \"Hello \" << name << \"\\n\"; \nreturn 0; \n\n```", "```cpp\nQProcess* childProcess = new QProcess(this); \n\nconnect(childProcess,  \n    &QProcess::readyReadStandardOutput, [childProcess] { \n        qDebug().noquote() << \"[*]\" << childProcess->readAll(); \n}); \n\nconnect(childProcess, &QProcess::started, [childProcess] { \n    childProcess->write(\"Sophie\\n\"); \n}); \n\nchildProcess->start(\"/path/to/hello\"); \n\n```", "```cpp\n[*] Please enter your name: \n[*] Hello Sophie \n\n```", "```cpp\n//HelloService.h \nclass HelloService : public QObject \n{ \n    Q_OBJECT \n\npublic slots: \n    QString sayHello(const QString &name); \n}; \n\n//HelloService.cpp \nQString HelloService::sayHello(const QString& name) \n{ \n    qDebug().noquote() << name << \" is here!\"; \n    return QString(\"Hello %1!\").arg(name);; \n} \n\n```", "```cpp\nHelloService helloService; \nQString serviceName(\"org.masteringqt.QtDBus.HelloService\"); \n\nQDBusConnection::sessionBus().registerService(serviceName); \nQDBusConnection::sessionBus().registerObject(\"/\",  \n    &helloService, QDBusConnection::ExportAllSlots); \n\n```", "```cpp\nQString serviceName(\"org.masteringqt.QtDBus.HelloService\"); \nQDBusInterface serviceInterface(serviceName, \"/\"); \nQDBusReply<QString> response = serviceInterface.call( \n    \"sayHello\", \"Lenna\"); \nqDebug().noquote() << response; \n\n```", "```cpp\n//service application output \nLenna is here! \n\n//client application output \nHello Lenna! \n\n```", "```cpp\n#include <QByteArray> \n\nstruct Message { \n\n    enum class Type { \n        WORKER_REGISTER, \n        WORKER_UNREGISTER, \n        ALL_JOBS_ABORT, \n        JOB_REQUEST, \n        JOB_RESULT, \n    }; \n\n    Message(const Type type = Type::WORKER_REGISTER, \n            const QByteArray& data = QByteArray()) : \n        type(type), \n        data(data) \n    { \n    } \n\n    ~Message() {} \n\n    Type type; \n    QByteArray data; \n};  \n\n```", "```cpp\nOTHER_FILES += \\ \nsdk/Message.h \n\n```", "```cpp\n#include <QSize> \n#include <QPointF> \n\nstruct JobRequest \n{ \n    int pixelPositionY; \n    QPointF moveOffset; \n    double scaleFactor; \n    QSize areaSize; \n    int iterationMax; \n}; \n\nQ_DECLARE_METATYPE(JobRequest) \n\n// In ch10-mandelbrot-ipc \nOTHER_FILES += \\ \n    sdk/Message.h \\ \n    sdk/JobRequest.h \n\n```", "```cpp\n#include <QSize> \n#include <QVector> \n#include <QPointF> \n\nstruct JobResult \n{ \n    JobResult(int valueCount = 1) : \n        areaSize(0, 0), \n        pixelPositionY(0), \n        moveOffset(0, 0), \n        scaleFactor(0.0), \n        values(valueCount) \n    { \n    } \n\n    QSize areaSize; \n    int pixelPositionY; \n    QPointF moveOffset; \n    double scaleFactor; \n\n    QVector<int> values; \n}; \n\nQ_DECLARE_METATYPE(JobResult) \n\n// In ch10-mandelbrot-ipc \nOTHER_FILES += \\ \n    sdk/Message.h \\ \n    sdk/JobRequest.h \\ \n    sdk/JobResult.h \n\n```", "```cpp\nQFile file(\"myfile\"); \nfile.open(QIODevice::WriteOnly); \nQDataStream out(&file); \nout << QString(\"QDataStream saved my day\"); \nout << (qint32)42; \n\n```", "```cpp\nQDataStream& operator<<(QDataStream& out,  \n                        const JobRequest& jobRequest) \n\n```", "```cpp\n#include <QSize> \n#include <QPointF> \n#include <QDataStream> \n\nstruct JobRequest \n{ \n   ... \n}; \n\ninline QDataStream& operator<<(QDataStream& out,  \n                               const JobRequest& jobRequest) \n{ \n    out << jobRequest.pixelPositionY \n        << jobRequest.moveOffset \n        << jobRequest.scaleFactor \n        << jobRequest.areaSize \n        << jobRequest.iterationMax; \n    return out; \n} \n\ninline QDataStream& operator>>(QDataStream& in,  \n                               JobRequest& jobRequest) \n{ \n    in >> jobRequest.pixelPositionY; \n    in >> jobRequest.moveOffset; \n    in >> jobRequest.scaleFactor; \n    in >> jobRequest.areaSize; \n    in >> jobRequest.iterationMax; \n    return in; \n} \n\n```", "```cpp\n#include <QByteArray> \n#include <QDataStream> \n\n#include <QByteArray> \n#include <QDataStream> \n\nstruct Message { \n    ... \n}; \n\ninline QDataStream &operator<<(QDataStream &out, const Message &message) \n{ \n    out <<  static_cast<qint8>(message.type) \n        << message.data; \n    return out; \n} \n\ninline QDataStream &operator>>(QDataStream &in, Message &message) \n{ \n    qint8 type; \n    in >> type; \n    in >> message.data; \n\n    message.type = static_cast<Message::Type>(type); \n    return in; \n} \n\n```", "```cpp\n#include <QByteArray> \n#include <QTcpSocket> \n#include <QDataStream> \n\n#include \"Message.h\" \n\nnamespace MessageUtils { \n\ninline void sendMessage(QTcpSocket& socket, \n                        Message::Type messageType, \n                        QByteArray& data, \n                        bool forceFlush = false) \n{ \n    Message message(messageType, data); \n\n    QByteArray byteArray; \n    QDataStream stream(&byteArray, QIODevice::WriteOnly); \n    stream << message; \n    socket.write(byteArray); \n    if (forceFlush) { \n        socket.flush(); \n    } \n} \n\n```", "```cpp\ninline void sendMessage(QTcpSocket& socket, \n                        Message::Type messageType, \n                        bool forceFlush = false) { \n    QByteArray data; \n    sendMessage(socket, messageType, data, forceFlush); \n} \n\n```", "```cpp\nin.startTransaction(); \nqint8 messageType; \nQByteArray messageData; \nin >> messageType >> messageData; \n\nif (!in.commitTransaction()) \n    return; \n\n```", "```cpp\n#include <memory> \n#include <vector> \n#include <QByteArray> \n#include <QTcpSocket> \n#include <QDataStream> \n\n#include \"Message.h\" \n\n... \n\ninline std::unique_ptr<std::vector<std::unique_ptr<Message>>> readMessages(QDataStream& stream) \n{ \n    auto messages = std::make_unique<std::vector<std::unique_ptr<Message>>>(); \n    bool commitTransaction = true; \n    while (commitTransaction \n                    && stream.device()->bytesAvailable() > 0) { \n        stream.startTransaction(); \n        auto message = std::make_unique<Message>(); \n        stream >> *message; \n        commitTransaction = stream.commitTransaction(); \n        if (commitTransaction) { \n            messages->push_back(std::move(message)); \n        } \n    } \n    return messages; \n} \n\n} \n\n```", "```cpp\n#include <QObject> \n#include <QRunnable> \n#include <QAtomicInteger> \n\n#include \"JobRequest.h\" \n#include \"JobResult.h\" \n\nclass Job : public QObject, public QRunnable \n{ \n    Q_OBJECT \npublic: \n    explicit Job(const JobRequest& jobRequest,  \n                 QObject *parent = 0); \n    void run() override; \n\nsignals: \n    void jobCompleted(JobResult jobResult); \n\npublic slots: \n    void abort(); \n\nprivate: \n    QAtomicInteger<bool> mAbort; \n    JobRequest mJobRequest; \n}; \n\n```", "```cpp\n#include <QObject> \n#include <QTcpSocket> \n#include <QDataStream> \n\n#include \"Message.h\" \n#include \"JobResult.h\" \n\nclass Worker : public QObject \n{ \n    Q_OBJECT \npublic: \n    Worker(QObject* parent = 0); \n    ~Worker(); \n\nprivate: \n    void sendRegister(); \n\nprivate: \n    QTcpSocket mSocket; \n}; \n\n```", "```cpp\n#include \"Worker.h\" \n\n#include <QThread> \n#include <QDebug> \n#include <QHostAddress> \n\n#include \"JobRequest.h\" \n#include \"MessageUtils.h\" \n\nWorker::Worker(QObject* parent) : \n    QObject(parent), \n    mSocket(this) \n{ \n    connect(&mSocket, &QTcpSocket::connected, [this] { \n        qDebug() << \"Connected\"; \n        sendRegister(); \n    }); \n    connect(&mSocket, &QTcpSocket::disconnected, [] { \n        qDebug() << \"Disconnected\"; \n    }); \n\n    mSocket.connectToHost(QHostAddress::LocalHost, 5000); \n} \n\n```", "```cpp\nvoid Worker::sendRegister() \n{ \n    QByteArray data; \n    QDataStream out(&data, QIODevice::WriteOnly); \n    out << QThread::idealThreadCount(); \n    MessageUtils::sendMessage(mSocket, \n                              Message::Type::WORKER_REGISTER, \n                              data); \n} \n\n```", "```cpp\nclass Worker : public QObject \n{ \n    ... \nsignals: \n    void abortAllJobs(); \n\nprivate slots: \n    void readMessages(); \n\nprivate: \n    void handleJobRequest(Message& message); \n    void handleAllJobsAbort(Message& message); \n    void sendRegister(); \n    void sendJobResult(JobResult jobResult); \n    void sendUnregister(); \n    Job* createJob(const JobRequest& jobRequest); \n\nprivate: \n    QTcpSocket mSocket; \n    QDataStream mSocketReader; \n    int mReceivedJobsCounter; \n    int mSentJobsCounter; \n}; \n\n```", "```cpp\nWorker::Worker(QObject* parent) : \n    QObject(parent), \n    mSocket(this), \n    mSocketReader(&mSocket), \n    mReceivedJobsCounter(0), \n    mSentJobsCounter(0) \n{ \n    ... \n    connect(&mSocket, &QTcpSocket::readyRead, \n            this, &Worker::readMessages); \n\n    mSocket.connectToHost(QHostAddress::LocalHost, 5000); \n} \n\n```", "```cpp\nvoid Worker::readMessages() \n{ \n    auto messages = MessageUtils::readMessages(mSocketReader); \n    for(auto& message : *messages) { \n        switch (message->type) { \n            case Message::Type::JOB_REQUEST: \n                handleJobRequest(*message); \n                break; \n            case Message::Type::ALL_JOBS_ABORT: \n                handleAllJobsAbort(*message); \n                break; \n            default: \n                break; \n        } \n    } \n} \n\n```", "```cpp\nvoid Worker::handleJobRequest(Message& message) \n{ \n     QDataStream in(&message.data, QIODevice::ReadOnly); \n     QList<JobRequest> requests; \n     in >> requests; \n\n     mReceivedJobsCounter += requests.size(); \n     for(const JobRequest& jobRequest : requests) { \n         QThreadPool::globalInstance() \n                    ->start(createJob(jobRequest)); \n     } \n} \n\n```", "```cpp\nJob* Worker::createJob(const JobRequest& jobRequest) \n{ \n    Job* job = new Job(jobRequest); \n    connect(this, &Worker::abortAllJobs, \n            job, &Job::abort); \n    connect(job, &Job::jobCompleted, \n            this, &Worker::sendJobResult); \n    return job; \n} \n\n```", "```cpp\nvoid Worker::sendJobResult(JobResult jobResult) \n{ \n    mSentJobsCounter++; \n    QByteArray data; \n    QDataStream out(&data, QIODevice::WriteOnly); \n    out << jobResult; \n    MessageUtils::sendMessage(mSocket, \n                              Message::Type::JOB_RESULT, \n                              data); \n} \n\n```", "```cpp\nvoid Worker::handleAllJobsAbort(Message& /*message*/) \n{ \n    emit abortAllJobs(); \n    QThreadPool::globalInstance()->clear(); \n    mReceivedJobsCounter = 0; \n    mSentJobsCounter = 0; \n} \n\n```", "```cpp\nWorker::~Worker() \n{ \n    sendUnregister(); \n} \n\nvoid Worker::sendUnregister() \n{ \n    MessageUtils::sendMessage(mSocket, \n                              Message::Type::WORKER_UNREGISTER, \n                              true); \n} \n\n```", "```cpp\n#include <QWidget> \n#include <QThread> \n#include <QProgressBar> \n#include <QTimer> \n\n#include \"Worker.h\" \n\nclass WorkerWidget : public QWidget \n{ \n    Q_OBJECT \npublic: \n    explicit WorkerWidget(QWidget *parent = 0); \n    ~WorkerWidget(); \n\nprivate: \n    QProgressBar mStatus; \n    Worker mWorker; \n    QThread mWorkerThread; \n    QTimer mRefreshTimer; \n}; \n\n```", "```cpp\n#include \"WorkerWidget.h\" \n\n#include <QVBoxLayout> \n\nWorkerWidget::WorkerWidget(QWidget *parent) : \n    QWidget(parent), \n    mStatus(this), \n    mWorker(), \n    mWorkerThread(this), \n    mRefreshTimer() \n{ \n    QVBoxLayout* layout = new QVBoxLayout(this); \n    layout->addWidget(&mStatus); \n\n    mWorker.moveToThread(&mWorkerThread); \n\n    connect(&mRefreshTimer, &QTimer::timeout, [this] { \n        mStatus.setMaximum(mWorker.receivedJobsCounter()); \n        mStatus.setValue(mWorker.sentJobCounter()); \n    }); \n\n    mWorkerThread.start(); \n    mRefreshTimer.start(100); \n} \n\nWorkerWidget::~WorkerWidget() \n{ \n    mWorkerThread.quit(); \n    mWorkerThread.wait(1000); \n} \n\n```", "```cpp\n#include <QApplication> \n\n#include \"JobResult.h\" \n\n#include \"WorkerWidget.h\" \n\nint main(int argc, char *argv[]) \n{ \n    qRegisterMetaType<JobResult>(); \n\n    QApplication a(argc, argv); \n    WorkerWidget workerWidget; \n\n    workerWidget.show(); \n    return a.exec(); \n} \n\n```", "```cpp\n#include <QTcpSocket> \n#include <QList> \n#include <QDataStream> \n\n#include \"JobRequest.h\" \n#include \"JobResult.h\" \n#include \"Message.h\" \n\nclass WorkerClient : public QObject \n{ \n    Q_OBJECT \npublic: \n    WorkerClient(int socketDescriptor); \n\nprivate: \n    int mSocketDescriptor; \n    int mCpuCoreCount; \n    QTcpSocket mSocket; \n    QDataStream mSocketReader; \n}; \n\nQ_DECLARE_METATYPE(WorkerClient*) \n\n```", "```cpp\nclass WorkerClient : public QObject \n{ \n    Q_OBJECT \npublic: \n    WorkerClient(int socketDescriptor); \n    int cpuCoreCount() const; \n\nsignals: \n    void unregistered(WorkerClient* workerClient); \n    void jobCompleted(WorkerClient* workerClient,  \n                      JobResult jobResult); \n    void sendJobRequests(QList<JobRequest> requests); \n\npublic slots: \n    void start(); \n    void abortJob(); \n\nprivate slots: \n    void readMessages(); \n    void doSendJobRequests(QList<JobRequest> requests); \n\nprivate: \n    void handleWorkerRegistered(Message& message); \n    void handleWorkerUnregistered(Message& message); \n    void handleJobResult(Message& message); \n\n    ... \n}; \n\n```", "```cpp\n#include \"MessageUtils.h\" \n\nWorkerClient::WorkerClient(int socketDescriptor) : \n    QObject(), \n    mSocketDescriptor(socketDescriptor), \n    mSocket(this), \n    mSocketReader(&mSocket) \n{ \n    connect(this, &WorkerClient::sendJobRequests, \n            this, &WorkerClient::doSendJobRequests); \n} \n\n```", "```cpp\nvoid WorkerClient::start() \n{ \n    connect(&mSocket, &QTcpSocket::readyRead,  \n            this, &WorkerClient::readMessages); \n    mSocket.setSocketDescriptor(mSocketDescriptor); \n} \n\n```", "```cpp\nvoid WorkerClient::readMessages() \n{ \n    auto messages = MessageUtils::readMessages(mSocketReader); \n    for(auto& message : *messages) { \n        switch (message->type) { \n            case Message::Type::WORKER_REGISTER: \n                handleWorkerRegistered(*message); \n                break; \n            case Message::Type::WORKER_UNREGISTER: \n                handleWorkerUnregistered(*message); \n                break; \n            case Message::Type::JOB_RESULT: \n                handleJobResult(*message); \n                break; \n            default: \n                break; \n        } \n    } \n} \n\n```", "```cpp\nvoid WorkerClient::handleWorkerRegistered(Message& message) \n{ \n    QDataStream in(&message.data, QIODevice::ReadOnly); \n    in >> mCpuCoreCount; \n} \n\n```", "```cpp\nvoid WorkerClient::handleWorkerUnregistered(Message& /*message*/) \n{ \n    emit unregistered(this); \n} \n\n```", "```cpp\nvoid WorkerClient::handleJobResult(Message& message) \n{ \n    QDataStream in(&message.data, QIODevice::ReadOnly); \n    JobResult jobResult; \n    in >> jobResult; \n    emit jobCompleted(this, jobResult); \n} \n\n```", "```cpp\nvoid WorkerClient::abortJob() \n{ \n    MessageUtils::sendMessage(mSocket,  \n                              Message::Type::ALL_JOBS_ABORT,  \n                              true); \n} \n\nvoid WorkerClient::doSendJobRequests(QList<JobRequest> requests) \n{ \n    QByteArray data; \n    QDataStream stream(&data, QIODevice::WriteOnly); \n    stream << requests; \n\n    MessageUtils::sendMessage(mSocket,  \n                              Message::Type::JOB_REQUEST,  \n                              data); \n} \n\n```", "```cpp\n#include <memory> \n#include <vector> \n\n#include <QTcpServer> \n#include <QList> \n#include <QThread> \n#include <QMap> \n#include <QElapsedTimer> \n\n#include \"WorkerClient.h\" \n#include \"JobResult.h\" \n#include \"JobRequest.h\" \n\nclass MandelbrotCalculator : public QTcpServer \n{ \n    Q_OBJECT \npublic: \n    MandelbrotCalculator(QObject* parent = 0); \n    ~MandelbrotCalculator(); \n\nsignals: \n    void pictureLinesGenerated(QList<JobResult> jobResults); \n    void abortAllJobs(); \n\npublic slots: \n    void generatePicture(QSize areaSize, QPointF moveOffset,  \n                         double scaleFactor, int iterationMax); \n\nprivate slots: \n    void process(WorkerClient* workerClient, JobResult jobResult); \n    void removeWorkerClient(WorkerClient* workerClient); \n\nprotected: \n    void incomingConnection(qintptr socketDescriptor) override; \n\nprivate: \n    std::unique_ptr<JobRequest> createJobRequest( \n                                              int pixelPositionY); \n    void sendJobRequests(WorkerClient& client,  \n                         int jobRequestCount = 1); \n    void clearJobs(); \n\nprivate: \n    QPointF mMoveOffset; \n    double mScaleFactor; \n    QSize mAreaSize; \n    int mIterationMax; \n    int mReceivedJobResults; \n    QList<JobResult> mJobResults; \n    QMap<WorkerClient*, QThread*> mWorkerClients; \n    std::vector<std::unique_ptr<JobRequest>> mJobRequests; \n    QElapsedTimer mTimer; \n}; \n\n```", "```cpp\n#include <QDebug> \n#include <QThread> \n\nusing namespace std; \n\nconst int JOB_RESULT_THRESHOLD = 10; \n\nMandelbrotCalculator::MandelbrotCalculator(QObject* parent) : \n    QTcpServer(parent), \n     mMoveOffset(), \n    mScaleFactor(), \n    mAreaSize(), \n    mIterationMax(), \n    mReceivedJobResults(0), \n    mWorkerClients(), \n    mJobRequests(), \n    mTimer() \n{ \n    listen(QHostAddress::Any, 5000); \n} \n\n```", "```cpp\nvoid MandelbrotCalculator::incomingConnection( \n                                         qintptr socketDescriptor) \n{ \n    qDebug() << \"Connected workerClient\"; \n    QThread* thread = new QThread(this); \n    WorkerClient* client = new WorkerClient(socketDescriptor); \n    int workerClientsCount = mWorkerClients.keys().size(); \n    mWorkerClients.insert(client, thread); \n    client->moveToThread(thread); \n\n    connect(this, &MandelbrotCalculator::abortAllJobs, \n            client, &WorkerClient::abortJob); \n\n    connect(client, &WorkerClient::unregistered, \n            this, &MandelbrotCalculator::removeWorkerClient); \n    connect(client, &WorkerClient::jobCompleted, \n            this, &MandelbrotCalculator::process); \n\n    connect(thread, &QThread::started, \n            client, &WorkerClient::start); \n    thread->start(); \n\n    if(workerClientsCount == 0 && \n        mWorkerClients.size() == 1) { \n        generatePicture(mAreaSize, mMoveOffset,  \n                        mScaleFactor, mIterationMax); \n    } \n} \n\n```", "```cpp\nvoid MandelbrotCalculator::removeWorkerClient(WorkerClient* workerClient) \n{ \n    qDebug() << \"Removing workerClient\"; \n    QThread* thread = mWorkerClients.take(workerClient); \n    thread->quit(); \n    thread->wait(1000); \n    delete thread; \n    delete workerClient; \n} \n\n```", "```cpp\nMandelbrotCalculator::~MandelbrotCalculator() \n{ \n    while (!mWorkerClients.empty()) { \n        removeWorkerClient(mWorkerClients.firstKey()); \n    } \n} \n\n```", "```cpp\nvoid MandelbrotCalculator::generatePicture( \n                             QSize areaSize, QPointF moveOffset, \n                             double scaleFactor, int iterationMax) \n{ \n    // sanity check & members initization \n    ... \n\n    for(int pixelPositionY = mAreaSize.height() - 1;   \n        pixelPositionY >= 0; pixelPositionY--) { \n        mJobRequests.push_back(move( \n                               createJobRequest(pixelPositionY))); \n    } \n\n    for(WorkerClient* client : mWorkerClients.keys()) { \n        sendJobRequests(*client, client->cpuCoreCount() * 2); \n    } \n} \n\n```", "```cpp\nstd::unique_ptr<JobRequest> MandelbrotCalculator::createJobRequest(int pixelPositionY) \n{ \n    auto jobRequest = make_unique<JobRequest>(); \n    jobRequest->pixelPositionY = pixelPositionY; \n    jobRequest->moveOffset = mMoveOffset; \n    jobRequest->scaleFactor = mScaleFactor; \n    jobRequest->areaSize = mAreaSize; \n    jobRequest->iterationMax = mIterationMax; \n    return jobRequest; \n} \n\n```", "```cpp\nvoid MandelbrotCalculator::sendJobRequests(WorkerClient& client, int jobRequestCount) \n{ \n    QList<JobRequest> listJobRequest; \n    for (int i = 0; i < jobRequestCount; ++i) { \n        if (mJobRequests.empty()) { \n            break; \n        } \n\n        auto jobRequest = move(mJobRequests.back()); \n        mJobRequests.pop_back(); \n        listJobRequest.append(*jobRequest); \n    } \n\n    if (!listJobRequest.empty()) { \n        emit client.sendJobRequests(listJobRequest); \n    } \n} \n\n```", "```cpp\nvoid MandelbrotCalculator::process(WorkerClient* workerClient,  \n                                   JobResult jobResult) \n{ \n    // Sanity check and JobResult aggregation \n\n    if (mReceivedJobResults < mAreaSize.height()) { \n        sendJobRequests(*workerClient); \n    } else { \n        qDebug() << \"Generated in\" << mTimer.elapsed() << \"ms\"; \n    } \n} \n\n```", "```cpp\nvoid MandelbrotCalculator::clearJobs() \n{ \n    mReceivedJobResults = 0; \n    mJobRequests.clear(); \n    emit abortAllJobs(); \n} \n\n```", "```cpp\n#include <QApplication> \n#include <QList> \n\n#include \"JobRequest.h\" \n#include \"JobResult.h\" \n#include \"WorkerClient.h\" \n\nint main(int argc, char *argv[]) \n{ \n    qRegisterMetaType<QList<JobRequest>>(); \n    qRegisterMetaType<QList<JobResult>>(); \n    qRegisterMetaType<WorkerClient*>(); \n\n    QApplication a(argc, argv); \n    MainWindow w; \n    w.show(); \n\n    return a.exec(); \n} \n\n```"]