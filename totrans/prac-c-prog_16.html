<html><head></head><body>
        

                            
                    <h1 class="header-title">Low-Level Programming</h1>
                
            
            
                
<p>Sometimes, for precise results and in order to overcome the limitations of a programming language, you need to control the content of CPU registers at the bit level. In such situations, you can make use of two things: bitwise operators and assembly language programming.</p>
<p>In this chapter, we will learn how to perform the following recipes in order to carry out low-level programming in C:</p>
<ul>
<li>Converting a binary number into a decimal using a bitwise operator</li>
<li>Converting a decimal into binary using a bitwise operator</li>
<li>Converting a decimal number into binary using bit masking</li>
<li>Multiplying two numbers using the inline assembly language in C</li>
<li>Dividing two numbers using assembly code in C</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction to bitwise operators</h1>
                
            
            
                
<p>Every number that we enter into any variable is internally stored in the form of binary digits. To perform bit-level operations, C provides the following bitwise operators.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">&amp; (binary AND)</h1>
                
            
            
                
<p>This results in a binary 1 if both the operands are 1. If either of the bits is 0, then the result of the &amp; operation is 0.</p>
<p class="mce-root"/>
<p>Assuming that operand A has a value of 1010 and operand B has a value of 0111, then A&amp;B will be as follows:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign">A</td>
<td class="CDPAlignCenter CDPAlign">1010</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">B</td>
<td class="CDPAlignCenter CDPAlign">0111</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">A&amp;B</td>
<td class="CDPAlignCenter CDPAlign">0010</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">| (binary OR)</h1>
                
            
            
                
<p>This results in a binary 1 if either of the operands is 1. If both of the bits are 0, then the result of the | operation is 0.</p>
<p>Assuming that operand A has a value of 1010 and operand B has a value of 0111, then A|B will be as follows:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign">A</td>
<td class="CDPAlignCenter CDPAlign">1010</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">B</td>
<td class="CDPAlignCenter CDPAlign">0111</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">A|B</td>
<td class="CDPAlignCenter CDPAlign">1111</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">^ (binary XOR)</h1>
                
            
            
                
<p>This results in a binary 1 if either of the operands is 1 but not both. If both of the bits are 0, or if both are 1, then the result of the ^ operation is 0.</p>
<p>Assuming that operand A has a value of 1010 and operand B has a value of 0111, then A^B will be as follows:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign">A</td>
<td class="CDPAlignCenter CDPAlign">1010</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">B</td>
<td class="CDPAlignCenter CDPAlign">0111</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign">A^B</td>
<td class="CDPAlignCenter CDPAlign">1111</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">~ (binary complement)</h1>
                
            
            
                
<p>This negates or inverses the binary digits of the operand. That is, the binary digit 1 will be converted to 0 and vice versa. Assuming that operand A has a value of 1010, then ~A will be as follows:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 47.1377%" class="CDPAlignCenter CDPAlign">A</td>
<td style="width: 48.8623%" class="CDPAlignCenter CDPAlign">1010</td>
</tr>
<tr>
<td style="width: 47.1377%" class="CDPAlignCenter CDPAlign">~A</td>
<td style="width: 48.8623%" class="CDPAlignCenter CDPAlign">0101</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">&lt;&lt; (binary shift left)</h1>
                
            
            
                
<p>This left-shifts the binary digits of the operand by the specified number of bits, and the empty space created after the least significant bits is filled with 0s.</p>
<p>Assuming that operand A has a value of 00001010, then left-shifting A by 2 bits (A&lt;&lt;2) will give us the following:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr style="height: 32px">
<td style="width: 48.6226%;height: 32px" class="CDPAlignCenter CDPAlign">A</td>
<td style="width: 50.551%;height: 32px" class="CDPAlignCenter CDPAlign">00001010</td>
</tr>
<tr style="height: 33.8906px">
<td style="width: 48.6226%;height: 33.8906px" class="CDPAlignCenter CDPAlign">A&lt;&lt;2</td>
<td style="width: 50.551%;height: 33.8906px" class="CDPAlignCenter CDPAlign">00101000</td>
</tr>
</tbody>
</table>
<p>On every left-shift, the value of the operand is multiplied by powers of 2. That is, if the operand is left-shifted by 2 bits, that means it is multiplied by 2 x 2, that is, 4.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">&gt;&gt; (binary shift right)</h1>
                
            
            
                
<p>This right-shifts the binary digits of the operand by the specified number of bits, and the empty space created after the most significant bits is filled with 0s.</p>
<p>Assuming that operand A has a value of 00001010, then right-shifting A by 2 bits (A&gt;&gt;2) will give us the following:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 48.3113%" class="CDPAlignCenter CDPAlign">A</td>
<td style="width: 49.6887%" class="CDPAlignCenter CDPAlign">00001010</td>
</tr>
<tr>
<td style="width: 48.3113%" class="CDPAlignCenter CDPAlign">A&gt;&gt;2</td>
<td style="width: 49.6887%" class="CDPAlignCenter CDPAlign">00000010</td>
</tr>
</tbody>
</table>
<p> </p>
<p>You can see that on right-shifting, the least significant bits are dropped off. On every right-shift, the value of the operand is divided by powers of 2. That is, if the operand is right-shifted by 2 bits, that means it is divided by 2 x 2, that is, 4.</p>
<p>Let's go on to gain some practical knowledge by making some working recipes. The first recipe is next.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Converting a binary number into a decimal using a bitwise operator</h1>
                
            
            
                
<p>In this recipe, you will learn how to convert a binary number into a decimal.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>To convert a binary number into a decimal, perform the following steps:</p>
<ol>
<li>Enter a binary number.</li>
<li>Apply a mod 10 (<kbd>% 10</kbd>) operator to the binary digits of the binary number to isolate the last bit of the binary number.</li>
<li>Left-shift the binary digit isolated in <em>step 2</em> to multiply it by the power of 2. </li>
<li>Add the product of the previous multiplication to the variable that will store the result, that is, the decimal number. Let's call the variable <kbd>dec</kbd>.</li>
<li>The last digit of the binary number is truncated.</li>
<li>Repeat <em>step 2</em> to <em>step 4</em> until all the bits of the binary digits are over.</li>
<li>Display the decimal in the <kbd>dec</kbd> variable.</li>
</ol>
<p>The program for converting a binary number into a decimal is as follows:</p>
<pre><strong>binintodec.c</strong><br/>#include &lt;stdio.h&gt;<br/>void main()<br/>{<br/>    int num,bin,temp,dec=0,topower=0;<br/>    <br/>    printf("Enter the binary number: ");<br/>    scanf("%d",&amp;bin);<br/>    temp=bin;<br/>    while(bin &gt;0)<br/>    {<br/>        num=bin %10;<br/>        num=num&lt;&lt;topower;<br/>        dec=dec+num;<br/>        topower++;<br/>        bin=bin/10;<br/>    }    <br/>    printf("The decimal of %d is %d\n",temp,dec);<br/>}</pre>
<p>Now, let's go behind the scenes to understand the code better.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You will be prompted to enter a binary number. The number you enter will be assigned to the <kbd>bin</kbd> variable. The binary number is temporarily assigned to a <kbd>temp</kbd> variable. A <kbd>while</kbd> loop is executed until the binary number in the <kbd>bin</kbd> variable becomes 0.</p>
<p class="mce-root"/>
<p>Let's assume that the binary number entered in the <kbd>bin</kbd> variable is <kbd>1101</kbd>. Then, we will apply the <kbd>mod</kbd> (<kbd>%</kbd>) operator to the binary digits in the <kbd>bin</kbd> variable in order to isolate its last bit. In fact, the <kbd>%</kbd> operator divides by the specified number and returns the remainder. That is, when <kbd>% 10</kbd> is applied to <kbd>1 1 0 1</kbd>, it will return <kbd>1</kbd>, which is then assigned to the <kbd>num</kbd> variable.</p>
<p>A <kbd>topower</kbd> variable is initialized to <kbd>0</kbd>. The purpose of the <kbd>topower</kbd> variable is to left-shift the digits, that is, to multiply the binary digits by the power of <kbd>2</kbd>. The binary digit <kbd>1</kbd> in the <kbd>num</kbd> variable is added to another variable called <kbd>dec</kbd>. The value of the <kbd>topower</kbd> variable is incremented to <kbd>1</kbd>. The binary number <kbd>1 1 0 1</kbd> in the <kbd>bin</kbd> variable is truncated to <kbd>1 1 0</kbd> by dividing it by <kbd>10</kbd> and removing the fraction. </p>
<p>Again, the whole procedure is repeated. The last digit in the <kbd>bin</kbd> variable is isolated by the application of the <kbd>%10</kbd> operator; that is, <kbd>0</kbd> will be isolated from <kbd>1 1 0</kbd> and assigned to the <kbd>num</kbd> variable. The binary digit <kbd>0</kbd> is left-shifted by <kbd>1</kbd> bit, making it <kbd>0 0</kbd>. So, a value of <kbd>0</kbd> is then added to the value in the <kbd>dec</kbd> variable; that is, the value in the <kbd>dec</kbd> variable remains <kbd>1</kbd>. The value of <kbd>topower</kbd> is incremented to <kbd>2</kbd>. The last digit of the binary digit <kbd>1 1 0</kbd> in the <kbd>bin</kbd> variable is removed by dividing it by <kbd>10</kbd>; therefore, the binary digit in the <kbd>bin</kbd> variable will become <kbd>1 1</kbd>.</p>
<p>Once again, apply <kbd>%10</kbd> to <kbd>1 1</kbd>; the remainder will be <kbd>1</kbd>, which will be assigned to the <kbd>num</kbd> variable. The binary digit <kbd>1</kbd> is left-shifted by 2 bits, making it <kbd>1 0 0</kbd>. The binary value <kbd>1 0 0</kbd> represents <kbd>4</kbd>, which is then added to the value in the <kbd>dec</kbd> variable. The value in the <kbd>dec</kbd> variable was <kbd>1</kbd>, and after adding <kbd>4</kbd> to it, the total in the <kbd>dec</kbd> variable will become <kbd>5</kbd>. Again, the value in the <kbd>topower</kbd> variable will be incremented, making its value <kbd>3</kbd>. The last digit of the binary digits (<kbd>1 1</kbd>) in the <kbd>bin</kbd> variable will be truncated by dividing it by 10. Hence, the digit in the <kbd>bin</kbd> variable will become <kbd>1</kbd>.</p>
<p>Again, <kbd>%10</kbd> is applied to binary digit <kbd>1</kbd> in the <kbd>bin</kbd> variable. As a result of this, <kbd>1</kbd> will be assigned to the <kbd>num</kbd> variable. The binary digit <kbd>1</kbd> in the <kbd>num</kbd> variable is left-shifted by 3 bits, making it <kbd>1 0 0 0</kbd>. The binary value <kbd>1 0 0 0</kbd> represents <kbd>8</kbd>, which is then added to the value in the <kbd>dec</kbd> variable. The current value in the <kbd>dec</kbd> variable is <kbd>5</kbd>. On adding <kbd>8</kbd> to it, the value in the <kbd>dec</kbd> variable will become <kbd>13</kbd>. The value of the <kbd>topower</kbd> variable is incremented to <kbd>4</kbd>. The binary value <kbd>1</kbd> in the <kbd>bin</kbd> variable is divided by <kbd>10</kbd>, making it <kbd>0</kbd>. The <kbd>while</kbd> loop will terminate and the decimal value <kbd>13</kbd> in the <kbd>dec</kbd> variable is displayed on the screen.</p>
<p>The whole procedure can be illustrated as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/40a9f30b-d8a8-41ef-b2b4-abf2fd07c7a0.png" style="width:19.08em;height:47.33em;"/></p>
<p>Figure 16.1</p>
<p>Let's use GCC to compile the <kbd>binintodec.c</kbd> program as follows:</p>
<pre><strong>D:\CBook&gt;gcc binintodec.c -o binintodec</strong></pre>
<p class="mce-root"/>
<p>If you get no errors or warnings, this means the <kbd>binintodec.c</kbd> program has compiled into an executable file, <kbd>binintodec.exe</kbd>. Let's run this executable file as follows:</p>
<pre><strong>D:\CBook&gt;binintodec</strong><br/><strong>Enter the binary number: 1101</strong><br/><strong>The decimal of 1101 is 13</strong></pre>
<p>Voilà! We've successfully converted a binary number to a decimal using a bitwise operator. Now, let's move on to the next recipe!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Converting a decimal into binary using a bitwise operator</h1>
                
            
            
                
<p>In this recipe, we will learn to convert a decimal number into a binary number by making use of a bitwise operator. Bitwise operators operate on the binary digits of a number and enable us to do precise manipulation as desired.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>To convert a decimal number into a binary number by making use of a bitwise operator, perform the following steps:</p>
<ol>
<li>Enter a decimal number. This number is internally stored in the form of binary digits.</li>
<li>Isolate the least significant bit of the decimal number by applying a logical AND operation between the entered decimal number and value <kbd>1</kbd>.</li>
<li>The least significant bit that results from <em>step 2</em> is stored in an array.</li>
<li>Right-shift the binary digits of the decimal number by 1 bit. On shifting to the right, the second least significant bit will become the least significant bit.</li>
<li>Repeat <em>steps 2</em> to <em>4</em> until all the binary digits of the decimal number are placed into the array.</li>
<li>The binary digits assigned to the array are the binary version of the entered decimal number. Display the binary digits in an array to get the result.</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The program for converting a decimal into a binary number using a bitwise operator is as follows:</p>
<pre><strong>convertintobin.c</strong><br/>#include &lt;stdio.h&gt;<br/>void main()<br/>{<br/>    int num,i,x,temp;<br/>    int p[10];<br/>    printf("Enter Decimal Number : ");<br/>    scanf("%d",&amp;num);<br/>    temp=num;<br/>    x=0;<br/>    while(num &gt; 0)<br/>    {<br/>        if((num &amp; 1) == 0 )<br/>        {<br/>            p[x]=0;                                                            x++;<br/>        }<br/>        else<br/>        {<br/>            p[x]=1;<br/>            x++;<br/>        }<br/>        num = num &gt;&gt; 1;<br/>    }<br/>    printf("Binary of %d is ",temp);<br/>    for(i=x-1;i&gt;=0;i--)printf("%d",p[i]);<br/>}</pre>
<p>Now, let's go behind the scenes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You will be prompted to enter a decimal number. The number you enter is assigned to the <kbd>num</kbd> variable. The value entered in the <kbd>num</kbd> variable is temporarily assigned to another variable, <kbd>temp</kbd>. A <kbd>while</kbd> loop is set to execute until the value of <kbd>num</kbd> becomes <kbd>0</kbd>. Apply the logical AND operation to isolate each binary digit of the number. For example, if the value entered in variable <kbd>num</kbd> is <kbd>13</kbd>, then, internally, it will be stored in a binary format as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/843a9aec-7d2c-4131-9ece-3d1bd50c3e1f.png" style="width:11.92em;height:4.42em;"/></p>
<p>Figure 16.2</p>
<p>Now, the least significant bit is isolated by applying the AND operation. That is, the binary digits of <kbd>13</kbd><strong> </strong>are ANDed with <kbd>1</kbd> as follows. The ANDed means the AND operation is applied on binary digits of 13 and 1 :</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3ab2537f-2235-4ae0-a780-95128ed0d245.png" style="width:11.50em;height:5.58em;"/></p>
<p>Figure 16.3</p>
<p>The application of AND on binary digits<strong> <kbd>1</kbd></strong> and <kbd>1</kbd> results in <kbd>1</kbd>. If either of the binary digits is <kbd>0</kbd>, then the result of AND will be <kbd>0</kbd>. So, the output of <kbd>num</kbd> AND <kbd>1</kbd> will be <strong>1</strong>, which will be stored into array <kbd>p</kbd> at index location <kbd>0</kbd> as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/de43bfe9-797e-4c46-9902-d77cde9f5efc.png" style="width:25.25em;height:5.33em;"/></p>
<p>Figure 16.4</p>
<p>After that, right-shift the digits in the <kbd>num</kbd> variable by 1 bit. On shifting to the right, the least significant bit, <kbd>1</kbd>, will be dropped off and a <kbd>0</kbd> will be added to the most significant bit. Again, the new set of binary digits in the <kbd>num</kbd> variables is ANDed with <kbd>1</kbd>, that is, the AND operation is applied between the new set of binary digits in <kbd>num </kbd> variable and <kbd>1</kbd>. The output of <kbd>num</kbd> AND <strong><kbd>1</kbd> </strong>will be <kbd>0</kbd>, which is then assigned to array <kbd>p</kbd> at index location <kbd>1</kbd>; that is, <kbd>0</kbd> will be assigned to the <kbd>p[1]</kbd> location as shown in the figure:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4dbdaf5c-b0e7-4355-ae9b-204533f1ba85.png" style="width:25.17em;height:11.67em;"/></p>
<p>Figure 16.5</p>
<p>Again, right-shift the digits in the <kbd>num</kbd> variable by 1 bit. Again, the least significant bit, <kbd>0</kbd>, will be dropped off and a <kbd>0</kbd> will be added to the most significant bit. Once more, the new set of binary digits in the <kbd>num</kbd> variables is ANDed with <kbd>1</kbd>, as shown in <em>Figure 16.6(a)</em>. The output of the <kbd>num</kbd> variable AND <kbd>1</kbd> will be<strong> </strong><kbd>1</kbd>, which is then assigned to array <kbd>p</kbd> at index location <kbd>2</kbd>. Thereafter, right-shift the digits in the <kbd>num</kbd> variable again by 1 bit. The most significant bit in the <kbd>num</kbd> variable, <kbd>1</kbd>, will be dropped off and a <kbd>0</kbd> bit will be added to the most significant bit location. The binary digits in <kbd>num</kbd> are once more ANDed with <kbd>1</kbd> . ANDed here means, the AND operation is applied between the binary digits in num and 1. The output of the AND operation will be <kbd>1</kbd>, which will be assigned to array <kbd>p</kbd> at index location <kbd>p[3]</kbd> (<em>Figure 16.6(b)</em>):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/62b2c593-074a-40b4-9ad7-b7450ae8a7af.png" style="width:23.75em;height:25.83em;"/></p>
<p>Figure 16.6 (a) and (b)</p>
<p>Now, the binary digits assigned to array <kbd>p</kbd> are the binary conversion of the number assigned to variable <kbd>num</kbd>. Simply display the binary digits in array <kbd>p</kbd> in reverse order to get the result. Hence, <kbd>1 1 0 1</kbd> is the binary conversion of <kbd>13</kbd>.</p>
<p>Let's use GCC to compile the <kbd>convertintobin.c</kbd> program as follows:</p>
<pre><strong>D:\CBook&gt;gcc convertintobin.c -o convertintobin</strong></pre>
<p>If you get no errors or warnings, that means the <kbd>convertintobin.c</kbd> program has compiled into an executable file, <kbd>convertintobin.exe</kbd>. Let's run this executable file as follows:</p>
<pre><strong>D:\CBook&gt;convertintobin</strong><br/><strong>Enter Decimal Number : 13</strong><br/><strong>Binary of 13 is 1101</strong></pre>
<p>Voilà! We've successfully converted a decimal number into a binary number using a bitwise operator. Now, let's move on to the next recipe!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Converting a decimal number into binary using bit masking </h1>
                
            
            
                
<p>In this recipe, we will learn how to convert a decimal number into a binary number by masking certain bits of a register. Masking means isolating or separating out the desired binary digits. Masking hides the undesired binary digits and makes only the desired binary digits visible.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>To convert a decimal number into a binary number using bit masking, perform the following steps:</p>
<ol>
<li>Enter a decimal value. The decimal number entered is internally stored in the form of binary digits.</li>
<li>Assign a number <kbd>1</kbd> followed by 31 zeros to a variable called <kbd>mask</kbd>.</li>
<li>Mask each of the binary digits of the decimal number one by one, beginning from the most significant bit. Apply an AND operation between the binary digits of the entered decimal number and the binary digits in the <kbd>mask</kbd> variable. </li>
<li>Right-shift the binary digits in the <kbd>mask</kbd> variable by <kbd>1</kbd> bit making it <kbd>0 1</kbd> followed by 30 zeros. </li>
<li>Repeat this procedure. Apply the AND operation between the entered decimal number and the <kbd>mask</kbd> variable and the resultant binary digit is displayed on the screen. The procedure is repeated until the value in the <kbd>mask</kbd> variable becomes <kbd>0</kbd>.</li>
</ol>
<p>The program for converting a decimal number into binary using bit masking is as follows:</p>
<pre><strong>decintobin.c</strong><br/>#include &lt;stdio.h&gt;<br/>void main()<br/>{<br/>    int i, totbits;<br/>    unsigned mask,num;<br/>    printf("Enter decimal value: ");<br/>    scanf("%d", &amp;num);<br/>    totbits=32;<br/>    mask = 1 &lt;&lt; (totbits - 1);<br/>    for(i = 0; i &lt; totbits; i++)<br/>    {<br/>        if((num &amp; mask) == 0 )<br/>            printf("0");<br/>        else<br/>            printf("1");<br/>        mask &gt;&gt;= 1;<br/>    }<br/>}</pre>
<p>Now, let's go behind the scenes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You will be prompted to enter a decimal value. The decimal value you entered will be assigned to the <kbd>num</kbd> variable. Let's assume that you have entered a value of <kbd>13</kbd>. This value will be internally stored in the form of binary digits in the <kbd>num</kbd> variable as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1115dd56-feaf-42ce-a529-05c91dc5e53a.png" style="width:16.17em;height:5.33em;"/></p>
<p>Figure 16.7</p>
<p>We will set a <kbd>totbits</kbd> variable to <kbd>32</kbd> bits because an <kbd>int</kbd> data type in C consists of <kbd>32</kbd> bits, and we have to mask each bit of the number in the <kbd>num</kbd> variable to display its binary version. We will define a <kbd>mask</kbd> variable and assign a value of <kbd>1</kbd> to it. To make the value <kbd>1</kbd> in the <kbd>mask</kbd> variable appear as <kbd>10000...00</kbd>, that is, <kbd>1</kbd> followed by 31 zeros, we will left-shift value <kbd>1</kbd> by <kbd>31</kbd> bits as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c45e3224-6be0-42d6-a744-1d66b328b76d.png" style="width:20.50em;height:6.33em;"/></p>
<p>Figure 16.8</p>
<p class="mce-root"/>
<p>Now, we will execute a <kbd>for</kbd> loop <kbd>32</kbd> times to mask or isolate each bit in the <kbd>num</kbd> variable and display it. Within the <kbd>for</kbd> loop, we will apply an AND operation on the <kbd>num</kbd> and <kbd>mask</kbd> variables. Consequently, each of the binary digits of the two variables will be ANDed. We know that, in the AND operation, the output is <kbd>1</kbd> only when both of the bits are <kbd>1</kbd>. If either of the bits is <kbd>0</kbd>, the AND operation will return <kbd>0</kbd>.</p>
<p><em>Figure 16.9</em> shows the application of the AND operation on the <kbd>num</kbd> and <kbd>mask</kbd> variables:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7cbab9b5-10bc-40ee-b527-9c306e0aebf1.png" style="width:23.08em;height:7.17em;"/></p>
<p>Figure 16.9</p>
<p>Hence, the value <kbd>0</kbd> is returned. Thereafter, we will right-shift the binary digits in the <kbd>mask</kbd> variable by <kbd>1</kbd> bit, making it <kbd>0 1</kbd> followed by 30 zeros. Again, when the AND operation is applied between the <kbd>num</kbd> and <kbd>mask</kbd> variables, the result will be <kbd>0</kbd> (refer to the following figure), which is then displayed on the screen. So, up until now, we have <kbd>0 0</kbd> displayed on the screen:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/413430bf-f501-4b95-8692-c25a76f815b0.png" style="width:23.33em;height:7.25em;"/></p>
<p>Figure 16.10</p>
<p>Again, we will right-shift the binary digits in the <kbd>mask</kbd> variable by <kbd>1</kbd> bit, making <kbd>0 0 1</kbd> followed by 29 zeros. Again, when the AND operation is applied between the <kbd>num</kbd> and <kbd>mask</kbd> variables, the result will be <kbd>0</kbd>, which is then displayed on the screen.</p>
<p class="mce-root"/>
<p>The procedure and output will be the same for the next <kbd>25</kbd> bits; that is, we will get 28 zeros on the screen. After that, when we apply another right-shift operation on the binary digits of the <kbd>mask</kbd> variable, it will become <kbd>1 0 0 0</kbd>. On the application of the AND operation on the <kbd>num</kbd> and <kbd>mask</kbd> variables, we will get an output of <kbd>1</kbd>, which is then displayed on the screen. So, for now, we have 28 zeros followed by <kbd>1</kbd> bit on the screen:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b84697f1-c54a-4d11-b609-89f6569eab28.png" style="width:22.50em;height:7.00em;"/></p>
<p>Figure 16.11</p>
<p>As we keep repeating the procedure, we will get the outputs shown in <em>Figure 16.12</em>. We will have 28 zeros followed by <kbd>1 1</kbd> bits on the screen (<em>Figure 16.12 (a)</em>). After another repetition, we will have 28 zeros followed by <kbd>1 1 0</kbd> bits on the screen (<em>Figure 16.12 (b)</em>). In the final execution of the <kbd>for</kbd> loop, the final binary version of the number assigned to the <kbd>num</kbd> variable will be 28 zeros followed by <kbd>1 1 0 1</kbd> (<em>Figure 16.12 (c)</em>):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ee8309cc-b22f-4bd8-8cf1-a3b045257609.png" style="width:19.92em;height:23.42em;"/></p>
<p>Figure 16.12 (a), (b), and (c)</p>
<p>Let's use GCC to compile the <kbd>decintobin.c</kbd> program as follows:</p>
<pre><strong>D:\CBook&gt;gcc decintobin.c -o decintobin</strong></pre>
<p>If you get no errors or warnings, that means the <kbd>decintobin.c</kbd> program has compiled into an executable file, <kbd>decintobin.exe</kbd>. Let's run this executable file as follows:</p>
<pre><strong>D:\CBook&gt;decintobin</strong><br/><strong>Enter decimal value: 13</strong><br/><strong>00000000000000000000000000001101</strong></pre>
<p> Voilà! We've successfully converted a decimal number into binary using bit masking.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction to assembly coding</h1>
                
            
            
                
<p>The x86 processors have eight 32-bit general-purpose registers. The names of some of these general-purpose registers are EAX, EBX, ECX, and EDX. These registers can be used in subsections. For example, the least significant 2 bytes of EAX can be used as a 16-bit register called AX. Again, the least significant byte of AX can be used as an 8-bit register called AL and the most significant byte of AX can be used as an 8-bit register called AH. Similarly, the BX register can be used in the form of the BH and BL registers, and so on.</p>
<p>We will be writing inline assembly code in this chapter because this code is easily integrated with C code during code generation. Consequently, the C and assembly code is optimized by the compiler to produce efficient object code.</p>
<p>The syntax for using inline assembly code is as follows:</p>
<pre>asm [volatile] (<br/>asm statements<br/>: output statements<br/>: input statements<br/>);</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>asm</kbd> statements are enclosed within quotes, and the outputs and inputs are in the form of <kbd>"constraint"</kbd> (name) pairs separated by commas. The constraints can be any of the following:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Constraint </strong></td>
<td><strong>Usage</strong></td>
</tr>
<tr>
<td><kbd>g</kbd></td>
<td>Compiler will decide the register to be used for the variable</td>
</tr>
<tr>
<td><kbd>r</kbd></td>
<td>Load into any available register</td>
</tr>
<tr>
<td><kbd>a</kbd></td>
<td>Load into the <kbd>eax</kbd> register</td>
</tr>
<tr>
<td><kbd>b</kbd></td>
<td>Load into the <kbd>ebx</kbd> register</td>
</tr>
<tr>
<td><kbd>c</kbd></td>
<td>Load into the <kbd>ecx</kbd> register</td>
</tr>
<tr>
<td><kbd>d</kbd></td>
<td>Load into the <kbd>edx</kbd> register</td>
</tr>
<tr>
<td><kbd>f</kbd></td>
<td>Load into the floating-point register</td>
</tr>
<tr>
<td><kbd>D</kbd></td>
<td>Load into the <kbd>edi</kbd> register</td>
</tr>
<tr>
<td><kbd>S</kbd></td>
<td>Load into the <kbd>esi</kbd> register</td>
</tr>
</tbody>
</table>
<p>The outputs and inputs are referenced by numbers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Multiplying two numbers using the inline assembly language in C</h1>
                
            
            
                
<p>In this recipe, we will learn how to multiply two numbers using the inline assembly language in C. By making use of inline assembly code, we can have better control over CPU registers, manipulate their values up to the bit level, and take advantage of C as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>To multiply two numbers using the inline assembly language in C, perform the following steps:</p>
<ol>
<li>Load the two values to be multiplied into <kbd>eax</kbd> and <kbd>ebx</kbd> registers</li>
<li>Multiply the contents of the <kbd>eax</kbd> and <kbd>ebx</kbd> registers and store the result in the <kbd>eax</kbd> register</li>
<li>Display the content of the <kbd>eax</kbd> register on the screen</li>
</ol>
<p class="mce-root"/>
<p>The program for multiplying two digits using inline assembly code is as follows:</p>
<pre>#include &lt;stdio.h&gt;<br/>#include &lt;stdint.h&gt;<br/>int main(int argc, char **argv)<br/>{<br/>    int32_t var1=10, var2=20, multi = 0;<br/>    asm volatile ("imull %%ebx,%%eax;"<br/>        : "=a" (multi)          <br/>        : "a" (var1), "b" (var2) <br/>    );<br/>    printf("Multiplication = %d\n", multi);<br/>    return 0;<br/>}</pre>
<p>Now, let's go behind the scenes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Let's assign the two numbers that we want to multiply to two integer variables, <kbd>var1</kbd> and <kbd>var2</kbd>. Thereafter, we will load the contents of the <kbd>var1</kbd> variable into the <kbd>eax</kbd> register and the contents of the <kbd>var2</kbd> variable into the <kbd>ebx</kbd> register. We will multiply the contents of the <kbd>eax</kbd> and <kbd>ebx</kbd> registers and store the result in the <kbd>eax</kbd> register.</p>
<p>The content of the <kbd>eax</kbd> register is assigned to the <kbd>multi</kbd> variable. The content in this variable, which contains the multiplication of two variables, is displayed on the screen.</p>
<p>Let's use GCC to compile the <kbd>multiasm.c</kbd> program as follows:</p>
<pre><strong>D:\CBook&gt;gcc multiasm.c -o multiasm</strong></pre>
<p>If you get no errors or warnings, that means the <kbd>multiasm.c</kbd> program has compiled into an executable file, <kbd>multiasm.exe</kbd>. Let's run this executable file as follows:</p>
<pre><strong>D:\CBook&gt;multiasm</strong><br/><strong>Multiplication = 200</strong></pre>
<p>Voilà! We've successfully multiplied two numbers using the inline assembly language in C. Now, let's move on to the next recipe!</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Dividing two numbers using assembly code in C</h1>
                
            
            
                
<p>In this recipe, we will learn to divide two numbers using the inline assembly language in C. The assembly language provides us with better control over CPU registers, so we have to manually place the divisor and dividend in their respective registers. Additionally, after the division, the quotient and remainder will be automatically saved in their respective registers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>To divide two numbers using assembly code in C, perform the following steps:</p>
<ol>
<li>Load the dividend into the <kbd>eax</kbd> register.</li>
<li>Load the divisor into the <kbd>ebx</kbd> register.</li>
<li>Initialize the <kbd>edx</kbd> register to zero.</li>
<li>Execute the <kbd>divl</kbd> assembly statement to divide the content of the <kbd>eax</kbd> register by the content of the <kbd>ebx</kbd> register. By doing this division, the quotient will be assigned to any available register and the remainder will be assigned to the <kbd>ebx</kbd> register.</li>
<li>The quotient is retrieved from the available register and the remainder is retrieved from the <kbd>ebx</kbd> register, and both are displayed on the screen.</li>
</ol>
<p>The program for dividing two digits using inline assembly code is as follows:</p>
<pre><strong>asmdivide.c</strong><br/>#include &lt;stdio.h&gt;<br/>void main() {<br/>    int var1=19,var2=4, var3=0, remainder, quotient;<br/>    asm("divl %%ebx;"<br/>        "movl %%edx, %0"<br/>        : "=b" (remainder) , "=r" (quotient)<br/>        : "a" (var1), "b" (var2), "d" (var3) <br/>    );<br/>    printf ("On dividing %d by %d, you get %d quotient and %d remainder\n", var1, var2, quotient, remainder);<br/>}</pre>
<p>Now, let's go behind the scenes.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Let's assign the two numbers to be divided to the two variables <kbd>var1</kbd> and <kbd>var2</kbd>. Assign the dividend to <kbd>var1</kbd> and the divisor to <kbd>var2</kbd>. Thereafter, we will load the dividend from the <kbd>var1</kbd> variable into the <kbd>eax</kbd> register and the divisor from the <kbd>var2</kbd> variable into the <kbd>ebx</kbd> register.</p>
<p>The <kbd>edx</kbd> register has to be initialized to zero. To do this, we will initialize a <kbd>var3</kbd> variable to zero. From <kbd>var3</kbd>, the zero value is loaded into the <kbd>edx</kbd> register. Then, we will execute the <kbd>divl</kbd> assembly statement to divide the content of the <kbd>eax</kbd> register by the content of the <kbd>ebx</kbd> register. By doing this division, the quotient will be assigned to any available register and the remainder will be assigned to the <kbd>ebx</kbd> register.</p>
<p>The quotient from the available register is loaded into a variable called <kbd>quotient</kbd>, and the remainder from the <kbd>ebx</kbd> register is loaded into another variable called <kbd>remainder</kbd>. Finally, the quotient and remainder values are displayed on the screen.</p>
<p>Let's use GCC to compile the <kbd>asmdivide.c</kbd> program as follows:</p>
<pre><strong>D:\CBook&gt;gcc asmdivide.c -o asmdivide</strong></pre>
<p>If you get no errors or warnings, that means the <kbd>asmdivide.c</kbd> program has compiled into an executable file, <kbd>asmdivide.exe</kbd>. Let's run this executable file as follows:</p>
<pre><strong>D:\CBook&gt;asmdivide</strong><br/><strong>On dividing 19 by 4, you get 4 quotient and 3 remainder</strong></pre>
<p>Voilà! We've successfully divided two numbers using assembly code in C.</p>


            

            
        
    </body></html>