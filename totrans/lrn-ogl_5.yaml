- en: Types of light sources and combining of lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll discuss the various types of lighting effects, such as
    diffuse light, ambient light, and specular light. You'll also explore the different
    type of light sources, such as directional light, point light, and spot light.
    We'll also discuss how to combine these different types of light sources for your
    game world.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing different light sources, such as directional, point, and spot light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the different effects of lights, such as diffused, ambient, and
    specular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to combine different effects of light and the sources in your game world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to all the code files for this chapter in the `Chapter05` folder
    on GitHub. The GitHub link can be found in the preface of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Directional light
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to talk about a directional light. We are advancing
    quite a bit now into the different lighting mechanics that you can use in OpenGL.
    We've looked at lighting maps, to be able to shine a light and have it affect
    an object differently depending on what sort of material a particular object or
    a particular part of the object is.
  prefs: []
  type: TYPE_NORMAL
- en: Directional lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve looked at other basic material and basic lighting, but there are a few
    main types of lights that you can use in your game, such as directional lights,
    point lights, and spotlights. We''ll be covering point lights and spotlights in
    later sections; but directional lights are the most basic version of lights in
    3D graphics, in general:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30b0c351-57f1-43f0-a528-39f7f48e379c.png)'
  prefs: []
  type: TYPE_IMG
- en: So, as you can see in the preceding diagram, there are arrows coming from some
    sort of light source. A directional light doesn't have an origin, or more precisely,
    a position, because the light source is infinitely far away.
  prefs: []
  type: TYPE_NORMAL
- en: So, for example, you had five cubes. Irrespective of what material they are,
    let's just assume they were all the same and they were rotated in the same way,
    but were positioned all over the place. So, let's say each one of them was (we
    don't really have a concept of distance in miles or kilometers in our engine)
    100 miles away from each other and in any direction. The actual light and the
    directional light would affect each individual box object in the same way because
    the directional light has no starting position. You can't get any closer to the
    light source; you might think that if you move in the light's direction, you'll
    get closer to the light source. Technically, you could say that's true. But if
    it has no original location and no original position, and it's infinitely far
    away, it's still going to be infinitely far away. So that's what a directional
    light is.
  prefs: []
  type: TYPE_NORMAL
- en: A directional light is sort of just a general light you have in the scene, and
    then you use spotlights and point lights to enhance your scene to create more
    specific stuff. So, let's consider this example. If you have a game that's set
    on flat ground or some island, then the directional light could be the sun.
  prefs: []
  type: TYPE_NORMAL
- en: If you're not really going vertically up, you're not going into space, you can't
    really get any nearer to the sun; then you could think of that as a directional
    light and most of the time, that is thought of as a directional light in a lot
    of games.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, it depends on what sort of game you''re playing. If you''re playing
    a game where you can go into space and you can get to the stars or the sun, then
    that really wouldn''t be a directional light; that would be a different light.
    But more different types of light will be covered in different sections. So let''s
    implement this by using the `shaders/lighting.frag` file, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What we are doing is commenting out an original position, `vec3 position`, and
    instead adding a direction, that is, `vec3 direction`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the diffuse lighting, we need to modify it slightly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, let's just comment out `lightDir` because though we're going to have a light
    direction again, we want to leave in this code in case we need it later on. So,
    add a new code line, `lightDir = normalize -light.direction`.
  prefs: []
  type: TYPE_NORMAL
- en: So that's all we have to do here, because we're not working out the difference
    between the position (`light.position`) and the actual fragment shader position
    (`FragPos`). We don't have to do that, because all we are concerned about is the
    light's direction.
  prefs: []
  type: TYPE_NORMAL
- en: Making changes to main code to integrate directional light in our world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now open the `main.cpp` file, which is used for the actual light and the shaders.
    Comment out our shader programs, because we''re not going to actually use the
    lamp shader in this section, simply because we don''t want any sort of light source
    with an origin position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here we're going to use an array of different cube positions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to spawn several cubes, very similar to what we''ve done before,
    and you can see the variance in having different cubes. We don''t need the light
    vertex array object anymore because we''re not doing the lamp shader, so let''s
    just comment that out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'All this looks good so far, but we''ve to do a few changes within the `while`
    loop, to the part where we''re using the lighting shader. So, add `GLint lightDirLoc
    = glGetUniformLocation` and `glUniform3f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The view position location, which is just the camera's position, is fine. The
    ambient and the diffuse need not be changed. You can modify them if you want to,
    but it's not needed for this particular chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a for loop as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we add `glm::mat4` as a 4x4 matrix. We will call it model. Then we add
    `glBindVertexArray`, which will take the box vertex array object. Sometimes we
    only want one cube; sometimes we want several, so we will use `cubePositions`
    and it will take the iterator as the index. Now we're going to add `GLfloat angle
    = 20.0f * i; model = glm::rotate` and for the rotation, it's going to take the
    model again. For the angle, we are just going to put angle. After that, we will
    add a vector,`glm::vec3`, and for this, we are just going to put `1.0f`, `0.3f`,
    and `0.5f`. We're just going to uniform the 4x4 matrix. Use `glUniformMatrix4fv`,
    because its four float values and `modelLoc`, which is what we created previously,
    will take the value `1`. Then add `GL_FALSE` and `glm::value_ptr (model)`. `glDrawArrays`
    will take `GL_TRIANGLES`, the starting index `0`, and `36` different vertices.
    So, if we put a semicolon there, we just need to `glBind` the vertex array to
    `0`, so we will just unbind it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will run this bad boy and we get Build Failed. This is happening because
    we commented out the light vertex array object and hence there''s no need for
    us to use `glDeleteVertexArrays( 1, &lightVAO )`. So, now run it again and you
    will get Build Succeeded and the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0650b9a6-801a-4251-b1d3-9ed9596d1fb6.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we've got our different objects. All of these objects are affected by
    the light in the same way. Obviously, there are angle differences, and that's
    what makes the intensity of the light affecting it different. But in terms of
    their position, that doesn't matter. Because the light is coming from one direction,
    the objects are affected exactly the same. They are just as dark and bright. The
    specular lighting will affect them just the same way, and it's the angle that
    makes the lighting affect it differently.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned about directional lights in modern OpenGL. We'll cover
    an advanced form of lighting in the next section where we'll create some really,
    really cool stuff with lighting. When you see all our games, especially games
    that look really, really good in terms of graphical fidelity, you'll find that
    when you start going under the layers and start doing programming in graphics,
    you'll see a lot of it's due to lighting.
  prefs: []
  type: TYPE_NORMAL
- en: The way lighting affects things has probably the biggest effect because by using
    normal lighting you can make an object look like it's got depth, even though it's
    just a flat texture, and that is pretty radical.
  prefs: []
  type: TYPE_NORMAL
- en: Point lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss point lights. We've covered lighting systems
    in a bit of depth so far. One technique is directional lights, which essentially
    are light sources that point in a certain direction, hence the name directional
    light; but they do not have an original location, that is, they are infinitely
    far away. So, say for example, we have two objects that are exactly the same,
    rotated exactly the same way, and there's no other lighting affecting those objects;
    no matter how far they are away from each other, they will not be affected differently
    by the directional light source.
  prefs: []
  type: TYPE_NORMAL
- en: The point light concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **point light** is a light that has an actual origin, and it emits the light
    in every single direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/361b24d4-eebe-4fec-93cf-eed080f9f7b9.png)'
  prefs: []
  type: TYPE_IMG
- en: You can almost think of a point light like our sun or a star in real life. You
    could argue that the sun technically emits different amounts of light from different
    sides, but we could, for argument's sake, say it emits the same intensity, the
    same type of light from its origin in all directions. It's very common for, let's
    say, space games to have something like a point light as the sun, a star, or some
    other sort of object like that.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, just open your lighting fragment shader, that is, `../shaders/lighting.frag`,
    and in this file, we need to modify a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we will comment out the `direction` vector because
    we don't need the direction anymore since the lighting source has a position,
    and it just emits light in every direction. So, `ambient`, `diffuse`, and `specular`
    will need no changes. Now, we will add a constant, a linear, and a quadratic float.
    That's all for the lighting struct.
  prefs: []
  type: TYPE_NORMAL
- en: The diffuse section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s check out the diffuse section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We're still going to normalize our `Normal`, but we want the difference between
    the light position and the fragment position. So we'll comment out the light direction,
    `vec3 lightDir = normalize(-light.direction)` and we'll uncomment `light.position
    - FragPos`.
  prefs: []
  type: TYPE_NORMAL
- en: The difference, `max (dot( norm, lightDir)`, will be kept as it is. In terms
    of `diffuse`, we're still using `light.diffuse`, multiplying it by the `float
    diffuse` variable, `diff`, and then `vec3`.
  prefs: []
  type: TYPE_NORMAL
- en: The specular section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the specular section now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, the view direction and the reflection direction won't change. What we
    need to add is something called attenuation, something like, distance and lighting.
  prefs: []
  type: TYPE_NORMAL
- en: The attenuation section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Attenuation is essentially dropout. Attenuation lighting is a decrease in lighting
    as you move away from an object. Take a look at this image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/192a78ff-bd4b-4424-b46e-5baed84f8879.png)'
  prefs: []
  type: TYPE_IMG
- en: We've got four different light sources, **A**, **B**, **C**, and **D**. We will
    assume they're all the same. **A** has more of an effect on the ground than **D**
    because **D** is further away. So, basically attenuation is the fall-off.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, if the light source was further away but still
    had the same sort of angle, it would still affect our object the same, and we
    don't want that. So, we will add `float distance = length(light.position - FragPos)`,
    and after that, add `float attenuation = 1.0f / (light.constant + light.linear
    * distance + light.quadratic * (distance * distance))`. So, this is how we calculated
    the distance and the attenuation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want more information about how this works, feel free to check out the
    following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://open.gl](https://open.gl/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learnopengl.com](https://learnopengl.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are great resources, so feel free to check them out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are going to add attenuation to the ambient, diffuse, and specular lights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We need these because all three of them will have attenuation factored in as
    they need to factor in distance.
  prefs: []
  type: TYPE_NORMAL
- en: Time for changes in main.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `main.cpp` file. We will have to do a few modifications to it. The
    first thing we need to actually uncomment out is `lampShader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is because we're using the lamp again since we are dealing with the point
    light.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we need to change is the light vertex array object because we''re
    using the lamp shader now. So, uncomment the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need an emission map, so we will add `emissionMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The only change we need to make now is actually within our `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we also need to add the constants, the linear, and the quadratic, which
    are float values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in order to bind our textures, we need to uncomment out the `lampShader.Use(
    )` block. Also, delete the light vertex array object, that is, uncomment the `glDeleteVertexArrays(
    1, &lightVAO );` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to run our application and we get the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7df644a1-5179-4278-9289-a8bf38296192.png)'
  prefs: []
  type: TYPE_IMG
- en: If you examine the output, we've got our original light source and the objects
    that are further away are a bit darker, as they should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let''s make one more change in `main.cpp`; we can actually move our light
    by uncommenting the following lines in the `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lightPos.x -=0.005f;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lightPos.z -=0.005f;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And now, if you re-run the application, as you can see in the following screenshot,
    attenuation is factored in. You can see that this object is getting slightly brighter
    now, and you''ll actually start seeing this particular object getting brighter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ed63f29-bf47-432b-9963-1cd4d0bdc4db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, again comment out the following lines back in the `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lightPos.x -=0.005f;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lightPos.z -=0.005f;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And, instead we will try changing the light position in the camera section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'So, as you can see in the preceding code, we have replaced `2.0f` to `-2.0f`
    in the light attributes section. Now, if you run your application, you can see
    the light is being emitted in every single direction. Nearer objects are brighter
    than more distant objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5e35832-190e-4e04-891a-8fd890d2c685.png)'
  prefs: []
  type: TYPE_IMG
- en: So, that is it for point lights.
  prefs: []
  type: TYPE_NORMAL
- en: Spotlight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's discuss and take a look at how we can add spotlights to our game. We've
    looked at directional lights, we've looked at point lights. Directional lights
    have a direction but they don't have an original position, so they are infinitely
    far away. A point light has a position but it shines light in every single direction,
    whereas a spotlight has a position and a direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram of a spotlight:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b3fb65f-787c-4a2d-b82c-25d886312251.png)'
  prefs: []
  type: TYPE_IMG
- en: So, the position of the light is high up somewhere, and you can also see that
    there is a direction for the light. It essentially creates a cone-like effect,
    sort of what a lamp or a torch would do. Spotlights are used on stages. But spotlights
    are used in several scenarios in games throughout your world.
  prefs: []
  type: TYPE_NORMAL
- en: So, without further ado, let's get on with coding our spotlights.
  prefs: []
  type: TYPE_NORMAL
- en: Making changes to shader files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the below mentioned steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Updating shader files is actually very, very simple. We only need to actually
    modify the lighting fragment shader in terms of the shader files; everything else
    looks fine. In `lighting.frag`, we can keep the `Material` struct as it is because
    it's got `diffuse`, `specular`, and `shininess`, and that's what we require for
    a spot light.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'But with the light struct, we need the direction because the spotlight has
    an original position and a direction in which it is shining. So, we''ll uncomment
    `vec3 direction`. We also need a couple of float variables. The first one is `float
    cutOff`. The next one is `float outerCutOff`. Take a look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the terms till `void main` starts remain the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `void main`, the ambient calculation, the diffuse calculation, and the specular
    calculation aren't changing. Even the attenuation calculation isn't going to be
    changing. All we actually need to do is add an extra section for the spotlight,
    which is going to be calculating soft edges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, for the calculation of the soft edges, we''re going to add `float theta
    = dot();`, and to this we are going to pass `lightDir`. This needs to be normalized,
    so we''re passing `normalize()`. And then finally, here you need to specify `-light.direction`.
    You need to add a negative light value because you''re doing it from the perspective
    of the camera, not from the user. That''s the reason the position is negated.
    On the other line, we need to calculate the difference between `cutOff` and `outerCutOff`,
    so we''ll add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add `float intensity = clamp();`. And in here, we are going to pass `theta
    - light.outerCutOff`. We want to divide this calculation by `epsilon` and then
    just put two values, `0.0` and `1.0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we just need to add the intensity into `diffuse` and `specular`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So, we're now actually done with the updating the shader.
  prefs: []
  type: TYPE_NORMAL
- en: Minor modification to Camera.h
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll need `GetFront`, which is a private variable in our
    main code. We''ll make a minor modification for it in our `Camera.h` file. So,
    below the `glm:: vec3 GetPosition()` method, we''ll add a simple method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Making changes to the main code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, if we go to main.cpp, we''ll make the following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: We don't need `lampShader` because we're going to be doing it via a spotlight,
    so we'll comment out the code. The reason we don't need any sort of lamp shader
    or anything like that is because what we're going to do in this section is attach
    the spotlight to, essentially, the camera. You can almost think of it like those
    helmets with the light on top that people use for rock climbing and that sort
    of stuff. We're simply going to simulate that because directional light and point
    lights are great and if you have them static, they're easy to see and understand
    what is going on. With a spotlight, it really does help if you can move it, and
    the best way to move it is with the camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll comment out the light vertex array object as we don't need it anymore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After we''ve commented that out, we can go directly into the while loop and
    we need to change a few things here. When we go to `lightingShader.Use`, we need
    to change some of the code there. We''re going to add `GLint lightSpotDirLocation
    = glGetUniformLocation();`. In here, we need to pass `lightingShader.Program`,
    and the other parameter you need to specify is `"light.direction"`. What we are
    going to do next is duplicate the preceding code and make the following modifications
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll modify the remaining terms of `lightingShader` code where we set the
    light properties as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There's only one thing we're going to change in here now. We'll comment out
    the whole `lampShader` code. Because we commented out the declaration and initialization,
    we need to do the same here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need to comment out `glDeleteVertexArrays();`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're all ready to run this now. You will see similar output on your screen.
    So, as you can see, we've got some light. The spot light is attached to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we move forward, as you can see, we''ve got sort of a spotlight effect,
    and it''s more profound the closer we get to it, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbabce09-5e94-4d38-bbb3-0cb242d2d466.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Otherwise, it''s very wide as we move further away from the objects, as seen
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b6b6d74-0d58-4c8c-bc75-0803755a7255.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Hence, they''re smaller. As we look around, we get a sort of spotlight effect.
    As you can see, it affects objects that are further away slightly differently,
    and we have this really cool spotlight, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c107481-f0bc-4cc8-be1b-200ac41a92ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try and do it on a corner, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e3cab23-d7f1-4482-ae37-608c8c1d507d.png)'
  prefs: []
  type: TYPE_IMG
- en: We've got this really cool spotlight that is attached to our head. You could
    go ahead and create some sort of building game or some sort of miner's game where
    you have a light on your head. That would be pretty cool.
  prefs: []
  type: TYPE_NORMAL
- en: Combining light
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to be looking at combining our light sources.
    So far we''ve covered directional lights, point lights, and spotlights in the
    previous sections. The following is a brief overview of what they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Directional light**: A directional light is a light that has a particular
    direction. It shines light in a particular direction. But it doesn''t have a location,
    a position. It''s just infinitely far away from everything.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Point light**: A point light has a position, but it shines light in every
    single direction. Depending on what you''re doing and what sort of game you''ve
    got, you could potentially have the sun or a star'' as a directional light, but
    if you could go into space, go around your star or get near it, then you''d probably
    want a point light.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spotlight**: A spotlight essentially is like a lamp. It casts a light in
    an initial position, and then in a direction as well. So it''s like a combination
    of the preceding two types of light.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous sections, we looked at all of them, but at the moment, in these
    sections, we've just been covering them one at a time. We've either been commenting
    out code or modifying code to just show one realistically. But in a real game
    scenario or a free application scenario, you'll want multiple light sources. You'll
    want multiple instances of directional lights, point lights, and spotlights. You'll
    probably want to try and create your own really cool effects as well. In this
    section, we're going to be combining our three types of light casters.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we'll start by updating the shader files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the shader files ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the below mentioned steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that we need to do is go to the fragment shader for lighting,
    `lighting.frag`. That''s the only shader that we actually need to modify, so we
    won''t touch `lighting.vs`. Check out the following steps to understand the changes
    that we need to make to the fragment shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, first of all, we're going to add `#define`, and this is just going to be
    `NUMBER_OF_POINT_LIGHTS`. For our project, we'll add the value as 4 because we're
    going to have four point lights.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we''re going to need a data type for three different types of light source:
    a directional light, a point light, and a spotlight. For that, what we''ll do
    is actually duplicate the struct that we already have in code. We''ll rename each
    one of them appropriately: `DirLight` for directional light, `PointLight` for
    point light, and `SpotLight` for the spot light. We don''t need all of the vectors
    and the floats that we''ve got in the structs. Take a look at the following code
    to understand all the changes we need to make in the new struct that we have defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The directional light, as you may remember, doesn''t have a position, it has
    a direction. It has an ambient, diffuse, and specular, but it doesn''t have any
    of the float variables: constant linear and quadratic. So we''ll just remove them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For the point light, remember it doesn''t have a direction; it has a position
    because it just emits light in every direction. We can get rid of `cutOff` and
    `outerCutOff`, but we''re going to need everything else:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For the spotlight, nothing will be changing in here because this structure
    was created in the previous section, which covered spotlights:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As we move down, `uniform Light light` is going to change slightly as we''ve
    got three different sources of light. So we''ll make the following changes to
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, for a `PointLight` as you may remember, we created a
    `#define`. So, the `uniform PointLight` is going to be an array of lights. Even
    though we're creating multiple spotlights and only one directional light and spotlight,
    you can create multiple directional lights and you can create multiple spotlights
    such as lamps, lights on a stick and that sort of thing. You might have one really
    strong source of light such as a directional light that could be simulating the
    sun, and then you might have just other general small lights.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to do next is create some function prototypes because at the moment,
    what we''ve been doing is just doing everything in main. This has been alright
    for now, but we need a bit more flexibility with the way we''re doing things.
    So, we''re going to add `vec3 CalcDirLight();`, and this is going to take a few
    parameters such as `DirLight`. Then we''re going to take a `vec3` for the normal.
    We''ve explained the use of all of these different vectors and properties before.
    Again, we''re just combining what we''ve done over the past few sections. And
    then, we''ll duplicate the code and make the following highlighted changes to
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Making modifications void main of lighting.frag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following steps to understand the modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: In the void main of `lighting.frag`, we're going to get rid of all the initially
    present code and add fresh code to it. We'll start by adding `vec3` normal. We're
    just going to be normalizing using `Normal`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we're going to create a vec3 for `viewDir`. This is going to normalize
    the difference between `viewPos` and `FragPos`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to do the directional lighting calculation. With this, we're just
    going to be calling the `CalcDirLight` method. So, we're not going to be doing
    much code in main. Because we're adding more stuff to it, it's becoming like another
    C++ project because we are abstracting it out into different methods, so we can
    reuse this code when and where we need to. So, we'll add `vec3 result` and we'll
    assign the value of `CalcDirLight();`, and this is going to take the `dirLight`
    variable, the `norm` that we've just calculated, and the `viewDir`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we're just going to loop over the point lights, then factor them in. So,
    add a for loop and pass the initializing parameters, `int i = 0; i < NUMBER_OF_POINT_LIGHTS;
    i++`. In the `for` loop we are going to add `result += CalcPointLight()` . Again,
    what we're doing now is adding the effect of the different point lights to our
    result because again, this lighting is affecting our particular object, and this
    is the way it's done. So, to `CalcPointLight()` we're going to pass `pointLights[i]`,
    `norm`, and `FragPos`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What we''re going to do now is add the code for the spotlight. So, we''ll factor
    in the spotlight and add `result += CalcSpotLight()`. And this simply takes in
    the `spotLight` variable, `norm`, `FragPos`, and `viewDir`.Then we''ll add `color
    = vec4(result,1.0);`. Take a look at the following code to understand the description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is all stuff we've done before, and we're just abstracting it out now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's do the calculation of colors for the different sources of light. So
    here, what we'll do is copy and paste the `vec3 calc` code for all three sources
    of light. Now let's do the directional light calculation. So to the `vec3 CalcDirLight()`
    method we'll add vec3 lightDir, and this is going to equal to `normalize( -light.direction
    );`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reason for `-light.direction` is because we're not doing it from our object,
    we're doing it from the light. So, instead of the way the object is looking at
    the light, it's coming from the light. So, that's the reason why it's flipped.
  prefs: []
  type: TYPE_NORMAL
- en: And now we need to add float. This is going to be the diffuse shading. So, `diff
    = max ()`, and to `max()` we'll pass `dot( normal, lightDir ), 0.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we're going to be calculating the specular shading. So add `vec3 reflectDir
    = reflect()`, and to `reflect()` we'll pass `-lightDir`, `normal` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we'll add `float spec = pow()` , and to that we'll pass `max ()`, and to
    `max()` we'll pass `dot( viewDir, reflectDir )` and `0.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we need to add `material.shininess`. Now we need to combine the results.
    So, add `vec3 ambient = light.ambient * vec3 ();`, and to `vec3()` we''ll pass
    `texture( material.diffuse, TexCoords )`. This is going to be the texture diffuse
    and the texture coordinates, and for the diffuse and specular light it''s similar
    to ambient light, so make the highlighted changes to in the following code. Also,
    take a look at the following code to understand the preceding description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we just need to return the calculation, which is `ambient
    + diffuse + specular`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to calculate the point light, so what we''ll do is duplicate the
    lines of code mentioned in the previous steps and paste in the `CalcPointLight()`
    method; we''ll add, change, and remove what we need to. Take a look at the following
    highlighted code to understand the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, after defining the `specular` shading we added the attenuation
    code, as we need to factor in the attenuation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to do the calculations for the `spotlight ()` method. Again, we''re
    just going to copy and paste the previous code because we''ll most likely be adding
    quite a lot to it, but we''ll need most of it. So take a look at the following
    highlighted code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, before we go on to the `ambient`, `diffuse`, and `specular`
    vectors, we needed to add the spotlight intensity calculation code. Take a good
    look at the highlighted code. Then, finally, we just need to factor in the intensity.
    So we just multiplied the attenuation by the intensity in the final lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: We're done now updating the fragment lighting shader. We've covered all of this
    before in the previous sections. We are just combining it all together. Now, we're
    done. I'm sure there are going to be errors, because there's quite a lot of code
    in here, so we'll get to that when we start compiling it. So let's just save it.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will move on to our main code to make modifications to it.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to the main code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the below mentioned steps to combine the light source in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main.cpp`, we need the lamp shader, so we''ll uncomment it. After `cubePositions`,
    because now we''ve got multiple point light positions, we''re going to add `glm::vec3`,
    and this is going to be called `pointLightPositions[]`. We are going to add `glm::vec3();`
    in there, and for this, we are going to pass `0.7f`, `0.2f`, and `2.0f`. Duplicate
    this line of code, paste it four times, and make the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll uncomment the light vertex array object as we need it now to combine
    the lights.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The major changes that we need to make are within the `while` loop now. We''re
    using the lighting shader, so we''ll make the following changes to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re setting the uniforms for the directional light:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll set the uniforms for point light 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, set the uniforms for point light 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the definition of the uniforms for point light 3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the definitions for point light 4:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll define uniforms for the spotlight as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding lines of code, we set all the uniforms for the 5 or 6 types
    of lights we have. We have to set them manually and index the proper `PointLight`
    struct in the array to set each uniform variable. This can be made more code-friendly
    by defining light types as classes and setting their values in there, or by using
    a more efficient uniform approach by using uniform buffer objects.
  prefs: []
  type: TYPE_NORMAL
- en: We've still got all of the code that we don't need anymore, so, from just below
    the point where we finished our spotlight stuff to the point where we start defining
    our view matrix, we need to get rid of that all that code. These are the remnants
    from when we only had one type of light, and it was called `Light`, so we'll get
    rid of that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to comment back in the shader, and I need to comment back in the deleting
    of the light vertex array object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've looped through our box array, we have created all the different boxes,
    and we've got our lamp shader. Remember, we've got multiple point lights, so we
    just need to create a loop for that. So, after binding the vertex array and unbinding
    it, we need to add `glBindVertexArray( lightVAO );`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then we''ll add our `for` loop and pass the initializing parameters for the
    loop as `GLuint i = 0; i < 4; i++`, and to the loop we''re going to add, `model
    = glm:: mat4();`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, on the other line, we are going to add `model = glm::translate();`, and
    this is just going to be translating the `model`. And then the vector for this
    is going to be `pointLightPositions`. Then pass the iterator `[i]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And now, we're just going to make the cube a little bit smaller, as we have
    done before. So we'll add `model = glm::scale();`, and to that we are going to
    pass `model` and `glm::vec3( 0.2f )`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the other line we''re going to add `glUniformMatrix4fv()` because it''s
    a 4x4 matrix, and to that, we need to pass `modelLoc, 1, GL_FALSE;`, and `glm::
    value_ptr()`; to this, we are going to pass the model.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then we''ll add `glDrawArrays();`, and to that, we''ll pass `GL_TRIANGLES`,
    `0`, and `36`. And, after this for loop is completed on the other line, we need
    to unbind the vertex array as `glBindVertexArray( 0 );`. Take a look at the following
    code to understand the description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now all set to run the code. Save the updated code and compile it. You
    will get output similar to the following on your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2be11c3-3074-454d-89c2-dd74675550ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ve got our multiple light sources, four of which are point lights and one
    of which is just a regular lamp. We recommend you figure out which ones are the
    point lights and which one is the lamp. As you can see, we have the spotlight
    that is attached, and we also have the general directional light. You might be
    thinking that it''s hard to tell which light is which, and generally, in the real
    world, it''s hard to tell too. Light has an effect on everything around us, and
    this is how it works in the game. Now if you try to go further away from the object,
    our spotlight really isn''t affecting the cube anymore, but it''s still there,
    as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/123d6f1e-1ae6-46d3-bee8-3c5e1ceb4146.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we get closer to it, it starts affecting the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fa7a101-2e88-4f72-b9a4-8780bc8d8f4a.png)'
  prefs: []
  type: TYPE_IMG
- en: It's cool to see how the effect is combined with the other light sources. So,
    that's it for combining directional lights, point lights, and spotlights. There
    is a lot of lengthy code in this chapter, but a lot of it we've already done before.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed about the different types of light sources such
    as directional, point and spotlight. Then we learned how to combine these light
    source and the lighting effects to generate realistic lighting in our game world.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss about the cube maps and we'll learn to generate
    the skybox using for our game.
  prefs: []
  type: TYPE_NORMAL
