["```cpp\nclass LifeForm    // Abstract class definition\n{\nprivate:\n    // all LifeForms have a lifeExpectancy\n    int lifeExpectancy = 0; // in-class initialization\npublic:\n    LifeForm() = default; // def. ctor, uses in-class init \n    LifeForm(int life): lifeExpectancy(life) { }\n    // Remember, we get default copy, even w/o proto below\n    // LifeForm(const LifeForm &form) = default; \n    // Must include prototype to specify virtual destructor\n    virtual ~LifeForm() = default;   // virtual destructor\n    // Recall, [[nodiscard]] requires ret. value to be used\n    [[nodiscard]] int GetLifeExpectancy() const \n        { return lifeExpectancy; }\n    virtual void Print() const = 0; // pure virtual fns. \n    virtual string IsA() const = 0;   \n    virtual string Speak() const = 0;\n};\n```", "```cpp\nclass Charitable    // interface class definition\n{                   // implemented using an abstract class\npublic:\n    virtual void Give(float) = 0; // interface for 'giving'\n    // must include prototype to specify virtual destructor\n    virtual ~Charitable() = default; // remember virt. dest\n};\nclass Person: public Charitable   // mix-in an 'interface'\n{\n    // Assume typical Person class definition w/ data\n    // members, constructors, member functions exist.\npublic:\n    virtual void Give(float amt) override\n    {  // implement a means for giving here \n    }\n    ~Person() override;  // virtual destructor prototype\n};\n// Student Is-A Person which mixes-in Charitable interface\nclass Student: public Person \n{   \n    // Assume typical Student class definition w/ data\n    // members, constructors, member functions exist.\npublic:\n    virtual void Give(float amt) override\n    {  // Should a Student have little money to give,\n       // perhaps they can donate their time equivalent to\n       // the desired monetary amount they'd like to give\n    }\n    ~Student() override;  // virtual destructor prototype \n};\n```", "```cpp\n#include <iostream>\n#include <iomanip>\nusing std::cout;     // preferred to:  using namespace std;\nusing std::endl;\nusing std::setprecision;\nusing std::string;\nusing std::to_string;\nconstexpr int MAX = 5;\nclass LifeForm   // abstract class definition\n{\nprivate:\n   int lifeExpectancy = 0;  // in-class initialization\npublic:\n   LifeForm() = default;\n   LifeForm(int life): lifeExpectancy(life) { }\n   // Remember, we get the default copy ctor included,\n   // even without the prototype below:\n   // LifeForm(const LifeForm &) = default; \n   // Must include prototype to specify virtual destructor\n   virtual ~LifeForm() = default;     // virtual destructor\n   [[nodiscard]] int GetLifeExpectancy() const \n       { return lifeExpectancy; }\n   virtual void Print() const = 0;   // pure virtual fns. \n   virtual string IsA() const = 0;   \n   virtual string Speak() const = 0;\n};\n```", "```cpp\nclass Cat: public LifeForm\n{\nprivate:\n   int numberLivesLeft = 9;  // in-class initialization\n   string name;\n   static constexpr int CAT_LIFE = 15;  // Life exp for cat\npublic:\n   Cat(): LifeForm(CAT_LIFE) { } // note prior in-class init\n   Cat(int lives): LifeForm(CAT_LIFE),\n                   numberLivesLeft(lives) { }\n   Cat(const string &);\n   // Because base class destructor is virtual, ~Cat() is \n   // automatically virtual (overridden) whether or not \n   // explicitly prototyped. Below prototype not needed:\n   // ~Cat() override = default;   // virtual destructor\n   const string &GetName() const { return name; }\n   int GetNumberLivesLeft() const \n       { return numberLivesLeft; }\n   void Print() const override; // redef pure virt fns\n   string IsA() const override { return \"Cat\"; }\n   string Speak() const override { return \"Meow!\"; }\n};\nCat::Cat(const string &n) : LifeForm(CAT_LIFE), name(n)\n{  // numLivesLeft will be set with in-class initialization\n}\nvoid Cat::Print() const\n{\n   cout << \"\\t\" << name << \" has \" << numberLivesLeft;\n   cout << \" lives left\" << endl;\n}\n```", "```cpp\nclass Person: public LifeForm\n{\nprivate: \n    string firstName;\n    string lastName;\n    char middleInitial = '\\0';\n    string title;  // Mr., Ms., Mrs., Miss, Dr., etc.\n    static constexpr int PERSON_LIFE = 80;  // Life exp of\nprotected:                                  // a Person\n    void ModifyTitle(const string &);  \npublic:\n    Person();   // programmer-specified default constructor\n    Person(const string &, const string &, char, \n           const string &);  \n    // Default copy constructor prototype is not necessary:\n    // Person(const Person &) = default;  // copy const.\n    // Because base class destructor is virtual, ~Person() \n    // is automatically virtual (overridden) whether or not \n    // explicitly prototyped. Below prototype not needed:\n    // ~Person() override = default;  // destructor\n    const string &GetFirstName() const \n        { return firstName; }  \n    const string &GetLastName() const \n        { return lastName; }    \n    const string &GetTitle() const { return title; } \n    char GetMiddleInitial() const { return middleInitial; }\n    void Print() const override; // redef pure virt fns\n    string IsA() const override;   \n    string Speak() const override;\n};\n```", "```cpp\n// select the desired base constructor using mbr. init list\nPerson::Person(): LifeForm(PERSON_LIFE) \n{  // Remember, middleInitial will be set w/ in-class init\n   // and the strings will be default constructed to empty\n}\nPerson::Person(const string &fn, const string &ln, char mi,\n               const string &t): LifeForm(PERSON_LIFE), \n                               firstName(fn), lastName(ln),\n                               middleInitial(mi), title(t)\n{\n}\n// We're using the default copy constructor. But if we did\n// choose to prototype and define it, the method would be:\n// Person::Person(const Person &p): LifeForm(p),\n//           firstName(p.firstName), lastName(p.lastName),\n//           middleInitial(p.middleInitial), title(p.title)\n// {\n// }\nvoid Person::ModifyTitle(const string &newTitle)\n{\n   title = newTitle;\n}\nvoid Person::Print() const\n{\n   cout << \"\\t\" << title << \" \" << firstName << \" \";\n   cout << middleInitial << \". \" << lastName << endl;\n}\nstring Person::IsA() const\n{  \n   return \"Person\";  \n}\nstring Person::Speak() const \n{  \n   return \"Hello!\";  \n}  \n```", "```cpp\nclass Student: public Person\n{\nprivate: \n    float gpa = 0.0;  // in-class initialization\n    string currentCourse;\n    const string studentId;  \n    static int numStudents;\npublic:\n    Student();  // programmer-supplied default constructor\n    Student(const string &, const string &, char, \n            const string &, float, const string &, \n            const string &); \n    Student(const Student &);  // copy constructor\n    ~Student() override;  // virtual destructor\n    void EarnPhD();  \n    float GetGpa() const { return gpa; }\n    const string &GetCurrentCourse() const \n       { return currentCourse; }\n    const string &GetStudentId() const \n       { return studentId; }\n    void SetCurrentCourse(const string &);\n    // Redefine not all of the virtrtual function; don't \n    // override Person::Speak(). Also, mark Print() as \n    // the final override\n    void Print() const final override; \n    string IsA() const override;\n    static int GetNumberStudents();  \n};\nint Student::numStudents = 0; // static data mbr def/init\ninline void Student::SetCurrentCourse(const string &c)\n{\n    currentCourse = c; \n}\ninline int Student::GetNumberStudents()\n{\n    return numStudents;\n}\n```", "```cpp\n// default constructor\nStudent::Student(): studentId(to_string(numStudents + 100) \n                                         + \"Id\")\n{   // Set const studentId in mbr init list with unique id \n    // (based upon numStudents counter + 100), concatenated\n    // with the string \"Id\". Remember, string member\n    // currentCourse will be default constructed with\n    // an empty string - it is a member object\n    numStudents++;\n}\n// Alternate constructor member function definition\nStudent::Student(const string &fn, const string &ln, \n                 char mi, const string &t, float avg, \n                 const string &course, const string &id):\n                 Person(fn, ln, mi, t), gpa(avg),\n                 currentCourse(course), studentId(id)\n{\n    numStudents++;\n}\n// Copy constructor definition\nStudent::Student(const Student &s) : Person(s), \n                 gpa(s.gpa), \n                 currentCourse(s.currentCourse),\n                 studentId(s.studentId)\n{\n    numStudents++;\n}\n// destructor definition\nStudent::~Student()\n{\n    numStudents--;\n}\nvoid Student::EarnPhD()  \n{   \n   ModifyTitle(\"Dr.\");  \n}\nvoid Student::Print() const\n{\n   cout << \"\\t\" << GetTitle() << \" \" << GetFirstName();\n   cout << \" \" << GetMiddleInitial() << \". \" \n        << GetLastName();\n   cout << \" id: \" << studentId << \"\\n\\twith gpa: \";\n   cout << setprecision(3) << \" \" << gpa \n        << \" enrolled in: \" << currentCourse << endl;\n}\nstring Student::IsA() const\n{  \n   return \"Student\";  \n}\n```", "```cpp\nint main()\n{\n   // Notice that we are creating an array of POINTERS to\n   // LifeForms. Since LifeForm cannot be instantiated, \n   // we could not create an array of LifeForm(s).\n   LifeForm *entity[MAX] = { }; // init. with nullptrs\n   entity[0] = new Person(\"Joy\", \"Lin\", 'M', \"Ms.\");\n   entity[1] = new Student(\"Renee\", \"Alexander\", 'Z',\n                           \"Dr.\", 3.95, \"C++\", \"21-MIT\"); \n   entity[2] = new Student(\"Gabby\", \"Doone\", 'A', \"Ms.\", \n                            3.95, \"C++\", \"18-GWU\"); \n   entity[3] = new Cat(\"Katje\");\n   entity[4] = new Person(\"Giselle\", \"LeBrun\", 'R',\n                          \"Miss\");\n   // Use range for-loop to process each element of entity\n   for (LifeForm *item : entity)  // each item is a \n   {                              // LifeForm *       \n      cout << item->Speak();\n      cout << \" I am a \" << item->IsA() << endl;\n      item->Print();\n      cout << \"\\tHas a life expectancy of: \";\n      cout << item->GetLifeExpectancy();\n      cout << \"\\n\";\n   }\n   for (LifeForm *item : entity) // process each element \n   {                             // in the entity array    \n      delete item;\n      item = nullptr;   // ensure deleted ptr isn't used\n   }\n   return 0;\n}\n```", "```cpp\nHello! I am a Person\n        Ms. Joy M. Lin\n        Has a life expectancy of: 80\nHello! I am a Student\n        Dr. Renee Z. Alexander id: 21-MIT\n        with gpa:  3.95 enrolled in: C++\n        Has a life expectancy of: 80\nHello! I am a Student\n        Ms. Gabby A. Doone id: 18-GWU\n        with gpa:  3.95 enrolled in: C++\n        Has a life expectancy of: 80\nMeow! I am a Cat\n        Katje has 9 lives left\n        Has a life expectancy of: 15\nHello! I am a Person\n        Miss Giselle R. LeBrun\n        Has a life expectancy of: 80     \n```"]