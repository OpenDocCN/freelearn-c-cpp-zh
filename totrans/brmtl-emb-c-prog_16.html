<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer129">
			<h1 id="_idParaDest-268" class="chapter-number"><a id="_idTextAnchor448"/>16</h1>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor449"/>Independent Watchdog (IWDG)</h1>
			<p>In this chapter, we’ll learn about<a id="_idIndexMarker1116"/> the <strong class="bold">Independent Watchdog</strong> (<strong class="bold">IWDG</strong>) timer, a unique component for enhancing the reliability of embedded systems. IWDG is essential for monitoring the system’s operation and ensuring it can recover from unexpected faults <span class="No-Break">or malfunctions.</span></p>
			<p>We will begin by exploring the general concept<a id="_idIndexMarker1117"/> of <strong class="bold">watchdog timers</strong> (<strong class="bold">WDTs</strong>) and their importance in embedded systems. Following this, we will examine how WDTs function and the unique features of IWDG. Next, we will focus specifically on the STM32 implementation of the IWDG, looking at its key registers and configuration. Finally, we will apply this knowledge to develop a bare-metal IWDG driver, providing practical code examples to solidify <span class="No-Break">our understanding.</span></p>
			<p>In this chapter, we will cover the following <span class="No-Break">main topics<a id="_idTextAnchor450"/>:</span></p>
			<ul>
				<li><span class="No-Break">Understanding WDTs</span></li>
				<li>Types <span class="No-Break">of WDTs</span></li>
				<li>The <span class="No-Break">STM32 IWD<a id="_idTextAnchor451"/>G</span></li>
				<li>Developing the <span class="No-Break">IWDG driver</span></li>
			</ul>
			<p>By the end of this chapter, you will have a comprehensive understanding of IWDG timers and their critical role in embedded systems. You will also gain skills to develop and implement IWDG drivers for STM32 microcontrollers, ensuring your systems can maintain robustness <span class="No-Break">and reliability.</span></p>
			<h1 id="_idParaDest-270"><a id="_idTextAnchor452"/>Technical requirements</h1>
			<p>All code examples for this chapter can be found on GitHub at the <span class="No-Break">following link:</span></p>
			<p><a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming"><span class="No-Break">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</span></a></p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor453"/>Understanding WDTs</h1>
			<p>WDTs<a id="_idIndexMarker1118"/> are one of the unsung heroes of embedded systems. They quietly monitor the system’s health, ensuring it can recover gracefully from unexpected hitches. Imagine them as vigilant guards, always on the lookout for system malfunctions, ready to reset the microcontroller if something goes wrong. In this section, we’ll explore what WDTs are and how they function, and dive into some common use cases to illustrate <span class="No-Break">their importance.</span></p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor454"/>What are WDTs?</h2>
			<p>WDTs are<a id="_idIndexMarker1119"/> like guardians for your microcontroller. Imagine you’re using a device, and something goes wrong—a bug in the developer’s code causes an infinite loop, or a hardware glitch freezes the system. Without a watchdog, your device would be stuck, potentially causing significant problems, especially in critical applications such as medical devices or <span class="No-Break">automotive systems.</span></p>
			<p>A WDT is a hardware or software timer that resets the system if the main program fails to reset the timer before it expires. It’s a simple yet powerful mechanism to ensure that your system can recover from unexpected issues. Let’s see how <span class="No-Break">they work.</span></p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor455"/>How WDTs work</h2>
			<p>Think of a<a id="_idIndexMarker1120"/> WDT as an hourglass that you need to turn over regularly to prevent it from running out of sand. Here’s a step-by-step breakdown of how <span class="No-Break">it works:</span></p>
			<ol>
				<li><strong class="bold">Initialization</strong>: When your system starts, you initialize the WDT with a specific timeout period. This period is the maximum time your system can run without resetting <span class="No-Break">the timer.</span></li>
				<li><strong class="bold">Countdown</strong>: The WDT starts counting down from the set timeout value. If it reaches zero, it assumes something went wrong and triggers a <span class="No-Break">system reset.</span></li>
				<li><strong class="bold">Resetting the timer</strong>: Your main program needs to periodically reset the WDT before it reaches zero. This action is often <a id="_idIndexMarker1121"/>called <strong class="bold">feeding the watchdog</strong> or <strong class="bold">kicking the dog</strong>. If the <a id="_idIndexMarker1122"/>program is running correctly, it will continue to reset the timer, preventing <span class="No-Break">a reset.</span></li>
				<li><strong class="bold">System reset</strong>: If your program fails to reset the WDT in time—perhaps because it got stuck in an infinite loop or encountered a critical error—the WDT will expire <a id="_idIndexMarker1123"/>and reset the system, bringing it back to a <span class="No-Break">known state.</span></li>
			</ol>
			<p>Now that we understand the basics, let’s look at some real-world applications where WDTs play a <span class="No-Break">crucial role.</span></p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor456"/>Common use cases</h2>
			<p>Following is a list of some <span class="No-Break">real-world applications.</span></p>
			<h3>Industrial automation</h3>
			<p>In industrial automation, reliability<a id="_idIndexMarker1124"/> is paramount. Machines and processes need to run continuously and without failure. WDTs ensure that if a <strong class="bold">Programmable Logic Controller</strong> (<strong class="bold">PLC</strong>) or other <a id="_idIndexMarker1125"/>control systems hang or crash, they can <span class="No-Break">quickly recover.</span></p>
			<p><em class="italic">Example</em>: Imagine a conveyor belt system in a manufacturing plant. The PLC controlling the conveyor belt has a WDT set to 1 second. If the PLC software fails to reset the watchdog within 1 second due to a software bug or external interference, the WDT will reset the PLC. This reset ensures that the conveyor belt can resume operation with minimal downtime, preventing potential <span class="No-Break">production losses.</span></p>
			<h3>Automotive systems</h3>
			<p>Modern vehicles rely heavily on<a id="_idIndexMarker1126"/> embedded systems for various functions, from engine control to infotainment. WDTs are vital in ensuring these systems <span class="No-Break">operate reliably.</span></p>
			<p><em class="italic">Example</em>: Consider <a id="_idIndexMarker1127"/>an <strong class="bold">engine control unit</strong> (<strong class="bold">ECU</strong>) in a car. The ECU monitors and controls critical engine parameters. A WDT in the ECU might be set to 500 milliseconds. If the ECU software fails to reset the watchdog due to a fault, the WDT resets the<a id="_idIndexMarker1128"/> ECU. This reset can prevent engine misbehavior, ensuring the vehicle <span class="No-Break">operates safely.</span></p>
			<h3>Medical devices</h3>
			<p>In medical devices, WDTs<a id="_idIndexMarker1129"/> can be life-saving. Devices such as pacemakers, infusion pumps, and patient monitors must operate <span class="No-Break">without failure.</span></p>
			<p><em class="italic">Example</em>: Take a patient monitor that tracks vital signs such as heart rate and blood pressure. The monitor’s software includes a WDT set to 2 seconds. If the software encounters a problem and fails to reset the watchdog, the device will reset. This reset ensures the monitor can quickly recover and continue providing accurate, real-time data, which is crucial for <span class="No-Break">patient care.</span></p>
			<h3>Consumer electronics</h3>
			<p>Even in consumer electronics, WDTs <a id="_idIndexMarker1130"/>help maintain system reliability and enhance user experience. Think of smartphones, smart home devices, and <span class="No-Break">gaming consoles.</span></p>
			<p><em class="italic">Example</em>: In a smart thermostat, the software manages temperature settings and connectivity. A WDT ensures that if the software freezes, the system resets and continues operating. This functionality prevents users from experiencing extended downtime, maintaining comfort and convenience in <span class="No-Break">their homes.</span></p>
			<p>These examples illustrate the crucial role that WDTs play in modern systems. When implementing WDTs, it’s essential to consider several key factors to ensure their effectiveness. Let’s see some of <span class="No-Break">these factors.</span></p>
			<h3>Practical considerations</h3>
			<p>When implementing WDTs, you <a id="_idIndexMarker1131"/>must consider <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Timeout period</strong>: Choose an appropriate timeout period based on your application’s needs. Too short, and you risk unnecessary resets; too long, and you might not recover quickly enough <span class="No-Break">from faults.</span></li>
				<li><strong class="bold">Reset mechanism</strong>: Ensure that resetting the WDT (feeding the dog) is done in a part of your code that runs regularly and indicates the system is <span class="No-Break">operating correctly.</span></li>
				<li><strong class="bold">Recovery strategy</strong>: Plan how your system should recover after a watchdog reset. Ensure critical data is preserved and the system returns to a <span class="No-Break">safe state.</span></li>
				<li><strong class="bold">Testing</strong>: Thoroughly<a id="_idIndexMarker1132"/> test your WDT implementation to ensure it behaves as expected under various <span class="No-Break">fault conditions.</span></li>
			</ul>
			<p>Next, let’s see the types of <span class="No-Break">WDTs available.</span></p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor457"/>Types of WDTs</h2>
			<p>WDTs can be categorized into several types based on their functionality and integration. Let’s explore the most <span class="No-Break">common types.</span></p>
			<h3>Internal WDTs</h3>
			<p>Internal WDTs are built into the<a id="_idIndexMarker1133"/> microcontroller. They are a<a id="_idIndexMarker1134"/> convenient option because they don’t require additional external components. These timers are directly integrated into the microcontroller’s architecture and can be configured <span class="No-Break">through software.</span></p>
			<p>They have the <span class="No-Break">following features:</span></p>
			<ul>
				<li><strong class="bold">Integration</strong>: No need for<a id="_idIndexMarker1135"/> <span class="No-Break">external circuitry</span></li>
				<li><strong class="bold">Configuration</strong>: Typically configured using the <span class="No-Break">microcontroller’s registers</span></li>
				<li><strong class="bold">Power</strong>: They can continue to operate in low-power modes, making them suitable for <span class="No-Break">battery-powered applications</span></li>
			</ul>
			<p><em class="italic">Example use case</em>: In a small IoT device, an internal WDT can monitor the microcontroller’s operation without adding extra hardware, ensuring the device can reset itself if it encounters <span class="No-Break">an error.</span></p>
			<h3>External WDTs</h3>
			<p>External WDTs<a id="_idIndexMarker1136"/> are separate components connected to the microcontroller. These timers <a id="_idIndexMarker1137"/>provide additional flexibility and can be used when the internal WDT isn’t sufficient or if redundancy <span class="No-Break">is required.</span></p>
			<p>Here is a list of <a id="_idIndexMarker1138"/><span class="No-Break">their features:</span></p>
			<ul>
				<li><strong class="bold">Flexibility</strong>: Can be chosen based on specific requirements (for example, longer <span class="No-Break">timeout periods)</span></li>
				<li><strong class="bold">Redundancy</strong>: Adding an external watchdog provides an extra layer <span class="No-Break">of safety</span></li>
				<li><strong class="bold">Independence</strong>: Operate independently of the microcontroller’s clock <span class="No-Break">and power</span></li>
			</ul>
			<p><em class="italic">Example use case</em>: In a critical automotive system, an external WDT can provide an additional safeguard, ensuring the system resets even if the internal <span class="No-Break">timer fails.</span></p>
			<h3>Windowed WDTs</h3>
			<p><strong class="bold">Windowed WDTs</strong> (<strong class="bold">WWDTs</strong>) add an <a id="_idIndexMarker1139"/>extra layer of control by<a id="_idIndexMarker1140"/> introducing a <em class="italic">window</em> period. The system must reset the timer within a specific window period; too early or too late resets the system. This prevents scenarios where the software gets stuck in a loop resetting the watchdog too frequently (which could mask <span class="No-Break">a malfunction).</span></p>
			<p>Their features<a id="_idIndexMarker1141"/> include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Precision</strong>: Require the timer to be reset within a specific <span class="No-Break">time window</span></li>
				<li><strong class="bold">Fault detection</strong>: Can detect both early and late watchdog resets, offering improved <span class="No-Break">fault detection</span></li>
				<li><strong class="bold">Security</strong>: Enhance system security by ensuring the timer is reset at <span class="No-Break">appropriate intervals</span></li>
			</ul>
			<p><em class="italic">Example use case</em>: In a medical device, a WWDT ensures the control software operates correctly within defined time intervals, adding an extra layer <span class="No-Break">of reliability.</span></p>
			<h3>IWDGs</h3>
			<p>IWDGs<a id="_idIndexMarker1142"/> are designed to be<a id="_idIndexMarker1143"/> robust and reliable. They run from a separate clock source, usually a <strong class="bold">low-speed internal</strong> (<strong class="bold">LSI</strong>) clock, and<a id="_idIndexMarker1144"/> operate independently of the main system clock. This independence ensures they continue to function even if the main <span class="No-Break">clock fails.</span></p>
			<p>Their features<a id="_idIndexMarker1145"/> include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Independence</strong>: Operate from a separate <span class="No-Break">clock source</span></li>
				<li><strong class="bold">Robustness</strong>: Continue functioning even if the main system <span class="No-Break">clock fails</span></li>
				<li><strong class="bold">Minimal configuration</strong>: Typically simple to configure <span class="No-Break">and use</span></li>
			</ul>
			<p><em class="italic">Example use case</em>: In an <strong class="bold">industrial control system</strong> (<strong class="bold">ICS</strong>), an IWDG ensures the system can recover from malfunctions, even<a id="_idIndexMarker1146"/> if the main clock source <span class="No-Break">is disrupted.</span></p>
			<p>Selecting the appropriate WDT depends on several factors, including the criticality of the application, power constraints, and <span class="No-Break">required reliability.</span></p>
			<h3>Choosing the right WDT</h3>
			<p>Here’s a quick guide to<a id="_idIndexMarker1147"/> help you choose the <span class="No-Break">right WDT:</span></p>
			<ul>
				<li><strong class="bold">For low-power applications</strong>: Consider internal WDTs due to their integration and low <span class="No-Break">power consumption</span></li>
				<li><strong class="bold">For high-reliability systems</strong>: Use external WDTs <span class="No-Break">for redundancy</span></li>
				<li><strong class="bold">For applications requiring precise timing</strong>: WWDTs provide enhanced <span class="No-Break">fault detection</span></li>
				<li><strong class="bold">For systems needing robust operation</strong>: IWDGs offer continued functionality even if the main <span class="No-Break">clock fails</span></li>
			</ul>
			<p>Understanding the different types of WDTs and their features allows us to choose the right one for our applications. Whether it’s an internal WDT for simplicity, an external one for redundancy, a WWDT for precise control, or an IWDG for robustness, there’s a WDT suited for <span class="No-Break">every need.</span></p>
			<p>In the upcoming section, we will delve into the IWDG embedded within the STM32F411 microcontroller, examining its features and how to leverage it for enhanced <span class="No-Break">system reliability.</span></p>
			<h1 id="_idParaDest-276"><a id="_idTextAnchor458"/>The STM32 IWDG</h1>
			<p>In this section, we’ll analyze the<a id="_idIndexMarker1148"/> STM32 IWDG module, exploring its main features and other relevant information to help you understand how to leverage this powerful feature in your <span class="No-Break">embedded applications.</span></p>
			<p>STM32 microcontrollers feature two<a id="_idIndexMarker1149"/> types of WDTs: the IWDG<a id="_idIndexMarker1150"/> and the <strong class="bold">Window Watchdog</strong> (<strong class="bold">WWDG</strong>). Both are essential for detecting and correcting software malfunctions by initiating a system reset, but they each have unique characteristics <span class="No-Break">and applications.</span></p>
			<p>The IWDG operates using a dedicated LSI clock, ensuring it continues to function even if the main system clock fails. This makes it highly reliable for applications that require continuous monitoring, regardless of the main clock’s state. In contrast, the WWDG derives its clock from the APB1 clock and features a configurable time window. The system must refresh the WWDG within this time window; failing to do so, either too early or too late, will trigger a <span class="No-Break">system reset.</span></p>
			<p>The IWDG is best suited for applications needing an independent watchdog process with lower timing accuracy constraints, while the WWDG is ideal for applications requiring precise timing windows. Let’s see some key features of <span class="No-Break">the IWDG.</span></p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor459"/>Key features of the IWDG</h2>
			<p>The IWDG in STM32 microcontrollers boasts several <span class="No-Break">key features:</span></p>
			<ul>
				<li><strong class="bold">Free-running downcounter</strong>: The <a id="_idIndexMarker1151"/>IWDG operates as a free-running downcounter, continuously counting down from a <span class="No-Break">preset value</span></li>
				<li><strong class="bold">Independent clock source</strong>: It uses an independent <strong class="bold">resistor-capacitor</strong> (<strong class="bold">RC</strong>) oscillator, allowing <a id="_idIndexMarker1152"/>it to function in low-power modes such as Standby <span class="No-Break">and Stop</span></li>
				<li><strong class="bold">System reset on timeout</strong>: If the WDT is activated and the downcounter reaches zero (0x000), a system reset <span class="No-Break">is triggered</span></li>
				<li><strong class="bold">Write access protection</strong>: To modify critical registers, a specific sequence of operations <a id="_idIndexMarker1153"/>is required, ensuring protection against accidental or <span class="No-Break">malicious modifications</span></li>
			</ul>
			<p>Let’s see how <span class="No-Break">it works.</span></p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor460"/>How the IWDG works</h2>
			<p>The IWDG<a id="_idIndexMarker1154"/> module operates as an independent safeguard for the microcontroller, ensuring the system can recover from software malfunctions. <span class="No-Break"><em class="italic">Figure 16</em></span><em class="italic">.1</em> presents a block diagram of the IWDG, sourced from the <span class="No-Break">reference manual:</span></p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/B21914_16_1.jpg" alt="Figure 16.1: IWDG block diagram" width="1650" height="549"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.1: IWDG block diagram</p>
			<p>Let’s break down its functional blocks and how <span class="No-Break">it operates:</span></p>
			<ul>
				<li><strong class="bold">Starting the IWDG</strong>: To start the IWDG, we write the value <strong class="source-inline">0xCCCC</strong> to the Key Register (<strong class="source-inline">IWDG_KR</strong>). This action initiates the downcounter, which begins counting down from the reset value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">0xFFF</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Preventing a reset</strong>: To prevent the WDT from reaching zero and triggering a reset, the counter must be periodically reloaded. This is done by writing the value <strong class="source-inline">0xAAAA</strong> to the <strong class="source-inline">IWDG_KR</strong> register, which reloads the counter with the value from the Reload Register (<strong class="source-inline">IWDG_RLR</strong>) and prevents <span class="No-Break">a reset.</span></li>
				<li><strong class="bold">Hardware watchdog feature</strong>: If enabled, the IWDG is automatically activated at power-on. In this mode, the WDT will generate a reset unless the Key Register is written with the appropriate value before the counter <span class="No-Break">reaches zero.</span></li>
				<li><strong class="bold">Register access protection</strong>: To modify the prescaler (<strong class="source-inline">IWDG_PR</strong>) and reload (<strong class="source-inline">IWDG_RLR</strong>) registers, we must temporarily disable write access protection by writing the code <strong class="source-inline">0x5555</strong> to the <strong class="source-inline">IWDG_KR</strong> register. After doing this, any changes to these registers must be made immediately; otherwise, access protection will <span class="No-Break">be</span><span class="No-Break"><a id="_idIndexMarker1155"/></span><span class="No-Break"> re-enabled.</span></li>
			</ul>
			<p>With this general overview of the IWDG block in mind, let’s analyze the key registers one <span class="No-Break">by one.</span></p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor461"/>IWDG registers</h2>
			<p>In this<a id="_idIndexMarker1156"/> section, we will explore the characteristics and functions of some of the crucial registers within the <span class="No-Break">IWDG peripheral.</span></p>
			<p>Let’s start with the <strong class="bold">IWDG Key </strong><span class="No-Break"><strong class="bold">Register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">IWDG_KR</strong></span><span class="No-Break">).</span></p>
			<h3>IWDG Key Register (IWDG_KR)</h3>
			<p>The <strong class="source-inline">IWDG_KR</strong> register is a key <a id="_idIndexMarker1157"/>register used to control the IWDG’s operations, including starting the watchdog, reloading the counter, and disabling write access to other registers. This register is pivotal in managing the <span class="No-Break">IWDG’s functionality.</span></p>
			<p>Key operations in this register include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">0xCCCC</strong>: Start the IWDG. Writing this value to <strong class="source-inline">IWDG_KR</strong> starts the <span class="No-Break">IWDG timer.</span></li>
				<li><strong class="source-inline">0xAAAA</strong>: Reload the counter. Writing this value reloads the IWDG counter, preventing it from reaching zero and triggering a <span class="No-Break">system reset.</span></li>
				<li><strong class="source-inline">0x5555</strong>: Disable write protection. This value allows modifications to the prescaler and <span class="No-Break">reload registers.</span></li>
			</ul>
			<p>Next, let’s discuss the <strong class="bold">IWDG Prescaler </strong><span class="No-Break"><strong class="bold">Register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">IWDG_PR</strong></span><span class="No-Break">).</span></p>
			<h3>IWDG Prescaler Register (IWDG_PR)</h3>
			<p>The <strong class="source-inline">IWDG_PR</strong> register is<a id="_idIndexMarker1158"/> used to set the prescaler value, which determines the frequency<a id="_idIndexMarker1159"/> of the IWDG clock by dividing the LSI clock. Adjusting this register helps configure the countdown speed of <span class="No-Break">the WDT.</span></p>
			<p>Key bits in this register is <strong class="source-inline">PR[2:0]</strong>: Prescaler value. These bits can be set to divide the LSI clock by 4, 8, 16, 32, 64, 128, or 256, allowing flexibility in setting the <span class="No-Break">WDT interval.</span></p>
			<p>Next, we move on to the <strong class="bold">IWDG Reload </strong><span class="No-Break"><strong class="bold">Register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">IWDG_RLR</strong></span><span class="No-Break">).</span></p>
			<h3>IWDG Reload Register (IWDG_RLR)</h3>
			<p>The <strong class="source-inline">IWDG_RLR</strong> register defines the reload <a id="_idIndexMarker1160"/>value for the IWDG counter. This value determines the timeout period before the watchdog triggers a system reset if not reloaded <span class="No-Break">in time.</span></p>
			<p>The key field in this register is <strong class="source-inline">RL[11:0]</strong>; this means reload value. It is a 12-bit value that sets the counter’s reload value, which can range from 0x000 <span class="No-Break">to 0xFFF.</span></p>
			<p>Finally, we examine the <strong class="bold">IWDG Status </strong><span class="No-Break"><strong class="bold">Register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">IWDG_SR</strong></span><span class="No-Break">).</span></p>
			<h3>IWDG Status Register (IWDG_SR)</h3>
			<p>The <strong class="source-inline">IWDG_SR</strong> register provides status<a id="_idIndexMarker1161"/> information about the IWDG, indicating whether updates to the prescaler or reload registers <span class="No-Break">are ongoing.</span></p>
			<p>Key bits in this register include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">PVU</strong>: <strong class="bold">Prescaler value update</strong> (<strong class="bold">PVU</strong>). This bit<a id="_idIndexMarker1162"/> indicates that the prescaler value is <span class="No-Break">being updated.</span></li>
				<li><strong class="source-inline">RVU</strong>: <strong class="bold">Reload value update</strong> (<strong class="bold">RVU</strong>). This <a id="_idIndexMarker1163"/>bit indicates that the reload value is <span class="No-Break">being updated.</span></li>
			</ul>
			<p>With a clear understanding of the IWDG’s functionality and its registers, we can now move on to the next section, where we will develop the <span class="No-Break">IWDG driver.</span></p>
			<h1 id="_idParaDest-280"><a id="_idTextAnchor462"/>Developing the IWDG driver</h1>
			<p>In this section, we’ll <a id="_idIndexMarker1164"/>use what we’ve learned so far in this chapter to develop the <span class="No-Break">IWDG driver.</span></p>
			<p>Let’s start by setting up <span class="No-Break">the project.</span></p>
			<p>Create a copy of your previous project in your IDE, following the steps outlined in earlier chapters. Rename this copied project to <strong class="source-inline">IWDG</strong>. Next, create a new file named <strong class="source-inline">iwdg.c</strong> in the <strong class="source-inline">Src</strong> folder and another file named <strong class="source-inline">iwdg.h</strong> in the <span class="No-Break"><strong class="source-inline">Inc</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor463"/>The IWDG implementation file</h2>
			<p>Populate your <strong class="source-inline">iwdg.c</strong> file with the<a id="_idIndexMarker1165"/> <span class="No-Break">following code:</span></p>
			<pre class="source-code">
<strong class="bold">#include</strong> "iwdg.h"
<strong class="bold">#define</strong> IWDG_KEY_ENABLE                 0x0000CCCCU
<strong class="bold">#define</strong> IWDG_KEY_WR_ACCESS_ENABLE       0x00005555U
<strong class="bold">#define</strong> IWDG_PRESCALER_4              0x00000000U
<strong class="bold">#define</strong> IWDG_RELOAD_VAL              0xFFF
<strong class="bold">static</strong> uint8_t <strong class="bold">isIwdg_ready</strong>(<strong class="bold">void</strong>);
<strong class="bold">void iwdg_init</strong>(<strong class="bold">void</strong>)
{
    /*Enable the IWDG by writing 0x0000CCCC in the IWDG_KR register*/
    IWDG-&gt;KR = IWDG_KEY_ENABLE;
    /*Enable register access by writing 0x0000 5555 in the IWDG_KR 
    register*/
    IWDG-&gt;KR = IWDG_KEY_WR_ACCESS_ENABLE;
    /*Set the IWDG <strong class="bold">Prescaler</strong>*/
    IWDG-&gt;PR =  IWDG_PRESCALER_4;
    /*Set the reload register (IWDG_RLR) to the largest value 0xFFF*/
    IWDG-&gt;RLR = IWDG_RELOAD_VAL;
    /*Wait for the registers to be updated (IWDG_SR = 0x0000 0000)*/
    <strong class="bold">while</strong>(isIwdg_ready() != 1){}
    /*Refresh the counter value with IWDG_KR (IWDG_KR = 0x0000 AAAA)*/
    IWDG-&gt;KR = IWDG_KEY_RELOAD;
}
<strong class="bold">static</strong> uint8_t <strong class="bold">isIwdg_ready</strong>(<strong class="bold">void</strong>)
{
<strong class="bold"> return</strong> ((READ_BIT(IWDG-&gt;SR, IWDG_SR_PVU | IWDG_SR_RVU) == 0U) ? 1UL : 
 0UL);
}</pre>			<p>Let’s <a id="_idIndexMarker1166"/>break it down. Let’s look at the <strong class="bold">macro </strong><span class="No-Break"><strong class="bold">definitions</strong></span><span class="No-Break"> first:</span></p>
			<pre class="source-code">
#include "iwdg.h"
#define IWDG_KEY_ENABLE                 0x0000CCCCU
#define IWDG_KEY_WR_ACCESS_ENABLE       0x00005555U
#define IWDG_PRESCALER_4                0x00000000U
#define IWDG_RELOAD_VAL                 0xFFF</pre>			<ul>
				<li><strong class="source-inline">IWDG_KEY_ENABLE</strong>: This macro defines the key to enable <span class="No-Break">the IWDG</span></li>
				<li><strong class="source-inline">IWDG_KEY_WR_ACCESS_ENABLE</strong>: This macro defines the key to enable write access to <span class="No-Break">IWDG registers</span></li>
				<li><strong class="source-inline">IWDG_PRESCALER_4</strong>: This <a id="_idIndexMarker1167"/>macro defines the prescaler value for <span class="No-Break">the IWDG</span></li>
				<li><strong class="source-inline">IWDG_RELOAD_VAL</strong>: This macro sets the reload value to the maximum, 0xFFF, providing the longest <span class="No-Break">timeout period</span></li>
			</ul>
			<p>Next, we have the <span class="No-Break"><strong class="source-inline">iwdg_init()</strong></span><span class="No-Break"> function.</span></p>
			<pre class="source-code">
IWDG-&gt;KR = IWDG_KEY_ENABLE;</pre>			<p>This line writes <strong class="source-inline">0x0000CCCC</strong> to the IWDG <strong class="bold">Key Register</strong> (<strong class="bold">KR</strong>) to enable <span class="No-Break">the IWDG.</span></p>
			<pre class="source-code">
IWDG-&gt;KR = IWDG_KEY_WR_ACCESS_ENABLE;</pre>			<p>This line writes <strong class="source-inline">0x00005555</strong> to the IWDG Key Register to enable write access to the prescaler and <span class="No-Break">reload registers.</span></p>
			<pre class="source-code">
IWDG-&gt;PR = IWDG_PRESCALER_4;</pre>			<p>This line sets the prescaler register to divide the clock by 4, as defined <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">IWDG_PRESCALER_4</strong></span><span class="No-Break">.</span></p>
			<pre class="source-code">
IWDG-&gt;RLR = IWDG_RELOAD_VAL;</pre>			<p>This sets the reload register to the maximum value of 0xFFF to get the longest possible <span class="No-Break">timeout period.</span></p>
			<pre class="source-code">
while (isIwdg_ready() != 1) {}</pre>			<p>This waits until the IWDG <strong class="bold">status register</strong> (<strong class="bold">SR</strong>) indicates that the prescaler and reload registers have been updated and <span class="No-Break">are ready.</span></p>
			<pre class="source-code">
IWDG-&gt;KR = IWDG_KEY_RELOAD;</pre>			<p>This writes <strong class="source-inline">0x0000AAAA</strong> to the IWDG Key Register to reload the counter and prevent the IWDG from resetting <span class="No-Break">the system.</span></p>
			<p>The <strong class="source-inline">isIwdg_ready()</strong> function checks the Status Register to see if the <strong class="source-inline">PVU</strong> and <strong class="source-inline">RVU</strong> bits are <a id="_idIndexMarker1168"/>cleared. It returns 1 if both bits are cleared, indicating that the IWDG is ready, or <span class="No-Break">0 otherwise.</span></p>
			<p>We are now ready to test <span class="No-Break">inside </span><span class="No-Break"><strong class="source-inline">main.c</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor464"/>The main file</h2>
			<p>Update<a id="_idIndexMarker1169"/> your <strong class="source-inline">main.c</strong> file as <span class="No-Break">shown next:</span></p>
			<pre class="source-code">
#include &lt;stdio.h&gt;
#include "adc.h"
#include "uart.h"
#include "gpio.h"
#include "iwdg.h"
#include "gpio_exti.h"
uint8_t g_btn_press;
static void check_reset_source(void);
int main(void)
{
    /*Initialize debug UART*/
    uart_init();
    /*Initialize LED*/
    led_init();
    /*Initialize EXTI*/
    pc13_exti_init();
    /*Find reset source*/
    check_reset_source();
    /*Initialize IWDG*/
    iwdg_init();
    while(1)
    {
        if( g_btn_press != 1)
         {
              /*Refresh IWDG down-counter to default value*/
             IWDG-&gt;KR = IWDG_KEY_RELOAD;
             led_toggle();
             <strong class="bold">for</strong>(<strong class="bold">int</strong> i = 0; i &lt; 90000; i++){}
         }
    }
}</pre>			<p>The <strong class="source-inline">main</strong> function kicks off<a id="_idIndexMarker1170"/> by setting up the <strong class="bold">universal asynchronous receiver-transmitter</strong> (<strong class="bold">UART</strong>) for <a id="_idIndexMarker1171"/>serial communication, ensuring that we can send debugging information to the serial port. Next, it initializes the LED and configures the external interrupt (<strong class="source-inline">EXTI</strong>) on pin <strong class="source-inline">PC13</strong>, which is connected to the blue push button. The function then calls <strong class="source-inline">check_reset_source</strong> to determine if the last reset was caused by the IWDG. After that, it initializes the IWDG itself, ensuring that the system can recover from software malfunctions. The <strong class="source-inline">main</strong> loop continually checks the state of <strong class="source-inline">g_btn_press</strong>; if the button hasn’t been pressed, it refreshes the IWDG to prevent a system reset and toggles the LED, providing a visual indicator of <span class="No-Break">system activity.</span></p>
			<p>Let’s look at the next part of <span class="No-Break">the code:</span></p>
			<pre class="source-code">
static void check_reset_source(void)
{
if ((RCC-&gt;CSR &amp; RCC_CSR_IWDGRSTF) == (RCC_CSR_IWDGRSTF))
      {
          /*Clear IWDG Reset flag*/
          RCC-&gt;CSR = RCC_CSR_RMVF;
          /*Turn LED On*/
          led_on();
          printf("RESET was caused by IWDG.....\n\r");
          while( g_btn_press != 1)
          {
          }
          g_btn_press =  0;
      }
}</pre>			<p>The <strong class="source-inline">check_reset_source</strong> function determines if the most recent system reset was triggered by the IWDG. It begins by checking the <strong class="bold">Reset and Clock Control</strong> (<strong class="bold">RCC</strong>) status register (<strong class="source-inline">CSR</strong>) for the IWDG <a id="_idIndexMarker1172"/>reset flag (<strong class="source-inline">RCC_CSR_IWDGRSTF</strong>). If this flag is set, it confirms that the watchdog initiated the reset. The function then clears this flag by writing to the <strong class="source-inline">RCC_CSR_RMVF</strong> bit, ensuring the flag is reset for future detection. As a visual indication of the <a id="_idIndexMarker1173"/>IWDG-triggered reset, the LED is turned on, and a message is printed to the UART. The function enters a loop, waiting for the user to press the button (detected by the <strong class="source-inline">g_btn_press</strong> variable) before clearing the button press state <span class="No-Break">and exiting.</span></p>
			<p>Then, there is <span class="No-Break">the callback:</span></p>
			<pre class="source-code">
static void exti_callback(void)
{
    g_btn_press = 1;
}</pre>			<p>This is followed by the <span class="No-Break">interrupt handler:</span></p>
			<pre class="source-code">
void EXTI15_10_IRQHandler(void) {
    if((EXTI-&gt;PR &amp; LINE13)!=0)
    {
        /*Clear PR flag*/
        EXTI-&gt;PR |=LINE13;
        //Do something...
        exti_callback();
    }
}</pre>			<p>The <strong class="source-inline">exti_callback</strong> function is a simple yet vital part of our interrupt-handling mechanism. Its sole purpose is to set the <strong class="source-inline">g_btn_press</strong> flag to <strong class="source-inline">1</strong>, indicating that a button press has been detected. This flag is later used in the main loop to control the program flow. The <strong class="source-inline">EXTI15_10_IRQHandler</strong> function is the interrupt handler for external interrupts on lines 10 to 15. When an interrupt is triggered on <em class="italic">line 13</em>, this handler first checks the pending register (<strong class="source-inline">PR</strong>) to confirm the interrupt source. Once verified, it clears <a id="_idIndexMarker1174"/>the pending flag by writing back to the <strong class="source-inline">PR</strong> register. After clearing the interrupt, the handler calls <strong class="source-inline">exti_callback</strong> to update the <span class="No-Break"><strong class="source-inline">g_btn_press</strong></span><span class="No-Break"> flag.</span></p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor465"/>Testing the project</h2>
			<p>To test the <a id="_idIndexMarker1175"/>project on the microcontroller, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li><strong class="bold">Build and run the project</strong>: Compile the code and upload it to your microcontroller. Once running, you should observe the green LED blinking, indicating that the system is <span class="No-Break">functioning correctly.</span></li>
				<li><strong class="bold">Monitor the serial output</strong>: Open RealTerm or any other serial terminal application. Configure it with the appropriate port and baud rate to view the debug messages. This will allow you to confirm when the system restarts due to <span class="No-Break">the IWDG.</span></li>
				<li><strong class="bold">Trigger a watchdog reset</strong>: Press the blue push button to stop the IWDG timer from being refreshed. After the IWDG timeout period elapses, the system will reset, and you should see a corresponding message in the <span class="No-Break">serial terminal.</span></li>
			</ol>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor466"/>Summary</h1>
			<p>In this chapter, we explored the IWDG timer, an important component for enhancing the reliability of embedded systems. We began by discussing the general concept of WDTs, emphasizing their role in ensuring systems can recover from unexpected faults or malfunctions. We explored how WDTs function and highlighted the unique features of <span class="No-Break">the IWDG.</span></p>
			<p>Next, we focused on the STM32 implementation of the IWDG, examining its key registers and configuration options. We detailed the purpose and usage of essential registers such as the Key Register (<strong class="source-inline">IWDG_KR</strong>), Prescaler Register (<strong class="source-inline">IWDG_PR</strong>), Reload Register (<strong class="source-inline">IWDG_RLR</strong>), and Status Register (<strong class="source-inline">IWDG_SR</strong>). This provided a comprehensive understanding of how to configure and control the IWDG for robust <span class="No-Break">system operation.</span></p>
			<p>We also provided practical examples to solidify our understanding, including the development of a bare-metal IWDG driver. This involved initializing the IWDG, configuring its prescaler and reload values, and implementing the necessary functions to ensure the system can recover from <span class="No-Break">software malfunctions.</span></p>
			<p>In the next chapter, we will learn about the <strong class="bold">Direct Memory Access</strong> (<strong class="bold">DMA</strong>) module, an advanced feature for <span class="No-Break">transferring data.</span></p>
		</div>
	</div>
</div>
</body></html>