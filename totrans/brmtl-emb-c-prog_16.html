<html><head></head><body>
<div><div><div><h1 id="_idParaDest-268" class="chapter-number"><a id="_idTextAnchor448"/>16</h1>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor449"/>Independent Watchdog (IWDG)</h1>
			<p>In this chapter, we’ll learn about<a id="_idIndexMarker1116"/> the <strong class="bold">Independent Watchdog</strong> (<strong class="bold">IWDG</strong>) timer, a unique component for enhancing the reliability of embedded systems. IWDG is essential for monitoring the system’s operation and ensuring it can recover from unexpected faults or malfunctions.</p>
			<p>We will begin by exploring the general concept<a id="_idIndexMarker1117"/> of <strong class="bold">watchdog timers</strong> (<strong class="bold">WDTs</strong>) and their importance in embedded systems. Following this, we will examine how WDTs function and the unique features of IWDG. Next, we will focus specifically on the STM32 implementation of the IWDG, looking at its key registers and configuration. Finally, we will apply this knowledge to develop a bare-metal IWDG driver, providing practical code examples to solidify our understanding.</p>
			<p>In this chapter, we will cover the following main topics<a id="_idTextAnchor450"/>:</p>
			<ul>
				<li>Understanding WDTs</li>
				<li>Types of WDTs</li>
				<li>The STM32 IWD<a id="_idTextAnchor451"/>G</li>
				<li>Developing the IWDG driver</li>
			</ul>
			<p>By the end of this chapter, you will have a comprehensive understanding of IWDG timers and their critical role in embedded systems. You will also gain skills to develop and implement IWDG drivers for STM32 microcontrollers, ensuring your systems can maintain robustness and reliability.</p>
			<h1 id="_idParaDest-270"><a id="_idTextAnchor452"/>Technical requirements</h1>
			<p>All code examples for this chapter can be found on GitHub at the following link:</p>
			<p><a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</a></p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor453"/>Understanding WDTs</h1>
			<p>WDTs<a id="_idIndexMarker1118"/> are one of the unsung heroes of embedded systems. They quietly monitor the system’s health, ensuring it can recover gracefully from unexpected hitches. Imagine them as vigilant guards, always on the lookout for system malfunctions, ready to reset the microcontroller if something goes wrong. In this section, we’ll explore what WDTs are and how they function, and dive into some common use cases to illustrate their importance.</p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor454"/>What are WDTs?</h2>
			<p>WDTs are<a id="_idIndexMarker1119"/> like guardians for your microcontroller. Imagine you’re using a device, and something goes wrong—a bug in the developer’s code causes an infinite loop, or a hardware glitch freezes the system. Without a watchdog, your device would be stuck, potentially causing significant problems, especially in critical applications such as medical devices or automotive systems.</p>
			<p>A WDT is a hardware or software timer that resets the system if the main program fails to reset the timer before it expires. It’s a simple yet powerful mechanism to ensure that your system can recover from unexpected issues. Let’s see how they work.</p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor455"/>How WDTs work</h2>
			<p>Think of a<a id="_idIndexMarker1120"/> WDT as an hourglass that you need to turn over regularly to prevent it from running out of sand. Here’s a step-by-step breakdown of how it works:</p>
			<ol>
				<li><strong class="bold">Initialization</strong>: When your system starts, you initialize the WDT with a specific timeout period. This period is the maximum time your system can run without resetting the timer.</li>
				<li><strong class="bold">Countdown</strong>: The WDT starts counting down from the set timeout value. If it reaches zero, it assumes something went wrong and triggers a system reset.</li>
				<li><strong class="bold">Resetting the timer</strong>: Your main program needs to periodically reset the WDT before it reaches zero. This action is often <a id="_idIndexMarker1121"/>called <strong class="bold">feeding the watchdog</strong> or <strong class="bold">kicking the dog</strong>. If the <a id="_idIndexMarker1122"/>program is running correctly, it will continue to reset the timer, preventing a reset.</li>
				<li><strong class="bold">System reset</strong>: If your program fails to reset the WDT in time—perhaps because it got stuck in an infinite loop or encountered a critical error—the WDT will expire <a id="_idIndexMarker1123"/>and reset the system, bringing it back to a known state.</li>
			</ol>
			<p>Now that we understand the basics, let’s look at some real-world applications where WDTs play a crucial role.</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor456"/>Common use cases</h2>
			<p>Following is a list of some real-world applications.</p>
			<h3>Industrial automation</h3>
			<p>In industrial automation, reliability<a id="_idIndexMarker1124"/> is paramount. Machines and processes need to run continuously and without failure. WDTs ensure that if a <strong class="bold">Programmable Logic Controller</strong> (<strong class="bold">PLC</strong>) or other <a id="_idIndexMarker1125"/>control systems hang or crash, they can quickly recover.</p>
			<p><em class="italic">Example</em>: Imagine a conveyor belt system in a manufacturing plant. The PLC controlling the conveyor belt has a WDT set to 1 second. If the PLC software fails to reset the watchdog within 1 second due to a software bug or external interference, the WDT will reset the PLC. This reset ensures that the conveyor belt can resume operation with minimal downtime, preventing potential production losses.</p>
			<h3>Automotive systems</h3>
			<p>Modern vehicles rely heavily on<a id="_idIndexMarker1126"/> embedded systems for various functions, from engine control to infotainment. WDTs are vital in ensuring these systems operate reliably.</p>
			<p><em class="italic">Example</em>: Consider <a id="_idIndexMarker1127"/>an <strong class="bold">engine control unit</strong> (<strong class="bold">ECU</strong>) in a car. The ECU monitors and controls critical engine parameters. A WDT in the ECU might be set to 500 milliseconds. If the ECU software fails to reset the watchdog due to a fault, the WDT resets the<a id="_idIndexMarker1128"/> ECU. This reset can prevent engine misbehavior, ensuring the vehicle operates safely.</p>
			<h3>Medical devices</h3>
			<p>In medical devices, WDTs<a id="_idIndexMarker1129"/> can be life-saving. Devices such as pacemakers, infusion pumps, and patient monitors must operate without failure.</p>
			<p><em class="italic">Example</em>: Take a patient monitor that tracks vital signs such as heart rate and blood pressure. The monitor’s software includes a WDT set to 2 seconds. If the software encounters a problem and fails to reset the watchdog, the device will reset. This reset ensures the monitor can quickly recover and continue providing accurate, real-time data, which is crucial for patient care.</p>
			<h3>Consumer electronics</h3>
			<p>Even in consumer electronics, WDTs <a id="_idIndexMarker1130"/>help maintain system reliability and enhance user experience. Think of smartphones, smart home devices, and gaming consoles.</p>
			<p><em class="italic">Example</em>: In a smart thermostat, the software manages temperature settings and connectivity. A WDT ensures that if the software freezes, the system resets and continues operating. This functionality prevents users from experiencing extended downtime, maintaining comfort and convenience in their homes.</p>
			<p>These examples illustrate the crucial role that WDTs play in modern systems. When implementing WDTs, it’s essential to consider several key factors to ensure their effectiveness. Let’s see some of these factors.</p>
			<h3>Practical considerations</h3>
			<p>When implementing WDTs, you <a id="_idIndexMarker1131"/>must consider the following:</p>
			<ul>
				<li><strong class="bold">Timeout period</strong>: Choose an appropriate timeout period based on your application’s needs. Too short, and you risk unnecessary resets; too long, and you might not recover quickly enough from faults.</li>
				<li><strong class="bold">Reset mechanism</strong>: Ensure that resetting the WDT (feeding the dog) is done in a part of your code that runs regularly and indicates the system is operating correctly.</li>
				<li><strong class="bold">Recovery strategy</strong>: Plan how your system should recover after a watchdog reset. Ensure critical data is preserved and the system returns to a safe state.</li>
				<li><strong class="bold">Testing</strong>: Thoroughly<a id="_idIndexMarker1132"/> test your WDT implementation to ensure it behaves as expected under various fault conditions.</li>
			</ul>
			<p>Next, let’s see the types of WDTs available.</p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor457"/>Types of WDTs</h2>
			<p>WDTs can be categorized into several types based on their functionality and integration. Let’s explore the most common types.</p>
			<h3>Internal WDTs</h3>
			<p>Internal WDTs are built into the<a id="_idIndexMarker1133"/> microcontroller. They are a<a id="_idIndexMarker1134"/> convenient option because they don’t require additional external components. These timers are directly integrated into the microcontroller’s architecture and can be configured through software.</p>
			<p>They have the following features:</p>
			<ul>
				<li><strong class="bold">Integration</strong>: No need for<a id="_idIndexMarker1135"/> external circuitry</li>
				<li><strong class="bold">Configuration</strong>: Typically configured using the microcontroller’s registers</li>
				<li><strong class="bold">Power</strong>: They can continue to operate in low-power modes, making them suitable for battery-powered applications</li>
			</ul>
			<p><em class="italic">Example use case</em>: In a small IoT device, an internal WDT can monitor the microcontroller’s operation without adding extra hardware, ensuring the device can reset itself if it encounters an error.</p>
			<h3>External WDTs</h3>
			<p>External WDTs<a id="_idIndexMarker1136"/> are separate components connected to the microcontroller. These timers <a id="_idIndexMarker1137"/>provide additional flexibility and can be used when the internal WDT isn’t sufficient or if redundancy is required.</p>
			<p>Here is a list of <a id="_idIndexMarker1138"/>their features:</p>
			<ul>
				<li><strong class="bold">Flexibility</strong>: Can be chosen based on specific requirements (for example, longer timeout periods)</li>
				<li><strong class="bold">Redundancy</strong>: Adding an external watchdog provides an extra layer of safety</li>
				<li><strong class="bold">Independence</strong>: Operate independently of the microcontroller’s clock and power</li>
			</ul>
			<p><em class="italic">Example use case</em>: In a critical automotive system, an external WDT can provide an additional safeguard, ensuring the system resets even if the internal timer fails.</p>
			<h3>Windowed WDTs</h3>
			<p><strong class="bold">Windowed WDTs</strong> (<strong class="bold">WWDTs</strong>) add an <a id="_idIndexMarker1139"/>extra layer of control by<a id="_idIndexMarker1140"/> introducing a <em class="italic">window</em> period. The system must reset the timer within a specific window period; too early or too late resets the system. This prevents scenarios where the software gets stuck in a loop resetting the watchdog too frequently (which could mask a malfunction).</p>
			<p>Their features<a id="_idIndexMarker1141"/> include the following:</p>
			<ul>
				<li><strong class="bold">Precision</strong>: Require the timer to be reset within a specific time window</li>
				<li><strong class="bold">Fault detection</strong>: Can detect both early and late watchdog resets, offering improved fault detection</li>
				<li><strong class="bold">Security</strong>: Enhance system security by ensuring the timer is reset at appropriate intervals</li>
			</ul>
			<p><em class="italic">Example use case</em>: In a medical device, a WWDT ensures the control software operates correctly within defined time intervals, adding an extra layer of reliability.</p>
			<h3>IWDGs</h3>
			<p>IWDGs<a id="_idIndexMarker1142"/> are designed to be<a id="_idIndexMarker1143"/> robust and reliable. They run from a separate clock source, usually a <strong class="bold">low-speed internal</strong> (<strong class="bold">LSI</strong>) clock, and<a id="_idIndexMarker1144"/> operate independently of the main system clock. This independence ensures they continue to function even if the main clock fails.</p>
			<p>Their features<a id="_idIndexMarker1145"/> include the following:</p>
			<ul>
				<li><strong class="bold">Independence</strong>: Operate from a separate clock source</li>
				<li><strong class="bold">Robustness</strong>: Continue functioning even if the main system clock fails</li>
				<li><strong class="bold">Minimal configuration</strong>: Typically simple to configure and use</li>
			</ul>
			<p><em class="italic">Example use case</em>: In an <strong class="bold">industrial control system</strong> (<strong class="bold">ICS</strong>), an IWDG ensures the system can recover from malfunctions, even<a id="_idIndexMarker1146"/> if the main clock source is disrupted.</p>
			<p>Selecting the appropriate WDT depends on several factors, including the criticality of the application, power constraints, and required reliability.</p>
			<h3>Choosing the right WDT</h3>
			<p>Here’s a quick guide to<a id="_idIndexMarker1147"/> help you choose the right WDT:</p>
			<ul>
				<li><strong class="bold">For low-power applications</strong>: Consider internal WDTs due to their integration and low power consumption</li>
				<li><strong class="bold">For high-reliability systems</strong>: Use external WDTs for redundancy</li>
				<li><strong class="bold">For applications requiring precise timing</strong>: WWDTs provide enhanced fault detection</li>
				<li><strong class="bold">For systems needing robust operation</strong>: IWDGs offer continued functionality even if the main clock fails</li>
			</ul>
			<p>Understanding the different types of WDTs and their features allows us to choose the right one for our applications. Whether it’s an internal WDT for simplicity, an external one for redundancy, a WWDT for precise control, or an IWDG for robustness, there’s a WDT suited for every need.</p>
			<p>In the upcoming section, we will delve into the IWDG embedded within the STM32F411 microcontroller, examining its features and how to leverage it for enhanced system reliability.</p>
			<h1 id="_idParaDest-276"><a id="_idTextAnchor458"/>The STM32 IWDG</h1>
			<p>In this section, we’ll analyze the<a id="_idIndexMarker1148"/> STM32 IWDG module, exploring its main features and other relevant information to help you understand how to leverage this powerful feature in your embedded applications.</p>
			<p>STM32 microcontrollers feature two<a id="_idIndexMarker1149"/> types of WDTs: the IWDG<a id="_idIndexMarker1150"/> and the <strong class="bold">Window Watchdog</strong> (<strong class="bold">WWDG</strong>). Both are essential for detecting and correcting software malfunctions by initiating a system reset, but they each have unique characteristics and applications.</p>
			<p>The IWDG operates using a dedicated LSI clock, ensuring it continues to function even if the main system clock fails. This makes it highly reliable for applications that require continuous monitoring, regardless of the main clock’s state. In contrast, the WWDG derives its clock from the APB1 clock and features a configurable time window. The system must refresh the WWDG within this time window; failing to do so, either too early or too late, will trigger a system reset.</p>
			<p>The IWDG is best suited for applications needing an independent watchdog process with lower timing accuracy constraints, while the WWDG is ideal for applications requiring precise timing windows. Let’s see some key features of the IWDG.</p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor459"/>Key features of the IWDG</h2>
			<p>The IWDG in STM32 microcontrollers boasts several key features:</p>
			<ul>
				<li><strong class="bold">Free-running downcounter</strong>: The <a id="_idIndexMarker1151"/>IWDG operates as a free-running downcounter, continuously counting down from a preset value</li>
				<li><strong class="bold">Independent clock source</strong>: It uses an independent <strong class="bold">resistor-capacitor</strong> (<strong class="bold">RC</strong>) oscillator, allowing <a id="_idIndexMarker1152"/>it to function in low-power modes such as Standby and Stop</li>
				<li><strong class="bold">System reset on timeout</strong>: If the WDT is activated and the downcounter reaches zero (0x000), a system reset is triggered</li>
				<li><strong class="bold">Write access protection</strong>: To modify critical registers, a specific sequence of operations <a id="_idIndexMarker1153"/>is required, ensuring protection against accidental or malicious modifications</li>
			</ul>
			<p>Let’s see how it works.</p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor460"/>How the IWDG works</h2>
			<p>The IWDG<a id="_idIndexMarker1154"/> module operates as an independent safeguard for the microcontroller, ensuring the system can recover from software malfunctions. <em class="italic">Figure 16</em><em class="italic">.1</em> presents a block diagram of the IWDG, sourced from the reference manual:</p>
			<div><div><img src="img/B21914_16_1.jpg" alt="Figure 16.1: IWDG block diagram" width="1650" height="549"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.1: IWDG block diagram</p>
			<p>Let’s break down its functional blocks and how it operates:</p>
			<ul>
				<li><code>0xCCCC</code> to the Key Register (<code>IWDG_KR</code>). This action initiates the downcounter, which begins counting down from the reset value of <code>0xFFF</code>.</li>
				<li><code>0xAAAA</code> to the <code>IWDG_KR</code> register, which reloads the counter with the value from the Reload Register (<code>IWDG_RLR</code>) and prevents a reset.</li>
				<li><strong class="bold">Hardware watchdog feature</strong>: If enabled, the IWDG is automatically activated at power-on. In this mode, the WDT will generate a reset unless the Key Register is written with the appropriate value before the counter reaches zero.</li>
				<li><code>IWDG_PR</code>) and reload (<code>IWDG_RLR</code>) registers, we must temporarily disable write access protection by writing the code <code>0x5555</code> to the <code>IWDG_KR</code> register. After doing this, any changes to these registers must be made immediately; otherwise, access protection will be<a id="_idIndexMarker1155"/> re-enabled.</li>
			</ul>
			<p>With this general overview of the IWDG block in mind, let’s analyze the key registers one by one.</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor461"/>IWDG registers</h2>
			<p>In this<a id="_idIndexMarker1156"/> section, we will explore the characteristics and functions of some of the crucial registers within the IWDG peripheral.</p>
			<p>Let’s start with the <code>IWDG_KR</code>).</p>
			<h3>IWDG Key Register (IWDG_KR)</h3>
			<p>The <code>IWDG_KR</code> register is a key <a id="_idIndexMarker1157"/>register used to control the IWDG’s operations, including starting the watchdog, reloading the counter, and disabling write access to other registers. This register is pivotal in managing the IWDG’s functionality.</p>
			<p>Key operations in this register include the following:</p>
			<ul>
				<li><code>0xCCCC</code>: Start the IWDG. Writing this value to <code>IWDG_KR</code> starts the IWDG timer.</li>
				<li><code>0xAAAA</code>: Reload the counter. Writing this value reloads the IWDG counter, preventing it from reaching zero and triggering a system reset.</li>
				<li><code>0x5555</code>: Disable write protection. This value allows modifications to the prescaler and reload registers.</li>
			</ul>
			<p>Next, let’s discuss the <code>IWDG_PR</code>).</p>
			<h3>IWDG Prescaler Register (IWDG_PR)</h3>
			<p>The <code>IWDG_PR</code> register is<a id="_idIndexMarker1158"/> used to set the prescaler value, which determines the frequency<a id="_idIndexMarker1159"/> of the IWDG clock by dividing the LSI clock. Adjusting this register helps configure the countdown speed of the WDT.</p>
			<p>Key bits in this register is <code>PR[2:0]</code>: Prescaler value. These bits can be set to divide the LSI clock by 4, 8, 16, 32, 64, 128, or 256, allowing flexibility in setting the WDT interval.</p>
			<p>Next, we move on to the <code>IWDG_RLR</code>).</p>
			<h3>IWDG Reload Register (IWDG_RLR)</h3>
			<p>The <code>IWDG_RLR</code> register defines the reload <a id="_idIndexMarker1160"/>value for the IWDG counter. This value determines the timeout period before the watchdog triggers a system reset if not reloaded in time.</p>
			<p>The key field in this register is <code>RL[11:0]</code>; this means reload value. It is a 12-bit value that sets the counter’s reload value, which can range from 0x000 to 0xFFF.</p>
			<p>Finally, we examine the <code>IWDG_SR</code>).</p>
			<h3>IWDG Status Register (IWDG_SR)</h3>
			<p>The <code>IWDG_SR</code> register provides status<a id="_idIndexMarker1161"/> information about the IWDG, indicating whether updates to the prescaler or reload registers are ongoing.</p>
			<p>Key bits in this register include the following:</p>
			<ul>
				<li><code>PVU</code>: <strong class="bold">Prescaler value update</strong> (<strong class="bold">PVU</strong>). This bit<a id="_idIndexMarker1162"/> indicates that the prescaler value is being updated.</li>
				<li><code>RVU</code>: <strong class="bold">Reload value update</strong> (<strong class="bold">RVU</strong>). This <a id="_idIndexMarker1163"/>bit indicates that the reload value is being updated.</li>
			</ul>
			<p>With a clear understanding of the IWDG’s functionality and its registers, we can now move on to the next section, where we will develop the IWDG driver.</p>
			<h1 id="_idParaDest-280"><a id="_idTextAnchor462"/>Developing the IWDG driver</h1>
			<p>In this section, we’ll <a id="_idIndexMarker1164"/>use what we’ve learned so far in this chapter to develop the IWDG driver.</p>
			<p>Let’s start by setting up the project.</p>
			<p>Create a copy of your previous project in your IDE, following the steps outlined in earlier chapters. Rename this copied project to <code>IWDG</code>. Next, create a new file named <code>iwdg.c</code> in the <code>Src</code> folder and another file named <code>iwdg.h</code> in the <code>Inc</code> folder.</p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor463"/>The IWDG implementation file</h2>
			<p>Populate your <code>iwdg.c</code> file with the<a id="_idIndexMarker1165"/> following code:</p>
			<pre class="source-code">
<strong class="bold">#include</strong> "iwdg.h"
<strong class="bold">#define</strong> IWDG_KEY_ENABLE                 0x0000CCCCU
<strong class="bold">#define</strong> IWDG_KEY_WR_ACCESS_ENABLE       0x00005555U
<strong class="bold">#define</strong> IWDG_PRESCALER_4              0x00000000U
<strong class="bold">#define</strong> IWDG_RELOAD_VAL              0xFFF
<strong class="bold">static</strong> uint8_t <strong class="bold">isIwdg_ready</strong>(<strong class="bold">void</strong>);
<strong class="bold">void iwdg_init</strong>(<strong class="bold">void</strong>)
{
    /*Enable the IWDG by writing 0x0000CCCC in the IWDG_KR register*/
    IWDG-&gt;KR = IWDG_KEY_ENABLE;
    /*Enable register access by writing 0x0000 5555 in the IWDG_KR 
    register*/
    IWDG-&gt;KR = IWDG_KEY_WR_ACCESS_ENABLE;
    /*Set the IWDG <strong class="bold">Prescaler</strong>*/
    IWDG-&gt;PR =  IWDG_PRESCALER_4;
    /*Set the reload register (IWDG_RLR) to the largest value 0xFFF*/
    IWDG-&gt;RLR = IWDG_RELOAD_VAL;
    /*Wait for the registers to be updated (IWDG_SR = 0x0000 0000)*/
    <strong class="bold">while</strong>(isIwdg_ready() != 1){}
    /*Refresh the counter value with IWDG_KR (IWDG_KR = 0x0000 AAAA)*/
    IWDG-&gt;KR = IWDG_KEY_RELOAD;
}
<strong class="bold">static</strong> uint8_t <strong class="bold">isIwdg_ready</strong>(<strong class="bold">void</strong>)
{
<strong class="bold"> return</strong> ((READ_BIT(IWDG-&gt;SR, IWDG_SR_PVU | IWDG_SR_RVU) == 0U) ? 1UL : 
 0UL);
}</pre>			<p>Let’s <a id="_idIndexMarker1166"/>break it down. Let’s look at the <strong class="bold">macro </strong><strong class="bold">definitions</strong> first:</p>
			<pre class="source-code">
#include "iwdg.h"
#define IWDG_KEY_ENABLE                 0x0000CCCCU
#define IWDG_KEY_WR_ACCESS_ENABLE       0x00005555U
#define IWDG_PRESCALER_4                0x00000000U
#define IWDG_RELOAD_VAL                 0xFFF</pre>			<ul>
				<li><code>IWDG_KEY_ENABLE</code>: This macro defines the key to enable the IWDG</li>
				<li><code>IWDG_KEY_WR_ACCESS_ENABLE</code>: This macro defines the key to enable write access to IWDG registers</li>
				<li><code>IWDG_PRESCALER_4</code>: This <a id="_idIndexMarker1167"/>macro defines the prescaler value for the IWDG</li>
				<li><code>IWDG_RELOAD_VAL</code>: This macro sets the reload value to the maximum, 0xFFF, providing the longest timeout period</li>
			</ul>
			<p>Next, we have the <code>iwdg_init()</code> function.</p>
			<pre class="source-code">
IWDG-&gt;KR = IWDG_KEY_ENABLE;</pre>			<p>This line writes <code>0x0000CCCC</code> to the IWDG <strong class="bold">Key Register</strong> (<strong class="bold">KR</strong>) to enable the IWDG.</p>
			<pre class="source-code">
IWDG-&gt;KR = IWDG_KEY_WR_ACCESS_ENABLE;</pre>			<p>This line writes <code>0x00005555</code> to the IWDG Key Register to enable write access to the prescaler and reload registers.</p>
			<pre class="source-code">
IWDG-&gt;PR = IWDG_PRESCALER_4;</pre>			<p>This line sets the prescaler register to divide the clock by 4, as defined by <code>IWDG_PRESCALER_4</code>.</p>
			<pre class="source-code">
IWDG-&gt;RLR = IWDG_RELOAD_VAL;</pre>			<p>This sets the reload register to the maximum value of 0xFFF to get the longest possible timeout period.</p>
			<pre class="source-code">
while (isIwdg_ready() != 1) {}</pre>			<p>This waits until the IWDG <strong class="bold">status register</strong> (<strong class="bold">SR</strong>) indicates that the prescaler and reload registers have been updated and are ready.</p>
			<pre class="source-code">
IWDG-&gt;KR = IWDG_KEY_RELOAD;</pre>			<p>This writes <code>0x0000AAAA</code> to the IWDG Key Register to reload the counter and prevent the IWDG from resetting the system.</p>
			<p>The <code>isIwdg_ready()</code> function checks the Status Register to see if the <code>PVU</code> and <code>RVU</code> bits are <a id="_idIndexMarker1168"/>cleared. It returns 1 if both bits are cleared, indicating that the IWDG is ready, or 0 otherwise.</p>
			<p>We are now ready to test inside <code>main.c</code>.</p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor464"/>The main file</h2>
			<p>Update<a id="_idIndexMarker1169"/> your <code>main.c</code> file as shown next:</p>
			<pre class="source-code">
#include &lt;stdio.h&gt;
#include "adc.h"
#include "uart.h"
#include "gpio.h"
#include "iwdg.h"
#include "gpio_exti.h"
uint8_t g_btn_press;
static void check_reset_source(void);
int main(void)
{
    /*Initialize debug UART*/
    uart_init();
    /*Initialize LED*/
    led_init();
    /*Initialize EXTI*/
    pc13_exti_init();
    /*Find reset source*/
    check_reset_source();
    /*Initialize IWDG*/
    iwdg_init();
    while(1)
    {
        if( g_btn_press != 1)
         {
              /*Refresh IWDG down-counter to default value*/
             IWDG-&gt;KR = IWDG_KEY_RELOAD;
             led_toggle();
             <strong class="bold">for</strong>(<strong class="bold">int</strong> i = 0; i &lt; 90000; i++){}
         }
    }
}</pre>			<p>The <code>main</code> function kicks off<a id="_idIndexMarker1170"/> by setting up the <code>EXTI</code>) on pin <code>PC13</code>, which is connected to the blue push button. The function then calls <code>check_reset_source</code> to determine if the last reset was caused by the IWDG. After that, it initializes the IWDG itself, ensuring that the system can recover from software malfunctions. The <code>main</code> loop continually checks the state of <code>g_btn_press</code>; if the button hasn’t been pressed, it refreshes the IWDG to prevent a system reset and toggles the LED, providing a visual indicator of system activity.</p>
			<p>Let’s look at the next part of the code:</p>
			<pre class="source-code">
static void check_reset_source(void)
{
if ((RCC-&gt;CSR &amp; RCC_CSR_IWDGRSTF) == (RCC_CSR_IWDGRSTF))
      {
          /*Clear IWDG Reset flag*/
          RCC-&gt;CSR = RCC_CSR_RMVF;
          /*Turn LED On*/
          led_on();
          printf("RESET was caused by IWDG.....\n\r");
          while( g_btn_press != 1)
          {
          }
          g_btn_press =  0;
      }
}</pre>			<p>The <code>check_reset_source</code> function determines if the most recent system reset was triggered by the IWDG. It begins by checking the <code>CSR</code>) for the IWDG <a id="_idIndexMarker1172"/>reset flag (<code>RCC_CSR_IWDGRSTF</code>). If this flag is set, it confirms that the watchdog initiated the reset. The function then clears this flag by writing to the <code>RCC_CSR_RMVF</code> bit, ensuring the flag is reset for future detection. As a visual indication of the <a id="_idIndexMarker1173"/>IWDG-triggered reset, the LED is turned on, and a message is printed to the UART. The function enters a loop, waiting for the user to press the button (detected by the <code>g_btn_press</code> variable) before clearing the button press state and exiting.</p>
			<p>Then, there is the callback:</p>
			<pre class="source-code">
static void exti_callback(void)
{
    g_btn_press = 1;
}</pre>			<p>This is followed by the interrupt handler:</p>
			<pre class="source-code">
void EXTI15_10_IRQHandler(void) {
    if((EXTI-&gt;PR &amp; LINE13)!=0)
    {
        /*Clear PR flag*/
        EXTI-&gt;PR |=LINE13;
        //Do something...
        exti_callback();
    }
}</pre>			<p>The <code>exti_callback</code> function is a simple yet vital part of our interrupt-handling mechanism. Its sole purpose is to set the <code>g_btn_press</code> flag to <code>1</code>, indicating that a button press has been detected. This flag is later used in the main loop to control the program flow. The <code>EXTI15_10_IRQHandler</code> function is the interrupt handler for external interrupts on lines 10 to 15. When an interrupt is triggered on <em class="italic">line 13</em>, this handler first checks the pending register (<code>PR</code>) to confirm the interrupt source. Once verified, it clears <a id="_idIndexMarker1174"/>the pending flag by writing back to the <code>PR</code> register. After clearing the interrupt, the handler calls <code>exti_callback</code> to update the <code>g_btn_press</code> flag.</p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor465"/>Testing the project</h2>
			<p>To test the <a id="_idIndexMarker1175"/>project on the microcontroller, follow these steps:</p>
			<ol>
				<li><strong class="bold">Build and run the project</strong>: Compile the code and upload it to your microcontroller. Once running, you should observe the green LED blinking, indicating that the system is functioning correctly.</li>
				<li><strong class="bold">Monitor the serial output</strong>: Open RealTerm or any other serial terminal application. Configure it with the appropriate port and baud rate to view the debug messages. This will allow you to confirm when the system restarts due to the IWDG.</li>
				<li><strong class="bold">Trigger a watchdog reset</strong>: Press the blue push button to stop the IWDG timer from being refreshed. After the IWDG timeout period elapses, the system will reset, and you should see a corresponding message in the serial terminal.</li>
			</ol>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor466"/>Summary</h1>
			<p>In this chapter, we explored the IWDG timer, an important component for enhancing the reliability of embedded systems. We began by discussing the general concept of WDTs, emphasizing their role in ensuring systems can recover from unexpected faults or malfunctions. We explored how WDTs function and highlighted the unique features of the IWDG.</p>
			<p>Next, we focused on the STM32 implementation of the IWDG, examining its key registers and configuration options. We detailed the purpose and usage of essential registers such as the Key Register (<code>IWDG_KR</code>), Prescaler Register (<code>IWDG_PR</code>), Reload Register (<code>IWDG_RLR</code>), and Status Register (<code>IWDG_SR</code>). This provided a comprehensive understanding of how to configure and control the IWDG for robust system operation.</p>
			<p>We also provided practical examples to solidify our understanding, including the development of a bare-metal IWDG driver. This involved initializing the IWDG, configuring its prescaler and reload values, and implementing the necessary functions to ensure the system can recover from software malfunctions.</p>
			<p>In the next chapter, we will learn about the <strong class="bold">Direct Memory Access</strong> (<strong class="bold">DMA</strong>) module, an advanced feature for transferring data.</p>
		</div>
	</div>
</div>
</body></html>