["```cpp\n#include \"config.h\"\n#include \"building.h\"\n#include \"nodes.h\"\n#include <nymph/nymph.h>\n#include <thread>\n#include <condition_variable>\n#include <mutex>\nstd::condition_variable gCon;\nstd::mutex gMutex;\nbool gPredicate = false;\nvoid signal_handler(int signal) {\n    gPredicate = true;\n    gCon.notify_one();\n}\nvoid logFunction(int level, string logStr) {\n    std::cout << level << \" - \" << logStr << endl;\n}\n```", "```cpp\nNymphMessage* getNewMac(int session, NymphMessage* msg, void* data) {\n    NymphMessage* returnMsg = msg->getReplyMessage();\n\n    std::string mac = Nodes::getMAC();\n    Nodes::registerSession(mac, session);\n\n    returnMsg->setResultValue(new NymphString(mac));\n    return returnMsg;\n }\n```", "```cpp\nNymphMessage* writeUart(int session, NymphMessage* msg, void* data) {\n    NymphMessage* returnMsg = msg->getReplyMessage();\n\n    std::string mac = ((NymphString*) msg->parameters()[0])->getValue();\n    std::string bytes = ((NymphString*) msg->parameters()[1])->getValue();\n    returnMsg->setResultValue(new NymphBoolean(Nodes::writeUart(mac, bytes)));\n    return returnMsg;\n }\n```", "```cpp\nNymphMessage* writeSPI(int session, NymphMessage* msg, void* data) {\n    NymphMessage* returnMsg = msg->getReplyMessage();\n\n    std::string mac = ((NymphString*) msg->parameters()[0])->getValue();\n    std::string bytes = ((NymphString*) msg->parameters()[1])->getValue();\n    returnMsg->setResultValue(new NymphBoolean(Nodes::writeSPI(mac, bytes)));\n    return returnMsg;\n }\n NymphMessage* readSPI(int session, NymphMessage* msg, void* data) {\n    NymphMessage* returnMsg = msg->getReplyMessage();\n\n    std::string mac = ((NymphString*) msg->parameters()[0])->getValue();\n    returnMsg->setResultValue(new NymphString(Nodes::readSPI(mac)));\n    return returnMsg;\n }\n```", "```cpp\nNymphMessage* writeI2C(int session, NymphMessage* msg, void* data) {\n    NymphMessage* returnMsg = msg->getReplyMessage();\n\n    std::string mac = ((NymphString*) msg->parameters()[0])->getValue();\n    int i2cAddress = ((NymphSint32*) msg->parameters()[1])->getValue();\n    std::string bytes = ((NymphString*) msg->parameters()[2])->getValue();\n    returnMsg->setResultValue(new NymphBoolean(Nodes::writeI2C(mac, i2cAddress, bytes)));\n    return returnMsg;\n }\n\n NymphMessage* readI2C(int session, NymphMessage* msg, void* data) {\n    NymphMessage* returnMsg = msg->getReplyMessage();\n\n    std::string mac = ((NymphString*) msg->parameters()[0])->getValue();\n    int i2cAddress = ((NymphSint32*) msg->parameters()[1])->getValue();\n    int length = ((NymphSint32*) msg->parameters()[2])->getValue();\n    returnMsg->setResultValue(new NymphString(Nodes::readI2C(mac, i2cAddress, length)));\n    return returnMsg;\n }\n```", "```cpp\nint main() {\n    Config config;\n    config.load(\"config.cfg\");\n```", "```cpp\n   vector<NymphTypes> parameters;\n    NymphMethod getNewMacFunction(\"getNewMac\", parameters, NYMPH_STRING);\n    getNewMacFunction.setCallback(getNewMac);\n    NymphRemoteClient::registerMethod(\"getNewMac\", getNewMacFunction);\n\n    parameters.push_back(NYMPH_STRING);\n    NymphMethod serialRxCallback(\"serialRxCallback\", parameters, NYMPH_NULL);\n    serialRxCallback.enableCallback();\n    NymphRemoteClient::registerCallback(\"serialRxCallback\", serialRxCallback);\n\n    // string readI2C(string MAC, int i2cAddress, int length)\n    parameters.push_back(NYMPH_SINT32);\n    parameters.push_back(NYMPH_SINT32);\n    NymphMethod readI2CFunction(\"readI2C\", parameters, NYMPH_STRING);\n    readI2CFunction.setCallback(readI2C);\n    NymphRemoteClient::registerMethod(\"readI2C\", readI2CFunction);\n\n    // bool writeUart(string MAC, string bytes)\n    parameters.clear();\n    parameters.push_back(NYMPH_STRING);\n    parameters.push_back(NYMPH_STRING);\n    NymphMethod writeUartFunction(\"writeUart\", parameters, NYMPH_BOOL);\n    writeUartFunction.setCallback(writeUart);\n    NymphRemoteClient::registerMethod(\"writeUart\", writeUartFunction);\n\n    // bool writeSPI(string MAC, string bytes)\n    NymphMethod writeSPIFunction(\"writeSPI\", parameters, NYMPH_BOOL);\n    writeSPIFunction.setCallback(writeSPI);\n    NymphRemoteClient::registerMethod(\"writeSPI\", writeSPIFunction);\n\n    // bool writeI2C(string MAC, int i2cAddress, string bytes)\n    parameters.clear();\n    parameters.push_back(NYMPH_STRING);\n    parameters.push_back(NYMPH_SINT32);\n    parameters.push_back(NYMPH_SINT32);\n    NymphMethod writeI2CFunction(\"writeI2C\", parameters, NYMPH_BOOL);\n    writeI2CFunction.setCallback(writeI2C);\n    NymphRemoteClient::registerMethod(\"writeI2C\", writeI2CFunction);\n```", "```cpp\n\n    signal(SIGINT, signal_handler);\n\n    NymphRemoteClient::start(4004);\n\n    Building building(config);\n\n    std::unique_lock<std::mutex> lock(gMutex);\n    while (!gPredicate) {\n          gCon.wait(lock);\n    }\n\n    NymphRemoteClient::shutdown();\n\n    Thread::sleep(2000); \n\n    return 0;\n }\n```", "```cpp\n[Building]\n floors=2\n\n [Floor_1]\n rooms=1,2\n\n [Floor_2]\n rooms=2,3\n\n [Room_1]\n ; Define the room configuration.\n ; Sensors and actuators use the format:\n ; <device_id>:<node_id>\n nodes=1\n devices=1:1\n\n [Room_2]\n nodes=2\n\n [Room_3]\n nodes=3\n\n [Room_4]\n nodes=4\n\n [Node_1]\n mac=600912760001\n sensors=1\n\n [Node_2]\n mac=600912760002\n sensors=1\n\n [Node_3]\n mac=600912760003\n sensors=1\n\n [Node_4]\n mac=600912760004\n sensors=1\n\n [Device_1]\n type=i2c\n address=0x20\n device=bme280\n\n [Device_2]\n type=spi\n cs_gpio=1\n\n [Device_3]\n type=uart\n uart=0\n baud=9600\n device=mh-z19\n\n [Device_4]\n type=uart\n uart=0\n baud=9600\n device=jura\n\n```", "```cpp\n#include <string> \n#include <memory> \n#include <sstream> \n#include <iostream> \n#include <type_traits> \n\n#include <Poco/Util/IniFileConfiguration.h> \n#include <Poco/AutoPtr.h> \n\nusing Poco::AutoPtr; \nusing namespace Poco::Util; \n\nclass Config { \n   AutoPtr<IniFileConfiguration> parser; \n\npublic: \n   Config(); \n\n   bool load(std::string filename); \n\n   template<typename T> \n   auto getValue(std::string key, T defaultValue) -> T { \n         std::string value; \n         try { \n               value = parser->getRawString(key); \n         } \n         catch (Poco::NotFoundException &e) { \n               return defaultValue; \n         } \n\n         // Convert the value to our output type, if possible. \n         std::stringstream ss; \n         if (value[0] == '0' && value[1] == 'x') { \n               value.erase(0, 2); \n               ss << std::hex << value; // Read as hexadecimal. \n         } \n         else { \n               ss.str(value); \n         } \n\n         T retVal; \n         if constexpr (std::is_same<T, std::string>::value) { retVal = ss.str(); } \n         else { ss >> retVal; } \n\n         return retVal; \n   } \n}; \n```", "```cpp\n#include \"config.h\" \n\nConfig::Config() { \n   parser = new IniFileConfiguration(); \n} \n\nbool Config::load(std::string filename) { \n   try { \n         parser->load(filename); \n   } \n   catch (...) { \n         // An exception has occurred. Return false. \n         return false; \n   } \n\n   return true; \n} \n```", "```cpp\n#include <vector>\n #include <string>\n\n #include \"floor.h\"\n\n class Building {\n    std::vector<Floor> floors;\n\n public:\n    Building(Config &cfg);\n };\n```", "```cpp\n#include \"building.h\"\n #include \"floor.h\"\n Building::Building(Config &config) {\n    int floor_count = config.getValue<int>(\"Building.floors\", 0);\n\n    for (int i = 0; i < floor_count; ++i) {\n          Floor floor(i + 1, config); // Floor numbering starts at 1.\n          floors.push_back(floor);\n    }\n }\n```", "```cpp\n#include <vector>\n #include <cstdint>\n\n #include \"room.h\"\n\n class Floor {\n    std::vector<Room> rooms;\n\n public:\n    Floor(uint32_t level, Config &config);\n };\n\n```", "```cpp\n#include \"floor.h\"\n #include \"utility.h\"\n\n #include <string>\n\n Floor::Floor(uint32_t level, Config &config) {\n    std::string floor_cat = \"Floor_\" + std::to_string(level);\n    std::string roomsStr = config.getValue<std::string>(floor_cat + \".rooms\", 0);\n\n    std::vector<std::string> room_ids;\n    split_string(roomsStr, ',', room_ids);    \n    int room_count = room_ids.size();\n\n    if (room_count > 0) {   \n          for (int i = 0; i < room_count; ++i) {\n                Room room(std::stoi(room_ids.at(i)), config);\n                rooms.push_back(room);\n          }\n    }\n }\n```", "```cpp\n#include <string>\n #include <vector>\n\n void split_string(const std::string& str, char chr, std::vector<std::string>& vec);\n\n```", "```cpp\n#include \"utility.h\"\n\n #include <algorithm>\n\n void split_string(const std::string& str, char chr, std::vector<std::string>& vec) {\n     std::string::const_iterator first = str.cbegin();\n     std::string::const_iterator second = std::find(first + 1, str.cend(), chr);\n\n     while (second != str.cend()) {\n         vec.emplace_back(first, second);\n         first = second;\n         second = std::find(second + 1, str.cend(), chr);\n     }\n\n     vec.emplace_back(first, str.cend());\n }\n```", "```cpp\n#include \"node.h\"\n #include \"devices/device.h\"\n\n #include <vector>\n #include <map>\n #include <cstdint>\n\n class Room {\n    std::map<std::string, Node> nodes;\n    std::vector<Device> devices;\n    std::shared_ptr<RoomState> state;\n\n public:\n    Room(uint32_t type, Config &config);\n\n };\n```", "```cpp\n#include \"room.h\"\n\n #include \"utility.h\"\n\n Room::Room(uint32_t type, Config &config) {\n    std::string room_cat = \"Room_\" + std::to_string(type);\n    std::string nodeStr = config.getValue<std::string>(room_cat + \".nodes\", \"\");\n\n    state->setTemperature(24.3);\n    state->setHumidity(51.2);\n    std::string sensors;\n    std::string actuators;\n    std::string node_cat;\n    if (!nodeStr.empty()) {\n          std::vector<std::string> node_ids;\n          split_string(nodeStr, ',', node_ids);\n          int node_count = node_ids.size();\n\n          for (int i = 0; i < node_count; ++i) {\n                Node node(node_ids.at(i), config);  \n                node_cat = \"Node_\" + node_ids.at(i);                  \n                nodes.insert(std::map<std::string, Node>::value_type(node_ids.at(i), node));\n          }\n\n          std::string devicesStr = config.getValue<std::string>(node_cat + \".devices\", \"\");\n          if (!devicesStr.empty()) {\n                std::vector<std::string> device_ids;\n                split_string(devicesStr, ':', device_ids);\n                int device_count = device_ids.size();\n\n                for (int i = 0; i < device_count; ++i) {\n                      std::vector<std::string> device_data;\n                      split_string(device_ids.at(i), ':', device_data);\n                      if (device_data.size() != 2) {\n                            // Incorrect data. Abort.\n                            continue;\n                      }\n\n                      Device device(device_data[0], config, state);\n\n                      nodes.at(device_data[1]).addDevice(std::move(device));\n\n                      devices.push_back(device);\n                }\n          }\n    }\n\n }\n```", "```cpp\n#include \"config.h\"\n #include \"types.h\"\n\n class Device {\n    std::shared_ptr<RoomState> roomState;\n    Connection connType;\n    std::string device;\n    std::string mac;\n    int spi_cs;\n    int i2c_address;\n    int uart_baud;          // UART baud rate.\n    int uart_dev;           // UART peripheral (0, 1, etc.)\n    Config devConf;\n    bool deviceState;\n    uint8_t i2c_register;\n\n    void send(std::string data);\n\n public:\n    Device() { }\n    Device(std::string id, Config &config, std::shared_ptr<RoomState> rs);\n    void setMAC(std::string mac);\n    Connection connectionType() { return connType; }\n    int spiCS() { return spi_cs; }\n    int i2cAddress() { return i2c_address; }\n\n    bool write(std::string bytes);\n    std::string read();\n    std::string read(int length);\n };\n```", "```cpp\n#include \"device.h\"\n #include \"nodes.h\"\n\n Device::Device(std::string id, Config &config, std::shared_ptr<RoomState> rs) : \n                                                                                           roomState(rs),\n                                                                                           spi_cs(0) {\n    std::string cat = \"Device_\" + id;\n    std::string type = config.getValue<std::string>(cat + \".type\", \"\");\n    if (type == \"spi\") {\n          connType = CONN_SPI;\n          spi_cs = config.getValue<int>(cat + \".cs_gpio\", 0);\n          device = config.getValue<std::string>(cat + \".device\", \"\");\n    }\n    else if (type == \"i2c\") {\n          connType == CONN_I2C;\n          i2c_address = config.getValue<int>(cat + \".address\", 0);\n          device = config.getValue<std::string>(cat + \".device\", \"\");\n    }\n    else if (type == \"uart\") {\n          connType == CONN_UART;\n          uart_baud = config.getValue<int>(cat + \".baud\", 0);\n          uart_dev = config.getValue<int>(cat + \".uart\", 0);\n          device = config.getValue<std::string>(cat + \".device\", \"\");\n    }\n    else {\n          // Error. Invalid type.\n    }\n\n }\n```", "```cpp\n\n void Device::setMAC(std::string mac) {\n    this->mac = mac;\n }\n\n // Called when the device (UART-based) wishes to send data.\n void Device::send(std::string data) {\n    Nodes::sendUart(mac, data);\n }\n```", "```cpp\n\n bool Device::write(std::string bytes) {\n    if (!deviceState) { return false; }\n\n    // The first byte contains the register to read/write with I2C. Keep it as reference.\n    if (connType == CONN_I2C && bytes.length() > 0) {\n          i2c_register = bytes[0];\n    }\n    else if (connType == CONN_SPI) {\n          // .\n    }\n    else if (connType == CONN_UART) {\n          //\n    }\n    else { return false; }\n\n    return true;\n }\n```", "```cpp\nstd::string Device::read(int length) {\n    if (!deviceState) { return std::string(); }\n\n    switch (connType) {\n          case CONN_SPI:\n                return std::string();\n                break;\n          case CONN_I2C:\n          {\n                // Get the specified values from the room state instance.\n                // Here we hard code a BME280 sensor.\n                // Which value we return depends on the register set.\n                uint8_t zero = 0x0;\n                switch (i2c_register) {\n                      case 0xFA: // Temperature. MSB, LSB, XLSB.\n                      {\n                            std::string ret = std::to_string(roomState->getTemperature()); // MSB\n                            ret.append(std::to_string(zero)); // LSB\n                            ret.append(std::to_string(zero)); // XLSB\n                            return ret;\n                            break;\n                      }\n                      case 0xF7: // Pressure. MSB, LSB, XLSB.\n                      {\n                            std::string ret = std::to_string(roomState->getPressure()); // MSB\n                            ret.append(std::to_string(zero)); // LSB\n                            ret.append(std::to_string(zero)); // XLSB\n                            return ret;\n                            break;\n                      }\n                      case 0xFD: // Humidity. MSB, LSB.\n                      {\n                            std::string ret = std::to_string(roomState->getHumidity()); // MSB\n                            ret.append(std::to_string(zero)); // LSB\n                            return ret;\n                            break;\n                      }\n                      default:\n                            return std::string();\n                            break;\n                }\n\n                break;\n          }\n          case CONN_UART:\n                // \n\n                break;\n          default:\n                // Error.\n                return std::string();\n    };\n\n    return std::string();\n }\n\n std::string Device::read() {\n    return read(0);\n }\n```", "```cpp\n\n #include <memory>\n #include <thread>\n #include <mutex>\n\n enum Connection {\n    CONN_NC = 0,\n    CONN_SPI = 1,\n    CONN_I2C = 2,\n    CONN_UART = 3\n };\n\n class RoomState {\n    float temperature;      // Room temperature\n    float humidity;         // Relatively humidity (0.00 - 100.00%)\n    uint16_t pressure;      // Air pressure.\n    std::mutex tmtx;\n    std::mutex hmtx;\n    std::mutex pmtx;\n\n public:\n    RoomState() : \n          temperature(0),\n          humidity(0),\n          pressure(1000) {\n          //\n    }\n\n    float getTemperature() {\n          std::lock_guard<std::mutex> lk(tmtx); \n          return temperature; \n\n    }\n\n    void setTemperature(float t) {\n          std::lock_guard<std::mutex> lk(tmtx); \n          temperature = t; \n    }\n\n    float getHumidity() {\n          std::lock_guard<std::mutex> lk(hmtx); \n          return humidity;\n    }\n\n    void setHumidity(float h) {\n          std::lock_guard<std::mutex> lk(hmtx);\n          temperature = h; \n    }     \n\n    float getPressure() {\n          std::lock_guard<std::mutex> lk(pmtx); \n          return pressure;\n    }\n\n    void setPressure(uint16_t p) {\n          std::lock_guard<std::mutex> lk(pmtx);\n          pressure = p;\n    }\n };\n```", "```cpp\n#include \"config.h\"\n #include \"devices/device.h\"\n\n #include <string>\n #include <vector>\n #include <map>\n\n class Node {\n    std::string mac;\n    bool uart0_active;\n    Device uart0;\n    std::map<int, Device> i2c;\n    std::map<int, Device> spi;\n    std::vector<Device> devices;\n\n public:\n    Node(std::string id, Config &config);\n    bool addDevice(Device &&device);\n\n    bool writeUart(std::string bytes);\n    bool writeSPI(std::string bytes);\n    std::string readSPI();\n    bool writeI2C(int i2cAddress, std::string bytes);\n    std::string readI2C(int i2cAddress, int length);\n };\n```", "```cpp\n#include \"node.h\"\n #include \"nodes.h\"\n\n #include <cstdlib>\n #include <utility>\n\n Node::Node(std::string id, Config &config) : uart0_active(false) {\n    std::string node_cat = \"Node_\" + id;\n    mac = config.getValue<std::string>(node_cat + \".mac\", \"\");\n\n    Nodes::addNode(mac, this);\n    std::system(\"esp8266\");\n };\n```", "```cpp\nbool Node::addDevice(Device &&device) {\n    device.setMAC(mac);\n\n    switch (device.connectionType()) {\n          case CONN_SPI:\n                spi.insert(std::pair<int, Device>(device.spiCS(), std::move(device)));\n                break;\n          case CONN_I2C:\n                i2c.insert(std::pair<int, Device>(device.i2cAddress(), std::move(device)));\n                break;\n          case CONN_UART:\n                uart0 = std::move(device);\n                uart0_active = true;\n                break;\n          default:\n                // Error.\n                break;\n    }\n\n    return true;\n }\n```", "```cpp\nbool Node::writeUart(std::string bytes) {\n    if (!uart0_active) { return false; }\n\n    uart0.write(bytes);\n\n    return true;\n }\n\n bool Node::writeSPI(std::string bytes) {\n    if (spi.size() == 1) {\n          spi[0].write(bytes);\n    }\n    else {\n          return false; \n    }\n\n    return true;\n }\n\n std::string Node::readSPI() {\n    if (spi.size() == 1) {\n          return spi[0].read();\n    }\n    else {\n          return std::string();\n    }\n }\n\n bool Node::writeI2C(int i2cAddress, std::string bytes) {\n    if (i2c.find(i2cAddress) == i2c.end()) { return false; }\n\n    i2c[i2cAddress].write(bytes);\n    return true;\n }\n\n std::string Node::readI2C(int i2cAddress, int length) {\n    if (i2c.count(i2cAddress) || length < 1) { return std::string(); }\n\n    return i2c[i2cAddress].read(length);\n }\n\n```", "```cpp\n#include <map>\n #include <string>\n #include <queue>\n\n class Node;\n\n class Nodes {\n    static Node* getNode(std::string mac);\n\n    static std::map<std::string, Node*> nodes;\n    static std::queue<std::string> macs;\n    static std::map<std::string, int> sessions;\n\n public:\n    static bool addNode(std::string mac, Node* node);\n    static bool removeNode(std::string mac);\n    static void registerSession(std::string mac, int session);\n    static bool writeUart(std::string mac, std::string bytes);\n    static bool sendUart(std::string mac, std::string bytes);\n    static bool writeSPI(std::string mac, std::string bytes);\n    static std::string readSPI(std::string mac);\n    static bool writeI2C(std::string mac, int i2cAddress, std::string bytes);\n    static std::string readI2C(std::string mac, int i2cAddress, int length);\n    static void addMAC(std::string mac);\n    static std::string getMAC();\n };\n```", "```cpp\n#include \"nodes.h\"\n #include \"node.h\"\n #include <nymph/nymph.h>\n\n // Static initialisations.\n std::map<std::string, Node*> Nodes::nodes;\n std::queue<std::string> Nodes::macs;\n std::map<std::string, int> Nodes::sessions;\n\n Node* Nodes::getNode(std::string mac) {\n    std::map<std::string, Node*>::iterator it;\n    it = nodes.find(mac);\n    if (it == nodes.end()) { return 0; }\n\n    return it->second;\n }\n\n bool Nodes::addNode(std::string mac, Node* node) {\n    std::pair<std::map<std::string, Node*>::iterator, bool> ret;\n    ret = nodes.insert(std::pair<std::string, Node*>(mac, node));\n    if (ret.second) { macs.push(mac); }\n    return ret.second;\n }\n\n bool Nodes::removeNode(std::string mac) {\n    std::map<std::string, Node*>::iterator it;\n    it = nodes.find(mac);\n    if (it == nodes.end()) { return false; }  \n    nodes.erase(it);\n    return true;\n }\n```", "```cpp\nvoid Nodes::registerSession(std::string mac, int session) {\n    sessions.insert(std::pair<std::string, int>(mac, session));\n }\n```", "```cpp\nbool Nodes::writeUart(std::string mac, std::string bytes) {\n    Node* node = getNode(mac);\n    if (!node) { return false; }\n\n    node->writeUart(bytes);\n\n    return true;\n }\n\n bool Nodes::sendUart(std::string mac, std::string bytes) {\n    std::map<std::string, int>::iterator it;\n    it = sessions.find(mac);\n    if (it == sessions.end()) { return false; }\n\n    vector<NymphType*> values;\n    values.push_back(new NymphString(bytes));\n    string result;\n    NymphBoolean* world = 0;\n    if (!NymphRemoteClient::callCallback(it->second, \"serialRxCallback\", values, result)) {\n          // \n    }\n\n    return true;\n }\n\n bool Nodes::writeSPI(std::string mac, std::string bytes) {\n    Node* node = getNode(mac);\n    if (!node) { return false; }\n\n    node->writeSPI(bytes);\n\n    return true;\n }\n\n std::string Nodes::readSPI(std::string mac) {\n    Node* node = getNode(mac);\n    if (!node) { return std::string(); }\n\n    return node->readSPI();\n }\n\n bool Nodes::writeI2C(std::string mac, int i2cAddress, std::string bytes) {\n    Node* node = getNode(mac);\n    if (!node) { return false; }\n\n    node->writeI2C(i2cAddress, bytes);\n\n    return true;\n }\n\n std::string Nodes::readI2C(std::string mac, int i2cAddress, int length) {\n    Node* node = getNode(mac);\n    if (!node) { return std::string(); }\n\n    return node->readI2C(i2cAddress, length);\n }\n```", "```cpp\nvoid Nodes::addMAC(std::string mac) {\n    macs.push(mac);\n }\n\n std::string Nodes::getMAC() {\n     if (macs.empty()) { return std::string(); }\n\n     std::string val = macs.front();\n     macs.pop();\n     return val;\n  }\n```", "```cpp\nexport TOP := $(CURDIR)\n\n GPP = g++\n GCC = gcc\n MAKEDIR = mkdir -p\n RM = rm\n\n OUTPUT = bmac_server\n INCLUDE = -I .\n FLAGS := $(INCLUDE) -g3 -std=c++17 -U__STRICT_ANSI__\n LIB := -lnymphrpc -lPocoNet -lPocoUtil -lPocoFoundation -lPocoJSON\n CPPFLAGS := $(FLAGS)\n CFLAGS := -g3 \n CPP_SOURCES := $(wildcard *.cpp) $(wildcard devices/*.cpp)\n CPP_OBJECTS := $(addprefix obj/,$(notdir) $(CPP_SOURCES:.cpp=.o))\n\n all: makedir $(C_OBJECTS) $(CPP_OBJECTS) bin/$(OUTPUT)\n\n obj/%.o: %.cpp\n    $(GPP) -c -o $@ $< $(CPPFLAGS)\n\n bin/$(OUTPUT):\n    -rm -f $@\n    $(GPP) -o $@ $(C_OBJECTS) $(CPP_OBJECTS) $(LIB)\n\n makedir:\n    $(MAKEDIR) bin\n    $(MAKEDIR) obj/devices\n\n clean:\n    $(RM) $(CPP_OBJECTS)\n```", "```cpp\nclass TcpClient;\n #include \"../Delegate.h\"\n #include \"../../Wiring/WString.h\"\n #include \"../../Wiring/WHashMap.h\"\n #include \"libmosquitto/cpp/mosquittopp.h\"\n #include \"URL.h\"\n\n typedef Delegate<void(String topic, String message)> MqttStringSubscriptionCallback;\n typedef Delegate<void(uint16_t msgId, int type)> MqttMessageDeliveredCallback;\n typedef Delegate<void(TcpClient& client, bool successful)> TcpClientCompleteDelegate;\n\n class MqttClient;\n class URL;\n\n class MqttClient : public mosqpp::mosquittopp {\n public:\n    MqttClient(bool autoDestruct = false);\n    MqttClient(String serverHost, int serverPort, MqttStringSubscriptionCallback callback = NULL);\n    virtual ~MqttClient();\n\n    void setCallback(MqttStringSubscriptionCallback subscriptionCallback = NULL);\n\n    void setCompleteDelegate(TcpClientCompleteDelegate completeCb);\n\n    void setKeepAlive(int seconds);     \n    void setPingRepeatTime(int seconds);\n    bool setWill(const String& topic, const String& message, int QoS, bool retained = false);\n    bool connect(const URL& url, const String& uniqueClientName, uint32_t sslOptions = 0);\n    bool connect(const String& clientName, bool useSsl = false, uint32_t sslOptions = 0);\n    bool connect(const String& clientName, const String& username, const String& password, bool useSsl = false,\n                       uint32_t sslOptions = 0);\n\n    bool publish(String topic, String message, bool retained = false);\n    bool publishWithQoS(String topic, String message, int QoS, bool retained = false,\n                                  MqttMessageDeliveredCallback onDelivery = NULL);\n\n    bool subscribe(const String& topic);\n    bool unsubscribe(const String& topic);\n\n    void on_message(const struct mosquitto_message* message);\n\n protected:\n    void debugPrintResponseType(int type, int len);\n    static int staticSendPacket(void* userInfo, const void* buf, unsigned int count);\n\n private:\n    bool privateConnect(const String& clientName, const String& username, const String& password,\n                                  bool useSsl = false, uint32_t sslOptions = 0);\n\n    URL url;\n    mosqpp::mosquittopp mqtt;\n    int waitingSize;\n    uint8_t buffer[MQTT_MAX_BUFFER_SIZE + 1];\n    uint8_t* current;\n    int posHeader;\n    MqttStringSubscriptionCallback callback;\n    TcpClientCompleteDelegate completed = nullptr;\n    int keepAlive = 60;\n    int pingRepeatTime = 20;\n    unsigned long lastMessage = 0;\n    HashMap<uint16_t, MqttMessageDeliveredCallback> onDeliveryQueue;\n };\n```", "```cpp\n#include \"MqttClient.h\"\n #include \"../Clock.h\"\n #include <algorithm>\n #include <cstring>\n\n MqttClient::MqttClient(bool autoDestruct /* = false*/)\n {\n    memset(buffer, 0, MQTT_MAX_BUFFER_SIZE + 1);\n    waitingSize = 0;\n    posHeader = 0;\n    current = NULL;\n\n    mosqpp::lib_init();\n }\n\n MqttClient::MqttClient(String serverHost, int serverPort, MqttStringSubscriptionCallback callback /* = NULL*/)\n    {\n    url.Host = serverHost;\n    url.Port = serverPort;\n    this->callback = callback;\n    waitingSize = 0;\n    posHeader = 0;\n    current = NULL;\n\n    mosqpp::lib_init();\n }\n```", "```cpp\n\n MqttClient::~MqttClient() {\n    mqtt.loop_stop();\n    mosqpp::lib_cleanup();\n }\n```", "```cpp\n\n void MqttClient::setCallback(MqttStringSubscriptionCallback callback) {\n    this->callback = callback;\n }\n\n void MqttClient::setCompleteDelegate(TcpClientCompleteDelegate completeCb) {\n    completed = completeCb;\n }\n\n void MqttClient::setKeepAlive(int seconds) {\n    keepAlive = seconds;\n }\n\n void MqttClient::setPingRepeatTime(int seconds) {\n    if(pingRepeatTime > keepAlive) {\n          pingRepeatTime = keepAlive;\n    } else {\n          pingRepeatTime = seconds;\n    }\n }\n\n bool MqttClient::setWill(const String& topic, const String& message, int QoS, bool retained /* = false*/)\n {\n    return mqtt.will_set(topic.c_str(), message.length(), message.c_str(), QoS, retained);\n }\n```", "```cpp\n\n bool MqttClient::connect(const URL& url, const String& clientName, uint32_t sslOptions) {\n    this->url = url;\n    if(!(url.Protocol == \"mqtt\" || url.Protocol == \"mqtts\")) {\n          return false;\n    }\n\n    waitingSize = 0;\n    posHeader = 0;\n    current = NULL;\n\n    bool useSsl = (url.Protocol == \"mqtts\");\n    return privateConnect(clientName, url.User, url.Password, useSsl, sslOptions);\n }\n\n bool MqttClient::connect(const String& clientName, bool useSsl /* = false */, uint32_t sslOptions /* = 0 */)\n {\n    return MqttClient::connect(clientName, \"\", \"\", useSsl, sslOptions);\n }\n\n bool MqttClient::connect(const String& clientName, const String& username, const String& password,\n                                   bool useSsl /* = false */, uint32_t sslOptions /* = 0 */)\n {\n    return privateConnect(clientName, username, password, useSsl, sslOptions);\n }\n```", "```cpp\n\n bool MqttClient::privateConnect(const String& clientName, const String& username, const String& password,\n                                              bool useSsl /* = false */, uint32_t sslOptions /* = 0 */) {\n    if (clientName.length() > 0) {\n          mqtt.reinitialise(clientName.c_str(), false);\n    }\n\n    if (username.length() > 0) {\n          mqtt.username_pw_set(username.c_str(), password.c_str());\n    }\n\n    if (useSsl) {\n          //\n    }\n\n    mqtt.connect(url.Host.c_str(), url.Port, keepAlive);\n    mqtt.loop_start();\n    return true;\n }\n```", "```cpp\n\n bool MqttClient::publish(String topic, String message, bool retained /* = false*/) {\n    int res = mqtt.publish(0, topic.c_str(), message.length(), message.c_str(), 0, retained);\n    return res > 0;\n }\n\n bool MqttClient::publishWithQoS(String topic, String message, int QoS, bool retained /* = false*/,\n                                              MqttMessageDeliveredCallback onDelivery /* = NULL */)\n {\n    int res = mqtt.publish(0, topic.c_str(), message.length(), message.c_str(), QoS, retained);\n\n    return res > 0;\n }\n```", "```cpp\n\n bool MqttClient::subscribe(const String& topic) {\n    int res = mqtt.subscribe(0, topic.c_str());\n    return res > 0;\n }\n\n bool MqttClient::unsubscribe(const String& topic) {\n    int res = mqtt.unsubscribe(0, topic.c_str());\n    return res > 0;\n }\n```", "```cpp\n\n void MqttClient::on_message(const struct mosquitto_message* message) {\n    if (callback) {\n          callback(String(message->topic), String((char*) message->payload, message->payloadlen));\n    }\n }\n\n```", "```cpp\n#include <user_config.h>\n #include <SmingCore/SmingCore.h>\n```", "```cpp\n#include <cstdint>\n #include <cstdio>\n #include <string>\n #include <iostream>\n #include \"wiring/WString.h\"\n #include \"wiring/WVector.h\"\n #include \"wiring/WHashMap.h\"\n #include \"FileSystem.h\"\n #include \"wiring/Stream.h\"\n #include \"Delegate.h\"\n #include \"Network/MqttClient.h\"\n #include \"Timer.h\"\n #include \"WConstants.h\"\n #include \"Clock.h\"\n\n #include <nymph/nymph.h>\n\n```", "```cpp\ntypedef uint8_t uint8;\n typedef uint16_t uint16;\n typedef uint32_t uint32;\n typedef int8_t int8;\n typedef int16_t int16;\n typedef int32_t int32;\n typedef uint32_t u32_t;\n```", "```cpp\n#define UART_ID_0 0 ///< ID of UART 0\n #define UART_ID_1 1 ///< ID of UART 1\n #define SERIAL_BAUD_RATE 115200\n\n typedef Delegate<void(Stream& source, char arrivedChar, uint16_t availableCharsCount)> StreamDataReceivedDelegate;\n\n class SerialStream : public Stream {\n    //\n\n public:\n    SerialStream();\n    size_t write(uint8_t);\n    int available();\n    int read();\n    void flush();\n    int peek();\n };\n\n class HardwareSerial {\n    int uart;\n    uint32_t baud;\n    static StreamDataReceivedDelegate HWSDelegate;\n    static std::string rxBuffer;\n\n public:\n    HardwareSerial(const int uartPort);\n    void begin(uint32_t baud = 9600);\n    void systemDebugOutput(bool enable);\n    void end();\n    size_t printf(const char *fmt, ...);\n    void print(String str);\n    void println(String str);\n    void println(const char* str);\n    void println(int16_t ch);\n    void setCallback(StreamDataReceivedDelegate dataReceivedDelegate);\n    static void dataReceivedCallback(NymphMessage* msg, void* data);\n    size_t write(const uint8_t* buffer, size_t size);\n    size_t readBytes(char *buffer, size_t length);\n };\n\n extern HardwareSerial Serial;\n```", "```cpp\n struct rboot_config {\n    uint8 current_rom;\n    uint32 roms[2];\n };\n\n int rboot_get_current_rom();\n void rboot_set_current_rom(int slot);\n rboot_config rboot_get_config();\n\n class rBootHttpUpdate;\n typedef Delegate<void(rBootHttpUpdate& client, bool result)> OtaUpdateDelegate;\n class rBootHttpUpdate {\n    //\n\n public:\n    void addItem(int offset, String firmwareFileUrl);\n    void setCallback(OtaUpdateDelegate reqUpdateDelegate);\n    void start();\n };\n\n void spiffs_mount_manual(u32_t offset, int count);\n```", "```cpp\n\n class StationClass {\n    String mac;\n    bool enabled;\n\n public:\n    void enable(bool enable);\n    void enable(bool enable, bool save);\n    bool config(const String& ssid, const String& password, bool autoConnectOnStartup = true,\n                                    bool save = true);\n    bool connect();\n    String getMAC();\n\n    static int handle;\n };\n\n extern StationClass WifiStation;\n\n class AccessPointClass {\n    bool enabled;\n\n public:\n    void enable(bool enable, bool save);\n    void enable(bool enable);\n };\n\n extern AccessPointClass WifiAccessPoint;\n\n class IPAddress {\n    //\n public:\n    String toString();\n };\n\n typedef Delegate<void(uint8_t[6], uint8_t)> AccessPointDisconnectDelegate;\n typedef Delegate<void(String, uint8_t, uint8_t[6], uint8_t)> StationDisconnectDelegate;\n typedef Delegate<void(IPAddress, IPAddress, IPAddress)> StationGotIPDelegate;\n class WifiEventsClass {\n    //\n\n public:\n    void onStationGotIP(StationGotIPDelegate delegateFunction); \n    void onStationDisconnect(StationDisconnectDelegate delegateFunction);\n };\n\n extern WifiEventsClass WifiEvents;\n```", "```cpp\n\n void debugf(const char *fmt, ...);\n\n class WDTClass {\n    //\n\n public:\n    void alive();\n };\n\n extern WDTClass WDT;\n```", "```cpp\n\n class TwoWire {\n    uint8_t rxBufferIndex;\n    std::string buffer;\n    int i2cAddress;\n\n public:\n    void pins(int sda, int scl);\n    void begin();\n    void beginTransmission(int address);\n    size_t write(uint8_t data);\n    size_t write(int data);\n    size_t endTransmission();\n    size_t requestFrom(int address, int length);\n    int available();\n    int read();\n };\n\n extern TwoWire Wire;\n\n class SPISettings {\n    //\n public:\n    //\n };\n\n class SPIClass {\n    //\n\n public:\n    void begin();\n    void end();\n    void beginTransaction(SPISettings mySettings);\n    void endTransaction();\n    void transfer(uint8* buffer, size_t numberBytes);\n };\n\n extern SPIClass SPI;\n```", "```cpp\nvoid pinMode(uint16_t pin, uint8_t mode);\n void digitalWrite(uint16_t pin, uint8_t val);\n uint8_t digitalRead(uint16_t pin);\n\n uint16_t analogRead(uint16_t pin);\n```", "```cpp\nString system_get_sdk_version();\n int system_get_free_heap_size();\n int system_get_cpu_freq();\n int system_get_chip_id();\n int spi_flash_get_id();\n\n class SystemClass {\n    //\n\n public:\n    void restart();\n };\n\n extern SystemClass System;\n\n // --- TcpClient ---\n class TcpClient {\n    //\n\n public:\n    //\n };\n\n extern void init();\n```", "```cpp\n\n #include \"SmingCore.h\"\n\n #include <iostream>\n #include <cstdio>\n #include <cstdarg>\n\n int StationClass::handle;\n```", "```cpp\n\n void logFunction(int level, string logStr) {\n    std::cout << level << \" - \" << logStr << std::endl;\n }\n```", "```cpp\n\n void debugf(const char *fmt, ...) { \n    va_list ap;\n    va_start(ap, fmt);\n    int written = vfprintf(stdout, fmt, ap);\n    va_end(ap);\n }\n```", "```cpp\n\n StreamDataReceivedDelegate HardwareSerial::HWSDelegate = nullptr;\n std::string HardwareSerial::rxBuffer;\n HardwareSerial Serial(0);\n```", "```cpp\n\n SerialStream::SerialStream() { }\n size_t SerialStream::write(uint8_t) { return 1; }\n int SerialStream::available() { return 0; }\n int SerialStream::read() { return 0; }\n void SerialStream::flush() { }\n int SerialStream::peek() { return 0; }\n```", "```cpp\nHardwareSerial::HardwareSerial(const int uartPort) { \n    uart = uartPort; \n }\n\n void HardwareSerial::begin(uint32_t baud/* = 9600*/) { \n    this->baud = baud;\n }\n\n void HardwareSerial::systemDebugOutput(bool enable) { }\n void HardwareSerial::end() { }\n size_t HardwareSerial::printf(const char *fmt, ...) { \n    va_list ap;\n    va_start(ap, fmt);\n          int written = vfprintf(stdout, fmt, ap);\n          va_end(ap);\n\n    return written;\n }\n\n void HardwareSerial::print(String str) {\n    std::cout << str.c_str();\n }\n\n void HardwareSerial::println(String str) {\n    std::cout << str.c_str() << std::endl;\n }\n\n void HardwareSerial::println(const char* str) {\n    std::cout << str << std::endl;\n }\n\n void HardwareSerial::println(int16_t ch) {\n    std::cout << std::hex << ch << std::endl;\n }\n\n void HardwareSerial::setCallback(StreamDataReceivedDelegate dataReceivedDelegate) {\n    HWSDelegate = dataReceivedDelegate;\n }\n```", "```cpp\n\n void HardwareSerial::dataReceivedCallback(NymphMessage* msg, void* data) {\n    rxBuffer = ((NymphString*) msg->parameters()[0])->getValue();\n\n    SerialStream stream;\n    int length = rxBuffer.length();\n    int i = 0;\n    HWSDelegate(stream, rxBuffer[i], length - i);\n }\n```", "```cpp\n\n size_t HardwareSerial::write(const uint8_t* buffer, size_t size) {\n    vector<NymphType*> values;\n    values.push_back(new NymphString(WifiStation.getMAC().c_str()));\n    values.push_back(new NymphString(std::string((const char*) buffer, size)));\n    NymphType* returnValue = 0;\n    std::string result;\n    if (!NymphRemoteServer::callMethod(StationClass::handle, \"writeUart\", values, returnValue, result)) {\n          std::cout << \"Error calling remote method: \" << result << std::endl;\n          NymphRemoteServer::disconnect(StationClass::handle, result);\n          NymphRemoteServer::shutdown();\n          return 0;\n    }\n\n    if (returnValue->type() != NYMPH_BOOL) {\n          std::cout << \"Return value wasn't a boolean. Type: \" << returnValue->type() << std::endl;\n          NymphRemoteServer::disconnect(StationClass::handle, result);\n          NymphRemoteServer::shutdown();\n          return 0;\n    }\n\n    return size;\n }\n```", "```cpp\n\n size_t HardwareSerial::readBytes(char* buffer, size_t length) {\n    buffer = rxBuffer.data();\n    return rxBuffer.length();\n }\n```", "```cpp\nint rboot_get_current_rom() { return 0; }\n void rboot_set_current_rom(int slot) { }\n rboot_config rboot_get_config() {\n    rboot_config cfg;\n    cfg.current_rom = 0;\n    cfg.roms[0] = 0x1000;\n    cfg.roms[1] = 0x3000;\n    return cfg;\n }\n\n void rBootHttpUpdate::addItem(int offset, String firmwareFileUrl) { }\n void rBootHttpUpdate::setCallback(OtaUpdateDelegate reqUpdateDelegate) { }\n void rBootHttpUpdate::start() { }\n\n void spiffs_mount_manual(u32_t offset, int count) { }\n```", "```cpp\n\n StationClass WifiStation;\n\n void StationClass::enable(bool enable) { enabled = enable; }\n void StationClass::enable(bool enable, bool save) { enabled = enable; }\n String StationClass::getMAC() { return mac; }\n\n bool StationClass::config(const String& ssid, const String& password, bool autoConnectOnStartup /* = true*/,\n                                    bool save /* = true */) {\n    //\n\n    return true;\n }\n```", "```cpp\n\n bool StationClass::connect() {\n    long timeout = 5000; // 5 seconds.\n    NymphRemoteServer::init(logFunction, NYMPH_LOG_LEVEL_TRACE, timeout);\n    std::string result;\n    if (!NymphRemoteServer::connect(\"localhost\", 4004, StationClass::handle, 0, result)) {\n          cout << \"Connecting to remote server failed: \" << result << std::endl;\n          NymphRemoteServer::disconnect(StationClass::handle, result);\n          NymphRemoteServer::shutdown();\n          return false;\n    }\n\n    vector<NymphType*> values;\n    NymphType* returnValue = 0;\n    if (!NymphRemoteServer::callMethod(StationClass::handle, \"getNewMac\", values, returnValue, result)) {\n          std::cout << \"Error calling remote method: \" << result << std::endl;\n          NymphRemoteServer::disconnect(StationClass::handle, result);\n          NymphRemoteServer::shutdown();\n          return false;\n    }\n\n    if (returnValue->type() != NYMPH_STRING) {\n          std::cout << \"Return value wasn't a string. Type: \" << returnValue->type() << std::endl;\n          NymphRemoteServer::disconnect(StationClass::handle, result);\n          NymphRemoteServer::shutdown();\n          return false;\n    }\n\n    std::string macStr = ((NymphString*) returnValue)->getValue();\n    mac = String(macStr.data(), macStr.length());\n\n    delete returnValue;\n    returnValue = 0;\n\n    // Set the serial interface callback.\n    NymphRemoteServer::registerCallback(\"serialRxCallback\", HardwareSerial::dataReceivedCallback, 0);\n\n    return true;\n }\n```", "```cpp\n\n AccessPointClass WifiAccessPoint;\n\n void AccessPointClass::enable(bool enable, bool save) {\n    enabled = enable;\n }\n\n void AccessPointClass::enable(bool enable) {\n    enabled = enable;\n }\n\n WifiEventsClass WifiEvents;\n\n String IPAddress::toString() { return \"192.168.0.32\"; }\n\n void WifiEventsClass::onStationGotIP(StationGotIPDelegate delegateFunction) {\n    // Immediately call the callback.\n    IPAddress ip;\n    delegateFunction(ip, ip, ip);\n }\n\n void WifiEventsClass::onStationDisconnect(StationDisconnectDelegate delegateFunction) {\n    //\n }\n\n WDTClass WDT;\n\n void WDTClass::alive() { }\n```", "```cpp\n\n void SPIClass::begin() { }\n void SPIClass::end() { }\n void SPIClass::beginTransaction(SPISettings mySettings) { }\n void SPIClass::endTransaction() { }\n void SPIClass::transfer(uint8* buffer, size_t numberBytes) {\n    vector<NymphType*> values;\n    values.push_back(new NymphString(WifiStation.getMAC().c_str()));\n    values.push_back(new NymphString(std::string((char*) buffer, numberBytes)));\n    NymphType* returnValue = 0;\n    std::string result;\n    if (!NymphRemoteServer::callMethod(StationClass::handle, \"writeSPI\", values, returnValue, result)) {\n          std::cout << \"Error calling remote method: \" << result << std::endl;\n          NymphRemoteServer::disconnect(StationClass::handle, result);\n          NymphRemoteServer::shutdown();\n          return;\n    }\n\n    if (returnValue->type() != NYMPH_BOOL) {\n          std::cout << \"Return value wasn't a boolean. Type: \" << returnValue->type() << std::endl;\n          NymphRemoteServer::disconnect(StationClass::handle, result);\n          NymphRemoteServer::shutdown();\n          return;\n    }\n }\n\n SPIClass SPI;\n```", "```cpp\n void TwoWire::pins(int sda, int scl) { }\n void TwoWire::begin() { }\n void TwoWire::beginTransmission(int address) { i2cAddress = address; }\n size_t TwoWire::write(uint8_t data) {\n    vector<NymphType*> values;\n    values.push_back(new NymphString(WifiStation.getMAC().c_str()));\n    values.push_back(new NymphSint32(i2cAddress));\n    values.push_back(new NymphString(std::to_string(data)));\n    NymphType* returnValue = 0;\n    std::string result;\n    if (!NymphRemoteServer::callMethod(StationClass::handle, \"writeI2C\", values, returnValue, result)) {\n          std::cout << \"Error calling remote method: \" << result << std::endl;\n          NymphRemoteServer::disconnect(StationClass::handle, result);\n          NymphRemoteServer::shutdown();\n          return 0;\n    }\n\n    if (returnValue->type() != NYMPH_BOOL) {\n          std::cout << \"Return value wasn't a boolean. Type: \" << returnValue->type() << std::endl;\n          NymphRemoteServer::disconnect(StationClass::handle, result);\n          NymphRemoteServer::shutdown();\n          return 0;\n    }\n\n    return 1;\n }\n\n size_t TwoWire::write(int data) {\n    vector<NymphType*> values;\n    values.push_back(new NymphString(WifiStation.getMAC().c_str()));\n    values.push_back(new NymphSint32(i2cAddress));\n    values.push_back(new NymphString(std::to_string(data)));\n    NymphType* returnValue = 0;\n    std::string result;\n    if (!NymphRemoteServer::callMethod(StationClass::handle, \"writeI2C\", values, returnValue, result)) {\n          std::cout << \"Error calling remote method: \" << result << std::endl;\n          NymphRemoteServer::disconnect(StationClass::handle, result);\n          NymphRemoteServer::shutdown();\n          return 0;\n    }\n\n    if (returnValue->type() != NYMPH_BOOL) {\n          std::cout << \"Return value wasn't a boolean. Type: \" << returnValue->type() << std::endl;\n          NymphRemoteServer::disconnect(StationClass::handle, result);\n          NymphRemoteServer::shutdown();\n          return 0;\n    }\n\n    return 1;\n }\n```", "```cpp\n\n size_t TwoWire::endTransmission() { return 0; }\n size_t TwoWire::requestFrom(int address, int length) {\n    write(address);\n\n    vector<NymphType*> values;\n    values.push_back(new NymphString(WifiStation.getMAC().c_str()));\n    values.push_back(new NymphSint32(address));\n    values.push_back(new NymphSint32(length));\n    NymphType* returnValue = 0;\n    std::string result;\n    if (!NymphRemoteServer::callMethod(StationClass::handle, \"readI2C\", values, returnValue, result)) {\n          std::cout << \"Error calling remote method: \" << result << std::endl;\n          NymphRemoteServer::disconnect(StationClass::handle, result);\n          NymphRemoteServer::shutdown();\n          exit(1);\n    }\n\n    if (returnValue->type() != NYMPH_STRING) {\n          std::cout << \"Return value wasn't a string. Type: \" << returnValue->type() << std::endl;\n          NymphRemoteServer::disconnect(StationClass::handle, result);\n          NymphRemoteServer::shutdown();\n          exit(1);\n    }\n\n    rxBufferIndex = 0;\n    buffer = ((NymphString*) returnValue)->getValue();\n    return buffer.size();\n }\n```", "```cpp\n\n int TwoWire::available() {\n    return buffer.length() - rxBufferIndex;\n }\n\n int TwoWire::read() {\n    int value = -1;\n    if (rxBufferIndex < buffer.length()) {\n          value = buffer.at(rxBufferIndex);\n          ++rxBufferIndex;\n    }\n\n    return value;\n }\n\n TwoWire Wire;\n```", "```cpp\nString system_get_sdk_version() { return \"SIM_0.1\"; }\n int system_get_free_heap_size() { return 20000; }\n int system_get_cpu_freq() { return 1200000; }\n int system_get_chip_id() { return 42; }\n int spi_flash_get_id() { return 42; }\n\n void SystemClass::restart() { }\n\n SystemClass System;\n```", "```cpp\nvoid pinMode(uint16_t pin, uint8_t mode) { }\n void digitalWrite(uint16_t pin, uint8_t val) { }\n uint8_t digitalRead(uint16_t pin) { return 1; }\n\n uint16_t analogRead(uint16_t pin) { return 1000; }\n```", "```cpp\n\n int main() {\n    // Start the firmware image.\n    init();\n\n    return 0;\n }\n\n```", "```cpp\n#include \"FileSystem.h\"\n #include \"../Wiring/WString.h\"\n\n #include <filesystem>\n #include <iostream>\n #include <fstream>\n\n namespace fs = std::filesystem;\n\n file_t fileOpen(const String& name, FileOpenFlags flags) {\n    file_t res;\n\n    if ((flags & eFO_CreateNewAlways) == eFO_CreateNewAlways) {\n          if (fileExist(name)) {\n                fileDelete(name);\n          }\n\n          flags = (FileOpenFlags)((int)flags & ~eFO_Truncate);\n    }\n\n    res = std::fopen(name.c_str(), \"r+b\");\n    return res;\n }\n```", "```cpp\n\n void fileClose(file_t file) {\n    std::fclose(file);\n }\n\n size_t fileWrite(file_t file, const void* data, size_t size) {\n    int res = std::fwrite((void*) data, size, size, file);      \n    return res;\n }\n\n size_t fileRead(file_t file, void* data, size_t size) {\n    int res = std::fread(data, size, size, file);\n    return res;\n }\n\n int fileSeek(file_t file, int offset, SeekOriginFlags origin) {\n    return std::fseek(file, offset, origin);\n }\n\n bool fileIsEOF(file_t file) {\n    return true;\n }\n\n int32_t fileTell(file_t file) {\n    return 0;\n }\n\n int fileFlush(file_t file) {\n    return 0; \n }\n\n void fileDelete(const String& name) {\n    fs::remove(name.c_str());\n }\n\n void fileDelete(file_t file) {\n    //\n }\n\n bool fileExist(const String& name) {\n    std::error_code ec;\n    bool ret = fs::is_regular_file(name.c_str(), ec);\n    return ret;\n }\n\n int fileLastError(file_t fd) {\n    return 0;\n }\n\n void fileClearLastError(file_t fd) {\n    //\n }\n\n void fileSetContent(const String& fileName, const String& content) {\n    fileSetContent(fileName, content.c_str());\n }\n\n void fileSetContent(const String& fileName, const char* content) {\n    file_t file = fileOpen(fileName.c_str(), eFO_CreateNewAlways | eFO_WriteOnly);\n    fileWrite(file, content, strlen(content));\n    fileClose(file);\n }\n\n uint32_t fileGetSize(const String& fileName) {\n    int size = 0;\n    try {\n         size = fs::file_size(fileName.c_str());\n     } \n    catch (fs::filesystem_error& e) {\n         std::cout << e.what() << std::endl;\n     }\n\n    return size;\n }\n\n void fileRename(const String& oldName, const String& newName) {\n    try {\n          fs::rename(oldName.c_str(), newName.c_str());\n    }\n    catch (fs::filesystem_error& e) {\n          std::cout << e.what() << std::endl;\n    }\n }\n\n Vector<String> fileList() {\n    Vector<String> result;\n    return result;\n }\n\n String fileGetContent(const String& fileName) {\n    std::ifstream ifs(fileName.c_str(), std::ios::in | std::ios::binary | std::ios::ate);\n\n     std::ifstream::pos_type fileSize = ifs.tellg();\n     ifs.seekg(0, std::ios::beg);\n     std::vector<char> bytes(fileSize);\n     ifs.read(bytes.data(), fileSize);\n\n     return String(bytes.data(), fileSize);\n }\n\n int fileGetContent(const String& fileName, char* buffer, int bufSize) {\n    if (buffer == NULL || bufSize == 0) { return 0; }\n    *buffer = 0;\n\n    std::ifstream ifs(fileName.c_str(), std::ios::in | std::ios::binary | std::ios::ate);\n\n     std::ifstream::pos_type fileSize = ifs.tellg();\n    if (fileSize <= 0 || bufSize <= fileSize) {\n          return 0;\n    }\n\n     buffer[fileSize] = 0;\n     ifs.seekg(0, std::ios::beg);\n    ifs.read(buffer, fileSize);\n    ifs.close();\n\n     return (int) fileSize;\n }\n```", "```cpp\n#include \"Poco/Timer.h\"\n #include <iostream>\n\n typedef void (*os_timer_func_t)(void* timer_arg);\n\n class SimpleTimer {\n public:\n    SimpleTimer() : timer(0) {\n          cb = new Poco::TimerCallback<SimpleTimer>(*this, &SimpleTimer::onTimer);\n    }\n\n    ~SimpleTimer() {\n          stop();\n          delete cb;\n          if (timer) {\n                delete timer;\n          }\n    }\n\n    __forceinline void startMs(uint32_t milliseconds, bool repeating = false) {\n          stop();\n          if (repeating) {\n                timer = new Poco::Timer(milliseconds, 0);\n          }\n          else {\n                timer = new Poco::Timer(milliseconds, milliseconds);\n          }\n\n          timer->start(*cb);\n    }\n\n    __forceinline void startUs(uint32_t microseconds, bool repeating = false) {\n          stop();\n          uint32_t milliseconds = microseconds / 1000;\n          if (repeating) {\n                timer = new Poco::Timer(milliseconds, 0);\n          }\n          else {\n                timer = new Poco::Timer(milliseconds, milliseconds);\n          }\n\n          timer->start(*cb);\n    }\n\n    __forceinline void stop() {\n          timer->stop();\n          delete timer;\n          timer = 0;\n    }\n\n    void setCallback(os_timer_func_t callback, void* arg = nullptr)   {\n          stop();\n          userCb = callback;\n          userCbArg = arg;\n    }\n\n private:\n    void onTimer(Poco::Timer &timer) {\n          userCb(userCbArg);\n    }\n\n    Poco::Timer* timer;\n    Poco::TimerCallback<SimpleTimer>* cb;\n    os_timer_func_t userCb;\n    void* userCbArg;\n };\n```", "```cpp\n#include \"Clock.h\"\n #include <chrono>\n\n unsigned long millis() {\n    unsigned long now = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();\n    return now;\n }\n\n unsigned long micros() {\n    unsigned long now = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch()).count();\n    return now;\n }\n\n void delay(uint32_t milliseconds) {\n    //\n }\n\n void delayMicroseconds(uint32_t time) {   //\n }\n```", "```cpp\nGPP = g++\n GCC = gcc\n MAKEDIR = mkdir -p\n RM = rm\n AR = ar\n ROOT = test/node\n OUTPUT = bmac_esp8266\n OUTLIB = lib$(OUTPUT).a\n INCLUDE = -I $(ROOT)/ \\\n                -I $(ROOT)/SmingCore/ \\\n                -I $(ROOT)/SmingCore/network \\\n                -I $(ROOT)/SmingCore/network/Http \\\n                -I $(ROOT)/SmingCore/network/Http/Websocket \\\n                -I $(ROOT)/SmingCore/network/libmosquitto \\\n                -I $(ROOT)/SmingCore/network/libmosquitto/cpp \\\n                -I $(ROOT)/SmingCore/wiring \\\n                -I $(ROOT)/Libraries/BME280 \\\n                -I $(ROOT)/esp8266/app\n FLAGS := $(INCLUDE) -g3 -U__STRICT_ANSI__\n LIB := -L$(ROOT)/lib -l$(OUTPUT) -lmosquittopp -lmosquitto  -lnymphrpc \\\n          -lPocoNet -lPocoUtil -lPocoFoundation -lPocoJSON -lstdc++fs \\\n          -lssl -lcrypto\n LIB_WIN :=  -lws2_32\n ifeq ($(OS),Windows_NT)\n    LIB := $(LIB) $(LIB_WIN)\n endif\n include ./esp8266/version\n include ./Makefile-user.mk\n CPPFLAGS := $(FLAGS) -DVERSION=\"\\\"$(VERSION)\\\"\" $(USER_CFLAGS) -std=c++17 -Wl,--gc-sections\n CFLAGS := -g3 \n CPP_SOURCES := $(wildcard $(ROOT)/SmingCore/*.cpp) \\\n                $(wildcard $(ROOT)/SmingCore/network/*.cpp) \\\n                $(wildcard $(ROOT)/SmingCore/network/Http/*.cpp) \\\n                $(wildcard $(ROOT)/SmingCore/wiring/*.cpp) \\\n                $(wildcard $(ROOT)/Libraries/BME280/*.cpp)\n FW_SOURCES := $(wildcard esp8266/app/*.cpp)\n CPP_OBJECTS := $(addprefix $(ROOT)/obj/,$(notdir) $(CPP_SOURCES:.cpp=.o))\n FW_OBJECTS := $(addprefix $(ROOT)/obj/,$(notdir) $(FW_SOURCES:.cpp=.o))\n all: makedir $(FW_OBJECTS) $(CPP_OBJECTS) $(ROOT)/lib/$(OUTLIB) $(ROOT)/bin/$(OUTPUT)\n $(ROOT)/obj/%.o: %.cpp\n    $(GPP) -c -o $@ $< $(CPPFLAGS)\n $(ROOT)/obj/%.o: %.c\n    $(GCC) -c -o $@ $< $(CFLAGS)\n $(ROOT)/lib/$(OUTLIB): $(CPP_OBJECTS)\n    -rm -f $@\n    $(AR) rcs $@ $^\n $(ROOT)/bin/$(OUTPUT):\n    -rm -f $@\n    $(GPP) -o $@ $(CPPFLAGS) $(FW_SOURCES) $(LIB)\n makedir:\n    $(MAKEDIR) $(ROOT)/bin\n    $(MAKEDIR) $(ROOT)/lib\n    $(MAKEDIR) $(ROOT)/obj\n    $(MAKEDIR) $(ROOT)/obj/$(ROOT)/SmingCore/network\n    $(MAKEDIR) $(ROOT)/obj/$(ROOT)/SmingCore/wiring\n    $(MAKEDIR) $(ROOT)/obj/$(ROOT)/Libraries/BME280\n    $(MAKEDIR) $(ROOT)/obj/esp8266/app\n clean:\n    $(RM) $(CPP_OBJECTS) $(FW_OBJECTS)\n```", "```cpp\nWIFI_SSID = MyWi-FiNetwork\n WIFI_PWD = MyWi-FiPassword\n\n MQTT_HOST = localhost\n # For SSL support, uncomment the following line or compile with this parameter.\n #ENABLE_SSL=1\n # MQTT SSL port (for example):\n ifdef ENABLE_SSL\n MQTT_PORT = 8883 \n else\n MQTT_PORT = 1883\n endif\n\n # Uncomment if password authentication is used.\n # USE_MQTT_PASSWORD=1\n # MQTT username & password (if needed):\n # MQTT_USERNAME = esp8266\n # MQTT_PWD = ESPassword\n\n # MQTT topic prefix: added to all MQTT subscriptions and publications.\n # Can be left empty, but must be defined.\n # If not left empty, should end with a '/' to avoid merging with topic names.\n MQTT_PREFIX = \n\n # OTA (update) URL. Only change the host name (and port).\n OTA_URL = http://ota.host.net/ota.php?uid=\n\n USER_CFLAGS := $(USER_CFLAGS) -DWIFI_SSID=\"\\\"$(WIFI_SSID)\"\\\"\n USER_CFLAGS := $(USER_CFLAGS) -DWIFI_PWD=\"\\\"$(WIFI_PWD)\"\\\"\n USER_CFLAGS := $(USER_CFLAGS) -DMQTT_HOST=\"\\\"$(MQTT_HOST)\"\\\"\n USER_CFLAGS := $(USER_CFLAGS) -DMQTT_PORT=\"$(MQTT_PORT)\"\n USER_CFLAGS := $(USER_CFLAGS) -DMQTT_USERNAME=\"\\\"$(MQTT_USERNAME)\"\\\"\n USER_CFLAGS := $(USER_CFLAGS) -DOTA_URL=\"\\\"$(OTA_URL)\"\\\"\n USER_CFLAGS := $(USER_CFLAGS) -DMQTT_PWD=\"\\\"$(MQTT_PWD)\"\\\"\n ifdef USE_MQTT_PASSWORD\n USER_CFLAGS := $(USER_CFLAGS) -DUSE_MQTT_PASSWORD=\"\\\"$(USE_MQTT_PASSWORD)\"\\\"\n endif\n SER_CFLAGS := $(USER_CFLAGS) -DMQTT_PREFIX=\"\\\"$(MQTT_PREFIX)\"\\\"\n```", "```cpp\nmake\n```"]