- en: Deep Dive into Pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pointers have been the popular choice among programmers when it comes to using
    memory in an optimized way. Pointers have made it possible to access the content of
    any variable, array, or data type. You can use pointers for low-level access to
    any content and improve the overall performance of an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following recipes on pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: Reversing a string using pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the largest value in an array using pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting a singly linked list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the transpose of a matrix using pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing a structure using a pointer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start with the recipes, I would like to discuss a few things related
    to how pointers work.
  prefs: []
  type: TYPE_NORMAL
- en: What is a pointer?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pointer is a variable that contains the memory address of another variable,
    array, or string. When a pointer contains the address of something, it is said
    to be pointing at that thing. When a pointer points at something, it receives
    the right to access the content of that memory address. The question now is—why
    do we need pointers at all?
  prefs: []
  type: TYPE_NORMAL
- en: 'We need them because they do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Facilitate the dynamic allocation of memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide an alternative way to access a data type (apart from variable names,
    you can access the content of a variable through pointers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make it possible to return more than one value from a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, consider an `i` integer variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When you define an integer variable, two bytes will be allocated to it in memory.
    This set of two bytes can be accessed by a memory address. The value assigned
    to the variable is stored inside that memory location, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c87d29f-a0d3-402a-bef6-6e993c1cfa4f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, **1000** represents the memory address of the **i** variable.
    Though, in reality, memory address is quite big and is in hex format, for the
    sake of simplicity, I am taking a small integer number, **1000**. The value of **10** is
    stored inside the memory address, **1000**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, a `j` integer pointer can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This `j` integer pointer can point to the `i` integer through the following
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `&` (ampersand) symbol represents the address, and the address of **i**
    will be assigned to the **j** pointer, as shown in the following diagram. The
    **2000** address is assumed to be the address of the **j** pointer and the address
    of the **i** pointer, that is, **1000**, is stored inside the memory location
    assigned to the **j** pointer, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce63d3dc-5a76-419e-bbda-59f3854d0d25.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2
  prefs: []
  type: TYPE_NORMAL
- en: 'The address of the `i` integer can be displayed by the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To display the contents of `i`, we can use the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the case of pointers, `&` (ampersand) represents the memory address and `*`
    (asterisk) represents content in the memory address.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define a pointer to an integer pointer by means of the following
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This pointer to a `k` integer pointer can point to a `j` integer pointer using
    the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Through the previous statement, the address of the **j** pointer will be assigned
    to the pointer to a **k** integer pointer, as shown in the following diagram.
    The value of **3000** is assumed to be the memory address of **k**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccd2200b-6047-49c2-9618-c883acb9e939.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you display the value of `k`, it will display the address of `j`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To display the address of `i` through `k`, we need to use `*k`, because `*k`
    means that it will display the contents of the memory address pointed at by `k`.
    Now, `k` is pointing at `j` and the content in `j` is the address of `i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, to display the value of `i` through `k`, `**k` has to be used as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using pointers enables us to access content precisely from desired memory locations.
    But allocating memory through pointers and not releasing it when the job is done
    may lead to a problem called **memory leak**. A memory leak is a sort of resource
    leak. A memory leak can allow unauthorized access of the memory content to hackers
    and may also block some content from being accessed even though it is present.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's begin with the first recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Reversing a string using pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn to reverse a string using pointers. The best part
    is that we will not reverse the string and copy it onto another string, but we
    will reverse the original string itself.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enter a string to assign to the `str` string variable as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Set a pointer to point at the string, as demonstrated in the following code. The
    pointer will point at the memory address of the string''s first character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the length of the string by initializing an `n` variable to `1`. Set a
    `while` loop to execute when the pointer reaches the null character of the string
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `while` loop, the following actions will be performed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The pointer is moved one character forward.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The value of the `n` variable is incremented by 1:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The pointer will be at the null character, so move the pointer one step back
    to make it point at the last character of the string as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Set another pointer to point at the beginning of the string as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Exchange the characters equal to half the length of the string. To do that,
    set a `while` loop to execute for `n/2` times, as demonstrated in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `while` loop, the first exchange operations take place; that is,
    the characters pointed at by our pointers are exchanged:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After the character exchange, set the second pointer to move forward to point
    at its next character, that is, at the second character of the string, and move
    the first pointer backward to make it point at the second to last character as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeat this procedure for n/2 times, where `n` is the length of the string.
    When the `while` loop is finished, we will have the reverse form of the original
    string displayed on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `reversestring.c` program for reversing a string using pointers is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be prompted to enter a string that will be assigned to the `str` variable.
    A string is nothing but a character array. Assuming we enter the name `manish`,
    each character of the name will be assigned to a location in the array one by
    one (see *Figure 4.4*). We can see that the first character of the string, the
    letter **m**, is assigned to the **str[0]** location, followed by the second string
    character being assigned to the **str[1]** location, and so on. The null character,
    as usual, is at the end of the string, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec0814c0-ab76-46a8-aed8-43dd924144b6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4
  prefs: []
  type: TYPE_NORMAL
- en: 'To reverse the string, we will seek the help of two pointers: one will be set
    to point at the first character of the string, and the other at the final character
    of the string. So, the first **ptr1** pointer is set to point at the first character
    of the string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/367bd11b-28d8-4f37-8df0-d2b397196590.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5
  prefs: []
  type: TYPE_NORMAL
- en: The exchanging of the characters has to be executed equal to half the length
    of the string; therefore, the next step will be to find the length of the string.
    After finding the string's length, the **ptr1** pointer will be set to move to
    the final character of the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, another **ptr2** pointer is set to point at **m**, the first character
    of the string, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54c260fc-5859-469d-8f3b-9eef62aece1f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to interchange the first and last characters of the string
    that are being pointed at by the **ptr1** and **ptr2 **pointers (see *Figure 4.7
    (a)*). After interchanging the characters pointed at by the **ptr1** and **ptr2** pointers,
    the string will appear as shown in *Figure 4.7 (b)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ceff3a28-90a8-44c9-b2a6-50f2873702a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7
  prefs: []
  type: TYPE_NORMAL
- en: After interchanging the first and last characters, we will interchange the second
    and the second to last characters of the string. To do so, the **ptr2** pointer will
    be moved forward and set to point at the next character in line, and the **ptr1** pointer will
    be moved backward and set to point at the second to last character.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see in the following *Figure** 4.8 (a)* that the **ptr2** and **ptr1** pointers
    are set to point at the **a** and **s** characters. Once this is done, another
    interchanging of the characters pointed at by **ptr2** and **ptr1** will take
    place. The string will appear as follows (*Figure 4.8 (b)*) after the interchanging
    of the **a** and **s** characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e6860bb-db4c-415b-9302-11dd8b731aaf.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8
  prefs: []
  type: TYPE_NORMAL
- en: 'The only task now left in reversing the string is to interchange the third
    and the third to last character. So, we will repeat the relocation process of
    the **ptr2** and **ptr1** pointers. Upon interchanging the **n** and **i** characters
    of the string, the original **str** string will have been reversed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1778b4ce-5a6c-4d42-9409-061c5b9343c5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9
  prefs: []
  type: TYPE_NORMAL
- en: After applying the preceding steps, if we print the **str** string, it will
    appear in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `reversestring.c` program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get no errors or warnings, that means the `reversestring.c` program
    has been compiled into an executable file, called `reversestring.exe`. Let''s
    run this executable file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully reversed a string using pointers. Now, let's move
    on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Finding the largest value in an array using pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, all the elements of the array will be scanned using pointers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Define a macro by the name `max` with a size of `100` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a `p` integer array of a `max` size, as demonstrated in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify the number of elements in the array as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the elements for the array as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Define two `mx` and `ptr` pointers to point at the first element of the array
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mx` pointer will always point at the maximum value of the array, whereas
    the `ptr` pointer will be used for comparing the remainder of the values of the
    array. If the value pointed to by the `mx` pointer is smaller than the value pointed
    at by the `ptr` pointer, the `mx` pointer is set to point at the value pointed
    at by `ptr`. The `ptr` pointer will then move to point at the next array element
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If the value pointed at by the `mx` pointer is larger than the value pointed
    to by the `ptr` pointer, the `mx` pointer is undisturbed and is left to keep pointing
    at the same value and the `ptr` pointer is moved further to point at the next
    array element for the following comparison:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This procedure is repeated until all the elements of the array (pointed to
    by the `ptr` pointer) are compared with the element pointed to by the `mx` pointer.
    Finally, the `mx` pointer will be left pointing at the maximum value in the array.
    To display the maximum value of the array, simply display the array element pointed
    to by the `mx` pointer as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `largestinarray.c` program for finding out the largest value in an array
    using pointers is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Define an array of a certain size and enter a few elements in it. These will
    be the values among which we want to find the largest value. After entering a few
    elements, the array might appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/894bb236-7a56-4ac9-a709-727dd595dc6b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use two pointers for finding the largest value in the array. Let''s
    name the two pointers **mx** and **ptr**, where the **mx** pointer will be used
    to point at the maximum value of the array, and the **ptr** pointer will be used
    for comparing the rest of the array elements with the value pointed at by the **mx** pointer.
    Initially, both the pointers are set to point at the first element of the array,
    **p[0]**, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eededf67-1b47-4ec1-a827-86ab8936a6d2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11
  prefs: []
  type: TYPE_NORMAL
- en: 'The **ptr** pointer is then moved to point at the next element of the array,
    **p[1]**. Then, the values pointed at by the **mx** and **ptr** pointers are compared.
    This process continues until all the elements of the array have been compared
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65301ebf-ad4f-4bce-849d-5c8188515914.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that we want the **mx** pointer to keep pointing at the larger value.
    Since 15 is greater than 3 (see *Figure 4.13*), the position of the **mx** pointer
    will be left undisturbed, and the **ptr** pointer will be moved to point at the
    next element, **p[2]**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fee9ac7-3775-4f60-a577-5ef01c4ccc8b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the values pointed at by the **mx** and **ptr** pointers, which are
    the values 15 and 70 respectively, will be compared. Now, the value pointed at
    by the **mx** pointer is smaller than the value pointed at by the **ptr** pointer.
    So, the **mx** pointer will be set to point at the same array element as **ptr** as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/687c6f9c-b6d8-48ef-8d9a-6eaa819c3e9c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14
  prefs: []
  type: TYPE_NORMAL
- en: 'The comparison of the array elements will continue. The idea is to keep the
    **mx** pointer pointing at the largest element in the array, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d818dea-224c-45ee-a302-38dc01f39538.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 4.15*, **70** is greater than **20**, so the **mx** pointer
    will remain at **p[2]**, and the **ptr** pointer will move to the next element,
    **p[4]**. Now, the **ptr** pointer is pointing at the last array element. So,
    the program will terminate, displaying the last value pointed at by the **mx** pointer,
    which also happens to be the largest value in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `largestinarray.c` program as the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get no errors or warnings, that means that the `largestinarray.c` program
    has been compiled into an executable file, `largestinarray.exe`. Let''s now run
    this executable file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully found the largest value in an array using pointers.
    Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Sorting a singly linked list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create a singly linked list comprising
    integer elements, and then we will learn how to sort this linked list in ascending
    order.
  prefs: []
  type: TYPE_NORMAL
- en: 'A singly linked list consists of several nodes that are connected through pointers.
    A node of a singly linked list might appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29c0aa98-0d41-496d-adfd-c0ca9c167791.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, a node of a singly linked list is a structure composed of two
    parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data: **This can be one or more variables (also called members) of integer,
    float, string, or any data type. To keep the program simple, we will take **data**
    as a single variable of the integer type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pointer**: This will point to the structure of the type node. Let''s call
    this pointer **next** in this program, though it can be under any name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use bubble sort for sorting the linked list. Bubble sort is a sequential
    sorting technique that sorts by comparing adjacent elements. It compares the first
    element with the second element, the second element with the third element, and
    so on. The elements are interchanged if they are not in the preferred order. For
    example, if you are sorting elements into ascending order and the first element
    is larger than the second element, their values will be interchanged. Similarly,
    if the second element is larger than the third element, their values will be interchanged
    too.
  prefs: []
  type: TYPE_NORMAL
- en: This way, you will find that, by the end of the first iteration, the largest
    value will *bubble* down towards the end of the list. After the second iteration,
    the second largest value will be *bubbled* down to the end of the list. In all,
    n-1 iterations will be required to sort the n elements using bubble sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand the steps in creating and sorting a singly linked list.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Define a node comprising two members—`data` and `next`. The data member is
    for storing integer values and the next member is a pointer to link the nodes
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify the number of elements in the linked list. The value entered will be
    assigned to the `n` variable as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute a `for` loop for `n` number of times. Within the `for` loop, a node
    is created by the name `newNode`. When asked, enter an integer value to be assigned
    to the data member of `newNode` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Two pointers, `startList` and `temp1`, are set to point at the first node.
    The `startList` pointer will keep pointing at the first node of the linked list.
    The `temp1` pointer will be used to link the nodes as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To connect the newly created nodes, the following two tasks are performed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next member of `temp1` is set to point at the newly created node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `temp1` pointer is shifted to point at the newly created node as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `for` loop gets over, we will have a singly linked list with its first
    node pointed at by `startList`, and the next pointer of the last node pointing
    at NULL. This linked list is ready to undergo the sorting procedure. Set a `for`
    loop to execute from `0` until `n-2` that is equal to n-1 iterations as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `for` loop, to compare values, use two pointers, `temp1` and `temp2`.
    Initially, `temp1` and `temp2` will be set to point at the first two nodes of
    the linked list, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the nodes pointed at by `temp1` and `temp2` in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After comparing the first two nodes, the `temp1` and `temp2` pointers will
    be set to point at the second and third nodes, and so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The linked list has to be arranged in ascending order, so the data member of
    `temp1` must be smaller than the data member of `temp2`. In case the data member
    of `temp1` is larger than the data member of `temp2`, the interchanging of the
    values of the data members will be done with the help of a temporary variable, `k`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After n-1 performing iterations of comparing and interchanging consecutive
    values, if the first value in the pair is larger than the second, all the nodes
    in the linked list will be arranged in ascending order. To traverse the linked
    list and to display the values in ascending order, a temporary `t` pointer is
    set to point at the node pointed at by `startList`, that is, at the first node
    of the linked list, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'A `while` loop is executed until the `t` pointer reaches `NULL`. Recall that
    the next pointer of the last node is set to NULL, so the `while` loop will execute
    until all the nodes of the linked list are traversed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `while` loop, the following two tasks will be performed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The data member of the node pointed to by the `t` pointer is displayed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `t` pointer is moved further to point at its next node:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sortlinkedlist.c` program for creating a singly linked list, followed
    by sorting it in ascending order, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This program is performed in two parts—the first part is the creation of a singly
    linked list, and the second part is the sorting of the linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the first part.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a singly linked list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by creating a new node by the name of **newNode**. When prompted,
    we will enter the value for its data member and then set the next **newNode** pointer
    to **NULL** ( as shown in *Figure 4.17*). This next pointer will be used for connecting
    with other nodes (as we will see shortly):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a78052d-7c8b-420f-89bd-e343ff6634af.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17
  prefs: []
  type: TYPE_NORMAL
- en: 'After the first node is created, we will make the following two pointers point
    at it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**startList**: To traverse the singly linked list, we will need a pointer that
    points at the first node of the list. So, we will define a pointer called **startList** and
    set it to point at the first node of the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**temp1**: In order to connect with the next node, we will need one more pointer.
    We will call this pointer **temp1**, and set it to point at the **newNode** (see
    *Figure 4.18*):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/79419819-e2e7-4be7-a8af-b55050370191.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.18
  prefs: []
  type: TYPE_NORMAL
- en: We will now create another node for the linked list and call that **newNode** as
    well. The pointer can point to only one structure at a time. So, the moment we
    create a new node, the **newNode** pointer that was pointing at the first node
    will now point at the recently created node. We will be prompted to enter a value
    for the data member of the new node, and its next pointer will be set to **NULL**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see in the following diagram that the two pointers, **startList** and
    **temp1**, are pointing at the first node and the **newNode** pointer is pointing
    at the newly created node. As stated earlier, **startList** will be used for traversing
    the linked list and **temp1** will be used for connecting with the newly created
    node as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bdd0494c-d8ba-414a-968d-933f5970834a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.19
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect the first node with **newNode**, the next pointer of **temp1** will
    be set to point at **newNode** (see *Figure 4.20 (a)*). After connecting with
    **newNode**, the **temp**`1` pointer will be moved further and set to point at
    **newNode** (see *Figure 4.20 (b)*) so that it can be used again for connecting
    with any new nodes that may be added to the linked list in future:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1a8d265-9019-4157-a2c4-5f33dc5eb079.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.20
  prefs: []
  type: TYPE_NORMAL
- en: 'Steps three and four will be repeated for the rest of the nodes of the linked
    list. Finally, the singly linked list will be ready and will look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50816494-7dcc-42b4-ab85-58d6a357caac.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.21
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created the singly linked list, the next step is to sort the
    linked list in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting the singly linked list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the bubble sort algorithm for sorting the linked list. In the bubble
    sort technique, the first value is compared with the second value, the second
    is compared with the third value, and so on. If we want to sort our list in ascending
    order, then we will need to keep the smaller values toward the top when comparing
    the values.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, while comparing the first and second values, if the first value is
    larger than the second value, then their places will be interchanged. If the first
    value is smaller than the second value, then no interchanging will happen, and
    the second and third values will be picked up for comparison.
  prefs: []
  type: TYPE_NORMAL
- en: There will be n-1 iterations of such comparisons, meaning if there are five
    values, then there will be four iterations of such comparisons; and after every
    iteration, the last value will be left out—that is, it will not be compared as
    it reaches its destination. The destination here means the location where the
    value must be kept when arranged in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: The first iteration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To sort the linked list, we will employ the services of two pointers—**temp1**
    and **temp2**. The **temp1** pointer is set to point at the first node, and **temp2**
    is set to point at the next node as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49b5a9f5-01e6-4ab5-a0cf-57fb514b5fb9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.22
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be sorting the linked list in ascending order, so we will keep the
    smaller values toward the beginning of the list. The data members of **temp1**
    and **temp2** will be compared. Because `temp1->data` is greater than `temp2->data`,
    that is, the data member of **temp1** is larger than the data member of **temp2**,
    their places will be interchanged (see the following diagram). After interchanging
    the data members of the nodes pointed at by **temp1** and **temp2**, the linked
    list will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3cff457d-883c-4c46-84f1-c1d1d23f9449.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.23
  prefs: []
  type: TYPE_NORMAL
- en: After this, the two pointers will shift further, that is, the **temp1** pointer
    will be set to point at **temp2**, and the **temp2** pointer will be set to point
    at its next node. We can see in *Figure 4.24 (a)* that the **temp1** and **temp2** pointers
    are pointing at the nodes with the values 3 and 7, respectively. We can also see
    that `temp1->data` is less than `temp2->data`, that is, 3 < 7\. Since the data
    member of **temp1** is already smaller than the data member of **temp2**, no interchanging
    of values will take place and the two pointers will simply move one step further
    (see *Figure 4.24 (b)*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, because 7 > 4, their places will be interchanged. The values of data members
    pointed at by **temp1** and **temp2** will interchange as follows (*Figure 4.24
    (c)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69a89064-f366-4c09-9772-cab43be27292.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.24
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, the **temp1** and **temp2** pointer will be shifted one step further,
    that is, **temp1** will point at **temp2**, and **temp2** will move onto its next
    node. We can see in the following *Figure 4.25 (a)* that **temp1** and **temp2**
    are pointing at the nodes with the values 7 and 2, respectively. Again, the data
    members of **temp1** and **temp2** will be compared. Because `temp1->data` is
    greater than `temp2->data`, their places will be interchanged. *Figure 4.25 (b)*
    shows the linked list after interchanging values of the data members:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a562a203-d4dc-4180-b967-ee74ee062719.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.25
  prefs: []
  type: TYPE_NORMAL
- en: This was the first iteration, and you can notice that after this iteration,
    the largest value, 7, has been set to our desired location—at the end of the linked
    list. This also means that in the second iteration, we will not have to compare
    the last node. Similarly, after the second iteration, the second highest value
    will reach or is set to its actual location. The second highest value in the linked
    list is 4, so after the second iteration, the four node will just reach the seven node.
    How? Let's look at the second iteration of bubble sort.
  prefs: []
  type: TYPE_NORMAL
- en: The second iteration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will begin the comparison by comparing first two nodes, so the **temp1**
    and **temp2** pointers will be set to point at the first and second nodes of the
    linked list, respectively (see *Figure 4.26 (a)*). The data members of **temp1**
    and **temp2** will be compared. As is clear, `temp1->data` is less than `temp2->data`
    (that is, 1 < 7), so their places will not be interchanged. Thereafter, the **temp1**
    and **temp2** pointers will shift one step further. We can see in *Figure 4.26
    (b)* that the **temp1** and **temp2** pointers are set to point at nodes of the
    values 3 and 4, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ff89217-6f3f-49af-acd3-90db85b3ac72.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.26
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, the data members of the **temp1** and **temp2** pointers will be
    compared. Because `temp1->data` is less than `temp2->data`, that is, 3 < 4 , their
    places will again not be interchanged and the **temp1** and **temp2** pointers
    will, again, shift one step further. That is, the **temp1** pointer will be set
    to point at **temp2**, and **temp2** will be set to point at its next node. You
    can see in *Figure 4.27 (a)* that the **temp1** and **temp2** pointers are set
    to point at nodes with the values 4 and 2, respectively. Because 4 > 2, their
    places will be interchanged. After interchanging the place of these values, the
    linked list will appear as follows in *Figure 4.27 (b)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8a88cfd-1f57-4b31-9669-616cc3bf8175.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.27
  prefs: []
  type: TYPE_NORMAL
- en: This is the end of the second iteration, and we can see that the second largest
    value, four, is set to our desired location as per ascending order. So, with every
    iteration, one value is being set at the required location. Accordingly, the next
    iteration will require one comparison less.
  prefs: []
  type: TYPE_NORMAL
- en: The third and fourth iterations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the third iteration, we will only need to do the following comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: Compare the first and second nodes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compare the second and third nodes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the third iteration, the third largest value, that is, three, will be
    set at our desired location, that is, just before node four.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the fourth, and final, iteration, only the first and second nodes will be
    compared. The linked list will be sorted in ascending order as follows after the
    fourth iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b85ae8be-01bc-46d5-b8e6-0ec16f1bd232.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.28
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `sortlinkedlist.c` program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get no errors or warnings, that means that the `sortlinkedlist.c` program
    has been compiled into an executable file, `sortlinkedlist.exe`. Let''s run this
    executable file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully created and sorted a singly linked list. Now, let's
    move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Finding the transpose of a matrix using pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best part of this recipe is that we will not only display the transpose
    of the matrix using pointers, but we will also create the matrix itself using
    pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transpose of a matrix is a new matrix that has rows equal to the number
    of columns of the original matrix and columns equal to the number of rows. The
    following diagram shows you a matrix of order **2 x 3** and its transpose, of
    order **3 x 2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/841d4994-ab2c-4675-b605-c4b0a36f54f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.29
  prefs: []
  type: TYPE_NORMAL
- en: Basically, we can say that, upon converting the rows into columns and columns
    into rows of a matrix, you get its transpose.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Define a matrix of 10 rows and 10 columns as follows (you can have a bigger
    matrix if you wish):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the size of the rows and columns as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Allocate memory locations equal to `r *c` quantity for keeping the matrix elements
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter elements of the matrix that will be assigned sequentially to each allocated
    memory as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to access this matrix via a pointer, set a `ptr` pointer to point
    at the first memory location of the allocated memory block, as shown in *Figure
    4.30*. The moment that the `ptr` pointer is set to point at the first memory location,
    it will automatically get the address of the first memory location, so `1000`
    will be assigned to the `ptr` pointer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/95534adc-2f68-4dea-87e2-f55e992fccd0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.30
  prefs: []
  type: TYPE_NORMAL
- en: 'To access these memory locations and display their content, use the `*(ptr
    +i*c + j)` formula within the nested loop, as shown in this code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of the `r` row is assumed to be two, and that of column `c` is assumed
    to be three. With values of `i=0` and `j=0`, the formula will compute as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: It will display the content of the memory address, `1000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the value of `i=0` and `j=1`, the formula will compute as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We will first get `*(1000+1)`, because the `ptr` pointer is an integer pointer,
    and it will jump two bytes every time we add the value `1` to it at every memory
    location, from which we will get `*(1002)`, and it will display the content of
    the memory location `1002`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the value of `i=0` and `j=2`will lead to `*(1004)`; that is, the
    content of the memory location `1004` will be displayed. Using this formula, the
    value of `i=1` and `j=0` will lead to `*(1006)`; the value of `i=1` and `j=1`
    will lead to `*(1008)`; and the value of `i=1` and `j=2` will lead to `*(1010)`.
    So, when the aforementioned formula is applied within the nested loops, the original
    matrix will be displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee37f84f-dad1-41a6-bb97-3af49fe51c91.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.31
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the transpose of a matrix, apply the following formula within the
    nested loops:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, assuming the values of row (r=2) and column (c=3), the following content
    of memory locations will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **i** | **j** | **Memory address** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | `1000` |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | `1006` |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | `1002` |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | `1008` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 0 | `1004` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 1 | `1010` |'
  prefs: []
  type: TYPE_TB
- en: 'So, upon applying the preceding formula, the content of the following memory
    address will be displayed as the following in *Figure 4.32*. And the content of
    these memory addresses will comprise the transpose of the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c7eb621-d263-4da1-8297-2f06aedaf2b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.32
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how this formula is applied in a program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `transposemat.c` program for displaying the transpose of a matrix using
    pointers is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever an array is defined, the memory allocated to it internally is a sequential
    memory. Now let''s define a matrix of size 2 x 3, as shown in the following diagram.
    In that case, the matrix will be assigned six consecutive memory locations of
    two bytes each (see *Figure 4.33*). Why two bytes each? This is because an integer
    takes two bytes. This also means that if we define a matrix of the float type
    that takes four bytes, each allocated memory location would consist of four bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cb5f6a4-9c19-4b07-b683-5a059474dcd0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.33
  prefs: []
  type: TYPE_NORMAL
- en: In reality, the memory address is long and is in hex format; but for simplicity,
    we will take the memory addresses of integer type and take easy-to-remember numbers,
    such as **1000**, as memory addresses. After memory address **1000**, the next
    memory address is **1002** (because an integer takes two bytes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to display the original matrix elements in row-major form using a pointer,
    we will need to display the elements of memory locations, **1000**, **1002**,
    **1004**, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83a850f2-c3ec-450c-91b2-32e245017600.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.34
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, in order to display the transpose of the matrix using a pointer,
    we will need to display the elements of memory locations; **1000**, **1006**,
    **1002**, **1008**, **1004**, and **1010**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75905466-1375-4fdf-95c2-8857d2998b1d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.35
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `transposemat.c` program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get no errors or warnings, that means that the `transposemat.c` program
    has been compiled into an executable file, `transposemat.exe`. Let''s run this
    executable file with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully found the transpose of a matrix using pointers. Now,
    let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a structure using a pointer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will make a structure that stores the information of an
    order placed by a specific customer. A structure is a user-defined data type that
    can store several members of different data types within it. The structure will
    have members for storing the order number, email address, and password of the
    customer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The preceding structure is named `cart`, and comprises three members – `orderno` of
    the `int` type for storing the order number of the order placed by the customer,
    and `emailaddress` and `password` of the string type for storing the email address
    and password of the customer, respectively. Let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Define a `cart` structure by the name `mycart`. Also, define two pointers to
    structure of the `cart` structure, `ptrcart` and `ptrcust`, as shown in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the order number, email address, and password of the customer, and these
    values will be accepted using the `mycart` structure variable. As mentioned previously,
    the dot operator (`.`) will be used for accessing the structure members, `orderno`,
    `emailaddress`, and `password`, through a structure variable as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the pointer to the `ptrcart` structure to point at the `mycart` structure
    using the `ptrcart=&mycart` statement. Consequently, the pointer to the `ptrcart` structure
    will be able to access the members of the `mycart` structure by using the arrow
    (`->`) operator. By using `ptrcart->orderno`, `ptrcart->emailaddress`, and `ptrcart->password`,
    the values assigned to the `orderno`, `emailaddress`, and `password` structure
    members are accessed and displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also modify the email address and password of the customer by asking
    them to enter a new email address and password and accept the new details via
    the pointer to the `ptrcart` structure as follows. Because `ptrcart` is pointing
    to the `mycart` structure, the new email address and password will overwrite the
    existing values that were assigned to the structure members of `mycart`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define a pointer to the `*ptrcust` structure. Using the following `malloc`
    function, allocate memory for it. The `sizeof` function will find out the number
    of bytes consumed by each of the structure members and return the total number
    of bytes consumed by the structure as a whole:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the order number, email address, and password of the customer, and all
    the values will be assigned to the respective structure members using a pointer
    to a structure as follows. Obviously, the arrow operator (`->`) will be used for
    accessing the structure members through a pointer to a structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The values entered by the user are then displayed through the pointer to the `ptrcust` structure
    again as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `pointertostruct.c` program explains how to access a structure
    by using a pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you define a variable of the type structure, that variable can access
    members of the structure in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see a period (`.`) between the structure variable and the structure
    member. This period (`.`) is also known as a dot operator, or member access operator.
    The following example will make it clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can see that `mycart` is defined as a structure variable
    of the `cart` structure. Now, the `mycart` structure variable can access the `orderno`
    member by making the member access operator (`.`).
  prefs: []
  type: TYPE_NORMAL
- en: You can also define a pointer to a structure. The following statement defines
    `ptrcart` as a pointer to the `cart` structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'When the pointer to a structure points to a structure variable, it can access
    the structure members of the structure variable. In the following statement, the
    pointer to the `ptrcart` structure points at the address of the `mycart` structure
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `ptrcart` can access the structure members, but instead of the dot operator
    (`.`), the arrow operator (`->`) will be used. The following statement accesses
    the `orderno` member of the structure using the pointer to a structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t want a pointer to a structure to point at the structure variable,
    then memory needs to be allocated for a pointer to a structure to access structure
    members. The following statement defines a pointer to a structure by allocating
    memory for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code allocates memory equal to the size of a `cart` structure,
    typecasts that memory to be used by a pointer to a `cart` structure, and assigns
    that allocated memory to `ptrcust`. In other words, `ptrcust` is defined as a
    pointer to a structure, and it does not need to point to any structure variable,
    but can directly access the structure members.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use GCC to compile the `pointertostruct.c` program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get no errors or warnings, that means that the `pointertostruct.c` program
    has been compiled into an executable file, `pointertostruct.exe`. Let''s run this
    executable file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Voilà! We've successfully accessed a structure using a pointer.
  prefs: []
  type: TYPE_NORMAL
