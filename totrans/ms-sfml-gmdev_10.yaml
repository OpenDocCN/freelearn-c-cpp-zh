- en: Chapter 10. A Chapter You Shouldnt Skip - Final Optimizations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。你不应该跳过的章节 - 最终优化
- en: What's the most important aspect of any game? According to a very famous e-celebrity,
    it's being able to play it. Fancy graphics and advanced techniques definitely
    add a necessary touch of polish to a medium as visual and interactive as video
    games, but if that gets in the way of enjoying the most fundamental experience
    of smooth gameplay, the whole thing might as well just be a fancy screensaver.
    Optimizing code, even when the application runs fine on higher-end machines, is
    extremely important, since every iteration excludes potential machines that are
    older but could still be used to expand the fan base of a game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何游戏最重要的方面是什么？根据一位非常著名的网络名人，那便是能够玩它。华丽的图形和先进的技术无疑为像视频游戏这样视觉和交互式的媒介增添了必要的精致感，但如果这些都妨碍了享受最基本的无缝游戏体验，那么整个游戏可能就只是一个花哨的屏幕保护程序了。即使应用程序在高端机器上运行良好，优化代码也是极其重要的，因为每一次迭代都会排除掉一些可能较旧但仍然可以用来扩大游戏粉丝基础的机器。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The basics of profiling and reading code metrics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析和代码指标的基础
- en: Analyzing and repairing inefficiencies in our code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析和修复我们代码中的低效之处
- en: The basics of light culling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光线剔除的基础
- en: Let's not waste any more clock cycles and get to cleaning up some of those inefficiencies!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不要浪费更多的时钟周期，开始清理一些这些低效之处！
- en: Use of third-party software
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方软件
- en: As expected, we can't do all of this work with no additional tools. Profiling
    applications is a subject that requires a backend of established software, used
    to neatly organize and present us with the data of performance subtleties. *CodeXL*
    is an application we have already covered in [Chapter 9](ch09.html "Chapter 9. 
    The Speed of Dark - Lighting and Shadows") , *The Speed of Dark - Lighting and
    Shadows* and although we used it to view runtime OpenGL states, it also has quite
    a suite of options used to profile both CPU and GPU code. It can be found and
    downloaded here: [http://gpuopen.com/compute-product/codexl/](http://gpuopen.com/compute-product/codexl/).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们无法在没有额外工具的情况下完成所有这些工作。性能分析应用程序是一个需要成熟软件后端支持的课题，用于整洁地组织和展示给我们性能细节的数据。"CodeXL"是我们已经在[第9章](ch09.html
    "第9章. 黑暗的速度 - 灯光与阴影")中介绍过的应用程序，*《黑暗的速度 - 灯光与阴影*》，虽然我们用它来查看运行时的OpenGL状态，但它也提供了一系列用于分析CPU和GPU代码的选项。您可以在以下链接找到并下载它：[http://gpuopen.com/compute-product/codexl/](http://gpuopen.com/compute-product/codexl/)。
- en: Of course, if we don't have AMD hardware, only a very limited set of tools for
    profiling are available. Although we can get by with the limited CPU profiling
    options, GPU profiling on an Nvidia card, for example, would require a different
    tool. There are some choices out there, but one notable option is *Nvidia Nsight*: [http://www.nvidia.com/object/nsight.html](http://www.nvidia.com/object/nsight.html).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们没有AMD硬件，可用的性能分析工具集非常有限。虽然我们可以通过有限的CPU性能分析选项来应对，但例如在Nvidia显卡上进行GPU性能分析就需要不同的工具。市面上有一些选择，但一个值得注意的选项是*Nvidia
    Nsight*：[http://www.nvidia.com/object/nsight.html](http://www.nvidia.com/object/nsight.html)。
- en: It's worth mentioning, however, that the newest versions of Nsight don't support
    some of the legacy functions SFML invokes, so the functionalities are, once again,
    rather limited.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得一提的是，Nsight的最新版本不支持SFML调用的某些旧版功能，因此功能再次受到限制。
- en: The devil's in the details
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 细节决定成败
- en: 'They say that a master craftsman knows not only how, but also when to use their
    tools. Many programmers often enough arrive at the false conclusion that they
    must constantly write beautiful, efficient, and overall perfect code that will
    never fail. In practice, this couldn''t be farther from the truth. Many find this
    out the hard way. As *Donald Knuth* said:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常说，一位大师工匠不仅知道如何使用工具，还知道何时使用工具。许多程序员常常得出一个错误的结论，认为他们必须不断编写美丽、高效且总体上完美的代码，这样的代码永远不会失败。在实践中，这离事实相差甚远。许多人都是通过艰难的方式才意识到这一点。正如*唐纳德·克努特*所说：
- en: '*"Programmers waste enormous amounts of time thinking about, or worrying about,
    the speed of noncritical parts of their programs, and these attempts at efficiency
    actually have a strong negative impact when debugging and maintenance are considered.
    We should forget about small efficiencies, say about 97% of the time: premature
    optimization is the root of all evil."*'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"程序员在思考或担心程序非关键部分的运行速度上浪费了大量的时间，而这些关于效率的尝试实际上在调试和维护时会产生强烈的负面影响。我们应该忘记关于小效率的事情，比如说97%的时间：过早优化是万恶之源。"*'
- en: This doesn't mean that one shouldn't take performance into consideration. Things
    such as designing a class with later features in mind, or even picking the right
    algorithm for the job both fall under that remaining 3%. Rather, it simply means
    that, unless the application is noticeably slow, tackling performance issues in
    code should be one of the final tasks at all times.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着不应该考虑性能。例如，设计具有后续功能的类，或者为任务选择正确的算法，这些都属于剩余的3%。简单来说，除非应用程序明显运行缓慢，否则在代码中解决性能问题始终应该是最后的任务之一。
- en: Another common mistake programmers often make is relying on intuition when it
    comes to evaluating performance. It's easy to forget that a program has tons of
    underlying complexity and moving parts, which is why it's incredibly hard to always
    know exactly how a specific chunk of code is going to behave unless properly tested.
    That's the key here always profile! Is the game running slow? Break out the profiler
    and take it for a spin. Feeling like enemy path-finding code is really weighing
    down on performance? Don't feel, just profile! The same thing can be said about
    the state of your code after optimizations have been made. Don't just replace
    a ton of code and assume it runs faster. Take a base measurement, make the appropriate
    changes, and profile the final result to make sure the new code runs faster. Starting
    to see the picture? Good. With that out of the way, let's jump straight into the
    basics of profiling!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员常犯的另一个错误是在评估性能时依赖直觉。很容易忘记程序具有大量的底层复杂性和动态部分，这也是为什么除非经过适当测试，否则很难确切知道特定代码块将如何表现。关键在于始终进行性能分析！游戏运行缓慢吗？拿出分析器来试一试。感觉敌人的路径查找代码真的拖累了性能吗？不要只是感觉，要分析！优化后的代码状态也是如此。不要只是替换大量代码并假设它会运行得更快。先进行基准测量，做出适当的更改，然后分析最终结果以确保新代码运行得更快。开始看到这幅图了吗？很好。现在，让我们直接进入性能分析的基本知识！
- en: Profiling basics
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析基础知识
- en: There's a variety of different ways an application can be profiled. Anything
    from branching and individual instructions, to usage of caches and patterns of
    data access can be tracked in a project. Since our game isn't exactly overflowing
    with complexity, however, we really only need to worry about time-based profiling.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以以多种不同的方式进行性能分析。从分支和单个指令，到缓存的使用和数据访问模式，都可以在项目中跟踪。然而，由于我们的游戏并不特别复杂，我们实际上只需要关注基于时间的性能分析。
- en: 'There are three basic ways a profiler can gather information about an application:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器可以以三种基本方式收集有关应用程序的信息：
- en: '**Sampling**: This is a periodic application stack capture that yields relatively
    inaccurate results, yet has very little overhead.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采样**: 这是一种周期性的应用程序堆栈捕获，结果相对不准确，但开销非常小。'
- en: '**Event collection**: This involves tapping into the compilation process and
    configuring it in such a way that allows certain information to be sent to the
    profiling DLLs. A higher amount of overhead with a higher precision.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件收集**: 这涉及到利用编译过程，并对其进行配置，以便将某些信息发送到性能分析DLL。具有更高的开销和更高的精度。'
- en: '**Instrumentation**: This involves direct code injection into the application
    during run time that allows for the most precise results and has the highest level
    of overhead.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪器设备**: 这涉及到在运行时直接将代码注入到应用程序中，从而允许获得最精确的结果，但同时也具有最高的开销。'
- en: Any of these techniques can be utilized, depending on what software is being
    used and the data it needs to collect. Because we don't really need incredibly
    precise results to locate the hotspots of our code, it's best to go with a sampling
    approach.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可以根据所使用的软件和需要收集的数据来利用这些技术中的任何一种。由于我们实际上并不需要极其精确的结果来定位代码的热点，因此最好采用采样方法。
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As we have already established, profiling is not a free task. In some instances,
    it can slow down an application to a crawl, which, depending on the task, can
    be absolutely normal.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经建立的，分析并不是一项免费的任务。在某些情况下，它可能会使应用程序的速度慢到几乎无法运行，这取决于任务，可能是完全正常的。
- en: Time-based sampling
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于时间的采样
- en: Using the time-based sampling technique will create a rough estimate of all
    of the application's function/method calls, initializations/destructions, virtually
    anything that can be created or invoked, and assign a sample value to them. This
    even includes underlying libraries, such as STL, SFML, OpenGL, and so on. If your
    code uses it, it will be on the list.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于时间的采样技术将对应用程序的所有函数/方法调用、初始化/销毁、几乎可以创建或调用的任何内容进行粗略估计，并为它们分配样本值。这甚至包括底层库，如STL、SFML、OpenGL等。如果你的代码使用了它们，它们将会出现在列表中。
- en: 'This sample value represents how much time is spent executing a certain line
    of code. There are two types of time samples:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个样本值表示执行某一行代码所花费的时间。有两种类型的时间样本：
- en: '**Inclusive**: This involves all of the time spent inside a specific line/chunk
    of code, including all of the time it took to execute other functions that may
    have been called.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含**：这涉及到在特定行/代码块内花费的所有时间，包括执行可能被调用的其他函数所需的时间。'
- en: '**Exclusive**: This involves only the amount of time that a specific line/chunk
    of code took to execute on its own.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排除**：这仅涉及特定行/代码块执行本身所花费的时间。'
- en: We are not necessarily going to be dealing with exclusive sample counts, but
    it's important to understand these terms nonetheless.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能不会处理排他性样本计数，但理解这些术语仍然很重要。
- en: Lastly, it's important to understand that samples are relative. If a program
    is running slowly, fewer samples will be captured across the board. This particular
    benchmark shouldn't be interpreted based on quantity, but rather in comparison
    to the rest of the code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重要的是要理解样本是相对的。如果一个程序运行缓慢，那么整个程序捕获的样本将更少。这个特定的基准不应该根据数量来解释，而应该与代码的其他部分进行比较。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sampling should always be done with all of the relevant project's optimizations
    enabled, because it strips away unnecessary code that's used for debugging, which
    would interfere with the results. In the case of Visual Studio, the release mode
    should be used when sampling.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 采样应该始终在所有相关的项目优化都启用的情况下进行，因为它会移除用于调试的冗余代码，这可能会干扰结果。在Visual Studio的情况下，采样时应使用发布模式。
- en: Sampling our application
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采样我们的应用程序
- en: Now that we have the fundamentals covered, let's actually fire up a profile
    and get started! The first important aspect of this process is actually spending
    enough time sampling the state of the desired application. In our case, sampling
    should be done in the `Game` state, and for at least 20 seconds, to capture enough
    information. It isn't going to help us understand the time complexities of the
    entity component system, for example, if the majority of the application sampling
    time is spent inside the menu state.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了基础知识，让我们实际启动一个配置文件并开始吧！这个过程的第一重要方面实际上是花足够的时间采样所需应用程序的状态。在我们的案例中，采样应该在`游戏`状态下进行，并且至少持续20秒，以捕获足够的信息。如果大部分应用程序采样时间都花在菜单状态下，那么这并不能帮助我们理解实体组件系统的时间复杂度，例如。
- en: 'Secondly, we should probably test our application in a stressful state, just
    to make sure it holds up well under nonideal conditions. For our purposes, we
    will simply add a bunch more entities, particle emitters, and lights to the scene
    until a **stress test** that looks like the following is constructed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们应该在压力状态下测试我们的应用程序，以确保它在非理想条件下表现良好。为了我们的目的，我们将简单地添加更多的实体、粒子发射器和灯光到场景中，直到构建出类似以下内容的**压力测试**：
- en: '![Sampling our application](img/image_10_001.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![采样我们的应用程序](img/image_10_001.jpg)'
- en: It isn't pretty, but then again, neither are performance issues.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能看起来并不美观，但同样，性能问题也不美观。
- en: Once the application has been sampled enough and is terminated, most profilers
    will show a *profile overview* of all the processes that have been running during
    the sampling process. It's important to select only our game by clicking on it,
    because that's what we're interested in.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序采样足够并且终止，大多数分析器都会显示采样过程中运行的所有进程的**概览**。重要的是只通过点击它来选择我们的游戏，因为我们对此感兴趣。
- en: 'After navigating to the **Function** tab, we should be left with something
    similar to this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到**函数**选项卡后，我们应该得到类似以下的内容：
- en: '![Sampling our application](img/image_10_002.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![采样我们的应用程序](img/image_10_002.jpg)'
- en: By clicking on the **Timer** tab and sorting entries in a descending order,
    we can view the functions that have the highest amount of samples, thus taking
    the most time to run. This is where you will find the trade-off between using
    a general purpose library such as *SFML* and sacrificing some performance. While
    it's true that writing case-specific code would probably be more optimal in terms
    of performance, it's still a worthy price to pay when considering how versatile
    SFML is for small to medium-sized projects.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**计时器**选项卡并按降序排序条目，我们可以查看采样量最多的函数，从而运行时间最长。这就是你将找到使用通用库如 *SFML* 并牺牲一些性能的地方。虽然编写特定情况的代码在性能方面可能更优，但考虑到
    SFML 在小型到中型项目中的多功能性，这仍然是一个值得付出的代价。
- en: While it's obvious our own SFML rendering code could probably use some work
    and utilize vertex arrays when rendering sprites and tiles to reduce this bottleneck,
    we're not going to concern ourselves with SFML-specific optimizations this time.
    Instead, let's analyze the highlighted entries on the list first. As the `glm::`
    namespace seems to suggest, the OpenGL math library we're using for various calculations
    is the culprit. Upon closer inspection, it seems that all three of these hotspots
    have to do with matrix operations; the most expensive of which is the `glm::operator*`.
    By right-clicking on the entry, we can view it in a call graph.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然很明显我们的 SFML 渲染代码可能需要一些改进，并在渲染精灵和瓦片时使用顶点数组来减少这个瓶颈，但我们这次不会关注 SFML 特定的优化。相反，让我们首先分析列表上突出显示的条目。正如
    `glm::` 命名空间所暗示的，我们用于各种计算的 OpenGL 数学库是罪魁祸首。通过右键单击条目，我们可以在调用图中查看它。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A **call graph** is a tool that helps locate all points in our code that use
    a specific function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**调用图**是一种帮助我们定位代码中使用特定函数的所有点的工具。'
- en: 'By simply analyzing the information onscreen, we''re now able to see what code
    uses the GLM matrices in such a way that causes performance problems:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地分析屏幕上的信息，我们现在能够看到哪些代码以这种方式使用 GLM 矩阵，从而引起性能问题：
- en: '![Sampling our application](img/image_10_003.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![采样我们的应用程序](img/image_10_003.jpg)'
- en: 'As the **Parents** section indicates, the majority of time samples regarding
    this particular bottleneck are located inside the `GL_Transform::GetModelMatrix()`
    method. Double-clicking on the function allows us to also view the code and specific
    hotspots of each individual line:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如**父级**部分所示，关于这个特定瓶颈的大多数时间采样都位于 `GL_Transform::GetModelMatrix()` 方法内部。双击该函数可以让我们查看代码和每行特定的热点：
- en: '![Sampling our application](img/image_10_004.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![采样我们的应用程序](img/image_10_004.jpg)'
- en: This should all start to add up by now. The two most sampled lines in relation
    to matrices were `glm::tmat4x4<float,0>::tmat4x4<float,0>(float const&)`, which
    is the matrix constructor, and `glm::rotate`, which we're calling three times.
    Every time we want to obtain a model matrix from this class (which is once for
    each shadow caster every frame), a bunch of new matrices are constructed and filled
    out using quite expensive GLM function calls, not to mention being multiplied
    later as well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，所有这些都应该开始累积起来。与矩阵相关的两个最常被采样的是 `glm::tmat4x4<float,0>::tmat4x4<float,0>(float
    const&)`，这是矩阵构造函数，以及 `glm::rotate`，我们调用了三次。每次我们想要从这个类中获取一个模型矩阵（每帧每个阴影投射器都会调用一次），都会构造并填充许多新的矩阵，使用相当昂贵的
    GLM 函数调用，更不用说之后的乘法运算了。
- en: Finding GPU bottlenecks
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找 GPU 瓶颈
- en: 'Finding GPU bottlenecks is fairly similar to what we did with the CPU. It also
    utilizes time sampling and will generate similar looking reports that list OpenGL
    code based on how long it took to execute, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找 GPU 瓶颈与我们在 CPU 上所做的是相当相似的。它也利用时间采样，并将生成类似的外观报告，列出基于执行时间的 OpenGL 代码，如下所示：
- en: '![Finding GPU bottlenecks](img/image_10_005.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![寻找 GPU 瓶颈](img/image_10_005.jpg)'
- en: 'We''re not going to be covering GPU optimizations heavily here, but the idea
    is exactly the same: finding bottlenecks, re-implementing code in a more efficient
    manner, and testing again.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会深入讨论 GPU 优化，但思路是相同的：找到瓶颈，以更有效的方式重新实现代码，并再次测试。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some GPU profiling tools, such as Nvidia Nsight, don't support legacy OpenGL
    API calls made by SFML.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 GPU 分析工具，如 Nvidia Nsight，不支持 SFML 制作的旧版 OpenGL API 调用。
- en: Improving CPU code performance
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高CPU代码性能
- en: After establishing a baseline reading, we can begin making changes to our code.
    Some of these changes involve simply understanding the libraries we're using and
    being more cautious about the way they're deployed, while others revolve around
    making better design choices, applying faster and more appropriate algorithms,
    designing data structures better, and using the newest features of the C++ standard.
    Let's begin by taking a look at some easy changes that can be made to our code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立基线读取后，我们可以开始对我们的代码进行更改。其中一些更改涉及简单地理解我们使用的库，并更加谨慎地部署它们，而其他更改则围绕做出更好的设计选择，应用更快、更合适的算法，设计更好的数据结构，以及使用C++标准的最新功能。让我们先看看我们可以对代码进行的一些简单更改。
- en: Optimizing the three most obvious bottlenecks
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化三个最明显的瓶颈
- en: Judging by the profiler's results, there is quite a bit of room for improvement
    of the code we've written so far. In this section, we're going to be addressing
    three of the most inefficient implementations and how they can be fixed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 根据分析器的结果，我们之前编写的代码有很多改进的空间。在本节中，我们将解决三个最不高效的实现及其修复方法。
- en: GL_Transform optimizations
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GL_Transform优化
- en: 'The very first example we used to illustrate how time sampling works is a perfect
    candidate for improvement. There really is nothing subtle about it. First, the
    recalculation of all matrices involved in obtaining a model matrix every time
    one is requested is incredibly inefficient. To add insult to injury, all *7* of
    those matrices has to be created all over again. That''s a lot of clock cycles
    wasted for no reason. Let''s see how that can be quickly improved:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来说明时间采样如何工作的第一个例子是改进的完美候选。它真的没有太多微妙之处。首先，每次请求模型矩阵时都要重新计算所有涉及的矩阵是非常低效的。更糟糕的是，所有*7*个矩阵都必须重新创建。这浪费了大量的时钟周期，却没有理由。让我们看看如何快速改进这一点：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Firstly, notice the change of the return parameter of `GetModelMatrix` to a
    *const* *reference*. This ensures that we're not returning a newly constructed
    matrix each time. Additionally, we have added a Boolean flag that will help us
    keep track of whether the position, scale, or rotation of the object has changed
    and whether the model matrix needs to be updated to reflect that. Lastly, we're
    storing all 7 matrices inside the transform object now, so that they are created
    only once. This is important, because we don't want to recalculate three rotational
    matrices along with its combined matrix, for example, just because the position
    of the object was changed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意`GetModelMatrix`的返回参数从*const* *引用*改变。这确保了我们每次都不是返回一个新构造的矩阵。此外，我们增加了一个布尔标志，帮助我们跟踪对象的位置、缩放或旋转是否已更改，以及模型矩阵是否需要更新以反映这一点。最后，我们现在将所有7个矩阵存储在变换对象中，这样它们就只创建一次。这很重要，因为我们不希望仅仅因为对象的位置发生了变化，就重新计算三个旋转矩阵及其组合矩阵。
- en: 'Next, let''s actually implement these changes, starting with the setters of
    this class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实际实施这些更改，从本类的setter开始：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The general idea here is to first check whether the argument provided to the
    setter method isn't already the current value of whatever parameter it's supposed
    to override. If it isn't, the position is changed and the position matrix is updated,
    along with the `m_needsUpdate` flag being set to `true`. This will ensure that
    the model matrix is updated later on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一般思路是首先检查提供给setter方法的参数是否已经是它应该覆盖的任何参数的当前值。如果不是，则改变位置，并更新位置矩阵，同时将`m_needsUpdate`标志设置为`true`。这将确保稍后模型矩阵得到更新。
- en: 'Rotation follows the exact same principle:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转遵循完全相同的原理：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Before the assignment is committed to, however, we must check each individual
    member of the vector class, because each one of them has their own matrix. The
    point, as it's becoming clearer and clearer now, is to only calculate what we
    absolutely have to.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在提交赋值之前，我们必须检查向量类的每个成员，因为它们各自都有自己的矩阵。现在越来越清楚的是，我们的目标是只计算我们绝对必须计算的内容。
- en: 'Scale, once again, follows this idea exactly:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放，再次，完全遵循这个想法：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `GetModelMatrix` method should now be implemented this way:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetModelMatrix`方法现在应该这样实现：'
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, the update flag is checked to determine whether the matrix needs to be
    updated. If it does, all three relevant matrices are multiplied and the flag is
    reset back to `false`. We then return the const reference to the `m_modelMatrix`
    data member, ensuring one isn't created just to be thrown away later.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查更新标志以确定矩阵是否需要更新。如果需要，则将所有三个相关矩阵相乘，并将标志重置回 `false`。然后我们返回 `m_modelMatrix`
    数据成员的 const 引用，确保不会创建一个只是为了后来丢弃的对象。
- en: 'Let''s follow our own advice and profile the application again to make sure
    our changes worked:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遵循自己的建议，再次分析应用程序以确保我们的更改有效：
- en: '![GL_Transform optimizations](img/image_10_006.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![GL_Transform 优化](img/image_10_006.jpg)'
- en: All three of the previously highlighted lines to do with `glm::` have now completely
    disappeared from the top of the list! The highlighted exception in this illustration
    was taken during the sampling of `GL_Transform::GetModelMatrix()` that **did not**
    return by const reference, just to show that our approach does indeed work. When
    the method does return a const reference, even the highlighted function completely
    vanishes. This perfectly illustrates how avoiding useless copies of data can vastly
    improve overall performance.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与 `glm::` 相关的之前突出显示的行现在都已经完全从列表顶部消失！在这个说明中突出显示的异常是在采样 `GL_Transform::GetModelMatrix()`
    时拍摄的，**没有**通过 const 引用返回，只是为了表明我们的方法确实有效。当方法返回 const 引用时，甚至突出显示的函数也会完全消失。这完美地说明了避免无用的数据副本如何极大地提高整体性能。
- en: Particle system optimizations
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子系统优化
- en: 'Another massive bottleneck that''s right at the top of the sample list is the
    `ParticleSystem::Draw` method. In fact, it''s the highest sampled piece of code
    that we have actually written. It''s understandable that rendering so many particles
    would be taxing, but in this case, the unoptimized version of this method knocks
    the frame rate of our game down to 10 FPS:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 样本列表顶部的另一个巨大瓶颈正是 `ParticleSystem::Draw` 方法。实际上，这是我们编写的代码中采样最高的部分。理解渲染这么多粒子会很有压力是合理的，但在这个例子中，未优化的这个方法将我们游戏的帧率降低到
    10 FPS：
- en: '![Particle system optimizations](img/image_10_007.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![粒子系统优化](img/image_10_007.jpg)'
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Fraps** is a free piece of screen capture software that can record video,
    take screenshots, and most importantly for our purposes, show the frame rate!
    Although it''s Windows specific, there are other tools like it for Linux and OSX.
    The frame rate counter can also be easily implemented by simply counting the frames
    in our code and displaying the result using SFML.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fraps** 是一款免费的屏幕捕获软件，可以录制视频、截图，最重要的是对我们来说，可以显示帧率！虽然它是针对 Windows 的，但还有其他类似工具适用于
    Linux 和 OSX。帧率计数器也可以通过简单地计算我们的代码中的帧数并使用 SFML 显示结果来轻松实现。'
- en: 'That is absolutely unforgivable, so let''s break out the profiler and dissect
    the `Draw` method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是不可原谅的，所以让我们打开性能分析器并剖析一下 `Draw` 方法：
- en: '![Particle system optimizations](img/image_10_008.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![粒子系统优化](img/image_10_008.jpg)'
- en: 'Judging by the sample count, the main inefficiency lies somewhere inside the
    material value shader pass, where each particle is rendered for the normal and
    specular passes. There is something slightly weird going on, though, and that''s
    the fact that the normal pass samples seem to be really low, but when the time
    comes to render for the specular pass, they suddenly jump much higher. This may
    look especially weird considering all we''re doing is setting a `vec3` uniform
    and drawing to a render texture. This is where further digging through the function
    stack and understanding of how SFML needs to handle things behind the scenes comes
    in:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 根据样本计数，主要的不效率似乎在材质值着色器传递内部，其中每个粒子都为正常和漫反射传递进行渲染。然而，还有一些奇怪的事情发生，那就是正常传递的样本似乎非常低，但当渲染漫反射传递时，它们突然大幅增加。考虑到我们只是设置一个
    `vec3` 通用变量并将绘制到渲染纹理中，这看起来可能特别奇怪。这就是为什么需要进一步深入函数堆栈并理解 SFML 在幕后如何处理事情的原因：
- en: '![Particle system optimizations](img/image_10_009.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![粒子系统优化](img/image_10_009.jpg)'
- en: Because of context switching and the way render textures work behind the scenes,
    it's extremely inefficient to render two different types of material maps as we
    did. Switching textures too many times during runtime can cause serious performance
    bottlenecks, which is why sprite and tile sheets are used by games, rather than
    individual images.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上下文切换和渲染纹理在幕后工作的方式，以我们这样做的方式渲染两种不同类型的材质图是非常低效的。在运行时切换纹理次数过多会导致严重的性能瓶颈，这也是为什么游戏使用精灵和瓦片图而不是单个图像的原因。
- en: 'Let''s try and split up these two different types into two separate loops,
    making sure only one texture is being rendered two at a time:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将这些两种不同类型分开，确保一次只渲染一个纹理：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that the material uniform is also moved outside of the loop to prevent
    unnecessary copies from being constructed and sent to the shader every time. By
    just running the application now, a very obvious jump in performance will quickly
    become apparent. Let''s see how much faster it got by simply splitting up the
    little bit of code we had into two pieces:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，材质统一变量也被移出循环，以防止每次都构建不必要的副本并将其发送到着色器。现在只需运行应用程序，性能的明显提升将很快变得明显。让我们看看通过将我们已有的少量代码分成两部分，性能提高了多少：
- en: '![Particle system optimizations](img/image_10_010.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![粒子系统优化](img/image_10_010.jpg)'
- en: 'We just jumped from 10 FPS to 65 FPS by simply separating the normal and specular
    material passes! That''s more like it! You will notice that this sudden jump in
    performance will increase the sample count drastically:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是通过将正常和漫反射材质通道分开，就从10 FPS跳到了65 FPS！这才像样！你会注意到这种性能的突然提升将样本计数急剧增加：
- en: '![Particle system optimizations](img/image_10_011.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![粒子系统优化](img/image_10_011.jpg)'
- en: This is because the game is running much faster now and doesn't indicate that
    the function is taking more time to execute. Remember, the samples are relative.
    Upon looking through the list, the two previously highlighted bits of code are
    found much lower now, with sample counts in the 20s. That's only slightly lower
    than before, but because the samples are relative and they all jumped up to about
    6 times higher, it indicates a huge performance gain.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为游戏现在运行得更快，并没有表明函数执行时间更长。记住，样本是相对的。在查看列表后，之前高亮的两个代码片段现在出现在列表的下方，样本计数在20s左右。这比之前略低，但由于样本是相对的，并且它们都上升了大约6倍，这表明性能有了巨大的提升。
- en: Light culling
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 光线剔除
- en: The last main inefficiency we have to fix has to do with the lighting system
    implemented in [Chapter 8](ch08.html "Chapter 8.  Let There Be Light - An Introduction
    to Advanced Lighting") , *Let There Be Light! - An Introduction to Advanced Lighting*,
    and [Chapter 9](ch09.html "Chapter 9.  The Speed of Dark - Lighting and Shadows")
    , *The Speed of Dark - Lighting and Shadows*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须解决的最后一个主要低效问题与第8章中实现的照明系统有关，即*让光亮起来！——高级照明简介*和第9章*黑暗的速度——照明与阴影*。
- en: Dealing with multiple lights in a scene by using multipass shading/rendering
    is a great technique, but it can quickly become inefficient when those passes
    start to add up. The first obvious step to fixing that issue is not rendering
    lights that will not affect anything in the final image. The technique of reducing
    the number of objects being rendered by eliminating those that cannot be directly
    observed by the scene's view frustum, also known as **culling**, is going to help
    out with that.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用多通道着色/渲染处理场景中的多个光源是一种很好的技术，但当这些通道开始累积时，它可能会迅速变得低效。解决这个问题的第一步显然是不渲染那些不会影响最终图像的光源。通过消除那些不能直接被场景的视锥体观察到的对象来减少渲染对象数量的技术，也称为**剔除**，将有助于解决这个问题。
- en: Since we're only dealing with omni-directional point lights at this moment,
    culling lights can be achieved by simply checking for circle on rectangle collisions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们目前只处理全向点光源，可以通过简单地检查圆形与矩形的碰撞来实现光线剔除。
- en: 'Let''s set up some helper functions to help us do that:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一些辅助函数来帮助我们完成这项工作：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The function works by first creating an outer radius around the view's rectangle,
    so that we can default to a circle-on-circle collision checking for the majority
    of cases where the light is nowhere near the view frustum. The distance between
    the view's centre and circle's centre is obtained and checked for exceeding the
    sum of the view's outer bounding circle's radius summed with the circle's radius.
    This is the easiest way to check whether the light circle is anywhere close to
    the view's rectangle.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先在视图矩形周围创建一个外半径，这样我们就可以默认为大多数情况下光线远离视图视锥体的圆形-圆形碰撞检查。获取视图中心和圆形中心的距离，并检查是否超过视图外边界圆的半径加上圆形半径的总和。这是检查光线圆形是否接近视图矩形的最简单方法。
- en: If the light is closer to the view, another circle radius for the view's rectangle
    is constructed. This time, the circle is inside the view and only has the radius
    of the smaller dimension of the rectangle's size. If the distance between the
    light and the view's center is lower than the sum of the inner radius and the
    circle's radius, we know for sure that we have a collision. That's another common
    case that we can scratch off the list, before defaulting to a more complicated
    algorithm.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果光线更靠近视图，就会为视图的矩形构造另一个圆的半径。这次，圆在视图内部，并且只有矩形尺寸较小的一维的半径。如果光线和视图中心之间的距离低于内半径和圆的半径之和，我们就可以确定发生了碰撞。这又是一个我们可以从列表中划掉的常见情况，在默认使用更复杂的算法之前。
- en: Finally, if we know the light may be intersecting with one of the corners, its
    direction towards the view is normalized and used to obtain the closest point
    that is then checked for intersecting a constructed `sf::FloatRect` that represents
    our view.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们知道光线可能与某个角落相交，我们就将光线的方向向视图归一化，并使用它来获取最近点，然后检查该点是否与表示我们视图的构造的`sf::FloatRect`相交。
- en: 'Actual changes to the `RenderScene()` method of the light manager class simply
    involve storing a new list of lights that are definitely affecting something on
    screen, so that they can be passed to the shader:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对光线管理类中的`RenderScene()`方法的实际更改仅涉及存储一个新列表，其中包含肯定影响屏幕上某些内容的光线，以便可以将它们传递给着色器：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that we're not taking into account the light's falloff or how it's attenuated
    in the shader to determine whether it should be culled or not.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有考虑光线的衰减或它在着色器中的衰减情况，以确定是否应该剪裁它。
- en: After all the unnecessary lights have been culled, only the very busy areas
    will experience some performance loss. At this point, it's the area of level design
    that should show concern and improve the architecture of the map.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在剪裁掉所有不必要的灯光后，只有非常繁忙的区域才会经历一些性能损失。此时，应该引起关注的是关卡设计区域，并改进地图的架构。
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations on making it all the way to the end! It has been quite a journey,
    and we can certainly say that a lot of things have been covered here that should
    inspire confidence in advanced game development in anyone. Even so, as always,
    there's still a ton of features, optimizations, techniques, and topics that we
    either just briefly touched upon, or haven't even acknowledged yet. Use that as
    inspiration to seek greatness, because, as we have already established, master
    craftsmen know not only how, but when to use their tools. While we have covered
    the basics, there are still many more tools to add to your tool belt. Use them,
    abuse them, break them and replace them. Do whatever it takes, but always remember
    to take something out of it and make it better next time.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你一路走到最后！这是一段相当漫长的旅程，我们确实可以说，这里涵盖了应该能够激发任何人对高级游戏开发信心的大量内容。即便如此，一如既往地，还有很多特性、优化、技术和主题我们只是简要提及，或者甚至还没有承认。利用这一点作为灵感去追求卓越，因为，正如我们已经确立的，大师级工匠不仅知道如何使用工具，也知道何时使用工具。虽然我们已经涵盖了基础知识，但还有很多更多的工具可以添加到你的工具箱中。使用它们，滥用它们，打破它们并替换它们。做任何需要的事情，但始终记得从中吸取经验，并在下次做得更好。
- en: With that, may your next project exhibit that extra level of polish, and run
    just a little bit faster! Thanks for reading!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，愿你的下一个项目展现出额外的打磨水平，并且运行得更快！感谢阅读！
