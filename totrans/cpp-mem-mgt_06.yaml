- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Writing Smart Pointers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写智能指针
- en: 'In [*Chapter 5*](B21071_05.xhtml#_idTextAnchor079), we examined the standard
    smart pointers at our disposal, with emphasis on the most important ones: `unique_ptr<T>`
    and `shared_ptr<T>`. These types are precious and important tools in every contemporary
    C++ programmer’s toolbox, and using them when appropriate leads to programs that
    are smaller, faster, and simpler than they would be with most handwritten alternatives.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B21071_05.xhtml#_idTextAnchor079)中，我们考察了可用的标准智能指针，重点介绍了其中最重要的：`unique_ptr<T>`和`shared_ptr<T>`。这些类型是当代C++程序员工具箱中的宝贵且重要的工具，在适当的时候使用它们可以使程序比大多数手写替代方案更小、更快、更简单。
- en: 'This book aims to discuss how to manage memory in a C++ program. For that reason,
    in this chapter, we will write simple versions of both `unique_ptr<T>` and `shared_ptr<T>`
    to show ways in which one could write naïve-yet-workable versions of these types
    if needed. We *strongly* recommend that you use the standard versions in practice,
    not those in this book (at least in production code): standard versions have been
    thoroughly tested, optimized, and used by a multitude of programmers to good effect.
    The reason we write “homemade” flavors here is simply to develop an intuition
    as to how one could write such as type: there still exist companies using pre-C++11
    compilers, sometimes for reasonable reasons, and there might be reasons in some
    settings to write a smart pointer inspired by the standard ones yet slightly different.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书旨在讨论如何在C++程序中管理内存。因此，在本章中，我们将编写`unique_ptr<T>`和`shared_ptr<T>`的简单版本，以展示如果需要，可以如何编写这些类型的简单但可行的版本。我们**强烈**建议您在实际应用中使用标准版本，而不是本书中的版本（至少在生产代码中是这样）：标准版本已经经过彻底测试、优化，并被众多程序员有效地使用。我们在这里编写“自制”版本的原因仅仅是为了培养对如何编写此类类型的直觉：仍然存在一些公司使用C++11之前的编译器，有时出于合理的原因，在某些环境中可能存在编写受标准智能指针启发的但略有不同的智能指针的理由。
- en: We will then examine some niches not covered by the standard smart pointers,
    either because they are deemed simple enough that users can roll out their own,
    they are deemed specialized enough that they should be covered through third-party
    libraries, or there is no clear path to standardizing them yet.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考察一些标准智能指针未涵盖的领域，这可能是因为它们被认为足够简单，用户可以自行实现，或者它们被认为足够专业，应该通过第三方库来实现，或者还没有明确的标准化路径。
- en: 'To summarize, in this chapter, we will do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中，我们将做以下几件事：
- en: Take a brief look at ownership semantics, those of the standard smart pointers
    as well as others that we could – and sometimes will – implement ourselves.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要了解所有权语义，包括标准智能指针以及我们可能——有时会——自己实现的那些。
- en: Implement our own naïve-yet-usable version of `std::unique_ptr` in order to
    grasp some of the techniques this might entail.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了掌握可能涉及的一些技术，我们将实现我们自己的简单但可用的`std::unique_ptr`版本。
- en: Implement our own naïve-yet-usable version of `std::shared_ptr`. Note that by
    “usable” here we mean usable in simple contexts, as a full implementation of something
    such as `std::shared_ptr` is significantly more complex than what a book such
    as this one can reasonably cover.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现我们自己的简单但可用的`std::shared_ptr`版本。请注意，在这里所说的“可用”是指在简单环境中可用，因为`std::shared_ptr`的完整实现比本书可以合理涵盖的要复杂得多。
- en: Implement a non-standard smart pointer with single ownership and duplication
    semantics, showing different techniques to achieve this objective.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个具有单一所有权和复制语义的非标准智能指针，展示实现此目标的不同技术。
- en: Implement two distinct non-owning “smart” pointers that are very lightweight
    types yet help write better and safer code.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现两个不同的非所有权的“智能”指针，这些指针类型非常轻量级，但有助于编写更好、更安全的代码。
- en: After reading this chapter, we should have a better grasp of the techniques
    involved in writing types that syntactically behave as pointers but provide (or
    simply clarify) ownership semantics. The techniques used should be in large part
    reusable to other types of problems, memory-management related or not.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，我们应该对涉及编写在语法上表现为指针但提供（或仅澄清）所有权的类型的技术有更好的掌握。所使用的技术应该大部分可以用于其他类型的问题，无论是与内存管理相关还是不相关的问题。
- en: Does that sound like a plan? Let’s get to it then!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计划听起来怎么样？那么，让我们开始吧！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code files for this chapter in the book’s GitHub repository
    here: [https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter6](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter6).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个章节的GitHub仓库中找到这个章节的代码文件：[https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter6](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter6)。
- en: Ownership semantics
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有权语义
- en: 'Smart pointers are all about clarifying ownership over indirectly accessed
    resources. If we restrict ourselves to the standard facilities, smart or not-so-smart,
    what we have is the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针全在于明确间接访问资源的所有权。如果我们限制自己使用标准设施，无论是智能的还是非智能的，我们拥有的就是以下内容：
- en: '| **Type** | **Niche** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **领域** |'
- en: '| `unique_ptr<T>` | **Ownership semantics**: Single ownership.**Notable special
    member functions**: Non-copyable. The destructor is responsible for destroying
    the pointee. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `unique_ptr<T>` | **所有权语义**：单一所有权。**显著的特有成员函数**：不可复制。析构函数负责销毁指针所指向的对象。|'
- en: '| `shared_ptr<T>` | **Ownership semantics**: Shared ownership.**Notable special
    member functions**: Copying, assigning, and destroying update a shared use count.
    The destructor of the last co-owner is responsible for destroying both the pointee
    and the use count. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `shared_ptr<T>` | **所有权语义**：共享所有权。**显著的特有成员函数**：复制、赋值和销毁更新共享使用计数。最后一个共同所有者的析构函数负责销毁指针所指向的对象和使用计数。|'
- en: '| `T*` | **Ownership semantics**: No ownership is defined in the type system
    (ownership rules have to be inscribed in user code).**Notable special member functions**:
    Not applicable (this is a fundamental type). |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `T*` | **所有权语义**：在类型系统中未定义所有权（所有权规则必须写入用户代码）。**显著的特有成员函数**：不适用（这是一个基本类型）。|'
- en: Table 6.1 – Usage category per pointer type
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1 – 按指针类型划分的使用类别
- en: 'It’s a small zoo, all things considered. What are the other kinds of semantics
    we could envision in order to fill this table? Well, there could be the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，这是一个小型的动物园。为了填充这个表格，我们还能设想出哪些其他类型的语义呢？好吧，以下是一些可能的：
- en: An `observer_ptr<T>` type that behaves like `T*` but makes it more difficult
    to accidentally claim ownership with such operations as applying `delete` on the
    pointer (accidents happen indeed)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种 `observer_ptr<T>` 类型，它表现得像 `T*` 但使得通过如对指针应用 `delete` 这样的操作意外声明所有权变得更加困难（确实会发生意外）
- en: A `non_null_ptr<T>` type that behaves like `T*` but for which a `null` pointer
    never occurs, simplifying client code
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种 `non_null_ptr<T>` 类型，它表现得像 `T*` 但不会出现 `null` 指针，从而简化了客户端代码
- en: A `remote_ptr<T>` type that behaves like a proxy to remote pointees
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种 `remote_ptr<T>` 类型，它像一个代理来处理远程指针
- en: A `dup_ptr<T>` type that implements single ownership of the pointee, as `unique_ptr<T>`
    does, but is copyable and duplicates the pointee when `dup_ptr<T>` is copied,
    and so on
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种 `dup_ptr<T>` 类型，它实现了与 `unique_ptr<T>` 相同的单一所有权，但它可复制，并且在复制 `dup_ptr<T>` 时复制指针所指向的对象，依此类推
- en: We will not implement all of these (the `remote_ptr<T>` case in particular,
    interesting as it is, falls outside the scope of this book, and there are numerous
    other exotic semantics we could entertain that you are welcome to implement based
    on the ideas you will find in this chapter), but we will write a few. The important
    aspect in each case is to define clearly what the intended semantics are, ensure
    they are not already covered by an existing type, and make sure we implement them
    appropriately.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会实现所有这些（特别是 `remote_ptr<T>` 的情况，尽管它很有趣，但超出了本书的范围，还有许多其他异类语义我们可以考虑，你可以根据本章中找到的想法来实现它们），但我们将会编写一些。每个案例的重要方面是明确定义预期的语义，确保它们没有被现有类型覆盖，并确保我们适当地实现它们。
- en: 'Let’s start with a simple implementation of what is perhaps the best-known
    standard smart pointer: `unique_ptr`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单实现开始，这可能是最著名的标准智能指针：`unique_ptr`。
- en: Writing your own (naïve) unique_ptr
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你自己的（天真）unique_ptr
- en: 'We will first try a simple, homegrown version of `std::unique_ptr<T>`. As mentioned
    at the beginning of this chapter, our goal is to develop an intuition for the
    kind of code required to write such a type and not to encourage you to try to
    replace the standard facilities: they exist, they work, they are tested, use them.
    Oh, and they use many cool tricks we cannot explore in this book as we want to
    keep the book’s size under control!'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先尝试一个简单、自制的版本 of `std::unique_ptr<T>`。正如本章开头所提到的，我们的目标是培养编写此类类型所需代码的直觉，而不是鼓励你尝试替换标准设施：它们存在，它们工作，它们经过测试，使用它们。哦，而且它们使用了许多我们无法在本书中探索的酷技巧，因为我们想控制本书的大小！
- en: Type signature
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型签名
- en: As mentioned in [*Chapter 5*](B21071_05.xhtml#_idTextAnchor079), `unique_ptr<T>`
    does not really exist as the type is, in fact, `unique_ptr<T,D>`, where `D` defaults
    to `default_deleter<T>`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第5章*](B21071_05.xhtml#_idTextAnchor079)中所述，`unique_ptr<T>`实际上并不存在，因为该类型实际上是`unique_ptr<T,D>`，其中`D`默认为`default_deleter<T>`。
- en: We will cover both forms (scalar and array) of `unique_ptr`. The reason for
    these two specializations is that for `T[]`, we will want `unique_ptr` to expose
    `operator[]` but we will not want to expose this for a scalar `T` type.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖`unique_ptr`的两种形式（标量和数组）。这两个特殊化的原因在于，对于`T[]`，我们希望`unique_ptr`暴露`operator[]`，但我们不希望为标量`T`类型暴露这一点。
- en: 'Let’s start with the basic deleter types we will offer. Note that users can
    supply other deleter types if needed as long as they use the same signature for
    `operator()`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们将提供的基删除器类型开始。请注意，如果需要，用户可以提供其他删除器类型，只要它们使用相同的`operator()`签名：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What we have so far are three deleter types that are callable in the same way
    and that are all class types (the reason for this will become evident soon but
    know that there’s sometimes value in uniformity). The odd one is `deleter_pointer_wrapper<T>`,
    which wraps a copyable state (a function pointer) but otherwise behaves like the
    other two: when called on `T*`, it applies some (user-supplied) function to that
    pointer.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有三种可调用的删除器类型，它们都是类类型（原因很快就会变得明显，但要知道有时统一性是有价值的）。其中一个是`deleter_pointer_wrapper<T>`，它封装了一个可复制的状态（一个函数指针），但除此之外，它就像其他两个一样：当在`T*`上调用时，它将对那个指针应用一些（用户提供的）函数。
- en: The next step will be to choose the form of `unique_ptr<T,D>`. We will expect
    most deleters to be stateless and use `deleter_pointer_wrapper<T>`. To choose
    between these two options, we will need to detect whether `D` is a function pointer
    or not, which we will achieve using our own `is_deleter_function_candidate<T>`
    trait.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是选择`unique_ptr<T,D>`的形式。我们预计大多数删除器将是无状态的，并使用`deleter_pointer_wrapper<T>`。为了在这两种选项之间进行选择，我们需要检测`D`是否是一个函数指针，我们将通过我们自己的`is_deleter_function_candidate<T>`特性来实现这一点。
- en: 'The part of our implementation that detects deleter function candidates is
    the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现中检测删除器函数候选者的部分如下：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This bit is probably self-explanatory, but the idea is that most types are not
    candidates to be deleter functions, but functions of the `void(*)(T*)` type are.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分可能很直观，但想法是，大多数类型都不是删除器函数的候选者，但`void(*)(T*)`类型的函数是。
- en: 'We then get to the general `unique_ptr<T>` type, used for scalars. We will
    use our deleter function detection trait to conditionally choose between `D` types
    and `deleter_pointer_wrapper<T>` as the base class for our type, and cast this
    to a pointer to that base in order to release the resource in our destructor:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们到达了一般的`unique_ptr<T>`类型，用于标量。我们将使用我们的删除器函数检测特性来有条件地选择`D`类型，并将`deleter_pointer_wrapper<T>`作为我们类型的基类，并将它转换为指向该基类的指针，以便在我们的析构函数中释放资源：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The same approach, essentially, is taken for the `T[]` specialization of our
    type:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们类型的`T[]`特殊化，基本上采取相同的方法：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that a default `unique_ptr` will behave conceptually like a `null` pointer,
    something that should be unsurprising to most. Now that we have the basic idea
    in place, let’s explore the semantics specific to `unique_ptr`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到默认的`unique_ptr`在概念上会像`null`指针一样，这对大多数人来说应该不会感到意外。现在我们已经有了基本的概念，让我们探索`unique_ptr`特有的语义。
- en: Special member functions
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊成员函数
- en: 'The code for the special member functions will be the same for both the scalar
    and the array forms of `unique_ptr`. We have already looked at the destructor
    and the default constructor in the previous section, so let’s look at the other
    four, in pairs:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊成员函数的代码对于`unique_ptr`的标量和数组形式将是相同的。我们已经在上一节中看到了析构函数和默认构造函数，所以让我们看看其他四个，成对来看：
- en: We want the type to be non-copyable, as it represents sole ownership of the
    pointee (if it was copyable, would ownership of the pointee belong to the original
    or the copy?)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望类型是不可复制的，因为它代表了指针的唯一所有权（如果它是可复制的，指针的所有权属于原始的还是复制的？）
- en: We want move operations to implement the transfer of ownership
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望移动操作实现所有权的转移
- en: 'The code for both the general case and its array specialization will be as
    follows (note that the code uses `std::exchange()` and `std::swap()`, both found
    in the `<``utility>` header):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通用情况和其数组特殊化的代码如下（请注意，代码使用了`std::exchange()`和`std::swap()`，这两个都包含在`<utility>`头文件中）：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Most of this should be self-evident by this point. You might notice the use
    of `std::exchange()`, which has the effect of copying `other.p` to `this->p` and
    then copying `nullptr` to `other.p`, implementing the transfer of ownership as
    expected. Note that move operations for our type are trivial and never throw,
    both of which are highly desirable properties.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，大部分内容应该是显而易见的。你可能会注意到 `std::exchange()` 的使用，它将 `other.p` 复制到 `this->p`，然后将
    `nullptr` 复制到 `other.p`，实现了预期的所有权转移。请注意，我们类型的移动操作既简单又不会抛出异常，这两者都是非常理想化的属性。
- en: 'There are some operations that will be implemented in both the general case
    and the array case, namely, `operator bool` (`true` only if the object does not
    model a `null` pointer), `empty()` (`true` only if the object does model a `null`
    pointer), as well as `operator==()` and `operator!=()`. These are essentially
    trivial to implement. The other member function we will want to expose is `get()`
    in both its `const` and non-`const` versions in order to expose the underlying
    pointer for client code that needs to interact with lower-level functions such
    as system calls:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有些操作将在一般情况和数组情况下都实现，即 `operator bool`（只有当对象不表示 `null` 指针时才为 `true`），`empty()`（只有当对象表示
    `null` 指针时才为 `true`），以及 `operator==()` 和 `operator!=()`。这些实现基本上是微不足道的。我们还想公开的另一个成员函数是
    `get()`，包括其 `const` 和非 `const` 版本，以便于需要与底层函数（如系统调用）交互的客户端代码暴露底层指针：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As mentioned in the comments in the preceding code excerpt, one does not need
    to explicitly implement `operator!=()` since C++20 as long as `operator==()` offers
    the expected signature. The compiler will synthesize `operator!=()` from `operator==()`,
    quite simply.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码注释中所述，从 C++20 开始，只要 `operator==()` 提供了预期的签名，就不需要显式实现 `operator!=()`。编译器将简单地从
    `operator==()` 合成 `operator!=()`。
- en: Now, let’s take a look at how the `operator*()`, `operator->()`, and `operator[]()`
    pointer-like functions are implemented.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `operator*()`、`operator->()` 和 `operator[]()` 这些类似指针的函数是如何实现的。
- en: Pointer-like functions
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类似指针的函数
- en: 'The pointer-like functions are different for the scalar case and the array
    case. For pointer-to-scalar, we will want to implement `operator*()` and `operator->()`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 类似指针的函数在标量情况和数组情况中是不同的。对于指向标量的，我们希望实现 `operator*()` 和 `operator->()`：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `operator->()` member function is a strange beast: when used on an object,
    it will be reinvoked on the returned object (and again on that returned object,
    and so on) until something returns a raw pointer, at which point the compiler
    will know what to do. It’s a very powerful mechanism.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator->()` 成员函数是一个奇怪的生物：当用于对象时，它将在返回的对象上重新调用（并在返回的对象上再次调用，依此类推），直到返回一个原始指针，此时编译器将知道如何处理。这是一个非常强大的机制。'
- en: 'For pointer-to-array (the `unique_ptr<T[]>` specialization), we will want to
    implement `operator[]`, which will make more sense than either `operator*()` or
    `operator->()`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于指向数组的（即 `unique_ptr<T[]>` 特化），我们希望实现 `operator[]`，这将比 `operator*()` 或 `operator->()`
    更有意义：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You might notice the apparent duplication of these member functions as each
    one is exposed in both a `const` and non-`const` form, a “trend” started by the
    `get()` member function a bit earlier. This is a *syntactic* resemblance as they
    are *semantically* different: in particular, only the `const` form is available
    through a `const` `unique_ptr<T>` object.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到这些成员函数的明显重复，因为每个函数都以 `const` 和非 `const` 的形式暴露出来，这种“趋势”是由稍早前的 `get()`
    成员函数开始的。这是一种 *语法* 上的相似性，但它们在 *语义* 上是不同的：特别是，只有 `const` 形式可以通过 `const` `unique_ptr<T>`
    对象访问。
- en: 'If you have a C++23 compiler, you can make it so the compiler will synthesize
    the forms you use in practice given a properly written set of template member
    functions:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个 C++23 编译器，你可以让它根据正确编写的模板成员函数集合成你在实践中使用的形式：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This reduces the number of member functions we have to write by half. How does
    this work? Well, C++23 introduces the “deduced `this`” mechanism that allows one
    to explicitly mark the first argument of a member function with the `this` keyword.
    Doing so and combining it with a forwarding reference (the `U&&` type) lets the
    compiler deduce the `const`-ness (or lack thereof) of `this`, in effect, expressing
    both the `const` and non-`const` versions in a single function. Note the `decltype(auto)`
    return types that accompany these functions, which infer both the `return` statement.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们需要编写的成员函数数量减少了一半。这是怎么做到的？嗯，C++23 引入了“推导的 `this`”机制，允许显式地将成员函数的第一个参数标记为 `this`
    关键字。这样做并结合前向引用（`U&&` 类型）可以让编译器推导出 `this` 的 `const`-性（或缺乏 `const`-性），实际上是在一个函数中表达
    `const` 和非 `const` 两个版本。注意这些函数伴随的 `decltype(auto)` 返回类型，它们推断出 `return` 语句。
- en: And that’s it! We now have a simple, yet functional `unique_ptr<T>` implementation
    that works for most use cases.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在有一个简单但功能齐全的 `unique_ptr<T>` 实现，适用于大多数用例。
- en: Of course, as nice as it is, `unique_ptr<T>` is not a panacea and there are
    other needs to be covered in real programs. Let’s move on to a simplified implementation
    of `shared_ptr<T>` to see how we could implement shared ownership semantics.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`unique_ptr<T>` 虽然很好，但并不是万能的，在实际程序中还有其他需要解决的问题。让我们继续探讨 `shared_ptr<T>` 的简化实现，看看我们如何实现共享所有权的语义。
- en: 'A simple program that uses our homemade `unique_ptr<T>` with a default deleter
    would be as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们自制的 `unique_ptr<T>` 和默认删除器的一个简单程序如下：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Another that uses a custom deleter would be as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义删除器的一个程序如下：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Writing your own (naïve) shared_ptr
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自己的（原始）shared_ptr
- en: 'A `shared_ptr<T>` type is a difficult beast to implement and a harder beast
    yet to optimize. The invitation to use the standard version of existing smart
    pointers is stronger in this case than it was for `unique_ptr<T>`: this type is
    hard to get right, and the standard version benefits from years of experience
    and testing. Only use the naïve version in this section for experimentation (it
    works and does the job for simple cases, but writing an industrial-strength implementation
    is major-league work).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr<T>` 类型实现起来是一个难题，优化起来更是难上加难。在这种情况下，使用现有智能指针的标准版本的邀请比 `unique_ptr<T>`
    更加强烈：这种类型很难做到正确，而标准版本则受益于多年的经验和测试。在本节中，仅为了实验目的使用原始版本（它适用于简单情况，但编写一个工业级实现是职业级的工作）。'
- en: 'The main difficulty when writing a `shared_ptr` is that it’s a type with two
    responsibilities: it co-owns both the pointee and the usage counter, requiring
    some measure of care, especially with respect to exception safety. The single
    responsibility principle of classical object-oriented programming is a sound principle:
    a type with a single responsibility is exceedingly simpler to get right than a
    type with two or more responsibilities.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 `shared_ptr` 的主要困难在于它是一个具有两个职责的类型：它共同拥有被指点和使用计数器，需要一定的谨慎，尤其是在异常安全性方面。经典面向对象编程的单职责原则是一个正确的原则：具有单一职责的类型比具有两个或更多职责的类型更容易做到正确。
- en: 'To keep our proposition simple, we will eschew many details of the standard
    `shared_ptr` contract, limiting ourselves to managing a scalar `T`. Let’s take
    this type step by step:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的论点简单，我们将避免标准 `shared_ptr` 协议的许多细节，仅限于管理一个标量 `T`。让我们一步一步地来看这个类型：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As mentioned previously, `shared_ptr<T>` is responsible for `T*` and a pointer
    to a client counter, both of which need to be managed and shared between co-owners.
    Note that our shared counter is a pointer to an atomic integral since `shared_ptr<T>`
    is particularly relevant in multithreaded cases where one does not know which
    of the threads will be the last user of the object. For that reason, operations
    such as incrementing and decrementing the counter require synchronization to avoid
    incurring a *data race*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`shared_ptr<T>` 负责管理 `T*` 和指向客户端计数器的指针，这两者都需要被管理并在共同所有者之间共享。请注意，我们的共享计数器是一个指向原子整数的指针，因为
    `shared_ptr<T>` 在多线程情况下特别相关，在这些情况下，不知道哪个线程将是对象的最后一个用户。因此，像增加和减少计数器这样的操作需要同步，以避免发生
    *数据竞争*。
- en: Avoiding data races
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 避免数据竞争
- en: If a program meets a situation where a given object is (a) accessed concurrently
    by at least two threads, (b) at least one of these accesses is a write, and (c)
    there is no synchronization, then that program has what we call a **data race**
    and we essentially lose the capacity to reason about it from the source code.
    This is a really bad situation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个程序遇到一个给定对象（a）被至少两个线程并发访问，（b）至少有一个访问是写操作，并且（c）没有同步，那么这个程序就出现了我们所说的**数据竞争**，我们基本上失去了从源代码中推理它的能力。这是一个非常糟糕的情况。
- en: In our case, operations on the shared counter will most probably be done concurrently
    and, as such, they have to be synchronized. This explains our use of the low-level
    synchronization objects that are atomic integrals as counters.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，对共享计数器的操作很可能会并发进行，因此它们必须进行同步。这就解释了我们使用低级同步对象作为计数器的原子整数。
- en: 'Constructing a `shared_ptr<T>` object can be tricky:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个`shared_ptr<T>`对象可能很棘手：
- en: By default, we will define `shared_ptr<T>` to be empty, thus conceptually equivalent
    to a `null` pointer.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，我们将定义`shared_ptr<T>`为空，从概念上等同于一个`null`指针。
- en: The constructor of `shared_ptr<T>` that takes `T*` as an argument represents
    the act of *taking ownership* of the pointee. For that reason, if an exception
    is thrown when allocating the counter, that pointee is destroyed.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shared_ptr<T>`的构造函数接受`T*`作为参数，代表对所指向对象的**所有权获取**行为。因此，如果在分配计数器时抛出异常，那么这个指针将被销毁。'
- en: The copy constructor will represent *sharing ownership* of the pointee, making
    sure to consider the case where the source object models a `null` pointer.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制构造函数将代表对所指向对象的**共享所有权**，并确保考虑到源对象可能表示一个`null`指针的情况。
- en: The move constructor models the *transfer of ownership*. As is often the case
    for move operations, it’s very fast and it shows highly predictable behavior.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动构造函数模拟了**所有权转移**。正如移动操作通常那样，它非常快，并且表现出高度可预测的行为。
- en: 'As can be seen from the following code excerpt, with a type that has more than
    one responsibility, even construction is a delicate endeavor. In the constructor
    that takes `T*`, we might need to allocate the shared counter, which might throw,
    a situation we need to manage. In the copy constructor, we need to take into account
    that the argument might model an empty `shared_ptr<T>`, in which case the shared
    counter would be `null`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码片段所示，对于具有多个职责的类型，即使是构造也是一个微妙的过程。在接收`T*`参数的构造函数中，我们可能需要分配共享计数器，这可能会抛出异常，这种情况我们需要处理。在复制构造函数中，我们需要考虑到参数可能表示一个空的`shared_ptr<T>`，在这种情况下，共享计数器将是`null`：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `empty()`and `operator bool()` member functions have been included in that
    excerpt since these functions directly tie into the way the default constructor
    (the empty state of this type) is expressed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`empty()`和`operator bool()`成员函数已被包含在该片段中，因为这些函数直接与默认构造函数（此类型的空状态）的表达方式相关联。'
- en: 'The assignment operator is unsurprising: copy assignment models the act of
    releasing control of the currently held resource and sharing the resource of its
    argument, whereas move assignment models the act of releasing control of the currently
    held resource and transferring control of the resource held by the argument to
    the assigned-to object:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符并不令人意外：复制赋值模拟了释放当前持有的资源控制权并共享其参数的资源的行为，而移动赋值模拟了释放当前持有的资源控制权并将参数持有的资源控制权转移到被赋值对象的行为：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Destruction is probably the trickiest aspect of this type. We want to make sure
    that the last owner of the pointee destroys it, to avoid immortal objects. The
    key point is that `shared_ptr<T>` should only destroy the pointed-to `T` object
    if it was the last user of that object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 销毁可能是此类中最棘手的部分。我们想要确保最后一个所有者销毁它，以避免不朽对象。关键点是`shared_ptr<T>`只有在它是该对象的最后一个用户时才应该销毁指向的`T`对象。
- en: 'There are at least two “self-evident” naïve algorithms that do not work. One
    is *If* `ctr` *is not null, then if* `*ctr==1`*, delete* `p` *and delete* `ctr`.
    This algorithm allows the case where two threads enter the destructor concurrently
    with `*ctr==2`. In that case, it is possible that neither thread sees `*ctr==1`,
    and the pointees are never destroyed:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有两种“显而易见”的简单算法是无效的。一个是**如果**`ctr`**不为空，那么如果**`*ctr==1`**，则删除**`p`**和删除**`ctr`**。这个算法允许两个线程在`*ctr==2`时同时进入析构函数。在这种情况下，可能两个线程都没有看到`*ctr==1`，并且指针永远不会被销毁：
- en: '![Figure 6.1 – Race condition leading to an immortal object](img/B21071_06_01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 导致不朽对象的竞争条件](img/B21071_06_01.jpg)'
- en: Figure 6.1 – Race condition leading to an immortal object
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 导致对象永生的竞态条件
- en: 'The other is *If* `ctr` *is not null, then decrement* `*ctr`*. If* `*ctr==0`*,
    delete* `p` *and delete* `ctr`. This algorithm allows the case where two threads
    enter the destructor concurrently with `*ctr==2`, and then both concurrently decrement
    `*ctr` leading to the possibility of both seeing `*ctr==0`, resulting in a double
    deletion of the pointees:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个是 *如果* `ctr` *不为空，则递减* `*ctr`*。如果* `*ctr==0`*，删除 *p* 和删除 *ctr*。此算法允许两个线程在
    `*ctr==2` 时同时进入析构函数，然后两个线程同时递减 `*ctr`，导致两个线程都可能看到 `*ctr==0`，从而可能导致指针的重复删除：
- en: '![Figure 6.2 – Race condition leading to double deletion of the object](img/B21071_06_02.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 对象重复删除的竞态条件](img/B21071_06_02.jpg)'
- en: Figure 6.2 – Race condition leading to double deletion of the object
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 对象重复删除的竞态条件
- en: Both cases are bad, albeit for different reasons, so we need to do better. The
    difficult part of the process is ensuring that the executing thread can be made
    aware that it is the one that made it so `*ctr` became zero. The general solution
    to such a problem requires enclosing two steps (changing the value of a variable
    only if it had a known-beforehand value and being informed that this write did
    or did not happen) in a single operation, something that must be supported by
    at least one hardware operation on a multicore machine.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种情况都不好，尽管原因不同，所以我们需要做得更好。过程的难点在于确保执行线程可以知道它是使 `*ctr` 成为零的那个线程。解决此类问题的通用方法需要将两个步骤（仅在变量具有事先已知的值时更改其值，并被告知此写入是否发生）封装在单个操作中，这至少需要一个多核机器上的硬件操作支持。
- en: C++ offers abstractions over these essential hardware operations through atomics.
    One such atomic operation is named `compare_exchange_weak()`, which takes the
    `expected` value (what is believed to be in the variable) and the `desired` value
    (what one seeks to write to that variable, but only if it holds `expected`), and
    returns `true` only if the *write* actually happened. For convenience, `expected`
    is taken by reference and updated with the value actually held by the object at
    that time, since this function is usually called in a loop until a successful
    write of `desired` actually occurs, which involves re-reading `expected` every
    time to update the function’s view of the variable’s current state.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 通过原子操作提供了对这些基本硬件操作的抽象。其中一个原子操作被命名为 `compare_exchange_weak()`，它接受 `expected`
    值（被认为是变量中的值）和 `desired` 值（希望写入该变量的值，但只有当它保持 `expected` 时），并且只有在实际发生写入时才返回 `true`。为了方便，`expected`
    通过引用传递，并使用当时对象实际持有的值进行更新，因为此函数通常在循环中调用，直到成功写入 `desired` 实际发生，这涉及到每次重新读取 `expected`
    以更新函数对变量当前状态的看法。
- en: A dance with pictures
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与图片共舞
- en: This `expected` and `desired` dance can be seen as taking pictures. A thread
    wants to decrement `*ctr`, but `*ctr` holds a mutable state and is accessed concurrently,
    which means its value can change at any time. Thus, we take a picture (`expected`)
    in a local variable under our control. We base the value we want to write (`desired`)
    on that local picture that we know did not change. Then, we try to act based on
    that (potentially obsolete) knowledge and see whether our assumption (that `*ctr`
    holds `expected`) is held. This lets us know that we were the ones to write `desired`
    in `*ctr`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 `expected` 和 `desired` 的舞蹈可以看作是拍照。一个线程想要递减 `*ctr`，但 `*ctr` 保持可变状态且被并发访问，这意味着其值可以随时改变。因此，我们在我们控制的局部变量中拍下照片（`expected`）。我们基于我们想要写入的值（`desired`）基于我们知道的那个局部照片，我们知道它没有改变。然后，我们尝试根据这个（可能过时的）知识采取行动，看看我们的假设（`*ctr`
    保持 `expected`）是否成立。这让我们知道，是我们将 `desired` 写入 `*ctr` 的。
- en: 'With this knowledge, a possible implementation of the destructor would be the
    following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个知识，析构函数的一个可能的实现如下：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After the loop, we know that we wrote `desired` when `*ctr` held `expected`,
    thus if `desired` was `0` (implying `expected` was `1`), we know we were the last
    user of that pointee. Yes, it’s subtle. And this is only a toy version of `shared_ptr<T>`.
    We could optimize it in many ways, but that goes beyond the scope of this book.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环之后，我们知道我们在 `*ctr` 保持 `expected` 时写入了 `desired`，因此如果 `desired` 是 `0`（意味着 `expected`
    是 `1`），我们知道我们是最后一个使用那个指针的用户。是的，这很微妙。而且这只是一个 `shared_ptr<T>` 的玩具版本。我们可以以许多方式对其进行优化，但这超出了本书的范围。
- en: A simpler solution
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更简单的解决方案
- en: The solution shown here with `compare_exchange_weak()` is one of many options
    at our disposal. It was preferred for this book because it’s an interesting approach
    for a general solution to the concurrent update problem and opens up optimization
    opportunities if you are comfortable with memory order constraints (which we will
    not go into here). In this specific case, we could have replaced the loop with
    something like `if((*ctr)-- == 1)`, as if one decrements `*ctr` atomically and
    the value previously held was `1`, then we know for a fact that `*ctr` is now
    `0`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的 `compare_exchange_weak()` 解决方案是我们可用的许多选项之一。它被选为这本书的原因是，它为并发更新问题提供了一个有趣的通用解决方案，并且如果你对内存顺序约束感到舒适（我们在这里不会深入讨论），它还提供了优化机会。在这个特定的情况下，我们可以用类似
    `if((*ctr)-- == 1)` 的东西替换循环，就像原子地递减 `*ctr` 并且之前持有的值是 `1` 一样，那么我们可以确信 `*ctr` 现在是
    `0`。
- en: 'The other important member functions of our `shared_ptr<T>` implementation
    involve comparison (`operator==` and `operator!=`), the `get()` member functions
    that let one obtain the underlying, raw `T*` for code that needs it, and the indirection
    operators that are `operator*()` and `operator->()`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `shared_ptr<T>` 实现的另一个重要成员函数涉及比较（`operator==` 和 `operator!=`），允许获取底层原始 `T*`
    的 `get()` 成员函数，以及 `operator*()` 和 `operator->()` 这样的间接操作符：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you want to, feel free to apply the “deduced `this`” C++23 feature shown
    in the `unique_ptr` section earlier to simplify this code. Also remember that
    in C++20, `operator!=()` will be inferred from `operator==()` and does not need
    to be written explicitly in the source code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以自由地应用前面在 `unique_ptr` 部分展示的 “推导 `this`” C++23 功能来简化这段代码。还请记住，在 C++20
    中，`operator!=()` 将从 `operator==()` 推导出来，并且不需要在源代码中显式编写。
- en: 'A very simple example of client code for this smart pointer would be the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个智能指针的客户代码的一个非常简单的例子如下：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, `th0` and `th1` both sleep for a pseudorandom number of milliseconds,
    then display something and conclude execution, so we cannot know in advance which
    of `th0` and `th1` will conclude first; both threads are detached, which means
    there is no later point at which we will call `join()` on them, so we cannot suppose
    that `main()` is the last user of the shared resource.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`th0` 和 `th1` 都会暂停一个伪随机的毫秒数，然后显示一些内容并结束执行，因此我们无法预先知道 `th0` 和 `th1` 中哪一个会先结束；两个线程都是分离的，这意味着我们不会在它们上面调用
    `join()`，因此我们不能假设 `main()` 是最后一个使用共享资源的用户。
- en: The example is contrived to keep it simple, and it bears repeating that as `shared_ptr<T>`
    is significantly more costly to use than `unique_ptr<T>` would be, one will generally
    prefer the latter over the former when there is a clear last owner of the resource.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例子是为了保持简单而设计的，并且需要重复的是，由于 `shared_ptr<T>` 的使用成本显著高于 `unique_ptr<T>`，当资源有一个明确的最后一个所有者时，人们通常会优先选择后者。
- en: A few words on make_shared()
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 `make_shared()` 的一些话
- en: 'It is possible that when reading about C++ in general and `shared_ptr<T>` in
    particular, you might have read that, whenever possible, it is recommended practice
    to replace this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读关于 C++ 以及特别是 `shared_ptr<T>` 的内容时，你可能会读到，在可能的情况下，推荐的做法是替换以下内容：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Replace it with the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下内容替换它：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If that is the case, you might be wondering (a) why this is recommended practice,
    and (b) why we have not addressed it yet. The answer to (a) we can provide now,
    but the answer to (b) is that we will need to wait until we reach [*Chapter 7*](B21071_07.xhtml#_idTextAnchor116)
    to have the tools and knowledge required to implement such a facility.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样的话，你可能想知道（a）为什么这是推荐的做法，以及（b）为什么我们还没有解决这个问题。对于（a）的答案我们现在可以提供，但对于（b）的答案是我们需要等待直到我们达到
    [*第7章*](B21071_07.xhtml#_idTextAnchor116) 才有实现这种功能所需的工具和知识。
- en: To understand why we recommend preferring the `make_shared<T>()` factory function
    to a direct call to the `shared_ptr<T>` constructor, the key idea is that with
    the `shared_ptr<T>` constructor, the `T` object is allocated by client code, and
    given to `shared_ptr<T>` under construction, which takes ownership of that pointer
    and allocates a shared counter *separately*. We then end up with two allocations
    (the `T` object and the counter), probably on separate cache lines.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么我们推荐优先使用 `make_shared<T>()` 工厂函数而不是直接调用 `shared_ptr<T>` 构造函数，关键思想是，使用
    `shared_ptr<T>` 构造函数时，`T` 对象是由客户端代码分配的，并交给正在构建的 `shared_ptr<T>`，它接管这个指针并单独分配一个共享计数器。然后我们最终会有两个分配（`T`
    对象和计数器），可能位于不同的缓存行上。
- en: Now, if we go through `make_shared<T>()`, this factory function is responsible
    for allocating both the `T` object *and* the counter, perfectly forwarding the
    arguments received by the function to the `T` constructor. Since the same function
    performs both allocations, it can fuse them in a single allocation of a memory
    block that contains both the `T` object and the counter, *putting them both on
    the same cache line*. This can lead to enhanced performance characteristics if
    a single thread tends to read from both pointers (`T*` and the counter) in a short
    time span, but (as can sometimes be the case) can be hurtful if another thread
    observes frequent changes to the counter’s value. As is often the case in optimization-related
    situations, measure and make sure what works well in general is also good for
    your own, specific use cases.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们来看一下 `make_shared<T>()`，这个工厂函数负责分配 `T` 对象和计数器，并将函数接收到的参数完美转发给 `T` 构造函数。由于同一个函数执行了两次分配，它可以将它们融合在一个包含
    `T` 对象和计数器的内存块的单次分配中，*将它们都放在相同的缓存行上*。如果在短时间内单个线程倾向于从两个指针（`T*` 和计数器）中读取，这可能会提高性能特性，但（有时可能会发生）如果另一个线程观察到计数器值的频繁变化，可能会造成伤害。正如在优化相关情况下经常发生的那样，测量并确保在一般情况下效果良好的方法也适用于你自己的特定用例。
- en: Clearly, to achieve this optimization, we need to be able to create such a block
    (conceptually, a struct containing `T` and an atomic integral) and make sure that
    `shared_ptr<T>` can contain either representation (two separate pointers or a
    pointer to a block with two objects) while remaining usable and efficient. Controlled
    use of the tricks seen in [*Chapter 2*](B21071_02.xhtml#_idTextAnchor027) and
    [*Chapter 3*](B21071_03.xhtml#_idTextAnchor047) will be helpful when we get there.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，为了实现这种优化，我们需要能够创建这样的块（概念上，一个包含 `T` 和一个原子整数的结构体）并确保 `shared_ptr<T>` 可以包含这两种表示（两个单独的指针或指向包含两个对象的块的指针），同时保持可用性和效率。在到达那里时，控制使用在
    [*第 2 章*](B21071_02.xhtml#_idTextAnchor027) 和 [*第 3 章*](B21071_03.xhtml#_idTextAnchor047)
    中看到的技巧将是有帮助的。
- en: Writing a policy-based duplicating pointer
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写基于策略的复制指针
- en: Let’s leave aside the standard smart pointers for a moment. Suppose we seek
    to write a smart pointer type whose semantics fit neither the sole ownership mold
    of `std::unique_ptr<T>` nor the shared ownership mold of `std::shared_ptr<T>`.
    For the sake of this example, suppose more specifically that we want single ownership
    semantics but, unlike `std::unique_ptr<T>`, which is movable but non-copyable,
    we want duplication of the pointer to lead to duplication of the pointee. What
    can we do?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时抛开标准智能指针。假设我们想要编写一种智能指针类型，其语义既不符合 `std::unique_ptr<T>` 的单一所有者模式，也不符合 `std::shared_ptr<T>`
    的共享所有者模式。为了这个例子，更具体地说，我们想要单一所有者语义，但与 `std::unique_ptr<T>` 不同，它是可移动的但不可复制的，我们希望指针的复制导致指向的对象的复制。我们能做什么？
- en: Well, this is C++, so we can of course write our own. Let’s call this new smart
    pointer type of ours `dup_ptr<T>` (for “duplicating pointer”, or “pointer that
    duplicates the pointee”). Since we examined how one could implement sole ownership
    through our homemade `unique_ptr<T>` earlier in this chapter, this section will
    mostly focus on the question of duplicating the pointee.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这是 C++，所以我们当然可以自己编写。让我们称我们自己的这种新的智能指针类型为 `dup_ptr<T>`（表示“复制指针”，或“复制指向的对象的指针”）。由于我们在本章前面已经探讨了如何通过我们自制的
    `unique_ptr<T>` 实现单一所有者，本节将主要关注复制指向对象的问题。
- en: 'What do we mean by duplication? Well, there are two expected cases: copying
    an object of a non-polymorphic type and copying an object of a polymorphic type,
    with polymorphic meaning “with at least one `virtual` member function” for the
    sake of this example. Of course, programmers, being highly inventive creatures,
    know that someone will end up with more exotic situations so we will try to take
    care of the aforementioned “expected cases” and leave a door open for those with
    unusual applications.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的复制是什么意思？嗯，有两种预期情况：复制一个非多态类型的对象和一个多态类型的对象，其中多态在这里的意思是“至少有一个 `virtual` 成员函数”。当然，程序员是极具创造力的生物，知道有人最终会遇到更奇特的情况，所以我们将尽力处理上述“预期情况”，并为那些有特殊应用的人留下一条门路。
- en: 'Why is there a difference between polymorphic and non-polymorphic types? Consider
    the following program:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么多态类型和非多态类型之间有差异？考虑以下程序：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can suppose that the `duplicate(X*)` function can safely create an object
    of the `X` type since `X` has no `virtual` member function and, as such, is probably
    not meant to serve as a public base class. However, there is a high probability
    that `duplicate(B*)` does the wrong thing by calling the constructor of `B`, as
    `B*` passed as an argument could be `B` or a pointer to an object of any class
    derived from `B` (here, `D0*`). Hence, calling `new B{ *p };` only constructs
    the base part, slicing away any state from the pointed-to object and resulting
    in a probably incorrect program.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以假设`duplicate(X*)`函数可以安全地创建一个`X`类型的对象，因为`X`没有`virtual`成员函数，因此很可能不是作为公共基类而设计的。然而，`duplicate(B*)`通过调用`B`的构造函数做错事的可能性很高，因为作为参数传递的`B*`可能是`B`或指向任何从`B`派生出的类（这里，`D0*`）的对象的指针。因此，调用`new
    B{ *p };`仅构建基部分，切除了指向的对象的任何状态，导致程序可能不正确。
- en: As is well known in object-oriented programming circles, the customary way to
    duplicate an object of a polymorphic type is through *subjective duplication*,
    otherwise known as `virtual` member function, the only entity that can really
    claim to know the type of the pointee is… the pointee itself.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程领域，众所周知，复制多态类型对象的常用方法是**主观复制**，也称为`virtual`成员函数，唯一真正能声称知道指针所指类型的是…指针所指的对象本身。
- en: 'What `dup_ptr<T>` will do, then, is to pick a *duplication policy* based on
    the characteristics of `T`: by default, if `T` is polymorphic, then we will duplicate
    through cloning; otherwise, we will duplicate through copying. Of course, we will
    let the client code specify a custom duplication mechanism if needed.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`dup_ptr<T>`将要做什么呢？它将根据`T`的特性选择一个**复制策略**：默认情况下，如果`T`是多态的，我们将通过克隆来复制；否则，我们将通过复制来复制。当然，如果需要，我们将允许客户端代码指定一个自定义的复制机制。
- en: 'We will explore three approaches to this selection of a default duplication
    policy: an intrusive approach based on interfaces, a non-intrusive approach based
    on traits and compile-time detection of a cloning member function using C++17
    features, and another non-intrusive approach based on C++20 concepts.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨三种选择默认复制策略的方法：基于接口的侵入式方法，基于特性和使用C++17特性的编译时检测克隆成员函数的非侵入式方法，以及另一种基于C++20概念的非侵入式方法。
- en: Detection through interfaces
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过接口进行检测
- en: 'One thing we could do in user code is impose that cloneable types implement
    a specific interface, as in this example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 用户代码中可以做的事情之一是要求可克隆类型实现一个特定的接口，如下例所示：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Such a solution is probably not standardization-worthy: it is intrusive, imposes
    some overhead (we are assuming that cloneable types will be polymorphic types,
    something that is likely but not mandatory), and so on. It can be a solution for
    your own code base, of course. Applying this idea to a revisitation of the example
    that mishandled duplication of a polymorphic type, earlier, we end up with the
    following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的解决方案可能不值得标准化：它是侵入式的，增加了一些开销（我们假设可复制的类型将是多态类型，这是可能的但不是强制的），等等。当然，它可以成为你自己的代码库的解决方案。将这个想法应用于之前错误处理多态类型复制的示例重访，我们得到以下结果：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, suppose we want to develop a skeleton of `dup_ptr<T>` that copies types
    that are not derived from `cloneable` and clones types that are. To that effect,
    we can use the `std::conditional` type trait and choose between two function object
    types, a `Copier` type that copies and a `Cloner` type that clones:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要开发一个`dup_ptr<T>`的骨架，它复制非`cloneable`派生类型，克隆`cloneable`类型。为此，我们可以使用`std::conditional`类型特性和在两个函数对象类型之间进行选择，一个`Copier`类型用于复制，一个`Cloner`类型用于克隆：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This implementation supposes a stateless (no member variables) `Dup` type, which
    is highly probable but should be documented in practice (if we accept stateful
    `Dup` types, we need to instantiate a `Dup` object and write code to copy and
    move that object, leading to a much more involved implementation). With this implementation,
    any type that derives from `cloneable` will be cloned and other types will be
    copied, unless the user code supplies an exotic implementation of the `Dup` type.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现假设了一个无状态的（没有成员变量）`Dup`类型，这是高度可能的，但在实践中应该进行文档记录（如果我们接受有状态的`Dup`类型，我们需要实例化一个`Dup`对象并编写复制和移动该对象的代码，这将导致一个更复杂的实现）。使用这个实现，任何从`cloneable`派生的类型都将被克隆，其他类型将被复制，除非用户代码提供了`Dup`类型的异构实现。
- en: Detection through traits
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过特性进行检测
- en: If we do not want to impose a base class to our `cloneable` types, we can use
    type traits to detect the presence of a `const`-qualified `clone()` member function
    and suppose this is a reasonable claim that cloning is a better choice than copying.
    Note that this non-intrusiveness supposes an unspoken agreement on the meaning
    of `clone()`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望对我们的 `cloneable` 类型施加基类，我们可以使用类型特质来检测存在一个 `const` 修饰的 `clone()` 成员函数，并假设这是一个合理的声明，即克隆比复制更好。请注意，这种非侵入性假设了一个不言自明的关于
    `clone()` 意义的协议。
- en: 'We can achieve this in many ways, but the cleanest and most general one probably
    uses Dr. Walter Brown’s `std::void_t` type, found in `<type_traits>` since C++17:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过许多方式实现这一点，但最干净、最通用的方法可能是使用自 C++17 以来在 `<type_traits>` 中找到的沃尔特·布朗博士的 `std::void_t`
    类型：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `std::void_t` type is a brilliant piece of work that lets knowledgeable
    people simulate, in a limited manner but for general expressions, what `requires`
    has allowed since C++20\. The way to read this example is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::void_t` 类型是一项杰出的工作，它允许有知识的人以有限的方式模拟 C++20 以来 `requires` 允许的通用表达式。阅读这个示例的方法如下：'
- en: In general, `has_clone<T>::value` is `false`
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，`has_clone<T>::value` 是 `false`
- en: For any `T` type for which `p->clone()` for some `const T*` object `p`, `has_clone<T>::value`
    is `true`
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何 `T` 类型，对于某些 `const T*` 对象 `p` 的 `p->clone()`，`has_clone<T>::value` 是 `true`
- en: Once the `Dup` type has been chosen, normal operations continue. The advantage
    of this implementation over the previous one is that this one checks for the existence
    of a suitably written `clone()` member function, whereas the previous one checks
    for the existence of a specific base class. Implementing a function is a lighter
    contract than deriving from a specific base class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了 `Dup` 类型，正常操作继续。这种实现相对于之前的一个优点是，它检查是否存在一个适当编写的 `clone()` 成员函数，而之前的实现检查是否存在特定的基类。实现一个函数比从特定的基类派生更轻量级的合同。
- en: A word on std::void_t
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `std::void_t` 的一些话
- en: The `std::void_t` type is a brilliant piece of work. Using it relies on `has_clone<T>`
    is `false` for most types but is `true` when expression `p->clone()` is valid
    for some `const T*` object `p`. That we can easily test the validity of any expression
    even before concepts came into their own is just beautiful, and we owe Dr. Walter
    Brown much for this gem (among many other gems).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::void_t` 类型是一项杰出的工作。使用它依赖于 `has_clone<T>` 对于大多数类型是 `false`，但当表达式 `p->clone()`
    对于某些 `const T*` 对象 `p` 是有效的时候是 `true`。即使在概念真正发挥其作用之前，我们也能轻松地测试任何表达式的有效性，这真是太美了，我们非常感谢沃尔特·布朗博士（Dr.
    Walter Brown）为我们带来了这个宝石（以及其他许多宝石）。'
- en: Detection through concepts
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过概念进行检测
- en: Since C++20, tricks such as `std::void_t` are less useful than they were since
    concepts are now part of the language’s type system. Through concepts, we can
    define a `cloneable` type, `T`, to be something for which a call to `clone()`
    is well-formed on `const T*` and yields something that is convertible to `T*`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 C++20 以来，像 `std::void_t` 这样的技巧不如以前有用，因为概念现在是语言类型系统的一部分。通过概念，我们可以定义一个 `cloneable`
    类型 `T`，使其在 `const T*` 上调用 `clone()` 是良好形成的，并且得到可以转换为 `T*` 的结果。
- en: 'With this, we have the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有以下内容：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Concepts, like traits, are a non-intrusive solution to this problem. Where traits
    are a programming technique, however, they are ingrained in the type system and
    we can (for example) write code that’s specialized for `cloneable<T>` and code
    that is not. In our case, the fact that we want to leave the door open for types
    that use neither the copy constructor nor a `clone()` member function suggests
    that the current setup, which lets client code supply other duplication mechanisms,
    is probably preferable.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 概念，就像特质一样，是解决这个问题的非侵入式解决方案。然而，特质是一种编程技术，它内嵌在类型系统中，我们可以（例如）编写针对 `cloneable<T>`
    专门化的代码，以及不针对 `cloneable<T>` 编写的代码。在我们的情况下，我们希望为既不使用复制构造函数也不使用 `clone()` 成员函数的类型留下开放的大门，这表明当前设置，允许客户端代码提供其他复制机制，可能是更可取的。
- en: C++26
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: C++26
- en: C++26 will contain two standard types named `std::indirect` and `std::polymorphic`
    that will cover a niche close to the one described by this `dup_ptr`. It was voted
    in on February 15 2025.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: C++26 将包含两个名为 `std::indirect` 和 `std::polymorphic` 的标准类型，它们将覆盖一个接近于本 `dup_ptr`
    描述的利基市场。它于 2025 年 2 月 15 日获得投票通过。
- en: Some not-so-smart yet useful smart pointers
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些不太聪明但有用的智能指针
- en: So we have standard smart pointers, such as `unique_ptr<T>` (single ownership)
    and `shared_ptr<T>` (shared ownership), and we can write our own for more exotic
    situations (we examined `dup_ptr<T>` where we have single ownership but duplication
    of the pointee when the pointer is duplicated). Are there other common semantics
    we might want to ensconce in the type system of our program?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有标准的智能指针，如 `unique_ptr<T>`（单一所有者）和 `shared_ptr<T>`（共享所有者），我们可以为更特殊的情况编写自己的（我们检查了
    `dup_ptr<T>`，其中在指针被复制时，我们有单一所有者，但指向的对象被复制）。我们的程序类型系统中可能还有其他常见的语义我们想要封装？
- en: 'Well, there are at least two “easy” ones one could think of: implementing a
    “never null” semantic and implementing an “only observing” semantic.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，至少有两个“简单”的可以考虑：实现一个“永不为空”的语义和实现一个“仅观察”的语义。
- en: A non_null_ptr type
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个 non_null_ptr 类型
- en: 'Let’s go back to an earlier example where we wrote the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到一个早期的例子，我们写了以下内容：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note the comment, which puts the burden of not supplying a null pointer on
    user code. We could have approached this constraint in many other ways, including
    the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意注释，它将不提供空指针的责任放在用户代码上。我们可以用许多其他方式来处理这个约束，包括以下内容：
- en: Asserting `!p`
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言 `!p`
- en: Calling `std::abort()` if `!p`
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `!p`，调用 `std::abort()`
- en: Calling `std::terminate()` if `!p`
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `!p`，调用 `std::terminate()`
- en: Throwing if `!p`, and so on
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出 `!p`，等等
- en: 'The important thing is that if we care about pointers being non-null, and if
    we inject `if(!p)` tests in our runtime code, we are probably doing something
    wrong as this could (or should?) be part of the type system: *this function only
    accepts non-null pointers*. Code speaks louder than comments.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，如果我们关心指针不为空，并且我们在运行时代码中注入 `if(!p)` 测试，那么我们可能正在做错事，因为这可能是（或应该是）类型系统的一部分：*这个函数只接受非空指针*。代码比注释更有说服力。
- en: 'This idea appears in some commercial libraries (for example, `gsl::non_null<T>`
    from the guideline support library offered by some major compiler vendors) and
    is easy to implement as long as one has a clear way of signaling errors. For the
    sake of the example, we will suppose that this clear way is throwing an exception:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法出现在一些商业库中（例如，一些主要编译器供应商提供的指南支持库中的 `gsl::non_null<T>`），只要有一个明确的方式报告错误，就很容易实现。为了举例，我们将假设这个明确的方式是抛出异常：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using this type, any function that accepts a `non_null_ptr<T>` argument knows
    that the `T*` pointer therein will be non-null, relieving client code from the
    burden of validation. This makes `non_null_ptr<T>` a beautiful type for the interface
    of functions that expect a non-null `T*`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种类型，任何接受 `non_null_ptr<T>` 参数的函数都知道其中的 `T*` 指针将非空，从而减轻客户端代码验证的负担。这使得 `non_null_ptr<T>`
    成为期望非空 `T*` 的函数接口的一个美丽的类型。
- en: The rest of this class is mostly trivial to write at this point. The key peculiarity
    is that `non_null_ptr<T>` will not expose a default constructor, as that constructor
    would have to initialize the `p` data member to some default value (probably `nullptr`)
    but the `non_null_ptr<T>` type models a non-null pointer, which would lead to
    nonsensical code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这个类的其余部分主要是简单易写的。关键特性是 `non_null_ptr<T>` 不会暴露默认构造函数，因为那个构造函数必须将 `p` 数据成员初始化为某个默认值（可能是
    `nullptr`），但 `non_null_ptr<T>` 类型模拟了一个非空指针，这会导致不合理的代码。
- en: 'In terms of usage, take a look at this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用方面，看看这个：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, compare it with this, supposing that `non_null_ptr<T>` throws when constructed
    with a null pointer:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，比较一下这个，假设 `non_null_ptr<T>` 在用空指针构造时抛出异常：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The two main advantages of `non_null_ptr<T>` over `T*` in this case are that
    the type system documents the intent better with `non_null_ptr<T>` (with `T*`,
    a null pointer might be fine, but with `non_null_ptr<T>`, it is clearly not) and
    that the called functions can proceed without validating, the validation being
    (again) ingrained in the type system. Using a richer type than `T*` makes both
    caller code and called code better.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`non_null_ptr<T>` 比 `T*` 的两个主要优点是类型系统通过 `non_null_ptr<T>` 更好地记录了意图（使用
    `T*`，空指针可能没问题，但使用 `non_null_ptr<T>`，则显然不是），并且被调用的函数可以在不进行验证的情况下继续执行，验证（再次）内置于类型系统中。使用比
    `T*` 更丰富的类型使调用代码和被调用代码都变得更好。
- en: What if the called function needs `T*`? This can happen, for example, in the
    case where it needs to call a C function. Well, then, use the `non_null_ptr<T>`
    object’s `get()` member function. C++ is nothing if not pragmatic.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果被调用的函数需要 `T*`？这种情况可能发生，例如，当它需要调用一个 C 函数时。那么，使用 `non_null_ptr<T>` 对象的 `get()`
    成员函数。C++ 如果不是实用主义，那就什么都不是了。
- en: An observer_ptr type
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个 observer_ptr 类型
- en: 'How about having a very dumb smart pointer type named `observer_ptr<T>` that
    solely cares about expressing the idea that that “smart” pointer is, indeed, *not*
    a pointer, in the sense that operations that would apply to a raw pointer are
    restricted on that type. The canonical issue is that applying `delete` on `T*`
    would work but applying `delete` on `observer_ptr<T>` would not since `observer_ptr<T>`
    is… not a pointer. Indeed, consider the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有一个非常愚蠢的智能指针类型名为`observer_ptr<T>`，它只关心表达这样一个观点：“智能”指针实际上确实*不是*指针，因为在那种类型上，应用于原始指针的操作被限制。典型的问题是，对`T*`应用`delete`会起作用，但对`observer_ptr<T>`应用`delete`则不会，因为`observer_ptr<T>`不是指针。确实，考虑以下：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You might say, as the comment states, “But that function’s not supposed to do
    that! It does not own `*p`!” but, well, mistakes happen, as do misunderstandings.
    In this case, the impact of misunderstandings is made worse by the fact that nothing
    in the argument’s type states that applying `operator delete` to `p` is incorrect!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会说，正如评论中所说的，“但是那个函数不应该做那样的事情！它不拥有`*p`！”但是，嗯，错误是会发生的，误解也是如此。在这种情况下，误解的影响由于论证的类型中没有任何内容表明将`operator
    delete`应用于`p`是不正确的而被加剧了！
- en: 'Now, let’s change the signature slightly:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们稍微改变一下签名：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The “use `*p`” comment remains the same in both versions. The `observer_ptr<T>`
    type offers almost trivial versions of all reasonable operators and member functions
    (`get()`, `operator*()`, `operator->()`, `empty()`, and so on) so usage of `T*`
    and of `observer_ptr<T>` should be mostly equivalent in user code; the only difference
    is in misguided uses such as applying `delete` or performing pointer arithmetic.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: “使用`*p`”的注释在这两个版本中保持不变。`observer_ptr<T>`类型提供了几乎所有合理运算符和成员函数（`get()`、`operator*()`、`operator->()`、`empty()`等等）的几乎平凡的版本，因此`T*`和`observer_ptr<T>`在用户代码中的使用应该大致相同；唯一的区别在于像应用`delete`或执行指针运算这样的错误使用。
- en: Sometimes, just clarifying intent in a function interface makes code better.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，仅仅在函数接口中明确意图就能使代码变得更好。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In [*Chapter 5*](B21071_05.xhtml#_idTextAnchor079), we spent some time on the
    proper usage of standard smart pointers. In the current chapter, we “dirtied our
    hands,” so to speak, and we wrote homemade (and simplified) versions of `unique_ptr<T>`
    and `shared_ptr<T>`. As mentioned more than once, this is meant as an educational
    exploration, as your library vendor assuredly provides significantly better (more
    complete, more performant, better tested, etc.) implementations in both cases.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B21071_05.xhtml#_idTextAnchor079)中，我们花了一些时间讨论标准智能指针的正确用法。在当前章节中，我们“弄脏了我们的手”，也就是说，我们编写了自制的（以及简化的）`unique_ptr<T>`和`shared_ptr<T>`版本。正如多次提到的，这旨在作为一种教育性的探索，因为你的库供应商无疑在两种情况下都提供了显著更好的（更完整、更高效、更好测试等）实现。
- en: In this chapter, we also explored the possibility of providing homemade smart
    pointer types, with a policy-based `dup_ptr<T>` based on three distinct approaches
    to the selection of a duplication algorithm. The intent was to show that it can
    be done, how it can be done, and how we can provide reasonable, usable defaults
    without blocking user code with more exotic requirements.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还探讨了提供自制智能指针类型的可能性，有一个基于三种不同选择复制算法的策略`dup_ptr<T>`。意图是表明这是可以做到的，如何做到，以及我们如何提供合理、可用的默认值，而不会因为用户代码中更奇特的要求而阻碍它们。
- en: Toward the end of this chapter, we examined some relatively simple (but useful)
    smart (well, lightly smart) pointers that can be used at the edges of functions
    (typically, as argument types) to make semantic requirements implicit through
    the type system instead of forcing user code to enforce these requirements explicitly…
    and sometimes fail to do so.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾，我们考察了一些相对简单（但有用）的智能（或者说轻度智能）指针，这些指针可以在函数的边缘（通常是作为参数类型）使用，通过类型系统隐式地表达语义要求，而不是强迫用户代码明确地强制执行这些要求……有时甚至无法做到。
- en: Unsurprisingly, memory management is not limited to smart pointers. In the next
    chapter, we will explore how the `new`, `new[]`, `delete`, and `delete[]` operators
    work, how we can implement them ourselves, and why we sometimes want to do so.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 令人意外的是，内存管理不仅限于智能指针。在下一章中，我们将探讨`new`、`new[]`、`delete`和`delete[]`运算符的工作原理，我们如何自己实现它们，以及为什么我们有时想这样做。
- en: 'Part 3: Taking Control (of Memory Management Mechanisms)'
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：掌握（内存管理机制）
- en: In this part, we will delve somewhat deeper and examine ways in which you can
    take over some of the core memory allocation mechanisms in the C++ language and
    customize them to your needs. We will see how you can control what operators such
    as new and delete do, how to use specialized knowledge to obtain specific execution
    properties, and how these operators can be used in innovative ways. We will also
    use this knowledge for a few real-life applications and to achieve fast, sometimes
    extremely fast, memory management operations.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，我们将更深入地探讨，并检查您如何接管C++语言中的一些核心内存分配机制，并按需定制它们。我们将看到您如何控制诸如new和delete之类的运算符的行为，如何使用专业知识来获得特定的执行属性，以及这些运算符如何以创新的方式使用。我们还将利用这些知识应用于一些实际应用，以实现快速、有时甚至非常快速的内存管理操作。
- en: 'This part has the following chapters:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 7*](B21071_07.xhtml#_idTextAnchor116), *Overloading Memory Allocation
    Operators*'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B21071_07.xhtml#_idTextAnchor116), *重载内存分配运算符*'
- en: '[*Chapter 8*](B21071_08.xhtml#_idTextAnchor128), *Writing a Naïve Leak Detector*'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B21071_08.xhtml#_idTextAnchor128), *编写一个简单的内存泄漏检测器*'
- en: '[*Chapter 9*](B21071_09.xhtml#_idTextAnchor141), *Atypical Allocation Mechanisms*'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B21071_09.xhtml#_idTextAnchor141), *非典型分配机制*'
- en: '[*Chapter 10*](B21071_10.xhtml#_idTextAnchor153), *Arena-Based Memory Management
    and Other Optimizations*'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B21071_10.xhtml#_idTextAnchor153), *基于区域的内存管理和其他优化*'
- en: '[*Chapter 11*](B21071_11.xhtml#_idTextAnchor163), *Deferred Reclamation*'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B21071_11.xhtml#_idTextAnchor163), *延迟回收*'
