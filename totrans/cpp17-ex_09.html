<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Domain-Specific Language</h1>
                </header>
            
            <article>
                
<p>In the previous chapters, we developed the games Othello and Noughts and Crosses with the Qt library. In this chapter, we will start to develop a <strong>Domain-Specific Language</strong> (<strong>DSL</strong>), which is a language intended for a specific domain. More specifically, we will develop a language for writing graphical objects in a Qt widget. The language allows us to draw lines, rectangles, ellipses, and to write text. Moreover, it does allow us to choose color as well as pen and brush style for the graphical objects. It also allows us to choose font and alignment for the text.</p>
<p>Topics we will cover in this chapter include:</p>
<ul>
<li>First, we will informally look into the source code of our DSL by looking at an example. We will draw graphical objects and set their color, style, and font.</li>
<li>We will formally define our language with grammar.</li>
<li>When we have defined the grammar, we write the scanner. The scanner reads the source code and recognizes meaningful sequences of characters, called <strong>tokens</strong>.</li>
<li>When we have written the scanner, we write the parser. The parser can be considered the heart of our DSL. It requests new tokens from the scanner, when needed. It checks that the source code complies with the grammar, and it generates a sequence of actions. Each action holds an instruction, such as setting the color or drawing a line.</li>
<li>Finally, we write a viewer that reads the action sequence generated by the parser and displays the graphical objects in a Qt widget.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing the source language – a simple example</h1>
                </header>
            
            <article>
                
<p>The source language of our DSL is made up by a sequence of instructions. There are instructions for drawing graphical objects such as lines, rectangles, ellipses, and text. We also have instructions for setting the color and style of the objects as well as font and alignment of the text. Finally, there is instruction for assigning values to a name.</p>
<p>Let us look at an example. The following code draws a rectangle and writes text. Note that the language is not case-sensitive, that is, it does not matter whether we use small or capital letters in our code. We start by defining the top-left corner of a rectangle:</p>
<pre style="padding-left: 60px">  topLeft = point(100, 100); </pre>
<p>We use the coordinate operators to extract the <em>x</em> and <em>y</em> coordinates of the top-left point and define the bottom-right corner:</p>
<pre style="padding-left: 60px">  left = xCoordinate(topleft); 
  top = yCoordinate(topLeft); 
  bottomRight = point(left + 100, top + 100); </pre>
<p>We use the predefined values <kbd>DashLine</kbd> and <kbd>CrossPatterns</kbd> to set the style of the pen and brush:</p>
<pre style="padding-left: 60px">  SetPenStyle(DashLine); 
  SetBrushStyle(CrossPattern); </pre>
<p>We use the predefined color <kbd>Black</kbd> for the pen and create our own color <kbd>Purple</kbd> for the brush. We can create a new color with three values corresponding to their red, green, and blue components. Each component can hold a value between 0 and 255, inclusive:</p>
<pre style="padding-left: 60px">  SetPenColor(Black); 
  PurpleColor = color(128, 0, 128); 
  SetBrushColor(PurpleColor); 
  DrawRectangle(topLeft, bottomRight); </pre>
<p>We continue to add a text, with font and alignment. We choose <kbd>12</kbd> point <kbd>Times New Roman</kbd> with left horizontal alignment and top vertical alignment:</p>
<pre style="padding-left: 60px">  SetFont(font("Times New Roman", 12)); 
  SetHorizontalAlignment(AlignLeft); 
  SetVerticalAlignment(AlignTop); 
  DrawText(point(300, 150), "Hello, DSL!");</pre>
<p>The instructions of this example will be divided into meaningful parts by the scanner; the parser will check that the instructions comply with the grammar and generate a sequence of actions read by the viewer and display the following Qt widget:</p>
<div class="CDPAlignCenter CDPAlign"><img height="210" src="assets/30203c62-df0f-49a5-9e2a-e676d1dafdbf.png" width="311"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The grammar of the source language</h1>
                </header>
            
            <article>
                
<p>The source language of our DSL needs to be exactly defined. We do that by defining grammar<strong> </strong>for the language. Grammar is made up by rules (in <em>italic</em> style), keywords (in <strong>bold</strong> style), separations, and punctuations.</p>
<p>The <kbd>program</kbd> rule is the start rule. The arrow (<kbd>-&gt;</kbd>) means that a program is made up by an instructions list. The arrow can be read as:</p>
<pre style="padding-left: 60px">program -&gt; instructionList </pre>
<p>In the grammar, an asterisk (<kbd>*</kbd>) means <strong>zero</strong> or <strong>more</strong>. Hence, an instruction list is made up by zero or more instructions:</p>
<pre style="padding-left: 60px">instructionList -&gt; instruction* </pre>
<p>The assignment instruction takes a name followed by the assignment operator (<kbd>=</kbd>), an expression, and a semicolon. The instructions for setting the pen and brush color and style take one expression, so do the settings of the font and alignment. The instructions for drawing lines, rectangles, and text take two expressions. Note that every instruction is terminated by a semicolon (<kbd>;</kbd>).</p>
<p>The vertical bar (<kbd>|</kbd>) can be read as <strong>or</strong>. An instruction is an assignment or<em><em> </em></em>the setting of the pen color or<em><em> </em></em>the setting of the brush color, and so on:</p>
<pre style="padding-left: 60px">instruction -&gt; name = expression; 
             | SetPenColor(expression); 
             | SetPenStyle(expression); 
             | SetBrushColor(expression); 
             | SetBrushStyle(expression); 
             | SetFont(expression); 
             | SetHorizontalAlignment(expression); 
             | SetVerticalAlignment(expression); 
             | DrawLine(expression, expression); 
             | DrawRectangle(expression, expression); 
             | DrawEllipse(expression, expression); 
             | DrawText(expression, expression); </pre>
<p>The next part of the parser to define is the expressions. First, we look at the operators of the expressions. We also have to look into the priority of the operators. For instance, multiplication and division have higher priority than addition and subtraction. The operators of the grammar have the following priorities:</p>
<table class="MsoTableGrid">
<tbody>
<tr>
<td>
<p><strong>Expression</strong></p>
</td>
<td>
<p><strong>Operator</strong></p>
</td>
<td>
<p><strong>Priority</strong></p>
</td>
</tr>
<tr>
<td>
<p>Addition Subtraction</p>
</td>
<td>
<p><kbd>+ -</kbd></p>
</td>
<td>
<p>Lowest</p>
</td>
</tr>
<tr>
<td>
<p>Multiplication Division</p>
</td>
<td>
<p><kbd>* /</kbd></p>
</td>
<td/>
</tr>
<tr>
<td>
<p>Primary</p>
</td>
<td>
<p><kbd>point</kbd></p>
<p><kbd>xCoordinate</kbd></p>
<p><kbd>yCoordinate</kbd></p>
<p><kbd>color</kbd></p>
<p><kbd>font</kbd></p>
<p><kbd>(expression)</kbd></p>
<p><kbd>name</kbd></p>
<p><kbd>value</kbd></p>
</td>
<td>
<p>Highest</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>We define two rules each for addition and subtraction, as well as for multiplication and division. We start with the lowest priority level, which is addition and subtraction. In the <kbd>expression</kbd> rule we call the <kbd>mulDivExpression</kbd> rule, which handles multiplication and division expressions, and we call the <kbd>expressionRest</kbd> rule to examine the rest of the expression:</p>
<pre style="padding-left: 60px">expression -&gt; mulDivExpression expressionRest </pre>
<p>In the <kbd>expressionRest</kbd> rule we look into the next token. If it is a plus or a minus, we have an addition or subtraction expression. We call <kbd>mulDivExpression</kbd> to handle expressions of higher priority. Finally, we call the <kbd>expressionRest</kbd> rule again in case of another plus or minus. However, if the first token is neither a plus nor a minus,  we do nothing:</p>
<pre style="padding-left: 60px">expressionRest -&gt; + mulDivExpression expressionRest 
                | - mulDivExpression expressionRest 
                | /* empty */ </pre>
<p><kbd>mulDivExpression</kbd> and <kbd>mulDivExpressionRest</kbd> work in the same way as <kbd>expression</kbd> and <kbd>expressionRest</kbd> shown previously:</p>
<pre style="padding-left: 60px">mulDivExpression -&gt; primaryExpression mulDivExpressionRest 
mulDivExpressionRest -&gt; * primaryExpression mulDivExpressionRest 
                      | / primaryExpression mulDivExpressionRest 
                      | /* empty */ </pre>
<p>The primary expression is a point, an <em>x</em> or <em>y</em> coordinate, a color, a font, a name, or a value. A point is made up by two expressions holding the <em>x</em> and <em>y</em> coordinate of the point. A coordinate takes an expression holding a point and gives it an <em>x</em> or <em>y</em> coordinate:</p>
<pre style="padding-left: 60px">primaryExpression -&gt; point(expression, expression) 
                   | xCoordinate(expression) 
                   | yCoordinate(expression) </pre>
<p>A color expression is made up by its red, green, and blue components, while a font expression is made up by the name and size of the font:</p>
<pre>                   | color(expression, expression, expression) 
                   | font(expression, expression) </pre>
<p>An expression can be enclosed in parentheses in order to change the priority of the expression. For instance, in the expression 2 + 3 x 4, multiplication takes precedence over addition, but in the expression (2 + 3) x 4, addition takes precedence over multiplication:</p>
<pre>                   | (expression) </pre>
<p>Finally, an expression can be a name earlier associated with a value, or simply a value:</p>
<pre>                   | name 
                   | value</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The target language</h1>
                </header>
            
            <article>
                
<p>The target language is defined by a sequence of actions. Informally, the actions correspond to the instructions of the grammar. We have actions for setting the color or style of a pen or a brush, and for setting the horizontal or vertical alignment of the text, as well as actually drawing the lines, rectangles, ellipses, and text of the drawing. Later in this chapter, we will write a parser that generates a sequence of actions, and a viewer that reads the actions and displays graphical objects in a Qt widget.</p>
<p>An <kbd>Action</kbd> object holds the identity of the action (which is defined by the <kbd>TokenId</kbd> enumeration in the <kbd>Token</kbd> class, as follows) together with, at most, two values.</p>
<p><strong>Action.h:</strong></p>
<pre style="padding-left: 60px">#ifndef ACTION_H 
#define ACTION_H 
 
#include "Token.h" 
#include "Value.h" 
 
class Action { 
  public: 
    Action(TokenId actionId, const Value&amp; value1 = Value(), 
           const Value&amp; value2 = Value()); 
 
    Action(const Action&amp; action); 
    Action operator=(const Action&amp; action); 
 
    TokenId id() const {return m_actionId;} 
    const Value&amp; value1() const {return m_value1;} 
    const Value&amp; value2() const {return m_value2;} 
 
  private: 
    TokenId m_actionId; 
    Value m_value1, m_value2; 
}; 
 
#endif // ACTION_H </pre>
<p>The <kbd>Action.cpp</kbd> file holds the definitions of the methods of the <kbd>Action</kbd> class.</p>
<p><strong>Action.cpp:</strong></p>
<pre style="padding-left: 60px">#include "Action.h"</pre>
<p>The constructor takes the action identity and at most two values:</p>
<pre style="padding-left: 60px">Action::Action(TokenId actionId, 
               const Value&amp; value1 /*= Value()*/, 
               const Value&amp; value2 /*= Value()*/ ) 
  :m_actionId(actionId), 
   m_value1(value1), 
   m_value2(value2) { 
  // Empty. 
}  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The colors</h1>
                </header>
            
            <article>
                
<p>When setting the color of the pen or brush, we need to submit the color with the instruction. We can use the color rule in the preceding grammar to create our own color. However, there is a set of predefined colors of the Qt class <kbd>QColor</kbd>. The following scanner defines a set of predefined <kbd>QColor</kbd> objects (<kbd>Aqua</kbd>, <kbd>Black</kbd>, ...) and maps them to their names. For instance, the user can write the following instruction in the source code:</p>
<pre style="padding-left: 60px">SetPenColor(Aqua); </pre>
<p>In that case, since the name <kbd>Aqua</kbd> is associated with the <kbd>QColor</kbd> object <kbd>Aqua</kbd>, the pen color is set to <kbd>Aqua</kbd>.</p>
<p><strong>Colors.h:</strong></p>
<pre style="padding-left: 60px">#ifndef COLOR_H 
#define COLOR_H 
 
#include &lt;QWidget&gt; 
 
extern QColor 
  Aqua, Black, Blue, Brown, Cyan, Gray, Green, Lime, Magenta, 
  Navyblue, Orange, Orchid, Pink, Purple, Red, Silver, Snow, 
  SteelBlue, SystemColor, Turquoise, Violet, White, Yellow; 
 
#endif // COLOR_H </pre>
<p>The <kbd>Colors.cpp</kbd> file holds the definitions of the colors in the <kbd>Colors.h</kbd> file.</p>
<p><strong>Colors.cpp:</strong></p>
<pre style="padding-left: 60px">#include "Colors.h"</pre>
<p>Each color is defined by its red, green, and blue component. Each component holds a value from 0 to 255, inclusive. For instance, the <kbd>Blue</kbd> color holds the full value of the blue component and zero of the other components, while <kbd>Yellow</kbd> is a blend of red and green:</p>
<pre style="padding-left: 60px">QColor 
  Aqua(0, 255, 255), Black(0, 0, 0), Blue(0, 0, 255), 
  Brown(165, 42, 42), Cyan(0, 255, 255), Gray(127, 127, 127), 
  Green(0, 128, 0), Lime(0, 255, 0), Magenta(255, 0, 255), 
  Navyblue(159, 175, 223), Orange(255, 165, 0), 
  Orchid(218, 112, 214), Pink(255, 192, 203), 
  Purple(128, 0, 128), Red(255, 0, 0), Silver(192, 192, 192), 
  Snow(255, 250, 250),  SteelBlue(70, 130, 180), 
  SystemColor(0, 0, 0), Turquoise(64, 224, 208), 
  Violet(238, 130, 238), White(255, 255, 255), 
  Yellow(255, 255, 0); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Error handling</h1>
                </header>
            
            <article>
                
<p>There are some functions for error handling: <kbd>check</kbd> checks whether a condition is true and reports an error if it is not. The <kbd>syntaxError</kbd> and <kbd>semanticError</kbd> functions report a syntactic and semantic error, while <kbd>error</kbd> throws an exception that is caught and reported by the <kbd>main</kbd> function.</p>
<p><strong>Error.h:</strong></p>
<pre style="padding-left: 60px">#ifndef ERROR_H 
#define ERROR_H 
 
#include &lt;QString&gt; 
 
void error(const QString&amp; message); 
void syntaxError(); 
void syntaxError(const QString&amp; message); 
void semanticError(const QString&amp; message); 
void check(bool condition, const QString&amp; message); 
 
#endif // ERROR_H </pre>
<p>The <kbd>Error.cpp</kbd> file holds the definitions of the <kbd>Error.h</kbd> file.</p>
<p><strong>Error.cpp:</strong></p>
<pre style="padding-left: 60px">#include &lt;SStream&gt; 
#include &lt;Exception&gt; 
using namespace std; 
 
#include "Error.h" 
 
extern int g_lineNo = 1; 
 
void error(const QString&amp; message) { 
  throw exception(message.toStdString().c_str()); 
} </pre>
<p>We use the C++ <kbd>stringstream</kbd> standard class to compound the error message:</p>
<pre style="padding-left: 60px">void syntaxError() { 
  stringstream stringStream; 
  stringStream &lt;&lt; "Syntax error at line " &lt;&lt; g_lineNo &lt;&lt; "."; </pre>
<p>The <kbd>str</kbd> method returns an object of the C++ <kbd>string</kbd> standard class, and <kbd>c_str</kbd> returns a character pointer that is converted to a <kbd>QString</kbd> object in the <kbd>error</kbd> call:</p>
<pre style="padding-left: 60px">  error(stringStream.str().c_str()); 
} </pre>
<p>A syntax error occurs when the scanner finds a character sequence that does not constitute a token, or when the parser detects that the token sequence does not comply with the grammar. We will cover the topic soon; for now, just remember that a scanner can report errors too:</p>
<pre style="padding-left: 60px">void syntaxError(const QString&amp; message) { 
  stringstream stringStream; 
  stringStream &lt;&lt; "Syntax error at line " &lt;&lt; g_lineNo 
               &lt;&lt; ": " &lt;&lt; message.toStdString() &lt;&lt; "."; 
  error(stringStream.str().c_str()); 
} </pre>
<p>A semantic error occurs when an unknown name is found, or when the types of an expression do not comply:</p>
<pre style="padding-left: 60px">void semanticError(const QString&amp; message) { 
  stringstream stringStream; 
  stringStream &lt;&lt; "Sematic error: " 
               &lt;&lt; message.toStdString() &lt;&lt; "."; 
  error(stringStream.str().c_str()); 
}</pre>
<p>The <kbd>check</kbd> method has a similar effect to the <kbd>assert</kbd> macro. It checks whether the condition is true. If it is not true, <kbd>semanticError</kbd> is called, which eventually throws an error exception:</p>
<pre style="padding-left: 60px">void check(bool condition, const QString&amp; message) { 
  if (!condition) { 
    semanticError(message); 
  } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The value</h1>
                </header>
            
            <article>
                
<p>There are several kinds of values in the language, which are used to set the color or style of the pen or brush, or to set the end-points of a line, or to set the name of the font, or the alignment of the text: numerical (<kbd>double</kbd>), string (<kbd>QString</kbd>), color (<kbd>QColor</kbd>), font (<kbd>QFont</kbd>), point (<kbd>QPoint</kbd>), pen style (<kbd>Qt::PenStyle</kbd>), brush style (<kbd>Qt</kbd>::<kbd>BrushStyle</kbd>), and horizontal or vertical alignment (<kbd>Qt</kbd>::<kbd>AlignmentFlag</kbd>).</p>
<p><strong>Value.h:</strong></p>
<pre style="padding-left: 60px">#ifndef VALUE_H 
#define VALUE_H 
 
#include &lt;IOStream&gt; 
using namespace std; 
 
#include &lt;QtWidgets&gt; 
 
enum TypeId {NumericalTypeId, StringTypeId, ColorTypeId, 
             PenStyleTypeId, BrushStyleId, AlignmentTypeId, 
             FontTypeId, PointTypeId}; 
 
class Value { 
  public: 
    Value(); 
    Value(double numericalValue); 
    Value(const QString&amp; stringValue); 
    Value(const QPoint&amp; pointValue); 
    Value(const QColor&amp; colorValue); 
    Value(const QFont&amp; fontValue); 
    Value(const Qt::PenStyle&amp; penStyleValue); 
    Value(const Qt::BrushStyle&amp; brushStyleValue); 
    Value(const Qt::AlignmentFlag&amp; alignment); 
 
    Value(const Value&amp; value); 
    Value&amp; operator=(const Value&amp; value); 
 
    bool isNumerical() const {return (m_typeId==NumericalTypeId);} 
    bool isString() const { return (m_typeId == StringTypeId); } 
    bool isColor() const { return (m_typeId == ColorTypeId); } 
    bool isFont() const { return (m_typeId == FontTypeId); } 
    bool isPoint() const { return (m_typeId == PointTypeId); } 
    bool isPenStyle() const {return (m_typeId == PenStyleTypeId);} 
    bool isBrushStyle() const {return (m_typeId == BrushStyleId);} 
    bool isAlignment() const {return (m_typeId==AlignmentTypeId);} 
 
    double numericalValue() const { return m_numericalValue; } 
    const QString&amp; stringValue() const { return m_stringValue; } 
    const QColor&amp; colorValue() const { return m_colorValue; } 
    const QFont&amp; fontValue() const { return m_fontValue; } 
    const QPoint&amp; pointValue() const { return m_pointValue; } 
    const Qt::PenStyle&amp; penStyleValue() const 
                        { return m_penStyleValue; } 
    const Qt::BrushStyle&amp; brushStyleValue() const 
                          { return m_brushStyleValue; } 
    const Qt::AlignmentFlag&amp; alignmentValue() const 
                             { return m_alignmentValue; } 
 
  private: 
    TypeId m_typeId; 
    double m_numericalValue; 
    QString m_stringValue; 
    QPoint m_pointValue; 
    QColor m_colorValue; 
    QFont m_fontValue; 
    Qt::PenStyle m_penStyleValue; 
    Qt::BrushStyle m_brushStyleValue; 
    Qt::AlignmentFlag m_alignmentValue; 
}; 
 
#endif // VALUE_H </pre>
<p>The <kbd>Value.cpp</kbd> file holds the definitions of the methods of the <kbd>Value</kbd> class.</p>
<p><strong>Value.cpp:</strong></p>
<pre style="padding-left: 60px">#include &lt;CAssert&gt; 
using namespace std; 
 
#include "Value.h" 
 
Value::Value() { 
  // Empty. 
} </pre>
<p>The non-default constructors initialize the <kbd>Value</kbd> object with appropriate values:</p>
<pre style="padding-left: 60px">Value::Value(double numericalValue) 
 :m_typeId(NumericalTypeId), 
  m_numericalValue(numericalValue) { 
  // Empty. 
} 
 
Value::Value(const QPoint&amp; pointValue) 
 :m_typeId(PointTypeId), 
  m_pointValue(pointValue) { 
  // Empty. 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The scanner</h1>
                </header>
            
            <article>
                
<p>The <strong>scanner</strong> is a part of the application that accepts the source code and generates a sequence of tokens. A <strong>token</strong> is the smallest meaningful part of the source code. For instance, the characters <strong>f</strong>, <strong>o</strong>, <strong>n</strong>, and <strong>t</strong> make up the keyword <strong>font</strong>, and the characters <strong>1</strong>, <strong>2</strong>, and <strong>3</strong> constitute the numerical value <strong>123</strong>.</p>
<p>However, first we need the <kbd>Token</kbd> class to keep track of the tokens. The <kbd>m_tokenId</kbd> field is set to a value of the enumeration <kbd>TokenId</kbd>. In the case of a name, the <kbd>m_name</kbd> field holds the name, and in the case of a value, the <kbd>m_value</kbd> field holds the value.</p>
<p><strong>Token.h:</strong></p>
<pre style="padding-left: 60px">#ifndef TOKEN_H 
#define TOKEN_H 
 
#include &lt;QWidget&gt; 
#include "Value.h" </pre>
<p>The <kbd>TokenId</kbd> enumeration holds all the tokens of the scanner. They are divided into keywords, operators, punctuation, and separators, as well as names and values. In order to avoid converting between different enumerations, the <kbd>TokenId</kbd> enumeration is used by the scanner, parser, and viewer. The <kbd>TokenId</kbd> enumeration is used by the scanner to distinguish between the different tokens by the parser when type checking and evaluating expressions, and by the <kbd>Action</kbd> class to distinguish between different actions.</p>
<p>The first part (<kbd>ColorId</kbd> to <kbd>YCoordinateId</kbd>) is keywords of the language:</p>
<pre style="padding-left: 60px">enum TokenId {ColorId, DrawEllipseId, DrawLineId, 
              DrawRectangleId, DrawTextId, FontId,  
              PointId, SetBrushColorId, SetBrushStyleId, 
              SetFontId, SetHorizontalAlignmentId, 
              SetPenColorId, SetPenStyleId, 
              SetVerticalAlignmentId, 
              XCoordinateId, YCoordinateId, </pre>
<p>The second part (<kbd>AddId</kbd> to <kbd>DivideId</kbd>) is operators:</p>
<pre>              AddId, SubtractId, MultiplyId, DivideId, </pre>
<p>The next part is parentheses, assignment (<kbd>=</kbd>), comma, and semicolon:</p>
<pre>              LeftParenthesisId, RightParenthesisId, 
              AssignId, CommaId, SemicolonId, </pre>
<p>Finally, the last part is the name, value, and end-of-file marking:</p>
<pre style="padding-left: 60px">              NameId, ValueId, EndOfFileId}; 
 
class Token{ 
  public: 
    Token(); 
    Token(TokenId tokenId); 
    Token(TokenId tokenId, const QString&amp; name); 
    Token(TokenId tokenId, const Value&amp; value); </pre>
<p>Each token can be annotated with a name or a value:</p>
<pre style="padding-left: 60px">    TokenId id() const {return m_tokenId;} 
    const QString&amp; name() const { return m_name; } 
    const Value&amp; value() const { return m_value; } 
 
  private: 
    TokenId m_tokenId; 
    QString m_name; 
    Value m_value; 
}; 
 
#endif // TOKEN_H</pre>
<p>The <kbd>Token.cpp</kbd> file holds the definitions of the methods of the <kbd>Token</kbd> class.</p>
<p><strong>Token.cpp:</strong></p>
<pre style="padding-left: 60px">#include "Token.h" </pre>
<p>The default token is initialized with an end-of-file token:</p>
<pre style="padding-left: 60px">Token::Token() 
 :m_tokenId(EndOfFileId) { 
  // Empty. 
} </pre>
<p>Most tokens hold only a value of the <kbd>TokenId</kbd> enumeration:</p>
<pre style="padding-left: 60px">Token::Token(TokenId tokenId) 
 :m_tokenId(tokenId) { 
  // Empty. 
} </pre>
<p>Tokens can also hold a name or a value:</p>
<pre style="padding-left: 60px">Token::Token(TokenId tokenId, const QString&amp; name) 
 :m_tokenId(tokenId), 
  m_name(name) { 
  // Empty. 
} 
 
Token::Token(TokenId tokenId, const Value&amp; value) 
 :m_tokenId(tokenId), 
  m_value(value) { 
  // Empty. 
} </pre>
<p>The <kbd>Scanner</kbd> class takes the source code and divides it into tokens. A token can also be associated by a name or a value.</p>
<p><strong>Scanner.h:</strong></p>
<pre style="padding-left: 60px">#ifndef SCANNER_H 
#define SCANNER_H 
 
#include "Token.h" 
#include "Colors.h"</pre>
<p>The <kbd>init</kbd> method initializes the names of the keywords and operators:</p>
<pre style="padding-left: 60px">class Scanner { 
  public: 
    static void init(); 
    Scanner(QString&amp; buffer); </pre>
<p>The <kbd>nextToken</kbd> method scans the buffer and returns the next token. If there is no recognizable token, an error exception is thrown that is later caught by the <kbd>main</kbd> function:</p>
<pre style="padding-left: 60px">  public: 
    Token nextToken(); </pre>
<p>The <kbd>m_buffer</kbd> field holds the source code; <kbd>m_bufferIndex</kbd> holds the index of the next character in the buffer to be examined (the index is initialized to zero); <kbd>m_keywordMap</kbd> holds the names of the keywords; <kbd>m_valueMap</kbd> holds a map of color, alignment, and pen and brush style values, and <kbd>m_operatorList</kbd> hold a list of operators:</p>
<pre style="padding-left: 60px">  private: 
    QString m_buffer; 
    int m_bufferIndex = 0; </pre>
<p>In previous chapters, we have used the C++ standard classes <kbd>map</kbd>, <kbd>set</kbd>, <kbd>list</kbd>, <kbd>vector</kbd>, and <kbd>stack</kbd>. In this chapter, we will use the Qt classes <kbd>QMap</kbd>, <kbd>QSet</kbd>, <kbd>QList</kbd>, <kbd>QVector</kbd>, and <kbd>QStack</kbd> instead. They work approximately in the same way:</p>
<pre style="padding-left: 60px">    static QMap&lt;QString,TokenId&gt; m_keywordMap; 
    static QMap&lt;QString,Value&gt; m_valueMap; 
    static QList&lt;pair&lt;QString,TokenId&gt;&gt; m_operatorList; 
}; 
 
#endif // SCANNER_H </pre>
<p>The <kbd>Scanner.cpp</kbd> file holds the definitions of the methods of the <kbd>Scanner</kbd> class.</p>
<p><strong>Scanner.cpp:</strong></p>
<pre style="padding-left: 60px">#include &lt;SStream&gt; 
#include &lt;IOStream&gt; 
#include &lt;Exception&gt; 
using namespace std; 
 
#include "Error.h" 
#include "Scanner.h" 
 
QMap&lt;QString,Value&gt; Scanner::m_valueMap; 
QMap&lt;QString,TokenId&gt; Scanner::m_keywordMap; 
QList&lt;pair&lt;QString, TokenId&gt;&gt; Scanner::m_operatorList; </pre>
<p>The <kbd>g_lineNo</kbd> global field keeps track of the current line in the source code, in order for the error messages to state the line number:</p>
<pre style="padding-left: 60px">extern int g_lineNo; </pre>
<p>The <kbd>ADD_TO_OPERATOR_LIST</kbd> macro adds a token to the operator list. For instance, <kbd>ADD_TO_OPERATOR_LIST("+", AddId)</kbd> adds the pair of <kbd>"+"</kbd> and <kbd>AddId</kbd> to the list:</p>
<pre style="padding-left: 60px">#define ADD_TO_OPERATOR_LIST(text, token)                      
  m_operatorList.push_back(pair&lt;QString,TokenId&gt;(text, token)); 
 
void Scanner::init() { 
  ADD_TO_OPERATOR_LIST("+", AddId) 
  ADD_TO_OPERATOR_LIST("-", SubtractId) 
  ADD_TO_OPERATOR_LIST("*", MultiplyId) 
  ADD_TO_OPERATOR_LIST("/", DivideId) 
  ADD_TO_OPERATOR_LIST("(", LeftParenthesisId) 
  ADD_TO_OPERATOR_LIST(")", RightParenthesisId) 
  ADD_TO_OPERATOR_LIST("=", AssignId) 
  ADD_TO_OPERATOR_LIST(",", CommaId) 
  ADD_TO_OPERATOR_LIST(";", SemicolonId) </pre>
<p>The <kbd>ADD_TO_KEYWORD_MAP</kbd> macro adds a keyword to the keyword map. For instance, <kbd>ADD_TO_KEYWORD_MAP(ColorId)</kbd> adds the pair of <kbd>Color</kbd> and <kbd>ColorId</kbd> to the map. Note that the <kbd>Id</kbd> part of the keyword (the last two characters) text is removed:</p>
<pre style="padding-left: 60px">#define ADD_TO_KEYWORD_MAP(x) {                        
  QString s(#x);                                       
  m_keywordMap[s.toLower().left(s.length() - 2)] = x; } 
 
  ADD_TO_KEYWORD_MAP(ColorId) 
  ADD_TO_KEYWORD_MAP(DrawEllipseId) 
  ADD_TO_KEYWORD_MAP(DrawLineId) 
  ADD_TO_KEYWORD_MAP(DrawRectangleId) 
  ADD_TO_KEYWORD_MAP(DrawTextId) 
  ADD_TO_KEYWORD_MAP(FontId) 
  ADD_TO_KEYWORD_MAP(PointId) 
  ADD_TO_KEYWORD_MAP(SetBrushColorId) 
  ADD_TO_KEYWORD_MAP(SetBrushStyleId) 
  ADD_TO_KEYWORD_MAP(SetFontId) 
  ADD_TO_KEYWORD_MAP(SetHorizontalAlignmentId) 
  ADD_TO_KEYWORD_MAP(SetPenColorId) 
  ADD_TO_KEYWORD_MAP(SetPenStyleId) 
  ADD_TO_KEYWORD_MAP(SetVerticalAlignmentId) 
  ADD_TO_KEYWORD_MAP(XCoordinateId) 
  ADD_TO_KEYWORD_MAP(YCoordinateId) </pre>
<p>The <kbd>ADD_TO_VALUE_MAP</kbd> macro adds a value to the value map. For instance, <kbd>ADD_TO_VALUE_MAP(Aqua)</kbd> adds the pair of aqua and the <kbd>QColor</kbd> object Aqua to the map. Note that the text is converted to lower case. Also note that only the last part after the last potential pair of colons (<kbd>::</kbd>) is included:</p>
<pre style="padding-left: 60px">#define ADD_TO_VALUE_MAP(x) {                           
  QString s(#x);                                        
  QString t = s.toLower();                              
  int i = t.lastIndexOf("::");                          
  m_valueMap[(i == -1) ? t : t.mid(i + 2)] = Value(x); } </pre>
<p><kbd>ADD_TO_VALUE_MAP(Qt::AlignLeft)</kbd> adds the pair of align left and the <kbd>Qt::PenStyle</kbd> value to the map. Again, note that only the last segment of the value's name is stored as text:</p>
<pre style="padding-left: 60px">  ADD_TO_VALUE_MAP(Qt::AlignLeft) 
  ADD_TO_VALUE_MAP(Qt::AlignTop) 
 
  ADD_TO_VALUE_MAP(Qt::PenStyle::NoPen) 
  ADD_TO_VALUE_MAP(Qt::PenStyle::SolidLine) 
 
  ADD_TO_VALUE_MAP(Qt::BrushStyle::NoBrush) 
  ADD_TO_VALUE_MAP(Qt::BrushStyle::SolidPattern) 
 
  ADD_TO_VALUE_MAP(Aqua) 
  ADD_TO_VALUE_MAP(Black) 
} </pre>
<p>In the constructor, we load the buffer into the <kbd>m_buffer</kbd> field. We also add the null-character (<kbd>''</kbd>) in order to find the end of the buffer in an easier way:</p>
<pre style="padding-left: 60px">Scanner::Scanner(QString&amp; buffer) 
 :m_buffer(buffer) { 
  m_buffer.append(''); 
} </pre>
<p>The <kbd>nextToken</kbd> method scans the buffer and returns the token found. First, we iterate as long as we find new-line, white-space, or line comment. In case of a new line, we increase the line count:</p>
<pre style="padding-left: 60px">Token Scanner::nextToken() { 
  while (true) { 
    if (m_buffer[m_bufferIndex] == 'n') { 
      ++g_lineNo; 
      ++m_bufferIndex; 
    } </pre>
<p>A white-space is regular space, a horizontal or vertical tabulator, a return character, or new line. We use the <kbd>isSpace</kbd> method to check whether the character is a white-space:</p>
<pre style="padding-left: 60px">    else if (m_buffer[m_bufferIndex].isSpace()) { 
      ++m_bufferIndex; 
    } </pre>
<p>If we encounter the beginning of a line comment (<kbd>//</kbd>), we continue until we find the end of the line (<kbd>'n'</kbd>) or the end of the buffer (<kbd>''</kbd>):</p>
<pre style="padding-left: 60px">    else if (m_buffer.indexOf("//", m_bufferIndex) == 
             m_bufferIndex) { 
      while ((m_buffer[m_bufferIndex] != QChar('n')) &amp;&amp; 
             (m_buffer[m_bufferIndex] != QChar(''))) { 
        ++m_bufferIndex; 
      } 
    } </pre>
<p>If we do not find a new line, white-space, or line comment, we break the iteration and continue looking for the next token:</p>
<pre style="padding-left: 60px">    else { 
      break; 
    } 
  } </pre>
<p>When we have scanned through the potential white-spaces and comments, we start looking for the real tokens. We start by checking if the next character in the buffer is a null character (<kbd>''</kbd>). If it is a null character, we have found the end of the source code and return end-of-file. Remember that we added a null character at the end of the buffer in the constructor, just to be able to recognize the end of the file:</p>
<pre style="padding-left: 60px">  if (m_buffer[m_bufferIndex] == QChar('')) { 
    return Token(EndOfFileId); 
  } </pre>
<p>If the next token is not end-of-file, we check if it is an operator. We iterate through the operator list and check if the buffer begins with any of the operator's text. For instance, the add operator holds the text <kbd>+</kbd>:</p>
<pre style="padding-left: 60px">  for (const pair&lt;QString,TokenId&gt;&amp; pair : m_operatorList) { 
    const QString&amp; operatorText = pair.first; 
    TokenId tokenId = pair.second;</pre>
<p>When we have found the operator, we increment the buffer index, and return the token:</p>
<pre style="padding-left: 60px">    if (m_buffer.indexOf(operatorText, m_bufferIndex) == 
        m_bufferIndex) { 
      m_bufferIndex += operatorText.length(); 
      return Token(tokenId); 
    } 
  } </pre>
<p>If the buffer does not begin with an operator, we look after a name representing a keyword, a value, or simply a name. We start by checking if the buffer begins with a letter or the underscore character (<kbd>'_'</kbd>), since a name is allowed to start with a letter or an underscore. However, the remaining characters can be digits besides the letters and underscores:</p>
<pre style="padding-left: 60px">  if (m_buffer[m_bufferIndex].isLetter() || 
      (m_buffer[m_bufferIndex] == '_')) { 
    int index = m_bufferIndex; </pre>
<p>We iterate until we find a character that is not a letter, digit, or underscore:</p>
<pre style="padding-left: 60px">    while (m_buffer[index].isLetterOrNumber() || 
           (m_buffer[index] == '_')) { 
      ++index; 
    } </pre>
<p>We extract the text and increase the buffer index:</p>
<pre style="padding-left: 60px">    int size = index - m_bufferIndex; 
    QString text = m_buffer.mid(m_bufferIndex, size).toLower(); 
    m_bufferIndex += size; </pre>
<p>The text can hold a keyword, a value, or a name. First, we check whether the text is present in the keyword map. If it is present, we just return the token associated with the keyword text:</p>
<pre style="padding-left: 60px">    if (m_keywordMap.contains(text)) { 
      return Token(m_keywordMap[text]); 
    } </pre>
<p>We then check whether the text is present in the value map. If it is present, we return a value token with the value annotated to the token. The value can later be obtained by the parser:</p>
<pre style="padding-left: 60px">    else if (m_valueMap.contains(text)) { 
      return Token(ValueId, m_valueMap[text]); 
    }</pre>
<p>If the text is neither a keyword nor a value, we assume that it is a name and return a name token with the name annotated to the token. The name can later be obtained by the parser:</p>
<pre style="padding-left: 60px">    else { 
      return Token(NameId, text); 
    } 
  } </pre>
<p>When we have looked for a name without finding it, we start looking for a string instead. A string is a text enclosed by double quotes (<kbd>'"'</kbd>). If the next character in the buffer is a double quote, it is the beginning of a text. We remove the double quote from the buffer and iterate until we find the end quote of the text:</p>
<pre style="padding-left: 60px">  if (m_buffer[m_bufferIndex] == '"') { 
    int index = m_bufferIndex + 1; 
 
    while (m_buffer[index] != '"') { </pre>
<p>If we find a null character before the end of the text, a syntax error is reported since we have found the end of the file inside the text:</p>
<pre style="padding-left: 60px">      if (m_buffer[index] == QChar('')) { 
        syntaxError("unfinished string"); 
      } 
 
      ++index; 
    } </pre>
<p>When we have found the end quote, we increase the buffer index and return a value token with the text as its annotated value. The text can later be obtained by the parser:</p>
<pre style="padding-left: 60px">    int size = index - m_bufferIndex + 1; 
    QString text = m_buffer.mid(m_bufferIndex, size); 
    m_bufferIndex += size; 
    return Token(ValueId, Value(text)); 
  } </pre>
<p>If the next character in the buffer is a digit, we have found a numerical value, with or without decimals. First, we iterate as long as we find digits in the buffer:</p>
<pre style="padding-left: 60px">  if (m_buffer[m_bufferIndex].isDigit()) { 
    int index = m_bufferIndex; 
     
    while (m_buffer[index].isDigit()) { 
      ++index; 
    }</pre>
<p>When we no longer find any digits, we check whether the next character in the buffer is a dot (<kbd>'.'</kbd>). If it is a dot, we continue to iterate as long as we find digits:</p>
<pre style="padding-left: 60px">    if (m_buffer[index] == '.') { 
      ++index; 
 
      while (m_buffer[index].isDigit()) { 
        ++index; 
      } 
    } </pre>
<p>When we no longer find any digits, we increase the buffer index and return a value token with the annotated value. The value can later be obtained by the parser:</p>
<pre style="padding-left: 60px">    int size = index - m_bufferIndex; 
    QString text = m_buffer.mid(m_bufferIndex, size); 
    m_bufferIndex += size; 
    return Token(ValueId, Value(text.toDouble())); 
  } </pre>
<p>Finally, if none of the preceding cases apply, the source code is syntactically incorrect, and we report a syntax error:</p>
<pre style="padding-left: 60px">  syntaxError(); </pre>
<p>We return an end-of-file token, simply because we have to return a value. However, we will never reach this point of the code since the <kbd>syntaxError</kbd> call caused an exception to be thrown:</p>
<pre style="padding-left: 60px">  return Token(EndOfFileId); 
} </pre>
<p>Now that we have looked at the scanner, we will continue to look at the parser in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the parser</h1>
                </header>
            
            <article>
                
<p>Now that we have looked into the scanner, it is time to move on to the parser. The parser checks that the source code complies with the grammar. It also performs type checking and generates the action list, which is later displayed by the viewer, as follows. The <kbd>Parser</kbd> class mirrors the grammar in that way the it holds one method for each grammar rule.</p>
<p><strong>Parser.h:</strong></p>
<pre style="padding-left: 60px">#ifndef PARSER_H 
#define PARSER_H 
 
#include "Action.h" 
#include "Scanner.h" </pre>
<p>The constructor takes a grammar object and the action list, which is empty at the beginning. The parser calls the scanner each time it needs a new token:</p>
<pre style="padding-left: 60px">class Parser { 
  public: 
    Parser(Scanner&amp; m_scanner, QList&lt;Action&gt;&amp; actionList); </pre>
<p>The <kbd>match</kbd> method checks whether the given token equals the next token obtained by the scanner. If it does not, a syntax error is reported:</p>
<pre style="padding-left: 60px">  private: 
    void match(TokenId tokenId); </pre>
<p>The remaining methods of the <kbd>Parser</kbd> class are divided into methods for instructions and expressions in the grammar, as well as methods for type checking and evaluation of expressions:</p>
<pre style="padding-left: 60px">    void instructionList(); 
    void instruction(); </pre>
<p>We also add a method to the parser for each expression rule in the grammar:</p>
<pre style="padding-left: 60px">    Value expression(); 
    Value expressionRest(Value leftValue); 
    Value mulDivExpression(); 
    Value mulDivExpressionRest(Value leftValue); 
    Value primaryExpression(); 
    Value primaryExpression(); </pre>
<p>When evaluating the values of expressions, we need to check the types of the values. For instance, when adding two values, both of the operands shall have numerical values:</p>
<pre style="padding-left: 60px">    void checkType(TokenId operatorId, const Value&amp; value); 
    void checkType(TokenId operatorId, const Value&amp; leftValue, 
                   const Value&amp; rightValue); 
    Value evaluate(TokenId operatorId, const Value&amp; value); 
    Value evaluate(TokenId operatorId, const Value&amp; leftValue, 
                   const Value&amp; rightValue);</pre>
<p>The <kbd>m_lookAhead</kbd> field holds the next token obtained by the scanner, and <kbd>m_scanner</kbd> holds the scanner itself. The <kbd>m_actionList</kbd> field holds a reference to the action list given in the constructor. Finally, <kbd>m_assignMap</kbd> holds a map for the names assigned to values by the assignment rule:</p>
<pre style="padding-left: 60px">  private: 
    Token m_lookAHead; 
    Scanner&amp; m_scanner; 
    QList&lt;Action&gt;&amp; m_actionList; 
    QMap&lt;QString,Value&gt; m_assignMap;                                                                                                                                                                                                            }; 
 
#endif // PARSER_H </pre>
<p>The <kbd>Parser.cpp</kbd> file holds the definitions of the methods of the <kbd>Parser</kbd> class.</p>
<p><strong>Parser.cpp:</strong></p>
<pre style="padding-left: 60px">#include &lt;CAssert&gt; 
using namespace std; 
 
#include "Value.h" 
#include "Token.h" 
#include "Scanner.h" 
#include "Parser.h" 
#include "Error.h" </pre>
<p>The constructor initializes the references to the scanner and the action list, and sets the <kbd>m_lookAHead</kbd> field to the first token obtained by the scanner. Then the parsing process begins by calling <kbd>instructionList</kbd>. When the instruction list has been parsed, the only remaining token shall be the end-of-file token:</p>
<pre style="padding-left: 60px">Parser::Parser(Scanner&amp; m_scanner, QList&lt;Action&gt;&amp; actionList) 
 :m_scanner(m_scanner), 
  m_actionList(actionList) { 
  m_lookAHead = m_scanner.nextToken(); 
  instructionList(); 
  match(EndOfFileId); 
} </pre>
<p>The <kbd>g_lineNo</kbd> field keeps track of the current line of the source code so that a syntax error can be reported with the correct line number:</p>
<pre style="padding-left: 60px">extern int g_lineNo;</pre>
<p>The <kbd>instructionList</kbd> method keeps iterating until it encounters the end-of-file token:</p>
<pre style="padding-left: 60px">void Parser::instructionList() { 
  while (m_lookAHead.id() != EndOfFileId) { 
    instruction(); 
  } 
} </pre>
<p>The <kbd>match</kbd> method compares the next token obtained by the scanner with the given token. If they do not comply, a syntax error is reported. If they do comply, the next token is obtained by the scanner:</p>
<pre style="padding-left: 60px">void Parser::match(TokenId tokenId) { 
  if (m_lookAHead.id() != tokenId) { 
    syntaxError(); 
  } 
 
  m_lookAHead = m_scanner.nextToken(); 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parsing the instructions of the language</h1>
                </header>
            
            <article>
                
<p>The <kbd>instruction</kbd> method holds a sequence of switch cases, one case for each category of instructions. We will look into the next token obtained by the scanner:</p>
<pre style="padding-left: 60px">void Parser::instruction() { 
  TokenId tokenId = m_lookAHead.id(); </pre>
<p>In the case of a name, we parse the name, assignment (<kbd>=</kbd>), the following expression, and a semicolon:</p>
<pre style="padding-left: 60px">  switch (tokenId) { 
    case NameId: { 
        QString assignName = m_lookAHead.name(); 
        match(NameId); 
        match(AssignId); 
        Value assignValue = expression(); 
        match(SemicolonId); </pre>
<p>If the name is already associated with a value, a semantic error is reported:</p>
<pre style="padding-left: 60px">        check(!m_assignMap.contains(assignName), 
              "the name "" + assignName + "" defined twiced"); 
        m_assignMap[assignName] = assignValue; 
      } 
      break;</pre>
<p>The settings of pen and brush colors and styles, as well as fonts and alignments, are a little bit more complicated. We call <kbd>expression</kbd> to parse and evaluate the value of an expression. The type of the expression is checked, and an <kbd>Action</kbd> object is added to the action list:</p>
<pre style="padding-left: 60px">    case SetPenColorId: 
    case SetPenStyleId: 
    case SetBrushColorId: 
    case SetBrushStyleId: 
    case SetFontId: 
    case SetHorizontalAlignmentId: 
    case SetVerticalAlignmentId: { 
        match(tokenId); 
        match(LeftParenthesisId); 
        Value value = expression(); 
        match(RightParenthesisId); 
        match(SemicolonId); 
        checkType(tokenId, value); 
        m_actionList.push_back(Action(tokenId, value)); 
      } 
      break; </pre>
<p>The drawing of lines, rectangles, ellipses, and text takes two expressions, whose values are evaluated and type checked:</p>
<pre style="padding-left: 60px">    case DrawLineId: 
    case DrawRectangleId: 
    case DrawEllipseId: 
    case DrawTextId: { 
        match(tokenId); 
        match(LeftParenthesisId); 
        Value firstValue = expression(); 
        match(CommaId); 
        Value secondValue = expression(); 
        match(RightParenthesisId); 
        match(SemicolonId); 
        checkType(tokenId, firstValue, secondValue); 
        m_actionList.push_back(Action(tokenId, firstValue, 
                                      secondValue)); 
      } 
      break; </pre>
<p>If none of the preceding tokens apply, a syntax error is reported:</p>
<pre style="padding-left: 60px">    default: 
      syntaxError(); 
  } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parsing the expressions of the language</h1>
                </header>
            
            <article>
                
<p>An expression, at its lowest priority level, is made up by two multiplication or division expressions. First, we call <kbd>mulDivExpression</kbd>, which is the next expression in increasing priority order, to obtain the left value of a possible addition or subtraction expression, and then <kbd>expressionRest</kbd>, which checks if there actually is such an expression:</p>
<pre style="padding-left: 60px">Value Parser::expression() { 
  Value leftValue = mulDivExpression (); 
  return expressionRest(leftValue); 
} </pre>
<p>The <kbd>expressionRest</kbd> method checks whether the next token is a plus or a minus. In that case, we have an addition or subtraction expression, the token is matched, the left and right values are type checked, and the resulting expression is evaluated and returned:</p>
<pre style="padding-left: 60px">Value Parser::expressionRest(Value leftValue) { 
  TokenId tokenId = m_lookAHead.id(); 
 
  switch (tokenId) { 
    case AddId: 
    case SubtractId: { 
        match(tokenId); 
        Value rightValue = mulDivExpression(); 
        check(leftValue.isNumerical() &amp;&amp; rightValue.isNumerical(), 
              "non-numerical values in arithmetic expression"); 
        Value resultValue = 
          evaluate(tokenId, leftValue, rightValue); 
        return expressionRest(resultValue); 
      } 
 
    default: 
      return leftValue; 
  } 
}</pre>
<p>The <kbd>mulDivExpression</kbd> method works in a way similar to <kbd>expression</kbd> shown previously. It calls <kbd>primaryExpression</kbd> and <kbd>mulDivExpressionRest</kbd>, which look for multiplication and division. Multiplication and division have higher priority than addition and subtraction. As stated in <em>The grammar of source language</em> section previously, we need a new pair of rules in the grammar, with two pairs of methods in the parser for the addition/subtraction and multiplication/division expressions:</p>
<pre style="padding-left: 60px">Value Parser::mulDivExpression() { 
  Value leftValue = primaryExpression(); 
  return mulDivExpressionRest(leftValue); 
} 
 
Value Parser::mulDivExpressionRest(Value leftValue) { 
  TokenId tokenId = m_lookAHead.id(); 
 
  switch (tokenId) { 
    case MultiplyId: 
    case DivideId: { 
        match(tokenId); 
        Value rightValue = primaryExpression(); 
        check(leftValue.isNumerical() &amp;&amp; rightValue.isNumerical(), 
              "non-numerical values in arithmetic expression"); 
        Value resultValue = 
          evaluate(tokenId, leftValue, rightValue); 
        return mulDivExpressionRest (resultValue); 
      } 
 
    default: 
      return leftValue; 
  } 
} </pre>
<p>Finally, the primary expression is made up by a point, coordinate, color, or font expression. It can also be made up by an expression enclosed in parentheses, a name (in which case we look up its value), or a value:</p>
<pre style="padding-left: 60px">Value Parser::primaryExpression() { 
  TokenId tokenId = m_lookAHead.id(); </pre>
<p>The coordinate expression takes a point and returns its x or y coordinate. We match the keyword and the parentheses and call expressions in between. We then check that the value of the expression is a point, and finally call <kbd>evaluate</kbd> to extract the <em>x</em> or <em>y</em> coordinate:</p>
<pre style="padding-left: 60px">  switch (tokenId) { 
    case XCoordinateId: 
    case YCoordinateId: { 
        match(tokenId); 
        match(LeftParenthesisId); 
        Value value = expression(); 
        match(RightParenthesisId); 
        check(value.isPoint(), 
              "not a point in coordinate expression"); 
        checkType(tokenId, value); 
        return evaluate(tokenId, value); 
      } 
      break; </pre>
<p>A point expression is made up by the keyword <kbd>point</kbd> and two numerical expressions: the <em>x</em> and <em>y</em> coordinate:</p>
<pre style="padding-left: 60px">    case PointId: { 
        match(PointId); 
        match(LeftParenthesisId); 
        Value xValue = expression(); 
        match(CommaId); 
        Value yValue = expression(); 
        match(RightParenthesisId); 
        check(xValue.isNumerical() &amp;&amp; yValue.isNumerical(), 
              "non-numerical values in point expression"); 
        return Value(QPoint(xValue.numericalValue(), 
                            yValue.numericalValue())); 
    } </pre>
<p>A color expression is made up by the keyword <kbd>color</kbd> and three numerical expressions: the red, green, and blue components:</p>
<pre style="padding-left: 60px">    case ColorId: { 
        match(ColorId); 
        match(LeftParenthesisId); 
        Value redValue = expression(); 
        match(CommaId); 
        Value greenValue = expression(); 
        match(CommaId); 
        Value blueValue = expression(); 
        match(RightParenthesisId); 
        check(redValue.isNumerical() &amp;&amp; greenValue.isNumerical() 
              &amp;&amp; blueValue.isNumerical(), 
              "non-numerical values in color expression"); 
        return Value(QColor(redValue.numericalValue(), 
                            greenValue.numericalValue(), 
                            blueValue.numericalValue())); 
      } </pre>
<p>A font expression is made up by the keyword <kbd>font</kbd> and two expressions: the name of the font (string) and its size (numerical):</p>
<pre style="padding-left: 60px">    case FontId: { 
        match(FontId); 
        match(LeftParenthesisId); 
        Value nameValue = expression(); 
        match(CommaId); 
        Value sizeValue = expression(); 
        match(RightParenthesisId); 
        check(nameValue.isString() &amp;&amp; sizeValue.isNumerical(), 
              "invalid types in font expression"); 
        return Value(QFont(nameValue.stringValue(), 
                           sizeValue.numericalValue())); 
      } </pre>
<p>An expression can be enclosed by parentheses. In that case, we match the parentheses and call <kbd>expression</kbd> in between to obtain the value of the expression:</p>
<pre style="padding-left: 60px">    case LeftParenthesisId: { 
        match(LeftParenthesisId); 
        Value value = expression(); 
        match(RightParenthesisId); 
        return value; 
      } </pre>
<p>In case of a name, we look up its value in the assignment map and return the value. If there is no value, a semantic error is reported:</p>
<pre style="padding-left: 60px">    case NameId: { 
        QString lookupName = m_lookAHead.name(); 
        match(NameId); 
        check(m_assignMap.contains(lookupName ), 
              "unknown name: "" + lookupName + ""."); 
        return m_assignMap[lookupName ]; 
      } </pre>
<p>In the case of a value, we simply return the value:</p>
<pre style="padding-left: 60px">    case ValueId: { 
        Value value = m_lookAHead.value(); 
        match(ValueId); 
        return value; 
      } </pre>
<p>In any other case, a syntax error is reported:</p>
<pre style="padding-left: 60px">    default: 
      syntaxError(); 
      return Value(); 
  } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type checking the expression</h1>
                </header>
            
            <article>
                
<p>The first <kbd>checkType</kbd> method checks the type of an expression with one value. When setting a pen or brush style, the type must be a pen or brush style, respectively:</p>
<pre style="padding-left: 60px">void Parser::checkType(TokenId codeId, const Value&amp; value) { 
  switch (codeId) { 
    case SetPenStyleId: 
      check(value.isPenStyle(), "not a pen-style value"); 
      break; 
 
    case SetBrushStyleId: 
      check(value.isBrushStyle(), "not a brush-style value"); 
      break; </pre>
<p>When setting a color or a font, the value must be a color or a font, respectively:</p>
<pre style="padding-left: 60px">    case SetPenColorId: 
    case SetBrushColorId: 
      check(value.isColor(), "not a color value"); 
      break; 
 
    case SetFontId: 
      check(value.isFont(), "not a font value"); 
      break; </pre>
<p>When setting an alignment, the value must be an alignment:</p>
<pre style="padding-left: 60px">    case SetHorizontalAlignmentId: 
    case SetVerticalAlignmentId: 
      check(value.isAlignment(), "not an alignment value"); 
      break; </pre>
<p>When extracting the <em>x</em> or <em>y</em> coordinate from a point, the value must be a point:</p>
<pre style="padding-left: 60px">    case XCoordinateId: 
    case YCoordinateId: 
      check(value.isPoint(), "not a point value"); 
      break; 
  } 
} </pre>
<p>The second <kbd>checkType</kbd> method takes two values. The drawing instructions must take two points:</p>
<pre style="padding-left: 60px">void Parser::checkType(TokenId codeId, const Value&amp; leftValue, 
                       const Value&amp; rightValue) { 
  switch (codeId) { 
    case DrawLineId: 
    case DrawRectangleId: 
    case DrawEllipseId: 
      check(leftValue.isPoint() &amp;&amp; rightValue.isPoint(), 
            "non-point values in draw expression"); 
      break; </pre>
<p>The drawing of text instructions must take a point and a string:</p>
<pre style="padding-left: 60px">    case DrawTextId: 
      check(leftValue.isPoint() &amp;&amp; rightValue.isString(), 
            "invalid values in text-drawing expression"); 
      break; 
  } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Evaluating the values of the expressions</h1>
                </header>
            
            <article>
                
<p>The first <kbd>evaluate</kbd> method returns the value of an expression with one value. The <em>x</em> and <em>y</em> coordinate operators return the <em>x</em> or <em>y</em> coordinate of the point:</p>
<pre style="padding-left: 60px">Value Parser::evaluate(TokenId codeId, const Value&amp; value) { 
  switch (codeId) { 
    case XCoordinateId: 
      return Value((double) value.pointValue().x()); 
 
    case YCoordinateId: 
      return Value((double) value.pointValue().y()); </pre>
<p>The assertion is for debugging purposes only, and we return false simply because the method has to return a value:</p>
<pre style="padding-left: 60px">    default: 
      assert(false); 
      return false; 
  } 
} </pre>
<p>Finally, the second <kbd>evaluate</kbd> method evaluates the value of expressions with two values. First, we extract numerical values and evaluate the arithmetic expressions:</p>
<pre style="padding-left: 60px">Value Parser::evaluate(TokenId codeId, const Value&amp; leftValue, 
                          const Value&amp; rightValue) { 
  double leftNumericalValue = leftValue.numericalValue(), 
         rightNumericalValue = rightValue.numericalValue(); 
 
  switch (codeId) { 
    case AddId: 
      return Value(leftNumericalValue + rightNumericalValue); 
 
    case SubtractId: 
      return Value(leftNumericalValue - rightNumericalValue); 
 
    case MultiplyId: 
      return Value(leftNumericalValue * rightNumericalValue); </pre>
<p>In case of division by zero, a semantic error is reported:</p>
<pre style="padding-left: 60px">    case DivideId: 
      if (rightNumericalValue == 0) { 
        semanticError("division by zero"); 
      } 
 
      return Value(leftNumericalValue / rightNumericalValue); </pre>
<p>Finally, in the point expression, we return a point value holding the two numerical values holding its <em>x</em> and <em>y</em> coordinates:</p>
<pre style="padding-left: 60px">    case PointId: 
      return Value(QPoint(leftNumericalValue, 
                          rightNumericalValue)); </pre>
<p>As in the first evaluate case previously, the assertion is for debugging purposes only, and we return false simply because the method has to return a value:</p>
<pre style="padding-left: 60px">    default: 
      assert(false); 
      return Value(); 
  } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The viewer</h1>
                </header>
            
            <article>
                
<p>Finally, it is time to write the viewer, the last part of our DSL. The viewer iterates through the actions and displays the graphical objects. The <kbd>ViewerWidget</kbd> class inherits the Qt class <kbd>QWidget</kbd>, which displays a widget on the screen.</p>
<p><strong>ViewerWidget.h:</strong></p>
<pre style="padding-left: 60px">#ifndef MAINWIDGET_H 
#define MAINWIDGET_H 
 
#include &lt;QWidget&gt; 
#include &lt;QtWidgets&gt; 
#include "Value.h" 
#include "Colors.h" 
#include "Action.h" 
 
class ViewerWidget : public QWidget { 
  Q_OBJECT </pre>
<p>The constructor calls the constructor of the base class <kbd>QWidget</kbd> and stores a reference to the action list:</p>
<pre style="padding-left: 60px">  public: 
    ViewerWidget(const QList&lt;Action&gt;&amp; actionList, 
                 QWidget *parentWidget = nullptr); </pre>
<p>The main part of the class is the <kbd>paintEvent</kbd> method. It gets called every time the widget needs to be repainted and iterates through the actions list:</p>
<pre style="padding-left: 60px">    void paintEvent(QPaintEvent *eventPtr); </pre>
<p>The default constructor of <kbd>QFont</kbd> is called, which initializes the font to an appropriate system font. Both the horizontal and vertical alignment is centered. Finally, <kbd>m_actionList</kbd> holds a reference to the action list generated by the parser:</p>
<pre style="padding-left: 60px">  private: 
    Qt::Alignment m_horizontalAlignment = Qt::AlignHCenter, 
                  m_verticalAlignment = Qt::AlignVCenter; 
    const QList&lt;Action&gt;&amp; m_actionList; 
}; 
 
#endif // MAINWIDGET_H </pre>
<p>The <kbd>ViewerWidget.cpp</kbd> file holds the definitions of the methods of the <kbd>ViewerWidget</kbd> class.</p>
<p><strong>ViewerWidget.cpp:</strong></p>
<pre style="padding-left: 60px">#include &lt;QtWidgets&gt; 
#include "ViewerWidget.h" </pre>
<p>The constructor calls the constructor of the base class <kbd>QWidget</kbd> with the parent widget, initializes the <kbd>m_actionList</kbd> reference, sets the title of the widget, and sets an appropriate size:</p>
<pre style="padding-left: 60px">ViewerWidget::ViewerWidget(const QList&lt;Action&gt;&amp; actionList, 
                           QWidget *parentWidget) 
 :QWidget(parentWidget), 
  m_actionList(actionList) { 
  setWindowTitle(tr("Domain Specific Language")); 
  resize(500, 300); 
} </pre>
<p>The <kbd>paintEvent</kbd> method is called every time the widget needs to be repainted. First, the <kbd>QPainter</kbd> object <kbd>painter</kbd> is defined, we then iterate through the action list:</p>
<pre style="padding-left: 60px">void ViewerWidget::paintEvent(QPaintEvent* /*event*/) { 
  QPainter painter(this); 
 
  for (const Action&amp; action : m_actionList) { 
    switch (action.id()) { </pre>
<p>The <kbd>SetPenColor</kbd> action creates a new pen with the new color and current style, which is added to <kbd>painter</kbd>. In the same way, the <kbd>SetPenStyle</kbd> action creates a pen with the new style and the current color:</p>
<pre style="padding-left: 60px">      case SetPenColorId: { 
          QColor penColor = action.value1().colorValue(); 
          QPen pen(penColor); 
          pen.setStyle(painter.pen().style()); 
          painter.setPen(pen); 
        } 
        break; 
 
      case SetPenStyleId: { 
          Qt::PenStyle penStyle = action.value1().penStyleValue(); 
          QPen pen(penStyle); 
          pen.setColor(painter.pen().color()); 
          painter.setPen(pen); 
        } 
        break; </pre>
<p>We set the color and style of the brush in the same way as we set the pen previously. The only difference is that we create a brush instead of a pen:</p>
<pre style="padding-left: 60px">      case SetBrushColorId: { 
          QColor brushColor = action.value1().colorValue(); 
          QBrush brush(brushColor); 
          brush.setStyle(painter.brush().style()); 
          painter.setBrush(brush); 
        } 
        break; 
 
      case SetBrushStyleId: { 
          Qt::BrushStyle brushStyle = 
            action.value1().brushStyleValue(); 
          QBrush brush(brushStyle); 
          brush.setColor(painter.brush().color()); 
          painter.setBrush(brush); 
        } 
        break; </pre>
<p>In the case of the font, we call <kbd>setFont</kbd> on <kbd>painter</kbd>. Thereafter, the font is associated to <kbd>painter</kbd>, and will be used when writing text:</p>
<pre style="padding-left: 60px">      case SetFontId: { 
          QFont font = action.value1().fontValue(); 
          painter.setFont(font); 
        } 
        break; </pre>
<p>The horizontal and vertical alignment are stored in <kbd>m_horizontalAlignment</kbd> and <kbd>m_verticalAlignment</kbd>, which are values that are later used when writing text:</p>
<pre style="padding-left: 60px">      case SetHorizontalAlignmentId: 
        m_horizontalAlignment = action.value1().alignmentValue(); 
        break; 
 
      case SetVerticalAlignmentId: 
        m_verticalAlignment = action.value1().alignmentValue(); 
        break; </pre>
<p>Now, it is time to actually draw some graphical objects. A line is simply drawn between two points, while a rectangle or ellipse has top-left and bottom-right corners, which are placed in a rectangle that is used as a parameter to the calls to <kbd>drawRect</kbd> and <kbd>drawEllipse</kbd>:</p>
<pre style="padding-left: 60px">      case DrawLineId: 
        painter.drawLine(action.value1().pointValue(), 
                         action.value2().pointValue()); 
        break; 
 
      case DrawRectangleId: { 
          QRect rect(action.value1().pointValue(), 
                     action.value2().pointValue()); 
 
          painter.drawRect(rect); 
        } 
        break; 
 
      case DrawEllipseId: { 
          QRect rect(action.value1().pointValue(), 
                     action.value2().pointValue()); 
 
          painter.drawEllipse(rect); 
        } 
        break; </pre>
<p>Finally, we write text. We start by extracting the point to center the text around and the text to draw. We then obtain the size of the text (in pixels) with the Qt <kbd>QFontMetrics</kbd> class:</p>
<pre style="padding-left: 60px">      case DrawTextId:  { 
          QPoint point = action.value1().pointValue(); 
          const QString&amp; text = action.value2().stringValue(); 
          QFontMetrics metrics(painter.font()); 
          QSize size = metrics.size(0, text); </pre>
<p>In the case of left horizontal alignment, the left side of the text is the <em>x</em> coordinate of the point. In the case of center alignment, the left side of the text is moved to the left with half the text width, and in the case of right alignment, the left side is moved to the left with the whole text width:</p>
<pre style="padding-left: 60px">          switch (m_horizontalAlignment) { 
            case Qt::AlignHCenter: 
              point.rx() -= size.width() / 2; 
              break; 
 
            case Qt::AlignRight: 
              point.rx() -= size.width(); 
              break; 
          } </pre>
<p>In the same way: in the case of top vertical alignment, the top side of the text is the <em>y</em> coordinate of the point. In the case of center alignment, the top side of the text is moved upwards with half of the text height, and in the case of bottom alignment, the top side is moved upwards with the whole text height:</p>
<pre style="padding-left: 60px">          switch (m_verticalAlignment) { 
            case Qt::AlignVCenter: 
              point.ry() -= size.height() / 2; 
              break; 
 
            case Qt::AlignBottom: 
              point.ry() -= size.height(); 
              break; 
          } 
 
          painter.drawText(point, text); 
        } 
        break; 
    } 
  } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The main function</h1>
                </header>
            
            <article>
                
<p>Finally, the main function calls the <kbd>init</kbd> static method on the scanner in order to initialize its tokens, keywords, and values. A <kbd>QApplication</kbd> object is created, the source code is read and parsed, and the viewer widget is created. It executes the action list and displays the graphical objects. The application executes until the user presses the close button in the top-right corner.</p>
<p><strong>Main.cpp:</strong></p>
<pre style="padding-left: 60px">#include &lt;QApplication&gt; 
#include &lt;QMessageBox&gt; 
 
#include "Action.h" 
#include "Error.h" 
#include "Scanner.h" 
#include "Parser.h" 
#include "ViewerWidget.h" 
 
int main(int argc, char *argv[]) { 
  Scanner::init(); 
  QApplication application(argc, argv); 
 
  try { 
    QString path = "C:\Input.dsl"; 
    QFile file(path); 
    if (!file.open(QIODevice::ReadOnly)) { 
      error("Cannot open file "" + path + "" for reading."); 
    } 
 
    QString buffer(file.readAll()); 
    Scanner scanner(buffer); 
 
    QList&lt;Action&gt; actionList; 
    Parser(scanner, actionList); 
 
    ViewerWidget mainWidget(actionList); 
    mainWidget.show(); 
    return application.exec(); 
  } </pre>
<p>In the case of a syntactic or semantic error, its message is displayed in a message box:</p>
<pre style="padding-left: 60px">  catch (exception e) { 
    QMessageBox messageBox(QMessageBox::Information, 
                           QString("Error"), QString(e.what())); 
    messageBox.exec(); 
  } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we started to develop a DSL that generates a sequence of actions creating graphical objects, which are viewed in a widget. Our DSL supports instructions for drawing graphical objects such as lines, rectangles, ellipses, and text, and for setting the color, style, and alignment of the objects. It also supports expressions with arithmetic operators.</p>
<p>The language of our DSL is defined by grammar and is made up by a scanner that scans the text for meaningful parts, the parser checks that the source code complies with the grammar and generates a sequence of actions, which is read and executed by the viewer.</p>
<p>In the next chapter, we will continue to develop our DSL. The DSL of this chapter only supports code executed in straight sequence. However, in the next chapter, we will add function calls as well as selection and iteration (the <kbd>if</kbd> and <kbd>while</kbd> instructions).</p>


            </article>

            
        </section>
    </body></html>