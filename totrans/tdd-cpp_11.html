<html><head></head><body>
		<div id="_idContainer021">
			<h1 id="_idParaDest-108" class="chapter-number" lang="en-GB"><a id="_idTextAnchor113"/><a id="_idTextAnchor114"/>11</h1>
			<h1 id="_idParaDest-109" lang="en-GB"><a id="_idTextAnchor115"/>Managing Dependencies</h1>
			<p lang="en-GB"><a id="_idTextAnchor116"/><a id="_idTextAnchor117"/>Identifying dependencies and implementing your code around common interfaces that the dependencies use will help you in many ways. You’ll be able to do the <span class="No-Break" lang="">following things:</span></p>
			<ul>
				<li lang="en-GB">Avoid waiting for another team or even yourself to finish a complicated and <span class="No-Break" lang="">necessary component</span></li>
				<li lang="en-GB">Isolate your code and make sure it works, even if there are bugs in other code that <span class="No-Break" lang="">you use</span></li>
				<li lang="en-GB">Achieve greater flexibility with your designs so that you can change the behavior by simply changing <span class="No-Break" lang="">dependent components</span></li>
				<li lang="en-GB">Create interfaces that clearly document and highlight <span class="No-Break" lang="">essential requirements</span></li>
			</ul>
			<p lang="en-GB">In this chapter, you’ll learn what dependencies are and how to design your code to use them. By the end of this chapter, you’ll learn how to finish writing your code faster and prove that it works, even if the rest of the project is not ready for <span class="No-Break" lang="">it yet.</span></p>
			<p lang="en-GB">You don’t need to be using TDD to design and use dependencies. But if you are using TDD, then the whole process becomes even better because you’ll also be able to write better tests that can focus on specific areas of code without worrying about extra complexity and bugs coming from outside <span class="No-Break" lang="">the code.</span></p>
			<p lang="en-GB">This chapter will cover the following <span class="No-Break" lang="">main topics:</span></p>
			<ul>
				<li lang="en-GB">Designing <span class="No-Break" lang="">with dependencies</span></li>
				<li lang="en-GB">Adding multiple <span class="No-Break" lang="">logging outputs</span></li>
			</ul>
			<h1 id="_idParaDest-110" lang="en-GB"><a id="_idTextAnchor118"/>Technical requirements</h1>
			<p lang="en-GB">All code in this chapter uses standard C++ that builds on any modern C++ 20 or later compiler and standard library. The code uses the testing library from <em class="italic" lang="">Part 1</em>, <em class="italic" lang="">Testing MVP</em>, of this book and continues the development of a logging library started in the <span class="No-Break" lang="">previous chapters.</span></p>
			<p lang="en-GB">You can find all the code for this chapter in the following <span class="No-Break" lang="">GitHub repository:</span></p>
			<p lang="en-GB"><a href="https://github.com/PacktPublishing/Test-Driven-Development-with-CPP&#13;"><span class="No-Break" lang="">https://github.com/PacktPublishing/Test-Driven-Development-with-CPP</span></a></p>
			<h1 id="_idParaDest-111" lang="en-GB"><a id="_idTextAnchor119"/>Designing with dependencies</h1>
			<p lang="en-GB">Dependencies are not always<a id="_idIndexMarker440"/> obvious. If a project uses a library, such as how the logging project uses the unit test library, then that’s an easy dependency to spot. The logging project depends on the unit test library to function correctly. Or in this case, only the logging tests depend on the unit test library. But that’s enough to form <span class="No-Break" lang="">a dependency.</span></p>
			<p lang="en-GB">Another easy dependency to spot is if you need to call another service. Even if the code checks to see if the other service is available first before making a call, the dependency <span class="No-Break" lang="">still exists.</span></p>
			<p lang="en-GB">Libraries and services are good examples of <em class="italic" lang="">external dependencies</em>. You have to do extra work to get a project to use the code or services of another project, which is why an external dependency is so easy <span class="No-Break" lang="">to spot.</span></p>
			<p lang="en-GB">Other dependencies are harder to spot, and these are usually <em class="italic" lang="">internal dependencies</em> within the project. In a way, almost all the code in a project depends on the rest of the code doing what it’s supposed to do. So let’s refine what we mean by a dependency. Normally, when a dependency is mentioned, as it relates to code design, we refer to something that can <span class="No-Break" lang="">be exchanged.</span></p>
			<p lang="en-GB">This might be easiest to understand with the external service dependency example. The service operates on its own with a well-defined interface. You make a request to a service based on its location or address using the interface that the service defines. You could instead call a different service for the same request if the first service is not available. Ideally, the two services would use the same interface so that the only thing your code needs to change is <span class="No-Break" lang="">the address.</span></p>
			<p lang="en-GB">If the two services use different interfaces, then it might make sense to create a wrapper for each service that knows how to translate between what each service expects and a <em class="italic" lang="">common interface</em> that your code will use. With a common interface, you can swap one service for another without changing your code. Your code depends on the service interface definition more than any <span class="No-Break" lang="">specific service.</span></p>
			<p lang="en-GB">If we look at internal design decisions, maybe there is a base class and a derived class. The derived class definitely depends on the base class, but this is not the type of dependency that can be changed without rewriting the code to use a different <span class="No-Break" lang="">base class.</span></p>
			<p lang="en-GB">We get closer to a dependency that can be swapped when considering the tags that the logging library defines. New tags can be defined and used without changing existing code. And the logging library can use any tag without worrying about what each tag does. But are we really <a id="_idIndexMarker441"/>swapping out tags? To me, the tags were designed to solve the problem of logging key=value elements in the log file in a consistent manner that does not depend on the data type of the value. Even though the logging library depends on tags and the interface they use, I wouldn’t classify the tag design as the same type of dependency as the <span class="No-Break" lang="">external service.</span></p>
			<p lang="en-GB">I mentioned early on when thinking about the logging library that we will need the ability to send the log information to different destinations, or maybe even multiple destinations. The code uses the <strong class="source-inline" lang="">log</strong> function and expects it to either be ignored or to go somewhere. The ability to send a log message to a specific destination is a dependency that the logging library needs to rely on. The logging library should let the project doing the logging decide on <span class="No-Break" lang="">the destination.</span></p>
			<p lang="en-GB">And this brings us to another aspect of dependencies. A dependency is often something that is configured. What I mean is that we can say that the logging library depends on some component to perform the task of sending a message to a destination. The logging library can be designed to choose its own destination, or the logging library can be told what dependency to use. When we let other code control the dependencies, we get something called <em class="italic" lang="">dependency injection</em>. You get <a id="_idIndexMarker442"/>a more flexible solution when you let the calling code <span class="No-Break" lang="">inject dependencies.</span></p>
			<p lang="en-GB">Here’s some initial code that I put into the <strong class="source-inline" lang="">main</strong> function to configure a component that knows how to send log messages to a file and then inject the file component into the logger so that the logger will know where to send the <span class="No-Break" lang="">log messages:</span></p>
			<pre class="source-code" lang="en-GB">
int main ()
{
    MereMemo::FileOutput appFile("application.log");
    appFile.maxSize() = 10'000'000;
    appFile.rolloverCount() = 5;
    MereMemo::addLogOutput(appFile);
    MereMemo::addDefaultTag(info);
    MereMemo::addDefaultTag(green);
    return MereTDD::runTests(std::cout);
}</pre>
			<p lang="en-GB">The idea is to create a class called <strong class="source-inline" lang="">FileOutput</strong> and give it the name of the file to write log messages. Because we don’t want log files to get too big, we should be able to specify a maximum size. The code uses 10 million bytes for the maximum size. What do we do when a log file reaches the maximum size? We should stop writing to that file and create a new file. We should be able to specify how many log files to create before we start deleting old log files. The code sets the maximum number of log files <span class="No-Break" lang="">to five.</span></p>
			<p lang="en-GB">Once the <strong class="source-inline" lang="">FileOutput</strong> instance is created and configured the way we want, it is injected into the logging library by calling the <span class="No-Break" lang=""><strong class="source-inline" lang="">addLogOutput</strong></span><span class="No-Break" lang=""> function.</span></p>
			<p lang="en-GB">Will this code meet our<a id="_idIndexMarker443"/> needs? Is it intuitive and easy to understand? Even though this is not a test, we’re still following TDD by concentrating on the usage of a new feature before writing the code to implement the <span class="No-Break" lang="">new feature.</span></p>
			<p lang="en-GB">As for meeting our needs, that’s not really the right question to ask. We need to ask if it will meet the needs of our target customer. We’re designing the logging library to be used by a micro-services developer. There might be hundreds of services running on a server computer and we really should place the log files in a specific location. The first change we’ll need is to let the caller specify a path where the log files should be created. The path seems like it should be separate from <span class="No-Break" lang="">the filename.</span></p>
			<p lang="en-GB">And for the filenames, how will we name multiple log files? They can’t all be called <strong class="source-inline" lang="">application.log</strong>. Should the files be numbered? They will all be placed in the same directory and the only requirement that the filesystem needs is that each file has a unique name. We need to let the caller provide a pattern for the log filenames instead of a single filename. A pattern will let the logging library know how to make the name unique while still following the overall naming style that the developer wants. We can change the initial code to look like <span class="No-Break" lang="">this instead:</span></p>
			<pre class="source-code" lang="en-GB">
    MereMemo::FileOutput appFile("logs");
    appFile.namePattern() = "application-{}.log";
    appFile.maxSize() = 10'000'000;
    appFile.rolloverCount() = 5;
    MereMemo::addLogOutput(appFile);</pre>
			<p lang="en-GB">When designing a class, it’s a good idea to make the class work with reasonable defaults after construction. For file output, the bare minimum we need is the directory to create the log files. The other properties are nice but not required. If the name pattern is not provided, we can default to a simple unique number. The max size can have an unlimited default, or at least a really big number. And we only need a single log file. So, the rollover count can be <a id="_idIndexMarker444"/>some value that tells us to use a <span class="No-Break" lang="">single file.</span></p>
			<p lang="en-GB">I decided to use simple open and close curly braces <strong class="source-inline" lang="">{}</strong> for the placeholder in the pattern where a unique number will be placed. We’ll just pick a random three-digit number to make the log filename unique. That will give us up to a thousand log files, which should be more than enough. Most users will only want to keep a handful and delete <span class="No-Break" lang="">older files.</span></p>
			<p lang="en-GB">Because the output is a dependency that can be swapped or even have multiple outputs at the same time, what would a different type of output look like? We’ll figure out what the output dependency component interface will be later. For now, we just want to explore how to use different outputs. Here is how output can be sent to the <span class="No-Break" lang=""><strong class="source-inline" lang="">std::cout</strong></span><span class="No-Break" lang=""> console:</span></p>
			<pre class="source-code" lang="en-GB">
    MereMemo::StreamOutput consoleStream(std::cout);
    MereMemo::addLogOutput(consoleStream);</pre>
			<p lang="en-GB">The console output is an ostream so we should be able to create a stream output that can work with any ostream. This example creates an output component called <strong class="source-inline" lang="">consoleStream</strong>, which can be added to the log output just like the <span class="No-Break" lang="">file output.</span></p>
			<p lang="en-GB">When using TDD, it’s important to avoid interesting features that may not really be needed by the customer. We’re not going to add the ability to remove outputs. Once an output is added to the logging library, it will remain. In order to remove an output, we’d have to return some sort of identifier that can be used to later remove the same output that was added. We did add the ability to remove filter clauses because that ability seemed likely to be needed. Removing outputs is something that seems unlikely for <span class="No-Break" lang="">most customers.</span></p>
			<p lang="en-GB">In order to design a dependency that can be swapped for another, we’ll need a common interface class that all outputs implement. The class will be called <strong class="source-inline" lang="">Output</strong> and goes in <strong class="source-inline" lang="">Log.h</strong> right before the <strong class="source-inline" lang="">LogStream</strong> class, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class Output
{
public:
    virtual ~Output () = default;
    Output (Output const &amp; other) = delete;
    Output (Output &amp;&amp; other) = delete;
    virtual std::unique_ptr&lt;Output&gt; clone () const = 0;
    virtual void sendLine (std::string const &amp; line) = 0;
    Output &amp; operator = (Output const &amp; rhs) = delete;
    Output &amp; operator = (Output &amp;&amp; rhs) = delete;
protected:
    Output () = default;
};</pre>
			<p lang="en-GB">The only methods that are <a id="_idIndexMarker445"/>part of the interface are the <strong class="source-inline" lang="">clone</strong> and the <strong class="source-inline" lang="">sendLine</strong> methods. We’ll follow a similar cloning pattern as the tags, except we’re not going to use templates. The <strong class="source-inline" lang="">sendLine</strong> method will be called whenever a line of text needs to be sent to the output. The other methods make sure that nobody can construct instances of <strong class="source-inline" lang="">Output</strong> directly or copy or assign one <strong class="source-inline" lang="">Output</strong> instance to another. The <strong class="source-inline" lang="">Output</strong> class is designed to be <span class="No-Break" lang="">inherited from.</span></p>
			<p lang="en-GB">We’ll keep track of all the outputs that have been added with the next two functions, which go right after the <strong class="source-inline" lang="">Output</strong> class <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
inline std::vector&lt;std::unique_ptr&lt;Output&gt;&gt; &amp; getOutputs ()
{
    static std::vector&lt;std::unique_ptr&lt;Output&gt;&gt; outputs;
    return outputs;
}
inline void addLogOutput (Output const &amp; output)
{
    auto &amp; outputs = getOutputs();
    outputs.push_back(output.clone());
}</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">getOutputs</strong> function uses a static vector of unique pointers and returns the collection when requested. The <strong class="source-inline" lang="">addLogOutput</strong> function adds a clone of the given output to the collection. This is all similar to how the default tags <span class="No-Break" lang="">are handled.</span></p>
			<p lang="en-GB">One interesting use of dependencies that you should be aware of is their ability to swap out a real component for a fake component. We’re adding two real components to manage the logging output. One will send output to a file and the other to the console. But you can also use dependencies if you want to make progress on your code and are waiting for another team<a id="_idIndexMarker446"/> to finish writing a needed component. Instead of waiting, make the component a dependency that you can swap out for a simpler version. The simpler version is not a real version, but it should be faster to write and let you continue making progress until the real version <span class="No-Break" lang="">becomes available.</span></p>
			<p lang="en-GB">Some other testing libraries take this fake dependency ability a step further and let you create components with just a few lines of code that respond in various ways that you can control. This lets you isolate your code and make sure it behaves as it should because you can rely on the fake dependency to always behave as specified, and you no longer have to worry about bugs in the real dependency affecting the results of your tests. The common term for these fake components <span class="No-Break" lang="">is </span><span class="No-Break" lang=""><em class="italic" lang="">mocks</em></span><span class="No-Break" lang="">.</span></p>
			<p lang="en-GB">It doesn’t matter if you are using a testing library that generates a mock for you with a few lines of code or if you are writing your own mock. Anytime you have a class that imitates another class, you have <span class="No-Break" lang="">a mock.</span></p>
			<p lang="en-GB">Other than isolating your code from bugs, a mock can also help speed up your tests and improve collaboration with other teams. The speed is improved because the real code might need to spend time requesting or calculating a result, while the mock can return quickly without the need to do any real work. Collaboration with other teams is improved because everybody can agree to simple mocks that are quick to develop and can be used to communicate <span class="No-Break" lang="">design changes.</span></p>
			<p lang="en-GB">The next section will implement the file and stream output classes based on the common interface. We’ll be able to simplify the <strong class="source-inline" lang="">LogStream</strong> class and the <strong class="source-inline" lang="">log</strong> function to use the common interface, which will document and make it easier to understand what is really needed to send log messages to <span class="No-Break" lang="">an output.</span></p>
			<h1 id="_idParaDest-112" lang="en-GB">Adding multiple logging o<a id="_idTextAnchor120"/>utputs</h1>
			<p lang="en-GB">A good way to validate that a design works with multiple scenarios is to implement solutions for each scenario. We have a common <strong class="source-inline" lang="">Output</strong> interface class that defines two methods, <strong class="source-inline" lang="">clone</strong> and <strong class="source-inline" lang="">sendLine</strong>, and we need to make sure this interface will work for sending log <a id="_idIndexMarker447"/>messages to a log file and to <span class="No-Break" lang="">the console.</span></p>
			<p lang="en-GB">Let’s start with a class called <strong class="source-inline" lang="">FileOutput</strong> that inherits from <strong class="source-inline" lang="">Output</strong>. The new class goes in <strong class="source-inline" lang="">Log.h</strong> right after the <strong class="source-inline" lang="">getOutputs</strong> and the <strong class="source-inline" lang="">addLogOutput</strong> functions, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class FileOutput : public Output
{
public:
    FileOutput (std::string_view dir)
    : mOutputDir(dir),
    mFileNamePattern("{}"),
    mMaxSize(0),
    mRolloverCount(0)
    { }
    FileOutput (FileOutput const &amp; rhs)
    : mOutputDir(rhs.mOutputDir),
    mFileNamePattern(rhs.mFileNamePattern),
    mMaxSize(rhs.mMaxSize),
    mRolloverCount(rhs.mRolloverCount)
    { }
    FileOutput (FileOutput &amp;&amp; rhs)
    : mOutputDir(rhs.mOutputDir),
    mFileNamePattern(rhs.mFileNamePattern),
    mMaxSize(rhs.mMaxSize),
    mRolloverCount(rhs.mRolloverCount),
    mFile(std::move(rhs.mFile))
    { }
    ~FileOutput ()
    {
        mFile.close();
    }
    std::unique_ptr&lt;Output&gt; clone () const override
    {
        return std::unique_ptr&lt;Output&gt;(
            new FileOutput(*this));
    }
    void sendLine (std::string const &amp; line) override
    {
        if (not mFile.is_open())
        {
            mFile.open("application.log", std::ios::app);
        }
        mFile &lt;&lt; line &lt;&lt; std::endl;
        mFile.flush();
    }
protected:
    std::filesystem::path mOutputDir;
    std::string mFileNamePattern;
    std::size_t mMaxSize;
    unsigned int mRolloverCount;
    std::fstream mFile;
};</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">FileOutput</strong> class follows<a id="_idIndexMarker448"/> the usage that was determined in the previous section, which looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
    MereMemo::FileOutput appFile("logs");
    appFile.namePattern() = "application-{}.log";
    appFile.maxSize() = 10'000'000;
    appFile.rolloverCount() = 5;
    MereMemo::addLogOutput(appFile);</pre>
			<p lang="en-GB">We give the <strong class="source-inline" lang="">FileOutput</strong> class a directory in the constructor where the log files will be saved. The class also supports a name pattern, a max log file size, and a rollover count. All the data members need to be initialized in the constructors and we have <span class="No-Break" lang="">three constructors.</span></p>
			<p lang="en-GB">The first constructor is a normal constructor that accepts the directory and gives default values to the other <span class="No-Break" lang="">data members.</span></p>
			<p lang="en-GB">The second constructor is the copy constructor, and it initializes the data members based on the values in the other instance of <strong class="source-inline" lang="">FileOutput</strong>. Only the <strong class="source-inline" lang="">mFile</strong> data member is left in a default state because we don’t <span class="No-Break" lang="">copy fstreams.</span></p>
			<p lang="en-GB">The third constructor is the move copy constructor, and it looks almost identical to the copy constructor. The only difference is that we now move the fstream into the <strong class="source-inline" lang="">FileOutput</strong> class <span class="No-Break" lang="">being constructed.</span></p>
			<p lang="en-GB">The destructor will close the output file. This is actually a big improvement over what was done up to this point. We used to open and close the output file each time a log message was made. We’ll now open the log file and keep it open until we need to close it at a later time. The destructor <a id="_idIndexMarker449"/>makes sure that the log file gets closed if it hasn’t already <span class="No-Break" lang="">been closed.</span></p>
			<p lang="en-GB">Next is the <strong class="source-inline" lang="">clone</strong> method, which calls the copy constructor to create a new instance that gets sent back as a unique pointer to the <span class="No-Break" lang="">base class.</span></p>
			<p lang="en-GB">The <strong class="source-inline" lang="">sendLine</strong> method is the last method, and it needs to check whether the output file has been opened already or not before sending the line to the file. We’ll add the ending newline here after each line gets sent to the output file. We also flush the log file after every line, which helps to make sure that the log file contains everything written to it in case the application doing the logging <span class="No-Break" lang="">crashes suddenly.</span></p>
			<p lang="en-GB">The last thing we need to do in the <strong class="source-inline" lang="">FileOutput</strong> class is to define the data members. We’re not going to fully implement all the data members though. For example, you can see that we’re still opening a file called <strong class="source-inline" lang="">application.log</strong> instead of following the naming pattern. We have the basic idea already and skipping the data members will let us test this part to make sure we haven’t broken anything. We’ll need to comment out the configuration in the <strong class="source-inline" lang="">main</strong> function, so it looks like this <span class="No-Break" lang="">for now:</span></p>
			<pre class="source-code" lang="en-GB">
    MereMemo::FileOutput appFile("logs");
    //appFile.namePattern() = "application-{}.log";
    //appFile.maxSize() = 10'000'000;
    //appFile.rolloverCount() = 5;
    MereMemo::addLogOutput(appFile);</pre>
			<p lang="en-GB">We can always come back to the configuration methods and the directory later once we get the multiple outputs working in a basic manner. This follows the TDD practice of doing as little as possible each step along the way. In a way, what we’re doing is creating a mock for the ultimate <span class="No-Break" lang=""><strong class="source-inline" lang="">FileOutput</strong></span><span class="No-Break" lang=""> class.</span></p>
			<p lang="en-GB">I almost forgot to mention that because we’re using <strong class="source-inline" lang="">filesystem</strong> features, such as <strong class="source-inline" lang="">path</strong>, we need to include <strong class="source-inline" lang="">filesystem</strong> at the top of <strong class="source-inline" lang="">Log.h</strong>, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;ctime&gt;
#include &lt;filesystem&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;ostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;</pre>
			<p lang="en-GB">We’ll make use of <strong class="source-inline" lang="">filesystem</strong> more once we start rolling log files over into new files instead of always opening the same file <span class="No-Break" lang="">each time.</span></p>
			<p lang="en-GB">Next is the <strong class="source-inline" lang="">StreamOutput</strong> class, which <a id="_idIndexMarker450"/>can go in <strong class="source-inline" lang="">Log.h</strong> right after the <strong class="source-inline" lang="">FileOutput</strong> class and looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
class StreamOutput : public Output
{
public:
    StreamOutput (std::ostream &amp; stream)
    : mStream(stream)
    { }
    StreamOutput (StreamOutput const &amp; rhs)
    : mStream(rhs.mStream)
    { }
    std::unique_ptr&lt;Output&gt; clone () const override
    {
        return std::unique_ptr&lt;Output&gt;(
            new StreamOutput(*this));
    }
    void sendLine (std::string const &amp; line) override
    {
        mStream &lt;&lt; line &lt;&lt; std::endl;
    }
protected:
    std::ostream &amp; mStream;
};</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">StreamOutput</strong> class is simpler than the <strong class="source-inline" lang="">FileOutput</strong> class because it has fewer data members. We only need to keep track of an ostream reference that gets passed in the constructor in <strong class="source-inline" lang="">main</strong>. We also don’t need to worry about a specific move copy constructor because we can easily copy the ostream reference. The <strong class="source-inline" lang="">StreamOutput</strong> class was already added in <strong class="source-inline" lang="">main</strong> <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
    MereMemo::StreamOutput consoleStream(std::cout);
    MereMemo::addLogOutput(consoleStream);</pre>
			<p lang="en-GB">The <strong class="source-inline" lang="">StreamOutput</strong> class will hold a reference to <strong class="source-inline" lang="">std::cout</strong> that <strong class="source-inline" lang="">main</strong> passes <span class="No-Break" lang="">to it.</span></p>
			<p lang="en-GB">Now that we’re working with<a id="_idIndexMarker451"/> the output interface, we no longer need to manage a file in the <strong class="source-inline" lang="">LogStream</strong> class. The constructors can be simplified to no longer worry about an fstream data member, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
    LogStream ()
    : mProceed(true)
    { }
    LogStream (LogStream const &amp; other) = delete;
    LogStream (LogStream &amp;&amp; other)
    : std::stringstream(std::move(other)),
    mProceed(other.mProceed)
    { }</pre>
			<p lang="en-GB">The destructor of the <strong class="source-inline" lang="">LogStream</strong> class is where all the work happens. It no longer needs to send the message directly to a file that the class manages. The destructor now gets <em class="italic" lang="">all</em> the outputs and sends the message to each one using the common interface, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
    ~LogStream ()
    {
        if (not mProceed)
        {
            return;
        }
        
        auto &amp; outputs = getOutputs();
        for (auto const &amp; output: outputs)
        {
            output-&gt;sendLine(this-&gt;str());
        }
    }</pre>
			<p lang="en-GB">Remember that the <strong class="source-inline" lang="">LogStream</strong> class inherits from <strong class="source-inline" lang="">std::stringstream</strong> and holds the message to be logged. If we are to proceed, then we can get the fully formatted message by calling the <span class="No-Break" lang=""><strong class="source-inline" lang="">str</strong></span><span class="No-Break" lang=""> method.</span></p>
			<p lang="en-GB">The end of <strong class="source-inline" lang="">LogStream</strong> no longer needs the <strong class="source-inline" lang="">mFile</strong> data member and only needs the <strong class="source-inline" lang="">mProceed</strong> flag, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
private:
    bool mProceed;
};</pre>
			<p lang="en-GB">Because we removed the <strong class="source-inline" lang="">LogStream</strong> constructor parameters for the filename and open mode, we can<a id="_idIndexMarker452"/> simplify how the <strong class="source-inline" lang="">LogStream</strong> class gets created in the <strong class="source-inline" lang="">log</strong> function <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
inline LogStream log (std::vector&lt;Tag const *&gt; tags = {})
{
    auto const now = std::chrono::system_clock::now();
    std::time_t const tmNow =          std::chrono::system_clock::to_time_t(now);
    auto const ms = duration_cast&lt;std::chrono::milliseconds&gt;(
        now.time_since_epoch()) % 1000;
    LogStream ls;
    ls &lt;&lt; std::put_time(std::gmtime(&amp;tmNow),        "%Y-%m-%dT%H:%M:%S.")
        &lt;&lt; std::setw(3) &lt;&lt; std::setfill('0')         &lt;&lt; std::to_string(ms.count());</pre>
			<p lang="en-GB">We can now construct the <strong class="source-inline" lang="">ls</strong> instance without any arguments, and it will use all the outputs that have <span class="No-Break" lang="">been added.</span></p>
			<p lang="en-GB">Let’s check the test application by building and running the project. The output to the console looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">Running 1 test suites</strong>
<strong class="bold" lang="">--------------- Suite: Single Tests</strong>
<strong class="bold" lang="">------- Test: Message can be tagged in log</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.116 color="green" log_level="error" simple 7809</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: log needs no namespace when used with LogLevel</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.118 color="green" log_level="error" no namespace</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Default tags set in main appear in log</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.118 color="green" log_level="info" default tag 9055</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Multiple tags can be used in log</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.118 color="red" log_level="debug" size="large" multi tags 7933</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Tags can be streamed to log</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.118 color="green" log_level="info" count=1 1 type 3247</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.118 color="green" log_level="info" id=123456789012345 2 type 6480</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.118 color="green" log_level="info" scale=1.500000 3 type 6881</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.119 color="green" log_level="info" cache_hit=false 4 type 778</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Tags can be used to filter messages</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.119 color="green" log_level="info" filter 1521</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Overridden default tag not used to filter messages</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Inverted tag can be used to filter messages</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Tag values can be used to filter messages</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.119 color="green" count=101 log_level="info" values 8461</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Simple message can be logged</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.120 color="green" log_level="info" simple 9466 with more text.</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">------- Test: Complicated message can be logged</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.120 color="green" log_level="info" complicated 9198 double=3.14 quoted="in quotes"</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">-----------------------------------</strong>
<strong class="bold" lang="">Tests passed: 11</strong>
<strong class="bold" lang="">Tests failed: 0</strong></pre>
			<p lang="en-GB">You can see that the log messages did indeed go to the console window. The log messages are included in<a id="_idIndexMarker453"/> the console alongside the test results. What about the log file? It looks <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">2022-07-24T22:32:13.116 color="green" log_level="error" simple 7809</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.118 color="green" log_level="error" no namespace</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.118 color="green" log_level="info" default tag 9055</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.118 color="red" log_level="debug" size="large" multi tags 7933</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.118 color="green" log_level="info" count=1 1 type 3247</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.118 color="green" log_level="info" id=123456789012345 2 type 6480</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.118 color="green" log_level="info" scale=1.500000 3 type 6881</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.119 color="green" log_level="info" cache_hit=false 4 type 778</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.119 color="green" log_level="info" filter 1521</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.119 color="green" count=101 log_level="info" values 8461</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.120 color="green" log_level="info" simple 9466 with more text.</strong>
<strong class="bold" lang="">2022-07-24T22:32:13.120 color="green" log_level="info" complicated 9198 double=3.14 quoted="in quotes"</strong></pre>
			<p lang="en-GB">The log file contains only the log messages, which are the same log messages that were sent to the console window. This shows that we have multiple outputs! There’s no good way to verify that the log messages are being sent to the console window, such as how we can open the log file and search for a <span class="No-Break" lang="">specific line.</span></p>
			<p lang="en-GB">But we could add yet another output using the <strong class="source-inline" lang="">StreamOutput</strong> class that is given  <strong class="source-inline" lang="">std::fstream</strong> instead of <strong class="source-inline" lang="">std::cout</strong>. We can do this because fstream implements ostream, which is all that the <strong class="source-inline" lang="">StreamOutput</strong> class needs. This is also dependency injection because the <strong class="source-inline" lang="">StreamOutput</strong> class depends on an ostream and we can give it any ostream we<a id="_idIndexMarker454"/> want it to use, <span class="No-Break" lang="">like this:</span></p>
			<pre class="source-code" lang="en-GB">
#include &lt;fstream&gt;
#include &lt;iostream&gt;
int main ()
{
    MereMemo::FileOutput appFile("logs");
    //appFile.namePattern() = "application-{}.log";
    //appFile.maxSize() = 10'000'000;
    //appFile.rolloverCount() = 5;
    MereMemo::addLogOutput(appFile);
    MereMemo::StreamOutput consoleStream(std::cout);
    MereMemo::addLogOutput(consoleStream);
    std::fstream streamedFile("stream.log", std::ios::app);
    MereMemo::StreamOutput fileStream(streamedFile);
    MereMemo::addLogOutput(fileStream);
    MereMemo::addDefaultTag(info);
    MereMemo::addDefaultTag(green);
    return MereTDD::runTests(std::cout);
}</pre>
			<p lang="en-GB">We’re not going to make this change. It’s just for demonstration purposes only. But it shows that you can open a file and pass that file to the <strong class="source-inline" lang="">StreamOutput</strong> class to use instead of the console output. If you do make this change, then you’ll see that the <strong class="source-inline" lang="">stream.log</strong> and <strong class="source-inline" lang="">application.log</strong> files are <span class="No-Break" lang="">the same.</span></p>
			<p lang="en-GB">Why would you want to consider using <strong class="source-inline" lang="">StreamOutput</strong> as if it was <strong class="source-inline" lang="">FileOutput</strong>? And why do we need <strong class="source-inline" lang="">FileOutput</strong> if <strong class="source-inline" lang="">StreamOutput</strong> can also write to <span class="No-Break" lang="">a file?</span></p>
			<p lang="en-GB">First of all, <strong class="source-inline" lang="">FileOutput</strong> is specialized for files. It will eventually know how to check the current file size to make sure it doesn’t get too big and roll over to a new log file whenever the current log file approaches the maximum size. There is a need for file management that <strong class="source-inline" lang="">StreamOutput</strong> will not even be <span class="No-Break" lang="">aware of.</span></p>
			<p lang="en-GB">The <strong class="source-inline" lang="">StreamOutput</strong> class is simpler though because it doesn’t need to worry about files at all. You might want to use <strong class="source-inline" lang="">StreamOutput</strong> to write to a file in case the <strong class="source-inline" lang="">FileOutput</strong> class takes too long to create. Sure, we created a simplified <strong class="source-inline" lang="">FileOutput</strong> without all the file management features, but another team might not be so willing to give you a partial implementation. You might find it better to use a mock solution while you wait for a <span class="No-Break" lang="">full implementation.</span></p>
			<p lang="en-GB">The ability to swap one<a id="_idIndexMarker455"/> implementation for another is a big advantage you get with properly <span class="No-Break" lang="">managed dependencies.</span></p>
			<p lang="en-GB">In fact, this book will leave the current implementation of <strong class="source-inline" lang="">FileOutput</strong> as it is now because finishing the implementation would take us into topics that have little to do with learning <span class="No-Break" lang="">about TDD.</span></p>
			<h1 id="_idParaDest-113" lang="en-GB"><a id="_idTextAnchor121"/>Summary</h1>
			<p lang="en-GB">We not only added a great new feature to the logging library that lets it send log messages to multiple destinations but we also added this ability using an interface. The interface helps document and isolate the idea of sending lines of text to a destination. This helped uncover a dependency that the logging library has. The logging library depends on the ability to send <span class="No-Break" lang="">text somewhere.</span></p>
			<p lang="en-GB">The destination could be a log file or the console, or somewhere else. Until we identified this dependency, the logging library was making assumptions in many places that it was working with a log file only. We were able to simplify the design and, at the same time create a more <span class="No-Break" lang="">flexible design.</span></p>
			<p lang="en-GB">We were also able to get the file logging working without a complete file logging component. We created a mock of the file logging component that leaves out all the additional file management tasks that a full implementation will need. While useful, the additional capabilities are not needed right now, and the mock will let us proceed <span class="No-Break" lang="">without them.</span></p>
			<p lang="en-GB">The next chapter will go back to the unit testing library and will show you how to enhance the confirmations to a new style that is extensible and easier <span class="No-Break" lang="">to understand.</span></p>
		</div>
	

		<div id="_idContainer022" class="Content">
			<h1 id="_idParaDest-114" lang="en-GB"><a id="_idTextAnchor122"/>Part 3: Extending the TDD Library to Support the Growing Needs of the Logging Library</h1>
			<p lang="en-GB">This book is divided into three parts. In this third and final part, we’ll be enhancing the unit test confirmations to use a new modern style called Hamcrest confirmations. You’ll also learn how to test services and how to test with multiple threads. This third part will tie everything you’ve learned so far together and prepare you to use TDD in your <span class="No-Break" lang="">own projects.</span></p>
			<p lang="en-GB">The following chapters are covered in <span class="No-Break" lang="">this part:</span></p>
			<ul>
				<li lang="en-GB"><a href="B18567_12.xhtml#_idTextAnchor123"><em class="italic" lang="">Chapter 12</em></a>, <em class="italic" lang="">Creating better test assertions</em></li>
				<li lang="en-GB"><a href="B18567_13.xhtml#_idTextAnchor131"><em class="italic" lang="">Chapter 13</em></a>, <em class="italic" lang="">How to Test Floating-Point and Custom Values</em></li>
				<li lang="en-GB"><a href="B18567_14.xhtml#_idTextAnchor139"><em class="italic" lang="">Chapter 14</em></a>, <em class="italic" lang="">How to Test Services</em></li>
				<li lang="en-GB"><a href="B18567_15.xhtml#_idTextAnchor149"><em class="italic" lang="">Chapter 15</em></a>, <em class="italic" lang="">Testing Across Multiple Threads</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer023">
			</div>
		</div>
		<div>
			<div id="_idContainer024">
			</div>
		</div>
	</body></html>