["```cpp\n#include <cstring>\n#include <cstdio>\nstruct A {\n   A(const char* p_a):m_a(new char[32]) { strcpy(m_a, p_a);\n       printf(\"A::A : %s\\n\", p_a);\n   }\n   ~A() {\n       printf(\"A::~A : %s\\n\", m_a);\n       delete[] m_a;\n   }\n   volatile const char* get() const {return m_a;}\nprivate:\n   char* m_a;\n};\nconst char* my_string= \"Hello string\";\nA my_a(my_string);\nconst char* my_other_string = \"Go away string\";\nA my_other_a(my_other_string);\nint main() {\n   printf(\"Hello, World, %s, %s\\n\", my_a.get(), my_other_a.get()); }\n```", "```cpp\nA::A : Hello string\nA::A : Go away string\nHello, World, Hello string, Go away string\nA::~A : Go away string\nA::~A : Hello string\n```", "```cpp\nstatic int create_elf_tables(struct linux_binprm *bprm,\nconst struct elfhdr *exec, unsigned long interp_load_addr,\nunsigned long e_entry,unsigned long phdr_addr) { ... }\n```", "```cpp\n/* Specialized bits of code needed to support construction and destruction of file-scope objects in C++ code.\n```", "```cpp\n__attribute__((constructor)) void welcome() {\n   printf(\"constructor fun\\n\");\n}\n```", "```cpp\nconstructor fun\nA::A : Hello string\nA::A : Go away string\nHello, World, Hello string, Go away string\nA::~A : Go away string\nA::~A : Hello string\n```", "```cpp\n#ifndef A_H\n#define A_H\nclass C;\nextern C a_c;\n#endif\n```", "```cpp\n#ifndef B_H\n#define B_H\nclass C;\nextern C b_c;\n#endif\n```", "```cpp\n#ifndef C_H\n#define C_H\n#include <cstring>\n#include <cstdio>\nstruct C {\n   C(const char* p_c) : m_c(nullptr) {\n       m_c = new char[32];\n       strcpy(m_c, p_c);\n       printf(\"C::C : %s\\n\", p_c);\n   }\n   ~C() {\n       printf(\"C::~C : %s\\n\", m_c);\n       delete[] m_c;\n   }\nprivate:\n   char* m_c;\n};\n#endif\n```", "```cpp\n#include \"C.h\"\nC a_c(\"A\");\n```", "```cpp\n#include \"C.h\"\nC b_c(\"B\");\n```", "```cpp\nint main()\n{\n}\n```", "```cpp\n> $ g++ main.cpp a.cpp b.cpp -o test\n> $ ./test\nC::C : A\nC::C : B\nC::~C : B\nC::~C : A\n```", "```cpp\n> $ g++ main.cpp b.cpp a.cpp -o test\n> $ ./test\nC::C : B\nC::C : A\nC::~C : A\nC::~C : B\n```", "```cpp\n#include \"C.h\"\n__attribute__((init_priority(1000))) C a_c(\"A\");\n```", "```cpp\n#include \"C.h\"\n__attribute__((init_priority(1001))) C b_c(\"B\");\n```", "```cpp\n> $ g++ main.cpp a.cpp b.cpp -o test\n> $ ./test\nC::C : A\nC::C : B\nC::~C : B\nC::~C : A\n> $ g++ main.cpp b.cpp a.cpp -o test\n> $ ./test\nC::C : A\nC::C : B\nC::~C : B\nC::~C : A\n```", "```cpp\n__attribute__((init_priority(1000)))\n                             A my_other_a(my_other_string);\n```", "```cpp\nA::A : Go away string\nconstructor fun\nA::A : Hello string\nHello, World, Hello string, Go away string\nA::~A : Hello string\nA::~A : Go away string\n```", "```cpp\n#include \"C.h\"\n#include <cstdio>\n__attribute__((init_priority(2000))) C synth_c(\"synth\");\n__attribute__((constructor)) void welcome_library() {\n   printf(\"welcome to the library\\n\");\n}\nvoid print_synth() {\n   printf(\"print_synth: %s\\n\", synth_c.get());\n}\n```", "```cpp\n#ifndef SYNTH_H\n#define SYNTH_H\nvoid print_synth();\n#endif\n```", "```cpp\n#include \"synth.h\"\n#include \"C.h\"\n__attribute__((constructor)) void welcome_main() {\n   printf(\"welcome to the main\\n\");\n}\nC main_c(\"main\") ;\nint main() {\n   print_synth();\n   return 0;\n}\n```", "```cpp\n> $ g++ -c -o synth.o synth.cpp\n> $ ar rcs libsynth.a synth.o\n> $ g++ -o main main.cpp a.cpp b.cpp -L. -lsynth\n```", "```cpp\n> $ ./main\nC::C : A\nC::C : B\nC::C : synth\nwelcome to the main\nC::C : main\nwelcome to the library\nprint_synth: synth\nC::~C : main\nC::~C : synth\nC::~C : B\nC::~C : A\n```", "```cpp\n> $ g++ -fPIC -c -o  synth.o synth.cpp\n> $ g++ -shared -o libsynth.so synth.o\n> $ g++ -pie -o main main.cpp a.cpp b.cpp -L. -lsynth\n```", "```cpp\n> $ LD_LIBRARY_PATH=. ldd ./main\n   linux-vdso.so.1 (0x00007fff17387000)\n   libsynth.so => ./libsynth.so (0x00007ea84ee45000)\n   libstdc++.so.6 => /lib/x86_64-linux-gnu/libstdc++.so.6\n```", "```cpp\n> $ LD_LIBRARY_PATH=. ./main\nC::C : synth\nwelcome to the library\nC::C : A\nC::C : B\nwelcome to the main\nC::C : main\nprint_synth: synth\nC::~C : main\nC::~C : B\nC::~C : A\nC::~C : synth\n```", "```cpp\n__attribute__((constructor)) void welcome_a() {\n   printf(\"welcome to the 'a' file\\n\"); }\n__attribute__((constructor)) void welcome_b() {\n   printf(\"welcome to the 'b' file\\n\"); }\n```", "```cpp\n#include <iostream>\nint main() {\n    std::cout << \"Hello World!\\n\";\n}\n```", "```cpp\nulong __cdecl entry(void *param_1) {\n  ulong uVar1;\n  uVar1 = __scrt_common_main();\n  return uVar1;\n}\n```", "```cpp\nint __cdecl __scrt_common_main(void) {\n  int iVar1;\n   __security_init_cookie();\n  iVar1 = __scrt_common_main_seh();\n  return iVar1;\n}\n```", "```cpp\nint __cdecl invoke_main(void) {\n  char **_Argv;\n  char **_Env;\n  undefined4 *puVar1;\n  int *piVar2;\n  int iVar3;\n  _Env = (char **)__get_initial_narrow_environment();\n  puVar1 = (undefined4 *)___p___argv();\n  _Argv = (char **)*puVar1;\n  piVar2 = (int *)___p___argc();\n  iVar3 = main(*piVar2,_Argv,_Env);\n  return iVar3;\n}\n```", "```cpp\nvoid __cdecl `dynamic_initializer_for_'my_a''(void)\n{\nint iVar1;\nuchar *unaff_EDI;\nundefined4 *puVar2;\n  puVar2 = (undefined4 *)&stack0xfffffffc;\nfor (iVar1 = 0; iVar1 != 0; iVar1 = iVar1 + -1) {\n   *puVar2 = 0xcccccccc;\n   puVar2 = puVar2 + 1;\n}\n__CheckForDebuggerJustMyCode(unaff_EDI);\nA::A(&my_a,my_string);\natexit(`dynamic_atexit_destructor_for_'my_a'');\nreturn;\n}\n```"]