["```cpp\n#include \"spi.h\" \n#define SPI1EN            (1U<<12)\n#define GPIOAEN            (1U<<0)\n#define SR_TXE            (1U<<1)\n#define SR_RXNE            (1U<<0)\n#define SR_BSY            (1U<<7)\nvoid spi_gpio_init(void)\n{\n    /*Enable clock access to GPIOA*/\n    RCC->AHB1ENR |= GPIOAEN;\n    /*Set PA5,PA6,PA7 mode to alternate function*/\n    /*PA5*/\n    GPIOA->MODER &=~(1U<<10);\n    GPIOA->MODER |=(1U<<11);\n    /*PA6*/\n    GPIOA->MODER &=~(1U<<12);\n    GPIOA->MODER |=(1U<<13);\n    /*PA7*/\n    GPIOA->MODER &=~(1U<<14);\n    GPIOA->MODER |=(1U<<15);\n    /*Set PA9 as output pin*/\n    GPIOA->MODER |=(1U<<18);\n    GPIOA->MODER &=~(1U<<19);\n    /*Set PA5,PA6,PA7 alternate function type to SPI1*/\n    /*PA5*/\n    GPIOA->AFR[0] |=(1U<<20);\n    GPIOA->AFR[0] &= ~(1U<<21);\n    GPIOA->AFR[0] |=(1U<<22);\n    GPIOA->AFR[0] &= ~(1U<<23);\n    /*PA6*/\n    GPIOA->AFR[0] |=(1U<<24);\n    GPIOA->AFR[0] &= ~(1U<<25);\n    GPIOA->AFR[0] |=(1U<<26);\n    GPIOA->AFR[0] &= ~(1U<<27);\n    /*PA7*/\n    GPIOA->AFR[0] |=(1U<<28);\n    GPIOA->AFR[0] &= ~(1U<<29);\n    GPIOA->AFR[0] |=(1U<<30);\n    GPIOA->AFR[0] &= ~(1U<<31);\n}\n```", "```cpp\nvoid spi1_config(void)\n{\n    /*Enable clock access to SPI1 module*/\n    RCC->APB2ENR |= SPI1EN;\n    /*Set clock to fPCLK/4*/\n    SPI1->CR1 |=(1U<<3);\n    SPI1->CR1 &=~(1U<<4);\n    SPI1->CR1 &=~(1U<<5);\n    /*Set CPOL to 1 and CPHA to 1*/\n    SPI1->CR1 |=(1U<<0);\n    SPI1->CR1 |=(1U<<1);\n    /*Enable full duplex*/\n    SPI1->CR1 &=~(1U<<10);\n    /*Set MSB first*/\n    SPI1->CR1 &= ~(1U<<7);\n    /*Set mode to MASTER*/\n    SPI1->CR1 |= (1U<<2);\n    /*Set 8 bit data mode*/\n    SPI1->CR1 &= ~(1U<<11);\n    /*Select software slave management by\n     * setting SSM=1 and SSI=1*/\n    SPI1->CR1 |= (1<<8);\n    SPI1->CR1 |= (1<<9);\n    /*Enable SPI module*/\n    SPI1->CR1 |= (1<<6);\n}\nvoid spi1_transmit(uint8_t *data,uint32_t size)\n{\n    uint32_t i=0;\n    uint8_t temp;\n    while(i<size)\n    {\n        /*Wait until TXE is set*/\n        while(!(SPI1->SR & (SR_TXE))){}\n        /*Write the data to the data register*/\n        SPI1->DR = data[i];\n        i++;\n    }\n    /*Wait until TXE is set*/\n    while(!(SPI1->SR & (SR_TXE))){}\n    /*Wait for BUSY flag to reset*/\n    while((SPI1->SR & (SR_BSY))){}\n    /*Clear OVR flag*/\n    temp = SPI1->DR;\n    temp = SPI1->SR;\n}\n```", "```cpp\nvoid spi1_receive(uint8_t *data,uint32_t size)\n{\n    while(size)\n    {\n        /*Send dummy data*/\n        SPI1->DR =0;\n        /*Wait for RXNE flag to be set*/\n        while(!(SPI1->SR & (SR_RXNE))){}\n        /*Read data from data register*/\n        *data++ = (SPI1->DR);\n        size--;\n    }\n}\n```", "```cpp\nvoid cs_enable(void)\n{\n    GPIOA->ODR &=~(1U<<9);\n}\n```", "```cpp\n/*Pull high to disable*/\nvoid cs_disable(void)\n{\n    GPIOA->ODR |=(1U<<9);\n}\n```", "```cpp\n#define SPI1EN      (1U<<12)\n#define GPIOAEN     (1U<<0)\n#define SR_TXE      (1U<<1)\n#define SR_RXNE     (1U<<0)\n#define SR_BSY      (1U<<7)\n```", "```cpp\nRCC->AHB1ENR |= GPIOAEN;\n```", "```cpp\n/*PA5*/\nGPIOA->MODER &=~(1U<<10);\nGPIOA->MODER |=(1U<<11);\n/*PA6*/\nGPIOA->MODER &=~(1U<<12);\nGPIOA->MODER |=(1U<<13);\n/*PA7*/\nGPIOA->MODER &=~(1U<<14);\nGPIOA->MODER |=(1U<<15);\n```", "```cpp\nGPIOA->MODER |= (1U<<18);\nGPIOA->MODER &= ~(1U<<19);\n```", "```cpp\n/*PA5*/\nGPIOA->AFR[0] |=(1U<<20);\nGPIOA->AFR[0] &= ~(1U<<21);\nGPIOA->AFR[0] |=(1U<<22);\nGPIOA->AFR[0] &= ~(1U<<23);\n/*PA6*/\nGPIOA->AFR[0] |=(1U<<24);\nGPIOA->AFR[0] &= ~(1U<<25);\nGPIOA->AFR[0] |=(1U<<26);\nGPIOA->AFR[0] &= ~(1U<<27);\n/*PA7*/\nGPIOA->AFR[0] |=(1U<<28);\nGPIOA->AFR[0] &= ~(1U<<29);\nGPIOA->AFR[0] |=(1U<<30);\nGPIOA->AFR[0] &= ~(1U<<31);\n```", "```cpp\nRCC->APB2ENR |= SPI1EN;\n```", "```cpp\nSPI1->CR1 |=(1U<<3);\nSPI1->CR1 &=~(1U<<4);\nSPI1->CR1 &=~(1U<<5);\n```", "```cpp\nSPI1->CR1 |=(1U<<0);\nSPI1->CR1 |=(1U<<1);\n```", "```cpp\nSPI1->CR1 &=~(1U<<10);\n```", "```cpp\nSPI1->CR1 &= ~(1U<<7);\n```", "```cpp\nSPI1->CR1 |= (1U<<2);\n```", "```cpp\nSPI1->CR1 &= ~(1U<<11);\n```", "```cpp\nSPI1->CR1 |= (1<<8);\nSPI1->CR1 |= (1<<9);\n```", "```cpp\nSPI1->CR1 |= (1<<6);\n```", "```cpp\nwhile (!(SPI1->SR & (SR_TXE))) {}\n```", "```cpp\nSPI1->DR = data[i];\n```", "```cpp\nwhile ((SPI1->SR & (SR_BSY))) {}\n```", "```cpp\ntemp = SPI1->DR;\ntemp = SPI1->SR;\n```", "```cpp\nSPI1->DR = 0;\n```", "```cpp\nwhile (!(SPI1->SR & (SR_RXNE))) {}\n```", "```cpp\n*data++ = (SPI1->DR);\n```", "```cpp\nGPIOA->ODR &= ~(1U << 9);\n```", "```cpp\nGPIOA->ODR |= (1U << 9);\n```", "```cpp\n#ifndef SPI_H_\n#define SPI_H_\n#include \"stm32f4xx.h\"\n#include <stdint.h>\nvoid spi_gpio_init(void);\nvoid spi1_config(void);\nvoid spi1_transmit(uint8_t *data,uint32_t size);\nvoid spi1_receive(uint8_t *data,uint32_t size);\nvoid cs_enable(void);\nvoid cs_disable(void);\n#endif\n```", "```cpp\n#ifndef ADXL345_H_\n#define ADXL345_H_\n#include \"spi.h\"\n#include <stdint.h>\n#define ADXL345_REG_DEVID                (0x00)\n#define ADXL345_REG_DATA_FORMAT          (0x31)\n#define ADXL345_REG_POWER_CTL            (0x2D)\n#define ADXL345_REG_DATA_START           (0x32)\n#define ADXL345_RANGE_4G                 (0x01)\n#define ADXL345_RESET                    (0x00)\n#define ADXL345_MEASURE_BIT              (0x08)\n#define ADXL345_MULTI_BYTE_ENABLE        (0x40)\n#define ADXL345_READ_OPERATION           (0x80)\nvoid adxl_init (void);\nvoid adxl_read(uint8_t address, uint8_t * rxdata);\nadxl345.h file begins by including our SPI driver with #include \"spi.h\" and proceeds to define the necessary macros. Let’s break down the macros:\n\n\t\t\t\t*   `ADXL345_REG_DEVID (0x00)`: This macro defines the register address for the device ID of the ADXL345\n\t\t\t\t*   `ADXL345_REG_DATA_FORMAT (0x31)`: This macro defines the register address for setting the data format of the ADXL345\n\t\t\t\t*   `ADXL345_REG_POWER_CTL (0x2D)`: This macro defines the register address for the power control settings of the ADXL345\n\t\t\t\t*   `ADXL345_REG_DATA_START (0x32)`: This macro defines the starting register address for reading acceleration data from the ADXL345\n\t\t\t\t*   `ADXL345_RANGE_4G (0x01)`: This macro defines the value to set the measurement range of the ADXL345 to ±4g\n\t\t\t\t*   `ADXL345_RESET (0x00)`: This macro defines the reset value for certain registers\n\t\t\t\t*   `ADXL345_MEASURE_BIT (0x08)`: This macro defines the bit value to enable measurement mode in the power control register\n\t\t\t\t*   `ADXL345_MULTI_BYTE_ENABLE (0x40)`: This macro defines the bit to enable multi-byte operations\n\t\t\t\t*   `ADXL345_READ_OPERATION (0x80)`: This macro defines the bit to specify a read operation\n\n\t\t\tNext, we populate the `adxl345.c` file:\n\n```", "```cpp\n\n\t\t\tLet’s analyze the functions line by line, starting with the `adxl_read()` function.\n\t\t\tFunction – adxl_read()\n\t\t\tLet’s break down the read function:\n\n\t\t\t\t*   `address |= ADXL345_READ_OPERATION;`: This line sets the MSB of the address to indicate a read operation\n\t\t\t\t*   `address |= ADXL345_MULTI_BYTE_ENABLE;`: This sets the multi-byte bit to enable multi-byte operations\n\t\t\t\t*   `cs_enable();`: This function pulls the CS line low, enabling communication with the ADXL345\n\t\t\t\t*   `spi1_transmit(&address, 1);`: This transmits the address (with read and multi-byte bits set) to the ADXL345\n\t\t\t\t*   `spi1_receive(rxdata, 6);`: This line reads 6 bytes of data from the ADXL345 and stores it in the buffer pointed to by `rxdata`\n\t\t\t\t*   `cs_disable();`: This function pulls the CS line high, ending communication with the ADXL345\n\n\t\t\tNext, we have the `adxl_write()` function.\n\t\t\tFunction – adxl_write\n\t\t\tLet’s go through each line of this function:\n\n\t\t\t\t*   `data[0] = address | ADXL345_MULTI_BYTE_ENABLE;`: This sets the multi-byte bit and stores the modified address in the buffer\n\t\t\t\t*   `data[1] = value;`: This stores the data to be written in the buffer\n\t\t\t\t*   `cs_enable();`: This function pulls the CS line low, enabling communication with the ADXL345\n\t\t\t\t*   `spi1_transmit(data, 2);`: This transmits the address and data to the ADXL345 in one transaction\n\t\t\t\t*   `cs_disable();`: This function pulls the CS line high, ending communication with the ADXL345\n\n\t\t\tFinally, we have the `adxl_init()` function.\n\t\t\tFunction – adxl_init\n\t\t\tLet’s analyze the initialization function:\n\n\t\t\t\t*   `spi_gpio_init();`: This function initializes the GPIO pins needed for SPI communication\n\t\t\t\t*   `spi1_config();`: This function configures the SPI settings (clock speed, mode, etc.)\n\t\t\t\t*   `adxl_write(ADXL345_REG_DATA_FORMAT, ADXL345_RANGE_4G);`: This line writes to the data format register to set the measurement range of the ADXL345 to ±4g\n\t\t\t\t*   `adxl_write(ADXL345_REG_POWER_CTL, ADXL345_RESET);`: This line writes to the power control register to reset all bits\n\t\t\t\t*   `adxl_write(ADXL345_REG_POWER_CTL, ADXL345_MEASURE_BIT);`: This line writes to the power control register to set the measure bit, enabling measurement mode\n\n\t\t\tWe are now ready to test the driver inside the `main.c` file. Update your `main.c` file as shown next:\n\n```", "```cpp\n\n\t\t\tLet’s break down the `main()` function:\n\n\t\t\t\t*   `accel_x, accel_y, accel_z`: These are variables to store the raw accelerometer data for each axis.\n\t\t\t\t*   `accel_x_g, accel_y_g, accel_z_g`: These are variables to store the converted accelerometer data in g units.\n\t\t\t\t*   `data_buffer[6]`: This is a buffer to hold the raw data bytes read from the ADXL345.\n\t\t\t\t*   `adxl_init()`: This initializes the ADXL345 accelerometer.\n\t\t\t\t*   `adxl_read(ADXL345_REG_DATA_START, data_buffer);`: This line reads data from the ADXL345 starting at the specified register (`ADXL345_REG_DATA_START`). The data is stored in `data_buffer`.\n\n\t\t\tFinally, we have the lines for constructing the final 16-bit values:\n\n```", "```cpp\n\n\t\t\tThe data read from the ADXL345 is in 2 bytes (high and low) for each axis. These lines combine the bytes to form 16-bit values for each axis:\n\n```", "```cpp\n\n\t\t\tThese lines convert the raw accelerometer values to g values:\n\n```", "```cpp\n\n\t\t\tThis line outputs the raw accelerometer data for debugging purposes:\n\t\t\tNow, let’s test the project. To test the project, compile the code and run it on your microcontroller. Open RealTerm or another serial terminal application and configure it with the appropriate port and baud rate to view the debug messages. Press the black pushbutton on the development board to reset the microcontroller. You should see the *x*, *y*, and *z* accelerometer values continuously being printed. Try moving the accelerometer to observe the values change significantly.\n\t\t\tSummary\n\t\t\tIn this chapter, we explored the SPI protocol, a widely used communication protocol in embedded systems for efficient data transfer between microcontrollers and peripherals. We began by understanding the basic principles of SPI, including its master-slave architecture, data transfer modes, and typical use cases, emphasizing its advantages such as full-duplex communication and high-speed operation.\n\t\t\tNext, we examined the SPI peripheral in STM32F4 microcontrollers, focusing on critical registers such as SPI Control Register 1 (`SPI_CR1`), SPI Status Register (`SPI_SR`), and SPI Data Register (`SPI_DR`). We detailed how to configure these registers to set up the SPI peripheral for communication, covering important aspects such as **clock polarity** (**CPOL**) and **clock phase** (**CPHA**), data frame size, and master/slave configuration.\n\t\t\tWe then applied this theoretical knowledge by developing a bare-metal SPI driver. The development process included initializing the SPI peripheral, implementing data transmission and reception functions, and handling CS management. We also integrated the SPI driver with an ADXL345 accelerometer, using SPI to communicate with the sensor and retrieve acceleration data. Finally, we tested the driver by reading and displaying the accelerometer data in real time.\n\t\t\tIn the next chapter, we will explore the final of the three most common communication protocols in embedded systems: I2C.\n\n```"]