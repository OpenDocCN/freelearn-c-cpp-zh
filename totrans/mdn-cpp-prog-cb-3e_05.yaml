- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Standard Library Containers, Algorithms, and Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ standard library has evolved a lot with C++11/14/17/20, and now C++23\.
    However, at its core still sit three main pillars: containers, algorithms, and
    iterators. They are all implemented as generic types and general-purpose function
    templates. In this chapter, we’ll look at how they can be employed together to
    achieve various goals.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following recipes in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `vector` as a default container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `bitset` for fixed-size sequences of bits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `vector<bool>` for variable-size sequences of bits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the bit manipulation utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding elements in a range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting a range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing a range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using set operations on a range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using iterators to insert new elements into a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own random-access iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container access with non-member functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting the right standard containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll begin this chapter by exploring the functionalities of the de facto default
    container in C++, which is `std::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: Using vector as a default container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard library provides various types of containers that store collections
    of objects; the library includes sequence containers (such as `vector`, `array`,
    and `list`), ordered and unordered associative containers (such as `set` and `map`),
    and container adapters that do not store data but provide an adapted interface
    toward a sequence container (such as `stack` and `queue`). All of them are implemented
    as class templates, which means they can be used with any type (providing it meets
    the container requirements). In general, you should always use the container that
    is the most appropriate for a particular problem, which not only provides good
    performance in terms of speed of inserts, deletes, access to elements, and memory
    usage but also makes the code easy to read and maintain. However, the default
    choice should be `vector`. In this recipe, we will see why `vector` should be
    the preferred choice for a container in many cases and what the most common operations
    with `vector` are.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, you must be familiar with arrays, both statically and dynamically
    allocated. A couple of examples are provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `vector` class template is available in the `std` namespace in the `<vector>`
    header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To initialize an `std::vector` class template, you can use any of the following
    methods, but you are not restricted to only these:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize from an initialization list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize from an array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize from another container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize from a count and a value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To modify the content of `std::vector`, you can use any of the following methods
    (as above, you’re not restricted to just these):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an element at the end of the vector with `push_back()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove an element from the end of the vector with `pop_back()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert anywhere in the vector with `insert()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an element by creating it at the end of the vector with `emplace_back()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert an element by creating it anywhere in the vector with `emplace()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To modify the whole content of the vector, you can use any of the following
    methods, although you’re not restricted to just these:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign from another vector with `operator=`; this replaces the content of the
    container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assign from another sequence defined by a begin and end iterator with the `assign()`
    method; this replaces the content of the container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Swap the content of two vectors with the `swap()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove all the elements with the `clear()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove one or more elements with the `erase()` method (which requires either
    an iterator or a pair of iterators that define the range of elements from the
    vector to be removed):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove one or more elements that satisfy a predicate with the `std::remove_if()`
    function and the `erase()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove one or more elements that satisfy a predicate with the `std::erase_if()`
    function, introduced in C++20\. A similar `std::erase()` function also exists:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get the address of the first element in a vector, usually to pass the content
    of a vector to a C-like API, use any of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `data()` method, which returns a pointer to the first element, providing
    direct access to the underlying contiguous sequence of memory where the vector
    elements are stored; this is only available since C++11:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the address of the first element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the address of the element referred to by the `front()` method (calling
    this method on an empty vector is undefined behavior):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the address of the element pointed by the iterator returned from `begin()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To modify the content of a vector, in C++23, you can also use the following
    range-aware member functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace the elements of a vector with a copy of the elements of a given
    range, use `assign_range()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To append copies of the elements of a range at the end of a vector (before
    the end iterator), use `append_range()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To insert copies of the elements of a range before a given iterator of a vector,
    use `insert_range()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::vector` class is designed to be the C++ container most similar to
    and inter-operable with arrays. A vector is a variable-sized sequence of elements,
    guaranteed to be stored contiguously in memory, which makes the content of a vector
    easily passable to a C-like function that takes a pointer to an element of an
    array and, usually, a size.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many benefits of using a vector instead of arrays, and these benefits
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: No direct memory management is required from the developer as the container
    does this internally, allocating memory, reallocating it, and releasing it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that a vector is intended for storing object instances. If you need to
    store pointers, do not store raw pointers but smart pointers. Otherwise, you need
    to handle the lifetime management of the pointed objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The possibility of modifying the size of the vector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple assignment or concatenation of two vectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direct comparison of two vectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `vector` class is a very efficient container, with all its implementations
    providing a lot of optimizations that most developers are not capable of doing
    with arrays. Random access to its elements and insertion and removal at the end
    of a vector is a constant *O(1)* operation (provided that reallocation is not
    necessary), while insertion and removal anywhere else is a linear *O(n)* operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to other standard containers, the vector has various benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: It is compatible with arrays and C-like APIs. If a function takes an array as
    a parameter, the content of other containers (except for `std::array`) needs to
    be copied to a `vector` before being passed as an argument to the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has the fastest access to elements of all containers (but the same as `std::array`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has no per-element memory overhead for storing elements. This is because
    elements are stored in a contiguous space, like arrays are. Therefore, `vector`
    has a small memory footprint, unlike other containers, such as `list`, which require
    additional pointers to other elements, or associative containers, which require
    hash values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::vector` is very similar in semantics to arrays but has a variable size.
    The size of a vector can increase and decrease. There are two properties that
    define the size of a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Capacity* is the number of elements the vector can accommodate without performing
    additional memory allocations; this is indicated by the `capacity()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Size* is the actual number of elements in the vector; this is indicated by
    the `size()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Size is always smaller than or equal to capacity. When size is equal to capacity
    and a new element needs to be added, the capacity needs to be modified so that
    the vector has space for more elements. In this case, the vector allocates a new
    chunk of memory and moves the previous content to the new location before freeing
    the previously allocated memory. Though this sounds time-consuming—and it is—implementations
    increase the capacity exponentially by doubling it each time it needs to be changed.
    As a result, on average, each element of the vector only needs to be moved once
    (that is because all the elements of the vector are moved during an increase of
    capacity, but then an equal number of elements can be added without incurring
    more moves, given that insertions are performed at the end of the vector).
  prefs: []
  type: TYPE_NORMAL
- en: If you know beforehand how many elements will be inserted in the vector, you
    can first call the `reserve()` method to increase the capacity to at least the
    specified amount (this method does nothing if the specified size is smaller than
    the current capacity) and only then insert the elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if you need to free additional reserved memory, you can
    use the `shrink_to_fit()` method to request this, but it is an implementation
    decision as to whether to free any memory or not. An alternative to this non-binding
    method, available since C++11, is to do a swap with a temporary, empty vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Calling the `clear()` method only removes all the elements from the vector but
    does not free any memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be noted that the `vector` class implements some operations that
    are specific to other types of containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '*stack*: With `push_back()` and `emplace_back()` to add at the end and `pop_back()`
    to remove from the end. Keep in mind that `pop_back()` does not return the last
    element that has been removed. You need to access that explicitly, if that is
    necessary, for instance, using the `back()` method before removing the element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*list*: With `insert()` and `emplace()` to add elements in the middle of the
    sequence and `erase()` to remove elements from anywhere in the sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good rule of thumb for C++ containers is to use `std::vector` as the default
    container unless you have good reasons to use another one.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using bitset for fixed-size sequences of bits*, to learn about the standard
    container for handling bit sequences of fixed sizes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using vector<bool> for variable-size sequences of bits*, to learn about the
    specialization of `std::vector` for the `bool` type, intended for handling bit
    sequences of variable sizes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using bitset for fixed-size sequences of bits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not uncommon for developers to operate with bit flags. This can be either
    because they work with operating system APIs (usually written in C) that take
    various types of arguments (such as options or styles) in the form of bit flags,
    or because they work with libraries that do similar things, or simply because
    some types of problems are naturally solved with bit flags.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of alternatives to working with bits and bit operations, such as
    defining arrays that have one element for every option/flag, or defining a structure
    with members and functions to model the bit flags, but these are often more complicated;
    and in cases when you need to pass a numerical value representing bit flags to
    a function, you still need to convert the array or the structure to a sequence
    of bits. For this reason, the C++ standard provides a container called `std::bitset`
    for fixed-size sequences of bits.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you must be familiar with bitwise operations (AND, OR, XOR,
    NOT, and shifting – moving each digit in a number’s binary representation to the
    left or right). If you need to learn more about these, [https://en.wikipedia.org/wiki/Bitwise_operation](https://en.wikipedia.org/wiki/Bitwise_operation)
    is a good starting point.
  prefs: []
  type: TYPE_NORMAL
- en: The `bitset` class is available in the `std` namespace in the `<bitset>` header.
    A bitset represents a fixed-size sequence of bits, with the size defined at compile
    time. For convenience, in this recipe, most examples will be with bitsets of 8
    bits.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To construct an `std::bitset` object, use one of the available constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An empty bitset with all bits set to `0`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A bitset from a numerical value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A bitset from a string of `''0''` and `''``1''`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A bitset from a string containing any two characters representing `''0''` and
    `''1''`; in this case, we must specify which character represents a `0` (the fourth
    parameter, `''o''`) and which character represents a `1` (the fifth parameter,
    `''x''`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To test individual bits in the set or the entire set for specific values, use
    any of the available methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`count()` to get the number of bits set to `1`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`any()` to check whether there is at least one bit set to `1`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`all()` to check whether all the bits are set to `1`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`none()` to check whether all the bits are set to `0`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`test()` to check the value of an individual bit (whose position is the only
    argument to the function):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`operator[]` to access and test individual bits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To modify the content of a bitset, use any of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Member operators `|=`, `&=`, `^=`, and `~` to perform the binary operation
    OR, AND, XOR, and NOT, respectively. Alternatively, use the non-member operators
    `|`, `&`, and `^`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Member operators `<<=`, `<<`, `>>=`, and `>>` to perform shifting operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`flip()` to toggle the entire set or an individual bit from `0` to `1` or from
    `1` to `0`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`set()` to change the entire set or an individual bit to `true` or the specified
    value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`reset()` to change the entire set or an individual bit to `false`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To convert a bitset to a numerical or string value, use the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`to_ulong()` and `to_ullong()` to convert to `unsigned long` or `unsigned long
    long`. These operations throw an `std::overflow_error` exception if the value
    cannot be represented in the output type. Refer to the following examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`to_string()` to convert to `std::basic_string`. By default, the result is
    a string containing `''0''` and `''1''`, but you can specify a different character
    for these two values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’ve ever worked with C or C-like APIs, chances are you have either written
    or at least seen code that manipulates bits to define styles, options, or other
    kinds of values. This usually involves operations such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the bit flags; these can be enumerations, static constants in a class,
    or macros introduced with `#define` in the C style. Usually, there is a flag representing
    no value (style, option, and so on). Since these are supposed to be bit flags,
    their values are powers of 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding and removing flags from the set (that is, a numerical value). Adding
    a bit flag is done with the bit-or operator (`value |= FLAG`) and removing a bit
    flag is done with the bit-and operator, with the negated flag (`value &= ~FLAG`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing whether a flag is added to the set (`value & FLAG == FLAG`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling functions with the flags as an argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following shows a simple example of flags defining the border style of
    a control that can have a border on the left, right, top, or bottom sides, or
    any combination of these, including no border:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The standard `std::bitset` class is intended as a C++ alternative to this C-like
    working style with sets of bits. It enables us to write more robust and safer
    code because it abstracts the bit operations with member functions, though we
    still need to identify what each bit in the set is representing:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing flags is done with the `set()` and `reset()` methods, which
    set the value of a bit indicated by its position to `1` or `0` (or `true` and
    `false`); alternatively, we can use the index operator for the same purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing if a bit is set with the `test()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversion from an integer or a string is done through the constructor, and
    conversion to an integer or string is done with member functions so that the values
    from the bitsets can be used where integers are expected (such as arguments to
    functions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice that the constructors that build a `bitset` from a sequence of characters
    – be that a `std::basic_string`, a `const char*` (or any other character type),
    or a `std::basic_string_view` in C++26, may throw exceptions: `std::invalid_argument`,
    if any character is not the zero or one specified values, or `std::out_of_range`,
    if the starting offset into the sequence is beyond the end of the sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these operations, the `bitset` class has additional methods for
    performing bitwise operations on bits, shifting, testing, and others that have
    been shown in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually, `std::bitset` is a representation of a numerical value that enables
    you to access and modify individual bits. Internally, however, a `bitset` has
    an array of integer values on which it performs bit operations. The size of a
    `bitset` is not limited to the size of a numerical type; it can be anything, except
    that it is a compile-time constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example of the control border styles from the previous section can be written
    using `std::bitset` in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind this is only one possible implementation. For instance, the `border_flags`
    class could have been an enumeration. However, using a scoped enumeration would
    require explicit casts to `int`. Different solutions may have advantages and disadvantages.
    You can take it as an exercise to write an alternative solution.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A bitset can be created from an integer and can convert its value to an integer
    using the `to_ulong()` or `to_ullong()` methods. However, if the size of the `bitset`
    is larger than the size of these numerical types and any of the bits beyond the
    size of the requested numerical type is set to `1`, then these methods throw an
    `std::overflow_error` exception. This is because the value cannot be represented
    on `unsigned long` or `unsigned long long`. In order to extract all the bits,
    we need to do the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Clear the bits beyond the size of `unsigned long` or `unsigned long long`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert the value to `unsigned long` or `unsigned long long`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shift the `bitset` with the number of bits in `unsigned long` or `unsigned long
    long`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do this until all the bits are retrieved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To exemplify, let’s take the following `bitset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If we print its content, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when we convert this set to a sequence of `unsigned long` values using
    `biset_to_vectorulong()` and print their hexadecimal representation, we get the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: For cases where the size of the `bitset` cannot be known at compile time, the
    alternative is `std::vector<bool>`, which we will cover in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using vector<bool> for variable-size sequences of bits*, to learn about the
    specialization of `std::vector` for the `bool` type, which is used for handling
    bit sequences of variable sizes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using the bit manipulation utilities*, to explore the C++20 set of utility
    functions for bit manipulation from the numeric library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using vector<bool> for variable-size sequences of bits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we looked at using `std::bitset` for fixed-size sequences
    of bits. Sometimes, however, `std::bitset` is not a good choice because you do
    not know the number of bits at compile time, and just defining a set of a large
    enough number of bits is not a good idea. This is because you can get into a situation
    where the number is not actually large enough. The standard alternative for this
    is to use the `std::vector<bool>` container, which is a specialization of `std::vector`
    with space and speed optimizations since implementations do not actually store
    Boolean values, but individual bits for each element.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, however, `std::vector<bool>` does not meet the requirements
    of a standard container or sequential container, nor does `std::vector<bool>::iterator`
    meet the requirements of a forward iterator. As a result, this specialization
    cannot be used in generic code where a vector is expected. On the other hand,
    being a vector, it has a different interface from that of `std::bitset` and cannot
    be viewed as a binary representation of a number. There are no direct ways to
    construct `std::vector<bool>` from a number or string, nor to convert it to a
    number or string.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe assumes you are familiar with both `std::vector` and `std::bitset`.
    If you didn’t read the previous recipes, *Using vector as a default container*
    and *Using bitset for fixed-size sequences of bits*, you should read them before
    continuing.
  prefs: []
  type: TYPE_NORMAL
- en: The `vector<bool>` class is available in the `std` namespace in the `<vector>`
    header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To manipulate an `std::vector<bool>`, use the same methods you would use for
    an `std::vector<T>`, as shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating an empty vector:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Adding bits to the vector:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Setting the values of individual bits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using generic algorithms:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Removing bits from the vector:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::vector<bool>` is not a standard vector because it is designed to provide
    space optimization by storing a single bit for each element instead of a Boolean
    value. Therefore, its elements are not stored in a contiguous sequence and cannot
    be substituted for an array of Booleans. Due to this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The index operator cannot return a reference to a specific element because
    elements are not stored individually:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Dereferencing an iterator cannot produce a reference to `bool` for the same
    reason as mentioned earlier:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is no guarantee that individual bits can be manipulated independently
    at the same time from different threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vector cannot be used with algorithms that require forward iterators, such
    as `std::search()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vector cannot be used in some generic code where `std::vector<T>` is expected
    if such code requires any of the operations mentioned in this list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternative to `std::vector<bool>` is `std::dequeu<bool>`, which is a standard
    container (a double-ended queue) that meets all container and iterator requirements
    and can be used with all standard algorithms. However, this will not have the
    space optimization that `std::vector<bool>` provides.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::vector<bool>` interface is very different from `std::bitset`. If you
    want to be able to write code in a similar manner, you can create a wrapper on
    `std::vector<bool>`, which looks like `std::bitset`, where possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following implementation provides members similar to what is available
    in `std::bitset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This is only a basic implementation, and if you want to use such a wrapper,
    you should add additional methods, such as bit logic operations, shifting, maybe
    reading and writing from and to streams, and so on. However, with the preceding
    code, we can write the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: These examples are very similar to the examples where `std::bitset` was used.
    This `bitvector` class has an API compatible with `std::bitset` but is useful
    for handling bit sequences of variable sizes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using vector as a default container*, to learn how to use the `std::vector`
    standard container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using bitset for fixed-size sequences of bits*, to learn about the standard
    container for handling bit sequences of fixed sizes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using the bit manipulation utilities*, to explore the C++20 set of utility
    functions for bit manipulation from the numeric library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the bit manipulation utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we have seen how to use `std::bitset` and `std::vector<bool>`
    to work with fixed and variable sequences of bits. There are, however, situations
    when we need to manipulate or process individual or multiple bits of an unsigned
    integral value. This includes operations such as counting or rotating bits. The
    C++20 standard provides a set of utility functions for bit manipulation as part
    of the numeric library. In this recipe, we will learn what they are and how to
    use these utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The function templates discussed in this recipe are all available in the `std`
    namespace in the new C++20 header `<bit>`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following function templates to manipulate bits of unsigned integral
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to perform a circular shift, use `std::rotl<T>()` for left rotation
    and `std::rotr<T>()` for right rotation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you need to count the number of consecutive `0` bits (that is, until a `1`
    is found), use `std::countl_zero<T>()` to count from left to right (that is, starting
    with the most significant bit) and `std::countr_zero<T>()` to count from right
    to left (that is, starting with the least significant bit):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you need to count the number of consecutive `1` bits (that is, until a `0`
    is found), use `std::countl_one<T>()` to count from left to right (that is, starting
    with the most significant bit) and `std::countr_one<T>()` to count from right
    to left (that is, starting with the least significant bit):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you need to count the number of `1` bits, use `std::popcount<T>()`. The
    number of `0` bits is the number of digits used to represent the value (this can
    be determined with `std::numeric_limits<T>::digits`), minus the count of `1` bits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you need to check whether a number is a power of two, use `std::has_single_bit<T>()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you need to find the smallest power of two that is greater than or equal
    to a given number, use `std::bit_ceil<T>()`. On the other hand, if you need to
    find the largest power of two that is smaller than or equal to a given number,
    use `std::bit_floor<T>()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you need to determine the smallest number of digits to represent a number,
    use `std::bit_width<T>()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you need to reinterpret the object representation of a type `F` as that
    of a type `T`, then use `std::bit_cast<T, F>()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the function templates mentioned in the previous section, with the exception
    of `std::bit_cast<T, F>()` are only available for unsigned integral types. That
    includes the types `unsigned char`, `unsigned short`, `unsigned int`, `unsigned
    long`, and `unsigned long long`, as well as the fixed width unsigned integer types
    (such as `uint8_t`, `uint64_t`, `uint_least8_t`, `uintmax_t`, and so on). These
    functions are simple and should not require a detailed description.
  prefs: []
  type: TYPE_NORMAL
- en: The function that is different from the rest is `std::bit_cast<T, F>()`. Here,
    `F` is the type that is reinterpreted, and `T` is the type that we interpret to.
    This function template does not require `T` and `F` to be unsigned integral types,
    but both of them must be trivially copyable. Moreover, the `sizeof(T)` must be
    the same as the `sizeof(F)`.
  prefs: []
  type: TYPE_NORMAL
- en: The specification for this function does not mention the value of padding bits
    in the result. On the other hand, if the result value does not correspond to a
    valid value of the type `T`, then the behavior is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::bit_cast<T, F>()` can be `constexpr` if `T`, `F`, and the types of all
    their sub-objects are not a union type, a pointer type, a pointer to member type,
    or a volatile-qualified type, and have no non-static data members of a reference
    type.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using bitset for fixed-size sequences of bits*, to learn about the standard
    container for handling bit sequences of fixed sizes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using vector<bool> for variable-size sequences of bits*, to learn about the
    specialization of `std::vector` for the `bool` type intended for handling bit
    sequences of variable sizes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding elements in a range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common operations we do in any application is searching through
    data. Therefore, it is not surprising that the standard library provides many
    generic algorithms for searching through standard containers, or anything that
    can represent a range and is defined by a start and a past-the-end iterator. In
    this recipe, we will see what these standard algorithms are and how they can be
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For all the examples in this recipe, we will use `std::vector`, but all the
    algorithms work with ranges defined by a begin and past-the-end, either input
    or forward iterators, depending on the algorithm (for more information about the
    various types of iterators, see the *Writing your own random access iterator*
    recipe, later in this chapter). All these algorithms are available in the `std`
    namespace in the `<algorithm>` header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a list of algorithms that can be used for finding elements
    in a range:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `std::find()` to find a value in a range; this algorithm returns an iterator
    to the first element equal to the value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::find_if()` to find a value in a range that meets a criterion from
    a unary predicate; this algorithm returns an iterator to the first element for
    which the predicate returns `true`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::find_if_not()` to find a value in a range that does not meet a criterion
    from a unary predicate; this algorithm returns an iterator to the first element
    for which the predicate returns `false`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::find_first_of()` to search for the occurrence of any value from a
    range in another range; this algorithm returns an iterator to the first element
    that is found:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::find_end()` to find the last occurrence of a subrange of elements
    in a range; this algorithm returns an iterator to the first element of the last
    subrange in the range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To find the minimum and the maximum elements in a range, use `std::min_element()`
    for the minimum, `std::max_element()` for the maximum, and `std::minmax_element()`
    for both the minimum and the maximum:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::search()` to search for the first occurrence of a subrange in a range;
    this algorithm returns an iterator to the first element of the subrange in the
    range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::search()` with a *searcher*, which is a class that implements a searching
    algorithm and meets some predefined criteria. This overload of `std::search()`
    was introduced in C++17, and available standard searchers implement the *Boyer-Moore*
    and *Boyer-Moore-Horspool* string searching algorithms:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::search_n()` to search for *N* consecutive occurrences of a value
    in a range; this algorithm returns an iterator to the first element of the found
    sequence in the range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::adjacent_find()` to find two adjacent elements in a range that are
    equal or satisfy a binary predicate; this algorithm returns an iterator to the
    first element that is found:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::binary_search()` to find whether an element exists in a sorted range;
    this algorithm returns a Boolean value to indicate whether the value was found
    or not:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::lower_bound()` to find the first element in a range not less than
    a specified value; this algorithm returns an iterator to the element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::upper_bound()` to find the first element in a range greater than
    a specified value; this algorithm returns an iterator to the element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::equal_range()` to find a subrange in a range whose values are equal
    to a specified value. This algorithm returns a pair of iterators defining the
    first and the one-past-end iterators to the subrange; these two iterators are
    equivalent to those returned by `std::lower_bound()` and `std::upper_bound()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The way these algorithms work is very similar: they all take, as arguments,
    iterators that define the searchable range and additional arguments that depend
    on each algorithm. With the exception of `std::binary_search()`, which returns
    a Boolean, and `std::equal_range()`, which returns a pair of iterators, they all
    return an iterator to the searched element or to a subrange. These iterators must
    be compared with the end iterator (that is, the past-last-element) of the range
    to check whether the search was successful or not. If the search did not find
    an element or a subrange, then the returned value is the end iterator.'
  prefs: []
  type: TYPE_NORMAL
- en: All these algorithms have multiple overloads, but in the *How to do it...* section,
    we only looked at one particular overload to show how the algorithm can be used.
    For a complete reference of all overloads, you should see other sources, such
    as [https://en.cppreference.com/w/cpp/algorithm](https://en.cppreference.com/w/cpp/algorithm).
  prefs: []
  type: TYPE_NORMAL
- en: In all the preceding examples, we used constant iterators, but all these algorithms
    work the same with mutable iterators and with reverse iterators. Because they
    take iterators as input arguments, they can work with standard containers, arrays,
    or anything that represents a sequence and has iterators available.
  prefs: []
  type: TYPE_NORMAL
- en: 'A special note on the `std::binary_search()` algorithm is necessary: the iterator
    parameters that define the range to search in should at least meet the requirements
    of the forward iterators. Regardless of the type of the supplied iterators, the
    number of comparisons is always logarithmic on the size of the range. However,
    the number of iterator increments is different if the iterators are random access,
    in which case the number of increments is also logarithmic, or are not random
    access, in which case it is linear and proportional to the size of the range.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All these algorithms, except for `std::find_if_not()`, were available before
    C++11\. However, some overloads of them have been introduced in the newer standards.
    An example is `std::search()`, which has several overloads that were introduced
    in C++17\. One of these overloads has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This overload searches for the occurrence of a pattern defined by a searcher
    function object for which the standard provides several implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`default_searcher` basically delegates the searching to the standard `std::search()`
    algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boyer_moore_searcher` implements the Boyer-Moore algorithm for string searching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boyer_moore_horspool_algorithm` implements the Boyer-Moore-Horspool algorithm
    for string searching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many standard containers have a member function `find()` for finding elements
    in the container. When such a method is available and suits your needs, it should
    be preferred to the general algorithms because these member functions are optimized
    based on the particularities of each container.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using vector as a default container*, to see how to use the `std::vector`
    standard container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Initializing a range*, to explore the standard algorithms for filling a range
    with values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using set operations on a range*, to learn about the standard algorithms used
    to perform union, intersection, or difference of sorted ranges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sorting a range*, to learn about the standard algorithms for sorting ranges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting a range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we looked at the standard general algorithms for searching
    in a range. Another common operation we often need to do is sorting a range because
    many routines, including some of the algorithms for searching, require a sorted
    range. The standard library provides several general algorithms for sorting ranges,
    and in this recipe, we will see what these algorithms are and how they can be
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sorting general algorithms work with ranges defined by a start and end iterator
    and, therefore, can sort standard containers, arrays, or anything that represents
    a sequence and has random iterators available. However, all the examples in this
    recipe will use `std::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a list of standard general algorithms for searching a range:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `std::sort()` for sorting a range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::stable_sort()` for sorting a range but keeping the order of the equal
    elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::partial_sort()` for sorting a part of a range (and leaving the rest
    in an unspecified order):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::partial_sort_copy()` for sorting a part of a range by copying the
    sorted elements to a second range and leaving the original range unchanged:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::nth_element()` for sorting a range so that the *N*th element is the
    one that would be in that position if the range was completely sorted, and the
    elements before it are all smaller and the ones after it are all greater, without
    any guarantee that they are also ordered:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::is_sorted()` to check whether a range is sorted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::is_sorted_until()` to find a sorted subrange from the beginning of
    a range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the preceding general algorithms take random iterators as arguments to
    define the range to be sorted. Some of them also take an output range. They all
    have overloads: one that requires a comparison function for sorting the elements
    and one that does not and uses `operator<` for comparing the elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These algorithms work in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::sort()` modifies the input range so that its elements are sorted according
    to the default or the specified comparison function; the actual algorithm for
    sorting is an implementation detail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::stable_sort()` is similar to `std::sort()`, but it guarantees to preserve
    the original order of elements that are equal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::partial_sort()` takes three iterator arguments indicating the first,
    middle, and last element in a range, where middle can be any element, not just
    the one at the natural middle position. The result is a partially sorted range
    so that the first *middle* – *first* smallest elements from the original range,
    that is, [*first*, *last*), are found in the [*first*, *middle*) subrange and
    the rest of the elements are in an unspecified order in the [*middle*, *last*)
    subrange.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::partial_sort_copy()` is not a variant of `std::partial_sort()`, as the
    name may suggest, but of `std::sort()`. It sorts a range without altering it by
    copying its elements to an output range. The arguments of the algorithm are the
    first and last iterators of the input and output ranges. If the output range has
    a size *M* that is greater than or equal to the size *N* of the input range, the
    input range is entirely sorted and copied to the output range; the first *N* elements
    of the output range are overwritten, and the last *M* – *N* elements are left
    untouched. If the output range is smaller than the input range, then only the
    first *M* sorted elements from the input range are copied to the output range
    (which is entirely overwritten in this case).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::nth_element()` is basically an implementation of a selection algorithm,
    which is an algorithm for finding the *N*th smallest element of a range. This
    algorithm takes three iterator arguments representing the first, *N*th, and last
    element, and partially sorts the range so that, after sorting, the *N*th element
    is the one that would be in that position if the range had been entirely sorted.
    In the modified range, all the *N* – 1 elements before the *N*th one are smaller
    than it, and all the elements after the *N*th element are greater than it. However,
    there is no guarantee on the order of these other elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::is_sorted()` checks whether the specified range is sorted according to
    the specified or default comparison function and returns a Boolean value to indicate
    that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::is_sorted_until()` finds a sorted subrange of the specified range, starting
    from the beginning, using either a provided comparison function or the default
    `operator<`. The returned value is an iterator representing the upper bound of
    the sorted subrange, which is also the iterator of the one-past-last sorted element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some standard containers, `std::list` and `std::forward_list`, provide a member
    function, `sort()`, which is optimized for those containers. These member functions
    should be preferred over the general standard algorithm, `std::sort()`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using vector as a default container*, to learn how to use the `std::vector`
    standard container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Initializing a range* to explore the standard algorithms for filling a range
    with values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using set operations on a range*, to learn about the standard algorithms used
    to perform union, intersection, or difference of sorted ranges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Finding elements in a range*, to learn about the standard algorithms for searching
    through sequences of values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing a range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we explored the general standard algorithms for searching
    in a range and sorting a range. The algorithms library provides many other general
    algorithms, and among them are several that are intended for filling a range with
    values. In this recipe, you will learn what these algorithms are and how they
    should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the examples in this recipe use `std::vector`. However, like all the general
    algorithms, the ones we will see in this recipe take iterators to define the bounds
    of a range and can therefore be used with any standard container, arrays, or custom
    types representing a sequence that have forward iterators defined.
  prefs: []
  type: TYPE_NORMAL
- en: Except for `std::iota()`, which is available in the `<numeric>` header, all
    the other algorithms are found in the `<algorithm>` header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To assign values to a range, use any of the following standard algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::fill()` to assign a value to all the elements of a range; the range is
    defined by a first and last forward iterator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::fill_n()` to assign values to a number of elements of a range; the range
    is defined by a first forward iterator and a counter that indicates how many elements
    should be assigned the specified value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::generate()` to assign the value returned by a function to the elements
    of a range; the range is defined by a first and last forward iterator, and the
    function is invoked once for each element in the range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::generate_n()` to assign the value returned by a function to a number
    of elements of a range; the range is defined by a first forward iterator and a
    counter that indicates how many elements should be assigned the value from the
    function that is invoked once for each element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::iota()` to assign sequentially increasing values to the elements of a
    range; the range is defined by a first and last forward iterator, and the values
    are incremented using the prefix `operator++` from an initial specified value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::fill()` and `std::fill_n()` work similarly but differ in the way the
    range is specified: for the former by a first and last iterator, for the latter
    by a first iterator and a count. The second algorithm returns an iterator, representing
    either the one-past-last assigned element if the counter is greater than zero,
    or an iterator to the first element of the range otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::generate()` and `std::generate_n()` are also similar, differing only
    in the way the range is specified. The first takes two iterators, defining the
    range’s lower and upper bounds, while the second takes an iterator to the first
    element and a count. Like `std::fill_n()`, `std::generate_n()` also returns an
    iterator, representing either the one-past-last assigned element if the count
    is greater than zero, or an iterator to the first element of the range otherwise.
    These algorithms call a specified function for each element in the range and assign
    the returned value to the element. The generating function does not take any argument,
    so the value of the argument cannot be passed to the function. This is because
    it’s intended as a function to initialize the elements of a range. If you need
    to use the value of the elements to generate new values, you should use `std::transform()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::iota()` takes its name from the `ι` (iota) function from the APL programming
    language, and though it was a part of the initial STL, it was only included in
    the standard library in C++11\. This function takes a first and last iterator
    to a range, as well as an initial value that is assigned to the first element
    of the range. These are then used to generate sequentially increasing values using
    the prefix `operator++` for the rest of the elements in the range.'
  prefs: []
  type: TYPE_NORMAL
- en: '**STL** stands for the **Standard Template Library**. It is a software library
    designed by Alexander Stepanov initially for C++ before the standardization of
    the C++ language. It was later used to model the C++ standard library, providing
    containers, iterators, algorithms, and functions. It should not be confused with
    the C++ standard library, as these two are distinct entities.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The examples we saw in this recipe used integers so they would be easy to follow.
    However, we can also provide a real-life example to help you better understand
    how these algorithms can be used for more complex scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a function that given two colors generates a series of intermediary
    points, representing a gradient. A color object has three values, one for the
    red, green, and blue channels. We can model it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We will write a function that takes the start and end color, as well as the
    number of points to generate, and returns a vector of `color` objects. Internally,
    this uses `std::generate_n()` to generate the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the output of running this snippet has 256 lines (one for each point),
    we can show an excerpt of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Sorting a range*, to learn about the standard algorithms for sorting ranges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using set operations on a range*, to learn about the standard algorithms used
    to perform union, intersection, or difference of sorted ranges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Finding elements in a range*, to learn about the standard algorithms for searching
    through sequences of values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 2*, *Generating pseudo-random numbers*, to understand the proper ways
    for generating pseudo-random numbers in C++'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 2*, *Initializing all bits of internal state of a pseudo-random number
    generator*, to learn how to properly initialize random number engines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using set operations on a range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard library provides several algorithms for set operations that enable
    us to do unions, intersections, or differences of sorted ranges. In this recipe,
    we will see what these algorithms are and how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The algorithms for set operations work with iterators, which means they can
    be used for standard containers, arrays, or any custom type representing a sequence
    that has input iterators available. All the examples in this recipe will use `std::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For all the examples in the next section, we will use the following ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: In the following section, we will explore the use of the standard algorithm
    for set operations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following general algorithms for set operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::set_union()` to compute the union of two ranges into a third range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::merge()` to merge the content of two ranges into a third one; this is
    similar to `std::set_union()` except that it copies the entire content of the
    input ranges into the output one, not just their union:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::set_intersection()` to compute the intersection of the two ranges into
    a third range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::set_difference()` to compute the difference of two ranges into a third
    range; the output range will contain elements from the first range, which are
    not present in the second range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::set_symmetric_difference()` to compute a dual difference of the two ranges
    into a third range; the output range will contain elements that are present in
    any of the input ranges, but only in one:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::includes()` to check if one range is a subset of another range (that
    is, all its elements are also present in the other range):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the set operations that produce a new range from two input ranges have
    the same interface and work in a similar way:'
  prefs: []
  type: TYPE_NORMAL
- en: They take two input ranges, each defined by a first and last input iterator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They take an output iterator to an output range where elements will be inserted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have an overload that takes an extra argument representing a comparison
    binary function object that must return `true` if the first argument is less than
    the second. When a comparison function object is not specified, `operator<` is
    used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They return an iterator past the end of the constructed output range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input ranges must be sorted using either `operator<` or the provided comparison
    function, depending on the overload that is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output range must not overlap any of the two input ranges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will demonstrate the way they work with additional examples using vectors
    of a POD type called `Task` that we also used in a previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The particular way each algorithm produces the output range is described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::set_union()` copies all the elements present in one or both of the input
    ranges to the output range, producing a new sorted range. If an element is found
    *M* times in the first range and *N* times in the second range, then all the *M*
    elements from the first range will be copied to the output range in their existing
    order, and then the *N* – *M* elements from the second range are copied to the
    output range if *N* > *M*, or `0` elements otherwise:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::merge()` copies all the elements from both the input ranges into the
    output range, producing a new range sorted with respect to the comparison function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::set_intersection()` copies all the elements that are found in both the
    input ranges into the output range, producing a new range sorted with respect
    to the comparison function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::set_difference()` copies to the output range all the elements from the
    first input range that are not found in the second input range. For equivalent
    elements that are found in both ranges, the following rule applies: if an element
    is found *M* times in the first range and *N* times in the second range, and if
    *M* > *N*, then it is copied *M* – *N* times; otherwise, it is not copied:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::set_symmetric_difference()` copies to the output range all the elements
    that are found in either of the two input ranges but not in both of them. If an
    element is found *M* times in the first range and *N* times in the second range,
    then if *M* > *N*, the last *M* – *N* of those elements from the first range are
    copied into the output range; otherwise, the last *N* – *M* of those elements
    from the second range will be copied into the output range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On the other hand, `std::includes()` does not produce an output range; it only
    checks whether the second range is included in the first range. It returns a Boolean
    value that is `true` if the second range is empty or all its elements are included
    in the first range, or `false` otherwise. It also has two overloads, one of which
    specifies a comparison binary function object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using vector as a default container*, to learn how to use the `std::vector`
    standard container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sorting a range* to learn about the standard algorithms for sorting ranges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using iterators to insert new elements in a container*, to learn how to use
    iterators and iterator adapters to add elements to a range'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Finding elements in a range*, to learn about the standard algorithms for searching
    through sequences of values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using iterators to insert new elements into a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you’re working with containers, it is often useful to insert new elements
    at the beginning, end, or somewhere in the middle. There are algorithms, such
    as the ones we saw in the previous recipe, *Using set operations on a range*,
    that require an iterator to a range to insert into, but if you simply pass an
    iterator, such as the one returned by `begin()`, it will not insert but overwrite
    the elements of the container. Moreover, it’s not possible to insert at the end
    by using the iterator returned by `end()`. In order to perform such operations,
    the standard library provides a set of iterators and iterator adapters that enable
    these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The iterators and adapters discussed in this recipe are available in the `std`
    namespace in the `<iterator>` header. If you include headers such as `<algorithm>`,
    you do not have to explicitly include `<iterator>`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following iterator adapters to insert new elements into a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::back_inserter()` to insert elements at the end for containers that have
    a `push_back()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::front_inserter()` to insert elements at the beginning for containers
    that have a `push_front()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::inserter()` to insert anywhere in a container, for containers that have
    an `insert()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::back_inserter()`, `std::front_inserter()`, and `std::inserter()` are
    all helper functions that create iterator adapters of the types `std::back_insert_iterator`,
    `std::front_insert_iterator`, and `std::insert_iterator`. These are all output
    iterators that append, prepend, or insert into the container for which they were
    constructed. Incrementing and dereferencing these iterators does not do anything.
    However, upon assignment, these iterators call the following methods from the
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::back_insterter_iterator` calls `push_back()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::front_inserter_iterator` calls `push_front()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::insert_iterator` calls `insert()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the oversimplified implementation of `std::back_inserter_iterator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of the way the assignment operator works, these iterators can only
    be used with some standard containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::back_insert_iterator` can be used with `std::vector`, `std::list`, `std::deque`,
    and `std::basic_string`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::front_insert_iterator` can be used with `std::list`, `std::forward_list`,
    and `std:deque`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::insert_iterator` can be used with all the standard containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example inserts three elements with the value `0` at the beginning
    of an `std::vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The `std::inserter()` adapter takes two arguments: the container and the iterator
    where an element is supposed to be inserted. Upon calling `insert()` on the container,
    `std::insert_iterator` increments the iterator, so upon being assigned again,
    it can insert a new element into the next position. Take a look at the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These iterator adapters are intended to be used with algorithms or functions
    that insert multiple elements into a range. They can also be used, of course,
    to insert a single element, but that is rather an anti-pattern, since simply calling
    `push_back()`, `push_front()`, or `insert()` is much simpler and intuitive in
    this case. Consider the following snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The examples shown here, where adaptor iterators are used to insert a single
    element, should be avoided. They do not provide any benefit; they only make the
    code cluttered.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using set operations on a range*, to learn about the standard algorithms used
    to perform union, intersection, or difference of sorted ranges'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own random-access iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first chapter, we saw how we can enable range-based for loops for custom
    types by implementing iterators, as well as free `begin()` and `end()` functions
    to return iterators to the first and one-past-the-last element of the custom range.
    You might have noticed that the minimal iterator implementation that we provided
    in that recipe does not meet the requirements for a standard iterator. This is
    because it cannot be copy constructible or assigned and cannot be incremented.
    In this recipe, we will build upon that example and show you how to create a random-access
    iterator that meets all requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you should know the types of iterators the standard defines
    and how they are different. A good overview of their requirements is available
    at [http://www.cplusplus.com/reference/iterator/](http://www.cplusplus.com/reference/iterator/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To exemplify how to write a random-access iterator, we will consider a variant
    of the `dummy_array` class used in the *Enabling range-based for loops for custom
    types* recipe of *Chapter 1*, *Learning Modern Core Language Features*. This is
    a very simple array concept with no practical value other than serving as a code
    base for demonstrating iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: All the code shown in the next section, the iterator classes, typedefs, and
    the `begin()` and `end()` functions, will be a part of this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in this recipe, we will look at an example utilizing the following class
    called `Tag`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To provide mutable and constant random-access iterators for the `dummy_array`
    class shown in the previous section, add the following members to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An iterator class template, which is parameterized with the type of elements
    and the size of the array. The class must have the following public typedefs that
    define standard synonyms:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Private members for the iterator class—a pointer to the array data and a current
    index into the array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A private method for the iterator class to check whether two iterator instances
    point to the same array data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An explicit constructor for the iterator class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Iterator class members to meet common requirements for all iterators—copy-constructible,
    copy-assignable, destructible, prefix, and postfix incrementable. In this implementation,
    the post-increment operator is implemented in terms of the pre-increment operator
    to avoid code duplication:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Iterator class members to meet input iterator requirements—test for equality/inequality,
    dereferenceable as `rvalues`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Iterator class members to meet forward iterator requirements—default constructible:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Iterator class members to meet bidirectional iterator requirements—decrementable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Iterator class members to meet random access iterator requirements—arithmetic
    add and subtract, comparable for inequality with other iterators, compound assignments,
    and offset dereferenceable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add typedefs to the `dummy_array` class for mutable and constant iterator synonyms:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the public `begin()` and `end()` functions to the `dummy_array` class to
    return the iterators to the first and one-past-last elements in the array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard library defines five categories of iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input iterators**: These are the simplest category and guarantee validity
    only for single-pass sequential algorithms. After being incremented, the previous
    copies may become invalid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output iterators**: These are basically input iterators that can be used
    to write to the pointed element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forward iterators**: These can read (and write) data to the pointed element.
    They satisfy the requirements for input iterators and, in addition, must be default
    constructible and must support multi-pass scenarios without invalidating the previous
    copies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bidirectional iterators**: These are forward iterators that, in addition,
    support decrementing so that they can move in both directions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Random access iterators**: These support access to any element in the container
    in constant time. They implement all the requirements for bidirectional iterators,
    and, in addition, support arithmetic operations `+` and `-`, compound assignments
    `+=` and `-=`, comparisons with other iterators with `<`, `<=`, `>`, `>=`, and
    the offset dereference operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forward, bidirectional, and random-access iterators that also implement the
    requirements of output iterators are called *mutable iterators*.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we saw how to implement random access iterators, with
    a step-by-step walkthrough of the requirements of each category of iterators (as
    each iterator category includes the requirements of the previous category and
    adds new requirements). The iterator class template is common for both constant
    and mutable iterators, and we have defined two synonyms for it called `iterator`
    and `constant_iterator`.
  prefs: []
  type: TYPE_NORMAL
- en: After implementing the inner iterator class template, we also defined the `begin()`
    and `end()` member functions, which return an iterator to the first and the one-past-last
    element in the array, respectively. These methods have overloads to return mutable
    or constant iterators, depending on whether the `dummy_array` class instance is
    mutable or constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this implementation of the `dummy_array` class and its iterators, we can
    write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: For more examples, check the source code that accompanies this book.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from `begin()` and `end()`, a container may have additional methods such
    as `cbegin()`/`cend()` (for constant iterators), `rbegin()`/`rend()` (for mutable
    reverse iterators), and `crbegin()`/ `crend()` (for constant reverse iterators).
    Implementing this is left as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, in modern C++, these functions that return the first and
    last iterators do not have to be member functions but can be provided as non-member
    functions. In fact, this is the topic of the next recipe, *Container access with
    non-member functions*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 1*, *Enabling range-based for loops for custom types,* to learn to
    execute one or more statements for each element of a collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 1*, *Creating type aliases and alias templates*, to learn about aliases
    for types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container access with non-member functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Standard containers provide the `begin()` and `end()` member functions for
    retrieving iterators for the first and one-past-last elements of the container.
    There are actually four sets of these functions. Apart from `begin()`/`end()`,
    containers provide `cbegin()`/`cend()` to return constant iterators, `rbegin()`/`rend()`
    to return mutable reverse iterators, and `crbegin()`/`crend()` to return constant
    reverse iterators. In C++11/C++14, all these have non-member equivalents that
    work with standard containers, arrays, and any custom type that specializes them.
    In C++17, even more non-member functions have been added: `std::data()`, which
    returns a pointer to the block of memory containing the elements of the container;
    `std::size()`, which returns the size of a container or array; and `std::empty()`,
    which returns whether the given container is empty. These non-member functions
    are intended for generic code but can be used anywhere in your code. Moreover,
    in C++20, the `std::ssize()` non-member function was introduced to return the
    size of a container or array as a signed integer.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will use the `dummy_array` class and its iterators that we
    implemented in the previous recipe, *Writing your own random-access iterator*,
    as an example. You should read that recipe before continuing with this one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-member `begin()`/`end()` functions and the other variants, as well as non-member
    `data()`, `size()`, and `empty()` functions are available in the `std` namespace
    in the `<iterator>` header, which is implicitly included with any of the following
    headers: `<array>`, `<deque>`, `<forward_list>`, `<list>`, `<map>`, `<regex>`,
    `<set>`, `<string>`, `<unordered_map>`, `<unordered_set>`, and `<vector>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will refer to the `std::begin()`/`std::end()` functions,
    but everything discussed also applies to the other functions: `std::cbegin()`/`std::cend()`,
    `std::rbegin()`/`std::rend()`, and `std::crbegin()`/`std::crend()`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the non-member `std::begin()`/`std::end()` function and the other variants,
    as well as `std::data()`, `std::size()`, and `std::empty()` with:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard containers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Arrays:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Custom types that provide the corresponding member functions; that is, `begin()`/`end()`,
    `data()`, `empty()`, or `size()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generic code where the type of the container is not known:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These non-member functions were introduced in different versions of the standard,
    but all of them were modified in C++17 to return `constexpr auto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::begin()` and `std::end()` in C++11'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::cbegin()`/`std::cend()`, `std::rbegin()`/`std::rend()`, and `std::crbegin()`/`std::crend()`
    in C++14'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::data()`, `std::size()`, and `std::empty()` in C++17'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::ssize()` in C++20'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `begin()`/`end()` family of functions have overloads for container classes
    and arrays, and all they do is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Return the results of calling the container-corresponding member function for
    containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a pointer to the first or one-past-last element of the array for arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The actual typical implementation for `std::begin()`/`std::end()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Custom specialization can be provided for containers that do not have corresponding
    `begin()`/`end()` members but can still be iterated. The standard library actually
    provides such specializations for `std::initializer_list` and `std::valarray`.
  prefs: []
  type: TYPE_NORMAL
- en: Specializations must be defined in the same namespace where the original class
    or function template has been defined. Therefore, if you want to specialize any
    of the `std::begin()`/`std::end()` pairs, you must do so in the `std` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other non-member functions for container access that were introduced in
    C++17 also have several overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::data()` has several overloads; for a class `C` it returns `c.data()`,
    for arrays it returns the `array`, and for `std::initializer_list<T>` it returns
    the `il.begin()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::size()` has two overloads; for a class `C` it returns `c.size()`, and
    for arrays it returns the size `N`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::empty()` has several overloads; for a class `C` it returns `c.empty()`,
    for arrays it returns `false`, and for `std::initializer_list<T>` it returns `il.size()
    == 0`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In C++20, the `std::ssize()` non-member function was added as a companion to
    `std::size()` to return the number of elements in a given container or an array
    as a signed integer. `std::size()` returns an unsigned integer, but there are
    scenarios where a signed value is desired. For instance, the C++20 class `std::span`,
    which represents a view to a contiguous sequence of objects, has a `size()` member
    function that returns a signed integer, unlike standard library containers where
    the `size()` member function returns an unsigned integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason the function `size()` of `std::span` returns a signed integer is
    that the value -1 is supposed to represent a sentinel for types whose size was
    not known at compile time. Performing mixed signed and unsigned arithmetic can
    lead to errors in code that are hard to find. `std::ssize()` has two overloads:
    for a class `C` it returns `c.size()` statically cast to a signed integer (typically
    `std::ptrdiff_t`) and for arrays it returns `N`, the number of elements. Take
    a look at the following code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippets show possible implementations for the `std::ssize()`
    function for containers and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These non-member functions are mainly intended for template code where the container
    is not known and can be a standard container, an array, or a custom type. Using
    the non-member version of these functions enables us to write simpler and less
    code that works with all these types of containers.
  prefs: []
  type: TYPE_NORMAL
- en: However, the use of these functions is not and should not be limited to generic
    code. Though it is rather a matter of personal preference, it can be a good habit
    to be consistent and use them everywhere in your code. All these methods have
    lightweight implementations that will most likely be inlined by the compiler,
    which means that there will be no overhead at all for using the corresponding
    member functions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Writing your own random-access iterator*, to understand what you need to do
    to write a custom, random-access iterator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting the right standard containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard library contains a variety of containers for meeting multiple and
    various needs. There are sequence containers (in which elements are arranged in
    a certain position), container adapters (that provide a different interface for
    sequential containers), associative containers (in which the order is given by
    a key associated with an element), unordered associative containers (in which
    the elements do not follow a certain order). Selecting the right container for
    a given task is not always straight forward. This recipe will provide guidelines
    to help you decide which one to use for what purpose.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To decide which standard container you should use, consider the following guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `std::vector` as the default container, when no other specific requirements
    exist.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::array` when the length of a sequence is fixed and known at compile
    time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::deque` if you frequently need to add or remove elements at the beginning
    and the end of a sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::list` if you frequently need to add or remove elements in the middle
    of the sequence (that’s anywhere else other than the beginning and end) and bidirectional
    traversing of the sequence is required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::forward_list` if you frequently need to add or remove elements anywhere
    in the sequence but you only need to traverse the sequence in one direction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::stack` if you need a sequence with **last-in, first-out** (**LIFO**)
    semantics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::queue` if you need a sequence with **first-in, first-out** (**FIFO**)
    semantics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::priority_queue` if you need a sequence with FIFO semantics, but in
    which elements are arranged in a strict weak ordering (the largest – highest priority
    element comes first).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::unordered_map` if you need to store key-value pairs and the order
    of the elements is not important but keys must be unique.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::map` if you need to store key-value pairs with unique keys but the
    order of the elements is given by their keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::unordered_multimap` if you need to store key-value pairs, the keys
    can be duplicated, and the order of the elements is not important.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::multimap` if you need to store key-value pairs, the keys can be duplicated,
    and the elements are stored in an order given by their keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::unordered_set` if you need to store unique values but their order
    is not important.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::set` if you need to store unique values but the order of the elements
    is important (the lowest elements are stored first).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::unordered_multiset` if you want to store non-unique values, although
    their order does not matter, and you want the search capabilities of a set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::multiset` if you want to store non-unique value, but the order of
    the elements matter, with those having a lowest key coming first, and you want
    the search capabilities of a set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Containers are objects that store other objects, internally managing the memory
    used by the stored objects. They provide access to elements and other functionality
    defined by standardized interfaces. There are four categories of containers in
    the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sequence containers** store elements in a certain order but this order does
    not depend on the value of the element. Sequence containers are typically implemented
    either as arrays (elements are stored contiguous in memory) or linked lists (elements
    are stored in nodes that point to others). The standard sequence containers are
    `std::array`, `std::vector`, `std::list`, `std::forward_list`, and `std::deque`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container adaptors** define an adapted interface towards a sequence container.
    These are `std::stack`, `std::queue`, and `std::priority_queue`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Associative containers** store elements in a certain order given by keys
    associated with each element. Although they support insertion and deletion, this
    cannot happen at a specific position but depends on the key. They provide good
    performance for searching elements, a binary search that has logarithmic complexity
    being possible for all containers. The standard associative containers are `std::map`,
    `std::set`, `std::multimap`, and `std::multiset`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unordered associative containers** store elements that are not ordered. These
    containers are implemented using hash tables, which makes searching elements a
    constant-time operation. Unlike associated containers, the unordered ones do not
    support binary search. Hash functions must be implemented for the types of the
    elements stored in an unordered associative container. The standard containers
    are `std::unordered_map`, `std::unordered_multimap`, `std::unordered_set`, and
    `std::unordered_multiset`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `std::vector` container is perhaps the most used one, as the code snippets
    in this book also show. A vector stores its elements sequentially in a contiguous
    memory. A vector can grow and shrink. Although elements can be inserted anywhere
    in the sequence, the most efficient operations are insertions and removals at
    the end of the sequence (with `push_back()` and `pop_back()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a conceptual representation of a vector before and after inserting
    an element at its end:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21549_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Inserting an element at the end of a vector'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inserting or removing elements anywhere other than the end of the sequence
    (with `insert()` and `erase()`) is less performant because all of the elements
    after the insertion/removal position must be moved in memory. If an insert operation
    would determine capacity of the vector (the number of elements that can be stored
    in the allocated memory) to be exceeded, a reallocation must occur. In this case,
    a new, larger contiguous sequence of memory is allocated, and all the stored elements
    are copied to this new buffer, along with the newly added ones, and the old memory
    chunk is deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'The next diagram shows a conceptual representation of a vector before and after
    inserting a new element in the middle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21549_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Inserting an element in the middle of a vector'
  prefs: []
  type: TYPE_NORMAL
- en: 'If frequent insertions or deletion also occur at the beginning of the sequence,
    a better alternative is the `std::deque` container. This allows fast inserts and
    removals at both ends (with `push_front()`/`pop_front()` and `push_back()`/`pop_back()`).
    Removals at the two ends do not invalidate pointers or references to the rest
    of the elements. However, unlike `std::vector`, `std::deque` does not store its
    elements contiguously in memory, but in a sequence of fixed-length arrays that
    require extra management. Although indexing elements involve two levels of pointer
    dereferencing, compared to just one for `std::vector`, expanding a `deque` is
    faster than for `vector`, because it does not require reallocating all the memory
    and copying the existing elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Neither `std::vector` nor `std::deque` have a good performance for insertions
    in the middle of the sequence (middle meaning anywhere other than the ends). A
    container that does offer constant time insertions in the middle is `std::list`.
    This is implemented as a double-linked list, which means elements are not stored
    in contiguous memory. The use cases for `std::list` are not many though. A typical
    one is the situations when you need to do many inserts and removals in the middle,
    more than iterations over the list. You can also use a `std::list` when you have
    one or more sequences that you need to split and join often.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you also need to retain the validity of iterators and references to the
    elements of the list even after an insert or removal, then `std::list` is a good
    candidate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'The next diagram shows a conceptual representation of a (double-linked) list
    and the insertion of a new element in the middle of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21549_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Inserting an element in the middle of a list'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to store values identified by a key, associative containers are
    the appropriate solution. Storing key-value pairs is possible with either `std::map`
    and `std::unordered_map`. These two containers differ significantly:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::map` stores the key-value pairs ordered by the key (using a comparison
    function, the default being `std::less`), while `std::unordered_map`, as the name
    implies, does not retain any order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::map` is implemented with self-balancing **binary search trees** (**BST**)
    such as red-back trees, while `std::unordered_map` is implemented with hash tables.
    Since hash tables require more book-keeping data, `std::unordered_map` uses more
    memory than `std::map` to store the same number of elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::map` provides logarithmic complexity, *O(log(n))*, for search operations,
    and the same plus a rebalancing for inserts and removals, while `std::unordered_map`
    provides constant-time, *O(1)*, on average for inserts, although worst case scenarios
    decrease to linear complexity, *O(n)*, for all search, insert, and remove operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on these differences, we can identify typical use cases for each of these
    containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::map` is recommended when:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to store the elements ordered in the container, so that they can be
    accessed in their defined order
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You need the successor or predecessor of an element
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to lexicographically compare maps with the `<`, `<=`, `>`, or `>=`
    operators
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to use algorithms such as `binary_search()`, `lower_bound()`, or `upper_bound()`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_map` is recommended when:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don’t need to store the unique objects in a particular order
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You perform a lot of inserts/removals and searches
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to access individual elements and iterating over the entire sequence
    is not required
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to use `std::unordered_map`, a hash function (either a specialization
    of `std::hash<T>` or a different implementation) must be defined for the type
    of the stored elements. This is necessary because in an `std::unordered_map`,
    elements are stored in buckets. The bucket to which an element is stored depends
    on the hash value of the key. A good hashing function can prevent collisions,
    allowing all operations to take constant time – *O(1)*. On the other hand, if
    the hashing function is not well crafted, it can lead to collisions that degrade
    searches and inserts/removals to linear complexity – *O(n)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to store unique objects but do not have a key associated with
    each object, the right standard containers are `std::set` and `std::unordered_set`.
    A set is very similar to a map, except that the object is also the key. These
    two containers, `std::set` and `std::unordered_set`, have the same differences
    we saw for `std::map` and `std::unordered_map`:'
  prefs: []
  type: TYPE_NORMAL
- en: In a `std::set` objects are ordered, while in a `std::unordered_set` they are
    unordered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::set` is implemented with red-black trees, while `std::unordered_set`
    is implemented with hash tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::set` provides logarithmic complexity, *O(log(n))*, for search operations,
    and the same plus a rebalancing for inserts and removals, while `std::unordered_set`
    provides constant-time, *O(1)*, on average for inserts, although worst case scenarios
    decrease to linear complexity, *O(n)*, for all search, insert, and remove operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking these differences into consideration and the similarities with the `std::map`/`std::unordered_map`
    containers, we can identify the same use-case scenarios for `std::set` as we did
    for `std::map` and for `std::unordered_set` as we did for `std::unordered_map`.
    Also, for using `std::unordered_set`, a hashing function must be defined for the
    type of the stored objects.
  prefs: []
  type: TYPE_NORMAL
- en: When you need to store more than one value associated with a key, you can use
    `std::multimap` and `std::unordered_multimap`. These two have the same considerations
    as `std::map` and `std::unordered_map`. We can say that `std::multimap` is to
    `std::map` what `std::unordered_multimap` is to `std::unordered_map`. Similarly,
    `std::multiset` and `std::unordered_multiset` can be used to store duplicates
    in a set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering all the various standard container types and their typical use
    based on their characteristics, we can use the following diagram to select the
    most appropriate container. The following diagram was created by me, based on
    the one created by Mikael Persson and shared on StackOverflow: ([https://stackoverflow.com/a/22671607/648078](https://stackoverflow.com/a/22671607/648078)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21549_05_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Flowchart for selecting the right standard container'
  prefs: []
  type: TYPE_NORMAL
- en: Although this recipe is intended as a guide for selecting the right standard
    container, it does not cover all containers and all possible considerations. When
    performance is key, the best choice may not be the typical one. In such a situation,
    you should try different implementations with different choices, benchmark them,
    and decide on a solution based on the results of your measurements.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using vector as a default container*, to learn how you can use the `std::vector`
    class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using vector<bool> for variable-size sequences of bits*, to understand how
    this `std::vector` specialization for bool can be used to manipulate sequence
    of bits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_05.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2659294082093549796.png)'
  prefs: []
  type: TYPE_IMG
