- en: Chapter 10. Introducing Lua!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。介绍Lua！
- en: '*In our last game, we''ll move to the new Cocos IDE and develop an entire game
    using the Lua scripting language. You''ll get to know and use the Lua bindings
    for the Cocos2d-x API, which is not much different from what we''ve been using
    in C++; if anything, it''s just a lot easier!*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在我们的上一场游戏中，我们将转向新的Cocos IDE，并使用Lua脚本语言开发整个游戏。你将了解并使用Cocos2d-x API的Lua绑定，这与我们之前在C++中使用的大致相同；如果有什么不同的话，那就是它更容易！*'
- en: 'This time, you''ll learn how to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你将学习如何：
- en: Create and publish a project in Cocos IDE
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Cocos IDE中创建和发布一个项目
- en: Code an entire game in Lua
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Lua编写整个游戏
- en: Use sprites, particles, labels, menus, and actions, but this time with the Lua
    bindings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用精灵、粒子、标签、菜单和动作，但这次使用Lua绑定
- en: Build a match-three game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个三消游戏
- en: So what is Lua like?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那Lua是什么样的呢？
- en: At the heart of Lua (which means moon in Portuguese), you have the table. You
    may think of it as being similar to a JavaScript object, only it's much more than
    that. It plays the part of arrays, dictionaries, enumerations, structures, and
    classes, among other things. It makes Lua the perfect language to manage large
    sets of data. You write a script that handles the data, and then keep feeding
    it different "stuff." An inventory or shop system, an interactive children's book—these
    types of projects could all benefit from Lua's table-centric power, as they can
    be built around a fixed template with a data table at its core.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lua的核心（在葡萄牙语中意为月亮），你有表。你可以把它想象成类似于JavaScript对象，但它远不止如此。它扮演着数组、字典、枚举、结构和类等角色。这使得Lua成为管理大量数据的完美语言。你编写一个处理数据的脚本，然后不断地给它提供不同的“东西”。存货或商店系统、互动儿童书——这些类型的项目都可以从Lua以表为中心的强大功能中受益，因为它们可以围绕一个固定模板和数据表的核心来构建。
- en: 'Its syntax, for those not used to a scripting language, can be a little odd,
    with its dos, thens, and ends. But once you get past this initial hurdle, you''ll
    find Lua quite user-friendly. Here are some of the "oddities" in its syntax:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不习惯脚本语言的人来说，其语法可能有点奇怪，因为它有dos、thens和ends。但一旦你克服了这个初步的障碍，你会发现Lua非常用户友好。以下是它语法中的一些“奇怪之处”：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Semicolons are optional.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 分号是可选的。
- en: 'A table can be turned into a template to generate instances of it, in other
    words, a class. Methods of the instance of the table must be accessed with a `:`
    notation:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 表可以被转换成模板以生成其实例，换句话说，就是一个类。必须使用 `:` 符号来访问表的实例方法：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'From inside the method, you refer to the instance of the class as `self`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法内部，你将类的实例称为 `self`：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, you can call the template''s method with a dot notation, passing
    the instance of that template to it as the first parameter:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用点符号调用模板的方法，将模板的实例作为第一个参数传递给它：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I admit, it's weird, but it can be useful at times as pretty much every method
    you write in Lua can be made available for other parts of your code—sort of the
    way static methods are used in traditional OOP languages.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我承认，这听起来很奇怪，但有时它很有用，因为你在Lua中编写的几乎所有方法都可以供代码的其他部分使用——有点像传统面向对象语言中静态方法的使用方式。
- en: Debugging in Lua – the knights who say nil
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lua中的调试 – 说nil的骑士
- en: 'Debugging your Lua code can be frustrating at times. But you soon learn to
    distinguish between the minute subtleties in Lua''s runtime errors. The compiler
    will say something is `nil` (Lua''s `null`) in about 99.9 percent of cases. It''s
    up to you to figure out why. Here are the main culprits:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 调试Lua代码有时可能会让人感到沮丧。但很快你就会学会区分Lua运行时错误中的细微差别。编译器会在大约99.9%的情况下告诉你某个东西是 `nil`（Lua的
    `null`）。这取决于你找出原因。以下是一些主要的原因：
- en: You are referencing an object's own property without prepending `self.` or `self:`.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在引用一个对象的属性时没有在前面加上 `self.` 或 `self:`。
- en: You are calling an instance method with a dot notation, and not passing the
    instance as the first parameter; something like `myObject.myMethod()` instead
    of `myObject.myMethod(myObject)`. Use `myObject:myMethod()` instead.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在使用点符号调用实例方法，而没有将实例作为第一个参数传递；例如 `myObject.myMethod()` 而不是 `myObject.myMethod(myObject)`。请使用
    `myObject:myMethod()`。
- en: You are referencing a variable from a place outside its scope. For example,
    a local variable declared inside an `if` statement is being referenced outside
    the conditional.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在引用一个在其作用域之外的地方的变量。例如，一个在 `if` 语句内部声明的局部变量正在条件外部被引用。
- en: You forgot to return the class object at the end of your class or module/table
    declaration.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在类或模块/表的声明结束时忘记了返回类对象。
- en: You tried to access the zero index of an array.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你尝试访问数组的零索引。
- en: You forgot to add a few dos and thens or ends.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你忘记添加一些 dos 和 thens 或 ends。
- en: And finally, maybe you're just having one of those days. A `nil` sort of day.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，也许你只是碰到了那种日子。一个 `nil` 类似的日子。
- en: The Cocos IDE will show errors in bold; the same bold it uses for global variables,
    which is confusing at times. But it helps nonetheless. Just make a habit of scanning
    your code for bold text!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos IDE 会用粗体显示错误；它与全局变量使用的相同粗体，有时会让人困惑。但无论如何，它还是有帮助的。只需养成检查代码中粗体文本的习惯即可！
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'You might need to increase the heap memory inside the IDE. The quickest way
    to accomplish this is to find the file called `eclipse.ini` inside the Cocos IDE
    application folder. On a Mac, this means inside the Cocos IDE app package: right-click
    on the app icon, select **Show Package Contents**, and then navigate to **Contents/MacOS/eclipse.ini**.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要增加 IDE 中的堆内存。完成此操作的最快方法是找到 Cocos IDE 应用程序文件夹中的名为 `eclipse.ini` 的文件。在 Mac
    上，这意味着在 Cocos IDE 应用程序包中：右键单击应用程序图标，选择**显示包内容**，然后导航到**Contents/MacOS/eclipse.ini**。
- en: Then find the line where you read `-Xmx256m` or `-Xmx512m` and change it to
    `-Xmx1024m`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后找到你读取 `-Xmx256m` 或 `-Xmx512m` 的行，并将其更改为 `-Xmx1024m`。
- en: This might help in slower computers. My laptop crashed a lot while running the
    IDE.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有助于较慢的计算机。我的笔记本电脑在运行 IDE 时经常崩溃。
- en: The game – Stone Age
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 《游戏 - 石器时代》
- en: This is a match-three game. You know, the kind of game that is making a couple
    of companies a gazillion dollars and making a gazillion other companies clone
    those games in order to earn a couple of dollars. Yes, that game!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个三消游戏。你知道，那种让一些公司赚得盆满钵满，让成千上万家公司克隆这些游戏以赚取一点钱的游戏。是的，就是那个游戏！
- en: You must match three or more gems. If you match more than three, a random gem
    bursts and turns into a diamond, which you collect for more points.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须匹配三个或更多的宝石。如果你匹配的宝石超过三个，一个随机宝石会爆炸并变成钻石，你可以收集这些钻石以获得更多分数。
- en: The game has a timer, and when time runs out, it's game over.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏有一个计时器，当时间耗尽时，游戏结束。
- en: I used pretty much the same structure as in the previous games in this book.
    But I broke it into separate modules so it's easier for you to use the code as
    a reference.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我基本上使用了这本书中之前游戏相同的结构。但我将其分解成独立的模块，这样你更容易将代码作为参考使用。
- en: We have a `MenuScene` and a `GameScene` item. I have pretty much all Cocos2d-x
    actions in one module called `GridAnimations` and most of the interactivity inside
    another module called `GridController`. And all object pools are kept inside a
    class called `ObjectPools`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个 `MenuScene` 和一个 `GameScene` 项目。我将几乎所有的 Cocos2d-x 动作放在一个名为 `GridAnimations`
    的模块中，大部分交互性放在另一个名为 `GridController` 的模块中。所有对象池都保存在一个名为 `ObjectPools` 的类中。
- en: 'This is a grid game, so it''s perfect to illustrate working with table arrays
    in Lua, and its main advantages over C++: it''s much easier to create and memory
    manage dynamic lists (arrays) in Lua. This flexibility, aligned with Cocos2d-x''s
    awesomeness, make for very rapid prototyping and development. The actual game
    will look like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个网格游戏，非常适合用来展示在 Lua 中使用表格数组，以及它相对于 C++ 的主要优势：在 Lua 中创建和内存管理动态列表（数组）要容易得多。这种灵活性，与
    Cocos2d-x 的强大功能相结合，使得原型设计和开发非常快速。实际的游戏将看起来像这样：
- en: '![The game – Stone Age](img/00039.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![《游戏 - 石器时代》](img/00039.jpeg)'
- en: But before you import the starter project, let me show you how to create a new
    project inside the Cocos IDE.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但在你导入起始项目之前，让我先向你展示如何在 Cocos IDE 中创建新项目。
- en: Time for action – creating or importing a project
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建或导入项目
- en: 'Nothing could be simpler; since the IDE is based on Eclipse, you know most
    of its main functionalities already:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比这更简单了；由于 IDE 基于 Eclipse，你知道它的许多主要功能：
- en: First let's set up the IDE to use the Lua bindings. Go to **Preferences** |
    **Cocos** | **Lua**, and in the drop-down menu for **Lua Frameworks**, find the
    Cocos2d-x framework folder you downloaded:![Time for action – creating or importing
    a project](img/00040.jpeg)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们设置 IDE 以使用 Lua 绑定。转到**首选项** | **Cocos** | **Lua**，然后在**Lua 框架**下拉菜单中找到您下载的
    Cocos2d-x 框架文件夹：![行动时间 - 创建或导入项目](img/00040.jpeg)
- en: Select **File** | **New** | **Cocos Lua Project**, if that option is already
    available, or select **File** | **New** | **Other** | **Cocos Lua** | **Cocos
    Lua Project**.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果该选项已经可用，请选择**文件** | **新建** | **Cocos Lua 项目**，或者选择**文件** | **新建** | **其他**
    | **Cocos Lua** | **Cocos Lua 项目**。
- en: In the **New Cocos Project** wizard, give your project a name and click **Next**.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**新建 Cocos 项目**向导中，给你的项目命名并点击**下一步**。
- en: In the next dialogue, you can choose your project's orientation and design size.
    And that's it. Click **Finish**.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个对话框中，您可以选择您项目的方向和设计大小。就这样。点击**完成**。
- en: In order to import a project, click **File** | **Import** then **Cocos** | **Import
    Cocos Project**, and navigate to the project start folder for this chapter. The
    game is called `StoneAge`. (Download this chapter's source files from this book's
    website if you haven't done so already. There is a starter project and a final
    project that you can run and test.)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了导入项目，点击**文件** | **导入**然后**Cocos** | **导入Cocos项目**，并导航到本章节的项目起始文件夹。游戏名为`StoneAge`。（如果您还没有下载，请从本书的网站下载本章节的源文件。这里有一个可以运行和测试的起始项目和最终项目。）
- en: '*What just happened?*'
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: You learned to create and import a project into the Cocos IDE. Since the IDE
    is an Eclipse-based program, the steps should be familiar to you by now.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您学会了如何在Cocos IDE中创建和导入项目。由于IDE是基于Eclipse的程序，这些步骤现在应该对您来说很熟悉。
- en: You may also wish to change the settings for the simulator. For that, all you
    need to do is right-click on your project and select either **Run As...** or **Debug
    As...**, and then **Run** or **Debug Configurations**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还希望更改模拟器的设置。为此，只需在您的项目上右键单击并选择**运行为...**或**调试为...**，然后选择**运行**或**调试配置**。
- en: 'It''s best to leave the default for the **Mac OSX** runtime (if you''re on
    a Mac of course), as this is the fastest option. But if you wish to change the
    simulator, here is where you do it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**Mac OSX**运行时（如果您在Mac上，当然），最好保持默认设置，因为这是最快的选择。但如果您想更改模拟器，这里就是您操作的地方：
- en: '![What just happened?](img/00041.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/00041.jpeg)'
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'On my machine, version 3.4 of the framework threw compile errors. I had to
    add two fixes in order to run Stone Age. In `cocos-cocos2d-Cocos2dConstants.lua`,
    just before the last table is declared, I added this line:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，框架的3.4版本抛出了编译错误。我不得不添加两个修复才能运行《石器时代》。在`cocos-cocos2d-Cocos2dConstants.lua`中，在最后一个表声明之前，我添加了这一行：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Similarly, in `cocos-ui-GuiConstants.lua`, I added `ccui.LayoutComponent = {}`
    before new tables are added to `LayoutComponent`, also near the end of the file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在`cocos-ui-GuiConstants.lua`中，我在添加新表到`LayoutComponent`之前添加了`ccui.LayoutComponent
    = {}`，也接近文件末尾。
- en: If you run into problems, switch to version 3.3, which was much more stable
    for Lua development.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到问题，切换到3.3版本，这个版本对Lua开发来说更加稳定。
- en: Time for action – setting up our screen resolution
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候动手设置我们的屏幕分辨率了
- en: 'The old `AppDelegate` class logic now exists inside a file called `main.lua`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的`AppDelegate`类逻辑现在存在于名为`main.lua`的文件中：
- en: In the IDE, open the `main.lua` file inside the `src` folder.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IDE中，打开`src`文件夹内的`main.lua`文件。
- en: 'After the line where we set the animation interval, type the following:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置动画间隔的行之后，输入以下内容：
- en: '[PRE5]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'I designed the game for iPhone retina, and here we set the appropriate scale
    and asset folder for both retina and non-retina phones. Next, let''s preload the
    sound files:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我为iPhone视网膜屏设计了这款游戏，并且我们为视网膜和非视网膜手机设置了适当的缩放和资源文件夹。接下来，让我们预加载声音文件：
- en: '[PRE6]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And finally, let''s set the ball rolling by creating and running our first
    scene:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们通过创建和运行我们的第一个场景来启动项目：
- en: '[PRE7]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*What just happened?*'
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: Like we've done in pretty much every game so far, we set the resolution policy
    and scale factor for our application and preloaded the sounds we'll be using.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在几乎每一款游戏中做的那样，我们设置了应用程序的分辨率策略和缩放因子，并预加载了我们将使用的声音。
- en: The game was designed only for phones this time, and it was designed with the
    iPhone 4 screen in mind, and it resizes to older phones.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这次游戏只针对手机设计，并且是以iPhone 4屏幕为设计目标，可以调整到旧手机。
- en: But don't run the game just yet. Let's create our menu scene. It has a little
    of everything in it and it will be a perfect introduction to the Cocos2d-x API
    in Lua.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在不要运行游戏。让我们创建我们的菜单场景。它包含了一些基本元素，这将是一个完美的Lua Cocos2d-x API入门介绍。
- en: Time for action – creating a menu scene
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候动手创建菜单场景了
- en: 'Let''s create a new file and add a menu scene to our game:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新文件，并将菜单场景添加到我们的游戏中：
- en: Right-click on the `src` folder and select **New** | **Lua File**; call the
    new file `MenuScene.lua`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`src`文件夹并选择**新建** | **Lua文件**；将新文件命名为`MenuScene.lua`。
- en: 'Let''s create a class that extends a scene. We first load our own module of
    all the game''s constants (this file already exists in the starter project):'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个扩展场景的类。我们首先加载我们自己的所有游戏常量模块（这个文件在起始项目中已经存在）：
- en: '[PRE8]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then we build our class:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们构建我们的类：
- en: '[PRE9]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We'll add the methods next, including the `init` method we called in the class
    constructor (always called `ctor`), but I wanted to stress the importance of returning
    the class at the end of its declaration.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将添加方法，包括在类构造函数中调用的`init`方法（总是称为`ctor`），但我想要强调在声明末尾返回类的的重要性。
- en: 'So moving just below the constructor, let''s continue building up our scene:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，在构造函数下方，让我们继续构建我们的场景：
- en: '[PRE10]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With this, we added a background and two other sprites, plus an animation of
    a pterodactyl flying in the background. Once again, the calls are remarkably similar
    to the ones in C++.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这种方式，我们添加了一个背景和两个其他精灵，以及一个翼龙在背景中飞行的动画。再一次，调用与C++中的调用非常相似。
- en: 'Now let''s add a menu with a play button (all this still inside the `init`
    method):'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`init`方法中添加一个带有播放按钮的菜单（所有这些仍然在`init`方法中）：
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Typing the button's callback inside the same method where the callback is referenced
    is similar to writing a block or even a lambda function in C++.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在引用回调的同一方法中键入按钮的回调，类似于在C++中编写一个块或甚至是lambda函数。
- en: '*What just happened?*'
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You created a scene in Lua with Cocos2d-x using a menu, a few sprites, and an
    animation. It's easy to see how similar the calls are in the Lua bindings to the
    original C++ ones. And with code completion inside the IDE, finding the correct
    methods is a breeze.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用Cocos2d-x和Lua创建了一个场景，其中包括一个菜单、几个精灵和一个动画。很容易看出Lua绑定与原始C++绑定的调用是多么相似。而且，在IDE中的代码补全功能使得查找正确的方法变得轻而易举。
- en: Now let's tackle the `GameScene` class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们处理`GameScene`类。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'One of the nicest features of Lua is something called **live coding**, and
    it''s switched on by default in the Cocos IDE. To see what I mean by live coding,
    do this: while the game is running in the simulator, change the position of the
    character sprite in your code and save it. You should see the change taking effect
    in the simulator. This is a great way to build UI and game scenes.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Lua最吸引人的特性之一是所谓的**实时编码**，在Cocos IDE中默认开启。为了了解我所说的实时编码是什么意思，这样做：当游戏在模拟器中运行时，更改你的代码中角色精灵的位置并保存它。你应该会在模拟器中看到变化生效。这是一种构建UI和游戏场景的绝佳方式。
- en: Time for action – creating our game scene
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——创建我们的游戏场景
- en: 'The `GameScene` class is already added to the start project and some of the
    code is already in place. We''ll focus first on building the game''s interface
    and listening to touches:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameScene`类已经添加到起始项目中，并且一些代码已经就位。我们首先将专注于构建游戏界面和监听触摸：'
- en: 'Let''s work on the `addTouchEvents` method:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们专注于`addTouchEvents`方法：
- en: '[PRE12]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once again, we register the events with the node''s instance of the event dispatcher.
    The actual touches are handled by our `GridController` object. We''ll go over
    those later; first, let''s build the UI. Time to work on the `init` method:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们使用节点的事件分发器的实例注册事件。实际的触摸由我们的`GridController`对象处理。我们稍后会介绍这些；首先，让我们构建UI。现在是时候在`init`方法上工作了：
- en: '[PRE13]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Create our special objects, one to handle user interactivity, another for animations,
    and our good old object pool.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建我们的特殊对象，一个用于处理用户交互，另一个用于动画，以及我们熟悉的对象池。
- en: 'Next, we add a couple of nodes and our score labels:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加几个节点和我们的得分标签：
- en: '[PRE14]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The main difference when compared to the C++ implementation of `Label:createWithTTF`
    is that, in Lua, we have a configuration table for the font.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Label:createWithTTF`的C++实现相比，主要的不同之处在于Lua中有一个字体配置表。
- en: '*What just happened?*'
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: This time, we saw how to register for touch events and how to create true type
    font labels. Next, we'll go over creating a typical grid for a match-three game.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们学习了如何注册触摸事件以及如何创建真类型字体标签。接下来，我们将介绍如何创建一个典型的三消游戏的网格。
- en: Time for action – building the gems
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——构建宝石
- en: 'There are basically two types of match-three games, those in which the selection
    of matches takes place automatically and those in which the matches are selected
    by the player. *Candy Crush* is a good example of the former, and *Diamond Dash*
    of the latter. When building the first type of game, you must add extra logic
    to ensure you start the game with a grid that contains no matches. This is what
    we''ll do now:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 三消游戏基本上有两种类型，一种是在游戏中自动进行匹配选择，另一种是由玩家进行选择。*糖果传奇*是前者的一个好例子，而*钻石冲刺*则是后者。在构建第一种类型的游戏时，你必须添加额外的逻辑来确保你开始游戏时网格中不包含任何匹配项。我们现在就要这样做：
- en: 'We start with the `buildGrid` method:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`buildGrid`方法开始：
- en: '[PRE15]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Ensure that we generate a different random series of gems each time we run the
    game by changing the `randomseed` value.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过更改 `randomseed` 值，确保每次运行游戏时都生成不同的随机宝石序列。
- en: The `enabled` property will stop user interactions while the grid is being altered
    or animated.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当网格正在更改或动画时，`enabled` 属性将阻止用户交互。
- en: The grid is a two-dimensional array of columns of gems. The magic happens in
    the `getVerticalUnique` and `getVerticalHorizontalUnique` methods.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 网格是由宝石列组成的二维数组。魔法发生在 `getVerticalUnique` 和 `getVerticalHorizontalUnique` 方法中。
- en: 'To ensure that none of the gems will form a three-gem-match on the first two
    columns, we check them vertically:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保没有任何宝石会在前两列形成三个宝石的匹配，我们垂直检查它们：
- en: '[PRE16]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All this code is doing is checking a column to see if any gem is forming a string
    of three connected gems of the same type.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有这些代码所做的只是检查一列，看看是否有任何宝石正在形成相同类型的三个相连宝石的字符串。
- en: 'Then, we check both vertically and horizontally, starting with column 3:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们垂直和水平检查，从第三列开始：
- en: '[PRE17]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This algorithm is doing the same thing we did previously with the columns, but
    it's also checking on individual rows.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法正在执行我们之前对列所做的相同操作，但它还在单独的行上进行检查。
- en: '*What just happened?*'
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We created a grid of gems, free of any three-gem matches. Again, if we had built
    the sort of match-three game where the user must select clusters of matched gems
    to have these removed from the grid (like *Diamond Dash*), we would not have to
    bother with this logic at all.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个没有三个宝石匹配的宝石网格。再次强调，如果我们构建了用户必须选择匹配宝石簇以从网格中移除的匹配三游戏（如 *Diamond Dash*），我们根本不需要担心这个逻辑。
- en: Next, let's manipulate the grid with gem swaps, identification of matches, and
    grid collapse.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过宝石交换、识别匹配和网格折叠来操作网格。
- en: Time for action – changing the grid with GridController
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候采取行动了——使用 GridController 改变网格。
- en: 'The `GridController` object initiates all grid changes since it''s where we
    handle touches. In the game, the user can drag a gem to swap places with another,
    or first select the gem they want to move and then select the gem they want to
    swap places with in a two-touch process. Let''s add the touch handling for that:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridController` 对象启动所有网格更改，因为这是我们处理触摸的地方。在游戏中，用户可以拖动宝石与另一个宝石交换位置，或者首先选择他们想要移动的宝石，然后在两指触摸过程中选择他们想要交换位置的宝石。让我们添加处理这种触摸的代码：'
- en: 'In `GridController`, let''s add the logic to `onTouchDown`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GridController` 中，让我们添加 `onTouchDown` 的逻辑：
- en: '[PRE18]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If we are displaying the game over screen, restart the scene.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们正在显示游戏结束屏幕，则重新启动场景。
- en: 'Next, we find the gem the user is trying to select:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们找到用户试图选择的宝石：
- en: '[PRE19]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We find the gem closest to the touch position. If the user has not selected
    a gem yet (`selectedGem = nil`), we set the one just touched as the first gem
    selected. Otherwise, we determine whether the second gem selected can be used
    for a swap. Only gems above and below the first selected gem, or the ones to the
    left and right of it, can be swapped with. If that is valid, we use the second
    gem as the target gem.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们找到离触摸位置最近的宝石。如果用户尚未选择宝石（`selectedGem = nil`），我们将刚刚触摸到的宝石作为第一个选中的宝石。否则，我们确定第二个选中的宝石是否可以用于交换。只有位于第一个选中宝石上方和下方的宝石，或者位于其左右两侧的宝石可以交换。如果这是有效的，我们就使用第二个宝石作为目标宝石。
- en: 'Before moving on to `onTouchMove` and `onTouchUp`, let''s see how we determine
    which gem is being selected and which gem is a valid target gem. So let''s work
    on the `findGemAtPosition` value. Begin by determining where in the grid container
    the touch landed:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续到 `onTouchMove` 和 `onTouchUp` 之前，让我们看看我们是如何确定哪个宝石被选中以及哪个宝石是有效目标宝石的。所以让我们处理
    `findGemAtPosition` 值。首先确定触摸落在网格容器中的位置：
- en: '[PRE20]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is where the magic happens. We use the `x` and `y` position of the touch
    inside the grid to determine the index of the gem inside the array:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是魔法发生的地方。我们使用网格内触摸的 `x` 和 `y` 位置来确定数组中宝石的索引：
- en: '[PRE21]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We finish by checking whether the touch is out of array bounds.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们最后检查触摸是否超出数组界限。
- en: 'And now let''s see the logic to determine whether the target gem is a valid
    target:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看看确定目标宝石是否为有效目标的逻辑：
- en: '[PRE22]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We first check to see whether the target gem is at the top, bottom, left, or
    right of the selected gem:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先检查目标宝石是否位于所选宝石的顶部、底部、左侧或右侧：
- en: '[PRE23]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We next use a bit of trig magic to determine whether the selected target gem
    is diagonal to the selected gem:'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们接下来使用一点三角学的魔法来确定所选的目标宝石是否与所选宝石对角线：
- en: '[PRE24]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We finish by checking whether the target gem is not the same as the previously
    selected gem.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们最后检查目标宝石是否与之前选中的宝石不同。
- en: 'Now, let''s move on to the `onTouchUp` event handling:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续处理`onTouchUp`事件：
- en: '[PRE25]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Pretty simple! We just change the `z` layering of the selected gem, as we want
    to make sure that the gem is shown above the others when the swap takes place.
    So when we release the gem, we push it back to its original `z` level (which is
    what the `dropSelectedGem` method does, and we'll see how it does this soon).
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 很简单！我们只是改变了选择宝石的`z`层级，因为我们想确保在交换发生时宝石显示在其他宝石之上。所以当我们释放宝石时，我们将其推回到原始的`z`层级（这就是`dropSelectedGem`方法所做的事情，我们很快就会看到它是如何做到这一点的）。
- en: 'The `onTouchMove` event handles the option of dragging the selected gem until
    it swaps places with another gem:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onTouchMove`事件处理选择宝石拖动直到它与另一个宝石交换位置：'
- en: '[PRE26]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We run most of the same logic as we did with `onTouchDown`. We move the `selectedGem`
    object until a suitable target gem is identified, and then we pick the second
    one as the target. This is when the swap happens. Let's do that now.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们运行了与`onTouchDown`相同的逻辑。我们将`selectedGem`对象移动，直到找到一个合适的目标宝石，然后选择第二个作为目标。这就是交换发生的时候。现在让我们来做这件事。
- en: 'First, the logic that sets our selected gem:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，设置我们选择宝石的逻辑：
- en: '[PRE27]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We start the swapping process; we have a selected gem but no target gem. We
    change the layering of the selected gem through `setLocalZOrder`. We also make
    the selected gem rotate 360 degrees.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们开始交换过程；我们有一个选择的宝石但没有目标宝石。我们通过`setLocalZOrder`改变选择宝石的层级。同时，我们也让选择宝石旋转360度。
- en: 'Then, we''re ready to select the target gem:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们准备好选择目标宝石：
- en: '[PRE28]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It is now that we finally call our `GameScene` class and ask it to swap the
    gems.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们最终调用`GameScene`类并要求它交换宝石的时候了。
- en: '*What just happened?*'
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just added the logic to handle all the user interactivity. Now, all that's
    left for us to do is handle the swaps, checking for matches and collapsing the
    grid. Let's do it!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加了处理所有用户交互的逻辑。现在，我们剩下要做的就是处理交换，检查匹配项并折叠网格。让我们来做吧！
- en: Time for action – swapping the gems and looking for matches
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 交换宝石并寻找匹配项
- en: 'The swapping logic is found in `GameScene` in the `swapGemsToNewPosition` method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 交换逻辑位于`GameScene`中的`swapGemsToNewPosition`方法：
- en: 'The `swapGemsToNewPosition` method makes one call to `GridAnimations` to animate
    the swap between the selected and target gem. Once this animation is complete,
    we fire a `onNewSwapComplete` method. The majority of the logic takes place in
    there:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`swapGemsToNewPosition`方法调用一次`GridAnimations`来动画化选择宝石和目标宝石之间的交换。一旦这个动画完成，我们触发一个`onNewSwapComplete`方法。大部分逻辑都发生在这里：'
- en: '[PRE29]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we have a match, we run animations on the matched gems, otherwise we play
    a swap back animation and play a sound effect to represent a wrong move by the
    player:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们找到了匹配项，我们对匹配的宝石运行动画，如果没有匹配，我们播放一个交换回动画并播放一个音效来表示玩家走错了一步：
- en: '[PRE30]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'At the end of each new animation, be it the match one or the swap back one,
    we once again run callbacks listed at the top of the method. The most important
    thing these do is the call to `collapseGrid` done when the matched gems finish
    animating inside the `onMatchedAnimatedOut` callback:'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在每个新动画的末尾，无论是匹配动画还是交换回动画，我们再次运行方法顶部列出的回调。这些回调最重要的作用是在`onMatchedAnimatedOut`回调中匹配宝石动画完成后调用`collapseGrid`：
- en: '[PRE31]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We end the callback by clearing the selected gems and start with a clean slate.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们通过清除选择的宝石并从一张干净的局面开始来结束回调。
- en: 'And here, at the end of the function, we call the swap gems animation with
    `onNewSwapComplete` as its callback:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，函数的末尾，我们调用带有`onNewSwapComplete`作为回调的宝石交换动画：
- en: '[PRE32]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s move back to `GridController` and add the `checkGridMatches` method.
    This is broken into three parts:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到`GridController`并添加`checkGridMatches`方法。这分为三个部分：
- en: '[PRE33]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This method starts the check by running `checkTypeMatch` on each cell.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个方法通过在每个单元格上运行`checkTypeMatch`来开始检查。
- en: 'The `checkTypeMatch` method searches around the current index and looks for
    matches at the top, bottom, left, and right of the index:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`checkTypeMatch`方法在当前索引周围搜索，寻找索引的上方、下方、左侧和右侧的匹配项：'
- en: '[PRE34]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If any matches are found, they are added to the `matches` array.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果找到了任何匹配项，它们将被添加到`matches`数组中。
- en: 'But first we need to make sure there are no duplicates listed there, so when
    we add a gem to the `matches` array, we check whether it has not been added already:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但首先我们需要确保没有重复项列在那里，所以当我们向`matches`数组添加宝石时，我们检查它是否已经被添加：
- en: '[PRE35]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And the simple method to look for duplicates:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以及查找重复项的简单方法：
- en: '[PRE36]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*What just happened?*'
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Finding matches is more than half the necessary logic for any match-three game.
    All you need to do is traverse the grid as effectively as you can and look for
    repeated patterns.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找匹配项是任何三合一游戏所需逻辑的一半以上。你所需要做的就是尽可能有效地遍历网格，寻找重复的模式。
- en: The rest of the logic concerns the grid collapse. We'll do that next and then
    we're ready to publish the game.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的逻辑涉及网格坍塌。我们将在下一步进行，然后我们就可以发布游戏了。
- en: Time for action – collapsing the grid and repeating
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——坍塌网格并重复
- en: 'So the flow of the game is move pieces around, look for matches, remove those,
    collapse the grid and add new gems, look for matches again, and if necessary,
    do the whole process in a loop:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，游戏的流程是移动部件，寻找匹配项，移除它们，坍塌网格，添加新的宝石，再次寻找匹配项，如果需要，整个流程循环进行：
- en: 'This is the longest method in the game, and again, most of the logic happens
    inside callbacks. First we tag the gems being removed by setting their type data
    to `-1`. All the gems inside `matchArray` will be removed:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是游戏中最长的方法，而且，同样，大部分逻辑都发生在回调中。首先，我们通过将它们的类型数据设置为 `-1` 来标记要移除的宝石。`matchArray`
    中的所有宝石都将被移除：
- en: '[PRE37]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we traverse the grid''s columns and rearrange the gems whose type is
    not equal to `-1` inside the column arrays. Essentially, we update the data here
    so that gems above the ones removed "fall down". The actual change will take place
    in the `animateCollapse` method:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们遍历网格的列，重新排列列数组中类型不等于 `-1` 的宝石。本质上，我们在这里更新数据，以便移除的宝石上面的宝石“落下”。实际的变化将在 `animateCollapse`
    方法中发生：
- en: '[PRE38]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'But now, let''s code the callback of that animation called `onGridCollapseComplete`.
    So above the code we''ve entered already inside `collapseGrid`, we add the `local`
    function:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但现在，让我们编写动画回调 `onGridCollapseComplete` 的代码。所以我们在 `collapseGrid` 中已经输入的代码上方添加
    `local` 函数：
- en: '[PRE39]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: First, we update the array of sprites, sorting them by the new `x` and `y` indexes
    of the grid.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们更新精灵数组，按网格的新 `x` 和 `y` 索引排序。
- en: 'Then, we check for matches again. Remember that this callback runs after the
    grid collapse animation has finished, which means new gems have been added already
    and these may create new matches (we''ll look at the logic soon):'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们再次检查匹配项。记住，这个回调在网格坍塌动画完成后运行，这意味着已经添加了新的宝石，这些宝石可能创建了新的匹配项（我们很快将查看逻辑）：
- en: '[PRE40]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, if we find no more matches, we replace some random gems with diamonds
    if the value for combos is above 0 (meaning we had more than a 3 gem match in
    the last player''s move):'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果我们没有找到更多的匹配项，当组合的价值大于0（意味着在上一个玩家的移动中我们有多于3个宝石匹配）时，我们将一些随机的宝石替换为钻石：
- en: '[PRE41]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And we pick random gems for the diamonds:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随机选择宝石作为钻石：
- en: '[PRE42]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Animate the diamonds being collected, and at the end of that animation, call
    back `onMatchedAnimatedOut`, which will collapse the grid once more now that we
    had gems "burst" into diamonds:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 动画收集钻石，并在该动画结束时调用 `onMatchedAnimatedOut` 回调，此时由于宝石“爆裂”成钻石，网格将再次坍塌：
- en: '[PRE43]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here''s the whole `collapseGrid` method:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是整个 `collapseGrid` 方法：
- en: '[PRE44]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*What just happened?*'
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The `collapseGrid` method collects all the gems affected by matches or gems
    which exploded into diamonds. The resulting array is sent to `GridAnimations`
    for the proper animations to be performed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`collapseGrid` 方法收集所有受匹配或爆炸成钻石的宝石影响的宝石。结果数组被发送到 `GridAnimations` 以执行适当的动画。'
- en: We'll work on those next and finish our game.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这些基础上工作，完成我们的游戏。
- en: Time for action – animating matches and collapses
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——动画匹配和坍塌
- en: 'Now for the last bit of logic: the final animations:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是最后一点逻辑：最后的动画：
- en: 'We''ll start with the easy ones:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从简单的开始：
- en: '[PRE45]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This rotates a gem; we use this animation when a gem is first selected.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会使宝石旋转；我们使用这个动画来表示宝石首次被选中。
- en: 'Next is the swap animation:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是交换动画：
- en: '[PRE46]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: All this does is swap the places of the first selected gem and the target gem.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这只是交换第一个选择的宝石和目标宝石的位置。
- en: 'Then, we add the animations we run for matched gems:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加运行匹配宝石的动画：
- en: '[PRE47]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will scale down a gem to nothing, and only fire the final callback when
    all gems have finish scaling.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将使宝石缩放到无，并且只有当所有宝石完成缩放时才触发最终的回调。
- en: 'Next is the collect diamonds animation:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是收集钻石的动画：
- en: '[PRE48]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This moves the diamonds to where the diamond score label is.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将钻石移动到钻石得分标签的位置。
- en: 'And now, finally, add the grid collapse:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，最后，添加网格坍塌：
- en: '[PRE49]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We loop through all the gems and identify the ones that have been scaled down,
    meaning the ones which were *removed*. We move these above the column, so they
    will fall down as new gems, and we pick a new type for them:'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们遍历所有宝石，并识别出那些被缩小的宝石，这意味着它们已经被*移除*。我们将这些宝石移动到列的上方，这样它们就会作为新的宝石落下，并为它们选择一个新的类型：
- en: '[PRE50]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The ones which were not removed will drop to their new positions. The way we
    do this is simple. We count how many gems were removed until we reached a gem
    which has not been removed. That count is stored in the local variable drop, which
    is reset to `0` with every column.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 那些没有被移除的宝石将落到它们的新位置。我们这样做的方式很简单。我们计算有多少宝石被移除，直到我们到达一个没有被移除的宝石。这个计数存储在局部变量drop中，每次列重置时都会将其重置为`0`。
- en: That way, we know how many gems were removed below other gems. We use that to
    find the new `y` position.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样，我们就知道了有多少宝石被其他宝石下面的宝石移除。我们使用这个信息来找到新的`y`位置。
- en: 'The `dropGemTo` new position looks like this:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dropGemTo`新位置看起来是这样的：'
- en: '[PRE51]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Again, we only fire the final callback once all gems have collapsed. This final
    callback will run another check for matches, as we've seen earlier, starting the
    whole process again.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们只在所有宝石都坍塌后才会触发最终的回调。这个最终的回调将运行另一个检查匹配，就像我们之前看到的，然后再次启动整个过程。
- en: '*What just happened?*'
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'That''s it; we have the three main parts of a match-three game: the swap, the
    matches, and the collapse.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；我们已经拥有了三合一游戏的三个主要部分：交换、匹配和坍塌。
- en: There is only one animation we haven't covered, which is already included in
    the code for this chapter, and that is the column drop for the intro animation
    when the grid is first created. But there's nothing new with that one. Feel free
    to review it, though.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有介绍的一个动画，它已经包含在本章的代码中，那就是当网格首次创建时，用于介绍动画的列下降动画。但那个并没有什么新意。尽管如此，你可以随意查看它。
- en: Now, it's time to publish the game.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候发布游戏了。
- en: Time for action – publishing the game with the Cocos IDE
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候使用Cocos IDE发布游戏了。
- en: 'In order to build and publish the game, we''ll need to tell the IDE a few things.
    I''ll show you how to publish the game for Android, but the steps are very similar
    for any of the other targets:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建和发布游戏，我们需要告诉IDE一些信息。我会展示如何为Android发布游戏，但步骤对于其他目标也非常相似：
- en: First, let's tell the IDE where to find the Android SDK, NDK, and ANT, just
    as we did when we installed the Cocos2d-x console. In the IDE, open the **Preferences**
    panel. Then, under **Cocos**, enter the three paths just like we did before (remember
    that for ANT, you need to navigate to its `bin` folder).![Time for action – publishing
    the game with the Cocos IDE](img/00042.jpeg)
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们告诉IDE在哪里可以找到Android SDK、NDK和ANT，就像我们安装Cocos2d-x控制台时做的那样。在IDE中，打开**首选项**面板。然后，在**Cocos**下输入三个路径，就像我们之前做的那样（记住，对于ANT，你需要导航到它的`bin`文件夹）。![使用Cocos
    IDE发布游戏的操作时间](img/00042.jpeg)
- en: Now, in order to build the project, you need to select the fourth button at
    the top of the IDE (from the left-hand side), or right-click on your project and
    select **Cocos Tools**. You'll have different options available depending on which
    stage you are at in the deployment process.![Time for action – publishing the
    game with the Cocos IDE](img/00043.jpeg)
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了构建项目，你需要选择IDE顶部的第四个按钮（从左侧开始），或者右键点击你的项目并选择**Cocos Tools**。根据你在部署过程中的阶段，你将会有不同的选项可用。![使用Cocos
    IDE发布游戏的操作时间](img/00043.jpeg)
- en: First, the IDE needs to add the native code support, and then it builds the
    project inside a folder called frameworks (it will contain an iOS, Mac OS, Windows,
    Android, and Linux version of your project just as if you had created it through
    the Cocos console).
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，IDE需要添加原生代码支持，然后它会在名为frameworks的文件夹内构建项目（它将包含iOS、Mac OS、Windows、Android和Linux版本的你的项目，就像你通过Cocos控制台创建它一样）。
- en: You can then choose to package the application into an APK or IPA, which you
    can transfer to your phone. Or, you can use the generated project inside Eclipse
    or Xcode.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以选择将应用程序打包成APK或IPA，你可以将其传输到你的手机上。或者，你可以使用Eclipse或Xcode中的生成项目。
- en: '*What just happened?*'
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You just built your Lua game to Android, or iOS, or Windows, or Linux, or Mac
    OS, or all of them! Well done.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚将你的Lua游戏构建到了Android、iOS、Windows、Linux、Mac OS，或者所有这些平台！做得好。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: That's it. You can now choose between C++ or Lua to build your games. The whole
    API can be accessed either way. So, every game created in this book can be done
    in either language (and yes, that includes the Box2D API.)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。你现在可以选择 C++ 或 Lua 来构建你的游戏。整个 API 都可以通过这两种方式访问。所以，这本书中创建的每个游戏都可以用这两种语言（是的，包括
    Box2D API）来完成。
- en: And this is it for the book. I hope you're not too tired to start working on
    your own ideas. And I hope to see your game sometime soon in an App Store near
    me!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书就到这里了。希望你不是太累，可以开始着手自己的想法。并且我希望不久能在附近的 App Store 中看到你的游戏！
- en: Appendix A. Vector Calculations with Cocos2d-x
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A. 使用 Cocos2d-x 进行向量计算
- en: This appendix will cover some of the math concepts used in [Chapter 5](part0072_split_000.html#page
    "Chapter 5. On the Line – Rocket Through"), *On the Line – Rocket Through*, in
    a little more detail.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录将更详细地介绍 [第 5 章](part0072_split_000.html#page "第 5 章. 在线上 – 火箭穿越") 中使用的数学概念，“在线上
    – 火箭穿越”。
- en: What are vectors?
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是向量？
- en: First, let's do a quick refresh on vectors and the way you can use Cocos2d-x
    to deal with them.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们快速回顾一下向量以及你如何使用 Cocos2d-x 来处理它们。
- en: 'So what is the difference between a vector and a point? At first, they seem
    to be the same. Consider the following point and vector:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，向量与点的区别是什么？起初，它们看起来很相似。考虑以下点和向量：
- en: Point (2, 3.5)
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点 (2, 3.5)
- en: Vec2 (2, 3.5)
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vec2 (2, 3.5)
- en: 'The following figure illustrates a point and a vector:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了点和向量：
- en: '![What are vectors?](img/00044.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![什么是向量？](img/00044.jpeg)'
- en: In this figure, they each have the same value for *x* and *y*. So what's the
    difference?
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，它们每个的 *x* 和 *y* 值都相同。那么区别在哪里？
- en: With a vector, you always have extra information. It is as if, besides those
    two values for *x* and *y*, we also have the *x* and *y* of the vector's origin,
    which in the previous figure we can assume to be point (0, 0). So the vector is
    *moving* in the direction described from point (0, 0) to point (2, 3.5). The extra
    information we can derive then from vectors is direction and length (usually referred
    to as magnitude).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用向量，你总是有额外的信息。就好像，除了 *x* 和 *y* 这两个值之外，我们还有向量的原点 *x* 和 *y* 的值，在之前的图中我们可以假设它是点
    (0, 0)。所以向量是 *移动* 在从点 (0, 0) 到点 (2, 3.5) 描述的方向上。我们可以从向量中推导出的额外信息是方向和长度（通常称为大小）。
- en: It's as if a vector is a person's stride. We know how long each step is, and
    we know the direction in which the person is walking.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 就好像向量是一个人的步幅。我们知道每一步有多长，也知道这个人朝哪个方向走。
- en: In game development, vectors can be used, among other things, to describe movement
    (speed, direction, acceleration, friction, and so on) or the combining forces
    acting upon a body.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，向量可以用来描述运动（速度、方向、加速度、摩擦等）或作用于物体的合力。
- en: The vector methods
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量方法
- en: 'There is a lot you can do with vectors, and there are many ways to create them
    and manipulate them. And Cocos2d-x comes bundled with helper methods that will
    take care of most of the calculations for you. Here are some examples:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用向量做很多事情，有很多种方法来创建和操作它们。Cocos2d-x 还附带了一些辅助方法，可以帮助你完成大部分计算。以下是一些示例：
- en: You have a vector, and you want to get its angle—use `getAngle()`
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个向量，并且想要得到它的角度——使用 `getAngle()`
- en: You want the length of a vector—use `getLength()`
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要一个向量的长度——使用 `getLength()`
- en: You want to subtract two vectors; for example, to reduce the amount of movement
    of a sprite by another vector—use `vector1 - vector2`
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要减去两个向量；例如，为了通过另一个向量减少精灵的移动量——使用 `vector1 - vector2`
- en: You want to add two vectors; for example, to increase the amount of movement
    of a sprite by another vector—use `vector1 + vector2`
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要添加两个向量；例如，为了通过另一个向量增加精灵的移动量——使用 `vector1 + vector2`
- en: You want to multiply a vector; for example, applying a friction value to the
    amount of movement of a sprite—use `vector1 * vector2`
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要乘以一个向量；例如，将摩擦值应用到精灵的移动量上——使用 `vector1 * vector2`
- en: You want the vector that is perpendicular to another (also known as a vector's
    normal)—use `getPerp()` or `getRPerp()`
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要一个垂直于另一个向量（也称为向量的法线）的向量——使用 `getPerp()` 或 `getRPerp()`
- en: And, most importantly for our game example, you want the dot product of two
    vectors—use `dot(vector1, vector2)`
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的是，对于我们的游戏示例，你想要两个向量的点积——使用 `dot(vector1, vector2)`
- en: Now let me show you how to use these methods in our game example.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我给你展示如何在我们的游戏示例中使用这些方法。
- en: Using ccp helper methods
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ccp 辅助方法
- en: In the example of *Rocket Through*, the game we developed in [Chapter 5](part0072_split_000.html#page
    "Chapter 5. On the Line – Rocket Through"), *On the Line – Rocket Through*, we
    used vectors to describe movement, and now I want to show you the logic behind
    some of the methods we used to handle vector operations and what they mean.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Rocket Through*的例子中，我们在[第5章](part0072_split_000.html#page "Chapter 5. On the
    Line – Rocket Through")中开发的*On the Line – Rocket Through*游戏中使用了向量来描述运动，现在我想向你展示我们用来处理向量操作的一些方法的逻辑以及它们的含义。
- en: Rotating the rocket around a point
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 围绕一个点旋转火箭
- en: 'Let''s start, as an example, with the rocket sprite moving with a vector of
    (5, 0):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以火箭精灵以向量（5, 0）移动为例开始：
- en: '![Rotating the rocket around a point](img/00045.jpeg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![围绕一个点旋转火箭](img/00045.jpeg)'
- en: 'We then draw a line from the rocket, say from point **A** to point **B**:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从火箭画一条线，比如说从点**A**到点**B**：
- en: '![Rotating the rocket around a point](img/00046.jpeg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![围绕一个点旋转火箭](img/00046.jpeg)'
- en: Now we want the rocket to rotate around point **B**. So how can we change the
    rocket's vector to accomplish that? With Cocos2d-x, we can use the helper point
    method `rotateByAngle` to rotate a point around any other point. In this case,
    we rotate the rocket's position point around point **B** by a certain angle.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想让火箭围绕点**B**旋转。那么我们如何改变火箭的向量来实现这一点？使用Cocos2d-x，我们可以使用辅助点方法`rotateByAngle`来围绕任何其他点旋转一个点。在这种情况下，我们通过一定的角度将火箭的位置点围绕点**B**旋转。
- en: But here's a question – in which direction should the rocket rotate?
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有一个问题——火箭应该朝哪个方向旋转？
- en: '![Rotating the rocket around a point](img/00047.jpeg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![围绕一个点旋转火箭](img/00047.jpeg)'
- en: 'By looking at this figure, you know that the rocket should rotate clockwise,
    since it''s moving towards the right. But programmatically, how could we determine
    that, and in the easiest way possible? We can determine this by using vectors
    and another property derived from them: the dot product.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察这个图，你知道火箭应该顺时针旋转，因为它正在向右移动。但程序上，我们如何确定这一点，并且以最简单的方式确定？我们可以通过使用向量和从它们导出的另一个属性：点积来确定这一点。
- en: Using the dot product of vectors
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用向量的点积
- en: 'The dot product of two vectors describes their angular relationship. If their
    dot product is greater than zero, the two vectors form an angle smaller than 90
    degrees. If it is less than zero, the angle is greater than 90 degrees. And if
    it is equal to zero, the vectors are perpendicular. Have a look at this descriptive
    figure:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 两个向量的点积描述了它们的角关系。如果它们的点积大于零，则两个向量形成的角度小于90度。如果它小于零，则角度大于90度。如果它等于零，则向量是垂直的。看看这个描述性的图：
- en: '![Using the dot product of vectors](img/00048.jpeg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![使用向量的点积](img/00048.jpeg)'
- en: But one other way to think about this is that if the dot product is a positive
    value, then the vectors will "point" in the same direction. If it is a negative
    value, they point in opposite directions. How can we use that to help us?
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 但另一种思考方式是，如果点积是一个正值，那么向量将“指向”同一方向。如果它是负值，它们指向相反的方向。我们如何利用这一点来帮助我们？
- en: 'A vector will always have two perpendiculars, as shown in the following figure:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 向量始终有两个垂线，如图所示：
- en: '![Using the dot product of vectors](img/00049.jpeg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![使用向量的点积](img/00049.jpeg)'
- en: These perpendiculars are often called right and left, or clockwise and counterclockwise
    perpendiculars, and they are themselves vectors, known as normals.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这些垂线通常被称为左右或顺时针和逆时针垂线，并且它们自身也是向量，被称为法线。
- en: Now, if we calculate the dot product between the rocket's vector and each of
    the perpendiculars on line **AB**, you can see that we can determine the direction
    the rocket should rotate in. If the dot product of the rocket and the vector's
    right perpendicular is a positive value, it means the rocket is moving towards
    the right (clockwise). If not, it means the rocket is moving towards the left
    (counterclockwise).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们计算火箭的向量与线**AB**上的每个垂线之间的点积，你可以看到我们可以确定火箭应该旋转的方向。如果火箭和向量的右垂线的点积是一个正值，这意味着火箭正在向右移动（顺时针）。如果不是，这意味着火箭正在向左移动（逆时针）。
- en: '![Using the dot product of vectors](img/00050.jpeg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![使用向量的点积](img/00050.jpeg)'
- en: The dot product is very easy to calculate. We don't even need to bother with
    the formula (though it's a simple one), because we can use the `d` `ot(vector1,
    vector2)` method.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 点积非常容易计算。我们甚至不需要担心公式（尽管它很简单），因为我们可以使用`d` `ot(vector1, vector2)`方法。
- en: So we have the vector for the rocket already. How do we get the vector for the
    normals? First, we get the vector for the **AB** line. We use another method for
    this – `point1 - point2`. This will subtract points **A** and **B** and return
    a vector representing that line.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经有火箭的向量了。我们如何得到法线的向量？首先，我们得到**AB**线的向量。我们为此使用另一个方法——`point1 - point2`。这将减去点**A**和**B**，并返回表示该线的向量。
- en: Next, we can get the left and right perpendiculars of that line vector with
    the `getPerp()` and `getRPerp()` methods respectively. However, we only need to
    check one of these. Then we get the dot product with `dot(rocketVector, lineNormal)`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`getPerp()`和`getRPerp()`方法分别得到那个线向量的左右垂直线。然而，我们只需要检查其中一个。然后我们用`dot(rocketVector,
    lineNormal)`得到点积。
- en: If this is the correct normal, meaning the value for the dot product is a positive
    one, we can rotate the rocket to point to this normal's direction; so the rocket
    will be at a 90-degree angle with the line at all times as it rotates. This is
    easy, because we can convert the normal vector to an angle with the `getAngle()`
    method. All we need to do is apply that angle to the rocket.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是正确的法线，意味着点积的值是正的，我们可以将火箭旋转到指向这个法线方向；因此，当火箭旋转时，它将始终与线保持90度角。这很容易，因为我们可以用`getAngle()`方法将法线向量转换为角度。我们只需要将这个角度应用到火箭上。
- en: But how fast should the rocket rotate? We'll see how to calculate that next.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 但火箭应该旋转多快？我们将在下一部分看到如何计算这一点。
- en: Moving from pixel-based speed to angular-based speed
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从基于像素的速度转换为基于角度的速度
- en: When rotating the rocket, we still want to show it moving at the same speed
    as it was when moving in a straight line, or as close to it as possible. How do
    we do that?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当旋转火箭时，我们仍然希望显示它以与直线移动时相同的速度移动，或者尽可能接近。我们如何做到这一点？
- en: '![Moving from pixel-based speed to angular-based speed](img/00051.jpeg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![从基于像素的速度转换为基于角度的速度](img/00051.jpeg)'
- en: Remember that the vector is being used to update the rocket's position in every
    iteration. In the example I gave you, the (5, 0) vector is currently adding 5
    pixels to the x position of the rocket in every iteration.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，向量正在被用来在每次迭代中更新火箭的位置。在我给出的例子中，(5, 0)向量目前在每次迭代中向火箭的x位置添加5像素。
- en: Now let's consider an angular speed. If the angular speed were 15 degrees, and
    we kept rotating the rocket's position by that angle, it would mean the rocket
    would complete a full circle in 24 iterations. Because 360 degrees of a full circle
    divided by 15 degrees equals 24.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑角速度。如果角速度是15度，并且我们保持以那个角度旋转火箭的位置，这意味着火箭将在24次迭代内完成一个完整的圆。因为一个完整圆的360度除以15度等于24。
- en: But we don't have the correct angle yet; we only have the amount in pixels the
    rocket moves in every iteration. But math can tell us a lot here.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还没有正确的角度；我们只有火箭在每次迭代中移动的像素量。但数学可以在这里告诉我们很多。
- en: Math says that the length of a circle is *twice the value of Pi, multiplied
    by the radius of the circle*, usually written as *2πr*.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 数学告诉我们，圆的长度是**圆的半径乘以π的两倍**，通常写作**2πr**。
- en: We know the radius of the circle we want the rocket to describe. It is the length
    of the line we drew.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们想要火箭描述的圆的半径。它是我们画的线的长度。
- en: '![Moving from pixel-based speed to angular-based speed](img/00052.jpeg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![从基于像素的速度转换为基于角度的速度](img/00052.jpeg)'
- en: With that formula, we can get the length in pixels of that circle, also known
    as its circumference. Let's say the line has a length of 100 pixels; this would
    mean the circle about to be described by the rocket has a length (or circumference)
    of 628.3 pixels (2 * π * 100).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用那个公式，我们可以得到那个圆的像素长度，也称为其周长。假设线的长度为100像素；这意味着火箭即将描述的圆的长度（或周长）为628.3像素（2 * π
    * 100）。
- en: With the speed described in the vector (5, 0), we can determine how long it
    would take the rocket to complete that pixel length. We don't need this to be
    absolutely precise; the last iteration will most likely move beyond that total
    length, but it's good enough for our purposes.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用向量中描述的速度（5, 0），我们可以确定火箭完成那个像素长度需要多长时间。我们不需要这绝对精确；最后一次迭代最有可能超过那个总长度，但对于我们的目的来说已经足够好了。
- en: '![Moving from pixel-based speed to angular-based speed](img/00053.jpeg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![从基于像素的速度转换为基于角度的速度](img/00053.jpeg)'
- en: When we have the total number of iterations to complete the length, we can convert
    that to an angle. So, if the iteration value is 125, the angle would be 360 degrees
    divided by 125; that is, 2.88\. That would be the angle required to describe a
    circle in 125 iterations.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有了完成长度所需的总迭代次数，我们可以将其转换为角度。所以，如果迭代值是125，角度将是360度除以125；即，2.88度。这将是在125次迭代中描述圆所需的角。
- en: '![Moving from pixel-based speed to angular-based speed](img/00054.jpeg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![从基于像素的速度转换为基于角度的速度](img/00054.jpeg)'
- en: Now the rocket can change from pixel-based movement to angular-based movement
    without much visual change.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，火箭可以从基于像素的运动转换为基于角度的运动，而视觉变化不大。
- en: Appendix B. Pop Quiz Answers
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录B. 突击测验答案
- en: Chapter 4, Fun with Sprites – Sky Defense
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章，与精灵的乐趣 – 天空防御
- en: Pop quiz – sprites and actions
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验 – 精灵和动作
- en: '| Q1 | 2 |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| Q1 | 2 |'
- en: '| Q2 | 1 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| Q2 | 1 |'
- en: '| Q3 | 3 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| Q3 | 3 |'
- en: '| Q4 | 4 |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| Q4 | 4 |'
- en: Chapter 8, Getting Physical – Box2D
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章，物理化 – Box2D
- en: Pop quiz
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验
- en: '| Q1 | 3 |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| Q1 | 3 |'
- en: '| Q2 | 2 |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| Q2 | 2 |'
- en: '| Q3 | 1 |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| Q3 | 1 |'
- en: '| Q4 | 3 |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| Q4 | 3 |'
