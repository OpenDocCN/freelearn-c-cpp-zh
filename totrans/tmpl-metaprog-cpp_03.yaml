- en: '*Chapter 2*: Template Fundamentals'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we saw a short introduction to templates. What they
    are, how they are helpful, pros and cons for using templates, and, also, a few
    examples of function and class templates. In this chapter, we will explore this
    area in detail, and look at aspects such as template parameters, instantiation,
    specializations, aliases, and more. The main topics that you will learn about
    from this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: How to define function templates, class templates, variable templates, and alias
    templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What kinds of template parameters exist?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is template instantiation?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is template specialization?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use generic lambdas and lambda templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be familiar with the core fundamentals
    of templates in C++ and be able to understand large areas of template code and
    also write templates by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: To start this chapter, we will explore the details of defining and using function
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: Defining function templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Function templates are defined in a similar way to regular functions, except
    that the function declaration is preceded by the keyword `template` followed by
    a list of template parameters between angle brackets. The following is a simple
    example of a function template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This function has two parameters, called `a` and `b`, both of the same `T` type.
    This type is listed in the template parameters list, introduced with the keyword
    `typename` or `class` (the former is used in this example and throughout the book).
    This function does nothing more than add the two arguments and returns the result
    of this operation, which should have the same `T` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Function templates are only blueprints for creating actual functions and only
    exist in source code. Unless explicitly called in your source code, the function
    templates will not be present in the compiled executable. However, when the compiler
    encounters a call to a function template and is able to match the supplied arguments
    and their types to a function template''s parameters, it generates an actual function
    from the template and the arguments used to invoke it. To understand this, let''s
    look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, we call the `add` function with two `int` parameters, `42`
    and `21`. The compiler is able to deduce the template parameter `T` from the type
    of the supplied arguments, making it unnecessary to explicitly provide it. However,
    the following two invocations are also possible, and, in fact, identical to the
    earlier one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'From this invocation, the compiler will generate the following function (keep
    in mind that the actual code may differ for various compilers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we change the call to the following form, we explicitly provide
    the argument for the template parameter `T`, as the `short` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the compiler will generate another instantiation of this function,
    with `short` instead of `int`. This new instantiation would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If the type of the two parameters is ambiguous, the compiler will not be able
    to deduce them automatically. This is the case with the following invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `41.0` is a `double` but `21` is an `int`. The `add` function
    template has two parameters of the same type, so the compiler is not able to match
    it with the supplied arguments and will issue an error. To avoid this, and suppose
    you expected it to be instantiated for `double`, you have to specify the type
    explicitly, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as the two arguments have the same type and the `+` operator is available
    for the type of the arguments, you can call the function template `add` in the
    ways shown previously. However, if the `+` operator is not available, then the
    compiler will not be able to generate an instantiation, even if the template parameters
    are correctly resolved. This is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the compiler will issue an error that a binary `+` operator is
    not found for arguments of type `foo`. Of course, the actual message differs for
    different compilers, which is the case for all errors. To make it possible to
    call `add` for arguments of type `foo`, you''d have to overload the `+` operator
    for this type. A possible implementation is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'All the examples that we have seen so far represented templates with a single
    template parameter. However, a template can have any number of parameters and
    even a variable number of parameters. This latter topic will be addressed in [*Chapter
    3*](B18367_03_ePub.xhtml#_idTextAnchor051), *Variadic Templates*. The next function
    is a function template that has two type template parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This function takes two input iterators to the start and end of a range and
    a predicate and returns the number of elements in the range that match the predicate.
    This function, at least conceptually, is very similar to the `std::count_if` general-purpose
    function from the `<algorithm>` header in the standard library and you should
    always prefer to use standard algorithms over hand-crafted implementations. However,
    for the purpose of this topic, this function is a good example to help you understand
    how templates work.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `count_if` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Again, there is no need to explicitly specify the arguments for the type template
    parameters (the type of the input iterator and the type of the unary predicate)
    because the compiler is able to infer them from the call.
  prefs: []
  type: TYPE_NORMAL
- en: Although there are more things to learn about function templates, this section
    provided an introduction to working with them. Let's now learn the basics of defining
    class templates.
  prefs: []
  type: TYPE_NORMAL
- en: Defining class templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Class templates are declared in a very similar manner, with the `template`
    keyword and the template parameter list preceding the class declaration. We saw
    the first example in the introductory chapter. The next snippet shows a class
    template called `wrapper`. It has a single template parameter, a type called `T`,
    that is used as the type for data members, parameters, and function return types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as the class template is not used anywhere in your source code, the
    compiler will not generate code from it. For that to happen, the class template
    must be instantiated and all its parameters properly matched to arguments either
    explicitly, by the user, or implicitly, by the compiler. Examples for instantiating
    this class template are shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The definitions of `a` and `e` in this snippet are only valid in C++17 and onward
    thanks to a feature called `wrapper<int>` or `wrapper<char const*>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Class templates can be declared without being defined and used in contexts
    where incomplete types are allowed, such as the declaration of a function, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'However, a class template must be defined at the point where the template instantiation
    occurs; otherwise, the compiler will generate an error. This is exemplified with
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: When declaring the `use_wrapper` function, the class template wrapper is only
    declared, but not defined. However, incomplete types are allowed in this context,
    which makes it all right to use `wrapper<T>` at this point. However, in the `main`
    function we are instantiating an object of the `wrapper` class template. This
    will generate a compiler error because at this point the definition of the class
    template must be available. To fix this particular example, we'd have to move
    the definition of the `main` function to the end, after the definition of `wrapper`
    and `use_wrapper`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the class template was defined using the `class` keyword.
    However, in C++ there is little difference between declaring classes with the
    `class` or `struct` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: With `struct`, the default member access is public, whereas using `class` is
    private.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `struct`, the default access specifier for base-class inheritance is public,
    whereas using `class` is private.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can define class templates using the `struct` keyword the same way we did
    here using the `class` keyword. The differences between classes defined with the
    `struct` or the `class` keyword are also observed for class templates defined
    with the `struct` or `class` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Classes, whether they are templates or not, may contain member function templates
    too. The way these are defined is discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Defining member function templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have learned about function templates and class templates. It is
    possible to define member function templates too, both in non-template classes
    and class templates. In this section, we will learn how to do this. To understand
    the differences, let''s start with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The `composition` class is a class template. It has a single member function
    called `add` that uses the type parameter `T`. This class can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: We first need to instantiate an object of the `composition` class. Notice that
    we must explicitly specify the argument for the type parameter `T` because the
    compiler is not able to figure it out by itself (there is no context from which
    to infer it). When we invoke the `add` function, we just provide the arguments.
    Their type, represented by the `T` type template parameter that was previously
    resolved to `int`, is already known. A call such as `c.add<int>(42, 21)` would
    trigger a compiler error. The `add` function is not a function template, but a
    regular function that is a member of the `composition` class template.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, the `composition` class changes slightly, but significantly.
    Let''s see the definition first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, `composition` is a non-template class. However, the `add` function
    is a function template. Therefore, to call this function, we must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The explicit specification of the `int` type for the `T` type template parameter
    is redundant since the compiler can deduce it by itself from the arguments of
    the call. However, it was shown here to better comprehend the differences between
    these two implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from these two cases, member functions of class templates and member
    function templates of classes, we can also have member function templates of class
    templates. In this case, however, the template parameters of the member function
    template must differ from the template parameters of the class template; otherwise,
    the compiler will generate an error. Let''s return to the `wrapper` class template
    example and modify it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see here, this implementation features one more member, a function
    called `as`. This is a function template and has a type template parameter called
    `U`. This function is used to cast the wrapped value from a type `T` to a type
    `U`, and return it to the caller. We can use this implementation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Arguments for the template parameters were specified when instantiating the
    `wrapper` class (`double`) â€“ although in C++17 this is redundant, and when invoking
    the `as` function (`int`) to perform the cast.
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue with other topics such as instantiation, specialization,
    and other forms of templates, including variables and aliases, it's important
    that we take the time to learn more about template parameters. This will make
    the subject of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding template parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in the book, we have seen multiple examples of templates with one or
    more parameters. In all these examples, the parameters represented types supplied
    at instantiation, either explicitly by the user, or implicitly by the compiler
    when it could deduce them. These kinds of parameters are called **type template
    parameters**. However, templates can also have **non-type template parameters**
    and **template template parameters**. In the following sections, we'll explore
    all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Type template parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As already mentioned, these are parameters representing types supplied as arguments
    during the template instantiation. They are introduced either with the `typename`
    or the `class` keyword. There is no difference between using these two keywords.
    A type template parameter can have a default value, which is a type. This is specified
    the same way you would specify a default value for a function parameter. Examples
    for these are shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The name of the type template parameter can be omitted, which can be useful
    in forwarding declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'C++11 has introduced variadic templates, which are templates with a variable
    number of arguments. A template parameter that accepts zero or more arguments
    is called a **parameter pack**. A **type template parameter pack** has the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Variadic templates will be addressed in [*Chapter 3*](B18367_03_ePub.xhtml#_idTextAnchor051),
    *Variadic Templates*. Therefore, we will not get into details about these kinds
    of parameters at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++20 has introduced `typename` or the `class` keyword. Examples, including
    concepts with a default value and constrained type template parameter pack, are
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Concepts and constraints are discussed in [*Chapter 6*](B18367_06_ePub.xhtml#_idTextAnchor099),
    *Concepts and Constraints*. We will learn more about these kinds of parameters
    in that chapter. For now, let's look at the second kind of template parameters,
    non-type template parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Non-type template parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Template arguments don''t always have to represent types. They can also be
    compile-time expressions, such as constants, addresses of functions or objects
    with external linkage, or addresses of static class members. Parameters supplied
    with compile-time expressions are called **non-type template parameters**. This
    category of parameters can only have a **structural type**. The following are
    the structural types:'
  prefs: []
  type: TYPE_NORMAL
- en: Integral types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floating-point types, as of C++20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointer types (either to objects or functions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointer to member types (either to member objects or member functions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lvalue reference types (either to objects or functions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A literal class type that meets the following requirements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All base classes are public and non-mutable.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All non-static data members are public and non-mutable.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The types of all base classes and non-static data members are also structural
    types or arrays thereof.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'cv-qualified forms of these types can also be used for non-type template parameters.
    Non-type template parameters can be specified in different ways. The possible
    forms are shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: In all these examples, the type of the non-type template parameters is `int`.
    The first and second examples are similar, except that in the second example a
    default value is used. The third example is significantly different because the
    parameter is actually a parameter pack. This will be discussed in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand non-type template parameters better, let''s look at the following
    example, where we sketch a fixed-size array class, called `buffer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'This `buffer` class holds an internal array of `S` elements of type `T`. Therefore,
    `S` needs to be a compile-type value. This class can be instantiated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'These two definitions are equivalent, and both `b1` and `b2` are two buffers
    holding 10 integers. Moreover, they are of the same type, since 2*5 and 10 are
    two expressions evaluated to the same compile-time value. You can easily check
    this with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not the case anymore, for the type of the `b3` object is declared as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `b3` is a `buffer` holding 15 integers, which is different
    from the `buffer` type from the previous example that held 10 integers. Conceptually,
    the compiler generates the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the code for the primary template but there are also a couple of specializations
    shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'The concept of specialization, seen in this code sample, is detailed further
    on in this chapter, in the *Understanding template specialization* section. For
    the time being, you should notice the two different `buffer` types. Again, it''s
    possible to verify that the types of `b1` and `b3` are different with the following
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of structural types such as integer, floating-point, or enumeration
    types is encountered in practice more often than the rest. It''s probably easier
    to understand their use and find useful examples for them. However, there are
    scenarios where pointers or references are used. In the following example, we
    will examine the use of a pointer to function parameter. Let''s see the code first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, `device` is a base class with a pure virtual function called
    `output` (and a virtual destructor). This is the base class for a class template
    called `smart_device` that implements the `output` virtual function by calling
    a function through a function pointer. This function pointer is passed an argument
    for the non-type template parameter of the class template. The following sample
    shows how it can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `w1` and `w2` are two `unique_ptr` objects. Although, apparently, they
    point to objects of the same type, that is not true, because `smart_device<&say_hello_in_english>`
    and `smart_device<&say_hello_in_spanish>` are different types since they are instantiated
    with different values for the function pointer. This can be easily checked with
    the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: 'If we, on the other hand, change the `auto` specifier with `std::unique_ptr<device>`,
    as shown in the following snippet, then `w1` and `w2` are smart pointers to the
    base class device, and therefore have the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this example uses a pointer to function, a similar example can be
    conceived for pointer to member functions. The previous example can be transformed
    to the following (still using the same base class device):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'These classes can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++17, a new form of specifying non-type template parameters was introduced,
    using the `auto` specifier (including the `auto*` and `auto&` forms) or `decltype(auto)`
    instead of the name of the type. This allows the compiler to deduce the type of
    the parameter from the expression supplied as the argument. If the deduced type
    is not permitted for a non-type template parameter the compiler will generate
    an error. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: 'This class template can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, for `f1`, the compiler deduces the type of the argument
    as `int`. In the second example, for `f2`, the compiler deduces the type as `double`.
    However, this is only the case for C++20\. In previous versions of the standard,
    this line would yield an error, since floating-point types were not permitted
    as arguments for non-type template parameters prior to C++20\. The last line,
    however, produces an error because `"42"` is a string literal and string literals
    cannot be used as arguments for non-type template parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last example can be, however, worked around in C++20 by wrapping the literal
    string in a structural literal class. This class would store the characters of
    the string literal in a fixed-length array. This is exemplified in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the `foo` class template shown previously needs to be modified to
    use `string_literal` explicitly and not the `auto` specifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: With this is in place, the `foo<"42"> f;` declaration shown earlier will compile
    without any errors in C++20.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `auto` specifier can also be used with a non-type template parameter pack.
    In this case, the type is deduced independently for each template argument. The
    types of the template arguments do not need to be the same. This is shown in the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the compiler deduces the types of the template arguments as
    `int`, `double`, `bool`, and `char`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The third and last category of template parameters are **template template parameters**.
    We will look at them next.
  prefs: []
  type: TYPE_NORMAL
- en: Template template parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the name may sound a bit strange, it refers to a category of template
    parameters that are themselves templates. These can be specified similarly to
    type template parameters, with or without a name, with or without a default value,
    and as a parameter pack with or without a name. As of C++17, both the keywords
    `class` and `typename` can be used to introduce a template template parameter.
    Prior to this version, only the `class` keyword could be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'To showcase the use of template template parameters, let''s consider the following
    two class templates first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: 'The `simple_wrapper` class is a very simple class template that holds a value
    of the type template parameter `T`. On the other hand, `fancy_wrapper` is a more
    complex wrapper implementation that hides the wrapped value and exposes member
    functions for data access. Next, we implement a class template called `wrapping_pair`
    that contains two values of a wrapping type. This can be either `simpler_wrapper`,
    `fancy_wrapper`, or anything else that is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: 'The `wrapping_pair` class template has three parameters. The first two are
    type template parameters, named `T` and `U`. The third parameter is a template
    template parameter, called `W`, that has a default value, which is the `fancy_wrapper`
    type. We can use this class template as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `p1` is a `wrapping_pair` object that contains two values,
    an `int` and a `double`, each wrapped in a `fancy_wrapper` object. This is not
    explicitly specified but is the default value of the template template parameter.
    On the other hand, `p2` is also a `wrapping_pair` object, also containing an `int`
    and a `double`, but these are wrapped by a `simple_wrapper` object, which is now
    specified explicitly in the template instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have seen the use of a default template argument for a template
    parameter. This topic is explored in detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Default template arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Default template arguments are specified similarly to default function arguments,
    in the parameter list after the equal sign. The following rules apply to default
    template arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: They can be used with any kind of template parameters with the exception of
    parameter packs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a default value is specified for a template parameter of a class template,
    variable template, or type alias, then all subsequent template parameters must
    also have a default value. The exception is the last parameter if it is a template
    parameter pack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a default value is specified for a template parameter in a function template,
    then subsequent template parameters are not restricted to also have a default
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a function template, a parameter pack may be followed by more type parameters
    only if they have default arguments or their value can be deduced by the compiler
    from the function arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are not allowed in declarations of friend class templates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are allowed in the declaration of a friend function template only if the
    declaration is also a definition and there is no other declaration of the function
    in the same translation unit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are not allowed in the declaration or definition of an explicit specialization
    of a function template or member function template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following snippet shows examples for using default template arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned previously, a template parameter with a default argument cannot
    be followed by parameters without a default argument when declaring a class template
    but this restriction does not apply to function templates. This is shown in the
    next snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: 'A template may have multiple declarations (but only one definition). The default
    template arguments from all the declarations and the definition are merged (the
    same way they are merged for default function arguments). Let''s look at an example
    to understand how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: 'This is semantically equivalent to the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: 'However, these multiple declarations with different default template arguments
    cannot be provided in any order. The rules mentioned earlier still apply. Therefore,
    a declaration of a class template where the first parameter has a default argument
    and the ensuing parameters do not have one is illegal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: 'Another restriction on default template arguments is that the same template
    parameter cannot be given multiple defaults in the same scope. Therefore, the
    next example will produce an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: 'When a default template argument uses names from a class, the member access
    restrictions are checked at the declaration, not at the instantiation of the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: When the `x` variable is defined, the bar class template is instantiated, but
    the `foo::value_type` typedef is protected and therefore cannot be used outside
    of `foo`. The result is a compiler error at the declaration of the `bar` class
    template.
  prefs: []
  type: TYPE_NORMAL
- en: With these mentions, we wrap up the topic of template parameters. The next one
    we will explore in the following section is template instantiation, which is the
    creation of a new definition of a function, class, or variable from a template
    definition and a set of template arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding template instantiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, templates are only blueprints from which the compiler creates
    actual code when it encounters their use. The act of creating a definition for
    a function, a class, or a variable from the template declaration is called **template
    instantiation**. This can be either **explicit**, when you tell the compiler when
    it should generate a definition, or **implicit**, when the compiler generates
    a new definition as needed. We will look at these two forms in detail in the next
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit instantiation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implicit instantiation occurs when the compiler generates definitions based
    on the use of templates and when no explicit instantiation is present. Implicitly
    instantiated templates are defined in the same namespace as the template. However,
    the way compilers create definitions from templates may differ. This is something
    we will see in the following example. Let''s consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a class template called `foo` with a member function `f`. In
    `main`, we define a variable of the type `foo<int>` but do not use any of its
    members. Because it encounters this use of `foo`, the compiler implicitly defines
    a specialization of `foo` for the `int` type. If you use [cppinsights.io](http://cppinsights.io),
    which runs in Clang, you will see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the function `f` is not invoked in our code, it is only declared but
    not defined. Should we add a call `f` in `main`, the specialization would change
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we add one more function, `g`, with the following implementation
    that contains an error, we will get different behaviors with different compilers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: The body of `g` contains an error (you could also use a `static_assert(false)`
    statement as an alternative). This code compiles without any problem with VC++,
    but fails with Clang and GCC. This is because VC++ ignores the parts of the template
    that are not used, provided that the code is syntactically correct, but the others
    perform semantic validation before proceeding with template instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For function templates, implicit instantiation occurs when the user code refers
    to a function in a context that requires its definition to exist. For class templates,
    implicit instantiation occurs when the user code refers to a template in a context
    when a complete type is required or when the completeness of the type affects
    the code. The typical example of such a context is when an object of such a type
    is constructed. However, this is not the case when declaring pointers to a class
    template. To understand how this works, let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, we use the same `foo` class template from the previous examples,
    and we declare several variables: `p` which is a pointer to `foo<int>`, `x` which
    is a `foo<int>`, and `q` which is a pointer to `foo<double>`. The compiler is
    required to instantiate only `foo<int>` at this point because of the declaration
    of `x`. Now, let''s consider some invocations of the member functions `f` and
    `g` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: 'With these changes, the compiler is required to instantiate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`foo<int>` when the `x` variable is declared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foo<int>::f()` when the `x.f()` call occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foo<double>` and `foo<double>::g()` when the `q->g()` call occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, the compiler is not required to instantiate `foo<int>` when
    the `p` pointer is declared nor `foo<double>` when the `q` pointer is declared.
    However, the compiler does need to implicitly instantiate a class template specialization
    when it is involved in pointer conversion. This is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: In the function `show`, a conversion between `button<int>*` and `control<int>*`
    takes place. Therefore, at this point, the compiler must instantiate `button<int>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a class template contains static members, those members are not implicitly
    instantiated when the compiler implicitly instantiates the class template but
    only when the compiler needs their definition. On the other hand, every specialization
    of a class template has its own copy of static members as exemplified in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: The class template `foo` has a static member variable called `data` that is
    initialized after the definition of `foo`. In the `main` function, we declare
    the variable `a` as an object of `foo<int>` and `b` and `c` as objects of `foo<double>`.
    Initially, all of them have the member field `data` initialized with 0\. However,
    the variables `b` and `c` share the same copy of data. Therefore, after the assignment
    `b.data = 42`, `a.data` is still 0, but both `b.data` and `c.data` are `42`.
  prefs: []
  type: TYPE_NORMAL
- en: Having learned how implicit instantiation works, it is time to move forward
    and understand the other form of template instantiation, which is explicit instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit instantiation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a user, you can explicitly tell the compiler to instantiate a class template
    or a function template. This is called explicit instantiation and it has two forms:
    **explicit instantiation definition** and **explicit instantiation declaration**.
    We will discuss them in this order.'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit instantiation definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An explicit instantiation definition may appear anywhere in a program but after
    the definition of the template it refers to. The syntax for explicit template
    instantiation definitions takes the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for class templates is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The syntax for function templates is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, in all cases, the explicit instantiation definition is introduced
    with the `template` keyword but not followed by any parameter list. For class
    templates, the `class-key` can be any of the `class`, `struct`, or `union` keywords.
    For both class and function templates, an explicit instantiation definition with
    a given argument list can only appear once in the entire program.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at some examples to understand how this works. Here is the first
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, `wrapper<T>` is a class template defined in the `ns` namespace.
    The statements marked with `[1]` and `[2]` in the code are both representing an
    explicit instantiation definition, for `wrapper<int>` and `wrapper<double>` respectively.
    An explicit instantiation definition can only appear in the same namespace as
    the template it refers to (as in `[1]`) to or it must be fully qualified (as in
    `[2]`). We can write similar explicit template definitions for a function template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: This second example has a striking resemblance to the first. Both `[1]` and
    `[2]` represent explicit template definitions for `add<int>()` and `add<double>()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the explicit instantiation definition is not in the same namespace as the
    template, the name must be fully qualified. The use of a `using` statement does
    not make the name visible in the current namespace. This is shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: The last line in this example generates a compile error because `wrapper` is
    an unknown name and must be qualified with the namespace name, as in `ns::wrapper`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When class members are used for return types or parameter types, member access
    specification is ignored in explicit instantiation definitions. An example is
    shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: Both the class `X<T>::bar` and the function `foo<T>::f()` are private to the
    `foo<T>` class, but they can be used in the explicit instantiation definition
    shown on the last line.
  prefs: []
  type: TYPE_NORMAL
- en: Having seen what explicit instantiation definition is and how it works, the
    question that arises is when is it useful. Why would you tell the compiler to
    generate instantiation from a template? The answer is that it helps distribute
    libraries, reduce build times, and executable sizes. If you are building a library
    that you want to distribute as a `.lib` file and that library uses templates,
    the template definitions that are not instantiated are not put into the library.
    But that leads to increased build times of your user code every time you use the
    library. By forcing instantiations of templates in the library, those definitions
    are put into the object files and the `.lib` file you are distributing. As a result,
    your user code only needs to be linked to those available functions in the library
    file. This is what the Microsoft MSVC CRT libraries do for all the stream, locale,
    and string classes. The `libstdc++` library does the same for string classes and
    others.
  prefs: []
  type: TYPE_NORMAL
- en: A problem that can arise with template instantiations is that you can end up
    with multiple definitions, one per translation unit. If the same header that contains
    a template is included in multiple translation units (`.cpp` files) and the same
    template instantiation is used (let's say `wrapper<int>` from our previous examples),
    then identical copies of these instantiations are put in each translation unit.
    This leads to increased object sizes. The problem can be solved with the help
    of explicit instantiation declarations, which we will look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit instantiation declaration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An explicit instantiation declaration (available with C++11) is the way you
    can tell the compiler that the definition of a template instantiation is found
    in a different translation unit and that a new definition should not be generated.
    The syntax is the same as for explicit instantiation definitions except that the
    keyword `extern` is used in front of the declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for class templates is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The syntax for function templates is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you provide an explicit instantiation declaration but no instantiation definition
    exists in any translation unit of the program, then the result is a compiler warning
    and a linker error. The technique is to declare an explicit template instantiation
    in one source file and explicit template declarations in the remaining ones. This
    will reduce both compilation times and object file sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `wrapper.h` header contains a class template called `wrapper<T>`. On the
    line marked with `[1]` there is an explicit instantiation declaration for `wrapper<int>`
    that tells the compiler not to generate definitions for this instantiation when
    a source file (translation unit) including this header is compiled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `source1.cpp` file includes `wrapper.h` and on the line marked with `[2]`
    contains an explicit instantiation definition for `wrapper<int>`. This is the
    only definition for this instantiation within the entire program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source files `source2.cpp` and `main.cpp` are both using `wrapper<int>`
    but without any explicit instantiation definition or declaration. That is because
    the explicit declaration from `wrapper.h` is visible when the header is included
    in each of these files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, the explicit instantiation declaration could be taken away from
    the header file but then it must be added to each source file that includes the
    header and that is likely to be forgotten.
  prefs: []
  type: TYPE_NORMAL
- en: When you do explicit template declarations, keep in mind that a class member
    function that is defined within the body of the class is always considered inline
    and therefore it will always be instantiated. Therefore, you can only use the
    `extern` keyword for member functions that are defined outside of the class body.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked at what template instantiation is, we will continue
    with another important topic, **template specialization**, which is the term used
    for the definition created from a template instantiation to handle a specific
    set of template arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding template specialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **template specialization** is the definition created from a template instantiation.
    The template that is being specialized is called the **primary template**. You
    can provide an explicit specialized definition for a given set of template arguments,
    therefore overwriting the implicit code the compiler would generate instead. This
    is the technique that powers features such as type traits and conditional compilation,
    which are metaprogramming concepts we will explore in [*Chapter 5*](B18367_05_ePub.xhtml#_idTextAnchor080),
    *Type Traits and Conditional Compilation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two forms of template specialization: **explicit (full) specialization**
    and **partial specialization**. We will look in detail at these two in the following
    sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit specialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Explicit specialization (also called full specialization) occurs when you provide
    a definition for a template instantiation with the full set of template arguments.
    The following can be fully specialized:'
  prefs: []
  type: TYPE_NORMAL
- en: Function templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable templates (as of C++14)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Member functions, classes, and enumerations of a class template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Member function templates and class templates of a class or class template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static data members of a class template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, `is_floating_point` is the primary template. It contains
    a `constexpr` static Boolean data member called `value` that is initialized with
    the `false` value. Then, we have three full specializations of this primary template,
    for the `float`, `double`, and `long double` types. These new definitions change
    the way `value` is being initialized using `true` instead of `false`. As a result,
    we can use this template to write code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: The first and last lines print `0` (for `false`); the other lines print `1`
    (for `true`). This example is a demonstration of how `type` traits work. In fact,
    the standard library contains a class template called `is_floating_point` in the
    `std` namespace, defined in the `<type_traits>` header. We will learn more about
    this topic in [*Chapter 5*](B18367_05_ePub.xhtml#_idTextAnchor080), *Type Traits
    and Conditional Compilation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in this example, static class members can be fully specialized.
    However, each specialization has its own copy of any static members, which is
    demonstrated with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: Here, `foo<T>` is a class template with a single static member, called `value`.
    This is initialized with `0` for the primary template and with `42` for the `int`
    specialization. After declaring the variables `a`, `b`, and `c`, `a.value` is
    `0` and `b.value` is `0` while `c.value` is `42`. However, after assigning the
    value `100` to `a.value`, `b.value` is also `100`, while `c.value` remains `42`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicit specialization must appear after the primary template declaration.
    It does not require a definition of the primary template to be available prior
    to the explicit specialization. The following code is therefore valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: 'Template specializations can also be only declared without being defined. Such
    a template specialization can be used like any other incomplete type. You can
    see an example of this here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `foo<T>` is the primary template for which a declaration of
    an explicit specialization for the `int` type exists. This makes it possible to
    use `foo<double>` and `foo<int>*` (declaring pointers to partial types is supported).
    However, at the point of declaring the `c` variable, the complete type `foo<int>`
    is not available, since a definition of the full specialization for `int` is missing.
    This generates a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: 'When specializing a function template, if the compiler can deduce a template
    argument from the type of the function arguments, then that template argument
    is optional. This is demonstrated by the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: The syntax for the full specialization for `int` of the `func` function template
    should be `template<> func<int>(foo<int>)`. However, the compiler is able to deduce
    the actual type that `T` represents from the function argument. Therefore, we
    don't have to specify it when defining the specialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, declarations or definitions of function templates and member
    function templates are not allowed to contain default function arguments. Therefore,
    in the following example, the compiler will issue an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: 'In all these examples, the templates had a single template argument. However,
    in practice, many templates have multiple arguments. Explicit specialization requires
    a definition with the full set of arguments being specified. This is demonstrated
    with the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: With these covered, we can move forward and look into partial specialization,
    which is basically a generalization of explicit (full) specialization.
  prefs: []
  type: TYPE_NORMAL
- en: Partial specialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Partial specialization occurs when you specialize a primary template but only
    specify some of the template arguments. This means a partial specialization has
    both a template parameter list (which follows the template keyword) and a template
    argument list (which follows the template name). However, only classes can be
    partially specialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the following example to understand how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a primary template called `collection` that has two template arguments
    (a type template argument and a non-type template argument) and we have three
    partial specializations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A specialization for the non-type template argument `S` with the value `10`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A specialization for the `int` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A specialization for the pointer type `T*`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These templates can be used as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: 'As specified in the comments, `a` is instantiated from the primary template,
    `b` from the partial specialization for `int` (`collection<int, S>`), `c` from
    the partial specialization for `10` (`collection<T, 10>`), and `d` from the partial
    specialization for pointers (`collection<T*, S>`). However, some combinations
    are not possible because they are ambiguous and the compiler cannot select which
    template instantiation to use. Here are a couple of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, both `collection<T, 10>` and `collection<int, S>` partial
    specializations match the type `collection<int, 10>`, while in the second case
    it can be either `collection<T, 10>` or `collection<T*, S>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When defining specializations of a primary template, you need to keep in mind
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Parameters in the template parameters list of the partial specialization cannot
    have default values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template parameters list implies an order of the arguments in the template
    arguments list, which is featured only in a partial specialization. This template
    arguments list of a partial specialization cannot be the same as the one implied
    by the template parameters list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the template argument list, you can only use identifiers for non-type template
    parameters. Expressions are not allowed in this context. This is demonstrated
    with the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE656]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When a class template has partial specializations, the compiler must decide
    what is the best match to generate a definition from. For this purpose, it matches
    the template arguments of the template specialization with the template argument
    list of the primary template and partial specializations. Depending on the result
    of this matching process, the compiler does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If no match is found, a definition is generated from the primary template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a single partial specialization is found, a definition is generated from
    that specialization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If more than a single partial specialization is found, then a definition is
    generated from the most specialized partial specialization but only if it is unique.
    Otherwise, the compiler generates an error (as we have seen previously). A template
    `A` is considered more specialized than a template `B` if it accepts a subset
    of the types that `B` accepts, but not the other way around.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, partial specializations are not found by name lookup and are considered
    only if the primary template is found by name lookup.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how partial specialization is useful, let's take a look at a real-world
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we want to create a function that formats the content of an
    array in a nice way and outputs it to a stream. The content of a formatted array
    should look like *[1,2,3,4,5]*. However, for arrays of `char` elements, the elements
    should not be separated by a comma but instead displayed as a string within square
    brackets, such as *[demo]*. For this purpose, we will consider the use of the
    `std::array` class. The following implementation formats the content of the array
    with delimiters between the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, `pretty_print` is a function template with two template parameters,
    matching the template parameters of the `std::array` class. When called with the
    `arr` array as an argument, it prints *[1,1,2,3,5,8,13,21]*. When called with
    the `str` array as an argument, it prints *[t,e,m,p,l,a,t,e]*. However, our intention
    is to print *[template]* in this latter case. For this, we need another implementation,
    which is specialized for the `char` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: In this second implementation, `pretty_print` is a function template with a
    single template parameter, which is a non-type template parameter indicating the
    size of the array. The type template parameter is explicitly specified as `char`,
    in `std::array<char, S>`. This time, the call to `pretty_print` with the `str`
    array prints `[template]` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: What is key to understand here is that it's not the `pretty_print` function
    template that is partially specialized but the `std::array` class template. Function
    templates cannot be specialized and what we have here are overloaded functions.
    However, `std::array<char,S>` is a specialization of the primary class template
    `std::array<T, S>`.
  prefs: []
  type: TYPE_NORMAL
- en: All the examples we have seen in this chapter were either function templates
    or class templates. However, variables can also be templates and this will be
    the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Defining variable templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variable templates were introduced in C++14 and allow us to define variables
    that are templates either at namespace scope, in which case they represent a family
    of global variables, or at class scope, in which case they represent static data
    members.
  prefs: []
  type: TYPE_NORMAL
- en: 'A variable template is declared at a namespace scope as shown in the following
    code snippet. This is a typical example that you can find in the literature, but
    we can use it to elaborate on the benefits of variable templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: The syntax is similar to declaring a variable (or data member) but combined
    with the syntax for declaring templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The question that arises is how variable templates are actually helpful. To
    answer this, let''s build up an example to demonstrate the point. Let''s consider
    we want to write a function template that, given the radius of a sphere, returns
    its volume. The volume of a sphere is `4Ï€r^3 / 3`. Therefore, a possible implementation
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `PI` is defined as a compile-time constant of the `double`
    type. This will generate a compiler warning if we use `float`, for instance, for
    the type template parameter `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: 'A potential solution to this problem is to make `PI` a static data member of
    a template class with its type determined by the type template parameter. This
    implementation can look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: 'This works, although the use of `PI<T>::value` is not ideal. It would be nicer
    if we could simply write `PI<T>`. This is exactly what the variable template `PI`
    shown at the beginning of the section allows us to do. Here it is again, with
    the complete solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: 'The next example shows yet another possible use case and also demonstrates
    the explicit specialization of variable templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE740]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE741]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE742]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a function template called `show_parts` that processes
    an input string after splitting it into parts delimited by a separator. The separator
    is a variable template defined at (global) namespace scope and is explicitly specialized
    for the `wchar_t` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'As previously mentioned, variable templates can be members of classes. In this
    case, they represent static data members and need to be declared using the `static`
    keyword. The following example demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE743]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE744]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE745]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE746]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE747]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE748]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE749]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE750]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE751]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE752]'
  prefs: []
  type: TYPE_PRE
- en: 'You can declare a variable template in a class and then provide its definition
    outside the class. Notice that in this case, the variable template must be declared
    with `static const` and not `static constexpr`, since the latter one requires
    in-class initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE753]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE754]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE755]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE756]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE757]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE758]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE759]'
  prefs: []
  type: TYPE_PRE
- en: 'Variable templates are used to simplify the use of type traits. The *Explicit
    specialization* section contained an example for a type trait called `is_floating_point`.
    Here is, again, the primary template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE760]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE761]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE762]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE763]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE764]'
  prefs: []
  type: TYPE_PRE
- en: 'There were several explicit specializations that I will not list here again.
    However, this `type` trait can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE765]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of `is_floating_point<float>::value` is rather cumbersome, but can
    be avoided with the help of a variable template that can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE766]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE767]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE768]'
  prefs: []
  type: TYPE_PRE
- en: 'This `is_floating_point_v` variable template helps write code that is arguably
    simpler and easier to read. The following snippet is the form I prefer over the
    verbose variant with `::value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE769]'
  prefs: []
  type: TYPE_PRE
- en: The standard library defines a series of variable templates suffixed with `_v`
    for `::value`, just as in our example (such as `std::is_floating_point_v` or `std::is_same_v`).
    We will discuss this topic in more detail in [*Chapter 5*](B18367_05_ePub.xhtml#_idTextAnchor080),
    *Type Traits and Conditional Compilation*.
  prefs: []
  type: TYPE_NORMAL
- en: Variable templates are instantiated similarly to function templates and class
    templates. This happens either with an explicit instantiation or explicit specialization,
    or implicitly by the compiler. The compiler generates a definition when the variable
    template is used in a context where a variable definition must exist, or the variable
    is needed for constant evaluation of an expression.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we move to the topic of alias templates, which allow us to define
    aliases for class templates.
  prefs: []
  type: TYPE_NORMAL
- en: Defining alias templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C++, an `typedef` declaration or with a `using` declaration (the latter
    was introduced in C++11). Here are several examples using `typedef`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE770]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE771]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE772]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE773]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE774]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE775]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE776]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE777]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE778]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `index_t` is an alias for `int`, `NameValueList` is an alias
    for `std::vector<std::pair<int, std::string>>`, while `fn_ptr` is an alias for
    the type of a pointer to a function that returns an `int` and has two parameters
    of type `int` and `char`. Lastly, `foo::value_type` is an alias for the type template
    `T`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since C++11, these type aliases can be created with the help of **using declarations**,
    which look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE779]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE780]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE781]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE782]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE783]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE784]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE785]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE786]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE787]'
  prefs: []
  type: TYPE_PRE
- en: Using declarations are now preferred over `typedef` declarations because they
    are simpler to use and are also more natural to read (from left to right). However,
    they have an important advantage over `typedef`s as they allow us to create aliases
    for templates. An **alias template** is a name that refers not to a type but a
    family of types. Remember, a template is not a class, function, or variable but
    a blueprint that allows the creation of a family of types, functions, or variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how alias templates work, let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE788]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE789]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE790]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE791]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE792]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE793]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE794]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE795]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE796]'
  prefs: []
  type: TYPE_PRE
- en: The declaration on line `[1]` introduces the alias template `customer_addresses_t`.
    It's an alias for a map type where the key type is `int` and the value type is
    `std::vector<T>`. Since `std::vector<T>` is not a type, but a family of types,
    `customer_addresses_t<T>` defines a family of types. The `using` declarations
    at `[2]` and `[3]` introduce two type aliases, `customer_delivery_addresses_t`
    and `customer_invoice_addresses_t`, from the aforementioned family of types.
  prefs: []
  type: TYPE_NORMAL
- en: Alias templates can appear at namespace or class scope just like any template
    declaration. On the other hand, they can neither be fully nor partially specialized.
    However, there are ways to overcome this limitation. A solution is to create a
    class template with a type alias member and specialize the class. Then you can
    create an alias template that refers to the type alias member. Let's demonstrate
    this with the help of an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the following is not valid C++ code, it represents the end goal I
    want to achieve, had the specialization of alias templates been possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE797]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE798]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE799]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE800]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `list_t` is an alias template for `std::vector<T>` provided
    the size of the collection is greater than `1`. However, if there is a single
    element, then `list_t` should be an alias for the type template parameter `T`.
    The way this can be actually achieved is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE801]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE802]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE803]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE804]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE805]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE806]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE807]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE808]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE809]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE810]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE811]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE812]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `list<T,S>` is a class template that has a member type alias
    called `T`. In the primary template, this is an alias for `std::vector<T>`. In
    the partial specialization `list<T,1>` it''s an alias for `T`. Then, `list_t`
    is defined as an alias template for `list<T, S>::type`. The following asserts
    prove this mechanism works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE813]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE814]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we end this chapter, there is one more topic that needs to be addressed:
    generic lambdas and their C++20 improvement, lambda templates.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring generic lambdas and lambda templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lambdas, which are formally called **lambda expressions**, are a simplified
    way to define function objects in the place where they are needed. This typically
    includes predicates or comparison functions passed to algorithms. Although we
    will not discuss lambda expressions in general, let''s take a look at the following
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE815]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE816]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE817]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE818]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE819]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE820]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE821]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE822]'
  prefs: []
  type: TYPE_PRE
- en: 'Lambda expressions are syntactic sugar, a simplified way of defining anonymous
    function objects. When encountering a lambda expression, the compiler generates
    a class with a function-call operator. For the previous example, these could look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE823]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE824]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE825]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE826]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE827]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE828]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE829]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE830]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE831]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE832]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE833]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE834]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE835]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE836]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE837]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE838]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE839]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE840]'
  prefs: []
  type: TYPE_PRE
- en: The names chosen here are arbitrary and each compiler will generate different
    names. Also, the implementation details may differ and the ones seen here are
    the bare minimum a compiler is supposed to generate. Notice that the difference
    between the first lambda and the second is that the latter contains state that
    it captures by value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lambda expressions, which were introduced in C++11, have received several updates
    in later versions of the standard. There are notably two, which will be discussed
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`auto` specifier instead of explicitly specifying types. This transforms the
    generated function object into one with a template function-call operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Template lambdas**, introduced in C++20, allow us to use the template syntax
    to explicitly specify the shape of the templatized function-call operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand the difference between these and how generic and template lambdas
    are helpful, let''s explore the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE841]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE842]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE843]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE844]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE845]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE846]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE847]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE848]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE849]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE850]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE851]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE852]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE853]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE854]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE855]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have three different lambdas: `l1` is a regular lambda, `l2` is a
    generic lambda, as at least one of the parameters is defined with the `auto` specifier,
    and `l3` is a template lambda, defined with the template syntax but without the
    use of the `template` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can invoke `l1` with an integer; we can also invoke it with a `double`,
    but this time the compiler will produce a warning about the possible loss of data.
    However, trying to invoke it with a string argument will produce a compile error,
    because `std::string` cannot be converted to `int`. On the other hand, `l2` is
    a generic lambda. The compiler proceeds to instantiate specializations of it for
    all the types of the arguments it''s invoked with, in this example `int`, `double`,
    and `std::string`. The following snippet shows how the generated function object
    may look, at least conceptually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE856]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE857]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE858]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE859]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE860]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE861]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE862]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE863]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE864]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE865]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE866]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE867]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE868]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE869]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE870]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE871]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE872]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE873]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE874]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE875]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE876]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE877]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE878]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see here the primary template for the function-call operator, as well
    as the three specializations that we mentioned. Not surprisingly, the compiler
    will generate the same code for the third lambda expression, `l3`, which is a
    template lambda, only available in C++20\. The question that arises from this
    is how are generic lambdas and lambda templates different? To answer this question,
    let''s modify the previous example a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE879]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE880]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE881]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE882]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE883]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE884]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE885]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE886]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE887]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE888]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE889]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE890]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE891]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE892]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE893]'
  prefs: []
  type: TYPE_PRE
- en: 'The new lambda expressions take two parameters. Again, we can call `l1` with
    two integers or an `int` and a `double` (although this again generates a warning)
    but we can''t call it with a string and `char`. However, we can do all these with
    the generic lambda `l2` and the lambda template `l3`. The code the compiler generates
    is identical for `l2` and `l3` and looks, semantically, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE894]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE895]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE896]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE897]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE898]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE899]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE900]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE901]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE902]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE903]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE904]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE905]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE906]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE907]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE908]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE909]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE910]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE911]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE912]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE913]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE914]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE915]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE916]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE917]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE918]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE919]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE920]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE921]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE922]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE923]'
  prefs: []
  type: TYPE_PRE
- en: 'We see, in this snippet, the primary template for the function-call operator,
    and several full explicit specializations: for two `int` values, for a `double`
    and an `int`, for a string and a `char`, and for two string objects. But what
    if we want to restrict the use of the generic lambda `l2` to arguments of the
    same type? This is not possible. The compiler cannot deduce our intention and,
    therefore, it would generate a different type template parameter for each occurrence
    of the `auto` specifier in the parameter list. However, the lambda templates from
    C++20 do allow us to specify the form of the function-call operator. Take a look
    at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE924]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE925]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE926]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE927]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE928]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE929]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE930]'
  prefs: []
  type: TYPE_PRE
- en: Invoking the lambda template with any two arguments of different types, even
    if they are implicitly convertible such as from `int` to `double`, is not possible.
    The compiler will generate an error. It's not possible to explicitly provide the
    template arguments when invoking the template lambda, such as in `l5<double>(42,
    1.0)`. This also generates a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `decltype` type specifier allows us to tell the compiler to deduce the
    type from an expression. This topic is covered in detail in [*Chapter 4*](B18367_04_ePub.xhtml#_idTextAnchor064),
    *Advanced Template Concepts*. However, in C++14, we can use this in a generic
    lambda to declare the second parameter in the previous generic lambda expression
    to have the same type as the first parameter. More precisely, this would look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE931]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this implies that the type of the second parameter, `b`, must be convertible
    to the type of the first parameter, `a`. This allows us to write the following
    calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE932]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE933]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE934]'
  prefs: []
  type: TYPE_PRE
- en: The first call is compiled without any problems because `int` is implicitly
    convertible to `double`. The second call compiles with a warning, because converting
    from `double` to `int` may incur a loss of data. The third call, however, generates
    an error, because `char` cannot be implicitly convertible to `std::string`. Although
    the `l4` lambda is an improvement over the generic lambda `l2` seen previously,
    it still does not help restrict calls completely if the arguments are of different
    types. This is only possible with lambda templates as shown earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of a lambda template is shown in the next snippet. This lambda
    has a single argument, a `std::array`. However, the type of the elements of the
    array and the size of the array are specified as template parameters of the lambda
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE935]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE936]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE937]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE938]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE939]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE940]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE941]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE942]'
  prefs: []
  type: TYPE_PRE
- en: 'Attempting to call this lambda with anything other than an `std::array` object
    produces a compiler error. The compiler-generated function object may look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE943]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE944]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE945]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE946]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE947]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE948]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE949]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE950]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE951]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE952]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE953]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE954]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE955]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE956]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE957]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE958]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE959]'
  prefs: []
  type: TYPE_PRE
- en: 'An interesting benefit of generic lambdas over regular lambdas concerns recursive
    lambdas. Lambdas do not have names; they are anonymous, therefore, you cannot
    recursively call them directly. Instead, you have to define a `std::function`
    object, assign the lambda expression to it, and also capture it by reference in
    the capture list. The following is an example of a recursive lambda that computes
    the factorial of a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE960]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE961]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE962]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE963]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE964]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE965]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be simplified with the use of generic lambdas. They don''t require
    a `std::function` and its capture. A recursive generic lambda can be implemented
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE966]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE967]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE968]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE969]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE970]'
  prefs: []
  type: TYPE_PRE
- en: 'If understanding how this works is hard, the compiler-generated code should
    help you figure it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE971]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE972]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE973]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE974]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE975]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE976]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE977]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE978]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE979]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE980]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE981]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE982]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE983]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE984]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE985]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE986]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE987]'
  prefs: []
  type: TYPE_PRE
- en: A generic lambda is a function object with a template function-call operator.
    The first argument, specified with `auto`, can be anything, including the lambda
    itself. Therefore, the compiler will provide a full explicit specialization of
    the call operator for the type of the generated class.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions help us avoid writing explicit code when we need to pass
    function objects as arguments to other functions. The compiler, instead, generates
    that code for us. Generic lambdas, introduced in C++14, help us avoid writing
    the same lambdas for different types. The lambda templates for C++20 allow us
    to specify the form of the generated call operator with the help of template syntax
    and semantics.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was a walk through of the core features of C++ templates. We have
    learned how to define class templates, function templates, variable templates,
    and alias templates. Along the way, we looked in detail at template instantiation
    and template specialization after learning about template parameters. We also
    learned about generic lambdas and lambda templates and what benefits they have
    compared to regular lambdas. By completing this chapter, you are now familiar
    with the template fundamentals, which should allow you to understand large parts
    of template code as well as write templates yourself.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at another important topic, which is templates
    with a variable number of arguments called variadic templates.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What category of types can be used for non-type template parameters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where are default template arguments not allowed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is explicit instantiation declaration and how does it differ syntactically
    from explicit instantiation definition?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an alias template?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are template lambdas?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ Template: A Quick UpToDate Look(C++11/14/17/20), [http://www.vishalchovatiya.com/c-template-a-quick-uptodate-look/](http://www.vishalchovatiya.com/c-template-a-quick-uptodate-look/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates aliases for C++, [https://www.stroustrup.com/template-aliases.pdf](https://www.stroustrup.com/template-aliases.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lambdas: From C++11 to C++20, Part 2, [https://www.cppstories.com/2019/03/lambdas-story-part2/](https://www.cppstories.com/2019/03/lambdas-story-part2/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
