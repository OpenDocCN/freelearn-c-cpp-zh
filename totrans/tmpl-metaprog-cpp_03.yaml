- en: '*Chapter 2*: Template Fundamentals'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：模板基础'
- en: 'In the previous chapter, we saw a short introduction to templates. What they
    are, how they are helpful, pros and cons for using templates, and, also, a few
    examples of function and class templates. In this chapter, we will explore this
    area in detail, and look at aspects such as template parameters, instantiation,
    specializations, aliases, and more. The main topics that you will learn about
    from this chapter are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了模板。它们是什么，它们如何有帮助，使用模板的优缺点，以及一些函数和类模板的例子。在本章中，我们将详细探讨这个领域，并查看模板参数、实例化、特化、别名等方面。本章的主要学习内容包括以下内容：
- en: How to define function templates, class templates, variable templates, and alias
    templates
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何定义函数模板、类模板、变量模板和别名模板
- en: What kinds of template parameters exist?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在哪些类型的模板参数？
- en: What is template instantiation?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是模板实例化？
- en: What is template specialization?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是模板特化？
- en: How to use generic lambdas and lambda templates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用泛型 lambda 和 lambda 模板
- en: By the end of this chapter, you will be familiar with the core fundamentals
    of templates in C++ and be able to understand large areas of template code and
    also write templates by yourself.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将熟悉 C++ 中模板的核心基础，能够理解大量模板代码，并能够自己编写模板。
- en: To start this chapter, we will explore the details of defining and using function
    templates.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始本章，我们将探讨定义和使用函数模板的细节。
- en: Defining function templates
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义函数模板
- en: 'Function templates are defined in a similar way to regular functions, except
    that the function declaration is preceded by the keyword `template` followed by
    a list of template parameters between angle brackets. The following is a simple
    example of a function template:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 函数模板的定义方式与常规函数类似，只是函数声明前面是关键字 `template`，后面跟着一个用尖括号括起来的模板参数列表。以下是一个简单的函数模板示例：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function has two parameters, called `a` and `b`, both of the same `T` type.
    This type is listed in the template parameters list, introduced with the keyword
    `typename` or `class` (the former is used in this example and throughout the book).
    This function does nothing more than add the two arguments and returns the result
    of this operation, which should have the same `T` type.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有两个参数，称为 `a` 和 `b`，它们都是相同的 `T` 类型。这个类型列在模板参数列表中，由关键字 `typename` 或 `class`（在本例和整本书中使用了前者）引入。这个函数所做的只是将两个参数相加并返回这个操作的结果，这个结果应该具有相同的
    `T` 类型。
- en: 'Function templates are only blueprints for creating actual functions and only
    exist in source code. Unless explicitly called in your source code, the function
    templates will not be present in the compiled executable. However, when the compiler
    encounters a call to a function template and is able to match the supplied arguments
    and their types to a function template''s parameters, it generates an actual function
    from the template and the arguments used to invoke it. To understand this, let''s
    look at some examples:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 函数模板只是创建实际函数的蓝图，并且只存在于源代码中。除非在源代码中显式调用，否则函数模板将不会出现在编译后的可执行文件中。然而，当编译器遇到对函数模板的调用并且能够将提供的参数及其类型与函数模板的参数匹配时，它将根据模板和用于调用的参数生成一个实际函数。为了理解这一点，让我们看看一些例子：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this snippet, we call the `add` function with two `int` parameters, `42`
    and `21`. The compiler is able to deduce the template parameter `T` from the type
    of the supplied arguments, making it unnecessary to explicitly provide it. However,
    the following two invocations are also possible, and, in fact, identical to the
    earlier one:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们使用两个 `int` 参数 `42` 和 `21` 调用 `add` 函数。编译器能够从提供的参数类型中推断出模板参数 `T`，因此不需要显式提供它。然而，以下两种调用也是可能的，并且实际上与前面的一种相同：
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'From this invocation, the compiler will generate the following function (keep
    in mind that the actual code may differ for various compilers):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个调用中，编译器将生成以下函数（请注意，实际代码可能因编译器的不同而有所不同）：
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, if we change the call to the following form, we explicitly provide
    the argument for the template parameter `T`, as the `short` type:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们改变调用形式，我们明确为模板参数 `T` 提供了 `short` 类型的参数：
- en: '[PRE12]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this case, the compiler will generate another instantiation of this function,
    with `short` instead of `int`. This new instantiation would look as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器将生成这个函数的另一个实例，用 `short` 代替 `int`。这个新的实例将如下所示：
- en: '[PRE13]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If the type of the two parameters is ambiguous, the compiler will not be able
    to deduce them automatically. This is the case with the following invocation:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个参数的类型不明确，编译器将无法自动推断它们。以下调用就是这种情况：
- en: '[PRE17]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this example, `41.0` is a `double` but `21` is an `int`. The `add` function
    template has two parameters of the same type, so the compiler is not able to match
    it with the supplied arguments and will issue an error. To avoid this, and suppose
    you expected it to be instantiated for `double`, you have to specify the type
    explicitly, as shown in the following snippet:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`41.0`是一个`double`类型，而`21`是一个`int`类型。`add`函数模板有两个相同类型的参数，因此编译器无法将其与提供的参数匹配，并将引发错误。为了避免这种情况，假设你希望它为`double`类型实例化，你必须显式指定类型，如下面的代码片段所示：
- en: '[PRE18]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As long as the two arguments have the same type and the `+` operator is available
    for the type of the arguments, you can call the function template `add` in the
    ways shown previously. However, if the `+` operator is not available, then the
    compiler will not be able to generate an instantiation, even if the template parameters
    are correctly resolved. This is shown in the following snippet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 只要两个参数具有相同的类型，并且`+`运算符对于参数类型是可用的，你就可以以前面显示的方式调用函数模板`add`。然而，如果`+`运算符不可用，那么即使模板参数被正确解析，编译器也无法生成实例化。这如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this case, the compiler will issue an error that a binary `+` operator is
    not found for arguments of type `foo`. Of course, the actual message differs for
    different compilers, which is the case for all errors. To make it possible to
    call `add` for arguments of type `foo`, you''d have to overload the `+` operator
    for this type. A possible implementation is the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器将发出错误，指出找不到类型`foo`的二进制`+`运算符。当然，不同的编译器会有不同的实际消息，所有错误都是如此。为了能够为类型`foo`的参数调用`add`，你必须为此类型重载`+`运算符。一个可能的实现如下：
- en: '[PRE28]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'All the examples that we have seen so far represented templates with a single
    template parameter. However, a template can have any number of parameters and
    even a variable number of parameters. This latter topic will be addressed in [*Chapter
    3*](B18367_03_ePub.xhtml#_idTextAnchor051), *Variadic Templates*. The next function
    is a function template that has two type template parameters:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的所有示例都表示了只有一个模板参数的模板。然而，一个模板可以有任意数量的参数，甚至可以有可变数量的参数。这个后者的主题将在[*第3章*](B18367_03_ePub.xhtml#_idTextAnchor051)中讨论，*可变参数模板*。下一个函数是一个有两个类型模板参数的函数模板：
- en: '[PRE32]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This function takes two input iterators to the start and end of a range and
    a predicate and returns the number of elements in the range that match the predicate.
    This function, at least conceptually, is very similar to the `std::count_if` general-purpose
    function from the `<algorithm>` header in the standard library and you should
    always prefer to use standard algorithms over hand-crafted implementations. However,
    for the purpose of this topic, this function is a good example to help you understand
    how templates work.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受两个输入迭代器，分别指向范围的开头和结尾，以及一个谓词，并返回范围内匹配谓词的元素数量。这个函数，至少在概念上，与标准库中`<algorithm>`头文件中的`std::count_if`通用函数非常相似，你应该始终优先使用标准算法而不是手工实现的算法。然而，为了本主题的目的，这个函数是一个很好的例子，可以帮助你理解模板是如何工作的。
- en: 'We can use the `count_if` function as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`count_if`函数如下：
- en: '[PRE43]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Again, there is no need to explicitly specify the arguments for the type template
    parameters (the type of the input iterator and the type of the unary predicate)
    because the compiler is able to infer them from the call.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，没有必要显式指定类型模板参数的参数（输入迭代器的类型和一元谓词的类型），因为编译器能够从调用中推断它们。
- en: Although there are more things to learn about function templates, this section
    provided an introduction to working with them. Let's now learn the basics of defining
    class templates.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然还有更多关于函数模板的知识需要学习，但本节提供了关于如何使用它们的介绍。现在让我们学习定义类模板的基础知识。
- en: Defining class templates
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义类模板
- en: 'Class templates are declared in a very similar manner, with the `template`
    keyword and the template parameter list preceding the class declaration. We saw
    the first example in the introductory chapter. The next snippet shows a class
    template called `wrapper`. It has a single template parameter, a type called `T`,
    that is used as the type for data members, parameters, and function return types:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板的声明方式与类声明非常相似，使用 `template` 关键字和模板参数列表在类声明之前。我们已经在引言章节中看到了第一个例子。下面的代码片段展示了名为
    `wrapper` 的类模板。它有一个单一的模板参数，称为 `T`，用作数据成员、参数和函数返回类型的类型：
- en: '[PRE51]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As long as the class template is not used anywhere in your source code, the
    compiler will not generate code from it. For that to happen, the class template
    must be instantiated and all its parameters properly matched to arguments either
    explicitly, by the user, or implicitly, by the compiler. Examples for instantiating
    this class template are shown next:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 只要类模板在您的源代码中任何地方都没有使用，编译器就不会从它生成代码。为了实现这一点，类模板必须被实例化，并且所有参数都必须正确地与参数匹配，无论是用户显式地匹配，还是编译器隐式地匹配。下面展示了实例化此类模板的例子：
- en: '[PRE61]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The definitions of `a` and `e` in this snippet are only valid in C++17 and onward
    thanks to a feature called `wrapper<int>` or `wrapper<char const*>`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个名为 `wrapper<int>` 或 `wrapper<char const*>` 的特性，这个片段中 `a` 和 `e` 的定义仅在 C++17
    及以后版本中有效。
- en: 'Class templates can be declared without being defined and used in contexts
    where incomplete types are allowed, such as the declaration of a function, as
    shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板可以在不定义的情况下声明，并在允许不完整类型的环境中使用，例如函数的声明，如下所示：
- en: '[PRE66]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'However, a class template must be defined at the point where the template instantiation
    occurs; otherwise, the compiler will generate an error. This is exemplified with
    the following snippet:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类模板必须在模板实例化的点定义；否则，编译器将生成错误。以下代码片段展示了这一点：
- en: '[PRE69]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: When declaring the `use_wrapper` function, the class template wrapper is only
    declared, but not defined. However, incomplete types are allowed in this context,
    which makes it all right to use `wrapper<T>` at this point. However, in the `main`
    function we are instantiating an object of the `wrapper` class template. This
    will generate a compiler error because at this point the definition of the class
    template must be available. To fix this particular example, we'd have to move
    the definition of the `main` function to the end, after the definition of `wrapper`
    and `use_wrapper`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明 `use_wrapper` 函数时，类模板 `wrapper` 只被声明，而没有定义。然而，在这个上下文中允许不完整类型，这使得在这一点上使用
    `wrapper<T>` 是可以的。然而，在 `main` 函数中，我们正在实例化 `wrapper` 类模板的对象。这将生成编译器错误，因为在这个点上类模板的定义必须是可用的。为了修复这个特定的例子，我们必须将
    `main` 函数的定义移动到末尾，在 `wrapper` 和 `use_wrapper` 定义之后。
- en: 'In this example, the class template was defined using the `class` keyword.
    However, in C++ there is little difference between declaring classes with the
    `class` or `struct` keyword:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，类模板是使用 `class` 关键字定义的。然而，在 C++ 中，使用 `class` 或 `struct` 关键字声明类之间几乎没有区别：
- en: With `struct`, the default member access is public, whereas using `class` is
    private.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `struct` 时，默认成员访问权限是公共的，而使用 `class` 则是私有的。
- en: With `struct`, the default access specifier for base-class inheritance is public,
    whereas using `class` is private.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `struct` 时，基类继承的默认访问修饰符是公共的，而使用 `class` 则是私有的。
- en: You can define class templates using the `struct` keyword the same way we did
    here using the `class` keyword. The differences between classes defined with the
    `struct` or the `class` keyword are also observed for class templates defined
    with the `struct` or `class` keyword.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `struct` 关键字定义类模板，就像我们在这里使用 `class` 关键字一样。使用 `struct` 或 `class` 关键字定义的类之间的差异也适用于使用
    `struct` 或 `class` 关键字定义的类模板。
- en: Classes, whether they are templates or not, may contain member function templates
    too. The way these are defined is discussed in the next section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不论类是否是模板，都可能包含成员函数模板。这些定义的方式将在下一节中讨论。
- en: Defining member function templates
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义成员函数模板
- en: 'So far, we have learned about function templates and class templates. It is
    possible to define member function templates too, both in non-template classes
    and class templates. In this section, we will learn how to do this. To understand
    the differences, let''s start with the following example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了关于函数模板和类模板的知识。也可以定义成员函数模板，无论是在非模板类中还是在类模板中。在本节中，我们将学习如何做到这一点。为了理解差异，让我们从以下示例开始：
- en: '[PRE86]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `composition` class is a class template. It has a single member function
    called `add` that uses the type parameter `T`. This class can be used as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`composition` 类是一个类模板。它有一个名为 `add` 的单一成员函数，该函数使用类型参数 `T`。这个类可以这样使用：'
- en: '[PRE95]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We first need to instantiate an object of the `composition` class. Notice that
    we must explicitly specify the argument for the type parameter `T` because the
    compiler is not able to figure it out by itself (there is no context from which
    to infer it). When we invoke the `add` function, we just provide the arguments.
    Their type, represented by the `T` type template parameter that was previously
    resolved to `int`, is already known. A call such as `c.add<int>(42, 21)` would
    trigger a compiler error. The `add` function is not a function template, but a
    regular function that is a member of the `composition` class template.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要实例化 `composition` 类的对象。请注意，我们必须显式指定类型参数 `T` 的参数，因为编译器无法自行推断出来（没有上下文可以从中推断）。当我们调用
    `add` 函数时，我们只需提供参数。它们的类型，由之前解析为 `int` 的 `T` 类型模板参数表示，已经已知。例如 `c.add<int>(42, 21)`
    这样的调用将触发编译器错误。`add` 函数不是一个函数模板，而是一个类模板 `composition` 的成员函数。
- en: 'In the next example, the `composition` class changes slightly, but significantly.
    Let''s see the definition first:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，`composition` 类略有变化，但意义重大。让我们首先看看定义：
- en: '[PRE97]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'This time, `composition` is a non-template class. However, the `add` function
    is a function template. Therefore, to call this function, we must do the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`composition` 是一个非模板类。然而，`add` 函数是一个函数模板。因此，要调用此函数，我们必须执行以下操作：
- en: '[PRE106]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The explicit specification of the `int` type for the `T` type template parameter
    is redundant since the compiler can deduce it by itself from the arguments of
    the call. However, it was shown here to better comprehend the differences between
    these two implementations.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `T` 类型模板参数的 `int` 类型显式指定是多余的，因为编译器可以从调用参数中自行推断出来。然而，这里展示了这样做有助于更好地理解这两种实现之间的差异。
- en: 'Apart from these two cases, member functions of class templates and member
    function templates of classes, we can also have member function templates of class
    templates. In this case, however, the template parameters of the member function
    template must differ from the template parameters of the class template; otherwise,
    the compiler will generate an error. Let''s return to the `wrapper` class template
    example and modify it as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两种情况之外，我们还可以有类模板的成员函数模板。在这种情况下，成员函数模板的模板参数必须与类模板的模板参数不同；否则，编译器将生成错误。让我们回到
    `wrapper` 类模板示例，并按如下方式修改它：
- en: '[PRE108]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'As you can see here, this implementation features one more member, a function
    called `as`. This is a function template and has a type template parameter called
    `U`. This function is used to cast the wrapped value from a type `T` to a type
    `U`, and return it to the caller. We can use this implementation as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个实现增加了一个成员，一个名为 `as` 的函数。这是一个函数模板，有一个名为 `U` 的类型模板参数。这个函数用于将包装值从类型 `T`
    转换为类型 `U`，并将其返回给调用者。我们可以如下使用这个实现：
- en: '[PRE123]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Arguments for the template parameters were specified when instantiating the
    `wrapper` class (`double`) – although in C++17 this is redundant, and when invoking
    the `as` function (`int`) to perform the cast.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化 `wrapper` 类（`double`）时指定了模板参数的参数 - 虽然在 C++17 中这是多余的，并且在调用 `as` 函数（`int`）以执行转换时。
- en: Before we continue with other topics such as instantiation, specialization,
    and other forms of templates, including variables and aliases, it's important
    that we take the time to learn more about template parameters. This will make
    the subject of the next section.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续其他主题之前，例如实例化、特化和其他形式的模板，包括变量和别名之前，重要的是我们要花时间更多地了解模板参数。这将使下一节的主题更加清晰。
- en: Understanding template parameters
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模板参数
- en: So far in the book, we have seen multiple examples of templates with one or
    more parameters. In all these examples, the parameters represented types supplied
    at instantiation, either explicitly by the user, or implicitly by the compiler
    when it could deduce them. These kinds of parameters are called **type template
    parameters**. However, templates can also have **non-type template parameters**
    and **template template parameters**. In the following sections, we'll explore
    all of them.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '到目前为止，本书中我们已经看到了多个具有一个或多个参数的模板示例。在所有这些示例中，参数代表在实例化时提供的类型，无论是用户明确提供的，还是编译器在可以推断它们时隐式提供的。这类参数被称为**类型模板参数**。然而，模板也可以有**非类型模板参数**和**模板模板参数**。在以下章节中，我们将探讨所有这些参数。 '
- en: Type template parameters
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型模板参数
- en: 'As already mentioned, these are parameters representing types supplied as arguments
    during the template instantiation. They are introduced either with the `typename`
    or the `class` keyword. There is no difference between using these two keywords.
    A type template parameter can have a default value, which is a type. This is specified
    the same way you would specify a default value for a function parameter. Examples
    for these are shown in the following snippet:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些是在模板实例化过程中作为参数提供的类型参数。它们通过`typename`或`class`关键字引入。使用这两个关键字没有区别。类型模板参数可以有一个默认值，这是一个类型。这可以通过与指定函数参数默认值相同的方式指定。以下是一些示例：
- en: '[PRE126]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The name of the type template parameter can be omitted, which can be useful
    in forwarding declarations:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 类型模板参数的名称可以省略，这在转发声明中可能很有用：
- en: '[PRE130]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'C++11 has introduced variadic templates, which are templates with a variable
    number of arguments. A template parameter that accepts zero or more arguments
    is called a **parameter pack**. A **type template parameter pack** has the following
    form:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了可变模板，这些模板具有可变数量的参数。接受零个或多个参数的模板参数称为**参数包**。**类型模板参数包**具有以下形式：
- en: '[PRE134]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Variadic templates will be addressed in [*Chapter 3*](B18367_03_ePub.xhtml#_idTextAnchor051),
    *Variadic Templates*. Therefore, we will not get into details about these kinds
    of parameters at this point.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 可变模板将在[*第3章*](B18367_03_ePub.xhtml#_idTextAnchor051)，“可变模板”中讨论。因此，我们在此不会深入讨论这类参数的细节。
- en: 'C++20 has introduced `typename` or the `class` keyword. Examples, including
    concepts with a default value and constrained type template parameter pack, are
    shown as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: C++20引入了`typename`或`class`关键字。以下是一些示例，包括具有默认值的概念和受约束的类型模板参数包：
- en: '[PRE136]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Concepts and constraints are discussed in [*Chapter 6*](B18367_06_ePub.xhtml#_idTextAnchor099),
    *Concepts and Constraints*. We will learn more about these kinds of parameters
    in that chapter. For now, let's look at the second kind of template parameters,
    non-type template parameters.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 概念和约束在第[*第6章*](B18367_06_ePub.xhtml#_idTextAnchor099)“概念和约束”中讨论。我们将在那一章中了解更多关于这类参数的信息。现在，让我们看看第二种模板参数，非类型模板参数。
- en: Non-type template parameters
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非类型模板参数
- en: 'Template arguments don''t always have to represent types. They can also be
    compile-time expressions, such as constants, addresses of functions or objects
    with external linkage, or addresses of static class members. Parameters supplied
    with compile-time expressions are called **non-type template parameters**. This
    category of parameters can only have a **structural type**. The following are
    the structural types:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数不总是必须代表类型。它们也可以是编译时表达式，例如常量、具有外部链接的函数或对象的地址，或静态类成员的地址。使用编译时表达式提供的参数称为**非类型模板参数**。这类参数只能具有**结构化类型**。以下是一些结构化类型：
- en: Integral types
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数类型
- en: Floating-point types, as of C++20
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点类型，自C++20起
- en: Enumerations
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Pointer types (either to objects or functions)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针类型（指向对象或函数）
- en: Pointer to member types (either to member objects or member functions)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员类型指针（指向成员对象或成员函数）
- en: Lvalue reference types (either to objects or functions)
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左值引用类型（指向对象或函数）
- en: 'A literal class type that meets the following requirements:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符合以下要求的字面类类型：
- en: All base classes are public and non-mutable.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有基类都是公开且不可变的。
- en: All non-static data members are public and non-mutable.
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有非静态数据成员都是公开且不可变的。
- en: The types of all base classes and non-static data members are also structural
    types or arrays thereof.
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有基类和非静态数据成员的类型也是结构化类型或其数组。
- en: 'cv-qualified forms of these types can also be used for non-type template parameters.
    Non-type template parameters can be specified in different ways. The possible
    forms are shown in the following snippet:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的 cv-限定形式也可以用于非类型模板参数。非类型模板参数可以以不同的方式指定。可能的形式在以下片段中显示：
- en: '[PRE142]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: In all these examples, the type of the non-type template parameters is `int`.
    The first and second examples are similar, except that in the second example a
    default value is used. The third example is significantly different because the
    parameter is actually a parameter pack. This will be discussed in the next chapter.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些例子中，非类型模板参数的类型是 `int`。第一个和第二个例子是相似的，除了第二个例子使用了默认值。第三个例子显著不同，因为参数实际上是一个参数包。这将在下一章中讨论。
- en: 'To understand non-type template parameters better, let''s look at the following
    example, where we sketch a fixed-size array class, called `buffer`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解非类型模板参数，让我们看看以下示例，其中我们草拟了一个固定大小的数组类，称为 `buffer`：
- en: '[PRE148]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'This `buffer` class holds an internal array of `S` elements of type `T`. Therefore,
    `S` needs to be a compile-type value. This class can be instantiated as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `buffer` 类包含一个内部数组，该数组有 `S` 个元素，类型为 `T`。因此，`S` 需要是一个编译时值。这个类可以如下实例化：
- en: '[PRE163]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'These two definitions are equivalent, and both `b1` and `b2` are two buffers
    holding 10 integers. Moreover, they are of the same type, since 2*5 and 10 are
    two expressions evaluated to the same compile-time value. You can easily check
    this with the following statement:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个定义是等价的，`b1` 和 `b2` 都是两个包含 10 个整数的缓冲区。此外，它们是同一类型，因为 2*5 和 10 是两个在编译时评估为相同值的表达式。你可以通过以下语句轻松检查这一点：
- en: '[PRE165]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'This is not the case anymore, for the type of the `b3` object is declared as
    follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况不再适用，因为 `b3` 对象的类型声明如下：
- en: '[PRE166]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'In this example, `b3` is a `buffer` holding 15 integers, which is different
    from the `buffer` type from the previous example that held 10 integers. Conceptually,
    the compiler generates the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`b3` 是一个包含 15 个整数的 `buffer`，这与上一个例子中包含 10 个整数的 `buffer` 类型不同。从概念上讲，编译器会生成以下代码：
- en: '[PRE167]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'This is the code for the primary template but there are also a couple of specializations
    shown next:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主模板的代码，但接下来还将展示几个特化示例：
- en: '[PRE182]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'The concept of specialization, seen in this code sample, is detailed further
    on in this chapter, in the *Understanding template specialization* section. For
    the time being, you should notice the two different `buffer` types. Again, it''s
    possible to verify that the types of `b1` and `b3` are different with the following
    statement:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中看到的特化概念将在本章的 *理解模板特化* 部分中进一步详细说明。目前，你应该注意到两种不同的 `buffer` 类型。再次强调，可以通过以下语句验证
    `b1` 和 `b3` 的类型不同：
- en: '[PRE202]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'The use of structural types such as integer, floating-point, or enumeration
    types is encountered in practice more often than the rest. It''s probably easier
    to understand their use and find useful examples for them. However, there are
    scenarios where pointers or references are used. In the following example, we
    will examine the use of a pointer to function parameter. Let''s see the code first:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，使用结构化类型（如整数、浮点数或枚举类型）的情况比其他情况更为常见。理解它们的使用和找到有用的示例可能更容易。然而，也存在使用指针或引用的场景。在以下示例中，我们将检查函数参数指针的使用。让我们先看看代码：
- en: '[PRE203]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'In this snippet, `device` is a base class with a pure virtual function called
    `output` (and a virtual destructor). This is the base class for a class template
    called `smart_device` that implements the `output` virtual function by calling
    a function through a function pointer. This function pointer is passed an argument
    for the non-type template parameter of the class template. The following sample
    shows how it can be used:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`device` 是一个具有纯虚函数 `output`（以及虚析构函数）的基类。这是 `smart_device` 类模板的基类，该类模板通过调用函数指针来实现
    `output` 虚函数。这个函数指针传递了一个参数给类模板的非类型模板参数。以下示例展示了它的用法：
- en: '[PRE216]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'Here, `w1` and `w2` are two `unique_ptr` objects. Although, apparently, they
    point to objects of the same type, that is not true, because `smart_device<&say_hello_in_english>`
    and `smart_device<&say_hello_in_spanish>` are different types since they are instantiated
    with different values for the function pointer. This can be easily checked with
    the following statement:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`w1`和`w2`是两个`unique_ptr`对象。尽管表面上它们指向相同类型的对象，但这并不正确，因为`smart_device<&say_hello_in_english>`和`smart_device<&say_hello_in_spanish>`是不同的类型，因为它们使用不同的函数指针值实例化。这可以通过以下语句轻松检查：
- en: '[PRE230]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'If we, on the other hand, change the `auto` specifier with `std::unique_ptr<device>`,
    as shown in the following snippet, then `w1` and `w2` are smart pointers to the
    base class device, and therefore have the same type:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果我们将`auto`指定符改为`std::unique_ptr<device>`，如下面的代码片段所示，那么`w1`和`w2`就是基类device的智能指针，因此它们具有相同的类型：
- en: '[PRE231]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'Although this example uses a pointer to function, a similar example can be
    conceived for pointer to member functions. The previous example can be transformed
    to the following (still using the same base class device):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子使用了函数指针，但也可以构思一个类似的使用成员函数指针的例子。前一个例子可以转换为以下形式（仍然使用相同的基类device）：
- en: '[PRE238]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'These classes can be used as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类可以如下使用：
- en: '[PRE260]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'In C++17, a new form of specifying non-type template parameters was introduced,
    using the `auto` specifier (including the `auto*` and `auto&` forms) or `decltype(auto)`
    instead of the name of the type. This allows the compiler to deduce the type of
    the parameter from the expression supplied as the argument. If the deduced type
    is not permitted for a non-type template parameter the compiler will generate
    an error. Let''s see an example:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，引入了一种新的指定非类型模板参数的形式，使用`auto`指定符（包括`auto*`和`auto&`形式）或`decltype(auto)`代替类型的名称。这允许编译器从提供的表达式推断参数的类型。如果推断的类型不允许作为非类型模板参数，编译器将生成错误。让我们看一个例子：
- en: '[PRE269]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'This class template can be used as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类模板可以如下使用：
- en: '[PRE272]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: In the first example, for `f1`, the compiler deduces the type of the argument
    as `int`. In the second example, for `f2`, the compiler deduces the type as `double`.
    However, this is only the case for C++20\. In previous versions of the standard,
    this line would yield an error, since floating-point types were not permitted
    as arguments for non-type template parameters prior to C++20\. The last line,
    however, produces an error because `"42"` is a string literal and string literals
    cannot be used as arguments for non-type template parameters.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，对于`f1`，编译器推断参数的类型为`int`。在第二个例子中，对于`f2`，编译器推断的类型为`double`。然而，这只适用于C++20。在标准的前版本中，这一行会产生错误，因为C++20之前不允许将浮点类型作为非类型模板参数的参数。然而，最后一行产生错误，因为`"42"`是一个字符串字面量，而字符串字面量不能用作非类型模板参数的参数。
- en: 'The last example can be, however, worked around in C++20 by wrapping the literal
    string in a structural literal class. This class would store the characters of
    the string literal in a fixed-length array. This is exemplified in the following
    snippet:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在C++20中，可以通过将字面量字符串包裹在结构字面量类中来绕过最后一个例子。这个类将字符串字面量的字符存储在固定长度的数组中。以下代码片段展示了这一点：
- en: '[PRE276]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: 'However, the `foo` class template shown previously needs to be modified to
    use `string_literal` explicitly and not the `auto` specifier:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前面展示的`foo`类模板需要修改，以显式使用`string_literal`而不是`auto`指定符：
- en: '[PRE285]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: With this is in place, the `foo<"42"> f;` declaration shown earlier will compile
    without any errors in C++20.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，前面展示的`foo<"42"> f;`声明在C++20中将无错误编译。
- en: 'The `auto` specifier can also be used with a non-type template parameter pack.
    In this case, the type is deduced independently for each template argument. The
    types of the template arguments do not need to be the same. This is shown in the
    following snippet:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto`指定符也可以与非类型模板参数包一起使用。在这种情况下，每个模板参数的类型都是独立推断的。模板参数的类型不需要相同。以下代码片段展示了这一点：'
- en: '[PRE289]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: In this example, the compiler deduces the types of the template arguments as
    `int`, `double`, `bool`, and `char`, respectively.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，编译器推断模板参数的类型分别为`int`、`double`、`bool`和`char`。
- en: The third and last category of template parameters are **template template parameters**.
    We will look at them next.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种也是最后一种模板参数类别是**模板模板参数**。我们将在下一节中探讨它们。
- en: Template template parameters
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板模板参数
- en: Although the name may sound a bit strange, it refers to a category of template
    parameters that are themselves templates. These can be specified similarly to
    type template parameters, with or without a name, with or without a default value,
    and as a parameter pack with or without a name. As of C++17, both the keywords
    `class` and `typename` can be used to introduce a template template parameter.
    Prior to this version, only the `class` keyword could be used.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个名字听起来可能有点奇怪，但它指的是一类模板参数，这些参数本身也是模板。这些参数可以像类型模板参数一样指定，带有或没有名称，带有或没有默认值，以及带有或没有名称的参数包。截至
    C++17，可以使用关键字 `class` 和 `typename` 来引入模板模板参数。在此版本之前，只能使用 `class` 关键字。
- en: 'To showcase the use of template template parameters, let''s consider the following
    two class templates first:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示模板模板参数的使用，让我们首先考虑以下两个类模板：
- en: '[PRE293]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: 'The `simple_wrapper` class is a very simple class template that holds a value
    of the type template parameter `T`. On the other hand, `fancy_wrapper` is a more
    complex wrapper implementation that hides the wrapped value and exposes member
    functions for data access. Next, we implement a class template called `wrapping_pair`
    that contains two values of a wrapping type. This can be either `simpler_wrapper`,
    `fancy_wrapper`, or anything else that is similar:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`simple_wrapper` 类是一个非常简单的类模板，它持有类型模板参数 `T` 的值。另一方面，`fancy_wrapper` 是一个更复杂的包装实现，它隐藏了包装的值并公开了数据访问的成员函数。接下来，我们实现一个名为
    `wrapping_pair` 的类模板，它包含两个包装类型的值。这可以是 `simpler_wrapper`、`fancy_wrapper` 或其他类似的东西：'
- en: '[PRE315]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: 'The `wrapping_pair` class template has three parameters. The first two are
    type template parameters, named `T` and `U`. The third parameter is a template
    template parameter, called `W`, that has a default value, which is the `fancy_wrapper`
    type. We can use this class template as shown in the following snippet:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrapping_pair` 类模板有三个参数。前两个是类型模板参数，分别命名为 `T` 和 `U`。第三个参数是模板模板参数，称为 `W`，它有一个默认值，即
    `fancy_wrapper` 类型。我们可以像以下代码片段所示使用这个类模板：'
- en: '[PRE327]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: In this example, `p1` is a `wrapping_pair` object that contains two values,
    an `int` and a `double`, each wrapped in a `fancy_wrapper` object. This is not
    explicitly specified but is the default value of the template template parameter.
    On the other hand, `p2` is also a `wrapping_pair` object, also containing an `int`
    and a `double`, but these are wrapped by a `simple_wrapper` object, which is now
    specified explicitly in the template instantiation.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`p1` 是一个包含两个值（一个 `int` 和一个 `double`，每个都包装在一个 `fancy_wrapper` 对象中）的 `wrapping_pair`
    对象。这不是显式指定的，而是模板模板参数的默认值。另一方面，`p2` 也是一个 `wrapping_pair` 对象，也包含一个 `int` 和一个 `double`，但这些被一个
    `simple_wrapper` 对象包装，现在在模板实例化中显式指定。
- en: In this example, we have seen the use of a default template argument for a template
    parameter. This topic is explored in detail in the next section.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到了模板参数的默认模板参数的使用。这个主题将在下一节中详细探讨。
- en: Default template arguments
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认模板参数
- en: 'Default template arguments are specified similarly to default function arguments,
    in the parameter list after the equal sign. The following rules apply to default
    template arguments:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 默认模板参数的指定方式与默认函数参数类似，在等号后面的参数列表中。以下规则适用于默认模板参数：
- en: They can be used with any kind of template parameters with the exception of
    parameter packs.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以与任何类型的模板参数一起使用，除了参数包。
- en: If a default value is specified for a template parameter of a class template,
    variable template, or type alias, then all subsequent template parameters must
    also have a default value. The exception is the last parameter if it is a template
    parameter pack.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在类模板、变量模板或类型别名中为模板参数指定了一个默认值，那么所有后续的模板参数也必须有一个默认值。例外是最后一个参数，如果它是模板参数包。
- en: If a default value is specified for a template parameter in a function template,
    then subsequent template parameters are not restricted to also have a default
    value.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在函数模板中为模板参数指定了一个默认值，那么后续的模板参数不受限制，也必须有一个默认值。
- en: In a function template, a parameter pack may be followed by more type parameters
    only if they have default arguments or their value can be deduced by the compiler
    from the function arguments.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数模板中，参数包之后可以跟有更多类型参数，前提是它们有默认参数或编译器可以从函数参数中推断出它们的值。
- en: They are not allowed in declarations of friend class templates.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不允许在友元类模板的声明中使用。
- en: They are allowed in the declaration of a friend function template only if the
    declaration is also a definition and there is no other declaration of the function
    in the same translation unit.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们只允许在友元函数模板的声明中使用，如果该声明也是一个定义，并且在同一翻译单元中没有其他函数声明。
- en: They are not allowed in the declaration or definition of an explicit specialization
    of a function template or member function template.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不允许在函数模板或成员函数模板的显式特化的声明或定义中使用。
- en: 'The following snippet shows examples for using default template arguments:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了使用默认模板参数的示例：
- en: '[PRE333]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: 'As mentioned previously, a template parameter with a default argument cannot
    be followed by parameters without a default argument when declaring a class template
    but this restriction does not apply to function templates. This is shown in the
    next snippet:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在声明类模板时，带有默认参数的模板参数不能后面跟着没有默认参数的参数，但这种限制不适用于函数模板。这将在下一个代码片段中展示：
- en: '[PRE337]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: 'A template may have multiple declarations (but only one definition). The default
    template arguments from all the declarations and the definition are merged (the
    same way they are merged for default function arguments). Let''s look at an example
    to understand how it works:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模板可以有多个声明（但只有一个定义）。所有声明和定义中的默认模板参数被合并（与默认函数参数合并的方式相同）。让我们通过一个例子来了解它是如何工作的：
- en: '[PRE341]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: 'This is semantically equivalent to the following definition:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这在语义上等同于以下定义：
- en: '[PRE351]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: 'However, these multiple declarations with different default template arguments
    cannot be provided in any order. The rules mentioned earlier still apply. Therefore,
    a declaration of a class template where the first parameter has a default argument
    and the ensuing parameters do not have one is illegal:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些具有不同默认模板参数的多个声明不能以任何顺序提供。前面提到的规则仍然适用。因此，第一个参数具有默认参数而后续参数没有的类模板声明是不合法的：
- en: '[PRE357]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: 'Another restriction on default template arguments is that the same template
    parameter cannot be given multiple defaults in the same scope. Therefore, the
    next example will produce an error:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 默认模板参数的另一个限制是，在同一个作用域内不能为同一个模板参数指定多个默认值。因此，下一个示例将产生错误：
- en: '[PRE361]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: 'When a default template argument uses names from a class, the member access
    restrictions are checked at the declaration, not at the instantiation of the template:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 当默认模板参数使用类中的名称时，成员访问限制是在声明时检查的，而不是在模板实例化时：
- en: '[PRE366]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: When the `x` variable is defined, the bar class template is instantiated, but
    the `foo::value_type` typedef is protected and therefore cannot be used outside
    of `foo`. The result is a compiler error at the declaration of the `bar` class
    template.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义`x`变量时，bar类模板被实例化，但`foo::value_type`类型别名是受保护的，因此不能在`foo`之外使用。结果是`bar`类模板声明时出现编译错误。
- en: With these mentions, we wrap up the topic of template parameters. The next one
    we will explore in the following section is template instantiation, which is the
    creation of a new definition of a function, class, or variable from a template
    definition and a set of template arguments.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些说明，我们结束了模板参数这一主题。在下一节中，我们将探讨模板实例化，这是从模板定义和一组模板参数创建函数、类或变量新定义的过程。
- en: Understanding template instantiation
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模板实例化
- en: As mentioned before, templates are only blueprints from which the compiler creates
    actual code when it encounters their use. The act of creating a definition for
    a function, a class, or a variable from the template declaration is called **template
    instantiation**. This can be either **explicit**, when you tell the compiler when
    it should generate a definition, or **implicit**, when the compiler generates
    a new definition as needed. We will look at these two forms in detail in the next
    sections.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，模板只是编译器在遇到它们的使用时创建实际代码的蓝图。从模板声明创建函数、类或变量定义的行为称为**模板实例化**。这可以是**显式的**，即当你告诉编译器何时生成定义时，或者**隐式的**，即编译器根据需要生成新的定义。我们将在下一节中详细探讨这两种形式。
- en: Implicit instantiation
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式实例化
- en: 'Implicit instantiation occurs when the compiler generates definitions based
    on the use of templates and when no explicit instantiation is present. Implicitly
    instantiated templates are defined in the same namespace as the template. However,
    the way compilers create definitions from templates may differ. This is something
    we will see in the following example. Let''s consider this code:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器根据模板的使用生成定义，并且没有显式实例化时，会发生隐式实例化。隐式实例化的模板定义在模板所在的同一命名空间中。然而，编译器从模板创建定义的方式可能不同。这将在以下示例中看到。让我们考虑以下代码：
- en: '[PRE378]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: 'Here, we have a class template called `foo` with a member function `f`. In
    `main`, we define a variable of the type `foo<int>` but do not use any of its
    members. Because it encounters this use of `foo`, the compiler implicitly defines
    a specialization of `foo` for the `int` type. If you use [cppinsights.io](http://cppinsights.io),
    which runs in Clang, you will see the following code:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个名为 `foo` 的类模板，它有一个成员函数 `f`。在 `main` 中，我们定义了一个 `foo<int>` 类型的变量，但没有使用它的任何成员。因为编译器遇到了对
    `foo` 的这种使用，它会隐式地为 `int` 类型定义 `foo` 的一个特化。如果你使用在 Clang 上运行的 [cppinsights.io](http://cppinsights.io)，你会看到以下代码：
- en: '[PRE387]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: 'Because the function `f` is not invoked in our code, it is only declared but
    not defined. Should we add a call `f` in `main`, the specialization would change
    as follows:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的代码中没有调用函数 `f`，它只被声明而没有定义。如果我们向 `main` 中添加一个 `f` 调用，特化将如下改变：
- en: '[PRE392]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: 'However, if we add one more function, `g`, with the following implementation
    that contains an error, we will get different behaviors with different compilers:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们添加一个名为 `g` 的额外函数，其实现包含一个错误，我们将根据不同的编译器获得不同的行为：
- en: '[PRE397]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: The body of `g` contains an error (you could also use a `static_assert(false)`
    statement as an alternative). This code compiles without any problem with VC++,
    but fails with Clang and GCC. This is because VC++ ignores the parts of the template
    that are not used, provided that the code is syntactically correct, but the others
    perform semantic validation before proceeding with template instantiation.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '`g` 函数体中存在一个错误（你也可以使用 `static_assert(false)` 语句作为替代）。这段代码在 VC++ 中编译没有任何问题，但在
    Clang 和 GCC 中会失败。这是因为 VC++ 忽略了模板中未使用的部分，只要代码在语法上是正确的，但其他编译器在继续模板实例化之前会进行语义验证。'
- en: 'For function templates, implicit instantiation occurs when the user code refers
    to a function in a context that requires its definition to exist. For class templates,
    implicit instantiation occurs when the user code refers to a template in a context
    when a complete type is required or when the completeness of the type affects
    the code. The typical example of such a context is when an object of such a type
    is constructed. However, this is not the case when declaring pointers to a class
    template. To understand how this works, let''s consider the following example:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数模板，当用户代码在需要其定义存在的上下文中引用一个函数时，会发生隐式实例化。对于类模板，当用户代码在需要完整类型或类型的完整性影响代码的上下文中引用模板时，会发生隐式实例化。此类上下文的典型例子是在构造此类类型的对象时。然而，在声明类模板的指针时并非如此。为了理解它是如何工作的，让我们考虑以下示例：
- en: '[PRE408]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: 'In this snippet, we use the same `foo` class template from the previous examples,
    and we declare several variables: `p` which is a pointer to `foo<int>`, `x` which
    is a `foo<int>`, and `q` which is a pointer to `foo<double>`. The compiler is
    required to instantiate only `foo<int>` at this point because of the declaration
    of `x`. Now, let''s consider some invocations of the member functions `f` and
    `g` as follows:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们使用了之前示例中的相同 `foo` 类模板，并声明了几个变量：`p` 是指向 `foo<int>` 的指针，`x` 是一个 `foo<int>`，`q`
    是指向 `foo<double>` 的指针。由于 `x` 的声明，编译器此时只需要实例化 `foo<int>`。现在，让我们考虑一些成员函数 `f` 和 `g`
    的调用，如下所示：
- en: '[PRE420]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: 'With these changes, the compiler is required to instantiate the following:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这些更改，编译器需要实例化以下内容：
- en: '`foo<int>` when the `x` variable is declared'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当声明 `x` 变量时 `foo<int>`
- en: '`foo<int>::f()` when the `x.f()` call occurs'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发生 `x.f()` 调用时 `foo<int>::f()`
- en: '`foo<double>` and `foo<double>::g()` when the `q->g()` call occurs.'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发生 `q->g()` 调用时 `foo<double>` 和 `foo<double>::g()`
- en: 'On the other hand, the compiler is not required to instantiate `foo<int>` when
    the `p` pointer is declared nor `foo<double>` when the `q` pointer is declared.
    However, the compiler does need to implicitly instantiate a class template specialization
    when it is involved in pointer conversion. This is shown in the following example:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当声明 `p` 指针时，编译器不需要实例化 `foo<int>`，当声明 `q` 指针时，也不需要实例化 `foo<double>`。然而，当类模板特化涉及指针转换时，编译器确实需要隐式实例化。以下示例展示了这一点：
- en: '[PRE428]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: In the function `show`, a conversion between `button<int>*` and `control<int>*`
    takes place. Therefore, at this point, the compiler must instantiate `button<int>`.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `show` 函数中，发生 `button<int>*` 和 `control<int>*` 之间的转换。因此，在这个点上，编译器必须实例化 `button<int>`。
- en: 'When a class template contains static members, those members are not implicitly
    instantiated when the compiler implicitly instantiates the class template but
    only when the compiler needs their definition. On the other hand, every specialization
    of a class template has its own copy of static members as exemplified in the following
    snippet:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类模板包含静态成员时，这些成员在编译器隐式实例化类模板时不会隐式实例化，但只有在编译器需要它们的定义时才会实例化。另一方面，每个类模板的特化都有自己的静态成员副本，如下面的代码片段所示：
- en: '[PRE438]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: The class template `foo` has a static member variable called `data` that is
    initialized after the definition of `foo`. In the `main` function, we declare
    the variable `a` as an object of `foo<int>` and `b` and `c` as objects of `foo<double>`.
    Initially, all of them have the member field `data` initialized with 0\. However,
    the variables `b` and `c` share the same copy of data. Therefore, after the assignment
    `b.data = 42`, `a.data` is still 0, but both `b.data` and `c.data` are `42`.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板 `foo` 有一个名为 `data` 的静态成员变量，它在 `foo` 的定义之后初始化。在 `main` 函数中，我们将变量 `a` 声明为
    `foo<int>` 的对象，而 `b` 和 `c` 则是 `foo<double>` 的对象。最初，它们的所有成员字段 `data` 都初始化为 0。然而，变量
    `b` 和 `c` 共享同一份数据副本。因此，在执行 `b.data = 42` 赋值操作后，`a.data` 仍然是 0，但 `b.data` 和 `c.data`
    都是 `42`。
- en: Having learned how implicit instantiation works, it is time to move forward
    and understand the other form of template instantiation, which is explicit instantiation.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了隐式实例化的工作原理之后，现在是时候继续前进，了解模板实例化的另一种形式，即显式实例化。
- en: Explicit instantiation
  id: totrans-595
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式实例化
- en: 'As a user, you can explicitly tell the compiler to instantiate a class template
    or a function template. This is called explicit instantiation and it has two forms:
    **explicit instantiation definition** and **explicit instantiation declaration**.
    We will discuss them in this order.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 作为用户，你可以明确告诉编译器实例化一个类模板或函数模板。这被称为显式实例化，并且有两种形式：**显式实例化定义**和**显式实例化声明**。我们将按此顺序讨论它们。
- en: Explicit instantiation definition
  id: totrans-597
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显式实例化定义
- en: 'An explicit instantiation definition may appear anywhere in a program but after
    the definition of the template it refers to. The syntax for explicit template
    instantiation definitions takes the following forms:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 显式实例化定义可能出现在程序中的任何位置，但必须在引用的模板定义之后。显式模板实例化定义的语法有以下形式：
- en: 'The syntax for class templates is as follows:'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类模板的语法如下：
- en: '[PRE457]'
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE457]'
- en: 'The syntax for function templates is as follows:'
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数模板的语法如下：
- en: '[PRE458]'
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE458]'
- en: As you can see, in all cases, the explicit instantiation definition is introduced
    with the `template` keyword but not followed by any parameter list. For class
    templates, the `class-key` can be any of the `class`, `struct`, or `union` keywords.
    For both class and function templates, an explicit instantiation definition with
    a given argument list can only appear once in the entire program.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在所有情况下，显式实例化定义都是以 `template` 关键字开始的，但不跟任何参数列表。对于类模板，`class-key` 可以是 `class`、`struct`
    或 `union` 关键字之一。对于类和函数模板，具有给定参数列表的显式实例化定义在整个程序中只能出现一次。
- en: 'We will look at some examples to understand how this works. Here is the first
    example:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一些示例来了解这是如何工作的。以下是第一个示例：
- en: '[PRE459]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: 'In this snippet, `wrapper<T>` is a class template defined in the `ns` namespace.
    The statements marked with `[1]` and `[2]` in the code are both representing an
    explicit instantiation definition, for `wrapper<int>` and `wrapper<double>` respectively.
    An explicit instantiation definition can only appear in the same namespace as
    the template it refers to (as in `[1]`) to or it must be fully qualified (as in
    `[2]`). We can write similar explicit template definitions for a function template:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`wrapper<T>`是在`ns`命名空间中定义的类模板。代码中标记为`[1]`和`[2]`的语句都代表显式实例化定义，分别对应`wrapper<int>`和`wrapper<double>`。显式实例化定义只能出现在它所引用的模板所在的同一命名空间中（如`[1]`所示），或者它必须是完全限定的（如`[2]`所示）。我们可以为函数模板编写类似的显式模板定义：
- en: '[PRE470]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: This second example has a striking resemblance to the first. Both `[1]` and
    `[2]` represent explicit template definitions for `add<int>()` and `add<double>()`.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例与第一个示例有惊人的相似之处。`[1]`和`[2]`都代表`add<int>()`和`add<double>()`的显式模板定义。
- en: 'If the explicit instantiation definition is not in the same namespace as the
    template, the name must be fully qualified. The use of a `using` statement does
    not make the name visible in the current namespace. This is shown in the following
    example:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 如果显式实例化定义不在与模板相同的命名空间中，则名称必须完全限定。使用`using`语句不会使名称在当前命名空间中可见。以下示例展示了这一点：
- en: '[PRE481]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: '[PRE486]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: The last line in this example generates a compile error because `wrapper` is
    an unknown name and must be qualified with the namespace name, as in `ns::wrapper`.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例的最后一行中，会生成一个编译错误，因为`wrapper`是一个未知名称，必须用命名空间名称限定，如`ns::wrapper`。
- en: 'When class members are used for return types or parameter types, member access
    specification is ignored in explicit instantiation definitions. An example is
    shown in the following snippet:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 当类成员用作返回类型或参数类型时，在显式实例化定义中会忽略成员访问指定。以下代码片段展示了示例：
- en: '[PRE488]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: Both the class `X<T>::bar` and the function `foo<T>::f()` are private to the
    `foo<T>` class, but they can be used in the explicit instantiation definition
    shown on the last line.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '`X<T>::bar`类和`foo<T>::f()`函数都是`foo<T>`类的私有成员，但它们可以在最后一行显示的显式实例化定义中使用。'
- en: Having seen what explicit instantiation definition is and how it works, the
    question that arises is when is it useful. Why would you tell the compiler to
    generate instantiation from a template? The answer is that it helps distribute
    libraries, reduce build times, and executable sizes. If you are building a library
    that you want to distribute as a `.lib` file and that library uses templates,
    the template definitions that are not instantiated are not put into the library.
    But that leads to increased build times of your user code every time you use the
    library. By forcing instantiations of templates in the library, those definitions
    are put into the object files and the `.lib` file you are distributing. As a result,
    your user code only needs to be linked to those available functions in the library
    file. This is what the Microsoft MSVC CRT libraries do for all the stream, locale,
    and string classes. The `libstdc++` library does the same for string classes and
    others.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了显式实例化定义及其工作原理之后，出现的问题是何时它是有用的。你为什么要告诉编译器从模板中生成实例化？答案是这有助于分发库、减少构建时间和可执行文件大小。如果你正在构建一个你想以`.lib`文件形式分发的库，并且该库使用模板，那么没有实例化的模板定义不会被放入库中。但这会导致每次使用库时用户代码的构建时间增加。通过强制在库中实例化模板，那些定义被放入对象文件和你要分发的`.lib`文件中。因此，你的用户代码只需要链接到库文件中可用的那些函数。这就是Microsoft
    MSVC CRT库为所有流、区域设置和字符串类所做的事情。`libstdc++`库对字符串类和其他类也做了同样的事情。
- en: A problem that can arise with template instantiations is that you can end up
    with multiple definitions, one per translation unit. If the same header that contains
    a template is included in multiple translation units (`.cpp` files) and the same
    template instantiation is used (let's say `wrapper<int>` from our previous examples),
    then identical copies of these instantiations are put in each translation unit.
    This leads to increased object sizes. The problem can be solved with the help
    of explicit instantiation declarations, which we will look at next.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 模板实例化可能引发的问题是你可能会得到多个定义，每个翻译单元一个。如果包含模板的相同头文件被包含在多个翻译单元（`.cpp`文件）中，并且使用了相同的模板实例化（例如，从我们之前的示例中的`wrapper<int>`），那么这些实例化的相同副本将被放入每个翻译单元中。这会导致对象大小增加。可以通过显式实例化声明来解决此问题，我们将在下一节中探讨。
- en: Explicit instantiation declaration
  id: totrans-652
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显式实例化声明
- en: 'An explicit instantiation declaration (available with C++11) is the way you
    can tell the compiler that the definition of a template instantiation is found
    in a different translation unit and that a new definition should not be generated.
    The syntax is the same as for explicit instantiation definitions except that the
    keyword `extern` is used in front of the declaration:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 显式实例化声明（自 C++11 起可用）是你可以告诉编译器模板实例化的定义位于不同的翻译单元中，并且不应生成新定义的方法。其语法与显式实例化定义相同，只是在声明前使用了
    `extern` 关键字：
- en: 'The syntax for class templates is as follows:'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类模板的语法如下：
- en: '[PRE498]'
  id: totrans-655
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE498]'
- en: 'The syntax for function templates is as follows:'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数模板的语法如下：
- en: '[PRE499]'
  id: totrans-657
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE499]'
- en: If you provide an explicit instantiation declaration but no instantiation definition
    exists in any translation unit of the program, then the result is a compiler warning
    and a linker error. The technique is to declare an explicit template instantiation
    in one source file and explicit template declarations in the remaining ones. This
    will reduce both compilation times and object file sizes.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提供了一个显式的实例化声明，但在程序的任何翻译单元中都没有实例化定义，那么结果将是编译器警告和链接错误。技术是在一个源文件中声明显式的模板实例化，在剩余的源文件中声明显式的模板声明。这将减少编译时间和目标文件大小。
- en: 'Let''s look at the following example:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE500]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '[PRE508]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[PRE512]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[PRE513]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[PRE514]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[PRE515]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[PRE517]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: '[PRE518]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '[PRE519]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[PRE520]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '[PRE521]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: '[PRE523]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: '[PRE524]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: '[PRE525]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: '[PRE526]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: '[PRE527]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: '[PRE528]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '[PRE529]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: 'In this example, we can see the following:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们可以看到以下内容：
- en: The `wrapper.h` header contains a class template called `wrapper<T>`. On the
    line marked with `[1]` there is an explicit instantiation declaration for `wrapper<int>`
    that tells the compiler not to generate definitions for this instantiation when
    a source file (translation unit) including this header is compiled.
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wrapper.h` 头文件包含一个名为 `wrapper<T>` 的类模板。在标记为 `[1]` 的行中有一个对 `wrapper<int>` 的显式实例化声明，告诉编译器在编译包含此头文件的源文件（翻译单元）时不要为这个实例化生成定义。'
- en: The `source1.cpp` file includes `wrapper.h` and on the line marked with `[2]`
    contains an explicit instantiation definition for `wrapper<int>`. This is the
    only definition for this instantiation within the entire program.
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source1.cpp` 文件包含了 `wrapper.h`，在标记为 `[2]` 的行中包含了对 `wrapper<int>` 的显式实例化定义。这是整个程序中这个实例化的唯一定义。'
- en: The source files `source2.cpp` and `main.cpp` are both using `wrapper<int>`
    but without any explicit instantiation definition or declaration. That is because
    the explicit declaration from `wrapper.h` is visible when the header is included
    in each of these files.
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源文件 `source2.cpp` 和 `main.cpp` 都使用了 `wrapper<int>`，但没有任何显式实例化定义或声明。这是因为当头文件包含在每个这些文件中时，`wrapper.h`
    中的显式声明是可见的。
- en: Alternatively, the explicit instantiation declaration could be taken away from
    the header file but then it must be added to each source file that includes the
    header and that is likely to be forgotten.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以将显式实例化声明从头文件中移除，但然后它必须添加到包含该头文件的每个源文件中，这很可能会被遗忘。
- en: When you do explicit template declarations, keep in mind that a class member
    function that is defined within the body of the class is always considered inline
    and therefore it will always be instantiated. Therefore, you can only use the
    `extern` keyword for member functions that are defined outside of the class body.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行显式模板声明时，请记住，定义在类体内部的类成员函数始终被认为是内联的，因此它总是会实例化。因此，你只能使用 `extern` 关键字来定义类体之外的成员函数。
- en: Now that we have looked at what template instantiation is, we will continue
    with another important topic, **template specialization**, which is the term used
    for the definition created from a template instantiation to handle a specific
    set of template arguments.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了模板实例化是什么，我们将继续讨论另一个重要主题，**模板特化**，这是从模板实例化中创建的定义，用于处理特定的模板参数集。
- en: Understanding template specialization
  id: totrans-697
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模板特化
- en: A **template specialization** is the definition created from a template instantiation.
    The template that is being specialized is called the **primary template**. You
    can provide an explicit specialized definition for a given set of template arguments,
    therefore overwriting the implicit code the compiler would generate instead. This
    is the technique that powers features such as type traits and conditional compilation,
    which are metaprogramming concepts we will explore in [*Chapter 5*](B18367_05_ePub.xhtml#_idTextAnchor080),
    *Type Traits and Conditional Compilation*.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板特化**是从模板实例化创建的定义。正在特化的模板称为**主模板**。你可以为给定的一组模板参数提供一个显式特化的定义，从而覆盖编译器会生成的隐式代码。这是支持诸如类型特性和条件编译等特性的技术，这些是我们在
    [*第 5 章*](B18367_05_ePub.xhtml#_idTextAnchor080)，*类型特性和条件编译* 中将要探讨的元编程概念。'
- en: 'There are two forms of template specialization: **explicit (full) specialization**
    and **partial specialization**. We will look in detail at these two in the following
    sections.'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 模板特化有两种形式：**显式（完整）特化**和**部分特化**。我们将在以下章节中详细探讨这两个方面。
- en: Explicit specialization
  id: totrans-700
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式特化
- en: 'Explicit specialization (also called full specialization) occurs when you provide
    a definition for a template instantiation with the full set of template arguments.
    The following can be fully specialized:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 显式特化（也称为完整特化）发生在你为具有完整模板参数集的模板实例提供定义时。以下内容可以完全特化：
- en: Function templates
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数模板
- en: Class templates
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类模板
- en: Variable templates (as of C++14)
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量模板（自 C++14 起可用）
- en: Member functions, classes, and enumerations of a class template
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类模板的成员函数、类和枚举
- en: Member function templates and class templates of a class or class template
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类或类模板的成员函数模板和类模板
- en: Static data members of a class template
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类模板的静态数据成员
- en: 'Let''s start by looking at the following example:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下示例开始：
- en: '[PRE530]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: '[PRE531]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '[PRE532]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: '[PRE533]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: '[PRE534]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: '[PRE535]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: '[PRE536]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: '[PRE537]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: '[PRE538]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: '[PRE539]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: '[PRE540]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: '[PRE541]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: '[PRE542]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: '[PRE543]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: '[PRE544]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: '[PRE545]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: '[PRE546]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '[PRE547]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: '[PRE548]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: '[PRE549]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: 'In this code snippet, `is_floating_point` is the primary template. It contains
    a `constexpr` static Boolean data member called `value` that is initialized with
    the `false` value. Then, we have three full specializations of this primary template,
    for the `float`, `double`, and `long double` types. These new definitions change
    the way `value` is being initialized using `true` instead of `false`. As a result,
    we can use this template to write code as follows:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，`is_floating_point` 是主模板。它包含一个名为 `value` 的 `constexpr` 静态布尔数据成员，其初始值为
    `false`。然后，我们有三个针对 `float`、`double` 和 `long double` 类型的完整特化。这些新定义改变了 `value` 使用
    `true` 而不是 `false` 初始化的方式。因此，我们可以使用此模板编写如下代码：
- en: '[PRE550]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: '[PRE551]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: '[PRE552]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: '[PRE553]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: '[PRE554]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: The first and last lines print `0` (for `false`); the other lines print `1`
    (for `true`). This example is a demonstration of how `type` traits work. In fact,
    the standard library contains a class template called `is_floating_point` in the
    `std` namespace, defined in the `<type_traits>` header. We will learn more about
    this topic in [*Chapter 5*](B18367_05_ePub.xhtml#_idTextAnchor080), *Type Traits
    and Conditional Compilation*.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行和最后一行打印 `0`（对于 `false`）；其他行打印 `1`（对于 `true`）。这个示例演示了 `type` 特性是如何工作的。实际上，标准库在
    `<type_traits>` 头文件中定义了一个名为 `is_floating_point` 的类模板，位于 `std` 命名空间中。我们将在 [*第 5
    章*](B18367_05_ePub.xhtml#_idTextAnchor080)，*类型特性和条件编译* 中了解更多关于这个主题的内容。
- en: 'As you can see in this example, static class members can be fully specialized.
    However, each specialization has its own copy of any static members, which is
    demonstrated with the following example:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在示例中看到的，静态类成员可以被完全特化。然而，每个特化都有自己的静态成员副本，以下示例进行了演示：
- en: '[PRE555]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: '[PRE556]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: '[PRE557]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: '[PRE558]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: '[PRE559]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: '[PRE560]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: '[PRE561]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: '[PRE562]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: '[PRE563]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: '[PRE564]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: Here, `foo<T>` is a class template with a single static member, called `value`.
    This is initialized with `0` for the primary template and with `42` for the `int`
    specialization. After declaring the variables `a`, `b`, and `c`, `a.value` is
    `0` and `b.value` is `0` while `c.value` is `42`. However, after assigning the
    value `100` to `a.value`, `b.value` is also `100`, while `c.value` remains `42`.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`foo<T>` 是一个具有单个静态成员的类模板，该成员称为 `value`。对于主模板，它被初始化为 `0`，而对于 `int` 特化，它被初始化为
    `42`。在声明变量 `a`、`b` 和 `c` 之后，`a.value` 是 `0`，`b.value` 也是 `0`，而 `c.value` 是 `42`。然而，在将值
    `100` 赋给 `a.value` 之后，`b.value` 也变成了 `100`，而 `c.value` 保持为 `42`。
- en: 'Explicit specialization must appear after the primary template declaration.
    It does not require a definition of the primary template to be available prior
    to the explicit specialization. The following code is therefore valid:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 显式特化必须出现在主模板声明之后。它不需要在显式特化之前提供主模板的定义。因此，以下代码是有效的：
- en: '[PRE565]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: '[PRE566]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: '[PRE567]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: '[PRE568]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: '[PRE569]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: '[PRE570]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: '[PRE571]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: '[PRE572]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: '[PRE573]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: '[PRE574]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: '[PRE575]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: '[PRE576]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: 'Template specializations can also be only declared without being defined. Such
    a template specialization can be used like any other incomplete type. You can
    see an example of this here:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 模板特化也可以只声明而不定义。这样的模板特化可以像任何其他不完整类型一样使用。您可以在以下示例中看到这一点：
- en: '[PRE577]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: '[PRE578]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: '[PRE579]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: '[PRE580]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: '[PRE581]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '[PRE582]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: '[PRE583]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: In this example, `foo<T>` is the primary template for which a declaration of
    an explicit specialization for the `int` type exists. This makes it possible to
    use `foo<double>` and `foo<int>*` (declaring pointers to partial types is supported).
    However, at the point of declaring the `c` variable, the complete type `foo<int>`
    is not available, since a definition of the full specialization for `int` is missing.
    This generates a compiler error.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`foo<T>` 是一个主模板，对于它存在一个针对 `int` 类型的显式特化的声明。这使得可以使用 `foo<double>` 和 `foo<int>*`（支持声明指向部分类型的指针）。然而，在声明
    `c` 变量时，完整的类型 `foo<int>` 不可用，因为缺少对 `int` 的完整特化的定义。这会生成编译器错误。
- en: 'When specializing a function template, if the compiler can deduce a template
    argument from the type of the function arguments, then that template argument
    is optional. This is demonstrated by the following example:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 当特化一个函数模板时，如果编译器能够从函数参数的类型中推断出一个模板参数，那么这个模板参数是可选的。以下示例展示了这一点：
- en: '[PRE584]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: '[PRE585]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: '[PRE586]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: '[PRE587]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: '[PRE588]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: '[PRE589]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: '[PRE590]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: '[PRE591]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: '[PRE592]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: '[PRE593]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: '[PRE594]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: '[PRE595]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: The syntax for the full specialization for `int` of the `func` function template
    should be `template<> func<int>(foo<int>)`. However, the compiler is able to deduce
    the actual type that `T` represents from the function argument. Therefore, we
    don't have to specify it when defining the specialization.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '`func` 函数模板的 `int` 完整特化的语法应该是 `template<> func<int>(foo<int>)`。然而，编译器能够从函数参数的类型中推断出
    `T` 实际表示的类型。因此，在定义特化时我们不必指定它。'
- en: 'On the other hand, declarations or definitions of function templates and member
    function templates are not allowed to contain default function arguments. Therefore,
    in the following example, the compiler will issue an error:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，函数模板和成员函数模板的声明或定义不允许包含默认函数参数。因此，在以下示例中，编译器将发出错误：
- en: '[PRE596]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: '[PRE597]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: '[PRE598]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: '[PRE599]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: '[PRE600]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: '[PRE601]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: '[PRE602]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: '[PRE603]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: '[PRE604]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: '[PRE605]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: 'In all these examples, the templates had a single template argument. However,
    in practice, many templates have multiple arguments. Explicit specialization requires
    a definition with the full set of arguments being specified. This is demonstrated
    with the following snippet:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些示例中，模板只有一个模板参数。然而，在实际应用中，许多模板有多个参数。显式特化需要一个包含完整参数集的定义。以下代码片段展示了这一点：
- en: '[PRE606]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: '[PRE607]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: '[PRE608]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: '[PRE609]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: '[PRE610]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: '[PRE611]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: '[PRE612]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: '[PRE613]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: '[PRE614]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: '[PRE615]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: '[PRE616]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: '[PRE617]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: '[PRE618]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: '[PRE619]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: '[PRE620]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: '[PRE621]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: '[PRE622]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: '[PRE623]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: With these covered, we can move forward and look into partial specialization,
    which is basically a generalization of explicit (full) specialization.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些内容的基础上，我们可以继续前进，研究部分特化，它基本上是显式（完整）特化的泛化。
- en: Partial specialization
  id: totrans-815
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分特化
- en: Partial specialization occurs when you specialize a primary template but only
    specify some of the template arguments. This means a partial specialization has
    both a template parameter list (which follows the template keyword) and a template
    argument list (which follows the template name). However, only classes can be
    partially specialized.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对一个主模板进行部分特化，但只指定了一些模板参数时，就会发生部分特化。这意味着部分特化既有模板参数列表（紧随模板关键字之后）和模板参数列表（紧随模板名称之后）。然而，只有类才能进行部分特化。
- en: 'Let''s explore the following example to understand how this works:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来了解它是如何工作的：
- en: '[PRE624]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: '[PRE625]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: '[PRE626]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: '[PRE627]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: '[PRE628]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: '[PRE629]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: '[PRE630]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: '[PRE631]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: '[PRE632]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: '[PRE633]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: '[PRE634]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: '[PRE635]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: '[PRE636]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: '[PRE637]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: '[PRE638]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: '[PRE639]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: '[PRE640]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: '[PRE641]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: '[PRE642]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: '[PRE643]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: '[PRE644]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: '[PRE645]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: '[PRE646]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: '[PRE647]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE647]'
- en: 'We have a primary template called `collection` that has two template arguments
    (a type template argument and a non-type template argument) and we have three
    partial specializations, as follows:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为 `collection` 的主模板，它有两个模板参数（一个类型模板参数和一个非类型模板参数），并且我们有三个部分特化，如下所示：
- en: A specialization for the non-type template argument `S` with the value `10`
  id: totrans-843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非类型模板参数 `S` 的值为 `10` 的特化
- en: A specialization for the `int` type
  id: totrans-844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int` 类型的特化'
- en: A specialization for the pointer type `T*`
  id: totrans-845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针类型 `T*` 的特化
- en: 'These templates can be used as shown in the following snippet:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模板可以按照以下代码片段所示使用：
- en: '[PRE648]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: '[PRE649]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE649]'
- en: '[PRE650]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: '[PRE651]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE651]'
- en: 'As specified in the comments, `a` is instantiated from the primary template,
    `b` from the partial specialization for `int` (`collection<int, S>`), `c` from
    the partial specialization for `10` (`collection<T, 10>`), and `d` from the partial
    specialization for pointers (`collection<T*, S>`). However, some combinations
    are not possible because they are ambiguous and the compiler cannot select which
    template instantiation to use. Here are a couple of examples:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 如注释中所述，`a` 从主模板实例化，`b` 从 `int` 的部分特化（`collection<int, S>`）实例化，`c` 从 `10` 的部分特化（`collection<T,
    10>`）实例化，而 `d` 从指针的部分特化（`collection<T*, S>`）实例化。然而，由于它们是模糊的，编译器无法选择使用哪个模板实例化，因此某些组合是不可能的。以下是一些示例：
- en: '[PRE652]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: '[PRE653]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: '[PRE654]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: '[PRE655]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: In the first case, both `collection<T, 10>` and `collection<int, S>` partial
    specializations match the type `collection<int, 10>`, while in the second case
    it can be either `collection<T, 10>` or `collection<T*, S>`.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，`collection<T, 10>` 和 `collection<int, S>` 的部分特化都与类型 `collection<int,
    10>` 匹配，而在第二种情况下，可以是 `collection<T, 10>` 或 `collection<T*, S>`。
- en: 'When defining specializations of a primary template, you need to keep in mind
    the following:'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义主模板的特化时，你需要记住以下几点：
- en: Parameters in the template parameters list of the partial specialization cannot
    have default values.
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分特化的模板参数列表中的参数不能有默认值。
- en: The template parameters list implies an order of the arguments in the template
    arguments list, which is featured only in a partial specialization. This template
    arguments list of a partial specialization cannot be the same as the one implied
    by the template parameters list.
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板参数列表暗示了模板参数列表中参数的顺序，这仅在部分特化中才有特征。部分特化的模板参数列表不能与模板参数列表暗示的列表相同。
- en: 'In the template argument list, you can only use identifiers for non-type template
    parameters. Expressions are not allowed in this context. This is demonstrated
    with the following example:'
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板参数列表中，你只能使用非类型模板参数的标识符。在此上下文中不允许使用表达式。以下示例展示了这一点：
- en: '[PRE656]'
  id: totrans-861
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE656]'
- en: 'When a class template has partial specializations, the compiler must decide
    what is the best match to generate a definition from. For this purpose, it matches
    the template arguments of the template specialization with the template argument
    list of the primary template and partial specializations. Depending on the result
    of this matching process, the compiler does the following:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类模板有部分特化时，编译器必须决定从哪个特化生成最佳匹配的定义。为此，它将模板特化的模板参数与主模板和部分特化的模板参数列表进行匹配。根据此匹配过程的结果，编译器执行以下操作：
- en: If no match is found, a definition is generated from the primary template.
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有找到匹配项，则从主模板生成一个定义。
- en: If a single partial specialization is found, a definition is generated from
    that specialization.
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到一个单独的部分特化，则从该特化生成一个定义。
- en: If more than a single partial specialization is found, then a definition is
    generated from the most specialized partial specialization but only if it is unique.
    Otherwise, the compiler generates an error (as we have seen previously). A template
    `A` is considered more specialized than a template `B` if it accepts a subset
    of the types that `B` accepts, but not the other way around.
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到多个部分特化，则从最特化的部分特化生成一个定义，但前提是它是唯一的。否则，编译器会生成一个错误（如我们之前所见）。如果模板 `A` 接受的类型是模板
    `B` 接受的子集，但反之则不然，则认为模板 `A` 比模板 `B` 更特化。
- en: However, partial specializations are not found by name lookup and are considered
    only if the primary template is found by name lookup.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，部分特化不是通过名称查找来找到的，只有在通过名称查找找到主模板时才会考虑。
- en: To understand how partial specialization is useful, let's take a look at a real-world
    example.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解部分特化的有用性，让我们看看一个现实世界的例子。
- en: 'In this example, we want to create a function that formats the content of an
    array in a nice way and outputs it to a stream. The content of a formatted array
    should look like *[1,2,3,4,5]*. However, for arrays of `char` elements, the elements
    should not be separated by a comma but instead displayed as a string within square
    brackets, such as *[demo]*. For this purpose, we will consider the use of the
    `std::array` class. The following implementation formats the content of the array
    with delimiters between the elements:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们想要创建一个函数，以优雅的方式格式化数组的内 容并将其输出到流中。格式化后的数组内容应看起来像 `[1,2,3,4,5]`。然而，对于
    `char` 元素数组，元素之间不应用逗号分隔，而应显示为方括号内的字符串，例如 `[demo]`。为此，我们将考虑使用 `std::array` 类。以下实现使用分隔符格式化数组的内容：
- en: '[PRE657]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: '[PRE658]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: '[PRE659]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: '[PRE660]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE660]'
- en: '[PRE661]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: '[PRE662]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE662]'
- en: '[PRE663]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: '[PRE664]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: '[PRE665]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE665]'
- en: '[PRE666]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: '[PRE667]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE667]'
- en: '[PRE668]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: '[PRE669]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE669]'
- en: '[PRE670]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: '[PRE671]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE671]'
- en: '[PRE672]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE672]'
- en: '[PRE673]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE673]'
- en: '[PRE674]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE674]'
- en: '[PRE675]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE675]'
- en: '[PRE676]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE676]'
- en: 'In this snippet, `pretty_print` is a function template with two template parameters,
    matching the template parameters of the `std::array` class. When called with the
    `arr` array as an argument, it prints *[1,1,2,3,5,8,13,21]*. When called with
    the `str` array as an argument, it prints *[t,e,m,p,l,a,t,e]*. However, our intention
    is to print *[template]* in this latter case. For this, we need another implementation,
    which is specialized for the `char` type:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`pretty_print` 是一个有两个模板参数的函数模板，与 `std::array` 类的模板参数相匹配。当用 `arr` 数组作为参数调用时，它打印
    `[1,1,2,3,5,8,13,21]`。当用 `str` 数组作为参数调用时，它打印 `[t,e,m,p,l,a,t,e]`。然而，我们的意图是在后一种情况下打印
    `[template]`。为此，我们需要另一个实现，它专门针对 `char` 类型：
- en: '[PRE677]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE677]'
- en: '[PRE678]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE678]'
- en: '[PRE679]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: '[PRE680]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE680]'
- en: '[PRE681]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE681]'
- en: '[PRE682]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: '[PRE683]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE683]'
- en: '[PRE684]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE684]'
- en: '[PRE685]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE685]'
- en: '[PRE686]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE686]'
- en: '[PRE687]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE687]'
- en: '[PRE688]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: '[PRE689]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE689]'
- en: In this second implementation, `pretty_print` is a function template with a
    single template parameter, which is a non-type template parameter indicating the
    size of the array. The type template parameter is explicitly specified as `char`,
    in `std::array<char, S>`. This time, the call to `pretty_print` with the `str`
    array prints `[template]` to the console.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第二个实现中，`pretty_print` 是一个只有一个模板参数的函数模板，这个模板参数是一个非类型模板参数，表示数组的尺寸。类型模板参数被显式指定为
    `char`，在 `std::array<char, S>` 中。这次，使用 `str` 数组调用 `pretty_print` 将 `[template]`
    打印到控制台。
- en: What is key to understand here is that it's not the `pretty_print` function
    template that is partially specialized but the `std::array` class template. Function
    templates cannot be specialized and what we have here are overloaded functions.
    However, `std::array<char,S>` is a specialization of the primary class template
    `std::array<T, S>`.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关键要理解的是，不是 `pretty_print` 函数模板被部分特化，而是 `std::array` 类模板。函数模板不能被特化，而我们这里有的是重载函数。然而，`std::array<char,S>`
    是 `std::array<T, S>` 主类模板的一个特化。
- en: All the examples we have seen in this chapter were either function templates
    or class templates. However, variables can also be templates and this will be
    the topic of the next section.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们看到的所有示例要么是函数模板，要么是类模板。然而，变量也可以是模板，这将是下一节的主题。
- en: Defining variable templates
  id: totrans-906
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义变量模板
- en: Variable templates were introduced in C++14 and allow us to define variables
    that are templates either at namespace scope, in which case they represent a family
    of global variables, or at class scope, in which case they represent static data
    members.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 变量模板是在 C++14 中引入的，允许我们在命名空间作用域或类作用域中定义模板变量，在这种情况下，它们代表一组全局变量或静态数据成员。
- en: 'A variable template is declared at a namespace scope as shown in the following
    code snippet. This is a typical example that you can find in the literature, but
    we can use it to elaborate on the benefits of variable templates:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 变量模板在命名空间作用域中声明，如下面的代码片段所示。这是一个典型的例子，你可以在文献中找到，但我们可以用它来阐述变量模板的好处：
- en: '[PRE690]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE690]'
- en: '[PRE691]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE691]'
- en: The syntax is similar to declaring a variable (or data member) but combined
    with the syntax for declaring templates.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 语法类似于声明变量（或数据成员），但结合了声明模板的语法。
- en: 'The question that arises is how variable templates are actually helpful. To
    answer this, let''s build up an example to demonstrate the point. Let''s consider
    we want to write a function template that, given the radius of a sphere, returns
    its volume. The volume of a sphere is `4πr^3 / 3`. Therefore, a possible implementation
    is as follows:'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的问题是变量模板实际上是如何有帮助的。为了回答这个问题，让我们构建一个示例来展示这个观点。假设我们想要编写一个函数模板，给定一个球体的半径，返回其体积。球体的体积是
    `4πr^3 / 3`。因此，一个可能的实现如下：
- en: '[PRE692]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE692]'
- en: '[PRE693]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE693]'
- en: '[PRE694]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE694]'
- en: '[PRE695]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE695]'
- en: '[PRE696]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE696]'
- en: '[PRE697]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE697]'
- en: 'In this example, `PI` is defined as a compile-time constant of the `double`
    type. This will generate a compiler warning if we use `float`, for instance, for
    the type template parameter `T`:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`PI`被定义为`double`类型的编译时常量。如果我们使用`float`等类型作为类型模板参数`T`，这将生成编译器警告：
- en: '[PRE698]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE698]'
- en: '[PRE699]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE699]'
- en: 'A potential solution to this problem is to make `PI` a static data member of
    a template class with its type determined by the type template parameter. This
    implementation can look as follows:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的潜在方法是将`PI`作为模板类的静态数据成员，其类型由类型模板参数确定。这种实现可以如下所示：
- en: '[PRE700]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE700]'
- en: '[PRE701]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE701]'
- en: '[PRE702]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE702]'
- en: '[PRE703]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE703]'
- en: '[PRE704]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE704]'
- en: '[PRE705]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE705]'
- en: '[PRE706]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE706]'
- en: '[PRE707]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE707]'
- en: '[PRE708]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE708]'
- en: '[PRE709]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE709]'
- en: '[PRE710]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE710]'
- en: '[PRE711]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE711]'
- en: 'This works, although the use of `PI<T>::value` is not ideal. It would be nicer
    if we could simply write `PI<T>`. This is exactly what the variable template `PI`
    shown at the beginning of the section allows us to do. Here it is again, with
    the complete solution:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 这方法是可行的，尽管使用`PI<T>::value`并不理想。如果能简单地写`PI<T>`会更好。这正是本节开头展示的变量模板`PI`允许我们做到的。下面是完整的解决方案：
- en: '[PRE712]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE712]'
- en: '[PRE713]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE713]'
- en: '[PRE714]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE714]'
- en: '[PRE715]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE715]'
- en: '[PRE716]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE716]'
- en: '[PRE717]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE717]'
- en: '[PRE718]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE718]'
- en: 'The next example shows yet another possible use case and also demonstrates
    the explicit specialization of variable templates:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了另一种可能的用法，并演示了变量模板的显式特化：
- en: '[PRE719]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE719]'
- en: '[PRE720]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE720]'
- en: '[PRE721]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE721]'
- en: '[PRE722]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE722]'
- en: '[PRE723]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE723]'
- en: '[PRE724]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE724]'
- en: '[PRE725]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE725]'
- en: '[PRE726]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE726]'
- en: '[PRE727]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE727]'
- en: '[PRE728]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE728]'
- en: '[PRE729]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE729]'
- en: '[PRE730]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE730]'
- en: '[PRE731]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE731]'
- en: '[PRE732]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE732]'
- en: '[PRE733]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE733]'
- en: '[PRE734]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE734]'
- en: '[PRE735]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE735]'
- en: '[PRE736]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE736]'
- en: '[PRE737]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE737]'
- en: '[PRE738]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE738]'
- en: '[PRE739]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE739]'
- en: '[PRE740]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE740]'
- en: '[PRE741]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE741]'
- en: '[PRE742]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE742]'
- en: In this example, we have a function template called `show_parts` that processes
    an input string after splitting it into parts delimited by a separator. The separator
    is a variable template defined at (global) namespace scope and is explicitly specialized
    for the `wchar_t` type.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个名为`show_parts`的函数模板，它处理一个输入字符串，在分割由分隔符分隔的部分之后。分隔符是一个在（全局）命名空间作用域中定义的变量模板，并显式特化为`wchar_t`类型。
- en: 'As previously mentioned, variable templates can be members of classes. In this
    case, they represent static data members and need to be declared using the `static`
    keyword. The following example demonstrates this:'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，变量模板可以是类的成员。在这种情况下，它们代表静态数据成员，需要使用`static`关键字进行声明。以下示例演示了这一点：
- en: '[PRE743]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE743]'
- en: '[PRE744]'
  id: totrans-971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE744]'
- en: '[PRE745]'
  id: totrans-972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE745]'
- en: '[PRE746]'
  id: totrans-973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE746]'
- en: '[PRE747]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE747]'
- en: '[PRE748]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE748]'
- en: '[PRE749]'
  id: totrans-976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE749]'
- en: '[PRE750]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE750]'
- en: '[PRE751]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE751]'
- en: '[PRE752]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE752]'
- en: 'You can declare a variable template in a class and then provide its definition
    outside the class. Notice that in this case, the variable template must be declared
    with `static const` and not `static constexpr`, since the latter one requires
    in-class initialization:'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在类中声明一个变量模板，然后在其外部提供其定义。请注意，在这种情况下，变量模板必须使用`static const`声明，而不是`static constexpr`，因为后者需要在类内初始化：
- en: '[PRE753]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE753]'
- en: '[PRE754]'
  id: totrans-982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE754]'
- en: '[PRE755]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE755]'
- en: '[PRE756]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE756]'
- en: '[PRE757]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE757]'
- en: '[PRE758]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE758]'
- en: '[PRE759]'
  id: totrans-987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE759]'
- en: 'Variable templates are used to simplify the use of type traits. The *Explicit
    specialization* section contained an example for a type trait called `is_floating_point`.
    Here is, again, the primary template:'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 变量模板用于简化类型特性的使用。*显式特化*部分包含了一个名为`is_floating_point`的类型特性的示例。这里再次是主要模板：
- en: '[PRE760]'
  id: totrans-989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE760]'
- en: '[PRE761]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE761]'
- en: '[PRE762]'
  id: totrans-991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE762]'
- en: '[PRE763]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE763]'
- en: '[PRE764]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE764]'
- en: 'There were several explicit specializations that I will not list here again.
    However, this `type` trait can be used as follows:'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个显式特化，这里不再列出。然而，这个`type`特性可以如下使用：
- en: '[PRE765]'
  id: totrans-995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE765]'
- en: 'The use of `is_floating_point<float>::value` is rather cumbersome, but can
    be avoided with the help of a variable template that can be defined as follows:'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`is_floating_point<float>::value`相当繁琐，但可以通过以下定义的变量模板来避免：
- en: '[PRE766]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE766]'
- en: '[PRE767]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE767]'
- en: '[PRE768]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE768]'
- en: 'This `is_floating_point_v` variable template helps write code that is arguably
    simpler and easier to read. The following snippet is the form I prefer over the
    verbose variant with `::value`:'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`is_floating_point_v`变量模板有助于编写更简单、更易于阅读的代码。以下片段是我更倾向于使用，而不是使用`::value`的冗长变体的形式：
- en: '[PRE769]'
  id: totrans-1001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE769]'
- en: The standard library defines a series of variable templates suffixed with `_v`
    for `::value`, just as in our example (such as `std::is_floating_point_v` or `std::is_same_v`).
    We will discuss this topic in more detail in [*Chapter 5*](B18367_05_ePub.xhtml#_idTextAnchor080),
    *Type Traits and Conditional Compilation*.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库定义了一系列以`_v`后缀结尾的变量模板，用于`::value`，就像我们的例子一样（例如`std::is_floating_point_v`或`std::is_same_v`）。我们将在[*第5章*](B18367_05_ePub.xhtml#_idTextAnchor080)中更详细地讨论这个主题，*类型特性与条件编译*。
- en: Variable templates are instantiated similarly to function templates and class
    templates. This happens either with an explicit instantiation or explicit specialization,
    or implicitly by the compiler. The compiler generates a definition when the variable
    template is used in a context where a variable definition must exist, or the variable
    is needed for constant evaluation of an expression.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 变量模板的实例化方式类似于函数模板和类模板。这可以通过显式实例化或显式特化来实现，或者由编译器隐式地完成。当变量模板在需要存在变量定义的上下文中使用时，或者变量需要用于表达式的常量评估时，编译器会生成一个定义。
- en: After this, we move to the topic of alias templates, which allow us to define
    aliases for class templates.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向别名模板的主题，它允许我们为类模板定义别名。
- en: Defining alias templates
  id: totrans-1005
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义别名模板
- en: 'In C++, an `typedef` declaration or with a `using` declaration (the latter
    was introduced in C++11). Here are several examples using `typedef`:'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，可以使用 `typedef` 声明或 `using` 声明（后者是在 C++11 中引入的）。以下是一些使用 `typedef` 的示例：
- en: '[PRE770]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE770]'
- en: '[PRE771]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE771]'
- en: '[PRE772]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE772]'
- en: '[PRE773]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE773]'
- en: '[PRE774]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE774]'
- en: '[PRE775]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE775]'
- en: '[PRE776]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE776]'
- en: '[PRE777]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE777]'
- en: '[PRE778]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE778]'
- en: In this example, `index_t` is an alias for `int`, `NameValueList` is an alias
    for `std::vector<std::pair<int, std::string>>`, while `fn_ptr` is an alias for
    the type of a pointer to a function that returns an `int` and has two parameters
    of type `int` and `char`. Lastly, `foo::value_type` is an alias for the type template
    `T`.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`index_t` 是 `int` 的别名，`NameValueList` 是 `std::vector<std::pair<int, std::string>>`
    的别名，而 `fn_ptr` 是返回 `int` 并有两个 `int` 和 `char` 类型的参数的函数指针类型的别名。最后，`foo::value_type`
    是类型模板 `T` 的别名。
- en: 'Since C++11, these type aliases can be created with the help of **using declarations**,
    which look as follows:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C++11 以来，这些类型别名可以通过以下形式的 **using 声明** 来创建：
- en: '[PRE779]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE779]'
- en: '[PRE780]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE780]'
- en: '[PRE781]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE781]'
- en: '[PRE782]'
  id: totrans-1021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE782]'
- en: '[PRE783]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE783]'
- en: '[PRE784]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE784]'
- en: '[PRE785]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE785]'
- en: '[PRE786]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE786]'
- en: '[PRE787]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE787]'
- en: Using declarations are now preferred over `typedef` declarations because they
    are simpler to use and are also more natural to read (from left to right). However,
    they have an important advantage over `typedef`s as they allow us to create aliases
    for templates. An **alias template** is a name that refers not to a type but a
    family of types. Remember, a template is not a class, function, or variable but
    a blueprint that allows the creation of a family of types, functions, or variables.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用声明比 `typedef` 声明更受欢迎，因为它们更容易使用，也更易于阅读（从左到右）。然而，它们比 `typedef` 有一个重要的优势，即允许我们为模板创建别名。**别名模板**
    是一个名称，它不仅指向一个类型，而且指向一系列类型。记住，模板不是一个类、函数或变量，而是一个蓝图，它允许创建一系列类型、函数或变量。
- en: 'To understand how alias templates work, let''s consider the following example:'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解别名模板是如何工作的，让我们考虑以下示例：
- en: '[PRE788]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE788]'
- en: '[PRE789]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE789]'
- en: '[PRE790]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE790]'
- en: '[PRE791]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE791]'
- en: '[PRE792]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE792]'
- en: '[PRE793]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE793]'
- en: '[PRE794]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE794]'
- en: '[PRE795]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE795]'
- en: '[PRE796]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE796]'
- en: The declaration on line `[1]` introduces the alias template `customer_addresses_t`.
    It's an alias for a map type where the key type is `int` and the value type is
    `std::vector<T>`. Since `std::vector<T>` is not a type, but a family of types,
    `customer_addresses_t<T>` defines a family of types. The `using` declarations
    at `[2]` and `[3]` introduce two type aliases, `customer_delivery_addresses_t`
    and `customer_invoice_addresses_t`, from the aforementioned family of types.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 `[1]` 行的声明中引入了别名模板 `customer_addresses_t`。它是一个映射类型的别名，其键类型为 `int`，值类型为 `std::vector<T>`。由于
    `std::vector<T>` 不是一个类型，而是一系列类型，因此 `customer_addresses_t<T>` 定义了一系列类型。在第 `[2]`
    和 `[3]` 行的 `using` 声明中，从上述类型系列中引入了两个类型别名，`customer_delivery_addresses_t` 和 `customer_invoice_addresses_t`。
- en: Alias templates can appear at namespace or class scope just like any template
    declaration. On the other hand, they can neither be fully nor partially specialized.
    However, there are ways to overcome this limitation. A solution is to create a
    class template with a type alias member and specialize the class. Then you can
    create an alias template that refers to the type alias member. Let's demonstrate
    this with the help of an example.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 别名模板可以出现在命名空间或类作用域中，就像任何模板声明一样。另一方面，它们既不能完全也不能部分特化。然而，有方法可以克服这种限制。一种解决方案是创建一个具有类型别名成员的类模板并特化该类。然后可以创建一个引用类型别名成员的别名模板。让我们通过以下示例来演示这一点。
- en: 'Although the following is not valid C++ code, it represents the end goal I
    want to achieve, had the specialization of alias templates been possible:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以下代码不是有效的 C++ 代码，但它代表了我想要实现的目标，如果别名模板的特化是可能的：
- en: '[PRE797]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE797]'
- en: '[PRE798]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE798]'
- en: '[PRE799]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE799]'
- en: '[PRE800]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE800]'
- en: 'In this example, `list_t` is an alias template for `std::vector<T>` provided
    the size of the collection is greater than `1`. However, if there is a single
    element, then `list_t` should be an alias for the type template parameter `T`.
    The way this can be actually achieved is shown in the following snippet:'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果集合的大小大于 `1`，则 `list_t` 是 `std::vector<T>` 的别名模板。然而，如果只有一个元素，则 `list_t`
    应该是类型模板参数 `T` 的别名。实际上实现这一点的示例如下：
- en: '[PRE801]'
  id: totrans-1046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE801]'
- en: '[PRE802]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE802]'
- en: '[PRE803]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE803]'
- en: '[PRE804]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE804]'
- en: '[PRE805]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE805]'
- en: '[PRE806]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE806]'
- en: '[PRE807]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE807]'
- en: '[PRE808]'
  id: totrans-1053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE808]'
- en: '[PRE809]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE809]'
- en: '[PRE810]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE810]'
- en: '[PRE811]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE811]'
- en: '[PRE812]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE812]'
- en: 'In this example, `list<T,S>` is a class template that has a member type alias
    called `T`. In the primary template, this is an alias for `std::vector<T>`. In
    the partial specialization `list<T,1>` it''s an alias for `T`. Then, `list_t`
    is defined as an alias template for `list<T, S>::type`. The following asserts
    prove this mechanism works:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`list<T,S>` 是一个具有名为 `T` 的成员类型别名的类模板。在主模板中，这是一个 `std::vector<T>` 的别名。在部分特化
    `list<T,1>` 中，它是 `T` 的别名。然后，`list_t` 被定义为 `list<T, S>::type` 的别名模板。以下断言证明了这一机制是有效的：
- en: '[PRE813]'
  id: totrans-1059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE813]'
- en: '[PRE814]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE814]'
- en: 'Before we end this chapter, there is one more topic that needs to be addressed:
    generic lambdas and their C++20 improvement, lambda templates.'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，还有一个需要解决的问题：泛型lambda及其C++20改进，lambda模板。
- en: Exploring generic lambdas and lambda templates
  id: totrans-1062
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索泛型lambda和lambda模板
- en: 'Lambdas, which are formally called **lambda expressions**, are a simplified
    way to define function objects in the place where they are needed. This typically
    includes predicates or comparison functions passed to algorithms. Although we
    will not discuss lambda expressions in general, let''s take a look at the following
    examples:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式，正式称为**lambda表达式**，是在需要的地方简化定义函数对象的一种方法。这通常包括传递给算法的谓词或比较函数。尽管我们不会一般性地讨论lambda表达式，但让我们看看以下示例：
- en: '[PRE815]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE815]'
- en: '[PRE816]'
  id: totrans-1065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE816]'
- en: '[PRE817]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE817]'
- en: '[PRE818]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE818]'
- en: '[PRE819]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE819]'
- en: '[PRE820]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE820]'
- en: '[PRE821]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE821]'
- en: '[PRE822]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE822]'
- en: 'Lambda expressions are syntactic sugar, a simplified way of defining anonymous
    function objects. When encountering a lambda expression, the compiler generates
    a class with a function-call operator. For the previous example, these could look
    as follows:'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式是语法糖，是一种简化定义匿名函数对象的方法。当遇到lambda表达式时，编译器会生成一个具有函数调用操作符的类。对于前面的例子，它们可能看起来如下：
- en: '[PRE823]'
  id: totrans-1073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE823]'
- en: '[PRE824]'
  id: totrans-1074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE824]'
- en: '[PRE825]'
  id: totrans-1075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE825]'
- en: '[PRE826]'
  id: totrans-1076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE826]'
- en: '[PRE827]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE827]'
- en: '[PRE828]'
  id: totrans-1078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE828]'
- en: '[PRE829]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE829]'
- en: '[PRE830]'
  id: totrans-1080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE830]'
- en: '[PRE831]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE831]'
- en: '[PRE832]'
  id: totrans-1082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE832]'
- en: '[PRE833]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE833]'
- en: '[PRE834]'
  id: totrans-1084
  prefs: []
  type: TYPE_PRE
  zh: '[PRE834]'
- en: '[PRE835]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE835]'
- en: '[PRE836]'
  id: totrans-1086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE836]'
- en: '[PRE837]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE837]'
- en: '[PRE838]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE838]'
- en: '[PRE839]'
  id: totrans-1089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE839]'
- en: '[PRE840]'
  id: totrans-1090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE840]'
- en: The names chosen here are arbitrary and each compiler will generate different
    names. Also, the implementation details may differ and the ones seen here are
    the bare minimum a compiler is supposed to generate. Notice that the difference
    between the first lambda and the second is that the latter contains state that
    it captures by value.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 这里选择的名字是任意的，每个编译器都会生成不同的名字。此外，实现细节可能不同，这里看到的是编译器应该生成的最基本的内容。注意，第一个lambda和第二个lambda之间的区别在于后者包含通过值捕获的状态。
- en: 'Lambda expressions, which were introduced in C++11, have received several updates
    in later versions of the standard. There are notably two, which will be discussed
    in this chapter:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式，在C++11中引入，在标准后来的版本中收到了几个更新。其中有两个特别值得注意，将在本章中讨论：
- en: '`auto` specifier instead of explicitly specifying types. This transforms the
    generated function object into one with a template function-call operator.'
  id: totrans-1093
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`auto`指定符而不是显式指定类型。这会将生成的函数对象转换为一个具有模板函数调用操作符的对象。
- en: '**Template lambdas**, introduced in C++20, allow us to use the template syntax
    to explicitly specify the shape of the templatized function-call operator.'
  id: totrans-1094
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板lambda**，在C++20中引入，允许我们使用模板语法显式指定模板化函数调用操作符的形状。'
- en: 'To understand the difference between these and how generic and template lambdas
    are helpful, let''s explore the following examples:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些之间的区别以及泛型和模板lambda如何有帮助，让我们探索以下示例：
- en: '[PRE841]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE841]'
- en: '[PRE842]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE842]'
- en: '[PRE843]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE843]'
- en: '[PRE844]'
  id: totrans-1099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE844]'
- en: '[PRE845]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE845]'
- en: '[PRE846]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE846]'
- en: '[PRE847]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE847]'
- en: '[PRE848]'
  id: totrans-1103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE848]'
- en: '[PRE849]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE849]'
- en: '[PRE850]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE850]'
- en: '[PRE851]'
  id: totrans-1106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE851]'
- en: '[PRE852]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE852]'
- en: '[PRE853]'
  id: totrans-1108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE853]'
- en: '[PRE854]'
  id: totrans-1109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE854]'
- en: '[PRE855]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE855]'
- en: 'Here, we have three different lambdas: `l1` is a regular lambda, `l2` is a
    generic lambda, as at least one of the parameters is defined with the `auto` specifier,
    and `l3` is a template lambda, defined with the template syntax but without the
    use of the `template` keyword.'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有三个不同的lambda：`l1`是一个常规lambda，`l2`是一个泛型lambda，因为至少有一个参数是用`auto`指定符定义的，而`l3`是一个模板lambda，使用模板语法定义，但没有使用`template`关键字。
- en: 'We can invoke `l1` with an integer; we can also invoke it with a `double`,
    but this time the compiler will produce a warning about the possible loss of data.
    However, trying to invoke it with a string argument will produce a compile error,
    because `std::string` cannot be converted to `int`. On the other hand, `l2` is
    a generic lambda. The compiler proceeds to instantiate specializations of it for
    all the types of the arguments it''s invoked with, in this example `int`, `double`,
    and `std::string`. The following snippet shows how the generated function object
    may look, at least conceptually:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个整数来调用`l1`；我们也可以用`double`来调用它，但这次编译器将产生一个关于可能数据丢失的警告。然而，尝试用字符串参数调用它将产生编译错误，因为`std::string`不能转换为`int`。另一方面，`l2`是一个泛型lambda。编译器将为其调用的所有参数类型实例化它的特化，在这个例子中是`int`、`double`和`std::string`。以下代码片段显示了生成的函数对象可能的样子，至少在概念上是这样：
- en: '[PRE856]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE856]'
- en: '[PRE857]'
  id: totrans-1114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE857]'
- en: '[PRE858]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE858]'
- en: '[PRE859]'
  id: totrans-1116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE859]'
- en: '[PRE860]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE860]'
- en: '[PRE861]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE861]'
- en: '[PRE862]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE862]'
- en: '[PRE863]'
  id: totrans-1120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE863]'
- en: '[PRE864]'
  id: totrans-1121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE864]'
- en: '[PRE865]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE865]'
- en: '[PRE866]'
  id: totrans-1123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE866]'
- en: '[PRE867]'
  id: totrans-1124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE867]'
- en: '[PRE868]'
  id: totrans-1125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE868]'
- en: '[PRE869]'
  id: totrans-1126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE869]'
- en: '[PRE870]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE870]'
- en: '[PRE871]'
  id: totrans-1128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE871]'
- en: '[PRE872]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE872]'
- en: '[PRE873]'
  id: totrans-1130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE873]'
- en: '[PRE874]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE874]'
- en: '[PRE875]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE875]'
- en: '[PRE876]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE876]'
- en: '[PRE877]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE877]'
- en: '[PRE878]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE878]'
- en: 'You can see here the primary template for the function-call operator, as well
    as the three specializations that we mentioned. Not surprisingly, the compiler
    will generate the same code for the third lambda expression, `l3`, which is a
    template lambda, only available in C++20\. The question that arises from this
    is how are generic lambdas and lambda templates different? To answer this question,
    let''s modify the previous example a bit:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到函数调用操作符的主要模板，以及我们提到的三个特殊化。不出所料，编译器将为第三个lambda表达式`l3`生成相同的代码，这是一个仅在C++20中可用的模板lambda。由此产生的问题是泛型lambda和lambda模板有何不同？为了回答这个问题，让我们稍微修改一下之前的例子：
- en: '[PRE879]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE879]'
- en: '[PRE880]'
  id: totrans-1138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE880]'
- en: '[PRE881]'
  id: totrans-1139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE881]'
- en: '[PRE882]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE882]'
- en: '[PRE883]'
  id: totrans-1141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE883]'
- en: '[PRE884]'
  id: totrans-1142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE884]'
- en: '[PRE885]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE885]'
- en: '[PRE886]'
  id: totrans-1144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE886]'
- en: '[PRE887]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE887]'
- en: '[PRE888]'
  id: totrans-1146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE888]'
- en: '[PRE889]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE889]'
- en: '[PRE890]'
  id: totrans-1148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE890]'
- en: '[PRE891]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE891]'
- en: '[PRE892]'
  id: totrans-1150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE892]'
- en: '[PRE893]'
  id: totrans-1151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE893]'
- en: 'The new lambda expressions take two parameters. Again, we can call `l1` with
    two integers or an `int` and a `double` (although this again generates a warning)
    but we can''t call it with a string and `char`. However, we can do all these with
    the generic lambda `l2` and the lambda template `l3`. The code the compiler generates
    is identical for `l2` and `l3` and looks, semantically, as follows:'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 新的lambda表达式接受两个参数。再次，我们可以用两个整数或一个`int`和一个`double`调用`l1`（尽管这又会产生警告），但我们不能用字符串和`char`调用它。然而，我们可以使用泛型lambda
    `l2`和lambda模板 `l3`做所有这些。编译器生成的代码对于`l2`和`l3`是相同的，从语义上看如下所示：
- en: '[PRE894]'
  id: totrans-1153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE894]'
- en: '[PRE895]'
  id: totrans-1154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE895]'
- en: '[PRE896]'
  id: totrans-1155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE896]'
- en: '[PRE897]'
  id: totrans-1156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE897]'
- en: '[PRE898]'
  id: totrans-1157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE898]'
- en: '[PRE899]'
  id: totrans-1158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE899]'
- en: '[PRE900]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE900]'
- en: '[PRE901]'
  id: totrans-1160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE901]'
- en: '[PRE902]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE902]'
- en: '[PRE903]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE903]'
- en: '[PRE904]'
  id: totrans-1163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE904]'
- en: '[PRE905]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE905]'
- en: '[PRE906]'
  id: totrans-1165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE906]'
- en: '[PRE907]'
  id: totrans-1166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE907]'
- en: '[PRE908]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE908]'
- en: '[PRE909]'
  id: totrans-1168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE909]'
- en: '[PRE910]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE910]'
- en: '[PRE911]'
  id: totrans-1170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE911]'
- en: '[PRE912]'
  id: totrans-1171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE912]'
- en: '[PRE913]'
  id: totrans-1172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE913]'
- en: '[PRE914]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE914]'
- en: '[PRE915]'
  id: totrans-1174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE915]'
- en: '[PRE916]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE916]'
- en: '[PRE917]'
  id: totrans-1176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE917]'
- en: '[PRE918]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE918]'
- en: '[PRE919]'
  id: totrans-1178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE919]'
- en: '[PRE920]'
  id: totrans-1179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE920]'
- en: '[PRE921]'
  id: totrans-1180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE921]'
- en: '[PRE922]'
  id: totrans-1181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE922]'
- en: '[PRE923]'
  id: totrans-1182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE923]'
- en: 'We see, in this snippet, the primary template for the function-call operator,
    and several full explicit specializations: for two `int` values, for a `double`
    and an `int`, for a string and a `char`, and for two string objects. But what
    if we want to restrict the use of the generic lambda `l2` to arguments of the
    same type? This is not possible. The compiler cannot deduce our intention and,
    therefore, it would generate a different type template parameter for each occurrence
    of the `auto` specifier in the parameter list. However, the lambda templates from
    C++20 do allow us to specify the form of the function-call operator. Take a look
    at the following example:'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们看到函数调用操作符的主要模板，以及几个完整的显式特殊化：对于两个`int`值，对于`double`和`int`，对于字符串和`char`，以及对于两个字符串对象。但如果我们想限制泛型lambda
    `l2`的使用，使其仅限于相同类型的参数呢？这是不可能的。编译器无法推断我们的意图，因此，它将为参数列表中每个`auto`指定符的出现生成不同的类型模板参数。然而，C++20中的lambda模板确实允许我们指定函数调用操作符的形式。看看下面的例子：
- en: '[PRE924]'
  id: totrans-1184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE924]'
- en: '[PRE925]'
  id: totrans-1185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE925]'
- en: '[PRE926]'
  id: totrans-1186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE926]'
- en: '[PRE927]'
  id: totrans-1187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE927]'
- en: '[PRE928]'
  id: totrans-1188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE928]'
- en: '[PRE929]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE929]'
- en: '[PRE930]'
  id: totrans-1190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE930]'
- en: Invoking the lambda template with any two arguments of different types, even
    if they are implicitly convertible such as from `int` to `double`, is not possible.
    The compiler will generate an error. It's not possible to explicitly provide the
    template arguments when invoking the template lambda, such as in `l5<double>(42,
    1.0)`. This also generates a compiler error.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何两种不同类型的两个参数调用lambda模板是不可能的，即使它们可以隐式转换，例如从`int`到`double`。编译器将生成一个错误。在调用模板lambda时，无法显式提供模板参数，例如在`l5<double>(42,
    1.0)`中。这也会生成编译器错误。
- en: 'The `decltype` type specifier allows us to tell the compiler to deduce the
    type from an expression. This topic is covered in detail in [*Chapter 4*](B18367_04_ePub.xhtml#_idTextAnchor064),
    *Advanced Template Concepts*. However, in C++14, we can use this in a generic
    lambda to declare the second parameter in the previous generic lambda expression
    to have the same type as the first parameter. More precisely, this would look
    as follows:'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: '`decltype`类型指定符允许我们告诉编译器从表达式推导类型。这个主题在[*第4章*](B18367_04_ePub.xhtml#_idTextAnchor064)，*高级模板概念*中详细讨论。然而，在C++14中，我们可以在泛型lambda中使用它来声明上一个泛型lambda表达式中第二个参数的类型与第一个参数相同。更确切地说，这看起来如下所示：'
- en: '[PRE931]'
  id: totrans-1193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE931]'
- en: 'However, this implies that the type of the second parameter, `b`, must be convertible
    to the type of the first parameter, `a`. This allows us to write the following
    calls:'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这暗示了第二个参数`b`的类型必须可以转换为第一个参数`a`的类型。这允许我们编写以下调用：
- en: '[PRE932]'
  id: totrans-1195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE932]'
- en: '[PRE933]'
  id: totrans-1196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE933]'
- en: '[PRE934]'
  id: totrans-1197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE934]'
- en: The first call is compiled without any problems because `int` is implicitly
    convertible to `double`. The second call compiles with a warning, because converting
    from `double` to `int` may incur a loss of data. The third call, however, generates
    an error, because `char` cannot be implicitly convertible to `std::string`. Although
    the `l4` lambda is an improvement over the generic lambda `l2` seen previously,
    it still does not help restrict calls completely if the arguments are of different
    types. This is only possible with lambda templates as shown earlier.
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用编译没有任何问题，因为`int`可以隐式转换为`double`。第二次调用编译时会有警告，因为从`double`转换为`int`可能会丢失数据。然而，第三次调用会生成错误，因为`char`不能隐式转换为`std::string`。尽管`l4`
    lambda比之前看到的泛型lambda `l2`有所改进，但它仍然不能完全限制不同类型参数的调用。这只有通过前面展示的lambda模板才能实现。
- en: 'Another example of a lambda template is shown in the next snippet. This lambda
    has a single argument, a `std::array`. However, the type of the elements of the
    array and the size of the array are specified as template parameters of the lambda
    template:'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个片段展示了lambda模板的另一个示例。这个lambda有一个单一参数，一个`std::array`。然而，数组的元素类型和数组的大小被指定为lambda模板的模板参数：
- en: '[PRE935]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE935]'
- en: '[PRE936]'
  id: totrans-1201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE936]'
- en: '[PRE937]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE937]'
- en: '[PRE938]'
  id: totrans-1203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE938]'
- en: '[PRE939]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE939]'
- en: '[PRE940]'
  id: totrans-1205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE940]'
- en: '[PRE941]'
  id: totrans-1206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE941]'
- en: '[PRE942]'
  id: totrans-1207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE942]'
- en: 'Attempting to call this lambda with anything other than an `std::array` object
    produces a compiler error. The compiler-generated function object may look as
    follows:'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用除`std::array`对象以外的任何东西调用这个lambda会产生编译器错误。编译器生成的函数对象可能看起来如下：
- en: '[PRE943]'
  id: totrans-1209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE943]'
- en: '[PRE944]'
  id: totrans-1210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE944]'
- en: '[PRE945]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE945]'
- en: '[PRE946]'
  id: totrans-1212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE946]'
- en: '[PRE947]'
  id: totrans-1213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE947]'
- en: '[PRE948]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE948]'
- en: '[PRE949]'
  id: totrans-1215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE949]'
- en: '[PRE950]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE950]'
- en: '[PRE951]'
  id: totrans-1217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE951]'
- en: '[PRE952]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE952]'
- en: '[PRE953]'
  id: totrans-1219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE953]'
- en: '[PRE954]'
  id: totrans-1220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE954]'
- en: '[PRE955]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE955]'
- en: '[PRE956]'
  id: totrans-1222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE956]'
- en: '[PRE957]'
  id: totrans-1223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE957]'
- en: '[PRE958]'
  id: totrans-1224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE958]'
- en: '[PRE959]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE959]'
- en: 'An interesting benefit of generic lambdas over regular lambdas concerns recursive
    lambdas. Lambdas do not have names; they are anonymous, therefore, you cannot
    recursively call them directly. Instead, you have to define a `std::function`
    object, assign the lambda expression to it, and also capture it by reference in
    the capture list. The following is an example of a recursive lambda that computes
    the factorial of a number:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规lambda相比，泛型lambda的一个有趣的好处是关于递归lambda。Lambda没有名字；它们是无名的，因此你不能直接递归调用它们。相反，你必须定义一个`std::function`对象，将lambda表达式赋值给它，并在捕获列表中通过引用捕获它。以下是一个递归lambda的示例，它计算一个数的阶乘：
- en: '[PRE960]'
  id: totrans-1227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE960]'
- en: '[PRE961]'
  id: totrans-1228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE961]'
- en: '[PRE962]'
  id: totrans-1229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE962]'
- en: '[PRE963]'
  id: totrans-1230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE963]'
- en: '[PRE964]'
  id: totrans-1231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE964]'
- en: '[PRE965]'
  id: totrans-1232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE965]'
- en: 'This can be simplified with the use of generic lambdas. They don''t require
    a `std::function` and its capture. A recursive generic lambda can be implemented
    as follows:'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以使用泛型lambda简化。它们不需要`std::function`及其捕获。一个递归泛型lambda可以如下实现：
- en: '[PRE966]'
  id: totrans-1234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE966]'
- en: '[PRE967]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE967]'
- en: '[PRE968]'
  id: totrans-1236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE968]'
- en: '[PRE969]'
  id: totrans-1237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE969]'
- en: '[PRE970]'
  id: totrans-1238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE970]'
- en: 'If understanding how this works is hard, the compiler-generated code should
    help you figure it out:'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果理解这一点有困难，编译器生成的代码应该能帮助你弄清楚：
- en: '[PRE971]'
  id: totrans-1240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE971]'
- en: '[PRE972]'
  id: totrans-1241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE972]'
- en: '[PRE973]'
  id: totrans-1242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE973]'
- en: '[PRE974]'
  id: totrans-1243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE974]'
- en: '[PRE975]'
  id: totrans-1244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE975]'
- en: '[PRE976]'
  id: totrans-1245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE976]'
- en: '[PRE977]'
  id: totrans-1246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE977]'
- en: '[PRE978]'
  id: totrans-1247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE978]'
- en: '[PRE979]'
  id: totrans-1248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE979]'
- en: '[PRE980]'
  id: totrans-1249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE980]'
- en: '[PRE981]'
  id: totrans-1250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE981]'
- en: '[PRE982]'
  id: totrans-1251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE982]'
- en: '[PRE983]'
  id: totrans-1252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE983]'
- en: '[PRE984]'
  id: totrans-1253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE984]'
- en: '[PRE985]'
  id: totrans-1254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE985]'
- en: '[PRE986]'
  id: totrans-1255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE986]'
- en: '[PRE987]'
  id: totrans-1256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE987]'
- en: A generic lambda is a function object with a template function-call operator.
    The first argument, specified with `auto`, can be anything, including the lambda
    itself. Therefore, the compiler will provide a full explicit specialization of
    the call operator for the type of the generated class.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通用的lambda是一个具有模板函数调用操作符的函数对象。第一个参数，使用`auto`指定，可以是任何东西，包括lambda本身。因此，编译器将为生成的类的类型提供一个完整的显式特化调用操作符。
- en: Lambda expressions help us avoid writing explicit code when we need to pass
    function objects as arguments to other functions. The compiler, instead, generates
    that code for us. Generic lambdas, introduced in C++14, help us avoid writing
    the same lambdas for different types. The lambda templates for C++20 allow us
    to specify the form of the generated call operator with the help of template syntax
    and semantics.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式帮助我们避免在需要将函数对象作为参数传递给其他函数时编写显式代码。相反，编译器为我们生成这些代码。C++14中引入的泛型lambda帮助我们避免为不同类型编写相同的lambda。C++20的lambda模板允许我们使用模板语法和语义指定生成的调用操作符的形式。
- en: Summary
  id: totrans-1259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was a walk through of the core features of C++ templates. We have
    learned how to define class templates, function templates, variable templates,
    and alias templates. Along the way, we looked in detail at template instantiation
    and template specialization after learning about template parameters. We also
    learned about generic lambdas and lambda templates and what benefits they have
    compared to regular lambdas. By completing this chapter, you are now familiar
    with the template fundamentals, which should allow you to understand large parts
    of template code as well as write templates yourself.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是对C++模板核心特性的概述。我们学习了如何定义类模板、函数模板、变量模板和别名模板。在学习模板参数之后，我们详细研究了模板实例化和模板特化。我们还学习了泛型lambda和lambda模板以及它们与常规lambda相比的优势。通过完成本章，你现在熟悉了模板基础知识，这应该允许你理解大量模板代码，并自己编写模板。
- en: In the next chapter, we will look at another important topic, which is templates
    with a variable number of arguments called variadic templates.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨另一个重要主题，即具有可变数量参数的模板，称为变长模板。
- en: Questions
  id: totrans-1262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What category of types can be used for non-type template parameters?
  id: totrans-1263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些类型的类别可以用于非类型模板参数？
- en: Where are default template arguments not allowed?
  id: totrans-1264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认模板参数不允许在哪些地方使用？
- en: What is explicit instantiation declaration and how does it differ syntactically
    from explicit instantiation definition?
  id: totrans-1265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显式实例化声明是什么，它与显式实例化定义在语法上有什么区别？
- en: What is an alias template?
  id: totrans-1266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是别名模板？
- en: What are template lambdas?
  id: totrans-1267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是模板lambda？
- en: Further reading
  id: totrans-1268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'C++ Template: A Quick UpToDate Look(C++11/14/17/20), [http://www.vishalchovatiya.com/c-template-a-quick-uptodate-look/](http://www.vishalchovatiya.com/c-template-a-quick-uptodate-look/)'
  id: totrans-1269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 模板：快速更新查看(C++11/14/17/20)，[http://www.vishalchovatiya.com/c-template-a-quick-uptodate-look/](http://www.vishalchovatiya.com/c-template-a-quick-uptodate-look/)
- en: Templates aliases for C++, [https://www.stroustrup.com/template-aliases.pdf](https://www.stroustrup.com/template-aliases.pdf)
  id: totrans-1270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 的模板别名，[https://www.stroustrup.com/template-aliases.pdf](https://www.stroustrup.com/template-aliases.pdf)
- en: 'Lambdas: From C++11 to C++20, Part 2, [https://www.cppstories.com/2019/03/lambdas-story-part2/](https://www.cppstories.com/2019/03/lambdas-story-part2/)'
  id: totrans-1271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda：从C++11到C++20，第二部分，[https://www.cppstories.com/2019/03/lambdas-story-part2/](https://www.cppstories.com/2019/03/lambdas-story-part2/)
