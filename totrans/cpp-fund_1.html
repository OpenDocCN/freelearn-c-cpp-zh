<html><head></head><body>
		<div class="Content" id="_idContainer010">
			<h1 id="_idParaDest-11"><em class="italics"><a id="_idTextAnchor011"/>Chapter 1</em></h1>
		</div>
		<div class="Content" id="_idContainer011">
			<h1 id="_idParaDest-12"><a id="_idTextAnchor012"/>Getting Started</h1>
		</div>
		<div class="Content" id="_idContainer012">
			<h2>Lesson Objectives</h2>
			<p>By the end of this chapter, you will be able:</p>
			<ul>
				<li class="bullets">Explain the C++ compilation model</li>
				<li class="bullets">Execute the <strong class="inline">main()</strong> function</li>
				<li class="bullets">Illustrate the declaration and definition of variables</li>
				<li class="bullets">Determine built-in arithmetic types, references, and pointers</li>
				<li class="bullets">Explain the scope of a variable</li>
				<li class="bullets">Use control flow statements</li>
				<li class="bullets">Define and utilize arrays</li>
			</ul>
			<p>In this chapter, you will learn about the usage of variables and control flow statements to create more robust programs.</p>
		</div>
		<div class="Content" id="_idContainer022">
			<h2 id="_idParaDest-13"><a id="_idTextAnchor013"/>Introduction</h2>
			<p>C++ has been a major player in the software development industry for more than 30 years, supporting some of the most successful companies in the world.</p>
			<p>In recent years, interest in the language has been growing more than ever, and it is an extremely popular choice for large-scale systems, with many big companies sponsoring its advancement.</p>
			<p>C++ remains a complex language, which puts a lot of power in the hands of the developer. However, this also comes with a lot of opportunities to make mistakes. It is a unique language as it has the ability to enable programmers to write high-level abstractions while retaining full control of hardware, performance, and maintainability.</p>
			<h2 id="_idParaDest-14"><a id="_idTextAnchor014"/>The C++ Compilation Model</h2>
			<p>It is fundamental to know how C++ compilation works to understand how programs are compiled and executed. Compiling C++ source code into machine-readable code consists of the following four processes:</p>
			<ol>
				<li>Preprocessing the source code.</li>
				<li>Compiling the source code.</li>
				<li>Assembling the compiled file.</li>
				<li>Linking the object code file to create an executable file.</li>
			</ol>
			<p>Let's start with a simple C++ program to understand how compilation happens.</p>
			<p>Create a file named <strong class="inline">HelloUniverse.cpp</strong> and save it on the <strong class="bold">Desktop</strong> after copy-pasting the following code:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">int main(){</p>
			<p class="snippet">	// This is a single line comment</p>
			<p class="snippet">	/* This is a multi-line </p>
			<p class="snippet">        comment */</p>
			<p class="snippet">	std::cout &lt;&lt; "Hello Universe" &lt;&lt; std::endl;</p>
			<p class="snippet">	return 0;</p>
			<p class="snippet">} </p>
			<p>Now, using the <strong class="inline">cd</strong> command on the Terminal, navigate to the location where our file is saved and execute the following command if you are on UNIX:</p>
			<p class="snippet">&gt; g++ -o HelloUniverse HelloUniverse.cpp</p>
			<p class="snippet">&gt; ./HelloUniverse</p>
			<p>If you are on a Windows system, a different compiler must be used. The command to compile the code with the Visual Studio compiler is as follows:</p>
			<p class="snippet">&gt; cl /EHsc HelloUniverse.cpp</p>
			<p class="snippet">&gt; HelloUniverse.exe</p>
			<p>This program, once executed, will print <strong class="inline">Hello Universe</strong> on the Terminal.</p>
			<p>Let's demystify the C++ compilation process using the following diagram:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer013">
					<img alt="Figure 1.1: C++ compilation of the HelloUniverse file" src="image/C11557_01_01.jpg"/>
				</div>
			</div>
			<h6>Figure 1.1: C++ compilation of the HelloUniverse file</h6>
			<ol>
				<li value="1">When the C++ preprocessor encounters the <strong class="inline">#include &lt;file&gt;</strong> directive, it replaces it with the content of the file creating an expanded source code file.</li>
				<li>Then, this expanded source code file is compiled into an assembly language for the platform.</li>
				<li>The assembler converts the file that's generated by the compiler into the object code file.</li>
				<li>This object code file is linked together with the object code files for any library functions to produce an executable file.</li>
			</ol>
			<h3 id="_idParaDest-15"><a id="_idTextAnchor015"/>Difference Between Header and Source Files</h3>
			<p>Source files contain the actual implementation code. Source files typically have the extension <strong class="inline">.cpp</strong>, although other extensions such as <strong class="inline">.cc</strong>, <strong class="inline">.ccx</strong>, or <strong class="inline">.c++</strong> are also quite common.</p>
			<p>On the other hand, header files contain code that describes the functionalities that are available. These functionalities can be referred to and used by the executable code in the source files, allowing source files to know what functionality is defined in other source files. The <em class="italics">most</em> common extensions for header files are <strong class="inline">.hpp</strong>, <strong class="inline">.hxx</strong>, and <strong class="inline">.h</strong>.</p>
			<p>To create an executable file from the header and the source files, the compiler starts by preprocessing the directives (preceded by a <strong class="inline">#</strong> sign and generally at the top of the files) that are contained in them. In the preceding <strong class="inline">HelloUniverse</strong> program, the directive would be <strong class="inline">#include</strong>. It is preprocessed by the compiler before actual compilation and replaced with the content of the <strong class="inline">iostream</strong> header, which describes standard functionality for reading and writing from streams.</p>
			<p>The second step is to process each source file and produce an object file that contains the machine code relative to that source file. Finally, the compilers link all the object files into a single executable program.</p>
			<p>We saw that the preprocessor converts the content of the directives into the source files. Headers can also include other headers, which will be expanded, creating a chain of expansions.</p>
			<p>For example, let's assume that the content of the <strong class="inline">logger.hpp</strong> header is as follows:</p>
			<p class="snippet">// implementation of logger</p>
			<p>Let's also assume that the content of the <strong class="inline">calculator.hpp</strong> header is as follows:</p>
			<p class="snippet">#include &lt;logger.hpp&gt;</p>
			<p class="snippet">// implementation of calculator</p>
			<p>In the <strong class="inline">main.cpp</strong> file, we include both directives, as shown in the following code snippet:</p>
			<p class="snippet">#include &lt;logger.hpp&gt;</p>
			<p class="snippet">#include &lt;calculator.hpp&gt;</p>
			<p class="snippet">int main() {</p>
			<p class="snippet">  // use both the logger and the calculator</p>
			<p class="snippet">}</p>
			<p>The result of the expansion will be as follows:</p>
			<p class="snippet">// implementation of logger</p>
			<p class="snippet">// implementation of logger</p>
			<p class="snippet">// implementation of calculator</p>
			<p class="snippet">int main() {</p>
			<p class="snippet">  // use both the logger and the calculator</p>
			<p class="snippet">}</p>
			<p>As we can see, the logger has been added in the resulting file twice:</p>
			<ul>
				<li>It was added the first time because we included <strong class="inline">logger.hpp</strong> in the <strong class="inline">main.cpp</strong> file</li>
				<li>It was added the second time because we included <strong class="inline">calculator.hpp</strong>, which then includes <strong class="inline">logger.hpp</strong></li>
			</ul>
			<p>Included files that are not directly specified in a <strong class="inline">#include</strong> directive in the file we are compiling, but are instead included by some other included file, are called <strong class="bold">transitive included files</strong>.</p>
			<p>Often, including the same header file multiple times creates a problem with multiple definitions, as we will see in <em class="italics">Lesson 2</em>, <em class="italics">Functions</em>, and <em class="italics">the Lesson 03</em>, <em class="italics">Classes.</em></p>
			<p>Including the same file multiple times is very likely because of the transitive included files we explained before, and will often result in a compilation error. In C++, there is a convention to prevent problems that originate from including a header file multiple times: <strong class="bold">include guards</strong>.</p>
			<p>An include guard is a specific pattern of instructing the preprocessor to ignore the content of the header if it has been included before.</p>
			<p>It consists of writing all the header code inside the following structure:</p>
			<p class="snippet">#ifndef &lt;unique_name&gt;</p>
			<p class="snippet">#define &lt;unique_name&gt;</p>
			<p class="snippet">// all the header code should go here</p>
			<p class="snippet">#endif /* &lt;unique_name&gt; */</p>
			<p>Here, <strong class="inline">&lt;unique_name&gt;</strong> is a name unique throughout the C++ project; it typically consists of the header file name, such as <strong class="inline">LOGGER_HPP</strong> for the <strong class="inline">logger.hpp</strong> header.</p>
			<p>The preceding code checks whether a special preprocessor variable, <strong class="inline">&lt;unique_name&gt;</strong>, exists. If it does not exist, it defines it and it proceeds to read the content of the header. If it exists, it will skip all the code until the <strong class="inline">#endif</strong> part.</p>
			<p>Since initially the special variable does not exist, the first time the preprocessor includes a header, it creates the variable and proceeds to read the file. The subsequent times, the variable is already defined, so the preprocessor jumps to the <strong class="inline">#endif</strong> directive, skipping all the content of the header file.</p>
			<p>Compilation is a process that ensures that a program is syntactically correct, but it does not perform any checks regarding its logical correctness. This means that a program that compiles correctly might still produce undesired results:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer014">
					<img alt="Figure 1.2: Compilation and linking processes for an executable file " src="image/C11557_01_02.jpg"/>
				</div>
			</div>
			<h6>Figure 1.2: Compilation and linking processes for an executable file</h6>
			<p>Every C++ program needs to define a starting point, that is, the part of the code the execution should start from. The convention is to have a uniquely named main function in the source code, which will be the first thing to be executed. This function is called by the operating system, so it needs to return a value that indicates the status of the program; for this reason, it is also referred to as the <strong class="inline">exit status code</strong>.</p>
			<p>Let's see how we can compile a program.</p>
			<p>Together with C, C++ is the language with the most supported hardware and platforms. This means that there are many C++ compilers, produced by many different vendors. Each compiler can accept parameters in a different way, and it's important to consult the manual of the compiler you are using when developing in C++ to understand the available options and their meaning.</p>
			<p>We'll now see how to compile a program with two of the most common compilers: the Microsoft Visual Studio compiler and GCC.</p>
			<h3 id="_idParaDest-16"><a id="_idTextAnchor016"/>Compiling a File into an Object File</h3>
			<p>To compile the <strong class="inline">myfile.cpp</strong> file in to an object file named <strong class="inline">myfile.obj</strong>, we can run the following commands:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer015">
					<img alt="Figure 1.3: Compiling the CPP file " src="image/C11557_01_03.jpg"/>
				</div>
			</div>
			<h6>Figure 1.3: Compiling the CPP file</h6>
			<p>When we compile, it is common to include some headers.</p>
			<p>We can include the headers defined in the C++ standard without performing any action, but in case we want to include user-defined headers, we need to tell the compiler in which folders to look up the header files.</p>
			<p>For MSVC, you need to pass the parameter as <strong class="inline">/I path</strong>, where <strong class="inline">path</strong> is the path to the directory to look in for the header.</p>
			<p>For GCC, you need to pass the parameter as <strong class="inline">-I path</strong>, where <strong class="inline">path</strong> has the same meaning as in MSVC.</p>
			<p>If <strong class="inline">myfile.cpp</strong> is including a header in the <strong class="inline">include</strong> directory, we would compile the file with the following commands:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer016">
					<img alt="Figure 1.4: Compiling the CPP file with the include directory " src="image/C11557_01_04.jpg"/>
				</div>
			</div>
			<h6>Figure 1.4: Compiling the CPP file with the include directory</h6>
			<p>We can compile several files in their respective object files, and then link them all together to create the final application.</p>
			<h3 id="_idParaDest-17"><a id="_idTextAnchor017"/>Linking Object Files</h3>
			<p>To link together two object files called <strong class="inline">main.obj</strong> and <strong class="inline">mylib.obj</strong> into an executable, we can run the following commands:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer017">
					<img alt="Figure 1.5: Compiling two object files " src="image/C11557_01_05.jpg"/>
				</div>
			</div>
			<h6>Figure 1.5: Compiling two object files</h6>
			<p>With MSVC, we will create an executable named <strong class="inline">main.exe</strong>, while with <strong class="inline">g++</strong>, the executable will be named <strong class="inline">main</strong>.</p>
			<p>For convenience, MSVC and GCC offer a way to compile several files into an executable, without the need to create an object file for each file, and then link the files together.</p>
			<p>Even in this case, if the files are including any user-defined header, you need to specify the header location with the <strong class="inline">/I</strong> or <strong class="inline">-I</strong> flags.</p>
			<p>To compile the <strong class="inline">main.cpp</strong> and <strong class="inline">mylib.cpp</strong> files together, which uses some headers from the <strong class="inline">include</strong> folder, you can use the following commands:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer018">
					<img alt="Figure 1.6: Compiling files with include folder " src="image/C11557_01_06.jpg"/>
				</div>
			</div>
			<h6>Figure 1.6: Compiling files with include folder </h6>
			<h3 id="_idParaDest-18"><a id="_idTextAnchor018"/>Working with the main Function</h3>
			<p>In the next chapter, we will discuss functions in more depth; for now, we can define the <strong class="inline">main</strong> function, which does nothing, apart from returning a successful status code in the following way:</p>
			<p class="snippet">int main() </p>
			<p class="snippet">{</p>
			<p class="snippet">  return 0;</p>
			<p class="snippet">}</p>
			<p>The first line contains the definition of the function, constituted by the return type <strong class="inline">int</strong>, the name of the <strong class="inline">main</strong> function, and the list of arguments, which in this case is an empty list. Then, we have the body of the function, delimited by curly braces. Finally, the body is composed of a single instruction that will return a successful status code.</p>
			<h4>Note</h4>
			<p class="callout">As opposed to C, in a C++ program, the return statement is optional. The compiler automatically adds <strong class="inline">return 0</strong> if you don't explicitly return a value.</p>
			<p>We will discuss these topics in more detail later; what is important to know is that this is a valid C++ program that can be compiled and executed.</p>
			<h4>Note</h4>
			<p class="callout">Most C compilers can compile C or C++ by determining the language based on the file extension.</p>
			<h3 id="_idParaDest-19"><a id="_idTextAnchor019"/>Exercise 1: Compiling and Executing the main Function</h3>
			<p><a id="_idTextAnchor020"/>In this exercise, we will create a source file named <strong class="inline">main.cpp</strong> containing the code. Compile the file and run the program. We will be using it to explore the C++ environment:</p>
			<ol>
				<li value="1">Using your favorite text editor (Sublime Text, Visual Studio Code, Atom, or Notepad++ if you use Windows), create a new file and name it <strong class="inline">main.cpp</strong>.</li>
				<li>Write the following code in the <strong class="inline">main.cpp</strong> file and save it:<p class="snippet">int main()</p><p class="snippet">{</p><p class="snippet">  return 0;</p><p class="snippet">}</p></li>
				<li>Compile the <strong class="inline">main.cpp</strong> file using the following command:<p class="snippet">//On UNIX:</p><p class="snippet">&gt; g++ main.cpp</p><p class="snippet">//On Windows:</p><p class="snippet">&gt; cl /EHsc main.cpp</p></li>
				<li>The compilation process will produce an executable file, which will be named <strong class="inline">main.exe</strong> on a Windows system and <strong class="inline">main.out</strong> on a UNIX one.</li>
			</ol>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor021"/>Built-in Data Types</h2>
			<p><a id="_idTextAnchor022"/>In most programming languages, data is stored in variables, which are labels that refer to the part of memory defined by the programmer. Each variable has an associated type. The type defines what kind of values the variable can hold.</p>
			<p>The built-in data types of C++ are divided into two categories:</p>
			<ul>
				<li><strong class="bold">Primitive data types</strong>: Can be used directly by the user to declare variables</li>
				<li><strong class="bold">Abstract or user defined data types</strong>: Are defined by the user, for example, to define a class in C++ or a structure</li>
			</ul>
			<h3 id="_idParaDest-21"><a id="_idTextAnchor023"/>Primitive Data Types</h3>
			<p>Primitive data types consist of the following types:</p>
			<ul>
				<li><strong class="bold">Integer</strong>: The <strong class="inline">int</strong> type stores a whole number value ranging from <strong class="inline">-2147483648</strong> to <strong class="inline">2147483647</strong>. This data type usually takes up <strong class="inline">4</strong> bytes of memory space.</li>
				<li><strong class="bold">Character</strong>: The <strong class="inline">char</strong> type stores character data. It is guaranteed to be big enough to represent any UTF-8 single byte code unit; for UTF-16 and UTF-32, <strong class="inline">char16_t</strong> and <strong class="inline">char32_t</strong> are used, respectively. <strong class="inline">char</strong> typically takes 1 byte of memory space.</li>
				<li><strong class="bold">Boolean</strong>: The <strong class="inline">bool</strong> data type is capable of holding one of two values: <strong class="inline">true</strong> or <strong class="inline">false</strong>.</li>
				<li><strong class="bold">Floating-point</strong>: The <strong class="inline">float</strong> type is used for storing single precision floating point values. This data type usually takes up 4 bytes of memory space.</li>
				<li><strong class="bold">Double floating point</strong>: The <strong class="inline">double</strong> type is used for storing double precision floating point values. This data type usually takes up 8 bytes of memory space.</li>
				<li><strong class="bold">Void</strong>: The <strong class="inline">void</strong> type is a valueless data type that is used for functions that do not return a value.</li>
				<li><strong class="bold">Wide character</strong>: The <strong class="inline">wchar_t</strong> type is also used to represent character sets, but allows for greater size. While char supports characters between 8 and 32 bits, a wide character is 2 to 4 bytes long.</li>
			</ul>
			<p>The character types <strong class="inline">char</strong> and <strong class="inline">wchar_t</strong> hold numeric values corresponding to the characters in the machine's character set.</p>
			<h3 id="_idParaDest-22"><a id="_idTextAnchor024"/>Datatype Modifiers</h3>
			<p>The numeric types offered by the C++ programming language fall into three categories:</p>
			<ul>
				<li>Signed</li>
				<li>Unsigned</li>
				<li>Floating point</li>
			</ul>
			<p>The signed and unsigned types come with different sizes, which means each of them can represent a smaller or larger range of values.</p>
			<p>Integer types can be signed or unsigned, where signed types can be used to distinguish between negative or positive numbers, while unsigned can only represent numbers greater than or equal to zero.</p>
			<p>The signed keyword is optional; the programmer only needs to specify it if the type is unsigned. Thus, <strong class="inline">signed int</strong> and <strong class="inline">int</strong> are the same types, but they are different from <strong class="inline">unsigned int</strong>, or just <strong class="inline">unsigned</strong> for brevity. Indeed, if it is not specified, an unsigned type always defaults to <strong class="inline">int</strong>.</p>
			<p>Integers, as previously mentioned, can come in different sizes:</p>
			<ul>
				<li><strong class="inline">int</strong></li>
				<li><strong class="inline">short int</strong></li>
				<li><strong class="inline">long int</strong></li>
				<li><strong class="inline">long long int</strong></li>
			</ul>
			<p>The <strong class="inline">short int</strong> type, or just <strong class="inline">short</strong>, is guaranteed to be at least 16 bits according to the standard. This means it can hold values in the range of <strong class="inline">-32768</strong> to <strong class="inline">32767</strong>. If it was also <strong class="inline">unsigned</strong>, so <strong class="inline">unsigned short int</strong> or just <strong class="inline">unsigned int</strong>, this range would be <strong class="inline">0</strong> to <strong class="inline">65535</strong>.</p>
			<h4>Note</h4>
			<p class="callout">The effective size in memory of types can change based on the platform for which the code is compiled. C++ is present in many platforms, from supercomputers in data centers to small embedded chips in industrial settings. To be able to support all these different types of machines, the standard only sets the minimum requirements on built-in types.</p>
			<h3 id="_idParaDest-23"><a id="_idTextAnchor025"/>Variable Definition</h3>
			<p>A variable is named storage that refers to a location in memory that can be used to hold a value. C++ is a strongly-typed language and it requires every variable to be declared with its type before its first use.</p>
			<p>The type of the variable is used by the compiler to determine the memory that needs to be reserved and the way to interpret its value.</p>
			<p>The following syntax is used to declare a new variable:</p>
			<p class="snippet">type variable_name;</p>
			<p>Variable names in C++ can contain letters from the alphabet, both upper and lower case, digits and underscores (_). While digits are allowed, they cannot be the first character of a variable name. Multiple variables of the same type can all be declared in the same statement by listing their variable names, separated by commas:</p>
			<p class="snippet">type variable_name1, variable_name2, …;</p>
			<p>This is equivalent to the following:</p>
			<p class="snippet">type variable_name1;</p>
			<p class="snippet">type variable_name2;</p>
			<p class="snippet">type ...;</p>
			<p>When declaring a variable, its value is left undetermined until an assignment is performed. It is also possible to declare a variable with a given value; this operation is also referred to as <strong class="keyword">variable initialization</strong>.</p>
			<p>One way – and probably the most common one – to initialize a variable, also referred to as <strong class="keyword">C-like initialization</strong>, uses the following syntax:</p>
			<p class="snippet">type variable_name = value;</p>
			<p>Another solution is constructor initialization, which we will see in detail in <em class="italics">Lesson 3</em>, <em class="italics">Classes</em>. Constructor initialization looks like this:</p>
			<p class="snippet">type variable_name (value);</p>
			<p>Uniform initialization or list initialization introduces brace initialization, which allows for the initialization of variables and objects of different types:</p>
			<p class="snippet">type variable_name {value};</p>
			<h3 id="_idParaDest-24"><a id="_idTextAnchor026"/>Demystifying Variable Initialization</h3>
			<p>When a variable is initialized, the compiler can figure out the type needed to store the value provided, which means that it is not necessary to specify the type of the variable. The compiler is indeed able to deduct the type of the variable, so this feature is also referred to as <strong class="keyword">type deduction</strong>. For this reason, the <strong class="keyword">auto</strong> keyword has been introduced to replace the type name during initialization. The initialization syntax becomes this:</p>
			<p class="snippet">auto vvariable_name = value;</p>
			<p>Another way to avoid directly providing a type is to use the <strong class="inline">decltype</strong> specifier. It is used to deduce a type of a given entity and is written with the following syntax:</p>
			<p class="snippet">type variable_name1;</p>
			<p class="snippet">decltype(variable_name1) variable_name2;</p>
			<p>Here, <strong class="inline">variable_name2</strong> is declared according to the type deducted from <strong class="inline">variable_name1</strong>.</p>
			<h4>Note</h4>
			<p class="callout">Type deduction using the <strong class="inline">auto</strong> and <strong class="inline">decltype</strong> keywords has been introduced by the C++11 standard to simplify and facilitate variable declaration when the type cannot be obtained. But at the same time, their extended use when not really needed can reduce code readability and robustness. We will see this in more detail in <em class="italics">Lesson 4</em>, <em class="italics">Generic Programming and Templates</em>.</p>
			<p>In the following code, we will check a valid statement for variables by creating a new source file named <strong class="inline">main.cpp</strong> and analyzing the code one line at a time. </p>
			<p>Which one of the following is a valid statement?</p>
			<p class="snippet">int foo;</p>
			<p class="snippet">auto foo2;</p>
			<p class="snippet">int bar = 10;</p>
			<p class="snippet">sum = 0;</p>
			<p class="snippet">float price = 5.3 , cost = 10.1;</p>
			<p class="snippet">auto val = 5.6;</p>
			<p class="snippet">auto val = 5.6f;</p>
			<p class="snippet">auto var = val;</p>
			<p class="snippet">int  a = 0, b = {1} , c(0);</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor027"/>Pointers and References</h2>
			<p>In the previous section, variables have been defined as portions of memory that can be accessed by their name. In this way, the programmer does not need to remember the memory location and size that's reserved, but can conveniently refer to the variable name.</p>
			<p>In C++, the way to retrieve the actual memory address of a variable is done by preceding the variable name with an ampersand sign (<strong class="inline">&amp;</strong>), also known as the <strong class="keyword">address-of operator</strong>.</p>
			<p>The syntax to use the concept of the address-of operator is as follows:</p>
			<p class="snippet">&amp;variable_name</p>
			<p>Using this in code will return the physical memory address of the variable.</p>
			<h3 id="_idParaDest-26"><a id="_idTextAnchor028"/>Pointers</h3>
			<p>A data structure that's capable of storing a memory address in C++ is known as a <strong class="keyword">pointer</strong>. A pointer always points to an object of a specific type, and because of that we need to specify the type of the object that's pointed to when declaring the pointer.</p>
			<p>The syntax to declare a pointer is as follows:</p>
			<p class="snippet">type * pointer_name;</p>
			<p>Multiple declarations in the same statement are also possible when it comes to a pointer, but it is important to remember that an asterisk (<strong class="inline">*</strong>) is needed for each pointer declaration. An example of multiple pointer declaration is as follows:</p>
			<p class="snippet">type * pointer_name1, * pointer_name2, *...;</p>
			<p>When the asterisk is specified only for the first declaration, the two variables will have different types. For example, in the following declaration, only the former is a pointer:</p>
			<p class="snippet">type * pointer_name, pointer_name;</p>
			<h4>Note</h4>
			<p class="callout">Independently of the pointed variable type, a pointer will always occupy the same size in memory. This derives from the fact that the memory space needed by the pointer is not related to a value stored by the variable, but to a memory address that is platform-dependent.</p>
			<p>Intuitively, a pointer assignment has the same syntax as any other variable:</p>
			<p class="snippet">pointer_name = &amp;variable_name; </p>
			<p>The previous syntax will copy the memory address of the <strong class="inline">variable_name</strong> variable into the pointer named <strong class="inline">pointer_name</strong>.</p>
			<p>The following code snippet will first initialize <strong class="inline">pointer_name1</strong> with the memory address of <strong class="inline">variable_name</strong>, and then it initializes <strong class="inline">pointer_name2</strong> with the value stored in <strong class="inline">pointer_name</strong><strong class="inline">1</strong>, which is the memory address of <strong class="inline">variable_name</strong>. As a result, <strong class="inline">pointer_name2</strong> will end up pointing to the <strong class="inline">variable_name</strong> variable:</p>
			<p class="snippet">type * pointer_name1 = &amp;variable_name; </p>
			<p class="snippet">type * pointer_name2 = pointer_name1; </p>
			<p>The following implementation is invalid:</p>
			<p class="snippet">type * pointer_name1 = &amp;variable_name; </p>
			<p class="snippet">type * pointer_name2 = &amp;pointer_name1;</p>
			<p>This time, <strong class="inline">pointer_name2</strong> would be initialized with the memory address of <strong class="inline">pointer_name1</strong>, resulting in a pointer that points to another pointer. The way to point a pointer to another pointer is to use the following code:</p>
			<p class="snippet">type ** pointer_name;</p>
			<p>Two asterisks (<strong class="inline">*</strong>) indicate the <strong class="inline">type</strong> that's pointed is now a pointer. In general, the syntax simply requires an asterisk (<strong class="inline">*</strong>) for each level of indirection in the declaration of the pointer.</p>
			<p>To access the actual content at a given memory address, it is possible to use the dereference operator (<strong class="inline">*</strong>), followed by the memory address or a pointer:</p>
			<p class="snippet">type variable_name1 = value;</p>
			<p class="snippet">type * pointer_name = &amp;variable_name1;</p>
			<p class="snippet">type variable_name2 = *pointer_name; </p>
			<p>The value contained by <strong class="inline">variable_name2</strong> is the same as the one contained by <strong class="inline">variable_name1</strong>. The same applies when it comes to assignment:</p>
			<p class="snippet">type variable_name1 = value1;</p>
			<p class="snippet">type * pointer_name = &amp;variable_name1;</p>
			<p class="snippet">*pointer_name = value2;</p>
			<h3 id="_idParaDest-27"><a id="_idTextAnchor029"/>References</h3>
			<p>Unlike a pointer, a reference is just an alias for an object, which is essentially a way to give another name to an existing variable. The way to define a reference is as follows:</p>
			<p class="snippet">type variable_name = value;</p>
			<p class="snippet">type &amp;reference_name = variable_name;</p>
			<p>Let's examine the following example:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">  int first_variable = 10;</p>
			<p class="snippet">  int &amp;ref_name = first_variable;</p>
			<p class="snippet">  std::cout &lt;&lt; "Value of first_variable: " &lt;&lt; first_variable &lt;&lt; std::endl;</p>
			<p class="snippet">  std::cout &lt;&lt; "Value of ref_name: " &lt;&lt; ref_name &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p class="snippet">//Output</p>
			<p class="snippet">Value of first_variable: 10</p>
			<p class="snippet">Value of ref_name: 10</p>
			<p>We can identify three main differences with pointers:</p>
			<ul>
				<li>Once initialized, a reference remains bound to its initial object. So, it is not possible to reassign a reference to another object. Any operations performed on a reference are actually operations on the object that has been referred.</li>
				<li>Since there is not the possibility to rebind a reference, it is necessary to initialize it.</li>
				<li>References are always associated with a variable that's stored in memory, but the variable might not be valid, in which case the reference should not be used. We will see more on this in the <em class="italics">Lesson 6, Object-Oriented Programming</em>.</li>
			</ul>
			<p>It is possible to define multiple references to the same object. Since the reference is not an object, it is not possible to have a reference to another reference.</p>
			<p>In the following code, given that <strong class="inline">a</strong> is an integer, <strong class="inline">b</strong> is a float, and <strong class="inline">p</strong> is a pointer to an integer, verify which of the variable initialization is valid and invalid:</p>
			<p class="snippet">int &amp;c = a;</p>
			<p class="snippet">float &amp;c = &amp;b;</p>
			<p class="snippet">int &amp;c;</p>
			<p class="snippet">int *c;</p>
			<p class="snippet">int *c = p;</p>
			<p class="snippet">int *c = &amp;p;</p>
			<p class="snippet">int *c = a;</p>
			<p class="snippet">int *c = &amp;b;</p>
			<p class="snippet">int *c = *p;</p>
			<h3 id="_idParaDest-28"><a id="_idTextAnchor030"/>The const Qualifier</h3>
			<p>In C++, it is possible to define a variable whose value will not be modified once initialized. The way to inform the compiler of this situation is through the <strong class="inline">const</strong> keyword. The syntax to declare and initialize a <strong class="inline">const</strong> variable is as follows:</p>
			<p class="snippet">const type variable_name = value;</p>
			<p>There are several reasons to enforce immutability in a C++ program, the most important ones being correctness and performance. Ensuring that a variable is constant will prevent the compilation of code that accidentally tries to change that variable, preventing possible bugs. </p>
			<p>The other reason is that informing the compiler about the immutability of the variable allows for optimizing the code and logic behind the implementation of the code.</p>
			<h4>Note</h4>
			<p class="callout">After creating an object, if its state remains unchanged, then this characteristic is known as immutability.</p>
			<p>An example of immutability is as follows:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">  const int imm = 10;</p>
			<p class="snippet">  std::cout &lt;&lt; imm &lt;&lt; std::endl;</p>
			<p class="snippet">  //Output: 10</p>
			<p class="snippet">  int imm_change = 11;</p>
			<p class="snippet">  std::cout &lt;&lt; imm_change &lt;&lt; std::endl;</p>
			<p class="snippet">  //Output: 11</p>
			<p class="snippet">  imm = imm_change;</p>
			<p class="snippet">  std::cout &lt;&lt; imm &lt;&lt; std::endl;</p>
			<p class="snippet">  //Error: We cannot change the value of imm</p>
			<p class="snippet">}</p>
			<p>An object is immutable if its state doesn't change once the object has been created. Consequently, a class is immutable if its instances are immutable. We will learn more about classes in <em class="italics">Lesson 3</em>, <em class="italics">Classes</em>.</p>
			<p>Modern C++ supports another notion of immutability, which is expressed with the <strong class="inline">constexpr</strong> keyword. In particular, it is used when it is necessary for the compiler to evaluate the constant at compile time. Also, every variable declared as <strong class="inline">constexpr</strong> is implicitly <strong class="inline">const</strong>.</p>
			<p>The previous topic introduced pointers and references; it turns out that even those can be declared as <strong class="inline">const</strong>. The following is pretty straightforward to understand, and its syntax is as follows:</p>
			<p class="snippet">const type variable_name;</p>
			<p class="snippet">const type &amp;reference_name = variable_name;</p>
			<p>This syntax shows how we can declare a reference to an object that has a <strong class="inline">const</strong> type; such a reference is colloquially called a <strong class="keyword">const reference</strong>.</p>
			<p>References to <strong class="inline">const</strong> cannot be used to change the object they refer to. Note that it is possible to bind a <strong class="inline">const</strong> reference to a non-<strong class="inline">const</strong> type, which is typically used to express that the object that's been referenced will be used as an immutable one:</p>
			<p class="snippet">type variable_name;</p>
			<p class="snippet">const type &amp;reference_name = variable_name;</p>
			<p>However, the opposite is not allowed. If an object is <strong class="inline">const</strong>, then it can only be referenced by a <strong class="inline">const</strong> reference:</p>
			<p class="snippet">const type variable_name = value;</p>
			<p class="snippet">type &amp;reference_name = variable_name; </p>
			<p class="snippet">// Wrong</p>
			<p>An example of this is as follows:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">  const int const_v = 10;</p>
			<p class="snippet">  int &amp;const_ref = const_v;</p>
			<p class="snippet">  //Error</p>
			<p class="snippet">  std::cout &lt;&lt; const_v &lt;&lt; std::endl;</p>
			<p class="snippet">  //Output: 10</p>
			<p class="snippet">}</p>
			<p>Just like for references, pointers can point to the <strong class="inline">const</strong> object, and the syntax is also similar and intuitive:</p>
			<p class="snippet">const type *pointer_name = &amp;variable_name;</p>
			<p>An example of this is as follows:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">  int v = 10;</p>
			<p class="snippet">  const int *const_v_pointer  = &amp;v;</p>
			<p class="snippet">  std::cout &lt;&lt; v &lt;&lt; std::endl;</p>
			<p class="snippet">  //Output: 10</p>
			<p class="snippet">  std::cout &lt;&lt; const_v_pointer &lt;&lt; std::endl;</p>
			<p class="snippet">  //Output: Memory location of v</p>
			<p class="snippet">}</p>
			<p><strong class="inline">const</strong> object addresses can only be stored in a pointer to <strong class="inline">const</strong>, but the opposite is not true. We could have a pointer to <strong class="inline">const</strong> point to a non-<strong class="inline">const</strong> object and, in this case, like for a reference to <strong class="inline">const</strong>, we are not guaranteed that the object itself will not change, but only that the pointer cannot be used to modify it.</p>
			<p>With pointers, since they are also objects, we have an additional case, which is the <strong class="inline">const</strong> pointer. While for references saying <strong class="inline">const</strong> reference is just a short version of reference to <strong class="inline">const</strong>, this is not the case for the pointer and has a totally different meaning.</p>
			<p>Indeed, a <strong class="inline">const</strong> pointer is a pointer that is itself constant. Here, the pointer does not indicate anything about the pointed object; it might be either <strong class="inline">const</strong> or non-<strong class="inline">const</strong>, but what we cannot change instead is the address pointed to by the pointer once it has been initialized. The syntax is as follows:</p>
			<p class="snippet">type *const pointer_name = &amp;variable_name;</p>
			<p>As you can see, the <strong class="inline">const</strong> keyword is placed after the <strong class="inline">*</strong> symbol. The easiest way to keep this rule in mind is to read from right to left, so <strong class="inline">pointer-name &gt; const &gt; * &gt; type</strong> can be read as follows: <strong class="inline">pointer-name</strong> is a <strong class="inline">const</strong> pointer to an object of type <strong class="inline">type</strong>. An example of this is as follows:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">  int v = 10;</p>
			<p class="snippet">  int *const v_const_pointer = &amp;v;</p>
			<p class="snippet">  std::cout &lt;&lt; v &lt;&lt; std::endl;</p>
			<p class="snippet">  //Output: 10</p>
			<p class="snippet">  std::cout &lt;&lt; v_const_pointer &lt;&lt; std::endl;</p>
			<p class="snippet">  //Output: Memory location of v</p>
			<p class="snippet">}</p>
			<h4>Note</h4>
			<p class="callout">Pointer to const and const to pointer are independent and can be expressed in the same statement:</p>
			<p class="callout"><strong class="inline">const type *const pointer_name = &amp;variable_name;</strong></p>
			<p class="callout">The preceding line indicates that both the pointed object and the pointer are <strong class="inline">const</strong>.</p>
			<h3 id="_idParaDest-29"><a id="_idTextAnchor031"/>The Scope of Variables</h3>
			<p>As we have already seen, variable names refer to a specific entity of a program. The live area of the program where this name has a particular meaning is also called a <strong class="inline">scope</strong> of a name. Scopes in C++ are delimited with curly braces, and this area is also called a <strong class="keyword">block</strong>. An entity that's declared outside of any block has a <strong class="keyword">global scope</strong> and is valid anywhere in the code:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer019">
					<img alt="Figure 1.7: Scope of a variable " src="image/C11557_01_07.jpg"/>
				</div>
			</div>
			<h6>Figure 1.7: Scope of a variable</h6>
			<p>The same name can be declared in two scopes and refers to different entities. Also, a name is visible once it is declared until the end of the block in which it is declared.</p>
			<p>Let's understand the scope of global and local variables with the following example:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">int global_var = 100;</p>
			<p class="snippet">//Global variable initialized</p>
			<p class="snippet">int print(){</p>
			<p class="snippet">  std::cout &lt;&lt; global_var &lt;&lt; std::endl;</p>
			<p class="snippet">  //Output: 100</p>
			<p class="snippet">  std::cout &lt;&lt; local_var &lt;&lt; std::endl;</p>
			<p class="snippet">  //Output: Error: Out of scope</p>
			<p class="snippet">}</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">  int local_var = 10;</p>
			<p class="snippet">  std::cout &lt;&lt; local_var &lt;&lt; std::endl;</p>
			<p class="snippet">  //Output: 10</p>
			<p class="snippet">  std::cout &lt;&lt; global_var &lt;&lt; std::endl;</p>
			<p class="snippet">  //Output: 100</p>
			<p class="snippet">  print();</p>
			<p class="snippet">  //Output:100</p>
			<p class="snippet">  //Output: Error: Out of scope</p>
			<p class="snippet">}</p>
			<p>Scopes can be nested, and we call the containing and contained scope the outer and inner scope, respectively. Names declared in the outer scope can be used in the inner one. Re-declaration of a name that was initially declared in the outer scope is possible. The result will be that the new variable will hide the one that was declared in the outer scope.</p>
			<p>Let's examine the following code:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">int global_var = 1000;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">  int global_var = 100;</p>
			<p class="snippet">  std::cout &lt;&lt; "Global: "&lt;&lt; ::global_var &lt;&lt; std::endl;</p>
			<p class="snippet">  std::cout &lt;&lt; "Local: " &lt;&lt; global_var &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">Global: 1000</p>
			<p class="snippet">Local: 100</p>
			<p>In the next chapter, we will explore how to use local and global variables with functions.</p>
			<p>In the following code, we will find the values of all the variables without executing the program. </p>
			<p>The following program shows how variable initialization works:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">  int a = 10;</p>
			<p class="snippet">  {</p>
			<p class="snippet">    int b = a;</p>
			<p class="snippet">  }</p>
			<p class="snippet">  const int c = 11;</p>
			<p class="snippet">  int d = c;</p>
			<p class="snippet">  c = a;</p>
			<p class="snippet">}</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor032"/>Control Flow Statements</h2>
			<p>In a program, it is rare to provide useful functionality by just executing a linear sequence of operations. Commonly, a program must be able to react in different ways in response to different situations or execute the same operation multiple times in different contexts.</p>
			<p>We will now see the control flow statements C++ offers to the programmer to control the sequence of operations to be executed.</p>
			<h3 id="_idParaDest-31"><a id="_idTextAnchor033"/>Selection Statement – if-else</h3>
			<p>C++ provides conditional execution support, where the <strong class="inline">if</strong> keyword indicates whether or not to execute the following statement or block, depending on the fulfillment of the condition provided:</p>
			<p class="snippet">if (condition) statement</p>
			<p>If the expression named <strong class="inline">condition</strong> evaluates to <strong class="inline">true</strong>, then the statement is executed; otherwise, it will be ignored and the program will continue with the subsequent code.</p>
			<p>The conditionally executed code can be a single statement or an entire block containing multiple ones. These statements needs to be enclosed in braces (<strong class="inline">{}</strong>) to form a block:</p>
			<p class="snippet">if (condition) {</p>
			<p class="snippet">  statement_1;</p>
			<p class="snippet">  statement_2;</p>
			<p class="snippet">  statement_N;</p>
			<p class="snippet">}</p>
			<h4>Note</h4>
			<p class="callout">It is common to forget the brace brackets and write the control statement in the following manner:</p>
			<p class="callout"><strong class="inline">if (condition)</strong></p>
			<p class="callout"><strong class="inline">  statement1</strong></p>
			<p class="callout"><strong class="inline">  statement2</strong></p>
			<p class="callout">In such a case, the compiler will not warn you, and it will execute <strong class="inline">statement1</strong> depending on the condition, but always execute <strong class="inline">statement2</strong>. To avoid such a situation, it can be a good practice to always add the braces.</p>
			<p>It is possible to specify what to execute instead when the condition evaluates to <strong class="inline">false</strong>. This is done through the <strong class="inline">else</strong> keyword, which is followed by a statement or a block.</p>
			<p>The following syntax is used to indicate that <strong class="inline">statement1</strong> should be executed if the <strong class="inline">case</strong> condition evaluates to <strong class="inline">true</strong>, and otherwise <strong class="inline">statement2</strong> is executed:</p>
			<p class="snippet">if (condition) statement1 else statement2</p>
			<p>Finally, we can concatenate on multiple if-else statements to produce a more complex branching logic. Let's examine the following example:</p>
			<p class="snippet">if (condition1) {</p>
			<p class="snippet">  statement1 </p>
			<p class="snippet">} else if (condition2) {</p>
			<p class="snippet">  statement2 </p>
			<p class="snippet">} else {</p>
			<p class="snippet">  statement3</p>
			<p class="snippet">}</p>
			<p>With this generic structure, it is possible to check the unlimited number of conditions and execute only the corresponding statement or the final one contained in the <strong class="inline">else</strong> branch.</p>
			<p>It is important to be aware that once one of the conditions is met, all of the ones that follow are discarded, for example:</p>
			<p class="snippet">if (x &gt; 0) { </p>
			<p class="snippet">  // When x is greater than 0, statement1 is executed.</p>
			<p class="snippet">  // If that is not the case, the control jumps to the else block. </p>
			<p class="snippet">  statement1 </p>
			<p class="snippet">} else if (x &gt; 100) {</p>
			<p class="snippet">  statement2 </p>
			<p class="snippet">}</p>
			<p>The previous code will always execute <strong class="inline">statement1</strong> for any positive <strong class="inline">x</strong>, regardless of whether it is greater than 100 or not.</p>
			<p>An alternative way is to sequence several <strong class="inline">if</strong> keywords, as follows:</p>
			<p class="snippet">if (condition1) </p>
			<p class="snippet">  // If condition1 is true, statement1 is executed</p>
			<p class="snippet">  statement1 </p>
			<p class="snippet">if (condition2) </p>
			<p class="snippet">  // if condition2 is true then statement2 is executed</p>
			<p class="snippet">  statement2</p>
			<p class="snippet">  /* independently whether condition1 and condition2 is true or not, the   statement3 will be executed */</p>
			<p class="snippet">statement3</p>
			<p>Let's demystify the previous logic with the following example:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">  int x = 10;</p>
			<p class="snippet">  if  (x &gt; 0){</p>
			<p class="snippet">    std::cout &lt;&lt; x &lt;&lt; std::endl;</p>
			<p class="snippet">  }</p>
			<p class="snippet">  if (x &gt; 11 ){</p>
			<p class="snippet">    std::cout &lt;&lt; x &lt;&lt; std::endl;</p>
			<p class="snippet">  }</p>
			<p class="snippet">  else{</p>
			<p class="snippet">    std::cout &lt;&lt; x-1 &lt;&lt; std::endl;</p>
			<p class="snippet">  }</p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">10</p>
			<p class="snippet">9</p>
			<p>In this way, all the conditions are evaluated independently and more than one statement can potentially be executed.</p>
			<h4>Note</h4>
			<p class="callout">As the <strong class="inline">else</strong> statement has no condition defined, after evaluating the <strong class="inline">if</strong> statement, the control comes to the <strong class="inline">else</strong> block to execute the statement.</p>
			<h3 id="_idParaDest-32"><a id="_idTextAnchor034"/>Selection Statement – switch</h3>
			<p>Another selection statement, with similarities to the <strong class="inline">if-else</strong> concatenation construction, is the <strong class="inline">switch</strong> statement. It is limited to constant expressions and is mainly used to check for a value among a number of possible expressions:</p>
			<p class="snippet">switch (expression)</p>
			<p class="snippet">{</p>
			<p class="snippet">  case constant1:</p>
			<p class="snippet">    group-of-statements-1;</p>
			<p class="snippet">  break;</p>
			<p class="snippet">  case constant2:</p>
			<p class="snippet">    group-of-statements-2;</p>
			<p class="snippet">  break;</p>
			<p class="snippet">...</p>
			<p class="snippet">  default:</p>
			<p class="snippet">    default-group-of-statements;</p>
			<p class="snippet">  break;</p>
			<p class="snippet">}</p>
			<p>The <strong class="inline">expression</strong> present in the parentheses following the <strong class="inline">switch</strong> keyword is evaluated against multiple cases, searching for the first equality between the expression and the constants. If none of the cases match, the default one (if it exists, since it is optional) is executed.</p>
			<p>It is important to keep in mind that the order of evaluation is sequential, and as soon as one of the constants matches, the corresponding group of statements are executed. The <strong class="inline">break</strong> keyword prevents them from further execution. If the <strong class="inline">break</strong> keyword is not included, all statements following the case, including the ones under different labels, are also executed.</p>
			<p>We will explore the break keyword more in the <em class="italics">Jump statements – break and continue</em> section.</p>
			<h3 id="_idParaDest-33"><a id="_idTextAnchor035"/>Iteration Statement – for loop</h3>
			<p>The <strong class="inline">for</strong> loop is a construct that's used to repeat a statement a certain number of times. The syntax of the <strong class="inline">for</strong> loop is as follows:</p>
			<p class="snippet">for (initialization; condition; increase){</p>
			<p class="snippet">  statement1;</p>
			<p class="snippet">  statement2;</p>
			<p class="snippet">...</p>
			<p class="snippet">  statementN;</p>
			<p class="snippet">}</p>
			<p>The <strong class="inline">for</strong> loop consists of two parts: the <strong class="keyword">header</strong> and the <strong class="keyword">body</strong>. The former controls how many times the latter is repeated. The header is the part enclosed by parentheses and it is formed by <strong class="inline">initialization</strong>, <strong class="inline">condition</strong>, and <strong class="inline">increase</strong> statements. The body can be a single statement or a block of multiple ones.</p>
			<p>The initialization statement is typically (but not necessarily) used to declare a new variable, usually a counter, and to initialize it to a certain value. The initialization statement is executed only once, at the beginning of the loop.</p>
			<p>Secondly, the condition statement is checked. This is similar to the condition that's checked for an <strong class="inline">if</strong> statement. If the condition is <strong class="inline">true</strong>, the body of the loop is executed, otherwise the program continues its execution with the instruction after the body of the <strong class="inline">for</strong> loop.</p>
			<p>After the body executes, the <strong class="inline">increase</strong> statement is executed. This usually changes the counter of the initialization statement. The condition is then checked again and, if <strong class="inline">true</strong>, the steps are repeated. The loop ends when the condition evaluates to <strong class="inline">false</strong>.</p>
			<p>The fields in the header of a <strong class="inline">for</strong> loop are optional and can be left blank, but the <strong class="inline">semicolons</strong> cannot be omitted. When the condition is omitted, it always evaluates to <strong class="inline">true</strong>. For example, the following corresponds to an infinite loop where the statement is executed unconditionally:</p>
			<p class="snippet">for ( ; ; ) statement;</p>
			<p>Another variant of the <strong class="inline">for</strong> loop is called a range-based for loop, the syntax for which is as follows:</p>
			<p class="snippet">for ( declaration : range ) statement;</p>
			<p>A range is a sequence of elements, like arrays, which are explained in the next section. This range-based <strong class="inline">for</strong> loop is used to iterate over all elements of these sequences. The <strong class="keyword">range</strong> is the name of the sequence, and in the <strong class="inline">for</strong> declaration, the name is a temporary variable that's declared for every iteration of the loop. This is used to store the current element. The declaration needs to be the same type as the elements contained in the range.</p>
			<h4>Note</h4>
			<p class="callout">A range-based <strong class="inline">for</strong> loop is a good example where <strong class="inline">type</strong> deduction and the use of the <strong class="inline">auto</strong> keyword for the declaration makes the code more readable and helps the programmer find the right type to use.</p>
			<p>A loop placed inside a loop is known as a <strong class="keyword">nested loop</strong>. Let's look at the following diagram to understand what a nested for loop is:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer020">
					<img alt="Figure 1.8: Nested for loop " src="image/C11557_01_08.jpg"/>
				</div>
			</div>
			<h6>Figure 1.8: Nested for loop</h6>
			<p>Using the following example, let's explore how a nested for loop works and print a reverse half-triangle on the console:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">  for (int x = 0; x &lt; 5; x++){</p>
			<p class="snippet">    for (int y = 5; y &gt; x; y--){</p>
			<p class="snippet">      std::cout &lt;&lt; "*";            </p>
			<p class="snippet">    }</p>
			<p class="snippet">    std::cout &lt;&lt;"\n" ;</p>
			<p class="snippet">  }</p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">*****</p>
			<p class="snippet">****</p>
			<p class="snippet">***</p>
			<p class="snippet">**</p>
			<p class="snippet">*</p>
			<h3 id="_idParaDest-34"><a id="_idTextAnchor036"/>Iteration Statement – while loop</h3>
			<p>Another iteration statement is the <strong class="inline">while</strong> loop. It is simpler than the <strong class="inline">for</strong> loop. The syntax for it is as follows:</p>
			<p class="snippet">while (condition) statement;</p>
			<p>It repeats the statement until the condition is met. When the condition is not <strong class="inline">true</strong> anymore, the loop ends and the program continues its execution right after the loop:</p>
			<h4>Note</h4>
			<p class="callout">A <strong class="inline">while</strong> loop can always be expressed using a <strong class="inline">for</strong> loop.</p>
			<p class="callout">Here is an example: <strong class="inline">for ( ; condition ; ) statement;</strong> </p>
			<h3 id="_idParaDest-35"><a id="_idTextAnchor037"/>Iteration Statement – do-while loop</h3>
			<p>A similar loop is the <strong class="inline">do-while</strong> loop, where the condition is checked after the execution of the statement, instead of before. It uses the following syntax:</p>
			<p class="snippet">do statement while (condition);</p>
			<p>It guarantees at least one execution of the statement, even though the condition never evaluates to <strong class="inline">true</strong>.</p>
			<h3 id="_idParaDest-36"><a id="_idTextAnchor038"/>Jump Statements – break and continue</h3>
			<p>The <strong class="inline">break</strong> keyword is used to end a loop independently, regardless of whether it fulfils its condition. In the following program, when <strong class="inline">condition2</strong> becomes <strong class="inline">true</strong>, the break statement will immediately terminate the <strong class="inline">while</strong> loop:</p>
			<p class="snippet">while (condition1){</p>
			<p class="snippet">    statement1;</p>
			<p class="snippet">    if (condition2)</p>
			<p class="snippet">        break;</p>
			<p class="snippet">}</p>
			<p>Alternatively, the <strong class="inline">continue</strong> statement is used to skip the rest of the body's loop in the current iteration. In the following example, when <strong class="inline">condition2</strong> evaluates to <strong class="inline">true</strong>, <strong class="inline">continue</strong> is called, causing the program to reach the end of the loop, skipping <strong class="inline">statement2</strong> and continuing with the next iteration:</p>
			<p class="snippet">while (condition1){</p>
			<p class="snippet">    statement1;</p>
			<p class="snippet">    if (condition2)</p>
			<p class="snippet">        continue;</p>
			<p class="snippet">    statement2;</p>
			<p class="snippet">}</p>
			<h4>Note</h4>
			<p class="callout">The <strong class="inline">break</strong> and continue statements can be used in both <strong class="inline">for</strong> and <strong class="inline">while</strong> loops.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor039"/>The try-catch block</h2>
			<p>During the execution of a program, an anomaly may occur. We refer to these runtime problems as <strong class="keyword">exceptions</strong>, and they represent the response to an exceptional circumstance that arises outside of the normal functioning of a program. Designing code that's resilient to errors is one of the hardest things a programmer has to deal with.</p>
			<p>Exceptions are generally thrown using the <strong class="inline">throw</strong> keyword when something that cannot be handled is encountered by the program. This is also referred to as <strong class="bold">raising an exception</strong>.</p>
			<p>The <strong class="inline">try</strong> keyword is followed by a block containing statements that might throw one or more exceptions. These exceptions can be caught by one or more <strong class="inline">catch</strong> clauses, which are sequentially listed after the <strong class="inline">try</strong> block. The syntax for this is as follows:</p>
			<p class="snippet">try {</p>
			<p class="snippet">  statement1;</p>
			<p class="snippet">} catch (exception-declaration1) { </p>
			<p class="snippet">  statement2; </p>
			<p class="snippet">} catch (exception-declaration2) { </p>
			<p class="snippet">  statement3; </p>
			<p class="snippet">}</p>
			<p class="snippet">...</p>
			<p>A <strong class="inline">catch</strong> block consists of the <strong class="inline">catch</strong> keyword, the exception declaration, and a block. Based on the exception thrown inside the <strong class="inline">try</strong> block, one <strong class="inline">catch</strong> clause is selected and the corresponding block is executed. Once the <strong class="inline">catch</strong> block has terminated, the program continues its execution with the statement following the last <strong class="inline">catch</strong> clause.</p>
			<p>Let's examine the following example to understand how try-catch conditional statements handle exceptions:</p>
			<p class="snippet">#include &lt;iostream&gt; </p>
			<p class="snippet">int main() </p>
			<p class="snippet">{ </p>
			<p class="snippet">  int x = 10; </p>
			<p class="snippet">  try { </p>
			<p class="snippet">    std::cout &lt;&lt; "Inside try block" &lt;&lt; std::endl;</p>
			<p class="snippet">    if (x &gt; 0) // True</p>
			<p class="snippet">    { </p>
			<p class="snippet">      throw x;// Following statement will be skipped</p>
			<p class="snippet">      std::cout &lt;&lt; "After throw keyword" &lt;&lt; std::endl;</p>
			<p class="snippet">    }</p>
			<p class="snippet">  } </p>
			<p class="snippet">  catch (int x ) { </p>
			<p class="snippet">    std::cout &lt;&lt; "Inside catch block: Exception found" &lt;&lt; std::endl;</p>
			<p class="snippet">  } </p>
			<p class="snippet">  std::cout &lt;&lt; "Outside try-catch block" &lt;&lt; std::endl; </p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">Inside try block</p>
			<p class="snippet">Inside catch block: Exception found</p>
			<p class="snippet">Outside try-catch block</p>
			<h3 id="_idParaDest-38"><a id="_idTextAnchor040"/>Exercise 2: Counting the Number of Times a Specific Number Appears in a Given List</h3>
			<p>In this exercise, we will discuss using the <strong class="inline">if</strong> statement and a <strong class="inline">for</strong> loop to count our magic number. Here, we will be trying to find all numbers that are divisible by 3, ranging from 1 to 30. </p>
			<h4>Hint</h4>
			<p class="callout">To find out if a number is divisible by another, use the modulo (%) operator.</p>
			<p>Now, let's perform the following steps:</p>
			<ol>
				<li value="1">Import all the required header files:<p class="snippet">#include &lt;iostream&gt;</p></li>
				<li>We need to store the number of times a number is divisible by 3 in a counter. For this reason, we define and initialize the <strong class="inline">count</strong> variable to <strong class="inline">0</strong>:<p class="snippet">unsigned count = 0;</p></li>
				<li>Now, we will use a <strong class="inline">for</strong> loop that produces values from 1 to 30 so that we can check whether they are divisible by 3 or not:<p class="snippet">for(unsigned x = 1; x &lt;= 30; x++){</p><p class="snippet">}</p></li>
				<li>Finally, we will check in the body of the <strong class="inline">for</strong> loop by using an <strong class="inline">if</strong> statement and the expression <strong class="inline">x%3 == 0</strong>, which evaluates to <strong class="inline">true</strong> if the division has a remainder equal to <strong class="inline">0</strong>:<p class="snippet">if (x%3 == 0) {</p><p class="snippet">  count++;</p><p class="snippet">}</p></li>
				<li>If the previous condition returns to <strong class="inline">true</strong>, then the <strong class="inline">X</strong> variable is divisible by <strong class="inline">3</strong> and we can increment the counter.</li>
				<li>Finally, we can print <strong class="inline">count</strong>:<p class="snippet">std::cout &lt;&lt; count &lt;&lt; std::endl;</p></li>
			</ol>
			<p><strong class="bold">Bonus exercises</strong>:</p>
			<ul>
				<li>Find how many numbers are divisible by 11 within the range of 1 to 100</li>
				<li>Print all the numbers that are not divisible by 3 within the range of 1 to 30</li>
			</ul>
			<h3 id="_idParaDest-39"><a id="_idTextAnchor041"/>Activity 1: Finding the Factors of 7 between 1 and 100 Using a while Loop</h3>
			<p>In the following activity, we will use a <strong class="inline">while</strong> loop and implement the previous concept from the earlier exercise to print the numbers between 1 and 100 that are divisible by 7.</p>
			<p>Now, let's rewrite the previous code using a <strong class="inline">while</strong> loop in the following way:</p>
			<ol>
				<li value="1">Create a variable of the <strong class="inline">unsigned</strong> type.</li>
				<li>Now, write the logic to print the numbers that are divisible by <strong class="inline">7</strong> using the <strong class="inline">while</strong> loop.</li>
				<li>Then, we have to increase the value of <strong class="inline">i</strong> after each iteration. Use the following code:<p class="snippet">i++;</p><p class="callout">The solution for this activity can be found on page 282.</p></li>
			</ol>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor042"/>Arrays</h2>
			<p>An <strong class="keyword">array</strong> is a data structure containing a series of elements of the same type that have been placed in contiguous memory locations that can be individually accessed by their position.</p>
			<p>Arrays have fixed sizes and cannot be extended; this contributes to their runtime performance, with a cost in terms of limited flexibility.</p>
			<h3 id="_idParaDest-41"><a id="_idTextAnchor043"/>Array Declaration</h3>
			<p>Like any other variable, arrays need to be declared before they can be used. An array declaration has the following form:</p>
			<p class="snippet">type name [elements];</p>
			<p>Here, <strong class="inline">type</strong> is the type of the contained elements, <strong class="inline">name</strong> is the identifier of the <strong class="inline">array</strong> variable, and elements is the length of the array, so it signifies the number of elements contained within.</p>
			<p>The term <strong class="inline">elements</strong> needs to be a constant expressions that is known at compile time, since that is the time when the array size is evaluated to determine the dimension of the block of static memory to allocate.</p>
			<p>When an array is declared, its content is left undetermined, which means that the elements are not set to any specific value. This is often confusing for programmers as you might expect that the elements are initialized to the default value for the array type.</p>
			<h3 id="_idParaDest-42"><a id="_idTextAnchor044"/>Array Initialization</h3>
			<p>Array elements can be specifically initialized at declaration time by enclosing these initial values in braces:</p>
			<p class="snippet">int foo [5] = { 1, 2, 11, 15, 1989 };</p>
			<p>When we initialize a list array, we can also omit its length as it will be determined by the number of values provided. The following declaration is equivalent to the previous one:</p>
			<p class="snippet">int foo [] = { 1, 2, 11, 15, 1989 };</p>
			<p>If the number of elements is provided, but the array is initialized with fewer elements, then the remaining value will be <em class="italics">zero-initialized</em>, for example:</p>
			<p class="snippet">int foo [5] = { 1, 2, 11 };</p>
			<p>The previous code is equivalent to the following:</p>
			<p class="snippet">int foo [5] = { 1, 2, 11, 0, 0 };</p>
			<h3 id="_idParaDest-43"><a id="_idTextAnchor045"/>Accessing the Values of an Array</h3>
			<p>The values of an array can be accessed in the same way as any other values of the same type. The following is the syntax to access an array:</p>
			<p class="snippet">name[index]</p>
			<p>An element of an array can be accessed to store a new element or to read its value.</p>
			<p>For example, the following statement updates the value at position 4 of the previously declared array named <strong class="inline">foo</strong>:</p>
			<p class="snippet">foo [4] = 15</p>
			<p>The following is used to copy the content of the element at position 2 into a new variable:</p>
			<p class="snippet">int x = foo [2]</p>
			<p>It is important to notice that the elements at positions <strong class="inline">4</strong> and <strong class="inline">2</strong> refer to the fifth and third elements, respectively. This is due to the fact that indexing starts from <strong class="inline">0</strong>. The following diagram illustrates how index entries work in arrays:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer021">
					<img alt="Figure 1.9: Initializing a one-dimensional array " src="image/C11557_01_09.jpg"/>
				</div>
			</div>
			<h6>Figure 1.9: Initializing a one-dimensional array</h6>
			<p>Exceeding the valid range of indices for an array is syntactically correct, so the compiler will not produce any errors. Accessing an array out of bounds in C++ is considered an undefined behavior, which means that the code's behavior is not prescribed by the language specification. This can result in runtime errors such as bugs caused by access to an unallocated location in memory or program termination (segmentation fault) due to an attempt to access memory not owned by the program.</p>
			<h3 id="_idParaDest-44"><a id="_idTextAnchor046"/>Multidimensional Arrays</h3>
			<p>Multidimensional arrays are commonly described as <em class="italics">arrays of arrays</em>, where an array's elements are other arrays.</p>
			<p>The following syntax illustrates a bi-dimensional array:</p>
			<p class="snippet">type name [n][m];</p>
			<p class="snippet">int bi_array [3][4]</p>
			<p>Here, <strong class="inline">n</strong> is the dimension of the array and <strong class="inline">m</strong> is the dimension of its elements.</p>
			<p>Typically, in a bi-dimensional array like the previous one, the first dimension is referred to as the <strong class="inline">row</strong> and the second one is referred to as the <strong class="inline">column</strong>.</p>
			<p>Multidimensional arrays are not limited to two dimensions; they can have as many dimensions as needed, but keep in mind that the memory that's used increases exponentially with each dimension. Similar to one-dimensional arrays, multidimensional arrays can be initialized by specifying a list of initializers, one for each row. Let's examine the following code:</p>
			<p class="snippet">#include &lt;iostream&gt;</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">  int foo [3][5] = {{ 1, 2, 11, 15, 1989 }, { 0, 7, 1, 5, 19 }, { 9, 6, 131, 1, 2 }};</p>
			<p class="snippet">  for (int x = 0; x &lt; 3; x++) </p>
			<p class="snippet">  { </p>
			<p class="snippet">    for (int y = 0; y &lt; 5; y++) </p>
			<p class="snippet">    {</p>
			<p class="snippet">      std::cout &lt;&lt;"Array element at [" &lt;&lt; x &lt;&lt; "]" &lt;&lt; "[" &lt;&lt; y &lt;&lt; "]: "&lt;&lt; foo[x][y] &lt;&lt; std::endl;</p>
			<p class="snippet">    }</p>
			<p class="snippet">  }</p>
			<p class="snippet">}</p>
			<p class="snippet">Output:</p>
			<p class="snippet">Array element at [0][0]: 1</p>
			<p class="snippet">Array element at [0][1]: 2</p>
			<p class="snippet">Array element at [0][2]: 11</p>
			<p class="snippet">Array element at [0][3]: 15</p>
			<p class="snippet">Array element at [0][4]: 1989</p>
			<p class="snippet">Array element at [1][0]: 0</p>
			<p class="snippet">Array element at [1][1]: 7</p>
			<p class="snippet">Array element at [1][2]: 1</p>
			<p class="snippet">Array element at [1][3]: 5</p>
			<p class="snippet">Array element at [1][4]: 19</p>
			<p class="snippet">Array element at [2][0]: 9</p>
			<p class="snippet">Array element at [2][1]: 6</p>
			<p class="snippet">Array element at [2][2]: 131</p>
			<p class="snippet">Array element at [2][3]: 1</p>
			<p class="snippet">Array element at [2][4]: 2</p>
			<p>Alternatively, since the compiler can infer the length of the internal arrays from the definition, the nested braces are optional and provided only for readability:</p>
			<p class="snippet">int foo [3][5] = {1, 2, 11, 15, 1989, 0, 7, 1, 5, 19, 9, 6, 131, 1, 2};</p>
			<h3 id="_idParaDest-45"><a id="_idTextAnchor047"/>Activity 2: Defining a Bi-Dimensional Array and Initializing Its Elements</h3>
			<p>In this section, we will define a bi-dimensional array (<strong class="inline">3x3</strong>) of type integer and write a program to assign each element the addition of their corresponding index entries in the array:</p>
			<ol>
				<li value="1">Define an array of integers of size <strong class="inline">3x3</strong>.</li>
				<li>Iterate over each element of the array using a nested <strong class="inline">for</strong> loop and assign the product values <strong class="inline">x</strong> and <strong class="inline">y</strong> to the index.<h4>Note:</h4><p class="callout">The solution for this activity can be found on page 282.</p></li>
			</ol>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor048"/>Summary</h2>
			<p>In this chapter, we saw the basic structure and syntax of the language. We started with an overview of the compilation model, the process of transforming C++ source code into an executable program. We wrote, compiled, and ran our first program, a simple <strong class="inline">main</strong> function that successfully returns an exit/return code.</p>
			<p>We described the built-in arithmetic types that the language offers. </p>
			<p>We learned how to declare and define variable names, and what the difference is between references and pointers. We also saw the use of the <strong class="inline">const</strong> qualifier and its advantages.</p>
			<p>Furthermore, we talked about control flow statements and how to exploit them to perform more complex actions.</p>
			<p>Finally, we presented arrays and multidimensional arrays, and the operation to perform to initialize them and access their values. In the next chapter, we will learn what functions in C++ are, and how and why we should use them in our code.</p>
		</div>
</body></html>