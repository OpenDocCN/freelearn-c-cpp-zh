<html><head></head><body>
		<div id="_idContainer306">
			<h1 class="chapter-number" id="_idParaDest-310"><a id="_idTextAnchor705"/>13</h1>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor706"/>OOP Continued and Advanced Topics</h1>
			<p>We learned so many things about programming over the course of this book, from basic variables, control flows, and classes to things that are GDScript-specific, such as accessing nodes in the scene tree and specific annotations. However, don’t be mistaken – there is still so much more knowledge out there that can help solve problems easier <span class="No-Break">and faster.</span></p>
			<p>After many years of studying and professionally applying my programming skills, I can confidently state that computer science is a deep and rewarding field to keep learning. Plus, every few years a new technology pokes out its head, waiting to <span class="No-Break">be studied.</span></p>
			<p>In this chapter, we’ll look at a bunch of more advanced techniques and concepts that will elevate your programming skills to <span class="No-Break">new heights!</span></p>
			<p>In this chapter, we will cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>The <span class="No-Break"><strong class="source-inline">super</strong></span><span class="No-Break"> keyword</span></li>
				<li>Static variables <span class="No-Break">and functions</span></li>
				<li><span class="No-Break">Enumeration</span></li>
				<li><span class="No-Break">Lambda functions</span></li>
				<li>Passing parameters by value <span class="No-Break">or reference</span></li>
				<li>The <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">tool</strong></span><span class="No-Break"> annotation</span></li>
			</ul>
			<h1 id="_idParaDest-312"><a id="_idTextAnchor707"/>Technical requirements</h1>
			<p>As with every chapter, you can find the final code in the GitHub repository in the subfolder for this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter13"><span class="No-Break">https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter13</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-313"><a id="_idTextAnchor708"/>The super keyword</h1>
			<p>In <a href="B19358_04.xhtml#_idTextAnchor164"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, we learned all about inheritance and how we can override functions from a base class in an inherited class. This overriding replaces the function with a whole new body and discards the original<a id="_idIndexMarker788"/> implementation of the base class. However, sometimes, we still would like to execute the original logic that was defined in the <span class="No-Break">parent class.</span></p>
			<p>To accomplish this, we can use the <strong class="source-inline">super</strong> keyword. This keyword gives us direct access to all the functions of the parent class on which the current class was based. Consider the following example, where we want to have different kinds of arrows in our game to shoot <span class="No-Break">enemies with:</span></p>
			<pre class="source-code">
class BaseArrow:
   func describe_damage():
      print("Pierces a person")
class FireArrow extends BaseArrow:
   func describe_damage():
      <strong class="bold">super()</strong>
      print("And sets them ablaze")</pre>			<p>Here, we define a <strong class="source-inline">BaseArrow</strong> class which is the base for all kinds of arrows. It has one function, <strong class="source-inline">describe_damage()</strong>, which just describes what kind of damage the arrow does by printing out <strong class="source-inline">Pierces a person</strong> to <span class="No-Break">the console.</span></p>
			<p>When we override the <strong class="source-inline">describe_damage()</strong> function of the <strong class="source-inline">FireArrow</strong> class, we first call <strong class="source-inline">super()</strong> as a function. This will execute the original <strong class="source-inline">describe_damage()</strong> function of the <strong class="source-inline">BaseArrow</strong> class before executing <span class="No-Break">the rest.</span></p>
			<p>Let’s execute some code that uses <span class="No-Break">these classes:</span></p>
			<pre class="source-code">
var fire_arrow: FireArrow = FireArrow.new()
fire_arrow.describe_damage()</pre>			<p>The result will be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Pierces a person
And sets them ablaze</pre>			<p>You can see that the <strong class="source-inline">describe_damage()</strong> function from the base class has been executed, using the <strong class="source-inline">super()</strong> keyword, as well as the rest of the <strong class="source-inline">FireArrow</strong> <span class="No-Break">class’s implementation.</span></p>
			<p>The <strong class="source-inline">super</strong> keyword gives <a id="_idIndexMarker789"/>access to the underlying class we inherited from; whether we have overridden that function or not, it will always return to the original one. Let’s continue with a look at another new keyword – <span class="No-Break"><strong class="source-inline">static</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor709"/>Static variables and functions</h1>
			<p>The next keyword we will look at is <strong class="source-inline">static</strong>. We can declare a variable or function as static by putting this keyword in<a id="_idIndexMarker790"/> front <span class="No-Break">of it:</span></p>
			<pre class="source-code">
class Enemy:
   <strong class="bold">static</strong> var damage: float = 10.0
   <strong class="bold">static</strong> func do_battle_cry():
      print("Aaaaaargh!")</pre>			<p>Static variables and functions are declared on the class itself. This means that they can be accessed without creating an instance of <span class="No-Break">the class:</span></p>
			<pre class="source-code">
print(Enemy.damage)
Enemy.do_battle_cry ()</pre>			<p>Static variables are <a id="_idIndexMarker791"/>made to contain information that is bound to a complete class of objects. But watch out – the following are two big gotchas for static variables <span class="No-Break">and functions:</span></p>
			<ul>
				<li>In GDScript, static variables can be assigned a new value, and you can change them during the execution of the game. Ideally, you don’t want to do this because it can impact your program in ways that are hard <span class="No-Break">to debug.</span></li>
				<li>From a static function, you can call other functions and use member variables of the class, but only if they are defined as static too. Because static functions are defined on the class itself, they do not have all the context of an initialized object of this class. Static<a id="_idIndexMarker792"/> functions need to be <span class="No-Break">very self-contained.</span></li>
			</ul>
			<p>All in all, you won’t see static variables and functions that often in GDScript, but it is a well-known concept that many object-oriented programming languages, such as C++ or Java, use. Let’s have a look at <span class="No-Break">enums next.</span></p>
			<h1 id="_idParaDest-315"><a id="_idTextAnchor710"/>Enumerations</h1>
			<p><strong class="bold">Enums</strong>, short for <strong class="bold">enumerations</strong>, are a variable type that defines a set of constants that need to be grouped together. Unlike normal constants, where we want to store a certain value, enums automatically <a id="_idIndexMarker793"/>assign values to <span class="No-Break">a constant.</span></p>
			<p>In <em class="italic">Chapters 2</em> and <em class="italic">5</em>, we saw that it’s very important to have well-named variables. This way, we always know what they will contain. We can actually do this for the values of variables too, with named values. Using named values, we can associate a human-readable name with a certain value, making code more readable. It also removes magic numbers from the code. Have a look at <span class="No-Break">this enum:</span></p>
			<pre class="source-code">
enum DAMAGE_TYPES {
   NONE,
   FIRE,
   ICE
}</pre>			<p>Here, we create an enum called <strong class="source-inline">DAMAGE_TYPES</strong> that defines three named values – <strong class="source-inline">NONE</strong>, <strong class="source-inline">FIRE</strong>, and <strong class="source-inline">ICE</strong>. You can access these values <span class="No-Break">like so:</span></p>
			<pre class="source-code">
DAMAGE_TYPES.FIRE</pre>			<p>Let’s try printing <span class="No-Break">them out:</span></p>
			<pre class="source-code">
print(DAMAGE_TYPES.NONE)
print(DAMAGE_TYPES.FIRE)
print(DAMAGE_TYPES.ICE)</pre>			<p>You’ll see that it prints out <span class="No-Break">the following:</span></p>
			<pre class="source-code">
0
1
2</pre>			<p>This is because each of the names within the enum is associated with an integer value. However, instead of using these rough integers, we can now use nicely readable names. The first named value is associated with <strong class="source-inline">0</strong>, and each following one goes up <span class="No-Break">by one.</span></p>
			<p>An enum can also be used to<a id="_idIndexMarker794"/> type-hint variables; this way, we know that the variable needs to be assigned an enum value from a <span class="No-Break">certain type:</span></p>
			<pre class="source-code">
var damage_type: DAMAGE_TYPES = DAMAGE_TYPES.FIRE
match damage_type:
   DAMAGE_TYPES.NONE:
      print("Nothing special happens")
   DAMAGE_TYPES.FIRE:
      print("You catch fire! ")
   DAMAGE_TYPES.ICE:
      print("You freeze!")</pre>			<p>In this example, we type-hint the <strong class="source-inline">damage_type</strong> variable as <strong class="source-inline">DAMAGE_TYPES</strong>. Then, we can, for example, match against this variable and determine what <span class="No-Break">to do.</span></p>
			<p class="callout-heading">Enums versus strings</p>
			<p class="callout">Now, you might think, “<em class="italic">Why don’t we use strings if we want to be able to read the value?</em>” Well, simply, it’s because strings<a id="_idIndexMarker795"/> are slower and more memory-heavy to work with than integers, the underlying<a id="_idIndexMarker796"/> data type of enum values. Another reason is ease of use. An enum has a finite set of values, the ones we defined, while a string can have an arbitrary number of characters. So, when using an enum, we’re sure we’re only dealing with values <span class="No-Break">we know.</span></p>
			<p>We can also access enums that <a id="_idIndexMarker797"/>are defined in one class from a totally different class; like<a id="_idIndexMarker798"/> static variables and functions, they can be accessed from the class <span class="No-Break">type directly:</span></p>
			<pre class="source-code">
class Arrow:
   Enum DAMAGE_TYPES {
      NONE,
      FIRE
   }
func _ready():
   var damage_type: <strong class="bold">Arrow.DAMAGE_TYPES</strong> = <strong class="bold">Arrow.DAMAGE_TYPES.FIRE</strong></pre>			<p>Here, we define the <strong class="source-inline">DAMAGE_TYPES</strong> enum from within the <strong class="source-inline">Arrow</strong> class. Later, we can access this enum by using <span class="No-Break"><strong class="source-inline">Arrow.DAMAGE_TYPES</strong></span><span class="No-Break"> directly.</span></p>
			<p>In this section, we looked at enums, named values that help us by providing human-readable labels. Next, we’ll take a look at <span class="No-Break">lambda functions.</span></p>
			<h1 id="_idParaDest-316"><a id="_idTextAnchor711"/>Lambda functions</h1>
			<p>So far, every function we have written belonged to a class or file, which could be treated as a class, but there is actually a way to <a id="_idIndexMarker799"/>define functions separately from any class definition. These kinds of functions are called <span class="No-Break"><strong class="bold">lambda functions</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-317"><a id="_idTextAnchor712"/>Creating a lambda function</h2>
			<p>Let’s take a look at a <span class="No-Break">lambda</span><span class="No-Break"><a id="_idIndexMarker800"/></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
var print_hello: Callable = func(): print("Hello")</pre>			<p>You can see that we’ve defined a function, just as we normally do, but this time without a function name. Instead, we assigned the function to a variable. This variable now contains the function in the form of the <strong class="source-inline">Callable</strong> object type. We can call a <strong class="source-inline">Callable</strong> object later on, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
print_hello.call()</pre>			<p>This will run the function that we defined and, thus, print out <strong class="source-inline">Hello</strong> to <span class="No-Break">the console.</span></p>
			<p>Lambda functions, just like<a id="_idIndexMarker801"/> normal functions, can take <span class="No-Break">arguments too:</span></p>
			<pre class="source-code">
var print_largest: Callable = func(number_a: float, number_b: float):
   if number_a &gt; number_b:
      print(number_a)
   else:
      print(number_b)</pre>			<p>In this example, you can also see that lambda functions can contain multiple lines of code in the form of a code block, where each line has the same level <span class="No-Break">of indentation.</span></p>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor713"/>Where to use lambda functions</h2>
			<p>So, where would we use lambda<a id="_idIndexMarker802"/> functions? Well, they are very useful in scenarios where you need a relatively small function but don’t want to have it as a permanent residence in <span class="No-Break">the class.</span></p>
			<p>One great application of lambda functions is connecting signals. If we have a button for example, then we can connect to its pressed signal using a lambda function, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
button.connect("pressed", <strong class="bold">func(): print("Button pressed!")</strong>)</pre>			<p>Now, every time the button is pressed and emits the <strong class="source-inline">pressed</strong> signal, our lambda function gets executed and prints out <span class="No-Break"><strong class="source-inline">Button pressed!</strong></span><span class="No-Break">.</span></p>
			<p>Another one of its use cases are the <strong class="source-inline">filter()</strong> or <strong class="source-inline">sort_custome()</strong> functions that can use lambda function to filter or sort elements in <span class="No-Break">an array:</span></p>
			<pre class="source-code">
[0, 1, 2, 3, 4].filter(func(number: int): return number % 2 == 0)
[0, 3, 2, 4, 1].sort_custome(func(number_a: int, number_b: int): return number_a &lt; number_b)</pre>			<p>Each array has the <strong class="source-inline">filter()</strong> and <strong class="source-inline">sort_custome()</strong> function that takes <strong class="source-inline">Callable</strong> as an argument. The <strong class="source-inline">filter()</strong> function will filter out any element within the array for which the function returns <strong class="source-inline">false</strong>, resulting<a id="_idIndexMarker803"/> in an array that only has the elements where the function returns <strong class="source-inline">true</strong>. In the preceding example, this results in an array with only <span class="No-Break">even numbers.</span></p>
			<p>The <strong class="source-inline">sort_custome()</strong> function sorts the elements within the array using the <strong class="source-inline">Callable</strong> we provide it. The lambda function should take two elements and, when the first element should be sorted before the second element, return <strong class="source-inline">true</strong>; otherwise, it should return <strong class="source-inline">false</strong>. This way, we can define our own rules to sort an <span class="No-Break">array’s elements.</span></p>
			<p>The resulting arrays after running <strong class="source-inline">filter()</strong> and <strong class="source-inline">sort_custome()</strong> with our lambda functions are <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
[0, 2, 4]
[0, 1, 2, 3, 4]</pre>			<p class="callout-heading">More information</p>
			<p class="callout">For more on lambda functions, check<a id="_idIndexMarker804"/> out the official <span class="No-Break">documentation: </span><a href="https://docs.godotengine.org/en/stable/classes/class_callable.html"><span class="No-Break">https://docs.godotengine.org/en/stable/classes/class_callable.html</span></a><span class="No-Break">.</span></p>
			<p>Now that we know what lambda functions are, let’s take a look at the different ways in which we can pass values <span class="No-Break">to functions.</span></p>
			<h1 id="_idParaDest-319"><a id="_idTextAnchor714"/>Passing parameters by value or reference</h1>
			<p>When passing parameters to a function, there are actually two different ways in which these parameters can arrive at the body of that function – by value or reference. We, as programmers, do not choose which of the two is used; GDScript makes this decision based on the data type of the value we provide the function. Let’s take a deeper look into both the methods for passing values, which data types apply to each, and why it is important to know <span class="No-Break">the difference.</span></p>
			<h2 id="_idParaDest-320"><a id="_idTextAnchor715"/>Passing by value</h2>
			<p>Passing by value means that GDScript <a id="_idIndexMarker805"/>sends over an exact copy of a value to a function. This approach is very simple and predictable because we get a new variable in the function that we called. However, because copying over data takes time, it can be quite slow for big <span class="No-Break">data types.</span></p>
			<p>Data types that get passed by value are any of the simpler built-in data types, such as integers, floating point numbers, and Booleans. Some also slightly more complex classes such as strings, <strong class="source-inline">Vector2</strong>, and <strong class="source-inline">Colors</strong> are passed by value. This list is not exhaustive. The general rule of inclusion is anything that is not an array, not a dictionary, and not inherited from the <span class="No-Break"><strong class="source-inline">Object</strong></span><span class="No-Break"> class.</span></p>
			<p>Let’s see what passing by value looks like <span class="No-Break">in practice:</span></p>
			<pre class="source-code">
func _ready():
   var number: int = 5
   print("Number before the function: ", number)
   function_taking_integers(number)
   print("Number after the function: ", number)
   var string: String = "Hello there!"
   print("String before the function: ", string)
   function_taking_strings(string)
   print("String after the function: ", string)
func function_taking_integers(number: int):
   number += 10
   print("Number during the function: ", number)
func function_taking_strings(string: String):
   string[0] = "W"
   print("String during the function: ", string)</pre>			<p>Here, you can see that we have two functions that take an integer and a string respectively, and each modify the value of the parameter during its execution. We also print out the value of this integer<a id="_idIndexMarker806"/> and string every step of the way, before, during, and after the function’s execution, to see whether the original variable, from the <strong class="source-inline">_ready()</strong> function, got altered. Running this will print out <span class="No-Break">the following:</span></p>
			<pre class="source-code">
Number before the function: 5
Number during the function: 15
Number after the function: 5
String before the function: Hello there!
String during the function: Wello there!
String after the function: Hello there!</pre>			<p>We can see that, although the value got altered in some way during the function’s execution, the original value did not change. This is the fun of passing by value; we don’t need to worry about <span class="No-Break">side effects.</span></p>
			<p class="callout-heading">Side effects of functions</p>
			<p class="callout">Side effects, in programmer lingo, mean that a function changes the state of a program in ways that are not directly apparent, altering variables outside of its scope. You want to avoid this as much as possible so that it is easy to understand what a <span class="No-Break">function does.</span></p>
			<p>This is how passing by value works – just a straight copy of the data. Now, we’ll see the contrasting idea – passing <span class="No-Break">by reference.</span></p>
			<h2 id="_idParaDest-321"><a id="_idTextAnchor716"/>Passing by reference</h2>
			<p>The other way to pass values to a function is by reference. This means that GDScript does not copy over the whole value but, rather, sends a reference that points toward the value. This reference points to where the actual value is stored and can be used to access and <span class="No-Break">change it.</span></p>
			<p>This mode of passing parameters is used for<a id="_idIndexMarker807"/> arrays, dictionaries, and any class that inherits from the <strong class="source-inline">Object</strong> class, which includes all types of nodes. It is essentially used to pass bigger data types, as copying their complete value over would take too much time and slow down the execution of <span class="No-Break">our game.</span></p>
			<p>Here’s an example of what passing by reference <span class="No-Break">looks like:</span></p>
			<pre class="source-code">
func _ready():
   var dictionary: Dictionary = { "value": 5 }
   print("Dictionary before the function: ", dictionary)
   function_taking_dictionary(dictionary)
   print("Dictionary after the function: ", dictionary)
func function_taking_dictionary(dictionary: Dictionary):
   dictionary["a_value"] = "has changed"
   print("Dictionary during the function: ", dictionary)</pre>			<p>Again, we use the same setup as before to print out our dictionary every step of the way. We run the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
Dictionary before the function: { "value": 5 }
Dictionary during the function: { "value": 5, "a_value": "has changed" }
Dictionary after the function: { "value": 5, "a_value": "has changed" }</pre>			<p>As expected, we can see that after the function ran, the original dictionary from the <strong class="source-inline">_ready()</strong> function was altered too! This is a side effect <span class="No-Break">in action.</span></p>
			<p>In general, it is good practice to <a id="_idIndexMarker808"/>never alter the values and variables that come into a function, and always make a copy or use them directly to calculate a value for another variable. When in doubt, it’s best to test out whether a value is passed by value or reference; this way, you never encounter <span class="No-Break">unintended bugs.</span></p>
			<p class="callout-heading">Duplicating arrays or dictionaries</p>
			<p class="callout">If you really want to make a copy <a id="_idIndexMarker809"/>of an array or dictionary, then you can use the <strong class="source-inline">duplicate()</strong> function that is defined on these data types. This function will return a copy of the array or dictionary that you can <span class="No-Break">alter safely.</span></p>
			<p class="callout">See the documentation for more <span class="No-Break">details: </span><a href="https://docs.godotengine.org/fr/4.x/classes/class_array.html#class-array-method-duplicate"><span class="No-Break">https://docs.godotengine.org/fr/4.x/classes/class_array.html#class-array-method-duplicate</span></a><span class="No-Break">.</span></p>
			<p>We’ll now switch gears and see how we can make tools for the editor from within <span class="No-Break">the editor.</span></p>
			<h1 id="_idParaDest-322"><a id="_idTextAnchor717"/>The @tool annotation</h1>
			<p>As well as using GDScript to run code during our game’s execution, we can actually use it to run code in the editor itself. Running <a id="_idIndexMarker810"/>code within the editor grants us the power to visualize things, such as the jump height of a character, or automate our workflow. In doing so we extend the Godot editor for our own specific needs. There are multiple ways of running GDScript code within the editor, ranging from running separate scripts to writing whole plugins, but the easiest way is by using the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">tool</strong></span><span class="No-Break"> annotation.</span></p>
			<p>The <strong class="source-inline">@tool</strong> annotation is an annotation that can be added to the top of any script. Its effect is that nodes with that script will run their script within the editor as if they were instanced within a game. This means that all of their code runs from within <span class="No-Break">the editor.</span></p>
			<p>This is very useful when we are editing our scenes and want to preview things within the editor, such as the health of our player, or create new nodes <span class="No-Break">using code.</span></p>
			<p>Knowing this, we can adjust our player script, by adding the <strong class="source-inline">@tool</strong> annotation to the top to update the health label in <span class="No-Break">the editor:</span></p>
			<pre class="source-code">
@tool
class_name Player extends CharacterBody2D
const MAX_HEALTH: int = 10
@onready var _health_label: Label = $Health
@export var health: int = 10:
   set(new_value):
      health = new_value
      update_health_label()
func _ready():
   update_health_label()
func update_health_label():
   if not is_instance_valid(_health_label):
      return
   _health_label.text = str(health) + "/" + str(MAX_HEALTH)</pre>			<p>This example is the minimum amount of code needed to update the health label from within the editor. However, you<a id="_idIndexMarker811"/> can just add the <strong class="source-inline">@tool</strong> annotation at the top of your existing player script, and it will work its magic. You’ll see that every time you change the player’s health from within the editor now, the health label will automatically reflect <span class="No-Break">this change.</span></p>
			<p class="callout-heading">The risks of @tool</p>
			<p class="callout">The <strong class="source-inline">@tool</strong> annotation is very powerful but not without danger. It can remove things permanently from a scene and easily<a id="_idIndexMarker812"/> change the values of nodes if you don’t watch out, so treat it <span class="No-Break">with caution.</span></p>
			<p>However, sometimes you want to use a node in a game and have some code that runs in the editor. When we do that, we need a way to distinguish whether the code is run in the game or the editor. This can<a id="_idIndexMarker813"/> be done by using <strong class="source-inline">Engine.is_editor_hint()</strong>. This function on the global <strong class="source-inline">Engine</strong> object returns <strong class="source-inline">true</strong> if we run the code from within the editor and <strong class="source-inline">false</strong> when from within <span class="No-Break">the game:</span></p>
			<pre class="source-code">
if Engine.is_editor_hint():
   # Code to execute in editor.
if not Engine.is_editor_hint():
   # Code to execute in game.</pre>			<p>This code example shows us how easy it is to differentiate between running code in the editor or <span class="No-Break">the game.</span></p>
			<p class="callout-heading">More information</p>
			<p class="callout">Want to know more about the <strong class="source-inline">@tool</strong> annotation and running code within the editor? Check out the official <a id="_idIndexMarker814"/><span class="No-Break">documentation: </span><a href="https://docs.godotengine.org/en/stable/tutorials/plugins/running_code_in_the_editor.html"><span class="No-Break">https://docs.godotengine.org/en/stable/tutorials/plugins/running_code_in_the_editor.html</span></a><span class="No-Break">.</span></p>
			<p>Using the <strong class="source-inline">@tool</strong> annotation wisely, we can make our workflow easier and faster. The possibilities are endless; you can even access and change almost every aspect of the Godot editor from within one of these scripts, but that is out of the scope of <span class="No-Break">this book.</span></p>
			<h1 id="_idParaDest-323"><a id="_idTextAnchor718"/>Summary</h1>
			<p>This chapter took a deeper dive into some of the more advanced topics of programming with GDScript. We expanded our knowledge of object-oriented programming with the <strong class="source-inline">super</strong> and <strong class="source-inline">static</strong> keywords and the difference between passing by value or reference. Then, we saw more features of the GDScript programming language, such as enums and lambda functions. We concluded the chapter with a way to run code within the Godot editor itself, u<a id="_idTextAnchor719"/>sing the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">tool</strong></span><span class="No-Break"> annotation.</span></p>
			<h1 id="_idParaDest-324"><a id="_idTextAnchor720"/>Quiz time</h1>
			<ul>
				<li>Imagine we have a class named <strong class="source-inline">Character</strong> that has a function called <strong class="source-inline">move()</strong>. Now, we create a <strong class="source-inline">Player</strong> class that inherits from this <strong class="source-inline">Character</strong> class and overrides this <strong class="source-inline">move()</strong> function. But, instead of completely overriding it, we want to extend the original functionality of the <strong class="source-inline">Character</strong> class’s <strong class="source-inline">move()</strong> function. What keyword can we use to call the original <strong class="source-inline">move()</strong> function of the <strong class="source-inline">Character</strong> class from within the <span class="No-Break"><strong class="source-inline">Player</strong></span><span class="No-Break"> class?</span></li>
				<li>Can functions that are labeled <strong class="source-inline">static</strong> call functions that are not <span class="No-Break">labeled </span><span class="No-Break"><strong class="source-inline">static</strong></span><span class="No-Break">?</span></li>
				<li>What will the following snippet of code <span class="No-Break">print out?</span><pre class="source-code">
enum COLLECTIBLE_TYPE {
   HEALTH,
   UPGRADE,
   DAMAGE,
}
print(COLLECTIBLE_TYPES.DAMAGE)</pre></li>				<li>Are container types, such as arrays and dictionaries, the only types that get passed <span class="No-Break">by reference?</span></li>
				<li>What annotation do we use at the top of a script if we want to run it in <span class="No-Break">the editor?</span></li>
			</ul>
		</div>
	</body></html>