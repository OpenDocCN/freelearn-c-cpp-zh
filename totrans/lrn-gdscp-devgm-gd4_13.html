<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-310"><a id="_idTextAnchor705"/>13</h1>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor706"/>OOP Continued and Advanced Topics</h1>
			<p>We learned so many things about programming over the course of this book, from basic variables, control flows, and classes to things that are GDScript-specific, such as accessing nodes in the scene tree and specific annotations. However, don’t be mistaken – there is still so much more knowledge out there that can help solve problems easier and faster.</p>
			<p>After many years of studying and professionally applying my programming skills, I can confidently state that computer science is a deep and rewarding field to keep learning. Plus, every few years a new technology pokes out its head, waiting to be studied.</p>
			<p>In this chapter, we’ll look at a bunch of more advanced techniques and concepts that will elevate your programming skills to new heights!</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li>The <code>super</code> keyword</li>
				<li>Static variables and functions</li>
				<li>Enumeration</li>
				<li>Lambda functions</li>
				<li>Passing parameters by value or reference</li>
				<li>The <code>@</code><code>tool</code> annotation</li>
			</ul>
			<h1 id="_idParaDest-312"><a id="_idTextAnchor707"/>Technical requirements</h1>
			<p>As with every chapter, you can find the final code in the GitHub repository in the subfolder for this chapter: <a href="https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter13">https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter13</a>.</p>
			<h1 id="_idParaDest-313"><a id="_idTextAnchor708"/>The super keyword</h1>
			<p>In <a href="B19358_04.xhtml#_idTextAnchor164"><em class="italic">Chapter 4</em></a>, we learned all about inheritance and how we can override functions from a base class in an inherited class. This overriding replaces the function with a whole new body and discards the original<a id="_idIndexMarker788"/> implementation of the base class. However, sometimes, we still would like to execute the original logic that was defined in the parent class.</p>
			<p>To accomplish this, we can use the <code>super</code> keyword. This keyword gives us direct access to all the functions of the parent class on which the current class was based. Consider the following example, where we want to have different kinds of arrows in our game to shoot enemies with:</p>
			<pre class="source-code">
class BaseArrow:
   func describe_damage():
      print("Pierces a person")
class FireArrow extends BaseArrow:
   func describe_damage():
      <strong class="bold">super()</strong>
      print("And sets them ablaze")</pre>			<p>Here, we define a <code>BaseArrow</code> class which is the base for all kinds of arrows. It has one function, <code>describe_damage()</code>, which just describes what kind of damage the arrow does by printing out <code>Pierces a person</code> to the console.</p>
			<p>When we override the <code>describe_damage()</code> function of the <code>FireArrow</code> class, we first call <code>super()</code> as a function. This will execute the original <code>describe_damage()</code> function of the <code>BaseArrow</code> class before executing the rest.</p>
			<p>Let’s execute some code that uses these classes:</p>
			<pre class="source-code">
var fire_arrow: FireArrow = FireArrow.new()
fire_arrow.describe_damage()</pre>			<p>The result will be as follows:</p>
			<pre class="source-code">
Pierces a person
And sets them ablaze</pre>			<p>You can see that the <code>describe_damage()</code> function from the base class has been executed, using the <code>super()</code> keyword, as well as the rest of the <code>FireArrow</code> class’s implementation.</p>
			<p>The <code>super</code> keyword gives <a id="_idIndexMarker789"/>access to the underlying class we inherited from; whether we have overridden that function or not, it will always return to the original one. Let’s continue with a look at another new keyword – <code>static</code>.</p>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor709"/>Static variables and functions</h1>
			<p>The next keyword we will look at is <code>static</code>. We can declare a variable or function as static by putting this keyword in<a id="_idIndexMarker790"/> front of it:</p>
			<pre class="source-code">
class Enemy:
   <strong class="bold">static</strong> var damage: float = 10.0
   <strong class="bold">static</strong> func do_battle_cry():
      print("Aaaaaargh!")</pre>			<p>Static variables and functions are declared on the class itself. This means that they can be accessed without creating an instance of the class:</p>
			<pre class="source-code">
print(Enemy.damage)
Enemy.do_battle_cry ()</pre>			<p>Static variables are <a id="_idIndexMarker791"/>made to contain information that is bound to a complete class of objects. But watch out – the following are two big gotchas for static variables and functions:</p>
			<ul>
				<li>In GDScript, static variables can be assigned a new value, and you can change them during the execution of the game. Ideally, you don’t want to do this because it can impact your program in ways that are hard to debug.</li>
				<li>From a static function, you can call other functions and use member variables of the class, but only if they are defined as static too. Because static functions are defined on the class itself, they do not have all the context of an initialized object of this class. Static<a id="_idIndexMarker792"/> functions need to be very self-contained.</li>
			</ul>
			<p>All in all, you won’t see static variables and functions that often in GDScript, but it is a well-known concept that many object-oriented programming languages, such as C++ or Java, use. Let’s have a look at enums next.</p>
			<h1 id="_idParaDest-315"><a id="_idTextAnchor710"/>Enumerations</h1>
			<p><strong class="bold">Enums</strong>, short for <strong class="bold">enumerations</strong>, are a variable type that defines a set of constants that need to be grouped together. Unlike normal constants, where we want to store a certain value, enums automatically <a id="_idIndexMarker793"/>assign values to a constant.</p>
			<p>In <em class="italic">Chapters 2</em> and <em class="italic">5</em>, we saw that it’s very important to have well-named variables. This way, we always know what they will contain. We can actually do this for the values of variables too, with named values. Using named values, we can associate a human-readable name with a certain value, making code more readable. It also removes magic numbers from the code. Have a look at this enum:</p>
			<pre class="source-code">
enum DAMAGE_TYPES {
   NONE,
   FIRE,
   ICE
}</pre>			<p>Here, we create an enum called <code>DAMAGE_TYPES</code> that defines three named values – <code>NONE</code>, <code>FIRE</code>, and <code>ICE</code>. You can access these values like so:</p>
			<pre class="source-code">
DAMAGE_TYPES.FIRE</pre>			<p>Let’s try printing them out:</p>
			<pre class="source-code">
print(DAMAGE_TYPES.NONE)
print(DAMAGE_TYPES.FIRE)
print(DAMAGE_TYPES.ICE)</pre>			<p>You’ll see that it prints out the following:</p>
			<pre class="source-code">
0
1
2</pre>			<p>This is because each of the names within the enum is associated with an integer value. However, instead of using these rough integers, we can now use nicely readable names. The first named value is associated with <code>0</code>, and each following one goes up by one.</p>
			<p>An enum can also be used to<a id="_idIndexMarker794"/> type-hint variables; this way, we know that the variable needs to be assigned an enum value from a certain type:</p>
			<pre class="source-code">
var damage_type: DAMAGE_TYPES = DAMAGE_TYPES.FIRE
match damage_type:
   DAMAGE_TYPES.NONE:
      print("Nothing special happens")
   DAMAGE_TYPES.FIRE:
      print("You catch fire! ")
   DAMAGE_TYPES.ICE:
      print("You freeze!")</pre>			<p>In this example, we type-hint the <code>damage_type</code> variable as <code>DAMAGE_TYPES</code>. Then, we can, for example, match against this variable and determine what to do.</p>
			<p class="callout-heading">Enums versus strings</p>
			<p class="callout">Now, you might think, “<em class="italic">Why don’t we use strings if we want to be able to read the value?</em>” Well, simply, it’s because strings<a id="_idIndexMarker795"/> are slower and more memory-heavy to work with than integers, the underlying<a id="_idIndexMarker796"/> data type of enum values. Another reason is ease of use. An enum has a finite set of values, the ones we defined, while a string can have an arbitrary number of characters. So, when using an enum, we’re sure we’re only dealing with values we know.</p>
			<p>We can also access enums that <a id="_idIndexMarker797"/>are defined in one class from a totally different class; like<a id="_idIndexMarker798"/> static variables and functions, they can be accessed from the class type directly:</p>
			<pre class="source-code">
class Arrow:
   Enum DAMAGE_TYPES {
      NONE,
      FIRE
   }
func _ready():
   var damage_type: <code>DAMAGE_TYPES</code> enum from within the <code>Arrow</code> class. Later, we can access this enum by using <code>Arrow.DAMAGE_TYPES</code> directly.</p>
			<p>In this section, we looked at enums, named values that help us by providing human-readable labels. Next, we’ll take a look at lambda functions.</p>
			<h1 id="_idParaDest-316"><a id="_idTextAnchor711"/>Lambda functions</h1>
			<p>So far, every function we have written belonged to a class or file, which could be treated as a class, but there is actually a way to <a id="_idIndexMarker799"/>define functions separately from any class definition. These kinds of functions are called <strong class="bold">lambda functions</strong>.</p>
			<h2 id="_idParaDest-317"><a id="_idTextAnchor712"/>Creating a lambda function</h2>
			<p>Let’s take a look at a lambda<a id="_idIndexMarker800"/> function:</p>
			<pre class="source-code">
var print_hello: Callable = func(): print("Hello")</pre>			<p>You can see that we’ve defined a function, just as we normally do, but this time without a function name. Instead, we assigned the function to a variable. This variable now contains the function in the form of the <code>Callable</code> object type. We can call a <code>Callable</code> object later on, like this:</p>
			<pre class="source-code">
print_hello.call()</pre>			<p>This will run the function that we defined and, thus, print out <code>Hello</code> to the console.</p>
			<p>Lambda functions, just like<a id="_idIndexMarker801"/> normal functions, can take arguments too:</p>
			<pre class="source-code">
var print_largest: Callable = func(number_a: float, number_b: float):
   if number_a &gt; number_b:
      print(number_a)
   else:
      print(number_b)</pre>			<p>In this example, you can also see that lambda functions can contain multiple lines of code in the form of a code block, where each line has the same level of indentation.</p>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor713"/>Where to use lambda functions</h2>
			<p>So, where would we use lambda<a id="_idIndexMarker802"/> functions? Well, they are very useful in scenarios where you need a relatively small function but don’t want to have it as a permanent residence in the class.</p>
			<p>One great application of lambda functions is connecting signals. If we have a button for example, then we can connect to its pressed signal using a lambda function, as follows:</p>
			<pre class="source-code">
button.connect("pressed", <code>pressed</code> signal, our lambda function gets executed and prints out <code>Button pressed!</code>.</p>
			<p>Another one of its use cases are the <code>filter()</code> or <code>sort_custome()</code> functions that can use lambda function to filter or sort elements in an array:</p>
			<pre class="source-code">
[0, 1, 2, 3, 4].filter(func(number: int): return number % 2 == 0)
[0, 3, 2, 4, 1].sort_custome(func(number_a: int, number_b: int): return number_a &lt; number_b)</pre>			<p>Each array has the <code>filter()</code> and <code>sort_custome()</code> function that takes <code>Callable</code> as an argument. The <code>filter()</code> function will filter out any element within the array for which the function returns <code>false</code>, resulting<a id="_idIndexMarker803"/> in an array that only has the elements where the function returns <code>true</code>. In the preceding example, this results in an array with only even numbers.</p>
			<p>The <code>sort_custome()</code> function sorts the elements within the array using the <code>Callable</code> we provide it. The lambda function should take two elements and, when the first element should be sorted before the second element, return <code>true</code>; otherwise, it should return <code>false</code>. This way, we can define our own rules to sort an array’s elements.</p>
			<p>The resulting arrays after running <code>filter()</code> and <code>sort_custome()</code> with our lambda functions are as follows:</p>
			<pre class="source-code">
[0, 2, 4]
[0, 1, 2, 3, 4]</pre>			<p class="callout-heading">More information</p>
			<p class="callout">For more on lambda functions, check<a id="_idIndexMarker804"/> out the official documentation: <a href="https://docs.godotengine.org/en/stable/classes/class_callable.html">https://docs.godotengine.org/en/stable/classes/class_callable.html</a>.</p>
			<p>Now that we know what lambda functions are, let’s take a look at the different ways in which we can pass values to functions.</p>
			<h1 id="_idParaDest-319"><a id="_idTextAnchor714"/>Passing parameters by value or reference</h1>
			<p>When passing parameters to a function, there are actually two different ways in which these parameters can arrive at the body of that function – by value or reference. We, as programmers, do not choose which of the two is used; GDScript makes this decision based on the data type of the value we provide the function. Let’s take a deeper look into both the methods for passing values, which data types apply to each, and why it is important to know the difference.</p>
			<h2 id="_idParaDest-320"><a id="_idTextAnchor715"/>Passing by value</h2>
			<p>Passing by value means that GDScript <a id="_idIndexMarker805"/>sends over an exact copy of a value to a function. This approach is very simple and predictable because we get a new variable in the function that we called. However, because copying over data takes time, it can be quite slow for big data types.</p>
			<p>Data types that get passed by value are any of the simpler built-in data types, such as integers, floating point numbers, and Booleans. Some also slightly more complex classes such as strings, <code>Vector2</code>, and <code>Colors</code> are passed by value. This list is not exhaustive. The general rule of inclusion is anything that is not an array, not a dictionary, and not inherited from the <code>Object</code> class.</p>
			<p>Let’s see what passing by value looks like in practice:</p>
			<pre class="source-code">
func _ready():
   var number: int = 5
   print("Number before the function: ", number)
   function_taking_integers(number)
   print("Number after the function: ", number)
   var string: String = "Hello there!"
   print("String before the function: ", string)
   function_taking_strings(string)
   print("String after the function: ", string)
func function_taking_integers(number: int):
   number += 10
   print("Number during the function: ", number)
func function_taking_strings(string: String):
   string[0] = "W"
   print("String during the function: ", string)</pre>			<p>Here, you can see that we have two functions that take an integer and a string respectively, and each modify the value of the parameter during its execution. We also print out the value of this integer<a id="_idIndexMarker806"/> and string every step of the way, before, during, and after the function’s execution, to see whether the original variable, from the <code>_ready()</code> function, got altered. Running this will print out the following:</p>
			<pre class="source-code">
Number before the function: 5
Number during the function: 15
Number after the function: 5
String before the function: Hello there!
String during the function: Wello there!
String after the function: Hello there!</pre>			<p>We can see that, although the value got altered in some way during the function’s execution, the original value did not change. This is the fun of passing by value; we don’t need to worry about side effects.</p>
			<p class="callout-heading">Side effects of functions</p>
			<p class="callout">Side effects, in programmer lingo, mean that a function changes the state of a program in ways that are not directly apparent, altering variables outside of its scope. You want to avoid this as much as possible so that it is easy to understand what a function does.</p>
			<p>This is how passing by value works – just a straight copy of the data. Now, we’ll see the contrasting idea – passing by reference.</p>
			<h2 id="_idParaDest-321"><a id="_idTextAnchor716"/>Passing by reference</h2>
			<p>The other way to pass values to a function is by reference. This means that GDScript does not copy over the whole value but, rather, sends a reference that points toward the value. This reference points to where the actual value is stored and can be used to access and change it.</p>
			<p>This mode of passing parameters is used for<a id="_idIndexMarker807"/> arrays, dictionaries, and any class that inherits from the <code>Object</code> class, which includes all types of nodes. It is essentially used to pass bigger data types, as copying their complete value over would take too much time and slow down the execution of our game.</p>
			<p>Here’s an example of what passing by reference looks like:</p>
			<pre class="source-code">
func _ready():
   var dictionary: Dictionary = { "value": 5 }
   print("Dictionary before the function: ", dictionary)
   function_taking_dictionary(dictionary)
   print("Dictionary after the function: ", dictionary)
func function_taking_dictionary(dictionary: Dictionary):
   dictionary["a_value"] = "has changed"
   print("Dictionary during the function: ", dictionary)</pre>			<p>Again, we use the same setup as before to print out our dictionary every step of the way. We run the following code:</p>
			<pre class="source-code">
Dictionary before the function: { "value": 5 }
Dictionary during the function: { "value": 5, "a_value": "has changed" }
Dictionary after the function: { "value": 5, "a_value": "has changed" }</pre>			<p>As expected, we can see that after the function ran, the original dictionary from the <code>_ready()</code> function was altered too! This is a side effect in action.</p>
			<p>In general, it is good practice to <a id="_idIndexMarker808"/>never alter the values and variables that come into a function, and always make a copy or use them directly to calculate a value for another variable. When in doubt, it’s best to test out whether a value is passed by value or reference; this way, you never encounter unintended bugs.</p>
			<p class="callout-heading">Duplicating arrays or dictionaries</p>
			<p class="callout">If you really want to make a copy <a id="_idIndexMarker809"/>of an array or dictionary, then you can use the <code>duplicate()</code> function that is defined on these data types. This function will return a copy of the array or dictionary that you can alter safely.</p>
			<p class="callout">See the documentation for more details: <a href="https://docs.godotengine.org/fr/4.x/classes/class_array.html#class-array-method-duplicate">https://docs.godotengine.org/fr/4.x/classes/class_array.html#class-array-method-duplicate</a>.</p>
			<p>We’ll now switch gears and see how we can make tools for the editor from within the editor.</p>
			<h1 id="_idParaDest-322"><a id="_idTextAnchor717"/>The @tool annotation</h1>
			<p>As well as using GDScript to run code during our game’s execution, we can actually use it to run code in the editor itself. Running <a id="_idIndexMarker810"/>code within the editor grants us the power to visualize things, such as the jump height of a character, or automate our workflow. In doing so we extend the Godot editor for our own specific needs. There are multiple ways of running GDScript code within the editor, ranging from running separate scripts to writing whole plugins, but the easiest way is by using the <code>@</code><code>tool</code> annotation.</p>
			<p>The <code>@tool</code> annotation is an annotation that can be added to the top of any script. Its effect is that nodes with that script will run their script within the editor as if they were instanced within a game. This means that all of their code runs from within the editor.</p>
			<p>This is very useful when we are editing our scenes and want to preview things within the editor, such as the health of our player, or create new nodes using code.</p>
			<p>Knowing this, we can adjust our player script, by adding the <code>@tool</code> annotation to the top to update the health label in the editor:</p>
			<pre class="source-code">
@tool
class_name Player extends CharacterBody2D
const MAX_HEALTH: int = 10
@onready var _health_label: Label = $Health
@export var health: int = 10:
   set(new_value):
      health = new_value
      update_health_label()
func _ready():
   update_health_label()
func update_health_label():
   if not is_instance_valid(_health_label):
      return
   _health_label.text = str(health) + "/" + str(MAX_HEALTH)</pre>			<p>This example is the minimum amount of code needed to update the health label from within the editor. However, you<a id="_idIndexMarker811"/> can just add the <code>@tool</code> annotation at the top of your existing player script, and it will work its magic. You’ll see that every time you change the player’s health from within the editor now, the health label will automatically reflect this change.</p>
			<p class="callout-heading">The risks of @tool</p>
			<p class="callout">The <code>@tool</code> annotation is very powerful but not without danger. It can remove things permanently from a scene and easily<a id="_idIndexMarker812"/> change the values of nodes if you don’t watch out, so treat it with caution.</p>
			<p>However, sometimes you want to use a node in a game and have some code that runs in the editor. When we do that, we need a way to distinguish whether the code is run in the game or the editor. This can<a id="_idIndexMarker813"/> be done by using <code>Engine.is_editor_hint()</code>. This function on the global <code>Engine</code> object returns <code>true</code> if we run the code from within the editor and <code>false</code> when from within the game:</p>
			<pre class="source-code">
if Engine.is_editor_hint():
   # Code to execute in editor.
if not Engine.is_editor_hint():
   # Code to execute in game.</pre>			<p>This code example shows us how easy it is to differentiate between running code in the editor or the game.</p>
			<p class="callout-heading">More information</p>
			<p class="callout">Want to know more about the <code>@tool</code> annotation and running code within the editor? Check out the official <a id="_idIndexMarker814"/>documentation: <a href="https://docs.godotengine.org/en/stable/tutorials/plugins/running_code_in_the_editor.html">https://docs.godotengine.org/en/stable/tutorials/plugins/running_code_in_the_editor.html</a>.</p>
			<p>Using the <code>@tool</code> annotation wisely, we can make our workflow easier and faster. The possibilities are endless; you can even access and change almost every aspect of the Godot editor from within one of these scripts, but that is out of the scope of this book.</p>
			<h1 id="_idParaDest-323"><a id="_idTextAnchor718"/>Summary</h1>
			<p>This chapter took a deeper dive into some of the more advanced topics of programming with GDScript. We expanded our knowledge of object-oriented programming with the <code>super</code> and <code>static</code> keywords and the difference between passing by value or reference. Then, we saw more features of the GDScript programming language, such as enums and lambda functions. We concluded the chapter with a way to run code within the Godot editor itself, u<a id="_idTextAnchor719"/>sing the <code>@</code><code>tool</code> annotation.</p>
			<h1 id="_idParaDest-324"><a id="_idTextAnchor720"/>Quiz time</h1>
			<ul>
				<li>Imagine we have a class named <code>Character</code> that has a function called <code>move()</code>. Now, we create a <code>Player</code> class that inherits from this <code>Character</code> class and overrides this <code>move()</code> function. But, instead of completely overriding it, we want to extend the original functionality of the <code>Character</code> class’s <code>move()</code> function. What keyword can we use to call the original <code>move()</code> function of the <code>Character</code> class from within the <code>Player</code> class?</li>
				<li>Can functions that are labeled <code>static</code> call functions that are not labeled <code>static</code>?</li>
				<li>What will the following snippet of code print out?<pre class="source-code">
enum COLLECTIBLE_TYPE {
   HEALTH,
   UPGRADE,
   DAMAGE,
}
print(COLLECTIBLE_TYPES.DAMAGE)</pre></li>				<li>Are container types, such as arrays and dictionaries, the only types that get passed by reference?</li>
				<li>What annotation do we use at the top of a script if we want to run it in the editor?</li>
			</ul>
		</div>
	</body></html>