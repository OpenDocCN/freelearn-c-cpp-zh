- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Utilizing a Rich Static Type System in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In modern software development, the notion of “type” has transcended its primitive
    definition, evolving into a rich and expressive language feature that encapsulates
    more than just data representation. In C++, a language renowned for its performance
    and flexibility, the static type system serves as a powerful tool, enabling developers
    to write code that’s not only robust and efficient but also self-documenting and
    maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: The significance of types in C++ extends beyond the mere categorization of data.
    By enforcing strict compile-time checks, the language’s type system reduces runtime
    errors, improves readability, and fosters a more intuitive understanding of code.
    With the advent of modern C++ standards, the opportunities to leverage types have
    further expanded, bringing forth elegant solutions to common programming challenges.
  prefs: []
  type: TYPE_NORMAL
- en: However, these powerful features can often be underutilized. Primitive data
    types such as integers are frequently misused to represent concepts such as time
    durations, leading to code that lacks expressiveness and can be prone to errors.
    Pointers, although flexible, can lead to null dereferencing issues, making the
    code base fragile.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore the rich landscape of C++’s static type system,
    focusing on advanced and modern techniques that help to mitigate these problems.
    From using the `<chrono>` library to represent time durations to employing `not_null`
    wrappers and `std::optional` for safer pointer handling, we’ll delve into practices
    that embody the essence of strong typing.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also look at external libraries such as Boost, which offer additional
    utilities to enhance type safety. Throughout the chapter, real-world examples
    will illustrate how these tools and techniques can be seamlessly integrated into
    your code, empowering you to harness the full potential of C++’s type system.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll gain a deep understanding of how to utilize
    types to write more robust, readable, and expressive code, tapping into the true
    power of C++.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing Chrono for time duration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the best examples of how C++’s type system can be leveraged to write
    more robust code is the `<chrono>` library. Introduced in C++11, this header provides
    a set of utilities to represent time durations and points in time, as well as
    perform time-related operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Managing time-related functions using plain integers or structures such as
    `timespec` can be a bug-prone approach, especially when dealing with different
    units of time. Imagine a function that takes an integer representing a timeout
    in seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This approach lacks flexibility and can lead to confusion when handling various
    time units. For example, if a caller mistakenly passes milliseconds instead of
    seconds, it can cause unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, using `<chrono>` to define the same function makes the code more
    robust and expressive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The caller can now pass the timeout using a strongly-typed duration, such as
    `std::chrono::seconds(5)`, and the compiler ensures that the correct unit is used.
    Moreover, `<chrono>` provides seamless conversion between different time units,
    allowing the caller to specify the timeout in seconds, milliseconds, or any other
    unit, without ambiguity. The following snippet illustrates the usage with different
    units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By embracing the strong typing offered by `<chrono>`, the code becomes clearer,
    more maintainable, and less susceptible to common bugs related to time representation.
  prefs: []
  type: TYPE_NORMAL
- en: Improving Pointer Safety with not_null and std::optional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++, pointers are a fundamental part of the language, allowing direct memory
    access and manipulation. However, the flexibility that pointers offer comes with
    certain risks and challenges. Here, we’ll explore how modern C++ techniques can
    enhance pointer safety.
  prefs: []
  type: TYPE_NORMAL
- en: The pitfalls of raw pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Raw pointers, while powerful, can be a double-edged sword. They provide no information
    about the ownership of the object they point to, and they can easily become “dangling”
    pointers, pointing to memory that has been deallocated. Dereferencing a null or
    dangling pointer leads to undefined behavior, which can result in hard-to-diagnose
    bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Using not_null from the Guidelines Support Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `not_null` wrapper provided by the `not_null`, you can clearly signal that
    a pointer should never be null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If a user passes a null pointer to this function as follows, the application
    will be terminated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the pointer is passed as `process_data(nullptr)`, the application
    will fail in compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This promotes robust code by catching potential null pointer errors early, thus
    reducing runtime errors.
  prefs: []
  type: TYPE_NORMAL
- en: Extending not_null to smart pointers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`gsl::not_null` is not limited to raw pointers; it can also be used with smart
    pointers such as `std::unique_ptr` and `std::shared_ptr`. This allows you to combine
    the benefits of modern memory management with the additional safety guarantees
    that `not_null` provides.'
  prefs: []
  type: TYPE_NORMAL
- en: With std::unique_ptr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`std::unique_ptr` ensures that the ownership of a dynamically allocated object
    is unique, and it automatically deletes the object when it is no longer needed.
    By using `not_null` with `unique_ptr`, you can also ensure that the pointer is
    never null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With std::shared_ptr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similarly, `gsl::not_null` can be used with `std::shared_ptr`, which enables
    shared ownership of an object. This allows you to write functions that accept
    shared pointers without having to worry about nullity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: These examples demonstrate how `not_null` can seamlessly integrate with modern
    C++ memory management techniques. By enforcing that a pointer (whether raw or
    smart) cannot be null, you further reduce the potential for runtime errors and
    make code more robust and expressive.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing std::optional for optional values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, a pointer is used to indicate an optional value, where `nullptr`
    signifies the absence of a value. C++17 introduced `std::optional`, which provides
    a type-safe way to represent optional values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using `std::optional` provides clear semantics and avoids the pitfalls associated
    with using pointers for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: A comparison between raw pointers and nullptr
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both `not_null` and `std::optional` offer advantages over raw pointers. While
    raw pointers can be null or dangling, leading to undefined behavior, `not_null`
    prevents null pointer errors at compile time, and `std::optional` provides a clear
    way to represent optional values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example using raw pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This code might lead to confusion and bugs, especially if the caller forgets
    to check for `nullptr`. By using `not_null` and `std::optional`, you can make
    the code more expressive and less error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging std::expected for expected results and errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While `std::optional` elegantly represents an optional value, sometimes you
    need to convey more information about why a value might be missing. In such cases,
    `std::expected` provides a way to return either a value or an error code, making
    code more expressive and the error handling more robust.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a scenario where you have a function that retrieves a value from a
    network, and you want to handle network errors. You might define an enumeration
    for the various network errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then use `std::expected` to define a function that returns either an
    `int` value or `NetworkError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, `std::expected` captures both the successful case and various error scenarios,
    allowing for clear and type-safe error handling. This example illustrates how
    modern C++ types such as `std::expected` enhance expressiveness and safety, allowing
    you to write code that more accurately models complex operations.
  prefs: []
  type: TYPE_NORMAL
- en: By embracing these modern C++ tools, you can enhance pointer safety in your
    code, reducing bugs and making your intentions clear.
  prefs: []
  type: TYPE_NORMAL
- en: Strong typing with enum class and scoped enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strong typing is a cornerstone of robust, maintainable software, and C++ provides
    several mechanisms to facilitate it. Among these, `enum class`, introduced in
    C++11, is a particularly effective tool for creating strongly typed enumerations
    that can make your programs both more robust and easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: A review of enum class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Traditional enumerations in C++ suffer from a few limitations – they can implicitly
    convert to integers, potentially causing errors if misused, and their enumerators
    are introduced into the enclosing scope, leading to name clashes. `enum class`,
    also known as scoped enumerations, addresses these limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The benefits over traditional enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scoped enumerations offer several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`enum class` type and integers, ensuring that you can’t accidentally misuse
    an enumerator as an integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enum class`, reducing the likelihood of name collisions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enum class` allows you to explicitly specify the underlying type, giving you
    precise control over the data representation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The ability to specify the underlying type is particularly useful for serializing
    data to binary formats. It ensures that you have fine-grained control over how
    the data is represented at the byte level, facilitating easier data interchange
    with systems that may have specific binary format requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world scenarios
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The advantages of `enum class` make it a powerful tool for various scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '`enum class` provides a type-safe, expressive way to represent various possible
    states'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Option sets**: Many functions have multiple behavior options, which can be
    neatly and safely encapsulated using scoped enumerations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enum class`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By using `enum class` to create strongly typed, scoped enumerations, you can
    write code that is not only easier to understand but also less prone to errors.
    This feature represents another step forward in C++’s ongoing evolution toward
    a language that combines high performance with modern programming conveniences.
    Whether you’re defining a complex state machine or simply trying to represent
    multiple options or statuses, `enum class` offers a robust, type-safe solution.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the standard library’s type utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern C++ offers a rich set of type utilities within the Standard library that
    enables developers to write more expressive, type-safe, and maintainable code.
    Two prominent examples are `std::variant` and `std::any`.
  prefs: []
  type: TYPE_NORMAL
- en: std::variant – a type-safe union
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::variant` provides a type-safe way to represent a value that can be one
    of several possible types. Unlike a traditional `union`, which allows the programmer
    to treat the stored value as any of its member types, leading to potential undefined
    behavior, `std::variant` tracks the currently held type and ensures proper handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The benefits over traditional unions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`std::variant`, conversely, keeps track of the current type and provides safe
    access through functions such as `std::get` and `std::holds_alternative`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::variant` automatically constructs and destroys the held object when you
    assign a new value, managing the object’s lifetime correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::get`, a `std::bad_variant_access` exception is thrown, making error handling
    more transparent and easier to manage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::variant` can be used with standard library functions such as `std::visit`,
    providing elegant ways to handle various types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::any – type-safe containers for any type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::any` is a container that can hold any type but maintains type safety
    by requiring explicit casting to the correct type. This allows for flexible handling
    of data without sacrificing type integrity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The advantages of using `std::any` include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flexibility**: It can store any type, making it suitable for heterogeneous
    collections or flexible APIs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type safety**: Requires explicit casting, preventing accidental misinterpretation
    of the contained value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encapsulation**: Allows you to pass around values without exposing their
    concrete types, supporting more modular and maintainable code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced type techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you delve deeper into C++, you’ll find that the language offers an array
    of advanced techniques for enhancing type safety, readability, and maintainability.
    In this section, we’ll explore a few of these advanced concepts, providing practical
    examples for each.
  prefs: []
  type: TYPE_NORMAL
- en: Templates – specializing for type safety
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Templates are a powerful feature in C++, but you may want to impose certain
    constraints or specializations based on types. One way to do this is via template
    specialization, which allows you to define custom behavior for certain types.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say you have a generic function to find the maximum element
    in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s say you want to provide a specialized implementation for `std::string`
    that is case-insensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this specialized version, calls to `find_max` with `std::string` will use
    a case-insensitive comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom type traits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, the standard type traits may not be sufficient for your needs. You
    can create your own custom type traits to encapsulate type-based logic. For instance,
    you might want a type trait to identify whether a class has a specific member
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use this custom trait like any other type trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Type aliases for readability and maintainability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Type aliases can improve the readability and maintainability of your code by
    providing meaningful names for complex types. For example, instead of writing
    out `std::unordered_map<std::string, std::vector<int>>` repeatedly, you could
    create a type alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can use `StringToIntVectorMap` in your code, making it more readable
    and easier to maintain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Type aliases can also be templated, allowing for even more flexibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: By employing these advanced type techniques, you add another layer of safety,
    readability, and maintainability to your C++ code. These methods give you more
    control over how types behave in templates, how they’re checked, and how they’re
    represented, ensuring that you can write code that’s as robust as it is efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding common pitfalls in advanced type usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing robust code with type checks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type-checking is one of the pillars that contributes to the robustness and safety
    of a program. While C++ is strongly typed, it does allow for some flexibility
    (or leniency, depending on your perspective) that can lead to errors if not carefully
    managed. Here are some techniques and best practices to write robust C++ code
    by leveraging type checks.
  prefs: []
  type: TYPE_NORMAL
- en: Using type traits for compile-time checks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The C++ Standard library offers a set of type traits in the `<type_traits>`
    header, which allows you to inspect and make decisions based on types at compile
    time. For example, if you have a generic function that should only accept unsigned
    integral types, you can enforce this using `static_assert`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Leveraging constexpr if
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C++17 introduced `constexpr if`, enabling you to write conditional code that’s
    evaluated at compile time. This can be very useful for type-specific operations
    in template code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Strong types for function arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C++ allows type aliases, which can sometimes make it difficult to understand
    the purpose of a function argument. For example, a function declared as `void
    process(int, int);` is not very informative. Is the first integer a length? Is
    the second one an index? One way to mitigate this is by using strong type definitions,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, the function signature provides semantic meaning, making it less likely
    for the developer to swap the arguments accidentally.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit conversions and type coercion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A case of accidental file creation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In C++ development, it’s common to define classes with constructors that accept
    various argument types for flexibility. However, this comes with the risk of unintentional
    implicit conversions. To illustrate this point, consider the following code snippet
    involving a `File` class and a `clean` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output demonstrates the issue clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The compiler automatically converts `std::string` to a `File` object due to
    the absence of the `explicit` keyword in the constructor, thereby triggering an
    unintended side-effect – the creation of a new file.
  prefs: []
  type: TYPE_NORMAL
- en: The utility of explicit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To mitigate such risks, the `explicit` keyword can be employed. By marking
    a constructor as `explicit`, you instruct the compiler to disallow implicit conversions
    for that constructor. Here’s how the corrected `File` class would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With this change, the `clean(random_string);` line would result in a compilation
    error, effectively preventing accidental file creation.
  prefs: []
  type: TYPE_NORMAL
- en: A light-hearted caveat
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our example might be somewhat simplified for educational purposes (yes,
    there’s no need to roll your own `File` class – we have libraries for that!),
    it serves to underline a critical aspect of type safety in C++. A seemingly innocuous
    constructor can lead to unexpected behavior if not explicitly guarded against
    implicit conversions.
  prefs: []
  type: TYPE_NORMAL
- en: So, remember, when you’re defining constructors, it pays to be explicit about
    your intentions. You never know when you might accidentally start a “file party”
    you never intended to host.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we’ve traversed the vast landscape of C++’s rich static type system, it’s
    worth taking a moment to reflect on how far we’ve come. From the earliest days
    of C++, where raw pointers and loosely typed arrays reigned supreme, to the modern
    era of `std::optional`, `std::variant`, and `enum class`, the language has evolved
    substantially in its approach to type safety.
  prefs: []
  type: TYPE_NORMAL
- en: The real power of these advances shines through when we consider how they improve
    not just individual code snippets but also entire software systems. Embracing
    C++’s robust type constructs can help us write safer, more readable, and ultimately,
    more maintainable code. Features such as the `std::optional` and `not_null` wrappers
    reduce the chance of null pointer errors. Advanced techniques such as template
    specialization and custom type traits offer unprecedented control over type behavior.
    These are not just academic exercises; they are practical tools for the everyday
    C++ programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Looking ahead, the trajectory of C++ suggests an increasingly nuanced and powerful
    type system. As the language continues to evolve, who knows what innovative type-related
    features may lie on the horizon? Perhaps future versions of C++ will offer even
    more dynamic type checking, or maybe they’ll introduce new constructs that we
    can’t yet imagine.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll pivot from the nitty-gritty of types to the grand
    architecture of classes, objects, and object-oriented programming in C++. While
    types give us the building blocks, it’s these larger constructs that help us assemble
    those blocks into towering structures of sustainable software design. Until then,
    may your types be strong, your pointers never null, and your code forever robust.
  prefs: []
  type: TYPE_NORMAL
