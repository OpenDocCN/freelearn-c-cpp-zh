- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Utilizing a Rich Static Type System in C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In modern software development, the notion of “type” has transcended its primitive
    definition, evolving into a rich and expressive language feature that encapsulates
    more than just data representation. In C++, a language renowned for its performance
    and flexibility, the static type system serves as a powerful tool, enabling developers
    to write code that’s not only robust and efficient but also self-documenting and
    maintainable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The significance of types in C++ extends beyond the mere categorization of data.
    By enforcing strict compile-time checks, the language’s type system reduces runtime
    errors, improves readability, and fosters a more intuitive understanding of code.
    With the advent of modern C++ standards, the opportunities to leverage types have
    further expanded, bringing forth elegant solutions to common programming challenges.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: However, these powerful features can often be underutilized. Primitive data
    types such as integers are frequently misused to represent concepts such as time
    durations, leading to code that lacks expressiveness and can be prone to errors.
    Pointers, although flexible, can lead to null dereferencing issues, making the
    code base fragile.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore the rich landscape of C++’s static type system,
    focusing on advanced and modern techniques that help to mitigate these problems.
    From using the `<chrono>` library to represent time durations to employing `not_null`
    wrappers and `std::optional` for safer pointer handling, we’ll delve into practices
    that embody the essence of strong typing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also look at external libraries such as Boost, which offer additional
    utilities to enhance type safety. Throughout the chapter, real-world examples
    will illustrate how these tools and techniques can be seamlessly integrated into
    your code, empowering you to harness the full potential of C++’s type system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll gain a deep understanding of how to utilize
    types to write more robust, readable, and expressive code, tapping into the true
    power of C++.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing Chrono for time duration
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the best examples of how C++’s type system can be leveraged to write
    more robust code is the `<chrono>` library. Introduced in C++11, this header provides
    a set of utilities to represent time durations and points in time, as well as
    perform time-related operations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Managing time-related functions using plain integers or structures such as
    `timespec` can be a bug-prone approach, especially when dealing with different
    units of time. Imagine a function that takes an integer representing a timeout
    in seconds:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This approach lacks flexibility and can lead to confusion when handling various
    time units. For example, if a caller mistakenly passes milliseconds instead of
    seconds, it can cause unexpected behavior.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, using `<chrono>` to define the same function makes the code more
    robust and expressive:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The caller can now pass the timeout using a strongly-typed duration, such as
    `std::chrono::seconds(5)`, and the compiler ensures that the correct unit is used.
    Moreover, `<chrono>` provides seamless conversion between different time units,
    allowing the caller to specify the timeout in seconds, milliseconds, or any other
    unit, without ambiguity. The following snippet illustrates the usage with different
    units:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By embracing the strong typing offered by `<chrono>`, the code becomes clearer,
    more maintainable, and less susceptible to common bugs related to time representation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Improving Pointer Safety with not_null and std::optional
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++, pointers are a fundamental part of the language, allowing direct memory
    access and manipulation. However, the flexibility that pointers offer comes with
    certain risks and challenges. Here, we’ll explore how modern C++ techniques can
    enhance pointer safety.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The pitfalls of raw pointers
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Raw pointers, while powerful, can be a double-edged sword. They provide no information
    about the ownership of the object they point to, and they can easily become “dangling”
    pointers, pointing to memory that has been deallocated. Dereferencing a null or
    dangling pointer leads to undefined behavior, which can result in hard-to-diagnose
    bugs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Using not_null from the Guidelines Support Library
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `not_null` wrapper provided by the `not_null`, you can clearly signal that
    a pointer should never be null:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If a user passes a null pointer to this function as follows, the application
    will be terminated:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, if the pointer is passed as `process_data(nullptr)`, the application
    will fail in compile time:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This promotes robust code by catching potential null pointer errors early, thus
    reducing runtime errors.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Extending not_null to smart pointers
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`gsl::not_null` is not limited to raw pointers; it can also be used with smart
    pointers such as `std::unique_ptr` and `std::shared_ptr`. This allows you to combine
    the benefits of modern memory management with the additional safety guarantees
    that `not_null` provides.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: With std::unique_ptr
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`std::unique_ptr` ensures that the ownership of a dynamically allocated object
    is unique, and it automatically deletes the object when it is no longer needed.
    By using `not_null` with `unique_ptr`, you can also ensure that the pointer is
    never null:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With std::shared_ptr
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similarly, `gsl::not_null` can be used with `std::shared_ptr`, which enables
    shared ownership of an object. This allows you to write functions that accept
    shared pointers without having to worry about nullity:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These examples demonstrate how `not_null` can seamlessly integrate with modern
    C++ memory management techniques. By enforcing that a pointer (whether raw or
    smart) cannot be null, you further reduce the potential for runtime errors and
    make code more robust and expressive.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing std::optional for optional values
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, a pointer is used to indicate an optional value, where `nullptr`
    signifies the absence of a value. C++17 introduced `std::optional`, which provides
    a type-safe way to represent optional values:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using `std::optional` provides clear semantics and avoids the pitfalls associated
    with using pointers for this purpose.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: A comparison between raw pointers and nullptr
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both `not_null` and `std::optional` offer advantages over raw pointers. While
    raw pointers can be null or dangling, leading to undefined behavior, `not_null`
    prevents null pointer errors at compile time, and `std::optional` provides a clear
    way to represent optional values.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example using raw pointers:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code might lead to confusion and bugs, especially if the caller forgets
    to check for `nullptr`. By using `not_null` and `std::optional`, you can make
    the code more expressive and less error-prone.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging std::expected for expected results and errors
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While `std::optional` elegantly represents an optional value, sometimes you
    need to convey more information about why a value might be missing. In such cases,
    `std::expected` provides a way to return either a value or an error code, making
    code more expressive and the error handling more robust.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a scenario where you have a function that retrieves a value from a
    network, and you want to handle network errors. You might define an enumeration
    for the various network errors:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can then use `std::expected` to define a function that returns either an
    `int` value or `NetworkError`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, `std::expected` captures both the successful case and various error scenarios,
    allowing for clear and type-safe error handling. This example illustrates how
    modern C++ types such as `std::expected` enhance expressiveness and safety, allowing
    you to write code that more accurately models complex operations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: By embracing these modern C++ tools, you can enhance pointer safety in your
    code, reducing bugs and making your intentions clear.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Strong typing with enum class and scoped enumerations
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strong typing is a cornerstone of robust, maintainable software, and C++ provides
    several mechanisms to facilitate it. Among these, `enum class`, introduced in
    C++11, is a particularly effective tool for creating strongly typed enumerations
    that can make your programs both more robust and easier to understand.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: A review of enum class
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Traditional enumerations in C++ suffer from a few limitations – they can implicitly
    convert to integers, potentially causing errors if misused, and their enumerators
    are introduced into the enclosing scope, leading to name clashes. `enum class`,
    also known as scoped enumerations, addresses these limitations:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The benefits over traditional enums
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scoped enumerations offer several advantages:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '`enum class` type and integers, ensuring that you can’t accidentally misuse
    an enumerator as an integer'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enum class`, reducing the likelihood of name collisions'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enum class` allows you to explicitly specify the underlying type, giving you
    precise control over the data representation:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The ability to specify the underlying type is particularly useful for serializing
    data to binary formats. It ensures that you have fine-grained control over how
    the data is represented at the byte level, facilitating easier data interchange
    with systems that may have specific binary format requirements.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Real-world scenarios
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The advantages of `enum class` make it a powerful tool for various scenarios:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '`enum class` provides a type-safe, expressive way to represent various possible
    states'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Option sets**: Many functions have multiple behavior options, which can be
    neatly and safely encapsulated using scoped enumerations'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enum class`:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By using `enum class` to create strongly typed, scoped enumerations, you can
    write code that is not only easier to understand but also less prone to errors.
    This feature represents another step forward in C++’s ongoing evolution toward
    a language that combines high performance with modern programming conveniences.
    Whether you’re defining a complex state machine or simply trying to represent
    multiple options or statuses, `enum class` offers a robust, type-safe solution.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the standard library’s type utilities
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern C++ offers a rich set of type utilities within the Standard library that
    enables developers to write more expressive, type-safe, and maintainable code.
    Two prominent examples are `std::variant` and `std::any`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: std::variant – a type-safe union
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::variant` provides a type-safe way to represent a value that can be one
    of several possible types. Unlike a traditional `union`, which allows the programmer
    to treat the stored value as any of its member types, leading to potential undefined
    behavior, `std::variant` tracks the currently held type and ensures proper handling:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The benefits over traditional unions
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`std::variant`, conversely, keeps track of the current type and provides safe
    access through functions such as `std::get` and `std::holds_alternative`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::variant` automatically constructs and destroys the held object when you
    assign a new value, managing the object’s lifetime correctly.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::get`, a `std::bad_variant_access` exception is thrown, making error handling
    more transparent and easier to manage.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::variant` can be used with standard library functions such as `std::visit`,
    providing elegant ways to handle various types.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::any – type-safe containers for any type
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::any` is a container that can hold any type but maintains type safety
    by requiring explicit casting to the correct type. This allows for flexible handling
    of data without sacrificing type integrity:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The advantages of using `std::any` include the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '**Flexibility**: It can store any type, making it suitable for heterogeneous
    collections or flexible APIs'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type safety**: Requires explicit casting, preventing accidental misinterpretation
    of the contained value'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encapsulation**: Allows you to pass around values without exposing their
    concrete types, supporting more modular and maintainable code'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced type techniques
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you delve deeper into C++, you’ll find that the language offers an array
    of advanced techniques for enhancing type safety, readability, and maintainability.
    In this section, we’ll explore a few of these advanced concepts, providing practical
    examples for each.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Templates – specializing for type safety
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Templates are a powerful feature in C++, but you may want to impose certain
    constraints or specializations based on types. One way to do this is via template
    specialization, which allows you to define custom behavior for certain types.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say you have a generic function to find the maximum element
    in an array:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let’s say you want to provide a specialized implementation for `std::string`
    that is case-insensitive:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this specialized version, calls to `find_max` with `std::string` will use
    a case-insensitive comparison.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom type traits
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, the standard type traits may not be sufficient for your needs. You
    can create your own custom type traits to encapsulate type-based logic. For instance,
    you might want a type trait to identify whether a class has a specific member
    function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can use this custom trait like any other type trait:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Type aliases for readability and maintainability
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Type aliases can improve the readability and maintainability of your code by
    providing meaningful names for complex types. For example, instead of writing
    out `std::unordered_map<std::string, std::vector<int>>` repeatedly, you could
    create a type alias:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, you can use `StringToIntVectorMap` in your code, making it more readable
    and easier to maintain:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Type aliases can also be templated, allowing for even more flexibility:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: By employing these advanced type techniques, you add another layer of safety,
    readability, and maintainability to your C++ code. These methods give you more
    control over how types behave in templates, how they’re checked, and how they’re
    represented, ensuring that you can write code that’s as robust as it is efficient.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding common pitfalls in advanced type usage
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing robust code with type checks
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type-checking is one of the pillars that contributes to the robustness and safety
    of a program. While C++ is strongly typed, it does allow for some flexibility
    (or leniency, depending on your perspective) that can lead to errors if not carefully
    managed. Here are some techniques and best practices to write robust C++ code
    by leveraging type checks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Using type traits for compile-time checks
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The C++ Standard library offers a set of type traits in the `<type_traits>`
    header, which allows you to inspect and make decisions based on types at compile
    time. For example, if you have a generic function that should only accept unsigned
    integral types, you can enforce this using `static_assert`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Leveraging constexpr if
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C++17 introduced `constexpr if`, enabling you to write conditional code that’s
    evaluated at compile time. This can be very useful for type-specific operations
    in template code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Strong types for function arguments
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C++ allows type aliases, which can sometimes make it difficult to understand
    the purpose of a function argument. For example, a function declared as `void
    process(int, int);` is not very informative. Is the first integer a length? Is
    the second one an index? One way to mitigate this is by using strong type definitions,
    such as the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, the function signature provides semantic meaning, making it less likely
    for the developer to swap the arguments accidentally.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Implicit conversions and type coercion
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A case of accidental file creation
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In C++ development, it’s common to define classes with constructors that accept
    various argument types for flexibility. However, this comes with the risk of unintentional
    implicit conversions. To illustrate this point, consider the following code snippet
    involving a `File` class and a `clean` function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output demonstrates the issue clearly:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The compiler automatically converts `std::string` to a `File` object due to
    the absence of the `explicit` keyword in the constructor, thereby triggering an
    unintended side-effect – the creation of a new file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The utility of explicit
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To mitigate such risks, the `explicit` keyword can be employed. By marking
    a constructor as `explicit`, you instruct the compiler to disallow implicit conversions
    for that constructor. Here’s how the corrected `File` class would look:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With this change, the `clean(random_string);` line would result in a compilation
    error, effectively preventing accidental file creation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: A light-hearted caveat
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our example might be somewhat simplified for educational purposes (yes,
    there’s no need to roll your own `File` class – we have libraries for that!),
    it serves to underline a critical aspect of type safety in C++. A seemingly innocuous
    constructor can lead to unexpected behavior if not explicitly guarded against
    implicit conversions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: So, remember, when you’re defining constructors, it pays to be explicit about
    your intentions. You never know when you might accidentally start a “file party”
    you never intended to host.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we’ve traversed the vast landscape of C++’s rich static type system, it’s
    worth taking a moment to reflect on how far we’ve come. From the earliest days
    of C++, where raw pointers and loosely typed arrays reigned supreme, to the modern
    era of `std::optional`, `std::variant`, and `enum class`, the language has evolved
    substantially in its approach to type safety.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The real power of these advances shines through when we consider how they improve
    not just individual code snippets but also entire software systems. Embracing
    C++’s robust type constructs can help us write safer, more readable, and ultimately,
    more maintainable code. Features such as the `std::optional` and `not_null` wrappers
    reduce the chance of null pointer errors. Advanced techniques such as template
    specialization and custom type traits offer unprecedented control over type behavior.
    These are not just academic exercises; they are practical tools for the everyday
    C++ programmer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑这些进步如何不仅改进单个代码片段，而且改进整个软件系统时，这些进步的真实力量才会显现出来。拥抱 C++ 的强大类型结构可以帮助我们编写更安全、更易读、最终更易于维护的代码。例如，`std::optional`
    和 `not_null` 包装器可以减少空指针错误的可能性。高级技术，如模板特化和自定义类型特性，提供了对类型行为的无与伦比的控制。这些不仅仅是学术练习；它们是日常
    C++ 程序员的实际工具。
- en: Looking ahead, the trajectory of C++ suggests an increasingly nuanced and powerful
    type system. As the language continues to evolve, who knows what innovative type-related
    features may lie on the horizon? Perhaps future versions of C++ will offer even
    more dynamic type checking, or maybe they’ll introduce new constructs that we
    can’t yet imagine.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，C++ 的轨迹表明类型系统将变得更加精细和强大。随着语言不断发展，谁知道未来版本的 C++ 将会带来哪些创新类型相关的特性？也许未来的 C++
    将提供更动态的类型检查，或者它们可能会引入我们目前还无法想象的新的结构。
- en: In the next chapter, we’ll pivot from the nitty-gritty of types to the grand
    architecture of classes, objects, and object-oriented programming in C++. While
    types give us the building blocks, it’s these larger constructs that help us assemble
    those blocks into towering structures of sustainable software design. Until then,
    may your types be strong, your pointers never null, and your code forever robust.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从类型的基础知识转向 C++ 中类、对象和面向对象编程的宏伟架构。虽然类型为我们提供了构建块，但正是这些更大的结构帮助我们将这些块组装成可持续的软件设计的摩天大楼。在此之前，愿你的类型强大，指针永不空，代码永远稳健。
