- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an Online Adventure Prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore the fascinating world of an online space adventure
    game that has the potential to evolve into a **massive multiplayer online role-playing
    game** (**MMORPG**). Throughout this journey, we will lay the foundations for
    an immersive gaming experience, allowing players to join a persistent world and
    seamlessly synchronize their game state with the current state of the game world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a snapshot of what the final spaceshooter adventure prototype will look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Two players accomplishing the Destroy 10 Asteroids quest together](img/Figure_09.01_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Two players accomplishing the Destroy 10 Asteroids quest together
  prefs: []
  type: TYPE_NORMAL
- en: Our primary focus will be building a robust networking system that facilitates
    real-time interaction among players by using the powerful Godot Engine Network
    API. Through this system, players will connect to a central server, ensuring that
    everyone shares the same game world and can witness each other’s actions, promoting
    collaboration and a sense of togetherness.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we will dive into the creation of a dynamic quest system capable
    of tracking player progress and storing this data in a database, so that when
    players come back, they will maintain their progress. Within our prototype of
    a space adventure, players will collaborate to complete missions such as destroying
    asteroids.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start the chapter by understanding the role of each piece of our game:
    the asteroids, the spaceship, and the player scene. Then, we will move to the
    core feature of an adventure game, the quest system, where we are going to learn
    how to pull and push data to the server and what builds up this robust system
    from both the server’s and player’s perspectives.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging the player in to the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating server and client responsibilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving data on the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid foundation for an online adventure
    game that can expand into a vast and captivating MMORPG. Equipped with a persistent
    world, synchronized gameplay, and a quest system, you will be well prepared to
    build an engaging and dynamic online gaming experience.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To access the resources for this chapter, go to our online project’s repository
    found at [https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0).
  prefs: []
  type: TYPE_NORMAL
- en: With the repository in your computer, open the `res://09.prototyping-space-adventure`
    folder in the Godot Engine editor. You will find all the necessary files for this
    chapter there.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us begin the onboarding process. In the next section, we will introduce
    the project, explore its main classes, and identify where we need to implement
    networking features.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will gain a comprehensive understanding of the core systems
    driving our prototype. As the network engineers of our fictional studio, our role
    is core in transforming our local game prototype into an exciting online multiplayer
    game prototype. To accomplish this, we must familiarize ourselves with the major
    classes and files that make up our project.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s not overlook the significance of the onboarding process when we join a
    project. As network engineers, applying our knowledge and insights is essential
    for seamless integration into the development process. By understanding the core
    systems and concepts, we create a collaborative and productive environment, empowering
    the team to collectively bring our vision to life.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s dive into the heart of our prototype and unlock the potential of online
    multiplayer gaming. By the end of this section, you will be equipped with the
    necessary systems you can tweak to shape an immersive and engaging online experience,
    uniting players in a dynamic and interconnected world. In the next section, let’s
    understand how the `Player` class and scene work.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Player scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In any game, the player’s avatar is a fundamental element of the player’s experience.
    In this section, our goal is to understand the composition of the `Player` scene,
    the scene that represents the player’s avatar in our prototype.
  prefs: []
  type: TYPE_NORMAL
- en: The `Player` scene is an abstract representation of the player as an entity
    in the game. It is a Node2D class that has a `Spaceship` scene, a `Weapon2D` scene,
    a `Sprite2D` node, a `HurtArea2D` node, a `CameraRemoteTransform2D` node, and,
    of course, the `Camera2D` node.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.2 – The Player scene \uFEFFnode’s hierarchy](img/Figure_09.02_B18527.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – The Player scene node’s hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s understand the role of the main components of this scene, namely
    the `Spaceship` and `Weapon2D` nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Spaceship` node is a direct child of `Player` node and carries most of
    the other components, with the exception of the `Camera2D` node; instead, it uses
    the `CameraRemoteTransform2D` node to remotely transform the `Camera2D` node.
    The `Spaceship` node is a RigidBody2D node that simulates the movement of a body
    within an environment with no gravity and very low friction. It has two main methods,
    `Spaceship.thrust()` and `Spaceship.turn()`. In the following code, we can see
    how we implemented these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `thrust()` method applies an acceleration force to `Spaceship.linear_velocity`
    property that makes it move. Then, the `turn()` method applies an acceleration
    force to the `Spaceship.angular_velocity` property that rotates it. We’ve set
    up the `Spaceship` node so that this is all it needs to perform a nice and smooth
    movement. It has some damping forces as well. In the following figure, we can
    see the properties related to the `Spaceship` scene to understand this movement
    better.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – The Spaceship RigidBody2D properties settings](img/Figure_9.03_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – The Spaceship RigidBody2D properties settings
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Player` scene controls the `Spaceship` node’s movement simply by calling
    the `Spaceship.thrust()` and `Spaceship.turn()` methods based on the player’s
    inputs. In the following code snippet, we can see how this works in the `_physics_process()`
    callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you are an attentive engineer, which at this point we can assume you
    are, you might have noticed that in the `_process()` callback, we call the `fire()`
    method on the `Weapon2D` node, right? Let’s understand how the `Weapon2D` node
    works; it’s another core class for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Weapon2D` scene is a `Marker2D` node with `BulletSpawner2D`, `Timer`,
    `Sprite2D`, and `AnimationPlayer` nodes as its children. The following screenshot
    showcases the `Weapon2D` scene’s structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The Weapon2D scene’s node hierarchy](img/Figure_09.04_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – The Weapon2D scene’s node hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: '`BulletSpawner2D` instantiates bullets and gives them a direction based on
    `BulletSpawner2D`’s `global_rotation` value. We can see how this works in the
    following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As for `Weapon2D`, it uses `Timer` to establish a fire rate in which if `Timer`
    is currently active, it can’t shoot. Otherwise, it plays the `"fire"` animation,
    spawns a bullet using whatever scene we set in its `bullet_scene` property, and
    starts `Timer` based on `Weapon2D`’s `fire_rate` value. By default, it shoots
    three bullets per second. In the following code, we can see how we implemented
    this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With that, players can shoot bullets and defend themselves while they accomplish
    their missions. One of these missions is to destroy some asteroids. So, in the
    next section, we are going to understand how the `Asteroid` scene works so we
    can move on to the quest system afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Gauging the Asteroid scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Asteroid` scene plays a fundamental role in our prototype. It represents
    an object that players must destroy in order to progress in a given mission. With
    the `Asteroid` scene working as planned, we can evaluate the quest system. In
    this section, we are going to understand how the `Asteroid` scene works so we
    have an idea of what to do in the process of turning the local gameplay prototype
    into an online multiplayer prototype.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Asteroid` scene is a `Node2D` node with an `AnimationPlayer` node, a `Sprite2D`
    node, a `GPUParticle2D` node, a `HitArea2D` scene, a `HurtArea2D` scene, a `StaticBody2D`
    node, and a `QuestProgress` scene. We can see the scene structure in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – The Asteroid scene’s node hierarchy](img/Figure_09.05_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – The Asteroid scene’s node hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: '`HitArea2D` node applies *1* damage to players’ spaceships that touch it. When
    players shoot bullets, their `HitArea2D` node applies *1* damage to the `Asteroid`
    node if they hit its `HurtArea2D` node. If the `Asteroid` node doesn’t have any
    hit points left, it plays the `"explode"` animation, emitting some particles through
    `GPUParticles2D` node and putting itself in the queue so `SceneTree` frees it
    from memory as soon as the animation finishes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing so emits the `tree_exiting` signal, which is connected to `QuestProgress.increase_progress()`
    method. We are going to talk about `QuestProgress` node in the *Unraveling the
    quest system* section. The `Asteroid` node’s behavior is expressed in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With that, the `Asteroid` node becomes a good testing subject for our quest
    system. In the next section, let’s understand how this system works and the important
    aspects that we should consider for the online multiplayer version of our prototype.
  prefs: []
  type: TYPE_NORMAL
- en: Unraveling the quest system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s time to understand the very core of what defines an adventure game. In
    this section, we are going to understand how the quest system of our prototype
    works and what we can do with it. This will enlighten us with a good understanding
    of what we need to change in order to turn it into a system that works for an
    online multiplayer version of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Representing a quest as a node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will understand how the `Quest` node works and what we can
    do with it. To do that, open the `res://09.prototyping-space-adventure/Quests/Quest.tscn`
    scene. As with all other components of the quest system, it is a node with a script.
    Open the script and let’s understand it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Quest` node ultimately represents a quest in the player’s quest log, and
    for that, it bundles all the data relevant to the quest itself:'
  prefs: []
  type: TYPE_NORMAL
- en: The `id` property that represents the quest in the database, `"asteroid_1"`
    by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The quest’s `title`, `description`, and `target_amount` properties. Note that
    these are exported variables, so this allows our (fake) quest designers to directly
    create new quests using the **Inspector**. You can see the **Inspector** displaying
    all these properties in the following figures:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.6 – The Quest properties in the Inspector](img/Figure_9.06_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – The Quest properties in the Inspector
  prefs: []
  type: TYPE_NORMAL
- en: It also has `current_amount` property to track the player’s progress toward
    the quest’s target amount, and a `completed` property to tell whether the player
    has finished the quest already or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On top of that, it has a setter method for `current_amount` property to process
    the received value. It ensures that the value is clamped between `0` and `target_amount`
    property. It also emits a signal notifying the quest was updated, and if `current_amount`
    property is equal to `target_amount` property, it emits a signal notifying that
    the quest was completed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code snippet, we can see how this was implemented concretely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have an object that can represent a quest in our quest system.
    This is the very basic component of this system. As we saw, there is some data
    that makes up a `Quest`, right? This data is stored in a database so we can load
    and store the quest’s content. In the next section, we are going to see what this
    database looks like and how we can load quest content and store any changes made
    to these quests.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and storing quests with QuestDatabase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In any given adventure game, the players need quests to progress through the
    game story and overall world design. It is likely that these quests are stored
    in a place where quest designers can simply write them out and create an NPC to
    provide these quests to players.
  prefs: []
  type: TYPE_NORMAL
- en: Since in our fake quest designers would need some kind of database to design
    the quests, we made the `QuestDatabase` singleton. It loads JSON files containing
    all the available quests in the game and the player’s progress in each of them.
    In this section, we will see how we can load these files and store the player’s
    progress so they won’t lose it when they leave the game, and how the `QuestDatabase`
    singleton provides this data to other classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the scene provided in the `res://09.prototyping-space-adventure/Quests/QuestDatabase.tscn`
    file and you will also notice that it’s nothing more than a node with a script.
    In the **Inspector**, you’ll notice the path to two important files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – QuestDatabase’s Inspector](img/Figure_9.07_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – QuestDatabase’s Inspector
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the JSON files that `QuestDatabase` uses to load the game’s quest
    and the player’s progress in the quests they have already started. The `PlayerProgress.json`
    file content is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So, each quest is represented by its ID and a dictionary with an indication
    of whether they are already completed or not and the progress the player has currently
    made. Now, for `QuestDatabase.json`, it is a bit more complex; the file content
    is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Again, every quest is abstracted as a dictionary that reflects the quest’s ID.
    Inside the dictionary, we have the `"title"`, `"description"`, and `"target_amount"`
    keys, which contain important data regarding the quest’s object serialization
    and deserialization processes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the `QuestDatabase` singleton has some important methods to load, read,
    process, store, and even allow other objects to access this data. Let’s briefly
    go through the main methods; you’ll notice there are some extra methods in the
    class, but they are essentially there to retrieve specific information about a
    quest’s data, such as the quest’s title.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let’s focus on the more relevant methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QuestDatabase.load_database()`: Loads and deserializes the `QuestDatabase.json`
    and `PlayerProgress.json` files and stores their content, respectively, in the
    `quests_database` and `progress_database` member variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QuestDatabase.store_database()`: Does the opposite of the preceding method,
    serializing the `quests_database` and `progress_database` member variables into
    their respective files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QuestDatabase.get_player_quests()`: Creates a `quest_data` dictionary for
    each key in the `progress_database` dictionary, gathering their data using the
    auxiliary methods, and returns a `quests` dictionary with all quests the player
    has started and their data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QuestDatabase.update_player_progress()`: Updates the player’s progress in
    a given quest. It receives a `quest_id`, `current_amount`, and `completed` argument
    to do so.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `QuestDatabase` script, we can see the concrete implementation of this
    behavior and the auxiliary methods. You will notice there’s an implementation
    of the `_notification()` callback, which essentially calls the `store_database()`
    method when the application’s window receives a close request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This guarantees that if the player quits the game through the usual means, for
    instance, clicking on the close button, their progress will be saved.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have the quest data and player’s progress available at runtime
    and the quest system is almost done. We just need to know what we do with all
    that in the end, right? In the next section, we will understand how we use the
    intriguing `QuestProgress` nodes to update the system whenever a player makes
    progress in a given quest.
  prefs: []
  type: TYPE_NORMAL
- en: Managing players’ quests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we know that we can use the `QuestProgress` class when players get
    to progress in a given quest, we need to understand how these quests are managed
    in the system itself. In this section, we will understand how we retrieve quests
    from a quests database, how we create new quests for the current player based
    on the available quests retrieved, how we manage the player’s progress in a given
    quest, and how we communicate that the player has a new quest in their quest log.
  prefs: []
  type: TYPE_NORMAL
- en: Open the scene available at `res://09.prototyping-space-adventure/Quests/QuestSingleton.tscn`
    and you will see it is a node with a script attached to it. Open the script and
    let’s understand what this scene does.
  prefs: []
  type: TYPE_NORMAL
- en: As the singleton name, `Quests`, suggests, this scene is a set of all quests
    the player currently has. In the *Representing a quest as a node* section, we
    will see how we abstract each quest as an object with all the relevant properties,
    such as `title`, `description`, and `id`. The `QuestSingleton` class is responsible
    for retrieving and managing the quests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, it has three core methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QuestSingleton.retrieve_quests()`: Requests all the available quests for the
    players from the `QuestDatabase` singleton. We talked about `QuestDatabase` in
    the *Loading and storing quests with* *QuestDatabase* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QuestSingleton.create_quest()`: Receives a `quest_data` dictionary with all
    the relevant data to create a `Quest` node, then it instantiates a `Quest` and
    maps it to the `QuestSingleton.quests` dictionary using the quest ID. This allows
    other classes to access the `Quest` node using the quest ID in the upcoming method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QuestSingleton.get_quest()`: Receives a `quest_id` value as an argument and
    uses it to return the given `Quest` node associated with the provided ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QuestSingleton.increase_quest_progress()`: Receives a `quest_id` value as
    an argument and an `amount` value to determine how much to increase in the provided
    quest’s progress.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code, we can see how these behaviors were implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With that, `QuestSingleton` is able to retrieve all the quests the player is
    currently engaged in and provide them to user classes so they can access and work
    with said quests. This will allow us to actually increase the players’ progress
    in a given quest. For that, we will understand how the `QuestProgress` node works.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing quests’ progress
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Back in the `Asteroid` scene, we have the `QuestProgress` node. This node is
    responsible for communicating to the quest system when the player makes progress
    in a given quest. To know which quest `QuestProgress` refers to, we use a variable
    called `quest_id`, and this is a fundamental concept in our quest system. Through
    this data, other classes of the system can communicate with each other, requesting
    changes or retrieving information about a given quest.
  prefs: []
  type: TYPE_NORMAL
- en: On top of that, the `QuestProgress` class has a method called `increase_quest_progress()`,
    which requests `QuestSingleton`, referred to as `Quests`, to increase the quest’s
    progress by the `amount` value provided, by default `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw how `QuestSingleton` works in the *Managing players’ quests* section.
    Nonetheless, in the following code snippet, we can see the `QuestProgress` class’
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The`QuestProgress` node itself is a small component of the system that works
    on the very end of the system, where the final output is processed. It is meant
    to be used by other classes to trigger its behavior. For instance, as mentioned
    in the *Gauging the Asteroid scene* section, the `Asteroid` node uses its `tree_exiting`
    signal to trigger the `QuestProgress.increase_progress()` method.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our quest system onboarding. Throughout this section, we understood
    how objects can increase a quest’s progress, how we retrieve quests and players’
    progress from a database, how and what kind of data we store in the database files,
    and how this data ends up in a node in which we can implement higher-level behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Our onboarding process is not over yet. In the upcoming section, we will understand
    how players will actually see the quest information in `QuestPanel` node, which
    is a component of the last piece of our prototype, the `World` scene. It is in
    this scene that all the action actually happens, so stay focused, and let’s see
    how this works.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down the World scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everything we’ve seen so far will come together into the `World` scene. This
    is the scene where everything is put together to interact. It’s the `World` scene
    that we use to test our current prototype. To do so, open the `res://09.prototyping-space-adventure/Levels/World.tscn`
    scene and hit the **Run Current Scene** button. You will be able to test the game
    and get a feel for the prototype.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in this section, we are going to understand how we create asteroids and
    players in the game, and how we display the player’s quest log on the screen.
    The world itself is a high-level abstraction scene, so things are easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The scene itself is a node called `Main` that has a `RadialSpawner` child node
    called `Asteroids` responsible for spawning asteroids around it, a `Spawner` node
    called `Players` responsible for spawning `Player` instances, and some `CanvasLayers`
    nodes to create the overall visual of the game, namely `BackgroundLayer` node,
    which uses a `ColorRect` node to set the game’s background color, then `ParallaxBackground`
    node, which has a `ParallaxLayer` node containing a `GPUParticles2D` node that
    creates a repeating starfield for the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we also have `InterfaceCanvasLayer` node, which, as the name suggests,
    contains interface elements. Here, we have an important element to wrap up the
    quest system: `QuestPanel` node. We are going to talk about it in the *Displaying
    quest information* section. In the following screenshot, we can see the `World`
    scene node hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – The World scene node’s hierarchy](img/Figure_09.08_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – The World scene node’s hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: Here, we were able to structure a prototype that spawns some Asteroids around
    a given area, spawns a pPlayer, and displays the player’s quest log with the current
    active quests and their information. In the next section, let’s understand how
    the `QuestPanel` node gathers, displays, and updates information about the player’s
    quests.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying quest information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the end, the quest system has a main responsibility that summarizes everything
    we’ve seen so far regarding it. It has to display information about the current
    active quests to the player. This funnels down to `QuestPanel` node, which is
    a UI element that displays such information based on the data it gathers from
    `QuestSingleton` node. In this section, we are going to understand how `QuestPanel`
    node works. To do so, open the `res://09.prototyping-space-adventure/Quests/QuestPanel.tscn`
    scene.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `QuestPanel` node itself extends the `ScrollContainer` class and it
    has a `VBoxContainer` node as its child. This allows us to display many quests
    for the player and they will be able to navigate these quests using a scrollbar.
    We currently have only one quest, as seen in the `QuestDatabase.json` file, but
    the ground is paved for more quests. Now, open the `QuestPanel` script, and let’s
    see how it implements displaying quest information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing it does right at the `_ready()` callback is to connect the
    `Quests` singleton’s `quest_created` signal to `QuestPanel`’s `add_quest()` method.
    Then it tells the `Quests` singleton to retrieve quests, which will populate the
    `Quests` singleton with the players’ quests. Every time the `Quests` singleton
    creates a new `Quest` node, adding it as its child, it emits a signal that the
    `QuestPanel` node listens to and calls the `add_quest()` method. Let’s talk about
    the `QuestPanel` node member variables and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`quests_labels` is a dictionary used to map `Label` nodes to their reference
    using the `Quest.id` property as the key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `add_quest()` method creates a new `Label` node and sets its `text` property
    to a formatted String using the information from the `Quest` node stored in the
    quest property. It also connects the `quest.updated` signal to its `update_quest()`
    method, which we are going to talk about in a moment. Then, it adds this `Label`
    node as a child of the`VBoxContainer` node and maps it in the `quests_labels`
    property for further reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `update_quest()` method takes the `quest_id` String and the `current_amount`
    integer as arguments, and uses the `quest_id` argument to find the proper `Label`
    node to update the text with the updated quest data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This behavior is expressed in the following code snippet if you want to understand
    the concrete implementation of how this all happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With that, we close our quest system onboarding, and you are ready to understand
    how you will use it for our online multiplayer version of the prototype! You’ve
    seen it all, how objects can update quest progress, where quests are gathered
    and stored, how we load and save a player’s progress in a given quest, how we
    implement a node to represent a quest in our game, and finally, how this all comes
    together to display the quest’s information to the player in a UI element.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, we will see how the World’s `Main` node works. Its
    main responsibility is to ensure the game world is running as planned with all
    objects in their proper places.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the game world
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To ensure that the game runs as we plan, at least its initialization, we have
    the `Main` node. It essentially spawns 30 `Asteroid` instances using the `Asteroids`
    node and creates an instance of the `Player` scene using the `Players` node. As
    explained at the beginning of the *Breaking down the World scene* section, the
    latter two nodes are spawners.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this local gameplay prototype, the `Main` node is really simple, but keep
    it in mind, especially regarding its responsibility, when you start implementing
    the online multiplayer features. For reference, the `Main` node script is shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that it has a `create_spaceship()` method instead of directly calling the
    `player_spawner.spawn()` method. This will help you with your job later on, so
    you can thank our fake team for making your job easier.
  prefs: []
  type: TYPE_NORMAL
- en: And with that, your onboarding process is done! We’ve seen how the player controls
    their spaceship, how the asteroids take hits and explode, increasing the player’s
    progress in a quest, how the quest system works, and what it handles and outputs.
    We’ve also just seen how the game world initializes and establishes where each
    object should be and how many of them there should be.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time for the magic. In the upcoming sections, we are going to see
    how we will turn this prototype into an online multiplayer game prototype where
    players can join anytime, so there won’t be a lobby. We will also understand what
    we need to do to keep the players’ world in sync with the server’s world and how
    we separate the server and client’s responsibilities using the same script. This
    will be useful especially when handling our databases to prevent players from
    cheating and completing quests without effort.
  prefs: []
  type: TYPE_NORMAL
- en: Logging the player in to the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement a different type of logging system. This
    time, the players don’t have a lobby screen where they wait for other players
    to join a game and start a match. No, here the world is always active; it doesn’t
    start only when the players ask the server to start the match or the game. And
    this type of connection requires a different approach.
  prefs: []
  type: TYPE_NORMAL
- en: The major problem is that since the game world is always active and running,
    the players who join this world need to sync their game instance to the server’s
    game instance. This includes the position of objects, new objects that usually
    are not part of the world, for instance, other players and the number of objects
    (in our case, how many asteroids are currently available), and many other factors
    necessary to build a shared world.
  prefs: []
  type: TYPE_NORMAL
- en: It all starts with the player authentication, because now the server and the
    client are in different parts of the game life cycle; while the player is just
    opening the game, the server is already handling the game world.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating players
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Don’t panic, yet. Besides the conditions of authentication being different,
    the overall logic is very much the same as the one we’ve been using so far. The
    major difference here is that we will need to have an `Authentication` node dedicated
    to each side of the connection performing the authentication procedure according
    to the client or server’s responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'These nodes will be on the two major points of interaction for each side of
    the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: For the client, in this case the player, we will have the `Authentication` node
    on the `LoggingScreen` scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the server we will have its `Authentication` node on the `World` scene itself,
    waiting for players to join
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that for each side of this relationship, we will implement distinct authentication
    procedures. So, besides both nodes being called `Authentication` and having the
    same path, in other words, both being direct children of a parent node called
    `Main`, they will be totally different classes.
  prefs: []
  type: TYPE_NORMAL
- en: They will need shared methods, but we will see that the method implementations
    are different. This is all due to how RPCs work. Remember, when making an RPC,
    it will look for a node with the same node path in all peer game instances, and
    this node must have all the same methods as the one making the RPC, even if we
    are not calling these other methods. This means that the server side will share
    client-side methods, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: This will get less confusing once we start to implement it, so let’s open the
    `res://09.prototyping-space-adventure/LoggingScreen.tscn` scene and implement
    the client side of the authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing client-side authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `LoggingScreen` scene, you will notice a scene structure meant to be
    a simple logging screen where players insert their credentials, get authenticated,
    and log in to the game. This is a bit similar to the lobby we’ve been using in
    previous chapters, such as the one in [*Chapter 8*](B18527_08.xhtml#_idTextAnchor162),
    *Designing an Online* *Co-Op Platformer*.
  prefs: []
  type: TYPE_NORMAL
- en: This time, we don’t have a panel showcasing the current players; this is not
    necessary as players can join the game and experience individually even when other
    players are not around. Note that the scene’s script is attached to the `Authentication`
    node this time, instead of attached to the `Main` node.
  prefs: []
  type: TYPE_NORMAL
- en: This is because in the `World` scene, the `Main` node has other responsibilities,
    so it’s better to delegate the authentication to an exclusive node. Due to that,
    `LoggingScreen`’s authentication was also delegated to its `Authentication` node.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – The LoggingScreen scene’s node hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_09.09_B18527.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.9 – The LoggingScreen scene’s node hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `res://09.prototyping-space-adventure/LoggingScreen.gd` script
    file. You will notice there are a lot of things in common with what we’ve created
    in [*chapter 3*](B18527_03.xhtml#_idTextAnchor065), *Making a Lobby to Gather
    Players Together*, so let’s focus on the necessary work we need to do this time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this time we are only communicating with the server, we don’t need to
    start the game on all peers, so in the `_on_StartButton_pressed()` callback, we
    need to send an RPC directly to the server asking it to start the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The server itself will then authenticate the player, and if everything goes
    well, the server will also call the client’s `start_game()` method, which has
    a different implementation. In the client, `start_game()` is an RPC that only
    the network authority can call and is called locally. When called, it switches
    the current scene to the `next_scene` property, which in this case will be the
    `World` scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Alright, most of the code is very similar to the `one` we have in the implementations
    of the `Lobby` scene. This one is cleaner as we’ve removed other methods such
    as the ones we used to display logged players or display avatars.
  prefs: []
  type: TYPE_NORMAL
- en: With these changes, this code is able to send a direct request authentication
    for the server and start the game on this instance of the game. In the next section,
    we will see the other side of this system, the server side.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing server-side authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, the server-side authentication is a bit trickier. Previously, all that
    we needed to do was to handle the player’s authentication requests. But now, since
    the authentication happens while the server is already running the game, we need
    to transfer the responsibility of setting up the hosting as well.
  prefs: []
  type: TYPE_NORMAL
- en: This means that if the current instance is the server, it will need to set up
    `ENetMultiplayerPeer` on top of authenticating players’ credentials as well. Open
    the `res://09.prototyping-space-adventure/Authentication.gd` file and let’s make
    the necessary changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we will focus only on what we need to change based on the work we did
    previously, so feel free to go through the other parts of the script if you don’t
    remember how this all works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `_ready()` callback, let’s create the `ENet` server using the default
    `PORT`. Remember, since this script will be running on both the client and server,
    we will need to check whether the current instance running is the server. For
    that, we use the `multiplayer.is_server()` method. After setting up the server,
    we load the users’ database to properly authenticate them as usual:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second thing we need to do is to connect as a client if the instance is
    not the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The third thing we need to do is to set up the `start_game()` method to respond
    to all peers remotely, so this method won’t be called locally in the server’s
    instance. Inside this method, we will make an RPC to the peer that requested the
    game to start telling their instance to start the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This allows the server to dictate whether the player can or cannot join the
    game, and if the player happens to try to connect locally, simply pressing the
    start button won’t actually start the game as their instance will hang, waiting
    for a response from the server:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With these changes, we are able to have a server that can run an independent
    instance of the game and wait for players to join it. Using the `rpc_id()` method,
    we can pinpoint which peer we want to contact and establish direct communication
    between instances of the game. In this case, we did that with the server and the
    client, but we can do it between two clients as well if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to focus on how to sync the server’s persistent
    `World` scene with the players’ `World` scene, which may not reflect the current
    state of the shared game world.
  prefs: []
  type: TYPE_NORMAL
- en: Syncing the World scenes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the player logs in to the game, their world will likely be different from
    the server’s world. For instance, only the server should be able to spawn asteroids,
    and even if the client were able to spawn them, there would be nothing to guarantee
    they would be in the same position. So, this is the first thing we are going to
    fix.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how we can sync the `Asteroid` instances from
    the server’s world into the client’s world.
  prefs: []
  type: TYPE_NORMAL
- en: Syncing the asteroids
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open the `Asteroid` scene again and let’s add a new `MultiplayerSynchronizer`
    as its child. This `MultiplayerSynchronizer` will replicate the asteroid’s `position`
    and `top_level` properties. The following figure showcases the asteroid’s **MultiplayerSynchronizer
    Replication** **Menu** settings.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – The Asteroid’s MultiplayerSynchronizer Replication Menu settings](img/Figure_09.10_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – The Asteroid’s MultiplayerSynchronizer Replication Menu settings
  prefs: []
  type: TYPE_NORMAL
- en: Then, we are going to use something really interesting regarding network replication.
    The `MultiplayerSynchronizer` node has a property called `World` scene. So, we
    will toggle that property off. In the following screenshot, we can see what this
    property should look like in the **Inspector**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – The asteroid’s MultiplayerSynchronizer Public Visibility property
    in the Inspector](img/Figure_9.11_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – The asteroid’s MultiplayerSynchronizer Public Visibility property
    in the Inspector
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to the next necessary steps, I want to present you with a
    trick that will help you synchronize relevant objects all at once. Add `MultiplayerSynchronizer`
    node inside a group so that you can perform a group call using `SceneTree` later
    on. In this case, to be clearer about the group’s intent, let’s call it `Sync`.
    The following screenshot showcases this group with the `Asteroid` node’s `MultiplayerSynchronizer`
    node inside of it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – The asteroid’s MultiplayerSynchronizer inside the Sync group](img/Figure_9.12_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – The asteroid’s MultiplayerSynchronizer inside the Sync group
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, the `Asteroid` instances are ready to replicate their properties
    on the client’s `World` instance. But there’s still a problem. The client’s `World`
    instance should not create these `Asteroid` instances; instead, only the server
    should be able to spawn these objects. So, let’s open the `World` scene and set
    it up for synchronization:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to add a `MultiplayerSpawner` node that points
    to the `Asteroids` node. Let’s call it `AsteroidsMultiplayerSpawner`, and it should
    have the `Asteroid` scene set up as its first and only element in the **Auto Spawn
    List** property. We can see these properties configured in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.13 – The world’s AsteroidsMultiplayerSpawner properties in the Inspector](img/Figure_9.13_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – The world’s AsteroidsMultiplayerSpawner properties in the Inspector
  prefs: []
  type: TYPE_NORMAL
- en: This will ensure that all the instances of the server’s world asteroids will
    also exist in the client’s world as well. But note that until now, they will only
    be spawned, but not synced yet. So, let’s fix that. Open the `World` script and
    let’s set it up for the sync logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first, in the `_ready()` callback, we need to prevent the `World`
    node from spawning asteroids if it isn’t the server. It should request synchronization
    from the server instead. For that, it will make an RPC to the server’s `sync_world`
    method, which we will create in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, let’s create the `sync_world()` RPC method, which can be called by any
    peer locally. It needs to be called locally because we will tell the server’s
    `Asteroid` instances’ `MultiplayerSynchronizer` nodes, which are in the `Sync`
    group, to add the player to their visibility list, effectively syncing the `Asteroid`
    instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`set_visibility_for()` is a method from the `MultiplayerSynchronizer` node
    that adds a peer to its visibility list, which basically means a whitelist of
    peers it should synchronize to.'
  prefs: []
  type: TYPE_NORMAL
- en: For that, it uses the peer’s ID and receives a Boolean to tell it whether this
    peer should or shouldn’t see the replication of the properties set in `multiplayer.get_remote_sender_id()`
    method, so whoever requests to sync will be synced.
  prefs: []
  type: TYPE_NORMAL
- en: This is all we need for the syncing of the asteroids. Now, we are still missing
    the players and their spaceships, right? In the next section, we will see how
    to remotely create `Player` instances on all connected peers, sync their spaceships,
    and only allow their owner to control the spaceship.
  prefs: []
  type: TYPE_NORMAL
- en: Syncing the players
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to put our players together in this vast world. In this section, we
    will understand how we sync players’ scenes that were already in the World when
    another player joins the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Still in the `World` script, we are going to turn the `create_spaceship()`
    method into an RPC method that any peer can call remotely:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Due to how the `Players` spawner works, we won’t be able to do the proper renaming
    and identification of the newly created spaceship before it syncs to other peers.
    So, the `create_spaceship()` method takes the responsibility of spawning spaceships
    as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we add the `spaceship` instance as a child of the `Players` node, we
    will set its name to match the player’s peer ID. This ensures this instance has
    a unique name and we can use this name to identify the proper authority of the
    instance:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we come to a very important part. We are going to implement the `setup_multiplayer()`
    method in the player, which essentially does the same thing as the one we made
    in [*Chapter 8*](B18527_08.xhtml#_idTextAnchor162), *Designing an Online Co-Op
    Platformer*. So, we can make an RPC to this function here after waiting for `0.1`
    seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, whenever a player asks the server’s `World` instance to create a
    spaceship, it will instantiate a `Player` scene, assign it a unique ID, and ask
    it to configure its multiplayer settings. Remember, since we are doing this using
    an RPC, this means this `Player` instance will configure its multiplayer settings
    in all currently connected peers. But as it is now, only the server has an instance
    of this `Player` node.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To fix that, we are going to add another `MultiplayerSpawner` node called `PlayersMultiplayerSpawner`
    to the `World` scene. Its `Players` node and its `Player` scene, `res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn`.
    In the following screenshot, we can see these properties set up in the **Inspector**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.14 – The World scene’s PlayersMultiplayerSpawner node properties
    in the Inspector](img/Figure_9.14_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – The World scene’s PlayersMultiplayerSpawner node properties in
    the Inspector
  prefs: []
  type: TYPE_NORMAL
- en: Now, since the instances created by the `PlayersMultiplayerSpawner` node will
    still not be configured yet, we also need to call their `setup_multiplayer()`
    method as soon as they spawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, let’s connect the `PlayersMultiplayerSpawner`‘s `spawned` signal
    to the `World` scene’s `Main` node script, and inside then `_on_players_multiplayer_spawner()`
    callback, we make an RPC on the recently spawned node passing `set_up_multiplayer`
    as argument. This time, we will use the node’s name as an argument instead of
    `player_id`. This is because we don’t have access to the ID of the player that
    is supposed to own this instance, so we can use the instance name instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, every time a player joins the game, the server will create a new
    `Player` instance for them and set this instance up. This also works for `Player`
    instances that are already in the server’s `World`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a player joins the game, the server will spawn all other `Player` instances
    that are also currently playing. Now, we need the `Player` scene itself to sync
    its relevant properties to its peers and to implement its `setup_multiplayer`
    method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `res://08.designing-online-platformer/Actors/Player/Player2D.tscn`
    scene, and let’s start by adding `MultiplayerSynchronizer` node as a child of
    the `Player` node. This `MultiplayerSynchronizer` node should sync the `Player`
    instance’s `position` and `top_level` properties and the `Spaceship` node’s `position`
    and `rotation` properties. The following screenshot showcases the `Player` scene’s
    **MultiplayerSynchronizer** **Replication Menu**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.15 – The Player’s MultiplayerSynchronizer Replication Menu](img/Figure_09.15_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – The Player’s MultiplayerSynchronizer Replication Menu
  prefs: []
  type: TYPE_NORMAL
- en: Since this `MultiplayerSynchronizer` node will work by syncing physics properties,
    we need to set its **Visibility Update Mode** property to **Physics**. This will
    prevent some weird behaviors such as bodies overlapping and unhandled or mishandled
    collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s implement the `setup_multiplayer()` method. In the following instructions,
    we are going to create an RPC method that checks whether the current instance
    is a competence of the current player and disables some important processes to
    prevent interaction from players into instances they don’t own, as well as preventing
    overwriting properties synchronized by the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Player.gd` script, let’s start by creating an RPC method called `setup_multiplayer`
    that any peer can call locally. It should receive `player_id` as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, inside this method, we need to compare whether the `player_id` value
    received as an argument matches the current player’s peer ID. We will store this
    information in a variable called `is_player` to use for further reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this information in hand, we can set up the player’s processes. We also
    need to disable `camera` if this isn’t the current player and make `camera` the
    current camera if it is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we set the player’s multiplayer authority to be `player_id`. This
    will ultimately prevent this client from making any changes on this `Player` instance
    and propagating them on the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Throughout this section, we learned how we can spawn already existing objects
    to a player’s game instances when they log in when the game world is already running.
    We also saw how we can selectively synchronize objects using the `MultiplayerSynchronizer.set_visibility_for()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: On top of that, we used the `MultiplayerSpawner.spawned` signal to configure
    spawned instances of an object on the client’s side. In our case, we needed to
    configure the player multiplayer settings. To do that, we created a method that
    checks whether this instance belongs to the current player, properly disabling
    or enabling its processing and camera and setting its multiplayer authority accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to learn how we can separate some responsibilities
    in the game to prevent cheating and to establish a more coherent multiplayer system,
    for instance, preventing a player’s game instances from deleting asteroids as
    they are the responsibility of the server.
  prefs: []
  type: TYPE_NORMAL
- en: We will also see how we can sync players’ actions on all peers. This will be
    useful to replicate actions locally; for instance, when a player shoots on their
    game instance, all other game instances should perform the shooting as well.
  prefs: []
  type: TYPE_NORMAL
- en: Separating server and client responsibilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have players sharing the same world, we need to establish which
    actions they are responsible for and which actions are part of the server’s responsibility.
    For instance, if a player shoots on their game instance and their bullet damages
    an asteroid but this asteroid was already destroyed by another player, what should
    happen? For this kind of situation, the server is the perfect mediator to prevent
    instance conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: With all this context in place, players tell all peers, including the server,
    to update their `Player` instance according to their actions, but only the server
    should have the authority to manage the actual impact of these actions in the
    game world, such as if the player managed to destroy an asteroid or not. In the
    next section, we are going to understand how players can sync their actions, not
    only their objects’ properties, across all network-connected peers.
  prefs: []
  type: TYPE_NORMAL
- en: Shooting bullets on all instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the `Player` scene’s `Spaceship` node movement is already synced by the
    `MultiplayerSynchronizer` node, we can focus our efforts on syncing the `Bullet`
    instances’ movement now. One way we could do that would be to use the `MultiplayerSpawner`
    and `MultiplayerSynchronizer` nodes to spawn `Bullet` instances remotely and replicate
    their position, rotation, and so on. But instead, we can make an RPC telling all
    `Spaceship` instances to call the `fire()` method on their `Weapon2D` nodes.
  prefs: []
  type: TYPE_NORMAL
- en: This is a quick and cheap way to do this. As the `Bullet` nodes have a constant
    trajectory, there’s no reason to sync their movement properties. The only thing
    relevant is where they start, that is, the spawning position, and the direction
    they should move. Both these properties are being synced already by the `Player`
    node’s `MultiplayerSynchronizer` node. So, we can leverage them. Nice trick, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, open the `res://09.prototyping-space-adventure/Actors/Player/Player2D.gd`
    script, and in the `_process()` callback, change the `weapon.fire()` line to `weapon.rpc("fire")`,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you test the game now, you should see the `Player` instances’ `Spaceship`
    nodes shooting bullets on all game instances: server and clients. In the following
    screenshot, we can see a player shooting being replicated on the server’s game
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – The Payer scene’s Spaceship node shooting Bullet instances
    on the server’s game instance using an RPC function](img/Figure_09.16_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – The Payer scene’s Spaceship node shooting Bullet instances on
    the server’s game instance using an RPC function
  prefs: []
  type: TYPE_NORMAL
- en: Now that the `Player` instances can shoot bullets on every peer instance of
    the game, we need to understand who should manage the damage calculation and the
    destruction of the objects the `Bullet` nodes hit. We’ve already talked about
    that, and this responsibility is the server’s.
  prefs: []
  type: TYPE_NORMAL
- en: But how do we do that? In the next section, we are going to break down the `Asteroid`
    nodes’ behavior in order to separate what should happen on the client’s side and
    what should happen on the server’s side.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating an asteroid’s damage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, it’s time to use the `multiplayer.is_server()` method extensively. We
    need to break down the `Asteroid` node’s behavior and establish what should happen
    when the `Bullet` instances on a client’s game instance hit an `Asteroid` node
    and what should happen when these `Bullet` instances hit an `Asteroid` node on
    the server side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `res://09.prototyping-space-adventure/Objects/Asteroid/Asteroid.gd`
    script, and let’s implement the damage-taking behavior, respecting the responsibilities
    of each side of the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is prevent applying any damage to the `Asteroid`
    node if the current peer isn’t the server. So, in a client’s game instance, the
    `Bullet` node should hit the `Asteroid` node and disappear, but should not apply
    damage to the `Asteroid` node. To do that, in the `_on_hurt_area_2d_damage_taken()`
    callback, we are going to check whether the peer is the server, and if it is,
    we call the `apply_damage()` method, passing `damage` as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the `apply_damage()` method, after doing the proper calculation, the
    server must tell the `Asteroid` instances on all peers to play their proper animation,
    either playing `"hit"` or `"explode"`. But here’s the trick: the `animator` doesn’t
    have an `RPC` method to do that.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, instead, we are going to extract this behavior into two RPC methods and
    call these methods. These RPC methods should be called only by the network authority,
    and they should also be called locally:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last thing we need to do is to allow only the server to call the `queue_free()`
    method on the `Asteroid` nodes, preventing players from cheating and completing
    the quest in unpredictable ways. To do that, in the `_on_animation_player_animation_finished()`
    callback, we are going to check whether the peer is the server and call `queue_free()`
    if the current animation is `"explode"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since the server, which is the `Asteroid` node’s multiplayer authority, is removing
    the `Asteroid` instance from its `SceneTree`, the `World` node’s `AsteroidsMultiplayerSpawner`
    node will ensure that the `Asteroid` instances spawned on the clients’ game instances
    will also be removed as well. Isn’t the Godot Engine’s Network API clever?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With that, each side of the connection is performing its duty. The client side
    plays animations based on the `Asteroid` node’s state, while the server side deals
    with the actual impacts of `Bullet` nodes hitting `Asteroid` nodes. In this section,
    we saw how we can work around the issue when a behavior needs to be replicated
    remotely on all peers, but the built-in class, for instance the `AnimationPlayer`,
    doesn’t have a way to do it.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to separate things and give each side of the connection
    the power to execute their responsibility. While the client side must instantiate
    bullet’s and do all the processing of the shooting, the server side does its part
    by processing the damage dealt by the `Bullet` nodes and handling the `Asteroid`
    node’s life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to strengthen this knowledge by applying the
    same principles to the quest system. How does the player retrieve their quests?
    What is the client’s responsibility? Should the client store the player’s progress?
    What about the server? How does it handle clients’ requests and maintain information
    consistently between play sessions? That’s what we are going to talk about.
  prefs: []
  type: TYPE_NORMAL
- en: Storing and retrieving data on the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s time to handle a sensitive topic when it comes to online adventure games:
    databases. Note that in this book, we are not focusing on the best and most secure
    way to handle and protect a database. Instead, we are practicing and understanding
    what the Godot Engine Network API allows us to achieve and exploring its possibilities.'
  prefs: []
  type: TYPE_NORMAL
- en: That said, in this section, we are going to implement the necessary steps to
    establish a communication channel where the client can retrieve its quests data
    from the server and send their progress updates to the server.
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we are going to work with the two main classes in our quest system,
    `QuestSingleton` node and the `QuestDatabase` node. But before we set these classes
    up for this new challenge, we need to change how the database is structured. Since
    now the `QuestDatabase` node will work by delivering and handling multiple players’
    data, the `PlayerProgress.json` file needs to have its data linked to a user.
    So, let’s create these fake users, matching the ones in `FakeDatabase.json` file,
    and store this arbitrary data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `res://09.prototyping-space-adventure/Quests/PlayerProgress.json`
    file and create two new keys, one for `user1` and another for `user2`. Then, add
    some manual data matching the original structure for each user key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, with this in mind, remember that we can, and should, use the user we have
    stored in the `AuthenticationCredentials` singleton to refer to any sensitive
    user data. This is important because it’s how we are going to properly manage
    users’ requests and deliver the data accordingly. In the next section, we are
    going to see how `QuestSingleton` node should retrieve and update quest data.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the quest system’s client side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s time to finally have our quest system ready to work in a network where
    players can retrieve quests from a remote database, make progress on them, and
    store their information for the future. In this section, we are going to see what
    the `QuestSingleton` node’s role is in this online multiplayer environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s open the `res://09.prototyping-space-adventure/Quests/QuestSingleton.gd`
    script and get started with that. In the following instructions, we will see how
    we can retrieve and update quest data in a remote `QuestDatabase`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `retrieve_quests()` method needs a complete, but simpler and more elegant,
    revamp. The easiest way to create new quests in this online environment is to
    make the client request the remote `QuestDatabase` to create them remotely. We
    will see how this happens in depth in the *Implementing the quest system’s* *server*
    section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'But for now, we will wait for `0.1` seconds to guarantee that everything is
    in place, and then we can make an RPC on the `QuestDatabase` node’s `get_player_quests()`
    method if this `QuestSingleton` node is not the server’s. Remember to pass `AuthenticationCredentials.user`
    property as an argument to the `get_player_quests()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, since the server’s `QuestDatabase` node will create the quests on the
    client’s `QuestSingleton` node, we need to turn the `create_quest()` method into
    an RPC method that only the authority can call remotely:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, in the `increase_quest_progress()` method, we need to call the `QuestDatabase.update_player_progress()`
    method using an RPC directly to the server as well. Let’s not forget to also pass
    `AuthenticationCredentials.user` as an argument as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, the `QuestSingleton` node will ask the server’s `QuestDatabase` node
    to create the current player’s quests, and whenever the player makes progress
    in a quest, the client’s `QuestSingleton` node updates the server’s `QuestDatabase`
    node about the current quest’s progress, ultimately delegating to the server the
    responsibility of handling this important data.
  prefs: []
  type: TYPE_NORMAL
- en: Now, my friends, comes the last piece of our puzzle. In the next section, we
    are going to understand how the server side of this system works now that it is
    put in an online multiplayer environment.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the quest system’s server side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will add the necessary functionalities to the `QuestDatabase`
    node in order for it to properly provide and store players’ quest data. To do
    that, we are going to use RPCs extensively together with the `multiplayer.is_server()`
    method to prevent some behaviors from happening on the players’ instances of the
    `QuestDatabase` node.
  prefs: []
  type: TYPE_NORMAL
- en: We do this mainly to maintain the quest data only on the server side, so clients
    don’t run into the temptation to cheat directly on their machines. This will be
    an extensive section, so take a breather. We’ve been through quite a bit of information
    up to this point. Take a pause, and once you feel ready, come right back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ready? Okay, open the `res://09.prototyping-space-adventure/Quests/QuestDatabase.gd`
    script and let’s get started. In the upcoming instructions, we are going to tweak
    the current `QuestDatabase` node’s methods and even create new ones in order to
    make it work as it should, starting with…the `_ready()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `_ready()` callback, we should only load the database files if the current
    peer is the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We do the same thing in the `_notification()` callback. We should only store
    the files if the current peer is the server, so let’s add this check together
    with the notification check:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Moving on to `get_player_quests()`, it should now be an RPC method that any
    peer can call remotely:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since it’s now an RPC, we will store the peer ID of the client that requested
    this data so we can use this later on when we respond to the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add an argument called `user` to the method’s signature so we know which
    key to look at in the `progress_database` dictionary. Remember, now each user
    has their own key with their progress data in the `PlayerProgress.json` file,
    so this is how we access the proper user data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we have some changes to make in the `get_progress()` and `get_completion()`
    method signatures, right? We need to add the user as an argument. So, let’s call
    them using this argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to fix the methods’ signatures to match the previous changes and
    allow them to receive a `user` argument and access the `user` key in the `progress_database`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back to the `get_player_quests()` method – for each `quest` key found in `progress_database`
    dictionary for a user, we will make an RPC directly to the `create_quest()` method
    of the client’s `QuestSingleton` node, passing the `quest_data` dictionary we
    just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s also turn `update_player_progress()` into an RPC method that
    any peer can call remotely. It should also receive a `user` argument to update
    the progress on the proper `user` key in `progress_database`. This should only
    happen if this is the server’s instance of the `QuestDatabase` node, of course:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And that wraps up our quest system and database management logic on both the
    client and server sides. If you test the `res://09.prototyping-space-adventure/MainMenu.tscn`
    scene and log in as a user, you will be able to see `QuestPanel` displaying the
    quest data correctly with the current player’s progress on the quest. In the following
    screenshot, we can see `user2`’s quest information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 – QuestPanel displaying user2’s Destroy 10 Asteroids quest information](img/Figure_09.17_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – QuestPanel displaying user2’s Destroy 10 Asteroids quest information
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot displays `user1`’s quest information. So, we can assume
    that our system is working as it should, properly loading, displaying, and modifying
    players’ quest progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – QuestPanel displaying user1’s Destroy 10 Asteroids quest information](img/Figure_09.18_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – QuestPanel displaying user1’s Destroy 10 Asteroids quest information
  prefs: []
  type: TYPE_NORMAL
- en: With that, our top-down space adventure prototype is ready! Congratulations
    on making it all the way to this point. This chapter tested out everything we’ve
    seen so far extensively, and it closes *Part 2*, *Creating Online Multiplayer
    Mechanics*, of this book, where we created five prototypes to learn the ins and
    outs of Godot Engine’s high-level Network API.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, by now, you feel confident in building and testing more prototypes
    on your own. In *Part 3*, *Optimizing the Online Experience*, which we are going
    to start in the next chapter, we are going to see how we can use the available
    tools to improve upon the experiences we created in *Part 2*. We will talk about
    how to debug and profile the network, optimize data requests, implement optimization
    techniques such as prediction and interpolation, cache data, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to allow players to join in the middle of a
    game run; how to synchronize their game instances; how to load, retrieve, send,
    and store information on a remote database; how to create a quest system; and
    overall, how to structure the very basics of an online multiplayer adventure game.
    In the next chapter, we are going to learn how to debug and profile the network
    so we can find bottlenecks and potential areas of improvement and optimization
    for our games. See you there!
  prefs: []
  type: TYPE_NORMAL
- en: Part 3:Optimizing the Online Experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the core aspects of developing an application, especially a game, is
    to make the experience smooth and keep it without any hiccups or lag. When talking
    about games, which are real-time experiences, this is even more relevant. So,
    throughout this part of the book, we learn about the debugging and profiling tools
    necessary to assess potential bottlenecks and then we implement techniques to
    effectively optimize the network usage of the final project from*Part 2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18527_10.xhtml#_idTextAnchor260), *Debugging and Profiling
    the Network*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18527_11.xhtml#_idTextAnchor276), *Optimizing Data Requests*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B18527_12.xhtml#_idTextAnchor285), *Lag and Packet Loss Compensation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B18527_13.xhtml#_idTextAnchor296), *Caching Data to Decrease
    Bandwidth*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
