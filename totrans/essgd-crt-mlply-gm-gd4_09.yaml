- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Creating an Online Adventure Prototype
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建在线冒险原型
- en: In this chapter, we will explore the fascinating world of an online space adventure
    game that has the potential to evolve into a **massive multiplayer online role-playing
    game** (**MMORPG**). Throughout this journey, we will lay the foundations for
    an immersive gaming experience, allowing players to join a persistent world and
    seamlessly synchronize their game state with the current state of the game world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索一个在线太空冒险游戏的迷人世界，该游戏有可能演变成一个**大型多人在线角色扮演游戏**（**MMORPG**）。在整个旅程中，我们将为沉浸式游戏体验奠定基础，允许玩家加入持久的世界，并无缝地将他们的游戏状态与游戏世界的当前状态同步。
- en: 'Here’s a snapshot of what the final spaceshooter adventure prototype will look
    like:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一张最终太空射击冒险原型快照：
- en: '![Figure 9.1 – Two players accomplishing the Destroy 10 Asteroids quest together](img/Figure_09.01_B18527.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 两位玩家共同完成摧毁10颗小行星的任务](img/Figure_09.01_B18527.jpg)'
- en: Figure 9.1 – Two players accomplishing the Destroy 10 Asteroids quest together
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 两位玩家共同完成摧毁10颗小行星的任务
- en: Our primary focus will be building a robust networking system that facilitates
    real-time interaction among players by using the powerful Godot Engine Network
    API. Through this system, players will connect to a central server, ensuring that
    everyone shares the same game world and can witness each other’s actions, promoting
    collaboration and a sense of togetherness.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要关注点将是构建一个强大的网络系统，通过使用Godot引擎网络API促进玩家之间的实时交互。通过这个系统，玩家将连接到一个中央服务器，确保每个人共享相同的游戏世界，并能够见证彼此的行动，促进协作和团队精神。
- en: Furthermore, we will dive into the creation of a dynamic quest system capable
    of tracking player progress and storing this data in a database, so that when
    players come back, they will maintain their progress. Within our prototype of
    a space adventure, players will collaborate to complete missions such as destroying
    asteroids.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将深入研究创建一个动态任务系统，该系统能够跟踪玩家进度并将此数据存储在数据库中，以便当玩家回来时，他们可以保持自己的进度。在我们的太空冒险原型中，玩家将合作完成诸如摧毁小行星等任务。
- en: 'We will start the chapter by understanding the role of each piece of our game:
    the asteroids, the spaceship, and the player scene. Then, we will move to the
    core feature of an adventure game, the quest system, where we are going to learn
    how to pull and push data to the server and what builds up this robust system
    from both the server’s and player’s perspectives.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先了解我们游戏中的每个部分的作用：小行星、宇宙飞船和玩家场景。然后，我们将转向冒险游戏的核心功能——任务系统，我们将学习如何将数据拉取和推送到服务器，以及从服务器和玩家的角度构建这个强大系统的要素。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Introducing the prototype
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍原型
- en: Logging the player in to the server
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将玩家登录到服务器
- en: Separating server and client responsibilities
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离服务器和客户端的责任
- en: Storing and retrieving data on the server
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上存储和检索数据
- en: By the end of this chapter, you will have a solid foundation for an online adventure
    game that can expand into a vast and captivating MMORPG. Equipped with a persistent
    world, synchronized gameplay, and a quest system, you will be well prepared to
    build an engaging and dynamic online gaming experience.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将拥有一个在线冒险游戏的基础，该游戏可以扩展成一个庞大而吸引人的大型多人在线角色扮演游戏（MMORPG）。配备持久的世界、同步游戏玩法和任务系统，您将准备好构建一个引人入胜且动态的在线游戏体验。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To access the resources for this chapter, go to our online project’s repository
    found at [https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本章的资源，请访问我们的在线项目仓库，网址为[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0)。
- en: With the repository in your computer, open the `res://09.prototyping-space-adventure`
    folder in the Godot Engine editor. You will find all the necessary files for this
    chapter there.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的计算机上拥有仓库后，在Godot引擎编辑器中打开`res://09.prototyping-space-adventure`文件夹。您将在这里找到本章所需的全部文件。
- en: Now, let us begin the onboarding process. In the next section, we will introduce
    the project, explore its main classes, and identify where we need to implement
    networking features.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始入职流程。在下一节中，我们将介绍项目，探索其主要类，并确定我们需要实现网络功能的地方。
- en: Introducing the prototype
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍原型
- en: In this section, we will gain a comprehensive understanding of the core systems
    driving our prototype. As the network engineers of our fictional studio, our role
    is core in transforming our local game prototype into an exciting online multiplayer
    game prototype. To accomplish this, we must familiarize ourselves with the major
    classes and files that make up our project.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将全面了解驱动我们原型的核心系统。作为我们虚构工作室的网络工程师，我们的角色在将我们的本地游戏原型转变为激动人心的在线多人游戏原型中至关重要。为了实现这一目标，我们必须熟悉构成我们项目的重大类和文件。
- en: Let’s not overlook the significance of the onboarding process when we join a
    project. As network engineers, applying our knowledge and insights is essential
    for seamless integration into the development process. By understanding the core
    systems and concepts, we create a collaborative and productive environment, empowering
    the team to collectively bring our vision to life.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们加入一个项目时，不要忽视入职流程的重要性。作为网络工程师，应用我们的知识和洞察力对于无缝融入开发过程至关重要。通过理解核心系统和概念，我们创造了一个协作和高效的环境，使团队能够共同将我们的愿景变为现实。
- en: So, let’s dive into the heart of our prototype and unlock the potential of online
    multiplayer gaming. By the end of this section, you will be equipped with the
    necessary systems you can tweak to shape an immersive and engaging online experience,
    uniting players in a dynamic and interconnected world. In the next section, let’s
    understand how the `Player` class and scene work.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们深入到我们的原型核心，解锁在线多人游戏的潜力。在本节结束时，你将具备必要的系统，可以对其进行调整以塑造沉浸式和引人入胜的在线体验，将玩家团结在一个动态和互联的世界中。在下一节中，让我们了解`Player`类和场景的工作原理。
- en: Understanding the Player scene
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解玩家场景
- en: In any game, the player’s avatar is a fundamental element of the player’s experience.
    In this section, our goal is to understand the composition of the `Player` scene,
    the scene that represents the player’s avatar in our prototype.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何游戏中，玩家的化身是玩家体验的基本元素。在本节中，我们的目标是理解`Player`场景的组成，即在我们原型中表示玩家化身的那一场景。
- en: The `Player` scene is an abstract representation of the player as an entity
    in the game. It is a Node2D class that has a `Spaceship` scene, a `Weapon2D` scene,
    a `Sprite2D` node, a `HurtArea2D` node, a `CameraRemoteTransform2D` node, and,
    of course, the `Camera2D` node.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player`场景是玩家作为游戏中的实体的抽象表示。它是一个Node2D类，具有`Spaceship`场景、`Weapon2D`场景、`Sprite2D`节点、`HurtArea2D`节点、`CameraRemoteTransform2D`节点，当然还有`Camera2D`节点。'
- en: "![Figure 9.2 – The Player scene \uFEFFnode’s hierarchy](img/Figure_09.02_B18527.jpg)"
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 玩家场景节点层次结构](img/Figure_09.02_B18527.jpg)'
- en: Figure 9.2 – The Player scene node’s hierarchy
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 玩家场景节点层次结构
- en: Now, let’s understand the role of the main components of this scene, namely
    the `Spaceship` and `Weapon2D` nodes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解这个场景的主要组件的作用，即`Spaceship`和`Weapon2D`节点。
- en: 'The `Spaceship` node is a direct child of `Player` node and carries most of
    the other components, with the exception of the `Camera2D` node; instead, it uses
    the `CameraRemoteTransform2D` node to remotely transform the `Camera2D` node.
    The `Spaceship` node is a RigidBody2D node that simulates the movement of a body
    within an environment with no gravity and very low friction. It has two main methods,
    `Spaceship.thrust()` and `Spaceship.turn()`. In the following code, we can see
    how we implemented these methods:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spaceship`节点是`Player`节点的直接子节点，携带了除`Camera2D`节点之外的大部分其他组件；相反，它使用`CameraRemoteTransform2D`节点来远程转换`Camera2D`节点。`Spaceship`节点是一个RigidBody2D节点，它模拟在无重力且摩擦力非常低的环境中身体的运动。它有两个主要方法，`Spaceship.thrust()`和`Spaceship.turn()`。在下面的代码中，我们可以看到我们如何实现这些方法：'
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `thrust()` method applies an acceleration force to `Spaceship.linear_velocity`
    property that makes it move. Then, the `turn()` method applies an acceleration
    force to the `Spaceship.angular_velocity` property that rotates it. We’ve set
    up the `Spaceship` node so that this is all it needs to perform a nice and smooth
    movement. It has some damping forces as well. In the following figure, we can
    see the properties related to the `Spaceship` scene to understand this movement
    better.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`thrust()`方法将加速度力应用到`Spaceship.linear_velocity`属性，使其移动。然后，`turn()`方法将加速度力应用到`Spaceship.angular_velocity`属性，使其旋转。我们已经设置了`Spaceship`节点，使其只需这些操作就能实现流畅的运动。它还有一些阻尼力。在下面的图中，我们可以看到与`Spaceship`场景相关的属性，以更好地理解这种运动。'
- en: '![Figure 9.3 – The Spaceship RigidBody2D properties settings](img/Figure_9.03_B18527.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 星船RigidBody2D属性设置](img/Figure_09.03_B18527.jpg)'
- en: Figure 9.3 – The Spaceship RigidBody2D properties settings
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – Spaceship RigidBody2D 属性设置
- en: 'The `Player` scene controls the `Spaceship` node’s movement simply by calling
    the `Spaceship.thrust()` and `Spaceship.turn()` methods based on the player’s
    inputs. In the following code snippet, we can see how this works in the `_physics_process()`
    callback:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player` 场景通过根据玩家的输入调用 `Spaceship.thrust()` 和 `Spaceship.turn()` 方法来简单地控制 `Spaceship`
    节点的移动。在以下代码片段中，我们可以看到在 `_physics_process()` 回调中它是如何工作的：'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, if you are an attentive engineer, which at this point we can assume you
    are, you might have noticed that in the `_process()` callback, we call the `fire()`
    method on the `Weapon2D` node, right? Let’s understand how the `Weapon2D` node
    works; it’s another core class for us.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你是一个细心的工程师，在这个阶段我们可以假设你是，你可能会注意到在 `_process()` 回调中，我们在 `Weapon2D` 节点上调用
    `fire()` 方法，对吧？让我们了解 `Weapon2D` 节点是如何工作的；它对我们来说是一个核心类。
- en: 'The `Weapon2D` scene is a `Marker2D` node with `BulletSpawner2D`, `Timer`,
    `Sprite2D`, and `AnimationPlayer` nodes as its children. The following screenshot
    showcases the `Weapon2D` scene’s structure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Weapon2D` 场景是一个包含 `BulletSpawner2D`、`Timer`、`Sprite2D` 和 `AnimationPlayer`
    节点的 `Marker2D` 节点。以下截图展示了 `Weapon2D` 场景的结构：'
- en: '![Figure 9.4 – The Weapon2D scene’s node hierarchy](img/Figure_09.04_B18527.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – `Weapon2D` 场景的节点层次结构](img/Figure_09.04_B18527.jpg)'
- en: Figure 9.4 – The Weapon2D scene’s node hierarchy
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – `Weapon2D` 场景的节点层次结构
- en: '`BulletSpawner2D` instantiates bullets and gives them a direction based on
    `BulletSpawner2D`’s `global_rotation` value. We can see how this works in the
    following code block:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`BulletSpawner2D` 根据其 `global_rotation` 值实例化子弹并赋予它们方向。我们可以在以下代码块中看到它是如何工作的：'
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As for `Weapon2D`, it uses `Timer` to establish a fire rate in which if `Timer`
    is currently active, it can’t shoot. Otherwise, it plays the `"fire"` animation,
    spawns a bullet using whatever scene we set in its `bullet_scene` property, and
    starts `Timer` based on `Weapon2D`’s `fire_rate` value. By default, it shoots
    three bullets per second. In the following code, we can see how we implemented
    this behavior:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Weapon2D`，它使用 `Timer` 来建立射击速率，如果 `Timer` 当前处于活动状态，则不能射击。否则，它播放 `"fire"`
    动画，使用我们在其 `bullet_scene` 属性中设置的任何场景实例化一个子弹，并根据 `Weapon2D` 的 `fire_rate` 值启动 `Timer`。默认情况下，它每秒射击三颗子弹。在以下代码中，我们可以看到我们是如何实现这个行为的：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With that, players can shoot bullets and defend themselves while they accomplish
    their missions. One of these missions is to destroy some asteroids. So, in the
    next section, we are going to understand how the `Asteroid` scene works so we
    can move on to the quest system afterward.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，玩家可以在完成任务的同时射击子弹并保护自己。其中一项任务就是摧毁一些小行星。所以，在下一节中，我们将了解 `Asteroid` 场景是如何工作的，以便我们之后可以继续到任务系统。
- en: Gauging the Asteroid scene
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估 `Asteroid` 场景
- en: The `Asteroid` scene plays a fundamental role in our prototype. It represents
    an object that players must destroy in order to progress in a given mission. With
    the `Asteroid` scene working as planned, we can evaluate the quest system. In
    this section, we are going to understand how the `Asteroid` scene works so we
    have an idea of what to do in the process of turning the local gameplay prototype
    into an online multiplayer prototype.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Asteroid` 场景在我们原型中起着基本的作用。它代表玩家必须摧毁以在特定任务中前进的对象。当 `Asteroid` 场景按计划工作，我们可以评估任务系统。在本节中，我们将了解
    `Asteroid` 场景是如何工作的，以便我们了解在将本地游戏原型转换为在线多人游戏原型过程中的操作。'
- en: 'The `Asteroid` scene is a `Node2D` node with an `AnimationPlayer` node, a `Sprite2D`
    node, a `GPUParticle2D` node, a `HitArea2D` scene, a `HurtArea2D` scene, a `StaticBody2D`
    node, and a `QuestProgress` scene. We can see the scene structure in the following
    screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Asteroid` 场景是一个包含 `AnimationPlayer` 节点、`Sprite2D` 节点、`GPUParticle2D` 节点、`HitArea2D`
    场景、`HurtArea2D` 场景、`StaticBody2D` 节点和 `QuestProgress` 场景的 `Node2D` 节点。我们可以在以下截图中看到场景结构：'
- en: '![Figure 9.5 – The Asteroid scene’s node hierarchy](img/Figure_09.05_B18527.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – `Asteroid` 场景的节点层次结构](img/Figure_09.05_B18527.jpg)'
- en: Figure 9.5 – The Asteroid scene’s node hierarchy
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – `Asteroid` 场景的节点层次结构
- en: '`HitArea2D` node applies *1* damage to players’ spaceships that touch it. When
    players shoot bullets, their `HitArea2D` node applies *1* damage to the `Asteroid`
    node if they hit its `HurtArea2D` node. If the `Asteroid` node doesn’t have any
    hit points left, it plays the `"explode"` animation, emitting some particles through
    `GPUParticles2D` node and putting itself in the queue so `SceneTree` frees it
    from memory as soon as the animation finishes.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`HitArea2D`节点对接触它的玩家太空船造成*1*点伤害。当玩家射击子弹时，如果他们击中`HurtArea2D`节点，他们的`HitArea2D`节点会对`Asteroid`节点造成*1*点伤害。如果`Asteroid`节点没有剩余的击中点数，它将播放`"explode"`动画，通过`GPUParticles2D`节点发射一些粒子，并将自己放入队列中，以便`SceneTree`在动画完成后立即从内存中释放它。'
- en: 'Doing so emits the `tree_exiting` signal, which is connected to `QuestProgress.increase_progress()`
    method. We are going to talk about `QuestProgress` node in the *Unraveling the
    quest system* section. The `Asteroid` node’s behavior is expressed in the following
    code snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做会发出`tree_exiting`信号，该信号连接到`QuestProgress.increase_progress()`方法。我们将在*揭示任务系统*部分讨论`QuestProgress`节点。以下代码片段展示了`Asteroid`节点的行为：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With that, the `Asteroid` node becomes a good testing subject for our quest
    system. In the next section, let’s understand how this system works and the important
    aspects that we should consider for the online multiplayer version of our prototype.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，`Asteroid`节点就成为了我们任务系统的一个很好的测试对象。在下一节中，让我们了解这个系统是如何工作的，以及我们应该考虑的重要方面，以便为我们的原型在线多人版本考虑。
- en: Unraveling the quest system
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 揭示任务系统
- en: It’s time to understand the very core of what defines an adventure game. In
    this section, we are going to understand how the quest system of our prototype
    works and what we can do with it. This will enlighten us with a good understanding
    of what we need to change in order to turn it into a system that works for an
    online multiplayer version of the game.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是了解定义冒险游戏核心要素的时候了。在本节中，我们将了解我们原型中的任务系统是如何工作的以及我们可以用它做什么。这将使我们能够更好地理解我们需要更改什么才能将其转变为适用于游戏在线多人版本的系统。
- en: Let’s get started!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Representing a quest as a node
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将任务表示为节点
- en: In this section, we will understand how the `Quest` node works and what we can
    do with it. To do that, open the `res://09.prototyping-space-adventure/Quests/Quest.tscn`
    scene. As with all other components of the quest system, it is a node with a script.
    Open the script and let’s understand it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解`Quest`节点的工作原理以及我们可以用它做什么。为此，打开`res://09.prototyping-space-adventure/Quests/Quest.tscn`场景。与其他所有任务系统组件一样，它是一个带有脚本的节点。打开脚本，让我们来理解它。
- en: 'The `Quest` node ultimately represents a quest in the player’s quest log, and
    for that, it bundles all the data relevant to the quest itself:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Quest`节点最终代表玩家任务日志中的任务，为此，它捆绑了与任务本身相关的所有数据：'
- en: The `id` property that represents the quest in the database, `"asteroid_1"`
    by default.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表数据库中任务的`id`属性，默认为`"asteroid_1"`。
- en: 'The quest’s `title`, `description`, and `target_amount` properties. Note that
    these are exported variables, so this allows our (fake) quest designers to directly
    create new quests using the **Inspector**. You can see the **Inspector** displaying
    all these properties in the following figures:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务的相关属性`title`、`description`和`target_amount`。请注意，这些是导出变量，因此这允许我们的（假）任务设计师直接使用**检查器**创建新的任务。您可以在以下图中看到**检查器**显示的所有这些属性：
- en: '![Figure 9.6 – The Quest properties in the Inspector](img/Figure_9.06_B18527.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 检查器中的任务属性](img/Figure_9.06_B18527.jpg)'
- en: Figure 9.6 – The Quest properties in the Inspector
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 检查器中的任务属性
- en: It also has `current_amount` property to track the player’s progress toward
    the quest’s target amount, and a `completed` property to tell whether the player
    has finished the quest already or not.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还有一个`current_amount`属性来跟踪玩家向任务目标数量的进度，以及一个`completed`属性来告知玩家是否已经完成了任务。
- en: On top of that, it has a setter method for `current_amount` property to process
    the received value. It ensures that the value is clamped between `0` and `target_amount`
    property. It also emits a signal notifying the quest was updated, and if `current_amount`
    property is equal to `target_amount` property, it emits a signal notifying that
    the quest was completed.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，它还有一个用于`current_amount`属性的setter方法来处理接收到的值。它确保该值在`0`和`target_amount`属性之间夹紧。它还会发出一个信号通知任务已被更新，如果`current_amount`属性等于`target_amount`属性，它还会发出一个信号通知任务已完成。
- en: 'In the following code snippet, we can see how this was implemented concretely:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们可以看到它是如何具体实现的：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With that, we have an object that can represent a quest in our quest system.
    This is the very basic component of this system. As we saw, there is some data
    that makes up a `Quest`, right? This data is stored in a database so we can load
    and store the quest’s content. In the next section, we are going to see what this
    database looks like and how we can load quest content and store any changes made
    to these quests.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个可以代表我们任务系统中任务的对象。这是这个系统的基本组成部分。正如我们所见，有一些数据构成了一个`Quest`，对吧？这些数据存储在数据库中，以便我们可以加载和存储任务的内容。在下一节中，我们将看到这个数据库的样子以及如何加载任务内容并存储对任务的任何更改。
- en: Loading and storing quests with QuestDatabase
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用QuestDatabase加载和存储任务
- en: In any given adventure game, the players need quests to progress through the
    game story and overall world design. It is likely that these quests are stored
    in a place where quest designers can simply write them out and create an NPC to
    provide these quests to players.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何一款冒险游戏中，玩家需要任务来推进游戏故事和整体世界设计。这些任务可能存储在一个地方，任务设计师可以简单地编写它们并创建一个NPC来向玩家提供这些任务。
- en: Since in our fake quest designers would need some kind of database to design
    the quests, we made the `QuestDatabase` singleton. It loads JSON files containing
    all the available quests in the game and the player’s progress in each of them.
    In this section, we will see how we can load these files and store the player’s
    progress so they won’t lose it when they leave the game, and how the `QuestDatabase`
    singleton provides this data to other classes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在我们的假任务设计师需要某种类型的数据库来设计任务，我们创建了`QuestDatabase`单例。它加载包含游戏中所有可用任务和玩家在每个任务中的进度的JSON文件。在本节中，我们将看到如何加载这些文件并存储玩家的进度，以便他们在离开游戏时不会丢失，以及`QuestDatabase`单例如何将这些数据提供给其他类。
- en: 'Open the scene provided in the `res://09.prototyping-space-adventure/Quests/QuestDatabase.tscn`
    file and you will also notice that it’s nothing more than a node with a script.
    In the **Inspector**, you’ll notice the path to two important files:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`res://09.prototyping-space-adventure/Quests/QuestDatabase.tscn`文件中提供的场景，你也会注意到它不过是一个带有脚本的节点。在**检查器**中，你会注意到两个重要文件的路径：
- en: '![Figure 9.7 – QuestDatabase’s Inspector](img/Figure_9.07_B18527.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – QuestDatabase的检查器](img/Figure_9.07_B18527.jpg)'
- en: Figure 9.7 – QuestDatabase’s Inspector
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – QuestDatabase的检查器
- en: 'These are the JSON files that `QuestDatabase` uses to load the game’s quest
    and the player’s progress in the quests they have already started. The `PlayerProgress.json`
    file content is shown in the following code snippet:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是`QuestDatabase`用来加载游戏中的任务和玩家在已开始的任务中的进度的JSON文件。`PlayerProgress.json`文件的内容如下所示：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, each quest is represented by its ID and a dictionary with an indication
    of whether they are already completed or not and the progress the player has currently
    made. Now, for `QuestDatabase.json`, it is a bit more complex; the file content
    is shown in the following code snippet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个任务都通过其ID和一个字典来表示，字典中指明了它们是否已经完成以及玩家目前所取得的进度。现在，对于`QuestDatabase.json`文件，它要复杂一些；文件内容如下所示：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Again, every quest is abstracted as a dictionary that reflects the quest’s ID.
    Inside the dictionary, we have the `"title"`, `"description"`, and `"target_amount"`
    keys, which contain important data regarding the quest’s object serialization
    and deserialization processes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，每个任务都被抽象为一个字典，反映了任务的ID。在字典内部，我们有`"title"`、`"description"`和`"target_amount"`键，它们包含关于任务对象序列化和反序列化过程的重要数据。
- en: Now, the `QuestDatabase` singleton has some important methods to load, read,
    process, store, and even allow other objects to access this data. Let’s briefly
    go through the main methods; you’ll notice there are some extra methods in the
    class, but they are essentially there to retrieve specific information about a
    quest’s data, such as the quest’s title.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`QuestDatabase`单例有一些重要的方法来加载、读取、处理、存储，甚至允许其他对象访问这些数据。让我们简要地了解一下主要方法；你会注意到类中还有一些额外的方法，但它们本质上是为了检索关于任务数据的特定信息，例如任务的标题。
- en: 'But let’s focus on the more relevant methods:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们关注更相关的几个方法：
- en: '`QuestDatabase.load_database()`: Loads and deserializes the `QuestDatabase.json`
    and `PlayerProgress.json` files and stores their content, respectively, in the
    `quests_database` and `progress_database` member variables.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QuestDatabase.load_database()`: 加载并反序列化`QuestDatabase.json`和`PlayerProgress.json`文件，并将它们的内容分别存储在`quests_database`和`progress_database`成员变量中。'
- en: '`QuestDatabase.store_database()`: Does the opposite of the preceding method,
    serializing the `quests_database` and `progress_database` member variables into
    their respective files.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QuestDatabase.store_database()`: 与前一个方法相反，将`quests_database`和`progress_database`成员变量序列化到各自的文件中。'
- en: '`QuestDatabase.get_player_quests()`: Creates a `quest_data` dictionary for
    each key in the `progress_database` dictionary, gathering their data using the
    auxiliary methods, and returns a `quests` dictionary with all quests the player
    has started and their data.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QuestDatabase.get_player_quests()`: 为`progress_database`字典中的每个键创建一个`quest_data`字典，使用辅助方法收集它们的数据，并返回一个包含玩家已开始的所有任务及其数据的`quests`字典。'
- en: '`QuestDatabase.update_player_progress()`: Updates the player’s progress in
    a given quest. It receives a `quest_id`, `current_amount`, and `completed` argument
    to do so.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QuestDatabase.update_player_progress()`: 更新玩家在特定任务中的进度。它接收一个`quest_id`、`current_amount`和`completed`参数来执行此操作。'
- en: 'In the `QuestDatabase` script, we can see the concrete implementation of this
    behavior and the auxiliary methods. You will notice there’s an implementation
    of the `_notification()` callback, which essentially calls the `store_database()`
    method when the application’s window receives a close request:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在`QuestDatabase`脚本中，我们可以看到这个行为的具体实现和辅助方法。你会注意到有一个`_notification()`回调的实现，它本质上是在应用程序的窗口接收到关闭请求时调用`store_database()`方法：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This guarantees that if the player quits the game through the usual means, for
    instance, clicking on the close button, their progress will be saved.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这保证了如果玩家通过常规方式退出游戏，例如点击关闭按钮，他们的进度将被保存。
- en: With that, we have the quest data and player’s progress available at runtime
    and the quest system is almost done. We just need to know what we do with all
    that in the end, right? In the next section, we will understand how we use the
    intriguing `QuestProgress` nodes to update the system whenever a player makes
    progress in a given quest.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们在运行时就有任务数据和玩家的进度，任务系统几乎完成了。我们只需要知道最后我们如何处理所有这些，对吧？在下一节中，我们将了解我们如何使用有趣的`QuestProgress`节点来更新系统，每当玩家在某个任务中取得进展时。
- en: Managing players’ quests
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理玩家的任务
- en: Now that we know that we can use the `QuestProgress` class when players get
    to progress in a given quest, we need to understand how these quests are managed
    in the system itself. In this section, we will understand how we retrieve quests
    from a quests database, how we create new quests for the current player based
    on the available quests retrieved, how we manage the player’s progress in a given
    quest, and how we communicate that the player has a new quest in their quest log.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们知道当玩家在某个任务中取得进展时，我们可以使用`QuestProgress`类，我们需要了解这些任务如何在系统中本身被管理。在本节中，我们将了解我们如何从任务数据库检索任务，如何根据检索到的可用任务为当前玩家创建新任务，如何管理玩家在特定任务中的进度，以及如何通知玩家他们在任务日志中有新的任务。 '
- en: Open the scene available at `res://09.prototyping-space-adventure/Quests/QuestSingleton.tscn`
    and you will see it is a node with a script attached to it. Open the script and
    let’s understand what this scene does.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于`res://09.prototyping-space-adventure/Quests/QuestSingleton.tscn`的场景，你会看到它是一个带有脚本的节点。打开脚本，让我们了解这个场景的作用。
- en: As the singleton name, `Quests`, suggests, this scene is a set of all quests
    the player currently has. In the *Representing a quest as a node* section, we
    will see how we abstract each quest as an object with all the relevant properties,
    such as `title`, `description`, and `id`. The `QuestSingleton` class is responsible
    for retrieving and managing the quests.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如单例名称`Quests`所暗示的，这个场景是玩家当前拥有的所有任务的集合。在*将任务表示为节点*部分，我们将看到我们如何将每个任务抽象为一个具有所有相关属性的对象，例如`title`、`description`和`id`。`QuestSingleton`类负责检索和管理任务。
- en: 'To do that, it has three core methods:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，它有三个核心方法：
- en: '`QuestSingleton.retrieve_quests()`: Requests all the available quests for the
    players from the `QuestDatabase` singleton. We talked about `QuestDatabase` in
    the *Loading and storing quests with* *QuestDatabase* section.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QuestSingleton.retrieve_quests()`: 从`QuestDatabase`单例请求所有可用的任务。我们在*使用QuestDatabase加载和存储任务*部分讨论了`QuestDatabase`。'
- en: '`QuestSingleton.create_quest()`: Receives a `quest_data` dictionary with all
    the relevant data to create a `Quest` node, then it instantiates a `Quest` and
    maps it to the `QuestSingleton.quests` dictionary using the quest ID. This allows
    other classes to access the `Quest` node using the quest ID in the upcoming method.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QuestSingleton.create_quest()`: 接收一个包含创建 `Quest` 节点所需所有相关数据的 `quest_data`
    字典，然后它实例化一个 `Quest` 并将其映射到 `QuestSingleton.quests` 字典中，使用任务 ID。这允许其他类在即将到来的方法中使用任务
    ID 访问 `Quest` 节点。'
- en: '`QuestSingleton.get_quest()`: Receives a `quest_id` value as an argument and
    uses it to return the given `Quest` node associated with the provided ID.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QuestSingleton.get_quest()`: 接收一个作为参数的 `quest_id` 值，并使用它来返回与提供的 ID 相关的给定 `Quest`
    节点。'
- en: '`QuestSingleton.increase_quest_progress()`: Receives a `quest_id` value as
    an argument and an `amount` value to determine how much to increase in the provided
    quest’s progress.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QuestSingleton.increase_quest_progress()`: 接收一个作为参数的 `quest_id` 值和一个 `amount`
    值，以确定在提供的任务进度中增加多少。'
- en: 'In the following code, we can see how these behaviors were implemented:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们可以看到这些行为是如何实现的：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With that, `QuestSingleton` is able to retrieve all the quests the player is
    currently engaged in and provide them to user classes so they can access and work
    with said quests. This will allow us to actually increase the players’ progress
    in a given quest. For that, we will understand how the `QuestProgress` node works.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个功能，`QuestSingleton` 能够检索玩家当前参与的所有任务，并将它们提供给用户类，以便它们可以访问并处理这些任务。这将使我们能够实际上增加玩家在特定任务中的进度。为此，我们将了解
    `QuestProgress` 节点的工作原理。
- en: Increasing quests’ progress
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增加任务进度
- en: Back in the `Asteroid` scene, we have the `QuestProgress` node. This node is
    responsible for communicating to the quest system when the player makes progress
    in a given quest. To know which quest `QuestProgress` refers to, we use a variable
    called `quest_id`, and this is a fundamental concept in our quest system. Through
    this data, other classes of the system can communicate with each other, requesting
    changes or retrieving information about a given quest.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Asteroid` 场景中，我们有 `QuestProgress` 节点。此节点负责在玩家在特定任务中取得进展时向任务系统通信。为了知道 `QuestProgress`
    指的是哪个任务，我们使用一个名为 `quest_id` 的变量，这是我们任务系统中的一个基本概念。通过这些数据，系统中的其他类可以相互通信，请求更改或检索有关特定任务的信息。
- en: On top of that, the `QuestProgress` class has a method called `increase_quest_progress()`,
    which requests `QuestSingleton`, referred to as `Quests`, to increase the quest’s
    progress by the `amount` value provided, by default `1`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`QuestProgress` 类有一个名为 `increase_quest_progress()` 的方法，该方法请求 `QuestSingleton`（称为
    `Quests`），通过提供的 `amount` 值（默认为 `1`）来增加任务的进度。
- en: 'We saw how `QuestSingleton` works in the *Managing players’ quests* section.
    Nonetheless, in the following code snippet, we can see the `QuestProgress` class’
    code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *管理玩家任务* 部分中看到了 `QuestSingleton` 的工作方式。尽管如此，在下面的代码片段中，我们可以看到 `QuestProgress`
    类的代码：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The`QuestProgress` node itself is a small component of the system that works
    on the very end of the system, where the final output is processed. It is meant
    to be used by other classes to trigger its behavior. For instance, as mentioned
    in the *Gauging the Asteroid scene* section, the `Asteroid` node uses its `tree_exiting`
    signal to trigger the `QuestProgress.increase_progress()` method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuestProgress` 节点本身是系统的一个小组件，它在系统的最后端工作，即最终输出被处理的地方。它旨在被其他类用来触发其行为。例如，如 *评估小行星场景*
    部分中提到的，`Asteroid` 节点使用其 `tree_exiting` 信号来触发 `QuestProgress.increase_progress()`
    方法。'
- en: This concludes our quest system onboarding. Throughout this section, we understood
    how objects can increase a quest’s progress, how we retrieve quests and players’
    progress from a database, how and what kind of data we store in the database files,
    and how this data ends up in a node in which we can implement higher-level behavior.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的任务系统入门。在本节中，我们了解了对象如何增加任务的进度，我们如何从数据库中检索任务和玩家的进度，我们在数据库文件中存储了哪些数据和类型的数据，以及这些数据最终如何进入我们可以实现高级行为的节点。
- en: Our onboarding process is not over yet. In the upcoming section, we will understand
    how players will actually see the quest information in `QuestPanel` node, which
    is a component of the last piece of our prototype, the `World` scene. It is in
    this scene that all the action actually happens, so stay focused, and let’s see
    how this works.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的入门流程还没有结束。在接下来的部分中，我们将了解玩家如何在 `QuestPanel` 节点中看到任务信息，这是我们的原型最后一块，即 `World`
    场景的一个组件。实际上所有的动作都发生在这个场景中，所以请保持专注，让我们看看它是如何工作的。
- en: Breaking down the World scene
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拆解世界场景
- en: Everything we’ve seen so far will come together into the `World` scene. This
    is the scene where everything is put together to interact. It’s the `World` scene
    that we use to test our current prototype. To do so, open the `res://09.prototyping-space-adventure/Levels/World.tscn`
    scene and hit the **Run Current Scene** button. You will be able to test the game
    and get a feel for the prototype.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们所看到的一切都将汇聚成`世界`场景。这是一个将所有元素组合起来进行交互的场景。这就是我们用来测试当前原型的`世界`场景。为此，打开`res://09.prototyping-space-adventure/Levels/World.tscn`场景并点击**运行当前场景**按钮。你将能够测试游戏并感受原型的效果。
- en: Now, in this section, we are going to understand how we create asteroids and
    players in the game, and how we display the player’s quest log on the screen.
    The world itself is a high-level abstraction scene, so things are easier to understand.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在本节中，我们将了解如何在游戏中创建小行星和玩家，以及如何在屏幕上显示玩家的任务日志。世界本身是一个高级抽象场景，因此事情更容易理解。
- en: The scene itself is a node called `Main` that has a `RadialSpawner` child node
    called `Asteroids` responsible for spawning asteroids around it, a `Spawner` node
    called `Players` responsible for spawning `Player` instances, and some `CanvasLayers`
    nodes to create the overall visual of the game, namely `BackgroundLayer` node,
    which uses a `ColorRect` node to set the game’s background color, then `ParallaxBackground`
    node, which has a `ParallaxLayer` node containing a `GPUParticles2D` node that
    creates a repeating starfield for the background.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 场景本身是一个名为`Main`的节点，它有一个名为`Asteroids`的`RadialSpawner`子节点，负责在其周围生成小行星，一个名为`Players`的`Spawner`节点，负责生成`Player`实例，以及一些`CanvasLayers`节点来创建游戏的整体视觉，即`BackgroundLayer`节点，它使用`ColorRect`节点设置游戏背景颜色，然后是`ParallaxBackground`节点，它包含一个`ParallaxLayer`节点，该节点包含一个`GPUParticles2D`节点，用于创建背景的重复星系。
- en: 'Finally, we also have `InterfaceCanvasLayer` node, which, as the name suggests,
    contains interface elements. Here, we have an important element to wrap up the
    quest system: `QuestPanel` node. We are going to talk about it in the *Displaying
    quest information* section. In the following screenshot, we can see the `World`
    scene node hierarchy:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还有一个名为`InterfaceCanvasLayer`的节点，正如其名称所暗示的，它包含界面元素。在这里，我们有一个重要的元素来总结任务系统：`QuestPanel`节点。我们将在*显示任务信息*部分讨论它。在下面的屏幕截图中，我们可以看到`World`场景节点的层次结构：
- en: '![Figure 9.8 – The World scene node’s hierarchy](img/Figure_09.08_B18527.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8 – 世界场景节点的层次结构](img/Figure_09.08_B18527.jpg)'
- en: Figure 9.8 – The World scene node’s hierarchy
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 世界场景节点层次结构
- en: Here, we were able to structure a prototype that spawns some Asteroids around
    a given area, spawns a pPlayer, and displays the player’s quest log with the current
    active quests and their information. In the next section, let’s understand how
    the `QuestPanel` node gathers, displays, and updates information about the player’s
    quests.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们能够构建一个原型，在该区域周围生成一些小行星，生成一个pPlayer，并显示带有当前活跃任务及其信息的玩家任务日志。在下一节中，我们将了解`QuestPanel`节点如何收集、显示和更新玩家任务的信息。
- en: Displaying quest information
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示任务信息
- en: In the end, the quest system has a main responsibility that summarizes everything
    we’ve seen so far regarding it. It has to display information about the current
    active quests to the player. This funnels down to `QuestPanel` node, which is
    a UI element that displays such information based on the data it gathers from
    `QuestSingleton` node. In this section, we are going to understand how `QuestPanel`
    node works. To do so, open the `res://09.prototyping-space-adventure/Quests/QuestPanel.tscn`
    scene.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，任务系统有一个主要责任，总结了迄今为止我们所看到的所有关于它的内容。它必须向玩家显示当前活跃任务的信息。这最终归结为`QuestPanel`节点，它是一个UI元素，根据从`QuestSingleton`节点收集的数据显示此类信息。在本节中，我们将了解`QuestPanel`节点的工作原理。为此，打开`res://09.prototyping-space-adventure/Quests/QuestPanel.tscn`场景。
- en: Note that `QuestPanel` node itself extends the `ScrollContainer` class and it
    has a `VBoxContainer` node as its child. This allows us to display many quests
    for the player and they will be able to navigate these quests using a scrollbar.
    We currently have only one quest, as seen in the `QuestDatabase.json` file, but
    the ground is paved for more quests. Now, open the `QuestPanel` script, and let’s
    see how it implements displaying quest information.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`QuestPanel`节点本身扩展了`ScrollContainer`类，并且它有一个作为其子节点的`VBoxContainer`节点。这使我们能够为玩家显示许多任务，并且他们可以使用滚动条来导航这些任务。我们目前只有一个任务，如`QuestDatabase.json`文件所示，但为更多任务铺平了道路。现在，打开`QuestPanel`脚本，让我们看看它是如何实现显示任务信息的。
- en: 'The first thing it does right at the `_ready()` callback is to connect the
    `Quests` singleton’s `quest_created` signal to `QuestPanel`’s `add_quest()` method.
    Then it tells the `Quests` singleton to retrieve quests, which will populate the
    `Quests` singleton with the players’ quests. Every time the `Quests` singleton
    creates a new `Quest` node, adding it as its child, it emits a signal that the
    `QuestPanel` node listens to and calls the `add_quest()` method. Let’s talk about
    the `QuestPanel` node member variables and methods:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它在 `_ready()` 回调中首先做的事情是将 `Quests` 单例的 `quest_created` 信号连接到 `QuestPanel` 的
    `add_quest()` 方法。然后它告诉 `Quests` 单例检索任务，这将用玩家的任务填充 `Quests` 单例。每当 `Quests` 单例创建一个新的
    `Quest` 节点并将其作为其子节点添加时，它都会发出一个信号，`QuestPanel` 节点会监听并调用 `add_quest()` 方法。让我们来谈谈
    `QuestPanel` 节点的成员变量和方法：
- en: '`quests_labels` is a dictionary used to map `Label` nodes to their reference
    using the `Quest.id` property as the key.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quests_labels` 是一个字典，用于使用 `Quest.id` 属性作为键将 `Label` 节点映射到它们的引用。'
- en: The `add_quest()` method creates a new `Label` node and sets its `text` property
    to a formatted String using the information from the `Quest` node stored in the
    quest property. It also connects the `quest.updated` signal to its `update_quest()`
    method, which we are going to talk about in a moment. Then, it adds this `Label`
    node as a child of the`VBoxContainer` node and maps it in the `quests_labels`
    property for further reference.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_quest()` 方法创建一个新的 `Label` 节点，并使用存储在 `quest` 属性中的 `Quest` 节点的信息将 `text`
    属性设置为格式化的字符串。它还将 `quest.updated` 信号连接到其 `update_quest()` 方法，我们将在稍后讨论该方法。然后，它将这个
    `Label` 节点作为 `VBoxContainer` 节点的子节点添加，并在 `quests_labels` 属性中映射以供进一步参考。'
- en: The `update_quest()` method takes the `quest_id` String and the `current_amount`
    integer as arguments, and uses the `quest_id` argument to find the proper `Label`
    node to update the text with the updated quest data.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_quest()` 方法接受 `quest_id` 字符串和 `current_amount` 整数作为参数，并使用 `quest_id`
    参数找到适当的 `Label` 节点，用更新的任务数据更新文本。'
- en: 'This behavior is expressed in the following code snippet if you want to understand
    the concrete implementation of how this all happens:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解这一切的具体实现，以下代码片段表达了这种行为：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With that, we close our quest system onboarding, and you are ready to understand
    how you will use it for our online multiplayer version of the prototype! You’ve
    seen it all, how objects can update quest progress, where quests are gathered
    and stored, how we load and save a player’s progress in a given quest, how we
    implement a node to represent a quest in our game, and finally, how this all comes
    together to display the quest’s information to the player in a UI element.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就完成了对任务系统的入门，你现在准备好了解你将如何使用它来处理我们的在线多人游戏原型的版本！你已经看到了一切，包括对象如何更新任务进度，任务在哪里收集和存储，我们如何加载和保存玩家在特定任务中的进度，我们如何在游戏中实现表示任务的节点，以及最后，这一切是如何组合在一起，在
    UI 元素中向玩家显示任务信息的。
- en: In the upcoming section, we will see how the World’s `Main` node works. Its
    main responsibility is to ensure the game world is running as planned with all
    objects in their proper places.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将了解世界的主节点是如何工作的。其主要职责是确保游戏世界按计划运行，所有对象都处于正确的位置。
- en: Initializing the game world
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化游戏世界
- en: To ensure that the game runs as we plan, at least its initialization, we have
    the `Main` node. It essentially spawns 30 `Asteroid` instances using the `Asteroids`
    node and creates an instance of the `Player` scene using the `Players` node. As
    explained at the beginning of the *Breaking down the World scene* section, the
    latter two nodes are spawners.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保游戏按我们的计划运行，至少是初始化，我们有 `Main` 节点。它本质上使用 `Asteroids` 节点生成 30 个 `Asteroid`
    实例，并使用 `Players` 节点创建 `Player` 场景的实例。正如在 *分解 World 场景* 部分的开头所解释的，后两个节点是生成器。
- en: 'In this local gameplay prototype, the `Main` node is really simple, but keep
    it in mind, especially regarding its responsibility, when you start implementing
    the online multiplayer features. For reference, the `Main` node script is shown
    in the following code snippet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个本地游戏原型中，`Main` 节点非常简单，但请记住，特别是关于其职责，当你开始实现在线多人游戏功能时。为了参考，`Main` 节点脚本在下面的代码片段中显示：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that it has a `create_spaceship()` method instead of directly calling the
    `player_spawner.spawn()` method. This will help you with your job later on, so
    you can thank our fake team for making your job easier.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它有一个 `create_spaceship()` 方法，而不是直接调用 `player_spawner.spawn()` 方法。这将有助于你后续的工作，所以你可以感谢我们的假团队使你的工作变得更简单。
- en: And with that, your onboarding process is done! We’ve seen how the player controls
    their spaceship, how the asteroids take hits and explode, increasing the player’s
    progress in a quest, how the quest system works, and what it handles and outputs.
    We’ve also just seen how the game world initializes and establishes where each
    object should be and how many of them there should be.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，你的入职流程完成了！我们已经看到了玩家如何控制他们的宇宙飞船，小行星如何受到打击并爆炸，从而增加玩家在任务中的进度，任务系统是如何工作的，以及它处理和输出的内容。我们还刚刚看到了游戏世界是如何初始化并确定每个对象应该在哪里以及应该有多少个对象。
- en: Now, it’s time for the magic. In the upcoming sections, we are going to see
    how we will turn this prototype into an online multiplayer game prototype where
    players can join anytime, so there won’t be a lobby. We will also understand what
    we need to do to keep the players’ world in sync with the server’s world and how
    we separate the server and client’s responsibilities using the same script. This
    will be useful especially when handling our databases to prevent players from
    cheating and completing quests without effort.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候展示魔法了。在接下来的章节中，我们将看到如何将这个原型转变为一个在线多人游戏原型，玩家可以随时加入，因此不会有大厅。我们还将了解我们需要做什么来保持玩家的世界与服务器世界的同步，以及我们如何使用相同的脚本区分服务器和客户端的职责。这在我们处理数据库时特别有用，以防止玩家作弊和轻松完成任务。
- en: Logging the player in to the server
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将玩家登录到服务器
- en: In this section, we will implement a different type of logging system. This
    time, the players don’t have a lobby screen where they wait for other players
    to join a game and start a match. No, here the world is always active; it doesn’t
    start only when the players ask the server to start the match or the game. And
    this type of connection requires a different approach.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现不同类型的日志记录系统。这次，玩家没有大厅屏幕，他们可以在那里等待其他玩家加入游戏并开始比赛。不，在这里，世界始终处于活跃状态；它不仅仅是在玩家请求服务器开始比赛或游戏时才开始。这种类型的连接需要不同的方法。
- en: The major problem is that since the game world is always active and running,
    the players who join this world need to sync their game instance to the server’s
    game instance. This includes the position of objects, new objects that usually
    are not part of the world, for instance, other players and the number of objects
    (in our case, how many asteroids are currently available), and many other factors
    necessary to build a shared world.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 主要问题是由于游戏世界始终处于活跃和运行状态，加入这个世界的玩家需要将他们的游戏实例与服务器上的游戏实例同步。这包括对象的位置，通常不是世界一部分的新对象，例如，其他玩家和对象的数量（在我们的例子中，当前有多少小行星可用），以及构建共享世界所需的其他许多因素。
- en: It all starts with the player authentication, because now the server and the
    client are in different parts of the game life cycle; while the player is just
    opening the game, the server is already handling the game world.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都从玩家认证开始，因为现在服务器和客户端处于游戏生命周期的不同部分；当玩家刚刚打开游戏时，服务器已经在处理游戏世界了。
- en: Authenticating players
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证玩家
- en: Don’t panic, yet. Besides the conditions of authentication being different,
    the overall logic is very much the same as the one we’ve been using so far. The
    major difference here is that we will need to have an `Authentication` node dedicated
    to each side of the connection performing the authentication procedure according
    to the client or server’s responsibilities.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 不要恐慌，尽管认证的条件不同，但整体逻辑与迄今为止我们所使用的非常相似。这里的主要区别是我们将需要一个专门的`Authentication`节点，针对连接的每一方执行认证程序，根据客户端或服务器的职责进行。
- en: 'These nodes will be on the two major points of interaction for each side of
    the connection:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些节点将位于连接两端的两个主要交互点：
- en: For the client, in this case the player, we will have the `Authentication` node
    on the `LoggingScreen` scene
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于客户端，在这种情况下是玩家，我们将在`LoggingScreen`场景中设置`Authentication`节点
- en: For the server we will have its `Authentication` node on the `World` scene itself,
    waiting for players to join
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于服务器，我们将在`World`场景本身上设置其`Authentication`节点，等待玩家加入
- en: Note that for each side of this relationship, we will implement distinct authentication
    procedures. So, besides both nodes being called `Authentication` and having the
    same path, in other words, both being direct children of a parent node called
    `Main`, they will be totally different classes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于这个关系的每一方，我们将实施不同的认证程序。所以，除了这两个节点都被称为`Authentication`并且有相同的路径，换句话说，它们都是名为`Main`的父节点的直接子节点之外，它们将是完全不同的类。
- en: They will need shared methods, but we will see that the method implementations
    are different. This is all due to how RPCs work. Remember, when making an RPC,
    it will look for a node with the same node path in all peer game instances, and
    this node must have all the same methods as the one making the RPC, even if we
    are not calling these other methods. This means that the server side will share
    client-side methods, and vice versa.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 他们将需要共享的方法，但我们会看到方法实现是不同的。这都归因于 RPC 的工作方式。记住，当创建 RPC 时，它将在所有对等游戏实例中寻找具有相同节点路径的节点，并且这个节点必须拥有与创建
    RPC 的节点相同的所有方法，即使我们并没有调用这些其他方法。这意味着服务器端将共享客户端方法，反之亦然。
- en: This will get less confusing once we start to implement it, so let’s open the
    `res://09.prototyping-space-adventure/LoggingScreen.tscn` scene and implement
    the client side of the authentication.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始实现它，这就会变得不那么令人困惑，所以让我们打开 `res://09.prototyping-space-adventure/LoggingScreen.tscn`
    场景并实现身份验证的客户端部分。
- en: Implementing client-side authentication
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现客户端身份验证
- en: In the `LoggingScreen` scene, you will notice a scene structure meant to be
    a simple logging screen where players insert their credentials, get authenticated,
    and log in to the game. This is a bit similar to the lobby we’ve been using in
    previous chapters, such as the one in [*Chapter 8*](B18527_08.xhtml#_idTextAnchor162),
    *Designing an Online* *Co-Op Platformer*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LoggingScreen` 场景中，你会注意到一个旨在作为简单登录屏幕的场景结构，玩家在此处输入他们的凭据，进行身份验证并登录游戏。这与我们在之前章节中使用的，例如在
    [*第 8 章*](B18527_08.xhtml#_idTextAnchor162) 中使用的 *设计在线合作平台游戏* 的大厅有些相似。
- en: This time, we don’t have a panel showcasing the current players; this is not
    necessary as players can join the game and experience individually even when other
    players are not around. Note that the scene’s script is attached to the `Authentication`
    node this time, instead of attached to the `Main` node.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们没有展示当前玩家的面板；这不是必要的，因为即使其他玩家不在场，玩家也可以加入游戏并单独体验。请注意，这次场景的脚本被附加到了 `Authentication`
    节点，而不是 `Main` 节点。
- en: This is because in the `World` scene, the `Main` node has other responsibilities,
    so it’s better to delegate the authentication to an exclusive node. Due to that,
    `LoggingScreen`’s authentication was also delegated to its `Authentication` node.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在 `World` 场景中，`Main` 节点有其他职责，所以最好将身份验证委托给一个专门的节点。因此，`LoggingScreen` 的身份验证也被委托给了它的
    `Authentication` 节点。
- en: '![Figure 9.9 – The LoggingScreen scene’s node hierarchy'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.9 – LoggingScreen 场景的节点层次结构'
- en: '](img/Figure_09.09_B18527.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_09.09_B18527.jpg)'
- en: Figure 9.9 – The LoggingScreen scene’s node hierarchy
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – LoggingScreen 场景的节点层次结构
- en: 'Now, open the `res://09.prototyping-space-adventure/LoggingScreen.gd` script
    file. You will notice there are a lot of things in common with what we’ve created
    in [*chapter 3*](B18527_03.xhtml#_idTextAnchor065), *Making a Lobby to Gather
    Players Together*, so let’s focus on the necessary work we need to do this time:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开 `res://09.prototyping-space-adventure/LoggingScreen.gd` 脚本文件。你会注意到其中有很多与我们之前在
    [*第 3 章*](B18527_03.xhtml#_idTextAnchor065) 中创建的内容相似，即 *制作一个大厅以聚集玩家*，所以让我们专注于这次需要完成的工作：
- en: 'Since this time we are only communicating with the server, we don’t need to
    start the game on all peers, so in the `_on_StartButton_pressed()` callback, we
    need to send an RPC directly to the server asking it to start the game:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这次我们只与服务器通信，我们不需要在所有对等体上启动游戏，所以在这个 `_on_StartButton_pressed()` 回调中，我们需要直接向服务器发送
    RPC 请求它启动游戏：
- en: '[PRE13]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The server itself will then authenticate the player, and if everything goes
    well, the server will also call the client’s `start_game()` method, which has
    a different implementation. In the client, `start_game()` is an RPC that only
    the network authority can call and is called locally. When called, it switches
    the current scene to the `next_scene` property, which in this case will be the
    `World` scene:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，服务器本身将对玩家进行身份验证，如果一切顺利，服务器还将调用客户端的 `start_game()` 方法，该方法有不同的实现。在客户端，`start_game()`
    是一个只有网络权威可以调用的 RPC，并且是本地调用的。当调用时，它将当前场景切换到 `next_scene` 属性，在这种情况下将是 `World` 场景：
- en: '[PRE14]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Alright, most of the code is very similar to the `one` we have in the implementations
    of the `Lobby` scene. This one is cleaner as we’ve removed other methods such
    as the ones we used to display logged players or display avatars.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，大部分代码与我们在 `Lobby` 场景实现中拥有的代码非常相似。这个更简洁，因为我们已经移除了其他方法，例如我们用来显示已登录玩家或显示头像的方法。
- en: With these changes, this code is able to send a direct request authentication
    for the server and start the game on this instance of the game. In the next section,
    we will see the other side of this system, the server side.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，此代码能够发送直接请求认证给服务器，并在游戏的此实例上启动游戏。在下一节中，我们将看到这个系统的另一面，即服务器端。
- en: Implementing server-side authentication
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现服务器端认证
- en: Now, the server-side authentication is a bit trickier. Previously, all that
    we needed to do was to handle the player’s authentication requests. But now, since
    the authentication happens while the server is already running the game, we need
    to transfer the responsibility of setting up the hosting as well.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，服务器端认证要复杂一些。之前，我们只需要处理玩家的认证请求。但现在，由于认证是在服务器运行游戏的同时进行的，我们还需要转移设置托管的责任。
- en: This means that if the current instance is the server, it will need to set up
    `ENetMultiplayerPeer` on top of authenticating players’ credentials as well. Open
    the `res://09.prototyping-space-adventure/Authentication.gd` file and let’s make
    the necessary changes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果当前实例是服务器，它将需要在认证玩家凭证的基础上设置`ENetMultiplayerPeer`。打开`res://09.prototyping-space-adventure/Authentication.gd`文件，让我们进行必要的更改。
- en: 'Again, we will focus only on what we need to change based on the work we did
    previously, so feel free to go through the other parts of the script if you don’t
    remember how this all works:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们只会关注基于之前工作的更改，所以如果你不记得所有这些是如何工作的，可以自由地浏览脚本的其他部分：
- en: 'In the `_ready()` callback, let’s create the `ENet` server using the default
    `PORT`. Remember, since this script will be running on both the client and server,
    we will need to check whether the current instance running is the server. For
    that, we use the `multiplayer.is_server()` method. After setting up the server,
    we load the users’ database to properly authenticate them as usual:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`_ready()`回调中，让我们使用默认的`PORT`创建`ENet`服务器。记住，由于这个脚本将在客户端和服务器上运行，我们需要检查当前运行的实例是否是服务器。为此，我们使用`multiplayer.is_server()`方法。设置服务器后，我们将加载用户数据库，以便像往常一样正确地认证他们：
- en: '[PRE15]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The second thing we need to do is to connect as a client if the instance is
    not the server:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第二件事是如果实例不是服务器，则以客户端的身份连接：
- en: '[PRE16]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The third thing we need to do is to set up the `start_game()` method to respond
    to all peers remotely, so this method won’t be called locally in the server’s
    instance. Inside this method, we will make an RPC to the peer that requested the
    game to start telling their instance to start the game.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第三件事是设置`start_game()`方法以响应所有远程的节点，因此这个方法在服务器的实例中不会本地调用。在这个方法内部，我们将对请求启动游戏的节点进行RPC调用，告诉它们的实例启动游戏。
- en: 'This allows the server to dictate whether the player can or cannot join the
    game, and if the player happens to try to connect locally, simply pressing the
    start button won’t actually start the game as their instance will hang, waiting
    for a response from the server:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这允许服务器决定玩家是否可以加入游戏，如果玩家尝试本地连接，仅仅按下开始按钮实际上并不会启动游戏，因为他们的实例会挂起，等待服务器的响应：
- en: '[PRE17]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With these changes, we are able to have a server that can run an independent
    instance of the game and wait for players to join it. Using the `rpc_id()` method,
    we can pinpoint which peer we want to contact and establish direct communication
    between instances of the game. In this case, we did that with the server and the
    client, but we can do it between two clients as well if necessary.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，我们能够拥有一个可以运行独立游戏实例并等待玩家加入的服务器。使用`rpc_id()`方法，我们可以确定我们想要联系哪个节点，并在游戏实例之间建立直接通信。在这种情况下，我们是在服务器和客户端之间这样做，但如果需要，我们也可以在两个客户端之间这样做。
- en: In the next section, we are going to focus on how to sync the server’s persistent
    `World` scene with the players’ `World` scene, which may not reflect the current
    state of the shared game world.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将关注如何同步服务器的持久`World`场景与玩家的`World`场景，这些场景可能不会反映共享游戏世界的当前状态。
- en: Syncing the World scenes
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步`World`场景
- en: When the player logs in to the game, their world will likely be different from
    the server’s world. For instance, only the server should be able to spawn asteroids,
    and even if the client were able to spawn them, there would be nothing to guarantee
    they would be in the same position. So, this is the first thing we are going to
    fix.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家登录游戏时，他们的世界可能不同于服务器世界。例如，只有服务器应该能够生成小行星，即使客户端能够生成它们，也无法保证它们会在相同的位置。所以，这是我们首先要解决的问题。
- en: In the next section, we will see how we can sync the `Asteroid` instances from
    the server’s world into the client’s world.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何将服务器世界的 `Asteroid` 实例同步到客户端的世界中。
- en: Syncing the asteroids
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同步小行星
- en: Open the `Asteroid` scene again and let’s add a new `MultiplayerSynchronizer`
    as its child. This `MultiplayerSynchronizer` will replicate the asteroid’s `position`
    and `top_level` properties. The following figure showcases the asteroid’s **MultiplayerSynchronizer
    Replication** **Menu** settings.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开 `Asteroid` 场景，并添加一个新的 `MultiplayerSynchronizer` 作为其子节点。这个 `MultiplayerSynchronizer`
    将复制小行星的 `position` 和 `top_level` 属性。以下图展示了小行星的 **MultiplayerSynchronizer 复制**
    **菜单** 设置。
- en: '![Figure 9.10 – The Asteroid’s MultiplayerSynchronizer Replication Menu settings](img/Figure_09.10_B18527.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – 小行星的多人同步器复制菜单设置](img/Figure_09.10_B18527.jpg)'
- en: Figure 9.10 – The Asteroid’s MultiplayerSynchronizer Replication Menu settings
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 小行星的多人同步器复制菜单设置
- en: Then, we are going to use something really interesting regarding network replication.
    The `MultiplayerSynchronizer` node has a property called `World` scene. So, we
    will toggle that property off. In the following screenshot, we can see what this
    property should look like in the **Inspector**.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用一些关于网络复制的非常有趣的东西。`MultiplayerSynchronizer` 节点有一个名为 `World` 场景的属性。因此，我们将关闭该属性。在下面的屏幕截图中，我们可以看到这个属性在
    **检查器** 中应该是什么样子。
- en: '![Figure 9.11 – The asteroid’s MultiplayerSynchronizer Public Visibility property
    in the Inspector](img/Figure_9.11_B18527.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 小行星的 MultiplayerSynchronizer 公共可见性属性在检查器中](img/Figure_09.11_B18527.jpg)'
- en: Figure 9.11 – The asteroid’s MultiplayerSynchronizer Public Visibility property
    in the Inspector
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 小行星的 MultiplayerSynchronizer 公共可见性属性在检查器中
- en: Before we move on to the next necessary steps, I want to present you with a
    trick that will help you synchronize relevant objects all at once. Add `MultiplayerSynchronizer`
    node inside a group so that you can perform a group call using `SceneTree` later
    on. In this case, to be clearer about the group’s intent, let’s call it `Sync`.
    The following screenshot showcases this group with the `Asteroid` node’s `MultiplayerSynchronizer`
    node inside of it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行下一步必要的步骤之前，我想向您展示一个技巧，这个技巧将帮助您一次性同步相关对象。在组内添加 `MultiplayerSynchronizer`
    节点，这样您就可以稍后使用 `SceneTree` 执行组调用。在这种情况下，为了更清楚地说明组的意图，让我们称它为 `Sync`。下面的屏幕截图展示了这个组，其中包含
    `Asteroid` 节点的 `MultiplayerSynchronizer` 节点。
- en: '![Figure 9.12 – The asteroid’s MultiplayerSynchronizer inside the Sync group](img/Figure_9.12_B18527.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – 小行星的 MultiplayerSynchronizer 在 Sync 组内](img/Figure_09.12_B18527.jpg)'
- en: Figure 9.12 – The asteroid’s MultiplayerSynchronizer inside the Sync group
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 小行星的 MultiplayerSynchronizer 在 Sync 组内
- en: 'With that, the `Asteroid` instances are ready to replicate their properties
    on the client’s `World` instance. But there’s still a problem. The client’s `World`
    instance should not create these `Asteroid` instances; instead, only the server
    should be able to spawn these objects. So, let’s open the `World` scene and set
    it up for synchronization:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`Asteroid` 实例就准备好在客户端的 `World` 实例上复制它们的属性了。但还有一个问题。客户端的 `World` 实例不应该创建这些
    `Asteroid` 实例；相反，只有服务器应该能够生成这些对象。所以，让我们打开 `World` 场景并为其设置同步：
- en: 'The first thing we need to do is to add a `MultiplayerSpawner` node that points
    to the `Asteroids` node. Let’s call it `AsteroidsMultiplayerSpawner`, and it should
    have the `Asteroid` scene set up as its first and only element in the **Auto Spawn
    List** property. We can see these properties configured in the following screenshot:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是添加一个指向 `Asteroids` 节点的 `MultiplayerSpawner` 节点。让我们称它为 `AsteroidsMultiplayerSpawner`，并且它应该在
    **自动生成列表** 属性中设置 `Asteroid` 场景作为其第一个也是唯一元素。我们可以在下面的屏幕截图中看到这些属性的配置：
- en: '![Figure 9.13 – The world’s AsteroidsMultiplayerSpawner properties in the Inspector](img/Figure_9.13_B18527.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13 – 世界的小行星 MultiplayerSpawner 属性在检查器中](img/Figure_09.13_B18527.jpg)'
- en: Figure 9.13 – The world’s AsteroidsMultiplayerSpawner properties in the Inspector
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – 世界的小行星 MultiplayerSpawner 属性在检查器中
- en: This will ensure that all the instances of the server’s world asteroids will
    also exist in the client’s world as well. But note that until now, they will only
    be spawned, but not synced yet. So, let’s fix that. Open the `World` script and
    let’s set it up for the sync logic.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保服务器世界中小行星的所有实例也将存在于客户端世界中。但请注意，到目前为止，它们只是被生成，还没有同步。所以，让我们解决这个问题。打开`World`脚本，让我们为同步逻辑进行设置。
- en: 'First things first, in the `_ready()` callback, we need to prevent the `World`
    node from spawning asteroids if it isn’t the server. It should request synchronization
    from the server instead. For that, it will make an RPC to the server’s `sync_world`
    method, which we will create in the next step:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`_ready()`回调中，我们需要防止如果不是服务器，`World`节点生成小行星。它应该从服务器请求同步。为此，它将向服务器的`sync_world`方法发出RPC调用，我们将在下一步创建该方法：
- en: '[PRE18]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then, let’s create the `sync_world()` RPC method, which can be called by any
    peer locally. It needs to be called locally because we will tell the server’s
    `Asteroid` instances’ `MultiplayerSynchronizer` nodes, which are in the `Sync`
    group, to add the player to their visibility list, effectively syncing the `Asteroid`
    instances.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们创建`sync_world()` RPC方法，它可以由任何本地玩家调用。它需要在本地调用，因为我们将会告诉服务器的`Asteroid`实例的`MultiplayerSynchronizer`节点，它们位于`Sync`组中，将玩家添加到它们的可见列表中，从而有效地同步`Asteroid`实例。
- en: '[PRE19]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`set_visibility_for()` is a method from the `MultiplayerSynchronizer` node
    that adds a peer to its visibility list, which basically means a whitelist of
    peers it should synchronize to.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_visibility_for()`是`MultiplayerSynchronizer`节点的一个方法，它将一个玩家添加到其可见列表中，这基本上意味着一个白名单，列出了它应该同步的玩家。'
- en: For that, it uses the peer’s ID and receives a Boolean to tell it whether this
    peer should or shouldn’t see the replication of the properties set in `multiplayer.get_remote_sender_id()`
    method, so whoever requests to sync will be synced.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，它使用玩家的ID，并接收一个布尔值来告诉它这个玩家是否应该或不应该看到在`multiplayer.get_remote_sender_id()`方法中设置的属性的复制，所以任何请求同步的玩家都将被同步。
- en: This is all we need for the syncing of the asteroids. Now, we are still missing
    the players and their spaceships, right? In the next section, we will see how
    to remotely create `Player` instances on all connected peers, sync their spaceships,
    and only allow their owner to control the spaceship.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是同步小行星所需的所有内容。现在，我们仍然缺少玩家和他们的宇宙飞船，对吧？在下一节中，我们将了解如何远程在所有已连接的玩家上创建`Player`实例，同步他们的宇宙飞船，并且只允许其所有者控制宇宙飞船。
- en: Syncing the players
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同步玩家
- en: It’s time to put our players together in this vast world. In this section, we
    will understand how we sync players’ scenes that were already in the World when
    another player joins the game.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将我们的玩家放入这个广阔的世界中了。在本节中，我们将了解当另一个玩家加入游戏时，如何同步已经在世界中的玩家场景。
- en: 'Let’s get started:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'Still in the `World` script, we are going to turn the `create_spaceship()`
    method into an RPC method that any peer can call remotely:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`World`脚本中，我们将把`create_spaceship()`方法转换成一个任何玩家都可以远程调用的RPC方法：
- en: '[PRE20]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Due to how the `Players` spawner works, we won’t be able to do the proper renaming
    and identification of the newly created spaceship before it syncs to other peers.
    So, the `create_spaceship()` method takes the responsibility of spawning spaceships
    as well.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`Players`生成器的工作方式，在与其他玩家同步之前，我们无法对新建的宇宙飞船进行适当的重命名和识别。因此，`create_spaceship()`方法同时负责生成宇宙飞船。
- en: 'Before we add the `spaceship` instance as a child of the `Players` node, we
    will set its name to match the player’s peer ID. This ensures this instance has
    a unique name and we can use this name to identify the proper authority of the
    instance:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们将`spaceship`实例作为`Players`节点的子节点之前，我们将将其名称设置为与玩家的ID匹配。这确保了这个实例有一个唯一的名称，我们可以使用这个名称来识别实例的正确权限：
- en: '[PRE21]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we come to a very important part. We are going to implement the `setup_multiplayer()`
    method in the player, which essentially does the same thing as the one we made
    in [*Chapter 8*](B18527_08.xhtml#_idTextAnchor162), *Designing an Online Co-Op
    Platformer*. So, we can make an RPC to this function here after waiting for `0.1`
    seconds:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来到了一个非常关键的部分。我们将在玩家中实现`setup_multiplayer()`方法，这本质上与我们在[*第8章*](B18527_08.xhtml#_idTextAnchor162)中制作的相同，即*设计一个在线合作平台游戏*。因此，我们可以在等待`0.1`秒后对此函数进行RPC调用：
- en: '[PRE22]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With that, whenever a player asks the server’s `World` instance to create a
    spaceship, it will instantiate a `Player` scene, assign it a unique ID, and ask
    it to configure its multiplayer settings. Remember, since we are doing this using
    an RPC, this means this `Player` instance will configure its multiplayer settings
    in all currently connected peers. But as it is now, only the server has an instance
    of this `Player` node.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样，每当一个玩家请求服务器的`World`实例创建一艘飞船时，它将实例化一个`Player`场景，分配一个唯一的ID，并要求它配置其多人设置。记住，由于我们正在使用RPC来完成此操作，这意味着此`Player`实例将在所有当前连接的对等节点中配置其多人设置。但就目前而言，只有服务器有一个`Player`节点的实例。
- en: To fix that, we are going to add another `MultiplayerSpawner` node called `PlayersMultiplayerSpawner`
    to the `World` scene. Its `Players` node and its `Player` scene, `res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn`.
    In the following screenshot, we can see these properties set up in the **Inspector**.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将在`World`场景中添加另一个名为`PlayersMultiplayerSpawner`的`MultiplayerSpawner`节点。它的`Players`节点及其`Player`场景`res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn`。在以下截图中，我们可以看到这些属性在**检查器**中已设置。
- en: '![Figure 9.14 – The World scene’s PlayersMultiplayerSpawner node properties
    in the Inspector](img/Figure_9.14_B18527.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图9.14 – 世界场景的`PlayersMultiplayerSpawner`节点属性在检查器中的设置](img/Figure_09.14_B18527.jpg)'
- en: Figure 9.14 – The World scene’s PlayersMultiplayerSpawner node properties in
    the Inspector
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – 世界场景的`PlayersMultiplayerSpawner`节点属性在检查器中的设置
- en: Now, since the instances created by the `PlayersMultiplayerSpawner` node will
    still not be configured yet, we also need to call their `setup_multiplayer()`
    method as soon as they spawn.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于由`PlayersMultiplayerSpawner`节点创建的实例仍然尚未配置，我们还需要在它们生成时立即调用它们的`setup_multiplayer()`方法。
- en: 'For that, let’s connect the `PlayersMultiplayerSpawner`‘s `spawned` signal
    to the `World` scene’s `Main` node script, and inside then `_on_players_multiplayer_spawner()`
    callback, we make an RPC on the recently spawned node passing `set_up_multiplayer`
    as argument. This time, we will use the node’s name as an argument instead of
    `player_id`. This is because we don’t have access to the ID of the player that
    is supposed to own this instance, so we can use the instance name instead:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现这一点，让我们将`PlayersMultiplayerSpawner`的`spawned`信号连接到`World`场景的`Main`节点脚本，并在`_on_players_multiplayer_spawner()`回调函数中，对最近生成的节点执行一个带有`set_up_multiplayer`作为参数的RPC。这次，我们将使用节点的名称作为参数而不是`player_id`。这是因为我们没有访问到应该拥有此实例的玩家的ID，因此我们可以使用实例名称：
- en: '[PRE23]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With that, every time a player joins the game, the server will create a new
    `Player` instance for them and set this instance up. This also works for `Player`
    instances that are already in the server’s `World`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样，每当一个玩家加入游戏时，服务器将为他们创建一个新的`Player`实例并设置此实例。这也适用于已经在服务器`World`中的`Player`实例。
- en: If a player joins the game, the server will spawn all other `Player` instances
    that are also currently playing. Now, we need the `Player` scene itself to sync
    its relevant properties to its peers and to implement its `setup_multiplayer`
    method.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一个玩家加入游戏，服务器将生成所有其他当前正在玩的游戏的`Player`实例。现在，我们需要`Player`场景本身同步其相关属性到其对等节点，并实现其`setup_multiplayer`方法。
- en: 'Open the `res://08.designing-online-platformer/Actors/Player/Player2D.tscn`
    scene, and let’s start by adding `MultiplayerSynchronizer` node as a child of
    the `Player` node. This `MultiplayerSynchronizer` node should sync the `Player`
    instance’s `position` and `top_level` properties and the `Spaceship` node’s `position`
    and `rotation` properties. The following screenshot showcases the `Player` scene’s
    **MultiplayerSynchronizer** **Replication Menu**:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`res://08.designing-online-platformer/Actors/Player/Player2D.tscn`场景，让我们首先将`MultiplayerSynchronizer`节点作为`Player`节点的子节点添加。这个`MultiplayerSynchronizer`节点应该同步`Player`实例的`position`和`top_level`属性以及`Spaceship`节点的`position`和`rotation`属性。以下截图展示了`Player`场景的**MultiplayerSynchronizer**
    **复制菜单**：
- en: '![Figure 9.15 – The Player’s MultiplayerSynchronizer Replication Menu](img/Figure_09.15_B18527.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图9.15 – 玩家的多人同步复制菜单](img/Figure_09.15_B18527.jpg)'
- en: Figure 9.15 – The Player’s MultiplayerSynchronizer Replication Menu
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 – 玩家的多人同步复制菜单
- en: Since this `MultiplayerSynchronizer` node will work by syncing physics properties,
    we need to set its **Visibility Update Mode** property to **Physics**. This will
    prevent some weird behaviors such as bodies overlapping and unhandled or mishandled
    collisions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个`MultiplayerSynchronizer`节点将通过同步物理属性来工作，我们需要将其**可见性更新模式**属性设置为**物理**。这将防止一些奇怪的行为，例如身体重叠和未处理或处理不当的碰撞。
- en: Now, let’s implement the `setup_multiplayer()` method. In the following instructions,
    we are going to create an RPC method that checks whether the current instance
    is a competence of the current player and disables some important processes to
    prevent interaction from players into instances they don’t own, as well as preventing
    overwriting properties synchronized by the network.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现`setup_multiplayer()`方法。在以下说明中，我们将创建一个RPC方法，用于检查当前实例是否是当前玩家的能力，并禁用一些重要进程以防止玩家与其不拥有的实例交互，以及防止覆盖由网络同步的属性。
- en: 'In the `Player.gd` script, let’s start by creating an RPC method called `setup_multiplayer`
    that any peer can call locally. It should receive `player_id` as an argument:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Player.gd`脚本中，让我们首先创建一个名为`setup_multiplayer`的RPC方法，任何对等体都可以在本地调用。它应该接收`player_id`作为参数：
- en: '[PRE24]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, inside this method, we need to compare whether the `player_id` value
    received as an argument matches the current player’s peer ID. We will store this
    information in a variable called `is_player` to use for further reference:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在这个方法内部，我们需要比较接收到的作为参数的`player_id`值是否与当前玩家的对等ID匹配。我们将把这个信息存储在一个名为`is_player`的变量中，以便进一步引用：
- en: '[PRE25]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With this information in hand, we can set up the player’s processes. We also
    need to disable `camera` if this isn’t the current player and make `camera` the
    current camera if it is:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拥有这些信息后，我们可以设置玩家的进程。我们还需要禁用`camera`，如果这不是当前玩家，如果它是，则将`camera`设置为当前摄像头：
- en: '[PRE26]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we set the player’s multiplayer authority to be `player_id`. This
    will ultimately prevent this client from making any changes on this `Player` instance
    and propagating them on the network:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将玩家的多人权限设置为`player_id`。这将最终防止这个客户端对`Player`实例进行任何更改并将它们传播到网络上：
- en: '[PRE27]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Throughout this section, we learned how we can spawn already existing objects
    to a player’s game instances when they log in when the game world is already running.
    We also saw how we can selectively synchronize objects using the `MultiplayerSynchronizer.set_visibility_for()`
    method.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何在游戏世界已经运行时，当玩家登录时，如何将已存在的对象生成到玩家的游戏实例中。我们还看到了如何使用`MultiplayerSynchronizer.set_visibility_for()`方法有选择性地同步对象。
- en: On top of that, we used the `MultiplayerSpawner.spawned` signal to configure
    spawned instances of an object on the client’s side. In our case, we needed to
    configure the player multiplayer settings. To do that, we created a method that
    checks whether this instance belongs to the current player, properly disabling
    or enabling its processing and camera and setting its multiplayer authority accordingly.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用了`MultiplayerSpawner.spawned`信号来配置客户端上的对象生成实例。在我们的例子中，我们需要配置玩家的多人游戏设置。为此，我们创建了一个方法，检查这个实例是否属于当前玩家，适当地禁用或启用其处理和摄像头，并相应地设置其多人权限。
- en: In the next section, we are going to learn how we can separate some responsibilities
    in the game to prevent cheating and to establish a more coherent multiplayer system,
    for instance, preventing a player’s game instances from deleting asteroids as
    they are the responsibility of the server.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何将游戏中的某些责任分离，以防止作弊并建立一个更连贯的多人游戏系统，例如，防止玩家的游戏实例删除小行星，因为这是服务器的责任。
- en: We will also see how we can sync players’ actions on all peers. This will be
    useful to replicate actions locally; for instance, when a player shoots on their
    game instance, all other game instances should perform the shooting as well.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看到如何同步所有对等体上的玩家动作。这将在本地复制动作时很有用；例如，当一个玩家在他们的游戏实例中射击时，所有其他游戏实例也应该执行射击动作。
- en: Separating server and client responsibilities
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离服务器和客户端的责任
- en: Now that we have players sharing the same world, we need to establish which
    actions they are responsible for and which actions are part of the server’s responsibility.
    For instance, if a player shoots on their game instance and their bullet damages
    an asteroid but this asteroid was already destroyed by another player, what should
    happen? For this kind of situation, the server is the perfect mediator to prevent
    instance conflicts.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有玩家共享同一个世界，我们需要确定他们负责哪些动作，哪些动作是服务器责任的组成部分。例如，如果一个玩家在他们的游戏实例中射击，并且他们的子弹损坏了一颗小行星，但这个小行星已经被另一个玩家摧毁了，那么应该发生什么？对于这种情况，服务器是完美的调解者，可以防止实例冲突。
- en: With all this context in place, players tell all peers, including the server,
    to update their `Player` instance according to their actions, but only the server
    should have the authority to manage the actual impact of these actions in the
    game world, such as if the player managed to destroy an asteroid or not. In the
    next section, we are going to understand how players can sync their actions, not
    only their objects’ properties, across all network-connected peers.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些背景信息就绪的情况下，玩家会告诉所有对等节点，包括服务器，根据他们的行为更新他们的 `Player` 实例，但只有服务器应该有权管理这些行为在游戏世界中的实际影响，例如玩家是否成功摧毁了一颗小行星。在下一节中，我们将了解玩家如何同步他们的行为，而不仅仅是他们的对象属性，到所有网络连接的对等节点。
- en: Shooting bullets on all instances
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在所有实例上射击子弹
- en: Since the `Player` scene’s `Spaceship` node movement is already synced by the
    `MultiplayerSynchronizer` node, we can focus our efforts on syncing the `Bullet`
    instances’ movement now. One way we could do that would be to use the `MultiplayerSpawner`
    and `MultiplayerSynchronizer` nodes to spawn `Bullet` instances remotely and replicate
    their position, rotation, and so on. But instead, we can make an RPC telling all
    `Spaceship` instances to call the `fire()` method on their `Weapon2D` nodes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Player` 场景的 `Spaceship` 节点运动已经通过 `MultiplayerSynchronizer` 节点同步，我们现在可以集中精力同步
    `Bullet` 实例的运动。我们可以采取的一种方法是通过 `MultiplayerSpawner` 和 `MultiplayerSynchronizer`
    节点远程生成 `Bullet` 实例并复制它们的位姿等。但相反，我们可以发送一个 RPC 通知所有 `Spaceship` 实例在其 `Weapon2D`
    节点上调用 `fire()` 方法。
- en: This is a quick and cheap way to do this. As the `Bullet` nodes have a constant
    trajectory, there’s no reason to sync their movement properties. The only thing
    relevant is where they start, that is, the spawning position, and the direction
    they should move. Both these properties are being synced already by the `Player`
    node’s `MultiplayerSynchronizer` node. So, we can leverage them. Nice trick, right?
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速且经济的方法。由于 `Bullet` 节点具有恒定的轨迹，没有必要同步它们的运动属性。唯一相关的是它们开始的位置，即生成位置，以及它们应该移动的方向。这两个属性已经通过
    `Player` 节点的 `MultiplayerSynchronizer` 节点同步。因此，我们可以利用它们。这是个不错的技巧，对吧？
- en: 'To do this, open the `res://09.prototyping-space-adventure/Actors/Player/Player2D.gd`
    script, and in the `_process()` callback, change the `weapon.fire()` line to `weapon.rpc("fire")`,
    as shown in the following code snippet:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，打开 `res://09.prototyping-space-adventure/Actors/Player/Player2D.gd` 脚本，并在
    `_process()` 回调中，将 `weapon.fire()` 行更改为 `weapon.rpc("fire")`，如下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you test the game now, you should see the `Player` instances’ `Spaceship`
    nodes shooting bullets on all game instances: server and clients. In the following
    screenshot, we can see a player shooting being replicated on the server’s game
    instance:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在测试游戏，你应该看到 `Player` 实例的 `Spaceship` 节点在所有游戏实例上射击子弹：服务器和客户端。在下面的屏幕截图中，我们可以看到一个玩家射击动作在服务器的游戏实例上被复制：
- en: '![Figure 9.16 – The Payer scene’s Spaceship node shooting Bullet instances
    on the server’s game instance using an RPC function](img/Figure_09.16_B18527.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.16 – Payer 场景的飞船节点在服务器的游戏实例上使用 RPC 函数射击子弹实例](img/Figure_09.16_B18527.jpg)'
- en: Figure 9.16 – The Payer scene’s Spaceship node shooting Bullet instances on
    the server’s game instance using an RPC function
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16 – Payer 场景的飞船节点在服务器的游戏实例上使用 RPC 函数射击子弹实例
- en: Now that the `Player` instances can shoot bullets on every peer instance of
    the game, we need to understand who should manage the damage calculation and the
    destruction of the objects the `Bullet` nodes hit. We’ve already talked about
    that, and this responsibility is the server’s.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然 `Player` 实例可以在游戏的每个对等实例上射击子弹，我们需要了解谁应该管理被 `Bullet` 节点击中的对象的伤害计算和破坏。我们已经讨论过这个问题，这个责任属于服务器。
- en: But how do we do that? In the next section, we are going to break down the `Asteroid`
    nodes’ behavior in order to separate what should happen on the client’s side and
    what should happen on the server’s side.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何做到这一点？在下一节中，我们将分解 `Asteroid` 节点的行为，以便区分客户端和服务器端应该发生什么。
- en: Calculating an asteroid’s damage
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算小行星的破坏力
- en: Here, it’s time to use the `multiplayer.is_server()` method extensively. We
    need to break down the `Asteroid` node’s behavior and establish what should happen
    when the `Bullet` instances on a client’s game instance hit an `Asteroid` node
    and what should happen when these `Bullet` instances hit an `Asteroid` node on
    the server side.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，是时候大量使用`multiplayer.is_server()`方法了。我们需要分解`Asteroid`节点的行为，并确定当客户端游戏实例上的`Bullet`实例击中`Asteroid`节点时应该发生什么，以及当这些`Bullet`实例击中服务器上的`Asteroid`节点时应该发生什么。
- en: 'Open the `res://09.prototyping-space-adventure/Objects/Asteroid/Asteroid.gd`
    script, and let’s implement the damage-taking behavior, respecting the responsibilities
    of each side of the connection:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`res://09.prototyping-space-adventure/Objects/Asteroid/Asteroid.gd`脚本，让我们实现承受伤害的行为，同时尊重连接每一方的责任：
- en: 'The first thing we need to do is prevent applying any damage to the `Asteroid`
    node if the current peer isn’t the server. So, in a client’s game instance, the
    `Bullet` node should hit the `Asteroid` node and disappear, but should not apply
    damage to the `Asteroid` node. To do that, in the `_on_hurt_area_2d_damage_taken()`
    callback, we are going to check whether the peer is the server, and if it is,
    we call the `apply_damage()` method, passing `damage` as an argument:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是防止在当前对等方不是服务器的情况下对`Asteroid`节点应用任何伤害。因此，在客户端的游戏实例中，`Bullet`节点应该击中`Asteroid`节点并消失，但不应对`Asteroid`节点应用伤害。为此，在`_on_hurt_area_2d_damage_taken()`回调中，我们将检查对等方是否是服务器，如果是，我们将调用`apply_damage()`方法，并将`damage`作为参数传递：
- en: '[PRE30]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, in the `apply_damage()` method, after doing the proper calculation, the
    server must tell the `Asteroid` instances on all peers to play their proper animation,
    either playing `"hit"` or `"explode"`. But here’s the trick: the `animator` doesn’t
    have an `RPC` method to do that.'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`apply_damage()`方法中，在进行适当的计算后，服务器必须告诉所有对等方的`Asteroid`实例播放它们适当的动画，无论是播放`"hit"`还是`"explode"`。但这里有个技巧：`animator`没有`RPC`方法来做这件事。
- en: 'So, instead, we are going to extract this behavior into two RPC methods and
    call these methods. These RPC methods should be called only by the network authority,
    and they should also be called locally:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们将提取这种行为到两个RPC方法中，并调用这些方法。这些RPC方法应由网络权限调用，并且也应该在本地调用：
- en: '[PRE31]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The last thing we need to do is to allow only the server to call the `queue_free()`
    method on the `Asteroid` nodes, preventing players from cheating and completing
    the quest in unpredictable ways. To do that, in the `_on_animation_player_animation_finished()`
    callback, we are going to check whether the peer is the server and call `queue_free()`
    if the current animation is `"explode"`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要做的是只允许服务器在`Asteroid`节点上调用`queue_free()`方法，防止玩家作弊并以不可预测的方式完成任务。为此，在`_on_animation_player_animation_finished()`回调中，我们将检查对等方是否是服务器，并在当前动画是`"explode"`时调用`queue_free()`：
- en: '[PRE32]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Since the server, which is the `Asteroid` node’s multiplayer authority, is removing
    the `Asteroid` instance from its `SceneTree`, the `World` node’s `AsteroidsMultiplayerSpawner`
    node will ensure that the `Asteroid` instances spawned on the clients’ game instances
    will also be removed as well. Isn’t the Godot Engine’s Network API clever?
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于服务器，即`Asteroid`节点的多人游戏权限，正在从其`SceneTree`中移除`Asteroid`实例，因此`World`节点的`AsteroidsMultiplayerSpawner`节点将确保在客户端游戏实例上生成的`Asteroid`实例也会被移除。Godot引擎的网络API不是非常聪明吗？
- en: With that, each side of the connection is performing its duty. The client side
    plays animations based on the `Asteroid` node’s state, while the server side deals
    with the actual impacts of `Bullet` nodes hitting `Asteroid` nodes. In this section,
    we saw how we can work around the issue when a behavior needs to be replicated
    remotely on all peers, but the built-in class, for instance the `AnimationPlayer`,
    doesn’t have a way to do it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，连接的每一方都在履行其职责。客户端根据`Asteroid`节点的状态播放动画，而服务器端处理`Bullet`节点击中`Asteroid`节点的实际影响。在本节中，我们看到了当需要在所有对等方远程复制行为时如何解决这个问题，但内置类，例如`AnimationPlayer`，没有提供这样做的方法。
- en: We also learned how to separate things and give each side of the connection
    the power to execute their responsibility. While the client side must instantiate
    bullet’s and do all the processing of the shooting, the server side does its part
    by processing the damage dealt by the `Bullet` nodes and handling the `Asteroid`
    node’s life cycle.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何分离事物，并赋予连接的每一方执行其责任的能力。虽然客户端必须实例化子弹并处理射击的所有处理，但服务器端通过处理`Bullet`节点造成的伤害和处理`Asteroid`节点的生命周期来完成其部分工作。
- en: In the next section, we are going to strengthen this knowledge by applying the
    same principles to the quest system. How does the player retrieve their quests?
    What is the client’s responsibility? Should the client store the player’s progress?
    What about the server? How does it handle clients’ requests and maintain information
    consistently between play sessions? That’s what we are going to talk about.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过将相同的原则应用于任务系统来加强这一知识。玩家如何检索他们的任务？客户端的责任是什么？客户端是否应该存储玩家的进度？至于服务器呢？它是如何处理客户端请求并在游戏会话之间保持信息一致性的？这正是我们要讨论的内容。
- en: Storing and retrieving data on the server
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器上存储和检索数据
- en: 'It’s time to handle a sensitive topic when it comes to online adventure games:
    databases. Note that in this book, we are not focusing on the best and most secure
    way to handle and protect a database. Instead, we are practicing and understanding
    what the Godot Engine Network API allows us to achieve and exploring its possibilities.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在线冒险游戏时，处理一个敏感话题的时间到了：数据库。请注意，在本书中，我们不是关注处理和保护数据库的最佳和最安全的方法。相反，我们正在实践和理解Godot引擎网络API允许我们实现的内容，并探索其可能性。
- en: That said, in this section, we are going to implement the necessary steps to
    establish a communication channel where the client can retrieve its quests data
    from the server and send their progress updates to the server.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在本节中，我们将实施建立通信通道所需的必要步骤，以便客户端可以从服务器检索其任务数据，并将进度更新发送到服务器。
- en: To do that, we are going to work with the two main classes in our quest system,
    `QuestSingleton` node and the `QuestDatabase` node. But before we set these classes
    up for this new challenge, we need to change how the database is structured. Since
    now the `QuestDatabase` node will work by delivering and handling multiple players’
    data, the `PlayerProgress.json` file needs to have its data linked to a user.
    So, let’s create these fake users, matching the ones in `FakeDatabase.json` file,
    and store this arbitrary data.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将与我们的任务系统中的两个主要类一起工作，即`QuestSingleton`节点和`QuestDatabase`节点。但在我们为这个新挑战设置这些类之前，我们需要更改数据库的结构。由于现在`QuestDatabase`节点将通过交付和处理多个玩家的数据来工作，因此`PlayerProgress.json`文件中的数据需要与一个用户链接。因此，让我们创建这些假用户，与`FakeDatabase.json`文件中的用户匹配，并存储这些任意数据。
- en: 'Open the `res://09.prototyping-space-adventure/Quests/PlayerProgress.json`
    file and create two new keys, one for `user1` and another for `user2`. Then, add
    some manual data matching the original structure for each user key:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`res://09.prototyping-space-adventure/Quests/PlayerProgress.json`文件，并为`user1`和`user2`创建两个新键。然后，为每个用户键添加一些与原始结构匹配的手动数据：
- en: '[PRE33]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, with this in mind, remember that we can, and should, use the user we have
    stored in the `AuthenticationCredentials` singleton to refer to any sensitive
    user data. This is important because it’s how we are going to properly manage
    users’ requests and deliver the data accordingly. In the next section, we are
    going to see how `QuestSingleton` node should retrieve and update quest data.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑到这一点，请记住，我们可以，也应该使用我们存储在`AuthenticationCredentials`单例中的用户来引用任何敏感的用户数据。这很重要，因为这是我们正确管理用户请求并相应地提供数据的方式。在下一节中，我们将看到`QuestSingleton`节点应该如何检索和更新任务数据。
- en: Implementing the quest system’s client side
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现任务系统的客户端
- en: It’s time to finally have our quest system ready to work in a network where
    players can retrieve quests from a remote database, make progress on them, and
    store their information for the future. In this section, we are going to see what
    the `QuestSingleton` node’s role is in this online multiplayer environment.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候让我们的任务系统准备好在网络中工作，在这个网络中，玩家可以从远程数据库检索任务，对他们进行进度，并存储他们的信息以备将来使用。在本节中，我们将了解`QuestSingleton`节点在这个在线多人游戏环境中的角色。
- en: 'So, let’s open the `res://09.prototyping-space-adventure/Quests/QuestSingleton.gd`
    script and get started with that. In the following instructions, we will see how
    we can retrieve and update quest data in a remote `QuestDatabase`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们打开`res://09.prototyping-space-adventure/Quests/QuestSingleton.gd`脚本并开始。在以下说明中，我们将了解如何从远程`QuestDatabase`检索和更新任务数据：
- en: The `retrieve_quests()` method needs a complete, but simpler and more elegant,
    revamp. The easiest way to create new quests in this online environment is to
    make the client request the remote `QuestDatabase` to create them remotely. We
    will see how this happens in depth in the *Implementing the quest system’s* *server*
    section.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`retrieve_quests()` 方法需要全面、但更简单、更优雅的改进。在这个在线环境中创建新任务的最简单方法就是让客户端请求远程 `QuestDatabase`
    创建它们。我们将在 *实现任务系统的服务器* *部分* 中深入了解这是如何发生的。'
- en: 'But for now, we will wait for `0.1` seconds to guarantee that everything is
    in place, and then we can make an RPC on the `QuestDatabase` node’s `get_player_quests()`
    method if this `QuestSingleton` node is not the server’s. Remember to pass `AuthenticationCredentials.user`
    property as an argument to the `get_player_quests()` method:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但现在，我们将等待 `0.1` 秒以确保一切就绪，然后我们可以在 `QuestDatabase` 节点的 `get_player_quests()` 方法上执行
    RPC，如果这个 `QuestSingleton` 节点不是服务器的话。请记住将 `AuthenticationCredentials.user` 属性作为参数传递给
    `get_player_quests()` 方法：
- en: '[PRE34]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, since the server’s `QuestDatabase` node will create the quests on the
    client’s `QuestSingleton` node, we need to turn the `create_quest()` method into
    an RPC method that only the authority can call remotely:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，由于服务器的 `QuestDatabase` 节点将在客户端的 `QuestSingleton` 节点上创建任务，我们需要将 `create_quest()`
    方法转换为只有授权者可以远程调用的 RPC 方法：
- en: '[PRE35]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, in the `increase_quest_progress()` method, we need to call the `QuestDatabase.update_player_progress()`
    method using an RPC directly to the server as well. Let’s not forget to also pass
    `AuthenticationCredentials.user` as an argument as well:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `increase_quest_progress()` 方法中，我们需要直接通过 RPC 调用服务器的 `QuestDatabase.update_player_progress()`
    方法。别忘了也将 `AuthenticationCredentials.user` 作为参数传递：
- en: '[PRE36]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With that, the `QuestSingleton` node will ask the server’s `QuestDatabase` node
    to create the current player’s quests, and whenever the player makes progress
    in a quest, the client’s `QuestSingleton` node updates the server’s `QuestDatabase`
    node about the current quest’s progress, ultimately delegating to the server the
    responsibility of handling this important data.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`QuestSingleton` 节点将请求服务器的 `QuestDatabase` 节点创建当前玩家的任务，并且每当玩家在任务中取得进展时，客户端的
    `QuestSingleton` 节点会更新服务器的 `QuestDatabase` 节点关于当前任务进展的信息，最终将处理这些重要数据的责任委托给服务器。
- en: Now, my friends, comes the last piece of our puzzle. In the next section, we
    are going to understand how the server side of this system works now that it is
    put in an online multiplayer environment.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我的朋友们，是我们拼图中的最后一部分。在下一节中，我们将了解在将其置于在线多人游戏环境后，这个系统的服务器端是如何工作的。
- en: Implementing the quest system’s server side
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现任务系统的服务器端
- en: In this section, we will add the necessary functionalities to the `QuestDatabase`
    node in order for it to properly provide and store players’ quest data. To do
    that, we are going to use RPCs extensively together with the `multiplayer.is_server()`
    method to prevent some behaviors from happening on the players’ instances of the
    `QuestDatabase` node.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向 `QuestDatabase` 节点添加必要的功能，以便它能够正确地提供和存储玩家的任务数据。为此，我们将广泛使用 RPC 与 `multiplayer.is_server()`
    方法一起，以防止某些行为在玩家的 `QuestDatabase` 节点实例上发生。
- en: We do this mainly to maintain the quest data only on the server side, so clients
    don’t run into the temptation to cheat directly on their machines. This will be
    an extensive section, so take a breather. We’ve been through quite a bit of information
    up to this point. Take a pause, and once you feel ready, come right back.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做主要是为了只在服务器端维护任务数据，这样客户端就不会直接在自己的机器上作弊的诱惑。这将是一个内容丰富的部分，所以请稍作休息。到目前为止，我们已经了解了很多信息。休息一下，当你感觉准备好了，就立刻回来。
- en: 'Ready? Okay, open the `res://09.prototyping-space-adventure/Quests/QuestDatabase.gd`
    script and let’s get started. In the upcoming instructions, we are going to tweak
    the current `QuestDatabase` node’s methods and even create new ones in order to
    make it work as it should, starting with…the `_ready()` method:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗？好的，打开 `res://09.prototyping-space-adventure/Quests/QuestDatabase.gd` 脚本，让我们开始吧。在接下来的说明中，我们将调整当前
    `QuestDatabase` 节点的现有方法，甚至创建新的方法，以便使其按预期工作，从 `_ready()` 方法开始：
- en: 'In the `_ready()` callback, we should only load the database files if the current
    peer is the server:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `_ready()` 回调中，我们应仅当当前节点是服务器时才加载数据库文件：
- en: '[PRE37]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We do the same thing in the `_notification()` callback. We should only store
    the files if the current peer is the server, so let’s add this check together
    with the notification check:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `_notification()` 回调中也做同样的事情。我们应该只存储文件，如果当前 peer 是服务器，所以让我们添加这个检查以及通知检查：
- en: '[PRE38]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Moving on to `get_player_quests()`, it should now be an RPC method that any
    peer can call remotely:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是 `get_player_quests()`，它现在应该是一个任何 peer 都可以远程调用的 RPC 方法：
- en: '[PRE39]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Since it’s now an RPC, we will store the peer ID of the client that requested
    this data so we can use this later on when we respond to the request:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于现在是一个 RPC，我们将存储请求此数据的客户端的 peer ID，这样我们可以在稍后响应请求时使用它：
- en: '[PRE40]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, add an argument called `user` to the method’s signature so we know which
    key to look at in the `progress_database` dictionary. Remember, now each user
    has their own key with their progress data in the `PlayerProgress.json` file,
    so this is how we access the proper user data:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在方法签名中添加一个名为 `user` 的参数，这样我们就可以知道在 `progress_database` 字典中查看哪个键。记住，现在每个用户都有自己的键，其进度数据存储在
    `PlayerProgress.json` 文件中，因此我们就是这样访问正确的用户数据的：
- en: '[PRE41]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we have some changes to make in the `get_progress()` and `get_completion()`
    method signatures, right? We need to add the user as an argument. So, let’s call
    them using this argument:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在 `get_progress()` 和 `get_completion()` 方法签名中需要做一些更改，对吧？我们需要将用户作为参数添加。所以，让我们使用这个参数来调用它们：
- en: '[PRE42]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we need to fix the methods’ signatures to match the previous changes and
    allow them to receive a `user` argument and access the `user` key in the `progress_database`:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要修复方法的签名以匹配之前的更改，并允许它们接收一个 `user` 参数并访问 `progress_database` 中的 `user`
    键：
- en: '[PRE43]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Back to the `get_player_quests()` method – for each `quest` key found in `progress_database`
    dictionary for a user, we will make an RPC directly to the `create_quest()` method
    of the client’s `QuestSingleton` node, passing the `quest_data` dictionary we
    just created:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 `get_player_quests()` 方法——对于在 `progress_database` 字典中找到的每个用户的 `quest` 键，我们将直接向客户端
    `QuestSingleton` 节点的 `create_quest()` 方法发送 RPC，传递我们刚刚创建的 `quest_data` 字典：
- en: '[PRE44]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, let’s also turn `update_player_progress()` into an RPC method that
    any peer can call remotely. It should also receive a `user` argument to update
    the progress on the proper `user` key in `progress_database`. This should only
    happen if this is the server’s instance of the `QuestDatabase` node, of course:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们也将 `update_player_progress()` 转换为一个任何 peer 都可以远程调用的 RPC 方法。它也应该接收一个 `user`
    参数来更新 `progress_database` 中正确的 `user` 键的进度。当然，这应该只发生在 `QuestDatabase` 节点的服务器实例上：
- en: '[PRE45]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And that wraps up our quest system and database management logic on both the
    client and server sides. If you test the `res://09.prototyping-space-adventure/MainMenu.tscn`
    scene and log in as a user, you will be able to see `QuestPanel` displaying the
    quest data correctly with the current player’s progress on the quest. In the following
    screenshot, we can see `user2`’s quest information:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了客户端和服务器两端的任务系统和数据库管理逻辑。如果你测试 `res://09.prototyping-space-adventure/MainMenu.tscn`
    场景并登录为用户，你将能够看到 `QuestPanel` 正确显示任务数据以及当前玩家在任务中的进度。在下面的屏幕截图中，我们可以看到 `user2` 的任务信息：
- en: '![Figure 9.17 – QuestPanel displaying user2’s Destroy 10 Asteroids quest information](img/Figure_09.17_B18527.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.17 – QuestPanel 显示用户2的摧毁 10 银河系任务信息](img/Figure_09.17_B18527.jpg)'
- en: Figure 9.17 – QuestPanel displaying user2’s Destroy 10 Asteroids quest information
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17 – QuestPanel 显示用户2的摧毁 10 银河系任务信息
- en: 'The following screenshot displays `user1`’s quest information. So, we can assume
    that our system is working as it should, properly loading, displaying, and modifying
    players’ quest progress:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了 `user1` 的任务信息。因此，我们可以假设我们的系统按预期工作，正确地加载、显示和修改玩家的任务进度：
- en: '![Figure 9.18 – QuestPanel displaying user1’s Destroy 10 Asteroids quest information](img/Figure_09.18_B18527.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.18 – QuestPanel 显示用户1的摧毁 10 银河系任务信息](img/Figure_09.18_B18527.jpg)'
- en: Figure 9.18 – QuestPanel displaying user1’s Destroy 10 Asteroids quest information
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18 – QuestPanel 显示用户1的摧毁 10 银河系任务信息
- en: With that, our top-down space adventure prototype is ready! Congratulations
    on making it all the way to this point. This chapter tested out everything we’ve
    seen so far extensively, and it closes *Part 2*, *Creating Online Multiplayer
    Mechanics*, of this book, where we created five prototypes to learn the ins and
    outs of Godot Engine’s high-level Network API.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们的自上而下的太空冒险原型已经准备好了！恭喜你一路走到这里。这一章全面测试了我们迄今为止所看到的一切，并结束了本书的第二部分，即“创建在线多人机制”，在这一部分中，我们创建了五个原型来学习
    Godot 引擎高级网络 API 的细节。
- en: Hopefully, by now, you feel confident in building and testing more prototypes
    on your own. In *Part 3*, *Optimizing the Online Experience*, which we are going
    to start in the next chapter, we are going to see how we can use the available
    tools to improve upon the experiences we created in *Part 2*. We will talk about
    how to debug and profile the network, optimize data requests, implement optimization
    techniques such as prediction and interpolation, cache data, and more.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到现在为止，你已经对独立构建和测试更多原型感到自信。在 *第3部分*，*优化在线体验*，我们将从下一章开始讨论，我们将看到如何使用可用的工具来改进我们在
    *第2部分* 中创建的体验。我们将讨论如何调试和配置网络，优化数据请求，实现预测和插值等优化技术，缓存数据，等等。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to allow players to join in the middle of a
    game run; how to synchronize their game instances; how to load, retrieve, send,
    and store information on a remote database; how to create a quest system; and
    overall, how to structure the very basics of an online multiplayer adventure game.
    In the next chapter, we are going to learn how to debug and profile the network
    so we can find bottlenecks and potential areas of improvement and optimization
    for our games. See you there!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何允许玩家在游戏运行过程中加入；如何同步他们的游戏实例；如何在远程数据库中加载、检索、发送和存储信息；如何创建任务系统；总的来说，如何构建在线多人冒险游戏的基本结构。在下一章中，我们将学习如何调试和配置网络，以便我们可以找到瓶颈和游戏改进和优化的潜在领域。那里见！
- en: Part 3:Optimizing the Online Experience
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：优化在线体验
- en: One of the core aspects of developing an application, especially a game, is
    to make the experience smooth and keep it without any hiccups or lag. When talking
    about games, which are real-time experiences, this is even more relevant. So,
    throughout this part of the book, we learn about the debugging and profiling tools
    necessary to assess potential bottlenecks and then we implement techniques to
    effectively optimize the network usage of the final project from*Part 2*.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '开发应用程序的一个核心方面，尤其是游戏，就是使体验流畅，并保持没有任何中断或延迟。当谈到游戏时，它们是实时体验，这一点尤为重要。因此，在本书的这一部分，我们学习了评估潜在瓶颈所需的调试和配置工具，然后我们实施技术来有效地优化从
    *第2部分* 的最终项目的网络使用。 '
- en: 'This part contains the following chapters:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 10*](B18527_10.xhtml#_idTextAnchor260), *Debugging and Profiling
    the Network*'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18527_10.xhtml#_idTextAnchor260), *调试和配置网络*'
- en: '[*Chapter 11*](B18527_11.xhtml#_idTextAnchor276), *Optimizing Data Requests*'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18527_11.xhtml#_idTextAnchor276), *优化数据请求*'
- en: '[*Chapter 12*](B18527_12.xhtml#_idTextAnchor285), *Lag and Packet Loss Compensation*'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18527_12.xhtml#_idTextAnchor285), *延迟和丢包补偿*'
- en: '[*Chapter 13*](B18527_13.xhtml#_idTextAnchor296), *Caching Data to Decrease
    Bandwidth*'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B18527_13.xhtml#_idTextAnchor296), *缓存数据以减少带宽*'
