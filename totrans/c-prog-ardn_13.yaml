- en: Chapter 13. Improving your C Programming and Creating Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。提高你的C编程技能和创建库
- en: This is the last chapter of this book and is the most advanced, but not the
    most complex. You will learn about C code optimization through several typical
    examples that will bring you a bit further and make you more capable for your
    future projects using Arduino. I am going to talk about libraries and how they
    can improve the reusability of your code to save time in the future. I will describe
    some tips to improve the performance of your code by using bit-shifting instead
    of the usual operators, and by using some memory management techniques. Then,
    I will talk about reprogramming the Arduino chip itself and debugging our code
    using an external hardware programmer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一章，也是最先进的，但不是最复杂的。你将通过几个典型的示例学习C代码优化，这些示例将使你更进一步，并使你在使用Arduino的未来项目中更有能力。我将讨论库以及它们如何提高你代码的可重用性，以节省未来的时间。我将描述一些使用位操作而不是常规操作符以及使用一些内存管理技术来提高代码性能的技巧。然后，我将讨论重新编程Arduino芯片本身以及使用外部硬件编程器调试我们的代码。
- en: Let's go.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Programming libraries
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程库
- en: I have already spoken about libraries in [Chapter 2](ch02.html "Chapter 2. First
    Contact with C"), *First Contact with C*. We can define it as a set of implementations
    of behavior already written using a particular language that provides some interfaces
    by which all the available behaviors can be called.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在[第2章](ch02.html "第2章。与C语言的初次接触")中提到了库，*与C语言的初次接触*。我们可以将其定义为一组使用特定语言编写的已实现的行为，该语言通过一些接口提供了一些方法，可以通过这些方法调用所有可用的行为。
- en: Basically, a library is something already written and reusable in our own code
    by following some specifications. For example, we can quote some libraries included
    in the Arduino core. Historically, some of those libraries had been written independently,
    and over time, the Arduino team as well as the whole Arduino community incorporated
    them into the growing core as natively available libraries.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，库是一些已经编写好并且可以重复使用的代码，我们可以在自己的代码中通过遵循一些规范来使用它们。例如，我们可以引用Arduino核心中包含的一些库。从历史上看，其中一些库是独立编写的，随着时间的推移，Arduino团队以及整个Arduino社区将它们纳入不断增长的核心库中，作为原生可用的库。
- en: 'Let''s take the EEPROM library. In order to check files related to it, we have
    to find the right folder on our computer. On OS X, for instance, we can browse
    the contents of the `Arduino.app` file itself. We can go to the `EEPROM` folder
    in `Contents`/`Resources`/`Java`/`libraries`/. In this folder, we have three files
    and a folder named `examples` containing all the examples related to the EEPROM
    library:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以EEPROM库为例。为了检查与之相关的文件，我们必须在我们的计算机上找到正确的文件夹。例如，在OS X上，我们可以浏览`Arduino.app`文件本身的内容。我们可以进入`Contents`/`Resources`/`Java`/`libraries`/中的`EEPROM`文件夹。在这个文件夹中，我们有三个文件和一个名为`examples`的文件夹，它包含所有与EEPROM库相关的示例：
- en: '![Programming libraries](img/7584_13_001.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![编程库](img/7584_13_001.jpg)'
- en: The EEPROM library on our computer (an OS X system)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算机上的EEPROM库（一个OS X系统）
- en: 'We have the following files:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下文件：
- en: '`EEPROM.h`, containing the headers of the library'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EEPROM.h`，包含库的头文件'
- en: '`EEPROM.cpp`, containing the code itself'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EEPROM.cpp`，包含实际的代码'
- en: '`keywords.txt`, containing some parameters to color the keywords of the library'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keywords.txt`，包含一些参数来着色库的关键字'
- en: Because of the location of these files in the folder hierarchy, they are available
    as parts of the core EEPROM library. This means we can include this library as
    soon as we have the Arduino environment installed on our computer without downloading
    anything else.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些文件在文件夹层次结构中的位置，它们可以作为核心EEPROM库的一部分使用。这意味着我们一旦在我们的计算机上安装了Arduino环境，就可以包含这个库，而无需下载其他任何东西。
- en: The simple statement `include <EEPROM.h>` includes the library in our code and
    makes all the features of this library available for further use.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的语句`include <EEPROM.h>`将库包含到我们的代码中，并使这个库的所有功能都可以进一步使用。
- en: Let's enter code in these files.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这些文件中编写代码。
- en: The header file
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头文件
- en: 'Let''s open `EEPROM.h`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`EEPROM.h`：
- en: '![The header file](img/7584_13_002.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![头文件](img/7584_13_002.jpg)'
- en: EEPROM.h displayed in Xcode IDE
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xcode IDE中显示的EEPROM.h
- en: 'In this file, we can see some preprocessor directives starting with the `#`
    character. This is the same one that we use to include libraries in our Arduino
    code. Here, this is a nice way to not include the same header twice. Sometimes,
    while coding, we include a lot of libraries and at compilation time, we would
    have to check that we didn''t include the same code twice. These directives and
    especially the `ifndef` directive mean: "If the `EEPROM_h` constant has not been
    defined, then do the following statements".'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们可以看到一些以`#`字符开头的预处理器指令。这是我们用来在Arduino代码中包含库的同一个指令。在这里，这是一种很好的方法，可以避免重复包含相同的头文件。有时，在编码过程中，我们会包含很多库，在编译时，我们必须检查我们没有重复包含相同的代码。这些指令，尤其是`ifndef`指令意味着：“如果`EEPROM_h`常量尚未定义，则执行以下语句”。
- en: This is a trick commonly known as **include guards**. The first thing we are
    doing after this test is defining the `EEPROM_h` constant. If in our code we or
    some other libraries include the EEPROM library, the preprocessor wouldn't reprocess
    the following statements the second time it sees this directive.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个众所周知的技术，称为**包含保护**。在这项测试之后，我们首先定义`EEPROM_h`常量。如果在我们的代码中我们或某些其他库包含了EEPROM库，预处理器就不会在第二次看到这个指令时重新处理以下语句。
- en: 'We have to finish the `#ifndef` directive with the `#endif` directive. This
    is a common block in the header files and you''ll see it many times if you open
    other library header files files. What is contained inside this block? We have
    another inclusion related to C integer types: `#include <inttypes.h>`.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用`#endif`指令完成`#ifndef`指令。这是头文件中的一个常见块，如果您打开其他库头文件，您会看到它很多次。这个块里包含什么？我们还有一个与C整数类型相关的包含：`#include
    <inttypes.h>`。
- en: The Arduino IDE contains all the required C headers in the library. As we have
    already mentioned, we could use pure C and C++ code in our firmware. We didn't
    until now because the functions and types we've been using have already been coded
    into the Arduino core. But please keep in mind that you have the choice to include
    other pure C code in your firmware and in this last chapter, we will also talk
    about the fact you can also follow pure AVR processor-type code too.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino IDE包含库中所有必需的C头文件。正如我们之前提到的，我们可以在固件中使用纯C和C++代码。我们之前没有这样做，因为我们一直在使用的函数和类型已经编码到Arduino核心中。但请记住，您可以选择在固件中包含其他纯C代码，在本章的最后，我们还将讨论您也可以遵循纯AVR处理器类型代码的事实。
- en: 'Now we have a class definition. This is a C++ feature. Inside this class, we
    declare two function prototypes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个类定义。这是一个C++特性。在这个类内部，我们声明了两个函数原型：
- en: '`uint8_t read(int)`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint8_t read(int)`'
- en: '`void write(int, uint8_t)`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void write(int, uint8_t)`'
- en: There is a function to read something, taking an integer as an argument and
    returning an unsigned integer that is 8 bits long (which is a byte). Then, there
    is another function to write something that takes an integer and a byte and returns
    nothing. These prototypes refer to the definition of these functions in the other
    `EEPROM.cpp` file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个函数用于读取，它接受一个整数作为参数，并返回一个8位无符号整数（即字节）。然后，还有一个函数用于写入，它接受一个整数和一个字节，并返回空值。这些原型指的是在其他`EEPROM.cpp`文件中这些函数的定义。
- en: The source file
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源文件
- en: 'Let''s open `EEPROM.cpp`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`EEPROM.cpp`文件：
- en: '![The source file](img/7584_13_003.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![源文件](img/7584_13_003.jpg)'
- en: The source file of the EEPROM library is displayed in the Xcode IDE
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: EEPROM库的源文件在Xcode IDE中显示
- en: The file begins by including some headers. `avr/eeprom.h` refers to the AVR
    type processor's EEPROM library itself. In this library example, we just have
    a library referring to and making a better interface for our Arduino programming
    style than the original pure AVR code. This is why I chose this library example.
    This is the shortest but the most explicit example, and it teaches us a lot.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 文件开始时包含了一些头文件。`avr/eeprom.h`指的是AVR类型处理器的EEPROM库本身。在这个库示例中，我们只是有一个库，它引用并为我们提供了比原始纯AVR代码更好的Arduino编程风格接口。这就是为什么我选择了这个库示例。这是最短但最明确的示例，它教会了我们很多。
- en: Then we include the `Arduino.h` header in order to have access to standard types
    and constants of the Arduino language itself. At last, of course, we include the
    header of the EEPROM library itself.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们包含`Arduino.h`头文件，以便访问Arduino语言本身的标凈类型和常量。最后，当然，我们还要包含EEPROM库本身的头文件。
- en: 'In the following statements, we define both functions. They call other functions
    inside their block definition:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下语句中，我们定义了这两个函数。它们在其块定义中调用其他函数：
- en: '`eeprom_read_byte()`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eeprom_read_byte()`'
- en: '`eeprom_write_byte()`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eeprom_write_byte()`'
- en: Those functions come from the AVR EEPROM library itself. The EEPROM Arduino
    library is only an interface to the AVR EEPROM library itself. Why wouldn't we
    try to create a library ourselves?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数直接来自AVR EEPROM库本身。EEPROM Arduino库只是AVR EEPROM库的一个接口。我们为什么不尝试自己创建一个库呢？
- en: Creating your own LED-array library
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自己的LED数组库
- en: We are going to create a very small library and test it with a basic circuit
    including six LEDs that are not multiplexed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个非常小的库，并用一个包括六个非复用LED的基本电路来测试它。
- en: Wiring six LEDs to the board
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将六个LED连接到板子上
- en: 'Here is the circuit. It basically contains six LEDs wired to Arduino:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是电路图。它基本上包含六个连接到Arduino的LED：
- en: '![Wiring six LEDs to the board](img/7584_13_005.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![将六个LED连接到板子上](img/7584_13_005.jpg)'
- en: Six LEDs wired to the board
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 六个LED连接到板子上
- en: 'The circuit diagram is shown as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 电路图如下所示：
- en: '![Wiring six LEDs to the board](img/7584_13_006.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![将六个LED连接到板子上](img/7584_13_006.jpg)'
- en: Another diagram of the six LEDs wired directly to Arduino
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个将六个LED直接连接到Arduino的电路图
- en: I won't discuss the circuit itself, except to mention that I put in a 1 kΩ resistor.
    I took the worst case where all LEDs would be switched on at the same time. This
    would drive a lot of current, and so this acts as security for our Arduino. Some
    authors wouldn't use it. I'd prefer to have some LEDs dimming a bit in order to
    protect my Arduino.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会讨论电路本身，只是提一下我放入了一个1 kΩ的电阻。我考虑了最坏的情况，即所有LED同时点亮。这将驱动大量的电流，因此这为我们的Arduino提供了安全保障。一些作者可能不会使用它。我更愿意让一些LED稍微暗一些，以保护我的Arduino。
- en: Creating some nice light patterns
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一些漂亮的灯光图案
- en: 'Here is code for lighting up the LEDs according to some patterns, all hardcoded.
    A pause is made between each pattern display:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是按照某些模式点亮LED的代码，所有这些都是硬编码的。每个图案显示之间都有一个暂停：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code works correctly. But how could we make it more elegant and, especially,
    more reusable? We could embed the `for()` blocks into functions. But these would
    only be available in this code. We'd have to copy and paste them by remembering
    the project in which we designed them in order to reuse them in another project.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行正确。但我们如何让它更优雅，尤其是更易于重用呢？我们可以将`for()`循环块嵌入到函数中。但它们只在这个代码中可用。我们必须通过记住我们设计它们的那个项目来复制和粘贴它们，以便在另一个项目中重用它们。
- en: By creating a small library that we can use over and over again, we can save
    time in the future in coding as well as processing. With some periodic modifications,
    we can arrive at the perfect module for its intended task, which will get better
    and better until there's no need to even touch it anymore because it performs
    more perfectly than anything else out there. At least that's what we hope for.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个我们可以反复使用的库，我们可以在未来的编码和数据处理中节省时间。通过一些定期的修改，我们可以达到为特定任务设计的完美模块，它将越来越好，直到不需要再触碰它，因为它比其他任何东西都表现得更好。至少这是我们希望看到的。
- en: Designing a small LED-pattern library
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计一个小型的LED图案库
- en: At first, we can design our function's prototype in a header. Let's call the
    library `LEDpatterns`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以在头文件中设计我们函数的原型。让我们把这个库叫做`LEDpatterns`。
- en: Writing the LEDpatterns.h header
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写LEDpatterns.h头文件
- en: 'Here is how a possible header could be:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个可能的头文件示例：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We first write our include guards. Then we include the Arduino library. Then,
    we define a class named `LEDpatterns` with the `public` functions including a
    constructor that has the same name as the class itself.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编写我们的include guards。然后包含Arduino库。然后，我们定义一个名为`LEDpatterns`的类，其中包含与类本身同名的构造函数等`public`函数。
- en: We also have two internal (`private`) variables related to the first pin on
    which LEDs are wired and related to the total number of LEDs wired. LEDs would
    have to be contiguously wired in that example.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有两个与第一个连接LED的引脚和与连接LED总数相关的内部（`private`）变量。在示例中，LED必须连续连接。
- en: Writing the LEDpatterns.cpp source
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写LEDpatterns.cpp源文件
- en: 'Here is the source code of the C++ library:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是C++库的源代码：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At the beginning, we retrieve all the `include` libraries. Then we have the
    constructor, which is a special method with the same name as the library. This
    is the important point here. It takes two arguments. Inside its body, we put all
    the pins from the first one to the last one considering the LED number as a digital
    output. Then, we store the arguments of the constructor inside the `private` variables
    previously defined in the header `LEDpatterns.h`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，我们检索所有`include`库。然后我们有构造函数，这是一个与库同名的特殊方法。这是这里的重要点。它接受两个参数。在其主体内部，我们将从第一个到最后的所有引脚（将LED视为数字输出）放入其中。然后，我们将构造函数的参数存储在之前在头文件`LEDpatterns.h`中定义的`private`变量中。
- en: We can then declare all our functions related to those created in the first
    example without the library. Notice the `LEDpatterns::` prefix for each function.
    I won't discuss this pure class-related syntax here, but keep in mind the structure.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声明所有与第一个示例中创建的函数相关的函数，而不需要库。注意每个函数的`LEDpatterns::`前缀。我不会在这里讨论这种纯类相关语法，但请记住结构。
- en: Writing the keyword.txt file
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写keyword.txt文件
- en: 'When we look at our source code, it''s very helpful to have things jump out
    at you, and not blend into the background. In order to correctly color the different
    keywords related to our new created library, we have to use the `keyword.txt`
    file. Let''s check this file out:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看我们的源代码时，如果某些内容能够跳出来而不是融入背景，那就非常有帮助。为了正确地着色与我们新创建的库相关的不同关键字，我们必须使用`keyword.txt`文件。让我们检查一下这个文件：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code we can see the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到以下内容：
- en: Everything followed by `KEYWORD1` will be colored in orange and is usually for
    classes
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有跟随`KEYWORD1`的内容都将被染成橙色，通常用于类
- en: Everything followed by `KEYWORD2` will be colored in brown and is for functions
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有跟随`KEYWORD2`的内容都将被染成棕色，用于函数
- en: Everything followed by `LITERAL1` will be colored in blue and is for constants
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有跟随`LITERAL1`的内容都将被染成蓝色，用于常量
- en: It is very useful to use these in order to color your code and make it more
    readable.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些来着色你的代码并使其更易于阅读是非常有用的。
- en: Using the LEDpatterns library
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LEDpatterns库
- en: 'The library is in the `LEDpatterns` folder in `Chapter13` and you have to put
    it in the correct folder with the other libraries, which we have done. We have
    to restart the Arduino IDE in order to make the library available. After having
    done that, you should be able to check if it is in the menu **Sketch** | **Import
    Library**. `LEDpatterns` is now present in the list:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 该库位于`Chapter13`的`LEDpatterns`文件夹中，你必须将它放在与其他库相同的正确文件夹中，我们已经这样做了。我们必须重新启动Arduino
    IDE以使库可用。完成之后，你应该能够在菜单**Sketch** | **Import Library**中检查它。现在`LEDpatterns`已经出现在列表中：
- en: '![Using the LEDpatterns library](img/7584_13_007.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![使用LEDpatterns库](img/7584_13_007.jpg)'
- en: The library is a contributed one because it is not part of the Arduino core
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该库是一个贡献的库，因为它不是Arduino核心的一部分
- en: 'Let''s now check the new code using this library. You can find it in the `Chapter13`/`LEDLib`
    folder:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用这个库来检查新的代码。你可以在`Chapter13`/`LEDLib`文件夹中找到它：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the first step, we include the `LEDpatterns` library. Then, we create the
    instance of `LEDpatterns` named `ledpattern`. We call the constructor that we
    designed previously with two arguments:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们包含`LEDpatterns`库。然后，我们创建名为`ledpattern`的`LEDpatterns`实例。我们使用之前设计的带有两个参数的构造函数：
- en: The first pin of the first LED
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个LED的第一个引脚
- en: The total number of LEDs
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED的总数
- en: '`ledpattern` is an instance of the `LEDpatterns` class. It is referenced throughout
    our code, and without `#include`, it would not work. We have also invoked each
    method of this instance.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`ledpattern`是`LEDpatterns`类的一个实例。它在我们的代码中被引用，如果没有`#include`，它将无法工作。我们已调用这个实例的每个方法。'
- en: If the code seems to be cleaner, the real benefit of such a design is the fact
    that we can reuse this library inside any of our projects. If we want to modify
    and improve the library, we only have to modify things in the header and the source
    file of our library.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码看起来更干净，这种设计的真正好处是我们可以在我们的任何项目中重用这个库。如果我们想修改和改进库，我们只需要修改库的头文件和源文件。
- en: Memory management
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: 'This section is a very short one but not a less important one at all. We have
    to remember we have the following three pools of memory on Arduino:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分非常短，但绝对不是不重要。我们必须记住，我们在Arduino上有以下三个内存池：
- en: Flash memory (program space), where the firmware is stored
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闪存（程序空间），其中存储固件
- en: '**Static Random Access Memory** (**SRAM**), where the sketch creates and manipulates
    variables at runtime'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态随机存取存储器**（**SRAM**），其中草图在运行时创建和操作变量'
- en: EEPROM is a memory space to store long-term information
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EEPROM 是一个用于存储长期信息的内存空间
- en: 'Flash and EEPROM, compared to SRAM, are non-volatile, which means the data
    persists even after the power is turned off. Each different Arduino board has
    a different amount of memory:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SRAM 相比，Flash 和 EEPROM 是非易失性的，这意味着即使断电后数据也会持续存在。每个不同的 Arduino 板都有不同数量的内存：
- en: 'ATMega328 (UNO) has:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ATMega328 (UNO) 具有：
- en: Flash 32k bytes (0.5k bytes used by the bootloader)
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flash 32k 字节（引导程序占用 0.5k 字节）
- en: SRAM 2k bytes
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SRAM 2k 字节
- en: EEPROM 1k bytes
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: EEPROM 1k 字节
- en: 'ATMega2560 (MEGA) has:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ATMega2560 (MEGA) 具有：
- en: Flash 256k bytes (8k bytes used by the bootloader)
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flash 256k 字节（引导程序占用 8k 字节）
- en: SRAM 8k bytes
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SRAM 8k 字节
- en: EEPROM 4k bytes
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: EEPROM 4k 字节
- en: 'A classic example is to quote a basic declaration of a string:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经典的例子是引用一个字符串的基本声明：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That takes 32 bytes into SRAM. It doesn''t seem a lot but with the UNO, you
    *only* have 2048 bytes available. Imagine you use a big lookup table or a large
    amount of text. Here are some tips to save memory:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将占用 32 字节到 SRAM 中。这似乎并不多，但 UNO 只提供了 2048 字节。想象一下，如果你使用了一个大的查找表或大量的文本。以下是一些节省内存的技巧：
- en: If your project uses both Arduino and a computer, you can try to move some calculation
    steps from Arduino to the computer itself, making Arduino only trigger calculations
    on the computer and request results, for instance.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的项目同时使用 Arduino 和计算机，你可以尝试将一些计算步骤从 Arduino 移动到计算机本身，使 Arduino 只在计算机上触发计算并请求结果，例如。
- en: Always use the smallest data type possible to store values you need. If you
    need to store something between 0 and 255, for instance, don't use an `int` type
    that takes 2 bytes, but use a `byte` type instead
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是使用可能的最小数据类型来存储你需要的数据。例如，如果你需要存储介于 0 和 255 之间的数据，不要使用占用 2 字节的 `int` 类型，而应使用
    `byte` 类型
- en: If you use some lookup tables or data that won't be changed, you can store them
    in the Flash memory instead of the SRAM. You have to use the `PROGMEM` keyword
    to do that.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用了一些不会更改的查找表或数据，你可以将它们存储在 Flash 内存中而不是 SRAM 中。你必须使用 `PROGMEM` 关键字来完成此操作。
- en: 'You can use the native EEPROM of your Arduino board, which would require making
    two small programs: the first to store that information in the EEPROM, and the
    second to use it. We did that using the PCM library in the [Chapter 9](ch09.html
    "Chapter 9. Making Things Move and Creating Sounds"), *Making Things Move and
    Creating Sounds*.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 Arduino 板的原生 EEPROM，这将需要编写两个小程序：第一个用于将信息存储在 EEPROM 中，第二个用于使用它。我们在第 9 章
    [Making Things Move and Creating Sounds](ch09.html "第 9 章。使事物移动和创造声音") 中使用 PCM
    库做到了这一点，*使事物移动和创造声音*。
- en: Mastering bit shifting
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握位移操作
- en: 'There are two bit shift operators in C++:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中有两个位移操作符：
- en: '`<<` is the left shift operator'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<<` 是左移操作符'
- en: '`>>` is the right shift operator'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>>` 是右移操作符'
- en: These can be very useful especially in SRAM memory, and can often optimize your
    code. `<<` can be understood as a multiplication of the left operand by 2 raised
    to the right operand power.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在 SRAM 内存中非常有用，并且通常可以优化你的代码。`<<` 可以理解为左操作数乘以 2 的右操作数次幂。
- en: '`>>` is the same but is similar to a division. The ability to manipulate bits
    is often very useful and can make your code faster in many situations.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>` 与之相同，但类似于除法。位操作的能力通常非常有用，并且可以在许多情况下使你的代码更快。'
- en: Multiplying/dividing by multiples of 2
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用 2 的倍数进行乘除
- en: Let's multiply a variable using bit shifting.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用位移来乘以一个变量。
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The second row multiplies the variable `a` by `2` to the third power, so `b`
    now contains `32`. On the same lines, division can be carried out as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行将变量 `a` 乘以 `2` 的三次方，因此 `b` 现在包含 `32`。同样，除法可以按以下方式进行：
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`b` contains `3` because `>> 2` equals division by 4\. The code can be faster
    using these operators because they are a direct access to binary operations without
    using any function of the Arduino core like `pow()` or even the other operators.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`b` 包含 `3`，因为 `>> 2` 等于除以 4。使用这些操作符可以使代码更快，因为它们是直接访问二进制操作，而不需要使用 Arduino 核心的任何函数，如
    `pow()` 或其他操作符。'
- en: Packing multiple data items into bytes
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将多个数据项打包到字节中
- en: 'Instead of using a big, two-dimensional table to store, for instance, a bitmap
    shown as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，而不是使用一个大型的二维表来存储，比如以下显示的位图：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can use use the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the first case, it takes 7 x 5 = 35 bytes per bitmap. In the second one,
    it takes only 5 bytes. I guess you've just figured out something huge, haven't
    you?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，每个位图需要 7 x 5 = 35 字节。在第二种情况下，只需要 5 字节。我想你已经刚刚发现了一些重大的事情，不是吗？
- en: Turning on/off individual bits in a control and port register
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在控制和端口寄存器中打开/关闭单个位
- en: 'The following is a direct consequence of the previous tip. If we want to set
    up pins 8 to 13 as output, we could do it like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前一条技巧的直接后果。如果我们想将引脚 8 到 13 设置为输出，我们可以这样做：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'But this would be better:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 但这样做会更好：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In one pass, we've configured the whole package into one variable directly in
    memory, and no `pinMode` function, structure, or variable name needs to be compiled.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在一次遍历中，我们直接在内存中将整个包配置到一个变量中，并且不需要编译 `pinMode` 函数、结构或变量名。
- en: Reprogramming the Arduino board
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新编程 Arduino 板
- en: Arduino natively uses the famous bootloader. This provides a nice way to upload
    our firmware using the virtual serial port on the USB. But we might be interested
    to go ahead without any bootloader. How and why? Firstly, that would save some
    Flash memory. It also provides a way to avoid the small delay when we power on
    or reset our board before it becomes active and starts running. It requires an
    external programmer.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 本地使用著名的引导加载程序。这为我们通过 USB 上的虚拟串行端口上传固件提供了一种很好的方式。但我们也可能对在没有引导加载程序的情况下继续前进感兴趣。如何以及为什么？首先，这将节省一些闪存内存。它还提供了一种避免在我们打开或重置板子并使其活跃并开始运行之前的小延迟的方法。这需要一个外部编程器。
- en: I can quote the AVR-ISP, the STK500, or even a parallel programmer (a parallel
    programmer is described at [http://arduino.cc/en/Hacking/ParallelProgrammer](http://arduino.cc/en/Hacking/ParallelProgrammer)).
    You can find an AVR-ISP at Sparkfun Electronics.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以引用 AVR-ISP、STK500，甚至并行编程器（并行编程器在 [http://arduino.cc/en/Hacking/ParallelProgrammer](http://arduino.cc/en/Hacking/ParallelProgrammer)
    中有描述）。你可以在 Sparkfun 电子找到 AVR-ISP。
- en: I used this one a couple of times to program an Arduino FIO-type board for specific
    wireless applications in a project connecting cities named The Village in 2013.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 2013 年的一个名为 The Village 的连接城市的项目中，用这个编程器编程了 Arduino FIO 型板，用于特定的无线应用。
- en: '![Reprogramming the Arduino board](img/7584_13_008.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![重新编程 Arduino 板](img/7584_13_008.jpg)'
- en: The Pocket AVR programmer by Sparkfun Electronics
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Sparkfun 电子的口袋 AVR 编程器
- en: This programmer can be wired using 2 x 5 connectors to the ICSP port on the
    Arduino board.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个编程器可以通过 2 x 5 连接器连接到 Arduino 板上的 ICSP 端口。
- en: '![Reprogramming the Arduino board](img/7584_13_009.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![重新编程 Arduino 板](img/7584_13_009.jpg)'
- en: The ICSP connector of Arduino
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino 的 ICSP 连接器
- en: 'In order to reprogram the processor of Arduino, we have to first close the
    Arduino IDE, and then check the preferences file (`preferences.txt` on a Mac,
    located in `Contents`/`Resources`/`Java`/`lib` inside the `Arduino.app` package
    itself). On a Windows 7 PC and higher, this file is located at: `c:\Users\<USERNAME>\AppData\Local\Arduino\preferences.txt`.
    In Linux it is located at: `~/arduino/preferences.ard`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重新编程 Arduino 的处理器，我们首先必须关闭 Arduino IDE，然后检查首选项文件（Mac 上的 `preferences.txt`，位于
    `Arduino.app` 包内的 `Contents`/`Resources`/`Java`/`lib` 中）。在 Windows 7 PC 和更高版本上，此文件位于：`c:\Users\<USERNAME>\AppData\Local\Arduino\preferences.txt`。在
    Linux 上位于：`~/arduino/preferences.ard`。
- en: 'We have to change the `upload.using` value that is initially set to bootloader
    to the correct identifier that fits your programmer. This can be found in the
    content of the Arduino application package on OS X or inside the Arduino folders
    on Windows. For instance, if you display the `Arduino.app` content, you can find
    this file: `Arduino.app/Contents/Resources/Java/hardware/arduino/programmers.txt`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将最初设置为引导加载程序的 `upload.using` 值更改为适合你的编程器的正确标识符。这可以在 OS X 的 Arduino 应用程序包内容中找到，或者在
    Windows 的 Arduino 文件夹中。例如，如果你显示 `Arduino.app` 内容，你可以找到这个文件：`Arduino.app/Contents/Resources/Java/hardware/arduino/programmers.txt`。
- en: Then we can start the Arduino IDE to upload the sketch using our programmer.
    To revert back to the normal bootloader behavior, we have to first reupload the
    bootloader that fits with our hardware. Then, we have to change back the `preferences.txt`
    file, and it will work as the initial board.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以启动 Arduino IDE，使用我们的编程器上传草图。要恢复到正常的引导加载程序行为，我们首先必须重新上传适合我们硬件的引导加载程序。然后，我们必须更改
    `preferences.txt` 文件，它将像初始板一样工作。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned more about designing libraries, and we are now able
    to design our projects a bit differently, keeping in mind reusability of the code
    or part of the code in future projects. This can save time and also improves readability.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了更多关于设计库的知识，我们现在能够以不同的方式设计我们的项目，考虑到未来项目中代码或代码部分的复用性。这可以节省时间，同时也提高了可读性。
- en: We can also explore existing libraries and enjoy the world of open source by
    taking them, hacking them, and making them fit our needs. This is a really open
    world into which we have just made our first steps.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用现有的库，通过修改它们，使它们符合我们的需求，来探索开源世界。这是一个真正开放的世界，我们刚刚迈出了第一步。
- en: Conclusion
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: We are at the end of this book. You have probably read everything and also tested
    some pieces of code with your own hardware, and I'm sure you are now able to imagine
    your future and advanced projects with Arduino.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到了这本书的结尾。你可能已经读完了所有的内容，也用你自己的硬件测试了一些代码片段，我相信你现在能够想象出你未来的高级项目了。
- en: 'I wanted to thank you for being so focused and interested. I know you are now
    almost in the same boat as myself, you want to learn more, test more, and check
    and use new technologies in order to achieve your craziest project. I''d like
    to say one last thing: do it, and do it now!'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我想感谢你如此专注和感兴趣。我知道你现在几乎和我处于同一条船上，你想要学习更多，测试更多，检查和使用新技术来实现你疯狂的项目。我想说最后一件事：去做，现在就去做！
- en: In most cases, people are afraid of the huge amount of work that they can imagine
    in the first steps just before they start. But you have to trust me, don't think
    too much about details or about optimization. Try to make something simple, something
    that works. Then you'll have ways to optimize and improve it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，人们在开始之前，仅仅想象到将要面对的大量工作就会感到害怕。但你要相信我，不要过多地考虑细节或优化。试着做一些简单的东西，一些能工作起来的东西。然后你会有方法去优化和改进它。
- en: 'One last piece of advice for you: don''t think too much, and make a lot. I
    have seen too many unfinished projects by people having wanted to think, think,
    think instead of just starting and making.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条建议给你：不要想太多，多做一些。我见过太多的人因为想要先想、想、想，而不是先开始做，结果项目没有完成。
- en: Take care and continue exploring!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 保重，继续探索！
