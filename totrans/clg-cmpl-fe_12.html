<html><head></head><body>
<div><div><h1 data-number="3.1" class="calibre5">Appendix 1</h1>
<h1 id="sigil_toc_id_152" class="calibre5"><a id="x1-1810009" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Compilation Database</h1>
<p class="hidden">The test examples considered in the book do not require special compilation flags and typically can be compiled without any flags. However, this is not the scenario if you want to employ the material on a real project, such as running a lint check on your code base. In that situation, you will need to furnish special compilation flags for each file to be processed. Clang offers various methods for supplying these flags. We will explore in detail the JSON Compilation Database, which is one of the primary tools for delivering compilation flags to Clang tools such as Clang-Tidy and Clangd. <a id="x1-181001r550" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>

<h2 data-number="3.1.1" id="sigil_toc_id_153" class="likechapterhead">9.1  <a id="x1-1820001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Compilation database definition</h2>
<p class="hidden">A <strong class="calibre12">compilation database (CDB) </strong>is a JSON file <a id="dx1-182001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>that specifies how each source file in a code base should be compiled. This JSON file is typically named <code class="calibre13">compile</code><code class="calibre13">_commands.json </code>and resides in the <a id="dx1-182002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>root directory of a project. It provides a machine-readable record of all compiler invocations in the build process and is often used by various tools for more accurate analysis, refactoring, and more. Each entry in this JSON file typically contains the following fields:</p>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15"><strong class="calibre12">directory</strong>: The working directory of the compilation.</p></li>
<li class="calibre14"><p class="calibre15"><strong class="calibre12">command</strong>: The actual compile command, including compiler options.</p></li>
<li class="calibre14"><p class="calibre15"><strong class="calibre12">arguments</strong>: Another field that can be used to specify compilation arguments. It contains the list of arguments.</p></li>
<li class="calibre14"><p class="calibre15"><strong class="calibre12">file</strong>: The path to the source file being compiled.</p></li>
<li class="calibre14"><p class="calibre15"><strong class="calibre12">output</strong>: The path to the output created by this compilation step.</p></li>
</ul>
<p class="hidden">As we can see from the fields description, there are two ways to specify compilation flags: using the <strong class="calibre12">command </strong>or <strong class="calibre12">arguments </strong>field. Let’s look at a specific example. Suppose our C++ file <code class="calibre13">ProjectLib.cpp </code>is located at the <code class="calibre13">/home/user/project/src/lib </code>folder and can be compiled with Clang using <a id="dx1-182003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>the following invocation command (the command is used as an example, and you can ignore the meaning of its arguments)</p>
<pre id="verbatim-121" class="console">$ cd /home/user/project/src/lib
$ clang -Wall -I../headers ProjectLib.cpp -o ProjectLib.o</pre>
<p class="hidden">The following CDB can be used to represent the command:</p>
<pre id="listing-77" class="source-code">1[ 
 
2    { 
 
3        "directory": "/home/user/project/src/lib", 
 

4        "command": "clang -Wall -I../headers ProjectLib.cpp -o ProjectLib.o", 
 

5        "file": "ProjectLib.cpp", 
 
6        "output": "ProjectLib.o" 
 

7    } 
 
8 ]</pre>
<p class="hidden"><a id="x1-182012r1" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-182013" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 9.1</strong>: Compilation Database for ProjectLib.cpp </p>
<p class="hidden">The <code class="calibre13">"command" </code>field was used in the example. We can also create the CDB in another form and use the <code class="calibre13">arguments </code>field. The result will be as follows:</p>
<pre id="listing-78" class="source-code">1[ 
 
2    { 
 

3        "directory": "/home/user/project/src/lib", 
 

4        "arguments": [ 
 
5            "clang", 
 

6            "-Wall", 
 
7            "-I../headers", 
 

8            "ProjectLib.cpp", 
 
9            "-o", 
 




10            "ProjectLib.o" 
 
11        ], 
 

12        "file": "ProjectLib.cpp", 
 

13        "output": "ProjectLib.o" 
 
14    } 
 
15 ]</pre>
<p class="hidden"><a id="x1-182029r2" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-182030" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 9.2</strong>: CDB for ProjectLib.cpp </p>
<p class="hidden">The <strong class="calibre12">CDB </strong>shown in <a href="#x1-182029r2" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 9.2</a> represents the same compilation recipe as in <a href="#x1-182012r1" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 9.1</a>, but it uses a list of arguments (the ”arguments” field) instead of the invocation command (the ”command” field) used in <a href="#x1-182012r1" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">Figure 9.1</a>. It’s important to note that the list of arguments also contains the executable ”clang” as its first argument. CDB processing tools can use this argument to make a decision <a id="dx1-182031" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>about which compiler should be used for the compilation in environments where different compilers are available, such as GCC versus Clang.</p>
<p class="hidden">The provided CDB example contains only one record for one file. A real project might contain thousands of records. LLVM is a good example, and if you look at the <code class="calibre13">build </code>folder that we used for the LLVM build (see <a href="B19722_01.xhtml#x1-270001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 1.3.1</em></a><em class="calibre11">, Configuration with CMake</em>), you may notice that it contains a <code class="calibre13">compile</code><code class="calibre13">_commands.json </code>file with the CDB for the projects we selected to be built. It’s worth noting that LLVM creates the CDB by default, but your project might require some special manipulations to create it. Let’s look at how the CDB can be created in detail. <a id="x1-182032r553" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


<h2 data-number="3.1.2" id="sigil_toc_id_154" class="likechapterhead">9.2  <a id="x1-1830002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>CDB creation</h2>
<p class="hidden">The <code class="calibre13">shell</code>compile˙commands.json file can be generated in various ways. For example, the build system CMake has built-in support <a id="dx1-183001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>for generating a compilation database. Some tools can also generate this file from Makefiles or other build systems. There are even tools such as Bear and intercept-build that can generate a CDB by intercepting the actual compile commands as they are run.</p>
<p class="hidden">So while the term is commonly associated with Clang and LLVM-based tools, the concept itself is more general and could theoretically be used by any tool that needs to understand the compilation settings for a set of source files. We will start with CDB generation using CMake, one of the most popular build systems.</p>

<h4 class="sigil_not_in_toc" data-number="3.1.2.1"><a id="x1-1840002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Generating a CDB with CMake</h4>
<p class="hidden">Generating a CDB with CMake involves a few steps:</p>
<ol class="calibre6">
<li class="calibre7"><div><p class="calibre15">First, open a terminal or <a id="dx1-184003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>command prompt and <a id="dx1-184004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>navigate to your project’s root directory.</p>
</div></li>
<li class="calibre7"><div><p class="calibre15">Then, run CMake with the <code class="calibre13">-DCMAKE</code><code class="calibre13">_EXPORT</code><code class="calibre13">_COMPILE</code><code class="calibre13">_COMMANDS=ON</code> option, which instructs CMake to create a <code class="calibre13">compile</code><code class="calibre13">_commands.json</code> file. This file contains the compilation commands for all source files in your project.</p>
</div></li>
<li class="calibre7"><div><p class="calibre15">After configuring your project with CMake, you can find the <code class="calibre13">compile</code><code class="calibre13">_commands.json </code>file in the same directory where you ran the configuration command.</p>
</div></li>
</ol>
<p class="hidden">As we noticed before, LLVM created the CDB by default. It’s achievable because <code class="calibre13">llvm/CMakeLists.txt </code>contains the following setup:</p>
<pre class="source-code"># Generate a CompilationDatabase (compile_commands.json file) for our build, 
 

# for use by clang_complete, YouCompleteMe, etc. 
 

set(CMAKE_EXPORT_COMPILE_COMMANDS 1)</pre>
<p class="hidden"><a id="x1-184013r3" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-184014" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 9.3</strong>: LLVM-18.x CMake configuration from llvm/CMakeLists.txt </p>
<p class="hidden">i.e., it set up the CDB generation by default.</p>


<h4 class="sigil_not_in_toc" data-number="3.1.2.2"><a id="x1-1850002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Ninja to Generate a CDB</h4>
<p class="hidden">The Ninja can also be used to generate a CDB. We can use a Ninja subtool called <code class="calibre13">"compdb" </code>to dump the CDB to stdout. To run <a id="dx1-185001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>the subtool, we use the <code class="calibre13">-t &lt;subtool&gt; </code>command-line option in Ninja. Thus, we will use the following <a id="dx1-185002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>command to produce the CDB with Ninja:</p>
<pre id="verbatim-122" class="console">$ ninja -t compdb &gt; compile_commands.json</pre>
<p class="hidden"><a id="x1-185003r4" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-185004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 9.4</strong>: Creating a CDB with Ninja </p>
<p class="hidden">This command instructs Ninja to generate the CDB information and save it in the <code class="calibre13">compile</code><code class="calibre13">_commands.json </code>file.</p>
<p class="hidden">The generated compilation database can be used with the different Clang tools that we have described in the book. Let’s look at two of the most valuable examples, which include Clang-Tidy and Clangd. <a id="x1-185005r556" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>



<h2 data-number="3.1.3" id="sigil_toc_id_155" class="likechapterhead">9.3  <a id="x1-1860003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Clang tools and a CDB</h2>
<p class="hidden">The concept of a CDB is not <a id="dx1-186001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>specific to Clang but Clang-based tools make extensive use of it. For instance, the Clang compiler itself can use a compilation database to understand how to compile files in a project. Tools such as Clang-Tidy and Clangd (for language support in IDEs) can also use it to ensure they understand code as it was built, making their analyses and transformations more accurate.</p>

<h4 class="sigil_not_in_toc" data-number="3.1.3.1"><a id="x1-1870003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Clang-Tidy Configuration for Large Projects</h4>
<p class="hidden">To use clang-tidy with a CDB, you typically don’t <a id="dx1-187001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>need any additional configuration. Clang-tidy can automatically <a id="dx1-187002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>detect and utilize the <code class="calibre13">compile</code><code class="calibre13">_commands.json </code>file in your project’s root directory.</p>
<p class="hidden">On the other hand, Clang Tools provide a special option, <strong class="calibre12">-p</strong>, defined as follows:</p>
<pre id="verbatim-123" class="console">-p &lt;build-path&gt; is used to read a compile command database</pre>
<p class="hidden">You can use this option to run Clang-Tidy on a file from the Clang source code. For example, if you run it from the llvm-project folder where the source code was cloned, it would look like this:</p>
<pre id="verbatim-124" class="console">$ ./install/bin/clang-tidy clang/lib/Parse/Parser.cpp -p ./build/</pre>
<p class="hidden"><a id="x1-187003r5" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-187004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 9.5</strong>: Running Clang-Tidy on the LLVM code base </p>
<p class="hidden">In this case, we are <a id="dx1-187005" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>running Clang-Tidy from the <a id="dx1-187006" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>folder, where we installed it, as described in <a href="B19722_05.xhtml#x1-1020001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"><em class="calibre11">Section</em><em class="calibre11"> 5.2.1</em></a><em class="calibre11">, Building and testing Clang-Tidy</em>. We have also specified the <code class="calibre13">build </code>folder as the project root folder containing the CDB.</p>
<p class="hidden">Clang-Tidy is one of the tools that actively uses the CDB to be executed on large projects. Another tool is Clangd, which we will also explore.</p>


<h4 class="sigil_not_in_toc" data-number="3.1.3.2"><a id="x1-1880003" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Clangd Setup for Large Projects</h4>
<p class="hidden">Clangd offers a <a id="dx1-188001" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>special configuration option to <a id="dx1-188002" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>specify the path to the CDB. This option is defined as follows:</p>
<pre id="verbatim-125" class="console">$ clangd --help
...
--compile-commands-dir=&lt;string&gt; - Specify a path to look for
compile_commands.json.If the path is invalid, clangd will search</pre>
<pre id="verbatim-126" class="console">in the current directory and parent paths of each source file.
...</pre>
<p class="hidden"><a id="x1-188003r6" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/> <a id="x1-188004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>
<p class="hidden"><strong class="calibre12">Figure 9.6</strong>: Description for ’–compile-commands-dir’ option from ’clangd –help’ output </p>
<p class="hidden">You can specify this option in Visual Studio Code via the <strong class="calibre12">Settings </strong>panel, as shown in the following figure:</p>
<div><img src="img/file12.png" alt="Figure 9.7: Configure the CDB path for clangd " class="calibre53"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 9.7</strong>: Configure the CDB path for clangd </p>
<p class="hidden">Therefore, if you <a id="dx1-188007" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>open a file from the Clang <a id="dx1-188008" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>source code, you will have access to navigation support provided by Clangd as you can see in the following figure:</p>
<div><img src="img/file13.png" alt="Figure 9.8: Hover provided for Parser::Parser method by Clangd at clang/lib/Parse/Parser.cpp " class="calibre54"/>
</div>
<p class="hidden"><strong class="calibre12">Figure 9.8</strong>: Hover provided for Parser::Parser method by Clangd at clang/lib/Parse/Parser.cpp </p>
<p class="hidden">Integration of compile <a id="dx1-188011" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>commands with Clang tools, such as Clang-Tidy or Clangd, provides a powerful <a id="dx1-188012" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>tool for exploring and analyzing your source code. <a id="x1-188013r562" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>



<h2 data-number="3.1.4" id="sigil_toc_id_156" class="likechapterhead">9.4  <a id="x1-1890004" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/>Further reading</h2>
<ul class="calibre6">
<li class="calibre14"><p class="calibre15">Clang Documentation - JSON Compilation Database Format Specification: <a href="https://clang.llvm.org/docs/JSONCompilationDatabase.html" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://clang.llvm.org/docs/JSONCompilationDatabase.html</a></p></li>
<li class="calibre14"><p class="calibre15">Clangd documentation - Compile commands: <a href="https://clangd.llvm.org/design/compile-commands" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8">https://clangd.llvm.org/design/compile-commands</a></p></li>
</ul>
<p class="hidden"><a id="x1-189001r552" class="pcalibre1 pcalibre2 pcalibre3 pcalibre calibre8"/></p>


</div>
</div>
</body></html>