["```cpp\n#include <stdio.h>\n#include <stdlib.h>\n// The POSIX standard header for using pthread library\n#include <pthread.h>\n// This function contains the logic which should be run\n// as the body of a separate thread\nvoid* thread_body(void* arg) {\n  printf(\"Hello from first thread!\\n\");\n  return NULL;\n}\nint main(int argc, char** argv) {\n  // The thread handler\n  pthread_t thread;\n  // Create a new thread\n  int result = pthread_create(&thread, NULL, thread_body, NULL);\n  // If the thread creation did not succeed\n  if (result) {\n    printf(\"Thread could not be created. Error number: %d\\n\",\n            result);\n    exit(1);\n  }\n  // Wait for the created thread to finish\n  result = pthread_join(thread, NULL);\n  // If joining the thread did not succeed\n  if (result) {\n    printf(\"The thread could not be joined. Error number: %d\\n\",\n            result);\n    exit(2);\n  }\n  return 0;\n}\n```", "```cpp\n$ gcc ExtremeC_examples_chapter15_1.c -o ex15_1.out -lpthread\n$ ./ex15_1.out\nHello from first thread!\n$\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n// The POSIX standard header for using pthread library\n#include <pthread.h>\n// This function contains the logic which should be run\n// as the body of a separate thread\nvoid* thread_body(void* arg) {\n  printf(\"Hello from first thread!\\n\");\n  return NULL;\n}\nint main(int argc, char** argv) {\n  // The thread handler\n  pthread_t thread;\n  // Create a new thread\n  int result = pthread_create(&thread, NULL, thread_body, NULL);\n  // If the thread creation did not succeed\n  if (result) {\n    printf(\"Thread could not be created. Error number: %d\\n\",\n            result);\n    exit(1);\n  }\n  // Detach the thread\n  result = pthread_detach(thread);\n  // If detaching the thread did not succeed\n  if (result) {\n    printf(\"Thread could not be detached. Error number: %d\\n\",\n            result);\n    exit(2);\n  }\n  // Exit the main thread\n  pthread_exit(NULL);\n  return 0;\n}\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n// The POSIX standard header for using pthread library\n#include <pthread.h>\nvoid* thread_body(void* arg) {\n  char* str = (char*)arg;\n  printf(\"%s\\n\", str);\n  return NULL;\n}\nint main(int argc, char** argv) {\n  // The thread handlers\n  pthread_t thread1;\n  pthread_t thread2;\n  pthread_t thread3;\n  // Create new threads\n  int result1 = pthread_create(&thread1, NULL,\n          thread_body, \"Apple\");\n  int result2 = pthread_create(&thread2, NULL,\n          thread_body, \"Orange\");\n  int result3 = pthread_create(&thread3, NULL,\n          thread_body, \"Lemon\");\n  if (result1 || result2 || result3) {\n    printf(\"The threads could not be created.\\n\");\n    exit(1);\n  }\n\n  // Wait for the threads to finish\n  result1 = pthread_join(thread1, NULL);\n  result2 = pthread_join(thread2, NULL);\n  result3 = pthread_join(thread3, NULL);\n  if (result1 || result2 || result3) {\n    printf(\"The threads could not be joined.\\n\");\n    exit(2);\n  }\n  return 0;\n}\n```", "```cpp\n$ gcc ExtremeC_examples_chapter15_2.c -o ex15_2.out -lpthread\n$ ./ex15_2.out\nApple\nOrange\nLemon\n$ ./ex15_2.out\nOrange\nApple\nLemon\n$ ./ex15_2.out\nApple\nOrange\nLemon\n$\n```", "```cpp\n$ ./ex15_2.out\nAppOrle\nAnge\nLemon\n$\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n// The POSIX standard header for using pthread library\n#include <pthread.h>\nvoid* thread_body(void* arg) {\n  char* str = (char*)arg;\n  printf(\"%s\\n\", str);\n  return NULL;\n}\nint main(int argc, char** argv) {\n  // The thread handlers\n  pthread_t thread1;\n  pthread_t thread2;\n  pthread_t thread3;\n  char str1[8], str2[8], str3[8];\n  strcpy(str1, \"Apple\");\n  strcpy(str2, \"Orange\");\n  strcpy(str3, \"Lemon\");\n  // Create new threads\n  int result1 = pthread_create(&thread1, NULL, thread_body, str1);\n  int result2 = pthread_create(&thread2, NULL, thread_body, str2);\n  int result3 = pthread_create(&thread3, NULL, thread_body, str3);\n  if (result1 || result2 || result3) {\n    printf(\"The threads could not be created.\\n\");\n    exit(1);\n  }\n  // Detach the threads\n  result1 = pthread_detach(thread1);\n  result2 = pthread_detach(thread2);\n  result3 = pthread_detach(thread3);\n  if (result1 || result2 || result3) {\n    printf(\"The threads could not be detached.\\n\");\n    exit(2);\n  }\n  // Now, the strings become deallocated.\n  pthread_exit(NULL);\n  return 0;\n}\n```", "```cpp\n$ gcc -g ExtremeC_examples_chapter15_2_1.c -o ex15_2_1.out -lpthread\n$ valgrind ./ex15_2_1.out\n==1842== Memcheck, a memory error detector\n==1842== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\n==1842== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info\n==1842== Command: ./ex15_2_1.out\n==1842==\nOrange\nApple\nLemon\n==1842==\n==1842== HEAP SUMMARY:\n==1842==     in use at exit: 0 bytes in 0 blocks\n==1842==   total heap usage: 9 allocs, 9 frees, 3,534 bytes allocated\n==1842==\n==1842== All heap blocks were freed -- no leaks are possible\n==1842==\n==1842== For counts of detected and suppressed errors, rerun with: -v\n==1842== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\n$\n```", "```cpp\n$ valgrind ./ex15_2_1.out\n==1854== Memcheck, a memory error detector\n==1854== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\n==1854== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info\n==1854== Command: ./ex15_2_1.out\n==1854==\nApple\nLemon\n==1854== Thread 4:\n==1854== Conditional jump or move depends on uninitialised value(s)\n==1854==    at 0x50E6A65: _IO_file_xsputn@@GLIBC_2.2.5 (fileops.c:1241)\n==1854==    by 0x50DBA8E: puts (ioputs.c:40)\n==1854==    by 0x1087C9: thread_body (ExtremeC_examples_chapter15_2_1.c:17)\n==1854==    by 0x4E436DA: start_thread (pthread_create.c:463)\n==1854==    by 0x517C88E: clone (clone.S:95)\n==1854==\n...\n==1854==\n==1854== Syscall param write(buf) points to uninitialised byte(s)\n==1854==    at 0x516B187: write (write.c:27)\n==1854==    by 0x50E61BC: _IO_file_write@@GLIBC_2.2.5 (fileops.c:1203)\n==1854==    by 0x50E7F50: new_do_write (fileops.c:457)\n==1854==    by 0x50E7F50: _IO_do_write@@GLIBC_2.2.5 (fileops.c:433)\n==1854==    by 0x50E8402: _IO_file_overflow@@GLIBC_2.2.5 (fileops.c:798)\n==1854==    by 0x50DBB61: puts (ioputs.c:41)\n==1854==    by 0x1087C9: thread_body (ExtremeC_examples_chapter15_2_1.c:17)\n==1854==    by 0x4E436DA: start_thread (pthread_create.c:463)\n==1854==    by 0x517C88E: clone (clone.S:95)\n...\n==1854==\nOrange\n==1854==\n==1854== HEAP SUMMARY:\n==1854==     in use at exit: 272 bytes in 1 blocks\n==1854==   total heap usage: 9 allocs, 8 frees, 3,534 bytes allocated\n==1854==\n==1854== LEAK SUMMARY:\n==1854==    definitely lost: 0 bytes in 0 blocks\n==1854==    indirectly lost: 0 bytes in 0 blocks\n==1854==      possibly lost: 272 bytes in 1 blocks\n==1854==    still reachable: 0 bytes in 0 blocks\n==1854==         suppressed: 0 bytes in 0 blocks\n==1854== Rerun with --leak-check=full to see details of leaked memory\n==1854==\n==1854== For counts of detected and suppressed errors, rerun with: -v\n==1854== Use --track-origins=yes to see where uninitialised values come from\n==1854== ERROR SUMMARY: 13 errors from 3 contexts (suppressed: 0 from 0)\n$\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n// The POSIX standard header for using pthread library\n#include <pthread.h>\nvoid* thread_body_1(void* arg) {\n  // Obtain a pointer to the shared variable\n  int* shared_var_ptr = (int*)arg;\n  // Increment the shared variable by 1 by writing\n  // directly to its memory address\n  (*shared_var_ptr)++;\n  printf(\"%d\\n\", *shared_var_ptr);\n  return NULL;\n}\nvoid* thread_body_2(void* arg) {\n  // Obtain a pointer to the shared variable\n  int* shared_var_ptr = (int*)arg;\n  // Increment the shared variable by 2 by writing\n  // directly to its memory address\n  *shared_var_ptr += 2;\n  printf(\"%d\\n\", *shared_var_ptr);\n  return NULL;\n}\nint main(int argc, char** argv) {\n  // The shared variable\n  int shared_var = 0;\n  // The thread handlers\n  pthread_t thread1;\n  pthread_t thread2;\n  // Create new threads\n  int result1 = pthread_create(&thread1, NULL,\n          thread_body_1, &shared_var);\n  int result2 = pthread_create(&thread2, NULL,\n          thread_body_2, &shared_var);\n  if (result1 || result2) {\n    printf(\"The threads could not be created.\\n\");\n    exit(1);\n  }\n  // Wait for the threads to finish\n  result1 = pthread_join(thread1, NULL);\n  result2 = pthread_join(thread2, NULL);\n  if (result1 || result2) {\n    printf(\"The threads could not be joined.\\n\");\n    exit(2);\n  }\n  return 0;\n}\n```", "```cpp\n$ gcc ExtremeC_examples_chapter15_3.c -o ex15_3.out -lpthread\n$ ./ex15_3.out\n1\n3\n$\n...\n...\n...\n$ ./ex15_3.out\n3\n1\n$\n...\n...\n...\n$ ./ex15_3.out\n1\n2\n$\n```"]