- en: Chapter 9.  The Speed of Dark - Lighting and Shadows
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 黑暗的速度 - 光照与阴影
- en: Contrasting differences are the very essence of existence, as the *yin-yang*
    symbol properly illustrates. Light and darkness are opposites, yet complementary,
    as they offset one another and give meaning through variety. Without darkness
    there can be no light, as they are never truly separate. By breathing light into
    our world, we are inevitably forced to add back the darkness that it creates.
    Let's follow the previous chapter and truly complete to our lighting engine by
    reintroducing the concept of darkness to it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对比差异是存在的本质，正如*阴阳*符号恰当地说明了这一点。光明与黑暗是相反的，但又是互补的，因为它们相互抵消并通过多样性赋予意义。没有黑暗就没有光明，因为它们从未真正分离。通过向我们的世界注入光明，我们不可避免地被迫添加它所创造的黑暗。让我们跟随上一章，真正通过重新引入黑暗的概念来完善我们的光照引擎。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Using OpenGL to render to and sample from cubemap textures
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenGL渲染到和从立方体贴图纹理采样
- en: Advanced shadow mapping for omni-directional point lights
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对全向点光源的高级阴影映射
- en: The use of Percentage Closer Filtering to smooth out shadow edges
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用百分比更近过滤来平滑阴影边缘
- en: Combating common and frustrating issues with shadow mapping
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应对阴影映射的常见和令人沮丧的问题
- en: There's quite a bit of theory to get out of the way, so let's get to it!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多理论需要先解决，所以让我们开始吧！
- en: Use of third-party software
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方软件
- en: Before diving into such a difficult subject to debug, it's always nice to have
    proper tools that will ease the headaches and reduce the number of questions one
    might ask oneself during development. While normal code executed on the *CPU*
    can just be stepped through and analyzed during runtime, shader code and OpenGL
    resources, such as textures are a bit more difficult to handle. Most, if not all,
    *C++* compilers don't have native support for dealing with *GPU-bound* problems.
    Luckily, there is software out there that makes it easier to deal with that very
    predicament.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究这样一个难以调试的主题之前，拥有合适的工具总是很令人高兴，这些工具可以减轻头痛并减少在开发过程中可能会问自己的问题的数量。虽然正常代码在*CPU*上可以执行并分析，但着色器代码和OpenGL资源，如纹理，处理起来要困难得多。大多数，如果不是所有，*C++*编译器都没有处理*GPU-bound*问题的原生支持。幸运的是，有软件可以更容易地处理这种情况。
- en: Among the few tools that exist out there to alleviate such headaches, *CodeXL*
    by *AMD Developer Tools Team* stands out. It's a free piece of software that can
    be used as a standalone application for Windows and Linux or even as a plugin
    for Visual Studio. Its most prominent features include being able to view OpenGL
    resources (including textures) while the program is running, profile the code
    and find bottlenecks, and even step through the shader code as it's being executed
    (given the right hardware). The tool can be found and downloaded here: [http://gpuopen.com/compute-product/codexl/](http://gpuopen.com/compute-product/codexl/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在为数不多的可以缓解此类头痛的工具中，*AMD开发者工具团队*的*CodeXL*脱颖而出。这是一款免费软件，可以作为Windows和Linux的独立应用程序使用，甚至可以作为Visual
    Studio的插件。其最显著的特点包括在程序运行时查看OpenGL资源（包括纹理），分析代码并找到瓶颈，甚至可以在执行时逐步执行着色器代码（前提是有合适的硬件）。您可以通过以下链接找到并下载此工具：[http://gpuopen.com/compute-product/codexl/](http://gpuopen.com/compute-product/codexl/)。
- en: Theory behind shadowing techniques
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 影子技术背后的理论
- en: There are a couple of different techniques that can be used when implementing
    realistic looking shadows in games. Choosing the right one can not only impact
    the kind of performance your application is going to exhibit, but can also heavily
    influence how good the effect is going to look in the end.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中实现看起来逼真的阴影时，可以使用几种不同的技术。选择正确的一种不仅可以影响应用程序将要展示的性能类型，还可以极大地影响最终效果的好坏。
- en: An approach that isn't at all uncommon for 2D is referred to as **ray tracing**.
    Depending on the type of light, a number of rays are cast in an appropriate direction.
    Shadows are then implemented depending on which solids these rays actually intersect
    with. Some simpler games tend to create an overlay mask and fill in geometrically
    the parts of it that are "in the shadow". This mask is later overlaid on top of
    the usual scene and blended in order to create the aesthetic of darkened areas
    meant to represent shadows. More advanced 3D games tend to allow rays to bounce
    around the scene, carrying different information about the particular fragments
    that they intersect with. By the time a ray reaches the camera, it will have enough
    information to do more than create simple shadows. Scenes that require extremely
    advanced lighting tend to use this technique, and rightly so, as it imitates the
    way light bounces off objects and hits the observer's eye in real life.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在2D中并不罕见的一种方法被称为**光线追踪**。根据光线的类型，以适当的方向发射一定数量的光线。然后根据这些光线实际与哪些固体相交来实现阴影。一些简单的游戏倾向于创建一个叠加蒙版，并在几何上填充其“在阴影中”的部分。这个蒙版随后叠加在通常的场景上，并混合以创建代表阴影的暗化区域的美学效果。更高级的3D游戏倾向于允许光线在场景中反弹，携带有关它们与特定片段相交的不同信息。当光线到达相机时，它将拥有足够的信息来完成不仅仅是创建简单阴影的任务。需要极其高级光照的场景通常使用这种技术，这是正确的，因为它模仿了现实生活中光线从物体上反弹并击中观察者眼睛的方式。
- en: An older, but still widely used approach for specifically creating shadows is
    called **shadow mapping**. The essence of this technique comes down to simply
    rendering the scene to an off screen buffer from the point of view of the light.
    All the solids' depth information, as opposed to color information, is written
    to this buffer as pixel data. When the real scene is rendered, some matrix math
    is then used to sample the right pixels of the shadow map to figure out whether
    they can be directly seen by the light, thus being illuminated, or whether they're
    being obstructed by something, and therefore sitting in the shadow.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一种较老但仍然广泛使用的方法是专门创建阴影的**阴影映射**。这种技术的本质是将场景简单地渲染到离屏缓冲区中，从光的角度来看。所有固体的深度信息，而不是颜色信息，都作为像素数据写入此缓冲区。当渲染真实场景时，然后使用一些矩阵运算来采样阴影映射的正确像素，以确定它们是否可以直接被光线看到，从而被照亮，或者是否被某物遮挡，因此处于阴影中。
- en: Shadow mapping
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阴影映射
- en: 'The main idea behind creating a shadow map is rendering the scene from the
    point of view of the light, and effectively encoding the depth of a particular
    piece of geometry being rendered as a color value that can later be sampled. The
    depth value itself is nothing more than the distance between the position of the
    light and the position of the vertex. Consider the following diagram:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建阴影映射背后的主要思想是从光的角度渲染场景，并有效地将渲染的特定几何形状的深度编码为颜色值，该颜色值可以在以后进行采样。深度值本身不过是光的位置与顶点位置之间的距离。考虑以下图示：
- en: '![Shadow mapping](img/image_09_001.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![阴影映射](img/image_09_001.jpg)'
- en: The distance between the light and a given vertex will be converted to a color
    value by simply dividing it by the frustum far distance, yielding a result in
    a range *[0;1]*. The frustum far value is simply the distance of how far the light/camera
    can see.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 光与给定顶点之间的距离将通过简单地除以视锥体远距离来转换为颜色值，得到的结果在范围*[0;1]*内。视锥体远值简单地表示光/相机可以看到多远。
- en: Omni-directional point lights
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全向点光源
- en: 'In the previous chapter, we managed to create lights that emit in all directions
    from a center point. These types of lights have a very fitting name: omni-directional
    point lights. Dealing with shadow mapping for these lights comes with a certain
    layer of complexity, as the scene now needs to be drawn in all six directions,
    rather than just one if we were dealing with a directional light. This means we
    need a good way of storing the results of this process that can be accessed with
    relative ease. Luckily, OpenGL provides a new type of texture we can use, the
    **cubemap**.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们成功创建了从中心点向所有方向发射光线的光源。这类光源有一个非常合适的名字：全向点光源。对于这些光源处理阴影映射带来了一定的复杂性，因为现在需要从六个方向绘制场景，而不是像处理方向光时那样只从一个方向。这意味着我们需要一种良好的方式来存储这个过程的结果，以便可以相对容易地访问。幸运的是，OpenGL提供了一种我们可以使用的新类型的纹理，即**立方体贴图**。
- en: Cubemap textures
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 立方体贴图纹理
- en: 'A cubemap is pretty much exactly what it sounds like. It''s a special texture
    that really holds six textures for each face of the cube. These textures are internally
    stored in an *unfolded* manner, as shown here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体贴图基本上就是它名字的直译。它是一种特殊的纹理，实际上为立方体的每个面存储了六个纹理。这些纹理以展开的方式内部存储，如图所示：
- en: '![Cubemap textures](img/image_09_003.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![立方体贴图纹理](img/image_09_003.jpg)'
- en: 'Because of this property, rendering shadow maps for omni-directional lights
    can be as simple as rendering the scene once for each direction of a cubemap.
    Sampling them is also quite easy. The shape of a cube lends itself to some useful
    properties we can exploit. If all of the cube''s vertices are in relation to its
    absolute center, then the coordinates of these vertices can also be thought of
    as directional vectors:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个特性，为全向光渲染阴影贴图可以简单到只需为立方体贴图的每个方向渲染一次场景。采样它们也非常简单。立方体的形状使其具有一些有用的特性，我们可以利用。如果立方体的所有顶点都与它的绝对中心相关联，那么这些顶点的坐标也可以被视为方向向量：
- en: '![Cubemap textures](img/image_09_005.jpg)![Cubemap textures](img/image_09_006.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![立方体贴图纹理](img/image_09_005.jpg)![立方体贴图纹理](img/image_09_006.jpg)'
- en: The direction (0, 1, 0) from the center of the cube would be pointing directly
    in the middle of the *+Y* face, for example. Since each face of a cubemap texture
    also holds a texture of its own that represents the view of the scene, it can
    easily be sampled using these coordinates. For a 2D texture, our shaders had to
    use the `sampler2D` type and provide 2D coordinates of the sampling location.
    Cubemaps have their own sampler type, `samplerCube`, and use a 3D vector for sampling.
    The consequence of this is that the largest member of the 3D vector is used to
    determine which face is to be sampled, and the other two members become the UV
    texture coordinates for that particular 2D texture/face.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从立方体中心出发的方向（0, 1, 0）将直接指向*+Y*面的中间，例如。由于立方体贴图纹理的每个面也包含一个代表场景视图的纹理，因此可以使用这些坐标轻松采样。对于2D纹理，我们的着色器必须使用`sampler2D`类型并提供采样位置的2D坐标。立方体贴图有自己的采样器类型`samplerCube`，并使用3D向量进行采样。结果是，3D向量的最大成员用于确定要采样的面，而其他两个成员成为该特定2D纹理/面的UV纹理坐标。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Cube textures can be used for much more than shadow mapping. 3D environments
    can take advantage of them when implementing skyboxes and reflective/refractive
    materials, to name just a few techniques.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体贴图不仅可以用于阴影映射。3D环境在实现天空盒和反射/折射材料等时可以利用它们，仅举几个技术。
- en: Preparations for rendering
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染准备
- en: It's safe to say that all of this functionality is a bit beyond the scope of
    SFML, as it seeks to deal with simple two-dimensional concepts. While we're still
    going to be using SFML to render our sprites, the lighting and shadowing of the
    scene will have to fall back on raw OpenGL. This includes setting up and sampling
    cubemap textures, as well as creating, uploading, and drawing 3D primitives used
    to represent objects that cast shadows.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可以肯定地说，所有这些功能都超出了SFML的范围，因为SFML旨在处理简单的二维概念。虽然我们仍然会使用SFML来渲染我们的精灵，但场景的光照和阴影将不得不回退到原始OpenGL。这包括设置和采样立方体贴图纹理，以及创建、上传和绘制用于表示投射阴影的对象的3D原语。
- en: Representing shadow casters
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表示阴影投射者
- en: 'While SFML is great for rendering sprites, we must remember that these are
    two-dimensional objects. In 3D space, our character would literally be paper thin.
    This means that all of our game''s shadow casters are going to need some 3D geometry
    behind them. Keep in mind that these basic rendering concepts have already been
    covered in [Chapter 7](ch07.html "Chapter 7.  One Step Forward, One Level Down
    - OpenGL Basics") , *One Step Forward, One Level Down - OpenGL Basics*. Let''s
    start by creating some common definitions that this system will use:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SFML非常适合渲染精灵，但我们必须记住这些是二维对象。在3D空间中，我们的角色将实际上是纸薄的。这意味着我们游戏中的所有阴影投射者都需要一些3D几何体作为支撑。记住，这些基本的渲染概念已经在[第7章](ch07.html
    "第7章。向前迈一步，向下提升一级 - OpenGL基础")，*向前迈一步，向下提升一级 - OpenGL基础*中已经介绍过了。让我们首先创建一些系统将使用的通用定义：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is going to be a common lookup array for us, and it's important that the
    directional vectors here are defined correctly. It represents a direction towards
    each face of the cubemap texture.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们常用的查找数组，并且在这里正确地定义方向向量非常重要。它代表指向立方体贴图纹理每个面的方向。
- en: 'Another common data structure we will be using is a list of indices used to
    draw the cubes/3D rectangles that represent our shadow casters:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用另一种常见的数据结构，即用于绘制代表我们的阴影投射者的立方体/3D矩形的索引列表：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since the cubes have 6 faces and each face uses 6 indices to enumerate the two
    triangles that make them up, we have a total of 36 indices.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于立方体有6个面，每个面使用6个索引来枚举构成它们的两个三角形，因此我们总共有36个索引。
- en: 'Finally, we need an up vector for each direction of a cubemap texture:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要为每个立方体贴图纹理的方向提供一个向上向量：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In order to get correct shadow mapping for the geometry, we're going to need
    to use these up directions when rendering to a shadow cubemap. Note that, unless
    we're rendering to *Y* faces of the cubemap, the *Y* direction is always used
    as up. This allows the geometry being rendered to be seen correctly by the camera.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为几何体获得正确的阴影映射，我们需要在渲染到阴影立方体贴图时使用这些向上方向。请注意，除非我们正在渲染到立方体贴图的*Y*面，否则*Y*方向始终用作向上方向。这允许渲染的几何体被相机正确地看到。
- en: Implementing the shadow caster structure
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现阴影投射者结构
- en: 'Representing the literally shapeless entities of our game is the task we''re
    going to be tackling next. In order to minimize the memory usage of this approach,
    it will be broken down into two parts:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 表示我们游戏中无形的实体是我们将要解决的问题。为了最小化这种方法的内存使用，它将被分为两部分：
- en: '**Prototype**: This is a structure that holds handles to uploaded geometry
    used by OpenGL. This kind of object represents a unique, one of a kind model.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原型**：这是一个包含OpenGL使用的上传几何体的句柄的结构。这种类型的对象代表一个独特、独一无二的模型。'
- en: '**Caster**: This is a structure that holds a pointer to a prototype it''s using,
    along with its own transform, to position, rotate, and scale it correctly.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**投射者**：这是一个包含它所使用的原型的指针以及它自己的变换的结构，用于正确地定位、旋转和缩放。'
- en: 'The prototype structure needs to hold on to the resources it allocates, as
    follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 原型结构需要保留它分配的资源，如下所示：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The constructor and destructor of this structure will take care of allocation/de-allocation
    of these resources:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构的构造函数和析构函数将负责这些资源的分配/释放：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the internal `m_vertices` data member is properly filled out, the geometry
    can be submitted to the GPU as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦内部`m_vertices`数据成员被正确填充，几何体就可以按照以下方式提交给GPU：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once the vertex array object and two buffers for vertices and indices are properly
    created, they're all bound and used to push the data to. Note the highlighted
    portion of the code that deals with the vertex attributes. Since this geometry
    is only going to be used to generate shadows, we really don't need anything else
    except the vertex position. The necessary math of converting all of that information
    into color values that represent distance from the light source is going to be
    done inside the shaders.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦正确创建了顶点数组对象以及用于顶点和索引的两个缓冲区，它们就会被绑定并用于推送数据。注意代码中处理顶点属性的突出部分。由于这个几何体仅用于生成阴影，我们实际上不需要除了顶点位置之外的其他任何东西。将所有这些信息转换为表示光源距离的颜色值的必要数学计算将在着色器内部完成。
- en: Also, note the usage of indices to render this geometry here. Doing it this
    way allows us to save some space by not having to upload twice as many vertices
    to the GPU as we would have to otherwise.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意这里渲染此几何体时使用的索引。这样做可以节省空间，因为我们不需要像其他情况下那样将两倍的顶点上传到GPU。
- en: 'The drawing of the shadow primitives is just as simple as one would imagine:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影原语的绘制就像人们想象的那样简单：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once all of the buffers are bound, we invoke `glDrawElements`. Let it know we're
    drawing triangles, give the method the count of indices to use, specify their
    data type, and provide the proper offset for those indices, which in this case
    is *0*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有缓冲区都绑定，我们就调用`glDrawElements`。让它知道我们在绘制三角形，给方法提供要使用的索引计数，指定它们的数据类型，并提供这些索引的正确偏移量，在这种情况下是*0*。
- en: 'Finally, because we''re using prototypes to store unique pieces of geometry,
    it''s definitely useful to overload the `==` operator for easy checking of matching
    shapes:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，因为我们使用原型来存储独特的几何体片段，所以为方便检查匹配的形状而重载`==`运算符肯定是有用的：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each vertex of the shadow primitive is iterated over and compared to the equivalent
    vertex of the provided argument. So far, nothing out of the ordinary!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历并比较阴影原语中的每个顶点与提供的参数的等效顶点。到目前为止，没有什么异常之处！
- en: 'The prototypes are going to need to be identified in some way when they''re
    being stored. Using string identifiers can be quite intuitive in this case, so
    let''s define a proper storage container type for this structure:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当原型被存储时，需要以某种方式识别它们。在这种情况下，使用字符串标识符可以非常直观，因此让我们为这个结构定义一个合适的存储容器类型：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With that out of the way, we can implement our simple `ShadowCaster` structure
    that''s going to hold all of the variable information about the prototype:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完这些之后，我们可以实现我们的简单 `ShadowCaster` 结构，它将包含有关原型的所有变量信息：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, it's a very simple data structure that holds a pointer to a
    prototype it uses, as well as its own `GL_Transform` member, which is going to
    store the displacement information of an object.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个非常简单的数据结构，它包含一个指向它使用的原型的指针，以及它自己的 `GL_Transform` 成员，该成员将存储对象的位移信息。
- en: 'The shadow casters are also going to need a proper storage data type:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 影子投射器也需要一个合适的存储数据类型：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This effectively leaves us with the means to create and manipulate different
    types of shadow-casting primitives in a memory-conservative manner.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就有了创建和以内存保守的方式操作不同类型阴影投射原型的手段。
- en: Creating the transform class
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建变换类
- en: 'The transform class that we''re using is exactly the same as the one in [Chapter
    7](ch07.html "Chapter 7.  One Step Forward, One Level Down - OpenGL Basics") ,
    *One Step Forward, One Level Down - OpenGL Basics*. For a quick refresher, let''s
    take a look at the most important part of it that we''re going to need for this
    process--the generation of a model matrix:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的变换类与[第7章](ch07.html "第7章。向前迈一步，向下迈一级 - OpenGL基础")，*向前迈一步，向下迈一级 - OpenGL基础*中的完全相同。为了快速复习，让我们看看这个过程中我们需要的重要部分——模型的生成矩阵：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All of this should be familiar by now, and if it isn't, a quick zip through
    [Chapter 7](ch07.html "Chapter 7.  One Step Forward, One Level Down - OpenGL Basics")
    , *One Step Forward, One Level Down - OpenGL Basics* is definitely in order. The
    main idea, however, is combining the translation, scale, and rotation matrices
    in the right order to retrieve a single matrix that contains all of the information
    about the primitive required to bring its vertices from object space to world
    space.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，所有这些都应该很熟悉，如果不熟悉，快速浏览一下[第7章](ch07.html "第7章。向前迈一步，向下迈一级 - OpenGL基础")，*向前迈一步，向下迈一级
    - OpenGL基础*，这绝对是有序的。然而，主要思想是按照正确的顺序组合平移、缩放和旋转矩阵，以获取一个包含将顶点从对象空间转换到世界空间所需的所有信息的单个矩阵。
- en: Creating a camera class
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建相机类
- en: 'Similar to the `GL_Transform` class, we''re also going to incorporate the `GL_Camera`
    class from [Chapter 7](ch07.html "Chapter 7.  One Step Forward, One Level Down
    - OpenGL Basics") , *One Step Forward, One Level Down - OpenGL Basics*. When we''re
    rendering shadow maps, the projection and view matrices for all six directions
    will need to be submitted to the respective shaders. This makes the `GL_Camera`
    class perfect for representing a light in a scene that needs to draw what it sees
    into a cubemap texture. Once again, this has been covered already, so we''re just
    going to breeze through it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `GL_Transform` 类类似，我们还将从[第7章](ch07.html "第7章。向前迈一步，向下迈一级 - OpenGL基础")，*向前迈一步，向下迈一级
    - OpenGL基础*中引入 `GL_Camera` 类。当我们渲染阴影贴图时，所有六个方向的投影和视图矩阵都需要提交给相应的着色器。这使得 `GL_Camera`
    类非常适合表示场景中的光源，该光源需要将其看到的图像绘制到立方体贴图中。再次强调，这已经讨论过了，所以我们只是快速浏览一下：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Appropriately enough, shadow maps are going to be drawn using a perspective
    projection. After all the necessary information about view frustum is collected,
    we can begin constructing the matrices necessary to transform those vertices from
    world space to the light''s view space, as well as to clip space:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 很合适地，阴影贴图将使用透视投影来绘制。在收集了所有必要的视图截锥体信息之后，我们可以开始构建将那些顶点从世界空间转换到光源视图空间以及裁剪空间的矩阵：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We're using `glm::lookAt` to construct a view matrix for the light's camera.
    Then, `glm::perspective` is used in another method to create the perspective projection
    matrix for the camera.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `glm::lookAt` 来构造光摄像机的视图矩阵。然后，在另一个方法中使用 `glm::perspective` 来创建摄像机的透视投影矩阵。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's very important to remember that `glm::perspective` takes the field of view
    angle of the view frustum as the first argument. It expects this parameter to
    be in **radians**, not degrees! Because we're storing it in degrees, `glm::radians`
    is used to convert that value. This is a very easy mistake to make and many people
    end up having problems with their shadow maps not mapping correctly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要记住，`glm::perspective` 函数将视锥体的视场角度作为第一个参数。它期望这个参数是以**弧度**为单位，而不是以度为单位！因为我们是以度为单位存储的，所以使用了
    `glm::radians` 来转换这个值。这是一个很容易犯的错误，很多人最终会遇到他们的阴影映射不正确的问题。
- en: Defining a cube texture class
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义立方体贴图纹理类
- en: Now that we have the storage of geometry and representation of the light's view
    frustum figured out, it's time to create the cube texture we're going to use to
    actually render the scene to.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经弄清楚了几何存储和光视锥体的表示，是时候创建我们将用于实际渲染场景的立方体贴图了。
- en: 'Let''s start by creating a simple class definition for it:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为它创建一个简单的类定义开始：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The texture is going to be used for two distinctive actions: being rendered
    to and being sampled. Both of these processes have a method for binding and unbinding
    the texture, with the notable difference that the sampling step also requires
    a texture unit as an argument. We''re going to cover that soon. This class also
    needs to have a separate method that needs to be called for each of the six faces
    when they''re being rendered.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个纹理将被用于两个独特的操作：渲染到纹理和从纹理采样。这两个过程都有一个用于绑定和解绑纹理的方法，值得注意的是，采样步骤还需要一个纹理单元作为参数。我们很快就会介绍这一点。这个类还需要有一个单独的方法，当六个面被渲染时需要调用。
- en: Although cube textures can be used for many things, in this particular instance,
    we're simply going to be using them for shadow mapping. The texture dimensions,
    therefore, are defined as constants of *1024px*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然立方体贴图可以用于很多事情，但在这个特定的例子中，我们只是将它们用于阴影映射。因此，纹理的尺寸被定义为 *1024px* 的常量。
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The size of a cubemap texture matters greatly, and can cause artifacting if
    left too small. Smaller textures will lead to sampling inaccuracies and will cause
    jagged shadow edges.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体贴图纹理的大小非常重要，如果太小，可能会导致伪影。较小的纹理会导致采样不准确，并造成阴影边缘参差不齐。
- en: Lastly, alongside the helper methods used when creating the texture and all
    of the necessary buffers, we store the handles to the texture itself, the frame
    buffer object, and render buffer object. The last two objects haven't been covered
    until this point, so let's dive right in and see what they're for!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，除了创建纹理和所有必要的缓冲区时使用的辅助方法之外，我们还存储了纹理本身、帧缓冲对象和渲染缓冲对象的句柄。直到这一点，最后两个对象还没有被介绍，所以让我们直接深入了解它们的作用！
- en: Implementing the cube texture class
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现立方体贴图类
- en: 'Let''s start, as always, by covering the construction and destruction of this
    particular OpenGL asset:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从始终如一地介绍这个特定的 OpenGL 资产的构建和销毁开始：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Similar to geometry classes, the handles are initialized to values of *0* to
    indicate their state of not being set up. The destructor checks those values and
    invokes the appropriate `glDelete` methods for the buffers/textures used.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与几何类类似，句柄被初始化为 *0* 的值，以指示它们的状态尚未设置。析构函数会检查这些值，并调用用于缓冲区/纹理的适当 `glDelete` 方法。
- en: 'Creating the cubemap is quite similar to a regular 2D texture, so let''s take
    a look:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建立方体贴图与常规 2D 纹理非常相似，所以让我们看看：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, a check is made to make sure we haven't already allocated this object.
    Provided that isn't the case, `glGenTextures` is used, just like for 2D textures,
    to create space for one texture object. Our first private helper method is then
    invoked to create all six faces of the cubemap, which brings us to the parameter
    setup. The *Min/Mag* filters are set up to use the nearest-neighbor interpolation,
    but can later be converted to `GL_LINEAR` for smoother results, if necessary.
    The texture wrapping parameters are then set up so that they're clamped to the
    edge, giving us a seamless transition between faces.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，进行一个检查以确保我们没有已经分配这个对象。如果情况不是这样，就像为 2D 纹理一样使用 `glGenTextures` 来为纹理对象创建空间。然后调用我们的第一个私有辅助方法来创建立方体贴图的所有六个面，这把我们带到了参数设置。*Min/Mag*
    过滤器被设置为使用最近邻插值，但必要时可以转换为 `GL_LINEAR` 以获得更平滑的结果。然后设置纹理包装参数，使它们被夹在边缘，从而在面之间提供无缝过渡。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that there are three parameters for texture wrapping: R, S, and T. That''s
    because we''re dealing with a three-dimensional texture type now, so each axis
    must be accounted for.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，纹理包裹有三个参数：R、S和T。这是因为我们现在处理的是三维纹理类型，所以每个轴都必须考虑在内。
- en: Lastly, another helper method is invoked for the creation of the buffers, just
    before we unbind the texture as we're done with it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在解绑纹理之前，我们调用另一个辅助方法来创建缓冲区。
- en: 'The creation of the cubemap faces, once again, is similar to how we set up
    its 2D counterpart back in [Chapter 7](ch07.html "Chapter 7.  One Step Forward,
    One Level Down - OpenGL Basics") , *One Step Forward, One Level Down - OpenGL
    Basics*, but the trick is to do it once for each face:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 立方体贴图面的创建，再次，与我们在[第7章](ch07.html "第7章. 向前一步，向下一个级别 - OpenGL基础")中设置其2D对应物的方式相似，即《向前一步，向下一个级别
    - OpenGL基础》，但技巧是针对每个面只做一次：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once the texture is bound, we iterate over each face and use `glTexImage2D`
    to set the face up. Each face is treated as a 2D texture, so this should really
    be nothing new to look at. Note, however, the use of the `GL_TEXTURE_CUBE_MAP_POSITIVE_X`
    definition usage is the first argument. 2D textures would take in a `GL_TEXTURE_2D`
    definition, but because cubemaps are stored in an unfolded manner, getting this
    part right is important.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦纹理被绑定，我们就遍历每个面，并使用`glTexImage2D`来设置面。每个面都被视为一个2D纹理，所以这部分应该不会有什么新内容。注意，然而，使用`GL_TEXTURE_CUBE_MAP_POSITIVE_X`定义的使用是第一个参数。2D纹理会接受一个`GL_TEXTURE_2D`定义，但由于立方体贴图以展开的方式存储，正确获取这部分内容非常重要。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are six definitions of `GL_TEXTURE_CUBE_MAP_`*. They're all defined in
    a row of *+X*, *-X*, *+Y*, *-Y*, *+Z*, and *-Z*, which is why we can use some
    basic arithmetic to pass in the correct face to the function by simply adding
    an integer to the definition.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`GL_TEXTURE_CUBE_MAP_`*有六个定义。它们都定义在一行中，即*+X*、*-X*、*+Y*、*-Y*、*+Z*和*-Z*，这就是为什么我们可以通过简单地将一个整数加到定义中，使用一些基本的算术来将正确的面传递给函数。'
- en: 'Clearing the cubemap texture is relatively easy:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 清除立方体贴图纹理相对简单：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that we're specifying the clear color as white, because that represents
    *infinite distance from the light* in a shadow map.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们指定清除颜色为白色，因为这代表在阴影图中从光源到无穷远的距离。
- en: 'Finally, sampling the cubemap is actually not any different from sampling a
    regular 2D texture:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，采样立方体贴图实际上与采样常规2D纹理没有区别：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Both binding and unbinding for sampling requires us to pass in the texture unit
    we want to use. Once the unit is active, we should enable the use of cubemaps
    and then bind the cubemap texture handle. The reverse of this procedure should
    be followed when unbinding the texture.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于采样，绑定和解绑都需要我们传入我们想要使用的纹理单元。一旦单元被激活，我们应该启用立方体贴图的使用，然后绑定立方体贴图纹理句柄。解绑纹理时应该遵循此过程的逆过程。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that the respective `sampler2D`/`samplerCube` uniforms inside fragment
    shaders are set to hold the unit ID of the texture they're sampling. When a texture
    is bound, the specific ID of that unit will be used to access it in a shader from
    then on, not the actual texture handle.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，片段着色器中的相应`sampler2D`/`samplerCube`统一变量被设置为保存它们所采样的纹理的单元ID。当纹理被绑定时，该单元的特定ID将从那时起在着色器中用于访问，而不是实际的纹理句柄。
- en: Rendering to an off-screen buffer
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 渲染到离屏缓冲区
- en: Something we didn't cover in [Chapter 7](ch07.html "Chapter 7.  One Step Forward,
    One Level Down - OpenGL Basics") , *One Step Forward, One Level Down - OpenGL
    Basics* is rendering a scene to a buffer image, rather than drawing directly onscreen.
    Luckily, because OpenGL operates as a giant state machine, it's just a matter
    of invoking the right functions at the right time, and doesn't involve us having
    to redesign the rendering procedures in any way.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第7章](ch07.html "第7章. 向前一步，向下一个级别 - OpenGL基础")中没有涵盖的内容是，将场景渲染到缓冲区图像，而不是直接在屏幕上绘制。幸运的是，因为OpenGL作为一个巨大的状态机运行，这只是一个在正确的时间调用正确函数的问题，并不需要我们以任何方式重新设计渲染过程。
- en: In order to render to a texture object, we must use what is called a **framebuffer**.
    It's a very basic object that directs draw calls to a texture the FBO is bound
    to. While FBOs are useful for color information, they don't carry the depth components
    with them. A **renderbuffer** object is used for that very purpose of attaching
    additional components to the FBO.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染到纹理对象，我们必须使用所谓的**帧缓冲区**。这是一个非常基本的对象，它将绘制调用指向FBO绑定的纹理。虽然FBO对于颜色信息很有用，但它们并不携带深度分量。一个**渲染缓冲区**对象用于将附加分量附加到FBO的目的。
- en: 'The first step to drawing something offscreen is creating a `FRAMEBUFFER` object
    and a `RENDERBUFFER` object:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制离屏内容的第一个步骤是创建一个`FRAMEBUFFER`对象和一个`RENDERBUFFER`对象：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After the buffers have been generated, the render buffer needs to have some
    storage allocated for any additional components it will provide. In this case,
    we're simply dealing with the depth component.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成缓冲区之后，渲染缓冲区需要为其将提供的任何附加分量分配一些存储空间。在这种情况下，我们只是处理深度分量。
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `GL_DEPTH_COMPONENT24` simply indicates that each depth pixel has a size
    of 24 bits. This definition can be replaced with a basic `GL_DEPTH_COMPONENT`,
    which will allow the application to choose the pixel size.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`GL_DEPTH_COMPONENT24`简单地表示每个深度像素的大小为24位。这个定义可以被一个基本的`GL_DEPTH_COMPONENT`所替代，这将允许应用程序选择像素大小。'
- en: The depth render buffer is then attached to the FBO as a depth attachment. Finally,
    if there were any errors during this procedure, `glCheckFramebufferStatus` is
    used to catch them. The next line simply prints out the status variable using
    `std::cout`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将深度渲染缓冲区作为深度附加组件附加到FBO上。最后，如果在这次过程中出现任何错误，`glCheckFramebufferStatus`用于捕获它们。下一行简单地使用`std::cout`打印出状态变量。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Frame buffers should always be unbound when no longer used, using `glBindFramebuffer(GL_FRAMEBUFFER,
    0)`! That's the only way we're ever going to go back to rendering subsequent geometry
    to the screen, rather than the buffer texture.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当不再使用时，帧缓冲区应该始终使用`glBindFramebuffer(GL_FRAMEBUFFER, 0)`解绑！这是我们回到将后续几何图形绘制到屏幕上而不是缓冲区纹理的唯一方法。
- en: 'Now that we have the buffers set up, let''s use them! When drawing to a buffer
    texture is desired, it''s first necessary to bind the frame buffer:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了缓冲区，让我们使用它们！当想要向缓冲区纹理绘制时，首先必须绑定帧缓冲区：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Unbinding the FBO is necessary after we're done with it. Using `RenderingUnbind()`
    means that any subsequent geometry will be drawn onscreen.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成使用后，解绑FBO是必要的。使用`RenderingUnbind()`意味着任何后续的几何图形都将绘制到屏幕上。
- en: 'Of course, just because the FBO is bound, doesn''t mean we''re going to magically
    start drawing to the cubemap. In order to do that, we must draw to one face at
    a time by binding the frame buffer to the desired face of the cubemap:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅因为FBO被绑定，并不意味着我们会神奇地开始向立方体贴图绘制。为了做到这一点，我们必须一次绘制立方体贴图的一个面，通过将帧缓冲区绑定到立方体贴图所需的面：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first argument to `glFramebufferTexture2D` simply indicates we're dealing
    with an FBO. We then specify that we want to use `GL_COLOR_ATTACHMENT0`. Frame
    buffers can have multiple attachments and use shaders to output different data
    to each one of them. For our purposes, we're only going to need to use one attachment.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`glFramebufferTexture2D`的第一个参数简单地表示我们正在处理一个FBO。然后我们指定我们想要使用`GL_COLOR_ATTACHMENT0`。帧缓冲区可以有多个附加组件，并使用着色器将不同的数据输出到每个附加组件。就我们的目的而言，我们只需要使用一个附加组件。'
- en: Because we're rendering to one face of the cubemap at a time, basic definition
    arithmetic is, once again, used to pick the correct face of the cube to render
    to. Finally, the texture handle and mipmapping level are passed in at the very
    end, just before `Clear()` is invoked to clear the face we currently bound to
    complete white.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们一次渲染立方体贴图的一个面，基本的定义算术再次被用来选择正确的立方体面进行渲染。最后，在调用`Clear()`清除当前绑定的面之前，将纹理句柄和米级映射级别传递进去，以完成白色面的清除。
- en: Rendering the shadow maps
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染阴影贴图
- en: We now have everything we need in order to start rendering shadow maps of our
    scene. Some rather significant changes are going to have to be made to the `LightManager`
    class in order to support this functionality, not to mention properly store and
    use these shadow map textures during later passes. Let's see what changes we need
    to make in order to make this happen.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了开始渲染场景阴影贴图所需的一切。为了支持这个功能，需要对`LightManager`类进行一些相当重大的修改，更不用说在后续过程中正确存储和使用这些阴影贴图纹理了。让我们看看我们需要做出哪些修改才能实现这一点。
- en: Modifying the light manager
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改光管理器
- en: 'First, let''s make some adjustments to the light manager class definition.
    We''re going to need a couple of methods to add shadow caster prototypes, add
    actual shadow casting objects, and render the shadow maps:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们对光照管理器类定义做一些调整。我们需要几个方法来添加阴影投射者原型、添加实际的阴影投射对象以及渲染阴影贴图：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In addition to the aforementioned methods, the `LightManager` class is also
    going to need to store extra information to support these changes. A list of both
    shadow primitive prototypes and the primitives themselves will need to be used
    to manage the entities that have to cast shadows. Additionally, we need to have
    the camera class that will be used as the point of view of the light.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述方法之外，`LightManager`类还需要存储额外的信息来支持这些更改。需要使用阴影原语原型和原语本身的一个列表来管理必须投射阴影的实体。此外，我们还需要有将用作光照视点的相机类。
- en: Lastly, an array of cubemap textures is required, since each light onscreen
    will be potentially seeing the scene from a completely different point of view,
    of course. The size of this array is simply the number of lights we're dealing
    with per shader pass, because these cubemap textures only need to exist for as
    long as they're being sampled. Once the lighting pass for those particular lights
    is over, the textures can be re-used for the next batch.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要一个立方体贴图纹理的数组，因为屏幕上的每个光线都可能从完全不同的视角看到场景。这个数组的大小仅仅是每个着色器通道中我们处理的灯光数量，因为这些立方体贴图纹理只需要在它们被采样时存在。一旦完成特定灯光的照明通道，这些纹理就可以被重新用于下一批。
- en: Implementing the light manager changes
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现光照管理器更改
- en: 'The adjustments to the constructor of the `LightManager` class are fairly simple
    to make this work:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对`LightManager`类构造函数的调整相当简单，以便实现这一点：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first thing we need to worry about is setting up the perspective camera
    correctly. It's initialized to be positioned at absolute zero coordinates in the
    world, and has its field of view angle set to **90 degrees**. The aspect ratio
    of the perspective camera is obviously going to be *1*, because the width and
    height of the textures we're using for rendering shadow casters to are identical.
    The view frustum minimum value is set to *1.f*, which ensures that the geometry
    won't be rendered if the light is intersecting with a face. The maximum value,
    however, will change for each light, depending on its radius. This default value
    isn't really important.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要关注的是正确设置透视相机。它被初始化为位于世界中的绝对零坐标，并且其视场角设置为**90度**。透视相机的纵横比显然将是*1*，因为我们用于渲染阴影投射者的纹理的宽度和高度是相同的。视图视锥的最小值设置为*1.f*，这确保了当光线与面相交时，几何体不会被渲染。然而，最大值将根据每个光线的半径而变化。这个默认值实际上并不重要。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Setting the field of view angle of **90** degrees for rendering a scene to a
    cubemap texture is important, as that's the only way the scene is going to be
    captured completely for each direction the camera looks at. Going too low on this
    value means there are going to be blind spots, and going too high will cause overlapping.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将场景渲染到立方体贴图纹理的视场角设置为**90**度对于渲染非常重要，因为这是场景能够被完全捕捉到每个相机所看的方向的唯一方式。这个值设置得太低意味着会出现盲点，而设置得太高则会导致重叠。
- en: The last thing we need to do in the constructor is make sure that all cubemap
    textures are allocated properly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中最后需要确保所有立方体贴图纹理都正确分配。
- en: 'Next, let''s worry about adding shadow caster prototypes to the light manager:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们关注向光照管理器添加阴影投射者原型：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When adding a prototype, the caller of this particular method will provide a
    string identifier for it, as well as move its established and allocated smart
    pointer to the second argument after the vertices have been properly loaded. First,
    we make sure the name provided as an argument isn't already taken. If it is, that
    same string is returned back just after the memory for the prototype provided
    as an argument is released.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加原型时，调用此特定方法的调用者将提供一个字符串标识符，以及将已建立和分配的智能指针移动到第二个参数之后，在顶点被正确加载之后。首先，我们确保提供的参数名称尚未被占用。如果是，则在释放作为参数提供的原型的内存之后立即返回相同的字符串。
- en: The second test makes sure that a prototype with the exact arrangement of vertices
    doesn't already exist under a different name, by iterating over every stored prototype
    and using the `==` operator we implemented earlier to compare the two. If something
    is found, the name of that prototype is returned instead, just after the `l_caster`
    is released.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试确保没有以不同的名称存在具有精确顶点排列的原型，通过遍历每个存储的原型并使用我们之前实现的`==`运算符来比较这两个原型。如果找到，则在释放`l_caster`之后返回该原型的名称。
- en: Finally, since we can be sure that the prototype we're adding is completely
    unique, the render window is set to active. `UploadVertices` on the object is
    invoked to send the data to the GPU and the prototype is placed inside the designated
    container.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们可以确信我们添加的原型是完全独特的，渲染窗口被设置为活动状态。对象上的`UploadVertices`被调用以将数据发送到GPU，并将原型放置在指定的容器中。
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using `sf::RenderWindow::setActive(true)` ensures that the main context is used
    while the vertices are uploaded. OpenGL **does not** share its states among different
    contexts, and since SFML likes to keep a number of different contexts alive internally,
    it's imperative to make sure the main context is selected during all operations.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sf::RenderWindow::setActive(true)`确保在上传顶点时使用主上下文。OpenGL **不**在不同上下文之间共享其状态，由于SFML喜欢在内部保持多个不同的上下文活跃，因此在所有操作期间选择主上下文是至关重要的。
- en: 'Adding shadow casters themselves is relatively easy as well:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 添加阴影投射器本身也相对简单：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This method only takes a string identifier for the prototype to be used, and
    allocates space for a new shadow caster object, provided the prototype with said
    name exists. Note the line just before the `return` statement. It ensures that
    the located prototype is passed to the shadow caster, so that it can use the prototype
    later.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法仅需要一个用于原型的字符串标识符，并在原型存在的情况下为新的阴影投射器对象分配空间。注意`return`语句之前的行。它确保找到的原型被传递给阴影投射器，以便它可以在以后使用该原型。
- en: 'Obtaining the prototypes is incredibly simple, and only requires a lookup into
    an `unordered_map` container:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 获取原型非常简单，只需要在`unordered_map`容器中进行查找：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We now only have one task at hand drawing the shadow maps!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在只有一个任务，那就是绘制阴影图！
- en: Drawing the actual shadow maps
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制实际的阴影图
- en: 'In order to keep this manageable and compartmentalized, we''re going to break
    down the `DrawShadowMap` method into smaller parts that we can discuss independently
    of the rest of the code. Let''s start by looking at the actual blueprint of the
    method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持可管理和模块化，我们将`DrawShadowMap`方法分解成更小的部分，这样我们就可以独立于其他代码讨论它们。让我们首先看看该方法的实际蓝图：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, it takes in a handle for the shadow pass shader. This is about as raw
    as it gets, since the handle is a simple unsigned integer we're going to bind
    to before drawing. The second argument is a reference to a light that we're currently
    drawing the shadow map for. Lastly, we have an *unsigned integer* that serves
    as the ID for the light that's being rendered in the current pass. In the case
    of having 4 lights per shader pass, this value will range from 0 to 3, and then
    get reset in the next pass. It is going to be used as an index for the cubemap
    texture lookup.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它接受一个用于阴影传递着色器的句柄。这几乎是原始的，因为句柄是一个简单的无符号整数，我们将在绘制之前将其绑定。第二个参数是我们当前正在绘制阴影图的光的引用。最后，我们有一个作为当前传递中渲染的光的ID的*无符号整数*。在每款着色器传递有4个光的情况下，此值将在0到3之间变化，然后在下一个传递中重置。它将被用作立方体贴图纹理查找的索引。
- en: 'Now, it''s time to really get into the actual rendering of the shadow maps,
    starting with enabling necessary OpenGL features:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候真正深入到阴影图的渲染中了，从启用必要的OpenGL功能开始：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first and most obvious feature we're going to be using here is the depth
    test. This ensures that different shadow caster geometry isn't rendered in the
    wrong order, overlapping each other. Then, we're going to be performing some face
    culling. Unlike normal geometry, however, we're going to be culling the front
    faces only. Drawing the back faces of shadow geometry will ensure that the front
    faces of sprites we're using will be lit, since the depth stored in the shadow
    map is the depth of the very back of the shadow-casting primitives.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将要使用的第一和最明显的特性是深度测试。这确保了不同的阴影投射几何体不会被错误地渲染，避免相互重叠。然后，我们将执行一些面剔除。然而，与正常几何体不同，我们将只剔除前向面。绘制阴影几何体的背面将确保我们使用的精灵的前面会被照亮，因为阴影图中存储的深度是阴影投射原型的最背面。
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The next part here deals with actually binding the shadow pass shader and fetching
    locations of different shader uniform variables. We have a model matrix uniform,
    a view matrix uniform, a projection matrix uniform, a light position uniform,
    and the frustum far uniform to update.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来这部分处理的是实际绑定阴影传递着色器并获取不同着色器统一变量的位置。我们有一个模型矩阵统一变量、一个视图矩阵统一变量、一个投影矩阵统一变量、一个灯光位置统一变量以及一个用于更新的视锥体远端统一变量。
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This next part of the code obtains a reference to the appropriate cubemap texture
    for the particular light, storing the light position, and positioning the perspective
    camera at that exact position.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的这一部分获取了特定灯光的适当立方体贴图纹理的引用，存储了灯光位置，并将透视摄像机定位在该确切位置。
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the swapped *Z* and *Y* coordinates. By default, OpenGL deals with the
    right-hand coordinate system. It also deals with the default *up* direction being
    the *+Y* axis. Our lights store coordinates using the *+Z* axis as the *up* direction.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意交换的 *Z* 和 *Y* 坐标。默认情况下，OpenGL 处理右手坐标系。它还处理默认的 *up* 方向是 *+Y* 轴。我们的灯光使用 *+Z*
    轴作为 *up* 方向来存储坐标。
- en: After the camera is set up, `glViewport` is invoked to resize the render target
    to the size of the cubemap texture. The cubemap is then bound to for rendering
    and we submit the light position uniform to the shaders. Just as before, the *Z*
    and *Y* directions here are swapped.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好摄像机后，`glViewport` 被调用以调整渲染目标的大小为立方体贴图纹理的大小。然后，立方体贴图被绑定用于渲染，并将灯光位置统一变量提交给着色器。就像之前一样，这里的
    *Z* 和 *Y* 方向被交换。
- en: 'With the setup out of the way, we can actually begin rendering the scene for
    each face of the cubemap:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完成后，我们可以开始为立方体贴图的每个面渲染场景：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The cubemap texture is first told which face we wish to render to in order to
    set up the FBO correctly. The forward and up directions for that particular face
    are then passed to the light's camera, along with the frustum far value, being
    the radius of the light. The perspective projection matrix is then recalculated,
    and both the view and projection matrices are retrieved from `GL_Camera` to pass
    to the shader, along with the frustum far value.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先告诉立方体贴图纹理我们希望渲染哪个面，以正确设置 FBO。然后，将那个特定面的前向和向上方向传递给灯光的摄像机，以及视锥体远值，即灯光的半径。然后重新计算透视投影矩阵，并从
    `GL_Camera` 获取视图和投影矩阵，将它们以及视锥体远值传递给着色器。
- en: Lastly, for each of the 6 faces of the cubemap, we iterate over all of the shadow
    caster objects, retrieve their model matrices, pass them into the shader, and
    invoke the prototype's `Draw()` method, which takes care of the rendering.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于立方体贴图的 6 个面，我们遍历所有的阴影投射对象，检索它们的模型矩阵，将它们传递到着色器中，并调用原型的 `Draw()` 方法，该方法负责渲染。
- en: 'After all of the texture''s faces have been drawn to, we need to set the state
    back to what it was before rendering shadow maps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制完所有纹理面之后，我们需要将状态设置回渲染阴影图之前的状态：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The texture is first unbound for rendering, which sets the FBO to 0 and allows
    us to draw to the screen again. The viewport is then resized back to the original
    size our window had, and the depth test, along with face culling, are both disabled.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将纹理从渲染中解绑，这会将 FBO 设置为 0，并允许我们再次绘制到屏幕上。然后，视口被调整回窗口原始大小，深度测试和面剔除都被禁用。
- en: The shadow pass shaders
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阴影传递着色器
- en: 'The C++ side of shadow mapping is finished, but we still have some logic to
    cover. The shaders here play an important role of actually translating the vertex
    information into depth. Let''s take a look at the vertex shader first:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影映射的 C++ 方面已经完成，但我们还有一些逻辑需要覆盖。这里的着色器实际上起着将顶点信息转换为深度的关键作用。让我们首先看看顶点着色器：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `vec3` input coordinates of a vertex position we receive on the GPU are
    in local space, which means they have to be passed through a number of matrices
    to be brought to world, view, and clip spaces in that order. The world coordinates
    are calculated first and stored separately, because they''re used to determine
    the distance between the vertex and the light. That distance is stored in the
    local variable `d`, which is divided by the frustum far value to convert it to
    a range of *[0;1]*. The position of the vertex is then converted to clip space
    by using the world, view, and projection matrices, and the distance value is passed
    on to the fragment shader, where it''s stored as a color for a particular pixel:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在GPU上接收到的顶点位置`vec3`输入坐标是在局部空间中，这意味着它们必须通过多个矩阵传递，以便按顺序转换到世界、视图和裁剪空间。首先计算世界坐标并单独存储，因为它们用于确定顶点与光源之间的距离。这个距离存储在局部变量`d`中，然后除以视锥体的远值，将其转换为范围*[0;1]*。然后使用世界、视图和投影矩阵将顶点位置转换为裁剪空间，并将距离值传递到片段着色器，在那里它被存储为特定像素的颜色：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Remember that the output variables from the vertex shader are interpolated between
    the vertices, so each fragment in between those vertices will be shaded in a gradient-like
    manner.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，顶点着色器的输出变量在顶点之间进行插值，所以这些顶点之间的每个片段将以渐变的方式着色。
- en: Results
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'While we still don''t have any actual geometry in the project to see the results
    of this, once we''re done, it will look like the following screenshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在这个项目中还没有任何实际的几何形状来查看这个结果，一旦完成，它将看起来像以下截图：
- en: '![Results](img/image_09_007.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![结果](img/image_09_007.jpg)'
- en: 'In this particular case, the primitives were extremely close to the light,
    so they''re shaded really dark. Given greater distances, a particular face of
    a shadow map would look a little something like this, where *#1* is a primitive
    close to the camera, *#2* is further away, and *#3* is near the far end of the
    view frustum:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的情况下，原始形状非常接近光源，因此它们被着色得非常暗。对于更大的距离，阴影贴图的一个特定面看起来可能像这样，其中*#1*是靠近摄像机的原始形状，*#2*更远，而*#3*接近视锥体的远端：
- en: '![Results](img/image_09_008.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![结果](img/image_09_008.jpg)'
- en: Adapting the light pass
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配光照阶段
- en: With the shadow maps rendered, it may be extremely tempting to try and sample
    them in our existing code, since the hard part is over, right? Well, not entirely.
    While we were extremely close with our previous approach, sadly, sampling of cubemap
    textures is the only thing that we couldn't do because of SFML. The sampling itself
    isn't really the problem, as much as binding the cubemap textures to be sampled
    is. Remember that sampling is performed by setting a uniform value of the sampler
    inside the shader to the **texture unit ID** that's bound to the texture in our
    C++ code. SFML resets these units each time something is rendered either onscreen,
    or to a render texture. The reason we haven't had this problem before is because
    we can set the uniforms of the shaders through SFML's `sf::Shader` class, which
    keeps track of references to textures and binds them to appropriate units when
    a shader is used for rendering. That's all fine and good, except for when the
    time comes to sample other types of textures that SFML doesn't support, which
    includes cubemaps. This is the only problem that requires us to completely cut
    SFML out of the picture during the light pass and use raw OpenGL instead.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染出阴影贴图后，可能会非常诱人地想要在我们的现有代码中尝试采样它们，因为困难的部分已经过去了，对吧？然而，并非完全如此。虽然我们之前的方案非常接近，但遗憾的是，由于SFML的限制，我们无法进行立方体贴图的采样。采样本身并不是问题，真正的问题是绑定立方体贴图以便进行采样。记住，采样是通过在着色器内部将采样器的统一值设置为**纹理单元ID**来实现的，这个ID绑定到我们在C++代码中的纹理上。SFML每次在屏幕上渲染或在渲染纹理上渲染时都会重置这些单元。我们之前没有遇到这个问题是因为我们可以通过SFML的`sf::Shader`类设置着色器的统一变量，该类跟踪纹理的引用，并在使用着色器进行渲染时将它们绑定到适当的单元。这都很好，但是当需要采样SFML不支持的其他类型的纹理时，比如立方体贴图，问题就出现了。这是唯一一个需要我们在光照阶段完全排除SFML，并使用原始OpenGL的问题。
- en: Replacing the m_fullScreenQuad
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换m_fullScreenQuad
- en: First things first, replacing the `sf::VertexArray` object inside the `LightManager`
    class that's used to redraw an entire buffer texture, which we were utilizing
    for multipass rendering. Since SFML has to be completely cut out of the picture
    here, we can't use its built-in vertex array class and render a quad that covers
    the entire screen. Otherwise, SFML will force its own state on before rendering,
    which isn't going to work with our system properly as it re-assigns its own texture
    units each time.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，替换`LightManager`类内部的`sf::VertexArray`对象，该对象用于重新绘制整个缓冲区纹理，这是我们用于多通道渲染的。由于在这里必须完全排除SFML，我们无法使用其内置的顶点数组类并渲染一个覆盖整个屏幕的四边形。否则，SFML将在渲染之前强制其自己的状态，这不会与我们的系统正确配合，因为它每次都会重新分配自己的纹理单元。
- en: Defining a generic frame buffer object
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义一个通用的帧缓冲区对象
- en: 'Just like before, we need to create a frame buffer object in order to render
    to a texture, rather than the screen. Since we''ve already done this once before
    for a cubemap, let''s breeze through the implementation of a generic FBO class
    for 2D textures:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们需要创建一个帧缓冲区对象以便将渲染到纹理而不是屏幕上。由于我们已经为立方体贴图做过一次，让我们快速浏览一下用于2D纹理的通用FBO类的实现：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The main difference here is the fact that we're using variable sizes for textures
    now. They may vary at some point, so it's a good idea to store the size internally,
    rather than using constant values.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于我们现在使用纹理的变量大小。它们可能在某个时刻发生变化，因此将大小内部存储是一个好主意，而不是使用常量值。
- en: Implementing a generic frame buffer object
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现一个通用的帧缓冲区对象
- en: 'The constructor and destructor of this class, once again, deals with resource
    management:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的构造函数和析构函数再次处理资源管理：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We're not storing a texture handle, because that too will vary depending on
    circumstances.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有存储纹理句柄，因为这也将根据情况而变化。
- en: 'Creating the buffers for this class is pretty similar to what we''ve done before:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为此类创建缓冲区与之前我们所做的大致相同：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Just like the cubemap textures, we need to attach a depth render buffer to the
    FBO. After allocation and binding, the FBO is checked for errors and both buffers
    are unbound.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 就像立方体贴图纹理一样，我们需要将深度渲染缓冲区附加到FBO上。在分配和绑定后，FBO会检查错误，并且两个缓冲区都会解绑。
- en: 'Rendering FBO points to a 2D texture is much easier. Binding for rendering
    needs to take a handle to a texture, because one is not stored internally, since
    this is a generic class that will be used with many different textures:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将FBO渲染到2D纹理要容易得多。渲染绑定需要获取一个纹理句柄，因为内部没有存储，因为这个类是一个通用的类，它将用于许多不同的纹理：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Once the FBO is bound, we again invoke `glFramebufferTexture2D`. This time,
    however, we use `GL_TEXTURE_2D` as the type of the texture, and pass in the `l_texture`
    argument into the function instead.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将FBO绑定，我们再次调用`glFramebufferTexture2D`。然而，这次我们使用`GL_TEXTURE_2D`作为纹理的类型，并将`l_texture`参数传递给函数。
- en: Rendering from a buffer to another buffer in OpenGL
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在OpenGL中从缓冲区渲染到另一个缓冲区
- en: 'During our potentially numerous light passes, we''re going to need a way of
    redrawing every pixel onscreen to the buffer texture just like we did before,
    except without using SFML this time. For this purpose, we''re going to construct
    a quad that has four vertices, all positioned in screen coordinates, and covers
    the screen entirely. These vertices are also going to have texture coordinates
    that will be used to sample the buffer texture. A basic structure of such vertex,
    similar to the one we created in [Chapter 7](ch07.html "Chapter 7.  One Step Forward,
    One Level Down - OpenGL Basics") , *One Step Forward, One Level Down - OpenGL
    Basics* looks like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可能众多的光照通道中，我们需要一种方法来重新绘制屏幕上的每个像素到缓冲区纹理，就像我们之前做的那样，但这次不使用SFML。为此，我们将构建一个具有四个顶点的四边形，所有顶点都位于屏幕坐标中，并覆盖整个屏幕。这些顶点还将具有用于采样缓冲区纹理的纹理坐标。这样的顶点的基本结构，类似于我们在[第7章](ch07.html
    "第7章。向前迈一步，向下提升一级 - OpenGL基础")中创建的结构，*向前迈一步，向下提升一级 - OpenGL基础*看起来是这样的：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This small structure will be used by the quad primitive that will cover the
    entire screen.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小的结构将被用于覆盖整个屏幕的四边形原语。
- en: Creating a basic quad primitive
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个基本的四边形原语
- en: 'The quad primitive, just like any other piece of geometry, must be pushed to
    the GPU for later use. Let''s construct a very basic class that will break down
    this functionality into manageable methods we can easily call from other classes:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 四边形原语，就像任何其他几何体一样，必须推送到GPU以供以后使用。让我们构建一个非常基本的类，将此功能分解成我们可以轻松从其他类中调用的可管理方法：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Once again, we have methods for creating, rendering, binding, and unbinding
    the primitive. The class stores the `m_VAO`, `m_VBO`, and `m_indices` of this
    primitive, which all need to be filled out.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们拥有创建、渲染、绑定和解绑原语的方法。该类存储了这个原语的`m_VAO`、`m_VBO`和`m_indices`，所有这些都需要填写完整。
- en: Implementing the quad primitive class
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现四边形原语类
- en: 'Construction and destruction of this class, once again, all take care of the
    resource allocation/de-allocation:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的构造和析构，再次强调，都负责资源分配/释放：
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Creating and uploading the primitive to the GPU is exactly the same as before:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并将原语上传到GPU的过程与之前完全相同：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The main difference here is that we're defining the vertices inside the method,
    since they're never going to change. The vertex attribute pointers are set up
    after the data is pushed onto the GPU; indices get defined in a clockwise manner
    (default for SFML), and pushed to the GPU.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别在于我们定义了方法内部的顶点，因为它们永远不会改变。顶点属性指针在数据推送到GPU后设置；索引以顺时针方向定义（SFML的默认方式），并推送到GPU。
- en: 'Binding and unbinding the buffers for rendering is, once again, exactly the
    same as with all of the other geometry for OpenGL:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定和解绑用于渲染的缓冲区，再次强调，与OpenGL中所有其他几何体完全相同：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Since we''re using indices, rendering the quad is achieved by calling `glDrawElements`,
    just like before:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用索引，渲染四边形是通过调用`glDrawElements`来实现的，就像之前一样：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This concludes the necessary preparations for rendering from an offscreen buffer
    to the screen.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了从离屏缓冲区到屏幕渲染的必要准备工作。
- en: Making the changes to the light manager
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对光管理器进行更改
- en: 'Given the complete re-architecture of our rendering process for shadows, it''s
    obvious some things are going to have to change within the `LightManager` class.
    First, let''s start with some new data we''re going to need to store:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对阴影渲染过程的完全重构，显然`LightManager`类内部的一些东西将不得不改变。首先，让我们从我们需要存储的一些新数据开始：
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `MaterialHandles` and `MaterialUniformNames` containers will be used to
    store the names and locations of uniforms in our light pass shader. This is an
    effort made entirely to make the mapping of new material map types and uniforms
    much easier by automating it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`MaterialHandles`和`MaterialUniformNames`容器将用于存储我们的光通行着色器中均匀量的名称和位置。这是完全为了通过自动化使新材质映射类型和均匀量的映射变得更加容易而做出的努力。'
- en: 'With that out of the way, let''s take a look at the `LightManager` class definition
    and the changes we need to make to it:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完这些之后，让我们来看看`LightManager`类的定义以及我们需要对其进行的更改：
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In addition to creating some new helper methods for generating material names,
    binding and unbinding all of the necessary 2D textures for the light pass sampling,
    and submitting the uniforms of a given light to the light pass shader, we're also
    storing the material names and handles. The `m_fullScreenQuad` class is replaced
    by our own class, and to accompany it, we have the `GenericFBO` object that will
    help us render to an offscreen buffer.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建一些新的辅助方法来生成材质名称、绑定和解绑光通行采样所需的所有必要的2D纹理，以及将给定光的均匀量提交到光通行着色器之外，我们还存储了材质名称和句柄。`m_fullScreenQuad`类被我们自己的类所取代，与之相伴的是`GenericFBO`对象，它将帮助我们渲染到离屏缓冲区。
- en: Implementing light manager changes
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现光管理器更改
- en: 'The constructor of our `LightManager` class now has additional work to do in
    setting up all of the new data members we added:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`LightManager`类的构造函数现在在设置我们添加的所有新数据成员时需要做更多的工作：
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: First, the FBO we'll be using is set up in the initializer list to hold the
    size of our window. We then ensure that the main OpenGL context is active by activating
    our window, and invoke the `GenerateMaterials` method that will take care of material
    texture allocation and storage of the texture handles for the same.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用FBO在初始化列表中设置窗口的大小。然后我们通过激活我们的窗口来确保主OpenGL上下文是活动的，并调用`GenerateMaterials`方法，该方法将负责材质纹理的分配和存储相应的纹理句柄。
- en: The uniform sampler2D names for all material types are then stored in the appropriate
    container. These names have to match the ones inside the light pass shader!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将所有材质类型的均匀sampler2D名称存储在适当的容器中。这些名称必须与光通行着色器内部的一致！
- en: Finally, the main OpenGL context is selected again and the FBO is created. We
    do this one more time for the `m_fullScreenQuad` class as well.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，再次选择主OpenGL上下文并创建FBO。我们也为`m_fullScreenQuad`类做同样的事情。
- en: 'The `GenerateMaterials()` method can be implemented like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenerateMaterials()`方法可以像这样实现：'
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It iterates over each material type and creates a new texture for it, just like
    we did before. The only difference here is that we also store the handle of the
    newly created texture in `m_materialHandles`, in an effort to tie a specific `MaterialMapType`
    to an existing texture. We're still using SFML's render textures, because they
    did a fine job at managing 2D resources.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 它遍历每种材料类型并为它创建一个新的纹理，就像我们之前做的那样。这里唯一的区别是我们还把新创建的纹理句柄存储在 `m_materialHandles`
    中，试图将特定的 `MaterialMapType` 与现有的纹理关联起来。我们仍然使用 SFML 的渲染纹理，因为它们在管理 2D 资源方面做得很好。
- en: 'Binding all of the necessary textures to be sampled in the light pass shader
    would look like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在灯光遍历着色器中绑定所有必要的纹理如下所示：
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This particular method will be used inside the `RenderScene` method for rendering
    lights. It takes two arguments: a handler for the light pass shader, and the ID
    of the current pass taking place.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的方法将在 `RenderScene` 方法内部用于渲染灯光。它接受两个参数：灯光遍历着色器的句柄和当前遍历的 ID。
- en: The finished texture handle is then obtained from the `Renderer` class. Just
    like before, we must pass the right texture as the `"LastPass"` uniform in the
    light pass shader. If we're still on the very first pass, a diffuse texture is
    used instead.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的纹理句柄随后从 `Renderer` 类中获取。就像之前一样，我们必须在灯光遍历着色器中将正确的纹理作为 `"LastPass"` 常量传递。如果我们仍然处于第一次遍历，则使用漫反射纹理。
- en: Note
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Passing textures to a shader for sampling simply means we're sending one integer
    to the shader. That integer represents the texture unit we want to sample.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 将纹理传递给着色器进行采样简单来说就是向着色器发送一个整数。这个整数代表我们想要采样的纹理单元。
- en: The render window is then set to active once again to make sure the main OpenGL
    context is active. We then bind to the texture unit 0 and use it for the `"LastPass"`
    uniform. All of the other materials are taken care of inside a `for` loop that
    runs once for each material type. The texture unit `GL_TEXTURE1 + i` is activated,
    which ensures that we start from unit 1 and go up, since unit 0 is already being
    used. The appropriate texture is then bound to, and the uniform of the correct
    sampler for that material type is located. The uniform is then set to the texture
    unit we've just activated.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将渲染窗口再次设置为活动状态，以确保主 OpenGL 上下文是活动的。我们接着绑定到纹理单元 0 并使用它来设置 `"LastPass"` 常量。所有其他材料都在一个
    `for` 循环中处理，该循环为每种材料类型运行一次。激活纹理单元 `GL_TEXTURE1 + i`，这确保我们从单元 1 开始并向上，因为单元 0 已经在使用。然后绑定适当的纹理，并定位该材料类型的正确采样器常量。然后将常量设置为刚刚激活的纹理单元。
- en: 'Unbinding these textures is easier still:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 解绑这些纹理则更为简单：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that we're now iterating from 0 up and including the material type count.
    This ensures that even texture unit `0` is unbound, since we're activating `GL_TEXTURE0
    + i`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在从 0 开始迭代，包括材料类型计数。这确保了即使纹理单元 `0` 也会被解绑，因为我们正在激活 `GL_TEXTURE0 + i`。
- en: Re-working the light pass
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重新处理灯光遍历
- en: 'Finally, we''ll take a look at the `RenderScene()` method. For clarity, we''re
    going to break it down into smaller chunks, just like before:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将查看 `RenderScene()` 方法。为了清晰起见，我们将像之前一样将其分解成更小的部分：
- en: '[PRE52]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'First, let''s start at the top of the method and set up some variables that
    are going to be used throughout:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从方法顶部开始设置一些将在整个方法中使用的变量：
- en: '[PRE53]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `passes` variable works out how many passes we're going to need with the
    given number of lights. We then obtain a reference to the beginning of the light
    container, the light pass shader handle, the shadow pass shader handle, and the
    shader handle of the currently used shader that's set up inside the `Renderer`
    object, if there is one. Lastly, the `window` pointer is obtained for easy access.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`passes` 变量计算出我们需要多少次遍历才能处理给定的灯光数量。然后，我们获取到灯光容器开始位置的引用、灯光遍历着色器句柄、阴影遍历着色器句柄、以及
    `Renderer` 对象内部设置的当前使用的着色器句柄（如果有的话）。最后，获取 `window` 指针以便于访问。'
- en: 'Still inside the `RenderScene` method, we enter into a `for` loop that''s going
    to iterate for each pass:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在 `RenderScene` 方法内部，我们进入一个 `for` 循环，该循环将遍历每个遍历：
- en: '[PRE54]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Another reference to a light container iterator is obtained. This time, it points
    to the first light for this current pass. Also, a `LightCount` variable is set
    up to keep track of the number of lights rendered for the current pass so far.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 获取对灯光容器迭代器的另一个引用。这次，它指向当前遍历的第一个灯光。同时，设置一个 `LightCount` 变量来跟踪当前遍历到目前为止渲染的灯光数量。
- en: 'Before we go on to do any actual light rendering, we need to draw the shadow
    maps for the lights we''re going to be using in this pass:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行任何实际的光照渲染之前，我们需要为这次渲染过程中将要使用到的灯光绘制阴影贴图：
- en: '[PRE55]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, we iterate over each light that belongs to this pass. A check needs to
    be made to make sure we haven't reached the end of the container, however. Provided
    that's not the case, the main OpenGL context is enabled by calling `setActive(true)`,
    and the shadow map for the current light is drawn to the cubemap buffer texture.
    The `LightCount` is then incremented to let the rest of the code know how many
    lights we're dealing with during this pass.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遍历属于此通道的每个灯光。需要检查以确保我们没有到达容器的末尾。如果情况不是这样，通过调用`setActive(true)`启用主OpenGL上下文，并将当前灯光的阴影贴图绘制到立方体贴图缓冲区纹理上。然后增加`LightCount`，让其余的代码知道在这个通道中我们处理了多少灯光。
- en: 'After shadow maps have been rendered, it''s time to actually bind the light
    pass shader and begin passing information to it:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在阴影贴图渲染完成后，现在是时候绑定光照通道着色器并开始向其传递信息了：
- en: '[PRE56]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: After the light pass shader has been bound, we must also bind all of the 2D
    textures of necessary material maps. This is followed by submission of the ambient
    light uniform, along with the light count, and current pass uniforms.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在光照通道着色器绑定后，我们还必须绑定所有必要的材质贴图的2D纹理。这之后是提交环境光统一变量，包括灯光数量和当前通道统一变量。
- en: 'All of this is great, but we still haven''t addressed the main concept that
    caused a necessity for this massive redesign to begin with the cubemap textures:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都很好，但我们还没有解决最初导致这次大规模重新设计的主要概念，即立方体贴图纹理：
- en: '[PRE57]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The texture unit for binding the very first cubemap texture is defined by simply
    adding *1* to the count of material map types. We have four types at this moment,
    and with unit *0* dedicated to the `LastPass` texture, it means units 1-4 will
    be used for material map textures. This leaves units 5 and up free for other samplers.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定第一个立方体贴图纹理的纹理单元是通过简单地将材质贴图类型的数量加1来定义的。目前我们有四种类型，并且将单元*0*专门用于`LastPass`纹理，这意味着单元1-4将用于材质贴图纹理。这留下了单元5及以上用于其他采样器。
- en: Another `for` loop is entered, this time using the `LightCount` variable for
    maximum value. We've already determined how many lights we're dealing with during
    the shadow pass, so we don't need to make that check again here.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 进入另一个`for`循环，这次使用`LightCount`变量作为最大值。我们已经确定了在阴影通道中我们处理了多少灯光，因此在这里不需要再次进行那个检查。
- en: A reference to a light is fetched and passed into the `SubmitLightUniforms()`
    method, along with the light pass shader handle and the light number currently
    being used. The cubemap texture for that specific light is then bound for sampling.
    Note the use of `BaseCubeMapUnit + lightID`. This ensures that each light gets
    its own texture unit.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 获取一个灯光的引用并将其传递到`SubmitLightUniforms()`方法中，同时传递光照通道着色器句柄和当前正在使用的灯光编号。然后为该特定灯光绑定立方体贴图纹理进行采样。注意使用`BaseCubeMapUnit
    + lightID`。这确保了每个灯光都拥有自己的纹理单元。
- en: Inside the light pass shader, the shadow map samplers are going to be stored
    inside an array. Because of this, a string name for each element of the array
    is constructed based on the current light ID we're working with, and the uniform
    for the texture unit is sent to the shader.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在光照通道着色器内部，阴影贴图采样器将被存储在一个数组中。因此，基于当前我们正在处理的当前灯光ID，为数组的每个元素构造一个字符串名称，并将纹理单元的统一变量发送到着色器。
- en: 'Finally, because all of the uniforms and textures are properly bound and updated,
    we can actually invoke the light-pass shader by rendering `m_fullScreenQuad`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，因为所有统一变量和纹理都已正确绑定和更新，我们可以通过渲染`m_fullScreenQuad`来实际调用光照通道着色器：
- en: '[PRE58]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: First, the FBO is bound to the handle of the current texture being used as a
    buffer. The quad itself is then bound, rendered, and unbound again. This is all
    we need to redraw the entire finished buffer texture to the current buffer texture,
    so the FBO is unbound. The 2D textures are also unbound at this point, since the
    light pass shader has just commenced executing.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将FBO绑定到当前用作缓冲区的纹理的句柄上。然后绑定四边形，渲染，并再次解绑。这所有的一切都是为了将整个完成的缓冲区纹理重新绘制到当前缓冲区纹理上，因此FBO被解绑。在这个时候，2D纹理也被解绑，因为光照通道着色器刚刚开始执行。
- en: 'Speaking of unbinding, all of these cubemap textures need to be unbound as
    well:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 说到解绑，所有这些立方体贴图纹理也需要被解绑：
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'At this point, the very last thing left to do inside the lighting pass loop
    is to swap the buffer textures inside the `Renderer` class:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，在光照过程循环中最后要做的就是在 `Renderer` 类内部交换缓冲区纹理：
- en: '[PRE60]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This makes sure the most recent buffer is always stored as the finished texture.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了最新的缓冲区始终被存储为完成的纹理。
- en: 'Finally, once the light passes have, commenced, we must clean up the state
    of everything and actually render the finished buffer texture:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦光照过程开始，我们必须清理所有状态并实际渲染完成的缓冲区纹理：
- en: '[PRE61]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The shader program is first reset to whatever it was before the light pass was
    executed. The SFML window itself has its OpenGL states reset, because our use
    of OpenGL functions most likely altered them. Afterwards, we obtain the current
    window view, reset the window to its default view, draw the buffer texture, and
    swap the previous view back, just as in [Chapter 8](ch08.html "Chapter 8.  Let
    There Be Light - An Introduction to Advanced Lighting") , *Let There Be Light!
    - An Introduction to Advanced Lighting*.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器程序首先被重置为执行光照过程之前的状态。SFML 窗口本身的 OpenGL 状态也被重置，因为我们使用 OpenGL 函数很可能会改变它们。之后，我们获取当前窗口视图，将窗口重置为其默认视图，绘制缓冲区纹理，并交换回之前的视图，就像在[第
    8 章](ch08.html "第 8 章. 光之诞生 - 高级光照简介") *光之诞生！高级光照简介*中描述的那样。
- en: Submitting light uniforms to the shader
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将光照统一变量提交给着色器
- en: 'One more little piece of code we still haven''t covered is the actual light
    uniform submission to the light pass shader:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有介绍的一个小段代码是实际将光照统一变量提交给光照过程着色器：
- en: '[PRE62]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This chunk of code is pretty much exactly the same as in [Chapter 8](ch08.html
    "Chapter 8.  Let There Be Light - An Introduction to Advanced Lighting") , *Let
    There Be Light! - An Introduction to Advanced Lighting* *,* except it uses raw
    OpenGL functions to submit the uniforms.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与[第 8 章](ch08.html "第 8 章. 光之诞生 - 高级光照简介") *光之诞生！高级光照简介*中的代码几乎完全相同，只是它使用原始的
    OpenGL 函数提交统一变量。
- en: The new and improved light pass shaders
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的改进后的光照过程着色器
- en: 'Since the light pass had to be completely rewritten to use raw modern OpenGL,
    the shaders need to reflect those changes too. To begin with, the vertex shader
    is much simpler now, because it no longer uses outdated and deprecated ways of
    obtaining and transforming vertex information, texture coordinates, and so on:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 由于光照过程必须完全重写以使用原始的现代 OpenGL，着色器也需要反映这些变化。首先，顶点着色器现在要简单得多，因为它不再使用过时和已弃用的方法来获取和变换顶点信息、纹理坐标等：
- en: '[PRE63]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The position being passed to this shader is that of `m_fullScreenQuad`, so
    it''s already in clip space. There''s no reason to transform it. The texture coordinates
    are simply passed along to the fragment shader, where they get interpolated between
    vertices, ensuring sampling of every pixel:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给这个着色器的位置是 `m_fullScreenQuad` 的位置，因此它已经在裁剪空间中。没有必要对其进行变换。纹理坐标直接传递到片段着色器，在那里它们在顶点之间进行插值，确保对每个像素进行采样：
- en: '[PRE64]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The fragment shader of the light pass has a couple of new values at the very
    top. We have a constant that's going to be used to offset the light's height,
    which we're going to cover very shortly. There's also the input value from the
    vertex shader of the texture coordinates we're going to need to sample. Lastly,
    we're using an array of `samplerCube` uniforms to access the shadow map information.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 光照过程片段着色器顶部有几个新的值。我们有一个常数，它将被用来偏移光照的高度，我们将在稍后进行介绍。还有从顶点着色器输入的纹理坐标值，这是我们将要采样的。最后，我们使用
    `samplerCube` 统一变量的数组来访问阴影图信息。
- en: 'Let''s take a look at the main body of the light pass fragment shader:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看光照过程片段着色器的主要内容：
- en: '[PRE65]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Things have changed, yet oddly enough stayed the same. We're sampling all of
    the values from different textures just like before, only now we're using the
    `texCoords` variable passed down from the vertex shader.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有所变化，但奇怪的是，一切似乎都保持不变。我们像以前一样从不同的纹理中采样所有值，但现在我们使用从顶点着色器传递下来的 `texCoords` 变量。
- en: Another small change is the pass number that gets checked for ambient lighting.
    It used to be *1* for clarity in the previous chapter. It's now changed to *0*.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个小变化是检查环境光照的通行编号。在上一章中，为了清晰起见，它曾是 *1*。现在它已更改为 *0*。
- en: Finally, the very reason we're here today the shadow calculations. A floating
    point value is obtained from the `CalculateShadow` function, that takes in coordinates
    of the current fragment, the position of the current light, and the number identifier
    of the current light as well. This value is later used when calculating the final
    pixel color. The pixel is simply multiplied by `ShadowValue` at the end, which
    determines how much in the shadow it is.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们今天在这里的真正原因是进行阴影计算。从`CalculateShadow`函数中获取一个浮点值，该函数接受当前片段的坐标、当前光的位置以及当前光的编号。这个值随后在计算最终像素颜色时使用。最终像素简单地乘以`ShadowValue`，这决定了它处于阴影中的程度。
- en: 'This function is for calculating the shadow value of a fragment that is implemented
    at the top of the shader as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于计算片段的阴影值，在着色器顶部实现如下：
- en: '[PRE66]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Looks simple enough, right? Well, it is. First, the light's height is offset
    by the height offset constant we defined at the top of the shader. This is just
    a detail of further tweaking that ensures lighting looks as good as it can, and
    could be completely changed. The current value simply looks better than the default
    0.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单，对吧？确实如此。首先，光的高度通过我们在着色器顶部定义的高度偏移常量进行偏移。这只是进一步调整的细节，以确保光照看起来尽可能好，并且可以完全改变。当前的值看起来比默认的0要好。
- en: The difference between the fragment's position and the light's position is then
    calculated by subtracting one from the other. The order matters here because this
    is going to be used as a directional vector to determine which face of the cubemap
    texture should be sampled.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过从另一个中减去来计算片段位置与光位置之间的差值。这里的顺序很重要，因为这将用作方向向量，以确定应该从立方体贴图纹理的哪个面进行采样。
- en: Note
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that our fragment and light positions use the *Z* component as
    the height. This effectively makes *Y* the depth axis, which can be visualized
    as the direction to and from the screen, as opposed to left/right for *X*, and
    up/down for *Z*.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的片段和光的位置使用*Z*组件作为高度。这有效地使*Y*成为深度轴，可以将其可视化为由屏幕向外的方向，而不是*X*的左右方向，以及*Z*的上下方向。
- en: The `currentDepth` variable is the distance from the light to the fragment being
    sampled. The *Y* component of the difference vector is then inverted, because
    in the right-hand coordinate system OpenGL uses, pointing towards the screen means
    going into the negatives.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentDepth`变量是从光到被采样的片段的距离。然后，差分向量的*Y*分量被反转，因为在OpenGL使用的右手坐标系中，指向屏幕意味着进入负值。'
- en: Now it's time to actually sample the shadow map texture and obtain the nearest
    depth at that particular fragment. This is done by passing the difference vector
    as a directional vector. Don't worry about it not being normalized, because it
    doesn't have to be. Also note the *Z* and *Y* components swapped. Again, we use
    *Z* for height, while OpenGL uses *Y*. Finally, we check whether the depth between
    the fragment and the light is greater than the depth sampled from the current
    shadow map, and if it is, it means the fragment is in the shadow. 0 could be returned,
    but in order to create shadows that slowly fade out with distance, `nearestDepth`
    is returned instead. This is the value that the final pixel gets multiplied by,
    and because it's in the range *[0;1]*, we get the linear fade with distance.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实际采样阴影贴图纹理并获取特定片段的最近深度了。这是通过传递差分向量作为方向向量来完成的。不用担心它没有被归一化，因为它不需要。还要注意*Z*和*Y*组件的交换。再次，我们使用*Z*作为高度，而OpenGL使用*Y*。最后，我们检查片段与光之间的深度是否大于从当前阴影贴图采样的深度，如果是，则意味着片段处于阴影中。可以返回0，但为了创建随着距离逐渐变淡的阴影，我们返回`nearestDepth`。这是最终像素乘以的值，因为它在*[0;1]*范围内，所以我们得到与距离成线性关系的渐变。
- en: Note
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note `nearestDepth` being multiplied by the light radius, which represents the
    frustum far value, when it's being checked. This transforms it from the range
    *[0;1]*, to the actual distance at which the shadow primitive is away from the
    light.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在检查时将`nearestDepth`乘以光半径，这代表视锥体的远值。这将其从*[0;1]*范围转换为阴影原语实际距离光的真实距离。
- en: 'Consider the following diagram to help get the point across:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图表以帮助说明问题：
- en: '![The new and improved light pass shaders](img/image_09_010.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![新的改进型光照着色器](img/image_09_010.jpg)'
- en: Here, the main arrow from the sample point to the light is `currentDepth`, and
    the `nearestDepth` after being multiplied by the light's radius is the arrow from
    the black box in the middle to the light.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，从样本点到光源的主要箭头是`currentDepth`，而`nearestDepth`在乘以光源半径后，是从中间黑色盒子到光源的箭头。
- en: Adding shadow casters to entities
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将阴影投射组件添加到实体中
- en: Now that we have all of the rendering resolved, we still need to make sure entities
    can cast shadows. This will be achieved by actually attaching special components
    to entities that will hold pointers to 3D geometry used during shadow pass. This
    geometry will obviously need to be updated to match the position of the entities
    it represents, which is why the component data is going to be accompanied by a
    separate system, used to actually keep everything synced up.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了所有渲染问题，我们还需要确保实体可以投射阴影。这将通过实际上将特殊组件附加到实体来实现，这些组件将包含在阴影传递期间使用的3D几何形状的指针。显然，这些几何形状需要更新以匹配它们所代表的实体的位置，这就是为什么组件数据将伴随一个单独的系统，用于实际保持一切同步。
- en: Adding the shadow caster component
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加阴影投射组件
- en: 'First, because our entities exist within the ECS paradigm, we need to add a
    component that represents the shadow volume of an entity:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，因为我们的实体存在于ECS范式内，我们需要添加一个表示实体阴影体积的组件：
- en: '[PRE67]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This component will be used to load entity shadow caster primitives from the
    entity file, as well as update their respective `ShadowCaster` instances. The
    player entity file, for example, would look like this with the new component added:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件将用于从实体文件中加载实体阴影投射原始形状，以及更新相应的`ShadowCaster`实例。例如，玩家实体文件在添加新组件后可能看起来像这样：
- en: '[PRE68]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Creating the shadow system
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建阴影系统
- en: 'Updating these components should be done in a separate, designated system for
    this very purpose. Because we''ve done this so many times before, let''s just
    take a look at the relevant parts of the code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 更新这些组件应该在为该目的专门设计的独立系统中完成。因为我们之前已经这样做了很多次，让我们看看代码的相关部分：
- en: '[PRE69]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The constructor of this system simply sets up the entity requirements to belong
    here. It requires the position and shadow caster components, obviously.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 此系统的构造函数只是设置实体需求以属于这里。显然，它需要位置和阴影投射组件。
- en: 'Updating these components is equally as easy:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 更新这些组件同样简单：
- en: '[PRE70]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: For each entity that belongs to this system, the position and shadow caster
    components are obtained. The shadow caster's `UpdateCaster` method is then invoked,
    with the 2D position and height being passed in. The constant value of `8.f` is
    simply used to offset the shadow primitive in order to center it properly.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 对于属于此系统的每个实体，获取其位置和阴影投射组件。然后调用阴影投射的`UpdateCaster`方法，传入2D位置和高度。`8.f`的常量值仅用于偏移阴影原始形状，以便正确居中。
- en: Note
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the *Y* and *Z* values are, once again, swapped around.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*Y* 和 *Z* 值再次被交换。
- en: 'Finally, because we want to properly emplace and manage unique shadow caster
    prototypes in the light manager, the shadow system must implement a method that
    will be called when the entity has finished loading and is about to be added,
    in order to set everything up properly:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，因为我们希望在灯光管理器中正确地放置和管理唯一的阴影投射原型，阴影系统必须实现一个方法，该方法将在实体加载完成并即将添加时被调用，以便正确设置一切：
- en: '[PRE71]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Once the shadow caster component is retrieved, the entity type name is obtained
    from the entity manager. This is simply the name of the entity prototype, such
    as player, skeleton, and so on. The primitive prototype with the appropriate name
    is then attempted to be added, and should there be an exact same shadow caster
    prototype already in `LightManager`, that name is returned instead. The shadow
    caster itself is then created, passed on to the `C_ShadowCaster` component, and
    scaled to a decent size. For the time being, this is a constant value, but it
    can obviously be made to change depending on the entity type, if it's stored inside
    the entity file along with the rest of the component data.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取到阴影投射组件，就会从实体管理器中获取实体类型名称。这仅仅是实体原型的名称，例如玩家、骨骼等。然后尝试添加具有适当名称的原始原型，如果`LightManager`中已经存在一个完全相同的阴影投射原型，则返回该名称。随后创建阴影投射本身，传递给`C_ShadowCaster`组件，并调整到合适的大小。目前，这是一个常量值，但显然可以根据实体类型进行更改，如果它在实体文件中与组件数据一起存储的话。
- en: Integrating the changes made
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合所做的更改
- en: 'Finally, all we have left to do in order to make this work is add the newly
    created component and system types to the ECS:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为了使这个功能正常工作，只剩下将新创建的组件和系统类型添加到ECS中：
- en: '[PRE72]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The shadow system itself also needs a pointer to the light manager for obvious
    reasons. Running the game now, with all of the lights properly set up and shadow
    casters correctly loaded, we should have three-dimensional shadows!
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 由于显而易见的原因，阴影系统本身也需要指向灯光管理器的指针。现在运行游戏，所有灯光都正确设置，阴影投射器正确加载，我们应该有三个维度的阴影！
- en: '![Integrating the changes made](img/image_09_012.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![集成所做的更改](img/image_09_012.jpg)'
- en: Because the entities can hop elevations, the lights can be made to change their
    heights, and the actual light pass of the scene incorporates different heights
    of tile layers. Moving the lights around actually creates results in three-dimensional
    space, allowing the shadows to flow across walls, if at a right angle. After all
    of that hard work, the effect is absolutely astonishing!
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 因为实体可以跳跃高度，灯光可以被设置为改变其高度，场景的实际灯光过渡包含了不同高度的瓦片层。移动灯光实际上在三维空间中创造出结果，如果角度正确，阴影可以流动在墙上。经过所有这些艰苦的工作，效果绝对令人惊叹！
- en: Potential issues and how to address them
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可能的问题及其解决方法
- en: Although we aren't facing any of these issues at this very point, most 3D games
    will have to deal with them as soon as basic shadows are established using this
    method.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们现在并没有面临这些问题，但大多数3D游戏在使用这种方法建立基本阴影后，将不得不处理这些问题。
- en: '**Shadow acne** is a graphical artefact that can be summarized as horrible
    *tearing*, where lit areas are horribly defaced with dark and white lines closely
    nested together. This happens because shadow maps are of finite size and pixels
    that are right next to each other will end up spanning a small distance on actual,
    *real* geometry being shaded. It can be fixed by simply adding or subtracting
    a simple *bias* floating point value to or from the shadow map''s depth sample
    inside the light pass shader. This floating point value would, ideally, not be
    a constant and instead depend on the slope between the point on the geometry and
    the light.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**阴影痤疮**是一种可以概括为可怕的*撕裂*的图形瑕疵，其中被照亮的区域被黑暗和白色线条紧密地覆盖。这是因为阴影图是有限大小的，相邻的像素最终会在实际被阴影的几何体上跨越一小段距离。这可以通过在灯光过渡着色器中简单地向或从阴影图的深度样本中添加或减去一个简单的*偏差*浮点值来修复。这个浮点值理想情况下不应该是一个常数，而应该取决于几何体上的点和光源之间的坡度。'
- en: '**Peter panning** can be described as shadows that appear to be *floating*
    away from the geometry that casts them. Adding the floating point bias to fix
    shadow acne will usually make this problem worse, especially when dealing with
    incredibly thin geometry. A common and easy fix for this problem is simply avoiding
    thin geometry and using front face culling during the shadow pass, as we did.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**彼得·潘效应**可以被描述为看起来像*漂浮*离开投射它们的几何体的阴影。添加浮点偏差以修复阴影痤疮通常会使这个问题变得更糟，尤其是在处理极其薄的几何体时。这个问题的常见且简单的修复方法是简单地避免薄几何体，并在阴影过渡期间使用前向面剔除，就像我们做的那样。'
- en: Percentage closer filtering
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 百分比更近过滤
- en: You may have noticed that the shadows produced by our geometry are rather hard
    and don't exactly smooth out around the edges. As always, there is a solution
    that will resolve this, and it involves sampling the shadow map a couple more
    times per pixel.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们几何体产生的阴影相当硬，边缘并不完全平滑。就像往常一样，有一个解决方案可以解决这个问题，它涉及到每个像素对阴影图进行几次额外的采样。
- en: By sampling not only the calculated pixel of the shadow map, but also the surrounding
    ones, we can easily take an average value of all of them and use it to *smooth* out
    the edge. If, for example, our sampled pixel is in the shadow but *50%* of all
    other sampled pixels around it are lit up, the center pixel itself should only
    be *50%* opaque. By eliminating this binary rule of a pixel either being completely
    lit or completely dark, we can successfully implement soft shadows using this
    technique. Higher numbers of surrounding pixels will obviously yield smoother
    results, but will also bog down performance.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采样不仅计算出的阴影图像素，还包括周围的像素，我们可以轻松地取所有这些像素的平均值，并使用它来*平滑*边缘。例如，如果我们的采样像素在阴影中，但周围所有其他采样像素的*50%*都是照亮的，那么中心像素本身应该只有*50%*不透明。通过消除像素要么完全照亮要么完全黑暗的二进制规则，我们可以成功地使用这种技术实现软阴影。周围像素的数量越多，显然结果越平滑，但也会降低性能。
- en: Summary
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations on making it to the end of this chapter! Although it took quite
    a while to re-architect our lighting engine, the results cannot be dismissed as
    miniscule. The shadows created by this method add a lot of graphical diversity
    to our world. In the next chapter, we're going to be discussing optimizations
    that can be applied to make the game run as fast as it possibly can after all
    of the fancy, clock cycle sucking techniques used throughout this book. See you
    there!
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成了这一章节！虽然重新架构我们的照明引擎花费了相当长的时间，但结果不容小觑。这种方法产生的阴影为我们的世界增添了大量的图形多样性。在下一章中，我们将讨论可以应用以使游戏尽可能快速运行的优化方法，这是在本书中使用了所有花哨的、消耗时钟周期的技术之后。在那里见！
