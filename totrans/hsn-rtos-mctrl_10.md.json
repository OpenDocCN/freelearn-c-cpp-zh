["```cpp\nint main(void)\n{\n    HWInit();\n```", "```cpp\nvoid GreenTask(void *argument)\n{\n  SEGGER_SYSVIEW_PrintfHost(\"Task1 running \\\n                 while Green LED is on\\n\");\n  GreenLed.On();\n  vTaskDelay(1500/ portTICK_PERIOD_MS);\n  GreenLed.Off();\n\n  //a task can delete itself by passing NULL to vTaskDelete\n  vTaskDelete(NULL);\n\n  //task never get's here\n  GreenLed.On();\n}\n```", "```cpp\nvoid BlueTask( void* argument )\n{\n  while(1)\n  {\n    SEGGER_SYSVIEW_PrintfHost(\"BlueTaskRunning\\n\");\n    BlueLed.On();\n    vTaskDelay(200 / portTICK_PERIOD_MS);\n    BlueLed.Off();\n    vTaskDelay(200 / portTICK_PERIOD_MS);\n  }\n}\n```", "```cpp\nvoid RedTask( void* argument )\n{\n  uint8_t firstRun = 1;\n\n  while(1)\n  {\n    lookBusy();\n\n    SEGGER_SYSVIEW_PrintfHost(\"RedTaskRunning\\n\");\n    RedLed.On();\n    vTaskDelay(500/ portTICK_PERIOD_MS);\n    RedLed.Off();\n    vTaskDelay(500/ portTICK_PERIOD_MS);\n\n    if(firstRun == 1)\n    {\n      vTaskDelete(blueTaskHandle);\n      firstRun = 0;\n    }\n  }\n}\n```", "```cpp\nBaseType_t xTaskCreate( TaskFunction_t pvTaskCode,\n                        const char * const pcName,    \n                        configSTACK_DEPTH_TYPE  usStackDepth,\n                        void *pvParameters,\n                        UBaseType_t uxPriority,\n                        TaskHandle_t *pxCreatedTask);\n\n```", "```cpp\n\nretVal = xTaskCreate(Task1, \"task1\", StackSizeWords, NULL, tskIDLE_PRIORITY + 2, tskHandlePtr);\n```", "```cpp\nif( xTaskCreate(GreenTask, \"GreenTask\", STACK_SIZE, NULL, \n                tskIDLE_PRIORITY + 2, NULL) != pdPASS){ while(1) }\n```", "```cpp\nretVal = xTaskCreate(BlueTask, \"BlueTask\", STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, &blueTaskHandle);\nassert_param(retVal == pdPASS);\n```", "```cpp\nvoid assert_failed(uint8_t *file, uint32_t line)\n{ \n  SEGGER_SYSVIEW_PrintfHost(\"Assertion Failed:file %s \\\n                            on line %d\\r\\n\", file, line);\n  while(1);\n}\n```", "```cpp\n//starts the FreeRTOS scheduler - doesn't\n//return if successful\nvTaskStartScheduler();\n```", "```cpp\nint main(void)\n{\n HWInit();\n\n if (xTaskCreate(GreenTask, \"GreenTask\", \n STACK_SIZE, NULL,\n tskIDLE_PRIORITY + 2, NULL) != pdPASS)\n { while(1); }\n\n assert_param(xTaskCreate(BlueTask, \"BlueTask\", STACK_SIZE,NULL,\n tskIDLE_PRIORITY + 1, &blueTaskHandle) == pdPASS);\n\n  xTaskCreateStatic( RedTask, \"RedTask\", STACK_SIZE, NULL,\n                     tskIDLE_PRIORITY + 1,\n                     RedTaskStack, &RedTaskTCB);\n\n  //start the scheduler - shouldn't return unless there's a problem\n  vTaskStartScheduler();\n\n  while(1){}\n}\n```", "```cpp\nvoid GreenTask(void *argument)\n{\n  SEGGER_SYSVIEW_PrintfHost(\"Task1 running \\\n                             while Green LED is on\\n\");\n  GreenLed.On();\n  vTaskDelay(1500/ portTICK_PERIOD_MS);\n  GreenLed.Off();\n\n  //a task can delete itself by passing NULL to vTaskDelete\n  vTaskDelete(NULL);\n\n  //task never get's here\n  GreenLed.On();\n}\n```", "```cpp\nTaskHandle_t blueTaskHandle;\nint main(void)\n{\n    HWInit();\n    assert_param( xTaskCreate(BlueTask, \"BlueTask\", STACK_SIZE,\n                  NULL, tskIDLE_PRIORITY + 1, &blueTaskHandle) == \n                  pdPASS);\n    xTaskCreateStatic( RedTask, \"RedTask\", STACK_SIZE, NULL,\n                       tskIDLE_PRIORITY + 1, RedTaskStack,\n                       &RedTaskTCB);\n    vTaskStartScheduler();\n    while(1);\n}\n\nvoid RedTask( void* argument )\n{\n    vTaskDelete(blueTaskHandle);\n}\n```", "```cpp\nxTaskCreate(Task1, \"task1\", StackSizeWords, TaskHandlePtr, tskIDLE_PRIORITY + 2, NULL);\n```", "```cpp\nTaskHandle_t xTaskCreateStatic( TaskFunction_t pxTaskCode,\n                                 const char * const pcName,\n                                 const uint32_t ulStackDepth,\n                                 void * const pvParameters,\n                                 UBaseType_t uxPriority,\n                                 StackType_t * const puxStackBuffer,\n                                 StaticTask_t * const pxTaskBuffer );\n\n```", "```cpp\nstatic StackType_t RedTaskStack[STACK_SIZE];\nstatic StaticTask_t RedTaskTCB;\nxTaskCreateStatic( RedTask, \"RedTask\", STACK_SIZE, NULL,\n                   tskIDLE_PRIORITY + 1,\n                   RedTaskStack, &RedTaskTCB);\n```", "```cpp\nuint_fast8_t freshAdcReading = 0;\nwhile(!freshAdcReading)\n{\n    freshAdcReading = checkAdc();\n}\n```", "```cpp\nint main(void)\n{\n  HWInit();\n\n  if (xTaskCreate(GreenTask, \"GreenTask\", \n                  STACK_SIZE, NULL,\n                  tskIDLE_PRIORITY + 2, NULL) != pdPASS)\n      { while(1); }\n\n  //code won't progress past assert_failed (called by\n  //assert_param on failed assertions)\n  retval = (xTaskCreate(BlueTask, \"BlueTask\",\n               STACK_SIZE*100,NULL,\n               tskIDLE_PRIORITY + 1, &blueTaskHandle);\n  assert_param(retVal == pdPASS);\n```", "```cpp\nvoid assert_failed(uint8_t *file, uint32_t line)\n{ \n  SEGGER_SYSVIEW_PrintfHost(\"Assertion Failed:file %s \\\n                            on line %d\\r\\n\", file, line);\n  while(1);    \n}\n```", "```cpp\n#define configTOTAL_HEAP_SIZE ((size_t)15360)\n```", "```cpp\n//start the scheduler - shouldn't return unless there's a problem\nvTaskStartScheduler();\n\n//if you've wound up here, there is likely\n//an issue with overrunning the freeRTOS heap\nwhile(1)\n{\n}\n```"]