- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Learning More about Process Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解进程管理
- en: You became familiar with the concept of processes in the previous chapter. Now,
    it’s time to get into details. It is important to understand how process management
    is related to the system’s overall behavior. In this chapter, we will emphasize
    fundamental OS mechanisms that are used specifically for process control and resource
    access management. We will use this opportunity to show you how to use some C++
    features too.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你在上一章中已经熟悉了进程的概念。现在，是时候深入了解细节了。了解进程管理如何与系统的整体行为相关联是很重要的。在本章中，我们将强调用于进程控制和资源访问管理的基本操作系统机制。我们将利用这个机会向你展示如何使用一些
    C++ 功能。
- en: Once we’ve investigated the program and its corresponding process as system
    entities, we are going to discuss the states that one process goes through during
    its lifetime. You are going to learn about spawning new processes and threads.
    You are also going to see the underlying problems of such activities. Later we
    are going to check out some examples while slowly introducing the multithreaded
    code. By doing so, you will have the opportunity to learn the basics of some POSIX
    and C++ techniques that are related to asynchronous execution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们调查了程序及其相应的进程作为系统实体，我们将讨论一个进程在其生命周期中经历的状态。你将学习如何创建新的进程和线程。你还将看到这些活动背后的问题。稍后，我们将逐步引入多线程代码的示例。通过这样做，你将有机会学习一些与异步执行相关的
    POSIX 和 C++ 技术的基础。
- en: Regardless of your C++ experience, this chapter will help you to understand
    some of the traps that you could end up in at the system level. You can use your
    knowledge of various language features to enhance your execution control and process
    predictability.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的 C++ 经验如何，本章都将帮助你了解你可能在系统级别陷入的一些陷阱。你可以使用你对各种语言特性的了解来增强你的执行控制和进程可预测性。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Investigating the nature of the process
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查进程的本质
- en: Continuing with the process states and some scheduling mechanisms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续探讨进程状态和一些调度机制
- en: Learning more about process creation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解进程创建
- en: Introducing the system calls for thread manipulation in C++
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 C++ 中线程操作的系统调用
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To run the code examples in this chapter, you must prepare the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码示例，你必须准备以下内容：
- en: A Linux-based system capable of compiling and executing C++20 (for example,
    **Linux** **Mint 21**)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够编译和执行 C++20 的基于 Linux 的系统（例如，**Linux** **Mint 21**）
- en: The GCC12.2 compiler ([https://gcc.gnu.org/git/gcc.gitgcc-source](https://gcc.gnu.org/git/gcc.gitgcc-source))
    with the `-std=c++2a` and `-``lpthread` flags
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC12.2 编译器 ([https://gcc.gnu.org/git/gcc.gitgcc-source](https://gcc.gnu.org/git/gcc.gitgcc-source))，使用
    `-std=c++2a` 和 `-lpthread` 标志
- en: Alternatively, for all the examples, you can use [https://godbolt.org/](https://godbolt.org/)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，对于所有示例，你也可以使用 [https://godbolt.org/](https://godbolt.org/)
- en: 'All code examples in this chapter are available for download from: [https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%202](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%202).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中所有代码示例均可从以下链接下载：[https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%202](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%202)。
- en: Disassembling process creation
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆解进程创建
- en: As we mentioned in the previous chapter, a process is a running instance of
    a program that contains its respective metadata, occupied memory, opened files,
    and so on. It is the main job executor in the OS. Recall that the overall goal
    of programming is to transform one type of data into another type of data, or
    count. What we do via programming languages is provide instructions to the hardware.
    Often, we *tell* the CPU what to do, including moving pieces of data throughout
    different portions of memory. In other words, the computer must *compute*, and
    we must tell it how to do this. This understanding is crucial and independent
    of the programming languages or OSs that are used.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中提到的，进程是程序的运行实例，包含其相应的元数据、占用的内存、打开的文件等。它是操作系统中的主要作业执行者。回想一下，编程的整体目标是把一种类型的数据转换成另一种类型的数据，或者进行计数。我们通过编程语言所做的就是向硬件提供指令。通常，我们
    *告诉* CPU 要做什么，包括在不同内存部分移动数据片段。换句话说，计算机必须 *计算*，我们必须告诉它如何做。这种理解至关重要，并且与所使用的编程语言或操作系统无关。
- en: With this, we have come back to the topic of system programming and understanding
    system behavior. Let’s immediately state that process creation and execution is
    neither simple nor fast. And neither is the process switching. It is rarely observable
    through the naked eye, but if you must design a highly scalable system or have
    a strict timeline for events during the system’s execution, then you will get
    to process interaction analysis sooner or later. Again, this is how the computer
    works and this knowledge is useful when you get into resource optimization.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们回到了系统编程和了解系统行为的话题。让我们立即声明，进程创建和执行既不简单也不快。进程切换也是如此。这通常无法用肉眼观察到，但如果你必须设计一个高度可扩展的系统或对系统执行期间的事件有严格的截止日期，那么你迟早会进行进程交互分析。再次，这就是计算机的工作方式，当你进入资源优化时，这种知识是有用的。
- en: Speaking of resources, let’s remind ourselves of the fact that our process was
    initially just a program. It is usually stored on **non-volatile memory** (**NVM**).
    Depending on the system, this could be a hard drive, SSD, ROM, EEPROM, Flash,
    and so on. We have mentioned these devices as they have different physical characteristics,
    such as speed, storage space, write access, and fragmentation. Each of these is
    an important factor when it comes to the system’s durability, but for this chapter,
    we care mostly about speed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到资源，让我们再次提醒自己，我们的进程最初只是一个程序。它通常存储在**非易失性存储器**（**NVM**）中。根据系统不同，这可能是硬盘驱动器、SSD、ROM、EEPROM、Flash等等。我们提到这些设备是因为它们具有不同的物理特性，例如速度、存储空间、写入访问和碎片化。这些因素中的每一个都是系统耐用性的重要因素，但在这个章节中，我们主要关心的是速度。
- en: 'Again, as we already mentioned in the previous chapter, a program, just like
    all other OS resources, is a file. The C++ program is an executable object file,
    which contains the code – for example, the instructions – that must be given to
    the CPU. This file is the result of a compilation. The compiler is another program
    that converts the C++ code into machine instructions. It is crucial to be aware
    of what instructions our system supports. The OS and the compiler are prerequisites
    for the integrated standards, libraries, language features, and so on, and there
    is a good chance that the compiled object file is not going to run on another
    system that’s not exactly matching ours. Moreover, the same code, compiled on
    another system or through another compiler, would most probably have a different
    executable object file size. The bigger the size, the longer the time to load
    the program from **NVM** to the **main memory** (**Random Access Memory** (**RAM**)
    is used the most). To analyze the speed of our code and optimize it as best as
    possible for a given system, we will look at a generic diagram regarding the full
    path along which our data or an instruction goes along. This is slightly off-topic,
    so bear with us:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，正如我们在上一章中提到的，程序，就像所有其他操作系统资源一样，是一个文件。C++程序是一个可执行目标文件，其中包含必须提供给CPU的代码——例如，指令。这个文件是编译的结果。编译器是另一个程序，它将C++代码转换为机器指令。了解我们的系统支持哪些指令至关重要。操作系统和编译器是集成标准、库、语言特性等的先决条件，并且有很大可能性，编译后的目标文件无法在另一个与我们不完全匹配的系统上运行。此外，相同的代码，在另一个系统或通过另一个编译器编译，很可能会生成不同大小的可执行目标文件。文件越大，从**NVM**加载程序到**主存储器**（**随机存取存储器**（**RAM**）是最常用的）所需的时间就越长。为了分析我们代码的速度并尽可能地为给定系统优化它，我们将查看一个关于我们的数据或指令沿着完整路径流动的通用图。这稍微有些离题，所以请耐心等待：
- en: '![Figure 2.1 – Loading a program and its sequence of instruction execution
    events](img/Figure_02.1_B20833.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 加载程序及其指令执行序列](img/Figure_02.1_B20833.jpg)'
- en: Figure 2.1 – Loading a program and its sequence of instruction execution events
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 加载程序及其指令执行序列
- en: A generalized CPU overview has been provided here as different architectures
    will have different layouts. L1 and L2 caches are **Static RAM** (**SRAM**) elements,
    making them extremely fast, but expensive. Therefore, we must keep them small.
    We also keep them small to achieve small CPU latency. The L2 cache has a bigger
    capacity to make a shared space between the **Arithmetic Logic Units** (**ALUs**)
    – a frequent example is two hardware threads in a single core, where the L2 cache
    plays the shared memory role. The L3 cache doesn’t always exist, but it’s usually
    based on **Dynamic RAM** (**DRAM**) elements. It is slower than the L1 and the
    L2 caches but allows the CPU to have one more level of cache, just for speed-up
    purposes. One example would be instructing the CPU to guess and prefetch data
    from the RAM, thus sparing time in RAM-to-CPU loads. Modern C++ features can use
    this mechanism a lot, leading to significant speed-ups in process execution.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供了一个通用的CPU概述，因为不同的架构会有不同的布局。L1和L2缓存是**静态RAM**（**SRAM**）元素，这使得它们非常快，但也很昂贵。因此，我们必须保持它们体积小。我们还保持它们体积小以实现小的CPU延迟。L2缓存具有更大的容量，以便在**算术逻辑单元**（**ALUs**）之间创建共享空间——一个常见的例子是在单个核心中的两个硬件线程，其中L2缓存扮演共享内存的角色。L3缓存并不总是存在，但它通常基于**动态RAM**（**DRAM**）元素。它比L1和L2缓存慢，但允许CPU有一个额外的缓存级别，仅用于加速目的。一个例子就是指导CPU猜测并从RAM中预取数据，从而节省在RAM到CPU加载中的时间。现代C++特性可以大量使用这种机制，从而在进程执行中实现显著的加速。
- en: 'In addition, depending on their roles, three types of caches are recognized:
    the **instruction cache**, **data cache**, and **Translation Lookaside Buffer**
    (**TLB**). The first two are self-explanatory, whereas the **TLB** is not directly
    related to CPU caches – it is a separate unit. It’s used for addresses of both
    data and instructions, but its role is to speed up virtual-to-physical address
    translation, which we’ll discuss later in this chapter.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，根据它们的作用，识别出三种类型的缓存：**指令缓存**、**数据缓存**和**转换后备缓冲器**（**TLB**）。前两种是显而易见的，而**TLB**与CPU缓存没有直接关系——它是一个独立的单元。它用于数据和指令的地址，但其作用是加速虚拟到物理地址的转换，我们将在本章后面讨论这一点。
- en: RAM is often used, and mostly involves **Double Data Rate Synchronous Dynamic
    RAM** (**DDR SDRAM**) memory circuits. This is a very important point because
    different DDR bus configurations have different speeds. And no matter the speed,
    it is still not as fast as CPU internal transfers. Even with a 100%-loaded CPU,
    the DDR is rarely fully utilized, thus becoming our *first significant bottleneck*.
    As mentioned in [*Chapter 1*](B20833_01.xhtml#_idTextAnchor014), NVM is way slower
    than DDR, which is its *second significant bottleneck*. We encourage you to analyze
    your system and see the speed differences.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: RAM经常被使用，主要涉及**双数据速率同步动态RAM**（**DDR SDRAM**）内存电路。这是一个非常重要的点，因为不同的DDR总线配置有不同的速度。而且不管速度如何，它仍然不如CPU内部传输快。即使CPU满载，DDR也很少被完全利用，因此成为我们的*第一个重大瓶颈*。正如在[*第一章*](B20833_01.xhtml#_idTextAnchor014)中提到的，NVM比DDR慢得多，这是它的*第二个重大瓶颈*。我们鼓励您分析您的系统并查看速度差异。
- en: Important note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your programs’ sizes matter. The process of optimizing the sequence of events
    for executing program instructions or loading data is a permanent and continuous
    balancing act. You must be aware of your system’s hardware and OS before thinking
    of code optimization!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您的程序大小很重要。优化执行程序指令或加载数据的事件序列的过程是一个永久和持续的平衡行为。在考虑代码优化之前，您必须了解您的系统硬件和操作系统！
- en: 'If you’re still not convinced, then think about the following: if we have a
    program to visualize some data on some screen, it might not be an issue for a
    desktop PC user if it’s there after 1 second or 10 seconds. But if this is a pilot
    on an airplane, then showing data within a strict time window is a safety compliance
    feature. And the size of our program matters. We believe the next few sections
    will give you the tools you’ll need to analyze your environment. So, what happens
    with our program during execution? Let’s find out.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍然不确信，那么考虑以下情况：如果我们有一个程序用于在某个屏幕上可视化一些数据，对于桌面PC用户来说，如果1秒后或10秒后出现，可能不是问题。但如果这是一个飞机上的飞行员，那么在严格的时间窗口内显示数据是一个安全合规特性。我们程序的大小也很重要。我们相信接下来的几节将为您提供分析您环境所需的工具。那么，我们的程序在执行过程中会发生什么？让我们来看看。
- en: Memory segments
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存段
- en: '*Memory segments* are also known as *memory layouts* or *memory sections*.
    These are just areas of memory and should not be mistaken for segmented memory
    architecture. Some experts prefer to use *sections* when the compile-time operations
    are discussed and *layout* for the runtime. Choose whatever you like, so long
    as it describes the same thing. The main segments are **text** (or **code**),
    **data**, **BSS**, **stack**, and **heap**, where **BSS** stands for **Block Started
    by Symbol** or **Block Starting Symbol**. Let’s take a closer look:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*内存段*也被称为*内存布局*或*内存部分*。这些只是内存区域，不应与分段内存架构混淆。一些专家在讨论编译时操作时更喜欢使用*部分*，而在运行时使用*布局*。选择你喜欢的，只要它能描述同一件事。主要段包括**文本**（或**代码**）、**数据**、**BSS**、**栈**和**堆**，其中**BSS**代表**由符号开始的块**或**由符号开始的块**。让我们更详细地看看：'
- en: '`const` variables there as well.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也有`const`变量。
- en: '**Data**: This segment is created at compile time as well and consists of initialized
    global, static, or both global and static data. It is used for preliminary allocated
    storage, whenever you don’t want to depend on runtime allocation.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据**：这个段也是在编译时创建的，由初始化的全局、静态或全局和静态数据组成。它用于初步分配的存储，当你不希望依赖于运行时分配时使用。'
- en: '`0`, theoretically as per the language standard, but it is practically set
    to `0` by the OS’s program loader during process startup.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`，理论上按照语言标准，但实际上在进程启动时由操作系统的程序加载器设置为`0`。'
- en: '**Stack**: The program stack is a memory segment that represents the running
    program routines – it holds their local variables and tracks where to continue
    from when a called function returns. It is constructed at runtime and follows
    the **Last-in, First-Out** (**LIFO**) policy. We want to keep it small and fast.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**栈**：程序栈是一个表示运行程序例程的内存段——它保存它们的局部变量，并在被调用的函数返回时跟踪继续的位置。它是在运行时构建的，并遵循**后进先出**（**LIFO**）策略。我们希望保持它小而快。'
- en: '**Heap**: This is another runtime-created segment that is used for dynamic
    memory allocation. For many embedded systems, it is considered forbidden, but
    we are going to explore it further later in this book. There are interesting lessons
    to be learned and it is not always possible to avoid it.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆**：这是另一个在运行时创建的段，用于动态内存分配。对于许多嵌入式系统来说，它被认为是禁止的，但我们将在此书稍后进一步探讨它。有许多有趣的教训可以学习，而且有时很难避免它。'
- en: 'In *Figure 2**.1*, you can observe two processes that are running the same
    executable and are being loaded to the main memory at runtime. We can see that
    for Linux, the **text** segment is copied only once since it should be the same
    for both processes. The **heap** is missing as we are not focusing on it right
    now. As you can see, the **stack** is not endless. Of course, its size depends
    on many factors, but we guess that you’ve already seen the *stack overflow* message
    a few times in practice. It is an unpleasant runtime event as the program flow
    is ungracefully ruined and there’s the chance of it causing an issue at the system
    level:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图2.1*中，你可以观察到两个正在运行相同可执行文件并正在运行时加载到主内存中的进程。我们可以看到，对于Linux，**文本**段只复制一次，因为它应该对两个进程都是相同的。**堆**缺失，因为我们现在不关注它。正如你所见，**栈**不是无限的。当然，其大小取决于许多因素，但我们猜测你已经在实践中看到过几次*栈溢出*消息。这是一个不愉快的运行时事件，因为程序流程被不优雅地破坏，并且有可能在系统级别引起问题：
- en: '![Figure 2.2 – The memory segments of two processes](img/Figure_02.2_B20833.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 两个进程的内存段](img/Figure_02.2_B20833.jpg)'
- en: Figure 2.2 – The memory segments of two processes
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 两个进程的内存段
- en: The main memory at the top in *Figure 2**.2* represents the **virtual address
    space**, where the OS uses a data structure, called a **page table**, to map the
    process’s memory layout to the physical memory addresses. It is an important technique
    to generalize the way the OS manages memory resources. That way, we don’t have
    to think about the device’s specific characteristics or interfaces. At an abstract
    level, it is quite like the way we accessed files in [*Chapter 1*](B20833_01.xhtml#_idTextAnchor014).
    We will get back to this discussion later in this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图2.2*中，主内存的顶部代表**虚拟地址空间**，其中操作系统使用一个称为**页表**的数据结构来将进程的内存布局映射到物理内存地址。这是一种重要的技术，可以概括操作系统管理内存资源的方式。这样，我们就不必考虑设备的特定特性或接口。在抽象层面上，它很像我们在[*第一章*](B20833_01.xhtml#_idTextAnchor014)中访问文件的方式。我们将在本章稍后回到这个讨论。
- en: 'Let’s use the following code sample for analysis:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下代码示例进行分析：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is a very simple program, where a function is called right after the entry
    point. There’s nothing special here. Let’s compile it for C++20 without any optimizations:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的程序，其中函数在入口点之后立即被调用。这里没有什么特别之处。让我们为 C++20 编译它，不进行任何优化：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The resulting binary object is called `test`. Let’s analyze it through the
    `size` command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的二进制对象称为 `test`。让我们通过 `size` 命令分析它：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The overall size is 2,688 bytes, 2,040 of which are the instructions, 640 are
    the **data**, and 8 are for **BSS**. As you can see, we don’t have any global
    or static data, but still, 648 bytes have gone there. Keep in mind that the compiler
    is still doing its job, so there are some allocated symbols there, which we could
    analyze further when required:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 总大小为 2,688 字节，其中 2,040 字节是指令，640 字节是 **数据**，8 字节用于 **BSS**。正如你所见，我们没有全局或静态数据，但仍然有
    648 字节被占用。记住，编译器仍在工作，所以那里有一些分配的符号，当需要时我们可以进一步分析：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let’s focus on something else and edit the code as such:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于其他事情并按照以下方式编辑代码：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A static variable that’s not initialized must cause **BSS** to grow:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个未初始化的静态变量必须导致 **BSS** 增长：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So, **BSS** is bigger – not by 4 bytes, but with 8\. Let’s double-check the
    size of our new variable:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**BSS** 变得更大——不是 4 字节，而是 8 字节。让我们检查一下新变量的大小：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Everything is fine – the unsigned 32-bit integer is for 4 bytes, as expected,
    but the compiler has put some extra symbols there. We can also see that it is
    in the `b` in front of the symbol. Now, let’s change the code again:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一切正常——无符号 32 位整数是 4 字节，正如预期的那样，但编译器在那里放了一些额外的符号。我们还可以看到它在符号前面的 `b`。现在，让我们再次更改代码：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have initialized the variable. Now, we expect it to be in the **data** segment:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经初始化了变量。现在，我们期望它在 **数据** 段中：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As expected, the `d` in front of the symbol). You can also see that the compiler
    has shrunk `2688` bytes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，符号前面的 `d`）。你还可以看到编译器已经将 `2688` 字节缩小了。
- en: 'Let’s make a final change:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行最后的更改：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since `const` cannot be changed during the program’s execution, it has to be
    marked as read-only. For this, it could be put into the **text** segment. Note
    that this is system implementation-dependent. Let’s check it out:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `const` 在程序执行期间不能更改，它必须被标记为只读。为此，它可以放入 **文本** 段。请注意，这取决于系统实现。让我们检查一下：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Correct! We can see the letter `r` in front of the symbol and that the `2044`
    and not `2040`, as it was previously. It seems rather funny that the compiler
    has generated an 8-byte `static` from the definition? We encourage you to try
    this out.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正确！我们可以看到符号前面的字母 `r`，以及 `2044` 而不是之前提到的 `2040`。编译器从定义中生成一个 8 字节的 `static` 看起来相当有趣？我们鼓励你尝试一下。
- en: At this point, you’ve probably made the connection that the bigger compile-time
    sections generally mean a bigger executable. And a bigger executable means more
    time for the program to be started because copying the data from NVM to the main
    memory is significantly slower than copying data from the main memory to the CPU’s
    caches. We will get back to this discussion later when we discuss context switching.
    If we want to keep our startup fast, then we should consider smaller compile-time
    sections, but larger runtime ones. This is a balancing act that is usually done
    by the software architects, or someone who has a good system overview and knowledge.
    Prerequisites such as NVM read/write speed, DDR configuration, CPU and RAM loads
    during system startup, normal work and shutdown, the number of active processes,
    and so on must be considered.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经建立了联系，即编译时较大的部分通常意味着可执行文件更大。而可执行文件更大意味着程序启动所需的时间更长，因为从 NVM 到主内存的数据复制速度明显慢于从主内存到
    CPU 缓存的复制速度。我们将在讨论上下文切换时回到这个话题。如果我们想保持启动速度快，那么我们应该考虑较小的编译时部分，但较大的运行时部分。这是一个通常由软件架构师或对系统有良好概述和知识的人进行的权衡。必须考虑的先决条件包括
    NVM 的读写速度、DDR 配置、系统启动、正常工作和关闭时的 CPU 和 RAM 负载、活动进程数量等。
- en: We will revisit this topic later in this book. For now, let’s focus on the meaning
    of the memory segments in the sense of new process creation. Their meaning will
    be discussed later in this chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面重新讨论这个话题。现在，让我们专注于新进程创建时内存段的意义。它们的意义将在本章后面讨论。
- en: Continuing with process states and some scheduling mechanisms
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续讨论进程状态和一些调度机制
- en: In the previous section, we discussed to how initiate a new process. But what
    happens with it under the hood? As mentioned in [*Chapter 1*](B20833_01.xhtml#_idTextAnchor014),
    processes and threads are considered tasks in Linux’s scheduler. Their states
    are generic, and their understanding is important for correct procedure planning.
    A task, when expecting a resource, might have to wait or even stopped. We can
    affect this behavior through synchronization mechanisms as well, such as semaphores
    and mutexes, which we’ll discuss later in this chapter. We believe that understanding
    these fundamentals is crucial for system programmers as bad task state management
    can lead to unpredictability and overall system degradation. This is strongly
    observable in large-scale systems.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了如何启动一个新的进程。但在底层发生了什么？如[第1章](B20833_01.xhtml#_idTextAnchor014)中所述，在Linux的调度器中，进程和线程被视为任务。它们的状态是通用的，对它们的理解对于正确的程序规划非常重要。当任务期望一个资源时，可能需要等待甚至停止。我们也可以通过同步机制来影响这种行为，例如信号量和互斥锁，我们将在本章后面讨论。我们相信，理解这些基础知识对于系统程序员来说至关重要，因为不良的任务状态管理可能导致不可预测性和整体系统退化。这在大型系统中表现得尤为明显。
- en: 'For now, let’s step aside for a bit and try to simplify the code’s goals –
    it needs to instruct the CPU to perform an operation and modify the data. Our
    task is to think about what the correct instructions would be so that we can save
    time in rescheduling or doing nothing by blocking resources. Let’s look at the
    states our process could find itself in:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们暂时放慢脚步，尝试简化代码的目标——它需要指导CPU执行操作并修改数据。我们的任务是思考正确的指令应该是什么，这样我们就可以在重新调度或通过阻塞资源什么都不做时节省时间。让我们看看我们的进程可能处于的状态：
- en: '![Figure 2.3 – Linux task states and their dependencies](img/Figure_02.3_B20833.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – Linux任务状态及其依赖关系](img/Figure_02.3_B20833.jpg)'
- en: Figure 2.3 – Linux task states and their dependencies
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – Linux任务状态及其依赖关系
- en: 'The states in the preceding figure are detailed, but Linux presents them to
    the user in four general letter denotations:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图中的状态是详细的，但Linux以四个一般字母表示法向用户展示它们：
- en: '**Executing (R – Running and Runnable)**: A processor (core or thread) is provided
    for the instructions of the process – the task is running. The scheduling algorithm
    might force it to give the execution. Then, the task becomes runnable, and it’s
    added to a queue of *runnables*, waiting their turn. Both states are distinct
    but are denoted as *processes* *in execution*.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行（R – 运行和可运行）**：处理器（核心或线程）为进程的指令提供服务——任务正在运行。调度算法可能迫使它执行。然后，任务变为可运行状态，并被添加到可运行队列中，等待轮到它们。这两种状态都是不同的，但都被表示为“正在执行”的进程。'
- en: '**Sleeping (D – Uninterruptible and S – Interruptible)**: Remember the example
    with file read/write from the previous chapter? That was a form of uninterruptable
    sleeping that was caused by waiting for external resources. Sleep cannot be interrupted
    through signals until the resource is available and the process is available for
    execution again. Interruptible sleep is not only dependent on resource availability
    but allows the process to be controlled by signals.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**睡眠（D – 不可中断和 S – 可中断）**：还记得上一章中关于文件读写操作的例子吗？那是一种由等待外部资源引起的不可中断睡眠形式。在资源可用且进程可以再次执行之前，睡眠状态不能通过信号中断。可中断睡眠不仅依赖于资源可用性，还允许进程通过信号进行控制。'
- en: '**Stopped (T)**: Have you ever used *Ctrl* + *Z* to stop a process? That’s
    the signal putting the process in a stopped state, but depending on the signal
    request, it could be ignored, and the process will continue. Alternatively, the
    process could be stopped until it is signaled to continue again. We will discuss
    signals later in this book.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止（T）**：你有没有使用 *Ctrl* + *Z* 来停止一个进程？这是将进程置于停止状态的信号，但根据信号请求，它可能被忽略，进程将继续。或者，进程可以被停止，直到它被信号通知继续。我们将在本书后面讨论信号。'
- en: '**Zombie (Z)**: We saw this state in [*Chapter 1*](B20833_01.xhtml#_idTextAnchor014)
    – the process is terminated, but it is still visible in the OS’s task vector.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**僵尸（Z）**：我们在[第1章](B20833_01.xhtml#_idTextAnchor014)中看到了这种状态——进程已终止，但在操作系统的任务向量中仍然可见。'
- en: 'Using the `top` command, you will see the letter `S` on the top row of the
    process information columns:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `top` 命令，你将在进程信息列的顶部行看到字母 `S`：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It will show you the letter denotation for the state of each process. Another
    option is the `ps` command, where the `STAT` column will give you the current
    states:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它将显示每个进程状态的字母表示。另一个选项是`ps`命令，其中`STAT`列将给出当前状态：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With that, we know what states the tasks end up in, but not how and why they
    switch between them. We’ll continue this discussion in the next section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们知道了任务最终处于哪些状态，但不知道它们是如何以及为什么在这些状态之间切换的。我们将在下一节继续这个讨论。
- en: Scheduling mechanisms
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调度机制
- en: Modern Linux distributions provide many scheduling mechanisms. Their sole purpose
    is to help the OS decide which task must be executed next in an optimized fashion.
    Should it be the one with the highest priority or the one that will finish fastest,
    or just a mix of both? There are other criteria as well, so don’t fall under the
    false apprehension that one will solve all your problems. Scheduling algorithms
    are especially important when there are more processes in the **R** state than
    the available processors on the system. To manage this task, the OS has a **scheduler**
    – a fundamental module that every OS implements in some form. It is usually a
    separate kernel process that acts like a load balancer, which means it keeps the
    computer resources busy and provides service to multiple users. It can be configured
    to aim at small latency, fair execution, max throughput, or minimal wait time.
    In real-time OSs, it must guarantee that deadlines are met. These factors are
    obviously in conflict, and the scheduler must resolve these through a suitable
    compromise. System programmers can configure the system’s preferences based on
    the users’ needs. But how does this happen?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Linux发行版提供了许多调度机制。它们唯一的目的就是帮助操作系统以优化的方式决定下一个必须执行的任务。是优先级最高的任务，还是完成最快的任务，或者两者兼而有之？还有其他标准，所以不要陷入一个错误的假设，认为一个可以解决你所有的问题。当系统中**R**状态下的进程数量多于可用处理器时，调度算法尤为重要。为了管理这项任务，操作系统有一个**调度器**——每个操作系统都以某种形式实现的根本模块。它通常是一个独立的内核进程，充当负载均衡器，这意味着它使计算机资源保持忙碌，并为多个用户提供服务。它可以配置为追求低延迟、公平执行、最大吞吐量或最短等待时间。在实时操作系统中，它必须保证满足截止日期。这些因素显然是相互冲突的，调度器必须通过适当的折衷来解决这个问题。系统程序员可以根据用户的需求配置系统的偏好。但这是如何发生的呢？
- en: Scheduling at a high level
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级调度
- en: We request the OS to start a program. First, we must load it from NVM. This
    scheduling level considers the execution of the **program loader**. The destination
    of the program is provided to it by the OS. The **text** and **data** segments
    are loaded into the main memory. Most modern OSs will load the program *on demand*.
    This enables a faster process startup and means that only the currently required
    code is provided at a given moment. The **BSS** data is allocated and initialized
    there as well. Then, the virtual address space is mapped. The new process, which
    carries the instructions, is created and the required fields, such as process
    ID, user ID, group ID, and others, are initialized. The **program counter** is
    set to the entry point of the program and control is passed to the loaded code.
    This overhead is considerably significant in the process’s lifetime because of
    the hardware constraints of **NVM**. Let’s see what happens after the program
    reaches the RAM.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们请求操作系统启动一个程序。首先，我们必须从NVM中加载它。这个调度级别考虑的是**程序加载器**的执行。程序的地址由操作系统提供。**文本**和**数据**段被加载到主内存中。大多数现代操作系统都会**按需**加载程序。这使进程启动更快，并且意味着在给定时刻只提供所需的代码。**BSS**数据也在那里分配和初始化。然后，虚拟地址空间被映射。携带指令的新进程被创建，并初始化所需的字段，如进程ID、用户ID、组ID等。**程序计数器**被设置为程序的入口点，控制权传递给加载的代码。由于NVM的硬件限制，这种开销在进程的生命周期中相当重要。让我们看看程序达到RAM后会发生什么。
- en: Scheduling at a low level
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 低级调度
- en: This is a collection of techniques that try to provide the best order of task
    execution. Although we don’t mention the term **scheduling** much in this book,
    be sure that every manipulation we do causes tasks to state switch, which means
    we cause the scheduler to act. Such an action is known as a **context switch**.
    The switch takes time too as the scheduling algorithm may need to reorder the
    queue of tasks, and newly started task instructions must be copied from the RAM
    to the CPU cache.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一系列尝试提供最佳任务执行顺序的技术。尽管我们在这本书中很少提到“调度”这个词，但请确保我们做的每一个操作都会导致任务状态切换，这意味着我们促使调度器行动。这种动作被称为**上下文切换**。切换也需要时间，因为调度算法可能需要重新排序任务队列，并且新启动的任务指令必须从RAM复制到CPU缓存。
- en: Important note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Multiple running tasks, parallel or not, could lead to time spent in rescheduling
    instead of procedure executions. This is another balancing act that depends on
    the system programmer’s design.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 多个运行的任务，无论是并行还是非并行，可能会导致在重新调度上花费时间而不是在程序执行上。这是另一种平衡行为，这取决于系统程序员的 设计。
- en: 'Here is a basic overview:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个基本的概述：
- en: '![Figure 2.4 – Ready /blocked task queues](img/Figure_02.4_B20833.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 准备/阻塞任务队列](img/Figure_02.4_B20833.jpg)'
- en: Figure 2.4 – Ready /blocked task queues
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 准备/阻塞任务队列
- en: The algorithm must pick a task from the queue and place it for execution. At
    a system level, the basic hierarchy is as (from highest priority to lowest) scheduler
    -> block devices -> file management -> character devices -> user processes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 算法必须从队列中选择一个任务并将其放置以执行。在系统级别，基本层次结构如下（从最高优先级到最低）：调度器 -> 块设备 -> 文件管理 -> 字符设备
    -> 用户进程。
- en: 'Depending on the queue’s data structure implementation and the **scheduler’s**
    configuration, we could execute different algorithms. Here are some of them:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 根据队列的数据结构实现和**调度器**的配置，我们可以执行不同的算法。以下是一些例子：
- en: '**First-come-first-serve** (**FCFS**): Nowadays, this is rarely used because
    longer tasks might stall the system’s performance and important processes might
    never be executed.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**先来先服务（First-come-first-serve，FCFS）**：如今，这种方法很少使用，因为较长的任务可能会阻碍系统的性能，而重要的进程可能永远不会被执行。'
- en: '**Shortest job first** (**SJF**): This provides a shorter time to wait than
    FCFS, but longer tasks may never be called. It lacks predictability.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最短作业优先（Shortest job first，SJF）**：这比FCFS提供了更短的等待时间，但较长的任务可能永远不会被调用。它缺乏可预测性。'
- en: '**Highest priority first** (**HPF**): Here, tasks have priority, where the
    highest one will be executed. But who sets the priority value and who decides
    if an incoming process will cause rescheduling or not? The Kleinrock rules are
    one such discipline where priority is increased linearly, while the task stays
    in the queue. Depending on the run-stay ratio, different orders are executed –
    FCFS, Last-CFS, SJF, and so on. An interesting article on this matter can be found
    here: [https://dl.acm.org/doi/10.1145/322261.322266](https://dl.acm.org/doi/10.1145/322261.322266).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最高优先级先执行（Highest priority first，HPF）**：在这里，任务有优先级，最高优先级的任务将被执行。但谁设置优先级值，谁决定新到达的进程是否会导致重新调度？Kleinrock规则就是这样一种纪律，其中优先级线性增加，而任务保持在队列中。根据运行-保持比率，不同的顺序被执行——FCFS、Last-CFS、SJF等等。关于这个问题的有趣文章可以在这里找到：[https://dl.acm.org/doi/10.1145/322261.322266](https://dl.acm.org/doi/10.1145/322261.322266)。'
- en: '**Round-robin**: This is a resource starvation-free and preemptive algorithm,
    where each task gets a time quantum in an equal portion. Tasks are executed in
    circular order. Each of them gets a CPU time slot, equal to the time quantum.
    When it expires, the task is pushed to the back of the queue. As you have probably
    deduced, the queue’s length and the quantum’s value (usually between 10 and 300ms)
    are of great significance. An additional technique to maintain fairness is to
    enrich this algorithm in modern OS schedulers.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮询（Round-robin）**：这是一个无资源饥饿和抢占式算法，每个任务在相等的时间量子中获得。任务按环形顺序执行。每个任务都获得一个CPU时间槽，等于时间量子。当时间量子到期时，任务被推回到队列的末尾。正如你可能推断的那样，队列的长度和时间量子（通常在10到300毫秒之间）非常重要。为了保持公平性，现代操作系统调度器中还会采用一些额外的技术来丰富这个算法。'
- en: '**Completely fair scheduling** (**CFS**): This is the current Linux scheduling
    mechanism. It applies a combination of the aforementioned algorithms, depending
    on the system’s state:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全公平调度（Completely fair scheduling，CFS）**：这是当前的Linux调度机制。它根据系统的状态应用上述算法的组合：'
- en: '[PRE13]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This approach is complex and deserves a book on its own.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法很复杂，值得单独一本书来讨论。
- en: 'What we care about here is the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关心的是以下内容：
- en: '**Priority**: Its value is the actual task priority, and it’s used for scheduling.
    Values between 0 and 99 are dedicated to real-time processes, whereas values between
    100 and 139 are for user processes.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级**：其值是实际任务优先级，用于调度。介于 0 到 99 之间的值专用于实时进程，而介于 100 到 139 之间的值用于用户进程。'
- en: '**Nice**: Its value is meaningful at the user-space level and adjusts the process’s
    priority at runtime. The root user can set it from -20 to +19 and a simple user
    could set it from 0 to +19, where a higher **nice** value means lower priority.
    The default is 0.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nice**：其值在用户空间级别上有意义，并在运行时调整进程的优先级。root 用户可以从 -20 到 +19 设置它，而普通用户可以从 0 到
    +19 设置它，其中较高的 **nice** 值意味着较低的优先级。默认值为 0。'
- en: 'Their dependency is that priority = nice + 20 for user processes and priority
    = -1 – real_time_priority for real-time processes. The higher the priority value,
    the lower the scheduling priority. We cannot change the base priority of a process,
    but we can start it with a different `ps` with a new priority:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的依赖关系是，对于用户进程，优先级 = nice + 20，对于实时进程，优先级 = -1 – real_time_priority。优先级值越高，调度优先级越低。我们无法更改进程的基本优先级，但我们可以以不同的
    `ps` 和新的优先级启动它：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, `-5` means `5`. Making it `5` requires **sudo** permissions:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`-5` 表示 `5`。将其改为 `5` 需要使用 **sudo** 权限：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Changing the priority of a process runtime can be done with the `renice` command
    and `pid`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `renice` 命令和 `pid` 可以在进程运行时更改进程的优先级：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will set the `nice` value to `-10`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置 `nice` 值为 `-10`。
- en: 'To start a real-time process or set and retrieve the real-time attributes of
    `pid`, you must use the `chrt` command. For example, let’s use it to start a real-time
    process with a priority of `99`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动实时进程或设置和检索 `pid` 的实时属性，您必须使用 `chrt` 命令。例如，让我们用它来启动一个优先级为 `99` 的实时进程：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We encourage you to take a look at other algorithms, such as **Feedback**, **Adaptive
    Partition Scheduling** (**APS**), **Shortest Remaining Time** (**SRT**), and **Highest
    Response Ratio** **Next** (**HRRN**).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您查看其他算法，例如 **反馈**、**自适应分区调度**（**APS**）、**最短剩余时间**（**SRT**）、**最高响应比** **下一个**（**HRRN**）。
- en: The topic of scheduling algorithms is wide and not only concerns the OS task’s
    execution but other areas, such as network data management. We cannot go through
    its entirety here, but it was important to illustrate how to initially handle
    it and learn about your system’s strengths. That said, let’s continue by looking
    at process management.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 调度算法的主题很广泛，不仅涉及操作系统任务的执行，还涉及其他领域，如网络数据管理。我们无法在这里全面介绍，但重要的是要说明如何最初处理它并了解您系统的优势。话虽如此，让我们继续通过查看进程管理来继续讨论。
- en: Learning more about process creation
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解更多关于进程创建的知识
- en: A common practice in system programming is to follow a strict timeline for process
    creation and execution. Programmers use either daemons, such as `systemd` and
    other in-house developed solutions, or startup scripts. We can use the Terminal
    as well but this is mostly for when we repair the system’s state and restore it,
    or test a given functionality. Another way to initiate processes from our code
    is through system calls. You probably know some of them, such as `fork()` and
    `vfork()`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程中，遵循严格的进程创建和执行时间表是一种常见做法。程序员使用守护进程，如 `systemd` 和其他内部开发的解决方案，或者启动脚本。我们也可以使用终端，但这主要是当我们修复系统状态并恢复它，或者测试某个特定功能时。从我们的代码中启动进程的另一种方式是通过系统调用。您可能知道其中的一些，例如
    `fork()` 和 `vfork()`。
- en: Introducing fork()
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 fork()
- en: 'Let’s look at an example; we’ll discuss it afterward:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子；我们稍后会讨论它：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Yes, we are aware that you’ve probably seen a similar example before and it’s
    clear what should be given as output – a new process is initiated by `fork()`
    [`1`] and both `pid` values are printed out:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们知道您可能之前已经见过类似的例子，并且很清楚应该输出什么 – 通过 `fork()` `1` 启动了一个新的进程，并且打印出了两个 `pid`
    值：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In `Parent`, `fork()` will return the ID of the newly created process; that
    way, the parent is aware of its children. In `Child`, `0` will be returned. This
    mechanism is important for process management because `fork()` creates a duplicate
    of the calling process. Theoretically, the compile-time segments (**text**, **data**,
    and **BSS**) are created anew in the main memory. The new **stack** starts to
    unwind from the same entry point of the program, but it branches at the fork call.
    Then, one logical path is followed by the parent, and another by the child. Each
    uses its own **data**, **BSS**, and **heap**.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Parent` 中，`fork()` 将返回新创建进程的 ID；这样，父进程就能知道其子进程。在 `Child` 中，将返回 `0`。这种机制对于进程管理非常重要，因为
    `fork()` 会创建调用进程的副本。理论上，编译时段（**text**、**data** 和 **BSS**）在主内存中重新创建。新的 **栈** 从程序的相同入口点开始展开，但在
    fork 调用处分支。然后，父进程遵循一条逻辑路径，子进程遵循另一条。每个都使用自己的 **data**、**BSS** 和 **heap**。
- en: You’re probably thinking that large compile-time segments and stacks will cause
    unnecessary memory usage because of duplication, especially when we don’t change
    them. And you’re correct! Luckily for us, we are using a virtual address space.
    This allows the OS to have extra management and abstraction over the memory. In
    the previous section, we discussed that processes with the same `fork()` endlessly
    as this will cause a so-called `exec`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为大型的编译时段和栈会因为重复而造成不必要的内存使用，尤其是在我们不做修改的情况下。你是对的！幸运的是，我们正在使用虚拟地址空间。这允许操作系统对内存有额外的管理和抽象。在前一节中，我们讨论了无限
    `fork()` 的进程将导致所谓的 `exec`。
- en: exec and clone()
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: exec 和 clone()
- en: 'The `exec` function call is not really a system call, but a group of system
    calls with the `execXX(<args>)` pattern. Each has a specific role, but most importantly,
    they create a new process through its filesystem path, known as `NULL`. This code
    is similar to the previous example, but a few changes have been made:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec` 函数调用实际上不是一个系统调用，而是一组具有 `execXX(<args>)` 模式的系统调用。每个都有其特定的作用，但最重要的是，它们通过其文件系统路径创建一个新的进程，称为
    `NULL`。这段代码与之前的例子类似，但做了一些修改：'
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The result is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can probably see that something’s missing from the printed output. Where’s
    the `"Process called!"` message? If something went wrong, such as the executable
    not being found, then we will observe `"Process creation failed!"`. But in this
    case, we know it has been run because of the parent and child outputs. The answer
    to this can be found in the paragraph before this code example – the memory segments
    are replaced with the ones from `test_fork`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到打印输出中缺少了一些内容。哪里去了 `"Process called!"` 消息？如果出了问题，比如可执行文件找不到，那么我们将观察到
    `"Process creation failed!"`。但在这个例子中，我们知道它已经运行，因为有了父进程和子进程的输出。这个答案可以在本代码示例之前的段落中找到——内存段被
    `test_fork` 中的段所替换。
- en: Similarly to `exec`, `clone()` is a wrapper function to the real `clone()` system
    call. It creates a new process, such as `fork()`, but allows you to precisely
    manage the way the new process is instantiated. A few examples are virtual address
    space sharing, signal handles, file descriptors, and so on. `vfork()`, as mentioned
    earlier, is a special variant of `clone()`. We encourage you to spend some time
    and take a look at some examples, although we believe that most of the time, `fork()`
    and `execXX()` will be enough.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `exec` 类似，`clone()` 是对真实 `clone()` 系统调用的包装函数。它创建一个新的进程，如 `fork()`，但允许你精确地管理新进程的实例化方式。一些例子包括虚拟地址空间共享、信号处理、文件描述符等。前面提到的
    `vfork()` 是 `clone()` 的一个特殊变体。我们鼓励你花些时间看看一些例子，尽管我们相信大多数时候，`fork()` 和 `execXX()`
    就足够了。
- en: 'As you can see, we’ve chosen the `execv()` function {`1`} for the given example.
    We’ve used this for simplicity and also because it’s related to *Figure 2**.5*.
    But before we look at this figure, there are other functions we can use as well:
    `execl()`, `execle()`, `execip()`, `execve()`, and `execvp()`. Following the `execXX()`
    pattern, we need to be compliant with the given requirement:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们为给定的例子选择了 `execv()` 函数 {`1`}。我们使用这个函数是为了简单，也因为它与 *图 2**.5* 有关。但在我们查看这个图之前，我们还可以使用其他函数：`execl()`、`execle()`、`execip()`、`execve()`
    和 `execvp()`。遵循 `execXX()` 模式，我们需要遵守给定的要求：
- en: '`e` requires the function to use an array of pointers to the environmental
    variables of the system, which are passed to the newly created process.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e` 要求函数使用指向系统环境变量的指针数组，这些变量传递给新创建的进程。'
- en: '`l` requires the command-line arguments to be stored in a temporary array and
    have them passed to the function call. This is just for convenience while handling
    the array’s size.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`l` 需要将命令行参数存储在一个临时数组中，并将它们传递给函数调用。这只是为了在处理数组大小时方便。'
- en: '`p` requires the path’s environment variable (seen as `PATH` in Unix) to be
    passed to the newly loaded process.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p` 需要将路径的环境变量（在 Unix 中表示为 `PATH`）传递给新加载的进程。'
- en: '`v` was used earlier in this book – it requires the command-line arguments
    to be provided to the function call, but they are passed as an array of pointers.
    In our example, we are setting it to `NULL` for simplicity.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v` 在本书中之前被使用过——它要求将命令行参数提供给函数调用，但它们是以指针数组的形式传递的。在我们的例子中，我们将其设置为 `NULL` 以简化。'
- en: 'Let’s see what this looks like now:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看现在这个样子：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In a nutshell, their implementation is the same when it comes to how we create
    a new process. The choice of whether or not to use them strictly depends on your
    needs and software design. We will revisit the topic of process creation several
    times in the next few chapters, especially when it goes to shared resources, so
    this will not be the last time we mention it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，当涉及到我们创建新进程的方式时，它们的实现是相同的。是否使用它们严格取决于您的需求和软件设计。在接下来的几章中，我们将多次回顾进程创建的主题，特别是当涉及到共享资源时，所以这不会是我们最后一次提到它。
- en: 'Let’s take a look at a trivial example: suppose we have a process-system command
    that’s initiated through the command-line Terminal – `&`. This can be expressed
    through the following graph:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子：假设我们有一个通过命令行终端——`&`——启动的进程系统命令。这可以通过以下图表表示：
- en: '![Figure 2.5 – Executing commands from the shell](img/Figure_02.5_B20833.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 从 shell 执行命令](img/Figure_02.5_B20833.jpg)'
- en: Figure 2.5 – Executing commands from the shell
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 从 shell 执行命令
- en: We have used this figure to emphasize the non-visible system calls for parent-child
    relationships between processes in Linux. In the background, the `exec()`. The
    kernel takes control and goes to the entry point of the application, where `main()`
    is called. The executable does its work and when `main()` returns, the process
    is ended. The ending routine is implementation-specific, but you can trigger it
    yourself in a controlled manner through the `exit()` and `_exit()` system calls.
    In the meantime, the **shell** is put to wait. Now, we’ll cover how to terminate
    a process.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这张图来强调 Linux 中进程之间父-子关系的不可见系统调用。在后台，是 `exec()`。内核接管控制权并转到应用程序的入口点，在那里调用
    `main()`。可执行文件完成其工作，当 `main()` 返回时，进程结束。结束例程是特定于实现的，但您可以通过 `exit()` 和 `_exit()`
    系统调用以受控的方式触发它。同时，**shell** 被置于等待状态。现在，我们将介绍如何终止一个进程。
- en: Terminating a process
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终止进程
- en: 'Usually, `exit()` is seen as a library function that’s implemented on top of
    `_exit()`. It does some extra work, such as buffer cleanup and closing streams.
    Using `return` in `main()` could be considered the equivalent of calling `exit()`.
    `_exit()` will handle the process termination by deallocating the data and the
    stack segments, destructing kernel objects (shared memory, semaphores, and so
    on), closing the files, and informing the parent about its status change (the
    `SIGCHLD` signal will be triggered). Their interfaces are as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`exit()` 被视为一个库函数，它是在 `_exit()` 之上实现的。它做一些额外的工作，例如缓冲区清理和关闭流。在 `main()` 中使用
    `return` 可以被认为是调用 `exit()` 的等效操作。`_exit()` 将通过释放数据和栈段、销毁内核对象（共享内存、信号量等）、关闭文件以及通知父进程其状态变化（将触发
    `SIGCHLD` 信号）来处理进程终止。它们的接口如下：
- en: '`void` `_exit(int status)`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void` `_exit(int status)`'
- en: '`void` `exit(int status)`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void` `exit(int status)`'
- en: 'It’s a common notion that the `status` value, when set to `0`, means a normal
    process termination, whereas others indicate a termination caused by an internal
    process issue. Therefore, the `EXIT_SUCCESS` and `EXIT_FAILURE` symbols are defined
    in `stdlib.h`. To demonstrate this, we could modify our fork example from earlier
    like so:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 人们普遍认为，当 `status` 值设置为 `0` 时，表示正常进程终止，而其他值表示由内部进程问题引起的终止。因此，在 `stdlib.h` 中定义了
    `EXIT_SUCCESS` 和 `EXIT_FAILURE` 符号。为了演示这一点，我们可以修改之前提到的 fork 示例，如下所示：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, the child will proceed as expected because nothing in particular happens,
    but we enable it to manage its termination policy better. The output will be the
    same as in the previous example. We will enrich this even further with a code
    snippet in the next section.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，子进程将按预期继续进行，因为没有发生任何特别的事情，但我们使它能够更好地管理其终止策略。输出将与上一个例子相同。我们将在下一节中进一步丰富这一点，通过一个代码片段。
- en: But before we do that, let’s note that both functions are usually related to
    a controlled manner of process termination. `abort()` will lead a process to termination
    in a similar fashion, but the `SIGABRT` signal will be triggered. As discussed
    in the next chapter, some signals should be handled and not ignored – this one
    is a good example of gracefully handling the exit routine of a process. In the
    meantime, what does the parent do and could it be affected by the child’s exit
    code? Let’s see.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们这样做之前，让我们注意，这两个函数通常都与一种受控的过程终止方式相关。`abort()`将以类似的方式导致进程终止，但会触发`SIGABRT`信号。正如下一章所讨论的，一些信号应该被处理而不是被忽略——这是一个优雅地处理进程退出例程的好例子。同时，父进程会做什么，它会不会受到子进程退出代码的影响？让我们看看。
- en: Blocking a calling process
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻塞调用进程
- en: 'As you may have noticed in *Figure 2*.5, a process might be set to wait. Using
    the `wait()`, `waitid()`, or `waitpid()` system calls will cause the calling process
    to be blocked until it receives a signal or one of its children changes its state:
    it is terminated, it is stopped by a signal, or it is resumed by a signal. We
    use `wait()` to instruct the system to release the resources related to the child;
    otherwise, it becomes a **zombie**, as discussed in the previous chapter. These
    three methods are almost the same, but the latter two are compliant with POSIX
    and provide more precise control over the monitored child process. The three interfaces
    are as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在*图2.5*中可能已经注意到的，一个进程可能被设置为等待。使用`wait()`、`waitid()`或`waitpid()`系统调用将导致调用进程被阻塞，直到它收到一个信号或其子进程改变状态：它被终止、被信号停止或被信号恢复。我们使用`wait()`来指示系统释放与子进程相关的资源；否则，它将成为一个**僵尸进程**，如前一章所述。这三种方法几乎相同，但后两种符合POSIX标准，并提供了对监控子进程的更精确控制。这三个接口如下：
- en: '`pid_t` `wait(int *status);`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pid_t wait(int *status);`'
- en: '`pid_t waitpid(pid_t pid, int *status,` `int options);`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pid_t waitpid(pid_t pid, int *status, int options);`'
- en: '`int waitid(idtype_t idtype, id_t id, siginfo_t * infop ,` `int options);`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int waitid(idtype_t idtype, id_t id, siginfo_t * infop, int options);`'
- en: 'The `status` argument has the same role for the first two functions. `wait()`
    could be represented as `waitpid(-1, &status, 0)`, meaning the process caller
    must wait for any child process that terminates and receive its status. Let’s
    take a look at one example directly with `waitpid()`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`status`参数对前两个函数具有相同的作用。`wait()`可以表示为`waitpid(-1, &status, 0)`，这意味着进程调用者必须等待任何终止的子进程并接收其状态。让我们直接通过`waitpid()`来看一个例子：'
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result from this execution is as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此执行的输出结果如下：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, we are creating two child processes and we set one of them to
    exit successfully and the other with a failure ([`1`] and [`2`]). We set the parent
    to wait for their exit statuses ([`1`] and [`5`]). When the child exits, the parent
    is notified through a signal accordingly, as described earlier, and the exit statuses
    are printed out ([`4`] and [`6`]).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在创建两个子进程，并将其中一个设置为成功退出，另一个设置为失败([`1`]和[`2`])。我们将父进程设置为等待它们的退出状态([`1`]和[`5`])。当子进程退出时，父进程会通过信号得到通知，正如前面所描述的，并打印出退出状态([`4`]和[`6`])。
- en: 'In addition, `idtype` and the `waitid()` system call allow us to wait not only
    for a certain process but also for a group of processes. Its status argument provides
    detailed information about the actual status update. Let’s modify the example
    again:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`idtype`和`waitid()`系统调用使我们能够等待一个特定的进程，也可以等待一组进程。其状态参数提供了关于实际状态更新的详细信息。让我们再次修改这个例子：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We changed `exit()` to `abort()` ([`1`]), which caused the child process to
    receive `SIGABRT` and exit with default handling (not exactly what we advised
    earlier). We used the `struct` status ([`2`]) to collect more meaningful status
    change information. The `waitid()` system call is used to monitor a single process
    and is set to wait for it to exit ([`3`]). If the child process signals its exit,
    then we print out the meaningful information ([`4`]), which in our case proves
    that we get `SIGABRT` (with a value of `6`), the update comes with `SIGCHLD` (with
    a value of `20`) and the exit code is `2`, as per the documentation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`exit()`改为`abort()`([`1`])，这导致子进程接收`SIGABRT`信号并以默认处理方式退出（这并不完全是我们之前建议的）。我们使用`struct`状态([`2`])来收集更有意义的状态变化信息。`waitid()`系统调用用于监控单个进程，并设置为等待其退出([`3`])。如果子进程发出退出信号，那么我们将打印出有意义的信息([`4`])，在我们的例子中，这证明了我们得到了`SIGABRT`（值为`6`），更新伴随着`SIGCHLD`（值为`20`），并且退出代码为`2`，正如文档中所述。
- en: 'The `waitid()` system call has various options and through it, you can monitor
    your spawned processes in real time. We will not delve deeper here, but you can
    find more information on the manual pages should it suit your needs: [https://linux.die.net/man/2/waitid](https://linux.die.net/man/2/waitid).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitid()`系统调用有多种选项，通过它，你可以实时监控你派生的进程。我们在这里不会深入探讨，但如果需要，你可以在手册页面上找到更多信息：[https://linux.die.net/man/2/waitid](https://linux.die.net/man/2/waitid)。'
- en: An important remark is that with POSIX and Linux’s thread management policy,
    which we discussed earlier, by default, a thread will wait on children of other
    threads in the same thread group. That said, we’ll get into some thread management
    in the next section.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的注意事项是，根据我们之前讨论的POSIX和Linux的线程管理策略，默认情况下，一个线程将等待同一线程组中其他线程的子线程。话虽如此，我们将在下一节中探讨一些线程管理。
- en: Introducing the system calls for thread manipulation in C++
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍C++中线程操作的系统调用
- en: 'As discussed in [*Chapter 1*](B20833_01.xhtml#_idTextAnchor014), we use threads
    to execute separate procedures in parallel. They exist only in the scope of a
    process and their creation overhead is bigger than the thread’s one, so we consider
    them lightweight, although they have their own stack and `task_struct`. They are
    almost self-sufficient, except they rely on the parent process to exist. That
    process is also known as *the main thread*. All others that are created by it
    need to join it to be initiated. You could create thousands of threads simultaneously
    on the system, but they will not run in parallel. You can run only *n* parallel
    tasks, where *n* is the number of the system’s concurrent ALUs (occasionally,
    these are the hardware’s concurrent threads). The others will be scheduled according
    to the OS’s task-scheduling mechanism. Let’s look at the simplest example of a
    POSIX thread interface:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在[*第一章*](B20833_01.xhtml#_idTextAnchor014)中讨论的那样，我们使用线程来并行执行不同的程序。它们只存在于进程的作用域内，它们的创建开销比线程的大，所以我们认为它们是轻量级的，尽管它们有自己的栈和`task_struct`。它们几乎可以自给自足，除了它们依赖于父进程的存在。这个进程也被称为*主线程*。所有由它创建的其他线程都需要加入它才能启动。你可以在系统上同时创建成千上万的线程，但它们不会并行运行。你可以运行的并行任务数量为*n*，其中*n*是系统并发ALU的数量（偶尔，这些是硬件的并发线程）。其他的将根据操作系统的任务调度机制进行调度。让我们看看POSIX线程接口的最简单例子：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Of course, there are other system calls we could use to manage the POSIX threads
    further, such as exiting a thread, receiving the called procedure’s returned value,
    detaching from the main thread, and so on. Let’s take a look at C++’s thread realization:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还可以使用其他系统调用来进一步管理POSIX线程，例如退出线程、接收被调用过程的返回值、从主线程分离等。让我们看看C++的线程实现：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This looks simpler, but it provides the same operations as the POSIX thread.
    To be consistent with the language, we advise you to use the C++ thread object.
    Now, let’s see how these tasks are executed. Since we’ll cover the newly added
    C++20 **jthreads** feature in [*Chapter 6*](B20833_06.xhtml#_idTextAnchor086),
    we will provide a system programming overview in the next few sections.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来更简单，但它提供了与POSIX线程相同的操作。为了与语言保持一致，我们建议您使用C++线程对象。现在，让我们看看这些任务是如何执行的。由于我们将在[*第六章*](B20833_06.xhtml#_idTextAnchor086)中介绍新添加的C++20
    **jthreads**功能，因此我们将在接下来的几节中提供一个系统编程概述。
- en: Joining and detaching threads
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程的连接和分离
- en: Regardless of whether you join threads through POSIX system calls or C++, you
    require this action to execute a routine through a given thread and wait for its
    termination. One remark, though – on Linux, the thread object of `pthread_join()`
    must be joinable, and the C++ thread object is not joinable by default. It is
    a good practice to join threads separately since joining them simultaneously leads
    to undefined behavior. It works the same way as the `wait()` system call does,
    except it relates to threads instead of processes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是通过 POSIX 系统调用还是 C++ 加入线程，您都需要执行此操作来通过给定的线程执行例程并等待其终止。有一点需要注意——在 Linux 上，`pthread_join()`
    的线程对象必须是可连接的，而 C++ 线程对象默认情况下不可连接。将线程分别连接是一个好习惯，因为同时连接它们会导致未定义的行为。它与 `wait()` 系统调用的工作方式相同，只是它涉及线程而不是进程。
- en: 'And the same way processes could be run as daemons, threads can become daemons
    as well through detaching – `pthread_detach()` for POSIX or `thread::detach()`
    in C++. We are going to see this in the following example, but we are also going
    to analyze the joinable setting of the threads:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，进程可以作为守护进程运行，线程也可以通过分离来成为守护进程——POSIX 的 `pthread_detach()` 或 C++ 中的 `thread::detach()`。我们将在下面的示例中看到这一点，但我们还将分析线程的可连接设置：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The respective output is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的输出如下：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding example is fairly simple – we create two thread objects: one
    is to be detached from the main thread handle (`detached_routine()`), while the
    other (`joined_thread()`) will join the main thread after exit. We check their
    joinable status at creation and after setting them to work. As expected, after
    the threads get to their routines, they are no longer joinable until they are
    terminated.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例相当简单——我们创建了两个线程对象：一个是要从主线程句柄中分离出来（`detached_routine()`），而另一个（`joined_thread()`）将在退出后连接到主线程。我们在创建时以及设置它们工作后检查它们的可连接状态。正如预期的那样，线程到达它们的例程后，它们就不再可连接，直到它们被终止。
- en: Thread termination
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程终止
- en: 'Linux (POSIX) provides two ways to end a thread’s routine in a controlled manner
    from the inside of the thread: `pthread_cancel()` and `pthread_exit()`. As you
    have probably guessed from their names, the second one terminates the caller thread
    and is expected to always succeed. In contrast with the process `exit()` system
    call, during this one’s execution, no process-shared resources, such as semaphores,
    file descriptors, mutexes, and so on, will be released, so make sure you manage
    them before the thread exits. Canceling the thread is a more flexible way to do
    this, but it ends up with `pthread_exit()`. Since the thread cancelation request
    is sent to the thread object, it has the opportunity to execute a cancelation
    cleanup and call thread-specific data destructors.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Linux (POSIX) 提供了两种从线程内部以受控方式结束线程例程的方法：`pthread_cancel()` 和 `pthread_exit()`。正如您可能从它们的名字中猜到的，第二个会终止调用线程，并且预期总是成功。与
    `exit()` 系统调用不同，在执行此操作期间，不会释放进程共享资源，例如信号量、文件描述符、互斥锁等，因此请确保在线程退出之前管理它们。取消线程是一种更灵活的方法来做这件事，但它最终会调用
    `pthread_exit()`。由于线程取消请求是发送到线程对象的，因此它有机会执行取消清理并调用线程特定的数据析构函数。
- en: As C++ is an abstraction on top of the system call interface, it uses the thread
    object’s scope to manage its lifetime and does this well. Of course, whatever
    happens in the background is implementation-specific and depends on the system
    and the compiler. We are revisiting this topic later in this book as well, so
    use this opportunity to familiarize yourself with the interfaces.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 C++ 是系统调用接口的抽象，它使用线程对象的范围来管理其生命周期，并且做得很好。当然，背景中发生的事情是特定于实现、系统和编译器的。我们将在本书的后续章节中再次探讨这个主题，所以请利用这个机会熟悉这些接口。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we walked through the low-level events that occur during process
    or thread creation and manipulation. We discussed the processes’ memory layout
    and its significance. You also learned some important points about the OS’s way
    of task scheduling and what happens in the background during process and thread
    state updates. We will use these fundamentals later in this book. The next chapter
    will cover filesystem management and will provide you with some interesting C++
    instruments in that domain.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在进程或线程创建和操作期间发生的低级事件。我们讨论了进程的内存布局及其重要性。您还了解了一些关于操作系统任务调度方式的重要观点以及进程和线程状态更新期间在后台发生的事情。我们将在本书的后续章节中使用这些基础知识。下一章将涵盖文件系统管理，并将提供一些该领域的有趣
    C++ 工具。
