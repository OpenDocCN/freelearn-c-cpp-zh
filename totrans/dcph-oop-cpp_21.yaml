- en: '21'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making C++ Safer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This bonus chapter will add insight into what we can do as C++ programmers to
    make the language as safe as possible in our everyday usage. We have progressed
    from basic language features to our core interest of OO programming with C++,
    to additional useful language features and libraries (exceptions, operator overloading,
    templates, and STL), to design patterns to give us a knowledge base to solve recurring
    types of OO programming problems. At every point along the way, we’ve seen that
    C++ requires extra care on our part to avoid tricky and potentially problematic
    programming situations. C++ is a language that will allow us to do anything, but
    with this power comes the need for guidelines to ensure our programming follows
    safe practices. After all, our goal is to create programs that will run successfully
    without errors and, additionally, be easy to maintain. The ability of C++ to do
    anything needs to be paired with sound practices to simply make C++ safer.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter is to revisit topics that we have covered in previous
    chapters, reviewing them with an eye toward safety. We will also incorporate topics
    strongly related to ones we have seen previously. This chapter is not meant to
    cover wholly new topics or previous topics in great depth, but to provide a grouping
    of safer programming practices and the encouragement to seek further information
    on each topic as needed. Some of these topics can encompass entire chapters (or
    books) themselves!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this bonus chapter, we will cover selected popular programming conventions
    to meet our safety challenge:'
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting smart pointers (unique, shared, and weak), as well as a complementary
    idiom (RAII)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using modern `for` loops (range-based, for-each) to avoid common errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adding type safety: usage of `auto` instead of explicit typing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preferring usage of STL types for simple containers (`std::vector`, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing `const` appropriately to ensure non-modification of select items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding thread safety issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering core programming guideline essentials, such as preferring initialization
    to assignment, or choosing only one of `virtual`, `override`, or `final`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adopting C++ core programming guidelines for safety (build and assemble one,
    if necessary)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding resources for programming safety in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand some of the current industry
    standards and concerns for programming safely in C++. This chapter is not meant
    to be a comprehensive list of all safety concerns and practices in C++, but to
    showcase the types of issues you will need to become mindful of as a successful
    C++ programmer. In some cases, you may desire to investigate a topic more deeply
    to gain a more thorough level of competence and proficiency. Adding safety to
    your C++ programming will make you a more valuable programmer, as your code will
    be more reliable and have more longevity and success.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s round out our programming skillset by considering how we can make C++
    safer.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter21](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter21).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter21` in a file named `Chp21-Ex1.cpp` under the aforementioned GitHub directory.
    Some programs are in applicable subdirectories as indicated in the examples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3wpOG6b](https://bit.ly/3wpOG6b).'
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting smart pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the book, we have developed a reasonable understanding of how to
    use raw or native C++ pointers, including the associated memory allocation and
    deallocation for heap instances. We have persevered through native C++ pointers
    because they are pervasive in existing C++ code. Having knowledge of how to properly
    utilize native pointers is essential in working with the volume of existing C++
    code currently in use. But, for newly created code, there is a safer way to manipulate
    heap memory.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that dynamic memory management with native pointers is a lot of
    work! Especially when there may be multiple pointers to the same chunk of memory.
    We’ve talked about reference counting to shared resources (such as heap memory)
    and mechanisms for deleting memory when all instances are done with the shared
    memory. We also know that memory deallocation can easily be overlooked, leading
    to memory leakage.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen, firsthand, that errors with native pointers can be costly.
    Our programs can end abruptly when we dereference memory we don’t intend to access,
    or when we dereference uninitialized native pointers (interpreting the memory
    to contain a valid address and meaningful data at that address—neither of which
    are actually valid). Pointer arithmetic to walk through memory can be laden with
    errors by an otherwise adept programmer. When a memory error is made, pointer
    or heap memory misuse are often the culprits.
  prefs: []
  type: TYPE_NORMAL
- en: Certainly, using references can ease the burden of many errors with native pointers.
    But references can still point to dereferenced heap memory that someone forgets
    to deallocate. For these and many other reasons, smart pointers have become popular
    in C++ with the primary purpose of making C++ safer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve talked about smart pointers in previous chapters and have seen them in
    action with our pImpl pattern (using `unique_ptr`). But there are more types of
    smart pointers for us to review in addition to unique: shared and weak. Let’s
    also make a programming premise (a future style guide addition) to prefer smart
    pointers in our newly created code to native pointers for the purpose and value
    of pointer safety.'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that a **smart pointer** is a small wrapper class that encapsulates a
    raw or native pointer, ensuring that the pointer it contains is automatically
    deleted when the wrapper object goes out of scope. The Standard C++ Library implementations
    of *unique*, *shared*, and *weak* smart pointers use templates to create a specific
    category of smart pointer for any data type.
  prefs: []
  type: TYPE_NORMAL
- en: Though we could devote an entire chapter to each type of smart pointer in depth,
    we will review each type briefly as a starting point to encourage their usage
    in newly created code to support our goal of making C++ safer.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s revisit each type of smart pointer, one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Using smart pointers – unique
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that a `unique_ptr` in the Standard C++ Library, is a type of smart pointer
    that encapsulates exclusive ownership and access to a given heap memory resource.
    A `unique_ptr` cannot be duplicated; the owner of a `unique_ptr` will have sole
    use of that pointer. Owners of unique pointers can choose to move these pointers
    to other resources, but the repercussions are that the original resource will
    no longer contain `unique_ptr`. Recall that we must use `#include <memory>` to
    include the definition for `unique_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a very simple example illustrating how to create unique pointers. This
    example can be found in our GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: First, notice that because we included `using std::unique_ptr;`, we did not
    need to qualify `unique_ptr` or `make_unique` with `std::` in the unique pointer
    declarations. In this small program, we create several unique pointers, starting
    with one to point to an integer, `p1`, and one to point to an instance of a `Person`,
    `pers1`. Each of these variables has exclusive use of the heap memory each points
    to because we are using unique pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we introduce a unique pointer, `pers2`, that takes over the memory originally
    allocated and linked to `pers1` using `pers2 = move(pers1);`. The original variable
    no longer has access to this memory. Note that though we could have allocated
    `pers2` to have its own, unique heap memory, we instead chose to demonstrate how
    to allow one unique pointer to relinquish its memory to another unique pointer
    using `move()`. Changing the ownership of unique pointers with `move()` is typical,
    as unique pointers cannot be copied (because that would allow two or more pointers
    to share the same memory and, therefore, not be unique!)
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create another unique pointer, `pers3`, that utilizes `make_unique`
    as a wrapper to allocate the heap memory for the unique pointer that `pers3` will
    represent. The preference for using `make_unique` is that the call to `new()`
    will be made internally, on our behalf. Additionally, any exceptions thrown during
    the construction of the object will be handled for us, as will any call to `delete()`,
    should the underlying `new()` not complete successfully and a call to `delete()`
    is then warranted.
  prefs: []
  type: TYPE_NORMAL
- en: The heap memory will be managed for us automatically; this is one of the benefits
    of using a smart pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output for our `unique_ptr` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Under the hood, the destructor will automatically be called for each object
    pointed to by a smart pointer, when the memory is no longer utilized. In the case
    of this example, the destructor for each `Person` object is called on our behalf
    when the local objects in `main()` go out of scope and are popped off the stack.
    Note that our `Person` destructor contains a `cout` statement so that we can visualize
    that there are only two `Person` objects destructed. Here, the destructed `Person`
    objects represent the instance taken over by `pers2` (from `pers1`) via the `move()`
    statement, and the `pers3` object that was created using the `make_unique` wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s add examples using shared and weak smart pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Using smart pointers – shared
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `shared_ptr` in the Standard C++ Library, is a type of smart pointer that
    permits shared ownership of and access to a given resource. The last shared pointer
    to the resource in question will trigger the destruction and memory deallocation
    of the resource. Shared pointers can be used in multithreaded applications; however,
    race conditions may occur if non-constant member functions are used to modify
    the shared resource. Since shared pointers only provide reference counting, we
    will need to enlist additional library methods to solve these issues (alleviating
    race conditions, synchronizing access to critical regions of code, and so on).
    The Standard C++ Library, for example, provides overloaded atomic methods to lock,
    store, and compare the underlying data pointed to by a shared pointer.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen many example programs that could take advantage of shared pointers.
    For example, we utilized associations between the `Course` and `Student` classes
    – a given student is associated with many courses and a given course is associated
    with many students. Clearly, multiple `Student` instances may point to the same
    `Course` instance, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, with raw pointers, it was the programmer’s responsibility to employ
    reference counting. In contrast, using shared pointers, the internal reference
    counter is atomically incremented and decremented in support of both pointer and
    thread safety.
  prefs: []
  type: TYPE_NORMAL
- en: Dereferencing a shared pointer is nearly as fast as dereferencing a raw pointer;
    however, because a shared pointer represents a wrapped pointer in a class, constructing
    and copying a shared pointer is more expensive. However, we are interested in
    making C++ safer, so we will simply note this very minor performance expense and
    move forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a very simple example using `shared_ptr`. This example
    can be found in our GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned program, we create four shared pointers – two to point
    to the same integer (`p1` and `p2`) and two to point to the same instance of `Person`
    (`pers1` and `pers2`). Each of these variables may change the specific shared
    memory they point to because we are using shared pointers (which allow such a
    reassignment). A change to the shared memory through `pers1`, for example, will
    be reflected should we then review the (shared) memory through pointer `pers2`;
    both variables point to the same memory location.
  prefs: []
  type: TYPE_NORMAL
- en: The heap memory will again be managed for us automatically as a benefit of using
    smart pointers. In this example, the memory will be destructed and deleted when
    the last reference to the memory is removed. Notice that reference counting is
    done on our behalf and that we can access this information using `use_count()`.
  prefs: []
  type: TYPE_NORMAL
- en: Let us notice something interesting about the previous example. Notice the mixed
    use of `->` and `.` notation with shared pointer variables `pers1` and `pers2`.
    For example, we utilize `pers1->Print();` and yet we also utilize `pers1.use_count()`.
    This is no mistake and reveals the wrapper implementation of the smart pointer.
    With that in mind, we know that `use_count()` is a method of `shared_ptr`. Our
    shared pointers `pers1` and `pers2` are each declared as instances of `shared_ptr`
    (definitely not using raw C++ pointers with the symbol `*`). Hence, dot notation
    is appropriate to access method `use_count()`. Yet, we are using `->` notation
    to access `pers1->Print();`. Here, recall that this notation is equivalent to
    `(*pers1).Print();`. Both `operator*` and `operator->` in the `shared_ptr` class
    are overloaded to delegate to the wrapped, raw pointer contained within the smart
    pointer. Hence, we may utilize standard pointer notation to access `Person` methods
    (through the safely wrapped raw pointer).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output for our `shared_ptr` pointer example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Shared pointers seem like a wonderful way to ensure that memory resources pointed
    to by multiple pointers are properly managed. Overall, this is true. However,
    there are situations with circular dependencies such that shared pointers simply
    cannot release their memory – another pointer is always pointing to the memory
    in question. This happens when a cycle of memory is orphaned; that is, when no
    outside shared pointers point *into* the circular connection. In such unique cases,
    we might actually (and counterintuitively) mismanage memory with shared pointers.
    In these situations, we can elicit help from a weak pointer to help us break the
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let’s next take a look at weak smart pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Using smart pointers – weak
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `weak_ptr` in the Standard C++ Library, is a type of smart pointer that does
    not take ownership of a given resource; instead, the weak pointer acts as an observer.
    Weak pointers can be used to help break a circular connection that may exist between
    shared pointers; that is, situations where the destruction of a shared resource
    would otherwise never occur. Here, a weak pointer is inserted into the chain to
    break the circular dependency that shared pointers alone might otherwise create.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, imagine our `Student` and `Course` dependencies from our initial
    programming examples utilizing association, or from our more complex program illustrating
    the Observer pattern. Each contains pointer data members of the associated object
    types, effectively creating a potential circular dependency. Now, should an outside
    (from the circle) shared pointer exist, such as an external list of courses or
    an external list of students, the exclusive circular dependency scenario may not
    arise. In this case, for example, the master list of courses (the external pointer,
    separate from any circular dependency existing between the associated objects)
    will provide the means to cancel a course, leading to its eventual destruction.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise in our example, an external set of students comprising the university’s
    student body can provide an external pointer to the potentially circular shared
    pointer scenario resulting from the association between `Student` and `Course`.
    Yet in both of these cases, work will need to be done to remove a canceled course
    from a student’s course list (or remove a dropped student from a course’s student
    list). The removal of the associations in this scenario reflects accurately managing
    a student’s schedule or a course’s attendance list. Nonetheless, we can imagine
    scenarios where a circular connection may exist without an outside handle to the
    links (unlike the aforementioned scenario, which has outside links into the circle).
  prefs: []
  type: TYPE_NORMAL
- en: In the case where a circular dependency exists (with no outside influences),
    we will need to downgrade one of the shared pointers to a weak pointer. A weak
    pointer will not control the lifetime of the resource that it points to.
  prefs: []
  type: TYPE_NORMAL
- en: A weak pointer to a resource cannot access the resource directly. This is because
    operators `*` and `->` are not overloaded in the `weak_ptr` class. You will need
    to convert the weak pointer to a shared pointer in order to access methods of
    the (wrapped) pointer type. One way to do this is to apply the `lock()` method
    to a weak pointer, as the return value is a shared pointer whose contents are
    locked with a semaphore to ensure mutual exclusivity to the shared resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a very simple example using `weak_ptr`. This example can
    be found on our GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex3.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned program, we allocate our resource using a shared pointer
    in `pers1`. Now, let us imagine we had a reason in our program to downgrade our
    resource to a weak pointer – perhaps we would like to insert a weak pointer to
    break an otherwise cycle of shared pointers. Using `weak_ptr<Person> wpers1(pers1);`,
    we establish a weak pointer to this resource. Notice that we cannot use `wpers1`
    to call `Print();`. This is because `operator->` and `operator*` have not been
    overloaded in the `weak_ptr` class.
  prefs: []
  type: TYPE_NORMAL
- en: We print out `use_count()` for each of `pers1` and `wpers1` to notice that each
    shows a value of `1`. That is, there is only one non-weak pointer controlling
    the resource in question (the weak pointer may temporarily hold the resource,
    but cannot modify it).
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that we would like to convert the resource pointed to by `wpers1`
    on-demand to another shared pointer, so that we may access the resource. We can
    do so by first gaining a lock on the weak pointer; `lock()` will return a shared
    pointer whose contents are protected by a semaphore. We assign this value to `pers2`.
    We then call `pers2->ModifyTitle("Dr.");` on the resource using the shared pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we print out `use_count()` from the perspective of each of `pers1`,
    `wpers1`, and `pers2`. In each case, the reference count will be `2`, as there
    are two non-weak pointers referencing the shared resource. The weak pointer does
    not contribute to the reference count of that resource, which is exactly how weak
    pointers can help break a chain of circular dependencies. By inserting a weak
    pointer into the dependency loop, the reference count to the shared resource will
    not be affected by the weak pointer’s presence. This strategy allows the resource
    to be deleted when only the weak pointer to the resource remains (and the reference
    count is `0`).
  prefs: []
  type: TYPE_NORMAL
- en: The heap memory will again be managed for us automatically as a benefit of using
    smart pointers. In this example, the memory will be destructed and deleted when
    the last reference to the memory is removed. Again, note that the weak pointer
    did not contribute a reference to this count. We can see from the `cout` statement
    in the `Person` destructor that only one instance was destructed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output for our `weak_ptr` pointer example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we’ve reviewed and added to the basics regarding smart pointers.
    However, there could be a chapter easily spent on each type of smart pointer.
    Nonetheless, hopefully, you have enough comfort with the essentials to begin to
    include a variety of smart pointers in your code and investigate each type further
    as your need arises.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a complementary idea – RAII
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A programming idiom that complements smart pointers (as well as other concepts)
    is `move()` operation.
  prefs: []
  type: TYPE_NORMAL
- en: Many C++ class libraries follow RAII for resource management, such as `std::string`
    and `std::vector`. These classes follow the idiom in that their constructors acquire
    the necessary resources (heap memory), and release the resources automatically
    in their destructors. The user of these classes is not required to explicitly
    release any memory for the container itself. In these class libraries, RAII as
    a technique is used to manage these resources, even though the heap memory is
    not managed using smart pointers. Instead, the concepts of RAII are encapsulated
    and hidden within the class implementations themselves.
  prefs: []
  type: TYPE_NORMAL
- en: When we implemented our own smart pointers in [*Chapter 20*](B19087_20.xhtml#_idTextAnchor876),
    *Removing Implementation Details Using the pImpl Pattern*, we used RAII, without
    knowing it, to ensure the allocation of the heap resource within our constructor
    and the release of the resource in our destructor. The smart pointers implemented
    in the Standard C++ Library (`std::unique_ptr`, `std::shared_ptr`, and `std::weak_ptr`)
    embrace this idiom as well. Embracing RAII by using classes employing this idiom
    (or by adding it yourself to classes when this is not possible), can help ensure
    code is safer and easier to maintain. Because of the safety and robustness that
    this idiom adds to code, savvy developers urge us to embrace RAII as one of the
    most important practices and features available in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Next in our effort to make C++ safer, let’s consider several easy C++ features
    we can easily embrace to ensure our coding is more robust.
  prefs: []
  type: TYPE_NORMAL
- en: Embracing additional C++ features promoting safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen through 20 previous chapters of programming, C++ is an extensive
    language. We know that C++ has great power and that we can do nearly anything
    in C++. As object-oriented C++ programmers, we have seen how to adopt OO designs,
    with the goal of making our code more easily maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: We have also gained a lot of experience utilizing raw (native) pointers in C++,
    primarily because raw pointers are very pervasive in existing code. You truly
    need experience and facility in using native pointers for when the need arises.
    In gaining this experience, we have seen firsthand the pitfalls we may encounter
    with mismanagement of heap memory – our programs may have crashed, we may have
    leaked memory, overwritten memory accidentally, left dangling pointers, and so
    on. Our first order of business in this chapter was to prefer using smart pointers
    in newly created code – to promote safety in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will explore other areas of C++ that we can similarly employ safer features.
    We have seen these various features throughout the book; it is important to establish
    a guideline that select language features promote safety in C++. Just because
    we can do anything in C++ doesn’t mean that we should routinely include features
    in our repertoire that have a high level of misuse associated with them. Applications
    that continually crash (or crash even once) are unacceptable. Certainly, we have
    noted no-nos throughout the book. Here, let’s point out language features that
    are worth embracing to further our goal of making C++ safer, leaving our applications
    more robust and more easily maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by reviewing simple items we can incorporate into our everyday code.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting range for loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ has a variety of looping constructs that we have seen throughout the book.
    One common error that occurs when processing a complete set of items is correctly
    keeping track of how many items are in the set, especially when this counter is
    used as a basis to loop through all items in the set. Processing too many elements
    when our set is stored as an array, for example, could lead our code to raise
    an exception unnecessarily (or worse, could lead our program to crash).
  prefs: []
  type: TYPE_NORMAL
- en: Rather than relying on a `MAX` value to conduct our looping for all elements
    in a set, it is more desirable to loop through every item in the set in a way
    that doesn’t count on the programmer correctly remembering this upper loop value.
    Instead, for each item in the set, let’s do some sort of processing. A for-each
    loop answers this need quite nicely.
  prefs: []
  type: TYPE_NORMAL
- en: One common error that occurs when processing a non-complete set of items is
    correctly keeping track of how many items are currently in the set. For example,
    a `Course` may have a maximum number of students permitted. Yet, as of today,
    only half of the potential `Student` slots are filled. When we peruse the list
    of students enrolled in the course, we need to ensure we are processing only the
    filled student spots (that is, the current number of students). Processing all
    maximum student spots would clearly be an error and could lead our program to
    crash. In this scenario, we must use care to iterate only over the currently utilized
    `Student` spots in the `Course`, either through using logic to exit a loop when
    appropriate or by selecting a container type whose current size represents the
    complete size of the set to be iterated upon (with no empty *to be filled* spots);
    the latter scenario making a for-each loop an ideal choice.
  prefs: []
  type: TYPE_NORMAL
- en: Also, what if we rely on looping based upon a `currentNumStudents` counter?
    This may be better than a `MAX` value in cases as previously illustrated, but
    what if we’ve not kept that counter correctly updated? We’re subject to an error
    on this as well. Again, combining a container class where the number of entries
    represents the current number of entries with a for-each type of loop can ensure
    that we process the complete, current grouping in a less error-prone manner.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have revisited modern and more safe looping styles, let’s embrace
    `auto` to ensure type safety. We will then see an example incorporating these
    collective features.
  prefs: []
  type: TYPE_NORMAL
- en: Using auto for type safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many situations arise in which using `auto` makes coding easier with respect
    to variable declarations, including loop iterators. Additionally, using `auto`
    instead of explicit typing can ensure type safety.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing to use `auto` is a simple way to declare a variable that has a complicated
    type. Using `auto` can also ensure that the best type is chosen for a given variable
    and that implicit conversion will not occur.
  prefs: []
  type: TYPE_NORMAL
- en: We can use `auto` as a placeholder for types in a variety of situations, allowing
    the compiler to deduce what is needed in a particular situation. We can even use
    `auto` as a return type for a function in many cases. Using `auto` allows our
    code to appear more generic and can complement templates as an alternative to
    genericizing a type. We can pair `auto` with `const`, and also pair these qualifiers
    with references; note that these qualifiers *combined* cannot be extrapolated
    with `auto` and must be specified individually by the programmer. Additionally,
    `auto` cannot also be used with qualifiers augmenting a type, such as `long` or
    `short`, nor can it be used with `volatile`. Though outside the scope of our book,
    `auto` can be utilized with lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, using `auto` has a few drawbacks. For example, if the programmer
    doesn’t understand the type of object being created, the programmer may anticipate
    the compiler to select a certain type, and yet another (unexpected) type is deduced.
    This may create subtle errors in your code. For example, if you have overloaded
    functions for both the type you think `auto` will select and for the type the
    compiler actually deduces the `auto` declaration to be, you may call a different
    function than anticipated! Certainly, this may mostly be due to the programmer
    not fully understanding the context of usage at hand when inserting the `auto`
    keyword. Another drawback is when the programmer uses `auto` just to force the
    code to compile, without truly working through the syntax at hand and thinking
    about how the code should be written.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have revisited adding `auto` to our code, let’s revisit embracing
    STL in our everyday code. We will then see an example incorporating these collective
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Preferring STL for simple containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Standard Template Library, as we’ve seen in [*Chapter 14*](B19087_14.xhtml#_idTextAnchor595),
    *Understanding STL Basics*, includes a very complete and robust set of container
    classes that are widely utilized in C++ code. Using these well-tested components
    instead of native C++ mechanisms (such as an array of pointers) to collect like
    items can add robustness and reliability to our code. The memory management is
    eased on our behalf (eliminating many potential errors).
  prefs: []
  type: TYPE_NORMAL
- en: The STL, by using templates to implement its large variety of container classes,
    allows its containers to be used generically for any data type our programs may
    encounter. By comparison, had we utilized native C++ mechanisms, it is likely
    that we may have tied our implementation to a specific class type, such as an
    array of pointers to `Student`. Certainly, we could have implemented an array
    of pointers to a templatized type, but why do so when such a nice variety of well-tested
    containers are readily available for our use?
  prefs: []
  type: TYPE_NORMAL
- en: STL containers also avoid using `new()` and `delete()` for memory management,
    choosing to use allocators to improve efficiency for STL’s underlying memory management.
    For example, a vector, stack, or queue may grow and shrink in size. Rather than
    allocating the maximum number of elements you may anticipate (which may be both
    difficult to estimate or inefficient to over-allocate for typical usage that does
    not reach the maximum), a certain buffer size or a number of elements may be allocated
    under the hood up front. This initial allocation allows multiple additions to
    the container without a resize necessary for each new addition to the set (as
    might otherwise be done to avoid over-allocation). Only when the underlying container’s
    internal allocation (or buffer) size exceeds the pre-allocated amount will an
    internal reallocation be necessary (unknown to the user of the container). The
    expense of an internal reallocation, or a *move*, is the allocation of a larger
    piece of memory, copying from the original memory to the larger piece, and then
    the release of the original memory. The STL works to fine-tune, under the hood,
    the internal allocations to balance typical usage needs versus costly reallocation
    that might otherwise be performed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have revisited preferring STL in our code, let’s revisit applying
    `const` when necessary to ensure code isn’t modified unless we so intend it to
    be. We will wrap up this section with an example illustrating all of the key safety
    points featured in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Applying const as needed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applying the `const` qualifier to objects is an easy way to indicate that instances
    that should not be modified are not, in fact, modified. We may recall that `const`
    instances may only call `const` member functions. And that `const` member functions
    may not modify any part of the object calling the method (`this`). Remembering
    to utilize this simple qualifier can ensure that this chain of checkpoints occurs
    for objects that we truly do not intend to modify.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, remember that `const` can be utilized in parameter lists,
    to qualify objects and methods. Using `const` adds readability to the objects
    and methods it qualifies as well as adding the valuable enforcement of read-only
    objects and methods. Let’s remember to use `const` as needed!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at how we can use each of these easily added C++ features
    that contribute to safer programming. This example revisits preferred looping
    styles, using `auto` for type safety, using the STL for simple containers, and
    applying `const` as appropriate. This example can be found in our GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex4.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned program, we initially notice that we have included the
    use of `std::vector` from C++’s STL. Further in `main()`, we notice the instantiation
    of a vector using `vector<Student> studentBody;`. Utilizing this well-tested container
    class certainly adds robustness to our code versus managing a dynamically sized
    array ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Next, notice the specification of a constant member function `void Student::Print()
    const;`. Here, the `const` qualification ensures that no part of the object invoking
    this method (`this`) will be able to be modified. Furthermore, should any `const`
    instances exist, they will be able to invoke `Student::Print()` as the `const`
    qualification guarantees this method to be safe (that is, read-only) for `const`
    instances to utilize.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we notice three looping styles and mechanisms, progressing from least
    to most safe in style. The first loop cycles through each element in the loop
    with a traditional style `for` loop. What if we had used `MAX` for the looping
    condition instead of `studentBody.size()`? We might have tried to process more
    elements than are currently in the container; this type of oversight can be error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: The second loop utilizes an iterator and the `auto` keyword to make the type
    specification easier (and hence safer) for the iterator itself. Iterators, though
    well defined, are still not the preferred looping mechanism. A subtlety from the
    increment in the second statement in the `for` statement can also lead to inefficiency.
    Consider, for example, the pre versus post increment in the statement that is
    executed before the loop condition is retested (that is, `++iter`). Had this been
    `iter++`, the code would be less efficient. This is because `iter` is an object
    and the pre-increment returns a reference to the object, whereas the post-increment
    returns a temporary object (what is created and destroyed with each loop iteration).
    The post-increment also utilizes an overloaded function, so the compiler cannot
    optimize its usage.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we see the preferred and safest looping mechanism, featuring a range-for
    loop combined with `auto` for the iterator specification (to simplify the type
    declaration). The use of `auto` replaces `vector<Student>::iterator` as the type
    for `iter`. Any time there is an ease in notation, there is also less room for
    error. Also, notice the use of `const` added to the iterator declaration to ensure
    that the loop will only call non-modifiable methods on each instance iterated
    upon; this is an example of an additional, appropriate safety feature we can employ
    in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output for our aforementioned program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We have now revisited several straightforward C++ language features that can
    easily be embraced to promote safety in our everyday coding practices. Using range-for
    loops provides code simplification and removes dependencies from often incorrect
    upper limits of loop iteration. Embracing `auto` simplifies variable declarations,
    including within loop iterators, and can help ensure type safety versus explicit
    typing. Using well-tested STL components can add robustness, reliability, and
    familiarity to our code. Finally, applying `const` to data and methods is an easy
    way to ensure data is not modified unintentionally. Each of these principles is
    easy to employ and adds value to our code by adding to its overall safety.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s consider how understanding thread safety can contribute to making
    C++ safer.
  prefs: []
  type: TYPE_NORMAL
- en: Considering thread safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multithreaded programming in C++ is an entire book unto itself. Nonetheless,
    we have mentioned several situations throughout the book that potentially require
    the consideration of thread safety. It is worth re-iterating these topics to provide
    an overview of the issues you may encounter in various niches of C++ programming.
  prefs: []
  type: TYPE_NORMAL
- en: A program may be comprised of multiple threads, each of which may potentially
    compete against one another to access a shared resource. For example, a shared
    resource could be a file, socket, region of shared memory, or output buffer. Each
    thread accessing the shared resource needs to have carefully coordinated (known
    as mutually exclusive) access to the resource.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine, for example, if two threads wanted to write output to your screen.
    If each thread could access the output buffer associated with `cout` without waiting
    for the other to complete a cohesive statement, the output would be a garbled
    mess of random letters and symbols. Clearly, synchronized access to a shared resource
    is important!
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety involves understanding atomic actions, mutual exclusion, locks,
    synchronization, and so on—all of which are aspects of multithreaded programming.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with an overview of threads and multithreaded programming.
  prefs: []
  type: TYPE_NORMAL
- en: Multithreaded programming overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **thread** is a separate flow of control within a process, conceptually working
    like a subprocess (or further subdivision of a process) within a given process.
    Threads are sometimes referred to as *threads of control*. Applications that have
    many threads of control are known as **multithreaded applications**.
  prefs: []
  type: TYPE_NORMAL
- en: In uniprocessor environments, threads give the appearance that multiple tasks
    are running concurrently. Just as with processes, threads are swapped in and out
    of the CPU quickly to appear to the user that they are being processed simultaneously
    (though they aren’t). In a shared, multiprocessor environment, the use of threads
    within an application can significantly speed up processing and allow parallel
    computing to be realized. Even in a uniprocessor system, threads can actually
    (and perhaps counterintuitively) speed up a process, in that one thread may run
    while waiting for the I/O of another thread to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Threads related by the tasks they are performing may find themselves in similar
    methods of a class simultaneously. If each thread is working on a distinct dataset
    (such as a distinct `this` pointer, even if working within the same method), there
    is generally no need to synchronize access to those methods. For example, imagine
    `s1.EarnPhd();` and `s2.EarnPhD();`. Here, two separate instances are in the same
    method (possibly concurrently). However, the datasets worked upon in each method
    differ – in the first scenario, `s1` will bind to `this`; in the second scenario,
    `s2` will bind to `this`. There is most likely no overlap in shared data between
    the two instances. However, if these methods are accessing static data (that is
    shared by all instances of a given class, such as a `numStudents` data member),
    synchronization to the critical pieces of code accessing the shared memory regions
    will be required. Traditionally, system-dependent locks or semaphores are added
    around data or functions that require mutual exclusivity to critical regions of
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Multithreaded programming in C++ is available through a variety of commercial
    or public domain multithreading libraries. Additionally, the Standard C++ Library
    features thread support in a variety of capacities including using `std::condition_variable`
    for thread synchronization, `std::mutex` to ensure mutual exclusivity of critical
    resources (by avoiding race conditions), and `std::semaphore` to model resource
    counting. By instantiating a `std::thread` object and becoming proficient with
    the aforementioned features, we can add multithreaded programming using an established
    C++ library. Additionally, the `std::atomic` template can be added to a type to
    establish it as an atomic type and ensure type-safe synchronization. The `std::exception_ptr`
    type allows the transport of exceptions between coordinating threads. Overall,
    there are many thread library features to consider; this is a vast topic.
  prefs: []
  type: TYPE_NORMAL
- en: The details for multithreaded programming are beyond the scope of this book;
    however, we can discuss scenarios within this book that may be augmented to require
    the knowledge of using threads. Let’s revisit some of those situations.
  prefs: []
  type: TYPE_NORMAL
- en: Multithreaded programming scenarios
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many programming scenarios that can benefit from the use of multithreaded
    programming. We will just mention a few that extend the ideas we have covered
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The Observer pattern may certainly be employed in multithreaded programming
    scenarios! In these instances, care must be used in the `Update()` and `Notify()`
    methods of `Observer` and `Subject`, respectively, to add synchronization and
    locking mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Smart pointers, such as `shared_ptr` and `weak_ptr`, can be used in multithreaded
    applications and already include the means to lock and synchronize access to shared
    resources via reference counting (and with the use of atomic library methods).
  prefs: []
  type: TYPE_NORMAL
- en: Objects related through association may arise with multithreaded programming
    or through shared memory regions. Any time access is conducted through a shared
    resource using multithreaded programming, mutexes (locks) should be employed to
    ensure mutual exclusivity to those shared resources.
  prefs: []
  type: TYPE_NORMAL
- en: Objects throwing exceptions that need to communicate with one another will need
    to include synchronization within catcher blocks or delegate exceptions to the
    `main()` program thread. Employing worker threads to communicate with the `main()`
    program thread is a typical design model. Utilizing shared memory is a means to
    store the data that will need to be shared between threads coordinating with a
    `throw` and `catch` of the exception itself. An instance of `std::exception_ptr`
    can be utilized with `std::current_exception()` to store an instance needing to
    be shared. This shared instance (between threads) can be rethrown to a participating
    thread using `std::rethrow_exception()`.
  prefs: []
  type: TYPE_NORMAL
- en: Multithreaded programming is a fascinating topic unto itself and requires in-depth
    understanding to utilize safely in C++. We’ve revisited a few areas in which thread
    safety considerations may complement areas we have covered in this book. It is
    highly recommended to delve deeply into thread safety in C++ before embarking
    on adding multithreaded programming to your code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s move forward to investigate how programming guidelines can add a
    necessary level of safety to C++ programming.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing core programming guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming guidelines are much more than a set of conventions to indicate how
    many spaces to indent or naming conventions for variables, functions, classes,
    data members, and member functions. A modern programming guideline is a covenant
    between programmers within an organization to create code adhering to specific
    standards, with the largest goal to provide robust and easily extensible code
    by following these common standards. The bottom line is that most of the conventions
    contained within a programming guideline are simply to make programming in C++
    safer.
  prefs: []
  type: TYPE_NORMAL
- en: The consensus of what comprises a C++ programming guideline may vary from organization
    to organization, but there are many resources available (including from standards
    committees) to provide examples and direction.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move forward to examine a sampling of programming guide essentials and
    then discuss adopting a core set of guidelines, as well as understanding resources
    widely available for programming safely in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Examining guideline essentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by examining a sampling of meaningful conventions to follow from
    a typical C++ programming guideline. We have examined many of these programming
    issues throughout the book, yet it is useful to review a few items to provide
    a starting point for choosing conventions to promote C++ safety.
  prefs: []
  type: TYPE_NORMAL
- en: Preferring initialization over assignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always choose initialization, whenever possible, over assignment. It’s simply
    more efficient and safer! Use in-class initialization or the member initialization
    list. When assignment is used after initialization, it can be less efficient.
    Imagine, for example, a member object that is default constructed, only to quickly
    overwrite its values with more suitable values via assignment in the body of the
    constructor. It would have been more efficient to utilize the member initialization
    list to initialize this member object via an alternate constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Also, neglecting to give each piece of memory an initial value can cost us dearly
    in terms of safety – memory in C++ is not clean, so it is truly inappropriate
    to interpret whatever is in an uninitialized variable (or data member) as valid.
    Accessing an uninitialized value is an undefined behavior. We truly never know
    what is lurking in uninitialized memory, but we know it is never the correct value
    to be used as an initializer!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review preferred initialization with a small program. This example can
    be found in our GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex5.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Examining the preceding code, we notice that the `Person` class uses in-class
    initialization to set the `middleInitial` data member to the null character (`'\0'`).
    For each instance of `Person`, `middleInitial` will be set to the null character
    prior to any constructor call that further initializes the instance in question.
    Notice that the other data members in the class are all of type `string`. Because
    `string` is a class itself, these data members are actually member objects of
    type `string` and will be default constructed, appropriately initializing each
    of these string members.
  prefs: []
  type: TYPE_NORMAL
- en: Next, notice that we opted not to provide a default (no argument) constructor,
    allowing the system-supplied default constructor to be linked in for us. In-class
    initialization, coupled with the appropriate member object initialization of the
    `string` members, left no additional initialization necessary for new `Person`
    instances, and hence no need for a programmer-specified default constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, notice our use of the member initialization list in the alternate constructor
    for `Person`. Here, each data member is set with an appropriate value from the
    parameter list of this method. Notice that every data member is set via initialization,
    leaving no assignments necessary in the body of the alternate constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our preceding code follows the popular code guideline: whenever possible, always
    opt to set values via initialization versus assignment. Knowing that each data
    member has an appropriate value during construction leads us to provide a safer
    code. Initialization is also more efficient than assignment.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s consider another core C++ guideline relating to virtual functions.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing one of virtual, override, or final
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Polymorphism is a wonderful concept that C++ easily supports with the use of
    virtual functions. We learned in [*Chapter 7*](B19087_07.xhtml#_idTextAnchor366),
    *Utilizing Dynamic Binding through Polymorphism*, that the keyword `virtual` is
    used to indicate a polymorphic operation – an operation that may be overridden
    by derived classes with a preferred method. Derived classes are not obligated
    to override a polymorphic operation (virtual function) by providing a new method,
    but may find it meaningful to do so.
  prefs: []
  type: TYPE_NORMAL
- en: When a derived class chooses to override a virtual function introduced by a
    base class with a new method, the overridden method may use both the keywords
    `virtual` and `override` in the signature of the method. However, it is a convention
    to use only `override` at this overridden (derived class) level.
  prefs: []
  type: TYPE_NORMAL
- en: When a virtual function is introduced in the hierarchy, it may be desirable
    at some point to indicate that a certain method is the *final* implementation
    of this operation. That is, the operation in question may no longer be overridden.
    We know that it is appropriate to apply the `final` specifier to the virtual function
    at this level of the hierarchy to indicate that a given method may no longer be
    overridden. Though we may also include the keyword `virtual` at this level as
    well, it is recommended to only utilize `final`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, when specifying a virtual function, only choose one label at each
    level: `virtual`, `override`, or `final` – even though the keyword `virtual` can
    be added to complement `override` and `final`. By doing so, it will be much clearer
    if the virtual function at hand is newly introduced (`virtual`), an overridden
    method of a virtual function (`override`), or the final method of a virtual function
    (`final`). Clarity causes fewer errors to occur and that helps make C++ safer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review the preferred keyword usage with virtual functions with a program
    segment. The complete example can be found in our GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter21/Chp21-Ex6.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we see our `Person` class that we have carried forward
    throughout the book. As a base class, notice that `Person` specifies polymorphic
    operations of `Print()`, `IsA()`, and `Greeting()`, as well as the destructor
    using the `virtual` keyword. These operations are intended to be overridden by
    a derived class with more suitable methods (not including the destructor), but
    are not required to be overridden should the derived class find the base class
    implementation suitable.
  prefs: []
  type: TYPE_NORMAL
- en: In the derived class, `Student`, we override `IsA()` with a more suitable method.
    Notice that we use `override` in the signature of this function, though we could
    have also included `virtual`. Next, notice that we have chosen not to override
    `Greeting()` at the `Student` level; we can assume that `Student` finds the implementation
    in `Person` acceptable. Also notice that the destructor is overridden to provide
    the entry point to the destruction chain. Recall with a destructor that not only
    is the derived class destructor called, but the base class destructor will also
    be called (implicitly as the last line of code in the derived class destructor),
    allowing the object’s full destruction sequence to properly commence.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, notice that `Print()` has been overridden as `final` in `Student`.
    Though we could have added `override` to the signature of this function as well,
    we choose to only utilize `final` per the recommended coding convention.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at another typical element in a typical C++ programming set
    of guidelines, relating to smart pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Preferring smart pointers in new code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have utilized many native (raw) C++ pointers in this book, as you will undoubtedly
    be asked to immerse yourself in existing code in which they are plentiful. Having
    native pointer experience and facility will make you a safer programmer when asked
    to step into situations that use native pointers.
  prefs: []
  type: TYPE_NORMAL
- en: However, for safety’s sake, most programming guides will recommend using smart
    pointers exclusively in newly created code. After all, their use adds little overhead
    and can help eliminate many of the potential pitfalls of managing heap memory
    by the programmer. Smart pointers also aid in exception safety. For example, exception
    handling implies that the expected flow of code may be interrupted at nearly any
    time, leading to potential memory leaks with traditional pointer usage. Smart
    pointers can alleviate some of this burden and provide for exception safety.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using smart pointers is so important in original code that this point is worth
    repeating: choosing smart pointers over native pointers leads to safer and far
    easier to maintain code in C++. The code will also be easier to write, eliminating
    the need for many destructors, automatically blocking undesired copies and assignment
    (`unique_ptr`), and so on. With that in mind, whenever possible, choose smart
    pointers in newly created code.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen smart pointers in this book as well as native pointers. Now, you
    can choose to use smart pointers in the new code that you create – this is highly
    recommended. Certainly, there may be some scenarios when this is not possible;
    perhaps you are creating new code that interfaces heavily with existing native
    pointer code and need to utilize the same data structures. Nonetheless, you can
    strive to use smart pointers, when possible, yet you have the flexibility and
    experience to understand the vast amounts of existing code, libraries, and online
    examples that exist utilizing native pointers.
  prefs: []
  type: TYPE_NORMAL
- en: What could be better for safety than to have the facility of smart pointers
    for your original code, paired with the knowledge of native pointers to use only
    when necessary?
  prefs: []
  type: TYPE_NORMAL
- en: There are many examples of programming guidelines that can be easily followed
    to make your code safer. The aforementioned examples are just a few of many to
    illustrate the types of practices you will expect to see in a set of essential
    C++ programming guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s consider how we can assemble or adopt core programming guidelines
    to help make our code safer.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting a programming guideline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether you build or assemble a set of programming guidelines yourself or adhere
    to a set governed by an organization you are a member of, adopting a core set
    of C++ programming guidelines is crucial to ensure your code is as safe and robust
    as possible, translating to more easily maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines should always remain fluid as the language evolves. Let’s next consider
    resources for finding core C++ programming guidelines to either follow directly
    or to revisit incrementally to improve the accepted guidelines within your organization.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding resources for programming safely in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many online resources for programming guidelines in C++. The essential
    resource, however, is the *ISO C++ Core Guidelines*, assembled primarily by Bjarne
    Stroustrup and Herb Sutter, which can be found at the following GitHub URL: [https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md).
    Their collective goal is to help programmers use modern C++ safely and more effectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Selected market sectors may have guidelines imposed upon them to obtain or ensure
    certification within an industry. For example, **MISRA** is a set of C++ coding
    standards for the **Motor Industry Software Reliability Association**; MISRA has
    also been adopted as a standard across other industries, such as for medical systems.
    Another coding standard, developed for embedded systems, is **CERT**, developed
    at **Carnegie Mellon University** (**CMU**). Once an acronym for **Computer Emergency
    Response Team**, CERT is now a registered trademark of CMU. CERT has been adopted
    in many financial sectors as well. **JSF AV C++** (**Joint Strike Fighter Air
    Vehicle C++**) is a C++ coding standard used in the aerospace engineering domain,
    developed by Lockheed Martin, to ensure error-free code for safety-critical systems.
  prefs: []
  type: TYPE_NORMAL
- en: Undoubtedly, each organization you join as a contributor will have a base set
    of programming guidelines for all programmers in the group to follow. If not,
    a wise move will be to suggest employing a core set of C++ programming guidelines.
    After all, you will need to help maintain your own code as well as the code of
    your colleagues; a uniform and expected set of standards will make this endeavor
    manageable for everyone involved.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this bonus chapter, we have added to our objective of becoming indispensable
    C++ programmers by understanding the importance of programming safely in C++.
    After all, our primary goal is to create robust and easily maintainable code.
    Incorporating safe programming practices will help us achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: We have reviewed concepts seen throughout the book, as well as related ideas
    that culminate in adopting a set of core programming guidelines to ensure safer
    coding practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we reviewed smart pointers, examining three types from the Standard
    C++ Library, namely `unique_ptr`, `shared_ptr`, and `weak_ptr`. We understand
    that these classes employ the RAII idiom by providing wrappers to allocate and
    deallocate heap memory safely on our behavior in well-tested standard library
    classes. We put forth a guideline: always prefer smart pointers in newly created
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we reiterated a variety of programming practices that we have seen throughout
    the book that we can employ to make our coding safer overall. For example, preferring
    for-each style loops and using `auto` for type safety. Also, using STL containers
    versus less robust native mechanisms, and also adding the `const` qualifier for
    data and methods to ensure read-only access when so needed. These practices are
    examples (among many) that can help ensure our code is as safe as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we introduced multithreaded programming in C++ and reviewed programming
    scenarios we have seen previously that may benefit from the use of threads. We
    also took a look ahead at the classes available in the Standard C++ Library in
    support of multithreaded programming, including those that provide synchronization,
    mutex locks, semaphores, and creating atomic types.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we examined programming guideline essentials to better understand rules
    that may be beneficial in a C++ core programming guide. For example, we reviewed
    preferring initialization over the assignment, virtual function usage with regard
    to the keywords `virtual`, `override`, and `final`, as well as previously examined
    topics from this chapter. We talked about the importance of adopting a comprehensive
    set of core programming guidelines for C++ as well as resources to find sample
    guidelines used as industry standards.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to make C++ safer as you apply the many features covered in
    the book will undoubtedly make you a more valuable programmer. You now have core
    language skills plus a very solid understanding of OOP in C++ (essential concepts
    and how to implement them in C++ with either direct language support or using
    programming techniques). We have augmented your skills with knowledge of exception
    handling, friends, operator overloading, templates, STL basics, and testing OO
    classes and components. We have also embraced core design patterns, delving into
    each pattern with comprehensive programming examples. Finally in this chapter,
    we have reviewed how to safely put together the knowledge you have learned by
    choosing to employ safer programming practices at each available opportunity.
  prefs: []
  type: TYPE_NORMAL
- en: As we wrap up our bonus chapter together, you are now ready to journey further
    on your own, applying C++ to many new and existing applications. You are ready
    to create safe, robust, and easy to maintain code. I am sincerely hopeful that
    you are as intrigued by C++ as I am. Once again, let’s get programming!
  prefs: []
  type: TYPE_NORMAL
- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The programming solution for each chapter’s questions can be found in our GitHub
    repository at the following URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main).
    Each full program solution can be found in our GitHub repository in the subdirectory
    Assessments , and then under the appropriate chapter heading (subdirectory, such
    as `Chapter01`), in a file that corresponds to the chapter number, followed by
    a dash, followed by the solution number in the chapter at hand. For example, the
    solution for *Question 3* in [*Chapter 1*](B19087_01.xhtml#_idTextAnchor016),
    *Understanding Basic C++ Assumptions*, can be found in the subdirectory `Assessments/Chapter01`
    in a file named `Chp1-Q3.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: The written responses for non-programming questions can be found in the following
    sections, organized by chapter, as well as in the aforementioned GitHub in the
    appropriate Assessments subdirectory for a given chapter. For example, `Assessments/Chapter01/Chp1-WrittenQs.pdf`
    will contain the answers to the non-programming solutions for [*Chapter 1*](B19087_01.xhtml#_idTextAnchor016),
    *Understanding Basic C++ Assumptions*. Should an exercise have a programming portion
    and a follow-up question to the program, the answer to the follow-up question
    may be found both in the next sections (as well as in the aforementioned `.pdf`
    file) and in a comment at the top of the programming solution in GitHub (as it
    may be appropriate to review the solution in order to fully understand the answer
    to the follow-up question).
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1, Understanding Basic C++ Assumptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `flush` may be useful, rather than and `endl`, for clearing the contents of
    a buffer associated with `cout` for the situations where you do not wish the cursor
    to be advanced to the next line for output. Recall, an `endl` manipulator is merely
    a newline character plus a buffer flush.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choosing a pre versus a post increment for a variable, such as `++i` (versus
    `i++`) will have an impact on the code when used in conjunction with a compound
    expression. A typical example would be `result = array[i++];` versus `result =
    array[++i];`. With the post-increment (`i++`) the contents of `array[i]` will
    be assigned to `result` and then `i` is incremented. With the pre-increment, `i`
    is first incremented and then `result` will have the value of `array[i]` (that
    is, using the new value of `i` as an index).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see `Assessments/Chapter01/Chp1-Q3.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 2, Adding Language Necessities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The signature of a function is the function’s name plus its type and number
    of arguments (no return type). This relates to name mangling as the signature
    helps the compiler provide a unique, internal name for each function. For example,
    `void Print(int, float);` may have mangled name of `Print_int_float();`. This
    facilitates overloaded functions by giving each function a unique name so that
    when a call is made, it is evident by the internal function name as to which function
    is being invoked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a – d. Please see `Assessments/Chapter02/Chp2-Q2.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 3, Indirect Addressing: Pointers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: a – f. Please see `Assessments/Chapter03/Chp3-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d. (follow-up question) `Print(Student)` is less efficient than `Print(const
    Student *)` as the initial version of this function passes an entire object on
    the stack, whereas the overloaded version passes only a pointer on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we have an existing pointer to an object of type `Student`, such as:
    `Student *s0 = new Student`; (this `Student` is not yet initialized with data)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `const Student *s1;` (does not require initialization)
  prefs: []
  type: TYPE_NORMAL
- en: b. `Student *const s2 = s0;` (requires initialization)
  prefs: []
  type: TYPE_NORMAL
- en: c. `const Student *const s3 = s0;` (also requires initialization)
  prefs: []
  type: TYPE_NORMAL
- en: Passing an argument of type `const Student *` to `Print()` would allow a pointer
    to a `Student` to be passed into `Print()` for speed, yet the object pointed to
    could not be dereferenced and modified. Yet passing a `Student * const` as a parameter
    to `Print()` would not make sense because a copy of the pointer would be passed
    to `Print()`. Marking that copy additionally as `const` (meaning not allowing
    changing where the pointer points) would then be meaningless, as disallowing a
    *copy* of a pointer to be changed has no effect on the original pointer itself.
    The original pointer was never in jeopardy of its address being changed within
    the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are many programming situations that might use a dynamically allocated
    3-D array. For example, if an image is stored in a 2-D array, a collection of
    images might be stored in a 3-D array. Having a dynamically allocated 3-D array
    allows for any number of images to be read in from a filesystem and stored internally.
    Of course, you’d need to know how many images you’ll be reading in before making
    the 3-D array allocation. For example, a 3-D array might hold 30 images, where
    30 is the third dimension to collect the images in a set. To conceptualize a 4-D
    array, perhaps you would like to organize sets of the aforementioned 3-D arrays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, perhaps you have a set of 31 images for the month of January. That
    set of January images is a 3-D array (2-D for the image and the third dimension
    for the set of 31 images comprising January). You may wish to do the same for
    every month. Rather than having separate 3-D array variables for each month’s
    image set, we can create a fourth dimension to collect the years’ worth of data
    into one set. The fourth dimension would have an element for each of the 12 months
    of the year. How about a 5-D array? You can extend this image idea by making the
    fifth dimension a way to collect various years of data, such as collecting images
    for a century (fifth dimension). Now we have images organized by century, then
    organized by year, then month, then by image (the image requiring the first two
    dimensions).
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 4, Indirect Addressing: References'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: a – c. Please see `Assessments/Chapter04/Chp4-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c. (follow-up question) Pointer variables need not only call the version of
    `ReadData(Student *)` that accepts a pointer to a `Student` and reference variables
    need not only call the version of `ReadData(Student &)` that accepts a reference
    to a `Student`. For example, a pointer variable may be dereferenced with `*` and
    then call the version that accepts a reference. Likewise, a reference variable
    may have its address taken using `&` and then call the version that accepts a
    pointer (though this is less commonly done). You simply need to make the data
    types match with respect to what you are passing and what the function expects.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5, Exploring Classes in Detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: a – e. Please see `Assessments/Chapter05/Chp5-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 6, Implementing Hierarchies with Single Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: a – d. Please see `Assessments/Chapter06/Chp6-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a – c. (Optional) Please see `Chapter06/Assessments/Chp6-Q2.cpp` in the GitHub
    repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7, Utilizing Dynamic Binding through Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: a – e. Please see `Assessments/Chapter07/Chp7-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 8, Mastering Abstract Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: a – d. Please see `Assessments/Chapter08/Chp8-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: e. Depending on your implementation, your `Shape` class may or may not be considered
    an interface class. If your implementation is an abstract class that contains
    no data members and only abstract methods (pure virtual functions), your `Shape`
    implementation is considered an interface class. If your `Shape` class, however,
    stores `area` as a data member once it has been calculated by the overridden `Area()`
    method in the derived classes, it is then just an abstract base class.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9, Exploring Multiple Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please see `Assessments/Chapter09/Chp9-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. There is one `LifeForm` subobject.
  prefs: []
  type: TYPE_NORMAL
- en: b. The `LifeForm` constructor and destructor are each invoked once.
  prefs: []
  type: TYPE_NORMAL
- en: c. The default constructor for `LifeForm` would be invoked if the specification
    of an alternate constructor of `LifeForm(1000)` was removed from the member initialization
    list of the `Centaur` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Please see the `Assessments/Chapter09/Chp9-Q2.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. There are two `LifeForm` sub-objects.
  prefs: []
  type: TYPE_NORMAL
- en: b. The `LifeForm` constructor and destructor are each invoked twice.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10, Implementing Association, Aggregation, and Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please see `Assessments/Chapter10/Chp10-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (follow-up question) Once you have overloaded a constructor that accepts a `University
    &` as a parameter, this version may be invoked using a `University *` by first
    dereferencing the pointer to the `University` within the constructor call (to
    make a referenceable object).
  prefs: []
  type: TYPE_NORMAL
- en: a – f. Please see `Assessments/Chapter10/Chp10-Q2.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a – b. (optional) Please see `Assessments/Chapter10/Chp10-Q3.cpp` in the GitHub
    repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 11, Handling Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: a – c. Please see `Assessments/Chapter11/Chp11-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 12, Friends and Operator Overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please see `Assessments/Chapter12/Chp12-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see `Assessments/Chapter12/Chp12-Q2.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see `Assessments/Chapter12/Chp12-Q3.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 13, Working with Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: a – b. Please see `Assessments/Chapter13/Chp13-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see `Assessments/Chapter13/Chp13-Q2.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 14, Understanding STL Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: a – b. Please see `Assessments/Chapter14/Chp14-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see `Assessments/Chapter14/Chp14-Q2.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see `Assessments/Chapter14/Chp14-Q3.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see `Assessments/Chapter14/Chp14-Q4.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 15, Testing Classes and Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: a. Your classes follow orthodox canonical class form if they each include a
    (user-specified) default constructor, copy constructor, overloaded assignment
    operator, and a virtual destructor. Your classes additionally follow extended
    canonical class form if they also include a move copy constructor and an overloaded
    move assignment operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b. Your class will be considered robust if it follows canonical class form and
    ensures that all instances of a class have the means to be fully constructed.
    Testing a class can ensure robustness.
  prefs: []
  type: TYPE_NORMAL
- en: a – c. Please see `Assessments/Chapter15/Chp15-Q2.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see `Assessments/Chapter15/Chp15-Q3.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 16, Using the Observer Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: a – b. Please see `Assessments/Chapter16/Chp16-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other examples which may easily incorporate the Observer pattern include any
    application requiring customers to receive notification of backordered products
    that they desire. For example, many people may wish to receive the Covid-19 vaccine
    and wish to be on a waiting list at a vaccine distribution site. Here, a `VaccineDistributionSite`
    (the subject of interest) can be inherited from `Subject` and contain a list of
    `Person` objects, where `Person` inherits from `Observer`. The `Person` objects
    will contain a pointer to the `VaccineDistributionSite`. Once enough supply for
    the vaccine exists at a given `VaccineDistributionSite` (that is, a distribution
    event has occurred), `Notify()` can be called to update the `Observer` instances
    (people on the waitlist). Each `Observer` will be sent an `Update()`, which will
    be the means to allow that person to schedule an appointment. If the `Update()`
    returns success and the `Person` has been scheduled for an appointment, the `Observer`
    can release itself from the waiting list with the `Subject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 17, Applying the Factory Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: a – b. Please see `Assessments/Chapter17/Chp17-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other examples which may easily incorporate the Factory Method pattern include
    many types of applications in which various derived classes may need to be instantiated
    based upon the specific values provided at construction. For example, a payroll
    application may require various types of `Employee` instances, such as `Manager`,
    `Engineer`, `Vice-President`, and so on. A factory method can provide a way to
    instantiate the various types of `Employee` based on the information provided
    when the `Employee` is hired. The Factory Method pattern is a pattern that can
    be applied to many types of applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 18, Applying the Adapter Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: a – b. Please see `Assessments/Chapter18/Chp18-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other examples which may easily incorporate the Adapter pattern include many
    examples of repurposing existing, well tested non-OO code to provide an OO interface
    (that is, a wrapper type of Adapter). Other examples include creating an Adapter
    to convert a formerly used class into a currently needed class (again with the
    idea of reusing previously created and well-tested components). An example is
    to adapt a `Car` class that has been previously used to represent gasoline engine
    cars into a class that models an `ElectricCar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 19, Using the Singleton Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: a – c. Please see `Assessments/Chapter19/Chp19-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We cannot label the `static instance()` method as virtual in `Singleton` and
    override it in `President`, simply because static methods can never be virtual.
    They are statically bound, and never receive a `this` pointer. Also, the signature
    may need to be different (and no one likes an un-intentional function hiding situation).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other examples which may easily incorporate the Singleton pattern include creating
    a Singleton `CEO` of a company, a Singleton `TreasuryDepartment` for a country,
    or a Singleton `Queen` of a nation. Each of these Singleton instances offers the
    opportunity to establish a registry to keep track of multiple Singleton objects.
    That is, many countries may have a single `Queen`. In this case, the registry
    would allow not just one Singleton per object type, but one Singleton per other
    qualifiers, such as *nation*. This is an example of the rare case in which more
    than one Singleton object of a given type can occur (but always a controlled number
    of such objects).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 20, Removing Implementation Details Using the pImpl Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please see `Assessments/Chapter20/Chp20-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see `Assessments/Chapter20/Chp20-Q2.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (follow-up question) In this chapter, simply inheriting `Student` from the `Person`
    class that embraces the pImpl pattern presents no logistical difficulties. Additionally,
    modifying the `Student` class to also employ the pImpl pattern and utilize a unique
    pointer is more challenging. Various approaches may run across various difficulties,
    including dealing with inline functions, down-casting, avoiding explicit calls
    to the underlying implementation, or requiring back pointers to help invoke virtual
    functions. Please see the online solution for details.
  prefs: []
  type: TYPE_NORMAL
- en: Other examples which may easily incorporate the pImpl pattern for relative implementation
    independence include creating generic GUI components, such as for `Window`, `Scrollbar`,
    `Textbox`, and so on, for various platforms (derived classes). The implementation
    details can easily be hidden. Another example could be proprietary commercial
    classes in which the developer wishes to hide the implementation details that
    might otherwise be seen in a header file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
