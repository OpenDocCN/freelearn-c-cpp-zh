<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-368"><a id="_idTextAnchor404"/>18</h1>
<h1 id="_idParaDest-369"><a id="_idTextAnchor405"/>Using Gameplay Framework Classes in Multiplayer</h1>
<p>In the previous chapter, we covered <strong class="bold">remote procedure calls</strong> (<strong class="bold">RPCs</strong>), which allow the server and the clients to execute remote functions on each other. We also covered enumerations and array index wrapping, which allow you to iterate an array in both directions and loop around when you go beyond its limits.</p>
<p>In this chapter, we’re going to look at the most common gameplay framework classes and see where their instances exist in a multiplayer environment. This is important to understand so that you know which instances can be accessed in a specific game instance. An example of this is that only the server should be able to access the game mode instance because you don’t want clients to be able to modify the rules of the game.</p>
<p>We’ll also cover the game state and player state classes, which, as their names imply, store information about the state of the game and each player, respectively. Finally, toward the end of this chapter, we’ll cover some new concepts in the game mode, as well as some useful built-in functionality.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Accessing Gameplay Framework instances in multiplayer</li>
<li>Using Game Mode, Player State, and Game State</li>
</ul>
<p>By the end of this chapter, you’ll understand where the instances of the most important Gameplay Framework classes exist in multiplayer, as well as how the game state and player state store information that can be accessed by any client. You’ll also know how to make the most out of the Game Mode class and other useful built-in functionality.</p>
<h1 id="_idParaDest-370"><a id="_idTextAnchor406"/>Technical requirements</h1>
<p>This chapter has the following technical requirements:</p>
<ul>
<li>Unreal Engine 5 installed</li>
<li>Visual Studio 2019 installed</li>
</ul>
<p>The project for this chapter can be found in the <code>Chapter18</code> folder of the code bundle for this book, which can be downloaded here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition</a>.</p>
<p>In the next section, we will learn how to access the gameplay framework instances in multiplayer.</p>
<h1 id="_idParaDest-371"><a id="_idTextAnchor407"/>Accessing Gameplay Framework Instances in Multiplayer</h1>
<p>Unreal Engine comes with a set<a id="_idIndexMarker1569"/> of built-in classes (the Gameplay Framework) that provide the common functionality that most games require, such as a way to define the game rules (game mode), a way to control a <a id="_idIndexMarker1570"/>character (the player controller and pawn/character class), and so on. When an instance of a gameplay framework class is created in a multiplayer environment, we need to know if it exists on the server, the clients, or the owning client. With that in mind, an instance of the gameplay framework class will always fall into one of the following categories:</p>
<ul>
<li><strong class="bold">Server Only</strong>: The instance will only exist on the server.</li>
<li><strong class="bold">Server and Clients</strong>: The instance will exist on the server and the clients.</li>
<li><strong class="bold">Server and Owning Client</strong>: The instance will exist on the server and the owning client.</li>
<li><strong class="bold">Owning Client Only</strong>: The instance will only exist on the owning client.</li>
</ul>
<p>Take a look at the following diagram, which shows each category and where the most common classes in the <a id="_idIndexMarker1571"/>gameplay framework fall into:</p>
<div><div><img alt="Figure 18.1 – The most common gameplay framework classes divided into categories " height="555" src="img/Figure_18.01_B18531.jpg" width="1104"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.1 – The most common gameplay framework classes divided into categories</p>
<p>Let’s look at each <a id="_idIndexMarker1572"/>class in the preceding diagram in more detail:</p>
<ul>
<li><code>Game Mode</code> class defines the rules of the game and its instance can only be accessed by the server. If a client tries to access it, the instance will always be invalid, to prevent clients from changing the game rules.</li>
<li><strong class="bold">Game State (Server and Clients)</strong>: The Game State class stores the state of the game and its instance can be accessed both by the server and the clients. The game state will be covered in greater depth in the next topic.</li>
<li><strong class="bold">Player State (Server and Clients)</strong>: The Player State class stores the state of a player and its instance can be accessed both by the server and the clients. The player state will be covered in greater depth in the next topic.</li>
<li><code>Pawn</code> class is the visual representation of a player and its instance can be accessed by the server and the clients.</li>
<li><code>Player Controller</code> class represents the intent of a player, which is relayed to the currently possessed pawn, and its instance can only be accessed on the server and the owning client. For <a id="_idIndexMarker1573"/>security reasons, clients can’t access other clients’ player controllers, so they should use the server to communicate. If a client calls the <code>UGameplayStatics::GetPlayerController</code> function with an index other than <code>0</code> (which would return its player controller), the returned instance will always be invalid. This means that the server is the only place that has access to all of the player controllers. You can find out whether a player controller instance is in its owning client by calling the <code>AController::IsLocalController</code> function.</li>
<li><strong class="bold">HUD (Owning Client Only)</strong>: The HUD class is used as an immediate mode to draw basic shapes and text on the screen. Since it’s used for the UI, its instance is only available on the owning client, because the server and the other clients don’t need to know about it.</li>
<li><strong class="bold">UMG Widgets (Owning Client Only)</strong>: The UMG widget classes are used to display complex UI on the screen. Since it’s used for the UI, its instance is only available on the owning client, because the server and the other clients don’t need to know about it.</li>
</ul>
<p>To help you understand these concepts, we will use <em class="italic">Dota 2</em> as an example:</p>
<ul>
<li>The game mode defines that there are different phases of the game (pre-game for hero picking, the actual game, and the post-game phase with the winner) and that the end goal is to destroy the other team’s ancient. Since the game mode is a class that is critical to gameplay, clients can’t be allowed to access it.</li>
<li>The game state stores the elapsed time, whether it’s day or night, the score of each team, and so on, so the server and the clients need to be able to access it.</li>
<li>The player state stores the name, the hero selected, and the kill/death/assist ratio of a player, so the server and the clients need to be able to access it.</li>
<li>The pawn would be the hero, the courier, the illusions, and so on, controlled by the player, so the server <a id="_idIndexMarker1574"/>and the clients need to be able to access it.</li>
<li>The player controller is what relays the input information to the controlled pawn, so only the server and the owning client need to be able to access it.</li>
<li>The UI classes (<code>HUD</code> and <code>User Widget</code>) display all of the information on the owning client, so it only needs to be accessed there.</li>
</ul>
<p>In the next exercise, you will display the instance values of the most common gameplay framework classes.</p>
<h2 id="_idParaDest-372"><a id="_idTextAnchor408"/>Exercise 18.01 – Displaying the Gameplay Framework instance values</h2>
<p>In this exercise, we’re <a id="_idIndexMarker1575"/>going to create a new C++ project that uses the <strong class="bold">Third Person</strong> template, and we’re going to add the following:</p>
<ul>
<li>On the owning client, the player controller creates and adds a simple UMG widget to the viewport that displays the name of the menu instance.</li>
<li>On the <code>Tick</code> function, the character displays the value of its instance (as a pawn), as well as whether it has a valid instance for the game mode, game state, player state, player controller, and HUD.</li>
</ul>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li>Create a new <code>GFInstances</code> (as in Gameplay Framework Instances) and save it to a location of your liking. Once the project has been created, it should open the editor as well as the Visual Studio solution.</li>
<li>In the editor, create a new <code>C++</code> class called <code>GFInstancePlayerController</code> that derives from <code>PlayerController</code>. Wait for the compilation to end, close the editor, and go back to Visual Studio.</li>
<li>Open the <code>GFInstancesCharacter.h</code> file and declare the protected override for the <code>Tick</code> function:<pre>virtual void Tick(float DeltaSeconds) override;</pre></li>
<li>Open the <code>GFInstancesCharacter.cpp</code> file and<a id="_idIndexMarker1576"/> implement the <code>Tick</code> function:<pre>void AGFInstancesCharacter::Tick(float DeltaSeconds)
{
  Super::Tick(DeltaSeconds);
}</pre></li>
<li>Get the instances for the game mode, game state, player controller, and HUD:<pre>const AGameModeBase* GameMode = GetWorld()-&gt;GetAuthGameMode();
const AGameStateBase* GameState = GetWorld()-&gt;GetGameState();
const APlayerController* PlayerController = 
  Cast&lt;APlayerController&gt;(GetController());
const AHUD* HUD = PlayerController != nullptr ? PlayerController-&gt;GetHUD() : nullptr;</pre></li>
</ol>
<p>In the preceding code snippet, we stored the instances for the game mode, game state, player controller, and HUD in separate variables so that we can check whether they are valid.</p>
<ol>
<li value="6">Create a string for each gameplay framework class:<pre>const FString GameModeString = GameMode != nullptr ? 
  TEXT("Valid") : TEXT("Invalid");
const FString GameStateString = GameState != nullptr ? 
  TEXT("Valid") : TEXT("Invalid");
const FString PlayerStateString = GetPlayerState() != nullptr ? TEXT("Valid") : TEXT("Invalid");
const FString PawnString = GetName();
const FString PlayerControllerString = PlayerController != nullptr ? TEXT("Valid") : TEXT("Invalid");
const FString HUDString = HUD != nullptr ? TEXT("Valid"):
  TEXT("Invalid");</pre></li>
</ol>
<p>Here, we have created<a id="_idIndexMarker1577"/> strings to store the name of the pawn and checked whether the other gameplay framework instances are valid.</p>
<ol>
<li value="7">Display each string on the screen:<pre>const FString String = FString::Printf(TEXT("Game Mode = %s\nGame 
  State = %s\nPlayerState = %s\nPawn = %s\nPlayer Controller = 
  %s\nHUD = %s"), *GameModeString, *GameStateString, 
  *PlayerStateString, *PawnString, 
  *PlayerControllerString, 
  *HUDString);
DrawDebugString(GetWorld(), GetActorLocation(), String, nullptr, FColor::White, 0.0f, true);</pre></li>
</ol>
<p>In the preceding code snippet, we have printed the strings that indicate the name of the pawn and whether the other gameplay framework instances are valid.</p>
<ol>
<li value="8">Before we can move <a id="_idIndexMarker1578"/>on to the <code>AGFInstancesPlayerController</code> class, we need to tell Unreal Engine that we want to use the UMG functionality so that we can use the <code>UUserWidget</code> class. To do this, we need to open <code>GFInstances.Build.cs</code> and add <code>UMG</code> to the <code>PublicDependencyModuleNames</code> string array, like so:<pre>PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "HeadMountedDisplay", "UMG" });</pre></li>
</ol>
<p>If you try to compile and get errors from adding the new module, then clean and recompile your project. If that doesn’t work, try restarting your IDE.</p>
<ol>
<li value="9">Open <code>GFInstancesPlayerController.h</code> and add the protected variables to create the UMG widget:<pre>UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "GF Instance Player Controller")
TSubclassOf&lt;UUserWidget&gt; MenuClass;
UPROPERTY()
UUserWidget* Menu;</pre></li>
<li>Declare the protected override for the <code>BeginPlay</code> function:<pre>virtual void BeginPlay() override;</pre></li>
<li>Open <code>GFInstancesPlayerController.cpp</code> and include <code>UserWidget.h</code>:<pre>#include "Blueprint/UserWidget.h"</pre></li>
<li>Implement the <code>BeginPlay</code> function:<pre>void AGFInstancePlayerController::BeginPlay()
{
  Super::BeginPlay();
}</pre></li>
<li>Create the widget and <a id="_idIndexMarker1579"/>add it to the viewport if it’s a local controller and the <code>MenuClass</code> variable is valid:<pre>if (IsLocalController() &amp;&amp; MenuClass != nullptr)
{
  Menu = CreateWidget&lt;UUserWidget&gt;(this, MenuClass);
  if (Menu != nullptr)
  {
    Menu-&gt;AddToViewport(0);
  }
}</pre></li>
<li>Compile and run the code.</li>
<li>In the <code>Content</code> folder, create a new folder called <code>UI</code>, and open it.</li>
<li>Create a new widget blueprint called <code>WBP_Menu</code> and open it.</li>
<li>Add a <code>Canvas Panel</code> to the <strong class="bold">Hierarchy</strong> panel.</li>
<li>Add a <code>Name</code> to the <strong class="bold">canvas panel</strong> and set it to be a variable.</li>
<li>Change the text block <code>true</code>.</li>
<li>Go to the <code>Event Construct</code> in the following manner:</li>
</ol>
<div><div><img alt="Figure 18.2 – The Event Construct that displays the name of the WBP_Menu instance " height="241" src="img/Figure_18.02_B18531.jpg" width="833"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.2 – The Event Construct that displays the name of the WBP_Menu instance</p>
<ol>
<li value="21">Save and <a id="_idIndexMarker1580"/>close <code>WBP_Menu</code>.</li>
<li>Go to the <code>Content</code> folder and create a blueprint called <code>BP_PlayerController</code> that derives from <code>GFInstancesPlayerController</code>.</li>
<li>Open <code>BP_PlayerController</code> and set <code>Menu Class</code> to use <code>WBP_Menu</code>.</li>
<li>Save and close <code>BP_PlayerController</code>.</li>
<li>Create a blueprint called <code>BP_GameMode</code> that derives from <code>GFInstancesGameMode</code>.</li>
<li>Open <code>BP_GameMode</code> and set <code>Player Controller Class</code> to use <code>BP_PlayerController</code>.</li>
<li>Save and close <code>BP_GameMode</code>.</li>
<li>Go to <strong class="bold">World Settings</strong>, set <strong class="bold">GameMode Override</strong> to <strong class="bold">None</strong>, and save the map.</li>
<li>Go to <strong class="bold">Project Settings</strong> and pick <strong class="bold">Maps &amp; Modes</strong> from the left panel, which can be found in the <strong class="bold">Project</strong> category.</li>
<li>Set the <code>Default</code> Game Mode to use <code>BP_GameMode</code>.</li>
<li>Close <strong class="bold">Project Settings</strong>.</li>
</ol>
<p>Finally, you can test the project.</p>
<ol>
<li value="32">Go to <code>2</code>.</li>
<li>Set the window <a id="_idIndexMarker1581"/>sizes to <code>800x600</code> and play using <strong class="bold">New Editor Window (PIE)</strong>.</li>
</ol>
<p>You should get the following output:</p>
<div><div><img alt="Figure 18.3 – Expected result on the Server and Client 1 windows " height="640" src="img/Figure_18.03_B18531.jpg" width="1612"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.3 – Expected result on the Server and Client 1 windows</p>
<p>Now that you’ve completed this exercise, you’ll notice that each character displays its name, as well as if the instances for the game mode, game state, player state, player controller, and HUD are valid. It also displays the instance name of the <code>WBP_Menu</code> UMG widget in the top-left corner of the screen.</p>
<p>Now, let’s analyze the values that are displayed in the Server and Client 1 windows.</p>
<p class="callout-heading">Note</p>
<p class="callout">The two figures for the Server and Client 1 window will have two text blocks that say <code>Server Character</code> and <code>Client 1 Character</code>. These were added to the original screenshot to help <a id="_idIndexMarker1582"/>you understand which character i<a id="_idTextAnchor409"/>s which.</p>
<h2 id="_idParaDest-373"><a id="_idTextAnchor410"/>Output for the Server window</h2>
<p>Have a look at the<a id="_idIndexMarker1583"/> following output of the <code>Server</code> window from the previous exercise:</p>
<div><div><img alt="Figure 18.4 – The Server window " height="640" src="img/Figure_18.04_B18531.jpg" width="806"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.4 – The Server window</p>
<p>In the preceding screenshot, you have the values for <code>Server Character</code> and <code>Client 1 Character</code>. The <code>WBP_Menu</code> UMG widget is displayed in the top-left corner and is only created for the player controller of <code>Server Character</code> since it’s the only player controller in this window that controls a character.</p>
<p>First, let’s analyze the values for <code>Server Ch<a id="_idTextAnchor411"/>aracter</code>.</p>
<h3>Server Character</h3>
<p>This is the character that the listen server is controlling. The values that are displayed on this character are <a id="_idIndexMarker1584"/>as follows:</p>
<ul>
<li><strong class="bold">Game Mode = Valid</strong> because the <a id="_idIndexMarker1585"/>game mode instance only exists in the server, which is the case here</li>
<li><strong class="bold">Game State = Valid</strong> because the game state instance exists on the clients and the server, which is the case here</li>
<li><strong class="bold">Player State = Valid</strong> because the player state instance exists on the clients and the server, which is the case here</li>
<li><strong class="bold">Pawn = BP_ThirdPersonCharacter_C_0</strong> because pawn instances exist on the clients and the server, which is the case here</li>
<li><strong class="bold">Player Controller = Valid</strong> because player controller instances exist on the owning client and the server, which is the case here</li>
<li><strong class="bold">HUD = Valid</strong> because HUD instances only exist on the owning client, which is the case here</li>
</ul>
<p>Next, we are going to look at <code>Client 1 Character</code> in the sa<a id="_idTextAnchor412"/>me window.</p>
<h3>Client 1 Character</h3>
<p>This is the <a id="_idIndexMarker1586"/>character that <code>Client 1</code> is controlling. The values that are displayed on this character are <a id="_idIndexMarker1587"/>as follows:</p>
<ul>
<li><strong class="bold">Game Mode = Valid</strong> because the game mode instance only exists in the server, which is the case here</li>
<li><strong class="bold">Game State = Valid</strong> because the game state instance exists on the clients and the server, which is the case here</li>
<li><strong class="bold">Player State = Valid</strong> because the player state instance exists on the clients and the server, which is the case here</li>
<li><strong class="bold">Pawn = BP_ThirdPersonCharacter_C_1</strong> because pawn instances exist on the clients and the server, which is the case here</li>
<li><strong class="bold">Player Controller = Valid</strong> because player controller instances exist on the owning client and the server, which is the case here</li>
<li><strong class="bold">HUD = Invalid</strong> because HUD instances only exist on the owning client, which is not<a id="_idIndexMarker1588"/> the case here</li>
</ul>
<h2 id="_idParaDest-374"><a id="_idTextAnchor413"/>Output for the Client 1 window</h2>
<p>Have a look at <a id="_idIndexMarker1589"/>the following output of the <code>Client 1</code> window from the previous exercise:</p>
<div><div><img alt="Figure 18.5 – The Client 1 window " height="640" src="img/Figure_18.05_B18531.jpg" width="806"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.5 – The Client 1 window</p>
<p>In the preceding screenshot, you have the values for <code>Client 1 Character</code> and <code>Server Character</code>. The <code>WBP_Menu</code> UMG widget is displayed in the top-left corner and is only created for the player controller of <code>Client 1 Character</code> since it’s the only player controller in this window that controls a character.</p>
<p>First, let’s analyze the values for <code>Client 1 Character</code>.</p>
<h3>Client 1 Character</h3>
<p>This is the character that <code>Client 1</code> is controlling. The values<a id="_idIndexMarker1590"/> that are displayed on this character are as follows:</p>
<ul>
<li><strong class="bold">Game Mode = Invalid</strong> because the game mode instance only exists in the server, which is not the case here</li>
<li><strong class="bold">Game State = Valid</strong> because the game state instance exists on the server and the clients, which is the case here</li>
<li><strong class="bold">Player State = Valid</strong> because the player state instance exists on the server and the clients, which is the case here</li>
<li><strong class="bold">Pawn = BP_ThirdPersonCharacter_C_0</strong> because pawn instances exist on the server and the clients, which is the case here</li>
<li><strong class="bold">Player Controller = Valid</strong> because player controller instances exist on the server and the owning client, which is the case here</li>
<li><strong class="bold">HUD = Valid</strong> because HUD instances only exist on the owning client, which is the case here</li>
</ul>
<p>Next, we are going to look at <code>Server Character</code> in the same window.</p>
<h3>Server Character</h3>
<p>This is the character<a id="_idIndexMarker1591"/> that the listen server controls. The values that are displayed on this character are as follows:</p>
<ul>
<li><strong class="bold">Game Mode = Invalid</strong> because the game mode instance only exists in the server, which is not the case here</li>
<li><strong class="bold">Game State = Valid</strong> because the game state instance exists on the server and the clients, which is the case here</li>
<li><strong class="bold">Player State = Valid</strong> because the player state instance exists on the server and the clients, which is the case here</li>
<li><strong class="bold">Pawn = BP_ThirdPersonCharacter_C_1</strong> because pawn instances exist on the server and the clients, which is the case here</li>
<li><strong class="bold">Player Controller = Invalid</strong> because player controller instances exist on the server and the owning client, which is not the case here</li>
<li><strong class="bold">HUD = Invalid</strong> because HUD instances only exist on the owning client, which is not the case here</li>
</ul>
<p>By completing this<a id="_idIndexMarker1592"/> exercise, you should have a better understanding of where each instance of the gameplay framework class exists and where it doesn’t. In the next section, we’re going to cover the player state and game state classes, as well as some additional concepts regarding the game mode and useful built-in functionalities.</p>
<p>Using Game Mode, Player State, and Game State</p>
<p>So far, we’ve covered most of the important classes in the gameplay framework, including the game mode, player controller, and the pawn. In this section, we’re going to cover the player state, game state, and some additional concepts regarding the game mode, as well as some useful built-in functionalities.</p>
<h2 id="_idParaDest-375"><a id="_idTextAnchor414"/>Game mode</h2>
<p>We’ve already talked<a id="_idIndexMarker1593"/> about the game mode and how it works, but there are a few concepts that are useful to know about. Let’s take a look.</p>
<h3>Constructor</h3>
<p>To set the default class values, you<a id="_idIndexMarker1594"/> can use a constructor like so:</p>
<pre class="source-code">
ATestGameMode::ATestGameMode()
{
  DefaultPawnClass = AMyCharacter::StaticClass();
  PlayerControllerClass = 
  AMyPlayerController::StaticClass();
  PlayerStateClass = AMyPlayerState::StaticClass();
  GameStateClass = AMyGameState::StaticClass();
}</pre>
<p>The preceding code lets you specify which classes to use when spawning pawns, player controllers, player states, and<a id="_idIndexMarker1595"/> game states when we are using this game mode.</p>
<h3>Getting the game mode instance</h3>
<p>If you want to<a id="_idIndexMarker1596"/> access the game mode instance, you need to get it from the <code>GetWorld</code> function by using the following code:</p>
<pre class="source-code">
AGameModeBase* GameMode = GetWorld()-&gt;GetAuthGameMode();</pre>
<p>The preceding code allows you to access the current game mode instance, but you have to make sure that you are calling it on the server since this will be invalid on the clients due to security reasons.</p>
<h3>Match states</h3>
<p>So far, we’ve only been using the <code>AGameModeBase</code> class, which is the most basic game mode class in the <a id="_idIndexMarker1597"/>framework. Although it’s more than enough for certain types of games, there will be cases where you will require a bit more functionality. An example of this would be if we wanted to do a lobby system, where the match only starts if all the players have marked that they are ready. This example wouldn’t be possible to do with just the built-in function of the <code>AGameModeBase</code> class. For these cases, it’s better to use the <code>AGameMode</code> class instead, which is a child class of <code>AGameModeBase</code> that adds support for match states. The way match states work is by using a state machine that can only be in one of the following states at a given time:</p>
<ul>
<li><code>EnteringMap</code>: This is the starting state when the world is still loading and the actors aren’t ticking yet. It will transition to the <code>WaitingToStart</code> state once the world finishes loading.</li>
<li><code>WaitingToStart</code>: This state is set when the world has finished loading and the actors are ticking, although the pawns for the players won’t be spawned because the game hasn’t started yet. When the state machine enters this state, it will call the <code>HandleMatchIsWaitingToStart</code> function. The state machine will transition to the <code>InProgress</code> state if the <code>ReadyToStartMatch</code> function returns <code>true</code> or if the <code>StartMatch</code> function is called somewhere in the code.</li>
<li><code>InProgress</code>: This state is where the actual game takes place. When the state machine enters this<a id="_idIndexMarker1598"/> state, it will spawn the pawns for the players, call <code>BeginPlay</code> on all of the actors in the world, and call the <code>HandleMatchHasStarted</code> function. The state machine will transition to the <code>WaitingPostMatch</code> state if the <code>ReadyToEndMatch</code> function returns <code>true</code> or if the <code>EndMatch</code> function is called somewhere in the code.</li>
<li><code>WaitingPostMatch</code>: This state is set when the match ends. When the state machine enters this state, it will call the <code>HandleMatchHasEnded</code> function. In this state, actors still tick, but new players cannot join. It will transition to the <code>LeavingMap</code> state when it starts unloading the world.</li>
<li><code>LeavingMap</code>: This state is set while it’s unloading the world. When the state machine enters this state, it will call the <code>HandleLeavingMap</code> function. The state machine will transition to the <code>EnteringMap</code> state when it starts loading the new level.</li>
<li><code>Aborted</code>: This is a failed state that can only be set by calling the <code>AbortMatch</code> function, which is used to flag that something went wrong that prevented the match from happening.</li>
</ul>
<p>To help you understand these concepts better, we can use <em class="italic">Dota 2</em> again as an example:</p>
<ul>
<li><code>EnteringMap</code>: The state machine will be in this state when the map is loading.</li>
<li><code>WaitingToStart</code>: The state machine will be in this state once the map is loaded and the players are picking their heroes. The <code>ReadyToStartMatch</code> function will check whether all the players have selected their heroes; if they have, then the match can start.</li>
<li><code>InProgress</code>: The state machine will be in this state when the game is underway. The players control their heroes to farm and fight other players. The <code>ReadyToEndMatch</code> function will constantly check the health of each ancient to see whether one of them was destroyed; if it was, then the match ends.</li>
<li><code>WaitingPostMatch</code>: The state machine will be in this state when the game has ended and you can see the <a id="_idIndexMarker1599"/>destroyed ancient, as well as a message that displays the name of the winning team.</li>
<li><code>LeavingMap</code>: The state machine will be in this state when it’s unloading the map. </li>
<li><code>Aborted</code>: The state machine will be in this state if one of the players failed to connect in the initial stage, therefore aborting the whole match.</li>
</ul>
<h3>Respawning the player</h3>
<p>When the player dies and you <a id="_idIndexMarker1600"/>want to respawn it, you typically have two options. The first option is to reuse the same pawn instance, manually reset its state back to the defaults, and teleport it to the respawn location. The second option is to destroy the current pawn instance and spawn a new one, which will already have its state reset. If you prefer the latter option, then the <code>AGameModeBase::RestartPlayer</code> function handles the logic of spawning a new pawn instance for a certain player controller for you and places it on a player start.</p>
<p>One important thing to take into consideration is that the function only spawns a new pawn instance if the player controller doesn’t already possess a pawn, so make sure to destroy the controlled pawn before calling <code>RestartPlayer</code>.</p>
<p>Take a look at the following example:</p>
<pre class="source-code">
void ATestGameMode::OnDeath(APlayerController* VictimController)
{
  if(VictimController == nullptr)
  {
    return;
  }
 
  APawn* Pawn = VictimController-&gt;GetPawn();
  if(Pawn != nullptr)
  {
    Pawn-&gt;Destroy();
  }
  
  RestartPlayer(VictimController);
}</pre>
<p>In the preceding code, we have the <code>OnDeath</code> function, which takes the player controller of the player that died, destroys its controlled pawn, and calls the <code>RestartPlayer</code> function to <a id="_idIndexMarker1601"/>spawn a new instance. By default, the new pawn instance will spawn in the player start actor that was used when the player spawned for the first time. Alternatively, you can tell the game mode that you want to spawn on a random player start. To accomplish that, all you need to do is override the <code>AGameModeBase::ShouldSpawnAtStartSpot</code> function and force it to <code>return false</code>, like so:</p>
<pre class="source-code">
bool ATestGameMode::ShouldSpawnAtStartSpot(AController* Player)
{
  return false;
}</pre>
<p>The preceding code will make the game mode use a random player start instead of always using the first one that was used.</p>
<p class="callout-heading">Note</p>
<p class="callout">For more information about the game mode, please visit <a href="https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamemodes">https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamemodes</a> and <a href="https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameMode/index.xhtml">https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameMode/index.xhtml</a>.</p>
<h2 id="_idParaDest-376"><a id="_idTextAnchor415"/>Player state</h2>
<p>The player state class stores<a id="_idIndexMarker1602"/> the information that other clients need to know about a specific player (such as their current score, kills/deaths/assists, and so on) since they can’t access its player controller. The most widely used built-in functions are <code>GetPlayerName()</code>, <code>GetScore</code> and <code>GetPingInMilliseconds()</code>, which give you the name, score, and ping of the player, respectively.</p>
<p>A good example of how to use the player state is a scoreboard entry on a multiplayer shooter such as <em class="italic">Call Of Duty</em>, because every client needs to know the name, kills/deaths/assists, and ping for that player. The player state instance can be accessed in various ways, so let’s take a look at the most common ones:</p>
<h3>AController::PlayerState</h3>
<p>This variable contains the player state <a id="_idIndexMarker1603"/>associated with the controller and can only be accessed by the server and the owning client. The following example shows how to use the variable: </p>
<pre class="source-code">
APlayerState* PlayerState = Controller-&gt;PlayerState;</pre>
<h3>AController::GetPlayerState()</h3>
<p>This function returns the player state <a id="_idIndexMarker1604"/>associated with the controller and can only be accessed by the server and the owning client. This function also has a template version so that you can cast it to your own custom player state class. The following example shows how to use the default and template versions of this function:</p>
<pre class="source-code">
// Default version
APlayerState* PlayerState = Controller-&gt;GetPlayerState();
// Template version
ATestPlayerState* MyPlayerState = Controller-&gt;GetPlayerState&lt;ATestPlayerState&gt;();</pre>
<h3>APawn::GetPlayerState()</h3>
<p>This function returns the player state<a id="_idIndexMarker1605"/> associated with the controller that is possessing the pawn and can be accessed by the server and the clients. This function also has a template version so that you can cast it to your own custom player state class. The following example shows how to use the default and template versions of this function:</p>
<pre class="source-code">
// Default version
APlayerState* PlayerState = Pawn-&gt;GetPlayerState();
// Template version
ATestPlayerState* MyPlayerState = Pawn-
  &gt;GetPlayerState&lt;ATestPlayerState&gt;();</pre>
<h3>AGameState::PlayerArray</h3>
<p>This variable in the game <a id="_idIndexMarker1606"/>state (covered in the next section) stores the player state instances for each player and can be accessed on the server and the clients. The following example shows how to use this variable:</p>
<pre class="source-code">
TArray&lt;APlayerState*&gt; PlayerStates = GameState-&gt;PlayerArray;</pre>
<p>To help you understand these concepts better, we will use <em class="italic">Dota 2</em> again as an example. The player state would have at least the following variables:</p>
<ul>
<li><strong class="bold">Name</strong>: The name of the player</li>
<li><strong class="bold">Hero</strong>: The selected hero</li>
<li><strong class="bold">Health</strong>: The health of the hero</li>
<li><strong class="bold">Mana</strong>: The mana of the hero</li>
<li><strong class="bold">Stats</strong>: The hero stats</li>
<li><strong class="bold">Level</strong>: The level the hero is <a id="_idIndexMarker1607"/>currently in</li>
<li><strong class="bold">Kill/Death/Assist</strong>: The kill/death/assist ratio for the player</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">For more information about the player state, please visit <a href="https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/APlayerState/index.xhtml">https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/APlayerState/index.xhtml</a>.</p>
<h2 id="_idParaDest-377"><a id="_idTextAnchor416"/>Game State</h2>
<p>The game state class stores<a id="_idIndexMarker1608"/> the information that other clients need to know about the game (such as the match’s elapsed time and the score required to win the game) since they can’t access the game mode. The most widely used variable is <code>PlayerArray</code>, which is an array that provides the player state of every connected client. A good example of how to use the game state is a scoreboard on a multiplayer shooter such as <em class="italic">Call Of Duty</em> because every client needs to know how many kills are required to win, as well as the names, kills/deaths/assists, and pings for every connected player.</p>
<p>The game state instance can be accessed in various ways. Let’s take a look.</p>
<h3>UWorld::GetGameState()</h3>
<p>This function returns the game state <a id="_idIndexMarker1609"/>associated with the world and can be accessed on the server and the clients. This function also has a template version so that you can cast it to your own custom game state class. The following example shows how to use the default and template versions of this function:</p>
<pre class="source-code">
// Default version
AGameStateBase* GameState = GetWorld()-&gt;GetGameState();
// Template version
AMyGameState* MyGameState = GetWorld()-&gt;GetGameState&lt;AMyGameState&gt;();</pre>
<h3>AGameModeBase::GameState</h3>
<p>This variable contains the<a id="_idIndexMarker1610"/> game state associated with the game mode and can only be accessed on the server. The following example shows how to use the variable:</p>
<pre class="source-code">
AGameStateBase* GameState = GameMode-&gt;GameState;</pre>
<h3>AGameModeBase::GetGameState()</h3>
<p>This function returns the game state <a id="_idIndexMarker1611"/>associated with the game mode and can only be accessed on the server. This function also has a template version so that you can cast it to your own custom game state class. The following example shows how to use the default and template versions of this function:</p>
<pre class="source-code">
// Default version
AGameStateBase* GameState = GameMode-&gt;GetGameState&lt;AGameStateBase&gt;();
// Template version
AMyGameState* MyGameState = GameMode-&gt;GetGameState&lt;AMyGameState&gt;();</pre>
<p>To help you understand these concepts better, we will use <em class="italic">Dota 2</em> again as an example. The game state will have the following variables:</p>
<ul>
<li><strong class="bold">Elapsed Time</strong>: How long the match has been going on for</li>
<li><strong class="bold">Radiant Kills</strong>: How many Dire heroes the Radiant team has killed</li>
<li><strong class="bold">Dire Kills</strong>: How many Radiant heroes the Dire team has killed</li>
<li><strong class="bold">Day/Night Timer</strong>: Used to determine whether it is day or night</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">For more information<a id="_idIndexMarker1612"/> about the game state, please visit <a href="https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameState/index.xhtml">https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameState/index.xhtml</a>.</p>
<h2 id="_idParaDest-378"><a id="_idTextAnchor417"/>Useful built-in functionality</h2>
<p>UE5 comes with a lot of <a id="_idIndexMarker1613"/>functionality built in. Let’s look at some examples that are useful to know about when developing a game.</p>
<h3>void AActor::EndPlay(const EEndPlayReason::Type EndPlayReason)</h3>
<p>This function is called when the<a id="_idIndexMarker1614"/> actor has stopped playing, which is the opposite of the <code>BeginPlay</code> function. This function has a parameter called <code>EndPlayReason</code>, which tells you why the actor stopped playing (if it was destroyed, if you stopped <code>PIE</code>, and so on). Take a look at the following example, which prints to the screen that the actor has stopped playing:</p>
<pre class="source-code">
void ATestActor::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
  Super::EndPlay(EndPlayReason);
  const FString String = FString::Printf(TEXT("The actor %s 
  has just stopped playing"), *GetName());
  GEngine-&gt;AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, 
  String);
}</pre>
<h3>void ACharacter::Landed(const FHitResult&amp; Hit)</h3>
<p>This function is called when a player lands<a id="_idIndexMarker1615"/> on a surface after being in the air. Take a look at the following example, which plays a sound when a player lands on a surface:</p>
<pre class="source-code">
void ATestCharacter::Landed(const FHitResult&amp; Hit)
{
  Super::Landed(Hit);
  UGameplayStatics::PlaySound2D(GetWorld(), LandSound);
}</pre>
<h3>bool UWorld::ServerTravel(const FString&amp; FURL, bool bAbsolute, bool bShouldSkipGameNotify)</h3>
<p>This function will make the server<a id="_idIndexMarker1616"/> load a new map and bring all of the connected clients along with it. This is different from using other methods that load maps, such as the <code>UGameplayStatics::OpenLevel</code> function, because it won’t bring the clients along; it will just load the map on the server and disconnect the clients.</p>
<p>Take a look at the following example, which gets the current map name and uses server travel to reload it and bring along the connected clients:</p>
<pre class="source-code">
void ATestGameModeBase::RestartMap()
{
  const FString URL = GetWorld()-&gt;GetName();
  GetWorld()-&gt;ServerTravel(URL, false, false);
}</pre>
<h3>void TArray::Sort(const PREDICATE_CLASS&amp; Predicate)</h3>
<p>The <code>TArray</code> data structure comes with the <code>Sort</code> function, which allows you to sort the values of an array by using a lambda function that returns whether the <code>A</code> value should be ordered first, followed <a id="_idIndexMarker1617"/>by the <code>B</code> value. Take a look at the following example, which sorts an integer array from the smallest value to the highest:</p>
<pre class="source-code">
void ATestActor::SortValues()
{
  TArray&lt;int32&gt; SortTest;
  SortTest.Add(43);
  SortTest.Add(1);
  SortTest.Add(23);
  SortTest.Add(8);
  SortTest.Sort([](const int32&amp; A, const int32&amp; B) { return 
  A &lt; B; });
}</pre>
<p>The preceding code will sort the <code>SortTest</code> array’s values of [43, 1, 23, 8] from smallest to highest – that is, [1, 8, 23, 43].</p>
<h3>void AActor::FellOutOfWorld(const UDamageType&amp; DmgType)</h3>
<p>In Unreal Engine, there is a concept <a id="_idIndexMarker1618"/>called <code>Z</code> (set in the <code>Z</code> value, it will call the <code>FellOutOfWorld</code> function, which, by default, destroys the actor. Take a look at the following example, which prints to the screen that the actor fell out of the world:</p>
<pre class="source-code">
void AFPSCharacter::FellOutOfWorld(const UDamageType&amp; DmgType)
{
  Super::FellOutOfWorld(DmgType);
  const FString String = FString::Printf(TEXT("The actor %s 
  has fell out of the world"), *GetName());
  GEngine-&gt;AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, 
  String);
}</pre>
<h3>URotatingMovementComponent</h3>
<p>This component rotates the <a id="_idIndexMarker1619"/>owning actor along time with a certain rate on each axis, defined in the <code>RotationRate</code> variable. To use it, you need to include the following header:</p>
<pre class="source-code">
#include "GameFramework/RotatingMovementComponent.h"</pre>
<p>You must also declare the component variable:</p>
<pre class="source-code">
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Test Actor")
URotatingMovementComponent* RotatingMovement;</pre>
<p>Finally, you must initialize it in the actor constructor, like so:</p>
<pre class="source-code">
RotatingMovement = CreateDefaultSubobject
  &lt;URotatingMovementComponent&gt;("Rotating Movement");
RotatingMovement-&gt;RotationRate = FRotator(0.0, 90.0f, 0);</pre>
<p>In the preceding code, <code>RotationRate</code> is set to rotate <code>90</code> degrees per second on the <code>Yaw</code> axis.</p>
<h2 id="_idParaDest-379"><a id="_idTextAnchor418"/>Exercise 18.02 – Making a simple multiplayer pickup game</h2>
<p>In this exercise, we’re going to create a new C++ project that uses the <strong class="bold">Third Person</strong> template. The following will happen:</p>
<ul>
<li>On the owning client, the player <a id="_idIndexMarker1620"/>controller will create and add to the viewport a UMG widget that, for each player, displays the score, sorted from highest to lowest, and how many pickups it has collected.</li>
<li>Create a simple pickup actor class that gives 10 points to the player that picked it up. The pickup will also rotate 90 degrees per second on the <code>Yaw</code> axis.</li>
<li>Set the <code>Kill Z</code> to <code>-500</code> and make the player respawn and lose 10 points every time they fall from the world.</li>
<li>The game will end when there are no more pickups available. Once the game ends, all characters will be destroyed and after 5 seconds, the server will do a server travel call to reload the same map and bring along the connected clients.</li>
</ul>
<p>Follow these steps to complete the C++ part of this exercise:</p>
<ol>
<li value="1">Create a new <code>Pickups</code> and save it to a location of your liking.</li>
<li>Once the project has been created, it should open the editor, as well as the Visual Studio solution.</li>
</ol>
<p>Now, let’s create the new C++ classes we’re going to use.</p>
<ol>
<li value="3">Create a <code>Pickup</code> class that derives from <code>Actor</code>.</li>
<li>Create a <code>PickupsGameState</code> class that derives from <code>GameState</code>.</li>
<li>Create a <code>PickupsPlayerState</code> class that derives from <code>PlayerState</code>.</li>
<li>Create a <code>PickupsPlayerController</code> class that derives from <code>PlayerController</code>.</li>
<li>Close the editor and open Visual Studio.</li>
</ol>
<p>Next, we’re going to work on the <code>PickupsGameState</code> class:</p>
<ol>
<li value="1">Open <code>PickupsGameState.h</code> and declare the protected replicated integer variable, <code>PickupsRemaining</code>, which tells all clients how many pickups remain in the level:<pre>UPROPERTY(Replicated, BlueprintReadOnly)
int32 PickupsRemaining;</pre></li>
<li>Declare the protected override for the <code>BeginPlay</code> function:<pre>virtual void BeginPlay() override;</pre></li>
<li>Declare the protected <code>GetPlayerStatesOrderedByScore</code> function:<pre>UFUNCTION(BlueprintCallable)
TArray&lt;APlayerState*&gt; GetPlayerStatesOrderedByScore() const;</pre></li>
<li>Implement the <a id="_idIndexMarker1621"/>public <code>RemovePickup</code> function, which removes one pickup from the <code>PickupsRemaining</code> variable:<pre>void RemovePickup() { PickupsRemaining--; }</pre></li>
<li>Implement the public <code>HasPickups</code> function, which returns whether any pickups remain:<pre>bool HasPickups() const { return PickupsRemaining &gt; 0; }</pre></li>
<li>Open <code>PickupsGameState.cpp</code> and include <code>Pickup.h</code>, <code>GameplayStatics.h</code>, <code>UnrealNetwork.h</code>, and <code>PlayerState.h</code>:<pre>#include "Pickup.h"
#include "Kismet/GameplayStatics.h"
#include "Net/UnrealNetwork.h"
#include "GameFramework/PlayerState.h"</pre></li>
<li>Implement the <code>GetLifetimeReplicatedProps</code> function and make the <code>PickupRemaining</code> variable replicate to all clients:<pre>void APickupsGameState::GetLifetimeReplicatedProps(TArray&lt; 
  FLifetimeProperty &gt;&amp; OutLifetimeProps) const
{
  Super::GetLifetimeReplicatedProps(OutLifetimeProps);
  DOREPLIFETIME(APickupsGameState, PickupsRemaining);
}</pre></li>
<li>Implement the <code>BeginPlay</code> override function and set the value of <code>PickupsRemaining</code> by getting <a id="_idIndexMarker1622"/>all the pickups in the world:<pre>void APickupsGameState::BeginPlay()
{
  Super::BeginPlay();
  TArray&lt;AActor*&gt; Pickups;
  UGameplayStatics::GetAllActorsOfClass(this, 
    APickup::StaticClass(), Pickups);
  PickupsRemaining = Pickups.Num();
}</pre></li>
<li>Implement the <code>GetPlayerStatesOrderedByScore</code> function, which duplicates the <code>PlayerArray</code> variable and sorts it so that the players with the highest scores show up first:<pre>TArray&lt;APlayerState*&gt; APickupsGameState::GetPlayerStatesOrderedByScore() const
{
  TArray&lt;APlayerState*&gt; PlayerStates(PlayerArray);
  PlayerStates.Sort([](const APlayerState&amp; A, const 
  APlayerState&amp; 
    B) { return A.GetScore() &gt; B.GetScore(); });
  return PlayerStates;
}</pre></li>
</ol>
<p>Next, let’s work on the <code>PickupsPlayerState</code> class. Follow these steps:</p>
<ol>
<li value="1">Open <code>PickupsPlayerState.h</code> and declare the protected replicated integer variable, <code>Pickups</code>, which<a id="_idIndexMarker1623"/> indicates how many pickups a player has collected:<pre>UPROPERTY(Replicated, BlueprintReadOnly)
int32 Pickups;</pre></li>
<li>Implement the public <code>AddPickup</code> function, which adds one pickup to the <code>Pickups</code> variable:<pre>void AddPickup() { Pickups++; }</pre></li>
<li>Open <code>PickupsPlayerState.cpp</code> and include <code>UnrealNetwork.h</code>:<pre>#include "Net/UnrealNetwork.h"</pre></li>
<li>Implement the <code>GetLifetimeReplicatedProps</code> function and make the <code>Pickups</code> variable replicate to all clients:<pre>void APickupsPlayerState::GetLifetimeReplicatedProps(TArray&lt; 
  FLifetimeProperty &gt;&amp; OutLifetimeProps) const
{
  Super::GetLifetimeReplicatedProps(OutLifetimeProps);
  DOREPLIFETIME(APickupsPlayerState, Pickups);
}</pre></li>
</ol>
<p>Next, let’s work on the <code>PickupsPlayerController</code> class.</p>
<ol>
<li value="5">Open <code>PickupsPlayerController.h</code> and declare the protected <code>ScoreboardMenuClass</code> variable, which will set the UMG widget class we want to use for our scoreboard:<pre>UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Pickup Player Controller")
TSubclassOf&lt;class UUserWidget&gt; ScoreboardMenuClass;</pre></li>
<li>Declare the protected <code>ScoreboardMenu</code> variable, which stores the scoreboard UMG <a id="_idIndexMarker1624"/>widget instance we will create on the <code>BeginPlay</code> function:<pre>UPROPERTY()
class UUserWidget* ScoreboardMenu;</pre></li>
<li>Declare the protected override for the <code>BeginPlay</code> function:<pre>virtual void BeginPlay() override;</pre></li>
<li>Open <code>PickupsPlayerController.cpp</code> and include <code>UserWidget.h</code>:<pre>#include "Blueprint/UserWidget.h"</pre></li>
<li>Implement the <code>BeginPlay</code> override function, which, for the owning client, creates and adds the scoreboard UMG widget to the viewport:<pre>void ApickupsPlayerController::BeginPlay()
{
  Super::BeginPlay();
  if (IsLocalController() &amp;&amp; ScoreboardMenuClass != 
  nullptr)
  {
    ScoreboardMenu = CreateWidget&lt;UUserWidget&gt;(this, 
    ScoreboardMenuClass);
    if (ScoreboardMenu != nullptr)
    {
      ScoreboardMenu-&gt;AddToViewport(0);
    }
  }  
}</pre></li>
</ol>
<p>Now, let’s edit the <code>PickupsGameMode</code> class:</p>
<ol>
<li value="1">Open <code>PickupsGameMode.h</code> and replace the <code>#include</code> statement for <code>GameModeBase.h</code> with <code>GameMode.h</code>:<pre>#include "GameFramework/GameMode.h"</pre></li>
<li>Make the class <a id="_idIndexMarker1625"/>derive from <code>AGameMode</code> instead of <code>AGameModeBase</code>:<pre>class APickupsGameMode : public AGameMode</pre></li>
<li>Declare the protected game state variable, <code>MyGameState</code>, which holds the instance of the <code>APickupsGameState</code> class:<pre>UPROPERTY()
class APickupsGameState* MyGameState;</pre></li>
<li>Move the constructor to the protected area and delete the public area.</li>
<li>Declare the protected override for the <code>BeginPlay</code> function:<pre>virtual void BeginPlay() override;</pre></li>
<li>Declare the protected override for the <code>ShouldSpawnAtStartSpot</code> function:<pre>virtual bool ShouldSpawnAtStartSpot(AController* Player) 
  override;</pre></li>
<li>Declare the protected overrides for the match state functions of the game mode:<pre>virtual void HandleMatchHasStarted() override;
virtual void HandleMatchHasEnded() override;
virtual bool ReadyToStartMatch_Implementation() override;
virtual bool ReadyToEndMatch_Implementation() override;</pre></li>
<li>Declare the<a id="_idIndexMarker1626"/> protected <code>RestartMap</code> function:<pre>void RestartMap() const;</pre></li>
<li>Open <code>PickupsGameMode.cpp</code> and include <code>GameplayStatics.h</code> and <code>PickupGameState.h</code>:<pre>#include "Kismet/GameplayStatics.h"
#include "PickupsGameState.h"</pre></li>
<li>Implement the <code>BeginPlay</code> override function, which stores the <code>APickupGameState</code> instance:<pre>void APickupsGameMode::BeginPlay()
{
  Super::BeginPlay();
  MyGameState = GetGameState&lt;APickupsGameState&gt;();
}</pre></li>
<li>Implement the <code>ShouldSpawnAtStartSpot</code> override function, which indicates that we want the players to respawn on a random player start and not always on the same one:<pre>bool APickupsGameMode::ShouldSpawnAtStartSpot
  (AController* Player)
{
  return false;
}</pre></li>
<li>Implement the <code>HandleMatchHasStarted</code> override function, which prints to the screen, informing players that the game has started:<pre>void APickupsGameMode::HandleMatchHasStarted()
{
  Super::HandleMatchHasStarted();
  GEngine-&gt;AddOnScreenDebugMessage(-1, 2.0f, 
  FColor::Green, "The game has started!");
}</pre></li>
<li>Implement the <code>HandleMatchHasEnded</code> override function, which prints to the screen, informing <a id="_idIndexMarker1627"/>players that the game has ended, destroys all characters, and schedules a timer to restart the map:<pre>void APickupsGameMode::HandleMatchHasEnded()
{
  Super::HandleMatchHasEnded();
  GEngine-&gt;AddOnScreenDebugMessage(-1, 2.0f, 
  FColor::Red, "The game has ended!");
  TArray&lt;AActor*&gt; Characters;
    UGameplayStatics::GetAllActorsOfClass(this, 
    APickupsCharacter::StaticClass(), Characters);
  for (AActor* Character : Characters)
  {
    Character-&gt;Destroy();
  }
  FTimerHandle TimerHandle;
  GetWorldTimerManager().SetTimer(TimerHandle, this, 
    &amp;APickupsGameMode::RestartMap, 5.0f);
}</pre></li>
<li>Implement the <code>ReadyToStartMatch_Implementation</code> override function, which indicates <a id="_idIndexMarker1628"/>that the match can start straight away:<pre>bool APickupsGameMode::ReadyToStartMatch_Implementation()
{
  return true;
}</pre></li>
<li>Implement the <code>ReadyToEndMatch_Implementation</code> override function, which indicates that the match ends when the game state has no more pickups remaining:<pre>bool APickupsGameMode::ReadyToEndMatch_Implementation()
{
  return MyGameState != nullptr &amp;&amp; !MyGameState
  -&gt;HasPickups();
}</pre></li>
<li>Implement the <code>RestartMap</code> function, which performs a server travel to the same level and brings all clients along:<pre>void APickupsGameMode::RestartMap() const
{
  GetWorld()-&gt;ServerTravel(GetWorld()-&gt;GetName(), 
  false, false);
}</pre></li>
</ol>
<p>Now, let’s edit the <code>PickupsCharacter</code> class. Follow<a id="_idIndexMarker1629"/> these steps:</p>
<ol>
<li value="1">Open <code>PickupsCharacter.h</code> and declare the protected sound variables for falling and landing:<pre>UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = 
  "Pickups Character")
USoundBase* FallSound;
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = 
  "Pickups Character")
USoundBase* LandSound;</pre></li>
<li>Declare the protected override functions:<pre>virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;
virtual void Landed(const FHitResult&amp; Hit) override;
virtual void FellOutOfWorld(const UDamageType&amp; DmgType) override;</pre></li>
<li>Declare the public functions that add scores and pickups to the player state:<pre>void AddScore(const float Score) const;
void AddPickup() const;</pre></li>
<li>Declare the public client RPC that plays a sound on the owning client:<pre>UFUNCTION(Client, Unreliable)
void ClientPlaySound2D(USoundBase* Sound);</pre></li>
<li>Open <code>PickupsCharacter.cpp</code> and include <code>PickupsPlayerState.h</code>, <code>GameMode.h</code>, <code>PlayerState.h</code>, and <code>GameplayStatics.h</code>:<pre>#include "PickupsPlayerState.h"
#include "GameFramework/GameMode.h"
#include "GameFramework/PlayerState.h"
#include "Kismet/GameplayStatics.h"</pre></li>
<li>Implement<a id="_idIndexMarker1630"/> the <code>EndPlay</code> override function, which plays the fall sound if the character was destroyed:<pre>void APickupsCharacter::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
  Super::EndPlay(EndPlayReason);
  if (EndPlayReason == EEndPlayReason::Destroyed)
  {
    UGameplayStatics::PlaySound2D(GetWorld(), 
    FallSound);
  }
}</pre></li>
<li>Implement the <code>Landed</code> override function, which plays the landed sound:<pre>void APickupsCharacter::Landed(const FHitResult&amp; Hit)
{
  Super::Landed(Hit);
  UGameplayStatics::PlaySound2D(GetWorld(), LandSound);
}</pre></li>
<li>Implement the <code>FellOutOfWorld</code> override function, which stores the controller, removes <code>10</code> points <a id="_idIndexMarker1631"/>from the score, destroys the character, and tells the game mode to restart the player using the previous controller:<pre>void APickupsCharacter::FellOutOfWorld(const UDamageType&amp; 
  DmgType)
{
  AController* TempController = Controller;
  AddScore(-10);
  Destroy();
  AGameMode* GameMode = GetWorld()
  -&gt;GetAuthGameMode&lt;AGameMode&gt;();
  if (GameMode != nullptr)
  {
    GameMode-&gt;RestartPlayer(TempController);
  }
}</pre></li>
<li>Implement the <code>AddScore</code> function, which adds a certain amount to the <code>score</code> in the player state:<pre>void APickupsCharacter::AddScore(const float Score) const
{
  APlayerState* MyPlayerState = GetPlayerState();
  if (MyPlayerState != nullptr)
  {
    const float CurrentScore = MyPlayerState-&gt;GetScore();
    MyPlayerState-&gt;SetScore(CurrentScore + Score);
  }
}</pre></li>
<li>Implement the <code>AddPickup</code> function, which adds a pickup to the <code>Pickup</code> variable in our custom <a id="_idIndexMarker1632"/>player state:<pre>void APickupsCharacter::AddPickup() const
{
  APickupsPlayerState* MyPlayerState = 
    GetPlayerState&lt;APickupsPlayerState&gt;();
  if (MyPlayerState != nullptr)
  {
    MyPlayerState-&gt;AddPickup();
  }
}</pre></li>
<li>Implement the <code>ClientPlaySound2D_Implementation</code> function, which plays a sound on the owning client:<pre>void APickupsCharacter::ClientPlaySound2D_Implementation(USoundBase* Sound)
{
  UGameplayStatics::PlaySound2D(GetWorld(), Sound);
}</pre></li>
</ol>
<p>Now, let’s work on the <code>Pickup</code> class. Follow these steps:</p>
<ol>
<li value="1">Open <code>Pickup.h</code> and clear <a id="_idIndexMarker1633"/>all existing functions and delete the public areas.</li>
<li>Declare the protected <code>Static Mesh</code> component called <code>Mesh</code>:<pre>UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = 
  "Pickup")
UStaticMeshComponent* Mesh;</pre></li>
<li>Declare the protected rotating movement component called <code>RotatingMovement</code>:<pre>UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = 
  "Pickup")
class URotatingMovementComponent* RotatingMovement;</pre></li>
<li>Declare the protected <code>PickupSound</code> variable:<pre>UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = 
  "Pickup")
USoundBase* PickupSound;</pre></li>
<li>Declare the protected constructor and <code>BeginPlay</code> override:<pre>APickup();
virtual void BeginPlay() override;</pre></li>
<li>Declare the protected <code>OnBeginOverlap</code> function:<pre>UFUNCTION()
void OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* 
  OtherActor, UPrimitiveComponent* OtherComp, int32 
  OtherBodyIndex, bool bFromSweep, const FHitResult&amp; 
  Hit);</pre></li>
<li>Open <code>Pickup.cpp</code> and include <code>PickupsCharacter.h</code>, <code>PickupsGameState.h</code>, and <code>RotatingMovementComponent.h</code> after <code>Pickup.h</code>:<pre>#include "PickupsCharacter.h"
#include "PickupsGameState.h"
#include "GameFramework/RotatingMovementComponent.h"</pre></li>
<li>In the constructor, initialize<a id="_idIndexMarker1634"/> the <code>Mesh</code> component so that it overlaps everything and make it the root component:<pre>Mesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;("Mesh");
Mesh-&gt;SetCollisionProfileName("OverlapAll");
RootComponent = Mesh;</pre></li>
<li>Still in the constructor, initialize the rotating movement component so that it rotates <code>90</code> degrees per second on the <code>Yaw</code> axis:<pre>RotatingMovement = CreateDefaultSubobject
  &lt;URotatingMovementComponent&gt;("Rotating Movement");
RotatingMovement-&gt;RotationRate = FRotator(0.0, 90.0f, 0);</pre></li>
<li>To finalize the constructor, enable replication and disable the <code>Tick</code> function:<pre>bReplicates = true;
PrimaryActorTick.bCanEverTick = false;</pre></li>
<li>At the end of the <code>BeginPlay</code> function, bind the begin overlap event of <code>Mesh</code> to the <code>OnBeginOverlap</code> function:<pre>Mesh-&gt;OnComponentBeginOverlap.AddDynamic(this, &amp;APickup::OnBeginOverlap);</pre></li>
<li>Delete the definition for the <code>Tick</code> function.</li>
<li>Implement the <code>OnBeginOverlap</code> function, which checks whether the character is valid and has <a id="_idIndexMarker1635"/>authority, removes the pickup from the game state, plays the pickup sound on the owning client, and adds <code>10</code> points and the pickup to the character. Once all of that is done, the pickup will destroy itself:<pre>void APickup::OnBeginOverlap(UPrimitiveComponent* OverlappedComp, 
  AActor* OtherActor, UPrimitiveComponent* OtherComp, 
  int32 
  OtherBodyIndex, bool bFromSweep, const FHitResult&amp; 
  Hit)
{
  APickupsCharacter* Character = 
    Cast&lt;APickupsCharacter&gt;(OtherActor);
  if (Character == nullptr || !HasAuthority())
  {
    return;
  }
  APickupsGameState* GameState = 
    Cast&lt;APickupsGameState&gt;(GetWorld()
  -&gt;GetGameState());
  if (GameState != nullptr)
  {
    GameState-&gt;RemovePickup();
  }
  Character-&gt;ClientPlaySound2D(PickupSound);
  Character-&gt;AddScore(10);
  Character-&gt;AddPickup();
  Destroy();
}</pre></li>
<li>Open <code>Pickups.Build.cs</code> and add<a id="_idIndexMarker1636"/> the <code>UMG</code> module to <code>PublicDependencyModuleNames</code>, like so:<pre>PublicDependencyModuleNames.AddRange(new string[] { "Core", 
  "CoreUObject", "Engine", "InputCore", 
  "HeadMountedDisplay", 
  "UMG" });</pre></li>
</ol>
<p>If you try to compile and get errors from adding the new module, then clean and recompile your project. If that doesn’t work, try restarting your IDE.</p>
<ol>
<li value="15">Compile and run the code until the editor loads. </li>
</ol>
<p>Once it’s loaded, we’re going to import some assets and create some blueprints that derive from the C++ classes we’ve just created.</p>
<p>First, let’s import the sound files:</p>
<ol>
<li value="1">In the <code>Content\Sounds</code> folder.</li>
<li>Import <code>Pickup.wav</code>, <code>Footstep.wav</code>, <code>Jump.wav</code>, <code>Land.wav</code>, and <code>Fall.wav</code> from the <code>Exercise18.02\Assets</code> folder.</li>
<li>Save the new files.</li>
</ol>
<p>Next, we will add the <code>Play Sound</code> anim notifies to some of the character’s animations.</p>
<ol>
<li value="4">Open the <code>MM_Jump</code> animation, located in <code>Content\Characters\Mannequins\Animations\Manny</code>, and add a <code>Play Sound</code> anim notify at frame <code>0</code> using the <code>Jump</code> sound. </li>
<li>Save and close <code>MM_Jump</code>.</li>
<li>Open the <code>MF_Run_Fwd</code> animation, located in <code>Content\Characters\Mannequins\Animations\Quinn</code>, and add <code>Play Sound</code> anim notifies using the <code>Footstep</code> sound at <code>0.24</code>, <code>0.56</code>, <code>0.82</code>, <code>1.12</code>, <code>1.38</code>, and <code>1.70</code> seconds.</li>
<li>Save and <a id="_idIndexMarker1637"/>close <code>MF_Run_Fwd</code>.</li>
<li>Open the <code>MF_Walk_Fwd</code> animation, located in <code>Content\Characters\Mannequins\Animations\Quinn</code>, and add two <code>Play Sound</code> anim notifies using the <code>Footstep</code> sound at <code>0.33, 0.72, 1.23,</code> and <code>1.7</code> seconds.</li>
<li>Save and close <code>MF_Walk_Fwd</code>.</li>
</ol>
<p>Now, let’s set the sounds to use on the character blueprint:</p>
<ol>
<li value="1">Open the <code>BP_ThirdPersonCharacter</code> blueprint, located in <code>Content\ThirdPerson\Blueprints</code>, and set <code>Fall Sound</code> and <code>Land Sound</code> so that they use the <code>Fall</code> and <code>Land</code> sounds, respectively.</li>
<li>Save and close <code>BP_ThirdPersonCharacter</code>.</li>
</ol>
<p>Now, let’s create the blueprint for the pickup.</p>
<ol>
<li value="3">Create and open the <code>Content\Blueprints</code> folder.</li>
<li>Create a new blueprint called <code>BP_Pickup</code> that derives from the <code>Pickup</code> class and open it.</li>
<li>Configure the <code>Static Mesh</code> component in the following way:<ul><li><code>(X=0.5, Y=0.5, Z=0.5)</code></li><li><code>Engine\BasicShapes\Cube</code></li><li><code>Engine\EngineMaterials\CubeMaterial</code></li></ul></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">To display the Engine content, you need to click on the dropdown for the static mesh, click on the cog icon next to the filter box, and make sure that the <code>true</code>.</p>
<ol>
<li value="6">Set the <code>Pickup Sound</code> variable to use the <code>Pickup</code> sound.</li>
<li>Save and<a id="_idIndexMarker1638"/> close <code>BP_Pickup</code>.</li>
</ol>
<p>Now, let’s create the scoreboard UMG widgets. Follow these steps:</p>
<ol>
<li value="1">Create and go to the <code>Content\UI</code> folder.</li>
<li>Create a new widget blueprint called <code>WBP_Scoreboard_Header</code>:<ul><li>Add a <code>true</code>, <code>true</code>, <code>Player Name</code>, and <code>green</code>.</li><li>Add a text block called <code>true</code>, <code> </code><code> = 500</code>, <code> = 1.0, 0.0</code>, <code>true</code>, <code>Score</code>, and <code>green</code>.</li><li>Add a text block called <code>true</code>, <code> </code><code> = 650</code>, <code> = 1.0, 0.0</code>, <code>true</code>, <code>Pickups</code>, and <code>green</code>.</li></ul></li>
<li>Save and close <code>WBP_Scoreboard_Header</code>.</li>
<li>Go back to <code>WBP_Scoreboard_Header</code>, rename it to <code>WBP_Scoreboard_Entry</code>, and open it.</li>
<li>Change the color of all of <a id="_idIndexMarker1639"/>the text blocks to <code>white</code> instead of <code>green</code>.</li>
<li>Go to the <code>Player State</code> variable with the following configuration:</li>
</ol>
<div><div><img alt="Figure 18.6 – Creating the Player State variable " height="192" src="img/Figure_18.06_B18531.jpg" width="446"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.6 – Creating the Player State variable</p>
<ol>
<li value="7">Go back to the <code>Name</code> with <code>Player Name</code> and bind it to the <code>GetPlayerName</code> function from the dropdown, like so:</li>
</ol>
<div><div><img alt="Figure 18.7 – Binding the player name function " height="299" src="img/Figure_18.07_B18531.jpg" width="479"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.7 – Binding the player name function</p>
<ol>
<li value="8">Create a text block<a id="_idIndexMarker1640"/> called <code>Score</code> with <code>Score</code> and bind it to the <code>Score</code> variable from the dropdown, like so:</li>
</ol>
<div><div><img alt="Figure 18.8 – Binding the player score function " height="302" src="img/Figure_18.08_B18531.jpg" width="478"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.8 – Binding the player score function</p>
<ol>
<li value="9">Create a text block called <code>Pickups</code> with <code>Pickups</code> and bind it to the <code>Pickups</code> variable from the dropdown, like so:</li>
</ol>
<div><div><img alt="Figure 18.9 – Binding the pickups count function " height="282" src="img/Figure_18.09_B18531.jpg" width="471"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.9 – Binding the pickups count function</p>
<ol>
<li value="10">Create a pure function called <code>Get Typeface</code> that does the following:</li>
</ol>
<div><div><img alt="Figure 18.10 – Determining whether the entry should be displayed in Bold or Regular " height="322" src="img/Figure_18.10_B18531.jpg" width="972"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.10 – Determining whether the entry should be displayed in Bold or Regular</p>
<p>In the preceding code, we <a id="_idIndexMarker1641"/>used a <code>Select</code> node, which can be created by dragging a wire from the return value and releasing it on an empty space, and then typed <code>Select</code> on the filter. From there, we picked the <code>Select</code> node from the list. Here, we are using the <code>Select</code> node to pick the name of the typeface we’re going to use, so it should return <code>Regular</code> if the player state’s pawn is not the same as the pawn that owns the widget and <code>Bold</code> if it is. We do this to highlight the player’s state entry in bold so that the player knows what their entry is.</p>
<ol>
<li value="11">Implement <code>Event Construct</code> in the following way:</li>
</ol>
<div><div><img alt="Figure 18.11 – The Event Graph that sets the text for the name, score, and pickups count " height="518" src="img/Figure_18.11_B18531.jpg" width="692"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.11 – The Event Graph that sets the text for the name, score, and pickups count</p>
<p>In the preceding code, we set the font for <code>Name</code>, <code>Score</code>, and <code>Pickups</code> to use the <code>Bold</code> typeface to highlight which scoreboard entry is relative to the player of the current client. For <a id="_idIndexMarker1642"/>the remainder of the players, use the <code>Regular</code> typeface. If you can’t find the <strong class="bold">Roboto</strong> font, then pick <strong class="bold">Show Engine Content</strong> from the dropdown options.</p>
<ol>
<li value="12">Save and close <code>WBP_Scoreboard_Entry</code>.</li>
<li>Open <code>WBP_Scoreboard</code> and add a <strong class="bold">Canvas Panel</strong> to the <strong class="bold">Hierarchy</strong> panel.</li>
<li>Go to the <code>Game State</code> of the <code>Pickups Game State</code> type.</li>
<li>Go back to the <code>Scoreboard</code> to the canvas panel with <code>true</code>.</li>
<li>Add a text block to <code>Scoreboard</code> called <code>PickupsRemaining</code> with <code>Text</code> set to <code>100 Pickup(s) Remaining</code>.</li>
<li>Add a vertical box to <code>PlayerStates</code> with <code>Is Variable</code> set to <code>true</code> and a top padding of <code>50</code>. You should have the following:</li>
</ol>
<div><div><img alt="Figure 18.12 – The WBP_Scoreboard widget hierarchy " height="241" src="img/Figure_18.12_B18531.jpg" width="1199"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.12 – The WBP_Scoreboard widget hierarchy</p>
<ol>
<li value="18">Bind the <code>Text</code> value for <a id="_idIndexMarker1643"/>the <code>PickupsRemaining</code> text block with the following function:</li>
</ol>
<div><div><img alt="Figure 18.13 – Displaying the number of pickups remaining in the world " height="272" src="img/Figure_18.13_B18531.jpg" width="1045"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.13 – Displaying the number of pickups remaining in the world</p>
<ol>
<li value="19">Go to <code>Add Scoreboard Header</code> that adds an instance of <code>WBP_Scoreboard_Header</code> to <code>Player States</code>, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 18.14 – The Add Scoreboard Header event " height="172" src="img/Figure_18.14_B18531.jpg" width="928"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.14 – The Add Scoreboard Header event</p>
<ol>
<li value="20">Create a new event called <code>Add Scoreboard Entries</code>. This goes through all of the player states<a id="_idIndexMarker1644"/> ordered by score and adds an instance of <code>WBP_Scoreboard_Entry</code> to <code>Player States</code>, as demonstrated in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 18.15 – The Add Scoreboard Entries event " height="196" src="img/Figure_18.15_B18531.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.15 – The Add Scoreboard Entries event</p>
<ol>
<li value="21">Create a new event called <code>Update Scoreboard</code>. This event clears the widgets in <code>Player States</code> and calls <code>Add Scoreboard Header</code> and <code>Add Scoreboard Entries</code>, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 18.16 – The Update Scoreboard event " height="157" src="img/Figure_18.16_B18531.jpg" width="861"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.16 – The Update Scoreboard event</p>
<ol>
<li value="22">Implement <code>Event Construct</code> in the following way:</li>
</ol>
<div><div><img alt="Figure 18.17 – Event Construct " height="428" src="img/Figure_18.17_B18531.jpg" width="1166"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.17 – Event Construct</p>
<p>In the preceding code, we get the game state instance, update the scoreboard, and schedule a timer to <a id="_idIndexMarker1645"/>automatically call the <code>Update Scoreboard</code> event every <code>0.5</code> seconds.</p>
<ol>
<li value="23">Save and close <code>WBP_Scoreboard</code>.</li>
</ol>
<p>Now, let’s create the blueprint for the player controller. Follow these steps:</p>
<ol>
<li value="1">Go to <code>Content\Blueprints</code> and create a new blueprint called <code>BP_PlayerController</code> that derives from the <code>PickupsPlayerController</code> class.</li>
<li>Open the new blueprint and set <code>Scoreboard Menu</code> to use <code>WBP_Scoreboard</code>.</li>
<li>Save and close <code>BP_PlayerController</code>.</li>
</ol>
<p>Next, let’s create the blueprint for the game mode.</p>
<ol>
<li value="4">Create a new blueprint called <code>BP_GameMode</code> that derives from the <code>PickupsGameMode</code> class, open it, and change the following variables:<ul><li><code>PickupsGameState</code></li><li><code>BP_PlayerController</code></li><li><code>PickupsPlayerState</code></li></ul></li>
<li>Save and close <code>BP_GameMode</code>.</li>
<li>Next, let’s configure <strong class="bold">Project Settings</strong> so that it uses the new game mode.</li>
<li>Go to <strong class="bold">Project Settings</strong> and pick <strong class="bold">Maps &amp; Modes</strong> from the left panel, which is in the <strong class="bold">Project</strong> category.</li>
<li>Set <code>BP_GameMode</code>.</li>
<li>Close <strong class="bold">Project Settings</strong>.</li>
</ol>
<p>Now, let’s modify the main level. Follow these steps:</p>
<ol>
<li value="1">Make sure you have <code>ThirdPersonMap</code> opened, located in <code>Content\ThirdPerson\Maps</code>.</li>
<li>Add some cube actors to act as platforms. Make sure they have gaps between them to force the player to jump on them and possibly fall from the level.</li>
<li>Add a couple of player <a id="_idIndexMarker1646"/>start actors spread throughout the map.</li>
<li>Add at least 50 instances of <code>BP_Pickup</code> and spread them across the entire map.</li>
<li>Here is an example of a possible way of configuring the map:</li>
</ol>
<div><div><img alt="Figure 18.18 – An example of a map configuration " height="478" src="img/Figure_18.18_B18531.jpg" width="708"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.18 – An example of a map configuration</p>
<ol>
<li value="6">Go to <strong class="bold">World Settings</strong>, set <strong class="bold">GameMode Override</strong> to <strong class="bold">None</strong>, and save everything.</li>
<li>Go to <code>2</code>.</li>
<li>Set the window sizes to <code>800x600</code> and play using <strong class="bold">New Editor Window (PIE).</strong></li>
</ol>
<p>You should get the following output:</p>
<div><div><img alt="Figure 18.19 – The listen Server and Client 1 picking up cubes in the world " height="641" src="img/Figure_18.19_B18531.jpg" width="1614"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.19 – The listen Server and Client 1 picking up cubes in the world</p>
<p>By completing this exercise, you<a id="_idIndexMarker1647"/> can play on each client. You’ll notice that the characters can collect pickups and gain <strong class="bold">10</strong> points just by overlapping with them. If a character falls from the level, they will respawn on a random player start and lose <strong class="bold">10</strong> points.</p>
<p>Once all the pickups have been collected, the game will end, and after <strong class="bold">5</strong> seconds, it will perform a server travel to reload the same level and bring all the clients with it. You will also see that the UI displays how many pickups are remaining in the level, as well as the scoreboard with information about the name, score, and pickups for each player.</p>
<p>In the next activity, you’re going to add a scoreboard, kill limit, the concept of death/respawning, and the ability for the characters to pick up weapons, ammo, armor, and health in our multiplayer FPS game.</p>
<h1 id="_idParaDest-380"><a id="_idTextAnchor419"/>Activity 18.01 – Adding death, respawning, a scoreboard, kill limit, and pickups to the multiplayer FPS game</h1>
<p>In this activity, you’ll add the concept of death/respawning and the ability for a character to collect pickups to our multiplayer <a id="_idIndexMarker1648"/>FPS game. We’ll also add a scoreboard and a kill limit to the game so that it has an end goal.</p>
<p>Follow these steps to complete this activity:</p>
<ol>
<li value="1">Open the <code>MultiplayerFPS</code> project from <em class="italic">Activity 17.01 – Adding weapons and ammo to the multiplayer FPS game</em>. Compile the code and run the editor.</li>
<li>Create a C++ class called <code>FPSGameState</code>, which derives from the <code>GameState</code> class, and has a kill limit variable and a<a id="_idIndexMarker1649"/> function that returns the player states ordered by kills.</li>
<li>Create a C++ class called <code>FPSPlayerState</code>, which derives from the <code>PlayerState</code> class, and stores the number of kills and deaths of a player.</li>
<li>Create a C++ class called <code>PlayerMenu</code>, which derives from the <code>UserWidget</code> class, and has some <code>BlueprintImplementableEvent</code> functions to toggle the scoreboard visibility, set the <a id="_idIndexMarker1650"/>scoreboard visibility, and notify when a player was killed.</li>
<li>Create a C++ class called <code>FPSPlayerController</code>, which derives from <code>APlayerController</code>, that creates the <code>PlayerMenu</code> UMG widget instance on the owning client.</li>
<li>Create a C++ class called <code>Pickup</code>, which derives from the <code>Actor</code> class, and has a static mesh that rotates 90 degrees per second on the <code>Yaw</code> axis and can be picked up by the player on overlap. Once picked up, it plays a pickup sound and disables collision and visibility. After a certain amount of time, it will make it visible and able to collide again.</li>
<li>Create a C++ class called <code>AmmoPickup</code>, which derives from the <code>Pickup</code> class, and adds a certain amount of an ammo type to the player.</li>
<li>Create a C++ class called <code>ArmorPickup</code>, which derives from the <code>Pickup</code> class, and adds a certain amount of armor to the player.</li>
<li>Create a C++ class called <code>HealthPickup</code>, which derives from the <code>Pickup</code> class, and adds a certain amount of health to the player.</li>
<li>Create a C++ class called <code>WeaponPickup</code>, which derives from the <code>Pickup</code> class, and adds a certain weapon type to the player. If the player already has the weapon, it will add<a id="_idIndexMarker1651"/> a certain amount of ammo.</li>
<li>Edit the <code>FPSCharacter</code> class so that it does the following:<ul><li>After the character is damaged, it checks whether it’s dead. If it’s dead, it registers the kill for the killer character and the death of the player and respawn it. If the character is not dead, then it plays the pain sound on the owning client.</li><li>When the character dies and executes the <code>EndPlay</code> function, it should destroy all of its weapon instances.</li><li>If the character falls from the world, it will register the death of the player and respawn it.</li><li>If the player presses the <em class="italic">Tab</em> key, it will toggle the visibility of the scoreboard menu.</li></ul></li>
<li>Edit the <code>MultiplayerFPSGameModeBase</code> class so that it does the following:<ul><li>Uses the <code>GameMode</code> class instead of <code>GameModeBase</code></li><li>Stores the number of kills necessary to win the game.</li><li>Uses our custom player controller, player state, and game state classes.</li><li>Makes it implement the match state functions so that the match starts immediately and ends if there is a player that has the required number of kills.</li><li>When the match ends, it will perform a server travel to the same level after <code>5</code> seconds.</li><li>Handles when a player dies by adding the kill (when killed by another player) and the death to the <a id="_idIndexMarker1652"/>respective player state, as well as respawn the player on a random player start.</li></ul></li>
<li>Import <code>AmmoPickup.wav</code> from <code>Activity18.01\Assets</code> into <code>Content\Pickups\Ammo</code>.</li>
<li>Create <code>BP_PistolBullets_Pickup</code> from <code>AmmoPickup</code>, place it in <code>Content\Pickups\Ammo</code>, and configure it with the following values:<ul><li><code>(X=0.5, Y=0.5, Z=0.5)</code></li><li><code>Engine\BasicShapes\Cube</code></li><li><code>Content\Weapon\Pistol\MI_Pistol</code></li><li><code>Pistol Bullets</code></li><li><code>25</code></li><li><code>Content\Pickup\Ammo\AmmoPickup</code></li></ul></li>
<li>Create <code>BP_MachineGunBullets_Pickup</code> from <code>AmmoPickup</code>, place it in <code>Content\Pickups\Ammo</code>, and configure it with the following values:<ul><li><code>(X=0.5, Y=0.5, Z=0.5)</code></li><li><code>Engine\BasicShapes\Cube</code></li><li><code>Content\Weapon\MachineGun\MI_MachineGun</code></li><li><code>Machine Gun Bullets</code></li><li><code>50</code></li><li><code>Content\Pickup\Ammo\AmmoPickup</code></li></ul></li>
<li>Create <code>BP_Slugs_Pickup</code> from <code>AmmoPickup</code>, place it in <code>Content\Pickups\Ammo</code>, and configure<a id="_idIndexMarker1653"/> it with the following values:<ul><li><code>(X=0.5, Y=0.5, Z=0.5)</code></li><li><code>Engine\BasicShapes\Cube</code></li><li><code>Content\Weapon\Railgun\MI_Railgun</code></li><li><code>Slugs</code></li><li><code>5</code></li><li><code>Content\Pickup\Ammo\AmmoPickup</code></li></ul></li>
<li>Import <code>ArmorPickup.wav</code> from <code>Activity18.01\Assets</code> into <code>Content\Pickups\Armor</code>.</li>
<li>Create the <code>M_Armor</code> material in <code>Content\Pickups\Armor</code>, which has <code>Base Color</code> set to <code>blue</code> and <code>Metallic</code> set to <code>1</code>.</li>
<li>Create <code>BP_Armor_Pickup</code> from <code>ArmorPickup</code>, place it in <code>Content\Pickups\Armor</code>, and configure it with the following values:<ul><li><code>(X=1.0, Y=1.5, Z=1.0)</code></li><li><code>Engine\BasicShapes\Cube</code></li><li><code>Content\Pickup\Armor\M_Armor</code></li><li><code>50</code></li><li><code>Content\Pickup\Armor\ArmorPickup</code></li></ul></li>
<li>Import <code>HealthPickup.wav</code> from <code>Activity18.01\Assets</code> into <code>Content\Pickups\Health</code>.</li>
<li>Create the <code>M_Health</code> material in <code>Content\Pickups\Health</code>, which has <code>Base Color</code> set to <code>green</code> and <code>Metallic</code>/<code>Roughness</code> set to <code>0.5</code>.</li>
<li>Create <code>BP_Health_Pickup</code> from <code>HealthPickup</code>, place it in <code>Content\Pickups\Health</code>, and configure it with the following values:<ul><li><code>Engine\BasicShapes\Sphere</code></li><li><code>Content\Pickup\Health\M_Health</code></li><li><code>50</code></li><li><code>Content\Pickup\Health\HealthPickup</code></li></ul></li>
<li>Import <code>WeaponPickup.wav</code> from <code>Activity18.01\Assets</code> into <code>Content\Pickups\Weapon</code>.</li>
<li>Create <code>BP_Pistol_Pickup</code> from <code>WeaponPickup</code>, place it in <code>Content\Pickups\Weapon</code>, and configure it <a id="_idIndexMarker1654"/>with the following values:<ul><li><code>Content\Pickup\Weapon\SM_Weapon</code></li><li><code>Content\Weapon\Pistol\MI_Pistol</code></li><li><code>Pistol</code></li><li><code>25</code></li><li><code>Content\Pickup\Weapon\WeaponPickup</code></li></ul></li>
<li>Create <code>BP_MachineGun_Pickup</code> from <code>WeaponPickup</code>, place it in <code>Content\Pickups\Weapon</code>, and configure it with the following values:<ul><li><code>Content\Pickup\Weapon\SM_Weapon</code></li><li><code>Content\Weapon\MachineGun\MI_MachineGun</code></li><li><code>Machine Gun</code></li><li><code>50</code></li><li><code>Content\Pickup\Weapon\WeaponPickup</code></li></ul></li>
<li>Create <code>BP_Railgun_Pickup</code> from <code>WeaponPickup</code>, place it in <code>Content\Pickups\Weapon</code>, and configure it with the following values:<ul><li><code>Content\Pickup\Weapon\SM_Weapon</code></li><li><code>Content\Weapon\Railgun\MI_Railgun</code></li><li><code>Railgun</code></li><li><code>5</code></li><li><code>Content\Pickup\Weapon\WeaponPickup</code></li></ul></li>
<li>Import <code>Land.wav</code> and <code>Pain.wav</code> from <code>Activity18.01\Assets</code> into <code>Content\Player\Sounds</code>.</li>
<li>Edit <code>BP_Player</code> so that it<a id="_idIndexMarker1655"/> uses the <code>Pain</code> and <code>Land</code> sounds, as well as deletes all of the nodes that create and add the <code>WBP_HUD</code> instance to the viewport in the <code>Begin Play</code> event.</li>
<li>Create a UMG widget called <code>WBP_Scoreboard_Entry</code> in <code>Content\UI</code> that displays the name, kills, deaths, and ping of <code>FPSPlayerState</code>.</li>
<li>Create a UMG widget called <code>WBP_Scoreboard_Header</code> that displays the headers for the name, kills, deaths, and ping.</li>
<li>Create a UMG <a id="_idIndexMarker1656"/>widget called <code>WBP_Scoreboard</code> that displays the kill limit from the game state, a vertical box that has <code>WBP_Scoreboard_Header</code> as the first entry, and then add a <code>WBP_Scoreboard_Entry</code> for each <code>FPSPlayerState</code> in the game state instance. The vertical box will update every <code>0.5</code> seconds, through a timer, by clearing its children and adding them again.</li>
<li>Edit <code>WBP_HUD</code> so that it adds a new text block called <code>Killed</code> that starts with <code>Visibility</code> set to <code>Hidden</code>. When the player kills someone, it will make the text block visible, display the name of the killed player, and hide after <code>1</code> second.</li>
<li>Create a new <a id="_idIndexMarker1657"/>blueprint called <code>WBP_PlayerMenu</code> from <code>PlayerMenu</code> and place it in <code>Content\UI</code>. Use a widget switcher with an instance of <code>WBP_HUD</code> to index <code>0</code> and an instance of <code>WBP_Scoreboard</code> to index <code>1</code>. In the event graph, make sure that you override the <code>Toggle Scoreboard</code>, <code>Set Scoreboard Visibility</code>, and <code>Notify Kill</code> events that were set as <code>BlueprintImplementableEvent</code> in C++. The <code>Toggle Scoreboard</code> event toggles the widget switcher’s active index between <code>0</code> and <code>1</code>, the <code>Set Scoreboard Visibility</code> event sets the widget switcher’s active index to <code>0</code> or <code>1</code>, and the <code>Notify Kill</code> event tells the <code>WBP_HUD</code> instance to set the text and hide it after 1 second. </li>
<li>Create <code>BP_PlayerController</code> from <code>FPSPlayerController</code>, place it in the <code>Content</code> folder, and set the <code>PlayerMenuClass</code> variable to use <code>WBP_PlayerMenu</code>.</li>
<li>Edit <code>BP_GameMode</code> and set <code>Player Controller Class</code> to use <code>BP_PlayerController</code>.</li>
<li>Create the input action <code>IA_Scoreboard</code> to toggle the scoreboard with the <em class="italic">Tab</em> key and update <code>IMC_Player</code>.</li>
<li>Edit the <code>DM-Test</code> level so that you have at least three new player starts placed in different locations. Then, place an instance of every different pickup.</li>
<li>In <code>-500</code>.</li>
</ol>
<p><strong class="bold">Expected output</strong>:</p>
<div><div><img alt="Figure 18.20 – The expected output of the activity " height="640" src="img/Figure_18.20_B18531.jpg" width="1612"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.20 – The expected output of the activity</p>
<p>The result should be a project where each client’s character can use and switch between three different weapons. If a character kills another, it should register the kill and the death, as well as respawn the character that died at a random player start. You should have a scoreboard that displays the name, kill count, death count, and ping for each player. A character can fall from the level, which should only count as a death, and respawn at a random player start. The character should also be able to pick up the different pickups in the level to get ammo, armor, health, and weapons. The game should end when the kill limit has been reached by <a id="_idIndexMarker1658"/>showing the scoreboard and server travel to the same level after 5 seconds.</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution to this activity can be found on GitHub here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<h1 id="_idParaDest-381"><a id="_idTextAnchor420"/>Summary</h1>
<p>In this chapter, you learned that the instances of the gameplay framework classes exist in some specific game instances, but not in others. You also learned about the purpose of the game state and player state classes, as well as new concepts for the game mode and some useful built-in functionalities. </p>
<p>At the end of this chapter, you made a basic but functional multiplayer shooter that can be used as a foundation to build upon. You added new weapons, ammo types, fire modes, pickups, and so on to make it more feature-complete and fun.</p>
<p>Having completed this book, you should now have a better understanding of how to use UE5 to make games come to life. We’ve covered a lot of topics in this book, ranging from the simple to more advanced. You started by learning how to create projects using the different templates and how to use Blueprints to create actors and components. Then, you learned how to create a fully functioning <strong class="bold">Third Person</strong> template from scratch by importing the required assets and setting up the Animation Blueprint, Blend Space, game mode, and character, as well as defining and handling the inputs.</p>
<p>Then, you moved on to your first project – a simple stealth game that uses game physics and collisions, projectile movement components, actor components, interfaces, blueprint function libraries, UMG, sounds, and particle effects. Following this, you learned how to create a simple side-scrolling game by using AI, Anim Montages, and Destructible Meshes. Finally, you learned how to create a first-person multiplayer shooter by using the Server-Client architecture, variable replication, and RPCs, as well as how the Player State, Game State, and Game Mode classes work.</p>
<p>By working on various projects that use different parts of Unreal Engine, you now have a strong understanding of how UE5 works. Although this is the end of this book, this is just the beginning of your journey into the world of game development using UE5.</p>
</div>
</div></body></html>