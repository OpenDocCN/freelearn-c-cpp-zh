<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer565">
<h1 class="chapter-number" id="_idParaDest-368"><a id="_idTextAnchor404"/>18</h1>
<h1 id="_idParaDest-369"><a id="_idTextAnchor405"/>Using Gameplay Framework Classes in Multiplayer</h1>
<p>In the previous chapter, we covered <strong class="bold">remote procedure calls</strong> (<strong class="bold">RPCs</strong>), which allow the server and the clients to execute remote functions on each other. We also covered enumerations and array index wrapping, which allow you to iterate an array in both directions and loop around when you go beyond its limits.</p>
<p>In this chapter, we’re going to look at the most common gameplay framework classes and see where their instances exist in a multiplayer environment. This is important to understand so that you know which instances can be accessed in a specific game instance. An example of this is that only the server should be able to access the game mode instance because you don’t want clients to be able to modify the rules of the game.</p>
<p>We’ll also cover the game state and player state classes, which, as their names imply, store information about the state of the game and each player, respectively. Finally, toward the end of this chapter, we’ll cover some new concepts in the game mode, as well as some useful built-in functionality.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Accessing Gameplay Framework instances in multiplayer</li>
<li>Using Game Mode, Player State, and Game State</li>
</ul>
<p>By the end of this chapter, you’ll understand where the instances of the most important Gameplay Framework classes exist in multiplayer, as well as how the game state and player state store information that can be accessed by any client. You’ll also know how to make the most out of the Game Mode class and other useful built-in functionality.</p>
<h1 id="_idParaDest-370"><a id="_idTextAnchor406"/>Technical requirements</h1>
<p>This chapter has the following technical requirements:</p>
<ul>
<li>Unreal Engine 5 installed</li>
<li>Visual Studio 2019 installed</li>
</ul>
<p>The project for this chapter can be found in the <strong class="source-inline">Chapter18</strong> folder of the code bundle for this book, which can be downloaded here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition</a>.</p>
<p>In the next section, we will learn how to access the gameplay framework instances in multiplayer.</p>
<h1 id="_idParaDest-371"><a id="_idTextAnchor407"/>Accessing Gameplay Framework Instances in Multiplayer</h1>
<p>Unreal Engine comes with a set<a id="_idIndexMarker1569"/> of built-in classes (the Gameplay Framework) that provide the common functionality that most games require, such as a way to define the game rules (game mode), a way to control a <a id="_idIndexMarker1570"/>character (the player controller and pawn/character class), and so on. When an instance of a gameplay framework class is created in a multiplayer environment, we need to know if it exists on the server, the clients, or the owning client. With that in mind, an instance of the gameplay framework class will always fall into one of the following categories:</p>
<ul>
<li><strong class="bold">Server Only</strong>: The instance will only exist on the server.</li>
<li><strong class="bold">Server and Clients</strong>: The instance will exist on the server and the clients.</li>
<li><strong class="bold">Server and Owning Client</strong>: The instance will exist on the server and the owning client.</li>
<li><strong class="bold">Owning Client Only</strong>: The instance will only exist on the owning client.</li>
</ul>
<p>Take a look at the following diagram, which shows each category and where the most common classes in the <a id="_idIndexMarker1571"/>gameplay framework fall into:</p>
<div>
<div class="IMG---Figure" id="_idContainer543">
<img alt="Figure 18.1 – The most common gameplay framework classes divided into categories " height="555" src="image/Figure_18.01_B18531.jpg" width="1104"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.1 – The most common gameplay framework classes divided into categories</p>
<p>Let’s look at each <a id="_idIndexMarker1572"/>class in the preceding diagram in more detail:</p>
<ul>
<li><strong class="bold">Game Mode (Server Only)</strong>: The <strong class="source-inline">Game Mode</strong> class defines the rules of the game and its instance can only be accessed by the server. If a client tries to access it, the instance will always be invalid, to prevent clients from changing the game rules.</li>
<li><strong class="bold">Game State (Server and Clients)</strong>: The Game State class stores the state of the game and its instance can be accessed both by the server and the clients. The game state will be covered in greater depth in the next topic.</li>
<li><strong class="bold">Player State (Server and Clients)</strong>: The Player State class stores the state of a player and its instance can be accessed both by the server and the clients. The player state will be covered in greater depth in the next topic.</li>
<li><strong class="bold">Pawn (Server and Clients)</strong>: The <strong class="source-inline">Pawn</strong> class is the visual representation of a player and its instance can be accessed by the server and the clients.</li>
<li><strong class="bold">PlayerController (Server and Owning Client)</strong>: The <strong class="source-inline">Player Controller</strong> class represents the intent of a player, which is relayed to the currently possessed pawn, and its instance can only be accessed on the server and the owning client. For <a id="_idIndexMarker1573"/>security reasons, clients can’t access other clients’ player controllers, so they should use the server to communicate. If a client calls the <strong class="source-inline">UGameplayStatics::GetPlayerController</strong> function with an index other than <strong class="source-inline">0</strong> (which would return its player controller), the returned instance will always be invalid. This means that the server is the only place that has access to all of the player controllers. You can find out whether a player controller instance is in its owning client by calling the <strong class="source-inline">AController::IsLocalController</strong> function.</li>
<li><strong class="bold">HUD (Owning Client Only)</strong>: The HUD class is used as an immediate mode to draw basic shapes and text on the screen. Since it’s used for the UI, its instance is only available on the owning client, because the server and the other clients don’t need to know about it.</li>
<li><strong class="bold">UMG Widgets (Owning Client Only)</strong>: The UMG widget classes are used to display complex UI on the screen. Since it’s used for the UI, its instance is only available on the owning client, because the server and the other clients don’t need to know about it.</li>
</ul>
<p>To help you understand these concepts, we will use <em class="italic">Dota 2</em> as an example:</p>
<ul>
<li>The game mode defines that there are different phases of the game (pre-game for hero picking, the actual game, and the post-game phase with the winner) and that the end goal is to destroy the other team’s ancient. Since the game mode is a class that is critical to gameplay, clients can’t be allowed to access it.</li>
<li>The game state stores the elapsed time, whether it’s day or night, the score of each team, and so on, so the server and the clients need to be able to access it.</li>
<li>The player state stores the name, the hero selected, and the kill/death/assist ratio of a player, so the server and the clients need to be able to access it.</li>
<li>The pawn would be the hero, the courier, the illusions, and so on, controlled by the player, so the server <a id="_idIndexMarker1574"/>and the clients need to be able to access it.</li>
<li>The player controller is what relays the input information to the controlled pawn, so only the server and the owning client need to be able to access it.</li>
<li>The UI classes (<strong class="source-inline">HUD</strong> and <strong class="source-inline">User Widget</strong>) display all of the information on the owning client, so it only needs to be accessed there.</li>
</ul>
<p>In the next exercise, you will display the instance values of the most common gameplay framework classes.</p>
<h2 id="_idParaDest-372"><a id="_idTextAnchor408"/>Exercise 18.01 – Displaying the Gameplay Framework instance values</h2>
<p>In this exercise, we’re <a id="_idIndexMarker1575"/>going to create a new C++ project that uses the <strong class="bold">Third Person</strong> template, and we’re going to add the following:</p>
<ul>
<li>On the owning client, the player controller creates and adds a simple UMG widget to the viewport that displays the name of the menu instance.</li>
<li>On the <strong class="source-inline">Tick</strong> function, the character displays the value of its instance (as a pawn), as well as whether it has a valid instance for the game mode, game state, player state, player controller, and HUD.</li>
</ul>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li>Create a new <strong class="bold">Third Person</strong> template project using <strong class="bold">C++</strong> called <strong class="source-inline">GFInstances</strong> (as in Gameplay Framework Instances) and save it to a location of your liking. Once the project has been created, it should open the editor as well as the Visual Studio solution.</li>
<li>In the editor, create a new <strong class="source-inline">C++</strong> class called <strong class="source-inline">GFInstancePlayerController</strong> that derives from <strong class="source-inline">PlayerController</strong>. Wait for the compilation to end, close the editor, and go back to Visual Studio.</li>
<li>Open the <strong class="source-inline">GFInstancesCharacter.h</strong> file and declare the protected override for the <strong class="source-inline">Tick</strong> function:<p class="source-code">virtual void Tick(float DeltaSeconds) override;</p></li>
<li>Open the <strong class="source-inline">GFInstancesCharacter.cpp</strong> file and<a id="_idIndexMarker1576"/> implement the <strong class="source-inline">Tick</strong> function:<p class="source-code">void AGFInstancesCharacter::Tick(float DeltaSeconds)</p><p class="source-code">{</p><p class="source-code">  Super::Tick(DeltaSeconds);</p><p class="source-code">}</p></li>
<li>Get the instances for the game mode, game state, player controller, and HUD:<p class="source-code">const AGameModeBase* GameMode = GetWorld()-&gt;GetAuthGameMode();</p><p class="source-code">const AGameStateBase* GameState = GetWorld()-&gt;GetGameState();</p><p class="source-code">const APlayerController* PlayerController = </p><p class="source-code">  Cast&lt;APlayerController&gt;(GetController());</p><p class="source-code">const AHUD* HUD = PlayerController != nullptr ? PlayerController-&gt;GetHUD() : nullptr;</p></li>
</ol>
<p>In the preceding code snippet, we stored the instances for the game mode, game state, player controller, and HUD in separate variables so that we can check whether they are valid.</p>
<ol>
<li value="6">Create a string for each gameplay framework class:<p class="source-code">const FString GameModeString = GameMode != nullptr ? </p><p class="source-code">  TEXT("Valid") : TEXT("Invalid");</p><p class="source-code">const FString GameStateString = GameState != nullptr ? </p><p class="source-code">  TEXT("Valid") : TEXT("Invalid");</p><p class="source-code">const FString PlayerStateString = GetPlayerState() != nullptr ? TEXT("Valid") : TEXT("Invalid");</p><p class="source-code">const FString PawnString = GetName();</p><p class="source-code">const FString PlayerControllerString = PlayerController != nullptr ? TEXT("Valid") : TEXT("Invalid");</p><p class="source-code">const FString HUDString = HUD != nullptr ? TEXT("Valid"):</p><p class="source-code">  TEXT("Invalid");</p></li>
</ol>
<p>Here, we have created<a id="_idIndexMarker1577"/> strings to store the name of the pawn and checked whether the other gameplay framework instances are valid.</p>
<ol>
<li value="7">Display each string on the screen:<p class="source-code">const FString String = FString::Printf(TEXT("Game Mode = %s\nGame </p><p class="source-code">  State = %s\nPlayerState = %s\nPawn = %s\nPlayer Controller = </p><p class="source-code">  %s\nHUD = %s"), *GameModeString, *GameStateString, </p><p class="source-code">  *PlayerStateString, *PawnString, </p><p class="source-code">  *PlayerControllerString, </p><p class="source-code">  *HUDString);</p><p class="source-code">DrawDebugString(GetWorld(), GetActorLocation(), String, nullptr, FColor::White, 0.0f, true);</p></li>
</ol>
<p>In the preceding code snippet, we have printed the strings that indicate the name of the pawn and whether the other gameplay framework instances are valid.</p>
<ol>
<li value="8">Before we can move <a id="_idIndexMarker1578"/>on to the <strong class="source-inline">AGFInstancesPlayerController</strong> class, we need to tell Unreal Engine that we want to use the UMG functionality so that we can use the <strong class="source-inline">UUserWidget</strong> class. To do this, we need to open <strong class="source-inline">GFInstances.Build.cs</strong> and add <strong class="source-inline">UMG</strong> to the <strong class="source-inline">PublicDependencyModuleNames</strong> string array, like so:<p class="source-code">PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "HeadMountedDisplay", "UMG" });</p></li>
</ol>
<p>If you try to compile and get errors from adding the new module, then clean and recompile your project. If that doesn’t work, try restarting your IDE.</p>
<ol>
<li value="9">Open <strong class="source-inline">GFInstancesPlayerController.h</strong> and add the protected variables to create the UMG widget:<p class="source-code">UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "GF Instance Player Controller")</p><p class="source-code">TSubclassOf&lt;UUserWidget&gt; MenuClass;</p><p class="source-code">UPROPERTY()</p><p class="source-code">UUserWidget* Menu;</p></li>
<li>Declare the protected override for the <strong class="source-inline">BeginPlay</strong> function:<p class="source-code">virtual void BeginPlay() override;</p></li>
<li>Open <strong class="source-inline">GFInstancesPlayerController.cpp</strong> and include <strong class="source-inline">UserWidget.h</strong>:<p class="source-code">#include "Blueprint/UserWidget.h"</p></li>
<li>Implement the <strong class="source-inline">BeginPlay</strong> function:<p class="source-code">void AGFInstancePlayerController::BeginPlay()</p><p class="source-code">{</p><p class="source-code">  Super::BeginPlay();</p><p class="source-code">}</p></li>
<li>Create the widget and <a id="_idIndexMarker1579"/>add it to the viewport if it’s a local controller and the <strong class="source-inline">MenuClass</strong> variable is valid:<p class="source-code">if (IsLocalController() &amp;&amp; MenuClass != nullptr)</p><p class="source-code">{</p><p class="source-code">  Menu = CreateWidget&lt;UUserWidget&gt;(this, MenuClass);</p><p class="source-code">  if (Menu != nullptr)</p><p class="source-code">  {</p><p class="source-code">    Menu-&gt;AddToViewport(0);</p><p class="source-code">  }</p><p class="source-code">}</p></li>
<li>Compile and run the code.</li>
<li>In the <strong class="bold">Content Browser</strong> area, go to the <strong class="source-inline">Content</strong> folder, create a new folder called <strong class="source-inline">UI</strong>, and open it.</li>
<li>Create a new widget blueprint called <strong class="source-inline">WBP_Menu</strong> and open it.</li>
<li>Add a <strong class="source-inline">Canvas Panel</strong> to the <strong class="bold">Hierarchy</strong> panel.</li>
<li>Add a <strong class="bold">Text Block</strong> called <strong class="source-inline">Name</strong> to the <strong class="bold">canvas panel</strong> and set it to be a variable.</li>
<li>Change the text block <strong class="bold">Name</strong> so that its <strong class="bold">Size To Content</strong> is <strong class="source-inline">true</strong>.</li>
<li>Go to the <strong class="bold">Graph</strong> section and, in <strong class="bold">Event Graph</strong>, implement <strong class="source-inline">Event Construct</strong> in the following manner:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer546">
<img alt="Figure 18.2 – The Event Construct that displays the name of the WBP_Menu instance " height="241" src="image/Figure_18.02_B18531.jpg" width="833"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.2 – The Event Construct that displays the name of the WBP_Menu instance</p>
<ol>
<li value="21">Save and <a id="_idIndexMarker1580"/>close <strong class="source-inline">WBP_Menu</strong>.</li>
<li>Go to the <strong class="source-inline">Content</strong> folder and create a blueprint called <strong class="source-inline">BP_PlayerController</strong> that derives from <strong class="source-inline">GFInstancesPlayerController</strong>.</li>
<li>Open <strong class="source-inline">BP_PlayerController</strong> and set <strong class="source-inline">Menu Class</strong> to use <strong class="source-inline">WBP_Menu</strong>.</li>
<li>Save and close <strong class="source-inline">BP_PlayerController</strong>.</li>
<li>Create a blueprint called <strong class="source-inline">BP_GameMode</strong> that derives from <strong class="source-inline">GFInstancesGameMode</strong>.</li>
<li>Open <strong class="source-inline">BP_GameMode</strong> and set <strong class="source-inline">Player Controller Class</strong> to use <strong class="source-inline">BP_PlayerController</strong>.</li>
<li>Save and close <strong class="source-inline">BP_GameMode</strong>.</li>
<li>Go to <strong class="bold">World Settings</strong>, set <strong class="bold">GameMode Override</strong> to <strong class="bold">None</strong>, and save the map.</li>
<li>Go to <strong class="bold">Project Settings</strong> and pick <strong class="bold">Maps &amp; Modes</strong> from the left panel, which can be found in the <strong class="bold">Project</strong> category.</li>
<li>Set the <strong class="source-inline">Default</strong> Game Mode to use <strong class="source-inline">BP_GameMode</strong>.</li>
<li>Close <strong class="bold">Project Settings</strong>.</li>
</ol>
<p>Finally, you can test the project.</p>
<ol>
<li value="32">Go to <strong class="bold">Multiplayer Options</strong>, set <strong class="bold">Net Mode</strong> to <strong class="bold">Play As Listen Server</strong>, and set the <strong class="bold">Number of Players</strong> to <strong class="source-inline">2</strong>.</li>
<li>Set the window <a id="_idIndexMarker1581"/>sizes to <strong class="source-inline">800x600</strong> and play using <strong class="bold">New Editor Window (PIE)</strong>.</li>
</ol>
<p>You should get the following output:</p>
<div>
<div class="IMG---Figure" id="_idContainer547">
<img alt="Figure 18.3 – Expected result on the Server and Client 1 windows " height="640" src="image/Figure_18.03_B18531.jpg" width="1612"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.3 – Expected result on the Server and Client 1 windows</p>
<p>Now that you’ve completed this exercise, you’ll notice that each character displays its name, as well as if the instances for the game mode, game state, player state, player controller, and HUD are valid. It also displays the instance name of the <strong class="source-inline">WBP_Menu</strong> UMG widget in the top-left corner of the screen.</p>
<p>Now, let’s analyze the values that are displayed in the Server and Client 1 windows.</p>
<p class="callout-heading">Note</p>
<p class="callout">The two figures for the Server and Client 1 window will have two text blocks that say <strong class="source-inline">Server Character</strong> and <strong class="source-inline">Client 1 Character</strong>. These were added to the original screenshot to help <a id="_idIndexMarker1582"/>you understand which character i<a id="_idTextAnchor409"/>s which.</p>
<h2 id="_idParaDest-373"><a id="_idTextAnchor410"/>Output for the Server window</h2>
<p>Have a look at the<a id="_idIndexMarker1583"/> following output of the <strong class="source-inline">Server</strong> window from the previous exercise:</p>
<div>
<div class="IMG---Figure" id="_idContainer548">
<img alt="Figure 18.4 – The Server window " height="640" src="image/Figure_18.04_B18531.jpg" width="806"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.4 – The Server window</p>
<p>In the preceding screenshot, you have the values for <strong class="source-inline">Server Character</strong> and <strong class="source-inline">Client 1 Character</strong>. The <strong class="source-inline">WBP_Menu</strong> UMG widget is displayed in the top-left corner and is only created for the player controller of <strong class="source-inline">Server Character</strong> since it’s the only player controller in this window that controls a character.</p>
<p>First, let’s analyze the values for <strong class="source-inline">Server Ch<a id="_idTextAnchor411"/>aracter</strong>.</p>
<h3>Server Character</h3>
<p>This is the character that the listen server is controlling. The values that are displayed on this character are <a id="_idIndexMarker1584"/>as follows:</p>
<ul>
<li><strong class="bold">Game Mode = Valid</strong> because the <a id="_idIndexMarker1585"/>game mode instance only exists in the server, which is the case here</li>
<li><strong class="bold">Game State = Valid</strong> because the game state instance exists on the clients and the server, which is the case here</li>
<li><strong class="bold">Player State = Valid</strong> because the player state instance exists on the clients and the server, which is the case here</li>
<li><strong class="bold">Pawn = BP_ThirdPersonCharacter_C_0</strong> because pawn instances exist on the clients and the server, which is the case here</li>
<li><strong class="bold">Player Controller = Valid</strong> because player controller instances exist on the owning client and the server, which is the case here</li>
<li><strong class="bold">HUD = Valid</strong> because HUD instances only exist on the owning client, which is the case here</li>
</ul>
<p>Next, we are going to look at <strong class="source-inline">Client 1 Character</strong> in the sa<a id="_idTextAnchor412"/>me window.</p>
<h3>Client 1 Character</h3>
<p>This is the <a id="_idIndexMarker1586"/>character that <strong class="source-inline">Client 1</strong> is controlling. The values that are displayed on this character are <a id="_idIndexMarker1587"/>as follows:</p>
<ul>
<li><strong class="bold">Game Mode = Valid</strong> because the game mode instance only exists in the server, which is the case here</li>
<li><strong class="bold">Game State = Valid</strong> because the game state instance exists on the clients and the server, which is the case here</li>
<li><strong class="bold">Player State = Valid</strong> because the player state instance exists on the clients and the server, which is the case here</li>
<li><strong class="bold">Pawn = BP_ThirdPersonCharacter_C_1</strong> because pawn instances exist on the clients and the server, which is the case here</li>
<li><strong class="bold">Player Controller = Valid</strong> because player controller instances exist on the owning client and the server, which is the case here</li>
<li><strong class="bold">HUD = Invalid</strong> because HUD instances only exist on the owning client, which is not<a id="_idIndexMarker1588"/> the case here</li>
</ul>
<h2 id="_idParaDest-374"><a id="_idTextAnchor413"/>Output for the Client 1 window</h2>
<p>Have a look at <a id="_idIndexMarker1589"/>the following output of the <strong class="source-inline">Client 1</strong> window from the previous exercise:</p>
<div>
<div class="IMG---Figure" id="_idContainer549">
<img alt="Figure 18.5 – The Client 1 window " height="640" src="image/Figure_18.05_B18531.jpg" width="806"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.5 – The Client 1 window</p>
<p>In the preceding screenshot, you have the values for <strong class="source-inline">Client 1 Character</strong> and <strong class="source-inline">Server Character</strong>. The <strong class="source-inline">WBP_Menu</strong> UMG widget is displayed in the top-left corner and is only created for the player controller of <strong class="source-inline">Client 1 Character</strong> since it’s the only player controller in this window that controls a character.</p>
<p>First, let’s analyze the values for <strong class="source-inline">Client 1 Character</strong>.</p>
<h3>Client 1 Character</h3>
<p>This is the character that <strong class="source-inline">Client 1</strong> is controlling. The values<a id="_idIndexMarker1590"/> that are displayed on this character are as follows:</p>
<ul>
<li><strong class="bold">Game Mode = Invalid</strong> because the game mode instance only exists in the server, which is not the case here</li>
<li><strong class="bold">Game State = Valid</strong> because the game state instance exists on the server and the clients, which is the case here</li>
<li><strong class="bold">Player State = Valid</strong> because the player state instance exists on the server and the clients, which is the case here</li>
<li><strong class="bold">Pawn = BP_ThirdPersonCharacter_C_0</strong> because pawn instances exist on the server and the clients, which is the case here</li>
<li><strong class="bold">Player Controller = Valid</strong> because player controller instances exist on the server and the owning client, which is the case here</li>
<li><strong class="bold">HUD = Valid</strong> because HUD instances only exist on the owning client, which is the case here</li>
</ul>
<p>Next, we are going to look at <strong class="source-inline">Server Character</strong> in the same window.</p>
<h3>Server Character</h3>
<p>This is the character<a id="_idIndexMarker1591"/> that the listen server controls. The values that are displayed on this character are as follows:</p>
<ul>
<li><strong class="bold">Game Mode = Invalid</strong> because the game mode instance only exists in the server, which is not the case here</li>
<li><strong class="bold">Game State = Valid</strong> because the game state instance exists on the server and the clients, which is the case here</li>
<li><strong class="bold">Player State = Valid</strong> because the player state instance exists on the server and the clients, which is the case here</li>
<li><strong class="bold">Pawn = BP_ThirdPersonCharacter_C_1</strong> because pawn instances exist on the server and the clients, which is the case here</li>
<li><strong class="bold">Player Controller = Invalid</strong> because player controller instances exist on the server and the owning client, which is not the case here</li>
<li><strong class="bold">HUD = Invalid</strong> because HUD instances only exist on the owning client, which is not the case here</li>
</ul>
<p>By completing this<a id="_idIndexMarker1592"/> exercise, you should have a better understanding of where each instance of the gameplay framework class exists and where it doesn’t. In the next section, we’re going to cover the player state and game state classes, as well as some additional concepts regarding the game mode and useful built-in functionalities.</p>
<p>Using Game Mode, Player State, and Game State</p>
<p>So far, we’ve covered most of the important classes in the gameplay framework, including the game mode, player controller, and the pawn. In this section, we’re going to cover the player state, game state, and some additional concepts regarding the game mode, as well as some useful built-in functionalities.</p>
<h2 id="_idParaDest-375"><a id="_idTextAnchor414"/>Game mode</h2>
<p>We’ve already talked<a id="_idIndexMarker1593"/> about the game mode and how it works, but there are a few concepts that are useful to know about. Let’s take a look.</p>
<h3>Constructor</h3>
<p>To set the default class values, you<a id="_idIndexMarker1594"/> can use a constructor like so:</p>
<pre class="source-code">
ATestGameMode::ATestGameMode()
{
  DefaultPawnClass = AMyCharacter::StaticClass();
  PlayerControllerClass = 
  AMyPlayerController::StaticClass();
  PlayerStateClass = AMyPlayerState::StaticClass();
  GameStateClass = AMyGameState::StaticClass();
}</pre>
<p>The preceding code lets you specify which classes to use when spawning pawns, player controllers, player states, and<a id="_idIndexMarker1595"/> game states when we are using this game mode.</p>
<h3>Getting the game mode instance</h3>
<p>If you want to<a id="_idIndexMarker1596"/> access the game mode instance, you need to get it from the <strong class="source-inline">GetWorld</strong> function by using the following code:</p>
<pre class="source-code">
AGameModeBase* GameMode = GetWorld()-&gt;GetAuthGameMode();</pre>
<p>The preceding code allows you to access the current game mode instance, but you have to make sure that you are calling it on the server since this will be invalid on the clients due to security reasons.</p>
<h3>Match states</h3>
<p>So far, we’ve only been using the <strong class="source-inline">AGameModeBase</strong> class, which is the most basic game mode class in the <a id="_idIndexMarker1597"/>framework. Although it’s more than enough for certain types of games, there will be cases where you will require a bit more functionality. An example of this would be if we wanted to do a lobby system, where the match only starts if all the players have marked that they are ready. This example wouldn’t be possible to do with just the built-in function of the <strong class="source-inline">AGameModeBase</strong> class. For these cases, it’s better to use the <strong class="source-inline">AGameMode</strong> class instead, which is a child class of <strong class="source-inline">AGameModeBase</strong> that adds support for match states. The way match states work is by using a state machine that can only be in one of the following states at a given time:</p>
<ul>
<li><strong class="source-inline">EnteringMap</strong>: This is the starting state when the world is still loading and the actors aren’t ticking yet. It will transition to the <strong class="source-inline">WaitingToStart</strong> state once the world finishes loading.</li>
<li><strong class="source-inline">WaitingToStart</strong>: This state is set when the world has finished loading and the actors are ticking, although the pawns for the players won’t be spawned because the game hasn’t started yet. When the state machine enters this state, it will call the <strong class="source-inline">HandleMatchIsWaitingToStart</strong> function. The state machine will transition to the <strong class="source-inline">InProgress</strong> state if the <strong class="source-inline">ReadyToStartMatch</strong> function returns <strong class="source-inline">true</strong> or if the <strong class="source-inline">StartMatch</strong> function is called somewhere in the code.</li>
<li><strong class="source-inline">InProgress</strong>: This state is where the actual game takes place. When the state machine enters this<a id="_idIndexMarker1598"/> state, it will spawn the pawns for the players, call <strong class="source-inline">BeginPlay</strong> on all of the actors in the world, and call the <strong class="source-inline">HandleMatchHasStarted</strong> function. The state machine will transition to the <strong class="source-inline">WaitingPostMatch</strong> state if the <strong class="source-inline">ReadyToEndMatch</strong> function returns <strong class="source-inline">true</strong> or if the <strong class="source-inline">EndMatch</strong> function is called somewhere in the code.</li>
<li><strong class="source-inline">WaitingPostMatch</strong>: This state is set when the match ends. When the state machine enters this state, it will call the <strong class="source-inline">HandleMatchHasEnded</strong> function. In this state, actors still tick, but new players cannot join. It will transition to the <strong class="source-inline">LeavingMap</strong> state when it starts unloading the world.</li>
<li><strong class="source-inline">LeavingMap</strong>: This state is set while it’s unloading the world. When the state machine enters this state, it will call the <strong class="source-inline">HandleLeavingMap</strong> function. The state machine will transition to the <strong class="source-inline">EnteringMap</strong> state when it starts loading the new level.</li>
<li><strong class="source-inline">Aborted</strong>: This is a failed state that can only be set by calling the <strong class="source-inline">AbortMatch</strong> function, which is used to flag that something went wrong that prevented the match from happening.</li>
</ul>
<p>To help you understand these concepts better, we can use <em class="italic">Dota 2</em> again as an example:</p>
<ul>
<li><strong class="source-inline">EnteringMap</strong>: The state machine will be in this state when the map is loading.</li>
<li><strong class="source-inline">WaitingToStart</strong>: The state machine will be in this state once the map is loaded and the players are picking their heroes. The <strong class="source-inline">ReadyToStartMatch</strong> function will check whether all the players have selected their heroes; if they have, then the match can start.</li>
<li><strong class="source-inline">InProgress</strong>: The state machine will be in this state when the game is underway. The players control their heroes to farm and fight other players. The <strong class="source-inline">ReadyToEndMatch</strong> function will constantly check the health of each ancient to see whether one of them was destroyed; if it was, then the match ends.</li>
<li><strong class="source-inline">WaitingPostMatch</strong>: The state machine will be in this state when the game has ended and you can see the <a id="_idIndexMarker1599"/>destroyed ancient, as well as a message that displays the name of the winning team.</li>
<li><strong class="source-inline">LeavingMap</strong>: The state machine will be in this state when it’s unloading the map. </li>
<li><strong class="source-inline">Aborted</strong>: The state machine will be in this state if one of the players failed to connect in the initial stage, therefore aborting the whole match.</li>
</ul>
<h3>Respawning the player</h3>
<p>When the player dies and you <a id="_idIndexMarker1600"/>want to respawn it, you typically have two options. The first option is to reuse the same pawn instance, manually reset its state back to the defaults, and teleport it to the respawn location. The second option is to destroy the current pawn instance and spawn a new one, which will already have its state reset. If you prefer the latter option, then the <strong class="source-inline">AGameModeBase::RestartPlayer</strong> function handles the logic of spawning a new pawn instance for a certain player controller for you and places it on a player start.</p>
<p>One important thing to take into consideration is that the function only spawns a new pawn instance if the player controller doesn’t already possess a pawn, so make sure to destroy the controlled pawn before calling <strong class="source-inline">RestartPlayer</strong>.</p>
<p>Take a look at the following example:</p>
<pre class="source-code">
void ATestGameMode::OnDeath(APlayerController* VictimController)
{
  if(VictimController == nullptr)
  {
    return;
  }
 
  APawn* Pawn = VictimController-&gt;GetPawn();
  if(Pawn != nullptr)
  {
    Pawn-&gt;Destroy();
  }
  
  RestartPlayer(VictimController);
}</pre>
<p>In the preceding code, we have the <strong class="source-inline">OnDeath</strong> function, which takes the player controller of the player that died, destroys its controlled pawn, and calls the <strong class="source-inline">RestartPlayer</strong> function to <a id="_idIndexMarker1601"/>spawn a new instance. By default, the new pawn instance will spawn in the player start actor that was used when the player spawned for the first time. Alternatively, you can tell the game mode that you want to spawn on a random player start. To accomplish that, all you need to do is override the <strong class="source-inline">AGameModeBase::ShouldSpawnAtStartSpot</strong> function and force it to <strong class="source-inline">return false</strong>, like so:</p>
<pre class="source-code">
bool ATestGameMode::ShouldSpawnAtStartSpot(AController* Player)
{
  return false;
}</pre>
<p>The preceding code will make the game mode use a random player start instead of always using the first one that was used.</p>
<p class="callout-heading">Note</p>
<p class="callout">For more information about the game mode, please visit <a href="https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamemodes">https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamemodes</a> and <a href="https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameMode/index.xhtml">https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameMode/index.xhtml</a>.</p>
<h2 id="_idParaDest-376"><a id="_idTextAnchor415"/>Player state</h2>
<p>The player state class stores<a id="_idIndexMarker1602"/> the information that other clients need to know about a specific player (such as their current score, kills/deaths/assists, and so on) since they can’t access its player controller. The most widely used built-in functions are <strong class="source-inline">GetPlayerName()</strong>, <strong class="source-inline">GetScore</strong> and <strong class="source-inline">GetPingInMilliseconds()</strong>, which give you the name, score, and ping of the player, respectively.</p>
<p>A good example of how to use the player state is a scoreboard entry on a multiplayer shooter such as <em class="italic">Call Of Duty</em>, because every client needs to know the name, kills/deaths/assists, and ping for that player. The player state instance can be accessed in various ways, so let’s take a look at the most common ones:</p>
<h3>AController::PlayerState</h3>
<p>This variable contains the player state <a id="_idIndexMarker1603"/>associated with the controller and can only be accessed by the server and the owning client. The following example shows how to use the variable: </p>
<pre class="source-code">
APlayerState* PlayerState = Controller-&gt;PlayerState;</pre>
<h3>AController::GetPlayerState()</h3>
<p>This function returns the player state <a id="_idIndexMarker1604"/>associated with the controller and can only be accessed by the server and the owning client. This function also has a template version so that you can cast it to your own custom player state class. The following example shows how to use the default and template versions of this function:</p>
<pre class="source-code">
// Default version
APlayerState* PlayerState = Controller-&gt;GetPlayerState();
// Template version
ATestPlayerState* MyPlayerState = Controller-&gt;GetPlayerState&lt;ATestPlayerState&gt;();</pre>
<h3>APawn::GetPlayerState()</h3>
<p>This function returns the player state<a id="_idIndexMarker1605"/> associated with the controller that is possessing the pawn and can be accessed by the server and the clients. This function also has a template version so that you can cast it to your own custom player state class. The following example shows how to use the default and template versions of this function:</p>
<pre class="source-code">
// Default version
APlayerState* PlayerState = Pawn-&gt;GetPlayerState();
// Template version
ATestPlayerState* MyPlayerState = Pawn-
  &gt;GetPlayerState&lt;ATestPlayerState&gt;();</pre>
<h3>AGameState::PlayerArray</h3>
<p>This variable in the game <a id="_idIndexMarker1606"/>state (covered in the next section) stores the player state instances for each player and can be accessed on the server and the clients. The following example shows how to use this variable:</p>
<pre class="source-code">
TArray&lt;APlayerState*&gt; PlayerStates = GameState-&gt;PlayerArray;</pre>
<p>To help you understand these concepts better, we will use <em class="italic">Dota 2</em> again as an example. The player state would have at least the following variables:</p>
<ul>
<li><strong class="bold">Name</strong>: The name of the player</li>
<li><strong class="bold">Hero</strong>: The selected hero</li>
<li><strong class="bold">Health</strong>: The health of the hero</li>
<li><strong class="bold">Mana</strong>: The mana of the hero</li>
<li><strong class="bold">Stats</strong>: The hero stats</li>
<li><strong class="bold">Level</strong>: The level the hero is <a id="_idIndexMarker1607"/>currently in</li>
<li><strong class="bold">Kill/Death/Assist</strong>: The kill/death/assist ratio for the player</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">For more information about the player state, please visit <a href="https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/APlayerState/index.xhtml">https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/APlayerState/index.xhtml</a>.</p>
<h2 id="_idParaDest-377"><a id="_idTextAnchor416"/>Game State</h2>
<p>The game state class stores<a id="_idIndexMarker1608"/> the information that other clients need to know about the game (such as the match’s elapsed time and the score required to win the game) since they can’t access the game mode. The most widely used variable is <strong class="source-inline">PlayerArray</strong>, which is an array that provides the player state of every connected client. A good example of how to use the game state is a scoreboard on a multiplayer shooter such as <em class="italic">Call Of Duty</em> because every client needs to know how many kills are required to win, as well as the names, kills/deaths/assists, and pings for every connected player.</p>
<p>The game state instance can be accessed in various ways. Let’s take a look.</p>
<h3>UWorld::GetGameState()</h3>
<p>This function returns the game state <a id="_idIndexMarker1609"/>associated with the world and can be accessed on the server and the clients. This function also has a template version so that you can cast it to your own custom game state class. The following example shows how to use the default and template versions of this function:</p>
<pre class="source-code">
// Default version
AGameStateBase* GameState = GetWorld()-&gt;GetGameState();
// Template version
AMyGameState* MyGameState = GetWorld()-&gt;GetGameState&lt;AMyGameState&gt;();</pre>
<h3>AGameModeBase::GameState</h3>
<p>This variable contains the<a id="_idIndexMarker1610"/> game state associated with the game mode and can only be accessed on the server. The following example shows how to use the variable:</p>
<pre class="source-code">
AGameStateBase* GameState = GameMode-&gt;GameState;</pre>
<h3>AGameModeBase::GetGameState()</h3>
<p>This function returns the game state <a id="_idIndexMarker1611"/>associated with the game mode and can only be accessed on the server. This function also has a template version so that you can cast it to your own custom game state class. The following example shows how to use the default and template versions of this function:</p>
<pre class="source-code">
// Default version
AGameStateBase* GameState = GameMode-&gt;GetGameState&lt;AGameStateBase&gt;();
// Template version
AMyGameState* MyGameState = GameMode-&gt;GetGameState&lt;AMyGameState&gt;();</pre>
<p>To help you understand these concepts better, we will use <em class="italic">Dota 2</em> again as an example. The game state will have the following variables:</p>
<ul>
<li><strong class="bold">Elapsed Time</strong>: How long the match has been going on for</li>
<li><strong class="bold">Radiant Kills</strong>: How many Dire heroes the Radiant team has killed</li>
<li><strong class="bold">Dire Kills</strong>: How many Radiant heroes the Dire team has killed</li>
<li><strong class="bold">Day/Night Timer</strong>: Used to determine whether it is day or night</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">For more information<a id="_idIndexMarker1612"/> about the game state, please visit <a href="https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameState/index.xhtml">https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameState/index.xhtml</a>.</p>
<h2 id="_idParaDest-378"><a id="_idTextAnchor417"/>Useful built-in functionality</h2>
<p>UE5 comes with a lot of <a id="_idIndexMarker1613"/>functionality built in. Let’s look at some examples that are useful to know about when developing a game.</p>
<h3>void AActor::EndPlay(const EEndPlayReason::Type EndPlayReason)</h3>
<p>This function is called when the<a id="_idIndexMarker1614"/> actor has stopped playing, which is the opposite of the <strong class="source-inline">BeginPlay</strong> function. This function has a parameter called <strong class="source-inline">EndPlayReason</strong>, which tells you why the actor stopped playing (if it was destroyed, if you stopped <strong class="source-inline">PIE</strong>, and so on). Take a look at the following example, which prints to the screen that the actor has stopped playing:</p>
<pre class="source-code">
void ATestActor::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
  Super::EndPlay(EndPlayReason);
  const FString String = FString::Printf(TEXT("The actor %s 
  has just stopped playing"), *GetName());
  GEngine-&gt;AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, 
  String);
}</pre>
<h3>void ACharacter::Landed(const FHitResult&amp; Hit)</h3>
<p>This function is called when a player lands<a id="_idIndexMarker1615"/> on a surface after being in the air. Take a look at the following example, which plays a sound when a player lands on a surface:</p>
<pre class="source-code">
void ATestCharacter::Landed(const FHitResult&amp; Hit)
{
  Super::Landed(Hit);
  UGameplayStatics::PlaySound2D(GetWorld(), LandSound);
}</pre>
<h3>bool UWorld::ServerTravel(const FString&amp; FURL, bool bAbsolute, bool bShouldSkipGameNotify)</h3>
<p>This function will make the server<a id="_idIndexMarker1616"/> load a new map and bring all of the connected clients along with it. This is different from using other methods that load maps, such as the <strong class="source-inline">UGameplayStatics::OpenLevel</strong> function, because it won’t bring the clients along; it will just load the map on the server and disconnect the clients.</p>
<p>Take a look at the following example, which gets the current map name and uses server travel to reload it and bring along the connected clients:</p>
<pre class="source-code">
void ATestGameModeBase::RestartMap()
{
  const FString URL = GetWorld()-&gt;GetName();
  GetWorld()-&gt;ServerTravel(URL, false, false);
}</pre>
<h3>void TArray::Sort(const PREDICATE_CLASS&amp; Predicate)</h3>
<p>The <strong class="source-inline">TArray</strong> data structure comes with the <strong class="source-inline">Sort</strong> function, which allows you to sort the values of an array by using a lambda function that returns whether the <strong class="source-inline">A</strong> value should be ordered first, followed <a id="_idIndexMarker1617"/>by the <strong class="source-inline">B</strong> value. Take a look at the following example, which sorts an integer array from the smallest value to the highest:</p>
<pre class="source-code">
void ATestActor::SortValues()
{
  TArray&lt;int32&gt; SortTest;
  SortTest.Add(43);
  SortTest.Add(1);
  SortTest.Add(23);
  SortTest.Add(8);
  SortTest.Sort([](const int32&amp; A, const int32&amp; B) { return 
  A &lt; B; });
}</pre>
<p>The preceding code will sort the <strong class="source-inline">SortTest</strong> array’s values of [43, 1, 23, 8] from smallest to highest – that is, [1, 8, 23, 43].</p>
<h3>void AActor::FellOutOfWorld(const UDamageType&amp; DmgType)</h3>
<p>In Unreal Engine, there is a concept <a id="_idIndexMarker1618"/>called <strong class="bold">Kill Z</strong>, which is a plane on a certain value in <strong class="source-inline">Z</strong> (set in the <strong class="bold">World Settings</strong> panel). If an actor goes below that <strong class="source-inline">Z</strong> value, it will call the <strong class="source-inline">FellOutOfWorld</strong> function, which, by default, destroys the actor. Take a look at the following example, which prints to the screen that the actor fell out of the world:</p>
<pre class="source-code">
void AFPSCharacter::FellOutOfWorld(const UDamageType&amp; DmgType)
{
  Super::FellOutOfWorld(DmgType);
  const FString String = FString::Printf(TEXT("The actor %s 
  has fell out of the world"), *GetName());
  GEngine-&gt;AddOnScreenDebugMessage(-1, 2.0f, FColor::Red, 
  String);
}</pre>
<h3>URotatingMovementComponent</h3>
<p>This component rotates the <a id="_idIndexMarker1619"/>owning actor along time with a certain rate on each axis, defined in the <strong class="source-inline">RotationRate</strong> variable. To use it, you need to include the following header:</p>
<pre class="source-code">
#include "GameFramework/RotatingMovementComponent.h"</pre>
<p>You must also declare the component variable:</p>
<pre class="source-code">
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Test Actor")
URotatingMovementComponent* RotatingMovement;</pre>
<p>Finally, you must initialize it in the actor constructor, like so:</p>
<pre class="source-code">
RotatingMovement = CreateDefaultSubobject
  &lt;URotatingMovementComponent&gt;("Rotating Movement");
RotatingMovement-&gt;RotationRate = FRotator(0.0, 90.0f, 0);</pre>
<p>In the preceding code, <strong class="source-inline">RotationRate</strong> is set to rotate <strong class="source-inline">90</strong> degrees per second on the <strong class="source-inline">Yaw</strong> axis.</p>
<h2 id="_idParaDest-379"><a id="_idTextAnchor418"/>Exercise 18.02 – Making a simple multiplayer pickup game</h2>
<p>In this exercise, we’re going to create a new C++ project that uses the <strong class="bold">Third Person</strong> template. The following will happen:</p>
<ul>
<li>On the owning client, the player <a id="_idIndexMarker1620"/>controller will create and add to the viewport a UMG widget that, for each player, displays the score, sorted from highest to lowest, and how many pickups it has collected.</li>
<li>Create a simple pickup actor class that gives 10 points to the player that picked it up. The pickup will also rotate 90 degrees per second on the <strong class="source-inline">Yaw</strong> axis.</li>
<li>Set the <strong class="source-inline">Kill Z</strong> to <strong class="source-inline">-500</strong> and make the player respawn and lose 10 points every time they fall from the world.</li>
<li>The game will end when there are no more pickups available. Once the game ends, all characters will be destroyed and after 5 seconds, the server will do a server travel call to reload the same map and bring along the connected clients.</li>
</ul>
<p>Follow these steps to complete the C++ part of this exercise:</p>
<ol>
<li value="1">Create a new <strong class="bold">Third Person</strong> template project using <strong class="bold">C++</strong> called <strong class="source-inline">Pickups</strong> and save it to a location of your liking.</li>
<li>Once the project has been created, it should open the editor, as well as the Visual Studio solution.</li>
</ol>
<p>Now, let’s create the new C++ classes we’re going to use.</p>
<ol>
<li value="3">Create a <strong class="source-inline">Pickup</strong> class that derives from <strong class="source-inline">Actor</strong>.</li>
<li>Create a <strong class="source-inline">PickupsGameState</strong> class that derives from <strong class="source-inline">GameState</strong>.</li>
<li>Create a <strong class="source-inline">PickupsPlayerState</strong> class that derives from <strong class="source-inline">PlayerState</strong>.</li>
<li>Create a <strong class="source-inline">PickupsPlayerController</strong> class that derives from <strong class="source-inline">PlayerController</strong>.</li>
<li>Close the editor and open Visual Studio.</li>
</ol>
<p>Next, we’re going to work on the <strong class="source-inline">PickupsGameState</strong> class:</p>
<ol>
<li value="1">Open <strong class="source-inline">PickupsGameState.h</strong> and declare the protected replicated integer variable, <strong class="source-inline">PickupsRemaining</strong>, which tells all clients how many pickups remain in the level:<p class="source-code">UPROPERTY(Replicated, BlueprintReadOnly)</p><p class="source-code">int32 PickupsRemaining;</p></li>
<li>Declare the protected override for the <strong class="source-inline">BeginPlay</strong> function:<p class="source-code">virtual void BeginPlay() override;</p></li>
<li>Declare the protected <strong class="source-inline">GetPlayerStatesOrderedByScore</strong> function:<p class="source-code">UFUNCTION(BlueprintCallable)</p><p class="source-code">TArray&lt;APlayerState*&gt; GetPlayerStatesOrderedByScore() const;</p></li>
<li>Implement the <a id="_idIndexMarker1621"/>public <strong class="source-inline">RemovePickup</strong> function, which removes one pickup from the <strong class="source-inline">PickupsRemaining</strong> variable:<p class="source-code">void RemovePickup() { PickupsRemaining--; }</p></li>
<li>Implement the public <strong class="source-inline">HasPickups</strong> function, which returns whether any pickups remain:<p class="source-code">bool HasPickups() const { return PickupsRemaining &gt; 0; }</p></li>
<li>Open <strong class="source-inline">PickupsGameState.cpp</strong> and include <strong class="source-inline">Pickup.h</strong>, <strong class="source-inline">GameplayStatics.h</strong>, <strong class="source-inline">UnrealNetwork.h</strong>, and <strong class="source-inline">PlayerState.h</strong>:<p class="source-code">#include "Pickup.h"</p><p class="source-code">#include "Kismet/GameplayStatics.h"</p><p class="source-code">#include "Net/UnrealNetwork.h"</p><p class="source-code">#include "GameFramework/PlayerState.h"</p></li>
<li>Implement the <strong class="source-inline">GetLifetimeReplicatedProps</strong> function and make the <strong class="source-inline">PickupRemaining</strong> variable replicate to all clients:<p class="source-code">void APickupsGameState::GetLifetimeReplicatedProps(TArray&lt; </p><p class="source-code">  FLifetimeProperty &gt;&amp; OutLifetimeProps) const</p><p class="source-code">{</p><p class="source-code">  Super::GetLifetimeReplicatedProps(OutLifetimeProps);</p><p class="source-code">  DOREPLIFETIME(APickupsGameState, PickupsRemaining);</p><p class="source-code">}</p></li>
<li>Implement the <strong class="source-inline">BeginPlay</strong> override function and set the value of <strong class="source-inline">PickupsRemaining</strong> by getting <a id="_idIndexMarker1622"/>all the pickups in the world:<p class="source-code">void APickupsGameState::BeginPlay()</p><p class="source-code">{</p><p class="source-code">  Super::BeginPlay();</p><p class="source-code">  TArray&lt;AActor*&gt; Pickups;</p><p class="source-code">  UGameplayStatics::GetAllActorsOfClass(this, </p><p class="source-code">    APickup::StaticClass(), Pickups);</p><p class="source-code">  PickupsRemaining = Pickups.Num();</p><p class="source-code">}</p></li>
<li>Implement the <strong class="source-inline">GetPlayerStatesOrderedByScore</strong> function, which duplicates the <strong class="source-inline">PlayerArray</strong> variable and sorts it so that the players with the highest scores show up first:<p class="source-code">TArray&lt;APlayerState*&gt; APickupsGameState::GetPlayerStatesOrderedByScore() const</p><p class="source-code">{</p><p class="source-code">  TArray&lt;APlayerState*&gt; PlayerStates(PlayerArray);</p><p class="source-code">  PlayerStates.Sort([](const APlayerState&amp; A, const </p><p class="source-code">  APlayerState&amp; </p><p class="source-code">    B) { return A.GetScore() &gt; B.GetScore(); });</p><p class="source-code">  return PlayerStates;</p><p class="source-code">}</p></li>
</ol>
<p>Next, let’s work on the <strong class="source-inline">PickupsPlayerState</strong> class. Follow these steps:</p>
<ol>
<li value="1">Open <strong class="source-inline">PickupsPlayerState.h</strong> and declare the protected replicated integer variable, <strong class="source-inline">Pickups</strong>, which<a id="_idIndexMarker1623"/> indicates how many pickups a player has collected:<p class="source-code">UPROPERTY(Replicated, BlueprintReadOnly)</p><p class="source-code">int32 Pickups;</p></li>
<li>Implement the public <strong class="source-inline">AddPickup</strong> function, which adds one pickup to the <strong class="source-inline">Pickups</strong> variable:<p class="source-code">void AddPickup() { Pickups++; }</p></li>
<li>Open <strong class="source-inline">PickupsPlayerState.cpp</strong> and include <strong class="source-inline">UnrealNetwork.h</strong>:<p class="source-code">#include "Net/UnrealNetwork.h"</p></li>
<li>Implement the <strong class="source-inline">GetLifetimeReplicatedProps</strong> function and make the <strong class="source-inline">Pickups</strong> variable replicate to all clients:<p class="source-code">void APickupsPlayerState::GetLifetimeReplicatedProps(TArray&lt; </p><p class="source-code">  FLifetimeProperty &gt;&amp; OutLifetimeProps) const</p><p class="source-code">{</p><p class="source-code">  Super::GetLifetimeReplicatedProps(OutLifetimeProps);</p><p class="source-code">  DOREPLIFETIME(APickupsPlayerState, Pickups);</p><p class="source-code">}</p></li>
</ol>
<p>Next, let’s work on the <strong class="source-inline">PickupsPlayerController</strong> class.</p>
<ol>
<li value="5">Open <strong class="source-inline">PickupsPlayerController.h</strong> and declare the protected <strong class="source-inline">ScoreboardMenuClass</strong> variable, which will set the UMG widget class we want to use for our scoreboard:<p class="source-code">UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Pickup Player Controller")</p><p class="source-code">TSubclassOf&lt;class UUserWidget&gt; ScoreboardMenuClass;</p></li>
<li>Declare the protected <strong class="source-inline">ScoreboardMenu</strong> variable, which stores the scoreboard UMG <a id="_idIndexMarker1624"/>widget instance we will create on the <strong class="source-inline">BeginPlay</strong> function:<p class="source-code">UPROPERTY()</p><p class="source-code">class UUserWidget* ScoreboardMenu;</p></li>
<li>Declare the protected override for the <strong class="source-inline">BeginPlay</strong> function:<p class="source-code">virtual void BeginPlay() override;</p></li>
<li>Open <strong class="source-inline">PickupsPlayerController.cpp</strong> and include <strong class="source-inline">UserWidget.h</strong>:<p class="source-code">#include "Blueprint/UserWidget.h"</p></li>
<li>Implement the <strong class="source-inline">BeginPlay</strong> override function, which, for the owning client, creates and adds the scoreboard UMG widget to the viewport:<p class="source-code">void ApickupsPlayerController::BeginPlay()</p><p class="source-code">{</p><p class="source-code">  Super::BeginPlay();</p><p class="source-code">  if (IsLocalController() &amp;&amp; ScoreboardMenuClass != </p><p class="source-code">  nullptr)</p><p class="source-code">  {</p><p class="source-code">    ScoreboardMenu = CreateWidget&lt;UUserWidget&gt;(this, </p><p class="source-code">    ScoreboardMenuClass);</p><p class="source-code">    if (ScoreboardMenu != nullptr)</p><p class="source-code">    {</p><p class="source-code">      ScoreboardMenu-&gt;AddToViewport(0);</p><p class="source-code">    }</p><p class="source-code">  }  </p><p class="source-code">}</p></li>
</ol>
<p>Now, let’s edit the <strong class="source-inline">PickupsGameMode</strong> class:</p>
<ol>
<li value="1">Open <strong class="source-inline">PickupsGameMode.h</strong> and replace the <strong class="source-inline">#include</strong> statement for <strong class="source-inline">GameModeBase.h</strong> with <strong class="source-inline">GameMode.h</strong>:<p class="source-code">#include "GameFramework/GameMode.h"</p></li>
<li>Make the class <a id="_idIndexMarker1625"/>derive from <strong class="source-inline">AGameMode</strong> instead of <strong class="source-inline">AGameModeBase</strong>:<p class="source-code">class APickupsGameMode : public AGameMode</p></li>
<li>Declare the protected game state variable, <strong class="source-inline">MyGameState</strong>, which holds the instance of the <strong class="source-inline">APickupsGameState</strong> class:<p class="source-code">UPROPERTY()</p><p class="source-code">class APickupsGameState* MyGameState;</p></li>
<li>Move the constructor to the protected area and delete the public area.</li>
<li>Declare the protected override for the <strong class="source-inline">BeginPlay</strong> function:<p class="source-code">virtual void BeginPlay() override;</p></li>
<li>Declare the protected override for the <strong class="source-inline">ShouldSpawnAtStartSpot</strong> function:<p class="source-code">virtual bool ShouldSpawnAtStartSpot(AController* Player) </p><p class="source-code">  override;</p></li>
<li>Declare the protected overrides for the match state functions of the game mode:<p class="source-code">virtual void HandleMatchHasStarted() override;</p><p class="source-code">virtual void HandleMatchHasEnded() override;</p><p class="source-code">virtual bool ReadyToStartMatch_Implementation() override;</p><p class="source-code">virtual bool ReadyToEndMatch_Implementation() override;</p></li>
<li>Declare the<a id="_idIndexMarker1626"/> protected <strong class="source-inline">RestartMap</strong> function:<p class="source-code">void RestartMap() const;</p></li>
<li>Open <strong class="source-inline">PickupsGameMode.cpp</strong> and include <strong class="source-inline">GameplayStatics.h</strong> and <strong class="source-inline">PickupGameState.h</strong>:<p class="source-code">#include "Kismet/GameplayStatics.h"</p><p class="source-code">#include "PickupsGameState.h"</p></li>
<li>Implement the <strong class="source-inline">BeginPlay</strong> override function, which stores the <strong class="source-inline">APickupGameState</strong> instance:<p class="source-code">void APickupsGameMode::BeginPlay()</p><p class="source-code">{</p><p class="source-code">  Super::BeginPlay();</p><p class="source-code">  MyGameState = GetGameState&lt;APickupsGameState&gt;();</p><p class="source-code">}</p></li>
<li>Implement the <strong class="source-inline">ShouldSpawnAtStartSpot</strong> override function, which indicates that we want the players to respawn on a random player start and not always on the same one:<p class="source-code">bool APickupsGameMode::ShouldSpawnAtStartSpot</p><p class="source-code">  (AController* Player)</p><p class="source-code">{</p><p class="source-code">  return false;</p><p class="source-code">}</p></li>
<li>Implement the <strong class="source-inline">HandleMatchHasStarted</strong> override function, which prints to the screen, informing players that the game has started:<p class="source-code">void APickupsGameMode::HandleMatchHasStarted()</p><p class="source-code">{</p><p class="source-code">  Super::HandleMatchHasStarted();</p><p class="source-code">  GEngine-&gt;AddOnScreenDebugMessage(-1, 2.0f, </p><p class="source-code">  FColor::Green, "The game has started!");</p><p class="source-code">}</p></li>
<li>Implement the <strong class="source-inline">HandleMatchHasEnded</strong> override function, which prints to the screen, informing <a id="_idIndexMarker1627"/>players that the game has ended, destroys all characters, and schedules a timer to restart the map:<p class="source-code">void APickupsGameMode::HandleMatchHasEnded()</p><p class="source-code">{</p><p class="source-code">  Super::HandleMatchHasEnded();</p><p class="source-code">  GEngine-&gt;AddOnScreenDebugMessage(-1, 2.0f, </p><p class="source-code">  FColor::Red, "The game has ended!");</p><p class="source-code">  TArray&lt;AActor*&gt; Characters;</p><p class="source-code">    UGameplayStatics::GetAllActorsOfClass(this, </p><p class="source-code">    APickupsCharacter::StaticClass(), Characters);</p><p class="source-code">  for (AActor* Character : Characters)</p><p class="source-code">  {</p><p class="source-code">    Character-&gt;Destroy();</p><p class="source-code">  }</p><p class="source-code">  FTimerHandle TimerHandle;</p><p class="source-code">  GetWorldTimerManager().SetTimer(TimerHandle, this, </p><p class="source-code">    &amp;APickupsGameMode::RestartMap, 5.0f);</p><p class="source-code">}</p></li>
<li>Implement the <strong class="source-inline">ReadyToStartMatch_Implementation</strong> override function, which indicates <a id="_idIndexMarker1628"/>that the match can start straight away:<p class="source-code">bool APickupsGameMode::ReadyToStartMatch_Implementation()</p><p class="source-code">{</p><p class="source-code">  return true;</p><p class="source-code">}</p></li>
<li>Implement the <strong class="source-inline">ReadyToEndMatch_Implementation</strong> override function, which indicates that the match ends when the game state has no more pickups remaining:<p class="source-code">bool APickupsGameMode::ReadyToEndMatch_Implementation()</p><p class="source-code">{</p><p class="source-code">  return MyGameState != nullptr &amp;&amp; !MyGameState</p><p class="source-code">  -&gt;HasPickups();</p><p class="source-code">}</p></li>
<li>Implement the <strong class="source-inline">RestartMap</strong> function, which performs a server travel to the same level and brings all clients along:<p class="source-code">void APickupsGameMode::RestartMap() const</p><p class="source-code">{</p><p class="source-code">  GetWorld()-&gt;ServerTravel(GetWorld()-&gt;GetName(), </p><p class="source-code">  false, false);</p><p class="source-code">}</p></li>
</ol>
<p>Now, let’s edit the <strong class="source-inline">PickupsCharacter</strong> class. Follow<a id="_idIndexMarker1629"/> these steps:</p>
<ol>
<li value="1">Open <strong class="source-inline">PickupsCharacter.h</strong> and declare the protected sound variables for falling and landing:<p class="source-code">UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = </p><p class="source-code">  "Pickups Character")</p><p class="source-code">USoundBase* FallSound;</p><p class="source-code">UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = </p><p class="source-code">  "Pickups Character")</p><p class="source-code">USoundBase* LandSound;</p></li>
<li>Declare the protected override functions:<p class="source-code">virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;</p><p class="source-code">virtual void Landed(const FHitResult&amp; Hit) override;</p><p class="source-code">virtual void FellOutOfWorld(const UDamageType&amp; DmgType) override;</p></li>
<li>Declare the public functions that add scores and pickups to the player state:<p class="source-code">void AddScore(const float Score) const;</p><p class="source-code">void AddPickup() const;</p></li>
<li>Declare the public client RPC that plays a sound on the owning client:<p class="source-code">UFUNCTION(Client, Unreliable)</p><p class="source-code">void ClientPlaySound2D(USoundBase* Sound);</p></li>
<li>Open <strong class="source-inline">PickupsCharacter.cpp</strong> and include <strong class="source-inline">PickupsPlayerState.h</strong>, <strong class="source-inline">GameMode.h</strong>, <strong class="source-inline">PlayerState.h</strong>, and <strong class="source-inline">GameplayStatics.h</strong>:<p class="source-code">#include "PickupsPlayerState.h"</p><p class="source-code">#include "GameFramework/GameMode.h"</p><p class="source-code">#include "GameFramework/PlayerState.h"</p><p class="source-code">#include "Kismet/GameplayStatics.h"</p></li>
<li>Implement<a id="_idIndexMarker1630"/> the <strong class="source-inline">EndPlay</strong> override function, which plays the fall sound if the character was destroyed:<p class="source-code">void APickupsCharacter::EndPlay(const EEndPlayReason::Type EndPlayReason)</p><p class="source-code">{</p><p class="source-code">  Super::EndPlay(EndPlayReason);</p><p class="source-code">  if (EndPlayReason == EEndPlayReason::Destroyed)</p><p class="source-code">  {</p><p class="source-code">    UGameplayStatics::PlaySound2D(GetWorld(), </p><p class="source-code">    FallSound);</p><p class="source-code">  }</p><p class="source-code">}</p></li>
<li>Implement the <strong class="source-inline">Landed</strong> override function, which plays the landed sound:<p class="source-code">void APickupsCharacter::Landed(const FHitResult&amp; Hit)</p><p class="source-code">{</p><p class="source-code">  Super::Landed(Hit);</p><p class="source-code">  UGameplayStatics::PlaySound2D(GetWorld(), LandSound);</p><p class="source-code">}</p></li>
<li>Implement the <strong class="source-inline">FellOutOfWorld</strong> override function, which stores the controller, removes <strong class="source-inline">10</strong> points <a id="_idIndexMarker1631"/>from the score, destroys the character, and tells the game mode to restart the player using the previous controller:<p class="source-code">void APickupsCharacter::FellOutOfWorld(const UDamageType&amp; </p><p class="source-code">  DmgType)</p><p class="source-code">{</p><p class="source-code">  AController* TempController = Controller;</p><p class="source-code">  AddScore(-10);</p><p class="source-code">  Destroy();</p><p class="source-code">  AGameMode* GameMode = GetWorld()</p><p class="source-code">  -&gt;GetAuthGameMode&lt;AGameMode&gt;();</p><p class="source-code">  if (GameMode != nullptr)</p><p class="source-code">  {</p><p class="source-code">    GameMode-&gt;RestartPlayer(TempController);</p><p class="source-code">  }</p><p class="source-code">}</p></li>
<li>Implement the <strong class="source-inline">AddScore</strong> function, which adds a certain amount to the <strong class="source-inline">score</strong> in the player state:<p class="source-code">void APickupsCharacter::AddScore(const float Score) const</p><p class="source-code">{</p><p class="source-code">  APlayerState* MyPlayerState = GetPlayerState();</p><p class="source-code">  if (MyPlayerState != nullptr)</p><p class="source-code">  {</p><p class="source-code">    const float CurrentScore = MyPlayerState-&gt;GetScore();</p><p class="source-code">    MyPlayerState-&gt;SetScore(CurrentScore + Score);</p><p class="source-code">  }</p><p class="source-code">}</p></li>
<li>Implement the <strong class="source-inline">AddPickup</strong> function, which adds a pickup to the <strong class="source-inline">Pickup</strong> variable in our custom <a id="_idIndexMarker1632"/>player state:<p class="source-code">void APickupsCharacter::AddPickup() const</p><p class="source-code">{</p><p class="source-code">  APickupsPlayerState* MyPlayerState = </p><p class="source-code">    GetPlayerState&lt;APickupsPlayerState&gt;();</p><p class="source-code">  if (MyPlayerState != nullptr)</p><p class="source-code">  {</p><p class="source-code">    MyPlayerState-&gt;AddPickup();</p><p class="source-code">  }</p><p class="source-code">}</p></li>
<li>Implement the <strong class="source-inline">ClientPlaySound2D_Implementation</strong> function, which plays a sound on the owning client:<p class="source-code">void APickupsCharacter::ClientPlaySound2D_Implementation(USoundBase* Sound)</p><p class="source-code">{</p><p class="source-code">  UGameplayStatics::PlaySound2D(GetWorld(), Sound);</p><p class="source-code">}</p></li>
</ol>
<p>Now, let’s work on the <strong class="source-inline">Pickup</strong> class. Follow these steps:</p>
<ol>
<li value="1">Open <strong class="source-inline">Pickup.h</strong> and clear <a id="_idIndexMarker1633"/>all existing functions and delete the public areas.</li>
<li>Declare the protected <strong class="source-inline">Static Mesh</strong> component called <strong class="source-inline">Mesh</strong>:<p class="source-code">UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = </p><p class="source-code">  "Pickup")</p><p class="source-code">UStaticMeshComponent* Mesh;</p></li>
<li>Declare the protected rotating movement component called <strong class="source-inline">RotatingMovement</strong>:<p class="source-code">UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = </p><p class="source-code">  "Pickup")</p><p class="source-code">class URotatingMovementComponent* RotatingMovement;</p></li>
<li>Declare the protected <strong class="source-inline">PickupSound</strong> variable:<p class="source-code">UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = </p><p class="source-code">  "Pickup")</p><p class="source-code">USoundBase* PickupSound;</p></li>
<li>Declare the protected constructor and <strong class="source-inline">BeginPlay</strong> override:<p class="source-code">APickup();</p><p class="source-code">virtual void BeginPlay() override;</p></li>
<li>Declare the protected <strong class="source-inline">OnBeginOverlap</strong> function:<p class="source-code">UFUNCTION()</p><p class="source-code">void OnBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* </p><p class="source-code">  OtherActor, UPrimitiveComponent* OtherComp, int32 </p><p class="source-code">  OtherBodyIndex, bool bFromSweep, const FHitResult&amp; </p><p class="source-code">  Hit);</p></li>
<li>Open <strong class="source-inline">Pickup.cpp</strong> and include <strong class="source-inline">PickupsCharacter.h</strong>, <strong class="source-inline">PickupsGameState.h</strong>, and <strong class="source-inline">RotatingMovementComponent.h</strong> after <strong class="source-inline">Pickup.h</strong>:<p class="source-code">#include "PickupsCharacter.h"</p><p class="source-code">#include "PickupsGameState.h"</p><p class="source-code">#include "GameFramework/RotatingMovementComponent.h"</p></li>
<li>In the constructor, initialize<a id="_idIndexMarker1634"/> the <strong class="source-inline">Mesh</strong> component so that it overlaps everything and make it the root component:<p class="source-code">Mesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;("Mesh");</p><p class="source-code">Mesh-&gt;SetCollisionProfileName("OverlapAll");</p><p class="source-code">RootComponent = Mesh;</p></li>
<li>Still in the constructor, initialize the rotating movement component so that it rotates <strong class="source-inline">90</strong> degrees per second on the <strong class="source-inline">Yaw</strong> axis:<p class="source-code">RotatingMovement = CreateDefaultSubobject</p><p class="source-code">  &lt;URotatingMovementComponent&gt;("Rotating Movement");</p><p class="source-code">RotatingMovement-&gt;RotationRate = FRotator(0.0, 90.0f, 0);</p></li>
<li>To finalize the constructor, enable replication and disable the <strong class="source-inline">Tick</strong> function:<p class="source-code">bReplicates = true;</p><p class="source-code">PrimaryActorTick.bCanEverTick = false;</p></li>
<li>At the end of the <strong class="source-inline">BeginPlay</strong> function, bind the begin overlap event of <strong class="source-inline">Mesh</strong> to the <strong class="source-inline">OnBeginOverlap</strong> function:<p class="source-code">Mesh-&gt;OnComponentBeginOverlap.AddDynamic(this, &amp;APickup::OnBeginOverlap);</p></li>
<li>Delete the definition for the <strong class="source-inline">Tick</strong> function.</li>
<li>Implement the <strong class="source-inline">OnBeginOverlap</strong> function, which checks whether the character is valid and has <a id="_idIndexMarker1635"/>authority, removes the pickup from the game state, plays the pickup sound on the owning client, and adds <strong class="source-inline">10</strong> points and the pickup to the character. Once all of that is done, the pickup will destroy itself:<p class="source-code">void APickup::OnBeginOverlap(UPrimitiveComponent* OverlappedComp, </p><p class="source-code">  AActor* OtherActor, UPrimitiveComponent* OtherComp, </p><p class="source-code">  int32 </p><p class="source-code">  OtherBodyIndex, bool bFromSweep, const FHitResult&amp; </p><p class="source-code">  Hit)</p><p class="source-code">{</p><p class="source-code">  APickupsCharacter* Character = </p><p class="source-code">    Cast&lt;APickupsCharacter&gt;(OtherActor);</p><p class="source-code">  if (Character == nullptr || !HasAuthority())</p><p class="source-code">  {</p><p class="source-code">    return;</p><p class="source-code">  }</p><p class="source-code">  APickupsGameState* GameState = </p><p class="source-code">    Cast&lt;APickupsGameState&gt;(GetWorld()</p><p class="source-code">  -&gt;GetGameState());</p><p class="source-code">  if (GameState != nullptr)</p><p class="source-code">  {</p><p class="source-code">    GameState-&gt;RemovePickup();</p><p class="source-code">  }</p><p class="source-code">  Character-&gt;ClientPlaySound2D(PickupSound);</p><p class="source-code">  Character-&gt;AddScore(10);</p><p class="source-code">  Character-&gt;AddPickup();</p><p class="source-code">  Destroy();</p><p class="source-code">}</p></li>
<li>Open <strong class="source-inline">Pickups.Build.cs</strong> and add<a id="_idIndexMarker1636"/> the <strong class="source-inline">UMG</strong> module to <strong class="source-inline">PublicDependencyModuleNames</strong>, like so:<p class="source-code">PublicDependencyModuleNames.AddRange(new string[] { "Core", </p><p class="source-code">  "CoreUObject", "Engine", "InputCore", </p><p class="source-code">  "HeadMountedDisplay", </p><p class="source-code">  "UMG" });</p></li>
</ol>
<p>If you try to compile and get errors from adding the new module, then clean and recompile your project. If that doesn’t work, try restarting your IDE.</p>
<ol>
<li value="15">Compile and run the code until the editor loads. </li>
</ol>
<p>Once it’s loaded, we’re going to import some assets and create some blueprints that derive from the C++ classes we’ve just created.</p>
<p>First, let’s import the sound files:</p>
<ol>
<li value="1">In the <strong class="bold">Content Browser</strong>, create and go to the <strong class="source-inline">Content\Sounds</strong> folder.</li>
<li>Import <strong class="source-inline">Pickup.wav</strong>, <strong class="source-inline">Footstep.wav</strong>, <strong class="source-inline">Jump.wav</strong>, <strong class="source-inline">Land.wav</strong>, and <strong class="source-inline">Fall.wav</strong> from the <strong class="source-inline">Exercise18.02\Assets</strong> folder.</li>
<li>Save the new files.</li>
</ol>
<p>Next, we will add the <strong class="source-inline">Play Sound</strong> anim notifies to some of the character’s animations.</p>
<ol>
<li value="4">Open the <strong class="source-inline">MM_Jump</strong> animation, located in <strong class="source-inline">Content\Characters\Mannequins\Animations\Manny</strong>, and add a <strong class="source-inline">Play Sound</strong> anim notify at frame <strong class="source-inline">0</strong> using the <strong class="source-inline">Jump</strong> sound. </li>
<li>Save and close <strong class="source-inline">MM_Jump</strong>.</li>
<li>Open the <strong class="source-inline">MF_Run_Fwd</strong> animation, located in <strong class="source-inline">Content\Characters\Mannequins\Animations\Quinn</strong>, and add <strong class="source-inline">Play Sound</strong> anim notifies using the <strong class="source-inline">Footstep</strong> sound at <strong class="source-inline">0.24</strong>, <strong class="source-inline">0.56</strong>, <strong class="source-inline">0.82</strong>, <strong class="source-inline">1.12</strong>, <strong class="source-inline">1.38</strong>, and <strong class="source-inline">1.70</strong> seconds.</li>
<li>Save and <a id="_idIndexMarker1637"/>close <strong class="source-inline">MF_Run_Fwd</strong>.</li>
<li>Open the <strong class="source-inline">MF_Walk_Fwd</strong> animation, located in <strong class="source-inline">Content\Characters\Mannequins\Animations\Quinn</strong>, and add two <strong class="source-inline">Play Sound</strong> anim notifies using the <strong class="source-inline">Footstep</strong> sound at <strong class="source-inline">0.33, 0.72, 1.23,</strong> and <strong class="source-inline">1.7</strong> seconds.</li>
<li>Save and close <strong class="source-inline">MF_Walk_Fwd</strong>.</li>
</ol>
<p>Now, let’s set the sounds to use on the character blueprint:</p>
<ol>
<li value="1">Open the <strong class="source-inline">BP_ThirdPersonCharacter</strong> blueprint, located in <strong class="source-inline">Content\ThirdPerson\Blueprints</strong>, and set <strong class="source-inline">Fall Sound</strong> and <strong class="source-inline">Land Sound</strong> so that they use the <strong class="source-inline">Fall</strong> and <strong class="source-inline">Land</strong> sounds, respectively.</li>
<li>Save and close <strong class="source-inline">BP_ThirdPersonCharacter</strong>.</li>
</ol>
<p>Now, let’s create the blueprint for the pickup.</p>
<ol>
<li value="3">Create and open the <strong class="source-inline">Content\Blueprints</strong> folder.</li>
<li>Create a new blueprint called <strong class="source-inline">BP_Pickup</strong> that derives from the <strong class="source-inline">Pickup</strong> class and open it.</li>
<li>Configure the <strong class="source-inline">Static Mesh</strong> component in the following way:<ul><li><strong class="bold">Scale</strong>: <strong class="source-inline">(X=0.5, Y=0.5, Z=0.5)</strong></li><li><strong class="bold">Static Mesh</strong>: <strong class="source-inline">Engine\BasicShapes\Cube</strong></li><li><strong class="bold">Material</strong>: <strong class="source-inline">Engine\EngineMaterials\CubeMaterial</strong></li></ul></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">To display the Engine content, you need to click on the dropdown for the static mesh, click on the cog icon next to the filter box, and make sure that the <strong class="bold">Show Engine Content</strong> flag is set to <strong class="source-inline">true</strong>.</p>
<ol>
<li value="6">Set the <strong class="source-inline">Pickup Sound</strong> variable to use the <strong class="source-inline">Pickup</strong> sound.</li>
<li>Save and<a id="_idIndexMarker1638"/> close <strong class="source-inline">BP_Pickup</strong>.</li>
</ol>
<p>Now, let’s create the scoreboard UMG widgets. Follow these steps:</p>
<ol>
<li value="1">Create and go to the <strong class="source-inline">Content\UI</strong> folder.</li>
<li>Create a new widget blueprint called <strong class="source-inline">WBP_Scoreboard_Header</strong>:<ul><li>Add a <strong class="bold">Canvas Panel</strong> to the <strong class="bold">Hierarchy</strong> panel.</li><li>Add a text block called <strong class="bold">Name</strong> to the canvas panel with <strong class="bold">Is Variable</strong> set to <strong class="source-inline">true</strong>, <strong class="bold">Size To Content</strong> set to <strong class="source-inline">true</strong>, <strong class="bold">Text</strong> set to <strong class="source-inline">Player Name</strong>, and <strong class="bold">Color and Opacity</strong> set to use the color <strong class="source-inline">green</strong>.</li><li>Add a text block called <strong class="bold">Score</strong> to the canvas panel with <strong class="bold">Is Variable</strong> set to <strong class="source-inline">true</strong>, <strong class="bold">Position</strong><strong class="source-inline"> </strong><strong class="bold">X</strong><strong class="source-inline"> = 500</strong>, <strong class="bold">Alignment</strong><strong class="source-inline"> = 1.0, 0.0</strong>, <strong class="bold">Size To Content</strong> set to <strong class="source-inline">true</strong>, <strong class="bold">Text</strong> set to <strong class="source-inline">Score</strong>, and <strong class="bold">Color and Opacity</strong> set to use the color <strong class="source-inline">green</strong>.</li><li>Add a text block called <strong class="bold">Pickups</strong> to the canvas panel with <strong class="bold">Is Variable</strong> set to <strong class="source-inline">true</strong>, <strong class="bold">Position</strong><strong class="source-inline"> </strong><strong class="bold">X</strong><strong class="source-inline"> = 650</strong>, <strong class="bold">Alignment</strong><strong class="source-inline"> = 1.0, 0.0</strong>, <strong class="bold">Size To Content</strong> set to <strong class="source-inline">true</strong>, <strong class="bold">Text</strong> set to <strong class="source-inline">Pickups</strong>, and <strong class="bold">Color and Opacity</strong> set to use the color <strong class="source-inline">green</strong>.</li></ul></li>
<li>Save and close <strong class="source-inline">WBP_Scoreboard_Header</strong>.</li>
<li>Go back to <strong class="bold">Content\UI</strong>, duplicate <strong class="source-inline">WBP_Scoreboard_Header</strong>, rename it to <strong class="source-inline">WBP_Scoreboard_Entry</strong>, and open it.</li>
<li>Change the color of all of <a id="_idIndexMarker1639"/>the text blocks to <strong class="source-inline">white</strong> instead of <strong class="source-inline">green</strong>.</li>
<li>Go to the <strong class="bold">Graph</strong> section and create the <strong class="source-inline">Player State</strong> variable with the following configuration:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer550">
<img alt="Figure 18.6 – Creating the Player State variable " height="192" src="image/Figure_18.06_B18531.jpg" width="446"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.6 – Creating the Player State variable</p>
<ol>
<li value="7">Go back to the <strong class="bold">Designer</strong> section and create a text block called <strong class="source-inline">Name</strong> with <strong class="bold">Text</strong> set to <strong class="source-inline">Player Name</strong> and bind it to the <strong class="source-inline">GetPlayerName</strong> function from the dropdown, like so:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer551">
<img alt="Figure 18.7 – Binding the player name function " height="299" src="image/Figure_18.07_B18531.jpg" width="479"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.7 – Binding the player name function</p>
<ol>
<li value="8">Create a text block<a id="_idIndexMarker1640"/> called <strong class="source-inline">Score</strong> with <strong class="bold">Text</strong> set to <strong class="source-inline">Score</strong> and bind it to the <strong class="source-inline">Score</strong> variable from the dropdown, like so:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer552">
<img alt="Figure 18.8 – Binding the player score function " height="302" src="image/Figure_18.08_B18531.jpg" width="478"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.8 – Binding the player score function</p>
<ol>
<li value="9">Create a text block called <strong class="source-inline">Pickups</strong> with <strong class="bold">Text</strong> set to <strong class="source-inline">Pickups</strong> and bind it to the <strong class="source-inline">Pickups</strong> variable from the dropdown, like so:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer553">
<img alt="Figure 18.9 – Binding the pickups count function " height="282" src="image/Figure_18.09_B18531.jpg" width="471"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.9 – Binding the pickups count function</p>
<ol>
<li value="10">Create a pure function called <strong class="source-inline">Get Typeface</strong> that does the following:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer554">
<img alt="Figure 18.10 – Determining whether the entry should be displayed in Bold or Regular " height="322" src="image/Figure_18.10_B18531.jpg" width="972"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.10 – Determining whether the entry should be displayed in Bold or Regular</p>
<p>In the preceding code, we <a id="_idIndexMarker1641"/>used a <strong class="source-inline">Select</strong> node, which can be created by dragging a wire from the return value and releasing it on an empty space, and then typed <strong class="source-inline">Select</strong> on the filter. From there, we picked the <strong class="source-inline">Select</strong> node from the list. Here, we are using the <strong class="source-inline">Select</strong> node to pick the name of the typeface we’re going to use, so it should return <strong class="source-inline">Regular</strong> if the player state’s pawn is not the same as the pawn that owns the widget and <strong class="source-inline">Bold</strong> if it is. We do this to highlight the player’s state entry in bold so that the player knows what their entry is.</p>
<ol>
<li value="11">Implement <strong class="source-inline">Event Construct</strong> in the following way:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer555">
<img alt="Figure 18.11 – The Event Graph that sets the text for the name, score, and pickups count " height="518" src="image/Figure_18.11_B18531.jpg" width="692"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.11 – The Event Graph that sets the text for the name, score, and pickups count</p>
<p>In the preceding code, we set the font for <strong class="source-inline">Name</strong>, <strong class="source-inline">Score</strong>, and <strong class="source-inline">Pickups</strong> to use the <strong class="source-inline">Bold</strong> typeface to highlight which scoreboard entry is relative to the player of the current client. For <a id="_idIndexMarker1642"/>the remainder of the players, use the <strong class="source-inline">Regular</strong> typeface. If you can’t find the <strong class="bold">Roboto</strong> font, then pick <strong class="bold">Show Engine Content</strong> from the dropdown options.</p>
<ol>
<li value="12">Save and close <strong class="source-inline">WBP_Scoreboard_Entry</strong>.</li>
<li>Open <strong class="source-inline">WBP_Scoreboard</strong> and add a <strong class="bold">Canvas Panel</strong> to the <strong class="bold">Hierarchy</strong> panel.</li>
<li>Go to the <strong class="bold">Graph</strong> section and create a new variable called <strong class="source-inline">Game State</strong> of the <strong class="source-inline">Pickups Game State</strong> type.</li>
<li>Go back to the <strong class="bold">Designer</strong> section and add a vertical box called <strong class="source-inline">Scoreboard</strong> to the canvas panel with <strong class="bold">Size To Content</strong> set to <strong class="source-inline">true</strong>.</li>
<li>Add a text block to <strong class="source-inline">Scoreboard</strong> called <strong class="source-inline">PickupsRemaining</strong> with <strong class="source-inline">Text</strong> set to <strong class="source-inline">100 Pickup(s) Remaining</strong>.</li>
<li>Add a vertical box to <strong class="bold">Scoreboard</strong> called <strong class="source-inline">PlayerStates</strong> with <strong class="source-inline">Is Variable</strong> set to <strong class="source-inline">true</strong> and a top padding of <strong class="source-inline">50</strong>. You should have the following:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer556">
<img alt="Figure 18.12 – The WBP_Scoreboard widget hierarchy " height="241" src="image/Figure_18.12_B18531.jpg" width="1199"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.12 – The WBP_Scoreboard widget hierarchy</p>
<ol>
<li value="18">Bind the <strong class="source-inline">Text</strong> value for <a id="_idIndexMarker1643"/>the <strong class="source-inline">PickupsRemaining</strong> text block with the following function:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer557">
<img alt="Figure 18.13 – Displaying the number of pickups remaining in the world " height="272" src="image/Figure_18.13_B18531.jpg" width="1045"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.13 – Displaying the number of pickups remaining in the world</p>
<ol>
<li value="19">Go to <strong class="bold">Event Graph</strong> and create a new event called <strong class="source-inline">Add Scoreboard Header</strong> that adds an instance of <strong class="source-inline">WBP_Scoreboard_Header</strong> to <strong class="source-inline">Player States</strong>, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer558">
<img alt="Figure 18.14 – The Add Scoreboard Header event " height="172" src="image/Figure_18.14_B18531.jpg" width="928"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.14 – The Add Scoreboard Header event</p>
<ol>
<li value="20">Create a new event called <strong class="source-inline">Add Scoreboard Entries</strong>. This goes through all of the player states<a id="_idIndexMarker1644"/> ordered by score and adds an instance of <strong class="source-inline">WBP_Scoreboard_Entry</strong> to <strong class="source-inline">Player States</strong>, as demonstrated in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer559">
<img alt="Figure 18.15 – The Add Scoreboard Entries event " height="196" src="image/Figure_18.15_B18531.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.15 – The Add Scoreboard Entries event</p>
<ol>
<li value="21">Create a new event called <strong class="source-inline">Update Scoreboard</strong>. This event clears the widgets in <strong class="source-inline">Player States</strong> and calls <strong class="source-inline">Add Scoreboard Header</strong> and <strong class="source-inline">Add Scoreboard Entries</strong>, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer560">
<img alt="Figure 18.16 – The Update Scoreboard event " height="157" src="image/Figure_18.16_B18531.jpg" width="861"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.16 – The Update Scoreboard event</p>
<ol>
<li value="22">Implement <strong class="source-inline">Event Construct</strong> in the following way:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer561">
<img alt="Figure 18.17 – Event Construct " height="428" src="image/Figure_18.17_B18531.jpg" width="1166"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.17 – Event Construct</p>
<p>In the preceding code, we get the game state instance, update the scoreboard, and schedule a timer to <a id="_idIndexMarker1645"/>automatically call the <strong class="source-inline">Update Scoreboard</strong> event every <strong class="source-inline">0.5</strong> seconds.</p>
<ol>
<li value="23">Save and close <strong class="source-inline">WBP_Scoreboard</strong>.</li>
</ol>
<p>Now, let’s create the blueprint for the player controller. Follow these steps:</p>
<ol>
<li value="1">Go to <strong class="source-inline">Content\Blueprints</strong> and create a new blueprint called <strong class="source-inline">BP_PlayerController</strong> that derives from the <strong class="source-inline">PickupsPlayerController</strong> class.</li>
<li>Open the new blueprint and set <strong class="source-inline">Scoreboard Menu</strong> to use <strong class="source-inline">WBP_Scoreboard</strong>.</li>
<li>Save and close <strong class="source-inline">BP_PlayerController</strong>.</li>
</ol>
<p>Next, let’s create the blueprint for the game mode.</p>
<ol>
<li value="4">Create a new blueprint called <strong class="source-inline">BP_GameMode</strong> that derives from the <strong class="source-inline">PickupsGameMode</strong> class, open it, and change the following variables:<ul><li><strong class="bold">Game State Class</strong>: <strong class="source-inline">PickupsGameState</strong></li><li><strong class="bold">Player Controller Class</strong>: <strong class="source-inline">BP_PlayerController</strong></li><li><strong class="bold">Player State Class</strong>: <strong class="source-inline">PickupsPlayerState</strong></li></ul></li>
<li>Save and close <strong class="source-inline">BP_GameMode</strong>.</li>
<li>Next, let’s configure <strong class="bold">Project Settings</strong> so that it uses the new game mode.</li>
<li>Go to <strong class="bold">Project Settings</strong> and pick <strong class="bold">Maps &amp; Modes</strong> from the left panel, which is in the <strong class="bold">Project</strong> category.</li>
<li>Set <strong class="bold">Default GameMode</strong> to use <strong class="source-inline">BP_GameMode</strong>.</li>
<li>Close <strong class="bold">Project Settings</strong>.</li>
</ol>
<p>Now, let’s modify the main level. Follow these steps:</p>
<ol>
<li value="1">Make sure you have <strong class="source-inline">ThirdPersonMap</strong> opened, located in <strong class="source-inline">Content\ThirdPerson\Maps</strong>.</li>
<li>Add some cube actors to act as platforms. Make sure they have gaps between them to force the player to jump on them and possibly fall from the level.</li>
<li>Add a couple of player <a id="_idIndexMarker1646"/>start actors spread throughout the map.</li>
<li>Add at least 50 instances of <strong class="source-inline">BP_Pickup</strong> and spread them across the entire map.</li>
<li>Here is an example of a possible way of configuring the map:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer562">
<img alt="Figure 18.18 – An example of a map configuration " height="478" src="image/Figure_18.18_B18531.jpg" width="708"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.18 – An example of a map configuration</p>
<ol>
<li value="6">Go to <strong class="bold">World Settings</strong>, set <strong class="bold">GameMode Override</strong> to <strong class="bold">None</strong>, and save everything.</li>
<li>Go to <strong class="bold">Multiplayer Options</strong>, set <strong class="bold">Net Mode</strong> to <strong class="bold">Play As Listen Server</strong>, and set <strong class="bold">Number of Players</strong> to <strong class="source-inline">2</strong>.</li>
<li>Set the window sizes to <strong class="source-inline">800x600</strong> and play using <strong class="bold">New Editor Window (PIE).</strong></li>
</ol>
<p>You should get the following output:</p>
<div>
<div class="IMG---Figure" id="_idContainer563">
<img alt="Figure 18.19 – The listen Server and Client 1 picking up cubes in the world " height="641" src="image/Figure_18.19_B18531.jpg" width="1614"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.19 – The listen Server and Client 1 picking up cubes in the world</p>
<p>By completing this exercise, you<a id="_idIndexMarker1647"/> can play on each client. You’ll notice that the characters can collect pickups and gain <strong class="bold">10</strong> points just by overlapping with them. If a character falls from the level, they will respawn on a random player start and lose <strong class="bold">10</strong> points.</p>
<p>Once all the pickups have been collected, the game will end, and after <strong class="bold">5</strong> seconds, it will perform a server travel to reload the same level and bring all the clients with it. You will also see that the UI displays how many pickups are remaining in the level, as well as the scoreboard with information about the name, score, and pickups for each player.</p>
<p>In the next activity, you’re going to add a scoreboard, kill limit, the concept of death/respawning, and the ability for the characters to pick up weapons, ammo, armor, and health in our multiplayer FPS game.</p>
<h1 id="_idParaDest-380"><a id="_idTextAnchor419"/>Activity 18.01 – Adding death, respawning, a scoreboard, kill limit, and pickups to the multiplayer FPS game</h1>
<p>In this activity, you’ll add the concept of death/respawning and the ability for a character to collect pickups to our multiplayer <a id="_idIndexMarker1648"/>FPS game. We’ll also add a scoreboard and a kill limit to the game so that it has an end goal.</p>
<p>Follow these steps to complete this activity:</p>
<ol>
<li value="1">Open the <strong class="source-inline">MultiplayerFPS</strong> project from <em class="italic">Activity 17.01 – Adding weapons and ammo to the multiplayer FPS game</em>. Compile the code and run the editor.</li>
<li>Create a C++ class called <strong class="source-inline">FPSGameState</strong>, which derives from the <strong class="source-inline">GameState</strong> class, and has a kill limit variable and a<a id="_idIndexMarker1649"/> function that returns the player states ordered by kills.</li>
<li>Create a C++ class called <strong class="source-inline">FPSPlayerState</strong>, which derives from the <strong class="source-inline">PlayerState</strong> class, and stores the number of kills and deaths of a player.</li>
<li>Create a C++ class called <strong class="source-inline">PlayerMenu</strong>, which derives from the <strong class="source-inline">UserWidget</strong> class, and has some <strong class="source-inline">BlueprintImplementableEvent</strong> functions to toggle the scoreboard visibility, set the <a id="_idIndexMarker1650"/>scoreboard visibility, and notify when a player was killed.</li>
<li>Create a C++ class called <strong class="source-inline">FPSPlayerController</strong>, which derives from <strong class="source-inline">APlayerController</strong>, that creates the <strong class="source-inline">PlayerMenu</strong> UMG widget instance on the owning client.</li>
<li>Create a C++ class called <strong class="source-inline">Pickup</strong>, which derives from the <strong class="source-inline">Actor</strong> class, and has a static mesh that rotates 90 degrees per second on the <strong class="source-inline">Yaw</strong> axis and can be picked up by the player on overlap. Once picked up, it plays a pickup sound and disables collision and visibility. After a certain amount of time, it will make it visible and able to collide again.</li>
<li>Create a C++ class called <strong class="source-inline">AmmoPickup</strong>, which derives from the <strong class="source-inline">Pickup</strong> class, and adds a certain amount of an ammo type to the player.</li>
<li>Create a C++ class called <strong class="source-inline">ArmorPickup</strong>, which derives from the <strong class="source-inline">Pickup</strong> class, and adds a certain amount of armor to the player.</li>
<li>Create a C++ class called <strong class="source-inline">HealthPickup</strong>, which derives from the <strong class="source-inline">Pickup</strong> class, and adds a certain amount of health to the player.</li>
<li>Create a C++ class called <strong class="source-inline">WeaponPickup</strong>, which derives from the <strong class="source-inline">Pickup</strong> class, and adds a certain weapon type to the player. If the player already has the weapon, it will add<a id="_idIndexMarker1651"/> a certain amount of ammo.</li>
<li>Edit the <strong class="source-inline">FPSCharacter</strong> class so that it does the following:<ul><li>After the character is damaged, it checks whether it’s dead. If it’s dead, it registers the kill for the killer character and the death of the player and respawn it. If the character is not dead, then it plays the pain sound on the owning client.</li><li>When the character dies and executes the <strong class="source-inline">EndPlay</strong> function, it should destroy all of its weapon instances.</li><li>If the character falls from the world, it will register the death of the player and respawn it.</li><li>If the player presses the <em class="italic">Tab</em> key, it will toggle the visibility of the scoreboard menu.</li></ul></li>
<li>Edit the <strong class="source-inline">MultiplayerFPSGameModeBase</strong> class so that it does the following:<ul><li>Uses the <strong class="source-inline">GameMode</strong> class instead of <strong class="source-inline">GameModeBase</strong></li><li>Stores the number of kills necessary to win the game.</li><li>Uses our custom player controller, player state, and game state classes.</li><li>Makes it implement the match state functions so that the match starts immediately and ends if there is a player that has the required number of kills.</li><li>When the match ends, it will perform a server travel to the same level after <strong class="source-inline">5</strong> seconds.</li><li>Handles when a player dies by adding the kill (when killed by another player) and the death to the <a id="_idIndexMarker1652"/>respective player state, as well as respawn the player on a random player start.</li></ul></li>
<li>Import <strong class="source-inline">AmmoPickup.wav</strong> from <strong class="source-inline">Activity18.01\Assets</strong> into <strong class="source-inline">Content\Pickups\Ammo</strong>.</li>
<li>Create <strong class="source-inline">BP_PistolBullets_Pickup</strong> from <strong class="source-inline">AmmoPickup</strong>, place it in <strong class="source-inline">Content\Pickups\Ammo</strong>, and configure it with the following values:<ul><li><strong class="bold">Scale</strong>: <strong class="source-inline">(X=0.5, Y=0.5, Z=0.5)</strong></li><li><strong class="bold">Static Mesh</strong>: <strong class="source-inline">Engine\BasicShapes\Cube</strong></li><li><strong class="bold">Material</strong>: <strong class="source-inline">Content\Weapon\Pistol\MI_Pistol</strong></li><li><strong class="bold">Ammo Type</strong>: <strong class="source-inline">Pistol Bullets</strong></li><li><strong class="bold">Ammo Amount</strong>: <strong class="source-inline">25</strong></li><li><strong class="bold">Pickup Sound</strong>: <strong class="source-inline">Content\Pickup\Ammo\AmmoPickup</strong></li></ul></li>
<li>Create <strong class="source-inline">BP_MachineGunBullets_Pickup</strong> from <strong class="source-inline">AmmoPickup</strong>, place it in <strong class="source-inline">Content\Pickups\Ammo</strong>, and configure it with the following values:<ul><li><strong class="bold">Scale</strong>: <strong class="source-inline">(X=0.5, Y=0.5, Z=0.5)</strong></li><li><strong class="bold">Static Mesh</strong>: <strong class="source-inline">Engine\BasicShapes\Cube</strong></li><li><strong class="bold">Material</strong>: <strong class="source-inline">Content\Weapon\MachineGun\MI_MachineGun</strong></li><li><strong class="bold">Ammo Type</strong>: <strong class="source-inline">Machine Gun Bullets</strong></li><li><strong class="bold">Ammo Amount</strong>: <strong class="source-inline">50</strong></li><li><strong class="bold">Pickup Sound</strong>: <strong class="source-inline">Content\Pickup\Ammo\AmmoPickup</strong></li></ul></li>
<li>Create <strong class="source-inline">BP_Slugs_Pickup</strong> from <strong class="source-inline">AmmoPickup</strong>, place it in <strong class="source-inline">Content\Pickups\Ammo</strong>, and configure<a id="_idIndexMarker1653"/> it with the following values:<ul><li><strong class="bold">Scale</strong>: <strong class="source-inline">(X=0.5, Y=0.5, Z=0.5)</strong></li><li><strong class="bold">Static Mesh</strong>: <strong class="source-inline">Engine\BasicShapes\Cube</strong></li><li><strong class="bold">Material</strong>: <strong class="source-inline">Content\Weapon\Railgun\MI_Railgun</strong></li><li><strong class="bold">Ammo Type</strong>: <strong class="source-inline">Slugs</strong></li><li><strong class="bold">Ammo Amount</strong>: <strong class="source-inline">5</strong></li><li><strong class="bold">Pickup Sound</strong>: <strong class="source-inline">Content\Pickup\Ammo\AmmoPickup</strong></li></ul></li>
<li>Import <strong class="source-inline">ArmorPickup.wav</strong> from <strong class="source-inline">Activity18.01\Assets</strong> into <strong class="source-inline">Content\Pickups\Armor</strong>.</li>
<li>Create the <strong class="source-inline">M_Armor</strong> material in <strong class="source-inline">Content\Pickups\Armor</strong>, which has <strong class="source-inline">Base Color</strong> set to <strong class="source-inline">blue</strong> and <strong class="source-inline">Metallic</strong> set to <strong class="source-inline">1</strong>.</li>
<li>Create <strong class="source-inline">BP_Armor_Pickup</strong> from <strong class="source-inline">ArmorPickup</strong>, place it in <strong class="source-inline">Content\Pickups\Armor</strong>, and configure it with the following values:<ul><li><strong class="bold">Scale</strong>: <strong class="source-inline">(X=1.0, Y=1.5, Z=1.0)</strong></li><li><strong class="bold">Static Mesh</strong>: <strong class="source-inline">Engine\BasicShapes\Cube</strong></li><li><strong class="bold">Material</strong>: <strong class="source-inline">Content\Pickup\Armor\M_Armor</strong></li><li><strong class="bold">Armor Amount</strong>: <strong class="source-inline">50</strong></li><li><strong class="bold">Pickup Sound</strong>: <strong class="source-inline">Content\Pickup\Armor\ArmorPickup</strong></li></ul></li>
<li>Import <strong class="source-inline">HealthPickup.wav</strong> from <strong class="source-inline">Activity18.01\Assets</strong> into <strong class="source-inline">Content\Pickups\Health</strong>.</li>
<li>Create the <strong class="source-inline">M_Health</strong> material in <strong class="source-inline">Content\Pickups\Health</strong>, which has <strong class="source-inline">Base Color</strong> set to <strong class="source-inline">green</strong> and <strong class="source-inline">Metallic</strong>/<strong class="source-inline">Roughness</strong> set to <strong class="source-inline">0.5</strong>.</li>
<li>Create <strong class="source-inline">BP_Health_Pickup</strong> from <strong class="source-inline">HealthPickup</strong>, place it in <strong class="source-inline">Content\Pickups\Health</strong>, and configure it with the following values:<ul><li><strong class="bold">Static Mesh</strong>: <strong class="source-inline">Engine\BasicShapes\Sphere</strong></li><li><strong class="bold">Material</strong>: <strong class="source-inline">Content\Pickup\Health\M_Health</strong></li><li><strong class="bold">Health Amount</strong>: <strong class="source-inline">50</strong></li><li><strong class="bold">Pickup Sound</strong>: <strong class="source-inline">Content\Pickup\Health\HealthPickup</strong></li></ul></li>
<li>Import <strong class="source-inline">WeaponPickup.wav</strong> from <strong class="source-inline">Activity18.01\Assets</strong> into <strong class="source-inline">Content\Pickups\Weapon</strong>.</li>
<li>Create <strong class="source-inline">BP_Pistol_Pickup</strong> from <strong class="source-inline">WeaponPickup</strong>, place it in <strong class="source-inline">Content\Pickups\Weapon</strong>, and configure it <a id="_idIndexMarker1654"/>with the following values:<ul><li><strong class="bold">Static Mesh</strong>: <strong class="source-inline">Content\Pickup\Weapon\SM_Weapon</strong></li><li><strong class="bold">Material</strong>: <strong class="source-inline">Content\Weapon\Pistol\MI_Pistol</strong></li><li><strong class="bold">Weapon Type</strong>: <strong class="source-inline">Pistol</strong></li><li><strong class="bold">Ammo Amount</strong>: <strong class="source-inline">25</strong></li><li><strong class="bold">Pickup Sound</strong>: <strong class="source-inline">Content\Pickup\Weapon\WeaponPickup</strong></li></ul></li>
<li>Create <strong class="source-inline">BP_MachineGun_Pickup</strong> from <strong class="source-inline">WeaponPickup</strong>, place it in <strong class="source-inline">Content\Pickups\Weapon</strong>, and configure it with the following values:<ul><li><strong class="bold">Static Mesh</strong>: <strong class="source-inline">Content\Pickup\Weapon\SM_Weapon</strong></li><li><strong class="bold">Material</strong>: <strong class="source-inline">Content\Weapon\MachineGun\MI_MachineGun</strong></li><li><strong class="bold">Weapon Type</strong>: <strong class="source-inline">Machine Gun</strong></li><li><strong class="bold">Ammo Amount</strong>: <strong class="source-inline">50</strong></li><li><strong class="bold">Pickup Sound</strong>: <strong class="source-inline">Content\Pickup\Weapon\WeaponPickup</strong></li></ul></li>
<li>Create <strong class="source-inline">BP_Railgun_Pickup</strong> from <strong class="source-inline">WeaponPickup</strong>, place it in <strong class="source-inline">Content\Pickups\Weapon</strong>, and configure it with the following values:<ul><li><strong class="bold">Static Mesh</strong>: <strong class="source-inline">Content\Pickup\Weapon\SM_Weapon</strong></li><li><strong class="bold">Material</strong>: <strong class="source-inline">Content\Weapon\Railgun\MI_Railgun</strong></li><li><strong class="bold">Weapon Type</strong>: <strong class="source-inline">Railgun</strong></li><li><strong class="bold">Ammo Amount</strong>: <strong class="source-inline">5</strong></li><li><strong class="bold">Pickup Sound</strong>: <strong class="source-inline">Content\Pickup\Weapon\WeaponPickup</strong></li></ul></li>
<li>Import <strong class="source-inline">Land.wav</strong> and <strong class="source-inline">Pain.wav</strong> from <strong class="source-inline">Activity18.01\Assets</strong> into <strong class="source-inline">Content\Player\Sounds</strong>.</li>
<li>Edit <strong class="source-inline">BP_Player</strong> so that it<a id="_idIndexMarker1655"/> uses the <strong class="source-inline">Pain</strong> and <strong class="source-inline">Land</strong> sounds, as well as deletes all of the nodes that create and add the <strong class="source-inline">WBP_HUD</strong> instance to the viewport in the <strong class="source-inline">Begin Play</strong> event.</li>
<li>Create a UMG widget called <strong class="source-inline">WBP_Scoreboard_Entry</strong> in <strong class="source-inline">Content\UI</strong> that displays the name, kills, deaths, and ping of <strong class="source-inline">FPSPlayerState</strong>.</li>
<li>Create a UMG widget called <strong class="source-inline">WBP_Scoreboard_Header</strong> that displays the headers for the name, kills, deaths, and ping.</li>
<li>Create a UMG <a id="_idIndexMarker1656"/>widget called <strong class="source-inline">WBP_Scoreboard</strong> that displays the kill limit from the game state, a vertical box that has <strong class="source-inline">WBP_Scoreboard_Header</strong> as the first entry, and then add a <strong class="source-inline">WBP_Scoreboard_Entry</strong> for each <strong class="source-inline">FPSPlayerState</strong> in the game state instance. The vertical box will update every <strong class="source-inline">0.5</strong> seconds, through a timer, by clearing its children and adding them again.</li>
<li>Edit <strong class="source-inline">WBP_HUD</strong> so that it adds a new text block called <strong class="source-inline">Killed</strong> that starts with <strong class="source-inline">Visibility</strong> set to <strong class="source-inline">Hidden</strong>. When the player kills someone, it will make the text block visible, display the name of the killed player, and hide after <strong class="source-inline">1</strong> second.</li>
<li>Create a new <a id="_idIndexMarker1657"/>blueprint called <strong class="source-inline">WBP_PlayerMenu</strong> from <strong class="source-inline">PlayerMenu</strong> and place it in <strong class="source-inline">Content\UI</strong>. Use a widget switcher with an instance of <strong class="source-inline">WBP_HUD</strong> to index <strong class="source-inline">0</strong> and an instance of <strong class="source-inline">WBP_Scoreboard</strong> to index <strong class="source-inline">1</strong>. In the event graph, make sure that you override the <strong class="source-inline">Toggle Scoreboard</strong>, <strong class="source-inline">Set Scoreboard Visibility</strong>, and <strong class="source-inline">Notify Kill</strong> events that were set as <strong class="source-inline">BlueprintImplementableEvent</strong> in C++. The <strong class="source-inline">Toggle Scoreboard</strong> event toggles the widget switcher’s active index between <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong>, the <strong class="source-inline">Set Scoreboard Visibility</strong> event sets the widget switcher’s active index to <strong class="source-inline">0</strong> or <strong class="source-inline">1</strong>, and the <strong class="source-inline">Notify Kill</strong> event tells the <strong class="source-inline">WBP_HUD</strong> instance to set the text and hide it after 1 second. </li>
<li>Create <strong class="source-inline">BP_PlayerController</strong> from <strong class="source-inline">FPSPlayerController</strong>, place it in the <strong class="source-inline">Content</strong> folder, and set the <strong class="source-inline">PlayerMenuClass</strong> variable to use <strong class="source-inline">WBP_PlayerMenu</strong>.</li>
<li>Edit <strong class="source-inline">BP_GameMode</strong> and set <strong class="source-inline">Player Controller Class</strong> to use <strong class="source-inline">BP_PlayerController</strong>.</li>
<li>Create the input action <strong class="source-inline">IA_Scoreboard</strong> to toggle the scoreboard with the <em class="italic">Tab</em> key and update <strong class="source-inline">IMC_Player</strong>.</li>
<li>Edit the <strong class="source-inline">DM-Test</strong> level so that you have at least three new player starts placed in different locations. Then, place an instance of every different pickup.</li>
<li>In <strong class="bold">World Settings</strong>, set<strong class="bold"> Kill Z</strong> to <strong class="source-inline">-500</strong>.</li>
</ol>
<p><strong class="bold">Expected output</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer564">
<img alt="Figure 18.20 – The expected output of the activity " height="640" src="image/Figure_18.20_B18531.jpg" width="1612"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 18.20 – The expected output of the activity</p>
<p>The result should be a project where each client’s character can use and switch between three different weapons. If a character kills another, it should register the kill and the death, as well as respawn the character that died at a random player start. You should have a scoreboard that displays the name, kill count, death count, and ping for each player. A character can fall from the level, which should only count as a death, and respawn at a random player start. The character should also be able to pick up the different pickups in the level to get ammo, armor, health, and weapons. The game should end when the kill limit has been reached by <a id="_idIndexMarker1658"/>showing the scoreboard and server travel to the same level after 5 seconds.</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution to this activity can be found on GitHub here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<h1 id="_idParaDest-381"><a id="_idTextAnchor420"/>Summary</h1>
<p>In this chapter, you learned that the instances of the gameplay framework classes exist in some specific game instances, but not in others. You also learned about the purpose of the game state and player state classes, as well as new concepts for the game mode and some useful built-in functionalities. </p>
<p>At the end of this chapter, you made a basic but functional multiplayer shooter that can be used as a foundation to build upon. You added new weapons, ammo types, fire modes, pickups, and so on to make it more feature-complete and fun.</p>
<p>Having completed this book, you should now have a better understanding of how to use UE5 to make games come to life. We’ve covered a lot of topics in this book, ranging from the simple to more advanced. You started by learning how to create projects using the different templates and how to use Blueprints to create actors and components. Then, you learned how to create a fully functioning <strong class="bold">Third Person</strong> template from scratch by importing the required assets and setting up the Animation Blueprint, Blend Space, game mode, and character, as well as defining and handling the inputs.</p>
<p>Then, you moved on to your first project – a simple stealth game that uses game physics and collisions, projectile movement components, actor components, interfaces, blueprint function libraries, UMG, sounds, and particle effects. Following this, you learned how to create a simple side-scrolling game by using AI, Anim Montages, and Destructible Meshes. Finally, you learned how to create a first-person multiplayer shooter by using the Server-Client architecture, variable replication, and RPCs, as well as how the Player State, Game State, and Game Mode classes work.</p>
<p>By working on various projects that use different parts of Unreal Engine, you now have a strong understanding of how UE5 works. Although this is the end of this book, this is just the beginning of your journey into the world of game development using UE5.</p>
</div>
</div></body></html>