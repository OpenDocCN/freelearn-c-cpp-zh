- en: User Interfaces - UI and UMG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面 - UI和UMG
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Drawing using Canvas
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用画布绘制
- en: Adding Slate Widgets to the screen
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Slate小部件添加到屏幕上
- en: Creating screen size-aware scaling for the UI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为UI创建屏幕尺寸感知缩放
- en: Displaying and hiding a sheet of UMG elements in-game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏中显示和隐藏UMG元素
- en: Attaching function calls to Slate events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数调用附加到Slate事件
- en: Using Data Binding with Unreal Motion Graphics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据绑定与Unreal Motion Graphics
- en: Controlling widget appearance with Styles
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用样式控制小部件外观
- en: Creating a custom SWidget/UWidget
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义SWidget/UWidget
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Displaying feedback to the player is one of the most important elements within
    game design, and this will usually involve some sort of HUD, or at least menus,
    within your game.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 向玩家显示反馈是游戏设计中最重要的元素之一，这通常涉及游戏中的某种HUD或至少是菜单。
- en: In previous versions of Unreal, there was simple HUD support, which allowed
    you to draw simple shapes and text to the screen. However, it was somewhat limited
    in terms of aesthetics, and so solutions such as **Scaleform** became common to
    work around these limitations. Scaleform leveraged Adobe's Flash file format to
    store vector images and UI scripts. It was not without its own cons for developers,
    though, not least the cost – it was a third-party product requiring a (sometimes,
    expensive) license.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unreal的早期版本中，有简单的HUD支持，允许你在屏幕上绘制简单的形状和文本。然而，在美学方面，它有些受限，因此像**Scaleform**这样的解决方案变得很常见，以克服这些限制。Scaleform利用Adobe的Flash文件格式来存储矢量图像和UI脚本。尽管如此，它对开发者来说也有自己的缺点，尤其是成本——它是一个需要（有时昂贵的）许可证的第三方产品。
- en: As a result, Epic developed Slate for the Unreal 4 editor and the in-game UI
    framework. Slate is a collection of widgets (UI elements) and a framework that
    allows for a cross-platform interface for the Editor. It is also usable in-game
    to draw widgets, such as sliders and buttons, for menus and HUDs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Epic为Unreal 4编辑器和游戏内UI框架开发了Slate。Slate是一组小部件（UI元素）和框架，它允许编辑器实现跨平台界面。它也可以在游戏中使用，用于绘制小部件，例如滑块和按钮，用于菜单和HUD。
- en: Slate uses declarative syntax to allow for an XML-style representation of user
    interface elements in their hierarchy in native C++. It accomplishes this by making
    heavy use of macros and operator overloading.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Slate使用声明性语法，允许在原生C++中用XML风格的表示来表示用户界面元素及其层次结构。它是通过大量使用宏和运算符重载来实现的。
- en: That said, not everybody wants to ask their programmers to design the game's
    HUD. One of the significant advantages of using Scaleform within Unreal 3 was
    the ability to develop the visual appearance of game UIs using the Flash visual
    editor so that visual designers didn't need to learn a programming language. Programmers
    could then insert the logic and data separately. This is the same paradigm that's
    espoused by the **Windows Presentation Framework** (**WPF**), for example.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，并不是每个人都想要求程序员设计游戏的HUD。在Unreal 3中使用Scaleform的一个显著优势是能够使用Flash可视化编辑器开发游戏UI的视觉外观，这样视觉设计师就不需要学习编程语言。然后程序员可以分别插入逻辑和数据。例如，这与**Windows
    Presentation Framework**（**WPF**）所倡导的范式相同。
- en: In a similar fashion, Unreal provides **Unreal Motion Graphics** (**UMG**).
    UMG is a visual editor for Slate widgets that allows you to visually style, lay
    out, and animate user interfaces. UI widgets (or controls, if you've come from
    a Win32 background) can have their properties controlled by either Blueprint code
    (written in the Graph view of the UMG window) or from C++. This chapter primarily
    deals with displaying UI elements, creating widget hierarchies, and creating base
    `SWidget` classes that can be styled and used within UMG.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，Unreal提供了**Unreal Motion Graphics**（**UMG**）。UMG是一个用于Slate小部件的可视化编辑器，允许你可视化地设计、布局和动画化用户界面。UI小部件（或控件，如果你来自Win32背景）可以通过蓝图代码（在UMG窗口的图形视图中编写）或C++来控制其属性。本章主要涉及显示UI元素、创建小部件层次结构和创建可以在UMG中样式化和使用的基`SWidget`类。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml),
    *UE4 Development Tools*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要使用Unreal Engine 4，并使用Visual Studio 2017作为IDE。有关如何安装这两款软件及其要求的信息，请参阅[第1章](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml)，*UE4开发工具*。
- en: Drawing using Canvas
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用画布绘制
- en: '**Canvas** is a continuation of the simple HUD that''s implemented within Unreal
    3\. While it isn''t so commonly used within shipping games, mostly being replaced
    by Slate/UMG, it''s simple to use, especially when you want to draw text or shapes
    to the screen. Canvas drawing is still used extensively by console commands that
    are used for debugging and performance analysis, such as `stat game` and the other
    `stat` commands.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**Canvas** 是 Unreal 3 中实现的简单 HUD 的延续。虽然它不太常用于发布的游戏中，大多数情况下被 Slate/UMG 替换，但它使用简单，尤其是在您想要在屏幕上绘制文本或形状时。Canvas
    绘图仍然被用于调试和性能分析的控制台命令中，例如 `stat game` 和其他 `stat` 命令。'
- en: Getting ready...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中...
- en: Refer to [Chapter 4](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml), *Actors and
    Components,* if you need a refresher on using the C++ Code Wizard.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要复习使用 C++ 代码向导，请参阅[第 4 章](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml)，*演员和组件*。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'From your Visual Studio project (File | Open Visual Studio), open the `Source\<Module>`
    folder and, from there, open the `<Module>.build.cs` file (in my case, it would
    be `Source\Chapter_14\Chapter_14.build.cs`) . Uncomment/add the following line
    of code:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的 Visual Studio 项目（文件 | 打开 Visual Studio），打开 `Source\<Module>` 文件夹，然后从那里打开
    `<Module>.build.cs` 文件（在我的情况下，将是 `Source\Chapter_14\Chapter_14.build.cs`）。取消注释/添加以下代码行：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Create a new `GameModeBase` called `CustomHUDGameMode` using the editor class
    wizard.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器类向导创建一个新的 `GameModeBase`，命名为 `CustomHUDGameMode`。
- en: 'Add a constructor to the class:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向类中添加一个构造函数：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following to the constructor implementation:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数实现中添加以下内容：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At this point, you will get compile errors, because the `CustomHUD` class does
    not exist. That is what we will be creating next.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您将得到编译错误，因为 `CustomHUD` 类不存在。这正是我们将要创建的。
- en: 'Create a new `HUD` subclass using the Add C++ Class wizard:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用添加 C++ 类向导创建一个新的 `HUD` 子类：
- en: '![](img/7830c68f-9f06-44ce-aedd-20e29710145d.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7830c68f-9f06-44ce-aedd-20e29710145d.png)'
- en: 'When asked for the name, put in `CustomHUD`, and click on the Create Class
    button:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被要求输入名称时，输入`CustomHUD`，然后点击创建类按钮：
- en: '![](img/279fff54-150b-4019-b6c1-fc9d9f07b0a0.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/279fff54-150b-4019-b6c1-fc9d9f07b0a0.png)'
- en: 'Inside `CustomHUD.h`, add the following function with the `override` keyword
    to the class:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CustomHUD.h` 中，添加以下带有 `override` 关键字的功能到类中：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, implement the function:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现该函数：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Compile your code and launch the editor.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的代码并启动编辑器。
- en: 'Within the editor, open the World Settings panel from the Settings drop-down
    menu:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，从设置下拉菜单中打开世界设置面板：
- en: '![](img/d725eff7-9368-40b6-a5da-84695df4ad25.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d725eff7-9368-40b6-a5da-84695df4ad25.jpg)'
- en: 'In the World Settings dialog, select `CustomHUDGameMode` from the list under
    GameMode Override:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在世界设置对话框中，从游戏模式覆盖下选择 `CustomHUDGameMode`：
- en: '![](img/5ff91259-600d-482f-b002-6497a6fae2ee.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5ff91259-600d-482f-b002-6497a6fae2ee.jpg)'
- en: 'Play and verify that your custom HUD is drawing to the screen:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放并验证您的自定义 HUD 是否已绘制到屏幕上：
- en: '![](img/a15e2c53-27d0-40fe-bd70-09c9464d1827.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a15e2c53-27d0-40fe-bd70-09c9464d1827.png)'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All the UI recipes here will be using Slate for drawing, so we need to add a
    dependency between our module and the Slate framework so that we can access the
    classes that have been declared in that module. The best place to put custom Canvas
    draw calls for a game HUD is inside a subclass of `AHUD`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里所有的 UI 菜单都将使用 Slate 进行绘制，因此我们需要在我们的模块和 Slate 框架之间添加一个依赖关系，以便我们可以访问在该模块中声明的类。为游戏
    HUD 添加自定义 Canvas 绘制调用的最佳位置是在 `AHUD` 的子类中。
- en: To tell the engine to use our custom subclass, though, we need to create a new
    `GameMode` and specify the type of our custom class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要告诉引擎使用我们的自定义子类，我们需要创建一个新的 `GameMode` 并指定我们自定义类的类型。
- en: Within the constructor of our custom Game Mode, we assign the `UClass` for our
    new HUD type to the `HUDClass` variable. This `UClass` is passed on to each player's
    controller as they spawn in, and the controller is then responsible for the `AHUD`
    instance that it creates.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们自定义游戏模式的构造函数中，我们将我们新的 HUD 类型的 `UClass` 分配给 `HUDClass` 变量。这个 `UClass` 在每个玩家生成时传递给玩家的控制器，控制器随后负责创建
    `AHUD` 实例。
- en: With our custom `GameMode` loading our custom HUD, we need to actually create
    said custom HUD class. `AHUD` defines a virtual function called `DrawHUD()`, which
    is invoked in every frame to allow us to draw elements to the screen. As a result,
    we override that function and perform our drawing inside the implementation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的自定义 `GameMode` 正在加载我们的自定义 HUD，因此我们需要实际创建这个自定义 HUD 类。`AHUD` 定义了一个名为 `DrawHUD()`
    的虚拟函数，它在每一帧被调用，以便我们可以将元素绘制到屏幕上。因此，我们重写该函数并在实现中进行绘制。
- en: 'The first method that''s used is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的第一种方法如下：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`DrawText` requires a font to draw with. The default font used by `stat` and
    other HUD drawing commands in the engine code is actually stored in the `GEngine`
    class, and can be accessed by using the `GetSmallFont` function, which returns
    an instance of the `UFont` as a pointer.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawText`需要一个字体来绘制。引擎代码中`stat`和其他HUD绘制命令使用的默认字体实际上存储在`GEngine`类中，可以通过使用`GetSmallFont`函数访问，该函数返回一个指向`UFont`实例的指针。'
- en: The remaining arguments that we are using are the actual text that should be
    rendered, and the offset, in pixels, at which the text should be drawn.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用的其余参数是应该渲染的实际文本，以及文本应该绘制的像素偏移量。
- en: '`DrawText` is a function that allows you to directly pass in the data that
    is to be displayed. The general `DrawItem` function is a Visitor implementation
    that allows you to create an object that encapsulates the information about the
    object to be drawn and reuse that object on multiple draw calls.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawText`是一个允许您直接传递要显示的数据的函数。通用的`DrawItem`函数是一个访问者实现，允许您创建一个封装要绘制对象信息的对象，并在多个绘制调用中重用该对象。'
- en: In this recipe, we create an element that can be used to represent a progress
    bar. We encapsulate the required information regarding the width and height of
    our box into an `FCanvasBoxItem`, which we then pass to the `DrawItem` function
    on our Canvas.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们创建了一个可以用来表示进度条的元素。我们将有关我们框的宽度和高度所需的信息封装到一个`FCanvasBoxItem`中，然后将其传递到我们的画布上的`DrawItem`函数。
- en: The third item that we draw is a filled rectangle. This function uses convenience
    methods that are defined in the HUD class rather than on the Canvas itself. The
    filled rectangle is placed at the same location as our `FCanvasBox` so that it
    can represent the current value inside the progress bar.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绘制的第三项是一个填充的矩形。此函数使用在HUD类中定义的便利方法，而不是在画布本身上。填充的矩形放置在与我们的`FCanvasBox`相同的位置，以便它可以表示进度条中的当前值。
- en: See also...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见...
- en: Refer to [Chapter 10](c73bb4ba-4b7d-4aef-a33e-732f184d261f.xhtml), *Integrating
    C++ and the Unreal Editor – Part II,* and the *Creating new console commands* recipe
    within, to learn how to create your own console commands
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第10章](c73bb4ba-4b7d-4aef-a33e-732f184d261f.xhtml)，*整合C++和虚幻编辑器——第二部分*，以及其中的*创建新的控制台命令*配方，了解如何创建您自己的控制台命令
- en: Adding Slate Widgets to the screen
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向屏幕添加Slate小部件
- en: The previous recipe used the `FCanvas` API to draw to the screen. However, `FCanvas`
    suffers from a number of limitations, for example, animations are difficult to
    implement, and drawing graphics on the screen involves creating textures or materials.
    `FCanvas` also doesn't implement anything in the way of widgets or window controls,
    making data entry or other forms of user input more complex than necessary. This
    recipe will show you how to begin creating HUD elements on-screen using Slate,
    which provides a number of built-in controls.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的配方使用了`FCanvas` API来绘制到屏幕上。然而，`FCanvas`存在一些限制，例如，动画难以实现，在屏幕上绘制图形涉及创建纹理或材质。`FCanvas`也没有实现任何形式的控件或窗口控制，这使得数据输入或其他形式的用户输入比必要的更复杂。本配方将向您展示如何开始使用Slate在屏幕上创建HUD元素，Slate提供了一些内置控件。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Add `Slate` and `SlateCore` to your module's dependencies if you haven't done
    so already (see the *Drawing using Canvas* recipe to learn how to do this).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未这样做，请将`Slate`和`SlateCore`添加到您的模块依赖项中（参见*使用画布绘制*配方了解如何这样做）。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new `PlayerController` subclass using the Add C++ Class wizard:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用添加C++类向导创建一个新的`PlayerController`子类：
- en: '![](img/7c52bf2e-a859-4474-8c1d-9cd54069694e.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7c52bf2e-a859-4474-8c1d-9cd54069694e.png)'
- en: 'When asked for the name of the class, type in `CustomHUDPlayerController` and
    press the Create Class button:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被要求输入类名时，键入`CustomHUDPlayerController`并按创建类按钮：
- en: '![](img/1ad35366-16d0-413a-bbb0-a5635ead359a.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1ad35366-16d0-413a-bbb0-a5635ead359a.png)'
- en: 'Override the `BeginPlay` virtual method within your new subclass:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的新子类中重写`BeginPlay`虚拟方法：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following code for your overridden `BeginPlay()` virtual method inside
    the subclass'' implementation:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在子类的实现中添加以下代码以覆盖`BeginPlay()`虚拟方法：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Create a new class based on `GameModeBase` called `SlateHUDGameMode`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于名为`GameModeBase`的新类创建一个名为`SlateHUDGameMode`的新类。
- en: 'Add a constructor inside the Game Mode:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游戏模式中添加一个构造函数：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Implement the constructor with the following code:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码实现构造函数：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Within the Editor, open the World Settings menu from the toolbar by going to
    Settings | World Settings:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，通过转到设置 | 世界设置，从工具栏打开“世界设置”菜单：
- en: '![](img/826cba58-111f-40cf-8ff5-4d6c56bf5a45.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/826cba58-111f-40cf-8ff5-4d6c56bf5a45.jpg)'
- en: 'Inside World Settings, override the level''s Game Mode to be our `SlateHUDGameMode`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“世界设置”中，覆盖级别的游戏模式为我们的`SlateHUDGameMode`：
- en: '![](img/9f73bfe4-1610-4d0c-b44b-b14e786dbbc7.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9f73bfe4-1610-4d0c-b44b-b14e786dbbc7.jpg)'
- en: 'Play the level. You will see your new UI displayed on the screen:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放级别。您将在屏幕上看到您的新UI：
- en: '![](img/2347b898-a48c-495d-84ce-d06b195e3021.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2347b898-a48c-495d-84ce-d06b195e3021.png)'
- en: Button located on the game screen
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 位于游戏屏幕上的按钮
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For us to reference Slate classes or functions in our code, our module must
    link with the `Slate` and `SlateCore` modules, so we add those to the module dependencies.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的代码中引用Slate类或函数，我们的模块必须与`Slate`和`SlateCore`模块链接，因此我们将这些添加到模块依赖项中。
- en: We need to instantiate our UI in one of the classes that loads when the game
    runs, so for this recipe, we use our custom `PlayerController` in the `BeginPlay`
    function as the place to create our UI.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在游戏运行时加载的类中实例化我们的UI，因此对于这个配方，我们在`BeginPlay`函数中使用我们的自定义`PlayerController`作为创建UI的位置。
- en: Inside the `BeginPlay` implementation, we create a new `SVerticalBox` using
    the `SNew` function. We add a slot for a widget to our box, and set that slot
    to both horizontal and vertical centering.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BeginPlay`实现中，我们使用`SNew`函数创建一个新的`SVerticalBox`。我们向我们的框添加一个用于小部件的槽，并将该槽设置为水平和垂直居中。
- en: Inside the slot, which we access using square brackets, we create a button that
    has `Textblock` inside it. In `Textblock`, we set the `Text` property to a string
    literal value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用方括号访问的槽中，我们创建了一个带有`Textblock`的按钮。在`Textblock`中，我们将`Text`属性设置为字符串字面值。
- en: With the UI now created, we call `AddViewportWidgetForPlayer` to display this
    widget on the local player's screen.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在UI已经创建，我们调用`AddViewportWidgetForPlayer`来在本地玩家的屏幕上显示此小部件。
- en: With our custom `PlayerController` ready, we now need to create a custom `GameMode`
    to specify that it should use our new `PlayerController`. With the custom `PlayerController`
    being loaded at the start of the game, when `BeginPlay` is called, our UI will
    be shown.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定制`PlayerController`准备好了，我们现在需要创建一个定制的`GameMode`来指定它应该使用我们新的`PlayerController`。由于自定义`PlayerController`在游戏开始时加载，当调用`BeginPlay`时，我们的UI将显示出来。
- en: The UI is very small at this screen size. Refer to the following recipe for
    information on how to scale it appropriately for the resolution of the game window.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕尺寸下，UI非常小。请参考以下配方以获取有关如何根据游戏窗口的分辨率适当缩放的信息。
- en: Creating screen size-aware scaling for the UI
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为UI创建屏幕尺寸感知的缩放
- en: If you have followed the previous recipe, you will notice that when you use
    **Play In Editor**, the button that loads is unusually small.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经遵循了前面的配方，您会注意到当您使用**在编辑器中播放**时，加载的按钮异常小。
- en: The reason for this is UI Scaling, a system that allows you to scale the user
    interface based on the screen size. User interface elements are represented in
    terms of pixels, usually in absolute terms (the button should be 10 pixels tall).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是UI缩放，这是一个允许您根据屏幕大小缩放用户界面的系统。用户界面元素以像素为单位表示，通常以绝对值（按钮应该高10像素）表示。
- en: The problem with this is that if you use a higher-resolution panel, 10 pixels
    might be much smaller, because each pixel is smaller in size.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在于，如果您使用高分辨率的面板，10像素可能非常小，因为每个像素的尺寸更小。
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The UI scaling system in Unreal allows you to control a global scale modifier,
    which will scale all the controls on the screen based on the screen resolution.
    Given the previous example, you might wish to adjust the size of the button so
    that its apparent size is unchanged when you view your UI on a smaller screen.
    This recipe shows two different methods for altering the scaling rates.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal中的UI缩放系统允许您控制全局缩放修改器，这将根据屏幕分辨率缩放屏幕上的所有控件。根据前面的示例，您可能希望调整按钮的大小，以便在您在较小的屏幕上查看UI时，其显示大小保持不变。本配方展示了两种不同的方法来改变缩放率。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a custom `PlayerController` subclass. Call it `ScalingUIPlayerController`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个自定义的`PlayerController`子类。将其命名为`ScalingUIPlayerController`。
- en: 'Inside the class, override `BeginPlay`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类内部，覆盖`BeginPlay`：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following code in the implementation of that function inside of `ScalingUIPlayerController.cpp`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ScalingUIPlayerController.cpp`函数的实现中添加以下代码：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a new `GameModeBase` subclass called `ScalingUIGameMode` and give it
    a default constructor:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`GameModeBase`子类，命名为`ScalingUIGameMode`，并给它一个默认构造函数：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Within the default constructor, set the default player controller class to
    `ScalingUIPlayerController`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在默认构造函数中，将默认玩家控制器类设置为`ScalingUIPlayerController`：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Save and compile your new classes.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并编译你的新类。
- en: Within the Editor, open the World Settings menu from the toolbar by going to Settings
    | World Settings.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，通过转到“设置 | 世界设置”从工具栏打开“世界设置”菜单。
- en: Inside World Settings, override the level's Game Mode to be our `ScalingUIGameMode`.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在世界设置中，覆盖级别的游戏模式为我们的`ScalingUIGameMode`。
- en: '![](img/02f9189c-7fad-4349-8bb7-195579247691.png)'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/02f9189c-7fad-4349-8bb7-195579247691.png)'
- en: 'This should give you a user interface like the one from the previous recipe.
    Note that the UI is very tiny if you use Play In Editor:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会给你一个类似于之前菜谱中的用户界面。注意，如果你使用“在编辑器中播放”，UI会非常小：
- en: '![](img/d136a6b5-4043-4f09-8443-541766ef6a1c.png)'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/d136a6b5-4043-4f09-8443-541766ef6a1c.png)'
- en: Tiny button on the game screen
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 游戏屏幕上的小按钮
- en: To alter the rate at which the UI scales down or up, we need to change the scaling
    curve. We can do that through two different methods.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要改变UI缩放上下文的速度，我们需要更改缩放曲线。我们可以通过两种不同的方法来实现。
- en: Using the In-Editor method
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用编辑器内方法
- en: 'Launch Unreal, then open the Project Settings dialog through the Edit menu:'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Unreal，然后通过编辑菜单打开项目设置对话框：
- en: '![](img/4bf372f4-6819-4ee5-96f2-662d40adc52c.jpg)'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/4bf372f4-6819-4ee5-96f2-662d40adc52c.jpg)'
- en: 'Under the Engine - User Interface section, there is a curve called the DPI
    Curve, which can be used to alter the UI scaling factor based on the short dimension
    of your screen:'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“引擎 - 用户界面”部分下，有一个名为DPI曲线的曲线，可以用来根据屏幕的短边调整UI缩放因子：
- en: '![](img/b3a198bb-bb69-47ea-a3d9-61f52351f475.png)'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/b3a198bb-bb69-47ea-a3d9-61f52351f475.png)'
- en: Click on the second dot, or keypoint, on the graph.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击图表上的第二个点，或关键点。
- en: 'Change its Scale value to `1`. Then, do the same for the first dot and set
    its Scale value to `1` as well:'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其缩放值更改为`1`。然后，对第一个点也做同样的操作，将其缩放值也设置为`1`：
- en: '![](img/71b43d27-052b-49b2-a2f5-28c1e89ae87c.png)'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/71b43d27-052b-49b2-a2f5-28c1e89ae87c.png)'
- en: 'Return to the main editor and run the game again. You should notice that the
    button is larger than it was before:'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回主编辑器并再次运行游戏。你应该注意到按钮比之前更大了：
- en: '![](img/91c6e745-0bc1-4555-9288-fe5dca318431.png)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/91c6e745-0bc1-4555-9288-fe5dca318431.png)'
- en: Easier to see button on the game screen
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 游戏屏幕上更容易看到的按钮
- en: Using the Config file method
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用配置文件方法
- en: 'Browse to your project directory and look inside the `Config` folder:'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到你的项目目录，并查看`Config`文件夹：
- en: '![](img/e4843569-d39c-408e-a063-9829f0467739.png)'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/e4843569-d39c-408e-a063-9829f0467739.png)'
- en: Open `DefaultEngine.ini`, which is located in the `Config` folder of your project,
    inside your text editor of choice.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于项目`Config`文件夹中的`DefaultEngine.ini`，使用你选择的文本编辑器。
- en: 'Find the `[/Script/Engine.UserInterfaceSettings]` section:'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找`[/Script/Engine.UserInterfaceSettings]`部分：
- en: '[PRE14]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Look for a key called `UIScaleCurve` in that section.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该部分查找名为`UIScaleCurve`的键。
- en: In the value for that key, you'll notice a number of `(Time=x,Value=y)` pairs.
    Edit the second pair so that its `Time` value is `720.000000` and the `Value`
    is `1.000000` if it isn't already.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该键的值中，你会注意到一些`(Time=x,Value=y)`对。如果尚未设置，编辑第二个对，使其`Time`值为`720.000000`，`Value`为`1.000000`。
- en: Restart the editor if you have it open.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你有打开编辑器，请重新启动编辑器。
- en: 'Start the Play In Editor preview to confirm that your UI now remains readable
    at the **PIE** screen''s resolution (assuming you are using a 1080p monitor so
    that the PIE window is running at 720p or thereabouts):'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动“在编辑器中播放”预览以确认你的UI现在在**PIE**屏幕的分辨率下仍然可读（假设你使用的是1080p显示器，因此PIE窗口运行在720p左右）：
- en: '![](img/288286d3-a546-4e7b-b440-5fc65abe4c8a.jpg)'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/288286d3-a546-4e7b-b440-5fc65abe4c8a.jpg)'
- en: You can also see how the scaling works if you use a New Editor Window to preview
    your game.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以通过使用新编辑器窗口预览你的游戏来查看缩放是如何工作的。
- en: To do so, click on the arrow to the right of Play on the toolbar.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要这样做，请点击工具栏上“播放”右侧的箭头。
- en: Select New Editor Window.
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择新编辑器窗口。
- en: Inside this window, you can use the console command `r.SetRes widthxheight`
    to change the resolution (for example, `r.SetRes 200x200`), and observe the changes
    that result from doing so.
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此窗口中，你可以使用控制台命令`r.SetRes widthxheight`来更改分辨率（例如，`r.SetRes 200x200`），并观察这样做产生的变化。
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As usual, when we want to use a custom `PlayerController`, we need a custom
    `GameMode` to specify which `PlayerController` to use.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如同往常，当我们想要使用自定义的 `PlayerController` 时，我们需要一个自定义的 `GameMode` 来指定使用哪个 `PlayerController`。
- en: We create both a custom `PlayerController` and `GameMode`, and then place some
    `Slate` code in the `BeginPlay` method of `PlayerController` so that some UI elements
    are drawn.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们创建了一个自定义的 `PlayerController` 和 `GameMode`，然后在 `PlayerController` 的 `BeginPlay`
    方法中放置一些 `Slate` 代码，以便绘制一些UI元素。
- en: Because the main game viewport is usually quite small within the Unreal editor,
    the UI initially shows in a scaled-down fashion. This is intended to allow for
    the game UI to take up less room on smaller resolution displays, but this can
    have the side effect of making the text very difficult to read if the window isn't
    being stretched to fit the full screen.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为在虚幻编辑器中，主游戏视口通常相当小，UI最初以缩放的方式显示。这是为了允许游戏UI在较小分辨率的显示器上占用更少的空间，但如果没有将窗口拉伸以适应全屏，这可能会导致文本非常难以阅读。
- en: Unreal stores the configuration data that should persist between sessions but
    not necessarily be hard coded into the executable inside config files. Config
    files use an extended version of the `.ini` file format, which has been commonly
    used with Windows software.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虚幻在配置文件中存储应在会话之间持久存在的配置数据，但不必一定硬编码到可执行文件中。配置文件使用 `.ini` 文件格式的扩展版本，这已经在Windows软件中广泛使用。
- en: 'Config files store data using the following syntax:'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 配置文件使用以下语法存储数据：
- en: '[PRE15]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Unreal has a `UserInterfaceSettings` class, with a property called `UIScaleCurve`
    on it. That `UPROPERTY` is marked as config, so Unreal serializes the value to
    the `.ini` file.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虚幻有一个 `UserInterfaceSettings` 类，它上面有一个名为 `UIScaleCurve` 的属性。该 `UPROPERTY` 被标记为配置，因此虚幻将值序列化到
    `.ini` 文件中。
- en: As a result, it stores the `UIScale` data in the `DefaultEngine.ini` file, in
    the `Engine.UserInterfaceSettings` section.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，它将 `UIScale` 数据存储在 `DefaultEngine.ini` 文件中的 `Engine.UserInterfaceSettings`
    部分。
- en: The data is stored using a text format, which contains a list of key points.
    Editing the `Time`, `Value` pairs alters or adds new key points to the curve.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据使用文本格式存储，其中包含一系列关键点。编辑 `Time`、`Value` 对会改变或添加新的关键点到曲线上。
- en: The Project Settings dialog is a simple frontend for directly editing the `.ini`
    files yourself, and for designers, it is an intuitive way to edit the curve. However,
    having the data stored textually allows for programmers to potentially develop
    build tools that modify properties such as `UIScale` without having to recompile
    their game.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 项目设置对话框是一个简单的界面，可以直接编辑 `.ini` 文件，对于设计师来说，这是一种直观的编辑曲线的方法。然而，以文本形式存储数据允许程序员开发构建工具，修改如
    `UIScale` 等属性，而无需重新编译他们的游戏。
- en: '`Time` refers to the input value. In this case, the input value is the narrower
    dimension of the screen (usually, the height).'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Time` 指的是输入值。在这种情况下，输入值是屏幕的较窄维度（通常是高度）。'
- en: '`Value` is the universal scaling factor that''s applied to the UI when the
    screen''s narrow dimension is approximately the height of the value in the `Time`
    field.'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Value` 是当屏幕的窄边大约等于 `Time` 字段中的值的高度时，应用于UI的通用缩放因子。'
- en: So, to set the UI to remain normal-sized at a 1280 x 720 resolution, set the
    time/input factor to 720 and the scale factor to 1.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，要将UI设置为在1280 x 720分辨率下保持正常大小，将时间/输入因子设置为720，将缩放因子设置为1。
- en: See also
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can refer to the UE4 documentation for more information regarding config
    files: [https://docs.unrealengine.com/en-US/Programming/Basics/ConfigurationFiles](https://docs.unrealengine.com/en-US/Programming/Basics/ConfigurationFiles).'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以参考UE4文档以获取有关配置文件的更多信息：[https://docs.unrealengine.com/en-US/Programming/Basics/ConfigurationFiles](https://docs.unrealengine.com/en-US/Programming/Basics/ConfigurationFiles)。
- en: Displaying and hiding a sheet of UMG elements in-game
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在游戏中显示和隐藏UMG元素的工作表
- en: We have already discussed how to add a widget to the viewport, which means that
    it will be rendered on the player's screen.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何将小部件添加到视口中，这意味着它将在玩家的屏幕上渲染。
- en: However, what if we want to have UI elements that are toggled based on other
    factors, such as proximity to certain Actors, or a player holding a key down,
    or if we want a UI that disappears after a specified time?
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，如果我们想根据其他因素切换UI元素，比如接近某些Actor、玩家按下一个键，或者如果我们想创建一个在指定时间后消失的UI呢？
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new `GameModeBase` class called `ToggleHUDGameMode`:'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `GameModeBase` 类，命名为 `ToggleHUDGameMode`：
- en: '![](img/ebab40ac-26b7-46a2-906b-b5eead0b1736.png)'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/ebab40ac-26b7-46a2-906b-b5eead0b1736.png)'
- en: 'Add the following `UPROPERTY` and function definitions to the `ToggleHUDGameMode.h`
    file:'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `UPROPERTY` 和函数定义添加到 `ToggleHUDGameMode.h` 文件中：
- en: '[PRE16]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Implement `BeginPlay` with the following code in the method body:'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法体中使用以下代码实现 `BeginPlay`：
- en: '[PRE17]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Implement `EndPlay`:'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `EndPlay`：
- en: '[PRE18]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Compile your code and start the editor.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码并启动编辑器。
- en: 'Within the Editor, open World Settings from the toolbar:'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，从工具栏打开世界设置：
- en: '![](img/e117fa02-d7d4-447a-a504-6350baad3827.jpg)'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/e117fa02-d7d4-447a-a504-6350baad3827.jpg)'
- en: 'Inside World Settings, override the level''s Game Mode to be our `AToggleHUDGameMode`:'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在世界设置中，覆盖关卡的游戏模式为我们的 `AToggleHUDGameMode`：
- en: '![](img/3eb58755-c6a1-4830-973d-c23df59487c3.jpg)'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/3eb58755-c6a1-4830-973d-c23df59487c3.jpg)'
- en: Play the level and verify that the UI toggles its visibility every five seconds.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放关卡并验证 UI 每五秒钟切换其可见性。
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As with most of the other recipes in this chapter, we are using a custom `GameMode`
    class to display our single-player UI on the player's viewport for convenience.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与本章中的大多数其他配方一样，我们使用自定义的 `GameMode` 类来方便地在玩家的视口中显示我们的单人 UI。
- en: We override `BeginPlay` and `EndPlay` so that we can correctly handle the timer
    that will be toggling our UI on and off for us. To make that possible, we need
    to store a reference to the timer as a `UPROPERTY` to ensure it won't be garbage
    collected.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们覆盖 `BeginPlay` 和 `EndPlay`，以便我们可以正确处理将为我们切换 UI 的计时器。为此，我们需要将计时器的引用存储为 `UPROPERTY`，以确保它不会被垃圾回收。
- en: Within `BeginPlay`, we create a new `VerticalBox` using the `SNew` macro, and
    place a button in its first slot. Buttons have `Content`, which can be some other
    widget to host inside them, such as `SImage` or `STextBlock`.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `BeginPlay` 中，我们使用 `SNew` 宏创建一个新的 `VerticalBox`，并在其第一个槽中放置一个按钮。按钮有 `Content`，它可以是其他小部件，例如
    `SImage` 或 `STextBlock`，以在其中托管。
- en: In this instance, we place an `STextBlock` into the `Content` slot. The contents
    of the text block are irrelevant, that is, as long as they are long enough for
    us to be able to see our button properly.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将一个 `STextBlock` 放入 `Content` 插槽中。文本块的内容无关紧要，也就是说，只要它们足够长，我们就能正确地看到我们的按钮。
- en: Having initialized our widget hierarchy, we add the root widget to the player's
    viewport so that it can be seen by them.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始化了我们的小部件层次结构后，我们将根小部件添加到玩家的视口中，以便他们可以看到。
- en: Now, we set up a timer to toggle the visibility of our widget. We are using
    a timer to simplify this recipe rather than having to implement user input and
    input bindings, but the principle is the same. To do this, we get a reference
    to the game world and its associated timer manager.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们设置一个计时器来切换我们小部件的可见性。我们使用计时器来简化这个配方，而不是必须实现用户输入和输入绑定，但原理是相同的。为此，我们获取游戏世界的引用及其相关的计时器管理器。
- en: With the timer manager in hand, we can create a new timer. However, we need
    to actually specify the code to run when the timer expires. One simple way to
    do this is to use a `lambda` function for our toggle the hud function.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 拿到计时器管理器后，我们可以创建一个新的计时器。但是，我们需要实际指定计时器到期时运行的代码。一种简单的方法是使用 `lambda` 函数来切换 hud
    功能。
- en: Lambdas are anonymous functions. Think of them as literal functions. To link
    a `lambda` function to the timer, we need to create a `timer` delegate.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Lambda 是匿名函数。可以将它们视为字面函数。要将 `lambda` 函数链接到计时器，我们需要创建一个 `timer` 代理。
- en: The `FTimerDelegate::CreateLambda` function is designed to convert a `lambda`
    function into a delegate, which the timer can call at the specified interval.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`FTimerDelegate::CreateLambda` 函数旨在将 `lambda` 函数转换为代理，计时器可以在指定的间隔调用它。'
- en: The `lambda` needs to access the `this` pointer from its containing object,
    our `GameMode`, so that it can change properties on the widget instance that we
    have created. To give it the access it needs, we begin our `lambda` declaration
    with the `[]` operators, which enclose variables that should be captured into
    the `lambda`, and are accessible inside it. The curly braces then enclose the
    function body in the same way they would with a normal function declaration.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`lambda` 需要从其包含的对象 `GameMode` 中访问 `this` 指针，以便能够更改我们创建的小部件实例上的属性。为了给它所需的访问权限，我们在
    `lambda` 声明中开始使用 `[]` 操作符，这些操作符包围着应该捕获到 `lambda` 中并可在其中访问的变量。然后大括号以与正常函数声明相同的方式包围函数体。'
- en: Inside the function, we check if our widget is visible. If it is visible, then
    we hide it using `SWidget::SetVisibility`. If the widget isn't visible, then we
    turn it on using the same function call.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在函数内部，我们检查我们的小部件是否可见。如果是可见的，则使用 `SWidget::SetVisibility` 隐藏它。如果小部件不可见，则使用相同的函数调用打开它。
- en: In the rest of the call to `SetTimer`, we specify the interval (in seconds)
    to call the timer, and set the timer to loop.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`SetTimer`的其余调用中，我们指定调用计时器的间隔（以秒为单位），并将计时器设置为循环。
- en: One thing we need to be careful of, though, is the possibility of our object
    being destroyed between two timer invocations, potentially leading to a crash
    if a reference to our object is left dangling. To fix this, we need to remove
    the timer.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，我们需要小心的一点是，我们的对象在两次计时器调用之间可能被销毁，如果留下对对象的引用悬空，可能会导致崩溃。为了解决这个问题，我们需要删除计时器。
- en: Given that we set the timer during `BeginPlay`, it makes sense to clear the
    timer during `EndPlay`. `EndPlay` will be called whenever `GameMode` either ends
    play or is destroyed, so we can safely cancel the timer during its implementation.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们在`BeginPlay`期间设置了计时器，因此有道理在`EndPlay`期间清除计时器。`EndPlay`将在`GameMode`结束播放或被销毁时被调用，因此我们可以在其实现期间安全地取消计时器。
- en: With `GameMode` set as the default game mode, the UI is created when the game
    begins to play, and the timer delegate executes every five seconds to switch the
    visibility of the widgets between `true` and `false`.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将`GameMode`设置为默认游戏模式，当游戏开始播放时创建UI，计时器代理每五秒执行一次，在`true`和`false`之间切换小部件的可见性。
- en: When you close the game, `EndPlay` clears the timer reference, avoiding any
    problems.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你关闭游戏时，`EndPlay`清除计时器引用，避免出现任何问题。
- en: Attaching function calls to Slate events
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数调用附加到Slate事件
- en: While creating buttons is all well and good, at the moment, any UI element you
    add to the player's screen just sits there without anything happening, even if
    a user clicks on it. We don't have any event handlers attached to the Slate elements
    at the moment, so events such as mouse clicks don't actually cause anything to
    happen.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然创建按钮是件好事，但目前，你添加到玩家屏幕上的任何UI元素都只是静静地在那里，没有任何反应，即使用户点击它也是如此。目前我们没有将任何事件处理程序附加到Slate元素上，因此鼠标点击等事件实际上不会引发任何操作。
- en: Getting ready
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: This recipe shows you how to attach functions to these events so that we can
    run custom code when they occur.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个配方展示了如何将这些事件附加到函数，以便在它们发生时运行自定义代码。
- en: How to do it...
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new `GameModeBase` subclass called `ClickEventGameMode`:'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`GameModeBase`子类，命名为`ClickEventGameMode`：
- en: '![](img/ee48dd37-65bb-47a8-aab4-41abb8f4e351.png)'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/ee48dd37-65bb-47a8-aab4-41abb8f4e351.png)'
- en: 'From the `ClickEventGameMode.h` file, add the following functions and `private`
    members to the class:'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`ClickEventGameMode.h`文件中，向类中添加以下函数和`private`成员：
- en: '[PRE19]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Within the `.cpp` file, add the implementation for `BeginPlay`:'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.cpp`文件中，添加`BeginPlay`的实现：
- en: '[PRE20]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Also, add an implementation for `ButtonClicked()`:'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，添加`ButtonClicked()`的实现：
- en: '[PRE21]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Compile your code and launch the editor.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码并启动编辑器。
- en: Override the game mode in World Settings to be `ClickEventGameMode`.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在世界设置中覆盖游戏模式为`ClickEventGameMode`。
- en: 'Preview this in the editor and verify that the UI shows a button that changes
    from Click Me! to Clicked! when you use the mouse cursor to click on it:'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中预览并验证UI是否显示了一个按钮，当你使用鼠标光标点击它时，按钮会从“Click Me!”变为“Clicked!”：
- en: '![](img/72e77d50-3b49-4973-b4ac-bddae6bbe8cc.png)'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/72e77d50-3b49-4973-b4ac-bddae6bbe8cc.png)'
- en: Button displays Clicked! after being clicked
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按钮在被点击后会显示“Clicked!”
- en: How it works...
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As with most of the recipes in this chapter, we use `GameMode` to create and
    display our UI to minimize the number of classes that are extraneous to the point
    of the recipe that you need to create.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与本章中的大多数配方一样，我们使用`GameMode`创建和显示我们的UI，以最小化你需要创建的与配方无关的类的数量。
- en: Within our new game mode, we need to retain references to the Slate Widgets
    that we create so that we can interact with them after their creation.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的新游戏模式中，我们需要保留我们创建的Slate小部件的引用，这样我们就可以在它们创建后与之交互。
- en: As a result, we create two shared pointers as member data within our `GameMode` – one
    to the overall parent or root widget of our UI, and the other to the label on
    our button, because we're going to be changing the label text at runtime later.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们在`GameMode`中创建了两个共享指针作为成员数据——一个指向我们的UI的整体父或根小部件，另一个指向按钮上的标签，因为我们将在稍后运行时更改标签文本。
- en: We override `BeginPlay`, as it is a convenient place to create our UI after
    the game has started, and we will be able to get valid references to our player
    controller.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们覆盖`BeginPlay`，因为这是在游戏开始后创建UI的一个方便的地方，我们能够获取到有效的玩家控制器引用。
- en: We also create a function called `ButtonClicked`. It returns `FReply`, a `struct`
    indicating if an event was handled. The function signature for `ButtonClicked`
    is determined by the signature of `FOnClicked`, a delegate that we will be using
    in a moment.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还创建了一个名为 `ButtonClicked` 的函数。它返回 `FReply`，一个表示事件是否被处理的 `struct`。`ButtonClicked`
    函数的签名由 `FOnClicked` 的签名决定，这是一个我们将在稍后使用的委托。
- en: Inside our implementation of `BeginPlay`, the first thing we do is call the
    implementation we are overriding to ensure that the class is initialized appropriately.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的 `BeginPlay` 实现中，我们首先调用我们正在重写的实现，以确保类被适当地初始化。
- en: Then, as usual, we use our `SNew` function to create `VerticalBox`, and we add
    a slot to it, which is centered.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，像往常一样，我们使用我们的 `SNew` 函数来创建 `VerticalBox`，并给它添加一个居中的槽位。
- en: We create a new `Button` inside that slot, and we add a value to the `OnClicked`
    attribute that the button contains.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在那个槽位中创建一个新的 `Button`，并向按钮包含的 `OnClicked` 属性添加一个值。
- en: '`OnClicked` is a delegate property. This means that the `Button` will broadcast
    the `OnClicked` delegate any time a certain event happens (as the name implies
    in this instance, when the button is clicked).'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`OnClicked` 是一个委托属性。这意味着当发生特定事件时（如名称所暗示的，在这个例子中，当按钮被点击时），`Button` 将广播 `OnClicked`
    委托。'
- en: To subscribe or listen to the delegate, and be notified of the event that it
    refers to, we need to assign a delegate instance to the property.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要订阅或监听委托，并接收它所引用的事件通知，我们需要将委托实例分配给属性。
- en: We do that using the standard delegate functions such as `CreateUObject`, `CreateStatic`,
    or `CreateLambda`. Any of those will work – we can bind `UObject` member functions,
    static functions, lambdas, and other functions.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用标准的委托函数，如 `CreateUObject`、`CreateStatic` 或 `CreateLambda` 来实现这一点。这些中的任何一个都可以工作——我们可以绑定
    `UObject` 成员函数、静态函数、lambda 函数和其他函数。
- en: Check out [Chapter 5](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml), *Handling
    Events and Delegates,* to learn more about delegates and look at the other types
    of functions that we can bind to delegates.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查阅[第5章](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml)，*处理事件和委托*，了解更多关于委托的信息，并查看我们可以绑定到委托的其他函数类型。
- en: '`CreateUObject` expects a pointer to a class instance, and a pointer to the
    member function that''s defined in that class to call. The function has to have
    a signature that can be converted into the signature of the delegate:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CreateUObject` 期望一个指向类实例的指针和一个指向在该类中定义的成员函数的指针。该函数必须具有可以转换为委托签名的签名：'
- en: '[PRE22]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we can see, the `OnClicked` delegate type is `FOnClicked` – this is why the
    `ButtonClicked` function that we declared has the same signature as `FOnClicked`.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们所见，`OnClicked` 委托类型是 `FOnClicked` ——这就是为什么我们声明的 `ButtonClicked` 函数具有与 `FOnClicked`
    相同的签名。
- en: By passing in a pointer to this, and the pointer to the function to invoke,
    the engine will call that function on this specific object instance when the button
    is clicked.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过传递对这个指针和要调用的函数的指针，当按钮被点击时，引擎将在特定的对象实例上调用该函数。
- en: After setting up the delegate, we use the `Content()` function, which returns
    a reference to the single slot that the button has for any content that it should
    contain.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在设置委托之后，我们使用 `Content()` 函数，它返回对按钮用于包含任何内容的单个槽位的引用。
- en: We then use `SAssignNew` to create our button's label by using the `TextBlock`
    widget. `SAssignNew` is important because it allows us to use Slate's declarative
    syntax, and yet assigns variables to point to specific child widgets in the hierarchy.
    `SAssignNew`'s first argument is the variable that we want to store the widget
    in, and the second argument is the type of that widget.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们接着使用 `SAssignNew` 通过 `TextBlock` 小部件创建我们的按钮标签。`SAssignNew` 非常重要，因为它允许我们使用
    Slate 的声明性语法，同时将变量分配给层次结构中特定的子小部件。`SAssignNew` 的第一个参数是我们想要存储小部件的变量，第二个参数是小部件的类型。
- en: With `ButtonLabel` now pointing at our button's `TextBlock`, we can set its
    `Text` attribute to a static string.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 `ButtonLabel` 现在指向我们的按钮的 `TextBlock`，我们可以将其 `Text` 属性设置为静态字符串。
- en: Finally, we add the widget to the player's viewport using `AddViewportWidgetForPlayer`,
    which expects, as parameters, `LocalPlayer` to add the widget to, the widget itself,
    and a depth value (higher values to the front).
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们使用 `AddViewportWidgetForPlayer` 将小部件添加到玩家的视图中，该函数期望参数为 `LocalPlayer` 以添加小部件，小部件本身，以及一个深度值（值越高越靠前）。
- en: To get the `LocalPlayer` instance, we assume we are running without split screen,
    and so the first player controller will be the only one, that is, the player's
    controller. The `GetFirstLocalPlayerFromController` function is a convenience
    function that simply fetches the first player's controller and returns its local
    player object.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要获取 `LocalPlayer` 实例，我们假设我们在没有分屏的情况下运行，因此第一个玩家控制器将是唯一的，即玩家的控制器。`GetFirstLocalPlayerFromController`
    函数是一个便利函数，它简单地获取第一个玩家的控制器并返回其本地玩家对象。
- en: We also need to focus the widget so that the player can click on it and display
    a cursor so that the player knows where their mouse is on the screen.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还需要聚焦小部件，以便玩家可以点击它，并显示光标，以便玩家知道他们的鼠标在屏幕上的位置。
- en: We know from the previous step that we can assume the first local player controller
    is the one we're interested in, so we can access it and change its `ShowMouseCursor`
    variable to `true`. This will cause the cursor to be rendered on screen.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从上一步我们知道，我们可以假设第一个本地玩家控制器是我们感兴趣的，因此我们可以访问它并更改其 `ShowMouseCursor` 变量为 `true`。这将导致光标在屏幕上渲染。
- en: '`SetInputMode` allows us to focus on a widget so that the player can interact
    with it among other UI-related functionality, such as locking the mouse to the
    game''s viewport. It uses an `FInputMode` object as its only parameter, which
    we can construct with the specific elements that we wish to include by using the
    `builder` pattern.'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SetInputMode` 允许我们聚焦于一个小部件，以便玩家可以在其他 UI 相关功能（如锁定鼠标到游戏视口）中与之交互。它使用一个 `FInputMode`
    对象作为其唯一参数，我们可以使用 `builder` 模式通过特定的元素来构建它，我们希望包含哪些元素。'
- en: The `FInputModeUIOnly` class is an `FInputMode` subclass that specifies that
    we want all input events to be redirected to the UI layer rather than the player
    controller and other input handling.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`FInputModeUIOnly` 类是 `FInputMode` 的子类，它指定了我们将所有输入事件重定向到 UI 层，而不是玩家控制器和其他输入处理。'
- en: The `builder` pattern allows us to chain the method calls to customize our object
    instance before it is sent into the function as the parameter.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`builder` 模式允许我们在对象实例被作为参数发送到函数之前，通过链式调用方法来自定义我们的对象实例。'
- en: We chain `SetLockMouseToViewport(false)` to specify that the player's mouse
    can leave the boundary of the game screen with `SetWidgetToFocus(Widget)`, which
    specifies our top-level widget as the one that the game should direct player input
    to.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们链式调用 `SetLockMouseToViewport(false)` 来指定玩家的鼠标可以离开游戏屏幕的边界，通过 `SetWidgetToFocus(Widget)`
    指定我们的顶级小部件作为游戏应将玩家输入定向到的小部件。
- en: Finally, we have our actual implementation for `ButtonClicked`, which is our
    event handler. When the function is run due to our button being clicked, we change
    our button's label to indicate it has been clicked. We then need to return an
    instance of `FReply` to the caller to let the UI framework know that the event
    has been handled, and to not continue propagating the event back up the widget
    hierarchy.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们有 `ButtonClicked` 的实际实现，它是我们的事件处理器。当函数因我们的按钮被点击而运行时，我们更改按钮的标签以指示它已被点击。然后我们需要返回一个
    `FReply` 实例给调用者，让 UI 框架知道事件已被处理，并且不要继续将事件向上传播到小部件层次结构。
- en: '`FReply::Handled()` returns `FReply` set up to indicate this to the framework.
    We could have used `FReply::Unhandled()`, but this would have told the framework
    that the click event wasn''t actually the one we were interested in, and it should
    look for other objects that might be interested in the event instead.'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`FReply::Handled()` 返回一个设置好的 `FReply`，以指示框架。我们本可以使用 `FReply::Unhandled()`，但这将告诉框架点击事件实际上不是我们感兴趣的，它应该寻找可能对事件感兴趣的其他对象。'
- en: Using Data Binding with Unreal Motion Graphics
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据绑定与 Unreal Motion Graphics
- en: So far, we've been assigning static values to the attributes of our UI widgets.
    However, what if we want to be more dynamic with widget content, or parameters
    such as border color? We can use a principle called data binding to dynamically
    link properties of our UI with variables in the broader program.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在将静态值分配给我们的 UI 小部件的属性。然而，如果我们想使小部件内容或如边框颜色等参数更加动态，我们可以使用一个称为数据绑定的原则，将我们的
    UI 属性与更广泛程序中的变量动态链接。
- en: Unreal uses the Attribute system to allow us to bind the value of an attribute
    to the return value from a function, for example. This means that changing those
    variables will automatically cause the UI to change in response, according to
    our wishes.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Unreal 使用属性系统来允许我们将属性的值绑定到函数的返回值，例如。这意味着更改这些变量将自动导致 UI 根据我们的意愿进行更改。
- en: How to do it...
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Create a new `GameModeBase` subclass called `AttributeGameMode`.
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `GameModeBase` 子类，命名为 `AttributeGameMode`。
- en: 'Update the `AttributeGameMode.h` file to the following:'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `AttributeGameMode.h` 文件更新为以下内容：
- en: '[PRE23]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the implementation for `BeginPlay` within the `.cpp` file:'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `.cpp` 文件中添加 `BeginPlay` 的实现：
- en: '[PRE24]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Also, add an implementation for `GetButtonLabel()`:'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要添加 `GetButtonLabel()` 的实现：
- en: '[PRE25]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Compile your code and launch the editor.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码并启动编辑器。
- en: Override the game mode in World Settings to be `AAttributeGameMode`.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在世界设置中覆盖游戏模式为 `AAttributeGameMode`。
- en: 'Note that, in a Play In Editor session, the value on the UI''s button changes
    as the player moves around the scene:'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在 Play In Editor 会话中，UI按钮上的值会随着玩家在场景中的移动而改变：
- en: '![](img/2154c05b-1acb-4ebe-b7ec-beea999cb541.png)'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/2154c05b-1acb-4ebe-b7ec-beea999cb541.png)'
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Just like almost all the other recipes in this chapter, the first thing we need
    to do is create a game mode as a convenient host for our UI. We create the UI
    in the same fashion as in the other recipes, that is, by placing `Slate` code
    inside the `BeginPlay()` method of our game mode.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像本章中几乎所有的其他配方一样，我们首先需要做的是创建一个游戏模式，作为我们UI的便捷宿主。我们创建UI的方式与其他配方相同，即在游戏模式的 `BeginPlay()`
    方法中放置 `Slate` 代码。
- en: 'The interesting feature of this recipe concerns how we set the value of our
    button''s label text:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本配方中有趣的功能涉及我们如何设置按钮标签文本的值：
- en: '[PRE26]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding syntax is unusually verbose, but what it is actually doing is
    comparatively simple. We assign something to the `Text` property, which is of
    the type `FText`. We can assign `TAttribute<FText>` to this property, and the
    `TAttribute Get()` method will be called whenever the UI wants to ensure that
    the value of `Text` is up to date.
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述语法非常冗长，但它实际上做的事情相对简单。我们向 `Text` 属性分配了一个值，该属性的类型为 `FText`。我们可以将 `TAttribute<FText>`
    分配给此属性，并且每当UI想要确保 `Text` 的值是最新的时，都会调用 `TAttribute Get()` 方法。
- en: To create `TAttribute`, we need to call the static `TAttribute<VariableType>::Create()`
    method. This function expects a delegate of some description. Depending on the
    type of delegate that's passed to `TAttribute::Create`, `TAttribute::Get()` invokes
    a different type of function to retrieve the actual value.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要创建 `TAttribute`，我们需要调用静态方法 `TAttribute<VariableType>::Create()`。此函数期望一个描述性的委托。根据传递给
    `TAttribute::Create` 的委托类型，`TAttribute::Get()` 将调用不同类型的函数来检索实际值。
- en: In the code for this recipe, we invoke a member function of `UObject`. This
    means that we know we will be calling the `CreateUObject` function on some delegate
    type.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本配方的代码中，我们调用 `UObject` 的成员函数。这意味着我们知道我们将在某些委托类型上调用 `CreateUObject` 函数。
- en: We can use `CreateLambda`, `CreateStatic`, or `CreateRaw` to invoke a `lambda`,
    a `static`, or a `member` function on a raw C++ class, respectively. This will
    give us the current value for the attribute.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用 `CreateLambda`、`CreateStatic` 或 `CreateRaw` 分别调用原始 C++ 类上的 `lambda`、`static`
    或 `member` 函数。这将给我们当前属性的值。
- en: But what delegate type do we want to create an instance of? Because we're templating
    the `TAttribute` class on the actual variable type that the attribute will be
    associated with, we need a delegate that is also templated on the variable type
    as its return value.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但我们想要创建哪种委托类型的实例？因为我们正在将 `TAttribute` 类模板化，以便与属性关联的实际变量类型，我们需要一个委托，其返回值也是模板化的变量类型。
- en: That is to say, if we have `TAttribute<FText>`, the delegate that's connected
    to it needs to return an `FText`.
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也就是说，如果我们有 `TAttribute<FText>`，与之连接的委托需要返回一个 `FText`。
- en: 'We have the following code within `TAttribute`:'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `TAttribute` 中，我们有以下代码：
- en: '[PRE27]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `FGetter` delegate type is declared inside the `TAttribute` class, so its
    return value can be templated on the `ObjectType` parameter of the `TAttribute`
    template. This means that `TAttribute<Typename>::FGetter` automatically defines
    a delegate with the correct return type of `Typename`. So, we need to create a
    UObject-bound delegate of type and signature for `TAttribute<FText>::FGetter`.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`FGetter` 委托类型在 `TAttribute` 类内部声明，因此其返回值可以基于 `TAttribute` 模板的 `ObjectType`
    参数进行模板化。这意味着 `TAttribute<Typename>::FGetter` 自动定义了一个具有正确返回类型 `Typename` 的委托。因此，我们需要创建一个与
    `TAttribute<FText>::FGetter` 类型签名绑定的 UObject 委托。'
- en: Once we have that delegate, we can call `TAttribute::Create` on the delegate
    to link the delegate's return value to our `TextBlock` member variable `Text`.
    With our UI defined and a binding between the `Text` property, a `TAttribute<FText>`,
    and a delegate returning `FText`, we can now add the UI to the player's screen
    so that it's visible.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们有了那个委托，我们就可以在委托上调用 `TAttribute::Create` 来将委托的返回值链接到我们的 `TextBlock` 成员变量
    `Text`。有了我们的UI定义以及 `Text` 属性、`TAttribute<FText>` 和返回 `FText` 的委托之间的绑定，我们现在可以将UI添加到玩家的屏幕上，使其可见。
- en: Every frame, the game engine checks all of the properties to see if they are
    linked to `TAttributes`. If there's a connection, then the `TAttribute``Get()`
    function is called, invoking the delegate and returning the delegate's return
    value so that Slate can store it inside the widget's corresponding member variable.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每一帧，游戏引擎都会检查所有属性，看它们是否链接到 `TAttributes`。如果有连接，则调用 `TAttribute::Get()` 函数，调用委托并返回委托的返回值，以便Slate可以将其存储在窗口小部件相应的成员变量中。
- en: For our demonstration of this process, `GetButtonLabel` retrieves the location
    of the first player pawn in the game world. We then use `FString::Printf` to format
    the location data into a human readable string, and wrap that in an `FText` so
    that it can be stored as the `TextBlock` text value.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于我们这个过程的演示，`GetButtonLabel` 获取游戏世界中第一个玩家兵的位置。然后我们使用 `FString::Printf` 将位置数据格式化为可读的字符串，并将其包裹在
    `FText` 中，以便它可以作为 `TextBlock` 文本值存储。
- en: Controlling widget appearance with Styles
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用样式控制小部件外观
- en: So far in this chapter, we've been creating UI elements that use the default
    visual representation. This recipe shows you how to create a Style in C++ that
    can be used as a common look and feel across your whole project.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们一直在创建使用默认视觉表示的UI元素。这个配方展示了如何在C++中创建一个样式，该样式可以在整个项目中用作通用的外观和感觉。
- en: How to do it...
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new class for your project by using the Add C++ Class wizard and selecting
    None as your parent class:'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用添加C++类向导并选择无作为父类来为你的项目创建一个新的类：
- en: '![](img/64c3708b-d1e9-480b-95c7-28fcaf1f9d69.png)'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/64c3708b-d1e9-480b-95c7-28fcaf1f9d69.png)'
- en: 'Under the name option, use `CookbookStyle` and click on the Create Class button:'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名称选项下，使用 `CookbookStyle` 并点击创建类按钮：
- en: '![](img/ebb36faa-5690-4154-aae9-0569f96d67d4.png)'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/ebb36faa-5690-4154-aae9-0569f96d67d4.png)'
- en: 'Replace the code in the `CookbookStyle.h` file with the following code:'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `CookbookStyle.h` 文件中的代码替换为以下代码：
- en: '[PRE28]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Open the `CookbookStyle.cpp` file and use the following code for it:'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `CookbookStyle.cpp` 文件，并使用以下代码：
- en: '[PRE29]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the following content below the previously created script in the `CookbookStyle.cpp` file
    to describe how to draw the screen:'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CookbookStyle.cpp` 文件中，在之前创建的脚本下方添加以下内容来描述如何绘制屏幕：
- en: '[PRE30]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a new `GameModeBase` subclass, `StyledHUDGameMode`:'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个新的 `GameModeBase` 子类，`StyledHUDGameMode`:'
- en: '![](img/a6078305-d562-4c27-b878-7e635d381cfd.png)'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/a6078305-d562-4c27-b878-7e635d381cfd.png)'
- en: 'Once Visual Studio opens, add the following code to its declaration:'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Visual Studio打开，向其声明中添加以下代码：
- en: '[PRE31]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Likewise, implement `GameMode`:'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '同样，实现 `GameMode`:'
- en: '[PRE32]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Lastly, create a 54 x 54 pixel PNG file with a border around it for our button:'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个带有边框的54 x 54像素PNG文件，用于我们的按钮：
- en: '![](img/73922731-36ea-47f4-9e56-48280866be32.png)'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/73922731-36ea-47f4-9e56-48280866be32.png)'
- en: 'Save it to the `Content` | `Slate` folder with the name `Button.png`, creating
    the folder if needed:'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其保存到 `Content` | `Slate` 文件夹，文件名为 `Button.png`，如果需要则创建文件夹：
- en: '![](img/293da37b-9933-4c8f-b2e5-d749a70f8302.png)'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/293da37b-9933-4c8f-b2e5-d749a70f8302.png)'
- en: You may be asked if you'd like to import the image into your project. Go ahead
    and say yes.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会被问是否要将图像导入到你的项目中。请继续并说“是”。
- en: 'Finally, we need to set our game''s module to properly initialize the style
    when it is loaded. In your game module''s implementation file (`Chapter_14.h`),
    ensure it looks like this:'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要设置我们的游戏模块，以便在加载时正确初始化样式。在你的游戏模块实现文件（`Chapter_14.h`）中，确保它看起来像这样：
- en: '[PRE33]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, go to the `Chapter_14.cpp` file and modify the code to the following:'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到 `Chapter_14.cpp` 文件并修改代码如下：
- en: '[PRE34]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Compile the code and set your game mode override to the new game mode, like
    we did in the other recipes in this chapter.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码并将你的游戏模式覆盖设置为新的游戏模式，就像我们在本章其他配方中所做的那样。
- en: 'When you play the game, you will see that your custom border is around the
    button, and that the text is white rather than black:'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你玩游戏时，你会看到你的自定义边框围绕在按钮周围，而且文本是白色而不是黑色：
- en: '![](img/0a88391a-3f1f-4343-be79-7a38b5271782.png)'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/0a88391a-3f1f-4343-be79-7a38b5271782.png)'
- en: How it works...
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For us to create styles that can be shared across multiple Slate widgets, we
    need to create an object to contain the styles and keep them in scope.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了创建可以在多个Slate小部件之间共享的样式，我们需要创建一个对象来包含这些样式并保持它们的作用域。
- en: Epic provides the `FSlateStyleSet` class for this purpose. `FSlateStyleSet`
    contains a number of styles that we can access within Slate's declarative syntax
    to skin widgets.
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Epic提供了`FSlateStyleSet`类来实现这个目的。`FSlateStyleSet`包含许多我们可以在Slate声明性语法中访问的样式，用于皮肤小部件。
- en: However, it's inefficient to have multiple copies of our `StyleSet` object scattered
    through the program. We really only need one of these objects.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，在程序中散布多个`StyleSet`对象的副本是不高效的。我们实际上只需要一个这样的对象。
- en: Because `FSlateStyleSet` itself is not a singleton, that is, an object that
    can only have one instance, we need to create a class that will manage our `StyleSet`
    object and ensure that we only have the single instance.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为`FSlateStyleSet`本身不是单例，即只能有一个实例的对象，我们需要创建一个类来管理我们的`StyleSet`对象，并确保我们只有一个实例。
- en: This is the reason we have the `FCookbookStyle` class. It contains an `Initialize()`
    function, which we will call in our module's startup code. In the `Initialize()`
    function, we check if we have an instance of our `StyleSet`. If we do not have
    a valid instance, we call the private `Create()` function to instantiate one.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是为什么我们有`FCookbookStyle`类。它包含一个`Initialize()`函数，我们将在模块的启动代码中调用它。在`Initialize()`函数中，我们检查我们是否有`StyleSet`的实例。如果没有有效的实例，我们调用私有的`Create()`函数来实例化一个。
- en: We then register the style with the `FSlateStyleRegistry` class.
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们使用`FSlateStyleRegistry`类注册样式。
- en: When our module is unloaded, we will need to reverse this registration process,
    then erase the pointer so that it doesn't dangle.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们的模块卸载时，我们需要反转这个注册过程，然后删除指针，以防止悬挂。
- en: We now have an instance of our class that was created during module initialization
    by calling `Create()`. You'll notice that `Create` is wrapped by a number of macros
    that all have a similar form. These macros are defined before the function, and
    undefined after it.
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有一个在模块初始化期间通过调用`Create()`创建的类的实例。你会注意到`Create`被多个具有类似形式的宏所包裹。这些宏在函数之前定义，在函数之后未定义。
- en: These macros make it easier for us to simplify the code that's required within
    the `Create` function by eliminating the need to specify a path and extension
    for all the image resources that our Style might want to use.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些宏使我们能够通过消除为我们的样式可能想要使用的所有图像资源指定路径和扩展名的需要，简化`Create`函数中所需的代码。
- en: Within the `Create` function, we create a new `FSlateStyleSet` object using
    the `FSlateGameResources::New()` function. `New()` needs a name for the style,
    and the folder paths that we want to search for in this Style Set.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`Create`函数内部，我们使用`FSlateGameResources::New()`函数创建一个新的`FSlateStyleSet`对象。`New()`需要一个样式的名称，以及我们想要在这个样式集中搜索的文件夹路径。
- en: This allows us to declare multiple Style Sets that are pointing to different
    directories, but using the same names for the images. It also allows us to skin
    or restyle the whole UI simply by switching to a Style Set in one of the other
    base directories.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这允许我们声明多个指向不同目录的样式集，但使用相同的图像名称。它还允许我们通过切换到其他基本目录中的一个样式集来简单地皮肤或重设整个UI。
- en: '`New()` returns a shared reference object, so we retrieve the actual `FStyleSet`
    instance using the `Get()` function.'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`New()`返回一个共享引用对象，因此我们使用`Get()`函数检索实际的`FStyleSet`实例。'
- en: With this reference in hand, we can create the styles we want this set to contain.
    To add styles to a set, we use the `Set()` method. Set expects the name of the
    style, and then a style object. Style objects can be customized using the `builder`
    pattern.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 拿着这个参考，我们可以创建我们想要这个集合包含的样式。要向集合添加样式，我们使用`Set()`方法。`Set()`方法期望样式的名称，然后是一个样式对象。样式对象可以使用`builder`模式进行自定义。
- en: We first add a style called `"NormalButtonBrush"`. The name can be arbitrary.
    Because we want to use this style to change the appearance of buttons, we need
    to use `FButtonStyle` for the second parameter.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先添加一个名为`"NormalButtonBrush"`的样式。名称可以是任意的。因为我们想使用这个样式来改变按钮的外观，所以我们需要为第二个参数使用`FButtonStyle`。
- en: To customize the style to our requirements, we use the Slate builder syntax,
    chaining whatever method calls that we need to set properties on our style.
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了根据我们的需求自定义样式，我们使用Slate构建器语法，链接我们需要设置样式属性的所有方法调用。
- en: For the first style in this set, we just change the visual appearance of the
    button when it isn't being clicked or is in a non-default state. This means that
    we want to change the brush that's used when the button is in the normal state,
    and so the function we use is `SetNormal()`.
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这个集合中的第一个样式，我们只是改变按钮在未被点击或处于非默认状态时的视觉外观。这意味着我们想要改变按钮在正常状态时使用的画刷，因此我们使用的函数是`SetNormal()`。
- en: Using the `BOX_BRUSH` macro, we tell Slate that we want to use `Button.png`,
    which is an image of 54 x 54 pixel size, and that we want to keep the 14 pixels
    in each corner unstretched for the purposes of nine-slice scaling.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`BOX_BRUSH`宏，我们告诉Slate我们想要使用`Button.png`，这是一个54 x 54像素大小的图像，并且我们想要保持每个角落的14像素不拉伸，用于九宫格缩放。
- en: For a more visual explanation of the nine-slice scaling functionality, take
    a look at `SlateBoxBrush.h` in the engine source.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于九宫格缩放功能的更直观解释，请查看引擎源代码中的`SlateBoxBrush.h`。
- en: For the second style in our Style Set, we create a style called `"NormalButtonText"`.
    For this style, we don't want to change everything from defaults in the style;
    we just want to alter one property. As a result, we access the default text style
    and clone it using the copy constructor.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于样式集中的第二个样式，我们创建了一个名为`"NormalButtonText"`的样式。对于这个样式，我们不想从默认样式改变一切；我们只想改变一个属性。因此，我们访问默认的文本样式并使用拷贝构造函数克隆它。
- en: With our fresh copy of the default style, we then change the color of the text
    to white, first creating a linear color of R=1 G=1 B=1 A=1, and then convert that
    into a Slate color object.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用我们默认样式的副本，我们首先将文本颜色更改为白色，首先创建一个线性颜色 R=1 G=1 B=1 A=1，然后将它转换成一个Slate颜色对象。
- en: With our Style Set configured with our two new styles, we can then return it
    to the calling function, which is `Initialize`. `Initialize` stores our Style
    Set reference and eliminates the need for us to create further instances.
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的样式集配置了两个新样式后，我们可以将其返回给调用函数，即`Initialize`。`Initialize`存储我们的样式集引用，消除了我们需要创建更多实例的需求。
- en: Our style container class also has a `Get()` function, which is used to retrieve
    the actual `StyleSet` for use in Slate. Because `Initialize()` has already been
    called at module startup, `Get()` simply returns the `StyleSet` instance that
    was created within that function.
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的风格容器类还有一个`Get()`函数，它用于检索用于Slate的实际`StyleSet`。因为`Initialize()`已经在模块启动时被调用，所以`Get()`简单地返回在该函数内部创建的`StyleSet`实例。
- en: Within the game module, we add the code that actually calls `Initialize` and
    `Shutdown`. This ensures that while our module is loaded, we will always have
    a valid reference to our Slate Style.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在游戏模块内部，我们添加了实际调用`Initialize`和`Shutdown`的代码。这确保了当我们的模块被加载时，我们始终有一个有效的Slate样式的引用。
- en: As always, we create a Game Mode as the host for our UI, and we override `BeginPlay`
    so that we can create the UI when the game starts.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和往常一样，我们创建一个游戏模式作为我们UI的主机，并覆盖`BeginPlay`以便我们可以在游戏开始时创建UI。
- en: The syntax for creating the UI is exactly the same as we've used in previous
    recipes – creating a `VerticalBox` using `SNew`, and then using Slate's declarative
    syntax to populate the box with other widgets.
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建UI的语法与我们之前在食谱中使用的完全相同——使用`SNew`创建一个`VerticalBox`，然后使用Slate的声明性语法填充其他小部件。
- en: 'It is important to note the two following lines:'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下两条以下内容非常重要：
- en: '[PRE35]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding lines are part of the declarative syntax for our button, and the
    text that makes its label. When we set the style for our widgets using a `<Class>Style()`
    method, we pass in two parameters.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的行是我们按钮的声明性语法的一部分，以及构成其标签的文本。当我们使用`<Class>Style()`方法为小部件设置样式时，我们传递两个参数。
- en: The first parameter is our actual Style Set, which is retrieved by using `FCookbookStyle::Get()`,
    and the second is a string parameter with the name of the style that we want to
    use.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个参数是我们实际的样式集，它通过使用`FCookbookStyle::Get()`检索，第二个是一个字符串参数，包含我们想要使用的样式的名称。
- en: With these minor changes, we override the styling of the widgets to use our
    custom styles so that when we add the widgets to the player's viewport, they display
    our customizations.
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这些微小的更改，我们覆盖了小部件的样式以使用我们的自定义样式，这样当我们把小部件添加到玩家的视口时，它们会显示我们的自定义设置。
- en: Creating a custom SWidget/UWidget
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义SWidget/UWidget
- en: The recipes in this chapter so far have shown you how to create UIs using the
    existing primitive widgets.
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，本章中的食谱已经向您展示了如何使用现有的原始小部件创建UI。
- en: Sometimes, it is convenient for developers to use composition to collect a number
    of UI elements to define a button class that automatically has a `TextBlock` as
    a label rather than manually specifying the hierarchy every time they are declared,
    for example.
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时，对于开发者来说，使用组合来收集多个 UI 元素以定义一个按钮类很有用，该按钮类自动具有 `TextBlock` 作为标签，而不是每次声明时都手动指定层次结构，例如。
- en: Furthermore, if you are manually specifying the hierarchy in C++, rather than
    declaring a compound object consisting of subwidgets, you won't be able to instantiate
    those widgets as a group using UMG.
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，如果你在 C++ 中手动指定层次结构，而不是声明由子控件组成的复合对象，则无法使用 UMG 将这些控件作为组实例化。
- en: Getting ready
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe shows you how to create a compound `SWidget` that contains a group
    of widgets and exposes new properties to control elements of those subwidgets.
    It will also show you how to create a `UWidget` wrapper, which will expose the
    new compound `SWidget` class to UMG so that it can be used by designers.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此配方向您展示了如何创建一个包含一组控件的复合 `SWidget`，并公开新的属性来控制这些子控件的元素。它还将向您展示如何创建一个 `UWidget`
    包装器，这样可以将新的复合 `SWidget` 类公开给 UMG，以便设计师可以使用它。
- en: How to do it...
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We need to add the UMG module to our module's dependencies.
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将 UMG 模块添加到我们模块的依赖项中。
- en: 'Open up `<YourModule>.build.cs`, which in our case is `Chapter_14.Build.cs`,
    and add UMG to the following code:'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `<YourModule>.build.cs`，在我们的例子中是 `Chapter_14.Build.cs`，并将 UMG 添加到以下代码中：
- en: '[PRE36]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create a new class based on the Slate Widget parent class (`SCompoundWidget`):'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于Slate Widget父类（`SCompoundWidget`）创建一个新的类：
- en: '![](img/1a17774f-7605-4d12-ad72-aa538589875a.png)'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/1a17774f-7605-4d12-ad72-aa538589875a.png)'
- en: When asked for a name, call it `CustomButton`.
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被要求命名时，将其命名为 `CustomButton`。
- en: 'Once created, add the following code to its declaration:'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建后，将其声明中的以下代码添加到其中：
- en: '[PRE37]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Implement the class with the following in the corresponding `.cpp` file:'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相应的 `.cpp` 文件中实现该类，如下所示：
- en: '[PRE38]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create a second class, this time based on `Widget`:'
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个类，这次基于 `Widget`：
- en: '![](img/70f5329f-c812-4ee8-9108-2c186e2130c5.png)'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/70f5329f-c812-4ee8-9108-2c186e2130c5.png)'
- en: Call this new class `CustomButtonWidget` and press Create Class.
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用这个新的类 `CustomButtonWidget` 并按创建类。
- en: 'Add the bold code in the following snippet to the `CustomButtonWidget.h` file:'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下片段中的粗体代码添加到 `CustomButtonWidget.h` 文件中：
- en: '[PRE39]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, create the implementation for `UCustomButtonWidget`:'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为 `UCustomButtonWidget` 创建实现：
- en: '[PRE40]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Save your scripts and compile your code.
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并编译你的代码。
- en: 'Create a new Widget Blueprint by right-clicking on the Content Browser and
    selecting User Interface and then Widget Blueprint:'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在内容浏览器上右键单击并选择用户界面然后选择 Widget 蓝图来创建一个新的 Widget 蓝图：
- en: '![](img/019ade72-7ac5-4639-84ec-59fbf045dcbd.png)'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/019ade72-7ac5-4639-84ec-59fbf045dcbd.png)'
- en: You can use the mouse wheel in the context menu to scroll to the User Interface
    section.
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用上下文菜单中的鼠标滚轮滚动到用户界面部分。
- en: Open your new Widget Blueprint by double-clicking on it.
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过双击它来打开你的新 Widget 蓝图。
- en: 'Find the Custom Button Widget in the Widget Palette:'
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Widget 面板中找到自定义按钮控件：
- en: '![](img/7ec28d12-c477-458d-bb1d-e22f94528e26.png)'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/7ec28d12-c477-458d-bb1d-e22f94528e26.png)'
- en: Drag an instance of it out into the main area.
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其实例拖到主区域。
- en: 'With the instance selected, change the Label property in the Details panel:'
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择实例后，在详细信息面板中更改标签属性：
- en: '![](img/5941564e-b55b-4f07-b642-a24507181855.png)'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/5941564e-b55b-4f07-b642-a24507181855.png)'
- en: Verify that your button has changed its label.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 验证你的按钮是否已更改其标签。
- en: Now, we will create a binding to demonstrate that we can link arbitrary blueprint
    functions to the label property on our widget, which, in turn, drives the Widget's
    textblock label.
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个绑定来演示我们可以将任意蓝图函数链接到我们的小部件的标签属性，这反过来又驱动了 Widget 的文本块标签。
- en: 'Click on Bind to the right of the Label property and select Create Binding:'
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击标签属性右侧的绑定，选择创建绑定：
- en: '![](img/e4e52462-a9f1-4ed4-a5fd-8cbe749f1003.png)'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/e4e52462-a9f1-4ed4-a5fd-8cbe749f1003.png)'
- en: 'Within the graph that is now displayed, place a Get Game Time in Seconds node
    by right-clicking within the main area:'
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现在显示的图中，通过在主区域内部右键单击来放置一个获取游戏时间（秒）节点：
- en: '![](img/6f13155b-1c21-4fcc-9bd0-3e49c3ef08fc.png)'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/6f13155b-1c21-4fcc-9bd0-3e49c3ef08fc.png)'
- en: 'Link the return value from the Get Game Time node to the Return Value pin in
    the function:'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将获取游戏时间节点的返回值链接到函数的返回值引脚：
- en: '![](img/6421b9a8-c550-46aa-a2c4-22482c2699f5.jpg)'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/6421b9a8-c550-46aa-a2c4-22482c2699f5.jpg)'
- en: 'A Convert Float to String node will be automatically inserted for you:'
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将自动为您插入一个转换浮点数为字符串节点：
- en: '![](img/508844dd-cbe0-48c4-a007-d9ecb4fbafff.jpg)'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/508844dd-cbe0-48c4-a007-d9ecb4fbafff.jpg)'
- en: Compile the blueprint to ensure it is working correctly.
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译蓝图以确保其正确运行。
- en: 'Next, open the Level Blueprints by clicking on the Blueprints button on the
    taskbar and then selecting Open Level Blueprint:'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过点击任务栏上的蓝图按钮并选择打开关卡蓝图来打开关卡蓝图：
- en: '![](img/a7e07af8-6327-4b45-9fd2-8b8ee267eba1.png)'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/a7e07af8-6327-4b45-9fd2-8b8ee267eba1.png)'
- en: 'To the right of the Event BeginPlay node, place a Create Widget node into the
    graph:'
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件`BeginPlay`节点的右侧放置一个创建小部件节点到图中：
- en: '![](img/287da0f3-30e0-48de-a7fb-7524a6bc0782.png)'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/287da0f3-30e0-48de-a7fb-7524a6bc0782.png)'
- en: 'Select the Class of widget to spawn it as the new Widget Blueprint that we
    created a moment ago within the editor:'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择要创建的新小部件蓝图（我们刚刚在编辑器中创建的）的小部件类：
- en: '![](img/926ba980-6528-4778-8868-bf71d895ccb8.jpg)'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/926ba980-6528-4778-8868-bf71d895ccb8.jpg)'
- en: 'Click and drag away from the Owning Player pin on the create widget node and
    place a Get Player Controller node:'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从创建小部件节点的拥有玩家引脚上点击并拖动，放置一个获取玩家控制器节点：
- en: '![](img/cd0d48b2-dc8f-4b71-805c-639f0510e06e.jpg)'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/cd0d48b2-dc8f-4b71-805c-639f0510e06e.jpg)'
- en: 'Likewise, drag away from the return value of the Create Widget node and place
    an Add to Viewport node:'
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，从创建小部件节点的返回值拖动，放置一个添加到视口节点：
- en: '![](img/e005b240-36a4-4bde-9cb9-fea79fb1ed0e.jpg)'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/e005b240-36a4-4bde-9cb9-fea79fb1ed0e.jpg)'
- en: 'Lastly, link the `BeginPlay` node to the execution pin on the create widget
    node:'
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`BeginPlay`节点链接到创建小部件节点的执行引脚：
- en: '![](img/29583739-bbd2-4a2f-9750-d150412bd044.png)'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/29583739-bbd2-4a2f-9750-d150412bd044.png)'
- en: Preview your game and verify that the widget we've displayed onscreen is our
    new custom button, with its label bound to the number of seconds that have elapsed
    since the game started:![](img/6e798818-3319-43c4-a5c3-24c71cc70708.png)
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预览你的游戏，并验证屏幕上显示的小部件是否是我们新创建的自定义按钮，其标签绑定自游戏开始以来经过的秒数！![图片](img/6e798818-3319-43c4-a5c3-24c71cc70708.png)
- en: Button displaying the elapsed time in the level
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在关卡中显示经过时间的按钮
- en: How it works...
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To use the `UWidget` class, our module needs to include the UMG module as one
    of its dependencies, because `UWidget` is defined inside the UMG module.
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使用`UWidget`类，我们的模块需要将UMG模块作为其依赖项之一包含，因为`UWidget`是在UMG模块内部定义的。
- en: The first class that we need to create, however, is our actual `SWidget` class.
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，我们需要创建的第一个类实际上是我们的`SWidget`类。
- en: Because we want to aggregate two widgets together into a compound structure,
    we create our new widget as a `CompoundWidget` subclass. `CompoundWidget` allows
    you to encapsulate a widget hierarchy as a widget itself.
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为我们想要将两个小部件组合成一个复合结构，所以我们创建了一个新的`CompoundWidget`子类。`CompoundWidget`允许你将小部件层次结构封装为小部件本身。
- en: Inside the class, we use the `SLATE_BEGIN_ARGS` and `SLATE_END_ARGS` macros
    to declare an internal `struct` called `FArguments` on our new `SWidget`. Within
    `SLATE_BEGIN_ARGS` and `SLATE_END_ARGS`, the `SLATE_ATTRIBUTE` and `SLATE_EVENT`
    macros are used. `SLATE_ATTRIBUTE` creates `TAttribute` for the type we give it.
    In this class, we declare a `TAttribute` called `_Label`, which is more specifically
    a `TAttribute<FString>`.
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在类内部，我们使用`SLATE_BEGIN_ARGS`和`SLATE_END_ARGS`宏在新的`SWidget`上声明一个名为`FArguments`的内部`struct`。在`SLATE_BEGIN_ARGS`和`SLATE_END_ARGS`之间，使用`SLATE_ATTRIBUTE`和`SLATE_EVENT`宏。`SLATE_ATTRIBUTE`为我们提供的类型创建`TAttribute`。在这个类中，我们声明了一个名为`_Label`的`TAttribute`，它更具体地是一个`TAttribute<FString>`。
- en: '`SLATE_EVENT` allows us to create member delegates that we can broadcast when
    something happens internally to the widget.'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SLATE_EVENT`允许我们创建成员委托，当小部件内部发生某些事件时，我们可以广播这些委托。'
- en: In `SCustomButton`, we declare a delegate with the signature `FOnClicked`, called
    `ButtonClicked`.
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`SCustomButton`中，我们声明了一个具有`FOnClicked`签名的委托，名为`ButtonClicked`。
- en: '`SLATE_ARGUMENT` is another macro (which wasn''t used in this recipe) that
    creates an internal variable with the type and name you provide, appending an
    underscore to the start of the variable name.'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SLATE_ARGUMENT`是另一个宏（在这个配方中没有使用），它使用你提供的类型和名称创建一个内部变量，并在变量名前添加一个下划线。'
- en: '`Construct()` is the function that widgets implement to self-initialize when
    they are being instantiated. You''ll notice we also create `TAttribute` and `FOnClicked`
    instances ourselves, without the underscores. These are the actual properties
    of our object into which the arguments that we declared earlier will be copied.'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Construct()`是当小部件实例化时实现自我初始化的函数。你会注意到我们自己也创建了`TAttribute`和`FOnClicked`实例，而没有使用下划线。这些是我们对象的实际属性，我们将把之前声明的参数复制到这些属性中。'
- en: Inside the implementation of `Construct`, we retrieve the arguments that were
    passed to us in the `FArgumentsstruct`, and store them inside our actual member
    variables for this instance.
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `Construct` 的实现中，我们检索传递给我们的 `FArgumentsstruct` 的参数，并将它们存储在我们实际成员变量中，用于此实例。
- en: We assign `Label` and `ButtonClicked` based on what was passed in, and then
    we actually create our widget hierarchy. We use the same syntax as usual for this
    with one thing to note, namely the use of `Text_Lambda` to set the text value
    of our internal text block. We use a `lambda` function to retrieve the value of
    our `Label` `TAttribute` using `Get()`, convert it into `FText`, and store it
    as our text block's `Text` property.
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们根据传入的内容分配 `Label` 和 `ButtonClicked`，然后实际上创建我们的小部件层次结构。我们使用通常的语法进行此操作，需要注意的是使用
    `Text_Lambda` 来设置内部文本块的文本值。我们使用一个 `lambda` 函数通过 `Get()` 获取我们的 `Label` `TAttribute`
    的值，将其转换为 `FText`，并将其存储为文本块的 `Text` 属性。
- en: Now that we have our `SWidget` declared, we need to create a wrapper `UWidget`
    object that will expose this widget to the UMG system so that designers can use
    the widget within the **WYSIWYG** editor. This class will be called `UCustomButtonWidget`,
    and it inherits from `UWidget` rather than `SWidget`.
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经声明了 `SWidget`，我们需要创建一个包装 `UWidget` 对象，以便将其暴露给 UMG 系统，这样设计师就可以在 **WYSIWYG**
    编辑器中使用该小部件。这个类将被称为 `UCustomButtonWidget`，它继承自 `UWidget` 而不是 `SWidget`。
- en: The `UWidget` object needs a reference to the actual `SWidget` that it owns,
    so we place a protected member in the class that will store it as a shared pointer.
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`UWidget` 对象需要一个对其拥有的实际 `SWidget` 的引用，因此我们在类中放置一个受保护的成员，将其存储为共享指针。'
- en: A constructor is declared, as well as a `ButtonClicked` delegate that can be
    set in Blueprint. We also mirror a `Label` property that is marked as `BlueprintReadWrite`
    so that it can be set in the UMG editor.
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声明了一个构造函数，以及一个可以在蓝图设置中的 `ButtonClicked` 代理。我们还镜像了一个标记为 `BlueprintReadWrite`
    的 `Label` 属性，以便可以在 UMG 编辑器中设置。
- en: Because we want to be able to bind our button's label to a delegate, we add
    the last of our member variables, which is a delegate that returns a `String`.
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为我们希望能够将我们的按钮标签绑定到代理，所以我们添加了我们的最后一个成员变量，即一个返回 `String` 的代理。
- en: The `SynchronizeProperties` function applies properties that have been mirrored
    in our `UWidget` class across to the `SWidget` that we are linked with.
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SynchronizeProperties` 函数将已在我们的 `UWidget` 类中镜像的属性应用到我们关联的 `SWidget` 上。'
- en: '`RebuildWidget` reconstructs the native widget that `UWidget` is associated
    with. It uses `SNew` to construct an instance of our `SCustomButton` widget, and
    uses the Slate declarative syntax to bind the UWidget''s `OnButtonClicked` method
    to the `ButtonClicked` delegate inside the native widget. This means that when
    the native widget is clicked, the `UWidget` will be notified by having `OnButtonClicked`
    called.'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`RebuildWidget` 重建与 `UWidget` 关联的本地小部件。它使用 `SNew` 构建我们的 `SCustomButton` 小部件的实例，并使用
    Slate 声明性语法将 UWidget 的 `OnButtonClicked` 方法绑定到本地小部件内部的 `ButtonClicked` 代理。这意味着当本地小部件被点击时，`UWidget`
    将通过调用 `OnButtonClicked` 来接收通知。'
- en: '`OnButtonClicked` re-broadcasts the clicked event from the native button via
    the UWidget''s `ButtonClicked` delegate. This means that UObjects and the UMG
    system can be notified of the button being clicked without having a reference
    to the native button widget themselves. We can bind to `UCustomButtonWidget::ButtonClicked` so
    that we''re notified about this.'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`OnButtonClicked` 通过 UWidget 的 `ButtonClicked` 代理重新广播来自本地按钮的点击事件。这意味着 UObjects
    和 UMG 系统可以在没有本地按钮小部件的引用的情况下通知按钮被点击。我们可以绑定到 `UCustomButtonWidget::ButtonClicked`
    以便我们得到通知。'
- en: '`OnButtonClicked` then returns `FReply::Handled()` to indicate that the event
    does not need to propagate further. Inside `SynchronizeProperties`, we call the
    parent method to ensure that any properties in the parent are also synchronized
    properly.'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`OnButtonClicked` 然后返回 `FReply::Handled()` 以指示事件不需要进一步传播。在 `SynchronizeProperties`
    中，我们调用父方法以确保父级中的任何属性都得到正确同步。'
- en: We use the `OPTIONAL_BINDING` macro to link the `LabelDelegate` delegate in
    our `UWidget` class to `TAttribute`, and, in turn, the native button's label.
    It is important to note that the `OPTIONAL_BINDING` macro expects the delegate
    to be called `NameDelegate` based on the second parameter to the macro.
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `OPTIONAL_BINDING` 宏将我们的 `UWidget` 类中的 `LabelDelegate` 代理链接到 `TAttribute`，进而链接到本地按钮的标签。重要的是要注意，`OPTIONAL_BINDING`
    宏期望代理根据宏的第二个参数被命名为 `NameDelegate`。
- en: '`OPTIONAL_BINDING` allows the value to be overridden by a binding made via
    UMG, but only if the UMG binding is valid.'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`OPTIONAL_BINDING`允许通过UMG创建的绑定覆盖值，但仅当UMG绑定有效时。'
- en: This means that when `UWidget` is told to update itself, for example, because
    the user customizes a value in the Details panel within UMG, it will recreate
    the native `SWidget` if necessary, and then copy the values set in Blueprint/UMG
    via `SynchronizeProperties` so that everything continues to work as expected.
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着当`UWidget`被告知更新自身时，例如，因为用户在UMG的详情面板中自定义了一个值，它将根据需要重新创建本地的`SWidget`，然后通过`SynchronizeProperties`复制在蓝图/UMG中设置的值，以确保一切按预期继续工作。
