- en: User Interfaces - UI and UMG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Drawing using Canvas
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Slate Widgets to the screen
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating screen size-aware scaling for the UI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying and hiding a sheet of UMG elements in-game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching function calls to Slate events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Data Binding with Unreal Motion Graphics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling widget appearance with Styles
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom SWidget/UWidget
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Displaying feedback to the player is one of the most important elements within
    game design, and this will usually involve some sort of HUD, or at least menus,
    within your game.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: In previous versions of Unreal, there was simple HUD support, which allowed
    you to draw simple shapes and text to the screen. However, it was somewhat limited
    in terms of aesthetics, and so solutions such as **Scaleform** became common to
    work around these limitations. Scaleform leveraged Adobe's Flash file format to
    store vector images and UI scripts. It was not without its own cons for developers,
    though, not least the cost – it was a third-party product requiring a (sometimes,
    expensive) license.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: As a result, Epic developed Slate for the Unreal 4 editor and the in-game UI
    framework. Slate is a collection of widgets (UI elements) and a framework that
    allows for a cross-platform interface for the Editor. It is also usable in-game
    to draw widgets, such as sliders and buttons, for menus and HUDs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Slate uses declarative syntax to allow for an XML-style representation of user
    interface elements in their hierarchy in native C++. It accomplishes this by making
    heavy use of macros and operator overloading.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: That said, not everybody wants to ask their programmers to design the game's
    HUD. One of the significant advantages of using Scaleform within Unreal 3 was
    the ability to develop the visual appearance of game UIs using the Flash visual
    editor so that visual designers didn't need to learn a programming language. Programmers
    could then insert the logic and data separately. This is the same paradigm that's
    espoused by the **Windows Presentation Framework** (**WPF**), for example.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: In a similar fashion, Unreal provides **Unreal Motion Graphics** (**UMG**).
    UMG is a visual editor for Slate widgets that allows you to visually style, lay
    out, and animate user interfaces. UI widgets (or controls, if you've come from
    a Win32 background) can have their properties controlled by either Blueprint code
    (written in the Graph view of the UMG window) or from C++. This chapter primarily
    deals with displaying UI elements, creating widget hierarchies, and creating base
    `SWidget` classes that can be styled and used within UMG.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml),
    *UE4 Development Tools*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Drawing using Canvas
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Canvas** is a continuation of the simple HUD that''s implemented within Unreal
    3\. While it isn''t so commonly used within shipping games, mostly being replaced
    by Slate/UMG, it''s simple to use, especially when you want to draw text or shapes
    to the screen. Canvas drawing is still used extensively by console commands that
    are used for debugging and performance analysis, such as `stat game` and the other
    `stat` commands.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to [Chapter 4](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml), *Actors and
    Components,* if you need a refresher on using the C++ Code Wizard.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From your Visual Studio project (File | Open Visual Studio), open the `Source\<Module>`
    folder and, from there, open the `<Module>.build.cs` file (in my case, it would
    be `Source\Chapter_14\Chapter_14.build.cs`) . Uncomment/add the following line
    of code:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Create a new `GameModeBase` called `CustomHUDGameMode` using the editor class
    wizard.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a constructor to the class:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following to the constructor implementation:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At this point, you will get compile errors, because the `CustomHUD` class does
    not exist. That is what we will be creating next.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `HUD` subclass using the Add C++ Class wizard:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7830c68f-9f06-44ce-aedd-20e29710145d.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 'When asked for the name, put in `CustomHUD`, and click on the Create Class
    button:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/279fff54-150b-4019-b6c1-fc9d9f07b0a0.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: 'Inside `CustomHUD.h`, add the following function with the `override` keyword
    to the class:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, implement the function:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Compile your code and launch the editor.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the editor, open the World Settings panel from the Settings drop-down
    menu:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d725eff7-9368-40b6-a5da-84695df4ad25.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: 'In the World Settings dialog, select `CustomHUDGameMode` from the list under
    GameMode Override:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5ff91259-600d-482f-b002-6497a6fae2ee.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: 'Play and verify that your custom HUD is drawing to the screen:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a15e2c53-27d0-40fe-bd70-09c9464d1827.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the UI recipes here will be using Slate for drawing, so we need to add a
    dependency between our module and the Slate framework so that we can access the
    classes that have been declared in that module. The best place to put custom Canvas
    draw calls for a game HUD is inside a subclass of `AHUD`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: To tell the engine to use our custom subclass, though, we need to create a new
    `GameMode` and specify the type of our custom class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Within the constructor of our custom Game Mode, we assign the `UClass` for our
    new HUD type to the `HUDClass` variable. This `UClass` is passed on to each player's
    controller as they spawn in, and the controller is then responsible for the `AHUD`
    instance that it creates.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: With our custom `GameMode` loading our custom HUD, we need to actually create
    said custom HUD class. `AHUD` defines a virtual function called `DrawHUD()`, which
    is invoked in every frame to allow us to draw elements to the screen. As a result,
    we override that function and perform our drawing inside the implementation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method that''s used is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`DrawText` requires a font to draw with. The default font used by `stat` and
    other HUD drawing commands in the engine code is actually stored in the `GEngine`
    class, and can be accessed by using the `GetSmallFont` function, which returns
    an instance of the `UFont` as a pointer.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The remaining arguments that we are using are the actual text that should be
    rendered, and the offset, in pixels, at which the text should be drawn.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '`DrawText` is a function that allows you to directly pass in the data that
    is to be displayed. The general `DrawItem` function is a Visitor implementation
    that allows you to create an object that encapsulates the information about the
    object to be drawn and reuse that object on multiple draw calls.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we create an element that can be used to represent a progress
    bar. We encapsulate the required information regarding the width and height of
    our box into an `FCanvasBoxItem`, which we then pass to the `DrawItem` function
    on our Canvas.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The third item that we draw is a filled rectangle. This function uses convenience
    methods that are defined in the HUD class rather than on the Canvas itself. The
    filled rectangle is placed at the same location as our `FCanvasBox` so that it
    can represent the current value inside the progress bar.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to [Chapter 10](c73bb4ba-4b7d-4aef-a33e-732f184d261f.xhtml), *Integrating
    C++ and the Unreal Editor – Part II,* and the *Creating new console commands* recipe
    within, to learn how to create your own console commands
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Slate Widgets to the screen
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe used the `FCanvas` API to draw to the screen. However, `FCanvas`
    suffers from a number of limitations, for example, animations are difficult to
    implement, and drawing graphics on the screen involves creating textures or materials.
    `FCanvas` also doesn't implement anything in the way of widgets or window controls,
    making data entry or other forms of user input more complex than necessary. This
    recipe will show you how to begin creating HUD elements on-screen using Slate,
    which provides a number of built-in controls.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add `Slate` and `SlateCore` to your module's dependencies if you haven't done
    so already (see the *Drawing using Canvas* recipe to learn how to do this).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `PlayerController` subclass using the Add C++ Class wizard:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7c52bf2e-a859-4474-8c1d-9cd54069694e.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: 'When asked for the name of the class, type in `CustomHUDPlayerController` and
    press the Create Class button:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1ad35366-16d0-413a-bbb0-a5635ead359a.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: 'Override the `BeginPlay` virtual method within your new subclass:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following code for your overridden `BeginPlay()` virtual method inside
    the subclass'' implementation:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Create a new class based on `GameModeBase` called `SlateHUDGameMode`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a constructor inside the Game Mode:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Implement the constructor with the following code:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Within the Editor, open the World Settings menu from the toolbar by going to
    Settings | World Settings:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/826cba58-111f-40cf-8ff5-4d6c56bf5a45.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: 'Inside World Settings, override the level''s Game Mode to be our `SlateHUDGameMode`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9f73bfe4-1610-4d0c-b44b-b14e786dbbc7.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: 'Play the level. You will see your new UI displayed on the screen:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2347b898-a48c-495d-84ce-d06b195e3021.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: Button located on the game screen
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For us to reference Slate classes or functions in our code, our module must
    link with the `Slate` and `SlateCore` modules, so we add those to the module dependencies.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: We need to instantiate our UI in one of the classes that loads when the game
    runs, so for this recipe, we use our custom `PlayerController` in the `BeginPlay`
    function as the place to create our UI.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `BeginPlay` implementation, we create a new `SVerticalBox` using
    the `SNew` function. We add a slot for a widget to our box, and set that slot
    to both horizontal and vertical centering.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Inside the slot, which we access using square brackets, we create a button that
    has `Textblock` inside it. In `Textblock`, we set the `Text` property to a string
    literal value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: With the UI now created, we call `AddViewportWidgetForPlayer` to display this
    widget on the local player's screen.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: With our custom `PlayerController` ready, we now need to create a custom `GameMode`
    to specify that it should use our new `PlayerController`. With the custom `PlayerController`
    being loaded at the start of the game, when `BeginPlay` is called, our UI will
    be shown.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The UI is very small at this screen size. Refer to the following recipe for
    information on how to scale it appropriately for the resolution of the game window.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Creating screen size-aware scaling for the UI
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have followed the previous recipe, you will notice that when you use
    **Play In Editor**, the button that loads is unusually small.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is UI Scaling, a system that allows you to scale the user
    interface based on the screen size. User interface elements are represented in
    terms of pixels, usually in absolute terms (the button should be 10 pixels tall).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this is that if you use a higher-resolution panel, 10 pixels
    might be much smaller, because each pixel is smaller in size.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The UI scaling system in Unreal allows you to control a global scale modifier,
    which will scale all the controls on the screen based on the screen resolution.
    Given the previous example, you might wish to adjust the size of the button so
    that its apparent size is unchanged when you view your UI on a smaller screen.
    This recipe shows two different methods for altering the scaling rates.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a custom `PlayerController` subclass. Call it `ScalingUIPlayerController`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the class, override `BeginPlay`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following code in the implementation of that function inside of `ScalingUIPlayerController.cpp`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a new `GameModeBase` subclass called `ScalingUIGameMode` and give it
    a default constructor:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Within the default constructor, set the default player controller class to
    `ScalingUIPlayerController`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Save and compile your new classes.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the Editor, open the World Settings menu from the toolbar by going to Settings
    | World Settings.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside World Settings, override the level's Game Mode to be our `ScalingUIGameMode`.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/02f9189c-7fad-4349-8bb7-195579247691.png)'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'This should give you a user interface like the one from the previous recipe.
    Note that the UI is very tiny if you use Play In Editor:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/d136a6b5-4043-4f09-8443-541766ef6a1c.png)'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Tiny button on the game screen
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To alter the rate at which the UI scales down or up, we need to change the scaling
    curve. We can do that through two different methods.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the In-Editor method
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Launch Unreal, then open the Project Settings dialog through the Edit menu:'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4bf372f4-6819-4ee5-96f2-662d40adc52c.jpg)'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Under the Engine - User Interface section, there is a curve called the DPI
    Curve, which can be used to alter the UI scaling factor based on the short dimension
    of your screen:'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b3a198bb-bb69-47ea-a3d9-61f52351f475.png)'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Click on the second dot, or keypoint, on the graph.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change its Scale value to `1`. Then, do the same for the first dot and set
    its Scale value to `1` as well:'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/71b43d27-052b-49b2-a2f5-28c1e89ae87c.png)'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Return to the main editor and run the game again. You should notice that the
    button is larger than it was before:'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/91c6e745-0bc1-4555-9288-fe5dca318431.png)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Easier to see button on the game screen
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the Config file method
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Browse to your project directory and look inside the `Config` folder:'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e4843569-d39c-408e-a063-9829f0467739.png)'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Open `DefaultEngine.ini`, which is located in the `Config` folder of your project,
    inside your text editor of choice.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the `[/Script/Engine.UserInterfaceSettings]` section:'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Look for a key called `UIScaleCurve` in that section.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the value for that key, you'll notice a number of `(Time=x,Value=y)` pairs.
    Edit the second pair so that its `Time` value is `720.000000` and the `Value`
    is `1.000000` if it isn't already.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart the editor if you have it open.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start the Play In Editor preview to confirm that your UI now remains readable
    at the **PIE** screen''s resolution (assuming you are using a 1080p monitor so
    that the PIE window is running at 720p or thereabouts):'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/288286d3-a546-4e7b-b440-5fc65abe4c8a.jpg)'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: You can also see how the scaling works if you use a New Editor Window to preview
    your game.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To do so, click on the arrow to the right of Play on the toolbar.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select New Editor Window.
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this window, you can use the console command `r.SetRes widthxheight`
    to change the resolution (for example, `r.SetRes 200x200`), and observe the changes
    that result from doing so.
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: As usual, when we want to use a custom `PlayerController`, we need a custom
    `GameMode` to specify which `PlayerController` to use.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We create both a custom `PlayerController` and `GameMode`, and then place some
    `Slate` code in the `BeginPlay` method of `PlayerController` so that some UI elements
    are drawn.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Because the main game viewport is usually quite small within the Unreal editor,
    the UI initially shows in a scaled-down fashion. This is intended to allow for
    the game UI to take up less room on smaller resolution displays, but this can
    have the side effect of making the text very difficult to read if the window isn't
    being stretched to fit the full screen.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unreal stores the configuration data that should persist between sessions but
    not necessarily be hard coded into the executable inside config files. Config
    files use an extended version of the `.ini` file format, which has been commonly
    used with Windows software.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Config files store data using the following syntax:'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Unreal has a `UserInterfaceSettings` class, with a property called `UIScaleCurve`
    on it. That `UPROPERTY` is marked as config, so Unreal serializes the value to
    the `.ini` file.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As a result, it stores the `UIScale` data in the `DefaultEngine.ini` file, in
    the `Engine.UserInterfaceSettings` section.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The data is stored using a text format, which contains a list of key points.
    Editing the `Time`, `Value` pairs alters or adds new key points to the curve.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Project Settings dialog is a simple frontend for directly editing the `.ini`
    files yourself, and for designers, it is an intuitive way to edit the curve. However,
    having the data stored textually allows for programmers to potentially develop
    build tools that modify properties such as `UIScale` without having to recompile
    their game.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Time` refers to the input value. In this case, the input value is the narrower
    dimension of the screen (usually, the height).'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Value` is the universal scaling factor that''s applied to the UI when the
    screen''s narrow dimension is approximately the height of the value in the `Time`
    field.'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, to set the UI to remain normal-sized at a 1280 x 720 resolution, set the
    time/input factor to 720 and the scale factor to 1.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the UE4 documentation for more information regarding config
    files: [https://docs.unrealengine.com/en-US/Programming/Basics/ConfigurationFiles](https://docs.unrealengine.com/en-US/Programming/Basics/ConfigurationFiles).'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying and hiding a sheet of UMG elements in-game
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already discussed how to add a widget to the viewport, which means that
    it will be rendered on the player's screen.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, what if we want to have UI elements that are toggled based on other
    factors, such as proximity to certain Actors, or a player holding a key down,
    or if we want a UI that disappears after a specified time?
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `GameModeBase` class called `ToggleHUDGameMode`:'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ebab40ac-26b7-46a2-906b-b5eead0b1736.png)'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Add the following `UPROPERTY` and function definitions to the `ToggleHUDGameMode.h`
    file:'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Implement `BeginPlay` with the following code in the method body:'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Implement `EndPlay`:'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Compile your code and start the editor.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the Editor, open World Settings from the toolbar:'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e117fa02-d7d4-447a-a504-6350baad3827.jpg)'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Inside World Settings, override the level''s Game Mode to be our `AToggleHUDGameMode`:'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3eb58755-c6a1-4830-973d-c23df59487c3.jpg)'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Play the level and verify that the UI toggles its visibility every five seconds.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: As with most of the other recipes in this chapter, we are using a custom `GameMode`
    class to display our single-player UI on the player's viewport for convenience.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We override `BeginPlay` and `EndPlay` so that we can correctly handle the timer
    that will be toggling our UI on and off for us. To make that possible, we need
    to store a reference to the timer as a `UPROPERTY` to ensure it won't be garbage
    collected.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Within `BeginPlay`, we create a new `VerticalBox` using the `SNew` macro, and
    place a button in its first slot. Buttons have `Content`, which can be some other
    widget to host inside them, such as `SImage` or `STextBlock`.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this instance, we place an `STextBlock` into the `Content` slot. The contents
    of the text block are irrelevant, that is, as long as they are long enough for
    us to be able to see our button properly.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Having initialized our widget hierarchy, we add the root widget to the player's
    viewport so that it can be seen by them.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we set up a timer to toggle the visibility of our widget. We are using
    a timer to simplify this recipe rather than having to implement user input and
    input bindings, but the principle is the same. To do this, we get a reference
    to the game world and its associated timer manager.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the timer manager in hand, we can create a new timer. However, we need
    to actually specify the code to run when the timer expires. One simple way to
    do this is to use a `lambda` function for our toggle the hud function.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Lambdas are anonymous functions. Think of them as literal functions. To link
    a `lambda` function to the timer, we need to create a `timer` delegate.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `FTimerDelegate::CreateLambda` function is designed to convert a `lambda`
    function into a delegate, which the timer can call at the specified interval.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `lambda` needs to access the `this` pointer from its containing object,
    our `GameMode`, so that it can change properties on the widget instance that we
    have created. To give it the access it needs, we begin our `lambda` declaration
    with the `[]` operators, which enclose variables that should be captured into
    the `lambda`, and are accessible inside it. The curly braces then enclose the
    function body in the same way they would with a normal function declaration.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inside the function, we check if our widget is visible. If it is visible, then
    we hide it using `SWidget::SetVisibility`. If the widget isn't visible, then we
    turn it on using the same function call.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the rest of the call to `SetTimer`, we specify the interval (in seconds)
    to call the timer, and set the timer to loop.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One thing we need to be careful of, though, is the possibility of our object
    being destroyed between two timer invocations, potentially leading to a crash
    if a reference to our object is left dangling. To fix this, we need to remove
    the timer.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Given that we set the timer during `BeginPlay`, it makes sense to clear the
    timer during `EndPlay`. `EndPlay` will be called whenever `GameMode` either ends
    play or is destroyed, so we can safely cancel the timer during its implementation.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With `GameMode` set as the default game mode, the UI is created when the game
    begins to play, and the timer delegate executes every five seconds to switch the
    visibility of the widgets between `true` and `false`.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When you close the game, `EndPlay` clears the timer reference, avoiding any
    problems.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Attaching function calls to Slate events
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: While creating buttons is all well and good, at the moment, any UI element you
    add to the player's screen just sits there without anything happening, even if
    a user clicks on it. We don't have any event handlers attached to the Slate elements
    at the moment, so events such as mouse clicks don't actually cause anything to
    happen.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to attach functions to these events so that we can
    run custom code when they occur.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `GameModeBase` subclass called `ClickEventGameMode`:'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ee48dd37-65bb-47a8-aab4-41abb8f4e351.png)'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'From the `ClickEventGameMode.h` file, add the following functions and `private`
    members to the class:'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Within the `.cpp` file, add the implementation for `BeginPlay`:'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Also, add an implementation for `ButtonClicked()`:'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Compile your code and launch the editor.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the game mode in World Settings to be `ClickEventGameMode`.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Preview this in the editor and verify that the UI shows a button that changes
    from Click Me! to Clicked! when you use the mouse cursor to click on it:'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/72e77d50-3b49-4973-b4ac-bddae6bbe8cc.png)'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Button displays Clicked! after being clicked
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: As with most of the recipes in this chapter, we use `GameMode` to create and
    display our UI to minimize the number of classes that are extraneous to the point
    of the recipe that you need to create.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Within our new game mode, we need to retain references to the Slate Widgets
    that we create so that we can interact with them after their creation.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As a result, we create two shared pointers as member data within our `GameMode` – one
    to the overall parent or root widget of our UI, and the other to the label on
    our button, because we're going to be changing the label text at runtime later.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We override `BeginPlay`, as it is a convenient place to create our UI after
    the game has started, and we will be able to get valid references to our player
    controller.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also create a function called `ButtonClicked`. It returns `FReply`, a `struct`
    indicating if an event was handled. The function signature for `ButtonClicked`
    is determined by the signature of `FOnClicked`, a delegate that we will be using
    in a moment.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inside our implementation of `BeginPlay`, the first thing we do is call the
    implementation we are overriding to ensure that the class is initialized appropriately.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, as usual, we use our `SNew` function to create `VerticalBox`, and we add
    a slot to it, which is centered.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We create a new `Button` inside that slot, and we add a value to the `OnClicked`
    attribute that the button contains.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`OnClicked` is a delegate property. This means that the `Button` will broadcast
    the `OnClicked` delegate any time a certain event happens (as the name implies
    in this instance, when the button is clicked).'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To subscribe or listen to the delegate, and be notified of the event that it
    refers to, we need to assign a delegate instance to the property.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We do that using the standard delegate functions such as `CreateUObject`, `CreateStatic`,
    or `CreateLambda`. Any of those will work – we can bind `UObject` member functions,
    static functions, lambdas, and other functions.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Check out [Chapter 5](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml), *Handling
    Events and Delegates,* to learn more about delegates and look at the other types
    of functions that we can bind to delegates.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`CreateUObject` expects a pointer to a class instance, and a pointer to the
    member function that''s defined in that class to call. The function has to have
    a signature that can be converted into the signature of the delegate:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we can see, the `OnClicked` delegate type is `FOnClicked` – this is why the
    `ButtonClicked` function that we declared has the same signature as `FOnClicked`.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By passing in a pointer to this, and the pointer to the function to invoke,
    the engine will call that function on this specific object instance when the button
    is clicked.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After setting up the delegate, we use the `Content()` function, which returns
    a reference to the single slot that the button has for any content that it should
    contain.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We then use `SAssignNew` to create our button's label by using the `TextBlock`
    widget. `SAssignNew` is important because it allows us to use Slate's declarative
    syntax, and yet assigns variables to point to specific child widgets in the hierarchy.
    `SAssignNew`'s first argument is the variable that we want to store the widget
    in, and the second argument is the type of that widget.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With `ButtonLabel` now pointing at our button's `TextBlock`, we can set its
    `Text` attribute to a static string.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we add the widget to the player's viewport using `AddViewportWidgetForPlayer`,
    which expects, as parameters, `LocalPlayer` to add the widget to, the widget itself,
    and a depth value (higher values to the front).
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To get the `LocalPlayer` instance, we assume we are running without split screen,
    and so the first player controller will be the only one, that is, the player's
    controller. The `GetFirstLocalPlayerFromController` function is a convenience
    function that simply fetches the first player's controller and returns its local
    player object.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also need to focus the widget so that the player can click on it and display
    a cursor so that the player knows where their mouse is on the screen.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We know from the previous step that we can assume the first local player controller
    is the one we're interested in, so we can access it and change its `ShowMouseCursor`
    variable to `true`. This will cause the cursor to be rendered on screen.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SetInputMode` allows us to focus on a widget so that the player can interact
    with it among other UI-related functionality, such as locking the mouse to the
    game''s viewport. It uses an `FInputMode` object as its only parameter, which
    we can construct with the specific elements that we wish to include by using the
    `builder` pattern.'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `FInputModeUIOnly` class is an `FInputMode` subclass that specifies that
    we want all input events to be redirected to the UI layer rather than the player
    controller and other input handling.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `builder` pattern allows us to chain the method calls to customize our object
    instance before it is sent into the function as the parameter.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We chain `SetLockMouseToViewport(false)` to specify that the player's mouse
    can leave the boundary of the game screen with `SetWidgetToFocus(Widget)`, which
    specifies our top-level widget as the one that the game should direct player input
    to.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we have our actual implementation for `ButtonClicked`, which is our
    event handler. When the function is run due to our button being clicked, we change
    our button's label to indicate it has been clicked. We then need to return an
    instance of `FReply` to the caller to let the UI framework know that the event
    has been handled, and to not continue propagating the event back up the widget
    hierarchy.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`FReply::Handled()` returns `FReply` set up to indicate this to the framework.
    We could have used `FReply::Unhandled()`, but this would have told the framework
    that the click event wasn''t actually the one we were interested in, and it should
    look for other objects that might be interested in the event instead.'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using Data Binding with Unreal Motion Graphics
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've been assigning static values to the attributes of our UI widgets.
    However, what if we want to be more dynamic with widget content, or parameters
    such as border color? We can use a principle called data binding to dynamically
    link properties of our UI with variables in the broader program.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unreal uses the Attribute system to allow us to bind the value of an attribute
    to the return value from a function, for example. This means that changing those
    variables will automatically cause the UI to change in response, according to
    our wishes.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new `GameModeBase` subclass called `AttributeGameMode`.
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `AttributeGameMode.h` file to the following:'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the implementation for `BeginPlay` within the `.cpp` file:'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Also, add an implementation for `GetButtonLabel()`:'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Compile your code and launch the editor.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the game mode in World Settings to be `AAttributeGameMode`.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that, in a Play In Editor session, the value on the UI''s button changes
    as the player moves around the scene:'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2154c05b-1acb-4ebe-b7ec-beea999cb541.png)'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like almost all the other recipes in this chapter, the first thing we need
    to do is create a game mode as a convenient host for our UI. We create the UI
    in the same fashion as in the other recipes, that is, by placing `Slate` code
    inside the `BeginPlay()` method of our game mode.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The interesting feature of this recipe concerns how we set the value of our
    button''s label text:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding syntax is unusually verbose, but what it is actually doing is
    comparatively simple. We assign something to the `Text` property, which is of
    the type `FText`. We can assign `TAttribute<FText>` to this property, and the
    `TAttribute Get()` method will be called whenever the UI wants to ensure that
    the value of `Text` is up to date.
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To create `TAttribute`, we need to call the static `TAttribute<VariableType>::Create()`
    method. This function expects a delegate of some description. Depending on the
    type of delegate that's passed to `TAttribute::Create`, `TAttribute::Get()` invokes
    a different type of function to retrieve the actual value.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the code for this recipe, we invoke a member function of `UObject`. This
    means that we know we will be calling the `CreateUObject` function on some delegate
    type.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can use `CreateLambda`, `CreateStatic`, or `CreateRaw` to invoke a `lambda`,
    a `static`, or a `member` function on a raw C++ class, respectively. This will
    give us the current value for the attribute.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: But what delegate type do we want to create an instance of? Because we're templating
    the `TAttribute` class on the actual variable type that the attribute will be
    associated with, we need a delegate that is also templated on the variable type
    as its return value.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That is to say, if we have `TAttribute<FText>`, the delegate that's connected
    to it needs to return an `FText`.
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We have the following code within `TAttribute`:'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `FGetter` delegate type is declared inside the `TAttribute` class, so its
    return value can be templated on the `ObjectType` parameter of the `TAttribute`
    template. This means that `TAttribute<Typename>::FGetter` automatically defines
    a delegate with the correct return type of `Typename`. So, we need to create a
    UObject-bound delegate of type and signature for `TAttribute<FText>::FGetter`.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once we have that delegate, we can call `TAttribute::Create` on the delegate
    to link the delegate's return value to our `TextBlock` member variable `Text`.
    With our UI defined and a binding between the `Text` property, a `TAttribute<FText>`,
    and a delegate returning `FText`, we can now add the UI to the player's screen
    so that it's visible.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Every frame, the game engine checks all of the properties to see if they are
    linked to `TAttributes`. If there's a connection, then the `TAttribute``Get()`
    function is called, invoking the delegate and returning the delegate's return
    value so that Slate can store it inside the widget's corresponding member variable.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For our demonstration of this process, `GetButtonLabel` retrieves the location
    of the first player pawn in the game world. We then use `FString::Printf` to format
    the location data into a human readable string, and wrap that in an `FText` so
    that it can be stored as the `TextBlock` text value.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Controlling widget appearance with Styles
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we've been creating UI elements that use the default
    visual representation. This recipe shows you how to create a Style in C++ that
    can be used as a common look and feel across your whole project.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new class for your project by using the Add C++ Class wizard and selecting
    None as your parent class:'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/64c3708b-d1e9-480b-95c7-28fcaf1f9d69.png)'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Under the name option, use `CookbookStyle` and click on the Create Class button:'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ebb36faa-5690-4154-aae9-0569f96d67d4.png)'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Replace the code in the `CookbookStyle.h` file with the following code:'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Open the `CookbookStyle.cpp` file and use the following code for it:'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the following content below the previously created script in the `CookbookStyle.cpp` file
    to describe how to draw the screen:'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a new `GameModeBase` subclass, `StyledHUDGameMode`:'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a6078305-d562-4c27-b878-7e635d381cfd.png)'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Once Visual Studio opens, add the following code to its declaration:'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Likewise, implement `GameMode`:'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Lastly, create a 54 x 54 pixel PNG file with a border around it for our button:'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/73922731-36ea-47f4-9e56-48280866be32.png)'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Save it to the `Content` | `Slate` folder with the name `Button.png`, creating
    the folder if needed:'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/293da37b-9933-4c8f-b2e5-d749a70f8302.png)'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: You may be asked if you'd like to import the image into your project. Go ahead
    and say yes.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we need to set our game''s module to properly initialize the style
    when it is loaded. In your game module''s implementation file (`Chapter_14.h`),
    ensure it looks like this:'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, go to the `Chapter_14.cpp` file and modify the code to the following:'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Compile the code and set your game mode override to the new game mode, like
    we did in the other recipes in this chapter.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you play the game, you will see that your custom border is around the
    button, and that the text is white rather than black:'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0a88391a-3f1f-4343-be79-7a38b5271782.png)'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: For us to create styles that can be shared across multiple Slate widgets, we
    need to create an object to contain the styles and keep them in scope.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Epic provides the `FSlateStyleSet` class for this purpose. `FSlateStyleSet`
    contains a number of styles that we can access within Slate's declarative syntax
    to skin widgets.
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, it's inefficient to have multiple copies of our `StyleSet` object scattered
    through the program. We really only need one of these objects.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Because `FSlateStyleSet` itself is not a singleton, that is, an object that
    can only have one instance, we need to create a class that will manage our `StyleSet`
    object and ensure that we only have the single instance.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is the reason we have the `FCookbookStyle` class. It contains an `Initialize()`
    function, which we will call in our module's startup code. In the `Initialize()`
    function, we check if we have an instance of our `StyleSet`. If we do not have
    a valid instance, we call the private `Create()` function to instantiate one.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We then register the style with the `FSlateStyleRegistry` class.
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When our module is unloaded, we will need to reverse this registration process,
    then erase the pointer so that it doesn't dangle.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We now have an instance of our class that was created during module initialization
    by calling `Create()`. You'll notice that `Create` is wrapped by a number of macros
    that all have a similar form. These macros are defined before the function, and
    undefined after it.
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These macros make it easier for us to simplify the code that's required within
    the `Create` function by eliminating the need to specify a path and extension
    for all the image resources that our Style might want to use.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Within the `Create` function, we create a new `FSlateStyleSet` object using
    the `FSlateGameResources::New()` function. `New()` needs a name for the style,
    and the folder paths that we want to search for in this Style Set.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This allows us to declare multiple Style Sets that are pointing to different
    directories, but using the same names for the images. It also allows us to skin
    or restyle the whole UI simply by switching to a Style Set in one of the other
    base directories.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`New()` returns a shared reference object, so we retrieve the actual `FStyleSet`
    instance using the `Get()` function.'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With this reference in hand, we can create the styles we want this set to contain.
    To add styles to a set, we use the `Set()` method. Set expects the name of the
    style, and then a style object. Style objects can be customized using the `builder`
    pattern.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We first add a style called `"NormalButtonBrush"`. The name can be arbitrary.
    Because we want to use this style to change the appearance of buttons, we need
    to use `FButtonStyle` for the second parameter.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To customize the style to our requirements, we use the Slate builder syntax,
    chaining whatever method calls that we need to set properties on our style.
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the first style in this set, we just change the visual appearance of the
    button when it isn't being clicked or is in a non-default state. This means that
    we want to change the brush that's used when the button is in the normal state,
    and so the function we use is `SetNormal()`.
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the `BOX_BRUSH` macro, we tell Slate that we want to use `Button.png`,
    which is an image of 54 x 54 pixel size, and that we want to keep the 14 pixels
    in each corner unstretched for the purposes of nine-slice scaling.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For a more visual explanation of the nine-slice scaling functionality, take
    a look at `SlateBoxBrush.h` in the engine source.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the second style in our Style Set, we create a style called `"NormalButtonText"`.
    For this style, we don't want to change everything from defaults in the style;
    we just want to alter one property. As a result, we access the default text style
    and clone it using the copy constructor.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With our fresh copy of the default style, we then change the color of the text
    to white, first creating a linear color of R=1 G=1 B=1 A=1, and then convert that
    into a Slate color object.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With our Style Set configured with our two new styles, we can then return it
    to the calling function, which is `Initialize`. `Initialize` stores our Style
    Set reference and eliminates the need for us to create further instances.
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our style container class also has a `Get()` function, which is used to retrieve
    the actual `StyleSet` for use in Slate. Because `Initialize()` has already been
    called at module startup, `Get()` simply returns the `StyleSet` instance that
    was created within that function.
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Within the game module, we add the code that actually calls `Initialize` and
    `Shutdown`. This ensures that while our module is loaded, we will always have
    a valid reference to our Slate Style.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As always, we create a Game Mode as the host for our UI, and we override `BeginPlay`
    so that we can create the UI when the game starts.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The syntax for creating the UI is exactly the same as we've used in previous
    recipes – creating a `VerticalBox` using `SNew`, and then using Slate's declarative
    syntax to populate the box with other widgets.
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It is important to note the two following lines:'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding lines are part of the declarative syntax for our button, and the
    text that makes its label. When we set the style for our widgets using a `<Class>Style()`
    method, we pass in two parameters.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first parameter is our actual Style Set, which is retrieved by using `FCookbookStyle::Get()`,
    and the second is a string parameter with the name of the style that we want to
    use.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With these minor changes, we override the styling of the widgets to use our
    custom styles so that when we add the widgets to the player's viewport, they display
    our customizations.
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a custom SWidget/UWidget
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipes in this chapter so far have shown you how to create UIs using the
    existing primitive widgets.
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Sometimes, it is convenient for developers to use composition to collect a number
    of UI elements to define a button class that automatically has a `TextBlock` as
    a label rather than manually specifying the hierarchy every time they are declared,
    for example.
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Furthermore, if you are manually specifying the hierarchy in C++, rather than
    declaring a compound object consisting of subwidgets, you won't be able to instantiate
    those widgets as a group using UMG.
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to create a compound `SWidget` that contains a group
    of widgets and exposes new properties to control elements of those subwidgets.
    It will also show you how to create a `UWidget` wrapper, which will expose the
    new compound `SWidget` class to UMG so that it can be used by designers.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to add the UMG module to our module's dependencies.
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up `<YourModule>.build.cs`, which in our case is `Chapter_14.Build.cs`,
    and add UMG to the following code:'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create a new class based on the Slate Widget parent class (`SCompoundWidget`):'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1a17774f-7605-4d12-ad72-aa538589875a.png)'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: When asked for a name, call it `CustomButton`.
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once created, add the following code to its declaration:'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Implement the class with the following in the corresponding `.cpp` file:'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create a second class, this time based on `Widget`:'
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/70f5329f-c812-4ee8-9108-2c186e2130c5.png)'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Call this new class `CustomButtonWidget` and press Create Class.
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the bold code in the following snippet to the `CustomButtonWidget.h` file:'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, create the implementation for `UCustomButtonWidget`:'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Save your scripts and compile your code.
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Widget Blueprint by right-clicking on the Content Browser and
    selecting User Interface and then Widget Blueprint:'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/019ade72-7ac5-4639-84ec-59fbf045dcbd.png)'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: You can use the mouse wheel in the context menu to scroll to the User Interface
    section.
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open your new Widget Blueprint by double-clicking on it.
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the Custom Button Widget in the Widget Palette:'
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7ec28d12-c477-458d-bb1d-e22f94528e26.png)'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Drag an instance of it out into the main area.
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the instance selected, change the Label property in the Details panel:'
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5941564e-b55b-4f07-b642-a24507181855.png)'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Verify that your button has changed its label.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we will create a binding to demonstrate that we can link arbitrary blueprint
    functions to the label property on our widget, which, in turn, drives the Widget's
    textblock label.
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Bind to the right of the Label property and select Create Binding:'
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e4e52462-a9f1-4ed4-a5fd-8cbe749f1003.png)'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Within the graph that is now displayed, place a Get Game Time in Seconds node
    by right-clicking within the main area:'
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6f13155b-1c21-4fcc-9bd0-3e49c3ef08fc.png)'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Link the return value from the Get Game Time node to the Return Value pin in
    the function:'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6421b9a8-c550-46aa-a2c4-22482c2699f5.jpg)'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'A Convert Float to String node will be automatically inserted for you:'
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/508844dd-cbe0-48c4-a007-d9ecb4fbafff.jpg)'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Compile the blueprint to ensure it is working correctly.
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, open the Level Blueprints by clicking on the Blueprints button on the
    taskbar and then selecting Open Level Blueprint:'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a7e07af8-6327-4b45-9fd2-8b8ee267eba1.png)'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'To the right of the Event BeginPlay node, place a Create Widget node into the
    graph:'
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/287da0f3-30e0-48de-a7fb-7524a6bc0782.png)'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Select the Class of widget to spawn it as the new Widget Blueprint that we
    created a moment ago within the editor:'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/926ba980-6528-4778-8868-bf71d895ccb8.jpg)'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Click and drag away from the Owning Player pin on the create widget node and
    place a Get Player Controller node:'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cd0d48b2-dc8f-4b71-805c-639f0510e06e.jpg)'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Likewise, drag away from the return value of the Create Widget node and place
    an Add to Viewport node:'
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e005b240-36a4-4bde-9cb9-fea79fb1ed0e.jpg)'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Lastly, link the `BeginPlay` node to the execution pin on the create widget
    node:'
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/29583739-bbd2-4a2f-9750-d150412bd044.png)'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Preview your game and verify that the widget we've displayed onscreen is our
    new custom button, with its label bound to the number of seconds that have elapsed
    since the game started:![](img/6e798818-3319-43c4-a5c3-24c71cc70708.png)
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Button displaying the elapsed time in the level
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: To use the `UWidget` class, our module needs to include the UMG module as one
    of its dependencies, because `UWidget` is defined inside the UMG module.
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first class that we need to create, however, is our actual `SWidget` class.
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Because we want to aggregate two widgets together into a compound structure,
    we create our new widget as a `CompoundWidget` subclass. `CompoundWidget` allows
    you to encapsulate a widget hierarchy as a widget itself.
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inside the class, we use the `SLATE_BEGIN_ARGS` and `SLATE_END_ARGS` macros
    to declare an internal `struct` called `FArguments` on our new `SWidget`. Within
    `SLATE_BEGIN_ARGS` and `SLATE_END_ARGS`, the `SLATE_ATTRIBUTE` and `SLATE_EVENT`
    macros are used. `SLATE_ATTRIBUTE` creates `TAttribute` for the type we give it.
    In this class, we declare a `TAttribute` called `_Label`, which is more specifically
    a `TAttribute<FString>`.
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SLATE_EVENT` allows us to create member delegates that we can broadcast when
    something happens internally to the widget.'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In `SCustomButton`, we declare a delegate with the signature `FOnClicked`, called
    `ButtonClicked`.
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SLATE_ARGUMENT` is another macro (which wasn''t used in this recipe) that
    creates an internal variable with the type and name you provide, appending an
    underscore to the start of the variable name.'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Construct()` is the function that widgets implement to self-initialize when
    they are being instantiated. You''ll notice we also create `TAttribute` and `FOnClicked`
    instances ourselves, without the underscores. These are the actual properties
    of our object into which the arguments that we declared earlier will be copied.'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inside the implementation of `Construct`, we retrieve the arguments that were
    passed to us in the `FArgumentsstruct`, and store them inside our actual member
    variables for this instance.
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We assign `Label` and `ButtonClicked` based on what was passed in, and then
    we actually create our widget hierarchy. We use the same syntax as usual for this
    with one thing to note, namely the use of `Text_Lambda` to set the text value
    of our internal text block. We use a `lambda` function to retrieve the value of
    our `Label` `TAttribute` using `Get()`, convert it into `FText`, and store it
    as our text block's `Text` property.
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have our `SWidget` declared, we need to create a wrapper `UWidget`
    object that will expose this widget to the UMG system so that designers can use
    the widget within the **WYSIWYG** editor. This class will be called `UCustomButtonWidget`,
    and it inherits from `UWidget` rather than `SWidget`.
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `UWidget` object needs a reference to the actual `SWidget` that it owns,
    so we place a protected member in the class that will store it as a shared pointer.
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A constructor is declared, as well as a `ButtonClicked` delegate that can be
    set in Blueprint. We also mirror a `Label` property that is marked as `BlueprintReadWrite`
    so that it can be set in the UMG editor.
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Because we want to be able to bind our button's label to a delegate, we add
    the last of our member variables, which is a delegate that returns a `String`.
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `SynchronizeProperties` function applies properties that have been mirrored
    in our `UWidget` class across to the `SWidget` that we are linked with.
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`RebuildWidget` reconstructs the native widget that `UWidget` is associated
    with. It uses `SNew` to construct an instance of our `SCustomButton` widget, and
    uses the Slate declarative syntax to bind the UWidget''s `OnButtonClicked` method
    to the `ButtonClicked` delegate inside the native widget. This means that when
    the native widget is clicked, the `UWidget` will be notified by having `OnButtonClicked`
    called.'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`OnButtonClicked` re-broadcasts the clicked event from the native button via
    the UWidget''s `ButtonClicked` delegate. This means that UObjects and the UMG
    system can be notified of the button being clicked without having a reference
    to the native button widget themselves. We can bind to `UCustomButtonWidget::ButtonClicked` so
    that we''re notified about this.'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`OnButtonClicked` then returns `FReply::Handled()` to indicate that the event
    does not need to propagate further. Inside `SynchronizeProperties`, we call the
    parent method to ensure that any properties in the parent are also synchronized
    properly.'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We use the `OPTIONAL_BINDING` macro to link the `LabelDelegate` delegate in
    our `UWidget` class to `TAttribute`, and, in turn, the native button's label.
    It is important to note that the `OPTIONAL_BINDING` macro expects the delegate
    to be called `NameDelegate` based on the second parameter to the macro.
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`OPTIONAL_BINDING` allows the value to be overridden by a binding made via
    UMG, but only if the UMG binding is valid.'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`OPTIONAL_BINDING`允许通过UMG创建的绑定覆盖值，但仅当UMG绑定有效时。'
- en: This means that when `UWidget` is told to update itself, for example, because
    the user customizes a value in the Details panel within UMG, it will recreate
    the native `SWidget` if necessary, and then copy the values set in Blueprint/UMG
    via `SynchronizeProperties` so that everything continues to work as expected.
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着当`UWidget`被告知更新自身时，例如，因为用户在UMG的详情面板中自定义了一个值，它将根据需要重新创建本地的`SWidget`，然后通过`SynchronizeProperties`复制在蓝图/UMG中设置的值，以确保一切按预期继续工作。
