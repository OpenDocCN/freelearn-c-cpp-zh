- en: User Interfaces - UI and UMG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing using Canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Slate Widgets to the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating screen size-aware scaling for the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying and hiding a sheet of UMG elements in-game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching function calls to Slate events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Data Binding with Unreal Motion Graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling widget appearance with Styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom SWidget/UWidget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Displaying feedback to the player is one of the most important elements within
    game design, and this will usually involve some sort of HUD, or at least menus,
    within your game.
  prefs: []
  type: TYPE_NORMAL
- en: In previous versions of Unreal, there was simple HUD support, which allowed
    you to draw simple shapes and text to the screen. However, it was somewhat limited
    in terms of aesthetics, and so solutions such as **Scaleform** became common to
    work around these limitations. Scaleform leveraged Adobe's Flash file format to
    store vector images and UI scripts. It was not without its own cons for developers,
    though, not least the cost – it was a third-party product requiring a (sometimes,
    expensive) license.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, Epic developed Slate for the Unreal 4 editor and the in-game UI
    framework. Slate is a collection of widgets (UI elements) and a framework that
    allows for a cross-platform interface for the Editor. It is also usable in-game
    to draw widgets, such as sliders and buttons, for menus and HUDs.
  prefs: []
  type: TYPE_NORMAL
- en: Slate uses declarative syntax to allow for an XML-style representation of user
    interface elements in their hierarchy in native C++. It accomplishes this by making
    heavy use of macros and operator overloading.
  prefs: []
  type: TYPE_NORMAL
- en: That said, not everybody wants to ask their programmers to design the game's
    HUD. One of the significant advantages of using Scaleform within Unreal 3 was
    the ability to develop the visual appearance of game UIs using the Flash visual
    editor so that visual designers didn't need to learn a programming language. Programmers
    could then insert the logic and data separately. This is the same paradigm that's
    espoused by the **Windows Presentation Framework** (**WPF**), for example.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar fashion, Unreal provides **Unreal Motion Graphics** (**UMG**).
    UMG is a visual editor for Slate widgets that allows you to visually style, lay
    out, and animate user interfaces. UI widgets (or controls, if you've come from
    a Win32 background) can have their properties controlled by either Blueprint code
    (written in the Graph view of the UMG window) or from C++. This chapter primarily
    deals with displaying UI elements, creating widget hierarchies, and creating base
    `SWidget` classes that can be styled and used within UMG.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml),
    *UE4 Development Tools*.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing using Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Canvas** is a continuation of the simple HUD that''s implemented within Unreal
    3\. While it isn''t so commonly used within shipping games, mostly being replaced
    by Slate/UMG, it''s simple to use, especially when you want to draw text or shapes
    to the screen. Canvas drawing is still used extensively by console commands that
    are used for debugging and performance analysis, such as `stat game` and the other
    `stat` commands.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to [Chapter 4](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml), *Actors and
    Components,* if you need a refresher on using the C++ Code Wizard.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From your Visual Studio project (File | Open Visual Studio), open the `Source\<Module>`
    folder and, from there, open the `<Module>.build.cs` file (in my case, it would
    be `Source\Chapter_14\Chapter_14.build.cs`) . Uncomment/add the following line
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `GameModeBase` called `CustomHUDGameMode` using the editor class
    wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a constructor to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the constructor implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you will get compile errors, because the `CustomHUD` class does
    not exist. That is what we will be creating next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `HUD` subclass using the Add C++ Class wizard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7830c68f-9f06-44ce-aedd-20e29710145d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When asked for the name, put in `CustomHUD`, and click on the Create Class
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/279fff54-150b-4019-b6c1-fc9d9f07b0a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside `CustomHUD.h`, add the following function with the `override` keyword
    to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, implement the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code and launch the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the editor, open the World Settings panel from the Settings drop-down
    menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d725eff7-9368-40b6-a5da-84695df4ad25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the World Settings dialog, select `CustomHUDGameMode` from the list under
    GameMode Override:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5ff91259-600d-482f-b002-6497a6fae2ee.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Play and verify that your custom HUD is drawing to the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a15e2c53-27d0-40fe-bd70-09c9464d1827.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the UI recipes here will be using Slate for drawing, so we need to add a
    dependency between our module and the Slate framework so that we can access the
    classes that have been declared in that module. The best place to put custom Canvas
    draw calls for a game HUD is inside a subclass of `AHUD`.
  prefs: []
  type: TYPE_NORMAL
- en: To tell the engine to use our custom subclass, though, we need to create a new
    `GameMode` and specify the type of our custom class.
  prefs: []
  type: TYPE_NORMAL
- en: Within the constructor of our custom Game Mode, we assign the `UClass` for our
    new HUD type to the `HUDClass` variable. This `UClass` is passed on to each player's
    controller as they spawn in, and the controller is then responsible for the `AHUD`
    instance that it creates.
  prefs: []
  type: TYPE_NORMAL
- en: With our custom `GameMode` loading our custom HUD, we need to actually create
    said custom HUD class. `AHUD` defines a virtual function called `DrawHUD()`, which
    is invoked in every frame to allow us to draw elements to the screen. As a result,
    we override that function and perform our drawing inside the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method that''s used is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`DrawText` requires a font to draw with. The default font used by `stat` and
    other HUD drawing commands in the engine code is actually stored in the `GEngine`
    class, and can be accessed by using the `GetSmallFont` function, which returns
    an instance of the `UFont` as a pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: The remaining arguments that we are using are the actual text that should be
    rendered, and the offset, in pixels, at which the text should be drawn.
  prefs: []
  type: TYPE_NORMAL
- en: '`DrawText` is a function that allows you to directly pass in the data that
    is to be displayed. The general `DrawItem` function is a Visitor implementation
    that allows you to create an object that encapsulates the information about the
    object to be drawn and reuse that object on multiple draw calls.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we create an element that can be used to represent a progress
    bar. We encapsulate the required information regarding the width and height of
    our box into an `FCanvasBoxItem`, which we then pass to the `DrawItem` function
    on our Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: The third item that we draw is a filled rectangle. This function uses convenience
    methods that are defined in the HUD class rather than on the Canvas itself. The
    filled rectangle is placed at the same location as our `FCanvasBox` so that it
    can represent the current value inside the progress bar.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to [Chapter 10](c73bb4ba-4b7d-4aef-a33e-732f184d261f.xhtml), *Integrating
    C++ and the Unreal Editor – Part II,* and the *Creating new console commands* recipe
    within, to learn how to create your own console commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Slate Widgets to the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe used the `FCanvas` API to draw to the screen. However, `FCanvas`
    suffers from a number of limitations, for example, animations are difficult to
    implement, and drawing graphics on the screen involves creating textures or materials.
    `FCanvas` also doesn't implement anything in the way of widgets or window controls,
    making data entry or other forms of user input more complex than necessary. This
    recipe will show you how to begin creating HUD elements on-screen using Slate,
    which provides a number of built-in controls.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add `Slate` and `SlateCore` to your module's dependencies if you haven't done
    so already (see the *Drawing using Canvas* recipe to learn how to do this).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `PlayerController` subclass using the Add C++ Class wizard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7c52bf2e-a859-4474-8c1d-9cd54069694e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When asked for the name of the class, type in `CustomHUDPlayerController` and
    press the Create Class button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1ad35366-16d0-413a-bbb0-a5635ead359a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Override the `BeginPlay` virtual method within your new subclass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code for your overridden `BeginPlay()` virtual method inside
    the subclass'' implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Create a new class based on `GameModeBase` called `SlateHUDGameMode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a constructor inside the Game Mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the Editor, open the World Settings menu from the toolbar by going to
    Settings | World Settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/826cba58-111f-40cf-8ff5-4d6c56bf5a45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside World Settings, override the level''s Game Mode to be our `SlateHUDGameMode`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9f73bfe4-1610-4d0c-b44b-b14e786dbbc7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Play the level. You will see your new UI displayed on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2347b898-a48c-495d-84ce-d06b195e3021.png)'
  prefs: []
  type: TYPE_IMG
- en: Button located on the game screen
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For us to reference Slate classes or functions in our code, our module must
    link with the `Slate` and `SlateCore` modules, so we add those to the module dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: We need to instantiate our UI in one of the classes that loads when the game
    runs, so for this recipe, we use our custom `PlayerController` in the `BeginPlay`
    function as the place to create our UI.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `BeginPlay` implementation, we create a new `SVerticalBox` using
    the `SNew` function. We add a slot for a widget to our box, and set that slot
    to both horizontal and vertical centering.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the slot, which we access using square brackets, we create a button that
    has `Textblock` inside it. In `Textblock`, we set the `Text` property to a string
    literal value.
  prefs: []
  type: TYPE_NORMAL
- en: With the UI now created, we call `AddViewportWidgetForPlayer` to display this
    widget on the local player's screen.
  prefs: []
  type: TYPE_NORMAL
- en: With our custom `PlayerController` ready, we now need to create a custom `GameMode`
    to specify that it should use our new `PlayerController`. With the custom `PlayerController`
    being loaded at the start of the game, when `BeginPlay` is called, our UI will
    be shown.
  prefs: []
  type: TYPE_NORMAL
- en: The UI is very small at this screen size. Refer to the following recipe for
    information on how to scale it appropriately for the resolution of the game window.
  prefs: []
  type: TYPE_NORMAL
- en: Creating screen size-aware scaling for the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have followed the previous recipe, you will notice that when you use
    **Play In Editor**, the button that loads is unusually small.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is UI Scaling, a system that allows you to scale the user
    interface based on the screen size. User interface elements are represented in
    terms of pixels, usually in absolute terms (the button should be 10 pixels tall).
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this is that if you use a higher-resolution panel, 10 pixels
    might be much smaller, because each pixel is smaller in size.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The UI scaling system in Unreal allows you to control a global scale modifier,
    which will scale all the controls on the screen based on the screen resolution.
    Given the previous example, you might wish to adjust the size of the button so
    that its apparent size is unchanged when you view your UI on a smaller screen.
    This recipe shows two different methods for altering the scaling rates.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a custom `PlayerController` subclass. Call it `ScalingUIPlayerController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the class, override `BeginPlay`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code in the implementation of that function inside of `ScalingUIPlayerController.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `GameModeBase` subclass called `ScalingUIGameMode` and give it
    a default constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the default constructor, set the default player controller class to
    `ScalingUIPlayerController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Save and compile your new classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the Editor, open the World Settings menu from the toolbar by going to Settings
    | World Settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside World Settings, override the level's Game Mode to be our `ScalingUIGameMode`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/02f9189c-7fad-4349-8bb7-195579247691.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'This should give you a user interface like the one from the previous recipe.
    Note that the UI is very tiny if you use Play In Editor:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/d136a6b5-4043-4f09-8443-541766ef6a1c.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Tiny button on the game screen
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To alter the rate at which the UI scales down or up, we need to change the scaling
    curve. We can do that through two different methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the In-Editor method
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Launch Unreal, then open the Project Settings dialog through the Edit menu:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4bf372f4-6819-4ee5-96f2-662d40adc52c.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Under the Engine - User Interface section, there is a curve called the DPI
    Curve, which can be used to alter the UI scaling factor based on the short dimension
    of your screen:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b3a198bb-bb69-47ea-a3d9-61f52351f475.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Click on the second dot, or keypoint, on the graph.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change its Scale value to `1`. Then, do the same for the first dot and set
    its Scale value to `1` as well:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/71b43d27-052b-49b2-a2f5-28c1e89ae87c.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Return to the main editor and run the game again. You should notice that the
    button is larger than it was before:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/91c6e745-0bc1-4555-9288-fe5dca318431.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Easier to see button on the game screen
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the Config file method
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Browse to your project directory and look inside the `Config` folder:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e4843569-d39c-408e-a063-9829f0467739.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Open `DefaultEngine.ini`, which is located in the `Config` folder of your project,
    inside your text editor of choice.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the `[/Script/Engine.UserInterfaceSettings]` section:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Look for a key called `UIScaleCurve` in that section.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the value for that key, you'll notice a number of `(Time=x,Value=y)` pairs.
    Edit the second pair so that its `Time` value is `720.000000` and the `Value`
    is `1.000000` if it isn't already.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart the editor if you have it open.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start the Play In Editor preview to confirm that your UI now remains readable
    at the **PIE** screen''s resolution (assuming you are using a 1080p monitor so
    that the PIE window is running at 720p or thereabouts):'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/288286d3-a546-4e7b-b440-5fc65abe4c8a.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: You can also see how the scaling works if you use a New Editor Window to preview
    your game.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To do so, click on the arrow to the right of Play on the toolbar.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select New Editor Window.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this window, you can use the console command `r.SetRes widthxheight`
    to change the resolution (for example, `r.SetRes 200x200`), and observe the changes
    that result from doing so.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: As usual, when we want to use a custom `PlayerController`, we need a custom
    `GameMode` to specify which `PlayerController` to use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We create both a custom `PlayerController` and `GameMode`, and then place some
    `Slate` code in the `BeginPlay` method of `PlayerController` so that some UI elements
    are drawn.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Because the main game viewport is usually quite small within the Unreal editor,
    the UI initially shows in a scaled-down fashion. This is intended to allow for
    the game UI to take up less room on smaller resolution displays, but this can
    have the side effect of making the text very difficult to read if the window isn't
    being stretched to fit the full screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unreal stores the configuration data that should persist between sessions but
    not necessarily be hard coded into the executable inside config files. Config
    files use an extended version of the `.ini` file format, which has been commonly
    used with Windows software.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Config files store data using the following syntax:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unreal has a `UserInterfaceSettings` class, with a property called `UIScaleCurve`
    on it. That `UPROPERTY` is marked as config, so Unreal serializes the value to
    the `.ini` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As a result, it stores the `UIScale` data in the `DefaultEngine.ini` file, in
    the `Engine.UserInterfaceSettings` section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The data is stored using a text format, which contains a list of key points.
    Editing the `Time`, `Value` pairs alters or adds new key points to the curve.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Project Settings dialog is a simple frontend for directly editing the `.ini`
    files yourself, and for designers, it is an intuitive way to edit the curve. However,
    having the data stored textually allows for programmers to potentially develop
    build tools that modify properties such as `UIScale` without having to recompile
    their game.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Time` refers to the input value. In this case, the input value is the narrower
    dimension of the screen (usually, the height).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Value` is the universal scaling factor that''s applied to the UI when the
    screen''s narrow dimension is approximately the height of the value in the `Time`
    field.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, to set the UI to remain normal-sized at a 1280 x 720 resolution, set the
    time/input factor to 720 and the scale factor to 1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the UE4 documentation for more information regarding config
    files: [https://docs.unrealengine.com/en-US/Programming/Basics/ConfigurationFiles](https://docs.unrealengine.com/en-US/Programming/Basics/ConfigurationFiles).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying and hiding a sheet of UMG elements in-game
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already discussed how to add a widget to the viewport, which means that
    it will be rendered on the player's screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, what if we want to have UI elements that are toggled based on other
    factors, such as proximity to certain Actors, or a player holding a key down,
    or if we want a UI that disappears after a specified time?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `GameModeBase` class called `ToggleHUDGameMode`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ebab40ac-26b7-46a2-906b-b5eead0b1736.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Add the following `UPROPERTY` and function definitions to the `ToggleHUDGameMode.h`
    file:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement `BeginPlay` with the following code in the method body:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement `EndPlay`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile your code and start the editor.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the Editor, open World Settings from the toolbar:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e117fa02-d7d4-447a-a504-6350baad3827.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Inside World Settings, override the level''s Game Mode to be our `AToggleHUDGameMode`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3eb58755-c6a1-4830-973d-c23df59487c3.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Play the level and verify that the UI toggles its visibility every five seconds.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: As with most of the other recipes in this chapter, we are using a custom `GameMode`
    class to display our single-player UI on the player's viewport for convenience.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We override `BeginPlay` and `EndPlay` so that we can correctly handle the timer
    that will be toggling our UI on and off for us. To make that possible, we need
    to store a reference to the timer as a `UPROPERTY` to ensure it won't be garbage
    collected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Within `BeginPlay`, we create a new `VerticalBox` using the `SNew` macro, and
    place a button in its first slot. Buttons have `Content`, which can be some other
    widget to host inside them, such as `SImage` or `STextBlock`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this instance, we place an `STextBlock` into the `Content` slot. The contents
    of the text block are irrelevant, that is, as long as they are long enough for
    us to be able to see our button properly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Having initialized our widget hierarchy, we add the root widget to the player's
    viewport so that it can be seen by them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we set up a timer to toggle the visibility of our widget. We are using
    a timer to simplify this recipe rather than having to implement user input and
    input bindings, but the principle is the same. To do this, we get a reference
    to the game world and its associated timer manager.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the timer manager in hand, we can create a new timer. However, we need
    to actually specify the code to run when the timer expires. One simple way to
    do this is to use a `lambda` function for our toggle the hud function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Lambdas are anonymous functions. Think of them as literal functions. To link
    a `lambda` function to the timer, we need to create a `timer` delegate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `FTimerDelegate::CreateLambda` function is designed to convert a `lambda`
    function into a delegate, which the timer can call at the specified interval.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `lambda` needs to access the `this` pointer from its containing object,
    our `GameMode`, so that it can change properties on the widget instance that we
    have created. To give it the access it needs, we begin our `lambda` declaration
    with the `[]` operators, which enclose variables that should be captured into
    the `lambda`, and are accessible inside it. The curly braces then enclose the
    function body in the same way they would with a normal function declaration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inside the function, we check if our widget is visible. If it is visible, then
    we hide it using `SWidget::SetVisibility`. If the widget isn't visible, then we
    turn it on using the same function call.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the rest of the call to `SetTimer`, we specify the interval (in seconds)
    to call the timer, and set the timer to loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One thing we need to be careful of, though, is the possibility of our object
    being destroyed between two timer invocations, potentially leading to a crash
    if a reference to our object is left dangling. To fix this, we need to remove
    the timer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Given that we set the timer during `BeginPlay`, it makes sense to clear the
    timer during `EndPlay`. `EndPlay` will be called whenever `GameMode` either ends
    play or is destroyed, so we can safely cancel the timer during its implementation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With `GameMode` set as the default game mode, the UI is created when the game
    begins to play, and the timer delegate executes every five seconds to switch the
    visibility of the widgets between `true` and `false`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When you close the game, `EndPlay` clears the timer reference, avoiding any
    problems.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Attaching function calls to Slate events
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: While creating buttons is all well and good, at the moment, any UI element you
    add to the player's screen just sits there without anything happening, even if
    a user clicks on it. We don't have any event handlers attached to the Slate elements
    at the moment, so events such as mouse clicks don't actually cause anything to
    happen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to attach functions to these events so that we can
    run custom code when they occur.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `GameModeBase` subclass called `ClickEventGameMode`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ee48dd37-65bb-47a8-aab4-41abb8f4e351.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'From the `ClickEventGameMode.h` file, add the following functions and `private`
    members to the class:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the `.cpp` file, add the implementation for `BeginPlay`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, add an implementation for `ButtonClicked()`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile your code and launch the editor.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the game mode in World Settings to be `ClickEventGameMode`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Preview this in the editor and verify that the UI shows a button that changes
    from Click Me! to Clicked! when you use the mouse cursor to click on it:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/72e77d50-3b49-4973-b4ac-bddae6bbe8cc.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Button displays Clicked! after being clicked
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: As with most of the recipes in this chapter, we use `GameMode` to create and
    display our UI to minimize the number of classes that are extraneous to the point
    of the recipe that you need to create.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Within our new game mode, we need to retain references to the Slate Widgets
    that we create so that we can interact with them after their creation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As a result, we create two shared pointers as member data within our `GameMode` – one
    to the overall parent or root widget of our UI, and the other to the label on
    our button, because we're going to be changing the label text at runtime later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We override `BeginPlay`, as it is a convenient place to create our UI after
    the game has started, and we will be able to get valid references to our player
    controller.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also create a function called `ButtonClicked`. It returns `FReply`, a `struct`
    indicating if an event was handled. The function signature for `ButtonClicked`
    is determined by the signature of `FOnClicked`, a delegate that we will be using
    in a moment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inside our implementation of `BeginPlay`, the first thing we do is call the
    implementation we are overriding to ensure that the class is initialized appropriately.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, as usual, we use our `SNew` function to create `VerticalBox`, and we add
    a slot to it, which is centered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We create a new `Button` inside that slot, and we add a value to the `OnClicked`
    attribute that the button contains.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`OnClicked` is a delegate property. This means that the `Button` will broadcast
    the `OnClicked` delegate any time a certain event happens (as the name implies
    in this instance, when the button is clicked).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To subscribe or listen to the delegate, and be notified of the event that it
    refers to, we need to assign a delegate instance to the property.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We do that using the standard delegate functions such as `CreateUObject`, `CreateStatic`,
    or `CreateLambda`. Any of those will work – we can bind `UObject` member functions,
    static functions, lambdas, and other functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Check out [Chapter 5](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml), *Handling
    Events and Delegates,* to learn more about delegates and look at the other types
    of functions that we can bind to delegates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`CreateUObject` expects a pointer to a class instance, and a pointer to the
    member function that''s defined in that class to call. The function has to have
    a signature that can be converted into the signature of the delegate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see, the `OnClicked` delegate type is `FOnClicked` – this is why the
    `ButtonClicked` function that we declared has the same signature as `FOnClicked`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By passing in a pointer to this, and the pointer to the function to invoke,
    the engine will call that function on this specific object instance when the button
    is clicked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After setting up the delegate, we use the `Content()` function, which returns
    a reference to the single slot that the button has for any content that it should
    contain.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We then use `SAssignNew` to create our button's label by using the `TextBlock`
    widget. `SAssignNew` is important because it allows us to use Slate's declarative
    syntax, and yet assigns variables to point to specific child widgets in the hierarchy.
    `SAssignNew`'s first argument is the variable that we want to store the widget
    in, and the second argument is the type of that widget.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With `ButtonLabel` now pointing at our button's `TextBlock`, we can set its
    `Text` attribute to a static string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we add the widget to the player's viewport using `AddViewportWidgetForPlayer`,
    which expects, as parameters, `LocalPlayer` to add the widget to, the widget itself,
    and a depth value (higher values to the front).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To get the `LocalPlayer` instance, we assume we are running without split screen,
    and so the first player controller will be the only one, that is, the player's
    controller. The `GetFirstLocalPlayerFromController` function is a convenience
    function that simply fetches the first player's controller and returns its local
    player object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also need to focus the widget so that the player can click on it and display
    a cursor so that the player knows where their mouse is on the screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We know from the previous step that we can assume the first local player controller
    is the one we're interested in, so we can access it and change its `ShowMouseCursor`
    variable to `true`. This will cause the cursor to be rendered on screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SetInputMode` allows us to focus on a widget so that the player can interact
    with it among other UI-related functionality, such as locking the mouse to the
    game''s viewport. It uses an `FInputMode` object as its only parameter, which
    we can construct with the specific elements that we wish to include by using the
    `builder` pattern.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `FInputModeUIOnly` class is an `FInputMode` subclass that specifies that
    we want all input events to be redirected to the UI layer rather than the player
    controller and other input handling.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `builder` pattern allows us to chain the method calls to customize our object
    instance before it is sent into the function as the parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We chain `SetLockMouseToViewport(false)` to specify that the player's mouse
    can leave the boundary of the game screen with `SetWidgetToFocus(Widget)`, which
    specifies our top-level widget as the one that the game should direct player input
    to.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we have our actual implementation for `ButtonClicked`, which is our
    event handler. When the function is run due to our button being clicked, we change
    our button's label to indicate it has been clicked. We then need to return an
    instance of `FReply` to the caller to let the UI framework know that the event
    has been handled, and to not continue propagating the event back up the widget
    hierarchy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`FReply::Handled()` returns `FReply` set up to indicate this to the framework.
    We could have used `FReply::Unhandled()`, but this would have told the framework
    that the click event wasn''t actually the one we were interested in, and it should
    look for other objects that might be interested in the event instead.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using Data Binding with Unreal Motion Graphics
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've been assigning static values to the attributes of our UI widgets.
    However, what if we want to be more dynamic with widget content, or parameters
    such as border color? We can use a principle called data binding to dynamically
    link properties of our UI with variables in the broader program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unreal uses the Attribute system to allow us to bind the value of an attribute
    to the return value from a function, for example. This means that changing those
    variables will automatically cause the UI to change in response, according to
    our wishes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new `GameModeBase` subclass called `AttributeGameMode`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `AttributeGameMode.h` file to the following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the implementation for `BeginPlay` within the `.cpp` file:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, add an implementation for `GetButtonLabel()`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile your code and launch the editor.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the game mode in World Settings to be `AAttributeGameMode`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that, in a Play In Editor session, the value on the UI''s button changes
    as the player moves around the scene:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2154c05b-1acb-4ebe-b7ec-beea999cb541.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like almost all the other recipes in this chapter, the first thing we need
    to do is create a game mode as a convenient host for our UI. We create the UI
    in the same fashion as in the other recipes, that is, by placing `Slate` code
    inside the `BeginPlay()` method of our game mode.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The interesting feature of this recipe concerns how we set the value of our
    button''s label text:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding syntax is unusually verbose, but what it is actually doing is
    comparatively simple. We assign something to the `Text` property, which is of
    the type `FText`. We can assign `TAttribute<FText>` to this property, and the
    `TAttribute Get()` method will be called whenever the UI wants to ensure that
    the value of `Text` is up to date.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To create `TAttribute`, we need to call the static `TAttribute<VariableType>::Create()`
    method. This function expects a delegate of some description. Depending on the
    type of delegate that's passed to `TAttribute::Create`, `TAttribute::Get()` invokes
    a different type of function to retrieve the actual value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the code for this recipe, we invoke a member function of `UObject`. This
    means that we know we will be calling the `CreateUObject` function on some delegate
    type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can use `CreateLambda`, `CreateStatic`, or `CreateRaw` to invoke a `lambda`,
    a `static`, or a `member` function on a raw C++ class, respectively. This will
    give us the current value for the attribute.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: But what delegate type do we want to create an instance of? Because we're templating
    the `TAttribute` class on the actual variable type that the attribute will be
    associated with, we need a delegate that is also templated on the variable type
    as its return value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That is to say, if we have `TAttribute<FText>`, the delegate that's connected
    to it needs to return an `FText`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We have the following code within `TAttribute`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `FGetter` delegate type is declared inside the `TAttribute` class, so its
    return value can be templated on the `ObjectType` parameter of the `TAttribute`
    template. This means that `TAttribute<Typename>::FGetter` automatically defines
    a delegate with the correct return type of `Typename`. So, we need to create a
    UObject-bound delegate of type and signature for `TAttribute<FText>::FGetter`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once we have that delegate, we can call `TAttribute::Create` on the delegate
    to link the delegate's return value to our `TextBlock` member variable `Text`.
    With our UI defined and a binding between the `Text` property, a `TAttribute<FText>`,
    and a delegate returning `FText`, we can now add the UI to the player's screen
    so that it's visible.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Every frame, the game engine checks all of the properties to see if they are
    linked to `TAttributes`. If there's a connection, then the `TAttribute``Get()`
    function is called, invoking the delegate and returning the delegate's return
    value so that Slate can store it inside the widget's corresponding member variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For our demonstration of this process, `GetButtonLabel` retrieves the location
    of the first player pawn in the game world. We then use `FString::Printf` to format
    the location data into a human readable string, and wrap that in an `FText` so
    that it can be stored as the `TextBlock` text value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Controlling widget appearance with Styles
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we've been creating UI elements that use the default
    visual representation. This recipe shows you how to create a Style in C++ that
    can be used as a common look and feel across your whole project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new class for your project by using the Add C++ Class wizard and selecting
    None as your parent class:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/64c3708b-d1e9-480b-95c7-28fcaf1f9d69.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Under the name option, use `CookbookStyle` and click on the Create Class button:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ebb36faa-5690-4154-aae9-0569f96d67d4.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Replace the code in the `CookbookStyle.h` file with the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `CookbookStyle.cpp` file and use the following code for it:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following content below the previously created script in the `CookbookStyle.cpp` file
    to describe how to draw the screen:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `GameModeBase` subclass, `StyledHUDGameMode`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a6078305-d562-4c27-b878-7e635d381cfd.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Once Visual Studio opens, add the following code to its declaration:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Likewise, implement `GameMode`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, create a 54 x 54 pixel PNG file with a border around it for our button:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/73922731-36ea-47f4-9e56-48280866be32.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Save it to the `Content` | `Slate` folder with the name `Button.png`, creating
    the folder if needed:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/293da37b-9933-4c8f-b2e5-d749a70f8302.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: You may be asked if you'd like to import the image into your project. Go ahead
    and say yes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we need to set our game''s module to properly initialize the style
    when it is loaded. In your game module''s implementation file (`Chapter_14.h`),
    ensure it looks like this:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, go to the `Chapter_14.cpp` file and modify the code to the following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile the code and set your game mode override to the new game mode, like
    we did in the other recipes in this chapter.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you play the game, you will see that your custom border is around the
    button, and that the text is white rather than black:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0a88391a-3f1f-4343-be79-7a38b5271782.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: For us to create styles that can be shared across multiple Slate widgets, we
    need to create an object to contain the styles and keep them in scope.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Epic provides the `FSlateStyleSet` class for this purpose. `FSlateStyleSet`
    contains a number of styles that we can access within Slate's declarative syntax
    to skin widgets.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, it's inefficient to have multiple copies of our `StyleSet` object scattered
    through the program. We really only need one of these objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Because `FSlateStyleSet` itself is not a singleton, that is, an object that
    can only have one instance, we need to create a class that will manage our `StyleSet`
    object and ensure that we only have the single instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is the reason we have the `FCookbookStyle` class. It contains an `Initialize()`
    function, which we will call in our module's startup code. In the `Initialize()`
    function, we check if we have an instance of our `StyleSet`. If we do not have
    a valid instance, we call the private `Create()` function to instantiate one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We then register the style with the `FSlateStyleRegistry` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When our module is unloaded, we will need to reverse this registration process,
    then erase the pointer so that it doesn't dangle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We now have an instance of our class that was created during module initialization
    by calling `Create()`. You'll notice that `Create` is wrapped by a number of macros
    that all have a similar form. These macros are defined before the function, and
    undefined after it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These macros make it easier for us to simplify the code that's required within
    the `Create` function by eliminating the need to specify a path and extension
    for all the image resources that our Style might want to use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Within the `Create` function, we create a new `FSlateStyleSet` object using
    the `FSlateGameResources::New()` function. `New()` needs a name for the style,
    and the folder paths that we want to search for in this Style Set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This allows us to declare multiple Style Sets that are pointing to different
    directories, but using the same names for the images. It also allows us to skin
    or restyle the whole UI simply by switching to a Style Set in one of the other
    base directories.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`New()` returns a shared reference object, so we retrieve the actual `FStyleSet`
    instance using the `Get()` function.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With this reference in hand, we can create the styles we want this set to contain.
    To add styles to a set, we use the `Set()` method. Set expects the name of the
    style, and then a style object. Style objects can be customized using the `builder`
    pattern.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We first add a style called `"NormalButtonBrush"`. The name can be arbitrary.
    Because we want to use this style to change the appearance of buttons, we need
    to use `FButtonStyle` for the second parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To customize the style to our requirements, we use the Slate builder syntax,
    chaining whatever method calls that we need to set properties on our style.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the first style in this set, we just change the visual appearance of the
    button when it isn't being clicked or is in a non-default state. This means that
    we want to change the brush that's used when the button is in the normal state,
    and so the function we use is `SetNormal()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the `BOX_BRUSH` macro, we tell Slate that we want to use `Button.png`,
    which is an image of 54 x 54 pixel size, and that we want to keep the 14 pixels
    in each corner unstretched for the purposes of nine-slice scaling.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For a more visual explanation of the nine-slice scaling functionality, take
    a look at `SlateBoxBrush.h` in the engine source.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the second style in our Style Set, we create a style called `"NormalButtonText"`.
    For this style, we don't want to change everything from defaults in the style;
    we just want to alter one property. As a result, we access the default text style
    and clone it using the copy constructor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With our fresh copy of the default style, we then change the color of the text
    to white, first creating a linear color of R=1 G=1 B=1 A=1, and then convert that
    into a Slate color object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With our Style Set configured with our two new styles, we can then return it
    to the calling function, which is `Initialize`. `Initialize` stores our Style
    Set reference and eliminates the need for us to create further instances.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our style container class also has a `Get()` function, which is used to retrieve
    the actual `StyleSet` for use in Slate. Because `Initialize()` has already been
    called at module startup, `Get()` simply returns the `StyleSet` instance that
    was created within that function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Within the game module, we add the code that actually calls `Initialize` and
    `Shutdown`. This ensures that while our module is loaded, we will always have
    a valid reference to our Slate Style.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As always, we create a Game Mode as the host for our UI, and we override `BeginPlay`
    so that we can create the UI when the game starts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The syntax for creating the UI is exactly the same as we've used in previous
    recipes – creating a `VerticalBox` using `SNew`, and then using Slate's declarative
    syntax to populate the box with other widgets.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It is important to note the two following lines:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding lines are part of the declarative syntax for our button, and the
    text that makes its label. When we set the style for our widgets using a `<Class>Style()`
    method, we pass in two parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first parameter is our actual Style Set, which is retrieved by using `FCookbookStyle::Get()`,
    and the second is a string parameter with the name of the style that we want to
    use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With these minor changes, we override the styling of the widgets to use our
    custom styles so that when we add the widgets to the player's viewport, they display
    our customizations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a custom SWidget/UWidget
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipes in this chapter so far have shown you how to create UIs using the
    existing primitive widgets.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Sometimes, it is convenient for developers to use composition to collect a number
    of UI elements to define a button class that automatically has a `TextBlock` as
    a label rather than manually specifying the hierarchy every time they are declared,
    for example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Furthermore, if you are manually specifying the hierarchy in C++, rather than
    declaring a compound object consisting of subwidgets, you won't be able to instantiate
    those widgets as a group using UMG.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to create a compound `SWidget` that contains a group
    of widgets and exposes new properties to control elements of those subwidgets.
    It will also show you how to create a `UWidget` wrapper, which will expose the
    new compound `SWidget` class to UMG so that it can be used by designers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to add the UMG module to our module's dependencies.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up `<YourModule>.build.cs`, which in our case is `Chapter_14.Build.cs`,
    and add UMG to the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new class based on the Slate Widget parent class (`SCompoundWidget`):'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1a17774f-7605-4d12-ad72-aa538589875a.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: When asked for a name, call it `CustomButton`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once created, add the following code to its declaration:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the class with the following in the corresponding `.cpp` file:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a second class, this time based on `Widget`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/70f5329f-c812-4ee8-9108-2c186e2130c5.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Call this new class `CustomButtonWidget` and press Create Class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the bold code in the following snippet to the `CustomButtonWidget.h` file:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create the implementation for `UCustomButtonWidget`:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your scripts and compile your code.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Widget Blueprint by right-clicking on the Content Browser and
    selecting User Interface and then Widget Blueprint:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/019ade72-7ac5-4639-84ec-59fbf045dcbd.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: You can use the mouse wheel in the context menu to scroll to the User Interface
    section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open your new Widget Blueprint by double-clicking on it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the Custom Button Widget in the Widget Palette:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7ec28d12-c477-458d-bb1d-e22f94528e26.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Drag an instance of it out into the main area.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the instance selected, change the Label property in the Details panel:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5941564e-b55b-4f07-b642-a24507181855.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Verify that your button has changed its label.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we will create a binding to demonstrate that we can link arbitrary blueprint
    functions to the label property on our widget, which, in turn, drives the Widget's
    textblock label.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Bind to the right of the Label property and select Create Binding:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e4e52462-a9f1-4ed4-a5fd-8cbe749f1003.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Within the graph that is now displayed, place a Get Game Time in Seconds node
    by right-clicking within the main area:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6f13155b-1c21-4fcc-9bd0-3e49c3ef08fc.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Link the return value from the Get Game Time node to the Return Value pin in
    the function:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6421b9a8-c550-46aa-a2c4-22482c2699f5.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'A Convert Float to String node will be automatically inserted for you:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/508844dd-cbe0-48c4-a007-d9ecb4fbafff.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Compile the blueprint to ensure it is working correctly.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, open the Level Blueprints by clicking on the Blueprints button on the
    taskbar and then selecting Open Level Blueprint:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a7e07af8-6327-4b45-9fd2-8b8ee267eba1.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'To the right of the Event BeginPlay node, place a Create Widget node into the
    graph:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/287da0f3-30e0-48de-a7fb-7524a6bc0782.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Select the Class of widget to spawn it as the new Widget Blueprint that we
    created a moment ago within the editor:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/926ba980-6528-4778-8868-bf71d895ccb8.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Click and drag away from the Owning Player pin on the create widget node and
    place a Get Player Controller node:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cd0d48b2-dc8f-4b71-805c-639f0510e06e.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Likewise, drag away from the return value of the Create Widget node and place
    an Add to Viewport node:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e005b240-36a4-4bde-9cb9-fea79fb1ed0e.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Lastly, link the `BeginPlay` node to the execution pin on the create widget
    node:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/29583739-bbd2-4a2f-9750-d150412bd044.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Preview your game and verify that the widget we've displayed onscreen is our
    new custom button, with its label bound to the number of seconds that have elapsed
    since the game started:![](img/6e798818-3319-43c4-a5c3-24c71cc70708.png)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Button displaying the elapsed time in the level
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: To use the `UWidget` class, our module needs to include the UMG module as one
    of its dependencies, because `UWidget` is defined inside the UMG module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first class that we need to create, however, is our actual `SWidget` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Because we want to aggregate two widgets together into a compound structure,
    we create our new widget as a `CompoundWidget` subclass. `CompoundWidget` allows
    you to encapsulate a widget hierarchy as a widget itself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inside the class, we use the `SLATE_BEGIN_ARGS` and `SLATE_END_ARGS` macros
    to declare an internal `struct` called `FArguments` on our new `SWidget`. Within
    `SLATE_BEGIN_ARGS` and `SLATE_END_ARGS`, the `SLATE_ATTRIBUTE` and `SLATE_EVENT`
    macros are used. `SLATE_ATTRIBUTE` creates `TAttribute` for the type we give it.
    In this class, we declare a `TAttribute` called `_Label`, which is more specifically
    a `TAttribute<FString>`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SLATE_EVENT` allows us to create member delegates that we can broadcast when
    something happens internally to the widget.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In `SCustomButton`, we declare a delegate with the signature `FOnClicked`, called
    `ButtonClicked`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SLATE_ARGUMENT` is another macro (which wasn''t used in this recipe) that
    creates an internal variable with the type and name you provide, appending an
    underscore to the start of the variable name.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Construct()` is the function that widgets implement to self-initialize when
    they are being instantiated. You''ll notice we also create `TAttribute` and `FOnClicked`
    instances ourselves, without the underscores. These are the actual properties
    of our object into which the arguments that we declared earlier will be copied.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inside the implementation of `Construct`, we retrieve the arguments that were
    passed to us in the `FArgumentsstruct`, and store them inside our actual member
    variables for this instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We assign `Label` and `ButtonClicked` based on what was passed in, and then
    we actually create our widget hierarchy. We use the same syntax as usual for this
    with one thing to note, namely the use of `Text_Lambda` to set the text value
    of our internal text block. We use a `lambda` function to retrieve the value of
    our `Label` `TAttribute` using `Get()`, convert it into `FText`, and store it
    as our text block's `Text` property.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have our `SWidget` declared, we need to create a wrapper `UWidget`
    object that will expose this widget to the UMG system so that designers can use
    the widget within the **WYSIWYG** editor. This class will be called `UCustomButtonWidget`,
    and it inherits from `UWidget` rather than `SWidget`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `UWidget` object needs a reference to the actual `SWidget` that it owns,
    so we place a protected member in the class that will store it as a shared pointer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A constructor is declared, as well as a `ButtonClicked` delegate that can be
    set in Blueprint. We also mirror a `Label` property that is marked as `BlueprintReadWrite`
    so that it can be set in the UMG editor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Because we want to be able to bind our button's label to a delegate, we add
    the last of our member variables, which is a delegate that returns a `String`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `SynchronizeProperties` function applies properties that have been mirrored
    in our `UWidget` class across to the `SWidget` that we are linked with.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`RebuildWidget` reconstructs the native widget that `UWidget` is associated
    with. It uses `SNew` to construct an instance of our `SCustomButton` widget, and
    uses the Slate declarative syntax to bind the UWidget''s `OnButtonClicked` method
    to the `ButtonClicked` delegate inside the native widget. This means that when
    the native widget is clicked, the `UWidget` will be notified by having `OnButtonClicked`
    called.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`OnButtonClicked` re-broadcasts the clicked event from the native button via
    the UWidget''s `ButtonClicked` delegate. This means that UObjects and the UMG
    system can be notified of the button being clicked without having a reference
    to the native button widget themselves. We can bind to `UCustomButtonWidget::ButtonClicked` so
    that we''re notified about this.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`OnButtonClicked` then returns `FReply::Handled()` to indicate that the event
    does not need to propagate further. Inside `SynchronizeProperties`, we call the
    parent method to ensure that any properties in the parent are also synchronized
    properly.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We use the `OPTIONAL_BINDING` macro to link the `LabelDelegate` delegate in
    our `UWidget` class to `TAttribute`, and, in turn, the native button's label.
    It is important to note that the `OPTIONAL_BINDING` macro expects the delegate
    to be called `NameDelegate` based on the second parameter to the macro.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`OPTIONAL_BINDING` allows the value to be overridden by a binding made via
    UMG, but only if the UMG binding is valid.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This means that when `UWidget` is told to update itself, for example, because
    the user customizes a value in the Details panel within UMG, it will recreate
    the native `SWidget` if necessary, and then copy the values set in Blueprint/UMG
    via `SynchronizeProperties` so that everything continues to work as expected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
