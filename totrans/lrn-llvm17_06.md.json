["```cpp\n\nunsigned gcd(unsigned a, unsigned b) {\n  if (b == 0)\n    return a;\n  while (b != 0) {\n    unsigned t = a % b;\n    a = b;\n    b = t;\n  }\n  return a;\n}\n```", "```cpp\n\n$ clang --target=aarch64-linux-gnu -O1 -S -emit-llvm gcd.c\n```", "```cpp\n\n; ModuleID = 'gcd.c'\nsource_filename = \"gcd.c\"\ntarget datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\ntarget triple = \"aarch64-unknown-linux-gnu\"\n```", "```cpp\n\ndefine i32 @gcd(i32 %a, i32 %b) {\n```", "```cpp\n\nentry:\n  %cmp = icmp eq i32 %b, 0\n  br i1 %cmp, label %return, label %while.body\n```", "```cpp\n\nwhile.body:\n  %b.loop = phi i32 [ %rem, %while.body ],\n                       [ %b, %entry ]\n  %a.loop = phi i32 [ %b.loop, %while.body ],\n                       [ %a, %entry ]\n  %rem = urem i32 %a.loop, %b.loop\n  %cmp1 = icmp eq i32 %rem, 0\n  br i1 %cmp1, label %return, label %while.body\n```", "```cpp\n\nreturn:\n  %retval = phi i32 [ %a, %entry ],\n                    [ %b.loop, %while.body ]\n  ret i32 %retval\n}\n```", "```cpp\n\n$ clang --target=aarch64-linux-gnu -S -emit-llvm gcd.c\n```", "```cpp\n\ndefine i32 @gcd(i32, i32) {\n  %3 = alloca i32, align 4\n  %4 = alloca i32, align 4\n  %5 = alloca i32, align 4\n  %6 = alloca i32, align 4\n  store i32 %0, ptr %4, align 4\n  store i32 %1, ptr %5, align 4\n  %7 = load i32, ptr %5, align 4\n  %8 = icmp eq i32 %7, 0\n  br i1 %8, label %9, label %11\n```", "```cpp\n\nvoid emitStmt(WhileStatement *Stmt) {\n  llvm::BasicBlock *WhileCondBB = llvm::BasicBlock::Create(\n      CGM.getLLVMCtx(), \"while.cond\", Fn);\n  llvm::BasicBlock *WhileBodyBB = llvm::BasicBlock::Create(\n      CGM.getLLVMCtx(), \"while.body\", Fn);\n  llvm::BasicBlock *AfterWhileBB = llvm::BasicBlock::Create(\n      CGM.getLLVMCtx(), \"after.while\", Fn);\n```", "```cpp\n\n  Builder.CreateBr(WhileCondBB);\n```", "```cpp\n\n  setCurr(WhileCondBB);\n  llvm::Value *Cond = emitExpr(Stmt->getCond());\n  Builder.CreateCondBr(Cond, WhileBodyBB, AfterWhileBB);\n```", "```cpp\n\n  setCurr(WhileBodyBB);\n  emit(Stmt->getWhileStmts());\n  Builder.CreateBr(WhileCondBB);\n```", "```cpp\n\n  sealBlock(WhileCondBB);\n  sealBlock(Curr);\n```", "```cpp\n\n  setCurr(AfterWhileBB);\n}\n```", "```cpp\n\nstruct BasicBlockDef {\n  llvm::DenseMap<Decl *, llvm::TrackingVH<llvm::Value>> Defs;\n  // ...\n};\n```", "```cpp\n\nllvm::DenseMap<llvm::BasicBlock *, BasicBlockDef> CurrentDef;\n```", "```cpp\n\nvoid writeLocalVariable(llvm::BasicBlock *BB, Decl *Decl,\n                        llvm::Value *Val) {\n  CurrentDef[BB].Defs[Decl] = Val;\n}\n```", "```cpp\n\nllvm::Value *\nreadLocalVariable(llvm::BasicBlock *BB, Decl *Decl) {\n  auto Val = CurrentDef[BB].Defs.find(Decl);\n  if (Val != CurrentDef[BB].Defs.end())\n    return Val->second;\n  return readLocalVariableRecursive(BB, Decl);\n}\n```", "```cpp\n\n    llvm::DenseMap<llvm::PHINode *, Decl *> IncompletePhis;\n    unsigned Sealed : 1;\n    ```", "```cpp\n\n    llvm::Value *CGProcedure::readLocalVariableRecursive(\n        llvm::BasicBlock *BB, Decl *Decl) {\n      llvm::Value *Val = nullptr;\n      if (!CurrentDef[BB].Sealed) {\n        llvm::PHINode *Phi = addEmptyPhi(BB, Decl);\n        CurrentDef[BB].IncompletePhis[Phi] = Decl;\n        Val = Phi;\n      } else if (auto *PredBB = BB->getSinglePredecessor()) {\n        Val = readLocalVariable(PredBB, Decl);\n      } else {\n        llvm::PHINode *Phi = addEmptyPhi(BB, Decl);\n        writeLocalVariable(BB, Decl, Phi);\n        Val = addPhiOperands(BB, Decl, Phi);\n      }\n      writeLocalVariable(BB, Decl, Val);\n      return Val;\n    }\n    ```", "```cpp\n\n    llvm::PHINode *\n    CGProcedure::addEmptyPhi(llvm::BasicBlock *BB,\n                             Decl *Decl) {\n      return BB->empty()\n                 ? llvm::PHINode::Create(mapType(Decl), 0,\n                                         \"\", BB)\n                 : llvm::PHINode::Create(mapType(Decl), 0,\n                                         \"\", &BB->front());\n    }\n    ```", "```cpp\n\n    llvm::Value *\n    CGProcedure::addPhiOperands(llvm::BasicBlock *BB,\n                                Decl *Decl,\n                                llvm::PHINode *Phi) {\n      for (auto *PredBB : llvm::predecessors(BB))\n        Phi->addIncoming(readLocalVariable(PredBB, Decl),\n                         PredBB);\n      return optimizePhi(Phi);\n    }\n    ```", "```cpp\n\n    llvm::Value *\n    CGProcedure::optimizePhi(llvm::PHINode *Phi) {\n      llvm::Value *Same = nullptr;\n      for (llvm::Value *V : Phi->incoming_values()) {\n        if (V == Same || V == Phi)\n          continue;\n        if (Same && V != Same)\n          return Phi;\n        Same = V;\n      }\n      if (Same == nullptr)\n        Same = llvm::UndefValue::get(Phi->getType());\n    ```", "```cpp\n\n      llvm::SmallVector<llvm::PHINode *, 8> CandidatePhis;\n      for (llvm::Use &U : Phi->uses()) {\n        if (auto *P =\n                llvm::dyn_cast<llvm::PHINode>(U.getUser()))\n          if (P != Phi)\n            CandidatePhis.push_back(P);\n      }\n      Phi->replaceAllUsesWith(Same);\n      Phi->eraseFromParent();\n      for (auto *P : CandidatePhis)\n        optimizePhi(P);\n      return Same;\n    }\n    ```", "```cpp\n\nvoid CGProcedure::sealBlock(llvm::BasicBlock *BB) {\n  for (auto PhiDecl : CurrentDef[BB].IncompletePhis) {\n    addPhiOperands(BB, PhiDecl.second, PhiDecl.first);\n  }\n  CurrentDef[BB].IncompletePhis.clear();\n  CurrentDef[BB].Sealed = true;\n}\n```", "```cpp\n\nllvm::Value *CGProcedure::readVariable(llvm::BasicBlock *BB,\n                                       Decl *D) {\n  if (auto *V = llvm::dyn_cast<VariableDeclaration>(D)) {\n    if (V->getEnclosingDecl() == Proc)\n      return readLocalVariable(BB, D);\n    else if (V->getEnclosingDecl() ==\n             CGM.getModuleDeclaration()) {\n      return Builder.CreateLoad(mapType(D),\n                                CGM.getGlobal(D));\n    } else\n      llvm::report_fatal_error(\n          \"Nested procedures not yet supported\");\n  } else if (auto *FP =\n                 llvm::dyn_cast<FormalParameterDeclaration>(\n                     D)) {\n    if (FP->isVar()) {\n      return Builder.CreateLoad(mapType(FP, false),\n                                FormalParams[FP]);\n    } else\n      return readLocalVariable(BB, D);\n  } else\n    llvm::report_fatal_error(\"Unsupported declaration\");\n}\n```", "```cpp\n\nstd::string CGModule::mangleName(Decl *D) {\n  std::string Mangled(\"_t\");\n  llvm::SmallVector<llvm::StringRef, 4> List;\n  for (; D; D = D->getEnclosingDecl())\n    List.push_back(D->getName());\n  while (!List.empty()) {\n    llvm::StringRef Name = List.pop_back_val();\n    Mangled.append(\n        llvm::Twine(Name.size()).concat(Name).str());\n  }\n  return Mangled;\n}\n```", "```cpp\n\nllvm::Type *CGModule::convertType(TypeDeclaration *Ty) {\n  if (Ty->getName() == \"INTEGER\")\n    return Int64Ty;\n  if (Ty->getName() == \"BOOLEAN\")\n    return Int1Ty;\n  llvm::report_fatal_error(\"Unsupported type\");\n}\n```", "```cpp\n\nllvm::Type *CGProcedure::mapType(Decl *Decl,\n                                 bool HonorReference) {\n  if (auto *FP = llvm::dyn_cast<FormalParameterDeclaration>(\n          Decl)) {\n    if (FP->isVar() && HonorReference)\n      return llvm::PointerType::get(CGM.getLLVMCtx(),\n                                    /*AddressSpace=*/0);\n    return CGM.convertType(FP->getType());\n  }\n  if (auto *V = llvm::dyn_cast<VariableDeclaration>(Decl))\n    return CGM.convertType(V->getType());\n  return CGM.convertType(llvm::cast<TypeDeclaration>(Decl));\n}\n```", "```cpp\n\nllvm::FunctionType *CGProcedure::createFunctionType(\n    ProcedureDeclaration *Proc) {\n  llvm::Type *ResultTy = CGM.VoidTy;\n  if (Proc->getRetType()) {\n    ResultTy = mapType(Proc->getRetType());\n  }\n  auto FormalParams = Proc->getFormalParams();\n  llvm::SmallVector<llvm::Type *, 8> ParamTypes;\n  for (auto FP : FormalParams) {\n    llvm::Type *Ty = mapType(FP);\n    ParamTypes.push_back(Ty);\n  }\n  return llvm::FunctionType::get(ResultTy, ParamTypes,\n                                 /*IsVarArgs=*/false);\n}\n```", "```cpp\n\nllvm::Function *\nCGProcedure::createFunction(ProcedureDeclaration *Proc,\n                            llvm::FunctionType *FTy) {\n  llvm::Function *Fn = llvm::Function::Create(\n      Fty, llvm::GlobalValue::ExternalLinkage,\n      CGM.mangleName(Proc), CGM.getModule());\n```", "```cpp\n\n  for (auto [Idx, Arg] : llvm::enumerate(Fn->args())) {\n    FormalParameterDeclaration *FP =\n        Proc->getFormalParams()[Idx];\n    if (FP->isVar()) {\n      llvm::AttrBuilder Attr(CGM.getLLVMCtx());\n      llvm::TypeSize Sz =\n          CGM.getModule()->getDataLayout().getTypeStoreSize(\n              CGM.convertType(FP->getType()));\n      Attr.addDereferenceableAttr(Sz);\n      Attr.addAttribute(llvm::Attribute::NoCapture);\n      Arg.addAttrs(Attr);\n    }\n    Arg.setName(FP->getName());\n  }\n  return Fn;\n}\n```", "```cpp\n\n    void CGProcedure::run(ProcedureDeclaration *Proc) {\n      this->Proc = Proc;\n      Fty = createFunctionType(Proc);\n      Fn = createFunction(Proc, Fty);\n    ```", "```cpp\n\n      llvm::BasicBlock *BB = llvm::BasicBlock::Create(\n          CGM.getLLVMCtx(), \"entry\", Fn);\n      setCurr(BB);\n    ```", "```cpp\n\n      for (auto [Idx, Arg] : llvm::enumerate(Fn->args())) {\n        FormalParameterDeclaration *FP =\n            Proc->getFormalParams()[Idx];\n        FormalParams[FP] = &Arg;\n        writeLocalVariable(Curr, FP, &Arg);\n      }\n    ```", "```cpp\n\n      auto Block = Proc->getStmts();\n      emit(Proc->getStmts());\n    ```", "```cpp\n\n      if (!Curr->getTerminator()) {\n        Builder.CreateRetVoid();\n      }\n      sealBlock(Curr);\n    }\n    ```", "```cpp\n\nvoid CGModule::run(ModuleDeclaration *Mod) {\n  for (auto *Decl : Mod->getDecls()) {\n    if (auto *Var =\n            llvm::dyn_cast<VariableDeclaration>(Decl)) {\n      // Create global variables\n      auto *V = new llvm::GlobalVariable(\n          *M, convertType(Var->getType()),\n          /*isConstant=*/false,\n          llvm::GlobalValue::PrivateLinkage, nullptr,\n          mangleName(Var));\n      Globals[Var] = V;\n    } else if (auto *Proc =\n                   llvm::dyn_cast<ProcedureDeclaration>(\n                       Decl)) {\n      CGProcedure CGP(*this);\n      CGP.run(Proc);\n    }\n  }\n}\n```", "```cpp\n\nInt64Ty = llvm::Type::getInt64Ty(getLLVMCtx());\n```", "```cpp\n\nstd::unique_ptr<llvm::Module>\nCodeGenerator::run(ModuleDeclaration *Mod,\n                   std::string FileName) {\n  std::unique_ptr<llvm::Module> M =\n      std::make_unique<llvm::Module>(FileName, Ctx);\n  M->setTargetTriple(TM->getTargetTriple().getTriple());\n  M->setDataLayout(TM->createDataLayout());\n  CGModule CGM(M.get());\n  CGM.run(Mod);\n  return M;\n}\n```", "```cpp\n\nCodeGenerator *\nCodeGenerator::create(llvm::LLVMContext &Ctx,\n                      llvm::TargetMachine *TM) {\n  return new CodeGenerator(Ctx, TM);\n}\n```", "```cpp\n\n#include \"llvm/CodeGen/CommandFlags.h\"\n```", "```cpp\n\nstatic llvm::cl::opt<std::string> MTriple(\n    \"mtriple\",\n    llvm::cl::desc(\"Override target triple for module\"));\n```", "```cpp\n\n    llvm::TargetMachine *\n    createTargetMachine(const char *Argv0) {\n    ```", "```cpp\n\n      llvm::Triple Triple = llvm::Triple(\n          !MTriple.empty()\n              ? llvm::Triple::normalize(MTriple)\n              : llvm::sys::getDefaultTargetTriple());\n      llvm::TargetOptions TargetOptions =\n          codegen::InitTargetOptionsFromCodeGenFlags(Triple);\n      std::string CPUStr = codegen::getCPUStr();\n      std::string FeatureStr = codegen::getFeaturesStr();\n    ```", "```cpp\n\n      std::string Error;\n      const llvm::Target *Target =\n          llvm::TargetRegistry::lookupTarget(\n              codegen::getMArch(), Triple, Error);\n      if (!Target) {\n        llvm::WithColor::error(llvm::errs(), Argv0) << Error;\n        return nullptr;\n      }\n    ```", "```cpp\n\n      llvm::TargetMachine *TM = Target->createTargetMachine(\n          Triple.getTriple(), CPUStr, FeatureStr,\n          TargetOptions, std::optional<llvm::Reloc::Model>(\n              codegen::getRelocModel()));\n      return TM;\n    }\n    ```", "```cpp\n\n#include \"llvm/IR/IRPrintingPasses.h\"\n#include \"llvm/IR/LegacyPassManager.h\"\n#include \"llvm/MC/TargetRegistry.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/ToolOutputFile.h\"\n```", "```cpp\n\nstatic llvm::cl::opt<bool> EmitLLVM(\n    \"emit-llvm\",\n    llvm::cl::desc(\"Emit IR code instead of assembler\"),\n    llvm::cl::init(false));\n```", "```cpp\n\nstatic llvm::cl::opt<std::string>\n    OutputFilename(\"o\",\n                   llvm::cl::desc(\"Output filename\"),\n                   llvm::cl::value_desc(\"filename\"));\n```", "```cpp\n\nbool emit(StringRef Argv0, llvm::Module *M,\n          llvm::TargetMachine *TM,\n          StringRef InputFilename) {\n  CodeGenFileType FileType = codegen::getFileType();\n  if (OutputFilename.empty()) {\n    if (InputFilename == \"-\") {\n      OutputFilename = \"-\";\n    }\n```", "```cpp\n\n    else {\n      if (InputFilename.endswith(\".mod\"))\n        OutputFilename =\n            InputFilename.drop_back(4).str();\n      else\n        OutputFilename = InputFilename.str();\n      switch (FileType) {\n      case CGFT_AssemblyFile:\n        OutputFilename.append(EmitLLVM ? \".ll\" : \".s\");\n        break;\n      case CGFT_ObjectFile:\n        OutputFilename.append(\".o\");\n        break;\n      case CGFT_Null:\n        OutputFilename.append(\".null\");\n        break;\n      }\n    }\n  }\n```", "```cpp\n\n  std::error_code EC;\n  sys::fs::OpenFlags OpenFlags = sys::fs::OF_None;\n  if (FileType == CGFT_AssemblyFile)\n    OpenFlags |= sys::fs::OF_TextWithCRLF;\n  auto Out = std::make_unique<llvm::ToolOutputFile>(\n      OutputFilename, EC, OpenFlags);\n  if (EC) {\n    WithColor::error(llvm::errs(), Argv0)\n        << EC.message() << '\\n';\n    return false;\n  }\n```", "```cpp\n\n  legacy::PassManager PM;\n  if (FileType == CGFT_AssemblyFile && EmitLLVM) {\n    PM.add(createPrintModulePass(Out->os()));\n  } else {\n    if (TM->addPassesToEmitFile(PM, Out->os(), nullptr,\n                                FileType)) {\n      WithColor::error(llvm::errs(), Argv0)\n          << \"No support for file type\\n\";\n      return false;\n    }\n  }\n```", "```cpp\n\n  PM.run(*M);\n```", "```cpp\n\n  Out->keep();\n```", "```cpp\n\n  return true;\n}\n```", "```cpp\n\nMODULE Gcd;\nPROCEDURE GCD(a, b: INTEGER) : INTEGER;\nVAR t: INTEGER;\nBEGIN\n  IF b = 0 THEN\n    RETURN a;\n  END;\n  WHILE b # 0 DO\n    t := a MOD b;\n    a := b;\n    b := t;\n  END;\n  RETURN a;\nEND GCD;\nEND Gcd.\n```", "```cpp\n\n$ tinylang --filetype=obj Gcd.mod\n```", "```cpp\n\n$ tinylang --filetype=asm --emit-llvm -o - Gcd.mod\n```", "```cpp\n\n#include <stdio.h>\nextern long _t3Gcd3GCD(long, long);\nint main(int argc, char *argv[]) {\n  printf(„gcd(25, 20) = %ld\\n\", _t3Gcd3GCD(25, 20));\n  printf(„gcd(3, 5) = %ld\\n\", _t3Gcd3GCD(3, 5));\n  printf(„gcd(21, 28) = %ld\\n\", _t3Gcd3GCD(21, 28));\n  return 0;\n}\n```", "```cpp\n\n$ tinylang --filetype=obj Gcd.mod\n$ clang callgcd.c Gcd.o -o gcd\n$ gcd\n```"]