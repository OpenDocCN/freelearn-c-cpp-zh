- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Using Coroutines in C++ for System Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++进行系统编程的协程
- en: We are almost at the end of our book. The final chapter is dedicated to a feature
    that is very useful for the purposes of system programming but is fairly new to
    the C++ standard. **Coroutine** objects found their application fast, becoming
    first-class state machine objects. Their power is in hiding logic behind the **coroutine
    frame**. Be advised that this is an advanced topic, and the coroutine interface
    of C++ is neither simple nor comfortable to use. It is well thought out but definitely
    not the most user-friendly in comparison to other programming languages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎到了本书的结尾。最后一章致力于一个对于系统编程非常有用但相对较新的C++标准特性。**协程**对象迅速找到了它们的应用，成为了一等状态机对象。它们的强大之处在于隐藏在**协程帧**背后的逻辑。请注意，这是一个高级主题，C++的协程接口既不简单也不舒适使用。它经过深思熟虑，但与其他编程语言相比，绝对不是最用户友好的。
- en: In this chapter, you will learn the basics of using this facility. If you are
    new to it, then you’ll spend some time understanding its requirements. You’ll
    have an easier time with coroutines if you have previous experience with them
    in other programming languages. Still, we will use this chapter to propose their
    application in system programming.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习使用此功能的基本知识。如果您是初学者，那么您将花费一些时间来理解其要求。如果您在其他编程语言中有协程的先前经验，那么您将更容易使用协程。尽管如此，我们仍将利用本章来探讨其在系统编程中的应用。
- en: We will present two practical solutions of previous examples related to **networking**
    and **shared memory**. You will immediately see the predictability and the clear
    execution path of the routines. We hope that you are impressed by the concurrent
    manner of execution without the use of synchronization primitives. Direct reuse
    in a real-world environment is possible; just make sure you have the required
    compilers, as the feature is still new. Without further ado, let’s get to our
    final topic.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示与**网络**和**共享内存**相关的先前示例的两个实际解决方案。您将立即看到例程的可预测性和清晰的执行路径。我们希望您对无需使用同步原语而执行的并发方式印象深刻。在现实世界环境中的直接重用是可能的；只需确保您有所需的编译器，因为这个特性仍然很新。不再拖延，让我们进入我们的最后一个主题。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introducing coroutines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍协程
- en: Network programming and coroutines in C++
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++中的网络编程和协程
- en: Revisiting the shared memory problem through coroutines in C++
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过C++中的协程重新审视共享内存问题
- en: Final thoughts on coroutines and their implementations in C++
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对协程及其在C++中的实现的最终思考
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to run the code examples, you must prepare the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行代码示例，您必须准备以下内容：
- en: A Linux-based system capable of compiling and executing C++20 (for example,
    **Linux** **Mint 21**)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够编译和执行C++20的基于Linux的系统（例如，**Linux** **Mint 21**）
- en: 'The GCC12.2 compiler – [https://gcc.gnu.org/git/gcc.git gcc-source](https://gcc.gnu.org/git/gcc.gitgcc-source):'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GCC12.2编译器 – [https://gcc.gnu.org/git/gcc.git gcc-source](https://gcc.gnu.org/git/gcc.gitgcc-source):'
- en: With the `-fcoroutines`, `-std=c++2a`, `-lpthread`, and `-``lrt` flags
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `-fcoroutines`，`-std=c++2a`，`-lpthread` 和 `-``lrt` 标志
- en: For some of the examples, you can alternatively use [https://godbolt.org/](https://godbolt.org/).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一些示例，您还可以使用[https://godbolt.org/](https://godbolt.org/)。
- en: All code examples in this chapter are available for download from [https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%2010](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%2010)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中所有代码示例均可从[https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%2010](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%2010)下载
- en: Introducing coroutines
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍协程
- en: At the end of your journey, we’d like to remind you about the knowledge you
    received in [*Chapter 1*](B20833_01.xhtml#_idTextAnchor014) and [*Chapter 2*](B20833_02.xhtml#_idTextAnchor029)
    about **processes** and **threads**. If you remember well, a process is simply
    a running instance of a program. It has its respective address space, which is
    not shared with others, except through shared memory. Threads reside in a process,
    and they cannot exist outside of them, although both processes and threads are
    treated as **tasks** in Linux. They are scheduled in the same manner and have
    the same controlling structures on the **kernel** level. Still, threads are considered
    lightweight because the bigger overhead for the initial load of a program is taken
    by the parent process.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的旅程结束时，我们想提醒你关于你在[*第一章*](B20833_01.xhtml#_idTextAnchor014)和[*第二章*](B20833_02.xhtml#_idTextAnchor029)中学到的关于**进程**和**线程**的知识。如果你记得很好，进程只是一个程序的运行实例。它有自己的地址空间，这个地址空间不与其他共享，除非通过共享内存。线程存在于进程内，并且它们不能独立于进程存在，尽管在Linux中，进程和线程都被视为**任务**。它们以相同的方式进行调度，并且在内核级别上有相同的控制结构。然而，线程被认为是轻量级的，因为程序初始加载的大开销由父进程承担。
- en: But this is not the full picture. There are **fibers** and coroutines as well.
    If the processes and threads are truly **concurrent** and working in parallel
    over shared resources, fibers are just like threads but are not **concurrency**-compliant.
    While threads often depend on **preemptive** time-slicing because of the task
    scheduler, fibers use **cooperative multitasking**. That is, they yield themselves
    to run another fiber while executing. They are also known as **stackful coroutines**.
    Meanwhile, coroutines in C++ are known as **stackless coroutines** and are not
    OS-managed. In other words, stackful coroutines could be suspended in a nested
    stack frame, while stackless coroutines can only be nested by the top-level routine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是全部。还有**纤程**和协程。如果进程和线程真正是**并发**的，并且并行地在共享资源上工作，纤程就像线程一样，但不是**并发**兼容的。虽然线程通常依赖于任务调度器的**抢占式**时间切片，但纤程使用**协作式多任务处理**。也就是说，在执行时，它们会自己让出运行权给另一个纤程。它们也被称为**堆栈式协程**。同时，C++中的协程被称为**无堆栈协程**，并且不是由操作系统管理的。换句话说，堆栈式协程可以在嵌套的堆栈帧中被挂起，而无堆栈协程只能通过顶层例程进行嵌套。
- en: Both facilities are considered implicitly synchronized, so all of the synchronization
    primitives and the **atomic** constructs from the previous chapters are needless.
    But you could picture the early example with reading from the file system – where
    the OS waits for the file to be opened, and the process-caller is signaled to
    continue its work. Imagine that the fibers and the coroutines are useful exactly
    for that reactive access, which does not need additional CPU processing. Actually,
    the networking and the file systems are the areas where the fibers and coroutines
    are considered most valuable. When a request is made, a fiber gives control to
    the main thread, and when the I/O operation is finished, the fiber continues where
    it yielded.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个设施被认为是隐式同步的，因此所有来自前几章的同步原语和**原子**构造都是不必要的。但你可以想象早期的例子，即从文件系统中读取——操作系统等待文件打开，并通知进程调用者继续其工作。想象一下，纤程和协程正是为了这种反应式访问而有用，这种访问不需要额外的CPU处理。实际上，网络和文件系统是纤程和协程被认为最有价值的领域。当一个请求被提出时，纤程将控制权交给主线程，而当I/O操作完成时，纤程继续其暂停的地方。
- en: The coroutines technique is rather old. C++ introduced it recently, and it is
    very useful for network programming, I/O operations, event management, and so
    on. Coroutines are also considered executions with the ability to pause. Still,
    they provide multitasking in a cooperative fashion and do not work in parallel.
    This means that tasks cannot be executed simultaneously. At the same time, they
    are real-timw-friendly, allowing switching context between coroutines to be fast,
    and not requiring system calls. In fact, they are **hard-RTOS**-friendly because
    the order of execution and scheduling is controlled by the system programmer,
    as you will see later in the chapter. The coroutines in C++ are very useful for
    implementing task graphs and state machines, too.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 协程技术相当古老。C++最近引入了它，这对于网络编程、I/O操作、事件管理等非常有用。协程也被认为是具有暂停能力的执行。然而，它们以协作的方式提供多任务处理，并不并行工作。这意味着任务不能同时执行。同时，它们对实时系统友好，允许快速在协程之间切换上下文，并且不需要系统调用。实际上，它们对**实时操作系统**非常友好，因为执行顺序和调度是由系统程序员控制的，正如你将在本章后面看到的那样。C++中的协程对于实现任务图和状态机也非常有用。
- en: Some of you are probably wondering what the difference between coroutines and
    standard single-threaded functional programming is. Well, the latter is considered
    a synchronous approach, while the former is an asynchronous approach with synchronous
    readability. But coroutines are really about reducing the needless (busy) waiting
    and doing something useful while a required resource or a call is being prepared.
    The following diagram is simple but reminds us of the respective differences between
    sync and async executions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你们中的一些人可能想知道协程和标准单线程函数式编程之间的区别是什么。好吧，后者被认为是一种同步方法，而前者是一种具有同步可读性的异步方法。但协程实际上是为了减少不必要的（忙碌的）等待，并在准备所需资源或调用时做些有用的事情。下面的图示简单但提醒我们同步和异步执行之间的相应差异。
- en: '![Figure 10.1 – Synchronous versus asynchronous application execution](img/Figure_10.01_B20833.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 同步与异步应用程序执行对比](img/Figure_10.01_B20833.jpg)'
- en: Figure 10.1 – Synchronous versus asynchronous application execution
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 同步与异步应用程序执行对比
- en: A regular single-threaded execution is also limited in some ways. First of all,
    calling, suspending, or resuming a function is not traceable inside a program,
    or at least not through a reference. In other words, the control flow happens
    in the background and is implicit. In addition, the control flow has a strict
    direction – a function could either return to its caller or proceed inward toward
    calling another function. Each function call creates a new record on the stack
    and happens immediately, and once invoked, a method cannot be delayed. As soon
    as that function returns, its portion of the stack is cleared and cannot be restored.
    In other words, the activation is not traceable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常规的单线程执行在某些方面也是有限的。首先，在程序内部调用、挂起或恢复一个函数是不可追踪的，或者至少不是通过引用来追踪。换句话说，控制流在后台发生，是隐式的。此外，控制流有一个严格的方向——一个函数要么返回给调用者，要么向内调用另一个函数。每次函数调用都会在栈上创建一个新的记录，并且立即发生，一旦调用，方法就不能延迟。一旦该函数返回，其栈的部分就会被清除，无法恢复。换句话说，激活是不可追踪的。
- en: On the other hand, coroutines have their own lifetime. A coroutine is an object
    and can be referenced explicitly. If the coroutine should outlive its caller or
    should be transferred to another, then it could be stored in the `int func(int
    arg)` prototype would mean a function with the name `func`, receiving an argument,
    `arg`, of an integer type, returning an integer. A similar coroutine may never
    return to its caller and the value that the caller expects may be produced by
    another coroutine. Let see how this happens in C++.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，协程有自己的生命周期。协程是一个对象，可以显式引用。如果协程应该比调用者存活得更久，或者应该转移到另一个协程，那么它可以存储在`int func(int
    arg)`原型中，这意味着一个名为`func`的函数，接收一个整型类型的参数`arg`，返回一个整型。类似的协程可能永远不会返回给调用者，而调用者期望的值可能由另一个协程产生。让我们看看在C++中这是如何发生的。
- en: The coroutine facility in C++
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++中的协程功能
- en: 'Initially, you can think about them like `Task exCoroutine()` task (a task
    is different from the Linux definition of task) – it is interpreted as a coroutine
    if it uses one of the following three operators: `co_await`, `co_yield`, or `co_return`.
    Here’s an example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，你可以把它们想象成`Task exCoroutine()`任务（任务与Linux中对任务的定义不同）——如果它使用以下三个操作符之一：`co_await`、`co_yield`或`co_return`，它就被解释为协程。以下是一个例子：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The wrapper type is currently `Task`. It is known on the caller level. The coroutine
    object is identified as the `exCoroutine()` function through the `co_return` operator.
    It’s the job of the system programmer to create the `Task` class. It is not a
    part of the Standard library. What’s the `Task` class then?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 包装类型目前是`Task`。它在调用者级别上是已知的。协程对象通过`co_return`运算符被标识为`exCoroutine()`函数。创建`Task`类是系统程序员的职责。它不是标准库的一部分。那么`Task`类是什么呢？
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Important note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This is a very generic pattern that is used in almost every coroutine example.
    You should initially refer to it at [https://en.cppreference.com/w/cpp/language/coroutines](https://en.cppreference.com/w/cpp/language/coroutines).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在几乎所有协程示例中都使用的非常通用的模式。您最初应该参考[https://en.cppreference.com/w/cpp/language/coroutines](https://en.cppreference.com/w/cpp/language/coroutines)。
- en: 'We call a task a coroutine that executes a given routine but doesn’t return
    a value. In addition, the coroutine is associated with a `promise` object – we
    spoke about that in [*Chapter 6*](B20833_06.xhtml#_idTextAnchor086). The `promise`
    object is manipulated on a coroutine level. The coroutine returns the operation
    result or raises an exception through this object. This facility also requires
    the `promise`. It also consists of the passed parameters – copied by value, a
    representation of the current invocation reference; the suspension point, so that
    the coroutine is resumed accordingly; and the local variables outside the scope
    of that point. So, what does our code do? Well, from a user standpoint, it does
    nothing, but there’s a lot happening in the background. Let’s observe the following
    diagram:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称执行给定例程但不返回值的任务为协程。此外，协程与一个`promise`对象相关联——我们曾在[*第6章*](B20833_06.xhtml#_idTextAnchor086)中讨论过这一点。`promise`对象在协程级别上进行操作。协程通过这个对象返回操作结果或抛出异常。这个功能也要求使用`promise`。它还包括传递的参数——按值复制，当前调用引用的表示；挂起点，以便协程可以相应地恢复；以及该点之外的作用域内的局部变量。那么，我们的代码做了什么？从用户的角度来看，它什么也没做，但在后台有很多事情发生。让我们观察以下图表：
- en: '![Figure 10.2 – Simple demonstration of a coroutine startup](img/Figure_10.02_B20833.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 协程启动的简单演示](img/Figure_10.02_B20833.jpg)'
- en: Figure 10.2 – Simple demonstration of a coroutine startup
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 协程启动的简单演示
- en: Remember, by-value parameters are copied or moved in the scope of the coroutine,
    and the by-reference parameters remain as references. This means that the programmer
    should consider their lifetime in the task-caller, so no dangling pointers appear.
    Afterward, the `promise` is constructed and `get_return_object()` is called. The
    result will be returned to the task-caller when the coroutine first suspends.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，按值参数在协程的作用域内被复制或移动，而按引用参数保持为引用。这意味着程序员应该考虑它们在任务调用者中的生命周期，以避免出现悬垂指针。之后，构造`promise`并调用`get_return_object()`。当协程首次挂起时，结果将返回给任务调用者。
- en: '*Figure 10**.2* demonstrates a case where the `promise` returns `suspend_always`
    and we have lazily started a coroutine. The `initial_suspend()` operation resumes
    and, without the knowledge or the context of how to continue, the coroutine will
    never be resumed and will leak. In order to handle this, we need... a `handle`
    object. You can think of the `handle` object as a view. Similar to the relationships
    between the `string_view` object and a `string` object, or a `vector` object and
    a `range` object with a `range view` object, the `handle` object is used to provide
    indirect access to `*this`. Through the `handle` object, we can call `resume()`
    to continue the coroutine’s work. It must be suspended first, or the behavior
    will be undefined:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.2*演示了`promise`返回`suspend_always`并且我们懒加载启动协程的情况。`initial_suspend()`操作恢复，但没有继续的知道或上下文，协程将永远不会恢复并且会泄漏。为了处理这种情况，我们需要...一个`handle`对象。你可以把`handle`对象看作是一个视图。类似于`string_view`对象和`string`对象之间的关系，或者`vector`对象和具有`range
    view`对象的`range`对象之间的关系，`handle`对象用于提供对`*this`的间接访问。通过`handle`对象，我们可以调用`resume()`来继续协程的工作。它必须首先挂起，否则行为将是未定义的：'
- en: '![Figure 10.3 – Graph demonstrating a coroutine’s creation and resumption](img/Figure_10.03_B20833.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 图形演示协程的创建和恢复](img/Figure_10.03_B20833.jpg)'
- en: Figure 10.3 – Graph demonstrating a coroutine’s creation and resumption
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 图形演示了协程的创建和恢复
- en: The `initial_suspend()` operation is called and the result is handled through
    `co_await`. This is done through the compiler generating additional code in the
    background around the `suspend_never` awaitable – the coroutine is not created
    in a lazy manner as with `suspend_always`, but is immediately started. Both are
    defined in the C++ Standard Library.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`initial_suspend()`操作，并通过`co_await`处理结果。这是通过编译器在`suspend_never`可等待对象周围生成额外的代码来实现的——协程不是以懒加载的方式创建，而是立即启动。这两个都在C++标准库中定义。
- en: The current coroutine does a `co_return` keyword (in `exCoroutine()`). But that
    way, the coroutine body is exited. If we want to use it to produce constantly
    new or the next generated values, then we require the `co_yield` operator. We
    call such a coroutine a `co_yield` operator as `co_await promise.yield_value(<some
    expression>)`. Otherwise, if it simply calls `co_await`, it is a task, as mentioned
    earlier. Now, if we look at *Figure 10**.3* again, using the `co_yield` operator
    will redirect the arrow from *thread-caller in control* to *coroutine execution*,
    thus providing the opportunity to coroutine to continue work. In other words,
    the `co_return` keyword will lead to execution completion, while the `co_yield`
    keyword will just suspend the coroutine temporarily.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当前协程执行`co_return`关键字（在`exCoroutine()`中）。但这样，协程主体就退出了。如果我们想用它来产生不断的新或下一个生成的值，那么我们需要`co_yield`运算符。我们称这样的协程为`co_yield`运算符，即`co_await
    promise.yield_value(<some expression>)`。否则，如果它只是调用`co_await`，那么它就像之前提到的任务一样。现在，如果我们再次看看*图10**.3*，使用`co_yield`运算符将箭头从*控制中的线程调用者*重定向到*协程执行*，从而为协程继续工作提供机会。换句话说，`co_return`关键字将导致执行完成，而`co_yield`关键字只是暂时挂起协程。
- en: 'Let’s go a step back and take a look at `co_await` call. Their work is presented
    in the following diagram:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，看看`co_await`调用。它们的工作在以下图中展示：
- en: '![Figure 10.4 – Graph representing generated invocations after a co_await call](img/Figure_10.04_B20833.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 表示在co_await调用后生成的调用的图形](img/Figure_10.04_B20833.jpg)'
- en: Figure 10.4 – Graph representing generated invocations after a co_await call
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 表示在co_await调用后生成的调用的图形
- en: 'Now, a private variable of the `Handle` type is used to call the true `resume()`
    function. Let’s check the code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`Handle`类型的私有变量来调用真正的`resume()`函数。让我们检查一下代码：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will use the `explicit` specifier. In C++ 20, it allows you to be more restrictive
    on constructor calls. That is, it cannot be used for copy tnitialization or implicit
    conversions. Additionally, we keep our `handle` object private. Now, let’s see
    how this might come in handy (markers {1} and {2}, while a wrapper is provided
    to the caller – markers {1} and {3}):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`explicit`指定符。在C++ 20中，它允许你对构造函数调用更加严格。也就是说，它不能用于复制初始化或隐式转换。此外，我们保持我们的`handle`对象私有。现在，让我们看看这可能会派上什么用场（标记{1}和{2}，同时提供一个包装器给调用者——标记{1}和{3}）：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s use this code structure to build a fully functional example. We will
    rename the `Task` struct `Generator`, and implement a coroutine with a generator
    functionality. The full code can be found here: [https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%2010](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%2010).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这种代码结构来构建一个完全功能性的示例。我们将重命名`Task`结构为`Generator`，并实现一个具有生成器功能的协程。完整的代码可以在以下位置找到：[https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%2010](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%2010)。
- en: 'We will increment a variable N number of times through the coroutine. That’s
    why it needs to be able to yield, and we add the following to `Generator`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过协程增加变量N的次数。这就是为什么它需要能够产生，所以我们向`Generator`添加以下内容：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, getting the next element happens as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，获取下一个元素的过程如下：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Proceeding with the coroutine body and its creation in the main thread. The
    increment will happen 100,000 times. This example allows the programmer to generate
    data lazily and not use a big portion of the RAM. At the same time, no separate
    thread is used, so the execution remains in the user space without extensive context
    switching:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在主线程中继续协程主体及其创建。增量将发生100,000次。这个例子允许程序员以懒加载的方式生成数据，而不使用大量RAM。同时，没有使用单独的线程，因此执行保持在用户空间，没有进行大量的上下文切换：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The shortened version of the output is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的简短版本如下：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Unfortunately, you probably already understand why it is not that trivial to
    create a simple coroutine application in C++. As a new feature, this facility
    continues to improve and there are new interfaces expected in upcoming C++ versions,
    which should simplify coroutine usage. But this shouldn’t discourage you from
    continuing to use them. This example could be easily extended to other functionalities,
    and you could build up your knowledge step by step. In the next sections, we will
    do exactly this and get the discussion back in the area of system programming.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，你可能已经理解了为什么在 C++ 中创建一个简单的协程应用程序并不那么简单。作为一个新特性，这个功能仍在不断改进，预计在即将到来的 C++ 版本中会有新的接口，这将简化协程的使用。但这不应该阻止你继续使用它们。这个例子可以很容易地扩展到其他功能，你可以逐步建立你的知识。在接下来的章节中，我们将做
    exactly this，并将讨论带回系统编程领域。
- en: Network programming and coroutines in C++
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 中的网络编程和协程
- en: 'In [*Chapter 7*](B20833_07.xhtml#_idTextAnchor101), you learned about the `Generator`
    definition to match the type of the **coroutine**, as discussed earlier. Traditionally,
    that object is made move-only – this allows us to restrict the usage of the coroutine
    wrapper, but in general cases, coroutine objects are non-copyable and non-moveable,
    because the **coroutine frame** is a part of them, and some local variables can
    be references or pointers to other local variables. Thus, let’s extend the structure
    accordingly:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 7 章*](B20833_07.xhtml#_idTextAnchor101) 中，你学习了如何使用 `Generator` 定义来匹配 **协程**
    的类型，正如之前讨论的那样。传统上，该对象被制成仅可移动的 – 这允许我们限制协程包装器的使用，但在一般情况下，协程对象是不可复制的且不可移动的，因为 **协程帧**
    是它们的一部分，并且一些局部变量可以是其他局部变量的引用或指针。因此，让我们相应地扩展结构：
- en: Important note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This, again, is a very generic pattern that is used in almost every coroutine
    example. You should initially refer to it at [https://en.cppreference.com/w/cpp/language/coroutines](https://en.cppreference.com/w/cpp/language/coroutines).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这，再次，是一个非常通用的模式，几乎在每一个协程示例中都使用。你应该最初参考[https://en.cppreference.com/w/cpp/language/coroutines](https://en.cppreference.com/w/cpp/language/coroutines)。
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You’ll notice that the `struct` object is defined as a `template` in order
    to be generic. We overload the `()` operator in order to be able to appropriately
    give the control back to the caller:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，`struct` 对象被定义为 `template` 以使其通用。我们重载 `()` 操作符，以便能够适当地将控制权交还给调用者：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We also add a behavior during an exception – the application will be terminated:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在异常期间添加了行为 – 应用程序将被终止：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the main thread, we create and join two threads – a server and a client.
    Each of them will execute the coroutines for the respective domains. We provide
    a `socket` (marker {9} in the following code):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在主线程中，我们创建并连接两个线程 – 一个服务器和一个客户端。每个线程都将执行相应域的协程。我们提供了一个 `socket`（以下代码中的标记 {9}）：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inside the `sendto()` method. We use a `string_view` object, the same way we
    did in [*Chapter 3*](B20833_03.xhtml#_idTextAnchor047) – the reasoning is primarily
    the safety of the code and the compactness of the data and its size. At the end
    of the loop, we use `co_yield value`, thus providing the number of bytes sent
    to the main thread. The endless loop allows the coroutine to run until truly canceled
    by outer logic – in this, it’s called 10 times, because of the `for` loop in the
    main thread (marker {10} in the following code):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sendto()` 方法内部。我们使用 `string_view` 对象，就像我们在 [*第 3 章*](B20833_03.xhtml#_idTextAnchor047)
    中做的那样 – 主要原因是代码的安全性以及数据及其大小的紧凑性。在循环结束时，我们使用 `co_yield value`，从而向主线程提供发送的字节数。无限循环允许协程在真正被外部逻辑取消之前运行
    – 在这种情况下，它被调用 10 次，因为主线程中的 `for` 循环（以下代码中的标记 {10}）：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The client thread is implemented in a similar fashion:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端线程以类似的方式实现：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The server-side coroutine has the following body:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端协程具有以下主体：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The client-side coroutines are implemented in a similar fashion:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端协程以类似的方式实现：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The coroutine function calls the `recvfrom()` system call. At the end, instead
    of the bytes received, the message coming from the socket is stored in the `currValue`
    member variable. It’s then printed out in the main thread. We also use the `MSG_DONTWAIT`
    flag. The respective output will be printed out in different ways every time as
    the code is asynchronous. The last part is as expected:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 协程函数调用 `recvfrom()` 系统调用。在结束时，不是存储接收到的字节，而是将来自套接字的消息存储在 `currValue` 成员变量中。然后，在主线程中打印出来。我们还使用了
    `MSG_DONTWAIT` 标志。由于代码是异步的，每次相应的输出将以不同的方式打印出来。最后一部分符合预期：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The merging or misplacing of text is to be expected, but it proves the useability
    of coroutines. The shortened version of the output is the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 文本的合并或错位是预期之中的，但这证明了协程的可使用性。输出的简短版本如下：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The full example can be found at https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%2010.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可以在 https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%2010
    找到。
- en: In the previous chapter, we also had the issue of synchronizing parallel threads,
    but the code was not truly parallel every time. For example, waiting for an event
    such as “the resource is accessible” is a matter of concurrency, not parallel
    execution. That said, coroutines are a powerful tool in the shared memory problem,
    too – let’s check it out in the next section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们也遇到了同步并行线程的问题，但代码并不总是真正并行。例如，等待“资源可访问”这样的事件是并发的问题，而不是并行执行。话虽如此，协程在共享内存问题中也是一个强大的工具——让我们在下一节中看看它。
- en: Revisiting the shared memory problem through coroutines in C++
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 C++ 协程重新审视共享内存问题
- en: One of the issues we had with **condition variables** was synchronization during
    process startup. In other words, for the producer-consumer example, we didn’t
    know which threads were going to be first. We synchronized the code through a
    condition variable – its **mutex**, together with a predicate in order to handle
    the correct sequence of events. Otherwise, we would’ve risked losing information
    or ending in a **deadlock**. For a good portion of this book’s example preparations,
    we got to this situation, which made the writing experience even better. But coroutines
    provide another way of doing it, which could be more efficient at times and simpler
    to use (after you get used to the interface of coroutines as it is not the easiest
    to grasp).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与 **条件变量** 有关的一个问题是进程启动时的同步。换句话说，对于生产者-消费者示例，我们不知道哪些线程将首先启动。我们通过条件变量——它的 **互斥锁**
    以及一个谓词来同步代码，以处理事件的正确顺序。否则，我们可能会丢失信息或陷入 **死锁**。在这本书的大部分示例准备过程中，我们遇到了这种情况，这使得写作体验更加丰富。但协程提供了另一种方法，有时可能更高效且更易于使用（在你习惯了协程的接口之后，因为它并不容易掌握）。
- en: 'The next example is motivated by the **awaitable-awaiter** pattern. It is similar
    to the condition variable, but it doesn’t use such synchronization primitives.
    Still, the notification signaling is dependent on an atomic variable. We’ll get
    back to the Task coroutine. It will used for handling the receiver end. The full
    example can be found here: [https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%2010](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%2010).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下一示例是由 **awaitable-awaiter** 模式激发的。它与条件变量类似，但它不使用这样的同步原语。然而，通知信号依赖于一个原子变量。我们将回到
    Task 协程。它将用于处理接收端。完整示例在此：[https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%2010](https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%2010)。
- en: Important note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The example is inspired by [https://www.modernescpp.com/index.php/c-20-thread-synchronization-with-coroutines/](https://www.modernescpp.com/index.php/c-20-thread-synchronization-with-coroutines/).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例受到了 [https://www.modernescpp.com/index.php/c-20-thread-synchronization-with-coroutines/](https://www.modernescpp.com/index.php/c-20-thread-synchronization-with-coroutines/)
    的启发。
- en: 'We reuse the code from the **shared memory** example from [*Chapter 9*](B20833_09.xhtml#_idTextAnchor129):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重用了来自 [*第9章*](B20833_09.xhtml#_idTextAnchor129) 的 **共享内存** 示例中的代码：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We align the shared memory and set its size first, then we continue mapping
    the pointer to it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先对共享内存进行对齐并设置其大小，然后继续将指针映射到它上面：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It is really important that the address of `res` is accessible for dereferencing
    inside the coroutine. Otherwise, the code will crash with `Segmentation fault`,
    which is preferable to a dangling pointer. Another remark is that different compilers
    (or environments) will give you different behavior for this code. Before we get
    to the `Event` struct, let’s see what the sender does – again, we step on our
    previous code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 确保对 `res` 的地址可访问以在协程内部进行解引用非常重要。否则，代码将因 `Segmentation fault` 而崩溃，这比悬挂指针更可取。另一个需要注意的是，不同的编译器（或环境）将为这段代码提供不同的行为。在我们到达
    `Event` 结构体之前，让我们看看发送者做了什么——再次，我们回到了之前的代码：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Again, we make sure the shared memory is of the correct size and we map the
    pointer to it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们确保共享内存的大小正确，并将指针映射到它上面：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Initially, the notification flag is set to `false`, meaning that the coroutine
    will not behave as a regular function but is going to be suspended. Then, the
    `waiter` object is loaded, which is `nullptr`, because it’s not previously set.
    Its respective `resume()` operation is not called. The subsequentially performed
    `await_suspend()` function gets the `waiter` state is stored in the `suspended`
    member variable. Later, `notify()` is triggered and it’s executed fully:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，通知标志被设置为`false`，这意味着协程将不会像常规函数那样执行，而是将被挂起。然后，加载`waiter`对象，它是`nullptr`，因为它之前没有被设置。相应的`resume()`操作没有被调用。随后执行的`await_suspend()`函数将`waiter`的状态存储在`suspended`成员变量中。稍后，`notify()`被触发并完全执行：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the main thread, an `Event` object is required to synchronize the workflow.
    A shared memory region is defined as well. If `shm_open()` is called inside each
    coroutine, it will not really be shared virtual memory, as the file descriptor
    will access private regions for each of the coroutines. Thus, we will end up with
    `Segmentation fault`. There are two threads, representing the sender and the receiver
    ends. The aforementioned coroutines are called respectively after the threads
    are joined:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在主线程中，需要一个`Event`对象来同步工作流程。同时定义了一个共享内存区域。如果在每个协程中调用`shm_open()`，它实际上不会是共享虚拟内存，因为文件描述符将访问每个协程的私有区域。因此，我们最终会遇到`Segmentation
    fault`。有两个线程，分别代表发送者和接收者端。上述协程分别在线程合并后分别被调用：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The receiver’s code is similar, but the `event` object is passed as an argument:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接收者的代码类似，但将`event`对象作为参数传递：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This example gives you the flexibility to manage your shared resources in a
    concurrent manner. The notification mechanism of awaiter-awaitable will do the
    job without the need for synchronization primitives. We encourage you to try it
    out yourself. In the meantime, we’ll proceed with some final notes on coroutines
    usage in system programming.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例为您提供了以并发方式管理共享资源的灵活性。awaiter-awaitable的通知机制将完成工作，无需同步原语。我们鼓励您亲自尝试。同时，我们将继续讨论系统编程中协程的使用的一些最终注意事项。
- en: Final thoughts on coroutines and their implementations in C++
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于协程及其在C++中的实现的最终思考
- en: The examples earlier were practical, although not so simple. They were useful
    in understanding the sequence that a coroutine’s execution might take. It is good
    to visualize the state graph of coroutines, although we still believe it would
    be confusing for inexperienced developers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子虽然实用，但并不简单。它们有助于理解协程执行可能遵循的顺序。可视化协程的状态图是很有帮助的，尽管我们仍然认为对于经验不足的开发者来说可能会有些混乱。
- en: As presented earlier, *Figure 10**.2*, *Figure 10**.3*, and *Figure 10**.4*
    pretty much cover what we’ve already explained through the code examples. It is
    useful to understand how much additional logic is generated around the coroutine
    and its members. Most of it happens in the background, and the system programmer
    only arranges the scheduling. In this chapter’s examples, we did this through
    the `promise` object and awaitables. The fact that the aforementioned figures
    partially represent a coroutine’s execution as a finite state machine should hint
    to you that this is another application where coroutines are useful. They transform
    state machines into first-class objects. Once the coroutine frame is defined,
    much of the logic remains there and it’s hidden from callers. This provides the
    opportunity for system programmers to put aside the concurrent logic for a moment
    and just focus on calling the coroutines through short code snippets, as we did.
    The system behavior code and task scheduling will be simpler and more obvious.
    Thus, much of the power of managing algorithms, parsers, data structure traversals,
    polling, and so on could be interpreted by this technique. Unfortunately, we cannot
    cover everything here, but we believe it’s worthwhile checking these things out.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，**图10.2**、**图10.3**和**图10.4**基本上涵盖了通过代码示例我们已经解释的内容。了解围绕协程及其成员生成的额外逻辑量是有用的。大部分逻辑都是在后台发生的，系统程序员只需安排调度。在本章的示例中，我们通过`promise`对象和可等待对象来实现这一点。上述图示部分表示协程的执行作为一个有限状态机，这应该会提示你，这也是协程有用处的另一个应用场景。它们将状态机转换为一等对象。一旦协程框架被定义，大部分逻辑都保留在那里，并且对调用者隐藏。这为系统程序员提供了暂时放下并发逻辑的机会，只通过简短的代码片段调用协程，就像我们这样做。系统行为代码和任务调度将更简单、更明显。因此，管理算法、解析器、数据结构遍历、轮询等许多功能的大部分能力都可以通过这种技术来解释。不幸的是，我们无法在此涵盖所有内容，但我们相信检查这些内容是值得的。
- en: 'Last but not least, we’d like to emphasize that coroutines are fairly new to
    the language. As the coroutine interface in C++ is still lacking comfort and simplicity,
    you can find many custom-made coroutine libraries on the internet. We advise you
    to rely only on the trustworthy ones or wait for the next Standard features of
    this facility. It makes more sense to apply those than to implement them anew
    yourself. As you can see, it’s quite a complex concept, and there’s a lot of research
    being done on the matter. For curious readers, we encourage you to spend some
    time learning about the evolution of coroutines in C++, especially in recent years.
    There are three techniques discussed in the C++ Standard – Coroutines TS, Core
    Coroutines, and Resumable expressions. Although just one is currently used in
    the Standard, the three of them deserve attention. A great summary and analysis
    has been done by Geoffrey Romer, Gor Nishanov, Lewis Baker, and Mihail Mihailov
    here: [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1493r0.pdf](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1493r0.pdf).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们想强调协程对这个语言来说相对较新。由于C++中的协程接口仍然缺乏舒适性和简单性，你可以在互联网上找到许多定制的协程库。我们建议您只依赖可信赖的库，或者等待这个设施的下一次标准特性。应用这些特性比重新实现它们更有意义。正如你所看到的，这是一个相当复杂的概念，并且在这方面有很多研究正在进行。对于好奇的读者，我们鼓励您花些时间了解C++中协程的演变，尤其是在最近几年。C++标准中讨论了三种技术——协程TS、核心协程和可恢复表达式。尽管目前标准中只使用其中一种，但三者都值得注意。Geoffrey
    Romer、Gor Nishanov、Lewis Baker和Mihail Mihailov在这里进行了很好的总结和分析：[https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1493r0.pdf](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1493r0.pdf)。
- en: Feel free to check it out. Many of the clarifications we gave in this chapter
    are presented in the document as a great visual comparison of the regular functions
    and coroutines. Meanwhile, we continue to the finish.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 随意查看。本章中我们提供的许多澄清都在文档中以优秀的视觉对比形式呈现，对比了常规函数和协程。同时，我们继续完成剩余部分。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With this, we’ve covered all the topics of this book. With the upcoming improvements
    of C++23, coroutines and their evolution will be analyzed more and more, especially
    in the system programming domain – and applied there, of course. Although complex
    to understand at first, coroutines allow you to continue sharpening the usage
    of C++ and give you one more instrument to enhance code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经涵盖了这本书的所有主题。随着C++23即将到来的改进，协程及其发展将得到越来越多的分析，尤其是在系统编程领域——当然，也会在那里应用。虽然一开始可能难以理解，但协程允许您继续磨练C++的使用，并为您提供另一个增强代码的工具。
- en: In this chapter, you learned how to apply them in your concurrent applications,
    but their usefulness is far greater. We are excited about what comes next. We
    expect the `modules` language feature, which we didn’t cover in this book – intentionally
    – to be fully covered by the compilers and be broadly applied. Another interesting
    feature is `std::generator` – a view for the synchronous creation of coroutines
    in C++23\. `std::stacktrace` from a thrown exception, which will help you in code
    debugging. And for easier printing, you’ll be able to use `std::print` as well.
    The monadic interface of `std::expected` will allow you to store either of two
    values. In addition to all this, files will be loaded at compile time as arrays
    through `#embed`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何在并发应用程序中应用它们，但它们的作用远不止于此。我们对接下来会发生什么感到兴奋。我们预计，编译器将完全覆盖我们在这本书中——故意地——没有涵盖的`modules`语言特性，并将其广泛应用。另一个有趣的功能是`std::generator`——C++23中用于同步创建协程的视图。`std::stacktrace`可以从抛出的异常中获取，这将帮助您进行代码调试。为了便于打印，您还将能够使用`std::print`。`std::expected`的单调接口将允许您存储两个值中的任意一个。除此之外，文件将通过`#embed`在编译时作为数组加载。
- en: We’d like to use this opportunity to express our gratitude to you – the reader!
    We hope you found this book useful and will apply parts of it in your daily job.
    We also hope you enjoyed the experience the way we enjoyed writing the book. It
    was a tremendous journey for us, and we’d be glad to share future journeys with
    you. With this, we wish you good fortune in all your projects!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想借此机会向您——读者——表达我们的感激之情！我们希望您觉得这本书有用，并将其中的部分内容应用到您的日常工作中。我们也希望您享受阅读这本书的过程，就像我们享受写作这本书一样。对我们来说，这是一次巨大的旅程，我们很高兴能与您分享未来的旅程。在此，我们祝愿您在所有项目中好运连连！
