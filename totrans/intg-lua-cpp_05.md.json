["```cpp\nposition = { x = 0, y = 0 }\n```", "```cpp\nint lua_gettable(lua_State *L, int index);\n```", "```cpp\nclass LuaExecutor\n{\npublic:\n    LuaValue getTable(const std::string &table,\n                      const std::string &key);\n};\n```", "```cpp\nLuaValue LuaExecutor::getTable(\n    const std::string &table, const std::string &key)\n{\n    int type = lua_getglobal(L, table.c_str());\n    assert(LUA_TTABLE == type);\n    lua_pushstring(L, key.c_str());\n    lua_gettable(L, -2);\n    auto value = popValue();\n    lua_pop(L, 1);\n    return value;\n}\n```", "```cpp\nvoid lua_settable(lua_State *L, int index);\n```", "```cpp\nclass LuaExecutor\n{\npublic:\n    void setTable(const std::string &table,\n                  const std::string &key,\n                  const LuaValue &value);\n};\n```", "```cpp\nvoid LuaExecutor::setTable(const std::string &table,\n    const std::string &key, const LuaValue &value)\n{\n    int type = lua_getglobal(L, table.c_str());\n    assert(LUA_TTABLE == type);\n    lua_pushstring(L, key.c_str());\n    pushValue(value);\n    lua_settable(L, -3);\n    lua_pop(L, 1);\n}\n```", "```cpp\nvoid dumpPosition(LuaExecutor *lua)\n{\n    auto x = lua->getTable(\"position\", \"x\");\n    auto y = lua->getTable(\"position\", \"y\");\n    std::cout << \"x=\" << std::get<LuaNumber>(x).value\n              << \", y=\" << std::get<LuaNumber>(y).value\n              << std::endl;\n}\n```", "```cpp\ndumpPositon(lua.get());\nlua->setTable(\"position\", \"x\", LuaNumber::make(3));\nlua->setTable(\"position\", \"y\", LuaNumber::make(4));\ndumpPositon(lua.get());\n```", "```cpp\nx=0, y=0\nx=3, y=4\n```", "```cpp\nseq = { 0, 0, 0 }\n```", "```cpp\nclass LuaExecutor\n{\npublic:\n    LuaValue getTable(const std::string &table,\n                      int index);\n    void setTable(const std::string &table,\n                  int index,\n                  const LuaValue &value);\n};\n```", "```cpp\nvoid lua_geti(lua_State *L, int index, int key);\nvoid lua_seti(lua_State *L, int index, int key);\n```", "```cpp\nLuaValue LuaExecutor::getTable(\n    const std::string &table, int index)\n{\n    int type = lua_getglobal(L, table.c_str());\n    assert(LUA_TTABLE == type);\n    lua_geti(L, -1, index);\n    auto value = popValue();\n    lua_pop(L, 1);\n    return value;\n}\n```", "```cpp\nvoid LuaExecutor::setTable(const std::string &table,\n    int index, const LuaValue &value)\n{\n    int type = lua_getglobal(L, table.c_str());\n    assert(LUA_TTABLE == type);\n    pushValue(value);\n    lua_seti(L, -2, index);\n    lua_pop(L, 1);\n}\n```", "```cpp\nvoid dumpSeq(LuaExecutor *lua)\n{\n    auto v1 = lua->getTable(\"seq\", 1);\n    auto v2 = lua->getTable(\"seq\", 2);\n    auto v3 = lua->getTable(\"seq\", 3);\n    std::cout << \"seq={\"\n              << std::get<LuaNumber>(v1).value << \", \"\n              << std::get<LuaNumber>(v2).value << \", \"\n              << std::get<LuaNumber>(v3).value << \"}\"\n              << std::endl;\n}\n```", "```cpp\ndumpSeq(lua.get());\nlua->setTable(\"seq\", 1, LuaNumber::make(3));\nlua->setTable(\"seq\", 2, LuaNumber::make(9));\nlua->setTable(\"seq\", 3, LuaNumber::make(27));\ndumpSeq(lua.get());\n```", "```cpp\nseq={0, 0, 0}\nseq={3, 9, 27}\n```", "```cpp\nint lua_getfield(\n    lua_State *L, int index, const char *k);\nvoid lua_setfield(\n    lua_State *L, int index, const char *k);\n```", "```cpp\nDestinations = { places = {} }\nsetmetatable(Destinations.places, {\n    __newindex = function (t, k, v)\n        print(\"You cannot use Destinations directly\")\n    end,\n})\n```", "```cpp\nfunction Destinations.new(global_name)\n    local obj = { places = {} }\n    setmetatable(obj, {__index = Destinations})\n    if global_name then _G[global_name] = obj end\n    return obj\nend\n```", "```cpp\nfunction Destinations:wish(...)\n    for _, place in ipairs{...} do\n        self.places[place] = false\n    end\nend\nfunction Destinations:went(...)\n    for _, place in ipairs{...} do\n        self.places[place] = true\n    end\nend\n```", "```cpp\nfunction Destinations.wish(self, ...)\n```", "```cpp\nfunction Destinations:list_visited()\n    local result = {}\n    for place, visited in pairs(self.places) do\n        if visited then result[#result + 1] = place end\n    end\n    return table.unpack(result)\nend\nfunction Destinations:list_unvisited()\n    local result = {}\n    for place, visited in pairs(self.places) do\n        if not visited then\n            result[#result + 1] = place\n        end\n    end\n    return table.unpack(result)\nend\n```", "```cpp\nLua 5.4.6  Copyright (C) 1994-2023 Lua.org, PUC-Rio\n> dofile(\"script.lua\")\n> dst = Destinations.new()\n> dst:wish(\"London\", \"Paris\", \"Amsterdam\")\n> dst:went(\"Paris\")\n> dst:list_visited()\nParis\n> dst:list_unvisited()\nLondon  Amsterdam\n```", "```cpp\nclass LuaExecutor\n{\npublic:\n    template <typename... Ts>\n    LuaValue tcall(\n        const std::string &table,\n        const std::string &function,\n        bool shouldPassSelf,\n        const Ts &...params);\n    template <typename... Ts>\n    std::vector<LuaValue> vtcall(\n        const std::string &table,\n        const std::string &function,\n        bool shouldPassSelf,\n        const Ts &...params);\n};\n```", "```cpp\ntemplate <typename... Ts>\nLuaValue LuaExecutor::tcall(...)\n{\n    int type = lua_getglobal(L, table.c_str());\n    assert(LUA_TTABLE == type);\n    type = lua_getfield(L, -1, function.c_str());\n    assert(LUA_TFUNCTION == type);\n    if (shouldPassSelf) {\n        lua_getglobal(L, table.c_str());\n    }\n    for (auto param :\n        std::initializer_list<LuaValue>{params...}) {\n        pushValue(param);\n    }\n    int nparams = sizeof...(params) +\n        (shouldPassSelf ? 1 : 0);\n    pcall(nparams, 1);\n    auto result = popValue();\n    lua_pop(L, 1);\n    return result;\n}\n```", "```cpp\nlua->tcall(\"Destinations\", \"new\", false,\n    LuaString::make(\"dst\"));\nlua->tcall(\"dst\", \"wish\", true,\n    LuaString::make(\"London\"),\n    LuaString::make(\"Paris\"),\n    LuaString::make(\"Amsterdam\"));\nlua->tcall(\"dst\", \"went\", true,\n    LuaString::make(\"Paris\"));\nauto visited = lua->vtcall(\n    \"dst\", \"list_visited\", true);\nauto unvisited = lua->vtcall(\n    \"dst\", \"list_unvisited\", true);\n```", "```cpp\nstd::cout << \"Visited:\" << std::endl;\nfor (auto place : visited) {\n    std::cout << std::get<LuaString>(place).value\n              << std::endl;\n}\nstd::cout << \"Unvisited:\" << std::endl;\nfor (auto place : unvisited) {\n    std::cout << std::get<LuaString>(place).value\n              << std::endl;\n}\n```", "```cpp\nVisited:\nParis\nUnvisited:\nLondon\nAmsterdam\n```"]