<html><head></head><body>
		<div><h1 id="_idParaDest-31" class="chapter-number"><a id="_idTextAnchor030"/>2</h1>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/> Coin Dash – Build Your First 2D Game</h1>
			<p>This first project will guide you through making your first Godot Engine game. You will learn how the Godot editor works, how to structure a project, and how to build a small 2D game using some of Godot’s most commonly used nodes.</p>
			<p class="callout-heading">Why start with 2D?</p>
			<p class="callout">In a nutshell, 3D games are much more complex than 2D ones. However, many of the underlying game engine features you’ll need to know are the same. You should stick to 2D until you have a good understanding of Godot’s workflow. At that point, the jump to 3D will feel much easier. You’ll get a chance to work in 3D in this book’s later chapters.</p>
			<p>Don’t skip this chapter, even if you aren’t a complete newcomer to game development. While you may already understand many of the concepts, this project will introduce Godot’s features and design paradigms – things you’ll need to know going forward.</p>
			<p>The game in this chapter<a id="_idIndexMarker053"/> is called <em class="italic">Coin Dash</em>. Your character must move around the screen, collecting as many coins as possible while racing against the clock. When you’re finished, the game will look like this:</p>
			<div><div><img src="img/B19289_02_01.jpg" alt="Figure 2.1: The completed game"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1: The completed game</p>
			<p>In this chapter, we’ll cover the following topics:</p>
			<ul>
				<li>Setting up a new project</li>
				<li>Creating character animations</li>
				<li>Moving a character</li>
				<li>Using <code>Area2D</code> to detect when objects touch</li>
				<li>Using <code>Control</code> nodes to display information</li>
				<li>Communicating between game objects using signals</li>
			</ul>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Technical requirements </h1>
			<p>Download the game assets from the following link below and unzip them into your new project folder: <a href="https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads">https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads</a></p>
			<p>You can also find the complete code for this chapter on GitHub at: <a href="https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter02%20-%20Coin%20Dash">https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter02%20-%20Coin%20Dash</a></p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Setting up the project</h1>
			<p>Launch Godot, and in the Project Manager, click the <strong class="bold">+ New </strong><strong class="bold">Project</strong> button.</p>
			<p>You first<a id="_idIndexMarker054"/> need to create a project folder. Type <code>Coin Dash</code> in the <strong class="bold">Project Name</strong> box and click <strong class="bold">Create Folder</strong>. Creating a folder for your project is important to keep all your project files separate from any other projects on your computer. Next, you can click <strong class="bold">Create &amp; Edit</strong> to open the new project in the Godot editor.</p>
			<div><div><img src="img/B19289_02_02.jpg" alt="Figure 2.2: The new project window"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2: The new project window</p>
			<p>In this project, you’ll make three independent scenes – the player character, the coin, and a display to show the score and clock – all of which will be combined into the game’s “main” scene (see <a href="B19289_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>). In a larger project, it might be useful to create separate folders to organize each scene’s assets and scripts, but for this relatively small game, you can save all of your scenes and scripts in the root folder, which is referred to as <code>res://</code> (res is short for resources). All resources in your project will be located relative to the res:// folder. You can see the project’s files in the <code>icon.svg,</code> which is the Godot icon.</p>
			<p>You can download a ZIP file of the art and sounds (collectively known as <em class="italic">assets</em>) for the game here: <a href="https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition/tree/main/Downloads">https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition/tree/main/Downloads</a>. Unzip this file in the new project folder you created.</p>
			<div><div><img src="img/B19289_02_03.jpg" alt="Figure 2.3: The FileSystem tab"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3: The FileSystem tab</p>
			<p>For example, the<a id="_idIndexMarker055"/> images for the coin are located in <code>res://assets/coin/</code>.</p>
			<p>Since this game will be in portrait mode (taller than it is wide), we’ll start by setting up the game window.</p>
			<p>Click <strong class="bold">Project</strong> -&gt; <strong class="bold">Project Settings</strong> from the menu at the top. The settings window looks like this:</p>
			<div><div><img src="img/B19289_02_04.jpg" alt="Figure 2.4: The Project Settings window"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4: The Project Settings window</p>
			<p>Look for <a id="_idIndexMarker056"/>the <code>480</code> and <code>720</code>, as shown in the preceding figure. Also in this section, under <strong class="bold">Stretch</strong>, set <strong class="bold">Mode</strong> to <strong class="bold">canvas_items</strong> and <strong class="bold">Aspect</strong> to <strong class="bold">keep</strong>. This will ensure that if a user resizes the game window, everything will scale appropriately and not become stretched or deformed. You can also uncheck the <strong class="bold">Resizable</strong> box under <strong class="bold">Size</strong> to prevent the window from being resized at all.</p>
			<p>Congratulations! You’ve set up your new project, and you’re ready to start making your first game. In this game, you’ll make objects that move around in 2D space, so it’s important to understand how objects are positioned and moved using 2D coordinates. In the next section, you’ll learn how that works and how to apply it to your game.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Vectors and 2D coordinate systems</h1>
			<p>This section is a <a id="_idIndexMarker057"/>very brief overview of 2D coordinate systems and vector math as it’s used in game development. Vector math is an essential tool in game development, so if you need a broader understanding of the topic, see Khan Academy’s linear algebra series (<a href="https://www.khanacademy.org/math/linear-algebra">https://www.khanacademy.org/math/linear-algebra</a>).</p>
			<p>When working in 2D, you’ll use Cartesian coordinates to identify locations in the 2D plane. A particular position in 2D space is written as a pair of values, such as <code>(4, 3)</code>, representing the position along the <em class="italic">x</em> and <em class="italic">y</em> axes, respectively. Any position in the 2D plane can be described in this way.</p>
			<p>In 2D space, Godot<a id="_idIndexMarker058"/> follows the common computer graphics practice of orienting the <em class="italic">x</em> axis to the right and the <em class="italic">y</em> axis downward:</p>
			<div><div><img src="img/B19289_02_05.jpg" alt="Figure 2.5: A 2D coordinate system"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5: A 2D coordinate system</p>
			<p class="callout-heading">That’s not what my math teacher taught me!</p>
			<p class="callout">If you’re new to computer graphics or game development, it might seem odd that the positive <em class="italic">y</em> axis points downward instead of upward, which you likely learned in math class. However, this orientation is very common in computer graphics applications.</p>
			<h3>Vectors</h3>
			<p>You can <a id="_idIndexMarker059"/>also think of the <code>(4, 3)</code> position as an <em class="italic">offset</em> from the <code>(0, 0)</code> point, or <em class="italic">origin</em>. Imagine an arrow pointing from the origin to the point:</p>
			<div><div><img src="img/B19289_02_06.jpg" alt="Figure 2.6: A 2D vector"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6: A 2D vector</p>
			<p>This arrow is a <em class="italic">vector</em>. It represents a great deal of useful information, including the point’s location, its distance or <em class="italic">length</em> (<code>m</code>), and its angle from the <em class="italic">x a</em>xis (<code>θ</code>). More specifically, this type of vector is referred to as a <em class="italic">position</em> vector – that is, one that describes a position in space. Vectors can also represent movement, acceleration, or any other<a id="_idIndexMarker060"/> quantity that has a size and a direction.</p>
			<p>In Godot, vectors have a wide array of uses, and you’ll use them in every project in this book.</p>
			<p>You should now have an understanding of how the 2D coordinate space works and how vectors can help to position and move objects. In the next section, you’ll create the player object and use this knowledge to control its movement.</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Part 1 – the player scene</h1>
			<p>The <a id="_idIndexMarker061"/>first scene you’ll make is the player object. One of the benefits of creating a separate scene for the player (and other objects) is that you can test it independently, even before you’ve created other parts of a game. This separation<a id="_idIndexMarker062"/> of game objects will become more and more helpful as your projects grow in size and complexity. Keeping individual game objects separate from each other makes them easier to troubleshoot, modify, and even replace entirely without affecting other parts of the game. It also means your player can be reusable – you can drop this player scene into an entirely different game and it will work just the same.</p>
			<p>Your player scene needs to do the following things:</p>
			<ul>
				<li>Display your character and its animations</li>
				<li>Respond to user input by moving the character</li>
				<li>Detect collisions with other game objects such as coins or obstacles</li>
			</ul>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Creating the scene</h2>
			<p>Start by <a id="_idIndexMarker063"/>clicking the <code>Area2D</code>. Then, click on the node’s name and change it to <code>Player</code>. Click <strong class="bold">Scene</strong> -&gt;<strong class="bold"> Save Scene</strong> (<em class="italic">Ctrl</em> + <em class="italic">S</em>) to save the scene.</p>
			<div><div><img src="img/B19289_02_07.jpg" alt="Figure 2.7: Adding a node"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7: Adding a node</p>
			<p>Take a<a id="_idIndexMarker064"/> look at the <code>player.tscn</code> file now appears. Whenever you save a scene in Godot, it will use the <code>.tscn</code> extension – this is the file format for Godot’s scenes. The “t” in the name stands for “text” because these are text files. Feel free to take a look at it in an external text editor if you’re curious, but you shouldn’t edit one by hand; otherwise, you run the risk of accidentally corrupting the file.</p>
			<p>You’ve now created<a id="_idIndexMarker065"/> the scene’s <code>Area2D</code> because it’s a 2D node, so it can move in 2D space, and it can detect overlap with other nodes, so we’ll be able to detect the coins and other game objects. Choosing which node to use for a particular game object is your first important decision when designing your game objects.</p>
			<p>Before adding any child nodes, it’s a good idea to make sure you don’t accidentally move or resize them by clicking on them. Select the <code>Player</code> node and hover your mouse on the icon next to the lock, <strong class="bold">Group </strong><strong class="bold">Selected Node(s)</strong>:</p>
			<div><div><img src="img/B19289_02_08.jpg" alt="Figure 2.8: Toggle the node grouping"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8: Toggle the node grouping</p>
			<p>The tooltip says <strong class="bold">Make selected node’s children not selectable.</strong>, and that’s good – it will help avoid mistakes. Click the button, and you’ll see the same icon appear next to the player <a id="_idIndexMarker066"/>node’s name:</p>
			<div><div><img src="img/B19289_02_09.jpg" alt="Figure 2.9: The node grouping icon"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9: The node grouping icon</p>
			<p>It’s a good idea to always do this when creating a new scene. If an object’s child nodes become offset or scaled, it can cause unexpected errors and be difficult to troubleshoot.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Sprite animation</h2>
			<p>With <code>Area2D</code>, you<a id="_idIndexMarker067"/> can detect when other objects overlap or run into a player, but <code>Area2D</code> doesn’t have an appearance on its own. You’ll also need a node that can display an image. Since the character has animations, select the player node and add an <code>AnimatedSprite2D</code> node. This node will handle the appearance and animations for the player. Note that there’s a warning symbol next to the node. <code>AnimatedSprite2D</code> requires a <code>SpriteFrames</code> resource, which contains the animation(s) it can display. To create one, find the <strong class="bold">Frames</strong> property in the <strong class="bold">Inspector</strong> window and click on <strong class="bold">&lt;empty&gt;</strong> to see the dropdown. Select <strong class="bold">New SpriteFrames</strong>:</p>
			<div><div><img src="img/B19289_02_10.jpg" alt="Figure 2.10: Adding a SpriteFrames resource"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10: Adding a SpriteFrames resource</p>
			<p>Next, in the same location, click the <code>SpriteFrames</code> label that appeared there to open a new panel at the bottom of the screen:</p>
			<div><div><img src="img/B19289_02_11.jpg" alt="Figure 2.11: The SpriteFrames panel"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11: The SpriteFrames panel</p>
			<p>On <a id="_idIndexMarker068"/>the left is the list of animations. Click the <code>default</code> one and rename it <code>run</code>. Then, click the <code>idle</code> and a third named <code>hurt</code>.</p>
			<p>In the <code>res://assets/player/</code> folder and drag them into the corresponding animations:</p>
			<div><div><img src="img/B19289_02_12.jpg" alt="Figure 2.12: Setting up player animations"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12: Setting up player animations</p>
			<p>Each new animation has a default speed setting of <code>5</code> frames per second. This is a little too slow, so select each of the animations and set <code>8</code>.</p>
			<p>To see the animations in action, click the <strong class="bold">Play</strong> button (<img src="img/B19289_02_13.png" alt=""/>). Your animations will appear in the <strong class="bold">Inspector</strong> window in the dropdown for the <strong class="bold">Animation</strong> property. Choose one to see it in action:</p>
			<div><div><img src="img/B19289_02_14.jpg" alt="Figure 2.13: The Animation property"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13: The Animation property</p>
			<p>You can <a id="_idIndexMarker069"/>also choose an animation to play by default. Select the <code>idle</code> animation and click the <strong class="bold">Autoplay on </strong><strong class="bold">Load</strong> button.</p>
			<div><div><img src="img/B19289_02_15.jpg" alt="Figure 2.14: Setting animation to autoplay"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14: Setting animation to autoplay</p>
			<p>Later, you’ll write code to select between these animations, depending on what the player is doing. However, first, you need to finish setting up the player’s nodes.</p>
			<p>The player image is a bit small, so set the <code>AnimatedSprite2D</code> to <code>(2, 2)</code> in order to increase it in scale. You can find this property under the <strong class="bold">Transform</strong> section in the <strong class="bold">Inspector</strong> window.</p>
			<div><div><img src="img/B19289_02_16.jpg" alt="Figure 2.15: Setting the Scale property"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15: Setting the Scale property</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Collision shape</h2>
			<p>When<a id="_idIndexMarker070"/> using <code>Area2D</code> or one of the other collision objects, you need to tell Godot what the shape of the object is. Its collision shape defines the region it occupies and is used to detect overlaps and/or collisions. Shapes are defined by the various <code>Shape2D</code> types and include rectangles, circles, and polygons. In game development, this is sometimes<a id="_idIndexMarker071"/> referred to as a <strong class="bold">hitbox</strong>.</p>
			<p>For convenience, when you need to add a shape to an area or physics body, you can add <code>CollisionShape2D</code> as a child. Then, you can select the type of shape you want and edit its size in the editor.</p>
			<p>Add <code>CollisionShape2D</code> as a child of the <code>Player</code> node (make sure you don’t add it as a child of <code>AnimatedSprite2D</code>). In the <strong class="bold">Inspector</strong> window, find the <strong class="bold">Shape</strong> property and click <strong class="bold">&lt;empty&gt;</strong> to select <strong class="bold">New RectangleShape2D</strong>.</p>
			<div><div><img src="img/B19289_02_17.jpg" alt="Figure 2.16: Adding a collision shape"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16: Adding a collision shape</p>
			<p>Drag the orange handles to adjust the shape’s size to cover the sprite. Hint – if you hold the <em class="italic">Alt</em> key while dragging a handle, the shape will size symmetrically. You may have noticed that the collision shape is not centered on the sprite. That is because the sprite images themselves are not centered vertically. You can fix this by adding a small offset to <code>AnimatedSprite2D</code>. Select the node and look for the <code>(</code><code>0, -5)</code>.</p>
			<div><div><img src="img/B19289_02_18.jpg" alt="Figure 2.17: Sizing the collision shape"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.17: Sizing the collision shape</p>
			<p>When<a id="_idIndexMarker072"/> you’re finished, your <strong class="bold">Player</strong> scene should look like this:</p>
			<div><div><img src="img/B19289_02_19.jpg" alt="Figure 2.18: The Player node setup"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.18: The Player node setup</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Scripting the player</h2>
			<p>Now, you’re<a id="_idIndexMarker073"/> ready to add some code to the player. Attaching a script to a node allows you to add additional functionality that isn’t provided by the node itself. Select the <code>Player</code> node and click the <strong class="bold">new </strong><strong class="bold">script</strong> button:</p>
			<div><div><img src="img/B19289_02_20.jpg" alt="Figure 2.19: The new script button"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.19: The new script button</p>
			<p>In the <strong class="bold">Attach Node Script</strong> window, you can leave the default settings as they are. If you’ve remembered to save the scene, the script will be automatically named to match the scene’s name. Click <strong class="bold">Create</strong>, and you’ll be taken to the script window. Your script will contain some default comments and hints.</p>
			<p>The first <a id="_idIndexMarker074"/>line of every script describes what type of node it is attached to. Just after that, you can start defining your variables:</p>
			<pre class="source-code">
extends Area2D
@export var speed = 350
var velocity = Vector2.ZERO
var screensize = Vector2(480, 720)</pre>
			<p>Using the <code>@export</code> annotation on the <code>speed</code> variable allows you to set its value in the <code>Player</code> node, and you’ll see the <code>350</code> speed value you wrote in the script.</p>
			<div><div><img src="img/B19289_02_21.jpg" alt="Figure 2.20: The exported variable in the Inspector window"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.20: The exported variable in the Inspector window</p>
			<p>As for the<a id="_idIndexMarker075"/> other variables, <code>velocity</code> will contain the character’s movement speed and direction, while <code>screensize</code> will help set the limits of the character’s movement. Later, you’ll set this value automatically from the game’s main scene, but for now, setting it manually will allow you to test that everything is working.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Moving the player</h2>
			<p>Next, you’ll <a id="_idIndexMarker076"/>use the <code>_process()</code> function to define what the player will do. The <code>_process()</code> function is called on every frame, so you can use it to update elements of your game that you expect to change often. In each frame, you need the player to do three things:</p>
			<ul>
				<li>Check for keyboard input</li>
				<li>Move in the given direction</li>
				<li>Play the appropriate animation</li>
			</ul>
			<p>First, you need to check the inputs. For this game, you have four directional inputs to check (the four arrow keys). Input actions are defined in <strong class="bold">Project Settings</strong> under the <strong class="bold">Input Map</strong> tab. In this tab, you can define custom events and assign keys, mouse actions, or other inputs to them. By default, Godot has events assigned to the keyboard arrows, so you can use them for this project.</p>
			<p>You can detect whether an input action is pressed using <code>Input.is_action_pressed()</code>, which returns <code>true</code> if a key is held down and <code>false</code> if it is not. Combining the states of all four keys will give you the resulting direction of movement.</p>
			<p>You can do<a id="_idIndexMarker077"/> this by checking all four keys separately using multiple <code>if</code> statements, but since this is such a common need, Godot provides a useful function called <code>Input.get_vector()</code> that will handle this for you – you just have to tell it which four inputs to use. Note the order that the input actions are listed in; <code>get_vector()</code> expects them in this order. The result of this function is <a id="_idIndexMarker078"/>a <strong class="bold">direction vector</strong> – a vector pointing in one of the eight possible directions resulting from the pressed inputs:</p>
			<pre class="source-code">
func _process(delta):
    velocity = Input.get_vector("ui_left", "ui_right",
        "ui_up", "ui_down")
    position += velocity * speed * delta</pre>
			<p>After that, you’ll have a <code>velocity</code> vector indicating which direction to move in, so the next step will be to actually update the player’s <code>position</code> using that velocity.</p>
			<p>Click <strong class="bold">Run Current Scene</strong> (<em class="italic">F6</em>) at the top right, and check that you can move the player around using all four arrow keys.</p>
			<p>You may notice that the player continues running off the side of the screen. You can use the <code>clamp()</code> function to limit the player’s <code>position</code> to minimum and maximum values, preventing them from leaving the screen. Add these two lines next, immediately after the previous line:</p>
			<pre class="source-code">
    position.x = clamp(position.x, 0, screensize.x)
    position.y = clamp(position.y, 0, screensize.y)</pre>
			<h3>About delta</h3>
			<p>The <code>_process()</code> function <a id="_idIndexMarker079"/>includes a parameter called <code>delta</code> that is then multiplied by <code>velocity</code>. What is <code>delta</code>?</p>
			<p>The game engine attempts to run at a constant <code>60</code> frames per second. However, this can change due to computer slowdowns, either in Godot or from other programs running on your computer at the same time. If the frame rate is not consistent, then it will affect the movement of objects in your game. For example, consider an object that you want to move at <code>10</code> pixels every frame. If everything runs smoothly, this will mean the object moves <code>600</code> pixels in one second. However, if some of those frames take a bit longer, then there may have been only <code>50</code> frames in that second, so the object only moved <code>500</code> pixels.</p>
			<p>Godot, like many game<a id="_idIndexMarker080"/> engines and frameworks, solves this by passing you a value called <code>delta</code>, which is the elapsed time since the previous frame. Most of the time, this will be very close to <code>0.016</code> seconds (around 16 milliseconds). If you then take your desired speed of <code>600</code> px/second and multiply it by <code>delta</code>, you’ll get a movement of exactly <code>10</code> pixels. If, however, <code>delta</code> increased to <code>0.3</code> seconds, then the object would move <code>18</code> pixels. Overall, the movement speed remains consistent and independent of the frame rate.</p>
			<p>As a side benefit, you can express your movement in units of pixels per second rather than pixels per frame, which is easier to visualize.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Choosing animations</h2>
			<p>Now that the <a id="_idIndexMarker081"/>player can move, you need to change which animation <code>AnimatedSprite2D</code> is playing, based on whether the player moves or stands still. The art for the <code>run</code> animation faces to the right, which means it needs to be flipped horizontally (using the <code>_process()</code> function after the movement code:</p>
			<pre class="source-code">
if velocity.length() &gt; 0:
    $AnimatedSprite2D.animation = "run"
else:
    $AnimatedSprite2D.animation = "idle"
if velocity.x != 0:
    $AnimatedSprite2D.flip_h = velocity.x &lt; 0</pre>
			<p class="callout-heading">Getting nodes</p>
			<p class="callout">When using the <code>$</code> notation, the node name is <em class="italic">relative</em> to the node running the script. For example, <code>$Node1/Node2</code> would refer to a node (<code>Node2</code>) that is a child of <code>Node1</code>, which is itself a child of the node that runs the script. Godot’s autocomplete will suggest node names as you type. Note that if the name contains spaces, you must put quote marks around it – for example, <code>$"</code><code>My Node"</code>.</p>
			<p>Note <a id="_idIndexMarker082"/>that this code takes a little shortcut. <code>flip_h</code> is a Boolean property, which means it can be <code>true</code> or <code>false</code>. A Boolean value is also the result of a comparison, such as <code>&lt;</code>. Because of this, you can directly set the property equal to the result of the comparison.</p>
			<p>Play the scene again and check that the animations are correct in each case. </p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Starting and ending the player’s movement</h2>
			<p>The main <a id="_idIndexMarker083"/>scene will need to inform the player when the game has started and ended. To do that, add a <code>start()</code> function to the player, which<a id="_idIndexMarker084"/> will set the player’s starting position and animation:</p>
			<pre class="source-code">
func start():
    set_process(true)
    position = screensize / 2
    $AnimatedSprite2D.animation = "idle"</pre>
			<p>Also, add a <code>die()</code> function to be called when the player hits an obstacle or runs out of time:</p>
			<pre class="source-code">
func die():
    $AnimatedSprite2D.animation = "hurt"
    set_process(false)</pre>
			<p>Using <code>set_process(false)</code> tells Godot to stop calling the <code>_process()</code> function every frame. Since the movement code is in that function, you’ll no longer be able to move when the game is over.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Preparing for collisions</h2>
			<p>The <a id="_idIndexMarker085"/>player should detect when it hits a coin or an obstacle, but you haven’t made those objects yet. That’s OK because you can use Godot’s <em class="italic">signal</em> functionality to make it work. Signals are a way for nodes to send out messages that other nodes can detect and react to. Many nodes have built-in signals to alert you when events occur, such as a body colliding or a button being pressed. You can also define custom signals for your own purposes.</p>
			<p>Signals are used by <em class="italic">connecting</em> them to the node(s) that you want to listen for them. This connection can be made in the <strong class="bold">Inspector</strong> window or in code. Later in the project, you’ll learn how to connect signals in both ways.</p>
			<p>Add the following lines to the top of the script (after <code>extends Area2D</code>):</p>
			<pre class="source-code">
signal pickup
signal hurt</pre>
			<p>These lines declare custom signals that your player will <code>Area2D</code> itself. Select the <code>Player</code> node, and click the <strong class="bold">Node</strong> tab next to the <strong class="bold">Inspector</strong> tab to see a list of signals the player can emit:</p>
			<div><div><img src="img/B19289_02_22.jpg" alt="Figure 2.21: The node’s list of signals"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.21: The node’s list of signals</p>
			<p>Note your custom signals there as well. Since the other objects will also be <code>Area2D</code> nodes, you’ll want to use the <code>area_entered</code> signal. Select it and click <code>_on_area_entered()</code> in your script.</p>
			<p>When <a id="_idIndexMarker086"/>connecting a signal, instead of having Godot create the function for you, you can also give the name of an existing function that you want to use instead. Toggle the <strong class="bold">Make Function</strong> switch off if you don’t want Godot to create the function for you.</p>
			<p>Add the following code to this new function:</p>
			<pre class="source-code">
func _on_area_entered(area):
    if area.is_in_group("coins"):
        area.pickup()
        pickup.emit()
    if area.is_in_group("obstacles"):
        hurt.emit()
        die()</pre>
			<p>Whenever another area object overlaps with the player, this function will be called, and that overlapping area will be passed in with the <code>area</code> parameter. The coin object will have a <code>pickup()</code> function that defines what the coin does when picked up (playing an animation or sound, for example). When you create the coins and obstacles, you’ll assign them to the appropriate <strong class="bold">group</strong> so that they can be detected correctly.</p>
			<p>To summarize, here is the complete player script so far:</p>
			<pre class="source-code">
extends Area2D
signal pickup
signal hurt
@export var speed = 350
var velocity = Vector2.ZERO
var screensize = Vector2(480, 720)
func _process(delta):
    # Get a vector representing the player's input
    # Then move and clamp the position inside the screen
    velocity = Input.get_vector("ui_left", "ui_right",
        "ui_up", "ui_down")
    position += velocity * speed * delta
    position.x = clamp(position.x, 0, screensize.x)
    position.y = clamp(position.y, 0, screensize.y)
    # Choose which animation to play
    if velocity.length() &gt; 0:
        $AnimatedSprite2D.animation = "run"
    else:
        $AnimatedSprite2D.animation = "idle"
    if velocity.x != 0:
        $AnimatedSprite2D.flip_h = velocity.x &lt; 0
func start():
    # This function resets the player for a new game
    set_process(true)
    position = screensize / 2
    $AnimatedSprite2D.animation = "idle"
func die():
    # We call this function when the player dies
    $AnimatedSprite2D.animation = "hurt"
    set_process(false)
func _on_area_entered(area):
    # When we hit an object, decide what to do
    if area.is_in_group("coins"):
        area.pickup()
        pickup.emit()
    if area.is_in_group("obstacles"):
        hurt.emit()
        die()</pre>
			<p>You’ve <a id="_idIndexMarker087"/>completed setting up the player object, and you’ve tested that the movement and animations work correctly. Before you move on to the next step, review the player scene setup and the script, and make sure you understand what you’ve done and why. In the next section, you’ll make some objects for the player to collect.</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Part 2 – the coin scene</h1>
			<p>In this part, you’ll<a id="_idIndexMarker088"/> make<a id="_idIndexMarker089"/> coins for the player to collect. This will be a separate scene, describing all the properties and behavior of a single coin. Once saved, the main scene will load this one and create multiple <strong class="bold">instances</strong> (that is, copies) of it.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>The node setup</h2>
			<p>Click <code>Player</code> scene:</p>
			<ul>
				<li><code>Area2D</code> (named <code>Coin</code>):<ul><li><code>AnimatedSprite2D</code></li><li><code>CollisionShape2D</code></li></ul></li>
			</ul>
			<p>Make sure to save the scene once you’ve added the nodes.</p>
			<p>Set up <code>AnimatedSprite2D</code> as you did in the player scene. This time, you only have one animation – a shine/sparkle effect that makes the coin look dynamic and interesting. Add all the frames and set the animation speed to <code>12 FPS</code>. The images are also a little too large, so set the <code>AnimatedSprite2D</code> to <code>(0.4, 0.4)</code>. In <code>CollisionShape2D</code>, use <code>CircleShape2D</code> and resize it to cover the coin image.</p>
			<h3>Using groups</h3>
			<p>Groups provide<a id="_idIndexMarker091"/> a tagging system for nodes, allowing you to identify similar nodes. A node can belong to any number of groups. In order for the player script to correctly detect a coin, you need to ensure that all coins will be in a group called <code>Coin</code> node, click the <code>coins</code> in the box and click <strong class="bold">Add</strong>:</p>
			<div><div><img src="img/B19289_02_23.jpg" alt="Figure 2.22: The Groups tab"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.22: The Groups tab</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Coin script</h2>
			<p>Your<a id="_idIndexMarker092"/> next step is to add a script to the <code>Coin</code> node. Select the node and click the new script button, just like you did with the <code>Player</code> node. If you uncheck the <strong class="bold">Template</strong> option, you’ll get an empty script without any comments or suggestions. The code for the coin is much shorter than the code for the player:</p>
			<pre class="source-code">
extends Area2D
var screensize = Vector2.ZERO
func pickup():
    queue_free()</pre>
			<p>Recall that the <code>pickup()</code> function is called by the player script. It defines what the coin will do when collected. <code>queue_free()</code> is Godot’s method for removing nodes. It safely removes the node from the tree and deletes it from memory, along with all its children. Later, you’ll add visual and audio effects here, but for now, just having the coin disappear is good enough.</p>
			<p class="callout-heading">Removing nodes</p>
			<p class="callout"><code>queue_free()</code> doesn’t delete the object immediately, but rather adds it to a queue to be deleted at the end of the current frame. This is safer than immediately deleting the node because other code running in the game may still need the node to exist. By waiting until the end of the frame, Godot can be sure that all code that can access the node has completed and the node can be removed safely.</p>
			<p>You’ve now <a id="_idIndexMarker093"/>completed the second of the two objects needed for this game. The coin object is ready to be placed randomly on the screen, and it can detect when it’s touched by the player, so it can be collected. The remaining piece of the puzzle is how to put it all together. In the next section, you’ll create a third scene to randomly create coins and allow the player to interact with them.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Part 3 – the Main scene</h1>
			<p>The <code>Main</code> scene is <a id="_idIndexMarker094"/>what ties all the pieces of the game together. It <a id="_idIndexMarker095"/>will manage the player, the coins, the clock, and all the other pieces of the game.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Node setup</h2>
			<p>Create a <a id="_idIndexMarker096"/>new scene and add a <code>Node</code> named <code>Main</code>. The simplest type of node is <code>Node</code> – it doesn’t do much at all on its own, but you’ll use it as the parent for all the game objects and add a script that will give it the functionality you need. Save the scene.</p>
			<p>Add the player as a child of <code>Main</code> by clicking the <code>player.tscn</code>:</p>
			<div><div><img src="img/B19289_02_24.jpg" alt="Figure 2.23: Instantiating a scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.23: Instantiating a scene</p>
			<p>Add the following nodes as children of <code>Main</code>:</p>
			<ul>
				<li>A <code>TextureRect</code> node named <code>Background</code> – for the background image</li>
				<li>A <code>Timer</code> node named <code>GameTimer</code> – for the countdown timer</li>
			</ul>
			<p>Make sure <code>Background</code> is the first child node by dragging it above the player in the node list. Nodes are drawn in the order shown in the tree, so if <code>Background</code> is first, that ensures<a id="_idIndexMarker097"/> it’s drawn behind the player. Add an image to the <code>Background</code> node by dragging the <code>grass.png</code> image from the <code>assets</code> folder into the <strong class="bold">Texture</strong> property. Change <strong class="bold">Stretch Mode</strong> to <strong class="bold">Tile</strong>, and then set the size to <strong class="bold">Full Rect</strong> by clicking the layout button at the top of the editor window:</p>
			<div><div><img src="img/B19289_02_25.jpg" alt="Figure 2.24: Layout options"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.24: Layout options</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Main script</h2>
			<p>Add a script<a id="_idIndexMarker098"/> to the <code>Main</code> node and add the following variables:</p>
			<pre class="source-code">
extends Node
@export var coin_scene : PackedScene
@export var playtime = 30
var level = 1
var score = 0
var time_left = 0
var screensize = Vector2.ZERO
var playing = false</pre>
			<p>The <code>Main</code> node. Drag <code>coin.tscn</code> from the <strong class="bold">FileSystem</strong> panel and drop it into the <strong class="bold">Coin </strong><strong class="bold">Scene</strong> property.</p>
			<h3>Initializing</h3>
			<p>To start <a id="_idIndexMarker100"/>things off, add the <code>_ready()</code> function:</p>
			<pre class="source-code">
func _ready():
    screensize = get_viewport().get_visible_rect().size
    $Player.screensize = screensize
    $Player.hide()</pre>
			<p>Godot automatically calls <code>_ready()</code> on every node when it’s added. This is a good place to put code that you want to happen at the beginning of a node’s lifetime.</p>
			<p>Note that you’re referring to the <code>Player</code> node by name using the <code>$</code> syntax, allowing you to find the size of the game screen and set the player’s <code>screensize</code> variable. <code>hide()</code> makes a node invisible, so you won’t see the player before the game starts.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>Starting a new game</h2>
			<p>The <code>new_game()</code> function <a id="_idIndexMarker101"/>will initialize everything for a new game:</p>
			<pre class="source-code">
func new_game():
    playing = true
    level = 1
    score = 0
    time_left = playtime
    $Player.start()
    $Player.show()
    $GameTimer.start()
    spawn_coins()</pre>
			<p>In addition to<a id="_idIndexMarker102"/> setting the variables to their starting values, this function calls the player’s <code>start()</code> function that you wrote earlier. Starting <code>GameTimer</code> will start counting down the remaining time in the game.</p>
			<p>You also need a function that will create a number of coins based on the current level:</p>
			<pre class="source-code">
func spawn_coins():
    for i in level + 4:
        var c = coin_scene.instantiate()
        add_child(c)
        c.screensize = screensize
        c.position = Vector2(randi_range(0, screensize.x),
            randi_range(0, screensize.y))</pre>
			<p>In this function, you create multiple <code>Coin</code> object and add them as children of <code>Main</code> (in code this time, rather than by manually clicking on the <code>add_child()</code>. Lastly, you choose a random position for the coin, using the <code>screensize</code> variable so that they won’t appear off screen. You’ll call this function at the start of every level, generating more coins each time.</p>
			<p>Eventually, you’ll want <code>new_game()</code> to be called when the player clicks the <code>new_game()</code> to the end of your <code>_ready()</code> function and click <code>main.tscn</code>. Now, whenever you play the project, the <code>Main</code> scene will be started.</p>
			<p>At this point, you should see your player and five coins appear on the screen. When the player touches a coin, it disappears.</p>
			<p>Once you’re done testing, remove <code>new_game()</code> from the <code>_ready()</code> function.</p>
			<h3>Checking for remaining coins</h3>
			<p>The <code>main</code> script <a id="_idIndexMarker103"/>needs to detect whether the player has picked up all the coins. Since the coins are all in the <code>coins</code> group, you can check the size of the group to see how many remain. Since it needs to be checked continuously, put it in the <code>_process()</code> function:</p>
			<pre class="source-code">
func _process(delta):
    if playing and
    get_tree().get_nodes_in_group("coins").size() == 0:
        level += 1
        time_left += 5
        spawn_coins()</pre>
			<p>If no more coins remain, then the player advances to the next level.</p>
			<p>This completes the main scene. The most important thing you learned in this step was how to dynamically create new objects in code using <code>instantiate()</code>. This is something that you will use again and again in building many types of game systems. In the last step, you’ll create one more scene to handle displaying game information, such as the player’s score and the time remaining.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/>Part 4 – the user interface</h1>
			<p>The<a id="_idIndexMarker104"/> final element <a id="_idIndexMarker105"/>your game needs is a <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>). This will display information that the player needs to see during gameplay, which is often referred to as a <strong class="bold">heads-up display</strong> (<strong class="bold">HUD</strong>) because<a id="_idIndexMarker106"/> the information appears as an overlay on top of the game view. You’ll also use this scene to display a start button after the game ends.</p>
			<p>Your HUD will display the following information:</p>
			<ul>
				<li>The score</li>
				<li>The time remaining</li>
				<li>A message, such as <strong class="bold">Game Over</strong></li>
				<li>A start button</li>
			</ul>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>Node setup</h2>
			<p>Create a<a id="_idIndexMarker107"/> new scene and add a <code>CanvasLayer</code> node named <code>HUD</code>. A <code>CanvasLayer</code> node creates a new drawing layer, which will allow you to draw your UI elements above the rest of the game so that it doesn’t get covered up by game objects, such as the player or coins.</p>
			<p>Godot provides a variety of UI elements that can be used to create anything from indicators, such as health bars, to complex interfaces, such as inventories. In fact, the Godot editor that you use to make this game is built using the Godot UI elements. The basic nodes for a UI are all extended from <code>Control</code> and appear with green icons in the node list. To create your UI, you’ll use various <code>Control</code> nodes to position, format, and display information. Here’s what the HUD will look like when complete:</p>
			<div><div><img src="img/B19289_02_26.jpg" alt="Figure 2.25: The HUD layout"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.25: The HUD layout</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Message label</h2>
			<p>Add a <code>Label</code> node <a id="_idIndexMarker108"/>to the scene and change its name to <code>Message</code>. This label will display the game’s title as well as <strong class="bold">Game Over</strong> when the game ends. This label should be centered on the game screen. You can drag it with the mouse, or set the values directly in the <strong class="bold">Inspector</strong> window, but it’s easiest to use the shortcuts provided in the layout menu, which will set the values for you.</p>
			<p>Select <strong class="bold">HCenter Wide</strong> from the layout menu:</p>
			<div><div><img src="img/B19289_02_27.jpg" alt="Figure 2.26: Positioning the message"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.26: Positioning the message</p>
			<p>The label now<a id="_idIndexMarker109"/> spans the width of the screen and is centered vertically. The <strong class="bold">Text</strong> property sets what text the label displays. Set it to <strong class="bold">Coin Dash!</strong>, and set <strong class="bold">Horizontal Alignment</strong> and <strong class="bold">Vertical Alignment</strong> both to <strong class="bold">Center</strong>.</p>
			<p>The default font for <code>Label</code> nodes is very small and unattractive, so the next step is to assign a custom font. In the <strong class="bold">Label Settings</strong> property, select <strong class="bold">New LabelSettings</strong> and then click it to expand.</p>
			<p>From the <code>Kenney Bold.ttf</code> font file and drop it into the <strong class="bold">Font</strong> property, and then set <strong class="bold">Size</strong> to <strong class="bold">48</strong>. You can also improve the appearance by adding a shadow – try the settings shown in the following screenshot, or experiment with your own:</p>
			<div><div><img src="img/B19289_02_28.jpg" alt="Figure 2.27: Font settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.27: Font settings</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Score and time display</h2>
			<p>The<a id="_idIndexMarker110"/> top of the HUD will display the player’s score and the time remaining on the clock. Both of these will be <code>Label</code> nodes, arranged at opposite sides of the game screen. Rather than position them separately, you’ll use a <strong class="bold">container</strong> node to manage their positions.</p>
			<h3>Containers</h3>
			<p>Godot’s <code>Container</code> nodes<a id="_idIndexMarker111"/> automatically arrange the positions and sizes of their child <code>Control</code> nodes (including other containers). You can use them to add padding around elements, keep them centered, or arrange them in rows and columns. Each type of <code>Container</code> has special properties that control how they arrange their children.</p>
			<p>Remember that containers automatically arrange their children. If you try to move or resize a <code>Control</code> that’s inside a <code>Container</code> node, you’ll get a warning from the editor. You can manually arrange controls <em class="italic">or</em> arrange them with a container, but not both.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Score and time display</h2>
			<p>To <a id="_idIndexMarker112"/>manage the score and time labels, add a <code>MarginContainer</code> node to the <code>HUD</code>. Use the layout menu to set the anchors to <code>10</code>. This will add some padding so that the text isn’t against the edge of the screen.</p>
			<p>Since the score and time labels will use the same font settings as <code>Message</code>, you can save time by duplicating it. Select <code>Message</code> and press <em class="italic">Ctrl</em> + <em class="italic">D</em> twice to create two duplicate labels. Drag them both and drop them onto <code>MarginContainer</code> to make them its children. Name one child <code>Score</code> and the other <code>Time</code>, and set the <code>Score</code> but <code>Time</code>.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>Updating the UI via GDScript</h2>
			<p>Add a <a id="_idIndexMarker113"/>script to the <code>HUD</code> node. This script will update the UI elements when their properties need to change, such as updating the <code>Score</code> text whenever a coin is collected. See the following code:</p>
			<pre class="source-code">
extends CanvasLayer
signal start_game
func update_score(value):
    $MarginContainer/Score.text = str(value)
func update_timer(value):
    $MarginContainer/Time.text = str(value)</pre>
			<p>The <code>Main</code> scene’s script will call these two functions to update the display whenever there is a change in a value. For the <code>Message</code> label, you also need a timer to make it disappear after a brief period.</p>
			<p>Add a <code>Timer</code> node as a child of <code>HUD</code>, and set <code>2</code> seconds and <strong class="bold">One Shot</strong> to <strong class="bold">On</strong>. This ensures that, when started, the timer will only run once, rather than repeating. Add the following code:</p>
			<pre class="source-code">
func show_message(text):
    $Message.text = text
    $Message.show()
    $Timer.start()</pre>
			<p>In this function, you will display the message and start the timer. To hide the message, connect the <code>timeout</code> signal of <code>Timer</code> (remember that it will automatically create the new function):</p>
			<pre class="source-code">
func _on_timer_timeout():
    $Message.hide()</pre>
			<h3>Using buttons</h3>
			<p>Add <a id="_idIndexMarker114"/>a <code>Button</code> node to <code>HUD</code> and change its name to <code>StartButton</code>. This button will be displayed before the game starts, and when clicked, it will hide itself and send a signal to the <code>Main</code> scene to start the game. Set the <code>Message</code>.</p>
			<p>In the layout menu, choose <strong class="bold">Center Bottom</strong> to center the button at the bottom of the screen.</p>
			<p>When a button is pressed, it emits a signal. In the <code>StartButton</code>, connect the <code>pressed</code> signal:</p>
			<pre class="source-code">
func _on_start_button_pressed():
    $StartButton.hide()
    $Message.hide()
    start_game.emit()</pre>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Game over</h2>
			<p>The final <a id="_idIndexMarker115"/>task for your UI script is to react to the game ending:</p>
			<pre class="source-code">
func show_game_over():
    show_message("Game Over")
    await $Timer.timeout
    $StartButton.show()
    $Message.text = "Coin Dash!"
    $Message.show()</pre>
			<p>In this function, you need the <code>show_message("Game Over")</code> does. However, you then want to show the start button and game title once the message has disappeared. The <code>await</code> command pauses the execution of a function until the given node (<code>Timer</code>) emits a given signal (<code>timeout</code>). Once the signal is received, the function continues, and everything will be returned to its initial state so that you can play again.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Adding HUD to Main</h2>
			<p>The <a id="_idIndexMarker116"/>next task is to set up the communication between <code>Main</code> and <code>HUD</code>. Add an instance of <code>HUD</code> to <code>Main</code>. In <code>Main</code>, connect the <code>timeout</code> signal of <code>GameTimer</code> and add the following so that every time <code>GameTimer</code> times out (every second), the remaining time is reduced:</p>
			<pre class="source-code">
func _on_game_timer_timeout():
    time_left -= 1
    $HUD.update_timer(time_left)
    if time_left &lt;= 0:
        game_over()</pre>
			<p>Next, select the instance of <code>Player</code> in <code>Main</code> and connect its <code>pickup</code> and <code>hurt</code> signals:</p>
			<pre class="source-code">
func _on_player_hurt():
    game_over()
func _on_player_pickup():
    score += 1
    $HUD.update_score(score)</pre>
			<p>Several things need to happen when the game ends, so add the following function:</p>
			<pre class="source-code">
func game_over():
    playing = false
    $GameTimer.stop()
    get_tree().call_group("coins", "queue_free")
    $HUD.show_game_over()
    $Player.die()</pre>
			<p>This function halts the game and also uses <code>call_group()</code> to remove all remaining coins by calling <code>queue_free()</code> on each of them.</p>
			<p>Finally, pressing <code>StartButton</code> needs to activate <code>Main</code>’s <code>new_game()</code> function. Select the instance of <code>HUD</code> and connect its <code>start_game</code> signal:</p>
			<pre class="source-code">
func _on_hud_start_game():
    new_game()</pre>
			<p>Make <a id="_idIndexMarker117"/>sure you’ve removed <code>new_game()</code> from <code>Main</code>’s <code>_ready()</code> function (remember, that was only there to test), and add these two lines to <code>new_game()</code>:</p>
			<pre class="source-code">
$HUD.update_score(score)
$HUD.update_timer(time_left)</pre>
			<p>Now, you can play the game! Confirm that all parts are working as intended – the score, the countdown, the game ending and restarting, and so on. If you find a part that’s not working, go back and check the step where you created it, as well as the step(s) where it may have been connected to the rest of the game. A common mistake is to forget to connect one of the many signals you used in different parts of the game.</p>
			<p>Once you’ve played the game and confirmed that everything works correctly, you can move on to the next section, where you can add a few additional features to round out the game experience.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Part 5 – finishing up</h1>
			<p>Congratulations on creating a complete, working game! In this section, you’ll add a few extra things to the game to make it a little more exciting. Game developers use the term <strong class="bold">juice</strong> to describe the things that make a game feel good to play. Juice can include things such as sound, visual effects, or any other addition that adds to the player’s enjoyment, without necessarily changing the nature of the gameplay.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Visual effects</h2>
			<p>When<a id="_idIndexMarker118"/> you pick up the coins, they just disappear, which is not very appealing. Adding a visual effect will make it much more satisfying to collect lots of coins.</p>
			<h3>What is a tween?</h3>
			<p>A <strong class="bold">tween</strong> is a <a id="_idIndexMarker119"/>way to <strong class="bold">interpolate</strong> (change gradually) some value over time using a particular mathematical function. For example, you might choose a function that steadily changes a value or one that starts slow but ramps up in speed. Tweening is also sometimes referred to<a id="_idIndexMarker120"/> as <strong class="bold">easing</strong>. You can see animated examples of lots of tweening functions at https://easings.net/.</p>
			<p>When using a tween in Godot, you can assign it to alter one or more properties of a node. In this case, you’re going to increase the scale of the coin and also cause it to fade out using the <strong class="bold">Modulate</strong> property. Once the tween has finished its job, the coin will be deleted.</p>
			<p>However, there’s a problem. If we don’t remove the coin immediately, then it’s possible for the player to move onto the coin again – triggering the <code>area_entered</code> signal a second time and registering it as a second pickup. To prevent this, you can disable the collision shape so that the coin can’t trigger any further collisions.</p>
			<p>Your new <code>pickup()</code> function should look like this:</p>
			<pre class="source-code">
func pickup():
    $CollisionShape2d.set_deferred("disabled", true)
    var tw = create_tween().set_parallel().
        set_trans(Tween.TRANS_QUAD)
    tw.tween_property(self, "scale", scale * 3, 0.3)
    tw.tween_property(self, "modulate:a", 0.0, 0.3)
    await tw.finished
    queue_free()</pre>
			<p>That’s a lot of new code, so let’s break it down:</p>
			<p>First, <code>CollisionShape2D</code>’s <code>disabled</code> property needs to be set to <code>true</code>. However, if you try setting it directly, Godot will complain. You’re not allowed to change physics properties while collisions are being processed; you have to wait until the end of the current frame. That’s what <code>set_deferred()</code> does.</p>
			<p>Next, <code>create_tween()</code> creates a tween object, <code>set_parallel()</code> says that any following tweens should <a id="_idIndexMarker121"/>happen at the same time, instead of one after another, and <code>set_trans()</code> sets the transition function to the “quadratic” curve.</p>
			<p>After that come two lines that set up the tweening of the properties. <code>tween_property()</code> takes four parameters – the object to affect (<code>self</code>), the property to change, the ending value, and the duration (in seconds).</p>
			<p>Now, when you run the game, you should see the coins playing the effect when they’re picked up.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Sound</h2>
			<p>Sound is <a id="_idIndexMarker122"/>an important but often neglected piece of game design. Good sound design can add a huge amount of juice to your game for a very small amount of effort. Sounds can give a player feedback, connect them emotionally to the characters, or even be a direct part of gameplay (“you hear footsteps behind you”).</p>
			<p>For this game, you’re going to add three sound effects. In the <code>Main</code> scene, add three <code>AudioStreamPlayer</code> nodes and name them <code>CoinSound</code>, <code>LevelSound</code>, and <code>EndSound</code>. Drag each sound from the <code>res://assets/audio/</code> folder into the corresponding node’s <strong class="bold">Stream</strong> property.</p>
			<p>To play a sound, you call the <code>play()</code> function on the node. Add each of the following lines to play the sounds at the appropriate times:</p>
			<ul>
				<li><code>$CoinSound.play()</code> to <code>_on_player_pickup()</code></li>
				<li><code>$EndSound.play()</code> to <code>game_over()</code></li>
				<li><code>$LevelSound.play()</code> to <code>spawn_coins()</code> (but not inside the loop!)</li>
			</ul>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>Powerups</h2>
			<p>There <a id="_idIndexMarker123"/>are many possibilities for objects that give the player a small advantage or powerup. In this section, you’ll add a powerup item that gives the player a small time bonus when collected. It will appear occasionally for a short time, and then disappear.</p>
			<p>The new scene will be very similar to the <code>Coin</code> scene you already created, so click on your <code>Coin</code> scene and choose <code>powerup.tscn</code>. Change the name of the root node to <code>Powerup</code> and remove the script by clicking the <strong class="bold">Detach script</strong> button – <strong class="bold">&lt;</strong><strong class="bold">IMG&gt;</strong>.</p>
			<p>In the <code>coins</code> group by clicking the trash can button and add a new group called <code>powerups</code> instead.</p>
			<p>In <code>AnimatedSprite2D</code>, change the images from the coin to the powerup, which you can find in the <code>res://assets/pow/</code> folder.</p>
			<p>Click to add a new script and copy the code from the <code>coin.gd</code> script.</p>
			<p>Next, add a <code>Timer</code> node named <code>Lifetime</code>. This will limit the amount of time the object remains on the screen. Set its <code>2</code> and both <code>timeout</code> signal so that the powerup can be removed at the end of the time period:</p>
			<pre class="source-code">
func _on_lifetime_timout():
    queue_free()</pre>
			<p>Now, go to your <code>Main</code> scene and add another <code>Timer</code> node called <code>PowerupTimer</code>. Set its <code>Powerup.wav</code> sound in the <code>audio</code> folder that you can add with another <code>AudioStreamPlayer</code>. Connect the <code>timeout</code> signal and add the following to spawn a powerup:</p>
			<pre class="source-code">
func _on_powerup_timer_timeout():
    var p = powerup_scene.instantiate()
    add_child(p)
    p.screensize = screensize
    p.position = Vector2(randi_range(0, screensize.x),
        randi_range(0, screensize.y))</pre>
			<p>The <code>Powerup</code> scene needs to be linked to a variable, as you did with the <code>Coin</code> scene, so add the following line at the top of <code>main.gd</code> and then drag <code>powerup.tscn</code> into the new property:</p>
			<pre class="source-code">
@export var powerup_scene : PackedScene</pre>
			<p>The<a id="_idIndexMarker124"/> powerups should appear unpredictably, so the wait time of <code>PowerupTimer</code> needs to be set whenever you begin a new level. Add this to the <code>_process()</code> function after the new coins are spawned with <code>spawn_coins()</code>:</p>
			<p>Now, you will have powerups appearing; the last step is to give the player the ability to collect them. Currently, the player script assumes that anything it runs into is either a coin or an obstacle. Change the code in <code>player.gd</code> to check what kind of object has been hit:</p>
			<pre class="source-code">
func _on_area_entered(area):
    if area.is_in_group("coins"):
        area.pickup()
        pickup.emit("coin")
    if area.is_in_group("powerups"):
        area.pickup()
        pickup.emit("powerup")
    if area.is_in_group("obstacles"):
        hurt.emit()
        die()</pre>
			<p>Note that now you emit the <code>pickup</code> signal with an additional argument that names the type of object. The corresponding function in <code>main.gd</code> must now be changed to accept that argument and decide what action to take:</p>
			<pre class="source-code">
func _on_player_pickup(type):
    match type:
        "coin":
            $CoinSound.play()
            score += 1
            $HUD.update_score(score)
        "powerup":
            $PowerupSound.play()
            time_left += 5
            $HUD.update_timer(time_left)</pre>
			<p>The <code>match</code> statement <a id="_idIndexMarker125"/>is a useful alternative to <code>if</code> statements, especially when you have a large number of possible values to test.</p>
			<p>Try running the game and collecting the powerup (remember, it won’t appear on level 1). Make sure the sound plays and the timer increases by five seconds.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>Coin animation</h2>
			<p>When you<a id="_idIndexMarker126"/> created the coin, you used <code>AnimatedSprite2D</code>, but it isn’t playing yet. The coin animation displays a “shimmer” effect, traveling across the face of the coin. If all the coins display this at the same time, it will look too regular, so each coin needs a small random delay in its animation.</p>
			<p>First, click on <code>AnimatedSprite2D</code> and then on the <code>SpriteFrames</code> resource. Make sure <strong class="bold">Animation Looping</strong> is set to <strong class="bold">Off</strong> and <strong class="bold">Speed</strong> is set to <strong class="bold">12 FPS</strong>.</p>
			<div><div><img src="img/B19289_02_29.jpg" alt="Figure 2.28: Animation settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.28: Animation settings</p>
			<p>Add a <code>Timer</code> node to the <code>Coin</code> scene and then add this to the coin’s script:</p>
			<pre class="source-code">
func _ready():
    $Timer.start(randf_range(3, 8))</pre>
			<p>Then, connect the <code>Timer</code>’s <code>timeout</code> signal and add this:</p>
			<pre class="source-code">
func _on_timer_timeout():
    $AnimatedSprite2d.frame = 0
    $AnimatedSprite2d.play()</pre>
			<p>Try running <a id="_idIndexMarker127"/>the game and watching the coins animate. It’s a nice visual effect for a very small amount of effort, at least on the part of the programmer –the artist had to draw all those frames! You’ll notice a lot of effects like this in professional games. Although subtle, the visual appeal makes for a much more pleasing experience.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Obstacles</h2>
			<p>Finally, the<a id="_idIndexMarker128"/> game can be made more challenging by introducing an obstacle that the player must avoid. Touching the obstacle will end the game.</p>
			<div><div><img src="img/B19289_02_30.jpg" alt="Figure 2.29: Example game with obstacles"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.29: Example game with obstacles</p>
			<p>Create a new <code>Area2D</code> scene and name it <code>Cactus</code>. Give it <code>Sprite2D</code> and <code>CollisionShape2D</code> children. Drag the cactus texture from <code>Sprite2D</code>. Add <code>RectangleShape2D</code> to the collision shape and size it so that it covers the image. Remember when you added <code>if area.is_in_group("obstacles"?)</code> to the player code? Add <code>Cactus</code> to the <code>obstacles</code> group using the <strong class="bold">Node</strong> tab. Play the game and see what happens when you run into the cactus.</p>
			<p>You may <a id="_idIndexMarker129"/>have spotted a problem – coins can spawn on top of the cactus, making them impossible to pick up. When the coin is placed, it needs to move if it detects that it’s overlapping with the obstacle. In the <code>Coin</code> scene, connect its <code>area_entered</code> signal and add the following:</p>
			<pre class="source-code">
func _on_area_entered(area):
    if area.is_in_group("obstacles"):
        position = Vector2(randi_range(0, screensize.x),
            randi_range(0, screensize.y))</pre>
			<p>If you added the <code>Powerup</code> object from the previous section, you’ll need to do the same in its script.</p>
			<p>Play the<a id="_idIndexMarker130"/> game, and test that the objects all spawn correctly and that they don’t overlap with an obstacle. Running into an obstacle should end the game.</p>
			<p>Do you find the game challenging or easy? Before moving on to the next chapter, take some time to think about other things you might add to this game. Go ahead and see whether you can add them, using what you’ve learned so far. If not, write them down and come back later, after you’ve learned some more techniques in the following chapters.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor065"/>Summary</h1>
			<p>In this chapter, you learned the basics of the Godot Engine by creating a small 2D game. You set up a project and created multiple scenes, worked with sprites and animations, captured user input, used <strong class="bold">signals</strong> to communicate between nodes, and created a UI. The things you learned in this chapter are important skills that you’ll use in any Godot project.</p>
			<p>Before moving to the next chapter, look through the project. Do you know what each node does? Are there any bits of code that you don’t understand? If so, go back and review that section of the chapter.</p>
			<p>Also, feel free to experiment with the game and change things around. One of the best ways to get a good feel for what different parts of the game do is to change them and see what happens.</p>
			<p>Remember the tip from <a href="B19289_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>? If you really want to advance your skills quickly, close this book, start a new Godot project, and try to make <em class="italic">Coin Dash</em> again without peeking. If you have to look in the book, it’s OK, but try to only look for things once you’ve tried to figure out how to do it yourself.</p>
			<p>In the next chapter, you’ll explore more of Godot’s features and learn how to use more node types by building a more complex game.</p>
		</div>
	</body></html>