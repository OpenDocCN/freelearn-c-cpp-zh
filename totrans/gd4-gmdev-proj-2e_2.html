<html><head></head><body>
		<div id="_idContainer048">
			<h1 id="_idParaDest-31" class="chapter-number"><a id="_idTextAnchor030"/>2</h1>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/> Coin Dash – Build Your First 2D Game</h1>
			<p>This first project will guide you through making your first Godot Engine game. You will learn how the Godot editor works, how to structure a project, and how to build a small 2D game using some of Godot’s most commonly <span class="No-Break">used nodes.</span></p>
			<p class="callout-heading">Why start with 2D?</p>
			<p class="callout">In a nutshell, 3D games are much more complex than 2D ones. However, many of the underlying game engine features you’ll need to know are the same. You should stick to 2D until you have a good understanding of Godot’s workflow. At that point, the jump to 3D will feel much easier. You’ll get a chance to work in 3D in this book’s <span class="No-Break">later chapters.</span></p>
			<p>Don’t skip this chapter, even if you aren’t a complete newcomer to game development. While you may already understand many of the concepts, this project will introduce Godot’s features and design paradigms – things you’ll need to know <span class="No-Break">going forward.</span></p>
			<p>The game in this chapter<a id="_idIndexMarker053"/> is called <em class="italic">Coin Dash</em>. Your character must move around the screen, collecting as many coins as possible while racing against the clock. When you’re finished, the game will look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B19289_02_01.jpg" alt="Figure 2.1: The completed game"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1: The completed game</p>
			<p>In this chapter, we’ll cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Setting up a <span class="No-Break">new project</span></li>
				<li>Creating <span class="No-Break">character animations</span></li>
				<li>Moving <span class="No-Break">a character</span></li>
				<li>Using <strong class="source-inline">Area2D</strong> to detect when <span class="No-Break">objects touch</span></li>
				<li>Using <strong class="source-inline">Control</strong> nodes to <span class="No-Break">display information</span></li>
				<li>Communicating between game objects <span class="No-Break">using signals</span></li>
			</ul>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Technical requirements </h1>
			<p>Download the game assets from the following link below and unzip them into your new project <span class="No-Break">folder: </span><a href="https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads"><span class="No-Break">https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads</span></a></p>
			<p>You can also find the complete code for this chapter on GitHub <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter02%20-%20Coin%20Dash"><span class="No-Break">https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter02%20-%20Coin%20Dash</span></a></p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Setting up the project</h1>
			<p>Launch Godot, and in the Project Manager, click the <strong class="bold">+ New </strong><span class="No-Break"><strong class="bold">Project</strong></span><span class="No-Break"> button.</span></p>
			<p>You first<a id="_idIndexMarker054"/> need to create a project folder. Type <strong class="source-inline">Coin Dash</strong> in the <strong class="bold">Project Name</strong> box and click <strong class="bold">Create Folder</strong>. Creating a folder for your project is important to keep all your project files separate from any other projects on your computer. Next, you can click <strong class="bold">Create &amp; Edit</strong> to open the new project in the <span class="No-Break">Godot editor.</span></p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B19289_02_02.jpg" alt="Figure 2.2: The new project window"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2: The new project window</p>
			<p>In this project, you’ll make three independent scenes – the player character, the coin, and a display to show the score and clock – all of which will be combined into the game’s “main” scene (see <a href="B19289_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>). In a larger project, it might be useful to create separate folders to organize each scene’s assets and scripts, but for this relatively small game, you can save all of your scenes and scripts in the root folder, which is referred to as <strong class="source-inline">res://</strong> (res is short for resources). All resources in your project will be located relative to the res:// folder. You can see the project’s files in the <strong class="bold">FileSystem</strong> dock in the lower-left corner. Because it’s a new project, it will be empty except for a file called <strong class="source-inline">icon.svg,</strong> which is the <span class="No-Break">Godot icon.</span></p>
			<p>You can download a ZIP file of the art and sounds (collectively known as <em class="italic">assets</em>) for the game here: <a href="https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition/tree/main/Downloads">https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition/tree/main/Downloads</a>. Unzip this file in the new project folder <span class="No-Break">you created.</span></p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B19289_02_03.jpg" alt="Figure 2.3: The FileSystem tab"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3: The FileSystem tab</p>
			<p>For example, the<a id="_idIndexMarker055"/> images for the coin are located <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">res://assets/coin/</strong></span><span class="No-Break">.</span></p>
			<p>Since this game will be in portrait mode (taller than it is wide), we’ll start by setting up the <span class="No-Break">game window.</span></p>
			<p>Click <strong class="bold">Project</strong> -&gt; <strong class="bold">Project Settings</strong> from the menu at the top. The settings window looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B19289_02_04.jpg" alt="Figure 2.4: The Project Settings window"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4: The Project Settings window</p>
			<p>Look for <a id="_idIndexMarker056"/>the <strong class="bold">Display</strong> -&gt; <strong class="bold">Window</strong> section and set <strong class="bold">Viewport Width</strong> to <strong class="source-inline">480</strong> and <strong class="bold">Viewport Height</strong> to <strong class="source-inline">720</strong>, as shown in the preceding figure. Also in this section, under <strong class="bold">Stretch</strong>, set <strong class="bold">Mode</strong> to <strong class="bold">canvas_items</strong> and <strong class="bold">Aspect</strong> to <strong class="bold">keep</strong>. This will ensure that if a user resizes the game window, everything will scale appropriately and not become stretched or deformed. You can also uncheck the <strong class="bold">Resizable</strong> box under <strong class="bold">Size</strong> to prevent the window from being resized <span class="No-Break">at all.</span></p>
			<p>Congratulations! You’ve set up your new project, and you’re ready to start making your first game. In this game, you’ll make objects that move around in 2D space, so it’s important to understand how objects are positioned and moved using 2D coordinates. In the next section, you’ll learn how that works and how to apply it to <span class="No-Break">your game.</span></p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Vectors and 2D coordinate systems</h1>
			<p>This section is a <a id="_idIndexMarker057"/>very brief overview of 2D coordinate systems and vector math as it’s used in game development. Vector math is an essential tool in game development, so if you need a broader understanding of the topic, see Khan Academy’s linear algebra <span class="No-Break">series (</span><a href="https://www.khanacademy.org/math/linear-algebra"><span class="No-Break">https://www.khanacademy.org/math/linear-algebra</span></a><span class="No-Break">).</span></p>
			<p>When working in 2D, you’ll use Cartesian coordinates to identify locations in the 2D plane. A particular position in 2D space is written as a pair of values, such as <strong class="source-inline">(4, 3)</strong>, representing the position along the <em class="italic">x</em> and <em class="italic">y</em> axes, respectively. Any position in the 2D plane can be described in <span class="No-Break">this way.</span></p>
			<p>In 2D space, Godot<a id="_idIndexMarker058"/> follows the common computer graphics practice of orienting the <em class="italic">x</em> axis to the right and the <em class="italic">y</em> <span class="No-Break">axis downward:</span></p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B19289_02_05.jpg" alt="Figure 2.5: A 2D coordinate system"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5: A 2D coordinate system</p>
			<p class="callout-heading">That’s not what my math teacher taught me!</p>
			<p class="callout">If you’re new to computer graphics or game development, it might seem odd that the positive <em class="italic">y</em> axis points downward instead of upward, which you likely learned in math class. However, this orientation is very common in computer <span class="No-Break">graphics applications.</span></p>
			<h3>Vectors</h3>
			<p>You can <a id="_idIndexMarker059"/>also think of the <strong class="source-inline">(4, 3)</strong> position as an <em class="italic">offset</em> from the <strong class="source-inline">(0, 0)</strong> point, or <em class="italic">origin</em>. Imagine an arrow pointing from the origin to <span class="No-Break">the point:</span></p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B19289_02_06.jpg" alt="Figure 2.6: A 2D vector"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6: A 2D vector</p>
			<p>This arrow is a <em class="italic">vector</em>. It represents a great deal of useful information, including the point’s location, its distance or <em class="italic">length</em> (<strong class="source-inline">m</strong>), and its angle from the <em class="italic">x a</em>xis (<strong class="source-inline">θ</strong>). More specifically, this type of vector is referred to as a <em class="italic">position</em> vector – that is, one that describes a position in space. Vectors can also represent movement, acceleration, or any other<a id="_idIndexMarker060"/> quantity that has a size and <span class="No-Break">a direction.</span></p>
			<p>In Godot, vectors have a wide array of uses, and you’ll use them in every project in <span class="No-Break">this book.</span></p>
			<p>You should now have an understanding of how the 2D coordinate space works and how vectors can help to position and move objects. In the next section, you’ll create the player object and use this knowledge to control <span class="No-Break">its movement.</span></p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Part 1 – the player scene</h1>
			<p>The <a id="_idIndexMarker061"/>first scene you’ll make is the player object. One of the benefits of creating a separate scene for the player (and other objects) is that you can test it independently, even before you’ve created other parts of a game. This separation<a id="_idIndexMarker062"/> of game objects will become more and more helpful as your projects grow in size and complexity. Keeping individual game objects separate from each other makes them easier to troubleshoot, modify, and even replace entirely without affecting other parts of the game. It also means your player can be reusable – you can drop this player scene into an entirely different game and it will work just <span class="No-Break">the same.</span></p>
			<p>Your player scene needs to do the <span class="No-Break">following things:</span></p>
			<ul>
				<li>Display your character and <span class="No-Break">its animations</span></li>
				<li>Respond to user input by moving <span class="No-Break">the character</span></li>
				<li>Detect collisions with other game objects such as coins <span class="No-Break">or obstacles</span></li>
			</ul>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Creating the scene</h2>
			<p>Start by <a id="_idIndexMarker063"/>clicking the <strong class="bold">Add/Create a New Node</strong> button (the keyboard shortcut is <em class="italic">Ctrl</em> + <em class="italic">A</em>) and selecting an <strong class="source-inline">Area2D</strong>. Then, click on the node’s name and change it to <strong class="source-inline">Player</strong>. Click <strong class="bold">Scene</strong> -&gt;<strong class="bold"> Save Scene</strong> (<em class="italic">Ctrl</em> + <em class="italic">S</em>) to save <span class="No-Break">the scene.</span></p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B19289_02_07.jpg" alt="Figure 2.7: Adding a node"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7: Adding a node</p>
			<p>Take a<a id="_idIndexMarker064"/> look at the <strong class="bold">FileSystem</strong> tab and note that the <strong class="source-inline">player.tscn</strong> file now appears. Whenever you save a scene in Godot, it will use the <strong class="source-inline">.tscn</strong> extension – this is the file format for Godot’s scenes. The “t” in the name stands for “text” because these are text files. Feel free to take a look at it in an external text editor if you’re curious, but you shouldn’t edit one by hand; otherwise, you run the risk of accidentally corrupting <span class="No-Break">the file.</span></p>
			<p>You’ve now created<a id="_idIndexMarker065"/> the scene’s <strong class="bold">root</strong> or top-level node. This node defines the overall functionality of the object. We’ve chosen <strong class="source-inline">Area2D</strong> because it’s a 2D node, so it can move in 2D space, and it can detect overlap with other nodes, so we’ll be able to detect the coins and other game objects. Choosing which node to use for a particular game object is your first important decision when designing your <span class="No-Break">game objects.</span></p>
			<p>Before adding any child nodes, it’s a good idea to make sure you don’t accidentally move or resize them by clicking on them. Select the <strong class="source-inline">Player</strong> node and hover your mouse on the icon next to the lock, <strong class="bold">Group </strong><span class="No-Break"><strong class="bold">Selected Node(s)</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B19289_02_08.jpg" alt="Figure 2.8: Toggle the node grouping"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8: Toggle the node grouping</p>
			<p>The tooltip says <strong class="bold">Make selected node’s children not selectable.</strong>, and that’s good – it will help avoid mistakes. Click the button, and you’ll see the same icon appear next to the player <a id="_idIndexMarker066"/><span class="No-Break">node’s name:</span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B19289_02_09.jpg" alt="Figure 2.9: The node grouping icon"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9: The node grouping icon</p>
			<p>It’s a good idea to always do this when creating a new scene. If an object’s child nodes become offset or scaled, it can cause unexpected errors and be difficult <span class="No-Break">to troubleshoot.</span></p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Sprite animation</h2>
			<p>With <strong class="source-inline">Area2D</strong>, you<a id="_idIndexMarker067"/> can detect when other objects overlap or run into a player, but <strong class="source-inline">Area2D</strong> doesn’t have an appearance on its own. You’ll also need a node that can display an image. Since the character has animations, select the player node and add an <strong class="source-inline">AnimatedSprite2D</strong> node. This node will handle the appearance and animations for the player. Note that there’s a warning symbol next to the node. <strong class="source-inline">AnimatedSprite2D</strong> requires a <strong class="source-inline">SpriteFrames</strong> resource, which contains the animation(s) it can display. To create one, find the <strong class="bold">Frames</strong> property in the <strong class="bold">Inspector</strong> window and click on <strong class="bold">&lt;empty&gt;</strong> to see the dropdown. Select <span class="No-Break"><strong class="bold">New SpriteFrames</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B19289_02_10.jpg" alt="Figure 2.10: Adding a SpriteFrames resource"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10: Adding a SpriteFrames resource</p>
			<p>Next, in the same location, click the <strong class="source-inline">SpriteFrames</strong> label that appeared there to open a new panel at the bottom of <span class="No-Break">the screen:</span></p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B19289_02_11.jpg" alt="Figure 2.11: The SpriteFrames panel"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11: The SpriteFrames panel</p>
			<p>On <a id="_idIndexMarker068"/>the left is the list of animations. Click the <strong class="source-inline">default</strong> one and rename it <strong class="source-inline">run</strong>. Then, click the <strong class="bold">Add Animation</strong> button, and create a second animation named <strong class="source-inline">idle</strong> and a third <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">hurt</strong></span><span class="No-Break">.</span></p>
			<p>In the <strong class="bold">FileSystem</strong> dock on the left, find the <strong class="bold">run</strong>, <strong class="bold">idle</strong>, and <strong class="bold">hurt</strong> images in the <strong class="source-inline">res://assets/player/</strong> folder and drag them into the <span class="No-Break">corresponding animations:</span></p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B19289_02_12.jpg" alt="Figure 2.12: Setting up player animations"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12: Setting up player animations</p>
			<p>Each new animation has a default speed setting of <strong class="source-inline">5</strong> frames per second. This is a little too slow, so select each of the animations and set <strong class="bold">Speed</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">8</strong></span><span class="No-Break">.</span></p>
			<p>To see the animations in action, click the <strong class="bold">Play</strong> button (<img src="image/B19289_02_13.png" alt=""/>). Your animations will appear in the <strong class="bold">Inspector</strong> window in the dropdown for the <strong class="bold">Animation</strong> property. Choose one to see it <span class="No-Break">in action:</span></p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B19289_02_14.jpg" alt="Figure 2.13: The Animation property"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13: The Animation property</p>
			<p>You can <a id="_idIndexMarker069"/>also choose an animation to play by default. Select the <strong class="source-inline">idle</strong> animation and click the <strong class="bold">Autoplay on </strong><span class="No-Break"><strong class="bold">Load</strong></span><span class="No-Break"> button.</span></p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B19289_02_15.jpg" alt="Figure 2.14: Setting animation to autoplay"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14: Setting animation to autoplay</p>
			<p>Later, you’ll write code to select between these animations, depending on what the player is doing. However, first, you need to finish setting up the <span class="No-Break">player’s nodes.</span></p>
			<p>The player image is a bit small, so set the <strong class="bold">Scale</strong> property of <strong class="source-inline">AnimatedSprite2D</strong> to <strong class="source-inline">(2, 2)</strong> in order to increase it in scale. You can find this property under the <strong class="bold">Transform</strong> section in the <span class="No-Break"><strong class="bold">Inspector</strong></span><span class="No-Break"> window.</span></p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/B19289_02_16.jpg" alt="Figure 2.15: Setting the Scale property"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15: Setting the Scale property</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Collision shape</h2>
			<p>When<a id="_idIndexMarker070"/> using <strong class="source-inline">Area2D</strong> or one of the other collision objects, you need to tell Godot what the shape of the object is. Its collision shape defines the region it occupies and is used to detect overlaps and/or collisions. Shapes are defined by the various <strong class="source-inline">Shape2D</strong> types and include rectangles, circles, and polygons. In game development, this is sometimes<a id="_idIndexMarker071"/> referred to as <span class="No-Break">a </span><span class="No-Break"><strong class="bold">hitbox</strong></span><span class="No-Break">.</span></p>
			<p>For convenience, when you need to add a shape to an area or physics body, you can add <strong class="source-inline">CollisionShape2D</strong> as a child. Then, you can select the type of shape you want and edit its size in <span class="No-Break">the editor.</span></p>
			<p>Add <strong class="source-inline">CollisionShape2D</strong> as a child of the <strong class="source-inline">Player</strong> node (make sure you don’t add it as a child of <strong class="source-inline">AnimatedSprite2D</strong>). In the <strong class="bold">Inspector</strong> window, find the <strong class="bold">Shape</strong> property and click <strong class="bold">&lt;empty&gt;</strong> to select <span class="No-Break"><strong class="bold">New RectangleShape2D</strong></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B19289_02_17.jpg" alt="Figure 2.16: Adding a collision shape"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16: Adding a collision shape</p>
			<p>Drag the orange handles to adjust the shape’s size to cover the sprite. Hint – if you hold the <em class="italic">Alt</em> key while dragging a handle, the shape will size symmetrically. You may have noticed that the collision shape is not centered on the sprite. That is because the sprite images themselves are not centered vertically. You can fix this by adding a small offset to <strong class="source-inline">AnimatedSprite2D</strong>. Select the node and look for the <strong class="bold">Offset</strong> property in the <strong class="bold">Inspector</strong> window. Set it to <strong class="source-inline">(</strong><span class="No-Break"><strong class="source-inline">0, -5)</strong></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B19289_02_18.jpg" alt="Figure 2.17: Sizing the collision shape"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.17: Sizing the collision shape</p>
			<p>When<a id="_idIndexMarker072"/> you’re finished, your <strong class="bold">Player</strong> scene should look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B19289_02_19.jpg" alt="Figure 2.18: The Player node setup"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.18: The Player node setup</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Scripting the player</h2>
			<p>Now, you’re<a id="_idIndexMarker073"/> ready to add some code to the player. Attaching a script to a node allows you to add additional functionality that isn’t provided by the node itself. Select the <strong class="source-inline">Player</strong> node and click the <strong class="bold">new </strong><span class="No-Break"><strong class="bold">script</strong></span><span class="No-Break"> button:</span></p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B19289_02_20.jpg" alt="Figure 2.19: The new script button"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.19: The new script button</p>
			<p>In the <strong class="bold">Attach Node Script</strong> window, you can leave the default settings as they are. If you’ve remembered to save the scene, the script will be automatically named to match the scene’s name. Click <strong class="bold">Create</strong>, and you’ll be taken to the script window. Your script will contain some default comments <span class="No-Break">and hints.</span></p>
			<p>The first <a id="_idIndexMarker074"/>line of every script describes what type of node it is attached to. Just after that, you can start defining <span class="No-Break">your variables:</span></p>
			<pre class="source-code">
extends Area2D
@export var speed = 350
var velocity = Vector2.ZERO
var screensize = Vector2(480, 720)</pre>
			<p>Using the <strong class="source-inline">@export</strong> annotation on the <strong class="source-inline">speed</strong> variable allows you to set its value in the <strong class="bold">Inspector</strong> window, just like any other node property. This can be very handy for values that you want to be able to adjust easily. Select the <strong class="source-inline">Player</strong> node, and you’ll see the <strong class="bold">Speed</strong> property now appears in the <strong class="bold">Inspector</strong> window. Any value you set in the <strong class="bold">Inspector</strong> window will override the <strong class="source-inline">350</strong> speed value you wrote in <span class="No-Break">the script.</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B19289_02_21.jpg" alt="Figure 2.20: The exported variable in the Inspector window"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.20: The exported variable in the Inspector window</p>
			<p>As for the<a id="_idIndexMarker075"/> other variables, <strong class="source-inline">velocity</strong> will contain the character’s movement speed and direction, while <strong class="source-inline">screensize</strong> will help set the limits of the character’s movement. Later, you’ll set this value automatically from the game’s main scene, but for now, setting it manually will allow you to test that everything <span class="No-Break">is working.</span></p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Moving the player</h2>
			<p>Next, you’ll <a id="_idIndexMarker076"/>use the <strong class="source-inline">_process()</strong> function to define what the player will do. The <strong class="source-inline">_process()</strong> function is called on every frame, so you can use it to update elements of your game that you expect to change often. In each frame, you need the player to do <span class="No-Break">three things:</span></p>
			<ul>
				<li>Check for <span class="No-Break">keyboard input</span></li>
				<li>Move in the <span class="No-Break">given direction</span></li>
				<li>Play the <span class="No-Break">appropriate animation</span></li>
			</ul>
			<p>First, you need to check the inputs. For this game, you have four directional inputs to check (the four arrow keys). Input actions are defined in <strong class="bold">Project Settings</strong> under the <strong class="bold">Input Map</strong> tab. In this tab, you can define custom events and assign keys, mouse actions, or other inputs to them. By default, Godot has events assigned to the keyboard arrows, so you can use them for <span class="No-Break">this project.</span></p>
			<p>You can detect whether an input action is pressed using <strong class="source-inline">Input.is_action_pressed()</strong>, which returns <strong class="source-inline">true</strong> if a key is held down and <strong class="source-inline">false</strong> if it is not. Combining the states of all four keys will give you the resulting direction <span class="No-Break">of movement.</span></p>
			<p>You can do<a id="_idIndexMarker077"/> this by checking all four keys separately using multiple <strong class="source-inline">if</strong> statements, but since this is such a common need, Godot provides a useful function called <strong class="source-inline">Input.get_vector()</strong> that will handle this for you – you just have to tell it which four inputs to use. Note the order that the input actions are listed in; <strong class="source-inline">get_vector()</strong> expects them in this order. The result of this function is <a id="_idIndexMarker078"/>a <strong class="bold">direction vector</strong> – a vector pointing in one of the eight possible directions resulting from the <span class="No-Break">pressed inputs:</span></p>
			<pre class="source-code">
func _process(delta):
    velocity = Input.get_vector("ui_left", "ui_right",
        "ui_up", "ui_down")
    position += velocity * speed * delta</pre>
			<p>After that, you’ll have a <strong class="source-inline">velocity</strong> vector indicating which direction to move in, so the next step will be to actually update the player’s <strong class="source-inline">position</strong> using <span class="No-Break">that velocity.</span></p>
			<p>Click <strong class="bold">Run Current Scene</strong> (<em class="italic">F6</em>) at the top right, and check that you can move the player around using all four <span class="No-Break">arrow keys.</span></p>
			<p>You may notice that the player continues running off the side of the screen. You can use the <strong class="source-inline">clamp()</strong> function to limit the player’s <strong class="source-inline">position</strong> to minimum and maximum values, preventing them from leaving the screen. Add these two lines next, immediately after the <span class="No-Break">previous line:</span></p>
			<pre class="source-code">
    position.x = clamp(position.x, 0, screensize.x)
    position.y = clamp(position.y, 0, screensize.y)</pre>
			<h3>About delta</h3>
			<p>The <strong class="source-inline">_process()</strong> function <a id="_idIndexMarker079"/>includes a parameter called <strong class="source-inline">delta</strong> that is then multiplied by <strong class="source-inline">velocity</strong>. What <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">delta</strong></span><span class="No-Break">?</span></p>
			<p>The game engine attempts to run at a constant <strong class="source-inline">60</strong> frames per second. However, this can change due to computer slowdowns, either in Godot or from other programs running on your computer at the same time. If the frame rate is not consistent, then it will affect the movement of objects in your game. For example, consider an object that you want to move at <strong class="source-inline">10</strong> pixels every frame. If everything runs smoothly, this will mean the object moves <strong class="source-inline">600</strong> pixels in one second. However, if some of those frames take a bit longer, then there may have been only <strong class="source-inline">50</strong> frames in that second, so the object only moved <span class="No-Break"><strong class="source-inline">500</strong></span><span class="No-Break"> pixels.</span></p>
			<p>Godot, like many game<a id="_idIndexMarker080"/> engines and frameworks, solves this by passing you a value called <strong class="source-inline">delta</strong>, which is the elapsed time since the previous frame. Most of the time, this will be very close to <strong class="source-inline">0.016</strong> seconds (around 16 milliseconds). If you then take your desired speed of <strong class="source-inline">600</strong> px/second and multiply it by <strong class="source-inline">delta</strong>, you’ll get a movement of exactly <strong class="source-inline">10</strong> pixels. If, however, <strong class="source-inline">delta</strong> increased to <strong class="source-inline">0.3</strong> seconds, then the object would move <strong class="source-inline">18</strong> pixels. Overall, the movement speed remains consistent and independent of the <span class="No-Break">frame rate.</span></p>
			<p>As a side benefit, you can express your movement in units of pixels per second rather than pixels per frame, which is easier <span class="No-Break">to visualize.</span></p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Choosing animations</h2>
			<p>Now that the <a id="_idIndexMarker081"/>player can move, you need to change which animation <strong class="source-inline">AnimatedSprite2D</strong> is playing, based on whether the player moves or stands still. The art for the <strong class="source-inline">run</strong> animation faces to the right, which means it needs to be flipped horizontally (using the <strong class="bold">Flip H</strong> property, which you can see in the <strong class="bold">Inspector</strong> window – go ahead and try toggling it) when moving to the left. Add this code to your <strong class="source-inline">_process()</strong> function after the <span class="No-Break">movement code:</span></p>
			<pre class="source-code">
if velocity.length() &gt; 0:
    $AnimatedSprite2D.animation = "run"
else:
    $AnimatedSprite2D.animation = "idle"
if velocity.x != 0:
    $AnimatedSprite2D.flip_h = velocity.x &lt; 0</pre>
			<p class="callout-heading">Getting nodes</p>
			<p class="callout">When using the <strong class="source-inline">$</strong> notation, the node name is <em class="italic">relative</em> to the node running the script. For example, <strong class="source-inline">$Node1/Node2</strong> would refer to a node (<strong class="source-inline">Node2</strong>) that is a child of <strong class="source-inline">Node1</strong>, which is itself a child of the node that runs the script. Godot’s autocomplete will suggest node names as you type. Note that if the name contains spaces, you must put quote marks around it – for example, <strong class="source-inline">$"</strong><span class="No-Break"><strong class="source-inline">My Node"</strong></span><span class="No-Break">.</span></p>
			<p>Note <a id="_idIndexMarker082"/>that this code takes a little shortcut. <strong class="source-inline">flip_h</strong> is a Boolean property, which means it can be <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>. A Boolean value is also the result of a comparison, such as <strong class="source-inline">&lt;</strong>. Because of this, you can directly set the property equal to the result of <span class="No-Break">the comparison.</span></p>
			<p>Play the scene again and check that the animations are correct in each case. </p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Starting and ending the player’s movement</h2>
			<p>The main <a id="_idIndexMarker083"/>scene will need to inform the player when the game has started and ended. To do that, add a <strong class="source-inline">start()</strong> function to the player, which<a id="_idIndexMarker084"/> will set the player’s starting position <span class="No-Break">and animation:</span></p>
			<pre class="source-code">
func start():
    set_process(true)
    position = screensize / 2
    $AnimatedSprite2D.animation = "idle"</pre>
			<p>Also, add a <strong class="source-inline">die()</strong> function to be called when the player hits an obstacle or runs out <span class="No-Break">of time:</span></p>
			<pre class="source-code">
func die():
    $AnimatedSprite2D.animation = "hurt"
    set_process(false)</pre>
			<p>Using <strong class="source-inline">set_process(false)</strong> tells Godot to stop calling the <strong class="source-inline">_process()</strong> function every frame. Since the movement code is in that function, you’ll no longer be able to move when the game <span class="No-Break">is over.</span></p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Preparing for collisions</h2>
			<p>The <a id="_idIndexMarker085"/>player should detect when it hits a coin or an obstacle, but you haven’t made those objects yet. That’s OK because you can use Godot’s <em class="italic">signal</em> functionality to make it work. Signals are a way for nodes to send out messages that other nodes can detect and react to. Many nodes have built-in signals to alert you when events occur, such as a body colliding or a button being pressed. You can also define custom signals for your <span class="No-Break">own purposes.</span></p>
			<p>Signals are used by <em class="italic">connecting</em> them to the node(s) that you want to listen for them. This connection can be made in the <strong class="bold">Inspector</strong> window or in code. Later in the project, you’ll learn how to connect signals in <span class="No-Break">both ways.</span></p>
			<p>Add the following lines to the top of the script (after <span class="No-Break"><strong class="source-inline">extends Area2D</strong></span><span class="No-Break">):</span></p>
			<pre class="source-code">
signal pickup
signal hurt</pre>
			<p>These lines declare custom signals that your player will <strong class="bold">emit</strong> when they touch a coin or obstacle. The touches will be detected by <strong class="source-inline">Area2D</strong> itself. Select the <strong class="source-inline">Player</strong> node, and click the <strong class="bold">Node</strong> tab next to the <strong class="bold">Inspector</strong> tab to see a list of signals the player <span class="No-Break">can emit:</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B19289_02_22.jpg" alt="Figure 2.21: The node’s list of signals"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.21: The node’s list of signals</p>
			<p>Note your custom signals there as well. Since the other objects will also be <strong class="source-inline">Area2D</strong> nodes, you’ll want to use the <strong class="source-inline">area_entered</strong> signal. Select it and click <strong class="bold">Connect</strong>. In the window that pops up, click <strong class="bold">Connect</strong> again – you don’t need to change any of those settings. Godot will automatically create a new function called <strong class="source-inline">_on_area_entered()</strong> in <span class="No-Break">your script.</span></p>
			<p>When <a id="_idIndexMarker086"/>connecting a signal, instead of having Godot create the function for you, you can also give the name of an existing function that you want to use instead. Toggle the <strong class="bold">Make Function</strong> switch off if you don’t want Godot to create the function <span class="No-Break">for you.</span></p>
			<p>Add the following code to this <span class="No-Break">new function:</span></p>
			<pre class="source-code">
func _on_area_entered(area):
    if area.is_in_group("coins"):
        area.pickup()
        pickup.emit()
    if area.is_in_group("obstacles"):
        hurt.emit()
        die()</pre>
			<p>Whenever another area object overlaps with the player, this function will be called, and that overlapping area will be passed in with the <strong class="source-inline">area</strong> parameter. The coin object will have a <strong class="source-inline">pickup()</strong> function that defines what the coin does when picked up (playing an animation or sound, for example). When you create the coins and obstacles, you’ll assign them to the appropriate <strong class="bold">group</strong> so that they can be <span class="No-Break">detected correctly.</span></p>
			<p>To summarize, here is the complete player script <span class="No-Break">so far:</span></p>
			<pre class="source-code">
extends Area2D
signal pickup
signal hurt
@export var speed = 350
var velocity = Vector2.ZERO
var screensize = Vector2(480, 720)
func _process(delta):
    # Get a vector representing the player's input
    # Then move and clamp the position inside the screen
    velocity = Input.get_vector("ui_left", "ui_right",
        "ui_up", "ui_down")
    position += velocity * speed * delta
    position.x = clamp(position.x, 0, screensize.x)
    position.y = clamp(position.y, 0, screensize.y)
    # Choose which animation to play
    if velocity.length() &gt; 0:
        $AnimatedSprite2D.animation = "run"
    else:
        $AnimatedSprite2D.animation = "idle"
    if velocity.x != 0:
        $AnimatedSprite2D.flip_h = velocity.x &lt; 0
func start():
    # This function resets the player for a new game
    set_process(true)
    position = screensize / 2
    $AnimatedSprite2D.animation = "idle"
func die():
    # We call this function when the player dies
    $AnimatedSprite2D.animation = "hurt"
    set_process(false)
func _on_area_entered(area):
    # When we hit an object, decide what to do
    if area.is_in_group("coins"):
        area.pickup()
        pickup.emit()
    if area.is_in_group("obstacles"):
        hurt.emit()
        die()</pre>
			<p>You’ve <a id="_idIndexMarker087"/>completed setting up the player object, and you’ve tested that the movement and animations work correctly. Before you move on to the next step, review the player scene setup and the script, and make sure you understand what you’ve done and why. In the next section, you’ll make some objects for the player <span class="No-Break">to collect.</span></p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Part 2 – the coin scene</h1>
			<p>In this part, you’ll<a id="_idIndexMarker088"/> make<a id="_idIndexMarker089"/> coins for the player to collect. This will be a separate scene, describing all the properties and behavior of a single coin. Once saved, the main scene will load this one and create multiple <strong class="bold">instances</strong> (that is, copies) <span class="No-Break">of it.</span></p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>The node setup</h2>
			<p>Click <strong class="bold">Scene</strong> -&gt; <strong class="bold">New Scene</strong> and<a id="_idIndexMarker090"/> add the following nodes. Don’t forget to set the children to not be selectable, as you did with the <span class="No-Break"><strong class="source-inline">Player</strong></span><span class="No-Break"> scene:</span></p>
			<ul>
				<li><strong class="source-inline">Area2D</strong> (<span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">Coin</strong></span><span class="No-Break">):</span><ul><li><span class="No-Break"><strong class="source-inline">AnimatedSprite2D</strong></span></li><li><span class="No-Break"><strong class="source-inline">CollisionShape2D</strong></span></li></ul></li>
			</ul>
			<p>Make sure to save the scene once you’ve added <span class="No-Break">the nodes.</span></p>
			<p>Set up <strong class="source-inline">AnimatedSprite2D</strong> as you did in the player scene. This time, you only have one animation – a shine/sparkle effect that makes the coin look dynamic and interesting. Add all the frames and set the animation speed to <strong class="source-inline">12 FPS</strong>. The images are also a little too large, so set the <strong class="bold">Scale</strong> value of <strong class="source-inline">AnimatedSprite2D</strong> to <strong class="source-inline">(0.4, 0.4)</strong>. In <strong class="source-inline">CollisionShape2D</strong>, use <strong class="source-inline">CircleShape2D</strong> and resize it to cover the <span class="No-Break">coin image.</span></p>
			<h3>Using groups</h3>
			<p>Groups provide<a id="_idIndexMarker091"/> a tagging system for nodes, allowing you to identify similar nodes. A node can belong to any number of groups. In order for the player script to correctly detect a coin, you need to ensure that all coins will be in a group called <strong class="bold">coins</strong>. Select the <strong class="source-inline">Coin</strong> node, click the <strong class="bold">Node</strong> tab (the same tab where you found the signals), and choose <strong class="bold">Groups</strong>. Type <strong class="source-inline">coins</strong> in the box and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Add</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B19289_02_23.jpg" alt="Figure 2.22: The Groups tab"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.22: The Groups tab</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Coin script</h2>
			<p>Your<a id="_idIndexMarker092"/> next step is to add a script to the <strong class="source-inline">Coin</strong> node. Select the node and click the new script button, just like you did with the <strong class="source-inline">Player</strong> node. If you uncheck the <strong class="bold">Template</strong> option, you’ll get an empty script without any comments or suggestions. The code for the coin is much shorter than the code for <span class="No-Break">the player:</span></p>
			<pre class="source-code">
extends Area2D
var screensize = Vector2.ZERO
func pickup():
    queue_free()</pre>
			<p>Recall that the <strong class="source-inline">pickup()</strong> function is called by the player script. It defines what the coin will do when collected. <strong class="source-inline">queue_free()</strong> is Godot’s method for removing nodes. It safely removes the node from the tree and deletes it from memory, along with all its children. Later, you’ll add visual and audio effects here, but for now, just having the coin disappear is <span class="No-Break">good enough.</span></p>
			<p class="callout-heading">Removing nodes</p>
			<p class="callout"><strong class="source-inline">queue_free()</strong> doesn’t delete the object immediately, but rather adds it to a queue to be deleted at the end of the current frame. This is safer than immediately deleting the node because other code running in the game may still need the node to exist. By waiting until the end of the frame, Godot can be sure that all code that can access the node has completed and the node can be <span class="No-Break">removed safely.</span></p>
			<p>You’ve now <a id="_idIndexMarker093"/>completed the second of the two objects needed for this game. The coin object is ready to be placed randomly on the screen, and it can detect when it’s touched by the player, so it can be collected. The remaining piece of the puzzle is how to put it all together. In the next section, you’ll create a third scene to randomly create coins and allow the player to interact <span class="No-Break">with them.</span></p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Part 3 – the Main scene</h1>
			<p>The <strong class="source-inline">Main</strong> scene is <a id="_idIndexMarker094"/>what ties all the pieces of the game together. It <a id="_idIndexMarker095"/>will manage the player, the coins, the clock, and all the other pieces of <span class="No-Break">the game.</span></p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Node setup</h2>
			<p>Create a <a id="_idIndexMarker096"/>new scene and add a <strong class="source-inline">Node</strong> named <strong class="source-inline">Main</strong>. The simplest type of node is <strong class="source-inline">Node</strong> – it doesn’t do much at all on its own, but you’ll use it as the parent for all the game objects and add a script that will give it the functionality you need. Save <span class="No-Break">the scene.</span></p>
			<p>Add the player as a child of <strong class="source-inline">Main</strong> by clicking the <strong class="bold">Instantiate Child Scene</strong> button and choosing your <span class="No-Break">saved </span><span class="No-Break"><strong class="source-inline">player.tscn</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B19289_02_24.jpg" alt="Figure 2.23: Instantiating a scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.23: Instantiating a scene</p>
			<p>Add the following nodes as children <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Main</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>A <strong class="source-inline">TextureRect</strong> node named <strong class="source-inline">Background</strong> – for the <span class="No-Break">background image</span></li>
				<li>A <strong class="source-inline">Timer</strong> node named <strong class="source-inline">GameTimer</strong> – for the <span class="No-Break">countdown timer</span></li>
			</ul>
			<p>Make sure <strong class="source-inline">Background</strong> is the first child node by dragging it above the player in the node list. Nodes are drawn in the order shown in the tree, so if <strong class="source-inline">Background</strong> is first, that ensures<a id="_idIndexMarker097"/> it’s drawn behind the player. Add an image to the <strong class="source-inline">Background</strong> node by dragging the <strong class="source-inline">grass.png</strong> image from the <strong class="source-inline">assets</strong> folder into the <strong class="bold">Texture</strong> property. Change <strong class="bold">Stretch Mode</strong> to <strong class="bold">Tile</strong>, and then set the size to <strong class="bold">Full Rect</strong> by clicking the layout button at the top of the <span class="No-Break">editor window:</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B19289_02_25.jpg" alt="Figure 2.24: Layout options"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.24: Layout options</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Main script</h2>
			<p>Add a script<a id="_idIndexMarker098"/> to the <strong class="source-inline">Main</strong> node and add the <span class="No-Break">following variables:</span></p>
			<pre class="source-code">
extends Node
@export var coin_scene : PackedScene
@export var playtime = 30
var level = 1
var score = 0
var time_left = 0
var screensize = Vector2.ZERO
var playing = false</pre>
			<p>The <strong class="bold">Coin Scene</strong> and <strong class="bold">Playtime</strong> properties now appear in the <strong class="bold">Inspector</strong> window when<a id="_idIndexMarker099"/> you select the <strong class="source-inline">Main</strong> node. Drag <strong class="source-inline">coin.tscn</strong> from the <strong class="bold">FileSystem</strong> panel and drop it into the <strong class="bold">Coin </strong><span class="No-Break"><strong class="bold">Scene</strong></span><span class="No-Break"> property.</span></p>
			<h3>Initializing</h3>
			<p>To start <a id="_idIndexMarker100"/>things off, add the <span class="No-Break"><strong class="source-inline">_ready()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func _ready():
    screensize = get_viewport().get_visible_rect().size
    $Player.screensize = screensize
    $Player.hide()</pre>
			<p>Godot automatically calls <strong class="source-inline">_ready()</strong> on every node when it’s added. This is a good place to put code that you want to happen at the beginning of a <span class="No-Break">node’s lifetime.</span></p>
			<p>Note that you’re referring to the <strong class="source-inline">Player</strong> node by name using the <strong class="source-inline">$</strong> syntax, allowing you to find the size of the game screen and set the player’s <strong class="source-inline">screensize</strong> variable. <strong class="source-inline">hide()</strong> makes a node invisible, so you won’t see the player before the <span class="No-Break">game starts.</span></p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>Starting a new game</h2>
			<p>The <strong class="source-inline">new_game()</strong> function <a id="_idIndexMarker101"/>will initialize everything for a <span class="No-Break">new game:</span></p>
			<pre class="source-code">
func new_game():
    playing = true
    level = 1
    score = 0
    time_left = playtime
    $Player.start()
    $Player.show()
    $GameTimer.start()
    spawn_coins()</pre>
			<p>In addition to<a id="_idIndexMarker102"/> setting the variables to their starting values, this function calls the player’s <strong class="source-inline">start()</strong> function that you wrote earlier. Starting <strong class="source-inline">GameTimer</strong> will start counting down the remaining time in <span class="No-Break">the game.</span></p>
			<p>You also need a function that will create a number of coins based on the <span class="No-Break">current level:</span></p>
			<pre class="source-code">
func spawn_coins():
    for i in level + 4:
        var c = coin_scene.instantiate()
        add_child(c)
        c.screensize = screensize
        c.position = Vector2(randi_range(0, screensize.x),
            randi_range(0, screensize.y))</pre>
			<p>In this function, you create multiple <strong class="bold">instances</strong> of the <strong class="source-inline">Coin</strong> object and add them as children of <strong class="source-inline">Main</strong> (in code this time, rather than by manually clicking on the <strong class="bold">Instantiate Child Scene</strong> button). Whenever you instantiate a new node, it must be added to the scene tree using <strong class="source-inline">add_child()</strong>. Lastly, you choose a random position for the coin, using the <strong class="source-inline">screensize</strong> variable so that they won’t appear off screen. You’ll call this function at the start of every level, generating more coins <span class="No-Break">each time.</span></p>
			<p>Eventually, you’ll want <strong class="source-inline">new_game()</strong> to be called when the player clicks the <strong class="bold">start</strong> button on the menu. For now, to test that everything is working, add <strong class="source-inline">new_game()</strong> to the end of your <strong class="source-inline">_ready()</strong> function and click <strong class="bold">Run Project</strong> (<em class="italic">F5</em>). When you are prompted to choose a main scene, select <strong class="source-inline">main.tscn</strong>. Now, whenever you play the project, the <strong class="source-inline">Main</strong> scene will <span class="No-Break">be started.</span></p>
			<p>At this point, you should see your player and five coins appear on the screen. When the player touches a coin, <span class="No-Break">it disappears.</span></p>
			<p>Once you’re done testing, remove <strong class="source-inline">new_game()</strong> from the <span class="No-Break"><strong class="source-inline">_ready()</strong></span><span class="No-Break"> function.</span></p>
			<h3>Checking for remaining coins</h3>
			<p>The <strong class="source-inline">main</strong> script <a id="_idIndexMarker103"/>needs to detect whether the player has picked up all the coins. Since the coins are all in the <strong class="source-inline">coins</strong> group, you can check the size of the group to see how many remain. Since it needs to be checked continuously, put it in the <span class="No-Break"><strong class="source-inline">_process()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func _process(delta):
    if playing and
    get_tree().get_nodes_in_group("coins").size() == 0:
        level += 1
        time_left += 5
        spawn_coins()</pre>
			<p>If no more coins remain, then the player advances to the <span class="No-Break">next level.</span></p>
			<p>This completes the main scene. The most important thing you learned in this step was how to dynamically create new objects in code using <strong class="source-inline">instantiate()</strong>. This is something that you will use again and again in building many types of game systems. In the last step, you’ll create one more scene to handle displaying game information, such as the player’s score and the <span class="No-Break">time remaining.</span></p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/>Part 4 – the user interface</h1>
			<p>The<a id="_idIndexMarker104"/> final element <a id="_idIndexMarker105"/>your game needs is a <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>). This will display information that the player needs to see during gameplay, which is often referred to as a <strong class="bold">heads-up display</strong> (<strong class="bold">HUD</strong>) because<a id="_idIndexMarker106"/> the information appears as an overlay on top of the game view. You’ll also use this scene to display a start button after the <span class="No-Break">game ends.</span></p>
			<p>Your HUD will display the <span class="No-Break">following information:</span></p>
			<ul>
				<li><span class="No-Break">The score</span></li>
				<li>The <span class="No-Break">time remaining</span></li>
				<li>A message, such as <span class="No-Break"><strong class="bold">Game Over</strong></span></li>
				<li>A <span class="No-Break">start button</span></li>
			</ul>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>Node setup</h2>
			<p>Create a<a id="_idIndexMarker107"/> new scene and add a <strong class="source-inline">CanvasLayer</strong> node named <strong class="source-inline">HUD</strong>. A <strong class="source-inline">CanvasLayer</strong> node creates a new drawing layer, which will allow you to draw your UI elements above the rest of the game so that it doesn’t get covered up by game objects, such as the player <span class="No-Break">or coins.</span></p>
			<p>Godot provides a variety of UI elements that can be used to create anything from indicators, such as health bars, to complex interfaces, such as inventories. In fact, the Godot editor that you use to make this game is built using the Godot UI elements. The basic nodes for a UI are all extended from <strong class="source-inline">Control</strong> and appear with green icons in the node list. To create your UI, you’ll use various <strong class="source-inline">Control</strong> nodes to position, format, and display information. Here’s what the HUD will look like <span class="No-Break">when complete:</span></p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B19289_02_26.jpg" alt="Figure 2.25: The HUD layout"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.25: The HUD layout</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Message label</h2>
			<p>Add a <strong class="source-inline">Label</strong> node <a id="_idIndexMarker108"/>to the scene and change its name to <strong class="source-inline">Message</strong>. This label will display the game’s title as well as <strong class="bold">Game Over</strong> when the game ends. This label should be centered on the game screen. You can drag it with the mouse, or set the values directly in the <strong class="bold">Inspector</strong> window, but it’s easiest to use the shortcuts provided in the layout menu, which will set the values <span class="No-Break">for you.</span></p>
			<p>Select <strong class="bold">HCenter Wide</strong> from the <span class="No-Break">layout menu:</span></p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B19289_02_27.jpg" alt="Figure 2.26: Positioning the message"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.26: Positioning the message</p>
			<p>The label now<a id="_idIndexMarker109"/> spans the width of the screen and is centered vertically. The <strong class="bold">Text</strong> property sets what text the label displays. Set it to <strong class="bold">Coin Dash!</strong>, and set <strong class="bold">Horizontal Alignment</strong> and <strong class="bold">Vertical Alignment</strong> both <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Center</strong></span><span class="No-Break">.</span></p>
			<p>The default font for <strong class="source-inline">Label</strong> nodes is very small and unattractive, so the next step is to assign a custom font. In the <strong class="bold">Label Settings</strong> property, select <strong class="bold">New LabelSettings</strong> and then click it <span class="No-Break">to expand.</span></p>
			<p>From the <strong class="bold">FileSystem</strong> tab, drag the <strong class="source-inline">Kenney Bold.ttf</strong> font file and drop it into the <strong class="bold">Font</strong> property, and then set <strong class="bold">Size</strong> to <strong class="bold">48</strong>. You can also improve the appearance by adding a shadow – try the settings shown in the following screenshot, or experiment with <span class="No-Break">your own:</span></p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B19289_02_28.jpg" alt="Figure 2.27: Font settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.27: Font settings</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Score and time display</h2>
			<p>The<a id="_idIndexMarker110"/> top of the HUD will display the player’s score and the time remaining on the clock. Both of these will be <strong class="source-inline">Label</strong> nodes, arranged at opposite sides of the game screen. Rather than position them separately, you’ll use a <strong class="bold">container</strong> node to manage <span class="No-Break">their positions.</span></p>
			<h3>Containers</h3>
			<p>Godot’s <strong class="source-inline">Container</strong> nodes<a id="_idIndexMarker111"/> automatically arrange the positions and sizes of their child <strong class="source-inline">Control</strong> nodes (including other containers). You can use them to add padding around elements, keep them centered, or arrange them in rows and columns. Each type of <strong class="source-inline">Container</strong> has special properties that control how they arrange <span class="No-Break">their children.</span></p>
			<p>Remember that containers automatically arrange their children. If you try to move or resize a <strong class="source-inline">Control</strong> that’s inside a <strong class="source-inline">Container</strong> node, you’ll get a warning from the editor. You can manually arrange controls <em class="italic">or</em> arrange them with a container, but <span class="No-Break">not both.</span></p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Score and time display</h2>
			<p>To <a id="_idIndexMarker112"/>manage the score and time labels, add a <strong class="source-inline">MarginContainer</strong> node to the <strong class="source-inline">HUD</strong>. Use the layout menu to set the anchors to <strong class="bold">Top Wide</strong>. In the <strong class="bold">Theme Overrides/Constants</strong> section of the <strong class="bold">Inspector</strong> window, set the four <strong class="bold">Margin</strong> properties to <strong class="source-inline">10</strong>. This will add some padding so that the text isn’t against the edge of <span class="No-Break">the screen.</span></p>
			<p>Since the score and time labels will use the same font settings as <strong class="source-inline">Message</strong>, you can save time by duplicating it. Select <strong class="source-inline">Message</strong> and press <em class="italic">Ctrl</em> + <em class="italic">D</em> twice to create two duplicate labels. Drag them both and drop them onto <strong class="source-inline">MarginContainer</strong> to make them its children. Name one child <strong class="source-inline">Score</strong> and the other <strong class="source-inline">Time</strong>, and set the <strong class="bold">Text</strong> property to <strong class="bold">0</strong> for both. Set <strong class="bold">Vertical Alignment</strong> to <strong class="bold">Center</strong> on both, and <strong class="bold">Horizontal Alignment</strong> to <strong class="bold">Right</strong> on <strong class="source-inline">Score</strong> but <strong class="bold">Left</strong> <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">Time</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>Updating the UI via GDScript</h2>
			<p>Add a <a id="_idIndexMarker113"/>script to the <strong class="source-inline">HUD</strong> node. This script will update the UI elements when their properties need to change, such as updating the <strong class="source-inline">Score</strong> text whenever a coin is collected. See the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
extends CanvasLayer
signal start_game
func update_score(value):
    $MarginContainer/Score.text = str(value)
func update_timer(value):
    $MarginContainer/Time.text = str(value)</pre>
			<p>The <strong class="source-inline">Main</strong> scene’s script will call these two functions to update the display whenever there is a change in a value. For the <strong class="source-inline">Message</strong> label, you also need a timer to make it disappear after a <span class="No-Break">brief period.</span></p>
			<p>Add a <strong class="source-inline">Timer</strong> node as a child of <strong class="source-inline">HUD</strong>, and set <strong class="bold">Wait Time</strong> to <strong class="source-inline">2</strong> seconds and <strong class="bold">One Shot</strong> to <strong class="bold">On</strong>. This ensures that, when started, the timer will only run once, rather than repeating. Add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
func show_message(text):
    $Message.text = text
    $Message.show()
    $Timer.start()</pre>
			<p>In this function, you will display the message and start the timer. To hide the message, connect the <strong class="source-inline">timeout</strong> signal of <strong class="source-inline">Timer</strong> (remember that it will automatically create the <span class="No-Break">new function):</span></p>
			<pre class="source-code">
func _on_timer_timeout():
    $Message.hide()</pre>
			<h3>Using buttons</h3>
			<p>Add <a id="_idIndexMarker114"/>a <strong class="source-inline">Button</strong> node to <strong class="source-inline">HUD</strong> and change its name to <strong class="source-inline">StartButton</strong>. This button will be displayed before the game starts, and when clicked, it will hide itself and send a signal to the <strong class="source-inline">Main</strong> scene to start the game. Set the <strong class="bold">Text</strong> property to <strong class="bold">Start</strong>, then scroll down to <strong class="bold">Theme Overrides/Fonts</strong>, and set the font as you did <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Message</strong></span><span class="No-Break">.</span></p>
			<p>In the layout menu, choose <strong class="bold">Center Bottom</strong> to center the button at the bottom of <span class="No-Break">the screen.</span></p>
			<p>When a button is pressed, it emits a signal. In the <strong class="bold">Node</strong> tab for <strong class="source-inline">StartButton</strong>, connect the <span class="No-Break"><strong class="source-inline">pressed</strong></span><span class="No-Break"> signal:</span></p>
			<pre class="source-code">
func _on_start_button_pressed():
    $StartButton.hide()
    $Message.hide()
    start_game.emit()</pre>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Game over</h2>
			<p>The final <a id="_idIndexMarker115"/>task for your UI script is to react to the <span class="No-Break">game ending:</span></p>
			<pre class="source-code">
func show_game_over():
    show_message("Game Over")
    await $Timer.timeout
    $StartButton.show()
    $Message.text = "Coin Dash!"
    $Message.show()</pre>
			<p>In this function, you need the <strong class="bold">Game Over</strong> message to be displayed for two seconds and then disappear, which is what <strong class="source-inline">show_message("Game Over")</strong> does. However, you then want to show the start button and game title once the message has disappeared. The <strong class="source-inline">await</strong> command pauses the execution of a function until the given node (<strong class="source-inline">Timer</strong>) emits a given signal (<strong class="source-inline">timeout</strong>). Once the signal is received, the function continues, and everything will be returned to its initial state so that you can <span class="No-Break">play again.</span></p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Adding HUD to Main</h2>
			<p>The <a id="_idIndexMarker116"/>next task is to set up the communication between <strong class="source-inline">Main</strong> and <strong class="source-inline">HUD</strong>. Add an instance of <strong class="source-inline">HUD</strong> to <strong class="source-inline">Main</strong>. In <strong class="source-inline">Main</strong>, connect the <strong class="source-inline">timeout</strong> signal of <strong class="source-inline">GameTimer</strong> and add the following so that every time <strong class="source-inline">GameTimer</strong> times out (every second), the remaining time <span class="No-Break">is reduced:</span></p>
			<pre class="source-code">
func _on_game_timer_timeout():
    time_left -= 1
    $HUD.update_timer(time_left)
    if time_left &lt;= 0:
        game_over()</pre>
			<p>Next, select the instance of <strong class="source-inline">Player</strong> in <strong class="source-inline">Main</strong> and connect its <strong class="source-inline">pickup</strong> and <span class="No-Break"><strong class="source-inline">hurt</strong></span><span class="No-Break"> signals:</span></p>
			<pre class="source-code">
func _on_player_hurt():
    game_over()
func _on_player_pickup():
    score += 1
    $HUD.update_score(score)</pre>
			<p>Several things need to happen when the game ends, so add the <span class="No-Break">following function:</span></p>
			<pre class="source-code">
func game_over():
    playing = false
    $GameTimer.stop()
    get_tree().call_group("coins", "queue_free")
    $HUD.show_game_over()
    $Player.die()</pre>
			<p>This function halts the game and also uses <strong class="source-inline">call_group()</strong> to remove all remaining coins by calling <strong class="source-inline">queue_free()</strong> on each <span class="No-Break">of them.</span></p>
			<p>Finally, pressing <strong class="source-inline">StartButton</strong> needs to activate <strong class="source-inline">Main</strong>’s <strong class="source-inline">new_game()</strong> function. Select the instance of <strong class="source-inline">HUD</strong> and connect its <span class="No-Break"><strong class="source-inline">start_game</strong></span><span class="No-Break"> signal:</span></p>
			<pre class="source-code">
func _on_hud_start_game():
    new_game()</pre>
			<p>Make <a id="_idIndexMarker117"/>sure you’ve removed <strong class="source-inline">new_game()</strong> from <strong class="source-inline">Main</strong>’s <strong class="source-inline">_ready()</strong> function (remember, that was only there to test), and add these two lines <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">new_game()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
$HUD.update_score(score)
$HUD.update_timer(time_left)</pre>
			<p>Now, you can play the game! Confirm that all parts are working as intended – the score, the countdown, the game ending and restarting, and so on. If you find a part that’s not working, go back and check the step where you created it, as well as the step(s) where it may have been connected to the rest of the game. A common mistake is to forget to connect one of the many signals you used in different parts of <span class="No-Break">the game.</span></p>
			<p>Once you’ve played the game and confirmed that everything works correctly, you can move on to the next section, where you can add a few additional features to round out the <span class="No-Break">game experience.</span></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Part 5 – finishing up</h1>
			<p>Congratulations on creating a complete, working game! In this section, you’ll add a few extra things to the game to make it a little more exciting. Game developers use the term <strong class="bold">juice</strong> to describe the things that make a game feel good to play. Juice can include things such as sound, visual effects, or any other addition that adds to the player’s enjoyment, without necessarily changing the nature of <span class="No-Break">the gameplay.</span></p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Visual effects</h2>
			<p>When<a id="_idIndexMarker118"/> you pick up the coins, they just disappear, which is not very appealing. Adding a visual effect will make it much more satisfying to collect lots <span class="No-Break">of coins.</span></p>
			<h3>What is a tween?</h3>
			<p>A <strong class="bold">tween</strong> is a <a id="_idIndexMarker119"/>way to <strong class="bold">interpolate</strong> (change gradually) some value over time using a particular mathematical function. For example, you might choose a function that steadily changes a value or one that starts slow but ramps up in speed. Tweening is also sometimes referred to<a id="_idIndexMarker120"/> as <strong class="bold">easing</strong>. You can see animated examples of lots of tweening functions <span class="No-Break">at </span><span class="No-Break">https://easings.net/</span><span class="No-Break">.</span></p>
			<p>When using a tween in Godot, you can assign it to alter one or more properties of a node. In this case, you’re going to increase the scale of the coin and also cause it to fade out using the <strong class="bold">Modulate</strong> property. Once the tween has finished its job, the coin will <span class="No-Break">be deleted.</span></p>
			<p>However, there’s a problem. If we don’t remove the coin immediately, then it’s possible for the player to move onto the coin again – triggering the <strong class="source-inline">area_entered</strong> signal a second time and registering it as a second pickup. To prevent this, you can disable the collision shape so that the coin can’t trigger any <span class="No-Break">further collisions.</span></p>
			<p>Your new <strong class="source-inline">pickup()</strong> function should look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
func pickup():
    $CollisionShape2d.set_deferred("disabled", true)
    var tw = create_tween().set_parallel().
        set_trans(Tween.TRANS_QUAD)
    tw.tween_property(self, "scale", scale * 3, 0.3)
    tw.tween_property(self, "modulate:a", 0.0, 0.3)
    await tw.finished
    queue_free()</pre>
			<p>That’s a lot of new code, so let’s break <span class="No-Break">it down:</span></p>
			<p>First, <strong class="source-inline">CollisionShape2D</strong>’s <strong class="source-inline">disabled</strong> property needs to be set to <strong class="source-inline">true</strong>. However, if you try setting it directly, Godot will complain. You’re not allowed to change physics properties while collisions are being processed; you have to wait until the end of the current frame. That’s what <span class="No-Break"><strong class="source-inline">set_deferred()</strong></span><span class="No-Break"> does.</span></p>
			<p>Next, <strong class="source-inline">create_tween()</strong> creates a tween object, <strong class="source-inline">set_parallel()</strong> says that any following tweens should <a id="_idIndexMarker121"/>happen at the same time, instead of one after another, and <strong class="source-inline">set_trans()</strong> sets the transition function to the “<span class="No-Break">quadratic” curve.</span></p>
			<p>After that come two lines that set up the tweening of the properties. <strong class="source-inline">tween_property()</strong> takes four parameters – the object to affect (<strong class="source-inline">self</strong>), the property to change, the ending value, and the duration (<span class="No-Break">in seconds).</span></p>
			<p>Now, when you run the game, you should see the coins playing the effect when they’re <span class="No-Break">picked up.</span></p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Sound</h2>
			<p>Sound is <a id="_idIndexMarker122"/>an important but often neglected piece of game design. Good sound design can add a huge amount of juice to your game for a very small amount of effort. Sounds can give a player feedback, connect them emotionally to the characters, or even be a direct part of gameplay (“you hear footsteps <span class="No-Break">behind you”).</span></p>
			<p>For this game, you’re going to add three sound effects. In the <strong class="source-inline">Main</strong> scene, add three <strong class="source-inline">AudioStreamPlayer</strong> nodes and name them <strong class="source-inline">CoinSound</strong>, <strong class="source-inline">LevelSound</strong>, and <strong class="source-inline">EndSound</strong>. Drag each sound from the <strong class="source-inline">res://assets/audio/</strong> folder into the corresponding node’s <span class="No-Break"><strong class="bold">Stream</strong></span><span class="No-Break"> property.</span></p>
			<p>To play a sound, you call the <strong class="source-inline">play()</strong> function on the node. Add each of the following lines to play the sounds at the <span class="No-Break">appropriate times:</span></p>
			<ul>
				<li><strong class="source-inline">$CoinSound.play()</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">_on_player_pickup()</strong></span></li>
				<li><strong class="source-inline">$EndSound.play()</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">game_over()</strong></span></li>
				<li><strong class="source-inline">$LevelSound.play()</strong> to <strong class="source-inline">spawn_coins()</strong> (but not inside <span class="No-Break">the loop!)</span></li>
			</ul>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>Powerups</h2>
			<p>There <a id="_idIndexMarker123"/>are many possibilities for objects that give the player a small advantage or powerup. In this section, you’ll add a powerup item that gives the player a small time bonus when collected. It will appear occasionally for a short time, and <span class="No-Break">then disappear.</span></p>
			<p>The new scene will be very similar to the <strong class="source-inline">Coin</strong> scene you already created, so click on your <strong class="source-inline">Coin</strong> scene and choose <strong class="bold">Scene</strong> -&gt; <strong class="bold">Save Scene As</strong> and save it as <strong class="source-inline">powerup.tscn</strong>. Change the name of the root node to <strong class="source-inline">Powerup</strong> and remove the script by clicking the <strong class="bold">Detach script</strong> button – <strong class="bold">&lt;</strong><span class="No-Break"><strong class="bold">IMG&gt;</strong></span><span class="No-Break">.</span></p>
			<p>In the <strong class="bold">Groups</strong> tab, remove the <strong class="source-inline">coins</strong> group by clicking the trash can button and add a new group called <span class="No-Break"><strong class="source-inline">powerups</strong></span><span class="No-Break"> instead.</span></p>
			<p>In <strong class="source-inline">AnimatedSprite2D</strong>, change the images from the coin to the powerup, which you can find in the <span class="No-Break"><strong class="source-inline">res://assets/pow/</strong></span><span class="No-Break"> folder.</span></p>
			<p>Click to add a new script and copy the code from the <span class="No-Break"><strong class="source-inline">coin.gd</strong></span><span class="No-Break"> script.</span></p>
			<p>Next, add a <strong class="source-inline">Timer</strong> node named <strong class="source-inline">Lifetime</strong>. This will limit the amount of time the object remains on the screen. Set its <strong class="bold">Wait Time</strong> value to <strong class="source-inline">2</strong> and both <strong class="bold">One Shot</strong> and <strong class="bold">Autostart</strong> to <strong class="bold">On</strong>. Connect its <strong class="source-inline">timeout</strong> signal so that the powerup can be removed at the end of the <span class="No-Break">time period:</span></p>
			<pre class="source-code">
func _on_lifetime_timout():
    queue_free()</pre>
			<p>Now, go to your <strong class="source-inline">Main</strong> scene and add another <strong class="source-inline">Timer</strong> node called <strong class="source-inline">PowerupTimer</strong>. Set its <strong class="bold">One Shot</strong> property to <strong class="bold">On</strong>. There is also a <strong class="source-inline">Powerup.wav</strong> sound in the <strong class="source-inline">audio</strong> folder that you can add with another <strong class="source-inline">AudioStreamPlayer</strong>. Connect the <strong class="source-inline">timeout</strong> signal and add the following to spawn <span class="No-Break">a powerup:</span></p>
			<pre class="source-code">
func _on_powerup_timer_timeout():
    var p = powerup_scene.instantiate()
    add_child(p)
    p.screensize = screensize
    p.position = Vector2(randi_range(0, screensize.x),
        randi_range(0, screensize.y))</pre>
			<p>The <strong class="source-inline">Powerup</strong> scene needs to be linked to a variable, as you did with the <strong class="source-inline">Coin</strong> scene, so add the following line at the top of <strong class="source-inline">main.gd</strong> and then drag <strong class="source-inline">powerup.tscn</strong> into the <span class="No-Break">new property:</span></p>
			<pre class="source-code">
@export var powerup_scene : PackedScene</pre>
			<p>The<a id="_idIndexMarker124"/> powerups should appear unpredictably, so the wait time of <strong class="source-inline">PowerupTimer</strong> needs to be set whenever you begin a new level. Add this to the <strong class="source-inline">_process()</strong> function after the new coins are spawned <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">spawn_coins()</strong></span><span class="No-Break">:</span></p>
			<p>Now, you will have powerups appearing; the last step is to give the player the ability to collect them. Currently, the player script assumes that anything it runs into is either a coin or an obstacle. Change the code in <strong class="source-inline">player.gd</strong> to check what kind of object has <span class="No-Break">been hit:</span></p>
			<pre class="source-code">
func _on_area_entered(area):
    if area.is_in_group("coins"):
        area.pickup()
        pickup.emit("coin")
    if area.is_in_group("powerups"):
        area.pickup()
        pickup.emit("powerup")
    if area.is_in_group("obstacles"):
        hurt.emit()
        die()</pre>
			<p>Note that now you emit the <strong class="source-inline">pickup</strong> signal with an additional argument that names the type of object. The corresponding function in <strong class="source-inline">main.gd</strong> must now be changed to accept that argument and decide what action <span class="No-Break">to take:</span></p>
			<pre class="source-code">
func _on_player_pickup(type):
    match type:
        "coin":
            $CoinSound.play()
            score += 1
            $HUD.update_score(score)
        "powerup":
            $PowerupSound.play()
            time_left += 5
            $HUD.update_timer(time_left)</pre>
			<p>The <strong class="source-inline">match</strong> statement <a id="_idIndexMarker125"/>is a useful alternative to <strong class="source-inline">if</strong> statements, especially when you have a large number of possible values <span class="No-Break">to test.</span></p>
			<p>Try running the game and collecting the powerup (remember, it won’t appear on level 1). Make sure the sound plays and the timer increases by <span class="No-Break">five seconds.</span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>Coin animation</h2>
			<p>When you<a id="_idIndexMarker126"/> created the coin, you used <strong class="source-inline">AnimatedSprite2D</strong>, but it isn’t playing yet. The coin animation displays a “shimmer” effect, traveling across the face of the coin. If all the coins display this at the same time, it will look too regular, so each coin needs a small random delay in <span class="No-Break">its animation.</span></p>
			<p>First, click on <strong class="source-inline">AnimatedSprite2D</strong> and then on the <strong class="source-inline">SpriteFrames</strong> resource. Make sure <strong class="bold">Animation Looping</strong> is set to <strong class="bold">Off</strong> and <strong class="bold">Speed</strong> is set to <span class="No-Break"><strong class="bold">12 FPS</strong></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B19289_02_29.jpg" alt="Figure 2.28: Animation settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.28: Animation settings</p>
			<p>Add a <strong class="source-inline">Timer</strong> node to the <strong class="source-inline">Coin</strong> scene and then add this to the <span class="No-Break">coin’s script:</span></p>
			<pre class="source-code">
func _ready():
    $Timer.start(randf_range(3, 8))</pre>
			<p>Then, connect the <strong class="source-inline">Timer</strong>’s <strong class="source-inline">timeout</strong> signal and <span class="No-Break">add this:</span></p>
			<pre class="source-code">
func _on_timer_timeout():
    $AnimatedSprite2d.frame = 0
    $AnimatedSprite2d.play()</pre>
			<p>Try running <a id="_idIndexMarker127"/>the game and watching the coins animate. It’s a nice visual effect for a very small amount of effort, at least on the part of the programmer –the artist had to draw all those frames! You’ll notice a lot of effects like this in professional games. Although subtle, the visual appeal makes for a much more <span class="No-Break">pleasing experience.</span></p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Obstacles</h2>
			<p>Finally, the<a id="_idIndexMarker128"/> game can be made more challenging by introducing an obstacle that the player must avoid. Touching the obstacle will end <span class="No-Break">the game.</span></p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B19289_02_30.jpg" alt="Figure 2.29: Example game with obstacles"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.29: Example game with obstacles</p>
			<p>Create a new <strong class="source-inline">Area2D</strong> scene and name it <strong class="source-inline">Cactus</strong>. Give it <strong class="source-inline">Sprite2D</strong> and <strong class="source-inline">CollisionShape2D</strong> children. Drag the cactus texture from <strong class="bold">FileSystem</strong> into the <strong class="bold">Texture</strong> property of <strong class="source-inline">Sprite2D</strong>. Add <strong class="source-inline">RectangleShape2D</strong> to the collision shape and size it so that it covers the image. Remember when you added <strong class="source-inline">if area.is_in_group("obstacles"?)</strong> to the player code? Add <strong class="source-inline">Cactus</strong> to the <strong class="source-inline">obstacles</strong> group using the <strong class="bold">Node</strong> tab. Play the game and see what happens when you run into <span class="No-Break">the cactus.</span></p>
			<p>You may <a id="_idIndexMarker129"/>have spotted a problem – coins can spawn on top of the cactus, making them impossible to pick up. When the coin is placed, it needs to move if it detects that it’s overlapping with the obstacle. In the <strong class="source-inline">Coin</strong> scene, connect its <strong class="source-inline">area_entered</strong> signal and add <span class="No-Break">the following:</span></p>
			<pre class="source-code">
func _on_area_entered(area):
    if area.is_in_group("obstacles"):
        position = Vector2(randi_range(0, screensize.x),
            randi_range(0, screensize.y))</pre>
			<p>If you added the <strong class="source-inline">Powerup</strong> object from the previous section, you’ll need to do the same in <span class="No-Break">its script.</span></p>
			<p>Play the<a id="_idIndexMarker130"/> game, and test that the objects all spawn correctly and that they don’t overlap with an obstacle. Running into an obstacle should end <span class="No-Break">the game.</span></p>
			<p>Do you find the game challenging or easy? Before moving on to the next chapter, take some time to think about other things you might add to this game. Go ahead and see whether you can add them, using what you’ve learned so far. If not, write them down and come back later, after you’ve learned some more techniques in the <span class="No-Break">following chapters.</span></p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor065"/>Summary</h1>
			<p>In this chapter, you learned the basics of the Godot Engine by creating a small 2D game. You set up a project and created multiple scenes, worked with sprites and animations, captured user input, used <strong class="bold">signals</strong> to communicate between nodes, and created a UI. The things you learned in this chapter are important skills that you’ll use in any <span class="No-Break">Godot project.</span></p>
			<p>Before moving to the next chapter, look through the project. Do you know what each node does? Are there any bits of code that you don’t understand? If so, go back and review that section of <span class="No-Break">the chapter.</span></p>
			<p>Also, feel free to experiment with the game and change things around. One of the best ways to get a good feel for what different parts of the game do is to change them and see <span class="No-Break">what happens.</span></p>
			<p>Remember the tip from <a href="B19289_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>? If you really want to advance your skills quickly, close this book, start a new Godot project, and try to make <em class="italic">Coin Dash</em> again without peeking. If you have to look in the book, it’s OK, but try to only look for things once you’ve tried to figure out how to do <span class="No-Break">it yourself.</span></p>
			<p>In the next chapter, you’ll explore more of Godot’s features and learn how to use more node types by building a more <span class="No-Break">complex game.</span></p>
		</div>
	</body></html>