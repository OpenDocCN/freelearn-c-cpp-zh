["```cpp\n#include <CStdLib>\n#include <CTime>\n#include <IOStream>\nusing namespace std;\nvoid main() {\n  srand((int) time(nullptr)); \n  int dice = (rand() % 6 ) + 1;\n  cout << \"Dice: \" << dice << endl;\n}\n```", "```cpp\n     class Car { \n       public: \n       Car(); \n       Car(int speed, int direction); \n       ~Car(); \n```", "```cpp\n    int getSpeed() const; \n    int getDirection() const; \n```", "```cpp\n    void accelerate(int speed); \n    void decelerate(int speed); \n    void turnLeft(int degrees); \n    void turnRight(int degrees); \n```", "```cpp\n    private: \n      int m_speed, m_direction; \n    }; \n```", "```cpp\n    #include \"Car.h\" \n```", "```cpp\nCar::Car() \n :m_speed(0), \n  m_direction(0) { \n  // Empty. \n} \n```", "```cpp\nCar::Car(int speed, int direction) \n :m_speed(speed), \n  m_direction(direction) { \n  // Empty. \n} \n```", "```cpp\nCar::Car() { \n  m_speed = 0; \n  m_direction = 0; \n} \n```", "```cpp\nCar::~Car() { \n  // Empty. \n} \n```", "```cpp\nint Car::getSpeed() const { \n  return m_speed; \n} \n\nint Car::getDirection() const { \n  return m_direction; \n} \n```", "```cpp\nvoid Car::accelerate(int speed) { \n  m_speed += speed; /* Same effect as: m_speed = m_speed + speed; */ \n} \n\nvoid Car::decelerate(int speed) { \n  m_speed -= speed; \n} \n\nvoid Car::turnLeft(int degrees) { \n  m_direction -= degrees; \n} \n\nvoid Car::turnRight(int degrees) { \n  m_direction += degrees; \n} \n```", "```cpp\n    #include <IOStream> \n    using namespace std; \n    #include \"Car.h\" \n```", "```cpp\n    void main() { \n```", "```cpp\n  Car redVolvo; \n```", "```cpp\n  cout << \"Red Volvo Speed: \" << redVolvo.getSpeed() \n       << \" miles/hour\" << \", Direction: \" \n       << redVolvo.getDirection() << \" degrees\" << endl; \n\n  redVolvo.accelerate(30); \n  redVolvo.turnRight(30); \n  cout << \"Red Volvo Speed: \" << redVolvo.getSpeed() \n       << \" miles/hour\" << \", Direction: \" \n       << redVolvo.getDirection() << \" degrees\" << endl; \n\n  redVolvo.decelerate(10); \n  redVolvo.turnLeft(10); \n  cout << \"Red Volvo Speed: \" << redVolvo.getSpeed() \n       << \" miles/hour\" << \", Direction: \" \n       << redVolvo.getDirection() << \" degrees\" << endl; \n```", "```cpp\n  const Car blueFiat(100, 90); \n  cout << \"Blue Fiat Speed: \" << blueFiat.getSpeed() \n       << \" miles/hour\" << \", Direction: \" \n       << blueFiat.getDirection() << \" degrees\" << endl; \n   } \n```", "```cpp\nclass Car { \n  public: \n    // ... \n\n  private: \n    int m_speed = 0, m_direction = 0; \n}; \n```", "```cpp\n#include \"Car.h\" \n\nCar::Car() { \n  // Empty. \n} \n\nCar::Car(int speed, int direction) \n :m_speed(speed), \n  m_direction(direction) { \n  // Empty. \n} \n```", "```cpp\nvoid Car::accelerate(int speed) { \n  m_speed += speed; \n\n  if (m_speed > 200) { \n    m_speed = 200; \n  } \n} \n```", "```cpp\nvoid Car::decelerate(int speed) { \n  m_speed -= speed; \n\n  if (m_speed < 0) { \n    m_speed = -m_speed; \n\n    if (m_speed > 200) { \n      m_speed = 200; \n    } \n\n    if (m_direction < 180) { \n      m_direction += 180; \n    } \n    else { \n      m_direction -= 180; \n    } \n  } \n} \n```", "```cpp\nvoid Car::turnLeft(int degrees) { \n  m_direction -= degrees; \n  m_direction %= 360; \n\n  if (m_direction < 0) { \n    m_direction += 360; \n  } \n} \n\nvoid Car::turnRight(int degrees) { \n  m_direction += degrees; \n  m_direction %= 360; \n} \n```", "```cpp\n#include <IOStream> \nusing namespace std; \n#include \"Car.h\" \n\nvoid main() { \n  Car redVolvo(20, 30); \n  cout << \"Red Volvo Speed: \" << redVolvo.getSpeed() \n       << \" miles/hour\" << \", Direction: \" \n       << redVolvo.getDirection() << \" degrees\" << endl; \n\n  redVolvo.accelerate(30); \n  redVolvo.turnLeft(60); \n  cout << \"Red Volvo Speed: \" << redVolvo.getSpeed() \n       << \" miles/hour\" << \", Direction: \" \n       << redVolvo.getDirection() << \" degrees\" << endl; \n\n  redVolvo.decelerate(60); \n  redVolvo.turnRight(50); \n  cout << \"Red Volvo Speed: \" << redVolvo.getSpeed() \n       << \" miles/hour\" << \", Direction: \" \n       << redVolvo.getDirection() << \" degrees\" << endl; \n} \n```", "```cpp\nclass Person { \n  public: \n    Person(string name); \n    virtual void print(); \n\n  private: \n    string m_name; \n}; \n```", "```cpp\n#include <String> \n#include <IOStream> \nusing namespace std; \n\n#include \"Person.h\" \n\nPerson::Person(string name) \n :m_name(name) { \n  // Empty. \n} \n\nvoid Person::print() { \n  cout << \"Person \" << m_name << endl; \n} \n```", "```cpp\nclass Student : public Person { \n  public: \n    Student(string name, string university); \n    void print(); \n\n  private: \n    string m_university; \n}; \n```", "```cpp\n#include <String> \n#include <IOStream> \nusing namespace std; \n\n#include \"Person.h\" \n#include \"Student.h\" \n```", "```cpp\nStudent::Student(string name, string university) \n :Person(name), \n  m_university(university) { \n  // Empty. \n} \n```", "```cpp\nvoid Student::print() { \n  Person::print(); \n  cout << \"University \" << m_university << endl; \n} \n```", "```cpp\nclass Employee : public Person { \n  public: \n    Employee(string name, string company); \n    void print(); \n\n  private: \n    string m_company; \n}; \n```", "```cpp\n#include <String> \n#include <IOStream> \nusing namespace std; \n\n#include \"Person.h\" \n#include \"Employee.h\" \n```", "```cpp\n\nEmployee::Employee(string name, string company)\n:Person(name),\nm_company(company) {\n// Empty.\n}\nvoid Employee::print() {\nPerson::print();\ncout << \"Company \" << m_company << endl;\n}\n```", "```cpp\n#include <String> \n#include <IOStream> \nusing namespace std; \n\n#include \"Person.h\" \n#include \"Student.h\" \n#include \"Employee.h\" \n```", "```cpp\nvoid main() { \n  Person monica(\"Monica\"); \n  person.print(); \n\n  Student demi(\"Demi\", \"MIT\"); \n  student.print(); \n\n  Employee charles(\"Charles\", \"Microsoft\"); \n  employee.print(); \n```", "```cpp\n    Person *personPtr; \n```", "```cpp\n    personPtr = &person; \n    personPtr->print(); \n```", "```cpp\n    personPtr = &student; \n    personPtr->print(); \n```", "```cpp\n    personPtr = &employee; \n    personPtr->print(); \n   } \n```", "```cpp\nclass Cell { \n  public: \n    Cell(int value, Cell *next); \n```", "```cpp\n    int value() const { return m_value; } \n    Cell *next() const { return m_next; } \n```", "```cpp\n  private: \n    int m_value; \n    Cell *m_next; \n}; \n```", "```cpp\n#include \"Cell.h\" \n```", "```cpp\nCell::Cell(int value, Cell *next) \n :m_value(value), \n  m_next(next) { \n  // Empty. \n} \n```", "```cpp\nclass Stack { \n  public: \n    Stack(); \n    void push(int value); \n    int top(); \n    void pop(); \n    int size() const; \n    bool empty() const; \n```", "```cpp\n  private: \n    Cell *m_firstCellPtr; \n    int m_size; \n}; \n```", "```cpp\n#include <CAssert> \nusing namespace std; \n\n#include \"Cell.h\" \n#include \"Stack.h\" \n```", "```cpp\nStack::Stack() \n :m_firstCellPtr(nullptr), \n  m_size(0) { \n  // Empty. \n} \n```", "```cpp\nvoid Stack::push(int value) { \n  m_firstCellPtr = new Cell(value, m_firstCellPtr); \n  ++m_size; \n} \n```", "```cpp\nint Stack::top() { \n  assert(!empty()); \n  return m_firstCellPtr->getValue(); \n} \n```", "```cpp\nvoid Stack::pop() { \n  assert(!empty()); \n  Cell *deleteCellPtr = m_firstCellPtr; \n  m_firstCellPtr = m_firstCellPtr->getNext(); \n  delete deleteCellPtr; \n```", "```cpp\n  --m_size; \n} \n```", "```cpp\nint Stack::size() const { \n  return m_size; \n} \n```", "```cpp\nbool Stack::empty() const { \n  return (m_firstCellPtr == nullptr); \n} \n```", "```cpp\n#include <String> \n#include <IOStream> \nusing namespace std; \n\n#include \"Cell.h\" \n#include \"Stack.h\" \n\nvoid main() { \n  Stack s; \n  s.push(1); \n  s.push(2); \n  s.push(3); \n```", "```cpp\n  cout << \"top \" << s.top() << \", size \" << s.size() \n       << \", empty \" << (s.empty() ? \"true\" : \"false\") << endl; \n\n  s.pop(); \n  s.pop(); \n  s.push(4); \n  cout << \"top \" << s.top() << \", size \" << s.size() \n       << \", empty \" << (s.empty() ? \"true\" : \"false\") << endl; \n} \n```", "```cpp\nclass Cell { \n  public: \n    Cell(int value, Cell *next); \n    int value() const {return m_value;} \n    Cell *getNext() const { return m_next; } \n    void setNext(Cell* next) { m_next = next; } \n\n  private: \n    int m_value; \n    Cell *m_next; \n}; \n```", "```cpp\nclass Queue { \n  public: \n    Queue(); \n    void enter(int value); \n    int first(); \n    void remove(); \n    int size() const; \n    bool empty() const; \n```", "```cpp\n  private: \n    Cell *m_firstCellPtr, *m_lastCellPtr; \n    int m_size; \n}; \n```", "```cpp\n#include <CAssert> \nusing namespace std; \n\n#include \"Cell.h\" \n#include \"Queue.h\" \n```", "```cpp\nQueue::Queue() \n :m_firstCellPtr(nullptr), \n  m_lastCellPtr(nullptr), \n  m_size(0) { \n  // Empty. \n} \n```", "```cpp\nvoid Queue::enter(int value) { \n  Cell *newCellPtr = new Cell(value, nullptr); \n\n  if (empty()) { \n    m_firstCellPtr = m_lastCellPtr = newCellPtr; \n  } \n  else { \n    m_lastCellPtr->setNext(newCellPtr); \n    m_lastCellPtr = newCellPtr; \n  } \n\n  ++m_size; \n} \n```", "```cpp\nint Queue::first() { \n  assert(!empty()); \n  return m_firstCellPtr->value(); \n} \n```", "```cpp\nvoid Queue::remove() { \n  assert(!empty()); \n  Cell *deleteCellPtr = m_firstCellPtr; \n  m_firstCellPtr = m_firstCellPtr->getNext(); \n  delete deleteCellPtr; \n  --m_size; \n} \n\nint Queue::size() const { \n  return m_size; \n} \n\nbool Queue::empty() const { \n  return (m_firstCellPtr == nullptr); \n} \n```", "```cpp\n#include <CMath> \n#include <String> \n#include <IOStream> \nusing namespace std; \n\n#include \"Cell.h\" \n#include \"Queue.h\" \n\nvoid main() { \n  Queue q; \n  q.enter(1); \n  q.enter(2); \n  q.enter(3); \n  cout << \"first \" << q.first() << \", size \" << q.size() \n       << \", empty \" << (q.empty() ? \"true\" : \"false\") << endl; \n\n  q.remove(); \n  q.remove(); \n  q.enter(4); \n  cout << \"first \" << q.first() << \", size \" << q.size() \n       << \", empty \" << (q.empty() ? \"true\" : \"false\") << endl; \n} \n```"]