- en: Chapter 2. Converting Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 转换数据
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Converting strings to numbers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串转换为数字
- en: Converting numbers to strings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数字转换为字符串
- en: Converting numbers to numbers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数字转换为数字
- en: Converting user-defined types to/from strings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户定义的类型转换为/从字符串转换
- en: Casting polymorphic objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换多态对象
- en: Parsing simple input
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析简单输入
- en: Parsing input
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析输入
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Now that we know some of the basic Boost types, it is time to get to know some
    data-converting functions. In this chapter we'll see how to convert strings, numbers,
    and user-defined types to each other, how to safely cast polymorphic types, and
    how to write small and large parsers right inside the C++ source files.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些基本的Boost类型，是时候了解一些数据转换函数了。在本章中，我们将看到如何将字符串、数字和用户定义的类型相互转换，如何安全地转换多态类型，以及如何在C++源文件中编写小型和大型解析器。
- en: Converting strings to numbers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将字符串转换为数字
- en: 'Converting strings to numbers in C++ makes a lot of people depressed because
    of its inefficiency and user unfriendliness. Let''s see how string `100` can be
    converted to `int`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中将字符串转换为数字让很多人感到沮丧，因为其低效和用户不友好。让我们看看如何将字符串`100`转换为`int`：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'C methods are not much better:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: C方法并不好多少：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Only basic knowledge of C++ and STL is required for this recipe.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要具备基本的C++和STL知识即可使用此菜谱。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'There is a library in Boost which will help you cope with the depressing difficulty
    of string to number conversions. It is called `Boost.LexicalCast` and consists
    of a `boost::bad_lexical_cast` exception class and a few `boost::lexical_cast`
    functions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Boost库中有一个库可以帮助你应对字符串到数字转换的令人沮丧的难度。它被称为`Boost.LexicalCast`，包括一个`boost::bad_lexical_cast`异常类和一些`boost::lexical_cast`函数：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It can even be used for non-zero-terminated strings:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它甚至可以用于非空终止的字符串：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `boost::lexical_cast` function accepts string as input and converts it
    to the type specified in triangular brackets. The `boost::lexical_cast` function
    will even check bounds for you:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::lexical_cast`函数接受字符串作为输入，并将其转换为尖括号中指定的类型。`boost::lexical_cast`函数甚至会为您检查边界：'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And also check for the correct syntax of input:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 还要检查输入的正确语法：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There's more...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Lexical cast just like all of the `std::stringstreams` classes uses `std::locale`
    and can convert localized numbers, but also has an impressive set of optimizations
    for C locale and for locales without number groupings:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 词法转换就像所有`std::stringstreams`类一样使用`std::locale`，可以转换本地化数字，但同时也有一套针对C locale和没有数字分组的locale的优化：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And that isn''t all! You can even simply create template functions for conversions
    to numbers. Let''s make a function that converts a container of some `string`
    values to a vector of `long int` values:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不算完！你甚至可以简单地创建用于转换数字的模板函数。让我们创建一个将某些`string`值容器转换为`long int`值向量的函数：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See also
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Converting numbers to strings* recipe for information about `boost::lexical_cast`
    performance.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅“将数字转换为字符串”菜谱以获取有关`boost::lexical_cast`性能的信息。
- en: 'The official documentation for `Boost.LexicalCast` contains some examples,
    performance measures, and answers to frequently asked questions. It is available
    at the following location:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.LexicalCast`的官方文档包含一些示例、性能指标和常见问题的答案。它可在以下位置找到：'
- en: '[http://www.boost.org/doc/libs/1_53_0/doc/html/boost_lexical_cast.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_lexical_cast.html)'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.boost.org/doc/libs/1_53_0/doc/html/boost_lexical_cast.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_lexical_cast.html)'
- en: Converting numbers to strings
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数字转换为字符串
- en: In this recipe we will continue discussing lexical conversions, but now we will
    be converting numbers to strings using `Boost.LexicalCast`. And as usual, `boost::lexical_cast`
    will provide a very simple way to convert the data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将继续讨论词法转换，但现在我们将使用`Boost.LexicalCast`将数字转换为字符串。像往常一样，`boost::lexical_cast`将提供一种非常简单的方法来转换数据。
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Only basic knowledge of C++ and STL is required for this recipe.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要具备基本的C++和STL知识即可使用此菜谱。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s convert integer `100` to `std::string` using `boost::lexical_cast`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`boost::lexical_cast`将整数`100`转换为`std::string`：
- en: '[PRE8]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Compare this to the traditional C++ conversion method:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它与传统的C++转换方法进行比较：
- en: '[PRE9]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And against the C conversion method:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与C转换方法相反：
- en: '[PRE10]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::lexical_cast` function may also accept numbers as input and convert
    them to the string type specified in triangular brackets. Pretty close to what
    we did in the previous recipe.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::lexical_cast` 函数也可以接受数字作为输入，并将它们转换为尖括号中指定的字符串类型。这与我们在上一个菜谱中所做的是非常相似的。'
- en: There's more...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A careful reader will note that in the case of `lexical_cast` we have an additional
    call to string copy the constructor and that such a call will be a hit on the
    performance. It is true, but only for old or bad compilers. Modern compilers implement
    a **named return value optimization** (**NRVO**), which will eliminate the unnecessary
    call to copy the constructor and destructor. Even if the C++11-compatible compilers
    don't detect NRVO, they will use a move copy constructor of `std::string`, which
    is fast and efficient. The *Performance* section of the `Boost.LexicalCast` documentation
    shows the conversion speed on different compilers for different types, and in
    most cases `lexical_cast` is faster than the `std::stringstream` and `printf`
    functions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细的读者会注意到，在 `lexical_cast` 的情况下，我们有一个额外的调用到字符串拷贝构造函数，并且这样的调用将对性能产生影响。这是真的，但仅限于旧或差的编译器。现代编译器实现了**命名返回值优化**（**NRVO**），这将消除对拷贝构造函数和析构函数的不必要调用。即使与
    C++11 兼容的编译器没有检测到 NRVO，它们也会使用 `std::string` 的移动拷贝构造函数，这是快速且高效的。`Boost.LexicalCast`
    文档的 *性能* 部分显示了不同编译器对不同类型的转换速度，在大多数情况下 `lexical_cast` 比标准库的 `std::stringstream`
    和 `printf` 函数更快。
- en: If `boost::array` or `std::array` is passed to `boost::lexical_cast` as the
    output parameter type, less dynamic memory allocations will occur (or there will
    be no memory allocations at all; it depends on the `std::locale` implementation).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将 `boost::array` 或 `std::array` 作为输出参数类型传递给 `boost::lexical_cast`，将减少动态内存分配（或者根本不会进行内存分配；这取决于
    `std::locale` 的实现）。
- en: See also
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Boost's official documentation contains tables that compare the `lexical_cast`
    performance against other conversion approaches. And in most cases it wins. [http://www.boost.org/doc/libs/1_53_0/doc/html/boost_lexical_cast.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_lexical_cast.html).
    It also has some more examples and a frequently asked questions section.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost 的官方文档包含表格，比较 `lexical_cast` 的性能与其他转换方法。在大多数情况下，它都胜出。[http://www.boost.org/doc/libs/1_53_0/doc/html/boost_lexical_cast.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_lexical_cast.html)。它还有一些更多示例和一个常见问题解答部分。
- en: The *Converting strings to numbers* recipe.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将字符串转换为数字* 的菜谱。'
- en: The *Converting user-defined types to/from strings* recipe.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将用户定义类型转换为字符串或从字符串转换* 的菜谱。'
- en: Converting numbers to numbers
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数字转换为数字
- en: 'You might remember situations where you wrote something like the following
    code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得你编写过如下代码的情况：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Usually, programmers just ignore such warnings by implicitly casting to unsigned
    short datatype, as demonstrated in the following code snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，程序员只是通过隐式转换为无符号短整型数据类型来忽略这样的警告，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But this may make it extremely hard to detect errors. Such errors may exist
    in code for years before they get caught:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但这可能会使检测错误变得极其困难。这样的错误可能在代码中存在数年才被发现：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Only basic knowledge of C++ is required for this recipe.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，只需要基本的 C++ 知识。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The library `Boost.NumericConversion` provides a solution for such cases. And
    it is easy to modify the existing code to use safe casts, just replace `static_cast`
    with `boost::numeric_cast`. It will throw an exception when the source value cannot
    be stored in the target. Let''s take a look at the following example:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 库 `Boost.NumericConversion` 为此类情况提供了一个解决方案。并且很容易修改现有的代码以使用安全的转换，只需将 `static_cast`
    替换为 `boost::numeric_cast`。如果源值无法存储在目标中，它将抛出一个异常。让我们看看以下示例：
- en: '[PRE14]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now if we run `test_function()` it will output the following:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们运行 `test_function()`，它将输出以下内容：
- en: '[PRE15]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can even detect specific overflow types:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们甚至可以检测特定的溢出类型：
- en: '[PRE16]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `test_function1()`function will output the following:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`test_function1()` 函数将输出以下内容：'
- en: '[PRE17]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It checks if the value of the input parameter fits into the new type without
    losing data and throws an exception if something is lost during conversion.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它检查输入参数的值是否可以适合新类型而不丢失数据，如果在转换过程中丢失了数据，它将抛出一个异常。
- en: The `Boost.NumericConversion` library has a very fast implementation; it can
    do a lot of work at compile time. For example, when converting to types of a wider
    range, the source will just call the `static_cast` method.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.NumericConversion` 库有一个非常快速的实现；它可以在编译时完成大量工作。例如，当转换为范围更广的类型时，源代码将直接调用
    `static_cast` 方法。'
- en: There's more...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `boost::numeric_cast` function is implemented via `boost::numeric::converter`,
    which can be tuned to use different overflow, range checking, and rounding policies.
    But usually, `numeric_cast` is just what you need.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::numeric_cast` 函数是通过 `boost::numeric::converter` 实现的，它可以调整以使用不同的溢出、范围检查和舍入策略。但通常，`numeric_cast`
    就是您所需要的。'
- en: 'Here is a small example that demonstrates how to make our own `mythrow_overflow_handler`
    overflow handler for `boost::numeric::cast`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小例子，演示了如何为 `boost::numeric::cast` 创建我们自己的 `mythrow_overflow_handler` 过滤器：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And this will output the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: See also
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Boost''s official documentation contains detailed descriptions of all of the
    template parameters of the numeric converter; it is available at the following
    link:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost 的官方文档包含了所有数值转换模板参数的详细描述；它可以在以下链接找到：
- en: '[http://www.boost.org/doc/libs/1_53_0/libs/numeric/conversion/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/numeric/conversion/doc/html/index.html)'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.boost.org/doc/libs/1_53_0/libs/numeric/conversion/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/numeric/conversion/doc/html/index.html)'
- en: Converting user-defined types to/from strings
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将用户定义类型转换为/从字符串
- en: There is a feature in `Boost.LexicalCast` that allows users to use their own
    types in `lexical_cast`. This feature just requires the user to write the correct
    `std::ostream` and `std::istream` operators for their types.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.LexicalCast` 有一个特性允许用户在 `lexical_cast` 中使用他们自己的类型。这个特性只需要用户为他们自己的类型编写正确的
    `std::ostream` 和 `std::istream` 操作符。'
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'All you need is to provide an `operator<< and operator>> stream` operators.
    If your class is already streamable, nothing needs to be done:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您只需要提供一个 `operator<<` 和 `operator>>` 流操作符。如果您的类已经是可流的，则不需要做任何事情：
- en: '[PRE20]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we may use `boost::lexical_cast` for conversions to and from the `negative_number`
    class. Here''s an example:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用 `boost::lexical_cast` 来将 `negative_number` 类转换为其他类型，以及从其他类型转换为 `negative_number`
    类。以下是一个例子：
- en: '[PRE21]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::lexical_cast` function can detect and use stream operators for converting
    user-defined types.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::lexical_cast` 函数可以检测并使用流操作符来转换用户定义的类型。'
- en: The `Boost.LexicalCast` library has many optimizations for basic types and they
    will be triggered when a user-defined type is being cast to basic type or when
    a basic type is being cast to a user-defined type.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.LexicalCast` 库为基本类型提供了许多优化，当用户定义类型被转换为基本类型或基本类型被转换为用户定义类型时，这些优化会被触发。'
- en: There's more...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `boost::lexical_cast` function may also convert to wide character strings,
    but the correct `basic_istream` and `basic_ostream` operator overloads are required
    for that:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::lexical_cast` 函数也可以转换为宽字符字符串，但需要正确的 `basic_istream` 和 `basic_ostream`
    操作符重载：'
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `Boost.LexicalCast` library is not a part of C++11, but there is a proposal
    to add it to C++ standard. A lot of Boost libraries use it and I hope that it
    will make your life easier as well.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.LexicalCast` 库不是 C++11 的一部分，但有一个提议将其添加到 C++ 标准中。许多 Boost 库都使用它，并希望它也能使您的生活更轻松。'
- en: See also
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The `Boost.LexicalCast` documentation contains some examples, performance measures,
    and answers to frequently asked questions; it is available at [http://www.boost.org/doc/libs/1_53_0/doc/html/boost_lexical_cast.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_lexical_cast.html)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.LexicalCast` 文档包含了一些示例、性能指标和常见问题的答案；它可以在 [http://www.boost.org/doc/libs/1_53_0/doc/html/boost_lexical_cast.html](http://www.boost.org/doc/libs/1_53_0/doc/html/boost_lexical_cast.html)
    找到'
- en: The *Converting strings to numbers* recipe
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将字符串转换为数字* 的配方'
- en: The *Converting numbers to strings* recipe
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将数字转换为字符串* 的配方'
- en: Casting polymorphic objects
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换多态对象
- en: 'Imagine that some programmer designed an awful interface as follows (this is
    a good example of how interfaces should not be written):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，某个程序员设计了一个糟糕的接口，如下所示（这是一个接口不应该如何编写的良好例子）：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And our task is to make a function that eats bananas, and throws exceptions
    if something instead of banana came along (eating pidgins gross!). If we dereference
    a value returned by the `try_produce_banana()` function, we are getting in danger
    of dereferencing a null pointer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是创建一个吃香蕉的函数，如果遇到的不是香蕉而是其他东西（吃洋泾浜语很恶心！），则抛出异常。如果我们尝试取消引用 `try_produce_banana()`
    函数返回的值，我们就会处于取消引用空指针的危险之中。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ is required for this recipe.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，需要具备基本的 C++ 知识。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'So we need to write the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要编写以下代码：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Ugly, isn''t it? `Boost.Conversion` provides a slightly better solution:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很糟糕，不是吗？`Boost.Conversion` 提供了一个稍微好一点的解决方案：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::polymorphic_cast` function just wraps around code from the first
    example, and that is all. It checks input for null and then tries to do a dynamic
    cast. Any error during those operations will throw a `std::bad_cast` exception.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::polymorphic_cast` 函数只是围绕第一个示例中的代码进行包装，仅此而已。它会检查输入是否为空，然后尝试进行动态转换。在这些操作过程中出现的任何错误都将抛出
    `std::bad_cast` 异常。'
- en: There's more...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Boost.Conversion` library also has a `polymorphic_downcast` function, which
    should be used only for downcasts that will always succeed. In debug mode (when
    `NDEBUG` is not defined) it will check for the correct downcast using `dynamic_cast`.
    When `NDEBUG` is defined, the `polymorphic_downcast` function will just do a `static_cast`
    operation. It is a good function to use in performance-critical sections, while
    still leaving the ability to detect errors in debug compilations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Conversion` 库还有一个 `polymorphic_downcast` 函数，它应该仅用于始终成功的向下转换。在调试模式（当
    `NDEBUG` 未定义时）中，它将使用 `dynamic_cast` 检查正确的向下转换。当 `NDEBUG` 定义时，`polymorphic_downcast`
    函数将仅执行 `static_cast` 操作。这是一个在性能关键部分使用的好函数，同时仍然能够在调试编译中检测到错误。'
- en: See also
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Initially, the `polymorphic_cast` idea was proposed in the book *The C++ Programming
    Language*, *Bjarne Stroustrup*. Refer to this book for more information and some
    good ideas on different topics.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`polymorphic_cast` 的想法最初是在书籍 *《C++编程语言》* 中提出的，作者是 *Bjarne Stroustrup*。有关更多信息以及不同主题的一些好主意，请参阅此书。'
- en: The official documentation may also be helpful; it is available at [http://www.boost.org/doc/libs/1_53_0/libs/conversion/cast.htm](http://www.boost.org/doc/libs/1_53_0/libs/conversion/cast.htm).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方文档也可能很有帮助；它可在 [http://www.boost.org/doc/libs/1_53_0/libs/conversion/cast.htm](http://www.boost.org/doc/libs/1_53_0/libs/conversion/cast.htm)
    找到。
- en: Parsing simple input
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析简单输入
- en: 'It is a common task to parse a small text. And such situations are always a
    dilemma: shall we use some third-party professional tools for parsing such as
    Bison or ANTLR, or shall we try to write it by hand using only C++ and STL? The
    third-party tools are good for handling the parsing of complex texts and it is
    easy to write parsers using them, but they require additional tools for creating
    C++ or C code from their grammar, and add more dependencies to your project. Handwritten
    parsers are usually hard to maintain, but they require nothing except C++ compiler.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 解析一小段文本是一个常见的任务。在这种情况下，我们常常面临一个困境：我们应该使用一些第三方专业工具进行解析，比如 Bison 或 ANTLR，还是尝试仅使用
    C++ 和 STL 手动编写它？第三方工具在处理复杂文本的解析方面表现良好，使用它们编写解析器也很容易，但它们需要额外的工具来从它们的语法中创建 C++ 或
    C 代码，并给项目添加更多的依赖。手写的解析器通常难以维护，但它们只需要 C++ 编译器。
- en: '![Parsing simple input](img/4880OS_02_02.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![解析简单输入](img/4880OS_02_02.jpg)'
- en: 'Let''s start with a very simple task to parse a date in ISO format as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的任务开始，解析 ISO 格式的日期，如下所示：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following are the examples of possible input:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可能的输入示例：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s take a look at the parser''s grammar from the following link [http://www.ietf.org/rfc/rfc3339.txt](http://www.ietf.org/rfc/rfc3339.txt):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下链接中的解析器语法 [http://www.ietf.org/rfc/rfc3339.txt](http://www.ietf.org/rfc/rfc3339.txt)：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you are familiar with the placeholders concept or read the *Reordering
    the parameters of function* and *Binding a value as a function parameter* recipes
    in [Chapter 1](ch01.html "Chapter 1. Starting to Write Your Application"), *Starting
    to Write Your Application*. Basic knowledge of parsing tools would be good.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你熟悉占位符的概念，或者阅读 [第 1 章](ch01.html "第 1 章。开始编写您的应用程序") 中的 *重新排序函数参数* 和 *将值绑定为函数参数*
    食谱，*开始编写您的应用程序*。对解析工具的基本了解也会很有帮助。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Let me introduce you to a `Boost.Spirit` library. It allows writing parsers
    (and lexers and generators) directly in C++ code format, which are immediately
    executable (that is, do not require additional tools for C++ code generation).
    The grammar of `Boost`.`Spirit` is very close to **Extended Backus-Naur Form**
    (**EBNF**), which is used for expressing grammar by many standards and understood
    by other popular parsers. The grammar at the beginning of this chapter is in EBNF.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我向你介绍 `Boost.Spirit` 库。它允许直接在 C++ 代码格式中编写解析器（以及词法分析和生成器），它们可以立即执行（也就是说，不需要额外的工具来生成
    C++ 代码）。`Boost.Spirit` 的语法非常接近 **扩展巴科斯-诺尔范式**（**EBNF**），它被许多标准用于表达语法，并且被其他流行的解析器所理解。本章开头的语法是
    EBNF 格式。
- en: 'We need to include the following headers:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要包含以下头文件：
- en: '[PRE29]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now it''s time to make a `date` structure to hold the parsed data:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候创建一个 `date` 结构来保存解析的数据了：
- en: '[PRE30]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now let''s look at the parser (a step-by-step description of how it works can
    be found in the next section):'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看看解析器（关于它是如何一步步工作的详细描述可以在下一节找到）：
- en: '[PRE31]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we may use this parser wherever we want:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在这个解析器想要使用的地方使用它：
- en: '[PRE32]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This is a very simple implementation; it does not check the digit count for
    numbers. Parsing occurs in the `boost::spirit::qi::parse` function. Let''s simplify
    it a little bit, removing the actions on successful parsing:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的实现；它不会检查数字的位数。解析发生在 `boost::spirit::qi::parse` 函数中。让我们稍微简化一下，移除成功的解析上的动作：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `first` argument points to the beginning of the data to parse; it must be
    a modifiable (non-constant) variable because the `parse` function will use it
    to show the end of the parsed sequence. The `end` argument points to the element
    beyond the last one. `first` and `end` shall be iterators.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`first` 参数指向要解析的数据的开始；它必须是一个可修改的（非常量）变量，因为 `parse` 函数将使用它来显示解析序列的结束。`end` 参数指向最后一个元素之后的元素。`first`
    和 `end` 应该是迭代器。'
- en: 'The third argument to the function is a parsing rule. And it does exactly what
    is written in the EBNF rule:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第三个参数是一个解析规则。它确实做了 EBNF 规则中写的那样的事情：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We just replaced white spaces with the `>>` operator.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是用 `>>` 操作符替换了空白。
- en: The `parse` function returns true on success. If we want to make sure that the
    whole string was successfully parsed, we need to check for the parser's return
    value and equality of the input iterators.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse` 函数在成功时返回 true。如果我们想确保整个字符串都被成功解析，我们需要检查解析器的返回值和输入迭代器的相等性。'
- en: Now we need to deal with the actions on successful parse and this recipe will
    be over. Semantic actions in `Boost.Spirit` are written inside `[]` and they can
    be written using function pointers, function objects, `boost::bind`, `std::bind`
    (or the other `bind()` implementations), or C++11 lambda functions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要处理成功的解析上的动作，这个配方就完成了。`Boost.Spirit` 中的语义动作写在 `[]` 内，并且可以使用函数指针、函数对象、`boost::bind`、`std::bind`（或其他的
    `bind()` 实现）或 C++11 lambda 函数来编写。
- en: 'So, you could also write a rule for `YYYY` using C++11 lambda:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你也可以用 C++11 lambda 为 `YYYY` 编写一个规则：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s take a look at the month''s semantic action closer:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更仔细地看看这个月的语义动作：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For those who have read the book from the beginning, this would remind you about
    `boost::bind` and placeholders. `ref(res.month)` means pass `res.month` as a modifiable
    reference and `_1` means the first input parameter, which would be a number (the
    result of `ushort_ parsing`).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些从开始就阅读这本书的人来说，这会让你想起 `boost::bind` 和占位符。`ref(res.month)` 表示将 `res.month`
    作为可修改的引用传递，而 `_1` 表示第一个输入参数，它将是一个数字（`ushort_` 解析的结果）。
- en: There's more...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'Now let''s modify our parser, so it can take care of the digits count. For
    that purpose, we will take the `unit_parser` template class and just set up the
    correct parameters:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们修改我们的解析器，使其能够处理数字的位数。为此，我们将使用 `unit_parser` 模板类并设置正确的参数：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Don't worry if those examples seem complicated. The first time I was also frightened
    by `Boost.Spirit`, but now it really simplifies my life. You are extremely brave,
    if this code does not scare you.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些例子看起来很复杂，请不要担心。我第一次接触 `Boost.Spirit` 时也感到很害怕，但现在它真的简化了我的生活。如果你不害怕这段代码，你非常勇敢。
- en: 'If you want to avoid code bloat, try to write parsers in source files and not
    in headers. Also take care of iterator types passed to the `boost::spirit::parse`
    function, the fewer different types of iterators you use, the smaller binary you''ll
    get. Writing parsers in source files has one more advantage: it does not slow
    down the project compilation (as you may notice, the `Spirit` parsers are slow
    to compile, so it is better to compile them once in the source file, than define
    them in the header files and use this file all around the project).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想避免代码膨胀，尽量在源文件中编写解析器，而不是在头文件中。还要注意传递给 `boost::spirit::parse` 函数的迭代器类型，你使用的迭代器类型越少，二进制文件就越小。在源文件中编写解析器还有一个优点：它不会减慢项目的编译速度（正如你可能注意到的，`Spirit`
    解析器编译速度较慢，所以最好在源文件中编译它们，而不是在头文件中定义它们并在整个项目中使用这个文件）。
- en: If you are now thinking that parsing dates was simpler to implement by hand
    using STL... you are right! But only for now. Take a look at the next recipe;
    it will give you more examples on `Boost.Spirit` usage and extend this example
    for a situation when writing the parser by hand is harder than using `Boost.Spirit`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在认为通过手动使用 STL 实现日期解析要简单一些...你是正确的！但仅限现在。看看下一个配方；它将给出更多关于 `Boost.Spirit`
    使用的示例，并扩展这个示例，说明手动编写解析器比使用 `Boost.Spirit` 更困难的情况。
- en: The `Boost.Spirit` library is not a part of C++11 and as far as I know, it is
    not proposed for inclusion in the closest upcoming C++ standard.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Spirit` 库不是 C++11 的一部分，据我所知，它也没有被提议纳入即将到来的最近的 C++ 标准。'
- en: See also
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Reordering the parameters of function* recipe in [Chapter 1](ch01.html
    "Chapter 1. Starting to Write Your Application"), *Starting to Write Your Application*.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章。开始编写您的应用程序")中的*重新排列函数参数*配方，*开始编写您的应用程序*。'
- en: The *Binding a value as a function parameter* recipe.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将值绑定为函数参数*配方。'
- en: '`Boost.Spirit` is a huge header-only library. A separate book may be written
    about it, so feel free to use its documentation [http://www.boost.org/doc/libs/1_53_0/libs/spirit/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/spirit/doc/html/index.html).
    You may also find information on how to write lexers and generators directly in
    C++11 code using Boost.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Spirit` 是一个巨大的仅头文件库。可能有一本单独的书来介绍它，所以请自由使用它的文档 [http://www.boost.org/doc/libs/1_53_0/libs/spirit/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/spirit/doc/html/index.html)。你还可以找到有关如何在
    C++11 代码中直接编写词法分析和生成器的信息。'
- en: Parsing input
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析输入
- en: 'In the previous recipe we were writing a simple parser for dates. Imagine that
    some time has passed and the task has changed. Now we need to write a date-time
    parser that will support multiple input formats plus zone offsets. So now our
    parser should understand the following inputs:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们编写了一个简单的日期解析器。想象一下，时间已经过去，任务已经改变。现在我们需要编写一个支持多种输入格式以及时区偏移的日期时间解析器。因此，现在我们的解析器应该能够理解以下输入：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll be using the `Spirit` library, which was described in the *Parsing simple
    input* recipe. Read it before getting hands on with this recipe.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在 *解析简单输入* 配方中描述的 `Spirit` 库。在动手做这个配方之前，请先阅读它。
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s start with writing a date-time structure that will hold a parsed result:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从编写一个将保存解析结果的日期时间结构开始：
- en: '[PRE39]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now let''s write a function for setting the zone offset:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个设置时区偏移的函数：
- en: '[PRE40]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Writing a parser can be split into writing a few simple parsers, so we start
    with writing a zone-offset parser.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写解析器可以分解为编写几个简单的解析器，所以我们首先从编写时区偏移解析器开始。
- en: '[PRE41]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s finish our example by writing the remaining parsers:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过编写剩余的解析器来完成我们的示例：
- en: '[PRE42]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A very interesting method here is `boost::spirit::qi::rule<const char*, void()>`.
    It erases the type and allows you to write parsers in source files and export
    them to headers. For example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个非常有趣的方法是 `boost::spirit::qi::rule<const char*, void()>`。它消除了类型，并允许你在源文件中编写解析器并将它们导出到头文件中。例如：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: But remember that this class implies an optimization barrier for compilers,
    so do not use it when it is not required.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，这个类对编译器来说是一个优化障碍，所以当不需要时不要使用它。
- en: There's more...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can make our example slightly faster by removing the `rule<>` objects that
    do type erasure. For our example in C++11, we can just replace them with the `auto`
    keyword.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过移除执行类型擦除的 `rule<>` 对象来使我们的示例稍微快一点。对于我们的 C++11 示例，我们可以直接用 `auto` 关键字替换它们。
- en: The `Boost.Spirit` library generates very fast parsers; there are some performance
    measures at the official site. There are also some recommendations for working
    with the `Boost.Spirit` library; one of them is to generate a parser only once,
    and then just re-use it (in our example this is not shown).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Spirit` 库生成的解析器非常快；官方网站上有一些性能指标。还有一些关于如何使用 `Boost.Spirit` 库的建议；其中之一是只生成一次解析器，然后重复使用它（在我们的示例中未展示）。'
- en: The rule that parses specific zone offset in `timezone_parser` uses the `boost::phoenix::bind`
    call, which is not mandatory. However, without it we'll be dealing with `boost::fusion::vector<char,
    unsigned short, unsigned short>`, which is not as user friendly as `bind(&set_zone_offset,
    ref(ret), _1, _2, _3)`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `timezone_parser` 中解析特定时区偏移量的规则使用了 `boost::phoenix::bind` 调用，这不是强制性的。然而，没有它，我们将处理
    `boost::fusion::vector<char, unsigned short, unsigned short>`，这不如 `bind(&set_zone_offset,
    ref(ret), _1, _2, _3)` 用户友好。
- en: When parsing large files, consider reading the *The fastest way to read files*
    recipe in [Chapter 11](ch11.html "Chapter 11. Working with the System"), *Working
    with the System*, because incorrect work with files may slow down your program
    much more than parsing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析大文件时，请考虑阅读 [第 11 章](ch11.html "第 11 章。与系统交互") 中关于 *最快读取文件的方法* 的菜谱，因为不正确地处理文件可能会比解析更大幅度地减慢您的程序。
- en: Compiling the code that uses the library `Boost.Spirit` (or `Boost.Fusion`)
    may take a lot of time, because of a huge number of template instantiations. When
    experimenting with the `Boost.Spirit` library use modern compilers, they provide
    better compilation times.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 编译使用库 `Boost.Spirit`（或 `Boost.Fusion`）的代码可能需要很长时间，因为模板实例化数量巨大。当在 `Boost.Spirit`
    库上进行实验时，请使用现代编译器，它们提供更好的编译时间。
- en: See also
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The `Boost.Spirit` library is worth writing a separate book on. It's impossible
    to describe all of its features in a few recipes, so referring to the documentation
    will help you to get more information about it. It is available at [http://www.boost.org/doc/libs/1_53_0/libs/spirit/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/spirit/doc/html/index.html).
    There you'll find many more examples, ready parsers, and information on how to
    write lexers and generators directly in C++11 code using Boost.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Spirit` 库值得专门写一本书来介绍。不可能在几个菜谱中描述其所有功能，因此参考文档将帮助您获取更多关于它的信息。它可在 [http://www.boost.org/doc/libs/1_53_0/libs/spirit/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/spirit/doc/html/index.html)
    找到。在那里您会发现更多示例、现成的解析器和有关如何直接在 C++11 代码中使用 Boost 编写词法分析和生成器的信息。'
