- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging and Profiling the Network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With [*Chapter 9*](B18527_09.xhtml#_idTextAnchor188), *Creating an Online Adventure
    Prototype*, we concluded *Part 2*, *Creating Online Multiplayer Mechanics*, of
    our journey, where we learned how we can use Godot Engine’s High-Level Network
    API to turn local gameplay mechanics into online multiplayer mechanics. Now, it’s
    time to go beyond implementation and start the optimization of our mechanics.
    This chapter inaugurates *Part 3*, *Optimizing the Online Experience*, of our
    journey through creating online multiplayer games with Godot Engine.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important that you have read, understood, and implemented the content provided
    in [*Chapter 9*](B18527_09.xhtml#_idTextAnchor188)*, Creating an Online Adventure
    Prototype,* because we are going to use the final project as our main subject
    through the following chapters in *Part 3*.
  prefs: []
  type: TYPE_NORMAL
- en: In this specific chapter, we are going to understand how we can use Godot Engine’s
    built-in `MultiplayerSynchronizers` are performing, giving us a good overview
    of potential issues in our network implementation. Finally, we are going to learn
    how to use the Debugger dock’s `Performance` singleton to figure out potential
    bottlenecks in our game and gather data to design potential solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will understand how to use the powerful Debugger
    tools, and the elements in the following figure won’t scare you anymore; instead,
    they will be some of your most reliable allies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – The Debugger’s Network Profiler (top) and Monitors (bottom)
    showing and plotting profiling data](img/Figure_10.1_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – The Debugger’s Network Profiler (top) and Monitors (bottom) showing
    and plotting profiling data
  prefs: []
  type: TYPE_NORMAL
- en: Don’t be surprised if you come back to this figure at the end of the chapter
    and understand what each of those graphs and charts means. You will get used to
    them, as they will appear in abundance throughout the next chapters, especially
    [*Chapter 11*](B18527_11.xhtml#_idTextAnchor276)*,* *Optimizing* *Data Requests*.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned previously, it’s crucial that you’ve read and followed the instructions
    provided in [*Chapter 9*](B18527_09.xhtml#_idTextAnchor188), *Creating an Online
    Adventure Prototype*. Here, in this chapter, we are going to use the final product
    you should have by the end of the previous chapter. You can access the resources
    for this chapter in the repository provided in the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0)'
  prefs: []
  type: TYPE_NORMAL
- en: With the result of [*Chapter 9*](B18527_09.xhtml#_idTextAnchor188)*,* *Creating
    an Online Adventure Prototype,* ready, we can move on to understanding how we
    can improve it.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Godot’s Debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Debugger is a developer’s best friend. Most of the work we do doesn’t have
    anything to do with creating and implementing features; instead, it has everything
    to do with assessing potential problems these implementations cause and fixing
    them. The **Debugger** dock is where Godot Engine talks to us, showing errors,
    warnings, resource consumption, object count, and more. So, we should listen carefully
    and properly address the issues and data it shows us. We can even ask it to track
    custom data, as we are going to see in the *Using the Monitors* *tab* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have been developing games with Godot Engine for enough time to run
    into errors, you have probably stumbled on the **Debugger** dock more than you’d
    like to, right? In this section, we will go in-depth to understand how to turn
    it into our best friend and actually wish it pops up. Let’s start by understanding
    each of its tabs, how to read them, and what to expect from them, starting with
    the most common and probably the one you’ve already had a hard time with: the
    **Stack** **Trace** tab.'
  prefs: []
  type: TYPE_NORMAL
- en: Mastering the Stack Trace tab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you click on the **Debugger** dock, Godot Engine’s editor will open the
    **Stack Trace** tab. Let’s use the following figure to navigate it and understand
    what each of its elements does.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The Debugger dock’s Stack Trace tab and its elements](img/Figure_10.2_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – The Debugger dock’s Stack Trace tab and its elements
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that each element of the **Stack Trace** tab in the figure is associated
    with a number, which will facilitate a better understanding. In the following
    list, we have the element’s name and a brief explanation about it:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Stack Frames** panel is the stack of functions that leads to an error
    or a breakpoint (highlighted and marked with **1** in *Figure 10**.2*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Filter Stack Variables** field is where you can filter variable names
    to display them in the panel below (highlighted and marked with **2** in *Figure
    10**.2*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Members** panel is where you can find the variables within a given script
    including temporary variables and scope-specific variables. Here, you can also
    see and edit their values (highlighted and marked with **3** in *Figure 10**.2*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Breakpoints** panel is where you can see information about a breakpoint
    reached in the script of a given instance (highlighted and marked with **4** in
    *Figure 10**.2*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Skip Breakpoints** button, when toggled on, allows the execution of the
    game to run ignoring breakpoints (highlighted and marked with **5** in *Figure
    10**.2*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Copy Error** button copies the current error, if any, to your clipboard
    (highlighted and marked with **6** in *Figure 10**.2*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clicking on the **Step Into** button when the application is paused, including
    when it reaches a breakpoint, will execute the next script instruction (i.e.,
    line). It will enter in indented blocks it would naturally go into, executing
    the whole code (highlighted and marked with **7** in *Figure 10**.2*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clicking on the **Step Over** button when the application is paused, including
    when it reaches a breakpoint, will execute the next script instruction (i.e.,
    line) but skip indented blocks (highlighted and marked with **8** in *Figure 10**.2*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Break** button pauses the application as if it reached a breakpoint (highlighted
    and marked with **9** in *Figure 10**.2*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Continue** button resumes the application if it was paused (highlighted
    and marked with **10** in *Figure 10**.2*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these elements at our disposal, we have the ability to experiment with
    our scripts and gather invaluable information about our game. For instance, we
    can see step by step how Godot Engine processes a given set of instructions using
    the **Step Into** button and see the stack of functions it executes and how the
    objects’ variables change with each step.
  prefs: []
  type: TYPE_NORMAL
- en: A cool tip to use this to its fullest is to not be afraid to add breakpoints
    all over your scripts to understand when, what, how, and why your objects change
    and the whole chain of events that caused such changes.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ve gone through the **Stack Trace** tab, which gives us
    an overview of our game’s flow and provides us with multiple ways of gathering
    information about the changes that happen through this flow, allowing us to understand
    the whole chain of cause-effects that led to a given change. This is especially
    helpful together with our next tab, the **Errors** tab. Let’s talk about it in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with the Errors tab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It may sound weird but, in many situations, you might wish for Godot Engine
    to prompt an error, especially when dealing with network features, as sometimes
    you are left waiting for something to happen. And if the packets sent don’t reach
    their destination, you will be hanging there waiting for an error to pop up, but
    packets not reaching their destination isn’t an error in itself. Still, it’s an
    undesired situation that can leave you confused.
  prefs: []
  type: TYPE_NORMAL
- en: The **Errors** tab is where you work with thousands of other developers, who
    worked on the development of Godot Engine’s core and identified thousands of errors
    and documented them so that when they happen, you have some light on the issue
    and are able to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, not only errors are displayed in this tab. The **Errors** tab also
    shows warnings about your script. They don’t necessarily break your application
    but are something you should be aware of and make a decision on. For instance,
    it’s common to get warnings about arguments in a function that are not being used
    in the function’s implementation. The following figure displays the **Error**
    tab and its elements associated with numbers, just like in the *Mastering the
    Stack Trace* *tab* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – The Session 1 Debugger dock’s Errors tab and its elements](img/Figure_10.03_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – The Session 1 Debugger dock’s Errors tab and its elements
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s understand what each of these elements is and how they can be useful
    for us:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Errors and Warnings** panel is where all the warnings and fatal and non-fatal
    errors are displayed. You can click on an error or warning to expand it and go
    to the script line that triggered it. You can also double-click to expand an error
    or warning and display the code stack that led to the error. When you double-click
    an expanded error or warning, you collapse it (highlighted and marked with **1**
    in *Figure 10**.3*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Expand All** button expands all the errors and warnings (highlighted and
    marked with **2** in *Figure 10**.3*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Collapse All** button collapses all the errors and warnings (highlighted
    and marked with **3** in *Figure 10**.3*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Clear** button empties the **Errors and Warnings** panel (highlighted
    and marked with **4** in *Figure 10**.3*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Something interesting about dealing with errors and warnings is that you can
    create your own error or warning messages. This is especially good when working
    with your teammates, but also, since we are working with more than one instance
    of the game running, it’s a good way to compartmentalize messages to their instance’s
    `print()` statement is coming from. So you can use the `push_error()` and `push_warning()`
    built-in methods instead and Godot will only show them in the game session’s **Debugger**
    dock that triggered the error or warning. The following figure showcases the **Error**
    tab of **Session 3** with a custom warning expanded so we can see where it comes
    from:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – The Session 3 Errors tab highlighting a custom warning among
    other built-in warnings](img/Figure_10.4_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – The Session 3 Errors tab highlighting a custom warning among other
    built-in warnings
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the **Debugger** button at the bottom tells us there’s a total of
    20 errors and warnings, but when we open the **Errors** tab in **Session 3**,
    there are only 13\. This is because the other errors come from other sessions
    and are in their respective **Errors** tabs.
  prefs: []
  type: TYPE_NORMAL
- en: With this powerful tool in our arsenal, we can trigger all sorts of errors and
    warnings in each individual game session, allowing us to distinguish which session
    is the server, which ones are players if any peer is getting a specific error
    that others aren’t, and so on. In the next section, we will talk about our first
    performance-based debugging tab, the **Profiler** tab, where we can see how our
    game is performing, how many resources it is taking, and which objects and functions
    are taking the most out of our computer.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Profiler tab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most developers are always looking for the most efficient, cheap, and ingenious
    optimizations to make their code run in a toaster. Well, while this is a nice
    and beautiful fantasy, the reality is that you shouldn’t be so focused on optimizing
    your code unless you really need it. There’s a saying in the industry that states,
    “*Premature optimization is the doom of* *an application*.”
  prefs: []
  type: TYPE_NORMAL
- en: Focus on the *premature* word here.
  prefs: []
  type: TYPE_NORMAL
- en: So, if premature optimization is something bad, but optimization in itself is
    something good, when is the right time to optimize your game or application? The
    answer is not set in stone and there’s no clear point that we can just point out
    and say “*Here, after X days of development, it’s time to optimize*,” or “*After
    you reach 80% of production, it’s the sign to optimize*.” No, instead, you should
    address issues as they show up and create the habit of diagnosing your game’s
    performance and deciding whether, based on your audience’s computers’ specs, you
    are going to need to squeeze some resources or not. This can happen on production
    day 1, or years after launching the game.
  prefs: []
  type: TYPE_NORMAL
- en: So, you need to engage in the habit of looking at how your game is performing
    and looking for areas of improvement regularly.
  prefs: []
  type: TYPE_NORMAL
- en: The **Profiler** tab is one of your best allies in optimization. It is in this
    tab that you will see rendering time, physics simulation time, audio processing
    time, and even how much time each of your custom script functions is taking to
    process and how many times they were called. Let’s take a look at the following
    figure and understand how the **Profiler** tab displays all this information.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Session 2’s Debugger dock Profiler tab and its elements](img/Figure_10.05_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Session 2’s Debugger dock Profiler tab and its elements
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand the role of each of these elements, again, following their
    number in the figure:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Functions** panel displays the currently available functions that the
    profiler can track (highlighted and marked with **1** in *Figure 10**.5*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Start** button initializes the measurement. Note that without toggling
    this on, the profiler won’t do anything. Profiling is quite resource-intensive,
    so by default, it’s off (highlighted and marked with **2** in *Figure 10**.5*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Clear** button clears the current data gathered and displayed (highlighted
    and marked with **3** in *Figure 10**.5*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Measure** drop-down menu allows us to change the type of data we want
    to measure (highlighted and marked with **4** in *Figure 10**.5*). The current
    options are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frame Time (ms)** is how many milliseconds Godot Engine takes to process
    a frame.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Average Time (ms)** is how long a function takes to process. This averages
    the time of each call of any given function.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frame %** is the percentage a given function takes to process relative to
    the frame’s rendering time. For instance, functions that are more resource-intensive
    take a bigger percentage.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physics Frame %** is the same as **Frame %** but relative to the physics
    frame process.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Time Scope** drop-down menu allows us to change the functions’ time scope
    that we want to measure (highlighted and marked with **5** in *Figure 10**.5*),
    and it has the following options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inclusive**, which will take into account the time a function and all its
    nested functions took to render'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self**, which will only take into account the individual time of each function
    without considering the function calls that the measured function made'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Frame #** stepper, or spinbox, marks the frame you are currently assessing
    (highlighted and marked with **6** in *Figure 10**.5*). Changing the frame number
    will allow you to accurately see the function’s measurements related to this frame
    in the **Functions** panel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Measurement Graph** panel is where the data is plotted so we can see it
    and access any unusual data. Each measured function has its own color to make
    it easy to see it on the graph (highlighted and marked with **7** in *Figure 10**.5*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Profiler is a powerful ally ready to give us access to important data regarding
    resource management. Now that we understand how to use it, let’s move on to the
    second profiler on the **Debugger** dock, **Visual Profiler**.
  prefs: []
  type: TYPE_NORMAL
- en: This one specializes in visual resources and potential bottlenecks so that we
    can improve our game’s visuals regarding rendering and other visual procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Visual Profiler tab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On top of knowing how many processing resources your functions are taking from
    the CPU, it’s also important to assess how much the rendering-related tasks (such
    as culling, lightning, and draw calls) are taking from the GPU. The **Visual Profiler**
    tool can help you keep track of what is causing the most delay in rendering a
    frame on the CPU and GPU. By identifying these sources of potential bottlenecks
    caused by rendering, you can optimize your CPU and GPU performance.
  prefs: []
  type: TYPE_NORMAL
- en: The **Visual Profiler** tab is quite similar to the **Profiler** tab but specializes
    in tracking and measuring rendering-related tasks. Take a look at the following
    figure to understand how the **Visual Profiler** tab displays all of this information.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Session 3’s Debugger dock Visual Profiler tab and its elements](img/Figure_10.06_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Session 3’s Debugger dock Visual Profiler tab and its elements
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to gain a deeper understanding of each of these elements, let us take
    a closer look at their individual roles. Again, we are going to follow the elements
    in the numeric order:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Tasks** panel displays the rendering-related tasks divided into categories.
    Note that they are broken down into elements such as the related viewport and
    canvas layer (highlighted and marked with **1** in *Figure 10**.6*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Start** button, just like in the **Profiler** tab, initializes the profiling.
    Visual profiling is also turned off by default (highlighted and marked with **2**
    in *Figure 10**.6*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Clear** button clears the current data gathered in the profiling session
    (highlighted and marked with **3** in *Figure 10**.6*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Measure** drop-down menu (highlighted and marked with **4** in *Figure
    10**.6*) allows us to select two measurement options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frame Time (ms)** is the time taken to render a frame in milliseconds'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frame %** is the percentage a given procedure takes from the rendering time
    of a given frame'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Fit to Frame** checkbox will fit the graph to the default frame scale
    (highlighted and marked with **5** in *Figure 10**.6*). Disable it to fit the
    graph onto over 60 **Frames Per Second** (**FPS**) portions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Linked** checkbox zooms the CPU and the GPU graphs to fit the same scale
    (highlighted and marked with **6** in *Figure 10**.6*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Frame #** stepper, just like in the **Profiler** tab, marks the current
    frame you are assessing. Rendering tasks displayed in the **Tasks** panel relate
    to this frame (highlighted and marked with **7** in *Figure 10**.6*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Profiler** is yet another powerful ally when optimizing the rendering
    performance of your game and is a game-changing tool that can help you assess
    what may be causing lags and frame drops in your game. In the next section, we
    are going to understand yet another powerful tool available for us to assess our
    game’s health, the **Monitors** tab, where we can find all sorts of interesting
    information regarding our game.'
  prefs: []
  type: TYPE_NORMAL
- en: Well, let’s dive into it so we understand how each of these, among other available
    data, will help us address potential issues in our game’s performance.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Monitors tab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the part where you can really feel like a game doctor. **Monitors**
    allows us to assess important data as graphs and see the game’s overall health.
    In this tab, we can track performance-related data in graphs. By default, it presents
    some useful data, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Time-related data, such as **FPS**, process time, and physics process time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory-related data, such as static memory, dynamic memory, and message buffers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-related data, such as the total object count, resource count, node count,
    and orphan nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There’s a series of properties you can track and plot into graphs so you can
    analyze your game’s health and spot potential areas for improvement. In the following
    figure, you can see the Debugger **Monitors** tab with some properties being tracked
    and plotted. Note that these properties are toggled on in the left panel by default.
    The **Monitors** tab will only plot charts for properties we toggle on in the
    left panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Session 2’s Debugger dock Monitors tab and its elements](img/Figure_10.7_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Session 2’s Debugger dock Monitors tab and its elements
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Monitors** tab seems to be the simplest of the tabs we’ve seen so far,
    but it is still very powerful, so let’s understand the two core elements that
    build it up:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Monitor** panel is where we can find the available monitors. A monitor
    is data marked for tracking. Note that there are plenty of monitors by default.
    By using them, we can obtain some valuable information about our project’s health
    (highlighted and marked with **1** in *Figure 10**.7*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Graphs** panel is where the monitors are plotted as graphs, and each monitor
    has its own graph and measures. Only the monitors checked in the **Monitor** panel
    are plotted in the **Graphs** panel (highlighted and marked with **2** in *Figure
    10**.7*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that there is no *start*, *stop*, or *clear* button on the **Monitors**
    tab. This is because Godot will always track the monitorable data.
  prefs: []
  type: TYPE_NORMAL
- en: Something interesting about the `Performance` singleton. We are going to talk
    about that in the *Identifying the project’s bottlenecks* section, where we will
    also talk about the **Monitors** panel in depth. In the next section, we will
    talk about the **Video RAM** tab, where we can assess our video-related resources.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the Video RAM tab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Video RAM** tab is useful when you want to understand what resources are
    causing the most impact on your video memory. This is of great help, especially
    in 3D games, but it can also be useful for 2D games – for instance, when we want
    to assess whether we need to pack more sprites into a single texture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Video RAM** tab is quite a simple panel with the essential information
    you need to assess video-related memory consumption. In the following figure,
    we can see it is made of a single table with four columns inside a panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Session 2’s Debugger dock Video RAM tab panel](img/Figure_10.08_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Session 2’s Debugger dock Video RAM tab panel
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an intuitive panel with the necessary data we need to understand the
    video memory usage of our resources. Let’s understand the type of information
    each of these columns presents:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource Path** is the path in our Godot Engine’s project to the resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AtlasTexture` Resource or a set of simple textures, for instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Format** column is where we can find the data regarding the file’s format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usage** is what we actually want in the end. It answers an important question:
    Given all the previous information, how much memory does this resource take?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There’s an option to save the table as a CSV file if you want to export it and
    make some table operations or create charts. This can be very useful for presentations,
    for instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `Control` node during the debugging section.
  prefs: []
  type: TYPE_NORMAL
- en: Grasping the Misc tab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned previously, the Debugger `Control` node clicked in the `Control`
    node is consuming inputs, and fix that in case we can have another `Control` node
    responsible for that. For instance, this is common when you have a `ColorRect`
    node that you use to fade the screen. If you don’t set **Mouse Filter** to **Ignore**,
    it will consume mouse events and prevent the player from interacting with other
    UI elements. In the following figure, we have the **Misc** tab for our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Session 3’s Debugger dock Misc tab and its elements](img/Figure_10.09_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Session 3’s Debugger dock Misc tab and its elements
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Misc** tab is quite simple, and we can’t do a lot with it. Still, it’s
    a good companion when we want to address interface-related issues, so let’s understand
    the elements that build up this debugging tool:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Control` node in the debugging section (highlighted and marked with **1**
    in *Figure 10**.9*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Clicked Control Type** row displays the type of the clicked control (highlighted
    and marked with **2** in *Figure 10**.9*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SceneTree` instance (highlighted and marked with **3** in *Figure 10**.9*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Set From Tree** button has no official documentation and it seems to be
    disabled all the time, so we couldn’t test what this button does (highlighted
    and marked with **4** in *Figure 10**.9*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Clear** button clears the data in the previously mentioned rows (highlighted
    and marked with **5** in *Figure 10**.9*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Export measures as CSV** button allows you to export a CSV file with the
    data in the aforementioned rows. It might be useful for keeping track of how the
    game flows based on the interactions with its controls (highlighted and marked
    with **6** in *Figure 10**.9*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good use case for this tab might be *Point ‘n’ Click* games. Since most interactions
    in this game happen with mouse clicks, we can use the Debugger **Misc** tab to
    identify which element led to a specific event. For instance, when clicking on
    a menu while a dialogue is being displayed, which one should consume the mouse
    click? Well, if the one you chose isn’t consuming the input, you can use the Debugger
    **Misc** tab to see what’s happening.
  prefs: []
  type: TYPE_NORMAL
- en: We just finished covering almost all the tools we can use to debug and profile
    our game. The only missing one is, for you, our fake studio’s network engineer,
    the most important one. The Network Profiler is where you are going to find the
    impact of your RPCs and synchronizers, along with other relevant information related
    to the High-Level Network API. Let’s get right into it!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Network Profiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s time to meet your best ally, the one that will help you address issues
    related to your craft as the network engineer of our fake studio and come up with
    potential solutions for the problems that appear along your journey. The Network
    Profiler, as the name suggests, is a profiler specialized in network-related profiling.
    It displays information about RPCs’ size and count, both sent and received, the
    node making and receiving the RPCs, `MultiplayerSynchronizer` nodes’ network consumption
    and syncing count, and even a bandwidth meter, which are all we need to assess
    the impact of our network code.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Network Profiler, by default, only tracks the High-Level Network
    API bandwidth. So, if you are using low-level approaches, such as `PacketPeerUDP`,
    `UDPServer`, `StreamPeerTCP`, and `TCPServer`, their consumption may not be taken
    into account by the Network Profiler by default. We are going to see how we can
    address that in the *Using the Monitors* *tab* section.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into the features we have available in the **Network Profiler** tab.
    Again, each element in this interface will be numbered for further reference.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Session 2’s Debugger dock Network Profiler tab and its elements](img/Figure_10.10_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Session 2’s Debugger dock Network Profiler tab and its elements
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the Network Profiler has fewer elements than the other profilers,
    each of its elements is more complex as well. You may have also noticed that there’s
    no graph element, right? So, assessing this data can be a bit less natural. But
    let’s understand what each of these elements does and how we can use them:'
  prefs: []
  type: TYPE_NORMAL
- en: The RPC panel displays each node that sends and receives RPCs (highlighted and
    marked with `Asteroid` nodes have an `3`, which is probably because they receive
    3 calls to process damage and are destroyed right after the third one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Weapon2D` has a big **Outgoing RPC** value because it’s constantly telling
    its peers’ instances to fire bullets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Start** button. Just like in the previous profilers, network profiling
    is turned off by default; by pressing this button, we can start profiling (highlighted
    and marked with **2** in *Figure 10**.10*).*   The **Clear** button clears the
    current data gathered in the profiling session (highlighted and marked with **3**
    in *Figure 10**.10*).*   The **Bandwidth** meter displays the total bandwidth
    consumption in bytes per second of the current profiling session (highlighted
    and marked with **4** in *Figure 10**.10*):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Down** displays how many bytes per second it downloaded in this profiling
    session'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Up** displays how many bytes per second it uploaded during this profiling
    session*   The `MultiplayerSynchronizer` nodes, their `SceneReplicationConfig`
    resource, which is always built-in by default, the sync count, and sync size in
    bytes (highlighted and marked with `MultiplayerSynchronizer` node’s scene*   The
    `MultiplayerSynchronizer`*   The `SceneReplicationConfig` resource associated
    with `MultiplayerSynchronizer`*   The `MultiplayerSynchronizer` node synced its
    replication data*   The **Size** column displays the total amount of data the
    synchronization took, in bytes, during the current profiling session'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With all this information in our hands, we can make sense of how our work is
    having an impact on the project’s overall performance. Knowing how many times
    a node calls its RPCs, how many times other nodes call its RPCs, the amount of
    data exchanged, and more can help us properly address the necessary bandwidth
    a player needs to play the game properly, and also optimize the game to embrace
    players with lower network profiles.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to learn how we can use the powerful tools
    we’ve seen so far to spot the bottlenecks in our network approach using the Network
    Profiler, but also extend our profiling by adding custom monitors to the **Monitors**
    tab. With that, we can pinpoint what we want Godot to report to us.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the project’s bottlenecks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all the tools we’ve seen so far in this chapter at our disposal, it’s
    time to use them to assess our project’s health and look for areas of improvement.
    Since your focus here is on networking, we are going to concentrate on features
    related to this area. In this section, we will use the final version of the [*Chapter
    9*](B18527_09.xhtml#_idTextAnchor188), *Creating an Online Adventure Prototype*,
    project to look for areas of improvement using **Network Profiler** and the **Monitors**
    debugging tools. You will learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the incoming and outgoing RPC count and size to identify potential bottlenecks
    in the network code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the bandwidth meter to track the total bandwidth consumption and come up
    with possible solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assess the synchronization count and size of `MultiplayerSynchronizer` nodes
    to optimize replication data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create custom monitors to analyze relevant data specific to your project and
    track potential issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started with the tool that will be our reliable companion through
    the process of identifying the issues related to the High-Level Network API, the
    Network Profiler.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Network Profiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we saw the Network Profiler, one of the most powerful
    tools available to us for identifying issues related to the High-Level Network
    API. In this section, we will dive deeper into using the Network Profiler to identify
    bottlenecks related to RPCs and `MultiplayerSynchronizer` nodes. To accomplish
    this, we will be using the final version of the [*Chapter 9*](B18527_09.xhtml#_idTextAnchor188),
    *Creating an Online Adventure* *Prototype*, project.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, we can use the Network Profiler to gather information about
    the size and count of a node’s incoming and outgoing RPCs, `MultiplayerSynchronizer`
    nodes’ network consumption, syncing count, and even a bandwidth meter. By understanding
    and analyzing this data, we can identify potential issues in our network code
    and come up with possible solutions.
  prefs: []
  type: TYPE_NORMAL
- en: To start, let’s take a closer look at the incoming and outgoing RPC count and
    size to identify potential bottlenecks in our network code. We will also use the
    bandwidth meter to track the total bandwidth consumption and come up with possible
    improvements.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will assess the synchronization count and size of `MultiplayerSynchronizer`
    syncing to optimize replication data.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this section, you will have a better understanding of how to use
    the Network Profiler to identify and address issues related to your game’s network
    performance. So, let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: RPCs are a straightforward and efficient way to pass data and trigger remote
    events over the network. However, it’s important to use them judiciously to avoid
    overloading the network.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will analyze the data related to our project’s RPCs and
    explore potential improvements. We will be implementing solutions in the next
    chapters, but for now, our focus is on learning how to look at the data critically
    and make informed decisions.
  prefs: []
  type: TYPE_NORMAL
- en: We start by playing the `res://09.prototyping-space- adventure/MainMenu.tscn`
    scene with three game sessions opened. Let’s start the Network Profiler on all
    three of them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – The Session 1 Debugger Network Profiler starting profiling](img/Figure_10.11_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – The Session 1 Debugger Network Profiler starting profiling
  prefs: []
  type: TYPE_NORMAL
- en: Then, let’s pick one to be the server while using the others as clients, in
    other words, as players. To enable multiple game sessions, you can select the
    **Run 3 Instances** option in the **Debug** → **Run Multiple** **Instances** menu.
  prefs: []
  type: TYPE_NORMAL
- en: With all three sessions opened, let’s identify which one is the server. For
    that, open the Debugger `ServerButton`. In my case, it’s the **Session 2** game
    instance, as shown in the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Using Session 2’s Debugger Misc tab to find the server’s game
    instance](img/Figure_10.12_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Using Session 2’s Debugger Misc tab to find the server’s game
    instance
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know that `QuestDatabase`.
  prefs: []
  type: TYPE_NORMAL
- en: To test whether this modification worked, I destroyed the *Asteroids* with one
    of the players’ game instances, so go ahead and do the same. After destroying
    all 30 *Asteroids*, let’s analyze the data that the Network Profiler collected.
    At this point, you can stop the Network Profiler if you want. In the following
    figure, we have the **Session 1** data, so we can assume it’s a client.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – The Session 1 Debugger Network Profiler displaying the data
    it gathered](img/Figure_10.13_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – The Session 1 Debugger Network Profiler displaying the data it
    gathered
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a brief analysis of the RPC counts and size. You can see that
    in the first row, we have a player `Spaceship/Weapon2D` with a high `fire()` method
    being called from another client’s game instance, so we can assume the player
    that destroyed the *Asteroids* used **Session 3**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This client called this method 693 times. The `fire()` method doesn’t rely
    on any data that would require streaming it this many times. `Weapon2D` essentially
    has two major states:'
  prefs: []
  type: TYPE_NORMAL
- en: Firing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not firing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that we could improve this RPC count by sending a Boolean value through
    the network once when the player presses the firing action and when they release
    the firing action. In the meantime, `Weapon2D` itself would just toggle between
    these two states, firing and not firing, and use `process()` to spawn *Bullets*
    based on their fire rate. This would reduce this RPC count by a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice how important this assessment can be as you build your project
    and adjust it along the way? Pretty cool, right?
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s take a look at the `QuestDatabase` node in the fourth row. It’s
    the only node that has an outgoing RPC count, right? So, it’s making requests
    to the server’s game instance. It made a total of 30 RPCs, but notice that their
    size is comparatively bigger than the 693 incoming `fire()` RPCs. This means that
    the data transmitted through this RPC is bigger. We should pay attention to it.
    This is likely to be the `update_player_progress()` method. Notice that we have
    30 *Asteroids*, and every time we destroy one of them, we make an RPC to the `update_player_progress()`
    method. The count is correct and I can’t see a clear area of improvement in this
    regard. It has a ratio of 1:1 – one event, one trigger. So, we are likely to figure
    out a way to improve the data; maybe compress it somehow to decrease the overall
    bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s take a look at the *Asteroids’* RPC count. Every single one of
    them receives only 3 RPCs; this is probably due to the server’s *Bullets* hitting
    the *Asteroids*, which leads to the server calling the `hit()` method twice on
    the clients’ instances. Then, it calls the `explode()` method the third time a
    *Bullet* hits
  prefs: []
  type: TYPE_NORMAL
- en: the *Asteroid*. It seems that this class is pretty healthy regarding its RPC
    counts on the client’s side. There’s nothing to improve on this side of the relationship.
    Let’s take a look at the server’s side. The following figure showcases the server’s
    Network Profiler. Note that, in this playtest, the server is represented by the
    **Session 3** instance of the game.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – The Session 3 Debugger Network Profiler displaying the data
    it gathered](img/Figure_10.14_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – The Session 3 Debugger Network Profiler displaying the data it
    gathered
  prefs: []
  type: TYPE_NORMAL
- en: The server has outgoing RPCs on its *Asteroids* instances, and they also have
    a total count of `SceneTree` instance, so there’s no reason to play animations
    on the server. Ideally, the server will be a headless instance, so there’s really
    no reason to play animations on it. But we won’t dwell in these lands yet. What
    we can do in the current project is to change the `hit()` method’s RPC annotation
    to only call it remotely and not locally. This way, at least the hit animation
    will only play on the client’s side.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take the chance that we are working with the *Asteroids* and also make
    an analysis of their `MultiplayerSynchronizer` nodes. You can see on the right
    panel’s `World` node calls its `sync_world()` method. After that, there’s no reason
    to keep updating the asteroids’ properties. So, we can use the asteroids `MultiplayerSynchronizer`
    `update_visibility()` method inside the `sync_world()` method and decrease this
    bandwidth consumption as well.
  prefs: []
  type: TYPE_NORMAL
- en: By using the Network Profiler, we already identified areas for improvement,
    such as reducing the number of RPCs sent to the `Weapon2D.fire()` method and manually
    calling the `MultiplayerSynchronizer` syncing to decrease overall bandwidth. We
    also saw that we can change the RPC annotation of `Asteroid.hit()` to only call
    it remotely and not locally to reduce unnecessary animations on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: Well, with just a brief analysis, we spotted some clear areas for improvement,
    didn’t we? And we haven’t even finished our assessment yet! In the next section,
    we will see how we can use the `Performance` singleton to create custom monitors
    and track them in the monitors track.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Monitors tab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we learned about the Network Profiler and how it can
    help us identify potential bottlenecks in our game’s network performance. In this
    section, we will focus on another powerful debugging tool in Godot Engine: the
    **Monitors** tab.'
  prefs: []
  type: TYPE_NORMAL
- en: The **Monitors** tab allows us to track and analyze specific data points in
    real time. We can use it to keep track of variables, functions, and even custom
    data points that we define ourselves. By monitoring these data points, we can
    gain insight into how our project is performing and identify areas for improvement.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the built-in monitors, we can also create custom monitors to
    track specific variables or functions in our project. To do this, we need to use
    the `Performance.add_custom_monitor()` method, passing an ID, a `callable` instance,
    and, optionally, an array as arguments. Godot will create a monitor in the `id`
    argument and track the data using the `Callable` instance passed in the `callable`
    argument. This means that every time we trigger an event that should count for
    the data tracking, we need to execute the `callable` instance.
  prefs: []
  type: TYPE_NORMAL
- en: During the current section, we will use the `QuestDatabase` node and the `QuestSingleton`
    node. By monitoring these data points, we will gain some insights into how our
    quest system is performing and identify potential areas for improvement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by opening the `res://09.prototyping-spaceadventure/Quests/QuestDatabase.gd`
    script. We are going to create a member variable to keep track of how many times
    the `QuestDatabase.update_player_progress()` method was called. We can name this
    variable `quest_update_count` and set its default value to `0`. Then, we need
    to create a method that returns its current value; let’s call this method `get_quest_update_count()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To update `quest_update_count`, let’s increment its value after the server
    successfully updates the player’s progress in a given quest. So, in the `update_player_progress()`
    method, add a line inside the `if multiplayer.is_server()` statement incrementing
    `quest_update_count` by `1` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we have everything ready to add `get_quest_update_count()` to our
    `_ready()` callback, create a `Callable` variable pointing to `QuestDatabase`
    using the `self` keyword, and pointing to `"get_quest_update_count"`. We can name
    this `Callable` variable `callable` to simplify the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let’s call the `Performance.add_custom_monitor()` method. To keep things
    organized, we will use a category named `"Network"` for our custom monitors. So,
    in the `id` argument, we will pass `"Network/Quests Updates"` and pass `callable`
    as the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let’s start by opening the `res://09.prototyping-space- adventure/Quests/QuestDatabase.gd`
    script. We are going to create a member variable to keep track of how many times
    the method was called.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to test whether this custom monitor is working and assess the data it will
    provide, let’s test the game using three debugging sessions and use one of the
    clients to destroy some *Asteroids*. This time around, my server is on **Session
    2**. The following figure showcases **Session 2**’s **Monitors** tab. You can
    find the **Quests Updates** monitor at the very bottom of the **Monitor** panel;
    tick the checkbox and Godot will display the tracked data.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – The Session 2 Debugger Monitors tab displaying the Quests
    Updates tracked data](img/Figure_10.15_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – The Session 2 Debugger Monitors tab displaying the Quests Updates
    tracked data
  prefs: []
  type: TYPE_NORMAL
- en: Notice that Godot counted only 58 quest updates. So I may have missed one asteroid.
    Interesting, right? Why does one *Asteroid* trigger two calls to the `QuestDatabase.update_player_progress()`
    method? Well, remember that currently the quest progress is shared among all peers,
    so this can grow exponentially. If there were 3 players, there would be 96 calls
    to `QuestDatabase.update_player_progress()`. We need to figure out a way to limit
    that. One quick solution is to check whether the quest is already completed, and
    if it is, stop updating it. This would limit this particular quest to 10 calls
    per player, which would be a good improvement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make this comparison, just for testing purposes. Open `res://09.prototyping-space-adventure/Quests/QuestSingleton.gd`
    and let’s create a monitor that would only increment until the quest reaches the
    target amount required to complete the quest. To do that, let’s create a new member
    variable called `increase_count` and set its value to `0` by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let’s create a method called `get_quest_increases()` that will return
    this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `_ready()` callback, if this is a client instance, we will add a new
    custom monitor using the previous method as `callable`, just like we did with
    `QuestDatabase.get_quest_update_count()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the `increase_quest_progress()` method, we will create an `if`
    statement that will only increment `increase_count` while `quest.current_amount`
    is less than `quest.target_amount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let’s test the game again and see what happens in the clients’ **Monitors**
    tab. In the following figure, there’s something very interesting happening.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – The Session 2 Debugger Monitors tab displaying the Quests
    Increases tracked data](img/Figure_10.16_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – The Session 2 Debugger Monitors tab displaying the Quests Increases
    tracked data
  prefs: []
  type: TYPE_NORMAL
- en: This time around, `user2` credentials. Why this is relevant? Notice that there
    were only four increments to `increase_count` in this game instance. This is due
    to the fact that, in the `res://09.prototypingspace-adventure/Quests/QuestDatabase.json`
    file, `user2` already destroyed five asteroids, so it only needed five more to
    complete the quest. This means that we can improve this aspect of our game even
    between play sessions. The more progress a player makes in a game session, the
    fewer RPCs we will need to make to the server if we implement this approach; pretty
    cool, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this section, we learned how we can use the `Performance` singleton
    to create new monitors in the `Performance.add_custom_monitor()` method. We also
    saw how we can create methods to collect data about potential bottlenecks in our
    game. Finally, we saw some potential fixes to the issues we found while debugging
    the game in order to optimize it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that, we conclude our chapter! Throughout this chapter, we introduced the
    **Debugger** dock, which is a powerful tool for assessing and debugging potential
    problems in our game, as well as for optimizing its performance.
  prefs: []
  type: TYPE_NORMAL
- en: We explored the **Stack Trace** tab, which gives us an overview of our game’s
    flow and provides us with multiple ways to gather information about the changes
    that happen throughout this flow, allowing us to understand the whole chain of
    cause and effect that led to a given change. We also talked about the **Errors**
    tab, which is where we work together with thousands of other developers who worked
    on the development of Godot Engine’s core and identified thousands of errors and
    documented them so that when they happen, we have some light on the issue and
    can fix it.
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of that, we explored two powerful performance-based debugging tabs:
    the **Profiler** tab and the **Visual Profiler** tab. The **Profiler** tab is
    one of your best allies in this task, as it allows you to see rendering time,
    physics simulation time, audio processing time, and even how much time each of
    your custom script functions is taking to process and how many times they were
    called. The **Visual Profiler** tab specializes in tracking and measuring rendering-related
    tasks and can help you keep track of what is causing the most delay in rendering
    a frame on the CPU and GPU.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the protagonists of the chapter were the `MultiplayerSynchronizer`
    nodes by analyzing data gathered by the tool. By understanding and analyzing this
    data, we came up with possible solutions to optimize network code. In addition
    to that, we learned how to use the `Performance` singleton and create custom monitors
    to track specific data points in real time in the **Monitors** tab. By monitoring
    these data points, we gained insights into how our project is performing and even
    made a test for a potential improvement.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to optimize data requests, especially regarding
    the quests data from the `QuestDatabase.get_player_quests()` method.
  prefs: []
  type: TYPE_NORMAL
- en: By optimizing the way we request and handle data, we can improve our game’s
    performance and provide a better experience for our users. See you there!
  prefs: []
  type: TYPE_NORMAL
