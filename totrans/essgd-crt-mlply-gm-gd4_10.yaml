- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Debugging and Profiling the Network
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和监控网络
- en: With [*Chapter 9*](B18527_09.xhtml#_idTextAnchor188), *Creating an Online Adventure
    Prototype*, we concluded *Part 2*, *Creating Online Multiplayer Mechanics*, of
    our journey, where we learned how we can use Godot Engine’s High-Level Network
    API to turn local gameplay mechanics into online multiplayer mechanics. Now, it’s
    time to go beyond implementation and start the optimization of our mechanics.
    This chapter inaugurates *Part 3*, *Optimizing the Online Experience*, of our
    journey through creating online multiplayer games with Godot Engine.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过[*第9章*](B18527_09.xhtml#_idTextAnchor188)*，*创建在线冒险原型*，我们结束了第2部分，*创建在线多人机制*，的旅程，其中我们学习了如何使用Godot引擎的高级网络API将本地游戏机制转换为在线多人机制。现在，是时候超越实现并开始优化我们的机制了。本章开启了第3部分，*优化在线体验*，的旅程，通过Godot引擎创建在线多人游戏。
- en: It’s important that you have read, understood, and implemented the content provided
    in [*Chapter 9*](B18527_09.xhtml#_idTextAnchor188)*, Creating an Online Adventure
    Prototype,* because we are going to use the final project as our main subject
    through the following chapters in *Part 3*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，你已经阅读、理解并实现了在[*第9章*](B18527_09.xhtml#_idTextAnchor188)*，*创建在线冒险原型*，中提供的内容，因为我们将在第3部分接下来的章节中，以最终项目作为我们的主要主题。
- en: In this specific chapter, we are going to understand how we can use Godot Engine’s
    built-in `MultiplayerSynchronizers` are performing, giving us a good overview
    of potential issues in our network implementation. Finally, we are going to learn
    how to use the Debugger dock’s `Performance` singleton to figure out potential
    bottlenecks in our game and gather data to design potential solutions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的章节中，我们将了解如何使用Godot引擎内置的`MultiplayerSynchronizers`的性能，为我们提供一个关于网络实现中潜在问题的良好概述。最后，我们将学习如何使用调试器窗口的`Performance`单例来找出游戏中的潜在瓶颈并收集数据以设计潜在解决方案。
- en: 'By the end of this chapter, you will understand how to use the powerful Debugger
    tools, and the elements in the following figure won’t scare you anymore; instead,
    they will be some of your most reliable allies:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何使用强大的调试器工具，以下图中的元素不会再让你感到害怕；相反，它们将成为你最可靠的盟友：
- en: '![Figure 10.1 – The Debugger’s Network Profiler (top) and Monitors (bottom)
    showing and plotting profiling data](img/Figure_10.1_B18527.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 调试器的网络分析器（顶部）和监视器（底部）显示并绘制分析数据](img/Figure_10.1_B18527.jpg)'
- en: Figure 10.1 – The Debugger’s Network Profiler (top) and Monitors (bottom) showing
    and plotting profiling data
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 调试器的网络分析器（顶部）和监视器（底部）显示并绘制分析数据
- en: Don’t be surprised if you come back to this figure at the end of the chapter
    and understand what each of those graphs and charts means. You will get used to
    them, as they will appear in abundance throughout the next chapters, especially
    [*Chapter 11*](B18527_11.xhtml#_idTextAnchor276)*,* *Optimizing* *Data Requests*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在本章结束时回到这个图并理解了每个图表和图表的含义，请不要感到惊讶。你会习惯它们的，因为它们将在下一章中大量出现，尤其是在[*第11章*](B18527_11.xhtml#_idTextAnchor276)*，*优化数据请求*。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As mentioned previously, it’s crucial that you’ve read and followed the instructions
    provided in [*Chapter 9*](B18527_09.xhtml#_idTextAnchor188), *Creating an Online
    Adventure Prototype*. Here, in this chapter, we are going to use the final product
    you should have by the end of the previous chapter. You can access the resources
    for this chapter in the repository provided in the following link:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，阅读并遵循在[*第9章*](B18527_09.xhtml#_idTextAnchor188)，*创建在线冒险原型*中提供的说明至关重要。在本章中，我们将使用上一章结束时你应该拥有的最终产品。你可以通过以下链接访问本章的资源：
- en: '[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0)'
- en: With the result of [*Chapter 9*](B18527_09.xhtml#_idTextAnchor188)*,* *Creating
    an Online Adventure Prototype,* ready, we can move on to understanding how we
    can improve it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好[*第9章*](B18527_09.xhtml#_idTextAnchor188)*，*创建在线冒险原型*的结果后，我们可以继续了解如何改进它。
- en: Introducing Godot’s Debugger
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Godot的调试器
- en: The Debugger is a developer’s best friend. Most of the work we do doesn’t have
    anything to do with creating and implementing features; instead, it has everything
    to do with assessing potential problems these implementations cause and fixing
    them. The **Debugger** dock is where Godot Engine talks to us, showing errors,
    warnings, resource consumption, object count, and more. So, we should listen carefully
    and properly address the issues and data it shows us. We can even ask it to track
    custom data, as we are going to see in the *Using the Monitors* *tab* section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器是开发者的最佳助手。我们的大部分工作与创建和实现功能无关；相反，它与我们评估这些实现可能引起的问题并修复它们有关。**调试器**窗口是Godot引擎与我们交流的地方，显示错误、警告、资源消耗、对象计数等等。因此，我们应该仔细倾听并妥善处理它显示的问题和数据。我们甚至可以要求它跟踪自定义数据，正如我们将在*使用监视器*标签部分中看到的那样。
- en: 'If you have been developing games with Godot Engine for enough time to run
    into errors, you have probably stumbled on the **Debugger** dock more than you’d
    like to, right? In this section, we will go in-depth to understand how to turn
    it into our best friend and actually wish it pops up. Let’s start by understanding
    each of its tabs, how to read them, and what to expect from them, starting with
    the most common and probably the one you’ve already had a hard time with: the
    **Stack** **Trace** tab.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经使用Godot引擎开发游戏足够长的时间以至于遇到了错误，您可能比您希望的更频繁地遇到了**调试器**窗口，对吧？在本节中，我们将深入探讨如何将其变成我们的好朋友，并希望它能够经常出现。让我们从理解它的每个标签开始，如何阅读它们，以及可以期待它们提供什么，从最常见的一个开始，可能也是您已经遇到困难的一个：**堆栈跟踪**标签。
- en: Mastering the Stack Trace tab
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 掌握堆栈跟踪标签
- en: When you click on the **Debugger** dock, Godot Engine’s editor will open the
    **Stack Trace** tab. Let’s use the following figure to navigate it and understand
    what each of its elements does.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击**调试器**窗口时，Godot引擎的编辑器将打开**堆栈跟踪**标签。让我们使用以下图示来导航它，并理解其每个元素的功能。
- en: '![Figure 10.2 – The Debugger dock’s Stack Trace tab and its elements](img/Figure_10.2_B18527.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 调试器窗口的堆栈跟踪标签及其元素](img/Figure_10.2_B18527.jpg)'
- en: Figure 10.2 – The Debugger dock’s Stack Trace tab and its elements
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 调试器窗口的堆栈跟踪标签及其元素
- en: 'You can see that each element of the **Stack Trace** tab in the figure is associated
    with a number, which will facilitate a better understanding. In the following
    list, we have the element’s name and a brief explanation about it:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到图中的**堆栈跟踪**标签的每个元素都与一个数字相关联，这将有助于更好地理解。在以下列表中，我们有元素名称及其简要说明：
- en: The **Stack Frames** panel is the stack of functions that leads to an error
    or a breakpoint (highlighted and marked with **1** in *Figure 10**.2*).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆栈帧**面板是导致错误或断点的函数堆栈（在*图10.2*中突出显示并标记为**1**）。'
- en: The **Filter Stack Variables** field is where you can filter variable names
    to display them in the panel below (highlighted and marked with **2** in *Figure
    10**.2*).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤堆栈变量**字段是您可以过滤变量名称以在下面的面板中显示它们的地方（在*图10.2*中突出显示并标记为**2**）。'
- en: The **Members** panel is where you can find the variables within a given script
    including temporary variables and scope-specific variables. Here, you can also
    see and edit their values (highlighted and marked with **3** in *Figure 10**.2*).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成员**面板是您可以找到给定脚本中的变量的地方，包括临时变量和特定作用域的变量。在这里，您还可以查看和编辑它们的值（在*图10.2*中突出显示并标记为**3**）。'
- en: The **Breakpoints** panel is where you can see information about a breakpoint
    reached in the script of a given instance (highlighted and marked with **4** in
    *Figure 10**.2*).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断点**面板是您可以查看给定实例脚本中达到的断点信息的地方（在*图10.2*中突出显示并标记为**4**）。'
- en: The **Skip Breakpoints** button, when toggled on, allows the execution of the
    game to run ignoring breakpoints (highlighted and marked with **5** in *Figure
    10**.2*).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跳过断点**按钮，当开启时，允许游戏执行忽略断点（在*图10.2*中突出显示并标记为**5**）。'
- en: The **Copy Error** button copies the current error, if any, to your clipboard
    (highlighted and marked with **6** in *Figure 10**.2*).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制错误**按钮会将当前错误（如果有）复制到您的剪贴板（在*图10.2*中突出显示并标记为**6**）。'
- en: Clicking on the **Step Into** button when the application is paused, including
    when it reaches a breakpoint, will execute the next script instruction (i.e.,
    line). It will enter in indented blocks it would naturally go into, executing
    the whole code (highlighted and marked with **7** in *Figure 10**.2*).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用暂停时，包括达到断点时，点击**步入**按钮将执行下一个脚本指令（即行）。它将进入它自然进入的缩进代码块，并执行整个代码（如*图 10*.2 中所示，高亮并标记为**7**）。
- en: Clicking on the **Step Over** button when the application is paused, including
    when it reaches a breakpoint, will execute the next script instruction (i.e.,
    line) but skip indented blocks (highlighted and marked with **8** in *Figure 10**.2*).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用暂停时，包括达到断点时，点击**步过**按钮将执行下一个脚本指令（即行），但会跳过缩进的代码块（如*图 10*.2 中所示，高亮并标记为**8**）。
- en: The **Break** button pauses the application as if it reached a breakpoint (highlighted
    and marked with **9** in *Figure 10**.2*).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断点**按钮会使应用暂停，就像它达到了断点一样（如*图 10*.2 中所示，高亮并标记为**9**）。'
- en: The **Continue** button resumes the application if it was paused (highlighted
    and marked with **10** in *Figure 10**.2*).
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继续**按钮会在应用暂停时恢复应用（如*图 10*.2 中所示，高亮并标记为**10**）。'
- en: With these elements at our disposal, we have the ability to experiment with
    our scripts and gather invaluable information about our game. For instance, we
    can see step by step how Godot Engine processes a given set of instructions using
    the **Step Into** button and see the stack of functions it executes and how the
    objects’ variables change with each step.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些元素，我们能够对我们的脚本进行实验，并收集有关我们游戏的无价信息。例如，我们可以通过**步入**按钮逐步查看 Godot 引擎如何处理一组指令，并查看它执行的函数堆栈以及每个步骤中对象变量的变化。
- en: A cool tip to use this to its fullest is to not be afraid to add breakpoints
    all over your scripts to understand when, what, how, and why your objects change
    and the whole chain of events that caused such changes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用这些功能的技巧是不要害怕在脚本中添加断点，以了解何时、什么、如何以及为什么对象发生变化，以及导致这些变化的整个事件链。
- en: In this section, we’ve gone through the **Stack Trace** tab, which gives us
    an overview of our game’s flow and provides us with multiple ways of gathering
    information about the changes that happen through this flow, allowing us to understand
    the whole chain of cause-effects that led to a given change. This is especially
    helpful together with our next tab, the **Errors** tab. Let’s talk about it in
    the next section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已介绍了**堆栈跟踪**选项卡，它为我们提供了游戏流程的概述，并提供了多种方式来收集关于通过此流程发生的变化的信息，使我们能够理解导致特定变化的原因和效果的整个链条。这特别有助于我们下一个选项卡，即**错误**选项卡。我们将在下一节中讨论它。
- en: Debugging with the Errors tab
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用**错误**选项卡进行调试
- en: It may sound weird but, in many situations, you might wish for Godot Engine
    to prompt an error, especially when dealing with network features, as sometimes
    you are left waiting for something to happen. And if the packets sent don’t reach
    their destination, you will be hanging there waiting for an error to pop up, but
    packets not reaching their destination isn’t an error in itself. Still, it’s an
    undesired situation that can leave you confused.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能有些奇怪，但在许多情况下，你可能希望 Godot 引擎提示错误，尤其是在处理网络功能时，因为有时你会被留在那里等待某个事件发生。如果发送的数据包没有到达目的地，你将挂在那里等待错误提示出现，但数据包没有到达目的地本身并不是错误。然而，这仍然是一种不希望出现的情况，可能会让你感到困惑。
- en: The **Errors** tab is where you work with thousands of other developers, who
    worked on the development of Godot Engine’s core and identified thousands of errors
    and documented them so that when they happen, you have some light on the issue
    and are able to fix it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误**选项卡是您与其他数千名开发者一起工作的地方，他们参与了 Godot 引擎核心的开发，并识别了数千个错误并对其进行了记录，以便当它们发生时，您可以对问题有所了解，并能够修复它。'
- en: 'However, not only errors are displayed in this tab. The **Errors** tab also
    shows warnings about your script. They don’t necessarily break your application
    but are something you should be aware of and make a decision on. For instance,
    it’s common to get warnings about arguments in a function that are not being used
    in the function’s implementation. The following figure displays the **Error**
    tab and its elements associated with numbers, just like in the *Mastering the
    Stack Trace* *tab* section:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个选项卡不仅显示错误。**错误**选项卡还会显示关于您脚本的警告。它们不一定破坏您的应用程序，但这是您应该注意并做出决定的事情。例如，在函数的实现中未使用的参数通常会收到警告。以下图显示了**错误**选项卡及其与数字关联的元素，就像在*掌握堆栈跟踪*选项卡部分一样：
- en: '![Figure 10.3 – The Session 1 Debugger dock’s Errors tab and its elements](img/Figure_10.03_B18527.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 第1次会话调试器选项卡的错误选项卡及其元素](img/Figure_10.03_B18527.jpg)'
- en: Figure 10.3 – The Session 1 Debugger dock’s Errors tab and its elements
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 第1次会话调试器选项卡的错误选项卡及其元素
- en: 'Now, let’s understand what each of these elements is and how they can be useful
    for us:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解这些元素是什么以及它们如何对我们有用：
- en: The **Errors and Warnings** panel is where all the warnings and fatal and non-fatal
    errors are displayed. You can click on an error or warning to expand it and go
    to the script line that triggered it. You can also double-click to expand an error
    or warning and display the code stack that led to the error. When you double-click
    an expanded error or warning, you collapse it (highlighted and marked with **1**
    in *Figure 10**.3*).
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误和警告**面板是显示所有警告和致命及非致命错误的地方。您可以点击一个错误或警告来展开它，并跳转到触发它的脚本行。您也可以双击来展开一个错误或警告，并显示导致错误的代码堆栈。当您双击展开的错误或警告时，它会折叠（在*图10.3*中突出显示并标记为**1**）。'
- en: The **Expand All** button expands all the errors and warnings (highlighted and
    marked with **2** in *Figure 10**.3*).
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**展开全部**按钮会展开所有错误和警告（在*图10.3*中突出显示并标记为**2**）。'
- en: The **Collapse All** button collapses all the errors and warnings (highlighted
    and marked with **3** in *Figure 10**.3*).
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**折叠全部**按钮会折叠所有错误和警告（在*图10.3*中突出显示并标记为**3**）。'
- en: The **Clear** button empties the **Errors and Warnings** panel (highlighted
    and marked with **4** in *Figure 10**.3*).
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清除**按钮会清空**错误和警告**面板（在*图10.3*中突出显示并标记为**4**）。'
- en: 'Something interesting about dealing with errors and warnings is that you can
    create your own error or warning messages. This is especially good when working
    with your teammates, but also, since we are working with more than one instance
    of the game running, it’s a good way to compartmentalize messages to their instance’s
    `print()` statement is coming from. So you can use the `push_error()` and `push_warning()`
    built-in methods instead and Godot will only show them in the game session’s **Debugger**
    dock that triggered the error or warning. The following figure showcases the **Error**
    tab of **Session 3** with a custom warning expanded so we can see where it comes
    from:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 处理错误和警告的一个有趣之处在于，您可以创建自己的错误或警告消息。当与队友一起工作时，这尤其有用，而且，由于我们正在处理多个游戏实例运行，这也是将消息分离开到它们各自的`print()`语句来源的好方法。因此，您可以使用`push_error()`和`push_warning()`内置方法，Godot将只在触发错误或警告的游戏会话的**调试器**选项卡中显示它们。以下图展示了**会话3**的**错误**选项卡，其中展开了一个自定义警告，以便我们可以看到它的来源：
- en: '![Figure 10.4 – The Session 3 Errors tab highlighting a custom warning among
    other built-in warnings](img/Figure_10.4_B18527.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 第3次会话错误选项卡突出显示一个自定义警告和其他内置警告](img/Figure_10.4_B18527.jpg)'
- en: Figure 10.4 – The Session 3 Errors tab highlighting a custom warning among other
    built-in warnings
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 第3次会话错误选项卡突出显示一个自定义警告和其他内置警告
- en: Notice that the **Debugger** button at the bottom tells us there’s a total of
    20 errors and warnings, but when we open the **Errors** tab in **Session 3**,
    there are only 13\. This is because the other errors come from other sessions
    and are in their respective **Errors** tabs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到底部的**调试器**按钮告诉我们总共有20个错误和警告，但当我们打开**会话3**中的**错误**选项卡时，只有13个。这是因为其他错误来自其他会话，它们位于各自的**错误**选项卡中。
- en: With this powerful tool in our arsenal, we can trigger all sorts of errors and
    warnings in each individual game session, allowing us to distinguish which session
    is the server, which ones are players if any peer is getting a specific error
    that others aren’t, and so on. In the next section, we will talk about our first
    performance-based debugging tab, the **Profiler** tab, where we can see how our
    game is performing, how many resources it is taking, and which objects and functions
    are taking the most out of our computer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的装备中有了这个强大的工具，我们可以在每个单独的游戏会话中触发各种错误和警告，这样我们就可以区分哪个会话是服务器，哪些是玩家（如果有任何对等体得到一个其他人没有的特定错误），等等。在下一节中，我们将讨论我们的第一个基于性能的调试选项卡，即**Profiler**选项卡，在那里我们可以看到我们的游戏性能如何，它消耗了多少资源，以及哪些对象和函数消耗了我们电脑的最大资源。
- en: Exploring the Profiler tab
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Profiler 选项卡
- en: Most developers are always looking for the most efficient, cheap, and ingenious
    optimizations to make their code run in a toaster. Well, while this is a nice
    and beautiful fantasy, the reality is that you shouldn’t be so focused on optimizing
    your code unless you really need it. There’s a saying in the industry that states,
    “*Premature optimization is the doom of* *an application*.”
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者总是在寻找最有效、最经济、最巧妙的优化，以便让他们的代码在烤面包机中运行。好吧，虽然这是一个美好而美丽的幻想，但现实是，除非你真的需要，否则你不应该如此专注于优化你的代码。行业内有一句话，“*过早优化是应用程序的厄运*。”
- en: Focus on the *premature* word here.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要关注的是**过早**这个词。
- en: So, if premature optimization is something bad, but optimization in itself is
    something good, when is the right time to optimize your game or application? The
    answer is not set in stone and there’s no clear point that we can just point out
    and say “*Here, after X days of development, it’s time to optimize*,” or “*After
    you reach 80% of production, it’s the sign to optimize*.” No, instead, you should
    address issues as they show up and create the habit of diagnosing your game’s
    performance and deciding whether, based on your audience’s computers’ specs, you
    are going to need to squeeze some resources or not. This can happen on production
    day 1, or years after launching the game.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果过早优化是件坏事，但优化本身是件好事，那么何时优化你的游戏或应用程序才是正确的时机呢？答案并非一成不变，也没有一个明确的点可以指出并说“*在这里，经过
    X 天的开发，是时候进行优化了*”，或者“*当你达到 80% 的生产水平时，是进行优化的信号*。”不，相反，你应该在问题出现时解决它们，并养成诊断游戏性能并决定是否根据你目标受众的电脑配置来挤压一些资源的习惯。这可以在游戏发布的第一天发生，或者游戏发布多年后。
- en: So, you need to engage in the habit of looking at how your game is performing
    and looking for areas of improvement regularly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你需要养成定期查看游戏性能和寻找改进区域的习惯。
- en: The **Profiler** tab is one of your best allies in optimization. It is in this
    tab that you will see rendering time, physics simulation time, audio processing
    time, and even how much time each of your custom script functions is taking to
    process and how many times they were called. Let’s take a look at the following
    figure and understand how the **Profiler** tab displays all this information.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**Profiler**选项卡是你在优化中的最佳盟友之一。正是在这个选项卡中，你会看到渲染时间、物理模拟时间、音频处理时间，甚至你自定义脚本函数处理所需的时间和它们被调用的次数。让我们看一下下面的图，并了解**Profiler**选项卡如何显示所有这些信息。'
- en: '![Figure 10.5 – Session 2’s Debugger dock Profiler tab and its elements](img/Figure_10.05_B18527.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 第 2 次会话的调试器停靠 Profiler 选项卡及其元素](img/Figure_10.05_B18527.jpg)'
- en: Figure 10.5 – Session 2’s Debugger dock Profiler tab and its elements
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 第 2 次会话的调试器停靠 Profiler 选项卡及其元素
- en: 'Let’s understand the role of each of these elements, again, following their
    number in the figure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次根据图中的编号来理解每个元素的作用：
- en: The **Functions** panel displays the currently available functions that the
    profiler can track (highlighted and marked with **1** in *Figure 10**.5*).
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**面板显示当前可用的函数，这些函数是分析器可以跟踪的（在*图 10.5*中突出显示并标记为**1**）。'
- en: The **Start** button initializes the measurement. Note that without toggling
    this on, the profiler won’t do anything. Profiling is quite resource-intensive,
    so by default, it’s off (highlighted and marked with **2** in *Figure 10**.5*).
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始**按钮初始化测量。请注意，如果不切换这个选项，分析器将不会做任何事情。分析非常消耗资源，所以默认情况下它是关闭的（在*图 10.5*中突出显示并标记为**2**）。'
- en: The **Clear** button clears the current data gathered and displayed (highlighted
    and marked with **3** in *Figure 10**.5*).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清除**按钮清除当前收集和显示的数据（在*图 10.5*中突出显示并标记为**3**）。'
- en: 'The **Measure** drop-down menu allows us to change the type of data we want
    to measure (highlighted and marked with **4** in *Figure 10**.5*). The current
    options are as follows:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测量**下拉菜单允许我们更改我们想要测量的数据类型（在*图10.5*中突出显示并标记为**4**）。当前选项如下：'
- en: '**Frame Time (ms)** is how many milliseconds Godot Engine takes to process
    a frame.'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帧时间（毫秒）**是Godot引擎处理一个帧所需的时间。'
- en: '**Average Time (ms)** is how long a function takes to process. This averages
    the time of each call of any given function.'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平均时间（毫秒）**是一个函数处理所需的时间。这是对任何给定函数的每次调用的时间的平均值。'
- en: '**Frame %** is the percentage a given function takes to process relative to
    the frame’s rendering time. For instance, functions that are more resource-intensive
    take a bigger percentage.'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架百分比**是给定函数相对于帧渲染时间的百分比。例如，资源密集型函数会占用更大的百分比。'
- en: '**Physics Frame %** is the same as **Frame %** but relative to the physics
    frame process.'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理框架百分比**与**框架百分比**相同，但相对于物理框架处理过程。'
- en: 'The **Time Scope** drop-down menu allows us to change the functions’ time scope
    that we want to measure (highlighted and marked with **5** in *Figure 10**.5*),
    and it has the following options:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间范围**下拉菜单允许我们更改我们想要测量的函数的时间范围（在*图10.5*中突出显示并标记为**5**），并且有以下选项：'
- en: '**Inclusive**, which will take into account the time a function and all its
    nested functions took to render'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含**，这将考虑一个函数及其所有嵌套函数渲染所需的时间'
- en: '**Self**, which will only take into account the individual time of each function
    without considering the function calls that the measured function made'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自我**，这只会考虑每个函数的个体时间，而不考虑被测量的函数所调用的函数调用'
- en: 'The **Frame #** stepper, or spinbox, marks the frame you are currently assessing
    (highlighted and marked with **6** in *Figure 10**.5*). Changing the frame number
    will allow you to accurately see the function’s measurements related to this frame
    in the **Functions** panel.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帧编号**步进器或旋转框标记了你当前正在评估的帧（在*图10.5*中突出显示并标记为**6**）。更改帧编号将允许你在**函数**面板中准确看到与该帧相关的函数测量。'
- en: The **Measurement Graph** panel is where the data is plotted so we can see it
    and access any unusual data. Each measured function has its own color to make
    it easy to see it on the graph (highlighted and marked with **7** in *Figure 10**.5*).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测量图**面板是数据被绘制的地方，因此我们可以看到它并访问任何异常数据。每个测量的函数都有其自己的颜色，以便在图表上容易看到它（在*图10.5*中突出显示并标记为**7**）。'
- en: The Profiler is a powerful ally ready to give us access to important data regarding
    resource management. Now that we understand how to use it, let’s move on to the
    second profiler on the **Debugger** dock, **Visual Profiler**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器是一个强大的盟友，它使我们能够访问有关资源管理的重要数据。现在我们了解了如何使用它，让我们继续到调试器停靠上的第二个分析器，即**视觉分析器**。
- en: This one specializes in visual resources and potential bottlenecks so that we
    can improve our game’s visuals regarding rendering and other visual procedures.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这一个专注于视觉资源和潜在瓶颈，以便我们可以改进我们的游戏在渲染和其他视觉过程方面的视觉效果。
- en: Exploring the Visual Profiler tab
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索视觉分析器选项卡
- en: On top of knowing how many processing resources your functions are taking from
    the CPU, it’s also important to assess how much the rendering-related tasks (such
    as culling, lightning, and draw calls) are taking from the GPU. The **Visual Profiler**
    tool can help you keep track of what is causing the most delay in rendering a
    frame on the CPU and GPU. By identifying these sources of potential bottlenecks
    caused by rendering, you can optimize your CPU and GPU performance.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了知道你的函数从CPU中消耗了多少处理资源外，评估与渲染相关的任务（如剔除、光照和绘制调用）从GPU中消耗了多少也同样重要。**视觉分析器**工具可以帮助你跟踪导致CPU和GPU渲染帧延迟最长的原因。通过识别由渲染引起的潜在瓶颈的来源，你可以优化CPU和GPU的性能。
- en: The **Visual Profiler** tab is quite similar to the **Profiler** tab but specializes
    in tracking and measuring rendering-related tasks. Take a look at the following
    figure to understand how the **Visual Profiler** tab displays all of this information.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**视觉分析器**选项卡与**分析器**选项卡非常相似，但专注于跟踪和测量与渲染相关的任务。看看以下图表，了解**视觉分析器**选项卡如何显示所有这些信息。'
- en: '![Figure 10.6 – Session 3’s Debugger dock Visual Profiler tab and its elements](img/Figure_10.06_B18527.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 第3次会话的调试器停靠视觉分析器选项卡及其元素](img/Figure_10.06_B18527.jpg)'
- en: Figure 10.6 – Session 3’s Debugger dock Visual Profiler tab and its elements
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 第3次会话的调试器停靠视觉分析器选项卡及其元素
- en: 'In order to gain a deeper understanding of each of these elements, let us take
    a closer look at their individual roles. Again, we are going to follow the elements
    in the numeric order:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地理解这些元素中的每一个，让我们更仔细地看看它们各自的作用。再次强调，我们将按照数字顺序来跟踪这些元素：
- en: The **Tasks** panel displays the rendering-related tasks divided into categories.
    Note that they are broken down into elements such as the related viewport and
    canvas layer (highlighted and marked with **1** in *Figure 10**.6*).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务**面板显示按类别划分的与渲染相关的任务。请注意，它们被分解为相关视口和画布层等元素（在*图10.6*中突出显示并标记为**1**）。'
- en: The **Start** button, just like in the **Profiler** tab, initializes the profiling.
    Visual profiling is also turned off by default (highlighted and marked with **2**
    in *Figure 10**.6*).
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始**按钮，就像在**分析器**标签页中一样，初始化分析。默认情况下，视觉分析也被关闭（在*图10.6*中突出显示并标记为**2**）。'
- en: The **Clear** button clears the current data gathered in the profiling session
    (highlighted and marked with **3** in *Figure 10**.6*).
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清除**按钮清除分析会话中收集的当前数据（在*图10.6*中突出显示并标记为**3**）。'
- en: 'The **Measure** drop-down menu (highlighted and marked with **4** in *Figure
    10**.6*) allows us to select two measurement options:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测量**下拉菜单（在*图10.6*中突出显示并标记为**4**）允许我们选择两个测量选项：'
- en: '**Frame Time (ms)** is the time taken to render a frame in milliseconds'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帧时间（毫秒）**是渲染一个帧所需的时间（以毫秒为单位）'
- en: '**Frame %** is the percentage a given procedure takes from the rendering time
    of a given frame'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帧百分比**是指给定过程从给定帧的渲染时间中占用的百分比'
- en: The **Fit to Frame** checkbox will fit the graph to the default frame scale
    (highlighted and marked with **5** in *Figure 10**.6*). Disable it to fit the
    graph onto over 60 **Frames Per Second** (**FPS**) portions.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适应帧**复选框将图形适应到默认帧比例（在*图10.6*中突出显示并标记为**5**）。取消选中它以将图形适应到超过60 **每秒帧数**（**FPS**）的部分。'
- en: The **Linked** checkbox zooms the CPU and the GPU graphs to fit the same scale
    (highlighted and marked with **6** in *Figure 10**.6*).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接**复选框将CPU和GPU图表缩放到相同的比例（在*图10.6*中突出显示并标记为**6**）。'
- en: 'The **Frame #** stepper, just like in the **Profiler** tab, marks the current
    frame you are assessing. Rendering tasks displayed in the **Tasks** panel relate
    to this frame (highlighted and marked with **7** in *Figure 10**.6*).'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帧编号**步进器，就像在**分析器**标签页中一样，标记了你正在评估的当前帧。在**任务**面板中显示的渲染任务与这个帧相关（在*图10.6*中突出显示并标记为**7**）。'
- en: '**Visual Profiler** is yet another powerful ally when optimizing the rendering
    performance of your game and is a game-changing tool that can help you assess
    what may be causing lags and frame drops in your game. In the next section, we
    are going to understand yet another powerful tool available for us to assess our
    game’s health, the **Monitors** tab, where we can find all sorts of interesting
    information regarding our game.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**视觉分析器**是优化游戏渲染性能时的另一个强大盟友，它是一个改变游戏规则的工具，可以帮助你评估可能造成游戏卡顿和帧降的原因。在下一节中，我们将了解另一个可用于评估游戏健康状况的强大工具，即**监视器**标签页，在那里我们可以找到有关游戏的各种有趣信息。'
- en: Well, let’s dive into it so we understand how each of these, among other available
    data, will help us address potential issues in our game’s performance.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们深入探讨，以便我们了解这些以及其他可用数据如何帮助我们解决游戏中性能的潜在问题。
- en: Exploring the Monitors tab
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索监视器标签页
- en: 'Here is the part where you can really feel like a game doctor. **Monitors**
    allows us to assess important data as graphs and see the game’s overall health.
    In this tab, we can track performance-related data in graphs. By default, it presents
    some useful data, such as the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你真正感觉像一名游戏医生的地方。**监视器**允许我们将重要数据作为图表来评估，并查看游戏的整体健康状况。在这个标签页中，我们可以通过图表跟踪与性能相关的数据。默认情况下，它显示一些有用的数据，如下所示：
- en: Time-related data, such as **FPS**, process time, and physics process time
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与时间相关的数据，例如**FPS**、进程时间和物理进程时间
- en: Memory-related data, such as static memory, dynamic memory, and message buffers
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与内存相关的数据，例如静态内存、动态内存和消息缓冲区
- en: Object-related data, such as the total object count, resource count, node count,
    and orphan nodes
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与对象相关的数据，例如总对象数、资源数、节点数和孤儿节点
- en: 'There’s a series of properties you can track and plot into graphs so you can
    analyze your game’s health and spot potential areas for improvement. In the following
    figure, you can see the Debugger **Monitors** tab with some properties being tracked
    and plotted. Note that these properties are toggled on in the left panel by default.
    The **Monitors** tab will only plot charts for properties we toggle on in the
    left panel:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有一系列属性您可以跟踪并绘制到图表中，以便您分析游戏的健康状况并发现潜在的改进区域。在下面的图中，您可以看到带有一些属性被跟踪和绘制的调试器**监视器**选项卡。请注意，这些属性默认在左侧面板中已打开。**监视器**选项卡将只为我们在左侧面板中打开的属性绘制图表：
- en: '![Figure 10.7 – Session 2’s Debugger dock Monitors tab and its elements](img/Figure_10.7_B18527.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 第2次会话的调试器停靠监视器选项卡及其元素](img/Figure_10.7_B18527.jpg)'
- en: Figure 10.7 – Session 2’s Debugger dock Monitors tab and its elements
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 第2次会话的调试器停靠监视器选项卡及其元素
- en: 'The **Monitors** tab seems to be the simplest of the tabs we’ve seen so far,
    but it is still very powerful, so let’s understand the two core elements that
    build it up:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**监视器**选项卡似乎是我们迄今为止看到的选项卡中最简单的，但它仍然非常强大，所以让我们了解构建它的两个核心元素：'
- en: The **Monitor** panel is where we can find the available monitors. A monitor
    is data marked for tracking. Note that there are plenty of monitors by default.
    By using them, we can obtain some valuable information about our project’s health
    (highlighted and marked with **1** in *Figure 10**.7*).
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监视器**面板是我们可以找到可用监视器的地方。监视器是标记为跟踪的数据。请注意，默认情况下有大量的监视器。通过使用它们，我们可以获得有关项目健康状况的一些有价值的信息（在*图10.7*中突出显示并标记为**1**）。'
- en: The **Graphs** panel is where the monitors are plotted as graphs, and each monitor
    has its own graph and measures. Only the monitors checked in the **Monitor** panel
    are plotted in the **Graphs** panel (highlighted and marked with **2** in *Figure
    10**.7*).
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图表**面板是监视器作为图表绘制的地方，每个监视器都有自己的图表和度量。只有**监视器**面板中检查的监视器才会在**图表**面板中绘制（在*图10.7*中突出显示并标记为**2**）。'
- en: Note that there is no *start*, *stop*, or *clear* button on the **Monitors**
    tab. This is because Godot will always track the monitorable data.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在**监视器**选项卡上没有*开始*、*停止*或*清除*按钮。这是因为Godot将始终跟踪可监视的数据。
- en: Something interesting about the `Performance` singleton. We are going to talk
    about that in the *Identifying the project’s bottlenecks* section, where we will
    also talk about the **Monitors** panel in depth. In the next section, we will
    talk about the **Video RAM** tab, where we can assess our video-related resources.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`性能`单例的一些有趣之处。我们将在*识别项目的瓶颈*部分讨论这个问题，在那里我们还将深入讨论**监视器**面板。在下一节中，我们将讨论**视频RAM**选项卡，在那里我们可以评估我们的视频相关资源。
- en: Getting to know the Video RAM tab
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解视频RAM选项卡
- en: The **Video RAM** tab is useful when you want to understand what resources are
    causing the most impact on your video memory. This is of great help, especially
    in 3D games, but it can also be useful for 2D games – for instance, when we want
    to assess whether we need to pack more sprites into a single texture.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想了解哪些资源对您的视频内存影响最大时，**视频RAM**选项卡非常有用。这在3D游戏中非常有帮助，但也可以用于2D游戏 – 例如，当我们想评估是否需要将更多的精灵打包到一个纹理中时。
- en: 'The **Video RAM** tab is quite a simple panel with the essential information
    you need to assess video-related memory consumption. In the following figure,
    we can see it is made of a single table with four columns inside a panel:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**视频RAM**选项卡是一个相当简单的面板，其中包含您评估视频相关内存消耗所需的基本信息。在下面的图中，我们可以看到它由一个包含四个列的单个表格组成，位于面板内部：'
- en: '![Figure 10.8 – Session 2’s Debugger dock Video RAM tab panel](img/Figure_10.08_B18527.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 第2次会话的调试器停靠视频RAM选项卡面板](img/Figure_10.08_B18527.jpg)'
- en: Figure 10.8 – Session 2’s Debugger dock Video RAM tab panel
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 第2次会话的调试器停靠视频RAM选项卡面板
- en: 'This is an intuitive panel with the necessary data we need to understand the
    video memory usage of our resources. Let’s understand the type of information
    each of these columns presents:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个直观的面板，包含我们理解资源视频内存使用所需的数据。让我们了解每一列所呈现的信息类型：
- en: '**Resource Path** is the path in our Godot Engine’s project to the resource.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源路径**是Godot引擎项目中资源的路径。'
- en: '`AtlasTexture` Resource or a set of simple textures, for instance.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AtlasTexture`资源或一组简单的纹理，例如。'
- en: The **Format** column is where we can find the data regarding the file’s format.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**格式**列是我们可以找到有关文件格式的数据的地方。'
- en: '**Usage** is what we actually want in the end. It answers an important question:
    Given all the previous information, how much memory does this resource take?'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** 是我们最终想要的。它回答了一个重要的问题：鉴于所有之前的信息，这个资源占用了多少内存？'
- en: Note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There’s an option to save the table as a CSV file if you want to export it and
    make some table operations or create charts. This can be very useful for presentations,
    for instance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想导出表格并执行一些表格操作或创建图表，可以选择将表格保存为 CSV 文件。这在演示中可能非常有用。
- en: The `Control` node during the debugging section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 调试部分中的 `Control` 节点。
- en: Grasping the Misc tab
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Misc标签
- en: 'As mentioned previously, the Debugger `Control` node clicked in the `Control`
    node is consuming inputs, and fix that in case we can have another `Control` node
    responsible for that. For instance, this is common when you have a `ColorRect`
    node that you use to fade the screen. If you don’t set **Mouse Filter** to **Ignore**,
    it will consume mouse events and prevent the player from interacting with other
    UI elements. In the following figure, we have the **Misc** tab for our game:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在 `Control` 节点中点击的调试器 `Control` 节点正在消耗输入，如果我们可以有一个负责该功能的另一个 `Control` 节点，那么我们应该修复这个问题。例如，当你有一个用于淡出屏幕的
    `ColorRect` 节点时，这是常见的。如果你没有将 **鼠标过滤器** 设置为 **忽略**，它将消耗鼠标事件并阻止玩家与其他 UI 元素交互。在下面的图中，我们有我们游戏的
    **Misc** 标签：
- en: '![Figure 10.9 – Session 3’s Debugger dock Misc tab and its elements](img/Figure_10.09_B18527.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 第 3 次会话的调试器停靠Misc标签及其元素](img/Figure_10.09_B18527.jpg)'
- en: Figure 10.9 – Session 3’s Debugger dock Misc tab and its elements
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 第 3 次会话的调试器停靠Misc标签及其元素
- en: 'The **Misc** tab is quite simple, and we can’t do a lot with it. Still, it’s
    a good companion when we want to address interface-related issues, so let’s understand
    the elements that build up this debugging tool:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**Misc** 标签非常简单，我们用它做不了太多事情。尽管如此，当我们想要处理与界面相关的问题时，它仍然是一个很好的伴侣。让我们了解构建这个调试工具的元素：'
- en: The `Control` node in the debugging section (highlighted and marked with **1**
    in *Figure 10**.9*).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试部分中的 `Control` 节点（在 *图 10.9* 中突出显示并标记为 **1**）。
- en: The **Clicked Control Type** row displays the type of the clicked control (highlighted
    and marked with **2** in *Figure 10**.9*).
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Clicked Control Type** 行显示被点击控件的类型（在 *图 10.9* 中突出显示并标记为 **2**）。'
- en: The `SceneTree` instance (highlighted and marked with **3** in *Figure 10**.9*).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SceneTree` 实例（在 *图 10.9* 中突出显示并标记为 **3**）。'
- en: The **Set From Tree** button has no official documentation and it seems to be
    disabled all the time, so we couldn’t test what this button does (highlighted
    and marked with **4** in *Figure 10**.9*).
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Set From Tree** 按钮没有官方文档，并且似乎一直处于禁用状态，所以我们无法测试这个按钮的功能（在 *图 10.9* 中突出显示并标记为
    **4**）。'
- en: The **Clear** button clears the data in the previously mentioned rows (highlighted
    and marked with **5** in *Figure 10**.9*).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Clear** 按钮清除之前提到的行中的数据（在 *图 10.9* 中突出显示并标记为 **5**）。'
- en: The **Export measures as CSV** button allows you to export a CSV file with the
    data in the aforementioned rows. It might be useful for keeping track of how the
    game flows based on the interactions with its controls (highlighted and marked
    with **6** in *Figure 10**.9*).
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Export measures as CSV** 按钮允许你导出一个包含上述行数据的 CSV 文件。这可能有助于跟踪游戏流程，基于与控制器的交互（在
    *图 10.9* 中突出显示并标记为 **6**）。'
- en: A good use case for this tab might be *Point ‘n’ Click* games. Since most interactions
    in this game happen with mouse clicks, we can use the Debugger **Misc** tab to
    identify which element led to a specific event. For instance, when clicking on
    a menu while a dialogue is being displayed, which one should consume the mouse
    click? Well, if the one you chose isn’t consuming the input, you can use the Debugger
    **Misc** tab to see what’s happening.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标签的一个很好的用途可能是 *点与点击* 游戏。由于这个游戏中大多数交互都是通过鼠标点击完成的，我们可以使用调试器的 **Misc** 标签来识别导致特定事件的元素。例如，当在显示对话框时点击菜单，哪个应该消耗鼠标点击？好吧，如果你选择的那个没有消耗输入，你可以使用调试器的
    **Misc** 标签来查看发生了什么。
- en: We just finished covering almost all the tools we can use to debug and profile
    our game. The only missing one is, for you, our fake studio’s network engineer,
    the most important one. The Network Profiler is where you are going to find the
    impact of your RPCs and synchronizers, along with other relevant information related
    to the High-Level Network API. Let’s get right into it!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Network Profiler
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s time to meet your best ally, the one that will help you address issues
    related to your craft as the network engineer of our fake studio and come up with
    potential solutions for the problems that appear along your journey. The Network
    Profiler, as the name suggests, is a profiler specialized in network-related profiling.
    It displays information about RPCs’ size and count, both sent and received, the
    node making and receiving the RPCs, `MultiplayerSynchronizer` nodes’ network consumption
    and syncing count, and even a bandwidth meter, which are all we need to assess
    the impact of our network code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Network Profiler, by default, only tracks the High-Level Network
    API bandwidth. So, if you are using low-level approaches, such as `PacketPeerUDP`,
    `UDPServer`, `StreamPeerTCP`, and `TCPServer`, their consumption may not be taken
    into account by the Network Profiler by default. We are going to see how we can
    address that in the *Using the Monitors* *tab* section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into the features we have available in the **Network Profiler** tab.
    Again, each element in this interface will be numbered for further reference.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Session 2’s Debugger dock Network Profiler tab and its elements](img/Figure_10.10_B18527.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Session 2’s Debugger dock Network Profiler tab and its elements
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the Network Profiler has fewer elements than the other profilers,
    each of its elements is more complex as well. You may have also noticed that there’s
    no graph element, right? So, assessing this data can be a bit less natural. But
    let’s understand what each of these elements does and how we can use them:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The RPC panel displays each node that sends and receives RPCs (highlighted and
    marked with `Asteroid` nodes have an `3`, which is probably because they receive
    3 calls to process damage and are destroyed right after the third one.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Weapon2D` has a big **Outgoing RPC** value because it’s constantly telling
    its peers’ instances to fire bullets.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Start** button. Just like in the previous profilers, network profiling
    is turned off by default; by pressing this button, we can start profiling (highlighted
    and marked with **2** in *Figure 10**.10*).*   The **Clear** button clears the
    current data gathered in the profiling session (highlighted and marked with **3**
    in *Figure 10**.10*).*   The **Bandwidth** meter displays the total bandwidth
    consumption in bytes per second of the current profiling session (highlighted
    and marked with **4** in *Figure 10**.10*):'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Down** displays how many bytes per second it downloaded in this profiling
    session'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Down** 显示在此分析会话期间每秒下载了多少字节'
- en: '**Up** displays how many bytes per second it uploaded during this profiling
    session*   The `MultiplayerSynchronizer` nodes, their `SceneReplicationConfig`
    resource, which is always built-in by default, the sync count, and sync size in
    bytes (highlighted and marked with `MultiplayerSynchronizer` node’s scene*   The
    `MultiplayerSynchronizer`*   The `SceneReplicationConfig` resource associated
    with `MultiplayerSynchronizer`*   The `MultiplayerSynchronizer` node synced its
    replication data*   The **Size** column displays the total amount of data the
    synchronization took, in bytes, during the current profiling session'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Up** 显示在此分析会话期间每秒上传了多少字节*   `MultiplayerSynchronizer` 节点，它们的 `SceneReplicationConfig`
    资源，默认情况下总是内置的，同步计数以及以字节为单位的同步大小（突出显示并标记为 `MultiplayerSynchronizer` 节点的场景*   `MultiplayerSynchronizer`*   与
    `MultiplayerSynchronizer` 相关的 `SceneReplicationConfig` 资源*   `MultiplayerSynchronizer`
    节点同步了其复制数据*   **大小** 列显示在当前分析会话期间同步所占用数据的总大小，以字节为单位'
- en: With all this information in our hands, we can make sense of how our work is
    having an impact on the project’s overall performance. Knowing how many times
    a node calls its RPCs, how many times other nodes call its RPCs, the amount of
    data exchanged, and more can help us properly address the necessary bandwidth
    a player needs to play the game properly, and also optimize the game to embrace
    players with lower network profiles.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有所有这些信息，我们可以理解我们的工作是如何影响项目整体性能的。了解节点调用其 RPC 的次数，其他节点调用其 RPC 的次数，交换的数据量等等，可以帮助我们正确地处理玩家需要以正确方式玩游戏所需的必要带宽，并优化游戏以适应网络配置较低的玩家。
- en: In the next section, we are going to learn how we can use the powerful tools
    we’ve seen so far to spot the bottlenecks in our network approach using the Network
    Profiler, but also extend our profiling by adding custom monitors to the **Monitors**
    tab. With that, we can pinpoint what we want Godot to report to us.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用我们迄今为止看到的强大工具，通过网络分析器来发现我们网络方法中的瓶颈，并通过向 **监视器** 选项卡添加自定义监视器来扩展我们的分析。这样，我们可以确定
    Godot 向我们报告的内容。
- en: Identifying the project’s bottlenecks
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别项目的瓶颈
- en: 'With all the tools we’ve seen so far in this chapter at our disposal, it’s
    time to use them to assess our project’s health and look for areas of improvement.
    Since your focus here is on networking, we are going to concentrate on features
    related to this area. In this section, we will use the final version of the [*Chapter
    9*](B18527_09.xhtml#_idTextAnchor188), *Creating an Online Adventure Prototype*,
    project to look for areas of improvement using **Network Profiler** and the **Monitors**
    debugging tools. You will learn how to do the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们迄今为止所看到的所有工具都在我们手中，现在是时候使用它们来评估我们项目的健康状况并寻找改进区域。由于你的重点是网络，我们将专注于与此区域相关的功能。在本节中，我们将使用
    *第 9 章* 的最终版本，*创建在线冒险原型* 项目，使用 **网络分析器** 和 **监视器** 调试工具来寻找改进区域。你将学习如何执行以下操作：
- en: Analyze the incoming and outgoing RPC count and size to identify potential bottlenecks
    in the network code
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析入站和出站 RPC 计数和大小，以识别网络代码中的潜在瓶颈
- en: Use the bandwidth meter to track the total bandwidth consumption and come up
    with possible solutions
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带宽计来跟踪总带宽消耗并提出可能的解决方案
- en: Assess the synchronization count and size of `MultiplayerSynchronizer` nodes
    to optimize replication data
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估 `MultiplayerSynchronizer` 节点的同步计数和大小以优化复制数据
- en: Create custom monitors to analyze relevant data specific to your project and
    track potential issues
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义监视器以分析项目特定的相关数据并跟踪潜在问题
- en: Let’s get started with the tool that will be our reliable companion through
    the process of identifying the issues related to the High-Level Network API, the
    Network Profiler.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用这个工具，它将是我们识别与高级网络 API 相关问题的可靠伴侣——网络分析器。
- en: Using the Network Profiler
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用网络分析器
- en: In the previous section, we saw the Network Profiler, one of the most powerful
    tools available to us for identifying issues related to the High-Level Network
    API. In this section, we will dive deeper into using the Network Profiler to identify
    bottlenecks related to RPCs and `MultiplayerSynchronizer` nodes. To accomplish
    this, we will be using the final version of the [*Chapter 9*](B18527_09.xhtml#_idTextAnchor188),
    *Creating an Online Adventure* *Prototype*, project.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了网络分析器，这是我们用于识别与高级网络 API 相关问题的最强大工具之一。在本节中，我们将更深入地探讨如何使用网络分析器来识别与
    RPC 和 `MultiplayerSynchronizer` 节点相关的瓶颈。为了完成这项任务，我们将使用 *第 9 章* 的最终版本，*创建在线冒险原型*
    项目。
- en: As mentioned before, we can use the Network Profiler to gather information about
    the size and count of a node’s incoming and outgoing RPCs, `MultiplayerSynchronizer`
    nodes’ network consumption, syncing count, and even a bandwidth meter. By understanding
    and analyzing this data, we can identify potential issues in our network code
    and come up with possible solutions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以使用网络分析器来收集有关节点传入和传出 RPC 的大小和计数的信息，`MultiplayerSynchronizer` 节点的网络消耗，同步计数，甚至带宽计。通过理解和分析这些数据，我们可以识别我们网络代码中的潜在问题，并提出可能的解决方案。
- en: To start, let’s take a closer look at the incoming and outgoing RPC count and
    size to identify potential bottlenecks in our network code. We will also use the
    bandwidth meter to track the total bandwidth consumption and come up with possible
    improvements.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们仔细查看传入和传出的 RPC 计数和大小，以识别我们网络代码中的潜在瓶颈。我们还将使用带宽计来跟踪总带宽消耗，并提出可能的改进措施。
- en: After that, we will assess the synchronization count and size of `MultiplayerSynchronizer`
    syncing to optimize replication data.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将评估 `MultiplayerSynchronizer` 同步的同步计数和大小，以优化复制数据。
- en: By the end of this section, you will have a better understanding of how to use
    the Network Profiler to identify and address issues related to your game’s network
    performance. So, let’s get started!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，您将更好地了解如何使用网络分析器来识别和解决与您游戏网络性能相关的问题。那么，让我们开始吧！
- en: RPCs are a straightforward and efficient way to pass data and trigger remote
    events over the network. However, it’s important to use them judiciously to avoid
    overloading the network.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: RPC 是一种简单高效地在网络上传递数据和触发远程事件的方式。然而，重要的是要谨慎使用它们，以避免网络过载。
- en: In this section, we will analyze the data related to our project’s RPCs and
    explore potential improvements. We will be implementing solutions in the next
    chapters, but for now, our focus is on learning how to look at the data critically
    and make informed decisions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析与我们项目 RPC 相关的数据，并探讨可能的改进。我们将在下一章中实施解决方案，但就目前而言，我们的重点是学习如何批判性地查看数据并做出明智的决定。
- en: We start by playing the `res://09.prototyping-space- adventure/MainMenu.tscn`
    scene with three game sessions opened. Let’s start the Network Profiler on all
    three of them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先打开三个游戏会话来播放 `res://09.prototyping-space-adventure/MainMenu.tscn` 场景。让我们在所有三个会话上启动网络分析器。
- en: '![Figure 10.11 – The Session 1 Debugger Network Profiler starting profiling](img/Figure_10.11_B18527.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – 第 1 次会话调试器网络分析器开始分析](img/Figure_10.11_B18527.jpg)'
- en: Figure 10.11 – The Session 1 Debugger Network Profiler starting profiling
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 第 1 次会话调试器网络分析器开始分析
- en: Then, let’s pick one to be the server while using the others as clients, in
    other words, as players. To enable multiple game sessions, you can select the
    **Run 3 Instances** option in the **Debug** → **Run Multiple** **Instances** menu.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们选择一个作为服务器，而使用其他作为客户端，换句话说，作为玩家。要启用多个游戏会话，您可以在“调试”→“运行多个实例”菜单中选择“运行 3 个实例”选项。
- en: With all three sessions opened, let’s identify which one is the server. For
    that, open the Debugger `ServerButton`. In my case, it’s the **Session 2** game
    instance, as shown in the following figure.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有三个会话都打开的情况下，让我们确定哪个是服务器。为此，打开调试器的“服务器按钮”。在我的情况下，它是**第 2 次会话**的游戏实例，如图下所示。
- en: '![Figure 10.12 – Using Session 2’s Debugger Misc tab to find the server’s game
    instance](img/Figure_10.12_B18527.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – 使用第 2 次会话调试器“其他”选项卡来查找服务器的游戏实例](img/Figure_10.12_B18527.jpg)'
- en: Figure 10.12 – Using Session 2’s Debugger Misc tab to find the server’s game
    instance
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 使用第 2 次会话的调试器“其他”选项卡来查找服务器的游戏实例
- en: Now that we know that `QuestDatabase`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了 `QuestDatabase`。
- en: To test whether this modification worked, I destroyed the *Asteroids* with one
    of the players’ game instances, so go ahead and do the same. After destroying
    all 30 *Asteroids*, let’s analyze the data that the Network Profiler collected.
    At this point, you can stop the Network Profiler if you want. In the following
    figure, we have the **Session 1** data, so we can assume it’s a client.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个修改是否有效，我用其中一个玩家的游戏实例摧毁了*小行星*，所以你也去做同样的事情。在摧毁所有30个*小行星*后，让我们分析网络分析器收集的数据。此时，如果你想的话，可以停止网络分析器。在下面的图中，我们有**第1次会话**的数据，所以我们可以假设它是一个客户端。
- en: '![Figure 10.13 – The Session 1 Debugger Network Profiler displaying the data
    it gathered](img/Figure_10.13_B18527.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图10.13 – 第1次会话调试器网络分析器显示其收集的数据](img/Figure_10.13_B18527.jpg)'
- en: Figure 10.13 – The Session 1 Debugger Network Profiler displaying the data it
    gathered
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 – 第1次会话调试器网络分析器显示其收集的数据
- en: Let’s start with a brief analysis of the RPC counts and size. You can see that
    in the first row, we have a player `Spaceship/Weapon2D` with a high `fire()` method
    being called from another client’s game instance, so we can assume the player
    that destroyed the *Asteroids* used **Session 3**.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对RPC计数和大小的简要分析开始。你可以看到，在第一行，我们有一个玩家`Spaceship/Weapon2D`，它的`fire()`方法被另一个客户端的游戏实例调用，所以我们可以假设摧毁*小行星*的玩家使用了**第3次会话**。
- en: 'This client called this method 693 times. The `fire()` method doesn’t rely
    on any data that would require streaming it this many times. `Weapon2D` essentially
    has two major states:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个客户端调用了这个方法693次。`fire()`方法不依赖于任何需要流式传输这么多次数的数据。`Weapon2D`本质上有两个主要状态：
- en: Firing
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射
- en: Not firing
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未发射
- en: This means that we could improve this RPC count by sending a Boolean value through
    the network once when the player presses the firing action and when they release
    the firing action. In the meantime, `Weapon2D` itself would just toggle between
    these two states, firing and not firing, and use `process()` to spawn *Bullets*
    based on their fire rate. This would reduce this RPC count by a lot.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以通过在玩家按下发射动作和释放发射动作时通过网络发送一个布尔值来改进这个RPC计数。同时，`Weapon2D`本身会在这两个状态之间切换，发射和不发射，并使用`process()`根据它们的发射速率生成*子弹*。这将大大减少这个RPC计数。
- en: Did you notice how important this assessment can be as you build your project
    and adjust it along the way? Pretty cool, right?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到，在构建你的项目并沿途调整时，这项评估有多么重要？真是太酷了，对吧？
- en: Next, let’s take a look at the `QuestDatabase` node in the fourth row. It’s
    the only node that has an outgoing RPC count, right? So, it’s making requests
    to the server’s game instance. It made a total of 30 RPCs, but notice that their
    size is comparatively bigger than the 693 incoming `fire()` RPCs. This means that
    the data transmitted through this RPC is bigger. We should pay attention to it.
    This is likely to be the `update_player_progress()` method. Notice that we have
    30 *Asteroids*, and every time we destroy one of them, we make an RPC to the `update_player_progress()`
    method. The count is correct and I can’t see a clear area of improvement in this
    regard. It has a ratio of 1:1 – one event, one trigger. So, we are likely to figure
    out a way to improve the data; maybe compress it somehow to decrease the overall
    bandwidth.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看第四行的`QuestDatabase`节点。这是唯一一个有出站RPC计数的节点，对吧？所以，它正在向服务器的游戏实例发送请求。它总共发送了30个RPC，但请注意，它们的大小与693个传入的`fire()`
    RPC相比要大得多。这意味着通过这个RPC传输的数据更大。我们应该注意这一点。这很可能是`update_player_progress()`方法。请注意，我们有30个*小行星*，每次我们摧毁其中一个，我们就会向`update_player_progress()`方法发送一个RPC。计数是正确的，我看不出在这方面有明显的改进空间。它的比例是1:1
    – 一个事件，一个触发器。所以，我们很可能会找到一种方法来改进数据；也许通过某种方式压缩它以减少整体带宽。
- en: Finally, let’s take a look at the *Asteroids’* RPC count. Every single one of
    them receives only 3 RPCs; this is probably due to the server’s *Bullets* hitting
    the *Asteroids*, which leads to the server calling the `hit()` method twice on
    the clients’ instances. Then, it calls the `explode()` method the third time a
    *Bullet* hits
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看*小行星*的RPC计数。每一个都只接收3个RPC；这可能是由于服务器的*子弹*击中*小行星*，导致服务器在客户端实例上调用`hit()`方法两次。然后，当*子弹*第三次击中时，它调用`explode()`方法
- en: the *Asteroid*. It seems that this class is pretty healthy regarding its RPC
    counts on the client’s side. There’s nothing to improve on this side of the relationship.
    Let’s take a look at the server’s side. The following figure showcases the server’s
    Network Profiler. Note that, in this playtest, the server is represented by the
    **Session 3** instance of the game.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 的 *小行星*。看起来这个类在客户端的 RPC 计数方面相当健康。在这一关系的一侧没有需要改进的地方。让我们看看服务器端的情况。以下图展示了服务器的网络分析器。请注意，在这个测试中，服务器由游戏的
    **会话 3** 实例表示。
- en: '![Figure 10.14 – The Session 3 Debugger Network Profiler displaying the data
    it gathered](img/Figure_10.14_B18527.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.14 – 会话 3 调试器网络分析器显示其收集的数据](img/Figure_10.14_B18527.jpg)'
- en: Figure 10.14 – The Session 3 Debugger Network Profiler displaying the data it
    gathered
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 会话 3 调试器网络分析器显示其收集的数据
- en: The server has outgoing RPCs on its *Asteroids* instances, and they also have
    a total count of `SceneTree` instance, so there’s no reason to play animations
    on the server. Ideally, the server will be a headless instance, so there’s really
    no reason to play animations on it. But we won’t dwell in these lands yet. What
    we can do in the current project is to change the `hit()` method’s RPC annotation
    to only call it remotely and not locally. This way, at least the hit animation
    will only play on the client’s side.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在其 *小行星* 实例上有出站 RPC，并且还有一个 `SceneTree` 实例的总数，因此没有必要在服务器上播放动画。理想情况下，服务器将是一个无头实例，因此在上面播放动画真的没有必要。但我们现在不会深入探讨这些领域。在当前项目中，我们可以将
    `hit()` 方法的 RPC 注解更改为仅远程调用，而不是本地调用。这样，至少击中动画只会播放客户端的一侧。
- en: Let’s take the chance that we are working with the *Asteroids* and also make
    an analysis of their `MultiplayerSynchronizer` nodes. You can see on the right
    panel’s `World` node calls its `sync_world()` method. After that, there’s no reason
    to keep updating the asteroids’ properties. So, we can use the asteroids `MultiplayerSynchronizer`
    `update_visibility()` method inside the `sync_world()` method and decrease this
    bandwidth consumption as well.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以正在处理的 *小行星* 为例，并对它们的 `MultiplayerSynchronizer` 节点进行分析。您可以在右侧面板的 `World`
    节点中看到它调用了 `sync_world()` 方法。之后，就没有必要继续更新小行星的属性了。因此，我们可以在 `sync_world()` 方法内部使用小行星的
    `MultiplayerSynchronizer` `update_visibility()` 方法，并减少带宽消耗。
- en: By using the Network Profiler, we already identified areas for improvement,
    such as reducing the number of RPCs sent to the `Weapon2D.fire()` method and manually
    calling the `MultiplayerSynchronizer` syncing to decrease overall bandwidth. We
    also saw that we can change the RPC annotation of `Asteroid.hit()` to only call
    it remotely and not locally to reduce unnecessary animations on the server side.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用网络分析器，我们已经确定了改进的区域，例如减少发送到 `Weapon2D.fire()` 方法的 RPC 数量，并手动调用 `MultiplayerSynchronizer`
    同步以减少整体带宽。我们还看到，我们可以将 `Asteroid.hit()` 的 RPC 注解更改为仅远程调用，而不是本地调用，以减少服务器端不必要的动画。
- en: Well, with just a brief analysis, we spotted some clear areas for improvement,
    didn’t we? And we haven’t even finished our assessment yet! In the next section,
    we will see how we can use the `Performance` singleton to create custom monitors
    and track them in the monitors track.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，仅仅通过简要分析，我们就发现了明显的改进区域，不是吗？而且我们还没有完成评估！在下一节中，我们将看到如何使用 `Performance` 单例创建自定义监视器，并在监视器跟踪中跟踪它们。
- en: Using the Monitors tab
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用监视器标签页
- en: 'In the previous section, we learned about the Network Profiler and how it can
    help us identify potential bottlenecks in our game’s network performance. In this
    section, we will focus on another powerful debugging tool in Godot Engine: the
    **Monitors** tab.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了网络分析器以及它是如何帮助我们识别游戏中网络性能的潜在瓶颈。在本节中，我们将关注 Godot 引擎中的另一个强大的调试工具：**监视器**标签页。
- en: The **Monitors** tab allows us to track and analyze specific data points in
    real time. We can use it to keep track of variables, functions, and even custom
    data points that we define ourselves. By monitoring these data points, we can
    gain insight into how our project is performing and identify areas for improvement.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**监视器**标签页允许我们实时跟踪和分析特定的数据点。我们可以用它来跟踪变量、函数，甚至是我们自己定义的自定义数据点。通过监控这些数据点，我们可以深入了解项目性能，并识别出需要改进的领域。'
- en: In addition to the built-in monitors, we can also create custom monitors to
    track specific variables or functions in our project. To do this, we need to use
    the `Performance.add_custom_monitor()` method, passing an ID, a `callable` instance,
    and, optionally, an array as arguments. Godot will create a monitor in the `id`
    argument and track the data using the `Callable` instance passed in the `callable`
    argument. This means that every time we trigger an event that should count for
    the data tracking, we need to execute the `callable` instance.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置的监视器外，我们还可以创建自定义监视器来跟踪项目中特定的变量或函数。为此，我们需要使用 `Performance.add_custom_monitor()`
    方法，传递一个 ID、一个 `callable` 实例，以及可选的数组作为参数。Godot 将在 `id` 参数中创建一个监视器，并使用传递给 `callable`
    参数的 `Callable` 实例跟踪数据。这意味着每次我们触发应计入数据跟踪的事件时，我们需要执行 `callable` 实例。
- en: During the current section, we will use the `QuestDatabase` node and the `QuestSingleton`
    node. By monitoring these data points, we will gain some insights into how our
    quest system is performing and identify potential areas for improvement.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 `QuestDatabase` 节点和 `QuestSingleton` 节点。通过监控这些数据点，我们将深入了解我们的任务系统性能，并识别潜在的改进区域。
- en: 'Let’s start by opening the `res://09.prototyping-spaceadventure/Quests/QuestDatabase.gd`
    script. We are going to create a member variable to keep track of how many times
    the `QuestDatabase.update_player_progress()` method was called. We can name this
    variable `quest_update_count` and set its default value to `0`. Then, we need
    to create a method that returns its current value; let’s call this method `get_quest_update_count()`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开 `res://09.prototyping-spaceadventure/Quests/QuestDatabase.gd` 脚本开始。我们将创建一个成员变量来跟踪
    `QuestDatabase.update_player_progress()` 方法被调用的次数。我们可以将此变量命名为 `quest_update_count`
    并将其默认值设置为 `0`。然后，我们需要创建一个返回其当前值的方法；让我们称这个方法为 `get_quest_update_count()`：
- en: '[PRE0]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To update `quest_update_count`, let’s increment its value after the server
    successfully updates the player’s progress in a given quest. So, in the `update_player_progress()`
    method, add a line inside the `if multiplayer.is_server()` statement incrementing
    `quest_update_count` by `1` :'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新 `quest_update_count`，请在服务器成功更新给定任务中玩家的进度后增加其值。因此，在 `update_player_progress()`
    方法中，在 `if multiplayer.is_server()` 语句内添加一行代码，将 `quest_update_count` 增加 `1`：
- en: '[PRE1]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With that, we have everything ready to add `get_quest_update_count()` to our
    `_ready()` callback, create a `Callable` variable pointing to `QuestDatabase`
    using the `self` keyword, and pointing to `"get_quest_update_count"`. We can name
    this `Callable` variable `callable` to simplify the process:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经准备好将 `get_quest_update_count()` 添加到我们的 `_ready()` 回调中，创建一个指向 `QuestDatabase`
    的 `Callable` 变量，使用 `self` 关键字，并指向 `"get_quest_update_count"`。我们可以将这个 `Callable`
    变量命名为 `callable` 以简化过程：
- en: '[PRE2]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, let’s call the `Performance.add_custom_monitor()` method. To keep things
    organized, we will use a category named `"Network"` for our custom monitors. So,
    in the `id` argument, we will pass `"Network/Quests Updates"` and pass `callable`
    as the second argument:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们调用 `Performance.add_custom_monitor()` 方法。为了保持组织有序，我们将使用名为 `"Network"`
    的类别来命名我们的自定义监视器。因此，在 `id` 参数中，我们将传递 `"Network/Quests Updates"` 并将 `callable` 作为第二个参数传递：
- en: '[PRE3]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let’s start by opening the `res://09.prototyping-space- adventure/Quests/QuestDatabase.gd`
    script. We are going to create a member variable to keep track of how many times
    the method was called.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开 `res://09.prototyping-space- adventure/Quests/QuestDatabase.gd` 脚本开始。我们将创建一个成员变量来跟踪方法被调用的次数。
- en: Now, to test whether this custom monitor is working and assess the data it will
    provide, let’s test the game using three debugging sessions and use one of the
    clients to destroy some *Asteroids*. This time around, my server is on **Session
    2**. The following figure showcases **Session 2**’s **Monitors** tab. You can
    find the **Quests Updates** monitor at the very bottom of the **Monitor** panel;
    tick the checkbox and Godot will display the tracked data.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试这个自定义监视器是否正常工作并评估它将提供的数据，让我们使用三个调试会话来测试游戏，并使用其中一个客户端销毁一些 *小行星*。这次，我的服务器在
    **Session 2**。以下图展示了 **Session 2** 的 **监视器** 选项卡。您可以在 **监视器** 面板的底部找到 **Quests
    Updates** 监视器；勾选复选框，Godot 将显示跟踪数据。
- en: '![Figure 10.15 – The Session 2 Debugger Monitors tab displaying the Quests
    Updates tracked data](img/Figure_10.15_B18527.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.15 – 显示 Quests Updates 跟踪数据的 Session 2 调试器监视器选项卡](img/Figure_10.15_B18527.jpg)'
- en: Figure 10.15 – The Session 2 Debugger Monitors tab displaying the Quests Updates
    tracked data
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 – 显示 Quests Updates 跟踪数据的 Session 2 调试器监视器选项卡
- en: Notice that Godot counted only 58 quest updates. So I may have missed one asteroid.
    Interesting, right? Why does one *Asteroid* trigger two calls to the `QuestDatabase.update_player_progress()`
    method? Well, remember that currently the quest progress is shared among all peers,
    so this can grow exponentially. If there were 3 players, there would be 96 calls
    to `QuestDatabase.update_player_progress()`. We need to figure out a way to limit
    that. One quick solution is to check whether the quest is already completed, and
    if it is, stop updating it. This would limit this particular quest to 10 calls
    per player, which would be a good improvement.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 Godot 只计算了 58 个任务更新。所以我可能错过了一颗小行星。有趣，对吧？为什么一颗 *小行星* 会触发对 `QuestDatabase.update_player_progress()`
    方法的两次调用？好吧，记住，目前任务进度是在所有对等体之间共享的，所以这可能会呈指数增长。如果有 3 个玩家，就会有 96 次对 `QuestDatabase.update_player_progress()`
    的调用。我们需要找出一种限制它的方法。一个快速的解决方案是检查任务是否已经完成，如果是，就停止更新它。这将把这个特定的任务限制为每个玩家 10 次调用，这将是一个很好的改进。
- en: 'Let’s make this comparison, just for testing purposes. Open `res://09.prototyping-space-adventure/Quests/QuestSingleton.gd`
    and let’s create a monitor that would only increment until the quest reaches the
    target amount required to complete the quest. To do that, let’s create a new member
    variable called `increase_count` and set its value to `0` by default:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行这个比较，仅用于测试目的。打开 `res://09.prototyping-space-adventure/Quests/QuestSingleton.gd`
    并创建一个监控器，该监控器只会递增，直到任务达到完成任务所需的目标数量。为此，让我们创建一个新的成员变量名为 `increase_count` 并将其默认值设置为
    `0`：
- en: '[PRE4]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, let’s create a method called `get_quest_increases()` that will return
    this variable:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个名为 `get_quest_increases()` 的方法，该方法将返回这个变量：
- en: '[PRE5]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `_ready()` callback, if this is a client instance, we will add a new
    custom monitor using the previous method as `callable`, just like we did with
    `QuestDatabase.get_quest_update_count()`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `_ready()` 回调中，如果这是一个客户端实例，我们将使用之前的方法作为 `callable` 添加一个新的自定义监控器，就像我们使用 `QuestDatabase.get_quest_update_count()`
    一样：
- en: '[PRE6]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, inside the `increase_quest_progress()` method, we will create an `if`
    statement that will only increment `increase_count` while `quest.current_amount`
    is less than `quest.target_amount`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `increase_quest_progress()` 方法中，我们将创建一个 `if` 语句，该语句只有在 `quest.current_amount`
    小于 `quest.target_amount` 时才会递增 `increase_count`：
- en: '[PRE7]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let’s test the game again and see what happens in the clients’ **Monitors**
    tab. In the following figure, there’s something very interesting happening.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次测试游戏，看看客户端的 **监控** 标签页中会发生什么。在下面的图中，有一些非常有趣的事情正在发生。
- en: '![Figure 10.16 – The Session 2 Debugger Monitors tab displaying the Quests
    Increases tracked data](img/Figure_10.16_B18527.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.16 – 会话 2 调试器监控标签页显示的任务递增跟踪数据](img/Figure_10.16_B18527.jpg)'
- en: Figure 10.16 – The Session 2 Debugger Monitors tab displaying the Quests Increases
    tracked data
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.16 – 会话 2 调试器监控标签页显示的任务递增跟踪数据
- en: This time around, `user2` credentials. Why this is relevant? Notice that there
    were only four increments to `increase_count` in this game instance. This is due
    to the fact that, in the `res://09.prototypingspace-adventure/Quests/QuestDatabase.json`
    file, `user2` already destroyed five asteroids, so it only needed five more to
    complete the quest. This means that we can improve this aspect of our game even
    between play sessions. The more progress a player makes in a game session, the
    fewer RPCs we will need to make to the server if we implement this approach; pretty
    cool, isn’t it?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这次是 `user2` 凭据。这有什么相关性？注意，在这个游戏实例中，`increase_count` 只增加了四次。这是因为，在 `res://09.prototyping-space-adventure/Quests/QuestDatabase.json`
    文件中，`user2` 已经摧毁了五颗小行星，所以它只需要再摧毁五颗来完成任务。这意味着我们甚至可以在游戏会话之间改进这个方面。玩家在游戏会话中取得的进步越多，如果我们实施这种方法，我们就需要向服务器发出越少的
    RPC 调用；这不是很酷吗？
- en: Throughout this section, we learned how we can use the `Performance` singleton
    to create new monitors in the `Performance.add_custom_monitor()` method. We also
    saw how we can create methods to collect data about potential bottlenecks in our
    game. Finally, we saw some potential fixes to the issues we found while debugging
    the game in order to optimize it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用 `Performance` 单例在 `Performance.add_custom_monitor()` 方法中创建新的监控器。我们还看到了如何创建方法来收集有关我们游戏中潜在瓶颈的数据。最后，我们看到了一些潜在的修复方法，以解决我们在调试游戏时发现的问题，以便优化它。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With that, we conclude our chapter! Throughout this chapter, we introduced the
    **Debugger** dock, which is a powerful tool for assessing and debugging potential
    problems in our game, as well as for optimizing its performance.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就结束了本章的内容！在本章中，我们介绍了**调试器**面板，这是一个强大的工具，用于评估和调试游戏中可能存在的问题，以及优化其性能。
- en: We explored the **Stack Trace** tab, which gives us an overview of our game’s
    flow and provides us with multiple ways to gather information about the changes
    that happen throughout this flow, allowing us to understand the whole chain of
    cause and effect that led to a given change. We also talked about the **Errors**
    tab, which is where we work together with thousands of other developers who worked
    on the development of Godot Engine’s core and identified thousands of errors and
    documented them so that when they happen, we have some light on the issue and
    can fix it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了**堆栈跟踪**标签页，它为我们提供了对游戏流程的概述，并提供了多种方式来收集关于整个流程中发生的变化的信息，使我们能够理解导致特定变化的原因和效果的整个链条。我们还讨论了**错误**标签页，这是我们与数千名参与Godot引擎核心开发的其他开发者一起工作的地方，我们识别了数千个错误并对其进行了记录，以便当它们发生时，我们能够对问题有所了解并修复它。
- en: 'On top of that, we explored two powerful performance-based debugging tabs:
    the **Profiler** tab and the **Visual Profiler** tab. The **Profiler** tab is
    one of your best allies in this task, as it allows you to see rendering time,
    physics simulation time, audio processing time, and even how much time each of
    your custom script functions is taking to process and how many times they were
    called. The **Visual Profiler** tab specializes in tracking and measuring rendering-related
    tasks and can help you keep track of what is causing the most delay in rendering
    a frame on the CPU and GPU.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还探讨了两个基于性能的调试标签页：**性能分析器**标签页和**视觉性能分析器**标签页。**性能分析器**标签页是你在这项任务中的最佳盟友之一，因为它允许你看到渲染时间、物理模拟时间、音频处理时间，甚至每个自定义脚本函数处理所需的时间和它们被调用的次数。**视觉性能分析器**标签页专注于跟踪和测量与渲染相关的任务，可以帮助你追踪在CPU和GPU上渲染帧时造成最大延迟的原因。
- en: However, the protagonists of the chapter were the `MultiplayerSynchronizer`
    nodes by analyzing data gathered by the tool. By understanding and analyzing this
    data, we came up with possible solutions to optimize network code. In addition
    to that, we learned how to use the `Performance` singleton and create custom monitors
    to track specific data points in real time in the **Monitors** tab. By monitoring
    these data points, we gained insights into how our project is performing and even
    made a test for a potential improvement.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本章的主角是通过分析工具收集的数据来分析`MultiplayerSynchronizer`节点。通过理解和分析这些数据，我们提出了优化网络代码的可能解决方案。除此之外，我们还学习了如何使用`Performance`单例并在**监控器**标签页中创建自定义监控器，以实时跟踪特定的数据点。通过监控这些数据点，我们获得了关于项目性能的见解，甚至对潜在的改进进行了测试。
- en: In the next chapter, we are going to optimize data requests, especially regarding
    the quests data from the `QuestDatabase.get_player_quests()` method.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将优化数据请求，特别是关于`QuestDatabase.get_player_quests()`方法中的任务数据。
- en: By optimizing the way we request and handle data, we can improve our game’s
    performance and provide a better experience for our users. See you there!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过优化我们请求和处理数据的方式，我们可以提高游戏性能并为用户提供更好的体验。在那里见！
