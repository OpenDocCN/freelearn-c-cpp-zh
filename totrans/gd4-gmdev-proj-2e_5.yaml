- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3D Minigolf: Dive into 3D by Building a Minigolf Course'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous projects in this book have been designed in 2D space. This is intentional
    to introduce the features and concepts of Godot while keeping the projects’ scopes
    limited. In this chapter, you’ll venture into the 3D side of game development.
    For some, 3D development feels significantly more difficult to manage. For others,
    it is more straightforward. In either case, there is certainly an additional layer
    of complexity for you to understand.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve never worked with any kind of 3D software before, you may find yourself
    encountering many new concepts. This chapter will explain them as much as possible,
    but remember to refer to the Godot documentation whenever you need a more in-depth
    understanding of a particular topic.
  prefs: []
  type: TYPE_NORMAL
- en: The game you’ll make in this chapter is called *3D Minigolf*. In it, you’ll
    build a small minigolf course, a ball, and an interface for aiming and shooting
    the ball toward the hole.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the things you’ll learn in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigating Godot’s 3D editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Node3D` and its properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing 3D meshes and using 3D collision shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use 3D cameras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up lighting and environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to PBR and materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before diving in, a brief introduction to 3D in Godot.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Download the game assets from the following link and unzip them into your new
    project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also find the complete code for this chapter on GitHub at: [https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter05%20-%203D%20Minigolf](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter05%20-%203D%20Minigolf)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to 3D
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the strengths of Godot is its ability to handle both 2D and 3D games.
    Much of what you’ve learned earlier in this book will apply equally well in 3D
    – nodes, scenes, signals, etc. But changing from 2D to 3D also brings with it
    a whole new layer of complexity and capabilities. First, you’ll find that there
    are some additional features available in the 3D editor window, and it’s a good
    idea to familiarize yourself with how to navigate.
  prefs: []
  type: TYPE_NORMAL
- en: Orienting in 3D space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open a new project and click on the **3D** button at the top of the editor
    window to see the 3D project view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: The 3D workspace](img/B19289_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: The 3D workspace'
  prefs: []
  type: TYPE_NORMAL
- en: The first things you should notice are the three colored lines in the center.
    These are the `x` (red), `y` (green), and `z` (blue) axes. The point where they
    meet is the `(0,` `0, 0)`.
  prefs: []
  type: TYPE_NORMAL
- en: 3D coordinates
  prefs: []
  type: TYPE_NORMAL
- en: Just as you used `Vector2(x, y)` to indicate a position in 2D space, you’ll
    use `Vector3(x, y, z)` to describe a position in three dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: One issue that often arises when working in 3D is that different applications
    use different conventions for orientation. Godot uses the `x` is pointing to the
    left/right, then `y` is up/down and `z` is forward/back. If you use other popular
    3D software, you may find that some of them use **Z-Up**. It’s good to be aware
    of this, as it can lead to confusion when moving between different programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important thing to be aware of is the unit of measure. In 2D, Godot
    measures everything in pixels, which makes sense as the natural basis for measurement
    when drawing on the screen. However, when working in 3D space, pixels aren’t really
    useful. Two objects of the same size will occupy different areas on the screen
    depending on how far away they are from the camera (more about cameras soon).
    For this reason, in 3D space, all objects in Godot are measured in generic units.
    While it’s most common to refer to them as “meters,” you’re free to call these
    units whatever you like: inches, millimeters, or even light years, depending on
    the scale of your game world.'
  prefs: []
  type: TYPE_NORMAL
- en: Godot’s 3D editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before moving too deeply into building a game, it will be useful to review
    how to navigate in 3D space. The view camera is controlled using the mouse and
    keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Mouse wheel up/down*: Zoom in/out on the current target'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Middle button* + *drag*: Orbit the camera around the current target'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Shift* + *middle button* + *drag*: Pan the camera up/down/left/right'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Right button* + *drag*: Rotate the camera in place'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that some of these movements are based on a camera target, or **focus**.
    To focus on an object in space, you can select it and press *F*.
  prefs: []
  type: TYPE_NORMAL
- en: Freelook navigation
  prefs: []
  type: TYPE_NORMAL
- en: If you’re familiar with popular 3D games such as *Minecraft*, you can press
    *Shift* + *F* to switch to FreeLook mode. In this mode, you can use the *W*/*A*/*S*/*D*
    keys to fly around the scene while aiming with the mouse. Press *Shift* + *F*
    again to exit FreeLook mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also affect the camera’s view by clicking on the **Perspective** label
    in the upper-left corner of the viewport. Here, you can snap the camera to a particular
    orientation such as **Top View** or **Front View**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: Perspective menu](img/B19289_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Perspective menu'
  prefs: []
  type: TYPE_NORMAL
- en: This can be especially useful on large displays when combined with the use of
    multiple viewports. Click the **View** menu and you can split the screen into
    multiple views, allowing you to see an object from all sides simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Keyboard shortcuts
  prefs: []
  type: TYPE_NORMAL
- en: Note that each of these menu options has a keyboard shortcut associated with
    it. You can click on **Editor** -> **Editor Settings** -> **3D** to see and adjust
    the keyboard shortcuts to your liking.
  prefs: []
  type: TYPE_NORMAL
- en: Adding 3D objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s time to add your first 3D node. Just as all 2D nodes inherit from `Node2D`,
    which provides properties such as `Node3D`, which provides spatial properties.
    Add one to the scene and you’ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: Node3D with a gizmo](img/B19289_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Node3D with a gizmo'
  prefs: []
  type: TYPE_NORMAL
- en: That colorful object you see is not the node, but rather a 3D **gizmo**. The
    gizmo is a tool that allows you to move and rotate objects in space. The three
    rings control rotation, while the three arrows move the object along the three
    axes. Notice that the rings and arrows are color-coded to match the axis colors.
    The arrows move the object *along* the corresponding axis, while the rings rotate
    the object *around* a particular axis. There are also three small squares that
    lock one axis and allow you to move along the object in a plane.
  prefs: []
  type: TYPE_NORMAL
- en: Take a few minutes to experiment and get familiar with the gizmo. Delete the
    node and add another if you find yourself getting lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes the gizmo gets in the way. You can click on the mode icons to restrict
    yourself to only one type of transformation: **Movement**, **Rotation**, or **Scaling**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: Select mode icons](img/B19289_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Select mode icons'
  prefs: []
  type: TYPE_NORMAL
- en: The *Q*/*W*/*E*/*R* keys are shortcuts for these buttons, allowing you to quickly
    change between modes.
  prefs: []
  type: TYPE_NORMAL
- en: Global versus local space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, the gizmo control operates in a global space. Try rotating the
    object – no matter how you turn it, the gizmo’s movement arrows still point along
    the global axes. Now try this: put the `Node3D` node back into its original position
    and orientation (or delete it and add a new one). Rotate the object around one
    axis and then click the **Use Local Space** button (note the **T** shortcut):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5: Toggling Local Space mode](img/B19289_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: Toggling Local Space mode'
  prefs: []
  type: TYPE_NORMAL
- en: Observe what happens to the gizmo arrows. They now point along the object’s
    *local* axes and not the world’s axes. When you click and drag the arrows, they
    move the object relative to its own rotation. You can toggle back to global space
    by clicking the button again. Switching back and forth between these two modes
    can make it much easier to place an object exactly where you want it.
  prefs: []
  type: TYPE_NORMAL
- en: Transforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Look at the Inspector for `Node3D`. Under the **Transform** section, you’ll
    see the node’s **Position**, **Rotation**, and **Scale** properties. As you move
    the object around, you’ll see these values change. Just as in 2D, these values
    are *relative* to the node’s parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Together, these three quantities make up the node’s `transform` property, which
    is a Godot `Transform3D` object. `Transform3D` has two sub-properties: `origin`
    and `basis`. The `origin` property represents the body’s position, while the `basis`
    property contains three vectors that define the body’s local coordinate axes.
    Think of the three axis arrows in the gizmo when you were in **Local** **Space**
    mode.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see how to use these properties later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Meshes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like `Node2D`, a `Node3D` node has no size or appearance of its own. In
    2D, you added `Sprite2D` to display a texture attached to a node. In 3D, you’ll
    typically want to add a **mesh**. A mesh is a mathematical description of a three-dimensional
    shape. It consists of a collection of points called **vertices**. These vertices
    are connected by lines, called **edges**, and multiple edges (at least three)
    together make a **face**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A cube, for example, is composed of eight vertices, twelve edges, and six faces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6: Vertices, edges, and faces](img/B19289_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Vertices, edges, and faces'
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve ever used 3D design software, this may already be familiar to you.
    If you haven’t, and you’re interested in learning about 3D modeling, *Blender*
    is a very popular open source tool for designing 3D objects. You can find many
    tutorials and lessons on the internet to help you get started with Blender.
  prefs: []
  type: TYPE_NORMAL
- en: Primitives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you haven’t already created or downloaded a 3D model, or if you just need
    a simple shape quickly, Godot has the ability to create certain 3D meshes directly.
    Add a `MeshInstance3D` node as a child of your `Node3D` node, and in the Inspector,
    look for the **Mesh** property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7: Adding a new mesh](img/B19289_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: Adding a new mesh'
  prefs: []
  type: TYPE_NORMAL
- en: These predefined shapes are called **primitives**, and they represent a handy
    collection of common useful shapes. Select **New BoxMesh** and you’ll see a cube
    appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Importing meshes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whatever modeling software you may use, you will need to export your models
    in a format that is readable by Godot. Godot supports a number of file formats
    for importing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`glTF` – supported in both text (`.gltf`) and binary (`.``glb`) versions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DAE (COLLADA)` – an old format that is still supported'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OBJ (Wavefront)` – supported, but limited due to the format limitations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ESCN` – a Godot-specific file format that Blender can export'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FBX` – a commercial format that has limited support'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recommended format is `.gltf`. It has the most features and is very well
    supported in Godot. See the appendix for details about exporting `.gltf` files
    from Blender for use in Godot.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see how to import some pre-built `.gltf` scenes later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Cameras
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Try running the scene with your cube mesh. Where is it? In 3D, you won’t see
    anything in the game viewport unless you have a `Camera3D` camera in the scene.
    Add one, and you’ll see a new node that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8: Camera widget](img/B19289_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.8: Camera widget'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the camera’s gizmo to position it a little bit above and point toward the
    cube:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9: Aiming the camera](img/B19289_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: Aiming the camera'
  prefs: []
  type: TYPE_NORMAL
- en: The pinkish-purple, pyramid-shaped object is called the camera’s **frustum**.
    It represents the camera’s view and can be made narrow or wide to affect the camera’s
    **field of view**. The triangular shape at the top of the frustum indicates the
    camera’s “up” direction.
  prefs: []
  type: TYPE_NORMAL
- en: As you’re moving the camera around, you can press the **Preview** button in
    the upper-right of the viewport to check what the camera sees. Go ahead and experiment
    with positioning the camera and adjusting its **FOV**.
  prefs: []
  type: TYPE_NORMAL
- en: Orientation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that the camera’s frustum faces along the `transform.basis` is the object’s
    local set of axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These new concepts and editor functions will help you to navigate and work in
    3D space. Refer back to this section if you need a reminder of what a particular
    3D-related term means. In the next section, you’ll start setting up your first
    3D project.
  prefs: []
  type: TYPE_NORMAL
- en: Project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you’ve learned how to navigate in Godot’s 3D editor, you’re ready to
    start on the minigolf game. As with the other projects, download the game assets
    from the following link and unzip them into your project folder. The unzipped
    `assets` folder contains images, 3D models, and other items you’ll need to complete
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project and download the project assets from [https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition](https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice a few different folders in `assets`. The `courses` folder has
    some pre-built minigolf holes for you to try out and compare to the ones you make.
    Don’t look at them yet – try and follow the steps to make your own first.
  prefs: []
  type: TYPE_NORMAL
- en: 'This game will use the left mouse click as an input. Open `click` and then
    click the plus sign to add the **Left Mouse Button** input to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: Assigning a mouse button input](img/B19289_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.10: Assigning a mouse button input'
  prefs: []
  type: TYPE_NORMAL
- en: 'While you’re in **Project Settings**, you can also set how the game behaves
    when the game window is resized. During gameplay, the user may choose to resize
    the window, which could disrupt the layout of your UI or show a distorted view
    of the game. To prevent this, navigate to the **Display/Window** section and find
    the **Stretch/Mode** setting. Change it to **viewport**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: Setting window stretch mode](img/B19289_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.11: Setting window stretch mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'That completes the setup of the project. Now, you can move on to building the
    first part of the game: the minigolf course.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the course
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the first scene, add a `Node3D` node called `Hole` and save the scene. As
    you did in *Jungle Jump*, you’re going to make a generic scene containing all
    the nodes and code that any hole will need, then inherit from this scene to make
    as many individual holes as you want to have in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Next, add a `GridMap` node to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding GridMaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`GridMap` is the 3D equivalent of the `TileMap` node you used earlier in the
    book. It allows you to use a collection of meshes (contained in a `MeshLibrary`
    collection – similar to `TileSet`) and lay them out in a grid. Because it operates
    in 3D, you can stack the meshes in any direction, although for this project you’ll
    stick to one plane.'
  prefs: []
  type: TYPE_NORMAL
- en: Making a MeshLibrary collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `res://assets/` folder, you’ll find a pre-generated `MeshLibrary` feature
    named `golf_tiles.tres` containing all the necessary course parts along with their
    collision shapes.
  prefs: []
  type: TYPE_NORMAL
- en: To create your own `MeshLibrary` function, you’ll make a 3D scene containing
    the individual meshes you want to use, add collisions to them, and then export
    that scene into a `MeshLibrary` collection. If you open `golf_tiles.tscn`, you’ll
    see the original scene that was used to create `golf_tiles.tres`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this scene, you’ll see all the individual golf course tile meshes, as they
    were imported from Blender, where they were originally modeled. To add collision
    shapes to each one, Godot has a handy shortcut: select a mesh and you’ll see a
    **Mesh** menu appear in the toolbar at the top of the viewport:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: The Mesh menu](img/B19289_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: The Mesh menu'
  prefs: []
  type: TYPE_NORMAL
- en: Select `StaticBody3D` node along with a `CollisionShape3D` node using the mesh’s
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the collisions are added, you can choose `GridMap` can use.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the first hole
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drag the `MeshLibrary` file into the `GridMap` node. You’ll see a list of the
    available tiles appear on the right side of the editor viewport.
  prefs: []
  type: TYPE_NORMAL
- en: To match the size of the tiles, set `(1,` `1, 1)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure the collisions with the ball will look good, find `0.5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: Working with Physics Material](img/B19289_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.13: Working with Physics Material'
  prefs: []
  type: TYPE_NORMAL
- en: Try drawing by selecting a tile piece from the list and placing it in the scene
    by left-clicking. You can rotate a piece around the `y` axis by pressing **S**.
    To remove a tile, right-click on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, stick to a simple layout. You can get fancy later when everything
    is working:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14: Example course layout](img/B19289_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.14: Example course layout'
  prefs: []
  type: TYPE_NORMAL
- en: You can check out what this will look like when the game runs. Add a `Camera3D`
    feature to the scene and move it to a position where it can look down on the course.
    Remember, you can press **Preview** to check what the camera sees.
  prefs: []
  type: TYPE_NORMAL
- en: Play the scene. You’ll notice that everything is very dark, unlike how it looks
    in the editor window. By default, a 3D scene has no *environment* or *lighting*
    configured.
  prefs: []
  type: TYPE_NORMAL
- en: Environment and lighting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lighting is a complex subject all on its own. Choosing where to place lights
    and how they’re configured can dramatically affect how a scene looks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Godot provides three lighting nodes in 3D:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OmniLight3D`: For light that is emitted in all directions, such as from a
    light bulb'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DirectionalLight3D`: Light from a distant source, such as sunlight'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SpotLight3D`: A cone-shaped light projected from a point, similar to a flashlight
    or lantern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to placing individual lights, you can also set up *ambient* light
    – light that is produced by the environment – using a `WorldEnvironment` node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than start from scratch, Godot will let you start with the default lighting
    setup that you see in the editor window using the buttons in the toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15: Lighting and environment settings](img/B19289_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.15: Lighting and environment settings'
  prefs: []
  type: TYPE_NORMAL
- en: The first two buttons allow you to toggle the preview sun (directional light)
    and environment. Note that the environment doesn’t just affect lighting, it generates
    a sky texture as well.
  prefs: []
  type: TYPE_NORMAL
- en: If you click on the three dots, you can see the default settings for these.
    Click the `WorldEnvironment` node and a `DirectionalLight3D` node in your scene.
  prefs: []
  type: TYPE_NORMAL
- en: If you zoom in on your mesh, you may notice that the shadows don’t look very
    good. The default shadow settings need to be adjusted, so select `DirectionalLight3D`
    and change `100` to `40`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the hole
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have the course laid out, you need a way to detect when the ball
    falls into the hole.
  prefs: []
  type: TYPE_NORMAL
- en: Add an `Area3D` node named `Hole`. This node works exactly like its 2D version
    – it can signal when a body enters its defined shape. Add a `CollisionShape3D`
    child to the area. In the `0.25` and `0.08`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Position `Hole` where you placed the hole tile for your course. Make sure the
    cylinder shape doesn’t project above the top of the hole, or the ball will count
    as “in” when it hasn’t dropped in yet. You might find it useful to use the **Perspective**
    button and change to **Top View** to make sure you’ve got it centered properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16: Positioning the hole](img/B19289_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.16: Positioning the hole'
  prefs: []
  type: TYPE_NORMAL
- en: You also need to mark the starting position for the ball, so add a `Marker3D`
    node named `Tee` to the scene. Position it where you want the ball to start. Make
    sure you place it above the surface so that the ball doesn’t spawn inside the
    ground.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you’re finished making the first course. Take a few minutes to look
    around and make sure you’re happy with the layout. Remember, this shouldn’t be
    a complex or challenging layout. It’s going to introduce the player to the game,
    and you’ll be using it to test that everything is working correctly later. To
    do that, you next need to create the golf ball.
  prefs: []
  type: TYPE_NORMAL
- en: Making the ball
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the ball needs physics – gravity, friction, collision with walls, and
    so on – `RigidBody3D` will be the best choice of node. Rigid bodies work similarly
    in 3D to the ones you’ve used before in 2D, and you’ll use the same methods to
    interact with them, such as `_integrate_forces()` and `apply_impulse()`.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene with a `RigidBody3D` node named `Ball` and save it.
  prefs: []
  type: TYPE_NORMAL
- en: Since you need a simple sphere shape and Godot includes primitive shapes, there’s
    no need for a fancy 3D model here. Add a `MeshInstance3D` child and choose **New
    SphereMesh** for the **Mesh** property in the Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: The default size is much too large, so click on the `0.05` and `0.1`.
  prefs: []
  type: TYPE_NORMAL
- en: Add a `CollisionShape3D` node and give it a `SphereShape3D`. Set its `0.05`
    to match the mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the ball
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add an instance of the `Ball` scene to your course. Position it over one of
    the tiles and play the scene. You should see the ball fall and land on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: You can also temporarily give the ball some motion by setting the `y`axis is
    up. Don’t forget to set it back to `(0, 0, 0)` before you move on.
  prefs: []
  type: TYPE_NORMAL
- en: Improving ball collisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed when adjusting the velocity that the ball sometimes goes
    through the wall and/or bounces oddly, especially if you choose a high-velocity
    value. There are several things you can do to improve the ball’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you can use **continuous collision detection** (**CCD**). Using CCD
    alters the way the physics engine calculates collisions. Normally, the engine
    operates by first moving the object and then testing for and resolving collisions.
    This is fast and works for most common situations. When using CCD, the engine
    projects the object’s movement along its path and attempts to predict where the
    collision may occur. This is slower (computationally) than the default behavior,
    especially when simulating many objects, but it is much more accurate. Since you
    only have one ball in a very small environment, CCD is a good option because it
    won’t introduce any noticeable performance penalty. You can find it in the Inspector
    as **Continuous CD**:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.17: The \uFEFFCCD toggle](img/B19289_05_17.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.17: The CCD toggle'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ball also needs a little more action, so in the `0.25`. This property determines
    how “bouncy” a collision will be. The value can range from `0` (no bounce at all)
    to `1.0` (the bounciest):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18: Physics material bounce settings](img/B19289_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.18: Physics material bounce settings'
  prefs: []
  type: TYPE_NORMAL
- en: You may also have noticed that the ball takes a long time to come to a complete
    stop. Set the `0.5` and `1`. These values can be thought of as analogous to air
    resistance – causing the object to slow down regardless of interaction with the
    surface. Increasing these means the player won’t have to wait as long for the
    ball to stop moving, and it won’t appear to be spinning in place after it stops
    rolling.
  prefs: []
  type: TYPE_NORMAL
- en: You’re finished setting up the ball, but here’s another good place to pause
    and make sure you have everything the way you want it before moving on. Does the
    ball feel like it’s bouncing and rolling convincingly? When it hits a wall, does
    it bounce too much or too little? When you’ve adjusted the ball’s behavior to
    your satisfaction, move on to the next section, where you’ll set up how to launch
    the ball.
  prefs: []
  type: TYPE_NORMAL
- en: Adding UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the ball is on the course, you need a way to aim and hit it. There
    are many possible control schemes for this type of game. For this project, you’ll
    use a two-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Aim**: An arrow appears, swinging back and forth. Clicking the mouse button
    sets the aim direction.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Shoot**: A power bar moves up and down. Clicking the mouse sets the power
    and launches the ball.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Aiming the arrow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Drawing an object in 3D is not as easy as it is in 2D. In many cases, you’ll
    have to switch to a 3D modeling program such as Blender to create your game’s
    objects. However, in this case, Godot’s primitives will do fine. To make an arrow,
    you need two meshes: a long thin rectangle and a triangular prism.'
  prefs: []
  type: TYPE_NORMAL
- en: Making your own model
  prefs: []
  type: TYPE_NORMAL
- en: If you’re comfortable using a separate 3D modeling program such as *Blender*,
    feel free to use that to create the arrow mesh instead of following the following
    procedure. Just drop the exported model into your Godot project folder and load
    it with a `MeshInstance3D` node. See the last chapter for details about importing
    models directly from Blender.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new scene by adding a `Node3D` node called `Arrow` and give it a `MeshInstance3D`
    child. Give this mesh a `BoxMesh` function and set the box’s `(0.5, 0.2, 2)`.
    This will be the body of the arrow, but before moving on, there is a problem.
    If you rotate the parent node, the mesh rotates around its center. You need it
    to rotate around its end, so change the `MeshInstance3D` node to `(0, 0, -1)`.
    Remember, this property is measured relative to the node’s parent, so this is
    offsetting the mesh from the `Node3D` node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19: Offsetting the base](img/B19289_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.19: Offsetting the base'
  prefs: []
  type: TYPE_NORMAL
- en: Try rotating the root node (`Arrow`) with the gizmo to confirm that the shape
    is now offset correctly.
  prefs: []
  type: TYPE_NORMAL
- en: When it’s viewed in the game, the arrow should be semi-transparent. You can
    also give it a color to make it stand out more. To change a mesh’s visual properties,
    you need to use **Material**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the mesh properties (where you set the size), you’ll see a `StandardMaterial3D`
    node in this box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20: Offsetting the base](img/B19289_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.20: Offsetting the base'
  prefs: []
  type: TYPE_NORMAL
- en: If you click this new material object to expand it, you’ll see a long list of
    new properties. Don’t worry, there are only two that you need to change.
  prefs: []
  type: TYPE_NORMAL
- en: First, expand the **Transparency** section and set **Transparency** to **Alpha**.
    This property tells the rendering engine that this object can allow light to pass
    through it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the color of an object is set in the `128`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to create the pointy end of the arrow, add another `MeshInstance3D` node,
    and this time, choose a `PrismMesh` mesh. Set its `(1.5, 1.5, 0.2)` so that you
    have a flat triangular shape. To place it at the end of the rectangle, change
    its `0, 0, -2.75)` and its `(-90,` `0, 0)`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, scale the whole arrow down by setting the root node’s `0.25,` `0.25,
    0.25)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need to set the prism’s material just as you did with the other section.
    To do this quickly, select the box shape and find its material property again.
    In the dropdown for the material, choose **Copy**. You can then go to the prism
    mesh and paste the same material onto it. Note that since they have the same material,
    any change you make to one shape will apply to both shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21: Positioning the arrow](img/B19289_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.21: Positioning the arrow'
  prefs: []
  type: TYPE_NORMAL
- en: Your aiming arrow is complete. Save the scene and instance it into your `Hole`
    scene.
  prefs: []
  type: TYPE_NORMAL
- en: UI display
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new scene using a `CanvasLayer` layer named `UI`. In this scene, you’ll
    show the power bar as well as the shot count for the player’s score. Just as it
    did in 2D, this node will cause its contents to be drawn above the main scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `Label` node, then a `MarginContainer` node. In that, add a `VboxContainer`
    node, and in that, two `Label` nodes and a `TextureProgressBar` node. Name them
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22: The UI node layout](img/B19289_05_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.22: The UI node layout'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MarginContainer` section, set `20`. Add the `Xolonium-Regular.ttf` font
    to both of the `Label` nodes and set their font sizes to `30`. Set the `Shots`
    to `PowerLabel` to **Power**.
  prefs: []
  type: TYPE_NORMAL
- en: Add the font for the `Message` label, using a larger font size of `80`, and
    set its text to `Get Ready!`. Choose **Center** from the **Anchor Presets** menu,
    then click the eye symbol next to the message to hide it.
  prefs: []
  type: TYPE_NORMAL
- en: Drag one of the colored bar textures from `res://assets` into the `PowerBar`.
    By default, `TextureProgressBar` grows from left to right, so for a vertical orientation,
    change **Fill Mode** to **Bottom to Top**. Change **Value** to a few different
    values to see the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The completed UI layout should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23: The UI preview](img/B19289_05_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.23: The UI preview'
  prefs: []
  type: TYPE_NORMAL
- en: Add an instance of `UI` in the `Hole` scene. Because it’s `CanvasLayer`, it
    will be drawn on top of the 3D camera view.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve finished drawing the course and you’ve added the UI, you have
    all of the visual elements that the player will see while playing. Your next task
    will be to make these parts work together by adding some code.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you’ll create the scripts needed to make everything work together.
    The flow of the game will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the ball at the `Tee`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to **Aim** mode and animate the arrow until the player clicks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to **Power** mode and animate the power bar until the player clicks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch the ball.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the process from *step 2* until the ball falls into the hole.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: UI code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add this script to the `UI` instance to update the UI elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These functions provide a way to update the UI elements when they need to display
    a new value. As you did in *Space Rocks*, changing the progress bar’s texture
    based on its value gives a nice low/medium/high feel to the power level.
  prefs: []
  type: TYPE_NORMAL
- en: Main script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a script to the `Hole` scene and start with these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `enum` lists the states the game can be in, while the `power` and `angle`
    variables will be used to set their respective values and change them over time.
    You can control the animation speed (and therefore the difficulty) by adjusting
    the two exported variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, set the initial values before starting to play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The ball gets moved to the tee position, and you change to the `AIM` state to
    begin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what needs to happen for each game state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`AIM` places the aiming arrow at the ball’s position and makes it visible.
    Recall that you offset the arrow, so it will appear to be pointing out from the
    ball. When you rotate the arrow, you’ll rotate it around the `y` axis so that
    it remains parallel to the ground.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that when entering the `SHOOT` state, you call the `shoot()` function
    on the ball, which you haven’t defined yet. You’ll add that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to check for user input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The only input for the game (so far) is clicking the left mouse button. Depending
    on what state you’re currently in, clicking it will transition to the next state.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `_process()`, you’ll determine what to animate based on the state. For now,
    it just calls the function that animates the appropriate property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these functions are similar. They gradually change a value between
    two extremes, reversing direction when the limit is reached. Note that the arrow
    is animating over a 180° range (+90° to -90°):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To detect when the ball drops into the hole, select the `Area3D` node that
    you positioned at the hole and connect its `body_entered` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, the player will need to be able to start the whole process again after
    the ball comes to a stop.
  prefs: []
  type: TYPE_NORMAL
- en: Ball script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the ball’s script, there are two functions needed. First, an *impulse* must
    be applied to the ball to start it moving. Second, when the ball stops moving,
    it needs to notify the main scene so that the player can take the next shot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you add this script to the `Ball` scene, not the instance of the
    ball in the `Hole` scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you saw in the *Space Rocks* game, you can use the physics state in `_integrate_forces()`
    to safely stop the ball if the speed has gotten very low. Due to floating point
    issues, the velocity may not slow to `0` on its own. Its `linear_velocity` value
    may be something like `0.00000001` for quite some time after it appears to stop.
    Rather than wait, you can just stop the ball if the speed falls below `0.1`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s also the chance that the ball happens to bounce over the wall and fall
    off the course. If this happens, you can reload the scene to let the player start
    over.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the `Hole` scene and connect the `Ball` instance’s `stopped` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Testing it out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try playing the scene. You should see the arrow rotating at the ball’s position.
    When you click the mouse button, the arrow stops, and the power bar starts moving
    up and down. When you click again, the ball is launched.
  prefs: []
  type: TYPE_NORMAL
- en: If any of those steps don’t work, don’t go any further. Go back and try to find
    what you missed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Once everything is working, you’ll notice some areas that need improvement.
    First, when the ball stops moving, the arrow may not point in the direction you
    want. The reason for this is that the starting angle is always `0`, which points
    along the `z`axis, and then the arrow swings +/-90° from there. In the next two
    sections, you’ll have a choice of two options for how to improve the aiming.
  prefs: []
  type: TYPE_NORMAL
- en: Option 1 for improving aiming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Aiming can be improved by pointing the 180° arc directly toward the hole at
    the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a variable called `hole_dir` to the top of the script. You can find this
    direction by using some vector math:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the ball’s position is its center, so it’s slightly above the
    surface, while the hole’s center is a bit below it. Because of this, a vector
    pointing from the ball to the hole would also point at a downward angle into the
    ground. To prevent this and keep the arrow level, you can use only the `x` and
    `z` values from the `position` to produce `Vector2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the initial angle can be set when starting the `AIM` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And the animation of the arrow can use that initial direction as the basis
    for the +/-90° swing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Try playing again. The arrow should now always point in the general direction
    of the hole. This is better, but you still may have a difficult time aiming.
  prefs: []
  type: TYPE_NORMAL
- en: Option 2 for improving aiming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’d prefer to have more control over your aiming, then instead of animating
    the arrow and clicking to set the aim, you could directly control the arrow by
    moving the mouse side-to-side.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, you can make use of one of Godot’s `InputEvent` types:
    `InputEventMouseMotion`. This event occurs whenever the mouse moves, and it includes
    a `relative` property representing how far the mouse moved in the previous frame.
    You can use this value to rotate that arrow by a small amount.'
  prefs: []
  type: TYPE_NORMAL
- en: First, disable the arrow animation by removing the `AIM` section from `_process()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a variable so that you can control how much the arrow will rotate based
    on the mouse movement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, write the following code to `_input()` to check for mouse movement and
    rotate the arrow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Capturing the mouse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that as you’re moving the mouse, it can leave the game
    window, and when you click, you don’t interact with the game anymore. Most 3D
    games solve this problem by *capturing* the mouse – locking the mouse to the window.
    When you do this, you also need to give the player a way to free the mouse so
    that they can close the program or click on other windows, and a way to re-capture
    it to come back to the game.
  prefs: []
  type: TYPE_NORMAL
- en: For this game, you’ll capture the mouse at first, and then if the player presses
    *Esc*, free it and pause the game. Clicking in the game window will un-pause and
    resume.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this functionality is controlled through the `Input.mouse_mode` property.
    Then, `mouse_mode` can be set to one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MOUSE_MODE_VISIBLE`: This is the default mode. The mouse is visible and free
    to move in and out of the window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MOUSE_MODE_HIDDEN`: The mouse cursor is hidden.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MOUSE_MODE_CAPTURED`: The mouse is hidden and its position is locked to the
    window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MOUSE_MODE_CONFINED`: The mouse is visible, but confined to the window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start by capturing the mouse in `_ready()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In `_process()`, you don’t want to animate things while the mouse is released:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To release the mouse, add this condition to `_input()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to re-capture the mouse when the window is clicked, add this right before
    `match_state`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Play the scene to try it out.
  prefs: []
  type: TYPE_NORMAL
- en: Camera improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another problem, especially if you have laid out a relatively large course,
    is that if you place your camera near the tee, it won’t show the other parts of
    the course well, or at all. You need your camera to move, showing other parts
    of the course so the player can aim comfortably.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main ways you could address this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple cameras: place several cameras at different locations around the course.
    Attach `Area3D` nodes to them, and when the ball enters a camera’s area, make
    that camera active by setting its `current` property to `true`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Moving camera: stick to having one camera, but make it move along with the
    ball, so the player’s perspective is always based on the ball’s location.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both of these schemes have pros and cons. Option 1 requires more planning, deciding
    exactly where to position the cameras, and how many to use. For that reason, this
    section will focus on option 2.
  prefs: []
  type: TYPE_NORMAL
- en: In many 3D games, the player can control a camera that rotates and moves. Typically,
    this control scheme uses a combination of mouse and keyboard. Since you’re already
    using mouse movement for aiming (if you chose that option), the *W*/*A*/*S*/*D*
    keys are a good choice. The mouse wheel can be used to control the camera’s zoom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these new actions in the **Input** **Map** property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24: Input map](img/B19289_05_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.24: Input map'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a gimbal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The camera movement needs to have some restrictions. For one, it should always
    remain level and not become tilted side to side. Try this: take a camera and rotate
    it a small amount around `y` (the gizmo’s green ring), then a small amount around
    `x` (the red ring). Now, reverse the `y` rotation and click the **Preview** button.
    See how the camera has become tilted?'
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this problem is to place the camera on a `Node3D` nodes, which
    will control the camera’s left/right and up/down movement respectively.
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure to remove any other `Camera3D` nodes in the scene, so that
    you don’t have any conflict over which camera is being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new scene and add two `Node3D` nodes and a `Camera3D` node, naming
    them as shown in *Figure 5**.25*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25: Camera gimbal node setup](img/B19289_05_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.25: Camera gimbal node setup'
  prefs: []
  type: TYPE_NORMAL
- en: Set the `Camera3D` to `(0, 0, 10)` so that it’s offset and looking toward the
    origin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how the gimbal works: the outer node is allowed to rotate *only* in
    `y`, while the inner one rotates *only* in `x`. You can try it yourself, but make
    sure to turn on **Use Local Space** (see the *Introduction to 3D space* section).
    Remember to only move the *green* ring of the outer gimbal node, and only the
    *red* ring of the inner one. Don’t change the camera at all. Reset all rotations
    back to zero once you’ve finished experimenting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To control this motion in the game, attach a script to the root node and add
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the right/left actions rotate the root `Node3D` node around
    its `y`axis, while the up/down actions rotate `GimbalInner` on its `x`axis. The
    entire gimbal system’s `scale` property is used to handle zooming. Finally, the
    rotation and zoom are limited by using `clamp()`, preventing the user from flipping
    the camera upside down or zooming too close or far away.
  prefs: []
  type: TYPE_NORMAL
- en: Add an instance of `CameraGimbal` to the `Hole` scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to make the camera follow the ball. You can do this in `_process()`
    by setting the camera’s position to the ball’s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Play the scene and test that you can rotate and zoom the camera and that it
    moves when the ball when you make a shot.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a full course
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the ball falls into the hole, the player should advance to play the next
    hole. Add this variable at the top of `hole.gd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This will let you set the next hole that will be loaded. In the Inspector, select
    the **Next Hole** property to choose what scene to load next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the loading code in the `WIN` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Your `Hole` scene is intended to be the generic scaffold for building multiple
    holes the player can play through. Now that you have it working, you can use it
    to make multiple scenes using **Scene** -> **New** **Inherited Scene**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this technique, you can make as many holes as you want and chain them
    together into the full golf course. Here’s the second hole in the example project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.26: Example course layout](img/B19289_05_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.26: Example course layout'
  prefs: []
  type: TYPE_NORMAL
- en: Visual effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The appearance of the ball and the other meshes in your scene have been intentionally
    left very plain. You can think of the flat, white ball as a blank canvas, ready
    to be painted. First, a bit of vocabulary:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Textures**: Textures are flat, 2D images that are *wrapped* around 3D objects.
    Imagine wrapping a gift: the flat paper is folded around the package, conforming
    to its shape. Textures can be simple or complex, depending on the shape they’re
    designed to be applied to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StandardMaterial3D`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Materials**: Godot uses a graphics rendering model called **Physically Based
    Rendering** (**PBR**). The goal of PBR is to render graphics in a way that accurately
    models the way light works in the real world. These effects are applied to meshes
    using their material property. Materials are essentially containers for textures
    and shaders. The material’s properties determine how the texture and shader effects
    are applied. Using Godot’s built-in material properties, you can simulate a wide
    range of physical materials, such as stone, cloth, or metal. If the built-in properties
    aren’t enough for your purposes, you can write your own shader code to add even
    more effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding materials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `Ball` scene, select `MeshInstance` and in its `StandardMaterial3D` node.
  prefs: []
  type: TYPE_NORMAL
- en: Expand the material and you’ll see a large number of properties, far more than
    can be covered here. This section will focus on some of the most useful ones for
    making the ball look more appealing. You are encouraged to visit [https://docs.godotengine.org/en/latest/tutorials/3d/standard_material_3d.html](https://docs.godotengine.org/en/latest/tutorials/3d/standard_material_3d.html)
    for a full explanation of all the settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, try experimenting with these parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Albedo**: This property sets the base color of the material. Change this
    to make the ball whatever color you’d like. If you’re working with an object that
    needs a texture, this is where you’d add it as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` and `1`. The **Metallic** value controls *shininess*. Higher values will
    reflect more light, as with metallic substances. The **Roughness** value applies
    an amount of blur to the reflection. Lower values are more reflective, such as
    the polished surface of a mirror. You can simulate a wide variety of materials
    by adjusting these two properties. *Figure 5**.27* is a guide to how the **Roughness**
    and **Metallic** properties affect the appearance of an object. Keep in mind that
    lighting and other factors will alter the appearance as well. Understanding how
    light and reflections interact with surface properties is a big part of designing
    effective 3D objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.27: Metallic and Roughness values](img/B19289_05_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.27: Metallic and Roughness values'
  prefs: []
  type: TYPE_NORMAL
- en: '**Normal Map**: Normal mapping is a 3D graphics technique for simulating the
    appearance of bumps and dents on a surface. Modeling these in the mesh itself
    would result in a large increase in the number of polygons, or faces, making up
    the object, leading to reduced performance. Instead, a 2D texture is used that
    maps the pattern of light and shadow that would result from these small surface
    features. The lighting engine then uses that information to alter the reflection
    as if those details were actually there. A properly constructed normal map can
    add a great amount of detail to an otherwise bland-looking object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ball is a perfect example of a good use case for normal mapping because
    a real golf ball has hundreds of dimples on its surface, but the sphere primitive
    you’re using is a smooth surface. Using a regular texture could add spots, but
    they would look flat as if they were painted on the surface. A normal map to simulate
    those dimples would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.28: A normal map](img/B19289_05_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.28: A normal map'
  prefs: []
  type: TYPE_NORMAL
- en: The pattern of red and blue contains information telling the engine which direction
    it should assume the surface is facing at that point, and therefore which direction
    the light should bounce in that position. Note the stretching along the top and
    bottom – that’s because this image is made to be wrapped around a sphere shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable the `res://assets/ball_normal_map.png` into the `-0.5` and `-1.0` works
    best:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.29: A ball with a normal map](img/B19289_05_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.29: A ball with a normal map'
  prefs: []
  type: TYPE_NORMAL
- en: Take some time to experiment with these settings and find a combination you
    like. Don’t forget to try playing the scene as well, as the ambient lighting of
    the `WorldEnvironment` feature will affect the final result.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you’ll learn how to adjust the `WorldEnvironment` settings
    to change the look of the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Lighting and Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve been using the default lighting setup, which you added to your scene
    back in the first section. While you may be happy with this lighting setup, you
    can also adjust it to dramatically change the appearance of your game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WorldEnvironment` node contains an `Environment` property that controls
    the background, sky, ambient light, and other aspects of the scene’s appearance.
    Select the node and click the property to expand it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.30: Environment properties](img/B19289_05_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.30: Environment properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of settings here, some of which are only really useful in specific
    advanced situations. However, these are the ones you’ll find yourself using the
    most often:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sky` material. Sky materials can either be special textures that wrap around
    the scene (see the next game for an example) or one that’s automatically generated
    by the engine. The default sky that you’re using now is the latter: `ProceduralSkyMaterial`.
    Expand it to take a look at the properties – you can configure the sky’s colors
    and the sun’s appearance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ambient Light**: This is global light that affects all meshes with the same
    intensity. You can set its color and how much of it is generated by the sky. To
    see the effect, try setting the color to white and reducing the **Sky Contribution**
    a bit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Screen Space Reflection** (**SSR**), **Screen Space Ambient Occlusion** (**SSAO**),
    **Screen Space Indirect Lighting** (**SSIL**), and **Signed Distance Field Global**
    **Illumination** (**SDFGI**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These options provide more advanced control over how lighting and shadows are
    processed. An entire book could be written about the art of good lighting, but
    for the purposes of this section, you should know that each of these features
    introduces a tradeoff between realistic rendering and performance. Most advanced
    lighting features are not available at all for low-end devices, such as mobile
    or older PC hardware. If you’d like to learn more, the Godot documentation has
    an extensive introduction to the usage of these lighting features.
  prefs: []
  type: TYPE_NORMAL
- en: The **Glow** lighting feature simulates the filmic effect of light that “bleeds”
    into its surroundings, making objects appear to be emitting light. Note that this
    is different from the **Emission** property of materials, which causes objects
    to actually emit light. Glow is enabled by default, but at a very subtle setting
    that may not be apparent in bright lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to experiment with the various environment settings. If you get completely
    lost and want to return to the default, delete the `WorldEnvironment` node, and
    you’ll be able to add the default version back again from the menu.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to 3D development. One of Godot’s great strengths
    is that the same tools and workflow are used in both 2D and 3D. Everything you
    learned about the process of creating scenes, instancing, and using signals works
    in the same way. For example, an interface you build with control nodes for a
    2D game can be dropped into a 3D game and will work just the same.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how to navigate the 3D editor to view and place
    nodes using gizmos. You learned about meshes and how to quickly make your own
    objects using Godot’s primitives. You used `GridMap` to lay out your minigolf
    course. You learned about using cameras, lighting, and the world environment to
    design how your game will appear on the screen. Finally, you got a taste of using
    PBR rendering via Godot’s `SpatialMaterial` resource.
  prefs: []
  type: TYPE_NORMAL
- en: In the next project, you’ll continue working in 3D and extend your understanding
    of transforms and meshes.
  prefs: []
  type: TYPE_NORMAL
