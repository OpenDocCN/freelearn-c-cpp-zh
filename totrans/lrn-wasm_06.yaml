- en: Interacting with JavaScript and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与JavaScript交互和调试
- en: There's a great deal of exciting features and proposals in the works for WebAssembly.
    However, at the time of writing this book, the feature set is rather limited.
    As it stands, you can benefit greatly from using some of the features Emscripten
    provides. The process for interacting with C/C++ from JavaScript (and vice versa)
    will differ depending on whether you decide to use Emscripten.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly有许多令人兴奋的功能和提案正在开发中。然而，在撰写本书时，功能集相当有限。目前，你可以从使用Emscripten提供的一些功能中受益良多。从JavaScript（反之亦然）与C/C++交互的过程将取决于你是否决定使用Emscripten。
- en: In this chapter, we will cover how to utilize JavaScript functions with C/C++
    code as well as how to interact with the compiled output of your C/C++ code from
    JavaScript. We'll also describe how Emscripten's *glue* code affects the ways
    a Wasm instance is utilized and how to debug compiled code in the browser.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何使用JavaScript函数与C/C++代码结合，以及如何从JavaScript代码中调用编译后的C/C++函数。我们还将描述Emscripten的*glue*代码如何影响Wasm实例的使用方式，以及如何在浏览器中调试编译代码。
- en: 'Our goal for this chapter is to understand the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章的目标是理解以下内容：
- en: The differences between Emscripten's `Module` and the browser's `WebAssembly`
    object
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Emscripten的`Module`对象与浏览器`WebAssembly`对象的区别
- en: How to call compiled C/C++ functions from your JavaScript code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从你的JavaScript代码中调用编译的C/C++函数
- en: How to call JavaScript functions from your C/C++ code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从你的C/C++代码中调用JavaScript函数
- en: Special considerations to be aware of when working with C++
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用C++时需要注意的特殊考虑事项
- en: Techniques for debugging compiled output in the browser
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中调试编译输出的技术
- en: The Emscripten module versus the WebAssembly object
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Emscripten模块与WebAssembly对象的比较
- en: In the previous chapter, we briefly covered Emscripten's `Module` object and
    how to load it in the browser. The `Module` object provides several convenient
    methods and differs significantly from the browser's `WebAssembly` object. In
    this section, we're going to review Emscripten's `Module` object in greater detail.
    We'll also discuss the difference between Emscripten's `Module` and the objects
    described in WebAssembly's *JavaScript API*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了Emscripten的`Module`对象以及如何在浏览器中加载它。`Module`对象提供了几个方便的方法，并且与浏览器的`WebAssembly`对象有显著的区别。在本节中，我们将更详细地回顾Emscripten的`Module`对象。我们还将讨论Emscripten的`Module`与WebAssembly的*JavaScript
    API*中描述的对象之间的区别。
- en: What is the Emscripten module?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Emscripten模块是什么？
- en: 'Emscripten''s official site provides the following definition for the `Module`
    object:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten的官方网站为`Module`对象提供了以下定义：
- en: '"Module is a global JavaScript object with attributes that Emscripten-generated
    code calls at various points in its execution."'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: “Module是一个全局JavaScript对象，Emscripten生成的代码在其执行过程中的不同点会调用其属性。”
- en: Not only is the loading procedure different from WebAssembly's `compile` and
    `instantiate` functions, but the `Module` provides some helpful functionality
    out of the box that would otherwise require a custom implementation in WebAssembly.
    The `Module` is available in a global scope (`window.Module`) after fetching and
    loading Emscripten's JavaScript *glue* code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅加载过程与WebAssembly的`compile`和`instantiate`函数不同，`Module`还提供了一些开箱即用的有用功能，否则在WebAssembly中可能需要自定义实现。在获取和加载Emscripten的JavaScript
    *glue*代码后，`Module`在全局作用域（`window.Module`）中可用。
- en: Default methods in the glue code
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Glue代码中的默认方法
- en: Emscripten's `Module` object provides some default methods and properties to
    aid in debugging and ensuring the successful execution of your compiled code.
    You can utilize the `preRun` and `postRun` properties to execute JavaScript code
    before or after the Module's `run()` function is called, or pipe the output of
    the `print()` and `printErr()` functions to an HTML element on the page. We'll
    utilize some of these methods later in this book. You can read more about them
    at [https://kripken.github.io/emscripten-site/docs/api_reference/module.html](https://kripken.github.io/emscripten-site/docs/api_reference/module.html).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten的`Module`对象提供了一些默认的方法和属性，以帮助调试并确保编译后的代码成功执行。你可以利用`preRun`和`postRun`属性在调用Module的`run()`函数之前或之后执行JavaScript代码，或者将`print()`和`printErr()`函数的输出管道连接到页面上的HTML元素。我们将在本书的后面部分使用其中的一些方法。你可以在[https://kripken.github.io/emscripten-site/docs/api_reference/module.html](https://kripken.github.io/emscripten-site/docs/api_reference/module.html)了解更多信息。
- en: Differences with the WebAssembly object
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与WebAssembly对象的区别
- en: We covered the browser's WebAssembly object and the corresponding loading procedures
    in [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating and Loading
    a WebAssembly Module*. WebAssembly's JavaScript and Web APIs define the objects
    and methods available in the browser's `window.WebAssembly` object. Emscripten's
    `Module` can be seen as a combination of WebAssembly's `Module` and `Instance`
    objects, which are present in the `result` object that WebAssembly's instantiation
    function returns. By passing the `-s MODULARIZE=1` flag to the `emcc` command,
    we're able to replicate WebAssembly's instantiation method (to a degree). We will
    examine the differences between Emscripten's `Module` and the browser's `WebAssembly`
    object in greater detail as we evaluate the methods of integrating JavaScript
    and C/C++ in the upcoming sections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第5章](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml)中介绍了浏览器中的WebAssembly对象及其相应的加载过程，即*创建和加载WebAssembly模块*。WebAssembly的JavaScript和Web
    API定义了浏览器`window.WebAssembly`对象中可用的对象和方法。Emscripten的`Module`可以看作是WebAssembly的`Module`和`Instance`对象的组合，这些对象存在于WebAssembly实例化函数返回的`result`对象中。通过将`-s
    MODULARIZE=1`标志传递给`emcc`命令，我们能够复制WebAssembly的实例化方法（在一定程度上）。在接下来的章节中，我们将更详细地比较Emscripten的`Module`和浏览器的`WebAssembly`对象之间的差异，并评估集成JavaScript和C/C++的方法。
- en: Calling compiled C/C++ functions from JavaScript
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从JavaScript调用编译后的C/C++函数
- en: Calling functions from a Wasm instance is a relatively straightforward process
    with or without Emscripten's glue code. Utilizing Emscripten's API affords a wider
    range of functionality and integration at the expense of including the glue code
    alongside the `.wasm` file. In this section, we will review the means of interacting
    with the compiled Wasm instance through JavaScript and the added tooling Emscripten
    provides.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是否使用Emscripten的粘合代码，从Wasm实例调用函数都是一个相对直接的过程。利用Emscripten的API可以提供更广泛的功能和集成，但代价是需要在`.wasm`文件中包含粘合代码。在本节中，我们将回顾通过JavaScript与编译后的Wasm实例交互的方法以及Emscripten提供的附加工具。
- en: Calling functions from a Module
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从模块中调用函数
- en: 'Emscripten provides two functions for calling compiled C/C++ functions from
    JavaScript: `ccall()` and `cwrap()`. Both of these functions are present in the
    `Module` object. Deciding which one to use is contingent on whether the function
    will be called more than once. The content in the following sections was taken
    from Emscripten''s API reference documentation for `preamble.js`, which can be
    viewed at [http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html](http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten提供了两个从JavaScript调用编译后的C/C++函数的函数：`ccall()`和`cwrap()`。这两个函数都存在于`Module`对象中。决定使用哪一个取决于该函数是否会被多次调用。以下章节的内容摘自Emscripten的API参考文档中的`preamble.js`，可以在[http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html](http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html)查看。
- en: You don't need to prefix function calls with `_` when using `ccall()` or `cwrap()` – just
    use the name specified in the C/C++ file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`ccall()`或`cwrap()`时，不需要在函数调用前加`_`前缀——只需使用C/C++文件中指定的名称即可。
- en: Module.ccall()
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Module.ccall()`'
- en: '`Module.ccall()` calls a compiled C function from JavaScript and returns the
    result of that function. The function signature for `Module.ccall()` is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Module.ccall()`从JavaScript调用编译后的C函数并返回该函数的结果。`Module.ccall()`的函数签名如下：'
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You must specify a type name for the `returnType` and `argTypes` parameters.
    The possible types are `"number"`, `"string"`, `"array"`, and `"boolean"`, which
    correspond to the appropriate JavaScript types. You cannot specify `"array"` for
    the `returnType` parameter because there is no way to know the length of the array.
    If the function doesn't return anything, you can specify `null` for the `returnType`
    (note the absence of quotation marks).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须为`returnType`和`argTypes`参数指定一个类型名称。可能的类型有`"number"`、`"string"`、`"array"`和`"boolean"`，它们对应于适当的JavaScript类型。您不能为`returnType`参数指定`"array"`，因为没有方法知道数组的长度。如果函数不返回任何内容，您可以为`returnType`指定`null`（注意引号的存在）。
- en: The `opts` parameter is an optional options object that can contain a Boolean
    property named `async`. Specifying a value of `true` for this property implies
    that the call will perform an async operation. We won't use this parameter for
    any of our examples, but if you wish to learn more about it, the documentation
    is available at [http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html#calling-compiled-c-functions-from-javascript](http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html#calling-compiled-c-functions-from-javascript).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`opts` 参数是一个可选的选项对象，它可以包含一个名为 `async` 的布尔属性。为这个属性指定 `true` 值意味着调用将执行异步操作。我们不会在我们的任何示例中使用此参数，但如果你希望了解更多信息，文档可在
    [http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html#calling-compiled-c-functions-from-javascript](http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html#calling-compiled-c-functions-from-javascript)
    查找。'
- en: 'Let''s look at an example of `ccall()`. The following code, taken from the
    Emscripten site, demonstrates how to call a function named `c_add()` from the
    compiled output of a C file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个 `ccall()` 的示例。以下代码摘自 Emscripten 网站，展示了如何从 C 文件的编译输出中调用名为 `c_add()` 的函数：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Module.cwrap()
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Module.cwrap()`'
- en: '`Module.cwrap()` is similar to `ccall()` in that it calls a compiled C function.
    However, rather than returning a value, it returns a JavaScript function that
    can be reused as many times as needed. The function signature for `Module.cwrap()` is
    as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Module.cwrap()` 与 `ccall()` 类似，它调用编译后的 C 函数。然而，它不是返回一个值，而是返回一个可以重复使用的 JavaScript
    函数。`Module.cwrap()` 的函数签名如下：'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Just as with `ccall()`, you can specify string values that represent types for
    the `returnType` and `argTypes` parameters. You cannot use the `"array"` type
    in `argTypes` because there is no way to know the length of the array when the
    function is called. For a function that doesn't return a value, use `null` (with
    no quotation marks) for the `returnType` parameter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 `ccall()` 一样，你可以指定代表 `returnType` 和 `argTypes` 参数类型的字符串值。你无法在 `argTypes`
    中使用 `"array"` 类型，因为在函数被调用时无法知道数组的长度。对于不返回值的函数，使用 `null`（不带引号）作为 `returnType` 参数。
- en: 'The following code, taken from the Emscripten site, demonstrates the use of
    `cwrap()` to create a reusable function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码摘自 Emscripten 网站，展示了如何使用 `cwrap()` 创建一个可重用的函数：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: C++ and name mangling
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 和名称修饰
- en: 'You may have noticed that the descriptions of `ccall()` and `cwrap()` specified
    that both are used to call a compiled C function. The omission of C++ was intentional
    because an additional step is needed to call functions from a C++ file. C++ supports
    function overloading, which means that you can use the same function name multiple
    times, but pass different arguments to each one to get a different result. Here''s
    an example of some code that uses function overloading:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`ccall()` 和 `cwrap()` 的描述中都说明了这两个都是用来调用编译后的 C 函数的。省略 C++ 是故意的，因为调用
    C++ 文件中的函数需要额外的步骤。C++ 支持函数重载，这意味着你可以多次使用相同的函数名，但为每个函数传递不同的参数以获得不同的结果。以下是一些使用函数重载的代码示例：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The compiler needs to differentiate between these functions. If it used the
    name `addNumbers` and you tried calling the function in one place with two arguments
    and another with three, it would fail. To call the function by name in your compiled
    Wasm, you need to wrap the function in an `extern` block. One implication of wrapping
    the function is that you would have to explicitly define functions for each condition.
    The following code snippet demonstrates how to implement the previous functions
    without name mangling:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器需要区分这些函数。如果它使用了 `addNumbers` 这个名称，而你尝试在一个地方用两个参数调用该函数，在另一个地方用三个参数调用，它就会失败。要在编译后的
    Wasm 中按名称调用函数，你需要将函数包裹在一个 `extern` 块中。包裹函数的一个含义是，你必须为每种情况显式定义函数。以下代码片段展示了如何实现之前的功能而不进行名称修饰：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Calling functions from a WebAssembly instance
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 WebAssembly 实例调用函数
- en: 'We demonstrated how to call a function in a Wasm instance from JavaScript in
    the previous chapter, but that was assuming you instantiated a module in the browser
    with no glue code. Emscripten provides the ability to call functions from the
    Wasm instance as well. After a module is instantiated, you call functions by invoking
    them from the `instance.exports` object, which is accessible from the result of
    the resolved `Promise`. MDN''s documentation provides the following function signature
    for `WebAssembly.instantiateStreaming`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们演示了如何从 JavaScript 调用 Wasm 实例中的函数，但那是假设您在浏览器中实例化了没有粘合代码的模块。Emscripten
    提供了从 Wasm 实例调用函数的能力。模块实例化后，您可以通过从解析后的 `Promise` 的结果中访问的 `instance.exports` 对象来调用函数。MDN
    的文档为 `WebAssembly.instantiateStreaming` 提供了以下函数签名：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You may need to use the `WebAssembly.instantiate()` method, depending on your
    browser. Chrome currently supports `WebAssembly.instantiateStreaming()`, but if
    you encounter an error when attempting to load your module, use the `WebAssembly.instantiate()`
    method instead.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的浏览器，您可能需要使用 `WebAssembly.instantiate()` 方法。目前 Chrome 支持 `WebAssembly.instantiateStreaming()`，但如果在尝试加载模块时遇到错误，请改用
    `WebAssembly.instantiate()` 方法。
- en: 'The `ResultObject` contains the `instance` object that we need to reference
    to call exported functions from the module. Here''s some code that calls a function
    named `_addTwoNumbers` from the compiled Wasm instance:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultObject` 包含我们需要的 `instance` 对象，以便从模块中调用导出的函数。以下是一些调用编译的 Wasm 实例中名为 `_addTwoNumbers`
    的函数的代码：'
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Emscripten provides a way to perform function calls in much the same way, albeit
    in a slightly different implementation. If you use the Promise-like API, you can
    access the function from an `asm` object that the promise of the `Module()` resolves
    with. The following example demonstrates how to utilize this functionality:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten 提供了一种以类似的方式执行函数调用的方法，尽管实现略有不同。如果您使用类似 Promise 的 API，您可以从 `Module()`
    的解析中返回的 `asm` 对象访问该函数。以下示例演示了如何利用此功能：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Replicating the WebAssembly's Web API syntax with Emscripten simplifies any
    future refactoring. You can easily replace `Module()` with WebAssembly's `instantiateStreaming()`
    method and `result.asm` with `result.instance` in the future if you decide to
    use WebAssembly's Web API.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Emscripten 复制 WebAssembly 的 Web API 语法简化了未来的重构。如果您决定使用 WebAssembly 的 Web
    API，您可以轻松地将 `Module()` 替换为 WebAssembly 的 `instantiateStreaming()` 方法，并将 `result.asm`
    替换为 `result.instance`。
- en: Calling JavaScript functions from C/C++
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 C/C++ 调用 JavaScript 函数
- en: Accessing JavaScript's functionality from C/C++ code allows for added flexibility
    when working with WebAssembly. The methodologies and means of utilizing JavaScript
    differ considerably between Emscripten's glue code and Wasm-only implementations.
    In this section, we will cover the various ways you can integrate JavaScript into
    your C/C++ code with and without Emscripten.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C/C++ 代码访问 JavaScript 的功能，在使用 WebAssembly 时提供了额外的灵活性。在 Emscripten 的粘合代码和仅
    Wasm 实现之间，利用 JavaScript 的方法和手段差异很大。在本节中，我们将介绍您可以将 JavaScript 集成到您的 C/C++ 代码中的各种方法，无论是否使用
    Emscripten。
- en: Interacting with JavaScript using glue code
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用粘合代码与 JavaScript 交互
- en: Emscripten provides several techniques for integrating JavaScript with your
    C/C++ code. The techniques available differ in implementation and complexity,
    and some only apply to specific execution environments (for example, the browser).
    Deciding which one to use is contingent on your specific use case. We'll focus
    on the `emscripten_run_script()` function and inlining JavaScript with `EM_*`
    wrappers. The content in the following sections was taken from the *Interacting
    with Code* section of Emscripten's site, which can be viewed at [https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#interacting-with-code](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#interacting-with-code).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten 提供了多种将 JavaScript 与您的 C/C++ 代码集成的技术。这些技术的实现和复杂度不同，其中一些仅适用于特定的执行环境（例如，浏览器）。选择使用哪种技术取决于您的具体用例。我们将重点关注
    `emscripten_run_script()` 函数以及使用 `EM_*` 包装器内联 JavaScript。以下各节的内容摘自 Emscripten
    网站的 *与代码交互* 部分，该部分可在 [https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#interacting-with-code](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#interacting-with-code)
    查看。
- en: Executing strings with emscripten_run_script()
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 emscripten_run_script() 执行字符串
- en: 'The Emscripten site describes the `emscripten_run_script()` function as the
    most direct, but slightly slower approach for calling JavaScript for C/C++. It''s
    a technique that is well suited for a single line of JavaScript code and can be
    useful for debugging. The documentation states that it effectively runs the code
    using `eval()`, which is a JavaScript function that executes a string as code.
    The following code taken from the Emscripten site demonstrates the use of `emscripten_run_script()`
    to call the browser''s `alert()` function with the text `''hi''`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten 网站将 `emscripten_run_script()` 函数描述为调用 C/C++ 中 JavaScript 的最直接但略慢的方法。这是一种非常适合单行
    JavaScript 代码的技术，并且对于调试很有用。文档指出，它通过 `eval()` 来有效地运行代码，这是一个将字符串作为代码执行的 JavaScript
    函数。以下代码摘自 Emscripten 网站，展示了如何使用 `emscripten_run_script()` 来调用浏览器中的 `alert()` 函数并显示文本
    `'hi'`：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For more complex use cases where performance is a factor, using *inline JavaScript*
    provides a better solution.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的用例，其中性能是一个因素，使用 *内联 JavaScript* 提供了更好的解决方案。
- en: Executing inline JavaScript with EM_ASM()
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 EM_ASM() 执行内联 JavaScript
- en: 'You can wrap JavaScript code inside your C/C++ file with `EM_ASM()` and it
    will execute when the compiled code is run in the browser. The following code
    demonstrates basic usage:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `EM_ASM()` 在您的 C/C++ 文件中包裹 JavaScript 代码，并在编译的代码在浏览器中运行时执行。以下代码演示了基本用法：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The JavaScript code is executed immediately and cannot be reused within the
    C/C++ file in which it is contained. Arguments can be passed into the JavaScript
    code block where they arrive as variables `$0`, `$1`, and so on. These arguments
    can either be of type `int32_t` or `double`. The following code snippet, taken
    from the Emscripten site, demonstrates how to utilize arguments in an `EM_ASM()`
    block:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 代码立即执行，并且不能在其包含的 C/C++ 文件中重用。可以将参数传递到 JavaScript 代码块中，它们作为变量 `$0`、`$1`
    等到达。这些参数可以是 `int32_t` 或 `double` 类型。以下代码片段摘自 Emscripten 网站，展示了如何在 `EM_ASM()` 块中利用参数：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Reusing inline JavaScript with EM_JS()
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 EM_JS() 重复使用内联 JavaScript
- en: 'If you need a reusable function within your C/C++ file, you can wrap JavaScript
    code within an `EM_JS()` block and execute it like a normal C/C++ function. The
    definition for `EM_JS()` is described in the following code snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在您的 C/C++ 文件中有一个可重用的函数，您可以在 `EM_JS()` 块中包裹 JavaScript 代码，并像正常 C/C++ 函数一样执行它。`EM_JS()`
    的定义在以下代码片段中描述：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `return_type` parameter represents the C type that corresponds with the
    JavaScript code''s output (for example, `int` or `float`). If nothing is returned
    from the JavaScript code, specify `void` for the `return_type`. The next parameter,
    `function_name`, represents the name to use when calling the JavaScript code from
    other locations in the C/C++ file. The `arguments` parameter is used to define
    arguments that can be passed into the JavaScript code from the C calling function.
    The `code` parameter is the JavaScript code that''s wrapped in curly braces. The
    following code snippet, taken from the Emscripten site, demonstrates the use of
    `EM_JS()` in a C file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`return_type` 参数表示与 JavaScript 代码输出对应的 C 类型（例如，`int` 或 `float`）。如果 JavaScript
    代码没有返回值，则指定 `void` 作为 `return_type`。下一个参数 `function_name` 表示在 C/C++ 文件的其他位置调用
    JavaScript 代码时使用的名称。`arguments` 参数用于定义可以从 C 调用函数传递到 JavaScript 代码中的参数。`code` 参数是包裹在大括号中的
    JavaScript 代码。以下代码片段摘自 Emscripten 网站，展示了在 C 文件中使用 `EM_JS()` 的方法：'
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Examples of using glue code
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粘合代码的使用示例
- en: Let's write some code that utilizes all of these features. In this section,
    we will modify the code we used in the *Compiling C without the glue code* and
    *Fetching and instantiating a Wasm file* sections of [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml),
    *Creating and Loading a WebAssembly Module*. This was the code that displayed
    a moving blue rectangle on a red canvas and could be paused and restarted with
    the click of a button. The code for this section is located in the `/chapter-06-interact-with-js`
    folder in the `learn-webassembly` repository. Let's start by updating the C code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些利用所有这些功能的代码。在本节中，我们将修改在 [第 5 章](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml)
    的 *“不使用粘合代码编译 C”* 和 *“获取和实例化 Wasm 文件”* 部分中使用的代码，即 *“创建和加载 WebAssembly 模块”*。这是在红色画布上显示移动蓝色矩形并可以通过按钮点击暂停和重新开始的代码。本节代码位于
    `learn-webassembly` 仓库中的 `/chapter-06-interact-with-js` 文件夹内。让我们先更新 C 代码。
- en: The C code
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C 代码
- en: 'Create a new folder in your `/book-examples` folder named `/chapter-06-interact-with-js`.
    Create a new file in the `/chapter-06-interact-with-js` folder named `js-with-glue.c`
    and populate it with the following contents:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `/book-examples` 文件夹中创建一个新的文件夹，命名为 `/chapter-06-interact-with-js`。在 `/chapter-06-interact-with-js`
    文件夹中创建一个新的文件，命名为 `js-with-glue.c`，并填充以下内容：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see that we used all three of the JavaScript integrations that Emscripten
    provides. There are two functions, `js_clear_rect()` and `js_fill_rect()`, that
    are defined in `EM_JS()` blocks that take the place of the imported functions
    from the original example. The `EM_ASM()` block within the `setIsRunning()` function
    updates the text of a new status element we'll add to the HTML code. The `emscripten_run_script()`
    functions simply log out some status messages. We need to specify `EMSCRIPTEN_KEEPALIVE`
    above the functions we're planning to utilize outside of the module. If you don't
    specify this, the compiler will treat the functions as dead code and remove them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们使用了 Emscripten 提供的所有三种 JavaScript 集成。有两个函数 `js_clear_rect()` 和 `js_fill_rect()`，它们在
    `EM_JS()` 块中定义，这些块取代了原始示例中导入的函数。`setIsRunning()` 函数中的 `EM_ASM()` 块更新了我们将添加到 HTML
    代码中的新状态元素的文本。`emscripten_run_script()` 函数简单地输出一些状态消息。我们需要在计划在模块外部使用的函数上方指定 `EMSCRIPTEN_KEEPALIVE`。如果不指定此选项，编译器将把函数视为死代码并删除它们。
- en: The HTML code
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML 代码
- en: 'Let''s create a file named `js-with-glue.html` in the `/chapter-06-interact-with-js`
    folder and populate it with the following contents:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/chapter-06-interact-with-js` 文件夹中创建一个名为 `js-with-glue.html` 的文件，并填充以下内容：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We added two `<span>` elements to display the status of the rectangle's movement,
    along with a corresponding label. We're using Emscripten's Promise-like API to
    load the module and reference the functions from the compiled code. We're no longer
    passing in the `_jsFillRect` and `_jsClearRect` functions to the module because
    we're handling that within the `js-with-glue.c` file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个 `<span>` 元素来显示矩形的移动状态，以及相应的标签。我们正在使用 Emscripten 的类似 Promise 的 API 来加载模块并从编译后的代码中引用函数。我们不再将
    `_jsFillRect` 和 `_jsClearRect` 函数传递给模块，因为我们已经在 `js-with-glue.c` 文件中处理了这些。
- en: Compiling and serving the result
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和提供结果
- en: 'To compile the code, ensure that you''re in the `/chapter-06-interact-with-js`
    folder and run the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译代码，请确保你位于 `/chapter-06-interact-with-js` 文件夹中，并运行以下命令：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once complete, run the following command to start your local server:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，运行以下命令以启动本地服务器：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open up a browser and navigate to `http://127.0.0.1:8080/js-with-glue.html`.
    You should see something like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并导航到 `http://127.0.0.1:8080/js-with-glue.html`。你应该看到如下内容：
- en: '![](img/72e12623-7f8d-4d6a-8661-1f13822c1ef5.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/72e12623-7f8d-4d6a-8661-1f13822c1ef5.png)'
- en: Glue code running in the browser
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中运行的粘合代码
- en: If you press the Pause button, the caption on the button should change to Start,
    the text next to Status should change to Paused, and the rectangle should stop
    moving.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按下暂停按钮，按钮上的标题应更改为“开始”，旁边状态文本应更改为“暂停”，并且矩形应停止移动。
- en: Interacting with JavaScript without glue code
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无粘合代码与 JavaScript 交互
- en: Utilizing JavaScript code in C/C++ files follows a different paradigm than the
    techniques used for Emscripten. Rather than writing JavaScript within the C/C++
    files, you pass the functions into your WebAssembly instantiation code. In this
    section, we will describe this process in greater detail.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C/C++ 文件中利用 JavaScript 代码遵循与 Emscripten 所用技术不同的范式。而不是在 C/C++ 文件中编写 JavaScript，你需要将函数传递到你的
    WebAssembly 实例化代码中。在本节中，我们将更详细地描述这个过程。
- en: Passing JavaScript to C/C++ using the import object
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用导入对象将 JavaScript 传递到 C/C++
- en: 'In order to utilize JavaScript''s functionality in your C/C++ code, you need
    to add a function definition to the `importObj.env` argument that gets passed
    into WebAssembly''s instantiation function. You can either define the function
    outside of the `importObj.env` or inline. The following code snippet demonstrates
    each option:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 C/C++ 代码中利用 JavaScript 的功能，你需要在传递给 WebAssembly 实例化函数的 `importObj.env` 参数中添加一个函数定义。你可以在
    `importObj.env` 外部定义函数，或者内联定义。以下代码片段演示了每个选项：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Given the manual memory management and strict typing requirements of C, C++,
    and Rust, you're limited in what can be passed in and utilized in a Wasm module.
    JavaScript allows you to easily add, remove, and change the values of properties
    on an object over the course of code execution. You can even extend the language
    by adding functions to the `prototype` of a built-in language feature. C, C++,
    and Rust are much more restrictive, and it can be difficult to take full advantage
    of WebAssembly if you're not familiar with these languages.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C、C++和Rust的手动内存管理和严格的类型要求，您在Wasm模块中可以传递和利用的内容有限。JavaScript允许您在代码执行过程中轻松地添加、删除和更改对象属性值。您甚至可以通过向内置语言功能的`prototype`添加函数来扩展语言。C、C++和Rust要严格得多，如果您不熟悉这些语言，可能难以充分利用WebAssembly。
- en: Calling imported functions in C/C++
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C/C++中调用导入函数
- en: 'You need to define the JavaScript function you passed into `importObj.env`
    within the C/C++ code that utilizes it. The function signature must match what
    you passed in. The following example demonstrates this in greater detail. Here''s
    the JavaScript code that interacts with the compiled C file (`index.html`):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在利用它的C/C++代码中定义您传递到`importObj.env`中的JavaScript函数。函数签名必须与您传递的内容相匹配。以下示例更详细地演示了这一点。这是与编译后的C文件（`index.html`）交互的JavaScript代码：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is the contents of `main.c`, which is compiled to `main.wasm` and used
    within `index.html`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`main.c`的内容，它被编译为`main.wasm`并在`index.html`中使用：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You call the JavaScript function in your C/C++ the same way you'd call a normal
    C/C++ function. Although you prefix your function with a `_` when you pass it
    into the `importObj.env`, you don't need to include the prefix when defining it
    in the C/C++ file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您在C/C++中调用JavaScript函数的方式与调用正常C/C++函数的方式相同。尽管您在传递到`importObj.env`时在函数前加了一个`_`前缀，但在C/C++文件中定义它时不需要包含前缀。
- en: An example without glue code
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无glue代码的示例
- en: The example code from the *Compiling C without the glue code* and *Fetching
    and instantiating a Wasm file* sections of [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml),
    *Creating and Loading a WebAssembly Module*, demonstrated how to integrate JavaScript
    in our C file without using Emscripten's glue code. In this section, we will modify
    the example code slightly and change the file type to C++.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 来自第5章“创建和加载WebAssembly模块”中“编译C语言而不使用glue代码”和“获取和实例化Wasm文件”部分的示例代码，展示了如何在我们的C文件中集成JavaScript而不使用Emscripten的glue代码。在本节中，我们将稍微修改示例代码，并将文件类型更改为C++。
- en: The C++ code
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++代码
- en: 'Create a file named `js-without-glue.cpp` in your `/chapter-06-interact-with-js`
    folder and populate it with the following contents:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`/chapter-06-interact-with-js`文件夹中创建一个名为`js-without-glue.cpp`的文件，并填充以下内容：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code is similar to the previous example, but the shape and direction of
    the element on the canvas has changed. Now, the element is a circle that starts
    in the lower-left corner of the canvas and moves diagonally toward the upper-right.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与上一个示例类似，但画布上元素的形状和方向已改变。现在，元素是一个从画布左下角开始，对角线移动到右上角的圆形。
- en: The HTML code
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML代码
- en: 'Next, create a file named `js-without-glue.html` in your `/chapter-06-interact-with-js`
    folder and populate it with the following contents:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在您的`/chapter-06-interact-with-js`文件夹中创建一个名为`js-without-glue.html`的文件，并填充以下内容：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Instead of using the `rect()` element, we can manually draw paths using the
    functions available on the canvas element's 2D context.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不使用`rect()`元素，而是使用画布元素的2D上下文上可用的函数手动绘制路径。
- en: Compiling and serving the result
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和提供结果
- en: 'We''re only generating a Wasm module, so we can use the build task we set up
    in the previous chapter to compile our code. Select Tasks | Run Build Task… or
    use the keyboard shortcut *Ctrl*/*Cmd* + *Shift* + *B* to compile the code. If
    you''re not using VS Code, open a CLI instance in the `/chapter-06-interact-with-js`
    folder and run the following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只生成一个Wasm模块，因此我们可以使用上一章中设置的构建任务来编译我们的代码。选择“任务”|“运行构建任务...”或使用键盘快捷键*Ctrl*/*Cmd*
    + *Shift* + *B*来编译代码。如果您不使用VS Code，请在`/chapter-06-interact-with-js`文件夹中打开一个CLI实例，并运行以下命令：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once complete, open a terminal in the `/book-examples` folder, and run the
    following command to start your local server:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，在`/book-examples`文件夹中打开一个终端，并运行以下命令以启动您的本地服务器：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Open up a browser and navigate to `http://127.0.0.1:8080/chapter-06-interact-with-js/js-without-glue.html`.
    You should see something like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并导航到 `http://127.0.0.1:8080/chapter-06-interact-with-js/js-without-glue.html`。你应该看到如下内容：
- en: '![](img/c981ffdb-10a6-4d61-b87c-fdfa19ce9d83.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c981ffdb-10a6-4d61-b87c-fdfa19ce9d83.png)'
- en: The Wasm module running in the browser without glue code
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行而不需要粘合代码的 Wasm 模块
- en: Just as with the previous examples, if you press the Pause button, the caption
    on the button should change to Start and the circle should stop moving.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的示例一样，如果你按下暂停按钮，按钮上的标题应该更改为开始，并且圆圈应该停止移动。
- en: Advanced Emscripten features
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 Emscripten 功能
- en: We covered the Emscripten features we'll be using most frequently for communicating
    between JavaScript and C/C++ in the previous sections, but those aren't the only
    capabilities Emscripten provides. There are advanced features and additional APIs
    that you need to be aware of, especially if you plan on adding more complex functionality
    to your application. In this section, we'll briefly review some of these advanced
    features and provide details about where you can learn more.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了我们将最频繁使用的 Emscripten 功能，用于在 JavaScript 和 C/C++ 之间进行通信，但 Emscripten
    提供的不仅仅是这些功能。还有一些高级功能和额外的 API，你需要了解这些，特别是如果你计划向你的应用程序添加更复杂的功能。在本节中，我们将简要回顾一些这些高级功能，并提供更多详细信息的学习途径。
- en: Embind
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Embind
- en: 'Embind is an additional feature that Emscripten offers for connecting JavaScript
    and C++. Emscripten''s site provides the following description:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Embind 是 Emscripten 提供的用于连接 JavaScript 和 C++ 的附加功能。Emscripten 的网站提供了以下描述：
- en: '"Embind is used to bind C++ functions and classes to JavaScript, so that the
    compiled code can be used in a natural way by ''normal'' JavaScript. Embind also
    supports calling JavaScript classes from C++."'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: “Embind 用于将 C++ 函数和类绑定到 JavaScript，以便编译后的代码可以以自然的方式由 '普通' JavaScript 使用。Embind
    还支持从 C++ 调用 JavaScript 类。”
- en: 'Embind is a powerful feature that allows for tight integration between JavaScript
    and C++. You can wrap some C++ code in an `EMSCRIPTEN_BINDINGS()` block and reference
    it through the `Module` object in your browser. Let''s look at an example from
    Emscripten''s site. The following file, `example.cpp`, is compiled with the `--bind`
    flag of `emcc`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Embind 是一个强大的功能，它允许 JavaScript 和 C++ 之间进行紧密集成。你可以在 `EMSCRIPTEN_BINDINGS()` 块中封装一些
    C++ 代码，并通过浏览器中的 `Module` 对象引用它。让我们看看 Emscripten 网站上的一个示例。以下文件 `example.cpp` 使用
    `emcc` 的 `--bind` 标志进行编译：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The resultant module is loaded in `example.html` and the `lerp()` function
    is called:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的模块在 `example.html` 中加载，并调用 `lerp()` 函数：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding example represents a small portion of Embind's capabilities. You
    can learn more about Embind at [https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例只是 Embind 功能的一小部分。你可以在 [https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html)
    了解更多关于 Embind 的信息。
- en: File System API
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统 API
- en: Emscripten provides support for file operations by using the FS library and
    exposes an API for working with the filesystem. However, it's not included by
    default when you compile your project because it could increase the file's size
    significantly. If your C/C++ code uses files, the library will be added automatically.
    The filesystem types vary based on the execution environment. For example, if
    you're running code inside a worker, the `WORKERFS` filesystem can be used. By
    default, `MEMFS` is used, which stores the data in memory, and any data written
    to memory is lost when the page is reloaded. You can read more about the File
    System API at [https://kripken.github.io/emscripten-site/docs/api_reference/Filesystem-API.html#filesystem-api](https://kripken.github.io/emscripten-site/docs/api_reference/Filesystem-API.html#filesystem-api).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten 通过使用 FS 库提供对文件操作的支持，并公开了一个用于处理文件系统的 API。然而，当你编译项目时，它默认不包含在内，因为它可能会显著增加文件的大小。如果你的
    C/C++ 代码使用文件，库将自动添加。文件系统类型根据执行环境而变化。例如，如果你在 worker 内运行代码，可以使用 `WORKERFS` 文件系统。默认情况下，使用
    `MEMFS`，它将数据存储在内存中，并且当页面重新加载时，写入内存的数据将丢失。你可以在 [https://kripken.github.io/emscripten-site/docs/api_reference/Filesystem-API.html#filesystem-api](https://kripken.github.io/emscripten-site/docs/api_reference/Filesystem-API.html#filesystem-api)
    了解更多关于文件系统 API 的信息。
- en: Fetch API
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fetch API
- en: 'Emscripten provides a Fetch API as well. The following is taken from the documentation:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten 还提供了一个 Fetch API。以下内容摘自文档：
- en: '"The Emscripten Fetch API allows native code to transfer files via XHR (HTTP
    GET, PUT, POST) from remote servers, and to persist the downloaded files locally
    in browser''s IndexedDB storage, so that they can be re-accessed locally on subsequent
    page visits. The Fetch API is callable from multiple threads, and the network
    requests can be run either synchronously or asynchronously as desired."'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: “Emscripten Fetch API 允许原生代码通过 XHR（HTTP GET、PUT、POST）从远程服务器传输文件，并将下载的文件持久保存在浏览器
    IndexedDB 存储中，以便在后续页面访问时本地重新访问。Fetch API 可从多个线程调用，网络请求可以按需同步或异步运行。”
- en: The Fetch API can be used to integrate with Emscripten's other features. If
    you need to fetch data that isn't utilized by Emscripten, you should use the browser's
    Fetch API ([https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)).
    You can read more about the Fetch API at [https://kripken.github.io/emscripten-site/docs/api_reference/fetch.html](https://kripken.github.io/emscripten-site/docs/api_reference/fetch.html).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Fetch API 可以用于与 Emscripten 的其他功能集成。如果您需要获取 Emscripten 未使用的数据，应使用浏览器的 Fetch API
    ([https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API))。您可以在
    [https://kripken.github.io/emscripten-site/docs/api_reference/fetch.html](https://kripken.github.io/emscripten-site/docs/api_reference/fetch.html)
    上了解更多关于 Fetch API 的信息。
- en: Debugging in the browser
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器中的调试
- en: Effectively debugging JavaScript code in the browser has not always been easy.
    However, development tooling has markedly improved in the browser and in editors/IDEs
    with built-in debugging capabilities. Unfortunately, adding WebAssembly to a web
    application adds an additional level of complexity to the debugging process. In
    this section, we will review some techniques for debugging JavaScript that utilizes
    Wasm as well as some of the additional capabilities Emscripten offers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中有效地调试 JavaScript 代码并不总是容易。然而，浏览器和内置调试功能的编辑器/IDE 中的开发工具已经显著改进。不幸的是，将 WebAssembly
    添加到 Web 应用程序中给调试过程增加了额外的复杂性。在本节中，我们将回顾一些利用 Wasm 调试 JavaScript 的技术以及 Emscripten
    提供的一些附加功能。
- en: High-level overview
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级概述
- en: Debugging Emscripten's `Module` is relatively straightforward. Emscripten's
    error messages are well formed and descriptive, so you'll usually discover what's
    causing the issue right away. You can view these messages in your browser's development
    tools console.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 调试 Emscripten 的 `Module` 比较直接。Emscripten 的错误信息格式良好且描述性强，因此您通常会立即发现导致问题的原因。您可以在浏览器开发工具控制台中查看这些信息。
- en: If you specified a `.html` output when running the `emcc` command, some debugging
    code will already be built in (`Module.print` and `Module.printErr`). Within the
    HTML file, the loading code sets the `window.onerror` event to call the `Module.printErr`
    event, so you can see details about the error that occurred when loading.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在运行 `emcc` 命令时指定了 `.html` 输出，一些调试代码已经内置（`Module.print` 和 `Module.printErr`）。在
    HTML 文件中，加载代码将 `window.onerror` 事件设置为调用 `Module.printErr` 事件，因此您可以在加载时看到有关错误详情。
- en: 'One common error you may encounter is calling the wrong function name. If you''re
    using Emscripten''s Promise-like API, you can print out the available functions
    by running the following code in your browser''s console:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会遇到的一个常见错误是调用错误的函数名。如果您使用 Emscripten 的类似 Promise 的 API，您可以在浏览器控制台中运行以下代码来打印出可用的函数：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following screenshot shows the output for the `js-with-glue.js` example
    we used in the *Calling JavaScript functions from C/C++* section of this chapter:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了本章“从 C/C++ 调用 JavaScript 函数”部分中使用的 `js-with-glue.js` 示例的输出：
- en: '![](img/7a85c9a2-9f60-48eb-b1d1-196d77f5e9f8.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a85c9a2-9f60-48eb-b1d1-196d77f5e9f8.png)'
- en: Logging the contents of `Module().asm` in the browser console
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器控制台中记录 `Module().asm` 的内容
- en: Your functions, as well as some functions that Emscripten generates, will be
    prefixed with a `_`. The advantage of writing code that gets compiled is that
    the compiler will catch most errors up front. Given the extensive tooling available
    for languages such as C and C++, you should be able to understand and address
    these errors quickly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您的函数以及 Emscripten 生成的某些函数将以前缀 `_` 开头。编写可编译的代码的优势在于编译器将提前捕获大多数错误。鉴于 C 和 C++ 等语言可用的广泛工具，您应该能够快速理解和解决这些错误。
- en: If you're not using any glue code and instantiating a Wasm file using WebAssembly's
    JavaScript and Web APIs, debugging can get a little more complex. As previously
    stated, you have the advantage of catching most errors at compile time in your
    C or C++ code. Just as with Emscripten, the error messages printed out in your
    browser's development tools console provide a stack trace and a relatively clear
    description of the issue. However, logging to the console may become cumbersome
    and difficult to manage if you're troubleshooting a particularly difficult bug.
    Fortunately, you can use source maps to improve your debugging capabilities.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用任何胶水代码，并且使用WebAssembly的JavaScript和Web API实例化Wasm文件，调试可能会变得稍微复杂一些。正如之前所述，你在编译时可以捕获C或C++代码中的大多数错误。与Emscripten一样，浏览器开发工具控制台打印出的错误消息提供了堆栈跟踪和相对清晰的问题描述。然而，如果你在调试一个特别棘手的错误，将日志记录到控制台可能会变得繁琐且难以管理。幸运的是，你可以使用源映射来提高你的调试能力。
- en: Using source maps
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用源映射
- en: 'Emscripten has the ability to generate source maps by passing some additional
    flags to the compiler. Source maps allow your browser to map the source of a file
    to the file being utilized in an application. For example, you can use a JavaScript
    build tool such Webpack to minify the code as part of your build process. However,
    it''s incredibly difficult to navigate and troubleshoot the minified code if you''re
    trying to find a bug. By generating a source map, you can view the code in its
    original form within the browser''s development tools and set breakpoints for
    debugging. Let''s generate a source map for our `/chapter-06-interact-with-js/js-without-glue.cpp`
    file. Within the `/book-examples` folder, run the following command in a terminal:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten可以通过向编译器传递一些额外的标志来生成源映射。源映射允许浏览器将文件的源映射到应用程序中使用的文件。例如，你可以使用Webpack这样的JavaScript构建工具在构建过程中将代码进行压缩。然而，如果你试图找到错误，导航和调试压缩代码会非常困难。通过生成源映射，你可以在浏览器开发工具中查看代码的原始形式，并为调试设置断点。让我们为我们的`/chapter-06-interact-with-js/js-without-glue.cpp`文件生成一个源映射。在`/book-examples`文件夹中，在终端运行以下命令：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `-g4` argument enables source maps, while the `--source-map-base` argument
    tells the browser where to find the source map file. Once compiled, start your
    local server up from the `/book-examples` folder by running the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g4`参数启用源映射，而`--source-map-base`参数告诉浏览器在哪里找到源映射文件。一旦编译完成，从`/book-examples`文件夹启动本地服务器，运行以下命令：'
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Navigate to `http://127.0.0.1:8080/chapter-06-interact-with-js/js-without-glue.html`,
    open the Developer Tools, and select the Sources tab (in Chrome) or Debugger tab
    (in Firefox). If you''re using Chrome, you should see the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`http://127.0.0.1:8080/chapter-06-interact-with-js/js-without-glue.html`，打开开发者工具，并选择“源”标签页（在Chrome中）或“调试器”标签页（在Firefox中）。如果你使用的是Chrome，你应该会看到以下内容：
- en: '![](img/ccc8b38d-f748-40fb-8d25-667dc176c0ff.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ccc8b38d-f748-40fb-8d25-667dc176c0ff.png)'
- en: Wasm source maps in Chrome Developer Tools
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome开发者工具中的Wasm源映射
- en: 'As you can see, the filenames aren''t very helpful. Each file should include
    the function name at the top, although some of the names may have been mangled.
    You can set breakpoints if you encounter errors, and Chrome''s debugging functionality
    allows you to navigate the call stack. Firefox handles their source maps differently.
    The following screenshot shows the Debugger view in Firefox''s Developer Tools:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，文件名并不很有帮助。每个文件都应该在顶部包含函数名，尽管一些名称可能已经被破坏。如果你遇到错误，可以设置断点，Chrome的调试功能允许你导航调用堆栈。Firefox以不同的方式处理它们的源映射。以下截图显示了Firefox开发者工具中的调试器视图：
- en: '![](img/d40de2b0-f550-4e74-bbac-4249f1693ec4.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d40de2b0-f550-4e74-bbac-4249f1693ec4.png)'
- en: Wasm source map in Firefox Developer Tools
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox开发者工具中的Wasm源映射
- en: The source map is a single file that contains the Wat representation of the
    Wasm file. You can set breakpoints and debug code here as well. As WebAssembly
    evolves, more (and better) tooling will become available. In the meantime, logging
    to the console and utilizing source maps are the current debugging methods you
    can use.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 源映射是一个包含Wasm文件Wat表示的单个文件。你可以在这里设置断点并调试代码。随着WebAssembly的发展，将会有更多（和更好的）工具可用。与此同时，将日志记录到控制台并使用源映射是当前你可以使用的调试方法。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused on the intercommunication of JavaScript and C/C++,
    some of the features Emscripten offers, and how to effectively debug web applications
    that utilize Wasm in the browser. We reviewed the various means of calling compiled
    C/C++ functions from JavaScript, and how to integrate JavaScript with your C/C++
    code. Emscripten's APIs were presented as a way to understand how you can overcome
    some of WebAssembly's current limitations by including glue code with your compiled
    Wasm files. Even though the capabilities Emscripten provides are not present in
    the official WebAssembly *Core Specification* (and may never be), that shouldn't
    deter you from taking advantage of them. Finally, we briefly covered how to debug
    Wasm files in the browser in the context of an Emscripten module or a WebAssembly
    instance.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于JavaScript和C/C++之间的互操作性，Emscripten提供的一些功能，以及如何有效地调试利用浏览器中的Wasm的Web应用程序。我们回顾了从JavaScript调用编译的C/C++函数的各种方法，以及如何将JavaScript与你的C/C++代码集成。Emscripten的API被展示为理解你如何通过将胶水代码包含在你的编译Wasm文件中，来克服WebAssembly的一些当前限制。即使Emscripten提供的功能不在官方WebAssembly
    *核心规范* 中（可能永远也不会），这也不应该阻止你利用它们。最后，我们简要介绍了如何在Emscripten模块或WebAssembly实例的上下文中调试浏览器中的Wasm文件。
- en: In the next chapter, we'll build a real-world WebAssembly application from scratch.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从头开始构建一个真实的WebAssembly应用程序。
- en: Questions
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the names of the two functions available on the `Module` object that
    you use to interact with the compiled code from the browser?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你使用的`Module`对象上可用的两个函数的名称是什么，你用它来与浏览器中的编译代码进行交互？
- en: What do you need to wrap your C++ code in to ensure the function names don't
    get mangled?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要将你的C++代码包裹在什么中，以确保函数名称不会被破坏？
- en: What's the difference between `EM_ASM()` and `EM_JS()`?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EM_ASM()`和`EM_JS()`之间的区别是什么？'
- en: Which is more performant, `emscripten_run_script()` or `EM_ASM()`/`EM_JS()`?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`emscripten_run_script()`或`EM_ASM()`/`EM_JS()`哪个性能更好？'
- en: 'What do you need to include in the line above your function if you want to
    use it outside of your C/C++ code (hint: it starts with `EMSCRIPTEN`)?'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想在C/C++代码外部使用它，你需要在函数上方包含什么（提示：它以`EMSCRIPTEN`开头）？
- en: Where can you define a function that needs to be passed into the `importObj.env`
    object when instantiating a module?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实例化模块时，你可以在哪里定义一个需要传递给`importObj.env`对象的函数？
- en: What additional APIs does Emscripten provide?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Emscripten提供了哪些额外的API？
- en: What is the purpose of source maps?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源映射的目的是什么？
- en: Further reading
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Emscripten API Reference: [http://kripken.github.io/emscripten-site/docs/api_reference/index.html](http://kripken.github.io/emscripten-site/docs/api_reference/index.html)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Emscripten API参考：[http://kripken.github.io/emscripten-site/docs/api_reference/index.html](http://kripken.github.io/emscripten-site/docs/api_reference/index.html)
- en: An Introduction to Source Maps: [http://blog.teamtreehouse.com/introduction-source-maps](http://blog.teamtreehouse.com/introduction-source-maps)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源映射简介：[http://blog.teamtreehouse.com/introduction-source-maps](http://blog.teamtreehouse.com/introduction-source-maps)
- en: Using Browsers to Debug WebAssembly: [http://webassemblycode.com/using-browsers-debug-webassembly](http://webassemblycode.com/using-browsers-debug-webassembly)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用浏览器调试WebAssembly：[http://webassemblycode.com/using-browsers-debug-webassembly](http://webassemblycode.com/using-browsers-debug-webassembly)
