- en: Interacting with JavaScript and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's a great deal of exciting features and proposals in the works for WebAssembly.
    However, at the time of writing this book, the feature set is rather limited.
    As it stands, you can benefit greatly from using some of the features Emscripten
    provides. The process for interacting with C/C++ from JavaScript (and vice versa)
    will differ depending on whether you decide to use Emscripten.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover how to utilize JavaScript functions with C/C++
    code as well as how to interact with the compiled output of your C/C++ code from
    JavaScript. We'll also describe how Emscripten's *glue* code affects the ways
    a Wasm instance is utilized and how to debug compiled code in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal for this chapter is to understand the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The differences between Emscripten's `Module` and the browser's `WebAssembly`
    object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to call compiled C/C++ functions from your JavaScript code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to call JavaScript functions from your C/C++ code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special considerations to be aware of when working with C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques for debugging compiled output in the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Emscripten module versus the WebAssembly object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we briefly covered Emscripten's `Module` object and
    how to load it in the browser. The `Module` object provides several convenient
    methods and differs significantly from the browser's `WebAssembly` object. In
    this section, we're going to review Emscripten's `Module` object in greater detail.
    We'll also discuss the difference between Emscripten's `Module` and the objects
    described in WebAssembly's *JavaScript API*.
  prefs: []
  type: TYPE_NORMAL
- en: What is the Emscripten module?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Emscripten''s official site provides the following definition for the `Module`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Module is a global JavaScript object with attributes that Emscripten-generated
    code calls at various points in its execution."'
  prefs: []
  type: TYPE_NORMAL
- en: Not only is the loading procedure different from WebAssembly's `compile` and
    `instantiate` functions, but the `Module` provides some helpful functionality
    out of the box that would otherwise require a custom implementation in WebAssembly.
    The `Module` is available in a global scope (`window.Module`) after fetching and
    loading Emscripten's JavaScript *glue* code.
  prefs: []
  type: TYPE_NORMAL
- en: Default methods in the glue code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Emscripten's `Module` object provides some default methods and properties to
    aid in debugging and ensuring the successful execution of your compiled code.
    You can utilize the `preRun` and `postRun` properties to execute JavaScript code
    before or after the Module's `run()` function is called, or pipe the output of
    the `print()` and `printErr()` functions to an HTML element on the page. We'll
    utilize some of these methods later in this book. You can read more about them
    at [https://kripken.github.io/emscripten-site/docs/api_reference/module.html](https://kripken.github.io/emscripten-site/docs/api_reference/module.html).
  prefs: []
  type: TYPE_NORMAL
- en: Differences with the WebAssembly object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered the browser's WebAssembly object and the corresponding loading procedures
    in [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating and Loading
    a WebAssembly Module*. WebAssembly's JavaScript and Web APIs define the objects
    and methods available in the browser's `window.WebAssembly` object. Emscripten's
    `Module` can be seen as a combination of WebAssembly's `Module` and `Instance`
    objects, which are present in the `result` object that WebAssembly's instantiation
    function returns. By passing the `-s MODULARIZE=1` flag to the `emcc` command,
    we're able to replicate WebAssembly's instantiation method (to a degree). We will
    examine the differences between Emscripten's `Module` and the browser's `WebAssembly`
    object in greater detail as we evaluate the methods of integrating JavaScript
    and C/C++ in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Calling compiled C/C++ functions from JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calling functions from a Wasm instance is a relatively straightforward process
    with or without Emscripten's glue code. Utilizing Emscripten's API affords a wider
    range of functionality and integration at the expense of including the glue code
    alongside the `.wasm` file. In this section, we will review the means of interacting
    with the compiled Wasm instance through JavaScript and the added tooling Emscripten
    provides.
  prefs: []
  type: TYPE_NORMAL
- en: Calling functions from a Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Emscripten provides two functions for calling compiled C/C++ functions from
    JavaScript: `ccall()` and `cwrap()`. Both of these functions are present in the
    `Module` object. Deciding which one to use is contingent on whether the function
    will be called more than once. The content in the following sections was taken
    from Emscripten''s API reference documentation for `preamble.js`, which can be
    viewed at [http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html](http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html).'
  prefs: []
  type: TYPE_NORMAL
- en: You don't need to prefix function calls with `_` when using `ccall()` or `cwrap()` – just
    use the name specified in the C/C++ file.
  prefs: []
  type: TYPE_NORMAL
- en: Module.ccall()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Module.ccall()` calls a compiled C function from JavaScript and returns the
    result of that function. The function signature for `Module.ccall()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You must specify a type name for the `returnType` and `argTypes` parameters.
    The possible types are `"number"`, `"string"`, `"array"`, and `"boolean"`, which
    correspond to the appropriate JavaScript types. You cannot specify `"array"` for
    the `returnType` parameter because there is no way to know the length of the array.
    If the function doesn't return anything, you can specify `null` for the `returnType`
    (note the absence of quotation marks).
  prefs: []
  type: TYPE_NORMAL
- en: The `opts` parameter is an optional options object that can contain a Boolean
    property named `async`. Specifying a value of `true` for this property implies
    that the call will perform an async operation. We won't use this parameter for
    any of our examples, but if you wish to learn more about it, the documentation
    is available at [http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html#calling-compiled-c-functions-from-javascript](http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html#calling-compiled-c-functions-from-javascript).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of `ccall()`. The following code, taken from the
    Emscripten site, demonstrates how to call a function named `c_add()` from the
    compiled output of a C file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Module.cwrap()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Module.cwrap()` is similar to `ccall()` in that it calls a compiled C function.
    However, rather than returning a value, it returns a JavaScript function that
    can be reused as many times as needed. The function signature for `Module.cwrap()` is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Just as with `ccall()`, you can specify string values that represent types for
    the `returnType` and `argTypes` parameters. You cannot use the `"array"` type
    in `argTypes` because there is no way to know the length of the array when the
    function is called. For a function that doesn't return a value, use `null` (with
    no quotation marks) for the `returnType` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code, taken from the Emscripten site, demonstrates the use of
    `cwrap()` to create a reusable function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: C++ and name mangling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may have noticed that the descriptions of `ccall()` and `cwrap()` specified
    that both are used to call a compiled C function. The omission of C++ was intentional
    because an additional step is needed to call functions from a C++ file. C++ supports
    function overloading, which means that you can use the same function name multiple
    times, but pass different arguments to each one to get a different result. Here''s
    an example of some code that uses function overloading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler needs to differentiate between these functions. If it used the
    name `addNumbers` and you tried calling the function in one place with two arguments
    and another with three, it would fail. To call the function by name in your compiled
    Wasm, you need to wrap the function in an `extern` block. One implication of wrapping
    the function is that you would have to explicitly define functions for each condition.
    The following code snippet demonstrates how to implement the previous functions
    without name mangling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Calling functions from a WebAssembly instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We demonstrated how to call a function in a Wasm instance from JavaScript in
    the previous chapter, but that was assuming you instantiated a module in the browser
    with no glue code. Emscripten provides the ability to call functions from the
    Wasm instance as well. After a module is instantiated, you call functions by invoking
    them from the `instance.exports` object, which is accessible from the result of
    the resolved `Promise`. MDN''s documentation provides the following function signature
    for `WebAssembly.instantiateStreaming`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You may need to use the `WebAssembly.instantiate()` method, depending on your
    browser. Chrome currently supports `WebAssembly.instantiateStreaming()`, but if
    you encounter an error when attempting to load your module, use the `WebAssembly.instantiate()`
    method instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ResultObject` contains the `instance` object that we need to reference
    to call exported functions from the module. Here''s some code that calls a function
    named `_addTwoNumbers` from the compiled Wasm instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Emscripten provides a way to perform function calls in much the same way, albeit
    in a slightly different implementation. If you use the Promise-like API, you can
    access the function from an `asm` object that the promise of the `Module()` resolves
    with. The following example demonstrates how to utilize this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Replicating the WebAssembly's Web API syntax with Emscripten simplifies any
    future refactoring. You can easily replace `Module()` with WebAssembly's `instantiateStreaming()`
    method and `result.asm` with `result.instance` in the future if you decide to
    use WebAssembly's Web API.
  prefs: []
  type: TYPE_NORMAL
- en: Calling JavaScript functions from C/C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessing JavaScript's functionality from C/C++ code allows for added flexibility
    when working with WebAssembly. The methodologies and means of utilizing JavaScript
    differ considerably between Emscripten's glue code and Wasm-only implementations.
    In this section, we will cover the various ways you can integrate JavaScript into
    your C/C++ code with and without Emscripten.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with JavaScript using glue code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Emscripten provides several techniques for integrating JavaScript with your
    C/C++ code. The techniques available differ in implementation and complexity,
    and some only apply to specific execution environments (for example, the browser).
    Deciding which one to use is contingent on your specific use case. We'll focus
    on the `emscripten_run_script()` function and inlining JavaScript with `EM_*`
    wrappers. The content in the following sections was taken from the *Interacting
    with Code* section of Emscripten's site, which can be viewed at [https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#interacting-with-code](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#interacting-with-code).
  prefs: []
  type: TYPE_NORMAL
- en: Executing strings with emscripten_run_script()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Emscripten site describes the `emscripten_run_script()` function as the
    most direct, but slightly slower approach for calling JavaScript for C/C++. It''s
    a technique that is well suited for a single line of JavaScript code and can be
    useful for debugging. The documentation states that it effectively runs the code
    using `eval()`, which is a JavaScript function that executes a string as code.
    The following code taken from the Emscripten site demonstrates the use of `emscripten_run_script()`
    to call the browser''s `alert()` function with the text `''hi''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For more complex use cases where performance is a factor, using *inline JavaScript*
    provides a better solution.
  prefs: []
  type: TYPE_NORMAL
- en: Executing inline JavaScript with EM_ASM()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can wrap JavaScript code inside your C/C++ file with `EM_ASM()` and it
    will execute when the compiled code is run in the browser. The following code
    demonstrates basic usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code is executed immediately and cannot be reused within the
    C/C++ file in which it is contained. Arguments can be passed into the JavaScript
    code block where they arrive as variables `$0`, `$1`, and so on. These arguments
    can either be of type `int32_t` or `double`. The following code snippet, taken
    from the Emscripten site, demonstrates how to utilize arguments in an `EM_ASM()`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Reusing inline JavaScript with EM_JS()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need a reusable function within your C/C++ file, you can wrap JavaScript
    code within an `EM_JS()` block and execute it like a normal C/C++ function. The
    definition for `EM_JS()` is described in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `return_type` parameter represents the C type that corresponds with the
    JavaScript code''s output (for example, `int` or `float`). If nothing is returned
    from the JavaScript code, specify `void` for the `return_type`. The next parameter,
    `function_name`, represents the name to use when calling the JavaScript code from
    other locations in the C/C++ file. The `arguments` parameter is used to define
    arguments that can be passed into the JavaScript code from the C calling function.
    The `code` parameter is the JavaScript code that''s wrapped in curly braces. The
    following code snippet, taken from the Emscripten site, demonstrates the use of
    `EM_JS()` in a C file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Examples of using glue code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's write some code that utilizes all of these features. In this section,
    we will modify the code we used in the *Compiling C without the glue code* and
    *Fetching and instantiating a Wasm file* sections of [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml),
    *Creating and Loading a WebAssembly Module*. This was the code that displayed
    a moving blue rectangle on a red canvas and could be paused and restarted with
    the click of a button. The code for this section is located in the `/chapter-06-interact-with-js`
    folder in the `learn-webassembly` repository. Let's start by updating the C code.
  prefs: []
  type: TYPE_NORMAL
- en: The C code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new folder in your `/book-examples` folder named `/chapter-06-interact-with-js`.
    Create a new file in the `/chapter-06-interact-with-js` folder named `js-with-glue.c`
    and populate it with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we used all three of the JavaScript integrations that Emscripten
    provides. There are two functions, `js_clear_rect()` and `js_fill_rect()`, that
    are defined in `EM_JS()` blocks that take the place of the imported functions
    from the original example. The `EM_ASM()` block within the `setIsRunning()` function
    updates the text of a new status element we'll add to the HTML code. The `emscripten_run_script()`
    functions simply log out some status messages. We need to specify `EMSCRIPTEN_KEEPALIVE`
    above the functions we're planning to utilize outside of the module. If you don't
    specify this, the compiler will treat the functions as dead code and remove them.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a file named `js-with-glue.html` in the `/chapter-06-interact-with-js`
    folder and populate it with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We added two `<span>` elements to display the status of the rectangle's movement,
    along with a corresponding label. We're using Emscripten's Promise-like API to
    load the module and reference the functions from the compiled code. We're no longer
    passing in the `_jsFillRect` and `_jsClearRect` functions to the module because
    we're handling that within the `js-with-glue.c` file.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and serving the result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compile the code, ensure that you''re in the `/chapter-06-interact-with-js`
    folder and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once complete, run the following command to start your local server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Open up a browser and navigate to `http://127.0.0.1:8080/js-with-glue.html`.
    You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72e12623-7f8d-4d6a-8661-1f13822c1ef5.png)'
  prefs: []
  type: TYPE_IMG
- en: Glue code running in the browser
  prefs: []
  type: TYPE_NORMAL
- en: If you press the Pause button, the caption on the button should change to Start,
    the text next to Status should change to Paused, and the rectangle should stop
    moving.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with JavaScript without glue code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Utilizing JavaScript code in C/C++ files follows a different paradigm than the
    techniques used for Emscripten. Rather than writing JavaScript within the C/C++
    files, you pass the functions into your WebAssembly instantiation code. In this
    section, we will describe this process in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: Passing JavaScript to C/C++ using the import object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to utilize JavaScript''s functionality in your C/C++ code, you need
    to add a function definition to the `importObj.env` argument that gets passed
    into WebAssembly''s instantiation function. You can either define the function
    outside of the `importObj.env` or inline. The following code snippet demonstrates
    each option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Given the manual memory management and strict typing requirements of C, C++,
    and Rust, you're limited in what can be passed in and utilized in a Wasm module.
    JavaScript allows you to easily add, remove, and change the values of properties
    on an object over the course of code execution. You can even extend the language
    by adding functions to the `prototype` of a built-in language feature. C, C++,
    and Rust are much more restrictive, and it can be difficult to take full advantage
    of WebAssembly if you're not familiar with these languages.
  prefs: []
  type: TYPE_NORMAL
- en: Calling imported functions in C/C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to define the JavaScript function you passed into `importObj.env`
    within the C/C++ code that utilizes it. The function signature must match what
    you passed in. The following example demonstrates this in greater detail. Here''s
    the JavaScript code that interacts with the compiled C file (`index.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the contents of `main.c`, which is compiled to `main.wasm` and used
    within `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You call the JavaScript function in your C/C++ the same way you'd call a normal
    C/C++ function. Although you prefix your function with a `_` when you pass it
    into the `importObj.env`, you don't need to include the prefix when defining it
    in the C/C++ file.
  prefs: []
  type: TYPE_NORMAL
- en: An example without glue code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example code from the *Compiling C without the glue code* and *Fetching
    and instantiating a Wasm file* sections of [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml),
    *Creating and Loading a WebAssembly Module*, demonstrated how to integrate JavaScript
    in our C file without using Emscripten's glue code. In this section, we will modify
    the example code slightly and change the file type to C++.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a file named `js-without-glue.cpp` in your `/chapter-06-interact-with-js`
    folder and populate it with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code is similar to the previous example, but the shape and direction of
    the element on the canvas has changed. Now, the element is a circle that starts
    in the lower-left corner of the canvas and moves diagonally toward the upper-right.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, create a file named `js-without-glue.html` in your `/chapter-06-interact-with-js`
    folder and populate it with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using the `rect()` element, we can manually draw paths using the
    functions available on the canvas element's 2D context.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and serving the result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re only generating a Wasm module, so we can use the build task we set up
    in the previous chapter to compile our code. Select Tasks | Run Build Task… or
    use the keyboard shortcut *Ctrl*/*Cmd* + *Shift* + *B* to compile the code. If
    you''re not using VS Code, open a CLI instance in the `/chapter-06-interact-with-js`
    folder and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once complete, open a terminal in the `/book-examples` folder, and run the
    following command to start your local server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Open up a browser and navigate to `http://127.0.0.1:8080/chapter-06-interact-with-js/js-without-glue.html`.
    You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c981ffdb-10a6-4d61-b87c-fdfa19ce9d83.png)'
  prefs: []
  type: TYPE_IMG
- en: The Wasm module running in the browser without glue code
  prefs: []
  type: TYPE_NORMAL
- en: Just as with the previous examples, if you press the Pause button, the caption
    on the button should change to Start and the circle should stop moving.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Emscripten features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered the Emscripten features we'll be using most frequently for communicating
    between JavaScript and C/C++ in the previous sections, but those aren't the only
    capabilities Emscripten provides. There are advanced features and additional APIs
    that you need to be aware of, especially if you plan on adding more complex functionality
    to your application. In this section, we'll briefly review some of these advanced
    features and provide details about where you can learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Embind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Embind is an additional feature that Emscripten offers for connecting JavaScript
    and C++. Emscripten''s site provides the following description:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Embind is used to bind C++ functions and classes to JavaScript, so that the
    compiled code can be used in a natural way by ''normal'' JavaScript. Embind also
    supports calling JavaScript classes from C++."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Embind is a powerful feature that allows for tight integration between JavaScript
    and C++. You can wrap some C++ code in an `EMSCRIPTEN_BINDINGS()` block and reference
    it through the `Module` object in your browser. Let''s look at an example from
    Emscripten''s site. The following file, `example.cpp`, is compiled with the `--bind`
    flag of `emcc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The resultant module is loaded in `example.html` and the `lerp()` function
    is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example represents a small portion of Embind's capabilities. You
    can learn more about Embind at [https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html).
  prefs: []
  type: TYPE_NORMAL
- en: File System API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Emscripten provides support for file operations by using the FS library and
    exposes an API for working with the filesystem. However, it's not included by
    default when you compile your project because it could increase the file's size
    significantly. If your C/C++ code uses files, the library will be added automatically.
    The filesystem types vary based on the execution environment. For example, if
    you're running code inside a worker, the `WORKERFS` filesystem can be used. By
    default, `MEMFS` is used, which stores the data in memory, and any data written
    to memory is lost when the page is reloaded. You can read more about the File
    System API at [https://kripken.github.io/emscripten-site/docs/api_reference/Filesystem-API.html#filesystem-api](https://kripken.github.io/emscripten-site/docs/api_reference/Filesystem-API.html#filesystem-api).
  prefs: []
  type: TYPE_NORMAL
- en: Fetch API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Emscripten provides a Fetch API as well. The following is taken from the documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The Emscripten Fetch API allows native code to transfer files via XHR (HTTP
    GET, PUT, POST) from remote servers, and to persist the downloaded files locally
    in browser''s IndexedDB storage, so that they can be re-accessed locally on subsequent
    page visits. The Fetch API is callable from multiple threads, and the network
    requests can be run either synchronously or asynchronously as desired."'
  prefs: []
  type: TYPE_NORMAL
- en: The Fetch API can be used to integrate with Emscripten's other features. If
    you need to fetch data that isn't utilized by Emscripten, you should use the browser's
    Fetch API ([https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)).
    You can read more about the Fetch API at [https://kripken.github.io/emscripten-site/docs/api_reference/fetch.html](https://kripken.github.io/emscripten-site/docs/api_reference/fetch.html).
  prefs: []
  type: TYPE_NORMAL
- en: Debugging in the browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Effectively debugging JavaScript code in the browser has not always been easy.
    However, development tooling has markedly improved in the browser and in editors/IDEs
    with built-in debugging capabilities. Unfortunately, adding WebAssembly to a web
    application adds an additional level of complexity to the debugging process. In
    this section, we will review some techniques for debugging JavaScript that utilizes
    Wasm as well as some of the additional capabilities Emscripten offers.
  prefs: []
  type: TYPE_NORMAL
- en: High-level overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging Emscripten's `Module` is relatively straightforward. Emscripten's
    error messages are well formed and descriptive, so you'll usually discover what's
    causing the issue right away. You can view these messages in your browser's development
    tools console.
  prefs: []
  type: TYPE_NORMAL
- en: If you specified a `.html` output when running the `emcc` command, some debugging
    code will already be built in (`Module.print` and `Module.printErr`). Within the
    HTML file, the loading code sets the `window.onerror` event to call the `Module.printErr`
    event, so you can see details about the error that occurred when loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common error you may encounter is calling the wrong function name. If you''re
    using Emscripten''s Promise-like API, you can print out the available functions
    by running the following code in your browser''s console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output for the `js-with-glue.js` example
    we used in the *Calling JavaScript functions from C/C++* section of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a85c9a2-9f60-48eb-b1d1-196d77f5e9f8.png)'
  prefs: []
  type: TYPE_IMG
- en: Logging the contents of `Module().asm` in the browser console
  prefs: []
  type: TYPE_NORMAL
- en: Your functions, as well as some functions that Emscripten generates, will be
    prefixed with a `_`. The advantage of writing code that gets compiled is that
    the compiler will catch most errors up front. Given the extensive tooling available
    for languages such as C and C++, you should be able to understand and address
    these errors quickly.
  prefs: []
  type: TYPE_NORMAL
- en: If you're not using any glue code and instantiating a Wasm file using WebAssembly's
    JavaScript and Web APIs, debugging can get a little more complex. As previously
    stated, you have the advantage of catching most errors at compile time in your
    C or C++ code. Just as with Emscripten, the error messages printed out in your
    browser's development tools console provide a stack trace and a relatively clear
    description of the issue. However, logging to the console may become cumbersome
    and difficult to manage if you're troubleshooting a particularly difficult bug.
    Fortunately, you can use source maps to improve your debugging capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Using source maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Emscripten has the ability to generate source maps by passing some additional
    flags to the compiler. Source maps allow your browser to map the source of a file
    to the file being utilized in an application. For example, you can use a JavaScript
    build tool such Webpack to minify the code as part of your build process. However,
    it''s incredibly difficult to navigate and troubleshoot the minified code if you''re
    trying to find a bug. By generating a source map, you can view the code in its
    original form within the browser''s development tools and set breakpoints for
    debugging. Let''s generate a source map for our `/chapter-06-interact-with-js/js-without-glue.cpp`
    file. Within the `/book-examples` folder, run the following command in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-g4` argument enables source maps, while the `--source-map-base` argument
    tells the browser where to find the source map file. Once compiled, start your
    local server up from the `/book-examples` folder by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to `http://127.0.0.1:8080/chapter-06-interact-with-js/js-without-glue.html`,
    open the Developer Tools, and select the Sources tab (in Chrome) or Debugger tab
    (in Firefox). If you''re using Chrome, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccc8b38d-f748-40fb-8d25-667dc176c0ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Wasm source maps in Chrome Developer Tools
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the filenames aren''t very helpful. Each file should include
    the function name at the top, although some of the names may have been mangled.
    You can set breakpoints if you encounter errors, and Chrome''s debugging functionality
    allows you to navigate the call stack. Firefox handles their source maps differently.
    The following screenshot shows the Debugger view in Firefox''s Developer Tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d40de2b0-f550-4e74-bbac-4249f1693ec4.png)'
  prefs: []
  type: TYPE_IMG
- en: Wasm source map in Firefox Developer Tools
  prefs: []
  type: TYPE_NORMAL
- en: The source map is a single file that contains the Wat representation of the
    Wasm file. You can set breakpoints and debug code here as well. As WebAssembly
    evolves, more (and better) tooling will become available. In the meantime, logging
    to the console and utilizing source maps are the current debugging methods you
    can use.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on the intercommunication of JavaScript and C/C++,
    some of the features Emscripten offers, and how to effectively debug web applications
    that utilize Wasm in the browser. We reviewed the various means of calling compiled
    C/C++ functions from JavaScript, and how to integrate JavaScript with your C/C++
    code. Emscripten's APIs were presented as a way to understand how you can overcome
    some of WebAssembly's current limitations by including glue code with your compiled
    Wasm files. Even though the capabilities Emscripten provides are not present in
    the official WebAssembly *Core Specification* (and may never be), that shouldn't
    deter you from taking advantage of them. Finally, we briefly covered how to debug
    Wasm files in the browser in the context of an Emscripten module or a WebAssembly
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll build a real-world WebAssembly application from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the names of the two functions available on the `Module` object that
    you use to interact with the compiled code from the browser?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you need to wrap your C++ code in to ensure the function names don't
    get mangled?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between `EM_ASM()` and `EM_JS()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which is more performant, `emscripten_run_script()` or `EM_ASM()`/`EM_JS()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What do you need to include in the line above your function if you want to
    use it outside of your C/C++ code (hint: it starts with `EMSCRIPTEN`)?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where can you define a function that needs to be passed into the `importObj.env`
    object when instantiating a module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What additional APIs does Emscripten provide?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of source maps?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Emscripten API Reference: [http://kripken.github.io/emscripten-site/docs/api_reference/index.html](http://kripken.github.io/emscripten-site/docs/api_reference/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Introduction to Source Maps: [http://blog.teamtreehouse.com/introduction-source-maps](http://blog.teamtreehouse.com/introduction-source-maps)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Browsers to Debug WebAssembly: [http://webassemblycode.com/using-browsers-debug-webassembly](http://webassemblycode.com/using-browsers-debug-webassembly)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
