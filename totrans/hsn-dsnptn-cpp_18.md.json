["```cpp\nstd::mutex m;\nMyData data;\n...\n// On several threads:\nm.lock();\ntransmogrify(data);\nm.unlock();\n```", "```cpp\n// Example 01\nstd::mutex m;\nint i = 0;\nvoid add() {\n  std::lock_guard<std::mutex> l(m);\n  ++i;\n}\n...\nstd::thread t1(add);\nstd::thread t2(add);\nt1.join();\nt2.join();\nstd::cout << i << std::endl;\n```", "```cpp\nWARNING: ThreadSanitizer: data race\n...\nLocation is global 'i' of size 4 at <address>\n```", "```cpp\n// Example 03\nstd::lock_guard l(m);\n```", "```cpp\n// Example 03\n{\n  std::jthread t1(add);\n  std::jthread t2(add);\n}\nstd::cout << i << std::endl;\n```", "```cpp\n// Example 04\ntemplate <typename T> class MutexGuarded {\n  std::mutex m_;\n  T data_ {};\n  public:\n  MutexGuarded() = default;\n  template <typename... Args>\n  explicit MutexGuarded(Args&&... args) :\n    data_(std::forward<Args>(args)...) {}\n  template <typename F> decltype(auto) operator()(F f) {\n    std::lock_guard<std::mutex> l(m_);\n    return f(data_);\n  }\n};\n```", "```cpp\n// Example 04\nMutexGuarded<int> i_guarded(0);\nvoid add() {\n  i_guarded([](int& i) { ++i; });\n}\n...\n// On many threads:\nstd::thread t1(add);\nstd::thread t2(add);\nt1.join();\nt2.join();\ni_guarded([](int i) { std::cout << i << std::endl; });\n```", "```cpp\n// Example 05\nMutexGuarded<size_t> count;\nvoid events(unsigned int s) {\n  for (size_t i = 1; i != 100; ++i) {\n    if ((rand_r(&s) % 10) == 0) { // Event!\n      count([](size_t& i) { ++i; });\n    }\n  }\n}\n```", "```cpp\n// Example 06\nMutexGuarded<size_t> count;\nvoid events(unsigned int s) {\n  size_t n = 0;\n  for (size_t i = 1; i != 100; ++i) {\n    if ((rand_r(&s) % 10) == 0) { // Event!\n      ++n;\n    }\n  }\n  if (n > 0) count([n](size_t& i) { i += n; });\n}\n```", "```cpp\n// Example 07\nvoid events(unsigned int s, size_t& n) {\n  for (size_t i = 1; i != 100; ++i) {\n    if ((rand_r(&s) % 10) == 0) ++n;\n  }\n}\n```", "```cpp\n// Example 07\nalignas(64) size_t n1 = 0;\nalignas(64) size_t n2 = 0;\nstd::thread t1(events, 1, std::ref(n1));\nstd::thread t2(events, 2, std::ref(n2));\nt1.join();\nt2.join();\nsize_t count = n1 + n2;\n```", "```cpp\n// Example 08\nstruct {\n  alignas(64) size_t n1 = 0;\n  alignas(64) size_t n2 = 0;\n} counts;\nstd::thread t1(events, 1, std::ref(counts.n1));\nstd::thread t2(events, 2, std::ref(counts.n2));\nt1.join();\nt2.join();\nsize_t count = counts.n1 + counts.n2;\n```", "```cpp\n// Example 09\ntemplate <typename IT, typename T>\nvoid clamp(IT from, IT to, T value) {\n  for (IT it = from; it != to; ++it) {\n    if (*it > value) *it = value;\n  }\n}\n```", "```cpp\n// Example 09\nstd::vector<int> data = ... data ...;\nstd::thread t1([&](){\n  clamp(data.begin(), data.begin() + data.size()/2, 42);\n});\nstd::thread t2([&](){\n  clamp(data.begin() + data.size()/2, data.end(), 42);\n});\n...\nt1.join();\nt2.join();\n```", "```cpp\n// Example 10\nvoid count_unique(std::vector<int> data, size_t& count) {\n  std::sort(data.begin(), data.end());\n  count = std::unique(data.begin(),\n                      data.end()) - data.begin();\n}\n```", "```cpp\n// Example 10\nvoid count_unique_even(std::vector<int> data, size_t& count) {\n  std::erase_if(data, [](int i) { return i & 1; });\n  std::sort(data.begin(), data.end());\n  count = std::unique(data.begin(),\n                      data.end()) - data.begin();\n}\n```", "```cpp\n// Example 10\nstd::vector<int> data = ...;\nsize_t unique_count = 0;\nsize_t unique_even_count = 0;\n{\n  std::jthread t1(count_unique, data,\n                  std::ref(unique_count));\n  std::jthread t2(count_unique_even, data,\n                  std::ref(unique_even_count));\n}\n```", "```cpp\n// Example 11\nstd::mutex m;\nstd::condition_variable cv;\nsize_t n = 0;               // Zero until work is done\n// Main thread\nvoid main_thread() {\n  std::unique_lock l(m);\n  std::thread t(produce);     // Start the worker\n  cv.wait(l, []{ return n != 0; });\n  ... producer thread is done, we have the lock ...\n}\n```", "```cpp\n// Example 11\n// Worker thread\nvoid produce() {\n  {\n    std::lock_guard l(m);\n    ... compute results ...\n    n = ... result count ...\n  } // Mutex unlocked\n  cv.notify_one();          // Waiting thread notified\n}\n```", "```cpp\n// Example 12\nstd::atomic_flag flag;\n// Worker thread:\nvoid produce() {\n  ... produce the results ...\n  flag.test_and_set(std::memory_order_release);\n}\n// Waiting thread:\nvoid main_thread() {\n  flag.clear();\n  std::thread t(produce);\n  while (!flag.test(std::memory_order_acquire)) {} // Wait\n  ... results are ready ...\n}\n```", "```cpp\n// Example 13\nstd::atomic_flag flag;\n// Worker thread:\nvoid produce() {\n  ... produce the results ...\n  flag.test_and_set(std::memory_order_release);\n  flag.notify_one();\n}\n// Waiting thread:\nvoid main_thread() {\n  flag.clear();\n  std::thread t(produce);\n  flag.wait(true, std::memory_order_acquire); // Wait\n  while (!flag.test(std::memory_order_acquire)) {}\n  ... results are ready ...\n}\n```", "```cpp\n// Example 14\n// Worker threads\nvoid produce(std::latch& latch) {\n  ... do the work ...\n  latch.count_down();     // One more thread is done\n}\nvoid main_thread() {\n  constexpr size_t nthread = 4;\n  std::jthread t[nthread];\n  std::latch latch(nthread); // Wait for 4 count_down()\n  for (size_t i = 0; i != nthread; ++i) {\n    t[i] = std::jthread(std::ref(latch));\n  }\n  latch.wait();   // Wait for producers to finish\n  ... results are ready ...\n}\n```", "```cpp\n// Example 15\nstd::atomic<size_t> count;\nvoid thread_work() {\n  size_t current_count = 0;\n  if (... counted even ...) {\n    current_count =\n      count.fetch_add(1, std::memory_order_relaxed);\n  }\n}\n```", "```cpp\n// Example 16\nstatic constexpr size_t N = 1024;\nstruct Data { ... };\nData data[N] {};\n```", "```cpp\n// Example 16\nstd::atomic<size_t> index(0);\n// Many producer threads\nvoid produce(size_t& n) {\n  while (... more work … ) {\n    const size_t s =\n      index.fetch_add(1, std::memory_order_relaxed);\n    if (s >= N) return;     // No more space\n    data[s] = ... results ...\n  }\n}\n```", "```cpp\n// Example 16\nvoid main_thread() {\n  constexpr size_t nthread = 5;\n  std::thread t[nthread];\n  for (size_t i = 0; i != nthread; ++i) {\n    t[i] = std::thread(produce);\n  }\n  // Wait for producers. to finish.\n  for (size_t i = 0; i != nthread; ++i) {\n    t[i].join();\n  }\n  ... all work is done, data is ready ...\n}\n```", "```cpp\n// Example 17\nstd::atomic<Data*> data;\nvoid produce() {\n  Data* p = new Data;\n  ... complete *p object ...\n  data.store(p, std::memory_order_release);\n}\nvoid consume() {\n  Data* p = nullptr;\n  while (!(p = data.load(std::memory_order_acquire))) {}\n  ... safe to use *p ...\n}\n```", "```cpp\n// Example 18\nconstexpr size_t N = ...;\nData data[N];     // Shared, not locked\nstd::atomic<size_t> size;\nvoid produce() {\n  for (size_t n = 0; n != N; ++n) {\n    data[n] = ... results ...\n    size.store(n, std::memory_order_release);\n  }\n}\nvoid consume() {\n  size_t n = 0;\n  do {\n    n = size.load(std::memory_order_acquire);\n    ... n elements are safe to access ...\n  } while (n < N - 1);\n}\n```", "```cpp\n// Example 19\nstatic constexpr size_t N = 1024;\nstruct Data { ... };\nstd::atomic<Data*> data[N] {};\nstd::atomic<size_t> size(0);     // Atomic index\nvoid produce() {\n  Data* p = new Data;\n  ... compute *p ...\n  const size_t s =\n    size.fetch_add(1, std::memory_order_relaxed);\n  data[s].store(p, std::memory_order_release);\n}\n```", "```cpp\n// Example 19\nvoid consumer() {\n  for (size_t i = 0; i != N; ++i) {\n    const Data* p =\n      data[i].load(std::memory_order_acquire);\n    if (!p) break; // No more data\n    ... *p is safe to access ...\n  }\n}\n```", "```cpp\ntemplate <typename T> class ts_queue {\n  std::mutex m_;\n  std::queue<T> q_;\n  public:\n  ts_queue() = default;\n  ...\n};\n```", "```cpp\ntemplate <typename T> class ts_queue {\n  public:\n  void push(const T& t) {\n    std::lock_guard l(m_);\n    q_.push(t);\n  }\n};\n```", "```cpp\ntemplate <typename T> class ts_queue {\n  public:\n  void pop() {\n    std::lock_guard l(m_);\n    q_.pop();\n  }\n};\n```", "```cpp\ntemplate <typename T> class ts_queue {\n  public:\n  T& front() const {\n    std::lock_guard l(m_);\n    return q_.front();\n  }\n};\n```", "```cpp\ntemplate <typename T> class ts_queue {\n  public:\n  bool empty() const {\n    std::lock_guard l(m_);\n    return q_.empty();\n  }\n};\n```", "```cpp\nts_queue<int> q;\nint i = 0;\nif (!q.empty()) {\n  i = q.front();\n  q.pop();\n}\n```", "```cpp\n// Example 20\ntemplate <typename T> class ts_queue {\n  std::queue<T> q_;\n  std::mutex m_;\n  public:\n  ts_queue() = default;\n  template <typename U> void push(U&& u) {\n    std::lock_guard l(m_);\n    q_.push(std::forward<U>(u));\n  }\n  std::optional<T> pop() {\n    std::lock_guard l(m_);\n    if (q_.empty()) return {};\n    std::optional<T> res(std::move(q_.front()));\n    q_.pop();\n    return res;\n }\n};\n```", "```cpp\n// Example 21\ntemplate <typename T, size_t N> class ts_queue {\n  T buffer_[N];\n  std::atomic<size_t> back_{0};\n  std::atomic<size_t> front_{N - 1};\n  ...\n};\n```", "```cpp\n// Example 21\ntemplate <typename T, size_t N> class ts_queue {\n  public:\n  template <typename U> bool push(U&& u) {\n    const size_t front =\n      front_.load(std::memory_order_acquire);\n    size_t back = back_.load(std::memory_order_relaxed);\n    if (back == front) return false;\n    buffer_[back] = std::forward<U>(u);\n    back_.store((back + 1) % N, std::memory_order_release);\n    return true;\n  }\n};\n```", "```cpp\n// Example 21\ntemplate <typename T, size_t N> class ts_queue {\n  public:\n  std::optional<T> pop() {\n    const size_t back =\n      back_.load(std::memory_order_acquire);\n    const size_t front =\n     (front_.load(std::memory_order_relaxed) + 1) % N;\n    if (front == back) return {};\n    std::optional<T> res(std::move(buffer_[front]));\n    front_.store(front, std::memory_order_release);\n    return res;\n  }\n};\n```", "```cpp\n// Example 22\nclass Job {\n  ... data ...\n  std::thread t_;\n  bool done_ {};\n  public:\n  Job(... args ...) { ... initialize data ... }\n  void operator()() {\n    t_ = std::thread([this](){ ... computations ... }\n  );\n  }\n  void wait() {\n    if (done_) return;\n    t_.join();\n    done_ = true;\n  }\n  ~Job() { wait(); }\n  auto get() { this->wait(); return ... results ...; }\n};\nJob j(... args ...);\nj();     // Execute code on a thread\n... do other work ...\nstd::cout << j.get();  // Wait for results and print them\n```", "```cpp\n// Example 23\nclass Job {\n  std::thread t_;\n  bool done_ {};\n  virtual void operator()() = 0;\n  public:\n  void wait() {\n    if (done_) return;\n    t_.join();\n    done_ = true;\n  }\n  void run() {\n    t_ = std::thread([this](){ (*this)(); });\n  }\n  virtual ~Job() { wait(); }\n};\n```", "```cpp\n// Example 23\nclass TheJob final : public Job {\n  ... data ...\n  void operator()() override { ... work ... }\n  public:\n  TheJob(... args ...) {\n    ... initialize data ...\n    this->run();\n  }\n  auto get() { this->wait(); return ... results ...; }\n};\n```", "```cpp\n// Example 23\nTheJob j1(... args ...);\nTheJob j2(... args ...);\n... do other stuff ...\nstd::cout << \"Results: \" << j1.get() << \" \" << j2.get();\n```", "```cpp\n// Example 24\nclass Job {\n  bool done_ {};\n  std::function<void()> f_;\n  std::thread t_;\n  public:\n  template <typename F> explicit Job(F&& f) :\n    f_(f), t_(f_) {}\n  void wait() {\n     if (done_) return;\n     t_.join();\n     done_ = true;\n  }\n  ~Job() { wait(); }\n};\n```", "```cpp\n// Example 24\nclass TheJob {\n  ... data ...\n  public:\n  TheJob(... args ...) { ... initialize data ... }\n  void operator()() { // Callable!\n    ... do the work ...\n  }\n};\nJob j(TheJob(... args ...));\nj.wait();\n```", "```cpp\n// Example 24\nclass TheJob {\n  ... data ...\n  double& res_; // Result\n  public:\n  TheJob(double& res, ... args ...) : res_(res) {\n    ... initialize data ...\n  }\n  void operator()() { // Callable!\n    ... do the work ...\n    res_ = ... result ...\n  }\n};\ndouble res = 0;\nJob j(TheJob(res, ... args ...));\nj.wait();\nstd::cout << res;\n```", "```cpp\n// Example 25\nclass Reactor {\n  static constexpr size_t N = 1024;\n  Data data_[N] {};\n  std::atomic<size_t> size_{0};\n  public:\n  bool operator()(... args ...) {\n    const size_t s =\n      size_.fetch_add(1, std::memory_order_acq_rel);\n    if (s >= N) return false;  // Array is full\n    data_[s] = ... result ...;\n    return true;\n  }\n  void print_results() { ... }\n};\n```", "```cpp\n// Example 26\nclass Proactor {\n  using callback_t = std::function<void(size_t, double)>;\n  struct op_task {\n    size_t n;\n    callback_t f;\n  };\n  std::atomic<bool> done_{false}; // Must come before t_\n  ts_queue<op_task> q_;           // Must come before t_\n  std::thread t_;\n  public:\n  Proactor() : t_([this]() {\n    while (true) {\n      auto task = q_.pop();\n      if (!task) {                // Queue is empty\n        if (done_.load(std::memory_order_relaxed)) {\n          return;                 // Work is done\n        }\n        continue;                 // Wait for more work\n      }\n      ... do the work ...\n      double x = ... result ...\n      task->f(n, x);\n    } // while (true)\n  }) {}\n  template <typename F>\n  void operator()(size_t n, F&& f) {\n    q_.push(op_task{n, std::forward<F>(f)});\n  }\n  ~Proactor() {\n    done_.store(true, std::memory_order_relaxed);\n    t_.join();\n  }\n};\n```", "```cpp\n// Example 26\nProactor p;\nfor (size_t n : ... all inputs ...) {\n  p(n, [](double x) { std::cout << x << std::endl; });\n}\n```", "```cpp\n// Example 27\nstatic constexpr size_t N = 1UL << 16;\nstruct Data {... data ... };\nData data[N] {};\nstd::atomic<size_t> index(0);\nvoid produce(std::atomic<size_t>& count) {\n  for (size_t n = 0; ; ++n) {\n    const size_t s =\n      index.fetch_add(1, std::memory_order_acq_rel);\n    if (s >= N) return;\n    const int niter = 1 << (8 + data[s].n);\n    data[s] = ... result ...\n    count.store(n + 1, std::memory_order_relaxed);\n  }\n}\n```", "```cpp\n// Example 27\nstd::thread t[nthread];\nstd::atomic<size_t> work_count[nthread] = {};\nfor (size_t i = 0; i != nthread; ++i) {\n  t[i] = std::thread(produce, std::ref(work_count[i]));\n}\n```", "```cpp\n// Example 27\nstd::atomic<bool> done {false};\nstd::thread monitor([&]() {\n  auto print = [&]() { ... print work_count[] ... };\n  std::cout << \"work counts:\" << std::endl;\n  while (!done.load(std::memory_order_relaxed)) {\n    std::this_thread::sleep_for(\n      std::chrono::duration<double, std::milli>(500));\n    print();\n  }\n  print();\n});\n```", "```cpp\nwork counts:\n1096 1083 957 1046 1116 -> 5298/65536\n2286 2332 2135 2242 2335 -> 11330/65536\n...\n13153 13061 13154 12979 13189 -> 65536/65536\n13153 13061 13154 12979 13189 -> 65536/65536\n```", "```cpp\n// Example 27\ndone.store(true, std::memory_order_relaxed);\nmonitor.join();\n```", "```cpp\nsize_t*** a; // 3D array\nfor (size_t i = 0; i < N1; ++i) {\n  for (size_t j = 0; j < N2; ++j) {\n    for (size_t k = 0; k < N3; ++k) {\n      ... do work with a[i][j][k] ...\n    }\n  }\n}\n```", "```cpp\n// Example 28\nclass Iterator {\n  const size_t N1, N2, N3;\n  size_t*** const a;\n  size_t i = 0, j = 0, k = 0;\n  bool done = false;\n  public:\n  Iterator(size_t*** a, size_t N1, size_t N2, size_t N3) :\n    N1(N1), N2(N2), N3(N3), a(a) {}\n  bool next(size_t& x) {\n    if (done) return false;\n    x = a[i][j][k];\n    if (++k == N3) {\n      k = 0;\n      if (++j == N2) {\n        j = 0;\n        if (++i == N1) return (done = true);\n      }\n    }\n    return true;\n  }\n};\n```", "```cpp\n// Example 28\nIterator it(a, N1, N2, N3);\nsize_t val;\nwhile (it.next(val)) {\n  ... val is the current array element ...\n}\n```", "```cpp\n// Example 28\ngenerator<size_t>\ncoro(size_t*** a, size_t N1, size_t N2, size_t N3) {\n  for (size_t i = 0; i < N1; ++i) {\n    for (size_t j = 0; j < N2; ++j) {\n      for (size_t k = 0; k < N3; ++k) {\n        co_yield a[i][j][k];\n      }\n    }\n  }\n}\n```", "```cpp\n// Example 28\nauto gen = coro(a, N1, N2, N3);\nwhile (true) {\n  const size_t val = gen();\n  if (!gen) break;\n  ... val is the current array element ...\n}\n```", "```cpp\nIterator time: 9.20286e-10 s/iteration\nGenerator time: 6.39555e-10 s/iteration\n```", "```cpp\nIterator time: 6.46543e-10 s/iteration\nGenerator time: 1.99748e-09 s/iteration\n```", "```cpp\n// Example 29\ngenerator<size_t> coro(size_t i) {\n  while (true) {\n    constexpr size_t m = 1234567890, k = 987654321;\n    for (size_t j = 0; j != 11; ++j) {\n      if (1) i = (i + k) % m; else ++i;\n    }\n    co_yield i;\n  }\n}\n```", "```cpp\n// Example 29\nauto gen = coro(42);\nsize_t random_number = gen();\n```"]