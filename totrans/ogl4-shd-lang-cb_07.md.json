["```cpp\nglGetIntegerv(GL_MAX_PATCH_VERTICES, &maxVerts);\n```", "```cpp\nglPatchParameteri( GL_PATCH_VERTICES, numPatchVerts ); \n```", "```cpp\nlayout (location = 0) in vec3 VertexPosition;\nuniform mat4 ModelViewMatrix;\n\nvoid main(){\n    gl_Position = ModelViewMatrix * vec4(VertexPosition,1.0);\n}\n```", "```cpp\nlayout( points ) in; \nlayout( triangle_strip, max_vertices = 4 ) out; \n\nuniform float Size2;   // Half the width of the quad \n\nuniform mat4 ProjectionMatrix; \n\nout vec2 TexCoord; \n\nvoid main() {\n    mat4 m = ProjectionMatrix;  // Reassign for brevity \n\n    gl_Position = m * (vec4(-Size2,-Size2,0.0,0.0) +  \n                       gl_in[0].gl_Position); \n    TexCoord = vec2(0.0,0.0); \n    EmitVertex(); \n\n    gl_Position = m * (vec4(Size2,-Size2,0.0,0.0) +  \n                       gl_in[0].gl_Position); \n    TexCoord = vec2(1.0,0.0); \n    EmitVertex(); \n\n    gl_Position = m * (vec4(-Size2,Size2,0.0,0.0) +  \n                       gl_in[0].gl_Position); \n    TexCoord = vec2(0.0,1.0); \n    EmitVertex(); \n\n    gl_Position = m * (vec4(Size2,Size2,0.0,0.0) +  \n                       gl_in[0].gl_Position); \n    TexCoord = vec2(1.0,1.0); \n    EmitVertex(); \n\n    EndPrimitive(); \n} \n```", "```cpp\nin vec2 TexCoord;  // From the geometry shader \n\nuniform sampler2D SpriteTex; \n\nlayout( location = 0 ) out vec4 FragColor; \n\nvoid main() {\n    FragColor = texture(SpriteTex, TexCoord); \n} \n```", "```cpp\nlayout( points ) in; \n```", "```cpp\nlayout( triangle_strip, max_vertices = 4 ) out; \n```", "```cpp\nlayout (location = 0 ) in vec3 VertexPosition; \nlayout (location = 1 ) in vec3 VertexNormal; \n\nout vec3 VNormal; \nout vec3 VPosition; \n\nuniform mat4 ModelViewMatrix; \nuniform mat3 NormalMatrix; \nuniform mat4 ProjectionMatrix; \nuniform mat4 MVP; \n\nvoid main() {\n    VNormal = normalize( NormalMatrix * VertexNormal); \n    VPosition = vec3(ModelViewMatrix *  \n                     vec4(VertexPosition,1.0)); \n    gl_Position = MVP * vec4(VertexPosition,1.0); \n} \n```", "```cpp\nlayout( triangles ) in; \nlayout( triangle_strip, max_vertices = 3 ) out; \n\nout vec3 GNormal; \nout vec3 GPosition; \nnoperspective out vec3 GEdgeDistance; \n\nin vec3 VNormal[]; \nin vec3 VPosition[]; \n\nuniform mat4 ViewportMatrix;  // Viewport matrix \n\nvoid main() {\n    // Transform each vertex into viewport space \n    vec3 p0 = vec3(ViewportMatrix * (gl_in[0].gl_Position /  \n                             gl_in[0].gl_Position.w)); \n    vec3 p1 = vec3(ViewportMatrix * (gl_in[1].gl_Position /  \n                             gl_in[1].gl_Position.w)); \n    vec3 p2 = vec3(ViewportMatrix * (gl_in[2].gl_Position /  \n                            gl_in[2].gl_Position.w)); \n\n    // Find the altitudes (ha, hb and hc) \n    float a = length(p1 - p2); \n    float b = length(p2 - p0); \n    float c = length(p1 - p0); \n    float alpha = acos( (b*b + c*c - a*a) / (2.0*b*c) ); \n    float beta = acos( (a*a + c*c - b*b) / (2.0*a*c) ); \n    float ha = abs( c * sin( beta ) ); \n    float hb = abs( c * sin( alpha ) ); \n    float hc = abs( b * sin( alpha ) ); \n\n    // Send the triangle along with the edge distances \n    GEdgeDistance = vec3( ha, 0, 0 ); \n    GNormal = VNormal[0]; \n    GPosition = VPosition[0]; \n    gl_Position = gl_in[0].gl_Position; \n    EmitVertex(); \n\n    GEdgeDistance = vec3( 0, hb, 0 ); \n    GNormal = VNormal[1]; \n    GPosition = VPosition[1]; \n    gl_Position = gl_in[1].gl_Position; \n    EmitVertex(); \n\n    GEdgeDistance = vec3( 0, 0, hc ); \n    GNormal = VNormal[2]; \n    GPosition = VPosition[2]; \n    gl_Position = gl_in[2].gl_Position; \n    EmitVertex(); \n\n    EndPrimitive(); \n} \n```", "```cpp\n// *** Insert appropriate uniforms for the Blinn-Phong model *** \n\n// The mesh line settings \nuniform struct LineInfo { \n  float Width; \n  vec4 Color; \n} Line; \n\nin vec3 GPosition; \nin vec3 GNormal; \nnoperspective in vec3 GEdgeDistance; \n\nlayout( location = 0 ) out vec4 FragColor; \nvec3 blinnPhong( vec3 pos, vec3 norm ) {\n   // ...\n}\n\nvoid main() { \n    // The shaded surface color. \n    vec4 color=vec4(blinnPhong(GPosition, GNormal), 1.0); \n\n    // Find the smallest distance \n    float d = min( GEdgeDistance.x, GEdgeDistance.y ); \n    d = min( d, GEdgeDistance.z ); \n\n    // Determine the mix factor with the line color \n    float mixVal = smoothstep( Line.Width - 1, \n                               Line.Width + 1, d ); \n\n    // Mix the surface color with the line color \n    FragColor = mix( Line.Color, color, mixVal ); \n} \n```", "```cpp\nlayout( triangles ) in; \nlayout( triangle_strip, max_vertices = 3 ) out; \n```", "```cpp\nnoperspective out vec3 GEdgeDistance;\n```", "```cpp\nfloat mixVal = smoothstep( Line.Width - 1, \n                           Line.Width + 1, d ); \n```", "```cpp\nlayout (location = 0 ) in vec3 VertexPosition; \nlayout (location = 1 ) in vec3 VertexNormal; \n\nout vec3 VNormal; \nout vec3 VPosition; \n\nuniform mat4 ModelViewMatrix; \nuniform mat3 NormalMatrix; \nuniform mat4 ProjectionMatrix; \nuniform mat4 MVP; \nvoid main() {\n    VNormal = normalize( NormalMatrix * VertexNormal); \n    VPosition = vec3(ModelViewMatrix *  \n                     vec4(VertexPosition,1.0)); \n    gl_Position = MVP * vec4(VertexPosition,1.0); \n} \n```", "```cpp\nlayout( triangles_adjacency ) in; \nlayout( triangle_strip, max_vertices = 15 ) out; \n\nout vec3 GNormal; \nout vec3 GPosition; \n\n// Which output primitives are silhouette edges \nflat out bool GIsEdge; \n\nin vec3 VNormal[];   // Normal in camera coords. \nin vec3 VPosition[]; // Position in camera coords. \n\nuniform float EdgeWidth;  // Width of sil. edge in clip cds. \nuniform float PctExtend;  // Percentage to extend quad \n\nbool isFrontFacing( vec3 a, vec3 b, vec3 c ) {\n    return ((a.x * b.y - b.x * a.y) +  \n            (b.x * c.y - c.x * b.y) + \n            (c.x * a.y - a.x * c.y)) > 0; \n} \nvoid emitEdgeQuad( vec3 e0, vec3 e1 ) {\n    vec2 ext = PctExtend * (e1.xy - e0.xy); \n    vec2 v = normalize(e1.xy - e0.xy); \n    vec2 n = vec2(-v.y, v.x) * EdgeWidth; \n\n    // Emit the quad \n    GIsEdge = true;   // This is part of the sil. edge \n\n    gl_Position = vec4( e0.xy - ext, e0.z, 1.0 );  \n    EmitVertex(); \n    gl_Position = vec4( e0.xy - n - ext, e0.z, 1.0 );  \n    EmitVertex(); \n    gl_Position = vec4( e1.xy + ext, e1.z, 1.0 );  \n    EmitVertex(); \n    gl_Position = vec4( e1.xy - n + ext, e1.z, 1.0 ); \n    EmitVertex(); \n\n    EndPrimitive(); \n} \n\nvoid main() {\n    vec3 p0 = gl_in[0].gl_Position.xyz /  \n              gl_in[0].gl_Position.w; \n    vec3 p1 = gl_in[1].gl_Position.xyz /  \n              gl_in[1].gl_Position.w; \n    vec3 p2 = gl_in[2].gl_Position.xyz /  \n              gl_in[2].gl_Position.w; \n    vec3 p3 = gl_in[3].gl_Position.xyz /  \n              gl_in[3].gl_Position.w; \n    vec3 p4 = gl_in[4].gl_Position.xyz /  \n              gl_in[4].gl_Position.w; \n    vec3 p5 = gl_in[5].gl_Position.xyz /  \n              gl_in[5].gl_Position.w; \n\n    if( isFrontFacing(p0, p2, p4) ) { \n        if( ! isFrontFacing(p0,p1,p2) )  \n                    emitEdgeQuad(p0,p2); \n        if( ! isFrontFacing(p2,p3,p4) )  \n                    emitEdgeQuad(p2,p4); \n        if( ! isFrontFacing(p4,p5,p0) )  \n                    emitEdgeQuad(p4,p0); \n    } \n\n    // Output the original triangle \n    GIsEdge = false; // Triangle is not part of an edge. \n\n    GNormal = VNormal[0]; \n    GPosition = VPosition[0]; \n    gl_Position = gl_in[0].gl_Position; \n    EmitVertex(); \n    GNormal = VNormal[2]; \n    GPosition = VPosition[2]; \n    gl_Position = gl_in[2].gl_Position; \n    EmitVertex();\n    GNormal = VNormal[4]; \n    GPosition = VPosition[4]; \n    gl_Position = gl_in[4].gl_Position; \n    EmitVertex(); \n\n    EndPrimitive(); \n}\n```", "```cpp\n//*** Light and material uniforms... **** \n\nuniform vec4 LineColor;  // The sil. edge color \n\nin vec3 GPosition;  // Position in camera coords \nin vec3 GNormal;    // Normal in camera coords. \n\nflat in bool GIsEdge; // Whether or not we're drawing an edge \n\nlayout( location = 0 ) out vec4 FragColor; \n\nvec3 toonShade( ) {\n   // *** toon shading algorithm from Chapter 4 *** \n} \n\nvoid main() {\n    // If we're drawing an edge, use constant color,  \n    // otherwise, shade the poly. \n    if( GIsEdge ) { \n        FragColor = LineColor; \n    } else { \n        FragColor = vec4( toonShade(), 1.0 ); \n    }\n} \n```", "```cpp\nlayout( triangles_adjacency ) in; \nlayout( triangle_strip, max_vertices = 15 ) out;\n```", "```cpp\nlayout (location = 0 ) in vec2 VertexPosition; \n\nvoid main() {\n    gl_Position = vec4(VertexPosition, 0.0, 1.0); \n} \n```", "```cpp\nlayout( vertices=4 ) out; \n\nuniform int NumSegments; \nuniform int NumStrips; \n\nvoid main() {\n    // Pass along the vertex position unmodified \n    gl_out[gl_InvocationID].gl_Position =  \n              gl_in[gl_InvocationID].gl_Position; \n    // Define the tessellation levels \n    gl_TessLevelOuter[0] = float(NumStrips); \n    gl_TessLevelOuter[1] = float(NumSegments); \n} \n```", "```cpp\nlayout( isolines ) in; \nuniform mat4 MVP;  // projection * view * model \n\nvoid main() {\n    // The tessellation u coordinate \n    float u = gl_TessCoord.x; \n\n    // The patch vertices (control points) \n    vec3 p0 = gl_in[0].gl_Position.xyz; \n    vec3 p1 = gl_in[1].gl_Position.xyz; \n    vec3 p2 = gl_in[2].gl_Position.xyz; \n    vec3 p3 = gl_in[3].gl_Position.xyz; \n\n    float u1 = (1.0 - u); \n    float u2 = u * u; \n\n    // Bernstein polynomials evaluated at u \n    float b3 = u2 * u; \n    float b2 = 3.0 * u2 * u1; \n    float b1 = 3.0 * u * u1 * u1; \n    float b0 = u1 * u1 * u1; \n\n    // Cubic Bezier interpolation \n    vec3 p = p0 * b0 + p1 * b1 + p2 * b2 + p3 * b3; \n\n    gl_Position = MVP * vec4(p, 1.0); \n\n} \n```", "```cpp\nuniform vec4 LineColor; \n\nlayout ( location = 0 ) out vec4 FragColor; \n\nvoid main() {\n    FragColor = LineColor; \n} \n```", "```cpp\nglPatchParameteri( GL_PATCH_VERTICES, 4); \n```", "```cpp\nglDrawArrays(GL_PATCHES, 0, 4); \n```", "```cpp\nlayout (vertices = 4) out; \n```", "```cpp\nlayout (isolines) in; \n```", "```cpp\nlayout (location = 0 ) in vec2 VertexPosition; \n\nvoid main() {\n    gl_Position = vec4(VertexPosition, 0.0, 1.0); \n}\n```", "```cpp\nlayout( vertices=4 ) out; \n\nuniform int Outer; \nuniform int Inner; \nvoid main() {\n    // Pass along the vertex position unmodified \n    gl_out[gl_InvocationID].gl_Position =  \n               gl_in[gl_InvocationID].gl_Position; \n\n    gl_TessLevelOuter[0] = float(Outer); \n    gl_TessLevelOuter[1] = float(Outer); \n    gl_TessLevelOuter[2] = float(Outer); \n    gl_TessLevelOuter[3] = float(Outer); \n\n    gl_TessLevelInner[0] = float(Inner); \n    gl_TessLevelInner[1] = float(Inner); \n}\n```", "```cpp\nlayout( quads, equal_spacing, ccw ) in; \n\nuniform mat4 MVP; \n\nvoid main() {\n    float u = gl_TessCoord.x; \n    float v = gl_TessCoord.y; \n\n    vec4 p0 = gl_in[0].gl_Position; \n    vec4 p1 = gl_in[1].gl_Position; \n    vec4 p2 = gl_in[2].gl_Position; \n    vec4 p3 = gl_in[3].gl_Position; \n\n    // Linear interpolation \n    gl_Position = \n        p0 * (1-u) * (1-v) + \n        p1 * u * (1-v) + \n        p3 * v * (1-u) + \n        p2 * u * v; \n\n    // Transform to clip coordinates \n    gl_Position = MVP * gl_Position; \n} \n```", "```cpp\nuniform float LineWidth; \nuniform vec4 LineColor; \nuniform vec4 QuadColor; \n\nnoperspective in vec3 GEdgeDistance;  // From geom. shader \n\nlayout ( location = 0 ) out vec4 FragColor; \n\nfloat edgeMix() {\n   // ** insert code here to determine how much of the edge \n   // color to include (see recipe \"Drawing a wireframe on \n   // top of a shaded mesh\").  ** \n} \n\nvoid main() {\n    float mixVal = edgeMix(); \n\n    FragColor = mix( QuadColor, LineColor, mixVal );\n} \n```", "```cpp\nglPatchParameteri(GL_PATCH_VERTICES, 4); \n```", "```cpp\nlayout (vertices=4) out; \n```", "```cpp\nlayout ( quads, equal_spacing, ccw ) in; \n```", "```cpp\nlayout( vertices=16 ) out; \n\nuniform int TessLevel; \n\nvoid main() {\n    // Pass along the vertex position unmodified \n    gl_out[gl_InvocationID].gl_Position =  \n                 gl_in[gl_InvocationID].gl_Position; \n\n    gl_TessLevelOuter[0] = float(TessLevel); \n    gl_TessLevelOuter[1] = float(TessLevel); \n    gl_TessLevelOuter[2] = float(TessLevel); \n    gl_TessLevelOuter[3] = float(TessLevel); \n\n    gl_TessLevelInner[0] = float(TessLevel); \n    gl_TessLevelInner[1] = float(TessLevel); \n}\n```", "```cpp\nlayout( quads ) in; \nout vec3 TENormal;   // Vertex normal in camera coords. \nout vec4 TEPosition; // Vertex position in camera coords \n\nuniform mat4 MVP; \nuniform mat4 ModelViewMatrix; \nuniform mat3 NormalMatrix; \n\nvoid basisFunctions(out float[4] b, out float[4] db, float t) {\n    float t1 = (1.0 - t); \n    float t12 = t1 * t1; \n\n    // Bernstein polynomials \n    b[0] = t12 * t1; \n    b[1] = 3.0 * t12 * t; \n    b[2] = 3.0 * t1 * t * t; \n    b[3] = t * t * t; \n\n    // Derivatives \n    db[0] = -3.0 * t1 * t1; \n    db[1] = -6.0 * t * t1 + 3.0 * t12; \n    db[2] = -3.0 * t * t + 6.0 * t * t1; \n    db[3] = 3.0 * t * t; \n} \n\nvoid main() {\n    float u = gl_TessCoord.x; \n    float v = gl_TessCoord.y; \n\n    // The sixteen control points \n    vec4 p00 = gl_in[0].gl_Position; \n    vec4 p01 = gl_in[1].gl_Position; \n    vec4 p02 = gl_in[2].gl_Position; \n    vec4 p03 = gl_in[3].gl_Position; \n    vec4 p10 = gl_in[4].gl_Position; \n    vec4 p11 = gl_in[5].gl_Position; \n    vec4 p12 = gl_in[6].gl_Position; \n    vec4 p13 = gl_in[7].gl_Position; \n    vec4 p20 = gl_in[8].gl_Position; \n    vec4 p21 = gl_in[9].gl_Position; \n    vec4 p22 = gl_in[10].gl_Position; \n    vec4 p23 = gl_in[11].gl_Position; \n    vec4 p30 = gl_in[12].gl_Position; \n    vec4 p31 = gl_in[13].gl_Position; \n    vec4 p32 = gl_in[14].gl_Position; \n    vec4 p33 = gl_in[15].gl_Position; \n    // Compute basis functions \n    float bu[4], bv[4];   // Basis functions for u and v \n    float dbu[4], dbv[4]; // Derivitives for u and v \n    basisFunctions(bu, dbu, u); \n    basisFunctions(bv, dbv, v); \n\n    // Bezier interpolation \n    TEPosition = \n     p00*bu[0]*bv[0] + p01*bu[0]*bv[1] + p02*bu[0]*bv[2] +  \n     p03*bu[0]*bv[3] + \n     p10*bu[1]*bv[0] + p11*bu[1]*bv[1] + p12*bu[1]*bv[2] +  \n     p13*bu[1]*bv[3] + \n     p20*bu[2]*bv[0] + p21*bu[2]*bv[1] + p22*bu[2]*bv[2] +  \n     p23*bu[2]*bv[3] + \n     p30*bu[3]*bv[0] + p31*bu[3]*bv[1] + p32*bu[3]*bv[2] +  \n     p33*bu[3]*bv[3]; \n\n    // The partial derivatives \n    vec4 du = \n     p00*dbu[0]*bv[0]+p01*dbu[0]*bv[1]+p02*dbu[0]*bv[2]+  \n     p03*dbu[0]*bv[3]+ \n     p10*dbu[1]*bv[0]+p11*dbu[1]*bv[1]+p12*dbu[1]*bv[2]+  \n     p13*dbu[1]*bv[3]+ \n     p20*dbu[2]*bv[0]+p21*dbu[2]*bv[1]+p22*dbu[2]*bv[2]+  \n     p23*dbu[2]*bv[3]+ \n     p30*dbu[3]*bv[0]+p31*dbu[3]*bv[1]+p32*dbu[3]*bv[2]+  \n     p33*dbu[3]*bv[3]; \n\n    vec4 dv = \n     p00*bu[0]*dbv[0]+p01*bu[0]*dbv[1]+p02*bu[0]*dbv[2]+  \n     p03*bu[0]*dbv[3]+ \n     p10*bu[1]*dbv[0]+p11*bu[1]*dbv[1]+p12*bu[1]*dbv[2]+  \n     p13*bu[1]*dbv[3]+ \n     p20*bu[2]*dbv[0]+p21*bu[2]*dbv[1]+p22*bu[2]*dbv[2]+  \n     p23*bu[2]*dbv[3]+ \n     p30*bu[3]*dbv[0]+p31*bu[3]*dbv[1]+p32*bu[3]*dbv[2]+  \n     p33*bu[3]*dbv[3]; \n\n    // The normal is the cross product of the partials \n    vec3 n = normalize( cross(du.xyz, dv.xyz) ); \n\n    // Transform to clip coordinates \n    gl_Position = MVP * TEPosition; \n\n    // Convert to camera coordinates \n    TEPosition = ModelViewMatrix * TEPosition; \n    TENormal = normalize(NormalMatrix * n); \n}\n```", "```cpp\nglPatchParameteri(GL_PATCH_VERTICES, 16); \n```", "```cpp\nlayout( vertices=16 ) out; \n```", "```cpp\nlayout( vertices=16 ) out; \n\nuniform int MinTessLevel; \nuniform int MaxTessLevel; \nuniform float MaxDepth; \nuniform float MinDepth; \n\nuniform mat4 ModelViewMatrix; \n\nvoid main() {\n    // Position in camera coordinates \n    vec4 p = ModelViewMatrix *  \n                   gl_in[gl_InvocationID].gl_Position; \n\n    // \"Distance\" from camera scaled between 0 and 1 \n    float depth = clamp( (abs(p.z) - MinDepth) /  \n                         (MaxDepth - MinDepth), 0.0, 1.0 ); \n\n    // Interpolate between min/max tess levels \n    float tessLevel =  \n          mix(MaxTessLevel, MinTessLevel, depth); \n\n    gl_TessLevelOuter[0] = float(tessLevel); \n    gl_TessLevelOuter[1] = float(tessLevel); \n    gl_TessLevelOuter[2] = float(tessLevel); \n    gl_TessLevelOuter[3] = float(tessLevel); \n\n    gl_TessLevelInner[0] = float(tessLevel); \n    gl_TessLevelInner[1] = float(tessLevel); \n\n    gl_out[gl_InvocationID].gl_Position =  \n                  gl_in[gl_InvocationID].gl_Position; \n} \n```"]