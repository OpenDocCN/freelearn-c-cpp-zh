- en: Finalizing Your Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how to create the game; in this chapter,
    we will finish the **Gameloop** so that you can play the game. The objective of
    the game is to make sure that none of the enemies are able to make it to the left
    of the screen. If they do, it is game over.
  prefs: []
  type: TYPE_NORMAL
- en: We will add a scoring system so that the player knows how much they have scored
    in a round. For each enemy that is shot down, the player will get one point. We
    will also add text to the game in order to display the title of the game, the
    player's score, and a small tutorial that shows you how to play the game.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we will embellish the game. We will add audio that
    will be used as background music, as well as sound effects for when the player
    shoots the rocket and when the player's rockets hit the enemy. We will also add
    some animation to the player so that the character looks more lively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the Gameloop and adding scoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding player animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the Gameloop and adding scoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will show you how to finish the Gameloop and add scoring
    to the game code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add two new variables to the `source.cpp` file: one of the `int` type, called
    `score`, and one of the `bool` type, called `gameover`. Initialize the score to
    `0` and `gameover` to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new function called `reset()`. We will use this to reset the variables.
    Create a prototype for the reset function at the top of the `source.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'At the bottom of the `source.cpp` file, after where we created the `checkCollision`
    function, add the reset function itself so that when the game resets, all the
    values are also reset. To do this, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the game is over, pressing the down arrow key once will restart the game.
    Once the game starts again, the `reset()` function will be called. In the `reset()`
    function, we need to set `score`, `currentTime`, and `prevTime` to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: When the game resets, remove any instantiated enemy and rocket objects by deleting
    and thus freeing the memory. This also clears the vectors that were holding a
    reference to the now-deleted objects. Now that we've set up the variables and
    the reset function, let's use them in the game to reset the values when we restart
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `UpdateInput` function, in the `while` loop, where we check whether
    the down arrow key on the keyboard was pressed, we will add an `if` condition
    to check whether the game is over. If it is over, we''ll set the `gameover` bool
    to `false` so that the game is ready to start, and we''ll reset the variables
    by calling the `reset` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `shoot()` is moved into an `else` statement so that the player can only
    shoot if the game is running.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will set the `gameover` condition to `true` when an enemy goes beyond
    the left-hand side of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: When we update the enemies, the enemy will be deleted when it disappears from
    the screen, and we will also set the `gameover` condition to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code for updating the enemies to the `update()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we want to update the game if `gameover` is `false`. In the `main` function,
    before we update the game, we will add a check to find out whether the game is
    over. If the game is over, we will not update the game. To do this, use the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also increase the score when the rocket collides with an enemy. This
    means that, in the `update()` function, when we delete the rocket and enemy after
    the intersection, we will also update the score:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When you run the game, start the game by pressing the down arrow key. When one
    of the enemies goes past the left-side of the screen, the game will end. When
    you press the down arrow key again, the game will restart.
  prefs: []
  type: TYPE_NORMAL
- en: The gameloop is now complete, but we still can't see the score. To do this,
    let's add some text to the game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps will guide you through how to add text to the game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `sf::Font` called `headingFont` so that we can load the font and
    then use it to display the name of the game. At the top of the screen, where we
    created all the variables, create the `headingFont` variable, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `init()` function, right after we loaded `bgSprite`, load the font using
    the `loadFromFile` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since we will need a font to be loaded in from the system, we have to place
    the font in the `fonts` directory, which can be found under the `Assets` directory.
    Make sure you place the font file there. The font we will be using for the heading
    is the `SnackerComic.ttf` file. I have also included the `arial.ttf` file, which
    we will use to display the score, so make sure you add that as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `headingText` variable using the `sf::Text` type so that we can
    display the heading of the game. Do this at the start of the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `init()` function, after loading `headingFont`, we will add the code
    to create the heading for the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We need to set the font for the heading text using the `setFont` function. In
    `setFont`, pass the `headingFont` variable that we just created.
  prefs: []
  type: TYPE_NORMAL
- en: We need to tell `headingText` what needs to be displayed. For that, we will
    use the `setString` function and pass in the `TinyBazooka` string since that is
    the name of the game we just made. Pretty cool name, huh?
  prefs: []
  type: TYPE_NORMAL
- en: Let's set the size of the font itself. To do this, we will use the `setCharacterSize`
    function and pass in `84` as the size in pixels so that it is clearly visible.
    Now, we can set the color to red using the `setFillColor` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want the heading to be centered on the viewport, so we will get the bounds
    of the text and set its origin to the `center` of the viewport in the *x* and
    *y* directions. Set the position of the text so that it''s at the center of the
    x-direction and `0.10` of the height from the top along the *y-*direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To display the text, call `window.draw` and pass `headingText` into it. We
    also want the text to be drawn when the game is over. To do this, add an `if`
    statement, which checks whether the game is over:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the game. You will see the name of the game displayed at the top:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/510dff6d-749c-4ea1-b678-2633b15c2de8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We still can''t see the score, so let''s add a `Font` variable and a `Text`
    variable and call them `scoreFont` and `scoreText`, respectively. In the `scoreFont`
    variable, load the `arial.ttf` font and set the text for the score using the `scoreText`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the `ScoreFont` string and then set the `ScoreText` string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set the `scoreText` string to a score of `0`, which we will change
    once the score increases. Set the size of the font to `45`.
  prefs: []
  type: TYPE_NORMAL
- en: Set the score so that it's in the same position as `headingText` since it will
    only be displayed when the game is over. When the game is running, `scoreText`
    will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `update` function, where we update the score, update `scoreText`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, we created a new string called `finalScore`. Here, we set
    the `"Score: "` string and concatenated it with the score, which is an int that''s
    been converted into a string by the `toString` property of the string class. Then,
    we used the `setString` function of `sf::Text` to set the string. We had to get
    the new bounds of the text since the text would have changed. Set the origin,
    center, and position of the updated text.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `draw` function, create a new `else` statement. If the game is not over,
    draw `scoreText`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Reset the `scoreText` in the `reset()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When you run the game now, the score will continue to update. The values will
    reset when you restart the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scoring system looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90966be4-23ea-4a5e-a791-edfeb143c100.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a tutorial so that the player knows what to do when the game starts. Create
    a new `sf::Text` called `tutorialText`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the text after `scoreText` in the `init()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We only want to show the tutorial at the start of the game, along with the
    heading text. Add the following code to the `draw` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you start the game, the player will see that the game will start
    if they press the down arrow key. They will also know that, when the game is running,
    they can press the down arrow key to shoot a rocket and use the up arrow key to
    jump. The following screenshot shows this on screen text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cde74d7-42db-418a-8c2f-633fc5ce9313.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add some audio to the game to make it a little more interesting. This
    will also provide audio feedback to the player to tell them whether the rocket
    was fired or an enemy was hit.
  prefs: []
  type: TYPE_NORMAL
- en: SFML supports `.wav` or `.ogg` files, but it doesn't support `.mp3` files. For
    this project, all the files will be in the `.ogg` file format as it is good for
    compression and is also cross-platform compatible. To start, place the audio files
    in the `Audio` directory in the `Assets` folder of the system. With the audio
    files in place, we can start playing the audio files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Audio files can be of two types:'
  prefs: []
  type: TYPE_NORMAL
- en: The background music, which is of a longer duration and a much higher quality
    than other files in the game. These files are played using the `sf::Music` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other sound files, such as sound effects – which are smaller in size and sometimes
    of lower quality – are played using the `sf::Sound` class. To play the files,
    you also need an `sf::SoundBuffer` class, which is used to store the file and
    play it later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To add audio to the game, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s play the background music file, `bgMusic.ogg`. Audio files use the `Audio.hpp`
    header, which needs to be included at the top of the `main.cpp` file. This can
    be done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of the `main.cpp` file, create a new instance of `sf::Music` and
    call it `bgMusic`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `init()` function, add the following lines to open the `bgMusic.ogg`
    file and play the `bgMusic` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Run the game. You will hear the background music playing as soon as the game
    starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To add the sound files that are for the rockets being fired and the enemies
    being hit, we need two sound buffers to store both of the effects and two sound
    files to play the sound files. Create two variables of the `sf::SoundBuffer` type
    called `fireBuffer` and `hitBuffer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create two `sf::Sound` variables called `fireSound` and `hitSound`. Both
    can be initialized by being passed into their respective buffers, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `init` function, initialize the buffers first, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When the rocket intersects with the enemy, we will play the `hitSound` effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `shoot` function, we will play the `fireSound` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you play the game, you will hear a sound effect when you shoot the
    rocket and when the rocket hits the enemy.
  prefs: []
  type: TYPE_NORMAL
- en: Adding player animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The game has now reached its final stages of development. Let's add some animation
    to the game to make it really come alive. To animate 2D sprites, we need a sprite
    sheet. We can use other techniques to add 2D animations, such as skeletal animation,
    but sprite sheet-based 2D animations are faster to make. Hence, we will use sprite
    sheets to add animations to the main character.
  prefs: []
  type: TYPE_NORMAL
- en: A sprite sheet is an image file; however, instead of just one single image,
    it contains a collection of images in a sequence so that we can loop them to create
    the animation. Each image in the sequence is called a frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the sprite sheet we are going to be using to animate the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8e99ebf-26f3-4887-85a1-922b90f08c71.png)'
  prefs: []
  type: TYPE_IMG
- en: Looking from left to right, we can see that each frame is slightly different
    from the last. The main things that are being animated here are the jet pack of
    the player character and the player character's eyes (so that the character looks
    like it's blinking). Each picture will be shown as an animation frame when the
    game runs, just like in a flip-book animation, where one image is quickly replaced
    with another image to create the effect of animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'SFML makes it really easy to animate 2D characters since we can choose which
    frame to display in the `update` function. Let''s start animating the character:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the sprite sheet file to the `Assets/graphics` folder. We need to make
    some changes to the `Hero.h` and `Hero.cpp` files. Let''s look at the changes
    for the `Hero.h` file first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We need to add two more parameters to the `init` function. The first is an int
    called `frameCount`, which is the number of frames in the animation. In our case,
    there are four frames in the hero sprite sheet. The other parameter is a float,
    called `animDuration`, which basically sets how long you want the animation to
    be played. This will determine the speed of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: We will also create some variables. The first two variables we'll create, `m_frameCount`
    and `m_animDuration`, will be used for storing `frameCount` and `animDuration`
    locally. We will also create a float called `m_elapsedTime`, which will keep track
    of how long the game has been running, and a `vector2` int called `m_spriteSize`,
    which will store the size of each frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the `Hero.cpp` file and see what changes are needed there.
    Here is the modified `init` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the `init` function, we set `m_frameCount` and `m_animationDuration` locally.
    We need to hardcode the value of the width (as `92`) and height (as `126`) of
    each frame. If you are loading in your own images, these values will be different.
  prefs: []
  type: TYPE_NORMAL
- en: After calling `setTexture`, we will call the `setTextureRect` function of the
    `Sprite` class to set which part of the sprite sheet we want to display. Start
    at the origin of the sprite and get the first frame of the sprite sheet by passing
    the width and height of `spriteSHere, we passed the new heroAnim.png file instead
    of theize`.
  prefs: []
  type: TYPE_NORMAL
- en: Set the position and origin, which is equal to the center of the width and height
    of `spriteSize`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make some changes to the `update` function, which is where the major
    magic happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the `update` function, increase the elapsed time by the delta time. Then,
    calculate the current animation frame number.
  prefs: []
  type: TYPE_NORMAL
- en: Update the part of the sprite sheet to be shown by calling `setTextureRect`
    and move the origin of the frame to the `x-axis`, which depends on `animFrame`,
    by multiplying it by the width of the frame. The height of the new frame doesn't
    change, so we set it to 0\. The width and height of the frame remain the same,
    so we pass in the size of the frame itself.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the functions in `Hero.cpp` remain as they are, and no changes need
    to be made to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to `main.cpp` so that we can change how we call `hero.init`. In the
    `init` function, make the required change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we passed the new `heroAnim.png` file instead of the single-frame `.png` file
    we loaded previously. Set the number of frames to `4` and set `animDuration` to
    `1.0f`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the game. You will see that the player character is now animated and blinks
    every four frames:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f1c30d01-f217-40d9-b723-41e6206f010f.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we completed the gameloop and added the `gameover` condition.
    We added scoring so that the player knows how many points they have scored. We
    also added text so that the name of the game is displayed, the player's score
    is displayed, and a tutorial is displayed that tells the user how to play the
    game. Then, we learned how to place these elements in the center of the viewport.
    Finally, we added sound effects and animations to make our game come to life.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to render 3D and 2D objects in a scene.
    Instead of using a framework, we will start creating a basic engine and begin
    our journey of understanding the basics of rendering.
  prefs: []
  type: TYPE_NORMAL
