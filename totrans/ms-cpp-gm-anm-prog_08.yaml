- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Extending Camera Handling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展相机处理
- en: Welcome to *Chapter 6*! In [*Chapter 5*](Chapter_5.xhtml), we added the functionality
    to save and load the application configuration. First, we explored data types,
    file formats, and which data to save to a file. Then, we implemented a parser
    class to write and read configuration files in the YAML file format. At the end
    of the chapter, all models and instances plus the global settings were stored
    in a YAML file by using the `yaml-cpp` library, and all data could be read back
    into the application, enabling us to resume building the virtual world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到**第6章**！在[*第5章*](Chapter_5.xhtml)中，我们添加了保存和加载应用程序配置的功能。首先，我们探讨了数据类型、文件格式以及要保存到文件中的数据。然后，我们实现了一个解析类来以YAML文件格式编写和读取配置文件。在本章末尾，所有模型和实例以及全局设置都通过使用`yaml-cpp`库存储在一个YAML文件中，并且所有数据都可以被读取回应用程序，使我们能够继续构建虚拟世界。
- en: In this chapter, we will enhance the camera configuration. As the first two
    steps, we will extend the application to handle more than one camera and add multiple
    camera types. Then, we’ll implement camera types for a first-person and third-person
    view, following a selected instance like in real games. Next, we will add stationary
    cameras, allowing a surveillance-style view of the virtual scenery. As the last
    step, we will add a hotkey to switch between cameras, along with orthogonal projection
    and mouse-wheel-based field of view adjustment.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将增强相机配置。作为前两个步骤，我们将扩展应用程序以处理多个相机并添加多种相机类型。然后，我们将实现第一人称和第三人称视图的相机类型，就像在真实游戏中跟随所选实例一样。接下来，我们将添加固定相机，允许以监控风格的视图查看虚拟场景。作为最后一步，我们将添加一个热键来切换相机，以及正交投影和基于鼠标滚轮的视野调整。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Adding multiple cameras
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加多个相机
- en: Creating different camera types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建不同类型的相机
- en: Implementing first- and third-person cameras
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现第一人称和第三人称相机
- en: Adding stationary cameras
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加固定相机
- en: Switching between cameras and configurations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在相机和配置之间切换
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example code is in the `chapter06` folder, in the subfolders `01_opengl_cameras`
    for OpenGL and `02_vulkan_cameras` for Vulkan.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码位于`chapter06`文件夹中，在`01_opengl_cameras`子文件夹中为OpenGL，在`02_vulkan_cameras`子文件夹中为Vulkan。
- en: Adding multiple cameras
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加多个相机
- en: In [*Chapter 3*](Chapter_3.xhtml), we added a button in the user interface to
    jump to any instance. But we still land at the same angle and distance for every
    instance we choose, and returning to a great composition of different models on
    a map is close to impossible. You may write down the camera values or take a screenshot,
    but that is far from perfect.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](Chapter_3.xhtml)中，我们在用户界面中添加了一个按钮，可以跳转到任何实例。但我们仍然以相同的角度和距离选择每个实例，并且返回到地图上不同模型的精彩组合几乎是不可能的。你可能需要写下相机值或截图，但这远远不够完美。
- en: Being able to add a virtually unlimited number of cameras to our scene allows
    us to create stunning map and model combinations and return to that view whenever
    we want. By adding different camera types, we can even go several steps further
    – a camera chasing one instance in the third person; another camera presenting
    the entire map in an isometric view; and yet another camera to see the virtual
    world through the virtual eyes of an instance – all reachable by pressing a hotkey
    or selecting a menu.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 能够向场景中添加几乎无限数量的相机，使我们能够创建令人惊叹的地图和模型组合，并且可以随时返回该视图。通过添加不同类型的相机，我们甚至可以更进一步——一个相机以第三人称追逐一个实例；另一个相机以等距视图展示整个地图；还有一个相机通过实例的虚拟眼睛观察虚拟世界——所有这些都可以通过按热键或选择菜单来实现。
- en: All those points will be implemented at the end of the chapter. So, let’s start
    with the first step, and add multiple camera objects to the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些点将在本章末尾实现。因此，让我们从第一步开始，向应用程序添加多个相机对象。
- en: From a single camera to an array of cameras
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从单个相机到多个相机的阵列
- en: Right now, we have only a single camera in the application, defined in the `Camera`
    class in the `tools` folder. This camera provides a free view of the virtual world.
    We can move in all three axes and rotate around two of the three axes. Rotating
    the view around the axis pointing *into* the screen (roll) is less useful at this
    point for the model and animation viewer application since we would just see the
    effect of tilting our head to the side. In addition, navigating a camera in three
    dimensions without a fixed reference like the horizon could be quite difficult.
    So, we only implement up and down (Elevation) and rotation around the vertical
    axis (Azimuth). Upgrading the camera rotation and adding mouse or keyboard controls
    for a rotation around the third axis is left as an exercise for you.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，应用程序中只有一个相机，定义在 `tools` 文件夹中的 `Camera` 类中。这个相机提供了一个对虚拟世界的自由视图。我们可以沿所有三个轴移动，并围绕三个轴中的两个轴旋转。在这个阶段，对于模型和动画查看器应用程序来说，围绕指向屏幕内部的轴（翻滚）旋转对于模型和动画查看器应用来说不太有用，因为我们只会看到头部向一侧倾斜的效果。此外，在没有固定参考（如地平线）的情况下，在三维空间中导航相机可能相当困难。因此，我们只实现了上下（仰角）和围绕垂直轴（方位角）的旋转。升级相机旋转和添加鼠标或键盘控制以围绕第三个轴旋转留给你作为练习。
- en: 'The values for the camera position and the two rotation angles are stored in
    the `OGLRenderData` struct for OpenGL and in the `VkRenderData` struct for Vulkan:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 相机位置和两个旋转角度的值存储在 OpenGL 的 `OGLRenderData` 结构体中，以及 Vulkan 的 `VkRenderData` 结构体中：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To support multiple cameras, we need a simple `std::vector` of the `Camera`
    class elements and an `int` value, stating which of the cameras is currently selected.
    Since these settings are closer to the models and model instances than the rendering,
    we will store the new camera vector in the `ModelAndInstanceData` struct. To match
    the new contents, we will rename the `ModelAndInstanceData` struct to `ModelInstanceCamData`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持多个相机，我们需要一个简单的 `std::vector` 来存储 `Camera` 类的元素和一个 `int` 值，表示当前选中的相机是哪一个。由于这些设置比渲染更接近模型和模型实例，我们将新的相机向量存储在
    `ModelAndInstanceData` 结构体中。为了匹配新的内容，我们将 `ModelAndInstanceData` 结构体重命名为 `ModelInstanceCamData`：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By using the refactoring function of your IDE, renaming the `ModelAndInstanceData`
    struct, along with the variables in classes and functions, is only a matter of
    some mouse clicks and a text edit.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 IDE 的重构功能，重命名 `ModelAndInstanceData` 结构体以及类和函数中的变量，只需几鼠标点击和一些文本编辑即可完成。
- en: In addition to the new struct name, we will also rename the file from `ModelAndInstanceData.h`
    to `ModelInstanceCamData.h` and move the file from the `model` folder to the `opengl`
    folder (the `vulkan` folder for Vulkan). In the end, it is a matter of personal
    preference where to store the header file, but using a central location as the
    folder containing the renderer makes a lot of sense since we access the struct
    mostly from the renderer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了新的结构体名称外，我们还将文件从 `ModelAndInstanceData.h` 重命名为 `ModelInstanceCamData.h`，并将文件从
    `model` 文件夹移动到 `opengl` 文件夹（对于 Vulkan 是 `vulkan` 文件夹）。最后，将头文件存储在包含渲染器的文件夹中是一个个人偏好的问题，但考虑到我们主要从渲染器访问结构体，这样做是有很多意义的。
- en: In the `UserInterface` class, we add a combo box containing the names of the
    available cameras inside the definition of `ImGui::CollapsingHeader` named `Cameras`.
    The code for the combo box can be taken and adjusted from the model or animation
    clip selection.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `UserInterface` 类中，我们在 `ImGui::CollapsingHeader` 的定义中添加了一个包含可用相机名称的组合框，命名为
    `Cameras`。组合框的代码可以从模型或动画剪辑选择中提取并调整。
- en: Extracting the camera settings
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取相机设置
- en: Similar to the instance settings, we will extract the main camera settings to
    a separate struct called `CameraSettings`. A separate struct containing the camera
    variables makes it easier to read out or to apply all camera-related settings
    at once, instead of accessing all settings by setters and getters.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与实例设置类似，我们将主要相机设置提取到一个单独的结构体中，称为 `CameraSettings`。包含相机变量的单独结构体使得读取或一次性应用所有相机相关设置变得更加容易，而不是通过设置器和获取器访问所有设置。
- en: 'The `CameraSettings` struct resides in a header file, `CameraSettings.h`, residing
    in the `tools` folder:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`CameraSettings` 结构体位于 `tools` 文件夹中的头文件 `CameraSettings.h` 中：'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next to a name for the camera, we start with the world position and the two
    view angles of the camera: Azimuth and elevation.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在相机名称旁边，我们开始定义世界位置和相机的两个视角：方位角和仰角。
- en: In the `Camera` class, the new `CameraSettings.h` header must be included, and
    a new private member variable called `mCamSettings` will be added. The three old
    variables containing position, azimuth, and elevation can be removed. All methods
    accessing the three variables for position and the view angles must be changed
    to store and retrieve the values inside the new `mCamSettings` variable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Camera`类中，必须包含新的`CameraSettings.h`头文件，并添加一个新的私有成员变量`mCamSettings`。可以移除包含位置、方位角和仰角的三个旧变量。所有访问这三个变量（位置和视图角度）的方法都必须更改为在新的`mCamSettings`变量中存储和检索值。
- en: We have to add a getter and a setter method for the new `CameraSettings`. The
    getter and setter will allow us to handle the cameras like the model instances,
    manipulating the camera settings by simple variable assignments.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为新的`CameraSettings`添加一个获取器和设置器方法。获取器和设置器将允许我们像处理模型实例一样处理相机，通过简单的变量赋值来操作相机设置。
- en: Adjusting the renderer
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整渲染器
- en: As the renderer needs to update the position and view of the camera, we also
    need to upgrade some methods to use the selected camera.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于渲染器需要更新相机的位置和视图，我们还需要升级一些方法以使用选定的相机。
- en: 'The first step is always to get a pointer to the current camera and read the
    `CameraSettings` for easier access and changes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步始终是获取当前相机的指针并读取`CameraSettings`，以便更容易访问和更改：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we changed any values, we must store the settings back to the camera:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更改了任何值，我们必须将设置存储回相机：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, in the `handleMousePositionEvents()` method, we change all variables
    from the old `mRenderData` variable, as highlighted in the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`handleMousePositionEvents()`方法中，我们将所有变量从旧的`mRenderData`变量更改为，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The new `camSettings` variable, containing the new camera settings, looks like
    this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 包含新相机设置的新`camSettings`变量看起来像这样：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A similar change needs to be made in the `draw()` method of the renderer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染器的`draw()`方法中也需要进行类似的更改。
- en: First, we remove the private `mCamera` member variable from the renderer class,
    as we will never use the single camera again. Then, we get the pointer to the
    camera and read the current camera settings.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从渲染器类中移除私有的`mCamera`成员变量，因为我们永远不会再次使用单个相机。然后，我们获取相机的指针并读取当前的相机设置。
- en: 'Now, the update of the camera will be switched away from the old `mCamera`
    variable:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，相机的更新将不再使用旧的`mCamera`变量：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Instead, we update the currently selected camera via the `cam` pointer:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们通过`cam`指针更新当前选定的相机：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For the projection matrix, we use the new `camSettings` variable to read the
    currently configured field of view:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于投影矩阵，我们使用新的`camSettings`变量来读取当前配置的视场。
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We read the updated view matrix also by accessing the `cam` pointer:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过访问`cam`指针来读取更新的视图矩阵：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, in the `centerInstance()` method of the renderer, the call to the
    `moveCameraTo()` method of the camera must be adjusted, too. We no longer use
    the old `mCamera` variable, highlighted in the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在渲染器的`centerInstance()`方法中，对相机`moveCameraTo()`方法的调用也需要调整。我们不再使用旧的`mCamera`变量，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we access the current camera directly in the `micCameras` vector:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们直接在`micCameras`向量中访问当前相机：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Extracting the pointer to the current camera makes no sense here since this
    is only a single operation on the `camera` instance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里提取当前相机的指针没有意义，因为这只是在`camera`实例上的一次单一操作。
- en: Defining a free camera as the default camera
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将自由相机定义为默认相机
- en: Like the null model and the null instance, we should make sure to always have
    at least one camera in the `micCameras` vector. Avoiding an empty array frees
    us from a lot of boundary checks, and the always-available free camera is a nice
    feature on a new configuration or after all existing cameras are removed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 就像空模型和空实例一样，我们应该确保在`micCameras`向量中始终至少有一个相机。避免空数组可以让我们摆脱很多边界检查，并且始终可用的自由相机在新配置或所有现有相机被移除后是一个很好的特性。
- en: 'To simplify the default free camera, a new method called `loadDefaultFreeCam()`
    will be added to the renderer class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化默认自由相机，将在渲染器类中添加一个名为`loadDefaultFreeCam()`的新方法：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'First, we clear the vector containing all the cameras. Then, we create a new
    camera settings object with some default values, apply the settings to the camera,
    and add the camera as the first instance:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们清除包含所有相机的向量。然后，我们创建一个新的具有一些默认值的相机设置对象，将设置应用到相机上，并将相机作为第一个实例添加：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can adjust the settings for the default free camera to your needs. The settings
    shown in the previous code snippet just center the origin of the world, making
    the first instance of a loaded model appear in the center of the screen.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需要调整默认自由相机的设置。前一个代码片段中显示的设置只是将世界原点居中，使加载的第一个模型出现在屏幕中央。
- en: Finally, we set the selected camera to zero, the index of our newly added camera.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将选定的相机设置为零，即我们新添加的相机的索引。
- en: Whenever we need to remove all cameras and add the default camera (i.e., when
    creating a new configuration), we can just call `loadDefaultFreeCam()`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们需要删除所有相机并添加默认相机（即创建新配置时），我们只需调用 `loadDefaultFreeCam()` 即可。
- en: For the user interface, we should disable name changes to the default free camera
    by surrounding the name field with calls to `ImGui::BeginDisabled()` and `ImGui::EndDisabled()`
    when the camera instance 0 is selected.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户界面，当选择相机实例 0 时，我们应该通过在名称字段周围调用 `ImGui::BeginDisabled()` 和 `ImGui::EndDisabled()`
    来禁用对默认自由相机名称的更改。
- en: '*Figure 6.1* shows the resulting user interface for the camera section:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.1* 展示了相机部分的最终用户界面：'
- en: '![](img/Figure_6.1_B22428.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_6.1_B22428.png)'
- en: 'Figure 6.1: The new camera settings'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：新的相机设置
- en: Switching between cameras is now as simple as selecting a new base model or
    a new animation clip, for instance. In addition to the combo box, two arrows have
    been added, allowing us to directly select the previous and the next camera.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在相机之间切换现在就像选择新的基础模型或新的动画剪辑一样简单。除了组合框外，还添加了两个箭头，允许我们直接选择上一个和下一个相机。
- en: 'For real camera management, two functions are missing: creating a new camera
    and deleting an existing camera, with the exception of the default camera.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于真正的相机管理，缺少两个函数：创建新相机和删除现有相机（默认相机除外）。
- en: Adding and deleting cameras
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和删除相机
- en: 'To create a camera, two paths can be taken:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建相机，可以采取两种路径：
- en: Adding a camera at the origin, using default values
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在原点添加相机，使用默认值
- en: Cloning the currently selected camera and all settings except the name
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆当前选定的相机及其所有设置（除名称外）
- en: Forcing the user to return to the origin and move the new camera to the desired
    place in the virtual world feels a bit off. A much better solution is to be able
    to clone the currently selected camera since the user most probably wants to make
    the current view of the virtual world persistent.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 强迫用户返回原点并将新相机移动到虚拟世界中的期望位置感觉有些不合适。一个更好的解决方案是能够克隆当前选定的相机，因为用户最可能希望使当前虚拟世界的视图保持不变。
- en: Both cloning and deleting functions are handled by new callbacks, moving the
    burden of checks and all work to the renderer instead of the user interface. The
    new renderer methods, called `cloneCamera()` and `deleteCamera()`, are short and
    simple, so we skip the listing here.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆和删除功能都由新的回调函数处理，将检查和所有工作的负担从用户界面转移到渲染器。新的渲染方法，称为 `cloneCamera()` 和 `deleteCamera()`，简短且简单，因此这里省略了列表。
- en: However, handling camera names needs some extra attention. Duplicate names in
    the combo box will be confusing, so we have to find a solution to create unique
    names when cloning a camera. A simple way to create new names is to append a number
    to the name and raise the number by one on further clones.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，处理相机名称需要一些额外的注意。组合框中的重复名称会令人困惑，因此我们必须找到在克隆相机时创建唯一名称的解决方案。创建新名称的一个简单方法是在名称后附加一个数字，并在进一步的克隆中递增该数字。
- en: The method handling the new names is called `generateUniqueCameraName()`, defined
    in the renderer class. The method has a camera base name as the only parameter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 处理新名称的方法称为 `generateUniqueCameraName()`，定义在渲染类中。该方法只有一个参数，即相机基础名称。
- en: 'First, we copy the base name, since we will adjust the name during the `while`
    loop if the camera name is already in use, and define a string named `matches`
    containing all numbers from zero to nine:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们复制基础名称，因为如果相机名称已被使用，我们将在 `while` 循环中调整名称，并定义一个名为 `matches` 的字符串，包含从零到九的所有数字：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the loop, we check if the camera name already has a number as a suffix.
    If not, we simply append a 1:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，我们检查相机名称是否已有一个数字作为后缀。如果没有，我们简单地附加一个 1：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we find a number, then we save the camera name without the trailing number
    into `cameraNameString`, convert the existing camera number to an `int`, increment
    the number by one, convert the new number back to a string, and combine the original
    camera name and the new number:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到一个数字，那么我们将不带尾随数字的相机名称保存到 `cameraNameString` 中，将现有的相机编号转换为 `int`，将数字增加一，将新数字转换回字符串，并将原始相机名称和新数字组合起来：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This way, we can create unique but still understandable camera names when we
    clone an existing camera.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当我们克隆现有相机时，我们可以创建唯一但仍然可理解的相机名称。
- en: 'The `while` loop in `generateUniqueCameraName()` uses another new method called
    `checkCameraNameUsed()`. Checking if the camera name is already in use is done
    by iterating over the existing cameras and comparing the camera names with the
    proposed new name:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`generateUniqueCameraName()` 中的 `while` 循环使用另一个新方法 `checkCameraNameUsed()`。通过遍历现有相机并比较相机名称与建议的新名称来检查相机名称是否已被使用：'
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The same `checkCameraNameUsed()` method will be used in the user interface to
    detect a duplicate name when a camera is renamed. As in most places in the user
    interface, a callback to the renderer is used for the name check, moving the work
    to the renderer class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的 `checkCameraNameUsed()` 方法将在用户界面中用于检测重命名相机时的重复名称。与用户界面中的大多数地方一样，使用对渲染器的回调来进行名称检查，将工作移至渲染器类。
- en: 'In *Figure 6.2*, the new buttons to clone and delete the camera are shown,
    together with the result of pressing the **Clone Current Camera** button several
    times:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图6.2* 中，显示了用于克隆和删除相机的新的按钮，以及多次按下 **克隆当前相机** 按钮的结果：
- en: '![](img/Figure_6.2_B22428.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2](img/Figure_6.2_B22428.png)'
- en: 'Figure 6.2: New buttons to clone and delete, plus some new cameras'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：新的克隆和删除按钮，以及一些新的相机
- en: As the last step for the transition away from a single camera, we must change
    the YAML-based configuration file to reflect the new camera configuration.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为从单一相机过渡的最后一步，我们必须将基于 YAML 的配置文件更改为反映新的相机配置。
- en: Adjusting camera configuration load and save
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整相机配置的加载和保存
- en: To load and save the new camera settings, we have to change the YAML parsing
    and emitting in the `YamlParser` class in the `tools` folder.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载和保存新的相机设置，我们必须更改 `tools` 文件夹中的 `YamlParser` 类中的 YAML 解析和输出。
- en: 'Decoding a YAML camera node can be achieved similarly to decoding `glm::vec3`
    or `InstanceSettings:`, by adding a new `decode` method in a new `convert` template
    block in the header file `YamlParserTypes.h`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 解码 YAML 相机节点可以通过类似解码 `glm::vec3` 或 `InstanceSettings:` 的方式实现，通过在头文件 `YamlParserTypes.h`
    中的新 `convert` 模板块中添加一个新的 `decode` 方法：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Handling exceptions thrown while parsing nodes ensures recovering as much of
    the camera configuration as possible in case of malformed or missing keys. Being
    unable to parse the camera name still skips the entire camera to avoid naming
    trouble.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析节点时处理抛出的异常确保在出现格式错误或缺失键的情况下尽可能恢复相机配置。如果无法解析相机名称，则跳过整个相机以避免命名问题。
- en: 'We also add the `encode` method to make a full implementation of the template.
    With the `decode` function available, we can read a node containing camera settings
    simply by passing the `CameraSettings` type to the `.as<>()` call:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了 `encode` 方法以实现模板的完整实现。有了 `decode` 函数，我们可以通过将 `CameraSettings` 类型传递给 `.as<>()`
    调用来简单地读取包含相机设置的节点：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For emitting camera configurations to a save file, we create a sequence and
    add a map for each of the cameras available:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将相机配置输出到保存文件，我们创建一个序列并为每个可用的相机添加一个映射：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the saved YAML configuration file, a new sequence will appear for each camera,
    storing all camera settings as key/value pairs:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存的 YAML 配置文件中，将为每个相机出现一个新的序列，将所有相机设置作为键/值对存储：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since we made essential changes to the configuration file, we should reflect
    the new on-disk format with a new version number.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对配置文件进行了重要更改，我们应该通过新的版本号来反映新的磁盘格式。
- en: Bumping the configuration file version
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高配置文件版本
- en: Adjusting the configuration file version number in the emitter is easy; we just
    have to raise the version number string from `1.0` to something like `1.1` or
    `2.0`. From now on, all saved configuration files will have the new version number.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出器中调整配置文件版本号很容易；我们只需将版本号字符串从 `1.0` 提高到类似 `1.1` 或 `2.0` 的值。从现在起，所有保存的配置文件都将具有新的版本号。
- en: Loading a configuration file gets a bit more complex now. If we want to support
    the old file format, we must retain all methods that were used to parse the previous
    file version contents. After reading the version number of the file to parse,
    we must decide if we want to parse the new sequence style for multiple cameras,
    or get the settings for the single camera and apply those settings to the always-available
    default free camera. Saving the configuration could be done in the new version,
    resulting in a migration of a configuration file from the old to the new version.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 加载配置文件现在变得更加复杂。如果我们想支持旧文件格式，我们必须保留所有用于解析先前文件版本内容的方法。在读取要解析的文件版本号之后，我们必须决定是否要解析多相机的新的序列风格，或者获取单相机的设置并将这些设置应用到始终可用的默认`free`相机上。保存配置可以在新版本中完成，从而实现从旧版本到新版本的配置文件迁移。
- en: Updating the configuration by supporting the reading of an older version is
    one of the tasks in the *Practical sessions* section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过支持读取旧版本来更新配置是*实践课程*部分的任务之一。
- en: We can create a bunch of free-floating cameras now, position the cameras in
    our virtual world, and switch between the cameras via the user interface. Still
    sounds a bit boring, doesn’t it? Let’s enhance the application more by adding
    different camera types.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一些自由浮动的相机，将相机放置在我们的虚拟世界中，并通过用户界面在相机之间切换。这听起来还是有点无聊，不是吗？让我们通过添加不同的相机类型来增强应用程序。
- en: Creating different camera types
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建不同的相机类型
- en: Having the ability to add more than one camera in the virtual world is a good
    basis for adding a couple of predefined camera settings. The different camera
    types behave in different ways regarding the movement of the view and the movement
    of the camera itself.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟世界中能够添加多个相机是添加一些预定义相机设置的良好基础。不同的相机类型在视图移动和相机本身的移动方面表现不同。
- en: 'We define a new `enum` class named `cameraType` in the `Enums.h` file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Enums.h`文件中定义了一个名为`cameraType`的新`enum`类：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the `CameraSettings` struct, a new variable of the `cameraType` type must
    be added:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CameraSettings`结构体中，必须添加一个`cameraType`类型的新变量：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The names already tell a lot about the purpose of the camera types. Here is
    what all the types are about:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 名称已经很好地说明了相机类型的目的。以下是所有类型的相关信息：
- en: 'The `free` camera is already known from previous code examples. We can freely
    move around the world in five degrees of freedom: three directions and two rotations.
    There are no movement restrictions for the camera or view.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`free`相机在之前的代码示例中已经介绍过了。我们可以自由地在五个自由度内移动：三个方向和两个旋转。对于相机或视图，没有任何运动限制。'
- en: 'The `firstPerson` camera does what cameras in first-person games do: it allows
    you to see the virtual world through the eyes of the protagonist. In our application,
    we will attach the camera to the head of an instance and move both camera and
    view just as the instance does. However, there will be an option to unlock the
    view to avoid weird angles or motion sickness.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firstPerson`相机做的是第一人称游戏中相机的功能：它允许你通过主角的眼睛看到虚拟世界。在我们的应用程序中，我们将相机附着到实例的头部，并像实例一样移动相机和视图。然而，将有一个选项解锁视图，以避免奇怪的视角或运动病。'
- en: The `thirdPerson` camera follows the selected instance like another person or
    a drone, showing the same angle of the virtual world as the instance sees but
    from the *outside* of the instance body. Some view adjustments are possible, like
    the distance from the instance, but both camera motion and view are controlled
    by the instance.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thirdPerson`相机像另一个人或无人机一样跟随选定的实例，显示与实例看到相同的虚拟世界角度，但来自实例身体的*外部*。可以进行一些视图调整，如与实例的距离，但相机的运动和视图都由实例控制。'
- en: The `stationary` camera can be compared to a fixed surveillance camera. The
    stationary camera can be placed anywhere in the world and at any angle, but once
    the camera is locked, no movement or view adjustment except the field of view
    is possible. The field of view setting is kept unlocked to allow zooming in and
    out, just like with a normal surveillance camera.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stationary`相机可以与固定式监控相机相比较。`stationary`相机可以放置在世界上的任何位置和任何角度，但一旦相机被锁定，除了视野之外，不可能进行任何移动或视图调整。视野设置保持解锁状态，以便可以进行缩放，就像普通监控相机一样。'
- en: Finally, the `stationaryFollowing` camera is a special type of surveillance
    camera. While both movement and view are not controllable by the user (again,
    with the exception of the field of view setting), this camera type will automatically
    center the selected instance, regardless of whether the instance is directly visible
    or not. And if the instance moves around, the camera will track that instance
    within the virtual world.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`stationaryFollowing` 相机是一种特殊的监控相机。虽然用户无法控制（再次，除视场设置外）移动和视图，但这种类型的相机将自动将选定的实例居中，无论实例是否直接可见。如果实例移动，相机将在虚拟世界中跟踪该实例。
- en: Depending on the camera type, we must restrict parts of the camera settings
    in the renderer. Whenever we are unable to change specific camera settings, like
    the position, we will also disable the user interface control for the same settings.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 根据相机类型，我们必须在渲染器中限制相机设置的一部分。每次我们无法更改特定的相机设置，如位置时，我们也将禁用相同设置的用户界面控制。
- en: We will start with the first- and third-person cameras because both camera types
    have large parts of behavior changes and data retrieval in common.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从第一人称和第三人称相机开始，因为这两种相机类型在行为变化和数据检索方面有大量共同点。
- en: Implementing first- and third-person cameras
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现第一人称和第三人称相机
- en: 'For a first-person camera, the `CameraSettings` struct in the `CameraSettings.h`
    header in the `tools` folder needs some additional variables:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一人称相机，`tools` 文件夹中 `CameraSettings.h` 头文件中的 `CameraSettings` 结构体需要一些额外的变量：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The new variable `csFirstPersonLockView` is used to control if the first-person
    view follows the motion of the instance bone or if we relax that restriction and
    enable a free view, but still at a fixed position. We need a bone of the model
    skeleton to attach the camera to; the variable `csFirstPersonBoneToFollow` lets
    us set the bone we will follow. In the user interface, the contents of the `csFirstPersonBoneNames`
    vector are used to present a combo box with all bone names, and the selected bone
    will be saved in `csFirstPersonBoneToFollow`. The last variable, `csFirstPersonOffsets`,
    can be used to slightly move the camera position around, preventing the camera
    from being placed at a strange point inside the head of the instance or suchlike.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 新变量 `csFirstPersonLockView` 用于控制第一人称视角是否跟随实例骨骼的运动，或者放松该限制并启用自由视角，但仍然保持在固定位置。我们需要一个模型骨骼的骨骼来将相机连接到；变量
    `csFirstPersonBoneToFollow` 允许我们设置我们将要跟随的骨骼。在用户界面中，`csFirstPersonBoneNames` 向量的内容用于显示包含所有骨骼名称的组合框，所选骨骼将被保存在
    `csFirstPersonBoneToFollow` 中。最后一个变量 `csFirstPersonOffsets` 可以用来稍微移动相机位置，防止相机被放置在实例头部或其他奇怪的位置。
- en: As we are doing skeletal animations, we need to access the matrix containing
    translation, rotation, and scaling of the bone where the camera is virtually attached.
    We could get the matrix by re-implementing the animation code from the first chapter,
    or we can extract the bone matrix from the Shader Storage Buffer Object after
    the compute shader from [*Chapter 2*](Chapter_2.xhtml) has finished calculating
    the final matrix data.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在进行骨骼动画，我们需要访问包含相机虚拟连接的骨骼的平移、旋转和缩放矩阵。我们可以通过重新实现第一章中的动画代码来获取矩阵，或者我们可以在[*第二章*](Chapter_2.xhtml)的计算着色器完成计算最终矩阵数据后从着色器存储缓冲对象中提取骨骼矩阵。
- en: For a real-world application, you should use a profiler to check the costs of
    both versions. In the example application, we will use the compute shader results
    to avoid making the same animation calculations again.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际应用，你应该使用分析器来检查两种版本的成本。在示例应用中，我们将使用计算着色器结果来避免再次进行相同的动画计算。
- en: Note on first-person models
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关于第一人称模型注意事项
- en: For many first-person-style games, the first-person model will differ from the
    third-person model of the same character.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多第一人称风格的游戏，第一人称模型将与同一角色的第三人称模型不同。
- en: Sometimes, the head elements are removed or rotated away. This generates the
    *feeling* of having a virtual body if the player sees the arms, hands, and legs
    while having the head removed from interfering with the view. In other games,
    the body is removed entirely, and only a partial model like the lower arms or
    the arms up to the shoulder is drawn. The resulting view gives a simple but still
    *good enough* representation of the virtual body for a player.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，头部元素被移除或旋转掉。如果玩家在头部移除以避免干扰视图的同时看到手臂、手和腿，这会产生拥有虚拟身体的*感觉*。在其他游戏中，身体被完全移除，只绘制部分模型，如从肘部以下的下半臂或从肩部以上的手臂。这种视图给出了简单但仍然*足够好*的虚拟身体表示，对玩家来说。
- en: We are using the same model for all camera types here, simply because swapping
    the model on the fly during camera switches will cause a lot of additional overhead.
    If you are interested in how much effort is needed to use another model in first-person,
    you are encouraged to add the logic to switch the models in parallel to the camera
    type.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为所有相机类型使用相同的模型，仅仅是因为在相机切换时动态交换模型将导致大量的额外开销。如果你对在第一人称视角中使用另一个模型所需的努力感兴趣，你被鼓励将切换模型的逻辑并行添加到相机类型中。
- en: 'Another addition to the `CameraSettings` struct is a weak pointer to the instance
    we want to follow:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`CameraSettings` 结构体的另一个新增功能是跟踪实例的弱指针：'
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Similar to the undo/redo settings, we use a `std::weak_ptr` instead of a `std::shared_ptr`
    to avoid trouble if the instance we follow gets removed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与撤销/重做设置类似，我们使用 `std::weak_ptr` 而不是 `std::shared_ptr`，以避免如果跟踪的实例被移除时出现的问题。
- en: Capturing the instance in the user interface can be done by adding a button
    that stores the currently selected instance in the `csInstanceToFollow` variable
    of the camera settings. But be aware to check for the null instance or you will
    get unwanted results and have the camera centered at the origin.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个按钮将当前所选实例存储在相机设置的 `csInstanceToFollow` 变量中，可以在用户界面中捕获实例。但请注意检查空实例，否则你将得到不希望的结果，并且相机将位于原点。
- en: Retrieving the bone matrix for the first-person view
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取第一人称视图的骨骼矩阵
- en: 'The first part of the first-person magic is the retrieval of the final TRS
    of the bone we want to have our camera attached to. In the `draw()` call of the
    renderer, right after the second computer shader, we extract the bone matrix from
    the `mShaderBoneMatrixBuffer` SSBO:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第一人称魔法的第一个部分是我们想要将相机附加到的骨骼的最终 TRS 的检索。在渲染器的 `draw()` 调用中，紧随第二个计算机着色器之后，我们从 `mShaderBoneMatrixBuffer`
    SSBO 中提取骨骼矩阵：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are using an overloaded `getSsboDataMat4()` method to read a single `glm::mat4`
    at the position of the selected bone of the selected instance. To be able to read
    more than one matrix from an SSBO, `getSsboDataMat4()` returns a `std::vector`
    of `glm::mat4`. But since we only need a single matrix, we extract the first matrix
    of the vector by using `.at(0)`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用重载的 `getSsboDataMat4()` 方法来读取所选实例所选骨骼位置的单个 `glm::mat4`。为了能够从 SSBO 读取多个矩阵，`getSsboDataMat4()`
    返回一个 `glm::mat4` 的 `std::vector`。但由于我们只需要一个矩阵，我们通过使用 `.at(0)` 提取向量的第一个矩阵。
- en: 'The camera offset matrix is calculated with a simple `glm::translate()` call:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 相机偏移矩阵通过简单的 `glm::translate()` 调用计算：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, a slightly monstrous call is used to calculate the position of the
    bone:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用一个稍微有些怪异的调用来计算骨骼的位置：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'By using the correct matrix multiplication order (depending on the library,
    GLM uses right to left), the following operations are done:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用正确的矩阵乘法顺序（根据库的不同，GLM 使用从右到左），执行以下操作：
- en: Get the offset matrix of the selected bone from the model and calculate the
    inverse of the offset matrix. The offset matrix of a bone contains the offset
    of that bone between the skinning position and the default **T-pose**.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从模型中获取所选骨骼的偏移矩阵并计算偏移矩阵的逆。骨骼的偏移矩阵包含该骨骼在皮肤位置和默认 **T-pose** 之间的偏移。
- en: Multiply the inverse of the bone offset matrix by the camera position offset
    matrix, moving the camera slightly away from the bone offset.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将骨骼偏移矩阵的逆矩阵与相机位置偏移矩阵相乘，将相机稍微移离骨骼偏移。
- en: Multiply the final bone TRS matrix by the previous product of the bone offset
    and camera matrices, moving the camera to the correct position of that bone relative
    to the model root.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将最终的骨骼 TRS 矩阵乘以之前骨骼偏移和相机矩阵的乘积，将相机移动到相对于模型根的正确位置。
- en: Multiply the world position offset of the selected instance, moving the camera
    to the selected bone of our selected instance.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所选实例的世界位置偏移量乘以，将相机移动到所选实例所选的骨骼。
- en: 'After the bone matrix has been calculated, we need to update the camera and
    re-upload the view and projection matrix to the GPU:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算完骨骼矩阵后，我们需要更新相机并重新上传视图和投影矩阵到GPU：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, part two of the magic follows: calculating position, azimuth, and elevation.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，接下来的魔法部分：计算位置、方位角和仰角。
- en: Computing first-person camera parameters
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算第一人称相机参数
- en: 'To get the world position and the azimuth and elevation view angles from the
    rotation matrix of the bone, some tricks are required:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要从骨骼的旋转矩阵中获得世界位置和方位角以及仰角，需要一些技巧：
- en: 'First, we set the camera position from the matrix:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们从矩阵中设置相机位置：
- en: '[PRE31]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In a row-major rotation matrix, the translation is stored in the first three
    columns of the last row. By extracting the entire row and discarding the fourth
    value, we instantly get the translation of the bone.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在行主序旋转矩阵中，平移存储在最后一行的前三个列中。通过提取整个行并丢弃第四个值，我们立即得到骨骼的平移。
- en: 'For the elevation view angle, we rotate a vector pointing upward by doing multiplication
    with the bone TRS matrix:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于仰角视图角度，我们通过将骨骼TRS矩阵与向上指的向量相乘来旋转：
- en: '[PRE32]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The matrix-vector multiplication rotates the reference vector `mSideVector`
    by the angles stored on the bone TRS matrix. In theory, we can use any vector
    as a reference; we are using a unit vector pointing to the positive Z axis here.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵-向量乘法通过骨骼TRS矩阵上存储的角度旋转参考向量 `mSideVector`。在理论上，我们可以使用任何向量作为参考；在这里，我们使用指向正Z轴的单位向量。
- en: The resulting vector points to the direction that was applied to the selected
    bone during animation calculation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 结果向量指向在动画计算过程中应用于所选骨骼的方向。
- en: 'Next, we calculate the elevation angle:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们计算仰角：
- en: '[PRE33]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: By using the two-element arctangent, we can calculate the angle between two
    given vectors. We are using the upward-pointing `mWorldUpVector` here as the second
    parameter since we are interested in the rotation angle relative to the vertical
    axis. Arctangent calculation combines the cosine and the sine angle calculation
    between the two angles. For details about the formula, a link is available in
    the *Additional resources* section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用双元素反正切，我们可以计算两个给定向量之间的角度。在这里，我们使用向上指的 `mWorldUpVector` 作为第二个参数，因为我们对相对于垂直轴的旋转角度感兴趣。反正切计算结合了两个角度之间的余弦和正弦角度计算。有关公式的详细信息，在
    *附加资源* 部分有一个链接。
- en: After converting the resulting angle from radians to degrees, we subtract 90
    degrees to get the angle relative to the horizon (`mWorldUpVector` points upward).
    This method is numerically more stable for angles close to the reference vectors
    compared to the arccosine + dot product method that is usually used to calculate
    the angle between two vectors.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将结果角度从弧度转换为度后，我们减去90度以获得相对于地平线的角度（`mWorldUpVector` 指向上方）。与通常用于计算两个向量之间角度的余弦加点积方法相比，这种方法在接近参考向量的角度上数值上更稳定。
- en: Elevation angle limits
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 仰角限制
- en: 'Be aware of an important limitation to the elevation angle: The total range
    for the elevation angle is only 180 degrees (from -90 degrees to 90 degrees).
    You cannot look more up than directly upward, or more down than directly downward.
    Trying to adjust the elevation angle outside the limits results in a rotation
    of 180 degrees around the `X` axis – the azimuth angle will be adjusted, and the
    elevation angle will be still inside the limiting range.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意仰角的一个重要限制：仰角的总范围仅为180度（从-90度到90度）。你不能比直接向上看更多，也不能比直接向下看更多。试图调整超出限制的仰角会导致围绕
    `X` 轴旋转180度——方位角将进行调整，而仰角仍然在限制范围内。
- en: At this point, the camera has the same up/down angle as our selected bone.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，相机具有与所选骨骼相同的上下角度。
- en: 'We can calculate the Azimuth in a similar way:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以类似的方式计算方位角：
- en: 'First, we rotate a vector by doing a multiplication with the bone TRS matrix.
    We again use the vector `mSideVector`, pointing toward the positive Z axis:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们通过将骨骼TRS矩阵与向量相乘来旋转一个向量。我们再次使用指向正Z轴的向量 `mSideVector`：
- en: '[PRE34]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we compute the angle between the rotated vector and another unit vector:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们计算旋转后的向量与另一个单位向量之间的角度：
- en: '[PRE35]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Two major differences are needed here, compared to the elevation angle:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与仰角相比，这里需要两个主要差异：
- en: The dot product is not calculated from the entire rotated angle but mapped to
    two dimensions by setting the `Y` coordinate to zero. The reason for this mapping
    may not be obvious – when using all three dimensions, the elevation part (up/down)
    may be smaller than the azimuth part (rotate around the vertical axis) and the
    dot product calculates the wrong angle. By eliminating the elevation part, we
    get the correct result.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点积不是从整个旋转角度计算的，而是通过将 `Y` 坐标设置为零将其映射到二维。这种映射的原因可能并不明显——当使用所有三个维度时，仰角部分（上下）可能小于方位角部分（围绕垂直轴旋转）并且点积计算了错误的角度。通过消除仰角部分，我们得到正确的结果。
- en: We calculate the dot product against a vector pointing in the opposite direction.
    This sign change is needed to get the correct value of the azimuth angle. Alternatively,
    we can negate the result of the dot product to get the same effect.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们计算与指向相反方向的向量的点积。这种符号变化是获取方位角正确值所必需的。或者，我们可以取点积结果的相反数以获得相同的效果。
- en: 'As the last step, we check if the `x` component of the initially computed `azimuthVector`
    vector is less than zero and adjust the rotation angle accordingly:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，我们检查最初计算的 `azimuthVector` 向量的 `x` 分量是否小于零，并相应地调整旋转角度：
- en: '[PRE36]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Normally, we only get an angle between 0 and 180 degrees as the result of calling
    the inverse cosine function `std::acos()`. By taking the direction of the resulting
    rotated vector into account, we can modify the calculations to retrieve the full
    angle between 0 and 360 degrees.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们只从调用反余弦函数 `std::acos()` 获得介于0到180度之间的角度。通过考虑结果旋转向量的方向，我们可以修改计算以检索0到360度之间的完整角度。
- en: 'If we create the view direction from the computed elevation and azimuth values
    now, the camera looks in exactly the same direction as the selected bone:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在从计算出的仰角和方位角值创建视图方向，相机将正好朝向选定的骨骼：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Figure 6.3* shows the first-person view of a model doing the **Pickup** animation:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.3* 展示了模型进行**拾取**动画的第一人称视角：'
- en: '![](img/Figure_6.3_B22428.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_6.3_B22428.png)'
- en: 'Figure 6.3: First-person view during the “pickup” animation'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：拾取动画期间的第一人称视角
- en: You can see that the instance squats and tries to get something on the ground,
    but you see the animation directly with the eyes of the instance, not from the
    outside. Be aware that the camera might end up somewhere inside the model, resulting
    in graphical artifacts since we draw only the outside faces of the triangles.
    For the third-person view, a different approach is needed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到实例蹲下并试图从地上取东西，但你看到的是实例的眼睛直接看到的动画，而不是从外部看到的。请注意，相机可能最终位于模型内部某个位置，由于我们只绘制三角形的侧面，这可能导致图形伪影。对于第三人称视角，需要采用不同的方法。
- en: Moving the camera in a third-person view
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在第三人称视角中移动相机
- en: 'In a third-person view, we don’t need to follow any bone of the model. We just
    need to follow the model’s location. The location can be retrieved via the `InstanceSettings`
    of the instance. But there is a catch: we must set the position of the camera
    to a place behind the instance.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三人称视角中，我们不需要跟随模型的任何骨骼。我们只需要跟随模型的位置。位置可以通过实例的 `InstanceSettings` 获取。但有一个问题：我们必须将相机的位置设置在实例后面。
- en: 'First, we have to calculate the azimuth angle by using the rotation of the
    instance:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须通过使用实例的旋转来计算方位角：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The offset of 180 degrees is needed due to the different angle ranges of instances
    and cameras. While the instance has a range of -180 to 180 degrees, the camera
    uses a range of 0 to 360 degrees. We also invert the direction of the instance
    rotation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实例和相机角度范围的不同，需要180度的偏移。虽然实例的范围是-180到180度，但相机使用的是0到360度的范围。我们还反转了实例旋转的方向。
- en: 'Next, we calculate the offset of the camera from the instance by using simple
    trigonometry:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用简单的三角学来计算相机与实例的偏移量：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Using sine and cosine rotates the camera around the center of an imaginary unit
    circle. A unit circle has a radius of one, so using `1.0f` for the `Y` axis of
    the offset leads to the same height distance from the ground as the radius of
    the imaginary circle. By using a uniform scaling with the `csThirdPersonDistance`
    variable, we can control the distance of the camera from the instance. And with
    the `csThirdPersonHeightOffset` variable, we can separately adjust the height
    of the camera.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正弦和余弦函数可以使相机围绕一个假想单位圆的中心旋转。单位圆的半径为1，因此使用 `1.0f` 作为偏移量的 `Y` 轴会导致与地面相同的高度距离，与假想圆的半径相同。通过使用与
    `csThirdPersonDistance` 变量一致的缩放，我们可以控制相机与实例的距离。并且通过 `csThirdPersonHeightOffset`
    变量，我们可以单独调整相机的高度。
- en: 'Next, we add the separate camera height offset and set the world position of
    the camera to the instance world position plus the offset:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加单独的相机高度偏移，并将相机的世界位置设置为实例世界位置加上偏移：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, the camera is always placed behind the instance, and we can control the
    view distance and an additional camera height offset.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，相机始终放置在实例后面，我们可以控制视图距离和额外的相机高度偏移。
- en: 'For the elevation angle of the view, we utilize the dot product again, this
    time between the vector from the camera to the instance and the upward-pointing
    `mWorldUpVector`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视图的仰角，我们再次使用点积，这次是在从相机到实例的向量和向上指的 `mWorldUpVector` 之间：
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As a result, we get half the angle in degrees between the `mWorldUpVector` and
    the view direction. The camera points slightly down to the world position of the
    instance, but still upward enough to look over the shoulders of the instance.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到 `mWorldUpVector` 和视图方向之间角度的一半。相机略微向下指向实例的世界位置，但仍然向上足够，可以越过实例的肩膀。
- en: '*Figure 6.4* shows the third-person view behind the selected model:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.4* 展示了所选模型的第三人称视图：'
- en: '![](img/Figure_6.4_B22428.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_6.4_B22428.png)'
- en: 'Figure 6.4: Third-person view'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：第三人称视图
- en: In addition to the calculation of camera position and view angles, we should
    disable the user-based camera movement. Ignoring the request to control the camera
    gives better feedback to the user than visibly resetting the camera changes in
    every frame.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 除了计算相机位置和视图角度之外，我们还应该禁用基于用户的相机移动。忽略控制相机的请求比在每一帧中明显重置相机变化给用户更好的反馈。
- en: Disabling manual camera movement
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用手动相机移动
- en: 'Ignoring the request to change the camera angle can be achieved by a simple
    addition. We only need to get the camera settings and surround the block, changing
    the `mMouseLock` variable in `handleMouseButtonEvents()` with the following condition:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略更改相机角度的请求可以通过简单的添加来实现。我们只需要获取相机设置并围绕方块，在 `handleMouseButtonEvents()` 函数中将
    `mMouseLock` 变量替换为以下条件：
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This complex condition can be broken down into the following rules: Only allow
    locking the mouse and moving the camera manually if:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个复杂条件可以分解为以下规则：只有当以下条件都满足时，才允许锁定鼠标并手动移动相机：
- en: The camera type is not first-person or third-person.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相机类型不是第一人称或第三人称。
- en: For a first-person camera, the view is unlocked.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第一人称相机，视图是解锁的。
- en: For both camera types, a target instance to follow is set.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于两种相机类型，都设置了要跟随的目标实例。
- en: This means the camera can be freely moved on a free camera type, as long as
    no instance has been set as a target in first- and third-person, and the view
    of a first-person camera is not set to locked.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着相机可以在自由相机类型上自由移动，只要没有实例被设置为第一人称和第三人称的目标，并且第一人称相机的视图没有被设置为锁定。
- en: The condition line may look a bit scary, but creating the same conditions with
    opposite logic elements to avoid the initial exclamation mark negation creates
    a Boolean expression of similar complexity. So, we could happily stick with this
    expression.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 条件行可能看起来有点吓人，但通过使用相反的逻辑元素来创建相同的条件，以避免初始感叹号否定，可以创建出类似复杂性的布尔表达式。因此，我们可以高兴地坚持这个表达式。
- en: Since we haven’t implemented the *roll* rotation, a rotation around the axis
    pointing toward the screen, the two new cameras may behave unexpectedly.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有实现 *翻滚* 旋转，即指向屏幕轴的旋转，这两个新相机可能会出现意外的行为。
- en: Limits of current first-/third-person cameras
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当前第一人称和第三人称相机的限制
- en: If you rotate the currently locked instance about the `X` and/or `Z` axes on
    a first-person camera, the view will be rotated around wildly, only following
    the position of the selected bone and not the rotation. This behavior could be
    fixed by adding the third rotation to the camera and doing a **roll** around the
    axis pointing into the screen. After adding the sixth degree of freedom, all calculations
    have to be adjusted to include the new angle.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在一个第一人称摄像头中围绕 `X` 和/或 `Z` 轴旋转当前锁定实例，视图将疯狂地旋转，只跟随所选骨骼的位置而不是旋转。这种行为可以通过向摄像头添加第三个旋转并在指向屏幕的轴上进行翻滚来修复。在添加第六个自由度后，所有计算都必须调整以包括新的角度。
- en: Also, the third-person camera may be placed incorrectly on models that are rotated
    in a different angle, or models that may need to have the `Z` and `Y` axes swapped.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，第三人称摄像头可能被放置在旋转角度不同的模型上，或者可能需要交换 `Z` 和 `Y` 轴的模型上。
- en: Although adding the last rotation is possible, the use inside the application
    is limited to cases like the first-person view, since you can get the same results
    by reversing the roll rotation and rotating the map instead of the model. For
    the *wrong* rotated third-person models, additional fixed rotation checkboxes
    would be needed, or more offset rotations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然添加最后一个旋转是可能的，但在应用程序中的使用仅限于第一人称视图等案例，因为您可以通过反转翻滚旋转并旋转地图而不是模型来获得相同的结果。对于 *错误*
    旋转的第三人称模型，可能需要额外的固定旋转复选框或更多的偏移旋转。
- en: You are encouraged to extend the current code base and add instance settings
    that honor the edge cases mentioned in this section.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励您扩展当前的代码库，并添加符合本节所述边缘情况的实例设置。
- en: After adding cameras directly related to the instance position, let’s continue
    with the stationary cameras.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在直接添加与实例位置相关的摄像头后，让我们继续添加固定摄像头。
- en: Adding stationary cameras
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加固定摄像头
- en: A stationary camera can be used in several situations. You made a great-looking
    composition of character models and props. Or, you want to have a top-down view
    of the entire game map you loaded and see where every character is placed. Maybe
    you even want to follow one of the instances wandering around the map. A perfect
    fit for stationary cameras.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 固定摄像头可以在几种情况下使用。您制作了一个看起来很棒的字符模型和道具的构图。或者，您想查看您加载的整个游戏地图的俯视图，并看到每个角色的位置。也许您甚至想跟随在地图上四处游荡的某个实例。固定摄像头是一个完美的选择。
- en: 'For the pure stationary camera, the configuration is simple. Just add the camera
    type to the activation of the `mMouseLock` Boolean in the `handleMouseButtonEvents()`
    method of the renderer:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于纯固定摄像头，配置很简单。只需将摄像头类型添加到渲染器的 `handleMouseButtonEvents()` 方法中 `mMouseLock`
    布尔值的激活状态：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And in `updateCamera()` of the `Camera` class, add the following line, right
    after checking for the zero `deltaTime`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Camera` 类的 `updateCamera()` 方法中，在检查零 `deltaTime` 之后添加以下行：
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: That’s it! As soon as you select a stationary camera, the right-click of the
    mouse will be ignored, and the camera will also never receive any updates.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！一旦您选择了一个固定摄像头，鼠标的右键点击将被忽略，并且摄像头也将永远不会接收任何更新。
- en: If a stationary camera should follow an instance, a bit more code is needed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个固定摄像头应该跟随一个实例，则需要更多的代码。
- en: Creating a stationary follow camera
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建固定跟随摄像头
- en: 'The first step for creating a stationary instance-follow camera is the same
    as for the pure stationary camera – add the camera type to the `handleMouseButtonEvents()`
    method of the renderer class:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 创建固定实例跟随摄像头的第一步与纯固定摄像头相同——将摄像头类型添加到渲染器类的 `handleMouseButtonEvents()` 方法中：
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We must add the camera type to the brackets for first- and third-person type
    checks since we only want to disable the camera manual movement if an instance
    to follow has been configured.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只想在已配置要跟随的实例时禁用摄像头手动移动，因此我们必须将摄像头类型添加到第一人称和第三人称类型检查的括号中。
- en: For the update of the camera position and view, a mix of the algorithms from
    first and third person will be created. You will recognize the code samples from
    the previous sections.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于摄像头位置和视图的更新，将创建一个结合第一人称和第三人称算法的混合。您将识别出来自上一节中的代码示例。
- en: 'First, we get the instance and calculate the view direction from the camera
    to the instance position:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取实例并从摄像头到实例位置计算视图方向：
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we set the elevation angle of the view to the cosine of the angle between
    the view direction to the instance and the upward-pointing `mWorldUpVector`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将视图的仰角设置为视图方向与向上指向的 `mWorldUpVector` 之间角度的余弦值：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Using the dot product between the view direction and the upward-pointing vector
    has been used in first- and third-person cameras in a very similar way.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一人称和第三人称相机中，使用视图方向与向上指向的向量的点积已被非常相似地使用。
- en: 'Then, we map the same view direction vector to two dimensions and calculate
    the angle between the *flattened* view direction vector and a vector pointing
    toward the negative z axis:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将相同的视图方向向量映射到二维，并计算*展开*的视图方向向量与指向负z轴的向量之间的角度：
- en: '[PRE48]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we extend the azimuth angle to a full 360 degrees:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将方位角扩展到完整的360度：
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The 2D-mapped vector, the dot product, and the extension of the azimuth angle
    to 360 degrees instead of only the 180 degrees of the dot product are exactly
    the same as for the first-person camera.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 2D映射向量、点积以及将方位角扩展到360度而不是仅点积的180度，对于第一人称相机来说完全相同。
- en: When we now use the `stationaryFollowing` type for a camera and select an instance
    as a target, the camera view will automatically follow the instance wherever we
    move it. But manual movement of both the camera and the camera view is prohibited.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在使用`stationaryFollowing`类型为相机并选择一个实例作为目标时，相机视图将自动跟随实例，无论我们将其移动到何处。但手动移动相机和相机视图是被禁止的。
- en: Handling the new camera types already works well, but there is still room for
    improvement. So, let’s add some more features to the application.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 处理新的相机类型已经工作得很好，但仍有改进的空间。所以，让我们给应用程序添加一些更多功能。
- en: Switching between cameras and configurations
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在相机和配置之间切换
- en: For faster movement between the available cameras in the `micCameras` vector,
    keyboard shortcuts are handy.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`micCameras`向量中更快地在可用的相机之间移动，键盘快捷键很有用。
- en: Configuring keyboard shortcuts for camera selection
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置相机选择的快捷键
- en: 'All we have to do to add keyboard shortcuts is add a small piece of code to
    the `handleKeyEvents()` method of the renderer:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的只是向渲染器的`handleKeyEvents()`方法中添加一小段代码来添加键盘快捷键：
- en: '[PRE50]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We also don’t limit the camera changes to edit mode to allow switching between
    cameras in the view mode.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也没有将相机更改限制在编辑模式中，以允许在视图模式之间切换相机。
- en: Another cool addition is the orthogonal projection. While perspective projection
    tries to mimic the size reduction of objects farther away from the camera, orthogonal
    projection will retain the dimension of the objects.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个酷炫的添加是正交投影。虽然透视投影试图模仿远离相机的物体尺寸缩小，但正交投影将保留物体的尺寸。
- en: Adding orthogonal projection
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加正交投影
- en: 'You may recognize a game similar to the picture in *Figure 6.5*:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在*图6.5*中认出与图片相似的游戏：
- en: '![](img/Figure_6.5_B22428.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_6.5_B22428.png)'
- en: 'Figure 6.5: A small level in orthogonal projection'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：正交投影的小型关卡
- en: This version of the Stalkyard map from Half-Life was created by the user pancakesbassoondonut
    on Sketchfab. The map is available at [https://skfb.ly/6ACOx](https://skfb.ly/6ACOx)
    and licensed under the Creative Commons Attribution license CC BY 4.0 ([https://creativecommons.org/licenses/by/4.0/](https://creativecommons.org/licenses/by/4.0/)).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的《半条命》地图由用户pancakesbassoondonut在Sketchfab上创建。该地图可在[https://skfb.ly/6ACOx](https://skfb.ly/6ACOx)找到，并授权于Creative
    Commons Attribution许可CC BY 4.0 ([https://creativecommons.org/licenses/by/4.0/](https://creativecommons.org/licenses/by/4.0/))。
- en: Older games used orthogonal projection only for aesthetic reasons. Without scaling
    the textures or changing the angle of the faces, very little computational power
    was required to create stunning-looking games.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的游戏仅出于美学原因使用了正交投影。在不缩放纹理或改变面角的情况下，创建看起来令人惊叹的游戏所需的计算能力非常有限。
- en: 'To support orthogonal projection, we create a new `enum` class named `cameraProjection`
    in the `Enums.h` file:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持正交投影，我们在`Enums.h`文件中创建了一个名为`cameraProjection`的新`enum`类：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the `CameraSettings` struct, we add two new variables named `csCamProjection`
    and `csOrthoScale`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CameraSettings`结构体中，我们添加了两个新变量，分别命名为`csCamProjection`和`csOrthoScale`：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: While `csCamProjection` is used to swap between perspective and orthogonal projection,
    the `csOrthoScale` variable will define a zoom-level style setting of the orthogonal
    projection, similar to the field of view setting for perspective projection.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`csCamProjection`用于在透视和正交投影之间切换，但`csOrthoScale`变量将定义正交投影的缩放级别样式设置，类似于透视投影的视野设置。
- en: 'The current code to create the projection matrix in `mProjectionMatrix` will
    be moved into a check for the new projection setting:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当前创建投影矩阵的代码将移动到对新投影设置的检查中：
- en: '[PRE53]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And, if the orthogonal projection has been selected, we will use `glm::ortho()`
    instead of `glm::perspective()` to create the projection matrix. First, we read
    `csOrthoScale` and use the value to scale the aspect ratio and the left and right
    plus near and far plane distances:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择了正交投影，我们将使用`glm::ortho()`而不是`glm::perspective()`来创建投影矩阵。首先，我们读取`csOrthoScale`并使用该值来缩放纵横比以及左右和远近平面的距离：
- en: '[PRE54]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The call to `glm::ortho()` creates the orthogonal projection matrix, moving
    the origin of the virtual world to the origin of the screen:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`glm::ortho()`的调用创建正交投影矩阵，将虚拟世界的原点移动到屏幕的原点：'
- en: '[PRE55]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: By using the center of the virtual world as the center for the projection matrix,
    we get a nicely scaled result on the screen. Due to the camera position in the
    view matrix, we are even able to move the camera in the orthogonally drawn virtual
    world.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用虚拟世界的中心作为投影矩阵的中心，我们在屏幕上得到了一个很好地缩放的结果。由于视图矩阵中的相机位置，我们甚至能够在正交绘制的虚拟世界中移动相机。
- en: 'The only restriction here is the movement *into* the screen: While moving the
    camera left and right or up and down adjusts the view as expected, a forward and
    backward movement will show no changes in the first place. This missing reaction
    to a camera movement in the direction of the z axis is caused by the basic principle
    of the orthogonal projection. We don’t have a view frustum like in the perspective
    projection: the projection matrix creates a huge rectangular box instead, and
    every triangle inside that box is drawn.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一限制是向屏幕内部移动：当左右或上下移动相机时，视图会按预期调整，但向前或向后移动最初不会显示任何变化。这种对z轴方向相机移动的缺失反应是由正交投影的基本原理造成的。我们没有像透视投影那样的视锥体：投影矩阵创建了一个巨大的矩形盒，盒子内的每个三角形都会被绘制。
- en: Reaching a point with the camera where some triangles are behind the far z plane
    of the rectangular box requires us to move the camera far away from the origin
    of the virtual world. You can try to reach such a point by yourself, but it will
    take a lot of time, even with the faster camera movement.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当相机到达一个点，其中一些三角形位于矩形盒子的远z平面之后时，我们需要将相机远离虚拟世界的原点移动。你可以自己尝试到达这样的点，但这将花费很多时间，即使使用更快的相机移动。
- en: Despite the cool-looking effect of an orthogonal projection, be aware that depth
    perception can be tricky in such a case. Our brain has learned that the size of
    an object will decrease if the distance to it grows, and objects with the same
    apparent sizes but different distances do not have the same sizes in real life.
    With all instances on the screen being the same size, you may be completely off
    when guessing which instances are closer to the camera.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管正交投影看起来很酷，但请注意在这种情况下深度感知可能会很棘手。我们的大脑已经学会了，如果一个物体离我们越远，它的尺寸就会减小，并且具有相同视尺寸但距离不同的物体在现实生活中并不具有相同的尺寸。由于屏幕上所有实例的尺寸都相同，你可能会完全猜错哪些实例更靠近相机。
- en: User interface controls for the projection settings
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 投影设置的用户界面控制
- en: 'To control which projection will be used, two radio buttons are added to the
    `UserInterface` class. The first radio button is used to activate the perspective
    projection:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制将使用哪种投影，我们在`UserInterface`类中添加了两个单选按钮。第一个单选按钮用于激活透视投影：
- en: '[PRE56]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The second radio button activates the orthogonal projection:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个单选按钮激活正交投影：
- en: '[PRE57]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Right below the field of view slider, a slider for the orthogonal scaling will
    be created:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在视场范围滑块下方，将创建一个用于正交缩放的滑块：
- en: '[PRE58]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The checkboxes and sliders are also surrounded by checks for camera types or
    conflicting settings. Disabling or even hiding controls that could confuse a user
    is better than trying to explain why changing settings does not give the expected
    result.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 复选框和滑块也被用于检查相机类型或冲突设置。禁用甚至隐藏可能会让用户困惑的控制比试图解释为什么更改设置不会得到预期的结果更好。
- en: By having multiple cameras and an extended camera handling available, exploring
    the virtual world and the model instances got a level-up. We can now place cameras
    in different areas of the world, and by using a first- or third-person camera,
    instances and instance animations can be viewed like in a real game.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拥有多个相机和扩展的相机处理功能，探索虚拟世界和模型实例得到了提升。我们现在可以在世界的不同区域放置相机，并通过使用第一人称或第三人称相机，可以像在真实游戏中一样查看实例和实例动画。
- en: A note on cameras and large models
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 关于相机和大型模型的注意事项
- en: When working with large models or models with a high scaling factor, clipping
    issues may occur for different camera types because some parts of the model are
    outside of the near and far clipping planes for the scene depth. Model parts too
    close to the camera position appear to have holes in them and model parts too
    far away may just vanish from the screen. In these cases, you need to adjust the
    scaling of the model or the configuration of the near and far plane for the projection
    matrices in the renderer.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理大型模型或具有高缩放因子的模型时，由于模型的一些部分位于场景深度的近裁剪面和远裁剪面之外，不同类型的摄像机可能会出现裁剪问题。靠近摄像机位置的模型部分看起来有洞，而远离屏幕的模型部分可能会消失。在这些情况下，你需要调整模型的缩放或渲染器中投影矩阵的近裁剪面和远裁剪面的配置。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, new camera functionality was implemented. First, we extended
    the current camera handling to support more than one camera object. Next, several
    camera types were defined and implemented, like first-person and third-person
    cameras. Finally, handy additions for handling cameras were made. Switching between
    the list of defined cameras by using keyboard shortcuts helps to simplify access,
    and the orthogonal projection creates interesting results for viewing the instances.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，实现了新的摄像机功能。首先，我们扩展了当前的摄像机处理以支持多个摄像机对象。接下来，定义并实现了几种摄像机类型，如第一人称和第三人称摄像机。最后，为处理摄像机添加了一些方便的功能。通过使用键盘快捷键在定义的摄像机列表之间切换，有助于简化访问，而正交投影为查看实例创造了有趣的结果。
- en: In the next chapter, we will add more life to our virtual world by enhancing
    the instance animations. By adding animations to different internal states of
    an instance, like walking, running, or jumping, we will be able to move the instance
    within the virtual world. And by blending animations between these states, the
    transition between the different states will be made smooth.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过增强实例动画来为我们的虚拟世界增添更多活力。通过向实例的不同内部状态添加动画，如行走、跑步或跳跃，我们能够在虚拟世界中移动实例。并且通过在这些状态之间混合动画，不同状态之间的过渡将变得平滑。
- en: Practical sessions
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践课程
- en: 'There are some additions you could make to the code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代码中添加一些内容：
- en: Extend the YAML loader to migrate the configuration file.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展 YAML 加载器以迁移配置文件。
- en: As mentioned in the section *Bumping the configuration file version*, add the
    functionality to load both the old and new versions of the configuration file.
    Saving the file could be done in the newest version.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如在*提升配置文件版本*部分所述，添加功能以加载配置文件的旧版和新版。保存文件可以使用最新版本。
- en: Add oscillation to the stationary camera.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将振荡添加到静止的摄像机中。
- en: Like in real life, a security camera could have the additional ability to automatically
    move left and right, or up and down. Possible controls are the extent and speed
    of the movement.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 就像现实生活中的监控摄像头一样，它可以有额外的能力自动左右移动，或者上下移动。可能的控制是移动的范围和速度。
- en: Add a rotation around the vertical axis of the third-person camera.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三人称摄像机周围添加垂直轴的旋转。
- en: Instead of just being able to view the instances from behind, add another property
    containing the rotation around the vertical axis. By rotating the camera 90 degrees,
    you would be able to create a three-dimensional side-scroller, and by rotating
    the camera 180 degrees, the instance would face you while walking or running.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 除了只能从后面查看实例之外，添加另一个包含围绕垂直轴旋转的属性。通过将摄像机旋转90度，你可以创建一个三维侧滚动游戏，而通过将摄像机旋转180度，实例在行走或跑步时会面向你。
- en: Add the roll rotation to the camera.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将翻滚旋转添加到摄像机中。
- en: Currently, the camera supports only elevation (look up and down) and azimuth
    (rotation around the vertical axis). Implement the third rotational axis to allow
    the camera to be moved to any arbitrary angle.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，摄像机仅支持仰角（向上和向下看）和方位角（围绕垂直轴旋转）。实现第三个旋转轴，以便摄像机可以移动到任何任意角度。
- en: Extend the third-person camera to be more action-like.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展第三人称摄像机以使其更具动作感。
- en: You could try to add more features to the third-person camera. What about a
    camera mounted on a spring, only loosely following the motion of the instance?
    Or effects like zooming a bit more out on moving forward, following with a small
    delay on rotations, or even tilting a bit when walking sideways? Or you could
    add a small shake on collisions, like the instance running into an obstacle. Also,
    presets for those different types would be handy.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Change camera implementation to quaternions.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the third dimension in the previous task will most probably lead to rotations
    resulting in a gimbal lock, thus losing one degree of freedom again because one
    axis is rotated or close to another axis. Changing the entire camera rotation
    to use quaternions instead of Euler angles should solve gimbal lock situations.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Add spline-based camera and target paths.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create fly-by scenes, you could add splines for the camera position to follow
    along, including configurable speed and ping-pong movement. By adding splines
    as targets, you could create camera shots of the virtual worlds.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Show the cameras as separate objects in edit mode.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to the arrows for the model manipulation, you could add a view frustum
    and a small box to depict the position and orientation of the cameras in the virtual
    world. Different camera types could be shown by different line colors.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Make the camera symbols selectable with the mouse.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After you finish the previous task, you could also add the camera symbols to
    the selection texture. Just reserve a range of values exclusively for the cameras,
    draw the boxes and/or frustum lines to the selection texture, and switch between
    instances and cameras, depending on the value you get back from the graphics card
    buffer.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'Expert difficulty: Add a **picture-in-picture** window.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most game engines have the ability to show a minimized version of another camera
    in a small window of the application screen. Creating a separate camera display
    requires some low-level additions to the renderer class since the entire scene
    has to be drawn twice by using the view and projection matrices of both cameras.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '**ImGui** has the ability to draw a texture to the screen – you could render
    the second camera view to a texture and show the image in an ImGui window. Adding
    additional information like the camera name and type to the window title would
    enhance the picture-in-picture mode even more.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: To avoid confusion when two different camera types are active, limiting the
    type-based restrictions to be only active in edit mode may be a good idea.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3D Math Primer for Graphics and Game Development: [https://gamemath.com/book/](https://gamemath.com/book/)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to calculate the angle between two vectors in 3D: [https://www.quora.com/How-do-I-calculate-the-angle-between-two-vectors-in-3D-space-using-atan2](https://www.quora.com/How-do-I-calculate-the-angle-between-two-vectors-in-3D-space-using-atan2)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
