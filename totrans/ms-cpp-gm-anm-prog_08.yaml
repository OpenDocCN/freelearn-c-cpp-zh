- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extending Camera Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to *Chapter 6*! In [*Chapter 5*](Chapter_5.xhtml), we added the functionality
    to save and load the application configuration. First, we explored data types,
    file formats, and which data to save to a file. Then, we implemented a parser
    class to write and read configuration files in the YAML file format. At the end
    of the chapter, all models and instances plus the global settings were stored
    in a YAML file by using the `yaml-cpp` library, and all data could be read back
    into the application, enabling us to resume building the virtual world.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will enhance the camera configuration. As the first two
    steps, we will extend the application to handle more than one camera and add multiple
    camera types. Then, we’ll implement camera types for a first-person and third-person
    view, following a selected instance like in real games. Next, we will add stationary
    cameras, allowing a surveillance-style view of the virtual scenery. As the last
    step, we will add a hotkey to switch between cameras, along with orthogonal projection
    and mouse-wheel-based field of view adjustment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding multiple cameras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating different camera types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing first- and third-person cameras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding stationary cameras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching between cameras and configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example code is in the `chapter06` folder, in the subfolders `01_opengl_cameras`
    for OpenGL and `02_vulkan_cameras` for Vulkan.
  prefs: []
  type: TYPE_NORMAL
- en: Adding multiple cameras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](Chapter_3.xhtml), we added a button in the user interface to
    jump to any instance. But we still land at the same angle and distance for every
    instance we choose, and returning to a great composition of different models on
    a map is close to impossible. You may write down the camera values or take a screenshot,
    but that is far from perfect.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to add a virtually unlimited number of cameras to our scene allows
    us to create stunning map and model combinations and return to that view whenever
    we want. By adding different camera types, we can even go several steps further
    – a camera chasing one instance in the third person; another camera presenting
    the entire map in an isometric view; and yet another camera to see the virtual
    world through the virtual eyes of an instance – all reachable by pressing a hotkey
    or selecting a menu.
  prefs: []
  type: TYPE_NORMAL
- en: All those points will be implemented at the end of the chapter. So, let’s start
    with the first step, and add multiple camera objects to the application.
  prefs: []
  type: TYPE_NORMAL
- en: From a single camera to an array of cameras
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right now, we have only a single camera in the application, defined in the `Camera`
    class in the `tools` folder. This camera provides a free view of the virtual world.
    We can move in all three axes and rotate around two of the three axes. Rotating
    the view around the axis pointing *into* the screen (roll) is less useful at this
    point for the model and animation viewer application since we would just see the
    effect of tilting our head to the side. In addition, navigating a camera in three
    dimensions without a fixed reference like the horizon could be quite difficult.
    So, we only implement up and down (Elevation) and rotation around the vertical
    axis (Azimuth). Upgrading the camera rotation and adding mouse or keyboard controls
    for a rotation around the third axis is left as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values for the camera position and the two rotation angles are stored in
    the `OGLRenderData` struct for OpenGL and in the `VkRenderData` struct for Vulkan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To support multiple cameras, we need a simple `std::vector` of the `Camera`
    class elements and an `int` value, stating which of the cameras is currently selected.
    Since these settings are closer to the models and model instances than the rendering,
    we will store the new camera vector in the `ModelAndInstanceData` struct. To match
    the new contents, we will rename the `ModelAndInstanceData` struct to `ModelInstanceCamData`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By using the refactoring function of your IDE, renaming the `ModelAndInstanceData`
    struct, along with the variables in classes and functions, is only a matter of
    some mouse clicks and a text edit.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the new struct name, we will also rename the file from `ModelAndInstanceData.h`
    to `ModelInstanceCamData.h` and move the file from the `model` folder to the `opengl`
    folder (the `vulkan` folder for Vulkan). In the end, it is a matter of personal
    preference where to store the header file, but using a central location as the
    folder containing the renderer makes a lot of sense since we access the struct
    mostly from the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: In the `UserInterface` class, we add a combo box containing the names of the
    available cameras inside the definition of `ImGui::CollapsingHeader` named `Cameras`.
    The code for the combo box can be taken and adjusted from the model or animation
    clip selection.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the camera settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the instance settings, we will extract the main camera settings to
    a separate struct called `CameraSettings`. A separate struct containing the camera
    variables makes it easier to read out or to apply all camera-related settings
    at once, instead of accessing all settings by setters and getters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CameraSettings` struct resides in a header file, `CameraSettings.h`, residing
    in the `tools` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next to a name for the camera, we start with the world position and the two
    view angles of the camera: Azimuth and elevation.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Camera` class, the new `CameraSettings.h` header must be included, and
    a new private member variable called `mCamSettings` will be added. The three old
    variables containing position, azimuth, and elevation can be removed. All methods
    accessing the three variables for position and the view angles must be changed
    to store and retrieve the values inside the new `mCamSettings` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We have to add a getter and a setter method for the new `CameraSettings`. The
    getter and setter will allow us to handle the cameras like the model instances,
    manipulating the camera settings by simple variable assignments.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the renderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the renderer needs to update the position and view of the camera, we also
    need to upgrade some methods to use the selected camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is always to get a pointer to the current camera and read the
    `CameraSettings` for easier access and changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we changed any values, we must store the settings back to the camera:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `handleMousePositionEvents()` method, we change all variables
    from the old `mRenderData` variable, as highlighted in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `camSettings` variable, containing the new camera settings, looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A similar change needs to be made in the `draw()` method of the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: First, we remove the private `mCamera` member variable from the renderer class,
    as we will never use the single camera again. Then, we get the pointer to the
    camera and read the current camera settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the update of the camera will be switched away from the old `mCamera`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we update the currently selected camera via the `cam` pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For the projection matrix, we use the new `camSettings` variable to read the
    currently configured field of view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We read the updated view matrix also by accessing the `cam` pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `centerInstance()` method of the renderer, the call to the
    `moveCameraTo()` method of the camera must be adjusted, too. We no longer use
    the old `mCamera` variable, highlighted in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we access the current camera directly in the `micCameras` vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Extracting the pointer to the current camera makes no sense here since this
    is only a single operation on the `camera` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a free camera as the default camera
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like the null model and the null instance, we should make sure to always have
    at least one camera in the `micCameras` vector. Avoiding an empty array frees
    us from a lot of boundary checks, and the always-available free camera is a nice
    feature on a new configuration or after all existing cameras are removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify the default free camera, a new method called `loadDefaultFreeCam()`
    will be added to the renderer class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we clear the vector containing all the cameras. Then, we create a new
    camera settings object with some default values, apply the settings to the camera,
    and add the camera as the first instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can adjust the settings for the default free camera to your needs. The settings
    shown in the previous code snippet just center the origin of the world, making
    the first instance of a loaded model appear in the center of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set the selected camera to zero, the index of our newly added camera.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we need to remove all cameras and add the default camera (i.e., when
    creating a new configuration), we can just call `loadDefaultFreeCam()`.
  prefs: []
  type: TYPE_NORMAL
- en: For the user interface, we should disable name changes to the default free camera
    by surrounding the name field with calls to `ImGui::BeginDisabled()` and `ImGui::EndDisabled()`
    when the camera instance 0 is selected.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6.1* shows the resulting user interface for the camera section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_6.1_B22428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: The new camera settings'
  prefs: []
  type: TYPE_NORMAL
- en: Switching between cameras is now as simple as selecting a new base model or
    a new animation clip, for instance. In addition to the combo box, two arrows have
    been added, allowing us to directly select the previous and the next camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'For real camera management, two functions are missing: creating a new camera
    and deleting an existing camera, with the exception of the default camera.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding and deleting cameras
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a camera, two paths can be taken:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a camera at the origin, using default values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloning the currently selected camera and all settings except the name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forcing the user to return to the origin and move the new camera to the desired
    place in the virtual world feels a bit off. A much better solution is to be able
    to clone the currently selected camera since the user most probably wants to make
    the current view of the virtual world persistent.
  prefs: []
  type: TYPE_NORMAL
- en: Both cloning and deleting functions are handled by new callbacks, moving the
    burden of checks and all work to the renderer instead of the user interface. The
    new renderer methods, called `cloneCamera()` and `deleteCamera()`, are short and
    simple, so we skip the listing here.
  prefs: []
  type: TYPE_NORMAL
- en: However, handling camera names needs some extra attention. Duplicate names in
    the combo box will be confusing, so we have to find a solution to create unique
    names when cloning a camera. A simple way to create new names is to append a number
    to the name and raise the number by one on further clones.
  prefs: []
  type: TYPE_NORMAL
- en: The method handling the new names is called `generateUniqueCameraName()`, defined
    in the renderer class. The method has a camera base name as the only parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we copy the base name, since we will adjust the name during the `while`
    loop if the camera name is already in use, and define a string named `matches`
    containing all numbers from zero to nine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the loop, we check if the camera name already has a number as a suffix.
    If not, we simply append a 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we find a number, then we save the camera name without the trailing number
    into `cameraNameString`, convert the existing camera number to an `int`, increment
    the number by one, convert the new number back to a string, and combine the original
    camera name and the new number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can create unique but still understandable camera names when we
    clone an existing camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `while` loop in `generateUniqueCameraName()` uses another new method called
    `checkCameraNameUsed()`. Checking if the camera name is already in use is done
    by iterating over the existing cameras and comparing the camera names with the
    proposed new name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The same `checkCameraNameUsed()` method will be used in the user interface to
    detect a duplicate name when a camera is renamed. As in most places in the user
    interface, a callback to the renderer is used for the name check, moving the work
    to the renderer class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 6.2*, the new buttons to clone and delete the camera are shown,
    together with the result of pressing the **Clone Current Camera** button several
    times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_6.2_B22428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: New buttons to clone and delete, plus some new cameras'
  prefs: []
  type: TYPE_NORMAL
- en: As the last step for the transition away from a single camera, we must change
    the YAML-based configuration file to reflect the new camera configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting camera configuration load and save
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To load and save the new camera settings, we have to change the YAML parsing
    and emitting in the `YamlParser` class in the `tools` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decoding a YAML camera node can be achieved similarly to decoding `glm::vec3`
    or `InstanceSettings:`, by adding a new `decode` method in a new `convert` template
    block in the header file `YamlParserTypes.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Handling exceptions thrown while parsing nodes ensures recovering as much of
    the camera configuration as possible in case of malformed or missing keys. Being
    unable to parse the camera name still skips the entire camera to avoid naming
    trouble.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also add the `encode` method to make a full implementation of the template.
    With the `decode` function available, we can read a node containing camera settings
    simply by passing the `CameraSettings` type to the `.as<>()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For emitting camera configurations to a save file, we create a sequence and
    add a map for each of the cameras available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the saved YAML configuration file, a new sequence will appear for each camera,
    storing all camera settings as key/value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Since we made essential changes to the configuration file, we should reflect
    the new on-disk format with a new version number.
  prefs: []
  type: TYPE_NORMAL
- en: Bumping the configuration file version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adjusting the configuration file version number in the emitter is easy; we just
    have to raise the version number string from `1.0` to something like `1.1` or
    `2.0`. From now on, all saved configuration files will have the new version number.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a configuration file gets a bit more complex now. If we want to support
    the old file format, we must retain all methods that were used to parse the previous
    file version contents. After reading the version number of the file to parse,
    we must decide if we want to parse the new sequence style for multiple cameras,
    or get the settings for the single camera and apply those settings to the always-available
    default free camera. Saving the configuration could be done in the new version,
    resulting in a migration of a configuration file from the old to the new version.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the configuration by supporting the reading of an older version is
    one of the tasks in the *Practical sessions* section.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a bunch of free-floating cameras now, position the cameras in
    our virtual world, and switch between the cameras via the user interface. Still
    sounds a bit boring, doesn’t it? Let’s enhance the application more by adding
    different camera types.
  prefs: []
  type: TYPE_NORMAL
- en: Creating different camera types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having the ability to add more than one camera in the virtual world is a good
    basis for adding a couple of predefined camera settings. The different camera
    types behave in different ways regarding the movement of the view and the movement
    of the camera itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a new `enum` class named `cameraType` in the `Enums.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `CameraSettings` struct, a new variable of the `cameraType` type must
    be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The names already tell a lot about the purpose of the camera types. Here is
    what all the types are about:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `free` camera is already known from previous code examples. We can freely
    move around the world in five degrees of freedom: three directions and two rotations.
    There are no movement restrictions for the camera or view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `firstPerson` camera does what cameras in first-person games do: it allows
    you to see the virtual world through the eyes of the protagonist. In our application,
    we will attach the camera to the head of an instance and move both camera and
    view just as the instance does. However, there will be an option to unlock the
    view to avoid weird angles or motion sickness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `thirdPerson` camera follows the selected instance like another person or
    a drone, showing the same angle of the virtual world as the instance sees but
    from the *outside* of the instance body. Some view adjustments are possible, like
    the distance from the instance, but both camera motion and view are controlled
    by the instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `stationary` camera can be compared to a fixed surveillance camera. The
    stationary camera can be placed anywhere in the world and at any angle, but once
    the camera is locked, no movement or view adjustment except the field of view
    is possible. The field of view setting is kept unlocked to allow zooming in and
    out, just like with a normal surveillance camera.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `stationaryFollowing` camera is a special type of surveillance
    camera. While both movement and view are not controllable by the user (again,
    with the exception of the field of view setting), this camera type will automatically
    center the selected instance, regardless of whether the instance is directly visible
    or not. And if the instance moves around, the camera will track that instance
    within the virtual world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the camera type, we must restrict parts of the camera settings
    in the renderer. Whenever we are unable to change specific camera settings, like
    the position, we will also disable the user interface control for the same settings.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the first- and third-person cameras because both camera types
    have large parts of behavior changes and data retrieval in common.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing first- and third-person cameras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a first-person camera, the `CameraSettings` struct in the `CameraSettings.h`
    header in the `tools` folder needs some additional variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The new variable `csFirstPersonLockView` is used to control if the first-person
    view follows the motion of the instance bone or if we relax that restriction and
    enable a free view, but still at a fixed position. We need a bone of the model
    skeleton to attach the camera to; the variable `csFirstPersonBoneToFollow` lets
    us set the bone we will follow. In the user interface, the contents of the `csFirstPersonBoneNames`
    vector are used to present a combo box with all bone names, and the selected bone
    will be saved in `csFirstPersonBoneToFollow`. The last variable, `csFirstPersonOffsets`,
    can be used to slightly move the camera position around, preventing the camera
    from being placed at a strange point inside the head of the instance or suchlike.
  prefs: []
  type: TYPE_NORMAL
- en: As we are doing skeletal animations, we need to access the matrix containing
    translation, rotation, and scaling of the bone where the camera is virtually attached.
    We could get the matrix by re-implementing the animation code from the first chapter,
    or we can extract the bone matrix from the Shader Storage Buffer Object after
    the compute shader from [*Chapter 2*](Chapter_2.xhtml) has finished calculating
    the final matrix data.
  prefs: []
  type: TYPE_NORMAL
- en: For a real-world application, you should use a profiler to check the costs of
    both versions. In the example application, we will use the compute shader results
    to avoid making the same animation calculations again.
  prefs: []
  type: TYPE_NORMAL
- en: Note on first-person models
  prefs: []
  type: TYPE_NORMAL
- en: For many first-person-style games, the first-person model will differ from the
    third-person model of the same character.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the head elements are removed or rotated away. This generates the
    *feeling* of having a virtual body if the player sees the arms, hands, and legs
    while having the head removed from interfering with the view. In other games,
    the body is removed entirely, and only a partial model like the lower arms or
    the arms up to the shoulder is drawn. The resulting view gives a simple but still
    *good enough* representation of the virtual body for a player.
  prefs: []
  type: TYPE_NORMAL
- en: We are using the same model for all camera types here, simply because swapping
    the model on the fly during camera switches will cause a lot of additional overhead.
    If you are interested in how much effort is needed to use another model in first-person,
    you are encouraged to add the logic to switch the models in parallel to the camera
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another addition to the `CameraSettings` struct is a weak pointer to the instance
    we want to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the undo/redo settings, we use a `std::weak_ptr` instead of a `std::shared_ptr`
    to avoid trouble if the instance we follow gets removed.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing the instance in the user interface can be done by adding a button
    that stores the currently selected instance in the `csInstanceToFollow` variable
    of the camera settings. But be aware to check for the null instance or you will
    get unwanted results and have the camera centered at the origin.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the bone matrix for the first-person view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first part of the first-person magic is the retrieval of the final TRS
    of the bone we want to have our camera attached to. In the `draw()` call of the
    renderer, right after the second computer shader, we extract the bone matrix from
    the `mShaderBoneMatrixBuffer` SSBO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We are using an overloaded `getSsboDataMat4()` method to read a single `glm::mat4`
    at the position of the selected bone of the selected instance. To be able to read
    more than one matrix from an SSBO, `getSsboDataMat4()` returns a `std::vector`
    of `glm::mat4`. But since we only need a single matrix, we extract the first matrix
    of the vector by using `.at(0)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The camera offset matrix is calculated with a simple `glm::translate()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, a slightly monstrous call is used to calculate the position of the
    bone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the correct matrix multiplication order (depending on the library,
    GLM uses right to left), the following operations are done:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the offset matrix of the selected bone from the model and calculate the
    inverse of the offset matrix. The offset matrix of a bone contains the offset
    of that bone between the skinning position and the default **T-pose**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiply the inverse of the bone offset matrix by the camera position offset
    matrix, moving the camera slightly away from the bone offset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiply the final bone TRS matrix by the previous product of the bone offset
    and camera matrices, moving the camera to the correct position of that bone relative
    to the model root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiply the world position offset of the selected instance, moving the camera
    to the selected bone of our selected instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the bone matrix has been calculated, we need to update the camera and
    re-upload the view and projection matrix to the GPU:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, part two of the magic follows: calculating position, azimuth, and elevation.'
  prefs: []
  type: TYPE_NORMAL
- en: Computing first-person camera parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get the world position and the azimuth and elevation view angles from the
    rotation matrix of the bone, some tricks are required:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we set the camera position from the matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In a row-major rotation matrix, the translation is stored in the first three
    columns of the last row. By extracting the entire row and discarding the fourth
    value, we instantly get the translation of the bone.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the elevation view angle, we rotate a vector pointing upward by doing multiplication
    with the bone TRS matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The matrix-vector multiplication rotates the reference vector `mSideVector`
    by the angles stored on the bone TRS matrix. In theory, we can use any vector
    as a reference; we are using a unit vector pointing to the positive Z axis here.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting vector points to the direction that was applied to the selected
    bone during animation calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we calculate the elevation angle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By using the two-element arctangent, we can calculate the angle between two
    given vectors. We are using the upward-pointing `mWorldUpVector` here as the second
    parameter since we are interested in the rotation angle relative to the vertical
    axis. Arctangent calculation combines the cosine and the sine angle calculation
    between the two angles. For details about the formula, a link is available in
    the *Additional resources* section.
  prefs: []
  type: TYPE_NORMAL
- en: After converting the resulting angle from radians to degrees, we subtract 90
    degrees to get the angle relative to the horizon (`mWorldUpVector` points upward).
    This method is numerically more stable for angles close to the reference vectors
    compared to the arccosine + dot product method that is usually used to calculate
    the angle between two vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Elevation angle limits
  prefs: []
  type: TYPE_NORMAL
- en: 'Be aware of an important limitation to the elevation angle: The total range
    for the elevation angle is only 180 degrees (from -90 degrees to 90 degrees).
    You cannot look more up than directly upward, or more down than directly downward.
    Trying to adjust the elevation angle outside the limits results in a rotation
    of 180 degrees around the `X` axis – the azimuth angle will be adjusted, and the
    elevation angle will be still inside the limiting range.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the camera has the same up/down angle as our selected bone.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can calculate the Azimuth in a similar way:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we rotate a vector by doing a multiplication with the bone TRS matrix.
    We again use the vector `mSideVector`, pointing toward the positive Z axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we compute the angle between the rotated vector and another unit vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Two major differences are needed here, compared to the elevation angle:'
  prefs: []
  type: TYPE_NORMAL
- en: The dot product is not calculated from the entire rotated angle but mapped to
    two dimensions by setting the `Y` coordinate to zero. The reason for this mapping
    may not be obvious – when using all three dimensions, the elevation part (up/down)
    may be smaller than the azimuth part (rotate around the vertical axis) and the
    dot product calculates the wrong angle. By eliminating the elevation part, we
    get the correct result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We calculate the dot product against a vector pointing in the opposite direction.
    This sign change is needed to get the correct value of the azimuth angle. Alternatively,
    we can negate the result of the dot product to get the same effect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As the last step, we check if the `x` component of the initially computed `azimuthVector`
    vector is less than zero and adjust the rotation angle accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Normally, we only get an angle between 0 and 180 degrees as the result of calling
    the inverse cosine function `std::acos()`. By taking the direction of the resulting
    rotated vector into account, we can modify the calculations to retrieve the full
    angle between 0 and 360 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we create the view direction from the computed elevation and azimuth values
    now, the camera looks in exactly the same direction as the selected bone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 6.3* shows the first-person view of a model doing the **Pickup** animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_6.3_B22428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: First-person view during the “pickup” animation'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the instance squats and tries to get something on the ground,
    but you see the animation directly with the eyes of the instance, not from the
    outside. Be aware that the camera might end up somewhere inside the model, resulting
    in graphical artifacts since we draw only the outside faces of the triangles.
    For the third-person view, a different approach is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the camera in a third-person view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a third-person view, we don’t need to follow any bone of the model. We just
    need to follow the model’s location. The location can be retrieved via the `InstanceSettings`
    of the instance. But there is a catch: we must set the position of the camera
    to a place behind the instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to calculate the azimuth angle by using the rotation of the
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The offset of 180 degrees is needed due to the different angle ranges of instances
    and cameras. While the instance has a range of -180 to 180 degrees, the camera
    uses a range of 0 to 360 degrees. We also invert the direction of the instance
    rotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we calculate the offset of the camera from the instance by using simple
    trigonometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Using sine and cosine rotates the camera around the center of an imaginary unit
    circle. A unit circle has a radius of one, so using `1.0f` for the `Y` axis of
    the offset leads to the same height distance from the ground as the radius of
    the imaginary circle. By using a uniform scaling with the `csThirdPersonDistance`
    variable, we can control the distance of the camera from the instance. And with
    the `csThirdPersonHeightOffset` variable, we can separately adjust the height
    of the camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add the separate camera height offset and set the world position of
    the camera to the instance world position plus the offset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, the camera is always placed behind the instance, and we can control the
    view distance and an additional camera height offset.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the elevation angle of the view, we utilize the dot product again, this
    time between the vector from the camera to the instance and the upward-pointing
    `mWorldUpVector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As a result, we get half the angle in degrees between the `mWorldUpVector` and
    the view direction. The camera points slightly down to the world position of the
    instance, but still upward enough to look over the shoulders of the instance.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6.4* shows the third-person view behind the selected model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_6.4_B22428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Third-person view'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the calculation of camera position and view angles, we should
    disable the user-based camera movement. Ignoring the request to control the camera
    gives better feedback to the user than visibly resetting the camera changes in
    every frame.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling manual camera movement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ignoring the request to change the camera angle can be achieved by a simple
    addition. We only need to get the camera settings and surround the block, changing
    the `mMouseLock` variable in `handleMouseButtonEvents()` with the following condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This complex condition can be broken down into the following rules: Only allow
    locking the mouse and moving the camera manually if:'
  prefs: []
  type: TYPE_NORMAL
- en: The camera type is not first-person or third-person.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a first-person camera, the view is unlocked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For both camera types, a target instance to follow is set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means the camera can be freely moved on a free camera type, as long as
    no instance has been set as a target in first- and third-person, and the view
    of a first-person camera is not set to locked.
  prefs: []
  type: TYPE_NORMAL
- en: The condition line may look a bit scary, but creating the same conditions with
    opposite logic elements to avoid the initial exclamation mark negation creates
    a Boolean expression of similar complexity. So, we could happily stick with this
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: Since we haven’t implemented the *roll* rotation, a rotation around the axis
    pointing toward the screen, the two new cameras may behave unexpectedly.
  prefs: []
  type: TYPE_NORMAL
- en: Limits of current first-/third-person cameras
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you rotate the currently locked instance about the `X` and/or `Z` axes on
    a first-person camera, the view will be rotated around wildly, only following
    the position of the selected bone and not the rotation. This behavior could be
    fixed by adding the third rotation to the camera and doing a **roll** around the
    axis pointing into the screen. After adding the sixth degree of freedom, all calculations
    have to be adjusted to include the new angle.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the third-person camera may be placed incorrectly on models that are rotated
    in a different angle, or models that may need to have the `Z` and `Y` axes swapped.
  prefs: []
  type: TYPE_NORMAL
- en: Although adding the last rotation is possible, the use inside the application
    is limited to cases like the first-person view, since you can get the same results
    by reversing the roll rotation and rotating the map instead of the model. For
    the *wrong* rotated third-person models, additional fixed rotation checkboxes
    would be needed, or more offset rotations.
  prefs: []
  type: TYPE_NORMAL
- en: You are encouraged to extend the current code base and add instance settings
    that honor the edge cases mentioned in this section.
  prefs: []
  type: TYPE_NORMAL
- en: After adding cameras directly related to the instance position, let’s continue
    with the stationary cameras.
  prefs: []
  type: TYPE_NORMAL
- en: Adding stationary cameras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stationary camera can be used in several situations. You made a great-looking
    composition of character models and props. Or, you want to have a top-down view
    of the entire game map you loaded and see where every character is placed. Maybe
    you even want to follow one of the instances wandering around the map. A perfect
    fit for stationary cameras.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the pure stationary camera, the configuration is simple. Just add the camera
    type to the activation of the `mMouseLock` Boolean in the `handleMouseButtonEvents()`
    method of the renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And in `updateCamera()` of the `Camera` class, add the following line, right
    after checking for the zero `deltaTime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: That’s it! As soon as you select a stationary camera, the right-click of the
    mouse will be ignored, and the camera will also never receive any updates.
  prefs: []
  type: TYPE_NORMAL
- en: If a stationary camera should follow an instance, a bit more code is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a stationary follow camera
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step for creating a stationary instance-follow camera is the same
    as for the pure stationary camera – add the camera type to the `handleMouseButtonEvents()`
    method of the renderer class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We must add the camera type to the brackets for first- and third-person type
    checks since we only want to disable the camera manual movement if an instance
    to follow has been configured.
  prefs: []
  type: TYPE_NORMAL
- en: For the update of the camera position and view, a mix of the algorithms from
    first and third person will be created. You will recognize the code samples from
    the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we get the instance and calculate the view direction from the camera
    to the instance position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set the elevation angle of the view to the cosine of the angle between
    the view direction to the instance and the upward-pointing `mWorldUpVector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Using the dot product between the view direction and the upward-pointing vector
    has been used in first- and third-person cameras in a very similar way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we map the same view direction vector to two dimensions and calculate
    the angle between the *flattened* view direction vector and a vector pointing
    toward the negative z axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we extend the azimuth angle to a full 360 degrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The 2D-mapped vector, the dot product, and the extension of the azimuth angle
    to 360 degrees instead of only the 180 degrees of the dot product are exactly
    the same as for the first-person camera.
  prefs: []
  type: TYPE_NORMAL
- en: When we now use the `stationaryFollowing` type for a camera and select an instance
    as a target, the camera view will automatically follow the instance wherever we
    move it. But manual movement of both the camera and the camera view is prohibited.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the new camera types already works well, but there is still room for
    improvement. So, let’s add some more features to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Switching between cameras and configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For faster movement between the available cameras in the `micCameras` vector,
    keyboard shortcuts are handy.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring keyboard shortcuts for camera selection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All we have to do to add keyboard shortcuts is add a small piece of code to
    the `handleKeyEvents()` method of the renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We also don’t limit the camera changes to edit mode to allow switching between
    cameras in the view mode.
  prefs: []
  type: TYPE_NORMAL
- en: Another cool addition is the orthogonal projection. While perspective projection
    tries to mimic the size reduction of objects farther away from the camera, orthogonal
    projection will retain the dimension of the objects.
  prefs: []
  type: TYPE_NORMAL
- en: Adding orthogonal projection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may recognize a game similar to the picture in *Figure 6.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_6.5_B22428.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: A small level in orthogonal projection'
  prefs: []
  type: TYPE_NORMAL
- en: This version of the Stalkyard map from Half-Life was created by the user pancakesbassoondonut
    on Sketchfab. The map is available at [https://skfb.ly/6ACOx](https://skfb.ly/6ACOx)
    and licensed under the Creative Commons Attribution license CC BY 4.0 ([https://creativecommons.org/licenses/by/4.0/](https://creativecommons.org/licenses/by/4.0/)).
  prefs: []
  type: TYPE_NORMAL
- en: Older games used orthogonal projection only for aesthetic reasons. Without scaling
    the textures or changing the angle of the faces, very little computational power
    was required to create stunning-looking games.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support orthogonal projection, we create a new `enum` class named `cameraProjection`
    in the `Enums.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `CameraSettings` struct, we add two new variables named `csCamProjection`
    and `csOrthoScale`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: While `csCamProjection` is used to swap between perspective and orthogonal projection,
    the `csOrthoScale` variable will define a zoom-level style setting of the orthogonal
    projection, similar to the field of view setting for perspective projection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current code to create the projection matrix in `mProjectionMatrix` will
    be moved into a check for the new projection setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'And, if the orthogonal projection has been selected, we will use `glm::ortho()`
    instead of `glm::perspective()` to create the projection matrix. First, we read
    `csOrthoScale` and use the value to scale the aspect ratio and the left and right
    plus near and far plane distances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to `glm::ortho()` creates the orthogonal projection matrix, moving
    the origin of the virtual world to the origin of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: By using the center of the virtual world as the center for the projection matrix,
    we get a nicely scaled result on the screen. Due to the camera position in the
    view matrix, we are even able to move the camera in the orthogonally drawn virtual
    world.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only restriction here is the movement *into* the screen: While moving the
    camera left and right or up and down adjusts the view as expected, a forward and
    backward movement will show no changes in the first place. This missing reaction
    to a camera movement in the direction of the z axis is caused by the basic principle
    of the orthogonal projection. We don’t have a view frustum like in the perspective
    projection: the projection matrix creates a huge rectangular box instead, and
    every triangle inside that box is drawn.'
  prefs: []
  type: TYPE_NORMAL
- en: Reaching a point with the camera where some triangles are behind the far z plane
    of the rectangular box requires us to move the camera far away from the origin
    of the virtual world. You can try to reach such a point by yourself, but it will
    take a lot of time, even with the faster camera movement.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the cool-looking effect of an orthogonal projection, be aware that depth
    perception can be tricky in such a case. Our brain has learned that the size of
    an object will decrease if the distance to it grows, and objects with the same
    apparent sizes but different distances do not have the same sizes in real life.
    With all instances on the screen being the same size, you may be completely off
    when guessing which instances are closer to the camera.
  prefs: []
  type: TYPE_NORMAL
- en: User interface controls for the projection settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To control which projection will be used, two radio buttons are added to the
    `UserInterface` class. The first radio button is used to activate the perspective
    projection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The second radio button activates the orthogonal projection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Right below the field of view slider, a slider for the orthogonal scaling will
    be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The checkboxes and sliders are also surrounded by checks for camera types or
    conflicting settings. Disabling or even hiding controls that could confuse a user
    is better than trying to explain why changing settings does not give the expected
    result.
  prefs: []
  type: TYPE_NORMAL
- en: By having multiple cameras and an extended camera handling available, exploring
    the virtual world and the model instances got a level-up. We can now place cameras
    in different areas of the world, and by using a first- or third-person camera,
    instances and instance animations can be viewed like in a real game.
  prefs: []
  type: TYPE_NORMAL
- en: A note on cameras and large models
  prefs: []
  type: TYPE_NORMAL
- en: When working with large models or models with a high scaling factor, clipping
    issues may occur for different camera types because some parts of the model are
    outside of the near and far clipping planes for the scene depth. Model parts too
    close to the camera position appear to have holes in them and model parts too
    far away may just vanish from the screen. In these cases, you need to adjust the
    scaling of the model or the configuration of the near and far plane for the projection
    matrices in the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, new camera functionality was implemented. First, we extended
    the current camera handling to support more than one camera object. Next, several
    camera types were defined and implemented, like first-person and third-person
    cameras. Finally, handy additions for handling cameras were made. Switching between
    the list of defined cameras by using keyboard shortcuts helps to simplify access,
    and the orthogonal projection creates interesting results for viewing the instances.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add more life to our virtual world by enhancing
    the instance animations. By adding animations to different internal states of
    an instance, like walking, running, or jumping, we will be able to move the instance
    within the virtual world. And by blending animations between these states, the
    transition between the different states will be made smooth.
  prefs: []
  type: TYPE_NORMAL
- en: Practical sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some additions you could make to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend the YAML loader to migrate the configuration file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned in the section *Bumping the configuration file version*, add the
    functionality to load both the old and new versions of the configuration file.
    Saving the file could be done in the newest version.
  prefs: []
  type: TYPE_NORMAL
- en: Add oscillation to the stationary camera.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like in real life, a security camera could have the additional ability to automatically
    move left and right, or up and down. Possible controls are the extent and speed
    of the movement.
  prefs: []
  type: TYPE_NORMAL
- en: Add a rotation around the vertical axis of the third-person camera.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of just being able to view the instances from behind, add another property
    containing the rotation around the vertical axis. By rotating the camera 90 degrees,
    you would be able to create a three-dimensional side-scroller, and by rotating
    the camera 180 degrees, the instance would face you while walking or running.
  prefs: []
  type: TYPE_NORMAL
- en: Add the roll rotation to the camera.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currently, the camera supports only elevation (look up and down) and azimuth
    (rotation around the vertical axis). Implement the third rotational axis to allow
    the camera to be moved to any arbitrary angle.
  prefs: []
  type: TYPE_NORMAL
- en: Extend the third-person camera to be more action-like.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could try to add more features to the third-person camera. What about a
    camera mounted on a spring, only loosely following the motion of the instance?
    Or effects like zooming a bit more out on moving forward, following with a small
    delay on rotations, or even tilting a bit when walking sideways? Or you could
    add a small shake on collisions, like the instance running into an obstacle. Also,
    presets for those different types would be handy.
  prefs: []
  type: TYPE_NORMAL
- en: Change camera implementation to quaternions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the third dimension in the previous task will most probably lead to rotations
    resulting in a gimbal lock, thus losing one degree of freedom again because one
    axis is rotated or close to another axis. Changing the entire camera rotation
    to use quaternions instead of Euler angles should solve gimbal lock situations.
  prefs: []
  type: TYPE_NORMAL
- en: Add spline-based camera and target paths.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create fly-by scenes, you could add splines for the camera position to follow
    along, including configurable speed and ping-pong movement. By adding splines
    as targets, you could create camera shots of the virtual worlds.
  prefs: []
  type: TYPE_NORMAL
- en: Show the cameras as separate objects in edit mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to the arrows for the model manipulation, you could add a view frustum
    and a small box to depict the position and orientation of the cameras in the virtual
    world. Different camera types could be shown by different line colors.
  prefs: []
  type: TYPE_NORMAL
- en: Make the camera symbols selectable with the mouse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After you finish the previous task, you could also add the camera symbols to
    the selection texture. Just reserve a range of values exclusively for the cameras,
    draw the boxes and/or frustum lines to the selection texture, and switch between
    instances and cameras, depending on the value you get back from the graphics card
    buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expert difficulty: Add a **picture-in-picture** window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most game engines have the ability to show a minimized version of another camera
    in a small window of the application screen. Creating a separate camera display
    requires some low-level additions to the renderer class since the entire scene
    has to be drawn twice by using the view and projection matrices of both cameras.
  prefs: []
  type: TYPE_NORMAL
- en: '**ImGui** has the ability to draw a texture to the screen – you could render
    the second camera view to a texture and show the image in an ImGui window. Adding
    additional information like the camera name and type to the window title would
    enhance the picture-in-picture mode even more.'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid confusion when two different camera types are active, limiting the
    type-based restrictions to be only active in edit mode may be a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3D Math Primer for Graphics and Game Development: [https://gamemath.com/book/](https://gamemath.com/book/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to calculate the angle between two vectors in 3D: [https://www.quora.com/How-do-I-calculate-the-angle-between-two-vectors-in-3D-space-using-atan2](https://www.quora.com/How-do-I-calculate-the-angle-between-two-vectors-in-3D-space-using-atan2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
