- en: 7 Advanced PBR extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Join our book community on Discord
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](img/file40.png)'
  prefs: []
  type: TYPE_IMG
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will delve into advanced glTF PBR extensions that build
    upon the base metallic-roughness model. While the base metallic-roughness model
    provides a starting point, it falls short of capturing the full spectrum of real-life
    materials. To address this, glTF incorporates additional material layers, each
    with specific parameters that define their unique behaviors. Our goal here is
    to guide you through implementing these layers from the ground up. We will introduce
    the concept of layers, break down some mathematical principles behind them, and
    then show you how to integrate each layer into the GLSL shader code.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the C++ code provided in this chapter is applicable across all the recipes
    we will cover here and throughout the rest of our book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to glTF PBR extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `KHR_materials_clearcoat` extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `KHR_materials_sheen` extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `KHR_materials_transmission` extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `KHR_materials_volume` extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `KHR_materials_ior` extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `KHR_materials_specular` extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `KHR_materials_emissive_strength` extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending analytical lights support with `KHR_lights_punctual`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our GLSL shaders code is based on the official Khronos Sample Viewer and serves
    as an example implementation of these extensions.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Introduction to glTF PBR extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will explore the design approach for PBR Material extensions,
    offering plenty of context to help you implement various glTF PBR extensions.
    The actual code will be shared in subsequent recipes, with the chapter structure
    following the sequence in which Khronos developed these PBR extensions.
  prefs: []
  type: TYPE_NORMAL
- en: PBR specifications evolve rapidly, and the reader should be aware that some
    extensions may become deprecated or obsolete by the time of reading.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We assume our readers have some basic understanding of linear algebra and calculus.
    It is recommended to have the glTF 2.0 list of ratified extensions specification
    at hand which can be found at [https://github.com/KhronosGroup/glTF/blob/main/extensions/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/README.md).
  prefs: []
  type: TYPE_NORMAL
- en: How is the glTF 2.0 PBR model designed?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous chapter, we explored the core Metallic-Roughness PBR model.
    This model is great for depicting many types of metallic and non-metallic materials,
    but the real world is much more complex.
  prefs: []
  type: TYPE_NORMAL
- en: To better capture that complexity, Khronos decided not to simply extend the
    Metallic-Roughness model. Instead, they introduced a layered approach, much like
    the layers of an onion. This method lets you gradually add complexity to the PBR
    material, similar to how layers are built up in Adobe Standard Surface [https://github.com/Autodesk/standard-surfacehttps://github.com/Autodesk/standard-surface](https://github.com/Autodesk/standard-surfacehttps://github.com/Autodesk/standard-surface).
  prefs: []
  type: TYPE_NORMAL
- en: '**Layering** mimics real-world material structures by stacking multiple layers,
    each with its own light-interacting properties. To maintain physical accuracy,
    the first layer, called the base layer, should be either fully opaque (like metallic
    surfaces) or completely transparent (like glass or skin). After that, additional
    layers, known as dielectric slabs, can be added on top of that one by one.'
  prefs: []
  type: TYPE_NORMAL
- en: When light hits the boundary between two layers, it can reflect and bounce back
    in the opposite direction. However, our main concern here is the light that continues
    to move through the material stack. As this light passes through the lower layers,
    it may be absorbed by the material.
  prefs: []
  type: TYPE_NORMAL
- en: The mixing operation provides a unique method for material modeling. You can
    think of it as a statistically weighted blend of two different materials, where
    you combine a certain percentage of material `A` with a certain percentage of
    material `B`. While this technique is great for creating new materials, it is
    important to remember that not all combinations are physically realistic. For
    example, mixing oil and water wouldn’t produce a believable material.
  prefs: []
  type: TYPE_NORMAL
- en: When the mixing operation is done as a linear interpolation, it naturally follows
    the principle of energy conservation. This means that the total energy within
    the resulting material stays the same, consistent with the basic laws of physics.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: glTF PBR layering and mixing](img/file51.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: glTF PBR layering and mixing'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following recipes, we will dive into several advanced material layers:
    specular retro-reflection (sheen), coating specular reflection, and diffuse transmission.
    We will also explore how these layers can be combined to create a broader range
    of material appearances.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter uses a single glTF viewer sample code for all the recipes. The
    `main.cpp` file varies across recipes in only two ways: they use different model
    files to demonstrate the specific glTF PBR extensions covered and the initial
    camera positions are adjusted to showcase the models attractively.'
  prefs: []
  type: TYPE_NORMAL
- en: The source code for the glTF Viewer itself resides in the file `shared/UtilsGLTF.cpp`.
    The corresponding GLSL vertex and fragment shaders are located in the `data/shaders/gltf/`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of these GLSL shaders differs from those covered in the previous
    chapter. We will explore the specific implementation differences in each of the
    individual recipes.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s go over the main differences between our glTF Viewer implementation from
    the previous chapter and the newly proposed unified version.
  prefs: []
  type: TYPE_NORMAL
- en: We refactored the code and introduced a very basic structure in `shared/UtilsGLTF.h`
    to store all the necessary application data. This chapter will explain all the
    struct member fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s introduce a very basic loading and rendering API for it. The `rebuildRenderList`
    argument signals that model-to-world transformations of glTF nodes should be rebuilt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We expanded the GPU data structures to include the required material properties
    and added a new `enum` called `MaterialType`, which allows us to provide the material
    ID as needed. The previous *Chapter 6, Physically Based Rendering Using the glTF
    2.0 Shading Model* covered the old materials: unlit, metallic-roughness, and specular-glossiness.
    New materials will be covered here in this chapter in the subsequent recipes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve added `3` different vector containers to keep lists of the glTF nodes:
    opaque, transparent and transmission. Here is the function `buildTransformsList()`
    to build node transformations and collect other nodes data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The body of our recursive traversal function is declared as a local C++ lambda.
    It collects all the transforms into `gltf.transforms` and adds opaque, transparent,
    and transmissive nodes to their corresponding containers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Push the index of the transform that was just added to `gltf.transforms` in
    the code block above.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the lambda to traverse the entire tree of glTF nodes starting from the
    root and store all the resulting transformations in a buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let’s add a node-sorting function to correctly render glTF nodes in the right
    order to support transparency. We’re using a very simple algorithm that sorts
    nodes based on the distance from the camera to the node’s center. To properly
    render transparent nodes, they should be rendered last, from back to front.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now we have to change the actual rendering function `renderGLTF()` to accommodate
    all the changes mentioned above.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we have to update the transforms list and sort glTF nodes based on the
    distance to the current camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Store per-frame camera parameters and prepare push constants with all necessary
    buffers and textures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s render all opaque nodes. For this pass, no transmission framebuffer is
    required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We use the built-in GLSL variable `gl_BaseInstance` to pass the value of `transformId`
    into shaders. This way, we do not have to update push constants per each draw
    call. This is the most efficient way to do it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `firstInstance` parameter of `vkCmdDrawIndexed()` is assigned to the built-in
    GLSL variable `gl_BaseInstance`. This allows you to pass an arbitrary per-draw-call
    `uint32_t` value into vertex shaders without involving any buffers or push constants.
    This is a very fast technique and should be used whenever possible.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we should render transparent nodes on top of opaque ones. Some transparent
    nodes may require a screen copy to render various effects, such as volume or index-of-refraction.
    Here’s a very simple way to obtain it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As we start the next render pass and use the offscreen texture, we have to
    synchronize it properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we render transmission nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Transparent nodes come last. The same `gl_BaseInstance` trick is used to pass
    the value of `transformId` for each glTF mesh:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Once the command buffer is filled, we can submit it and use another offscreen
    texture in a round-robin manner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This was a complete overview of our generic glTF rendering code. The real magic
    happens inside the GLSL shaders. In the next recipes, we will go through the shaders
    step by step to learn how to implement different glTF material extensions.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Khronos *3D Formats Working Group* is constantly working to improve PBR
    material capabilities by introducing new extension specifications. To stay up
    to date with the status of approved extensions, you can visit the Khronos GitHub
    page: [https://github.com/KhronosGroup/glTF/blob/main/extensions/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/README.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the KHR_materials_clearcoat extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **KHR_materials_clearcoat** extension improves glTF’s core **physically
    based rendering** (**PBR**) model by adding a clear, reflective layer on top of
    another material or surface. This layer reflects light both from itself and the
    layers underneath. Examples of this effect include the glossy finish on car paint
    or the shine of a well-polished shoe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a link to the Khronos glTF PBR extension: [https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Clearcoat parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following parameters are provided by the `KHR_materials_clearcoat` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '*clearcoatFactor / clearcoatTexure*: This parameter indicates the intensity
    of the coating. It can be set using a scalar factor or a texture. A value of `0`
    means no coating, while a value of `1` indicates the presence of the coating.
    In-between values should be used only along the boundary between coated and uncoated
    areas.'
  prefs: []
  type: TYPE_NORMAL
- en: '*clearcoatNormalTexture:* This parameter allows a normal map to be applied
    to the coating layer, introducing variations and details to the coating surface.'
  prefs: []
  type: TYPE_NORMAL
- en: '*clearcoatRoughnessFactor / clearcoatRoughnessTexture:* This parameter indicates
    the coating roughness. It can be set as a roughness scalar factor or a roughness
    texture. It works similarly to the roughness parameter of a base material but
    is applied to the coating layer.'
  prefs: []
  type: TYPE_NORMAL
- en: Specular BRDF for the clearcoat layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The specular BRDF for the clearcoat layer uses the specular term from the glTF
    2.0 Metallic-Roughness material. However, to maintain energy conservation within
    the material when using a simple layering function, a slight adjustment is applied.
  prefs: []
  type: TYPE_NORMAL
- en: The microfacet Fresnel term is calculated using the `NdotV` term instead of
    the `VdotH` term, effectively ignoring the microscopic surface orientation within
    the clearcoat layer. This simplification is justified because clearcoat layers
    usually have very low roughness, meaning the microfacets are mostly aligned with
    the normal direction. As a result, `NdotV` becomes approximately equivalent to
    `NdotL`. This approach ensures energy conservation within the material through
    a simple layering function and keeps computations efficient by omitting the `VdotH`
    term.
  prefs: []
  type: TYPE_NORMAL
- en: As explained in the previous chapter *Physically Based Rendering Using the glTF
    2.0 Shading Model*, `N` represents the normal vector at the surface point, `V`
    is the vector pointing from the surface to the viewer, `L` is the vector pointing
    from the surface point to the light source, and `H` is the half-vector that lies
    exactly between the directions of the light source `L` and the viewer `V`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The provided implementation of the `clearcoat` layer within the BRDF framework
    makes certain assumptions that neglect some real-world material properties. Here’s
    a breakdown of these limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Infinitely Thin Layer**: The clearcoat layer is treated as infinitely thin,
    disregarding its actual thickness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Neglecting Refraction**: Refraction, bending of light as it passes through
    the clearcoat layer, is not taken into account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Independent Fresnel Terms**: The refractive indices of the clearcoat and
    base layers are treated as independent, with their Fresnel terms calculated separately,
    without accounting for any interaction between them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Omitted Scattering**: The current model does not account for light scattering
    between the clearcoat layer and the base layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Diffraction Ignored:** Diffraction effects, the slight bending of light around
    the edges of microscopic facets, are not taken into account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Despite these limitations, the clearcoat BRDF is a valuable tool for simulating
    clear coat effects in material modeling. It strikes a good balance between computational
    efficiency and producing visually plausible results, especially for clearcoat
    layers with low roughness.
  prefs: []
  type: TYPE_NORMAL
- en: Important notice
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The clearcoat extension is designed to work with glTF’s core PBR shading model
    and is not compatible with other shading models like Unlit or Specular-glossiness.
    However, it can still be used alongside other PBR parameters, such as emissive
    materials, where the emitted light is influenced by the clearcoat layer.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for this recipe can be found in `Chapter07/01_Clearcoat/`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s take a look at the C++ code in `Chapter07/01_Clearcoat/src/main.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s load a `.gltf` file using our new glTF API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we render it using the `renderGLTF()` function described in the previous
    recipe *Introduction to glTF PBR extensions*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To load clearcoat parameters from a `.gltf` file, we have to introduce some
    changes to our GLTF material loader. Let’s take a look at the steps required to
    do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we should add some new member fields to the `GLTFMaterialDataGPU` structure
    in the file `shared/UtilsGLTF.h` to store scalar values and corresponding textures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s load textures and properties using the Assimp library in `shared/UtilsGLTF.cpp`.
    Here we emphasize only the properties related to the clearcoat extension:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we only set the `MaterialType_ClearCoat` flag if the checks
    pass and the extension is present in the `.gltf` file. While it’s technically
    possible to enable the clearcoat layer all the time — since the default settings
    effectively disable it — doing so is highly inefficient. The clearcoat layer adds
    secondary BRDF sampling, which is computationally expensive. It is better to use
    only the expensive features that are actually needed!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'That’s it for the C++ changes. Now, let’s look at the GLSL shader changes,
    where the actual rendering work takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the C++ changes for new parameters, we added GLSL utility functions
    to read clearcoat data from textures and input buffers in `data/shaders/gltf/inputs.frag`.
    The clearcoat factor and roughness are packed into a texture as `r` and `g` channels
    respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We calculate the clearcoat contribution as described in the beginning of this
    recipe. We use the GGX BRDF to perform an additional lookup and provide clearcoat
    roughness, reflectance `clearcoatF0`, and normal as inputs in `data/shaders/gltf/main.frag`.
    Please note that we use the IOR parameter, which will be covered later in the
    recipe *Implementing the IOR extension*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We calculate the Fresnel term for the clearcoat layer using a similar approach.
    We apply the Schlick approximation, but with input data specific to the clearcoat:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Finally, at the very end of the fragment shader `data/shaders/gltf/main.frag`,
    we apply the clearcoat contribution on top of all layers, including emissive ones!
    Note the `sheenColor` value here, which will be covered in the next recipe *Implementing
    the sheen material extension*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This concludes all the necessary GLSL changes to implement the clearcoat extension.
    The demo app should look like the screenshot below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: glTF PBR KHR_materials_clearcoat example](img/file52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: glTF PBR KHR_materials_clearcoat example'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the glossy layer on top of the ball—this is the clearcoat! Congratulations,
    we’ve completed our first advanced PBR extension.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Khronos glTF extensions repository includes a comprehensive list of references
    for clearcoat materials: [https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the KHR_materials_sheen extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `KHR_materials_sheen` extension improves the glTF 2.0 Metallic-Roughness
    material by adding a layer that simulates the sheen effect found on fabrics like
    satin or brushed metals. This enhancement creates more realistic and visually
    appealing sheen highlights.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sheen BRDF** sits on top of the glTF 2.0 Metallic-Roughness material. If
    the previous extension `KHR_materials_clearcoat` is also active, it is layered
    on top of the sheen effect.'
  prefs: []
  type: TYPE_NORMAL
- en: The `sheenColorFactor` property controls the base intensity of the sheen effect,
    independent of the viewing angle. A value of `0` disables **sheen** entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Sheen parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*sheenColorTexture / sheenColorFactor*: If the texture is defined, the sheen
    color is calculated by multiplying `sheenColorFactor` and the texture’s RGB value.'
  prefs: []
  type: TYPE_NORMAL
- en: '*sheenRoughnessTexture / sheenRoughnessFactor:* If defined, the sheen roughness
    is calculated by multiplying with the texture’s alpha channel value.'
  prefs: []
  type: TYPE_NORMAL
- en: If no textures are specified, `sheenColorFactor` directly controls the sheen
    color, and `sheenRoughnessFactor` directly controls sheen roughness.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating the sheen effect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **sheen BRDF** simulates how light scatters off velvet-like materials.
    It models how light bounces off tiny fibers that are oriented perpendicular to
    the surface. Sheen roughness controls how much these fibers deviate from that
    direction:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lower sheen roughness: the fibers are more aligned, creating a sharper sheen
    highlight when light grazes the surface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Higher sheen roughness: the fibers are more scattered, leading to a softer
    sheen highlight.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sheen BRDF is mathematically based on an exponentiated sinusoidal distribution,
    derived from the microfacet theory (Conty & Kulla, 2017 [https://blog.selfshadow.com/publications/s2017-shading-course/#course_content](https://blog.selfshadow.com/publications/s2017-shading-course/#course_content)).
    The roughness is mapped using `r=sheenRoughness^2` for a more intuitive understanding
    of roughness changes.
  prefs: []
  type: TYPE_NORMAL
- en: Sheen roughness operates independently of the material’s base roughness. This
    makes it possible for a material to have a rough surface texture (high base roughness)
    while still displaying a sharp sheen effect (low sheen roughness).
  prefs: []
  type: TYPE_NORMAL
- en: Not all incoming light interacts with the microfibers. Some light may directly
    reach the base layer or bounce between the fibers before doing so. The behavior
    of this light is governed by the underlying glTF 2.0 PBR Metallic-Roughness material
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for this recipe can be found in `Chapter07/02_Sheen/`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to the previous recipe *Implementing the clear coat material extension*,
    we introduce a bunch of new material parameters . Let’s take a look at the C++
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s load a `.gltf` file to demonstrate the effect `Chapter07/02_Sheen/src/main.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the file `shared/UtilsGLTF.h`, we added new member fields to the `GLTFMaterialDataGPU`
    structure in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s load new parameters via Assimp in `shared/UtilsGLTF.cpp` and store them
    into the sheen material. The sheen color texture is `sRGB` and has the index `0`
    and the roughness texture has the index of `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we follow the same pattern as with the clearcoat extension and
    set the flag `MaterialType_Sheen` only when we use this extension. This is it
    for the main C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: The Sheen extension needs a different BRDF function, which was discussed in
    the recipe *Precomputing BRDF look-up tables* of the previous *Chapter 6, Physically
    Based Rendering Using the glTF 2.0 Shading Model*. We recommend reviewing that
    recipe to refresh your understanding of how precomputed BRDF LUTs work and revisiting
    the implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s take a look at the GLSL shader code changes which follow a similar
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s introduce some utility functions in `data/shaders/gltf/inputs.frag`.
    We can simplify these functions by pre-multiplying textures values by sheen factors.
    In the C++ code, we set `sheenColorTexture` and `sheenRoughnessTexture` to use
    a white 1x1 texture in case when no texture data is provided in the `.gltf` asset.
    In this case, it is always correct to multiply these values by identity factors.
    We still perform a texture lookup for this small texture, but the overhead is
    minimal. These small textures should always fit into the GPU’s fastest cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The GLSL code of the sheen extension is scattered between the main fragment
    shader `data/shaders/gltf/main.frag` and the PBR module `data/shaders/gltf/PBR.sp`.
    In `main.frag`, we apply sheen parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next step during IBL calculations, we accumulate the sheen contribution
    calculated using the Charlie distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a look at the implementation of `getIBLRadianceCharlie()` in the
    file `data/shaders/gltf/PBR.sp`. This function is similar to `getIBLRadianceGGX()`
    used for metallic-roughness, but is much simpler. The Sheen extension provides
    its own roughness value, so no perceptual adjustments are needed. All we have
    to do here is to multiply `sheenRoughnessFactor` by the total number of mip-levels
    `mipCount` to determine the correct mip-level, sample the precalculated environment
    map, and then multiply it by the `BRDF` and `sheenColor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go back to `data/shaders/gltf/main.frag`. We modify the sheen contribution
    based on the value of `occlusionStrength`. Light’s The l sheen calculation `lights_sheen`
    will be covered in the last recipe *Extend analytical lights support* in this
    chapter. For now, assume it is just zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all the additional code required to implement the Sheen extension.
    The running demo app should look as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: glTF PBR KHR_materials_sheen example](img/file53.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: glTF PBR KHR_materials_sheen example'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Khronos glTF extensions repository has a comprehensive list of references
    to sheen materials: [https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_sheen/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_sheen/README.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the KHR_materials_transmission extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The glTF 2.0 core specification uses a basic method for handling transparency
    called **alpha-as-coverage**. While this approach works well for simple materials
    like gauze or burlap, it doesn’t do a good job of representing more complex transparent
    materials like glass or plastic. These materials involve complicated light interactions—such
    as reflection, refraction, absorption, and scattering—that alpha-as-coverage can’t
    accurately simulate on its own.
  prefs: []
  type: TYPE_NORMAL
- en: Alpha-as-coverage basically decides if a surface is there or not. A value of
    `0` means nothing is visible, while a value of `1` means the surface is solid.
    This method works well for materials with holes or gaps that let light pass through
    without actually entering the material. However, for materials like glass, light
    interacts with the surface in more complex ways—like reflecting, refracting, or
    even being absorbed. Alpha-as-coverage can’t handle these kinds of interactions.
    Additionally, it affects how intense reflections are, making more transparent
    materials have weaker reflections. This is the opposite of what happens with real-world
    transparent materials, which often have strong reflections even when they’re see-through.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome the limitations of alpha-as-coverage, the `KHR_materials_transmission`
    extension offers a more realistic way to render transparent materials in glTF.
    It allows for the simulation of materials that absorb, reflect, and transmit light
    depending on the angle of incidence and the light’s wavelength. This extension
    is especially useful for accurately representing thin-surface materials like plastic
    and glass.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `KHR_materials_transmission` extension targets the simplest cases of optical
    transparency: infinitely thin materials without refraction, scattering, or dispersion.
    This simplification enables efficient calculations of refraction and absorption.'
  prefs: []
  type: TYPE_NORMAL
- en: Transmission parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `KHR_materials_transmission` extension adds new properties to define material’s
    transmission characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '*transmissionFactor*: A scalar value between `0` and `1` that represents the
    material’s overall opacity. A value of `0` means the material is fully opaque,
    while a value of `1` means it is completely transparent.'
  prefs: []
  type: TYPE_NORMAL
- en: '*transmissionFilter*: A color value that alters the color of the light passing
    through the material.'
  prefs: []
  type: TYPE_NORMAL
- en: Transmission BTDF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `KHR_materials_transmission` extension introduces a specular **BTDF** (Bidirectional
    Transmission Distribution Function) based on the microfacet model. It uses the
    same **Trowbridge-Reitz** distribution as the specular **BRDF** (Bidirectional
    Reflectance Distribution Function) but samples along the view vector instead of
    the reflection direction. This method simulates how microfacets act like tiny
    prisms, blurring the transmitted light.
  prefs: []
  type: TYPE_NORMAL
- en: The transmission process is modeled as two back-to-back surfaces, representing
    a thin material. This approach simplifies the process by avoiding the complexities
    of average refraction and instead focusing on refraction at the microfacet level.
    The roughness parameter affects both reflection and transmission since the microfacet
    distribution impacts both sides of the surface. Let’s take a look at how to implement
    this glTF extension.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for this recipe can be found in `Chapter07/03_Transmission/`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the most complex extension discussed in this chapter, requiring changes
    to the C++ code to handle the complexities of transparency rendering. In addition
    to updating the C++ rendering code, we need to implement a specular BTDF in the
    GLSL shader code and incorporate the blending of two layers to accurately represent
    a thin material.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with C++ changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we should load a corresponding `.gltf` sample model in `Chapter07/03_Transmission/src/main.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters parsing is in `shared/UtilsGLTF.cpp` and quite simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Significant changes have been made to the rendering function `renderGLTF()`.
    We touched on some of these in the first recipe *Introduction to glTF PBR extensions*.
    Now, let’s take a closer look at these changes. To effectively render transparent
    and transmission surfaces, we need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepare lists of completely opaque, transmission, and transparent nodes, because
    these should be rendered in a particular order: opaque nodes first, then transmission,
    and then transparent.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep in mind that rendering transmission nodes doesn’t automatically make them
    transparent! Instead, we need to use the result from rendering opaque nodes. To
    do this, we must create a copy of the rendered surface and use it as input for
    the transmission nodes.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Pre-allocate an offscreen texture to store the rendered opaque nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Create a screen copy when necessary and pass its handle as `transmissionFramebuffer:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can render transmission nodes using the screen copy as input. It’s important
    to note that we’re not using alpha blending for this pass. The nodes are still
    rendered as opaque, and we simulate transparency by sampling the screen copy.
    We also specify a texture dependency for LightweightVK here to ensure the correct
    Vulkan barriers are applied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to render all transparent nodes in back-to-front order. We
    did not change push constants and these transparent nodes use the same offscreen
    texture as input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is it for the C++ changes. Let’s take a look at the GLSL shader changes
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we introduce a utility function in `data/shaders/gltf/inputs.frag` to
    read material inputs. The transmission factor is stored in the `r` channel of
    the texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we populate inputs in `data/shaders/gltf/main.frag` if the transmission
    extension is enabled for this material:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We calculate the transmission contribution. The volumetric part will be covered
    in detail in our next recipe for the `KHR_materials_volume` extension *Implementing
    the volume extension*. In a pure transmission implementation without the volume
    extension, the transmission part would be similar to GGX/Lambertian, but instead
    of using the reflection vector, we use the dot product `NdotV`. Implementing just
    the transmission extension without volume support is not practical, as the volume
    extension offers greater flexibility to represent effects like refraction, absorption,
    or scattering without adding excessive complexity on top of transmission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add the calculated transmission value to the diffuse contribution
    scaled by `transmissionFactor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting rendered 3D model should look as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: glTF PBR KHR_materials_transmission example](img/file54.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: glTF PBR KHR_materials_transmission example'
  prefs: []
  type: TYPE_NORMAL
- en: There is more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rendering transparent objects efficiently and accurately in real-time is challenging,
    particularly when dealing with overlapping transparent polygons. Issues such as
    order-dependent transparency and the need for separate blending operations for
    absorption and reflections add to the complexity. We will address some of these
    issues in *Chapter 11, Advanced Rendering Techniques and Optimizations*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Khronos extensions repository provides comprehensive reference materials
    for the transmission extension: [https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the KHR_materials_volume extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `KHR_materials_volume` extension adds volumetric effects to the glTF 2.0
    ecosystem, enabling the creation of materials with depth and internal structure.
    It’s crucial for accurately rendering materials such as smoke, fog, clouds, and
    translucent objects.
  prefs: []
  type: TYPE_NORMAL
- en: Volumetric effects are different from surface-based materials. While surface-based
    materials focus on how light interacts with a surface, volumetric materials describe
    how light moves through a medium. This includes simulating how light scatters
    and gets absorbed as it passes through the volume.
  prefs: []
  type: TYPE_NORMAL
- en: To create realistic volumetric effects, the `KHR_materials_volume` extension
    needs to work alongside other extensions that define light interactions with the
    material’s surface. The `KHR_materials_transmission` extension is key here, as
    it lets light rays pass through the surface and enter the volume. Once inside,
    the light’s interaction with the material is no longer affected by the surface
    properties. Instead, the light travels through the volume, undergoing refraction
    and attenuation. When it exits the volume, its direction is determined by the
    angle at which it leaves the volume boundary.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore how to add this extension to our glTF renderer.
  prefs: []
  type: TYPE_NORMAL
- en: Volumetric parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `KHR_materials_volume` extension defines the following parameters to describe
    a volumetric material:'
  prefs: []
  type: TYPE_NORMAL
- en: '**thicknessFactor**: A scalar floating-point value that represents the base
    thickness of the volume. This value is multiplied by the thickness texture value
    (if available) to determine the final thickness at any point on the surface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**attenuationDistance**: A floating-point value that indicates the distance
    over which the volume’s density decreases. This parameter controls how quickly
    the volume’s opacity fades as light passes through it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**attenuationColo***r*: A color value representing the base color of the volume’s
    attenuation. This color influences how light is absorbed as it travels through
    the volume.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**thicknessTexture**: An optional texture that adds extra detail about the
    volume’s thickness. The values in the texture are multiplied by the `thicknessFactor`
    to determine the final thickness at each point on the surface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s how these parameters work together:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Thickness**: The `thicknessFactor` and `thicknessTexture` are multiplied
    to define the volume’s depth. A higher thickness value results in a thicker volume.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attenuation**: The `attenuationDistance` and `attenuationColor` control how
    light is absorbed as it travels through the volume. A smaller value of `attenuationDistance`
    leads to quicker attenuation. The value of `attenuationColor` determines the color
    change due to absorption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `KHR_materials_volume` extension currently assumes a homogeneous volume,
    where the material properties are uniform throughout. Future extensions may add
    support for heterogeneous volumes with varying properties.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for this recipe can be found in `Chapter07/04_Volume/`. Please
    review the previous recipe *Implementing the transmission extension*, where we
    covered the transmission and volumetric C++ rendering flow.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This extension requires only a handful of changes across our existing C++ and
    GLSL shader code. This extension requires `KHR_materials_transmission` support
    and works only in conjunction with it.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore how to create advanced volumetric effects such as refraction,
    absorption, or scattering, starting with the C++.++. code
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we load a corresponding `.gltf` model in `Chapter07/04_Volume/main.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Parsing the volume parameters using Assimp in `shared/UtilsGLTF.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Most of the magic is hidden in GLSL shaders. Let’s step inside `data/shaders/gltf/PBR.sp`
    and check important helper functions.
  prefs: []
  type: TYPE_NORMAL
- en: The function `getVolumeTransmissionRay()` calculates the direction of refracted
    light `refractionVector` and uses the `modelScale` factor to get an actual lookup
    vector inside a volume. Note that the `thickness` factor is designed to be normalized
    to the actual scale of the mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Compute rotation-independent scaling of the model matrix. The `thickness` factor
    is specified in local space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Another helper function is `getIBLVolumeRefraction()`. This function has several
    important steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to get a transmission ray `transmissionRay` and calculate
    the final refraction position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We project the refracted vector onto the framebuffer and map it to normalized
    device coordinates to sample the color of the pixel where the refracted ray hits
    the framebuffer. The refracted framebuffer coordinates should be transformed from
    the `-1...+1` range into `0...1` and then flipped vertically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we apply volume attenuation and sample GGX BRDF to get the specular
    component and modulate it by `baseColor` and `attenuatedColor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the function `getTransmissionSample()`. We use a copy of the framebuffer
    as we explained in the previous recipe *Implementing the transmission extension*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The helper function `applyVolumeAttenuation()` looks as follows. The attenuation
    distance of `0` means the transmitted color is not attenuated at all. Light attenuation
    is computed using Beer-Lambert law [https://en.wikipedia.org/wiki/Beer%E2%80%93Lambert_law](https://en.wikipedia.org/wiki/Beer%E2%80%93Lambert_law):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can go back to `data/shaders/gltf/main.frag` and use `getIBLVolumeRefraction()`,
    together with other helper functions as described in the previous recipe *Implementing
    the transmission extension*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The resulting demo application should render a translucent dragon, similar to
    the screenshot below. You can move the camera around the dragon to observe how
    light interacts with the volume from different angles. This will allow you to
    see how the light passes through the medium and interacts with the volumetric
    material.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file55.png)Figure 7.5: glTF PBR KHR_materials_volume example'
  prefs: []
  type: TYPE_NORMAL
- en: 'After we explored a range of complex PBR glTF extensions, it is time to switch
    gears. Let’s take a look at something a bit more straightforward: implementing
    the **Index-of-Refraction** extension. This simpler extension is a great way to
    continue building your understanding while giving you a break from the more complex
    topics we have covered.'
  prefs: []
  type: TYPE_NORMAL
- en: There is more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alternative way to implement this extension could involve volume ray-casting
    or ray-tracing. We leave that as an exercise for our readers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Khronos extensions repository provides comprehensive reference materials
    for this extension: [https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#overview](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#overview).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the KHR_materials_ior extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `KHR_materials_ior` extension for glTF 2.0 adds the concept of **Index-of-Refraction**
    (**IOR**) to materials, allowing for more accurate and realistic simulations of
    transparent objects. IOR is a key material property that dictates how light bends
    when it passes through a substance [https://en.wikipedia.org/wiki/Refractive_index](https://en.wikipedia.org/wiki/Refractive_index).
  prefs: []
  type: TYPE_NORMAL
- en: The **IOR** is a dimensionless number that shows the ratio of the speed of light
    in a vacuum to its speed in a particular medium. Different materials have different
    IOR values, which influence how light bends when it enters or exits the material.
    A higher IOR means more refraction. For instance, the IOR of air is nearly `1`,
    water has an IOR of about `1.33`, and glass has an IOR of around `1.5`.
  prefs: []
  type: TYPE_NORMAL
- en: IOR parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `KHR_materials_ior` extension adds a single property to the glTF material
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*ior*: A floating-point value representing the index-of-refraction of the material.'
  prefs: []
  type: TYPE_NORMAL
- en: This value is used in conjunction with the `KHR_materials_transmission` extension
    to calculate the refraction direction of light rays when passing through the material.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for this recipe can be found in `Chapter07/05_IOR/`. Check out
    the recipe *Implementing the transmission extension* to recap how `KHR_materials_transmission`
    is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This extension requires only a handful of changes across C++ and GLSL shader
    code. Let’s start with C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Chapter07/05_IOR/main.cpp`, load a corresponding `.gltf` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here is the code in `shared/UtilsGLTF.cpp` for parsing the IOR material parameter
    with Assimp. You will notice that we don’t set any material flag, it’s not needed.
    IOR is just a value and does not alter the functionality of shaders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here goes the GLSL shader code. We need to modify a couple lines:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line is in the PBR module `data/shaders/gltf/PBR.sp` in the function
    `calculatePBRInputsMetallicRoughness()`. The default index of refraction value,
    `ior = 1.5`, results in the `f0` term being calculated as `0.04`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The second line is in `data/shaders/gltf/main.frag` and modifies the clearcoat
    reflectance value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s it! The application should now render a mosquito encased in a piece
    of amber, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: glTF PBR KHR_materials_ior example](img/file56.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: glTF PBR KHR_materials_ior example'
  prefs: []
  type: TYPE_NORMAL
- en: There is more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The official extension specification includes a normative section that explains
    how this glTF extension `KHR_material_ior` interacts with other extensions: [https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_ior/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_ior/README.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the KHR_materials_specular extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed the **Specular-Glossiness** PBR model.
    One of its main issues is the lack of compatibility with most other extensions.
    This is because it introduces non-physically based material properties, including
    an unclear distinction between dielectrics and metals in specular-glossiness mode,
    which makes it impossible to combine with the metallic-roughness model or other
    extension properties.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative, Khronos proposed the `KHR_materials_specular` extension,
    which addresses these issues and offers the functionality of `KHR_materials_pbrSpecularGlossiness`
    without compromising the physical accuracy of the **Metallic-Roughness** PBR model.
    This makes it compatible with most glTF PBR extensions. At the time of writing,
    the `KHR_materials_specular` extension is only incompatible with the `KHR_materials_pbrSpecularGlossiness`
    and `KHR_materials_unlit` extensions.
  prefs: []
  type: TYPE_NORMAL
- en: The `KHR_materials_specular` extension allows for more precise control over
    specular reflections in glTF materials. While the core glTF specification includes
    a basic specular BRDF, this extension introduces additional parameters to better
    fine-tune the appearance of specular highlights.
  prefs: []
  type: TYPE_NORMAL
- en: Specular parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `KHR_materials_specular` extension introduces several parameters to enhance
    specular reflections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**specularFactor/specularTexture**: A scalar value that scales the overall
    intensity of the specular reflection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**specularColorFactor/specularColorTexture**: A color value that modifies the
    color of the specular reflection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specular-Glossiness conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can convert **Specular-Glossiness** materials to the **Metallic-Roughness**
    workflow using the `KHR_materials_ior` extension described in the previous recipe
    *Implementing the index-of-refraction extension*. By setting the `IOR` parameter
    to `0`, the material is treated as a dielectric with the maximum specular reflection.
    The `IOR` parameter controls the upper limit of the specular reflection’s strength,
    and setting it to `0` maximizes this strength, allowing full control over specular
    reflection through the `specularColorFactor`. This method eliminates the need
    to classify materials as either dielectric or metallic. It’s important to note
    that materials using the `KHR_materials_volume` extension are incompatible with
    this conversion due to their non-zero `IOR` value. For new materials, it’s often
    better to use the **Metallic-Roughness** model directly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for this recipe can be found in `Chapter07/06_Specular/`. Reread
    two previous recipes *Implementing the index-of-refraction extension* and *Implementing
    the volume extension* as this extension interacts with them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This extension doesn’t require any major changes to the C++ code, aside from
    reading the additional material properties via Assimp:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s load a new `.gltf` model in `Chapter07/06_Specular/src/main.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this example more interesting, we added rotation to our 3D model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s load material properties in `shared/UtilsGLTF.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: GLSL shader changes are a bit more complex. The `specularColor` parameter introduces
    color variations into the specular reflection. It is integrated into the Fresnel
    term, influencing the specular reflectance at different viewing angles. At normal
    incidence, the specular color directly scales the base reflectance (`F0`), while
    at grazing angles, the reflectance approaches `1.0` regardless of the specular
    color. To maintain energy conservation, the maximum component of the specular
    color is used to calculate the scaling factor for the Fresnel term, preventing
    excessive energy in the specular reflection.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we introduce some utility functions in `data/shaders/gltf/inputs.frag`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We add a new field `specularWeight` to the `PBRInfo` structure in `data/shaders/gltf/PBR.sp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We modify the method for obtaining the `F0` reflectance and populate the `specularWeigthspecularWeigthh`
    field in the `calculatePBRInputsMetallicRoughness()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use these parameters in `data/shaders/gltf/main.frag` to calculate
    the specular and diffuse components of the IBL contribution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the specular contribution is calculated. Please note that we multiply
    by `specularWeight` at the end of the function `getIBLRadianceContributionGGX()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The diffuse contribution looks like this. Note that we scale the Fresnel term
    and replace it with a `vec3` RGB value to incorporate the `specularColor` contribution
    into `F0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Those are all the changes required to implement the `KHR_materials_specular`
    extension in our glTF renderer. The demo application should render a rotating
    torus as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7: glTF PBR KHR_materials_specular example](img/file57.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: glTF PBR KHR_materials_specular example'
  prefs: []
  type: TYPE_NORMAL
- en: For further details on the motivation behind this approach, please refer to
    the Khronos specification [https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md#implementation](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md#implementation).
  prefs: []
  type: TYPE_NORMAL
- en: There is more…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Khronos extension page [https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md)
    provides comprehensive information on various aspects of the extension. It includes
    detailed explanations of the BRDF and additional insights into converting between
    different PBR models.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the KHR_materials_emissive_strength extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The metallic-roughness core model supports light emission, but before the introduction
    of the `KHR_materials_emissive_strength` extension, it was difficult to control
    the intensity of a material’s light emission. This made it challenging to create
    realistic glowing objects or materials that function as light sources in a scene.
  prefs: []
  type: TYPE_NORMAL
- en: The `KHR_materials_emissive_strength` extension overcomes this limitation by
    introducing a new property called *emissiveStrength*. This property allows for
    precise control over the intensity of a material’s emitted light. With values
    ranging from `0.0` for no emission to higher values for increased intensity, artists
    and designers gain more control over the lighting in their scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for this recipe can be found in `Chapter07/07_EmissiveStrength/`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This extension is one of the simplest to implement. All it requires is loading
    an intensity value and applying it to the existing emissive value. Essentially,
    you only need to take the `emissiveStrength` property from Assimp, which determines
    how intense the material’s emitted light should be, and multiply it by the emissive
    color.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s load a new 3D model in `Chapter07/07_EmissiveStrength/src/main.cpp` to
    demonstrate this extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the C++ code in `shared/UtilsGLTF.cpp` to retrieve the material properties
    from Assimp:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting demo app should render a set of five glowing cubes, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8: glTF PBR KHR_materials_emissive_strength example](img/file58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: glTF PBR KHR_materials_emissive_strength example'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s jump to the final recipe of this chapter, where we will dive into
    implementing support for glTF analytical lights.
  prefs: []
  type: TYPE_NORMAL
- en: Extend analytical lights support with KHR_lights_punctual
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the final recipe in this chapter, and we will add support for analytical
    light sources to our glTF viewer. In the next chapter, we will cover the `KHR_lights_punctual`
    extension, which will allow us to load lighting information directly from glTF
    assets. In this recipe, we will only be dealing with shader changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of glTF PBR, the terms “analytical” and “punctual” lights are
    often used interchangeably to describe the same type of light source:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Analytical light**: This refers to light sources defined by mathematical
    equations, enabling precise calculations of its effect on lighting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Punctual light**: This describes light sources that are infinitely small
    points that emit light in specific directions and intensities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore these concepts in more detail in the next chapter. In this recipe,
    fFor simplicity, we’ll use both terms interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: Image-Based Lighting vs Punctual lights
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s refresh the difference between Image-Based (IBL) and punctual lights.
  prefs: []
  type: TYPE_NORMAL
- en: IBL simulates indirect lighting from the environment using a pre-computed environment
    map. In glTF PBR, this environment map is filtered based on roughness and normal
    direction to approximate incoming radiance. The reflected light is calculated
    using **BRDF** (**Bidirectional Reflectance Distribution Function**) based on
    the surface material properties, with integration performed over the hemisphere
    to account for light coming from all directions. Punctual lights, on the other
    hand, represent specific light sources like point, spot, and directional lights.
    For each surface point, the direction and distance to the light are calculated,
    with attenuation applied based on how far the light source is. Shadows are also
    considered to check if the light reaches the surface. The BRDF is then used to
    calculate the reflected light based on the light direction, surface normal, and
    material properties. This method is more computationally expensive than IBL since
    it requires calculating lighting for each individual light source.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at how to add glTF punctual lights to our viewer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for this recipe can be found in `Chapter07/08_AnalyticalLight`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++ code changes are pretty small and straightforward. We introduce additional
    structures to provide light information data.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s load a corresponding `.gltf` model in `Chapter07/08_AnalyticalLight/src/main.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare an enumeration for different light types in `shared/UtilsGLTF.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a structure called `LightDataGPU` to store light information in GPU
    buffers. It has default values defining a dummy directional light:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the light sources in `shared/UtilsGLTF.cpp` as a part of our per-frame
    constants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The changes to the GLSL shader code are substantial. We need to reimplement
    the specular and diffuse contributions for Metallic-Roughness and other extensions,
    applying these calculations for each light source individually. In this recipe,
    we will not go too deep into the implementation details, but we strongly recommend
    reviewing the actual shaders and the reference materials provided in the comments
    to fully understand this topic. Here’s a brief glimpse of the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s introduce a couple of utility functions in `data/shaders/gltf/inputs.frag`
    to conveniently access the light data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'In `data/shaders/gltf/main.frag`, we introduce accumulation variables for each
    individual contribution component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We iterate over all light sources, calculating the necessary terms for each
    one and checking if the light source is visible from the rendering point. Then
    we calculate the light intensity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating all lights for every object can be quite costly. Alternatives like
    clustered or deferred shading can help improve performance in this situation.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Then we calculate diffuse and specular contributions for this light:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The sheen contribution is now calculated as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The new clearcoat contribution is calculated in a similar way. Transmission
    and volume contributions are skipped here for the sake of brevity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We used a helper function `getLightIntensity()` which is declared in `data/shaders/gltf/PBR.sp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Other helper functions, such as `getBRDFLambertian()`, `getBRDFSpecularGGX()`,
    `getBRDFSpecularSheen()`, `getPunctualRadianceSheen()`, and many others mentioned
    in the GLSL code earlier, are defined in `data/shaders/gltf/PBR.sp`. These functions
    contain the math for calculating the specific terms. For brevity, we do not include
    them here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The running application should render a mesh illuminated by an analytical directional
    light, as shown in the screenshot below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9: Analytical lights example](img/file59.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: Analytical lights example'
  prefs: []
  type: TYPE_NORMAL
- en: With this example, we wrap up our chapter on advanced glTF PBR extensions. We
    have delved into complex topics and extended our understanding of how to work
    with various lighting models and extensions. In the next chapter, *Graphics Rendering
    Pipeline*, we will shift our focus to the broader organization of 3D scenes. We
    will explore various data structures and strategies needed to efficiently manage
    and render multiple 3D models. This will involve a detailed look at how to structure
    and optimize data for rendering, ensuring smooth and effective visualization of
    complex scenes.
  prefs: []
  type: TYPE_NORMAL
