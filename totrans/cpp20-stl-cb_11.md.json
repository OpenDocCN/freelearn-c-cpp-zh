["```cpp\n    using ilcstr = initializer_list<const char *>;\n    ```", "```cpp\n    namespace bw {\n        using std::map;\n        using std::deque;\n        using std::initializer_list;\n    ```", "```cpp\n    class trie {\n        using get_t = deque<deque<string>>;\n        using nodes_t = map<string, trie>;\n        using result_t = std::optional<const trie*>;\n        nodes_t nodes{};\n        mutable get_t result_dq{};\n        mutable deque<string> prefix_dq{};\n    ```", "```cpp\n    void insert(const ilcstr& il) {\n        _insert(il.begin(), il.end());\n    }\n    ```", "```cpp\ntemplate <typename It>\nvoid _insert(It it, It end_it) {\n    if(it == end_it) return;\n    nodes[*it]._insert(++it, end_it);\n}\n```", "```cpp\n    get_t& get() const {\n        result_dq.clear();\n        deque<string> dq{};\n        _get(dq, result_dq);\n        return result_dq;\n    }\n    ```", "```cpp\nvoid _get(deque<string>& dq, get_t& r_dq) const {\n    if(empty()) {\n        r_dq.emplace_back(dq);\n        dq.clear();\n    }\n    for(const auto& p : nodes) {\n        dq.emplace_back(p.first);\n        p.second._get(dq, r_dq);\n    }\n}\n```", "```cpp\n    deque<string>& find_prefix(const char * s) const {\n        _find_prefix(s, prefix_dq);\n        return prefix_dq;\n    }\n    ```", "```cpp\nvoid _find_prefix(const string& s, auto& pre_dq) const {\n    if(empty()) return;\n    for(const auto& [k, v] : nodes) {\n        if(k.starts_with(s)) {\n            pre_dq.emplace_back(k);\n            v._find_prefix(k, pre_dq);\n        }\n    }\n}\n```", "```cpp\nif(k.find(s) == 0) {\n    ...\n```", "```cpp\n    result_t search(const ilcstr& il) const {\n        return _search(il.begin(), il.end());\n    }\n    result_t search(const string& s) const {\n        const ilcstr il{s.c_str()};\n        return _search(il.begin(), il.end());\n    }\n    ```", "```cpp\ntemplate <typename It>\nresult_t _search(It it, It end_it) const {\n    if(it == end_it) return {this};\n    auto found_it = nodes.find(*it);\n    if(found_it == nodes.end()) return {};\n    return found_it->second._search(++it, end_it);\n}\n```", "```cpp\n    void print_trie_prefix(const bw::trie& t,\n            const string& prefix) {\n        auto& trie_strings = t.get();\n        cout << format(\"results for \\\"{}...\\\":\\n\", prefix);\n        for(auto& dq : trie_strings) {\n            cout << format(\"{} \", prefix);\n            for(const auto& s : dq) cout << format(\"{} \", s);\n            cout << '\\n';\n        }\n    }\n    void print_trie_prefix(const bw::trie& t,\n            const ilcstr & prefix) {\n        string sprefix{};\n        for(const auto& s : prefix) sprefix += \n            format(\"{} \", s);\n        print_trie_prefix(t, sprefix);\n    }\n    ```", "```cpp\n    int main() {\n        bw::trie ts;\n        ts.insert({ \"all\", \"along\", \"the\", \"watchtower\" });\n        ts.insert({ \"all\", \"you\", \"need\", \"is\", \"love\" });\n        ts.insert({ \"all\", \"shook\", \"up\" });\n        ts.insert({ \"all\", \"the\", \"best\" });\n        ts.insert({ \"all\", \"the\", \"gold\", \"in\",\n            \"california\" });\n        ts.insert({ \"at\", \"last\" });\n        ts.insert({ \"love\", \"the\", \"one\", \"you're\",        \"with\" });\n        ts.insert({ \"love\", \"me\", \"do\" });\n        ts.insert({ \"love\", \"is\", \"the\", \"answer\" });\n        ts.insert({ \"loving\", \"you\" });\n        ts.insert({ \"long\", \"tall\", \"sally\" });\n        ...\n    ```", "```cpp\n    const auto prefix = {\"love\"};\n    if (auto st = ts.search(prefix); st.have_result) {\n        print_trie_prefix(*st.t, prefix);\n    }\n    cout << '\\n';\n    ```", "```cpp\nresults for \"love...\":\nlove is the answer\nlove me do\nlove the one you're with\n```", "```cpp\n    const auto prefix = {\"all\", \"the\"};\n    if (auto st = ts.search(prefix); st.have_result) {\n        print_trie_prefix(*st.t, prefix);\n    }\n    cout << '\\n';\n    ```", "```cpp\nresults for \"all the ...\":\nall the  best\nall the  gold in california\n```", "```cpp\n    const char * prefix{ \"lo\" };\n    auto prefix_dq = ts.find_prefix(prefix);\n    for(const auto& s : prefix_dq) {\n        cout << format(\"match: {} -> {}\\n\", prefix, s);\n        if (auto st = ts.search(s); st.have_result) {\n            print_trie_prefix(*st.t, s);\n        }\n    }\n    cout << '\\n';\n    ```", "```cpp\nmatch: lo -> long\nresults for \"long...\":\nlong tall sally\nmatch: lo -> love\nresults for \"love...\":\nlove is the answer\nlove me do\nlove the one you're with\nmatch: lo -> loving\nresults for \"loving...\":\nloving you\n```", "```cpp\nusing nodes_t = map<string, trie>\n```", "```cpp\ntemplate <typename It>\nvoid _insert(It it, It end_it) {\n    if(it == end_it) return;\n    nodes[*it]._insert(++it, end_it);\n}\n```", "```cpp\ntemplate <typename It>\nresult_t _search(It it, It end_it) const {\n    if(it == end_it) return {this};\n    auto found_it = nodes.find(*it);\n    if(found_it == nodes.end()) return {};\n    return found_it->second._search(++it, end_it);\n}\n```", "```cpp\n    int main() {\n        constexpr size_t vlen{ 100 };\n        vector<double> ds(vlen);\n        vector<int> is(vlen);\n        size_t index{};\n        ...\n    ```", "```cpp\n    auto sin_gen = [&index]{\n      return 5.0 * sin(index++ * 2 * pi / 100);\n    };\n    for(auto& v : ds) v = sin_gen();\n    ```", "```cpp\n    index = 0;\n    for(auto& v : is) {\n        v = static_cast<int>(round(ds.at(index++)));\n    }\n    ```", "```cpp\n    for(const auto& v : ds) cout << format(\"{:-5.2f} \", v);\n    cout << \"\\n\\n\";\n    for(const auto& v : is) cout << format(\"{:-3d} \", v);\n    cout << \"\\n\\n\";\n    ```", "```cpp\n0.00  0.31  0.63  0.94  1.24  1.55  1.84  2.13  2.41\n0.00  0.31  0.63  0.94  1.24  1.55  1.84  2.13  2.41\n2.68  2.94  3.19  3.42  3.64  3.85  4.05  4.22  4.38\n4.52  4.65  4.76  4.84  4.91  4.96  4.99  5.00  4.99\n4.96  4.91  4.84  4.76  4.65  4.52  4.38  4.22  4.05\n3.85  3.64  3.42  3.19  2.94  2.68  2.41  2.13  1.84\n1.55  1.24  0.94  0.63  0.31  0.00 -0.31 -0.63 -0.94 -1.24 -1.55 -1.84 -2.13 -2.41 -2.68 -2.94 -3.19 -3.42 -3.64 -3.85 -4.05 -4.22 -4.38 -4.52 -4.65 -4.76 -4.84 -4.91 -4.96 -4.99 -5.00 -4.99 -4.96 -4.91 -4.84 -4.76 -4.65 -4.52 -4.38 -4.22 -4.05 -3.85 -3.64 -3.42 -3.19 -2.94 -2.68 -2.41 -2.13 -1.84 -1.55 -1.24 -0.94 -0.63 -0.31\n0   0   1   1   1   2   2   2   2   3   3   3   3   4   4 4   4   4   5   5   5   5   5   5   5   5   5   5   5   5 5   5   5   4   4   4   4   4   3   3   3   3   2   2   2 2   1   1   1   0   0   0   -1   -1   -1   -2   -2   -2 -2   -3   -3   -3   -3   -4   -4   -4   -4   -4   -5   -5 -5   -5   -5   -5   -5   -5   -5   -5   -5   -5   -5   -5 -5   -4   -4   -4   -4   -4   -3   -3   -3   -3   -2   -2 -2   -2   -1   -1   -1   0\n```", "```cpp\n    double errsum = inner_product(ds.begin(), ds.end(), \n        is.begin(), 0.0, std::plus<double>(),\n        [](double a, double b){ return pow(a - b, 2); });\n    cout << format(\"error sum: {:.3f}\\n\\n\", errsum);\n    ```", "```cpp\nerror sum: 7.304\n```", "```cpp\nT inner_product(InputIt1 first1, InputIt1 last1,\n    InputIt2 first2, T init, BinaryOperator1 op1,\n    BinaryOperator2 op2)\n```", "```cpp\ncout << \"accumulated error:\\n\";\nfor (auto it{ds.begin()}; it != ds.end(); ++it) {\n    double accumsum = inner_product(ds.begin(), it, \n        is.begin(), 0.0, std::plus<double>(),\n        [](double a, double b){ return pow(a - b, 2); });\n    cout << format(\"{:-5.2f} \", accumsum);\n}\ncout << '\\n';\n```", "```cpp\naccumulated error:\n0.00  0.00  0.10  0.24  0.24  0.30  0.51  0.53  0.55  0.72  0.82  0.82  0.86  1.04  1.16  1.19  1.19  1.24  1.38  1.61  1.73  1.79  1.82  1.82  1.83  1.83  1.83  1.83  1.83  1.84  1.86  1.92  2.04  2.27  2.42  2.46  2.47  2.49  2.61  2.79  2.83  2.83  2.93  3.10  3.12  3.14  3.35  3.41  3.41  3.55  3.65  3.65  3.75  3.89  3.89  3.95  4.16  4.19  4.20  4.37  4.47  4.48  4.51  4.69  4.82  4.84  4.84  4.89  5.03  5.26  5.38  5.44  5.47  5.48  5.48  5.48  5.48  5.48  5.48  5.49  5.51  5.57  5.70  5.92  6.07  6.12  6.12  6.14  6.27  6.45  6.48  6.48  6.59  6.75  6.77  6.80  7.00  7.06  7.07  7.21\n```", "```cpp\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\nbin:x:2:2:bin:/bin:/usr/sbin/nologin\nsys:x:3:3:sys:/dev:/usr/sbin/nologin\nsync:x:4:65534:sync:/bin:/bin/sync\n```", "```cpp\n    namespace bw {\n        template<typename It, typename Oc, typename V,\n            typename Pred>\n        It split(It it, It end_it, Oc& dest,\n                const V& sep, Pred& f) {\n            using SliceContainer = typename \n              Oc::value_type;\n            while(it != end_it) {\n                SliceContainer dest_elm{};\n                auto slice{ it };\n                while(slice != end_it) {\n                    if(f(*slice, sep)) break;\n                    dest_elm.push_back(*slice++);\n                }\n                dest.push_back(dest_elm);\n                if(slice == end_it) return end_it;\n                it = ++slice;\n            }\n            return it;\n        }\n    };\n    ```", "```cpp\nusing SliceContainer = typename Oc::value_type;\n```", "```cpp\ndest.push_back(dest_elm);\n```", "```cpp\n    constexpr auto eq = [](const auto& el, const auto& sep) {\n        return el == sep;\n    };\n    ```", "```cpp\n    template<typename It, typename Oc, typename V>\n    It split(It it, const It end_it, Oc& dest, const V& sep) {\n        return split(it, end_it, dest, sep, eq);\n    }\n    ```", "```cpp\n    template<typename Cin, typename Cout, typename V>\n    Cout& strsplit(const Cin& str, Cout& dest, const V& sep) {\n        split(str.begin(), str.end(), dest, sep, eq);\n        return dest;\n    }\n    ```", "```cpp\n    int main() {\n        constexpr char strsep{ ':' };\n        const string str\n            { \"sync:x:4:65534:sync:/bin:/bin/sync\" };\n        vector<string> dest_vs{};\n        bw::split(str.begin(), str.end(), dest_vs, strsep, \n            bw::eq);\n        for(const auto& e : dest_vs) cout <<\n            format(\"[{}] \", e);\n        cout << '\\n';\n    }\n    ```", "```cpp\n[sync] [x] [4] [65534] [sync] [/bin] [/bin/sync]\n```", "```cpp\n    vector<string> dest_vs2{};\n    bw::strsplit(str, dest_vs2, strsep);\n    for(const auto& e : dest_vs2) cout << format(\"[{}] \", e);\n    cout << '\\n';\n    ```", "```cpp\n[sync] [x] [4] [65534] [sync] [/bin] [/bin/sync]\n```", "```cpp\n    constexpr int intsep{ -1 };\n    vector<int> vi{ 1, 2, 3, 4, intsep, 5, 6, 7, 8, intsep,\n        9, 10, 11, 12 };\n    vector<vector<int>> dest_vi{};\n    bw::split(vi.begin(), vi.end(), dest_vi, intsep);\n    for(const auto& v : dest_vi) {\n        string s;\n        for(const auto& e : v) s += format(\"{}\", e);\n        cout << format(\"[{}] \", s);\n    }\n    cout << '\\n';\n    ```", "```cpp\n[1234] [5678] [9101112]\n```", "```cpp\nusing SliceContainer = typename Oc::value_type;\n```", "```cpp\nSliceContainer dest_elm{};\n```", "```cpp\ndest.push_back(dest_elm);\n```", "```cpp\nvector<int> vint{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\ngather(vint.begin(), vint.end(), mid(vint), is_even);\nfor(const auto& el : vint) cout << el;\n```", "```cpp\n1302468579\n```", "```cpp\n    namespace bw {\n    using std::stable_partition;\n    using std::pair;\n    using std::not_fn;\n    template <typename It, typename Pred>\n    pair<It, It> gather(It first, It last, It pivot,\n            Pred pred) {\n        return {stable_partition(first, pivot, not_fn(pred)),\n                stable_partition(pivot, last, pred)};\n    }\n    };\n    ```", "```cpp\n    constexpr auto midit = [](auto& v) {\n        return v.begin() + (v.end() - v.begin()) / 2;\n    };\n    constexpr auto is_even = [](auto i) {\n        return i % 2 == 0;\n    };\n    constexpr auto is_even_char = [](auto c) {\n        if(c >= '0' && c <= '9') return (c - '0') % 2 == 0;\n        else return false;\n    };\n    ```", "```cpp\n    int main() {\n        vector<int> vint{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n        auto gathered_even = bw::gather(vint.begin(),\n            vint.end(), bw::midit(vint), bw::is_even);\n        for(const auto& el : vint) cout << el;\n        cout << '\\n';\n    }\n    ```", "```cpp\n1302468579\n```", "```cpp\nauto& [it1, it2] = gathered_even;\nfor(auto it{ it1 }; it < it2; ++it) cout << *it;\ncout << '\\n';\n```", "```cpp\n02468\n```", "```cpp\n    bw::gather(vint.begin(), vint.end(), vint.begin(), \n        bw::is_even);\n    for(const auto& el : vint) cout << el;\n    cout << '\\n';\n    bw::gather(vint.begin(), vint.end(), vint.end(),\n        bw::is_even);\n    for(const auto& el : vint) cout << el;\n    cout << '\\n';\n    ```", "```cpp\n0246813579\n1357902468\n```", "```cpp\n    string jenny{ \"867-5309\" };\n    bw::gather(jenny.begin(), jenny.end(), jenny.end(),\n        bw::is_even_char);\n    for(const auto& el : jenny) cout << el;\n    cout << '\\n';\n    ```", "```cpp\n7-539860\n```", "```cpp\ntemplate <typename It, typename Pred>\npair<It, It> gather(It first, It last, It pivot, Pred pred) {\n    return { stable_partition(first, pivot, not_fn(pred)),\n             stable_partition(pivot, last, pred) };\n}\n```", "```cpp\n    template<typename T>\n    bool isws(const T& c) {\n        constexpr const T whitespace[]{ \" \\t\\r\\n\\v\\f\" };\n        for(const T& wsc : whitespace) {\n            if(c == wsc) return true;\n        }    \n        return false;\n    }\n    ```", "```cpp\n    string delws(const string& s) {\n        string outstr{s};\n        auto its = unique(outstr.begin(), outstr.end(),\n            [](const auto &a, const auto &b) {\n                return isws(a) && isws(b);\n            });\n        outstr.erase(its, outstr.end());\n        outstr.shrink_to_fit();\n        return outstr;\n    }\n    ```", "```cpp\n    int main() {\n        const string s{ \"big     bad    \\t   wolf\" };\n        const string s2{ bw::delws(s) };\n        cout << format(\"[{}]\\n\", s);\n        cout << format(\"[{}]\\n\", s2);\n        return 0;\n    }\n    ```", "```cpp\n[big     bad           wolf]\n[big bad wolf]\n```", "```cpp\nauto its = unique(outstr.begin(), outstr.end(),\n    [](const auto &a, const auto &b) {\n        return isws(a) && isws(b);\n    });\n```", "```cpp\nint main() {\n    bw::numword nw{};\n    uint64_t n;\n    nw = 3; bw::print(\"n is {}, {}\\n\", nw.getnum(), nw);\n    nw = 47; bw::print(\"n is {}, {}\\n\", nw.getnum(), nw);\n    n = 100073; bw::print(\"n is {}, {}\\n\", n, \n      bw::numword{n});\n    n = 1000000001; bw::print(\"n is {}, {}\\n\", n, \n      bw::numword{n});\n    n = 123000000000; bw::print(\"n is {}, {}\\n\", n, \n      bw::numword{n});\n    n = 1474142398007; bw::print(\"n is {}, {}\\n\", n, \n      nw.words(n));\n    n = 999999999999999999; bw::print(\"n is {}, {}\\n\", n, \n      nw.words(n));\n    n = 1000000000000000000; bw::print(\"n is {}, {}\\n\", n, \n        nw.words(n));\n}\n```", "```cpp\nn is 3, three\nn is 47, forty-seven\nn is 100073, one hundred thousand seventy-three\nn is 1000000001, one billion one\nn is 123000000000, one hundred twenty-three billion\nn is 1474142398007, one trillion four hundred seventy-four billion one hundred forty-two million three hundred ninety-eight thousand seven\nn is 999999999999999999, nine hundred ninety-nine quadrillion nine hundred ninety-nine trillion nine hundred ninety-nine billion nine hundred ninety-nine million nine hundred ninety-nine thousand nine hundred ninety-nine\nn is 1000000000000000000, error\n```", "```cpp\n    namespace bw {\n        using std::string;\n        using std::string_view;\n        using numnum = uint64_t; \n        using bufstr = std::unique_ptr<string>;\n    ```", "```cpp\n    constexpr numnum maxnum = 999'999'999'999'999'999;\n    constexpr int zero_i{ 0 };\n    constexpr int five_i{ 5 };\n    constexpr numnum zero{ 0 };\n    constexpr numnum ten{ 10 };\n    constexpr numnum twenty{ 20 };\n    constexpr numnum hundred{ 100 };\n    constexpr numnum thousand{ 1000 };\n    ```", "```cpp\n    constexpr string_view errnum{ \"error\" };\n    constexpr string_view _singles[] {\n        \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \n        \"six\", \"seven\", \"eight\", \"nine\"\n    };\n    constexpr string_view _teens[] {\n        \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \n        \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \n        \"nineteen\"\n    };\n    constexpr string_view _tens[] {\n        errnum, errnum, \"twenty\", \"thirty\", \"forty\", \n        \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\",\n    };\n    constexpr string_view _hundred_string = \"hundred\";\n    constexpr string_view _powers[] {\n        errnum, \"thousand\", \"million\", \"billion\", \n        \"trillion\", \"quadrillion\"\n    };\n    ```", "```cpp\n    class numword {\n        bufstr _buf{ std::make_unique<string>(string{}) };\n        numnum _num{};\n        bool _hyphen_flag{ false };\n    ```", "```cpp\n    void clearbuf();\n    size_t bufsize();\n    void appendbuf(const string& s);\n    void appendbuf(const string_view& s);\n    void appendbuf(const char c);\n    void appendspace();\n    ```", "```cpp\nnumnum pow_i(const numnum n, const numnum p);\n```", "```cpp\n    numword(const numnum& num = 0) : _num(num) {}\n    numword(const numword& nw) : _num(nw.getnum()) {}\n    const char * version() const { return _version; }\n    void setnum(const numnum& num) { _num = num; }\n    numnum getnum() const { return _num; }\n    numnum operator= (const numnum& num);\n    const string& words();\n    const string& words(const numnum& num);\n    const string& operator() (const numnum& num) {\n        return words(num); };\n    ```", "```cpp\n    const string& numword::words( const numnum& num ) {\n        numnum n{ num };\n        clearbuf();\n        if(n > maxnum) {\n            appendbuf(errnum);\n            return *_buf;\n        }\n        if (n == 0) {\n            appendbuf(_singles[n]);\n            return *_buf;\n        }\n        // powers of 1000\n        if (n >= thousand) {\n            for(int i{ five_i }; i > zero_i; --i) {\n                numnum power{ pow_i(thousand, i) };\n                numnum _n{ ( n - ( n % power ) ) / power };\n                if (_n) {\n                    int index = i;\n                    numword _nw{ _n };\n                    appendbuf(_nw.words());\n                    appendbuf(_powers[index]);\n                    n -= _n * power;\n                }\n            }\n        }\n        // hundreds\n        if (n >= hundred && n < thousand) {\n            numnum _n{ ( n - ( n % hundred ) ) / hundred };\n            numword _nw{ _n };\n            appendbuf(_nw.words());\n            appendbuf(_hundred_string);\n            n -= _n * hundred;\n        }\n        // tens\n        if (n >= twenty && n < hundred) {\n            numnum _n{ ( n - ( n % ten ) ) / ten };\n            appendbuf(_tens[_n]);\n            n -= _n * ten;\n            _hyphen_flag = true;\n        }\n        // teens\n        if (n >= ten && n < twenty) {\n            appendbuf(_teens[n - ten]);\n            n = zero;\n        }\n        // singles\n        if (n > zero && n < ten) {\n            appendbuf(_singles[n]);\n        }\n        return *_buf;\n    }\n    ```", "```cpp\n    void numword::appendbuf(const string& s) {\n        appendspace();\n        _buf->append(s);\n    }\n    ```", "```cpp\nvoid numword::appendbuf(const string_view& s) {\n    appendspace();\n    _buf->append(s.data());\n}\n```", "```cpp\nvoid numword::appendbuf(const char c) {\n    _buf->append(1, c);\n}\n```", "```cpp\nvoid numword::appendspace() {\n    if(bufsize()) {\n        appendbuf( _hyphen_flag ? _hyphen : _space);\n        _hyphen_flag = false;\n    }\n}\n```", "```cpp\n    template<>\n    struct std::formatter<bw::numword>: std::formatter<unsigned> {\n        template<typename FormatContext>\n        auto format(const bw::numword& nw, \n          FormatContext& ctx) {\n            bw::numword _nw{nw};\n            return format_to(ctx.out(), \"{}\", \n              _nw.words());\n        }\n    };\n    ```", "```cpp\n    namespace bw {\n        template<typename... Args> constexpr void print(\n                const std::string_view str_fmt, Args&&... \n                  args) {\n            fputs(std::vformat(str_fmt, \n                std::make_format_args(args...)).c_str(), \n                stdout);\n        }\n    };\n    ```", "```cpp\n    int main() {\n        bw::numword nw{};\n        uint64_t n{};\n        bw::print(\"n is {}, {}\\n\", nw.getnum(), nw);\n        ...\n    ```", "```cpp\nn is 0, zero\n```", "```cpp\n    nw = 3; bw::print(\"n is {}, {}\\n\", nw.getnum(), nw);\n    nw = 47; bw::print(\"n is {}, {}\\n\", nw.getnum(), nw);\n    ...\n    n = 100073; bw::print(\"n is {}, {}\\n\", n, bw::numword{n});\n    n = 1000000001; bw::print(\"n is {}, {}\\n\", n, bw::numword{n});\n    ...\n    n = 474142398123; bw::print(\"n is {}, {}\\n\", n, nw(n));\n    n = 1474142398007; bw::print(\"n is {}, {}\\n\", n, nw(n));\n    ...\n    n = 999999999999999999; bw::print(\"n is {}, {}\\n\", n, nw(n));\n    n = 1000000000000000000; bw::print(\"n is {}, {}\\n\", n, nw(n));\n    ```", "```cpp\nn is 3, three\nn is 47, forty-seven\n...\nn is 100073, one hundred thousand seventy-three\nn is 1000000001, one billion one\n...\nn is 474142398123, four hundred seventy-four billion one hundred forty-two million three hundred ninety-eight thousand one hundred twenty-three\nn is 1474142398007, one trillion four hundred seventy-four billion one hundred forty-two million three hundred ninety-eight thousand seven\n...\nn is 999999999999999999, nine hundred ninety-nine quadrillion nine hundred ninety-nine trillion nine hundred ninety-nine billion nine hundred ninety-nine million nine hundred ninety-nine thousand nine hundred ninety-nine\nn is 1000000000000000000, error\n```", "```cpp\nappendbuf(_tens[_n]);  // e.g., _tens[5] = \"fifty\"\n```", "```cpp\nnumnum power{ pow_i(thousand, i) };\nnumnum _n{ ( n - ( n % power ) ) / power };\nif (_n) {\n    int index = i;\n    numword _nw{ _n };\n    appendbuf(_nw.words());\n    appendbuf(_powers[index]);\n    n -= _n * power;\n}\n```", "```cpp\n$ ./saytime\nthree past five\n```", "```cpp\n$ ./saytime test\n00:00 midnight\n00:01 one past midnight\n11:00 eleven o'clock\n12:00 noon\n13:00 one o'clock\n12:29 twenty-nine past noon\n12:30 half past noon\n12:31 twenty-nine til one\n12:15 quarter past noon\n12:30 half past noon\n12:45 quarter til one\n11:59 one til noon\n23:15 quarter past eleven\n23:59 one til midnight\n12:59 one til one\n13:59 one til two\n01:60 OOR\n24:00 OOR\n```"]