<html><head></head><body>
<div><h1 class="chapterNumber">18</h1>
<h1 class="chapterTitle" id="_idParaDest-249">Cross-Platform Development</h1>
<p class="normal">In the previous chapters, we explored practical examples of designing and implementing software components for embedded systems. Each example demonstrated good software design practices and guided you through the implementation using modern C++ techniques.</p>
<p class="normal">The design practices we have followed throughout the book have helped us create portable, cross-platform code. Writing cross-platform code is important because it enables the reuse of software components across different hardware configurations. As we conclude this journey, let’s recap the key practices demonstrated in earlier chapters.</p>
<p class="normal">In this chapter, we will cover the following topics:</p>
<ul>
<li class="bulletList">Importance of writing portable code</li>
<li class="bulletList">SOLID design principles</li>
<li class="bulletList">Testability</li>
</ul>
<h1 class="heading-1" id="_idParaDest-250">Technical requirements</h1>
<p class="normal">This chapter focuses on cross-platform development. The code shown here runs on multiple platforms, including common desktop architectures.</p>
<p class="normal">You can use Compiler Explorer (<a href="https://godbolt.org/">https://godbolt.org/</a>) to run the examples. All source code is available on GitHub at <a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter18">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter18</a>.</p>
<h1 class="heading-1" id="_idParaDest-251">Importance of writing portable code</h1>
<p class="normal">Hardware projects <a id="_idIndexMarker789"/>mature, evolve, and adapt to market needs and supply chain conditions. Between 2020 and 2022, the global semiconductor industry faced a severe supply chain crisis, primarily triggered by the COVID-19 pandemic and worsened by several factors. Lockdowns disrupted production, while soaring demand for electronics (e.g., laptops, servers) collided with miscalculations in the automotive sector. Carmakers initially canceled chip orders, then scrambled to restock as demand rebounded.</p>
<p class="normal">As a result, many components became scarce, overpriced, or unavailable altogether. Products had to adapt by replacing electronic components such as sensors, drivers, communication modules, or even microcontrollers. This, in turn, required firmware modifications to match the new hardware.</p>
<p class="normal">For well-written firmware, this adaptation was relatively straightforward and involved implementing only hardware-specific interfaces. For example, if a product used an accelerometer and needed to replace it, a well-designed firmware architecture would require just implementing the interface for the new component, leaving the business logic unchanged.</p>
<p class="normal">Cross-platform code <a id="_idIndexMarker790"/>can also run in a simulated environment on a host. In <a href="Chapter_17.xhtml"><em class="italic">Chapter 17</em></a>, we ran Pigweed’s demo application on a host. This was possible, thanks to Pigweed’s well-structured interface design, which allowed host implementations of low-level hardware interfaces. The same business application code can run on multiple targets, including the host, where inputs and outputs are simulated.</p>
<p class="normal">Well-structured code is easier to read, change, and maintain. Good design principles keep projects flexible even as requirements evolve. Next, we will examine the five SOLID principles.</p>
<h1 class="heading-1" id="_idParaDest-252">SOLID design principles</h1>
<p class="normal">The examples throughout this book are aligned with <strong class="keyWord">SOLID</strong> design principles, originally described by Robert C. Martin in his 2000 paper <em class="italic">Design Principles and Design Patterns</em>. They serve as a <a id="_idIndexMarker791"/>
recognized guide for writing code that remains adaptable and easy to work with over time. Although the SOLID principles were originally introduced in object-oriented programming, their focus on creating modular, maintainable, and extensible code can be applied in broader software design contexts. Each letter in the SOLID mnemonic acronym stands for one principle:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Single Responsibility Principle (SRP)</strong>: A class <a id="_idIndexMarker792"/>should have only one responsibility, giving it a single reason to change.</li>
<li class="bulletList"><strong class="keyWord">Open/Closed Principle (OCP)</strong>: A class <a id="_idIndexMarker793"/>should be open for extension but closed for modification. A new functionality is added by extending the class through dynamic or static polymorphism, rather than modifying it.</li>
<li class="bulletList"><strong class="keyWord">Liskov Substitution Principle (LSP)</strong>: Derived classes should be usable in place of their <a id="_idIndexMarker794"/>parent classes without breaking the software’s behavior.</li>
<li class="bulletList"><strong class="keyWord">Interface Segregation Principle (ISP)</strong>: Interface classes should remain small and concise <a id="_idIndexMarker795"/>so that derived classes implement only methods they need.</li>
<li class="bulletList"><strong class="keyWord">Dependency Inversion Principle (DIP)</strong>: High-level modules (e.g., an accelerometer) should <a id="_idIndexMarker796"/>not depend on low-level modules (e.g., I2C). Both should rely on abstractions (interfaces) rather than concrete implementations.</li>
</ul>
<p class="normal">Next, we’ll go through an example of designing an accelerometer interface, explain how to use it, and show <a id="_idIndexMarker797"/>how it aligns with SOLID principles and why that alignment matters. First, we will design an accelerometer interface class. The code is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
#include &lt;cstdint&gt;
class accelerometer {
public:
struct data {
    float x;
    float y;
    float z;
};
enum class sampling_rate {
    c_20_hz,
    c_50_hz,
    c_100_hz,
};
enum error {
      ok,
      not_supported
};
virtual error set_sampling_rate(sampling_rate) = 0;
virtual data get_data() = 0;
};
</code></pre>
<p class="normal">The interface class accelerometer shown in the preceding code will be implemented by the <code class="inlineCode">adxl_345</code> class, which will use the i2c interface to communicate with the actual accelerometer hardware (the ADXL345 integrated circuit is a small accelerometer with an I2C digital interface). Also, we will <a id="_idIndexMarker798"/>run the code on the STM32 platform, so we will create a (stubbed) implementation of the i2c interface – <code class="inlineCode">i2c_stm32</code>. The code is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">class i2c {
public:
virtual void write() = 0;
};
class i2c_stm32 : public i2c {
public:
void write() override {
    printf("i2c::write...\r\n");
}
};
class adxl_345 : public accelerometer {
public:
adxl_345(i2c &amp;i2c_obj) : i2c_(i2c_obj) {}
error set_sampling_rate(sampling_rate) override {
    printf("adxl_345: setting sampling rate\r\n");
    i2c_.write();
    return error::ok;
}
data get_data() override {
    return data{0.02f, 0.981f, 0.03f};
}
private:
i2c &amp;i2c_;
};
</code></pre>
<p class="normal">Next, we will design a simple <code class="inlineCode">tap_detection_algo</code> class that uses an accelerometer interface to collect motion data and identify short, sudden movements, typically referred to as taps. The taps are quick spikes in acceleration that can be used as user input or trigger events in the application. A boilerplate for the tap-detection class is shown in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">class tap_detection_algo {
public:
tap_detection_algo(accelerometer &amp;accel) : accel_(accel) {
    auto err = accel_.set_sampling_rate(
        accelerometer::sampling_rate::c_100_hz);
    if(err == accelerometer::error::not_supported) {
    // try another sampling rate and adapt
    }
}
bool run () {
    auto accel_data = accel_.get_data();
    printf("algo: x = %.2f, y = %.2f, z = %.2f\r\n", accel_data.x, 
                                                     accel_data.y,
                                                     accel_data.z);
    // process data
return false;
}
private:
    accelerometer &amp;accel_;
};
</code></pre>
<p class="normal">Finally, we will <a id="_idIndexMarker799"/>write code for the <code class="inlineCode">main</code> function that instantiates an accelerometer and runs a tap detection algorithm:</p>
<pre class="programlisting code"><code class="hljs-code">int main() {
    i2c_stm32 i2c1;
    adxl_345 accel(i2c1);
    
    tap_detection_algo algo(accel);
    algo.run();
    
    return 0;
}
</code></pre>
<p class="normal">The preceding code is depicted in the following UML diagram:</p>
<figure class="mediaobject"><img alt="Figure 18.1 – Tap detection algorithm UML diagram" src="img/B22402_18-01.png"/></figure>
<p class="packt_figref">Figure 18.1 – Tap detection algorithm UML diagram</p>
<p class="normal"><em class="italic">Figure 18</em><em class="italic">.1</em> shows the <a id="_idIndexMarker800"/>architecture of the software components we designed. The code for the classes shown in the UML diagram is simplified, and it serves to demonstrate the following SOLID principles.</p>
<h3 class="heading-3" id="_idParaDest-253">Single Responsibility Principle (SRP)</h3>
<p class="normal">The <code class="inlineCode">accelerometer</code> class is an interface class with all virtual methods. Its single responsibility is <a id="_idIndexMarker801"/>to define an interface that will be used by higher-level components and implemented by concrete accelerometer <a id="_idIndexMarker802"/>implementations such as <code class="inlineCode">adxl_345</code>.</p>
<p class="normal">The <code class="inlineCode">adxl_345</code> class implements the accelerometer interface and it’s only responsible for implementing communication with the ADXL 345 accelerometer over a serial interface such as I2C or SPI. The only reason for this class to change is bug fixing related to the communication with the sensor itself on the higher protocol level, not the serial bus itself.</p>
<p class="normal">The <code class="inlineCode">i2c</code> class is an interface class with the responsibility of defining an interface for different implementations of the I2C peripheral, while <code class="inlineCode">i2c_stm32</code> implements this interface. The only reason for the concrete implementation to change is bug fixing or optimization related to the serial hardware peripheral.</p>
<p class="normal">The <code class="inlineCode">tap_detection_algo</code> class takes accelerometer data and implements a tap detection algorithm using the collected data. The only reason to change this class is to fix or optimize the algorithm.</p>
<h3 class="heading-3" id="_idParaDest-254">Open/Closed Principle (OCP)</h3>
<p class="normal">An interface-based design for the I2C and accelerometer components lets us extend the software <a id="_idIndexMarker803"/>without modifying any existing code. For example, if we want to run this code on a Texas Instruments microcontroller, all we <a id="_idIndexMarker804"/>need to do is implement the i2c interface for that platform. Likewise, if we change the accelerometer sensor (e.g., to an ST LSDO6), we only have to implement the accelerometer interface for the new sensor.</p>
<h3 class="heading-3" id="_idParaDest-255">The Liskov Substitution Principle (LSP)</h3>
<p class="normal">The LSP was introduced by Barbara Liskov in 1987. The LSP focuses on designing robust contracts <a id="_idIndexMarker805"/>between base classes and their subclasses. Any client code that relies on a base class’s contract should work correctly <a id="_idIndexMarker806"/>when using any derived class, without unexpected behavior.</p>
<p class="normal">In this example, a contract violation by <code class="inlineCode">adxl_345</code> would occur if it silently fails when an unsupported sampling rate is requested, rather than handling it in a way that respects the base class contract (e.g., returning an error status).</p>
<h3 class="heading-3" id="_idParaDest-256">The Interface Segregation Principle (ISP)</h3>
<p class="normal">The ISP is <a id="_idIndexMarker807"/>about splitting large, monolithic interfaces into <a id="_idIndexMarker808"/>more focused ones so that each class only implements the methods it actually needs. An example of a violation <a id="_idIndexMarker809"/>of this principle would be having a broad <strong class="keyWord">Inertial Measurement Unit</strong> (<strong class="keyWord">IMU</strong>) interface that includes gyroscope and magnetometer functions, as <code class="inlineCode">adxl_345</code> is only an accelerometer and would be forced to provide methods it cannot meaningfully support.</p>
<h3 class="heading-3" id="_idParaDest-257">The Dependency Inversion Principle (DIP)</h3>
<p class="normal">The example <a id="_idIndexMarker810"/>code we discussed clearly demonstrates <a id="_idIndexMarker811"/>the <strong class="keyWord">Dependency Inversion Principle (DIP)</strong>. By using an interface-based design, software components are cleanly decoupled:</p>
<ul>
<li class="bulletList">The <code class="inlineCode">tap_detection_algo</code> class depends on the <code class="inlineCode">accelerometer</code> interface, which is implemented by <code class="inlineCode">adxl_345</code></li>
<li class="bulletList">The <code class="inlineCode">adxl_345</code> class depends on the <code class="inlineCode">i2c</code> interface, which is implemented by <code class="inlineCode">i2c_stm32</code></li>
</ul>
<p class="normal">SOLID principles <a id="_idIndexMarker812"/>allow us to write <a id="_idIndexMarker813"/>highly decoupled software and create reusable, hardware-independent code. Decoupled code is more flexible, and it is easier to add new features.</p>
<p class="normal"><em class="italic">As an exercise, add an accelerometer data logging capability without modifying the existing classes.</em></p>
<p class="normal">Good software design also improves software testability, which we will explore next.</p>
<h1 class="heading-1" id="_idParaDest-258">Testability</h1>
<p class="normal">Interface-based design leads to decoupled software, which improves testability. Let us analyze the former <a id="_idIndexMarker814"/>example and see how decoupled design helps with testing. We’ll focus on the tap detection algorithm.</p>
<p class="normal">In this example, we create a simple algorithm that detects a tap when the difference between the current sample and the previous sample on any axis exceeds a predefined threshold. This oversimplified implementation is shown in this code:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cmath&gt;
#include &lt;algorithm&gt;
class tap_detection_algo {
public:
tap_detection_algo(accelerometer &amp;accel)
                    : accel_(accel), first_sample_(true) {}
bool run() {
    auto current = accel_.get_data();
    if (first_sample_) {
        prev_ = current;
        first_sample_ = false;
        return false;
    }
    bool tap = (std::fabs(current.x - prev_.x) &gt; c_threshold) ||
           (std::fabs(current.y - prev_.y) &gt; c_threshold) ||
               (std::fabs(current.z - prev_.z) &gt; c_threshold);
    prev_ = current;	
    return tap;
}
private:
static constexpr float c_threshold = 0.5f;
accelerometer &amp;accel_;
accelerometer::data prev_;
bool first_sample_ = true;
};
</code></pre>
<p class="normal">The preceding code implements a simple tap detection algorithm. It accepts an accelerometer reference and, on each call to <code class="inlineCode">run()</code>, retrieves the current sensor data. If it’s the first sample, it stores the value and returns false (no tap detected). On subsequent calls, it compares the current reading with the previous one on each axis. If the absolute difference on any <a id="_idIndexMarker815"/>axis exceeds a constant threshold, it signals a tap by returning true, then updates the previous sample.</p>
<p class="normal">For unit testing, we’ll create a <code class="inlineCode">fake_accel</code> class that simulates a sequence of accelerometer readings. This way, we can control the input data to check if <code class="inlineCode">tap_detection_algo</code> works. The code for the <code class="inlineCode">fake_accel</code> class is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">class fake_accel : public accelerometer {
public:
fake_accel(const std::vector&lt;data&gt;&amp; samples)
: samples_(samples), index_(0) {}
error set_sampling_rate(sampling_rate) override {
    return error::ok;
}
data get_data() override {
    if (index_ &lt; samples_.size()) {
        return samples_[index_++];
    }
    return samples_.back();
}
private:
std::vector&lt;data&gt; samples_;
size_t index_;
};
</code></pre>
<p class="normal">This class, <code class="inlineCode">fake_accel</code>, is a test double for the accelerometer interface. It simulates accelerometer data by:</p>
<ul>
<li class="bulletList">Accepting a <code class="inlineCode">vector</code> of predefined data samples through its constructor.</li>
<li class="bulletList">Implementing <code class="inlineCode">set_sampling_rate</code> to always return a successful result.</li>
<li class="bulletList">Returning each sample in order via <code class="inlineCode">get_data()</code>, and once all samples are used, it repeatedly returns the last sample.</li>
</ul>
<p class="normal">This makes it useful for testing components that depend on accelerometer readings. Let us see how to use it <a id="_idIndexMarker816"/>to test the tap detection algorithm using the GoogleTest framework in the code shown here:</p>
<pre class="programlisting code"><code class="hljs-code">TEST(TapDetectionAlgoTest, DetectTapOnSuddenChange) {
std::vector&lt;accelerometer::data&gt; samples = {
    {0.0f, 1.0f, 0.0f}, // initial reading
    {0.0f, 1.0f, 0.0f}, // no change -&gt; false
    {0.0f, 2.0f, 0.0f} // significant change
};
fake_accel fakeAccel(samples);
tap_detection_algo algo(fakeAccel);
EXPECT_FALSE(algo.run());
EXPECT_FALSE(algo.run());
EXPECT_TRUE(algo.run());
}
</code></pre>
<p class="normal">This test verifies that the tap detection algorithm correctly identifies a sudden change in accelerometer data as a tap. The test sets up a fake accelerometer with three samples:</p>
<ul>
<li class="bulletList">First sample: <code class="inlineCode">{0.0f, 1.0f, 0.0f}</code> – used for initialization (no tap detection).</li>
<li class="bulletList">Second sample: <code class="inlineCode">{0.0f, 1.0f, 0.0f}</code> – no change compared to the first sample, so no tap is detected.</li>
<li class="bulletList">Third sample: <code class="inlineCode">{0.0f, 2.0f, 0.0f}</code> – a significant change on the y axis (a difference of 1.0, which exceeds the threshold of 0.5) triggers tap detection.</li>
</ul>
<p class="normal">The test expects the first two calls to <code class="inlineCode">run()</code> to return false and the third call to return true. Thanks to interface-based design, we can pass a <code class="inlineCode">fake_accel</code> reference to the <code class="inlineCode">tap_detection_algo</code> constructor since <code class="inlineCode">fake_accel</code> implements the <code class="inlineCode">accelerometer</code> interface. We supply the <code class="inlineCode">fake_accel</code> constructor with a <code class="inlineCode">vector</code> container of samples to feed into the algorithm. This allows us to easily test the algorithm with a test dataset.</p>
<p class="normal">The full example can be found at GitHub (<a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter18">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter18</a>). Make sure you add the GoogleTest library to Compiler Explorer when running it.</p>
<h1 class="heading-1" id="_idParaDest-259">Summary</h1>
<p class="normal">In this chapter, we learned why writing portable, cross-platform code is important for embedded development. It allows you to easily reuse software components and adapt to hardware changes, and it improves testability.</p>
<p class="normal">You also learned about SOLID principles and how they apply to the design of software components in embedded systems using C++. Code readability and flexibility are some of the most important traits of well-designed software.</p>
<p class="normal">We humans read the code, and the human who reads your code may be the future you. So, having easy-to-read code should be a priority. Sacrifice readability and optimize for performance only when absolutely needed. Having flexible code allows you to adapt to changes or add new features easily.</p>
<p class="normal">With this chapter, our journey comes to an end. We began by exploring common myths about C++ and debunking them. From there, we covered many important aspects of modern C++ and learned how to apply them in embedded application development.</p>
<p class="normal">We explored how to use lambdas to write expressive code and took advantage of compile-time computation to generate lookup tables, conserving memory and processing power. We also leveraged C++ type safety to implement a type-safe HAL.</p>
<p class="normal">Next, we learned how to apply design patterns such as Adapter, Observer, and State to solve typical problems in embedded systems. We explored the C++ Standard Library, ETL, Pigweed, and cib and learned how to use them in embedded applications.</p>
<p class="normal">Throughout all the examples in this book, we focused on writing readable, maintainable, and loosely coupled code to strengthen our software design and development skills.</p>
<p class="normal">I hope you enjoyed this journey and wish you happy coding!</p>
<h1 class="heading-1" id="_idParaDest-260">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/embeddedsystems">https://packt.link/embeddedsystems</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_code_Discord.png"/></p>
</div>


<div><p class="BM-packtLogo"><img alt="" role="presentation" src="img/Packt_Logo_New1.png"/></p>
<p class="normal"><a href="https://packtpub.com">packtpub.com</a></p>
<p class="normal">Subscribe to our online digital library for full access to over 7,000 books and videos, as well as industry leading tools to help you plan your personal development and advance your career. For more information, please visit our website.</p>
<h1 class="heading-1" id="_idParaDest-261">Why subscribe?</h1>
<ul>
<li class="bulletList">Spend less time learning and more time coding with practical eBooks and Videos from over 4,000 industry professionals</li>
<li class="bulletList">Improve your learning with Skill Plans built especially for you</li>
<li class="bulletList">Get a free eBook or video every month</li>
<li class="bulletList">Fully searchable for easy access to vital information</li>
<li class="bulletList">Copy and paste, print, and bookmark content</li>
</ul>
<p class="normal">At <a href="https://www.packtpub.com">www.packtpub.com</a>, you can also read a collection of free technical articles, sign up for a range of free newsletters, and receive exclusive discounts and offers on Packt books and eBooks. </p>
<p class="eop"/>
<h1 class="mainHeading" id="_idParaDest-262">Other Books You May Enjoy</h1>
<p class="normal">If you enjoyed this book, you may be interested in these other books by Packt:</p>
<p class="BM-bookCover"><img alt="" role="presentation" src="img/9781803239545.jpg"/></p>
<p class="normal"><strong class="keyWord">Embedded Systems Architecture, Second Edition</strong></p>
<p class="normal">Daniele Lacamera</p>
<p class="normal">ISBN: 978-1-80323-954-5</p>
<ul>
<li class="bulletList">Participate in the design and definition phase of an embedded product</li>
<li class="bulletList">Get to grips with writing code for ARM Cortex-M microcontrollers</li>
<li class="bulletList">Build an embedded development lab and optimize the workflow</li>
<li class="bulletList">Secure embedded systems with TLS</li>
<li class="bulletList">Demystify the architecture behind the communication interfaces</li>
<li class="bulletList">Understand the design and development patterns for connected and distributed devices in the IoT</li>
<li class="bulletList">Master multitasking parallel execution patterns and real-time operating systems</li>
<li class="bulletList">Become familiar with Trusted Execution Environment (TEE)</li>
</ul>
<p class="eop"/>
<p class="BM-bookCover"><img alt="" role="presentation" src="img/9781835460818.jpg"/></p>
<p class="normal"><strong class="keyWord">Bare-Metal Embedded C Programming</strong></p>
<p class="normal">Israel Gbati</p>
<p class="normal">ISBN: 978-1-83546-081-8</p>
<ul>
<li class="bulletList">Decode microcontroller datasheets, enabling precise firmware development</li>
<li class="bulletList">Master register manipulations for optimized Arm-based microcontroller firmware creation</li>
<li class="bulletList">Discover how to navigate hardware intricacies confidently</li>
<li class="bulletList">Find out how to write optimized firmware without any assistance</li>
<li class="bulletList">Work on exercises to create bare-metal drivers for GPIO, timers, ADC, UART, SPI, I2C, DMA, and more</li>
<li class="bulletList">Design energy-efficient embedded systems with power management techniques</li>
</ul>
<p class="eop"/>
<h1 class="heading-1" id="_idParaDest-263">Packt is searching for authors like you</h1>
<p class="normal">If you’re interested in becoming an author for Packt, please visit <a href="https://authors.packtpub.com">authors.packtpub.com</a> and apply today. We have worked with thousands of developers and tech professionals, just like you, to help them share their insight with the global tech community. You can make a general application, apply for a specific hot topic that we are recruiting an author for, or submit your own idea.</p>
<p class="eop"/>
<h1 class="heading-1" id="_idParaDest-264">Share your thoughts</h1>
<p class="normal">Now you’ve finished <em class="italic">C++ in Embedded Systems</em>, we’d love to hear your thoughts! If you purchased the book from Amazon, please click here to go straight to the Amazon review page for this book and share your feedback or leave a review on the site that you purchased it from.</p>
<p class="normal">Your review is important to us and the tech community and will help us make sure we’re delivering excellent quality content. </p>
</div>
</body></html>