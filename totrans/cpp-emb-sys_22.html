<html><head></head><body>
<div id="_idContainer092">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">18</span></h1>
<h1 class="chapterTitle" id="_idParaDest-249"><span class="koboSpan" id="kobo.2.1">Cross-Platform Development</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">In the previous chapters, we explored practical examples of designing and implementing software components for embedded systems. </span><span class="koboSpan" id="kobo.3.2">Each example demonstrated good software design practices and guided you through the implementation using modern C++ techniques.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">The design practices we have followed throughout the book have helped us create portable, cross-platform code. </span><span class="koboSpan" id="kobo.4.2">Writing cross-platform code is important because it enables the reuse of software components across different hardware configurations. </span><span class="koboSpan" id="kobo.4.3">As we conclude this journey, let’s recap the key practices demonstrated in earlier chapters.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5.1">In this chapter, we will cover the following topics:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.6.1">Importance of writing portable code</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.7.1">SOLID design principles</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.8.1">Testability</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-250"><span class="koboSpan" id="kobo.9.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.10.1">This chapter focuses on cross-platform development. </span><span class="koboSpan" id="kobo.10.2">The code shown here runs on multiple platforms, including common desktop architectures.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.11.1">You can use Compiler Explorer (</span><a href="https://godbolt.org/"><span class="url"><span class="koboSpan" id="kobo.12.1">https://godbolt.org/</span></span></a><span class="koboSpan" id="kobo.13.1">) to run the examples. </span><span class="koboSpan" id="kobo.13.2">All source code is available on GitHub at </span><a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter18"><span class="url"><span class="koboSpan" id="kobo.14.1">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter18</span></span></a><span class="koboSpan" id="kobo.15.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-251"><span class="koboSpan" id="kobo.16.1">Importance of writing portable code</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.17.1">Hardware projects </span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.18.1">mature, evolve, and adapt to market needs and supply chain conditions. </span><span class="koboSpan" id="kobo.18.2">Between 2020 and 2022, the global semiconductor industry faced a severe supply chain crisis, primarily triggered by the COVID-19 pandemic and worsened by several factors. </span><span class="koboSpan" id="kobo.18.3">Lockdowns disrupted production, while soaring demand for electronics (e.g., laptops, servers) collided with miscalculations in the automotive sector. </span><span class="koboSpan" id="kobo.18.4">Carmakers initially canceled chip orders, then scrambled to restock as demand rebounded.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.19.1">As a result, many components became scarce, overpriced, or unavailable altogether. </span><span class="koboSpan" id="kobo.19.2">Products had to adapt by replacing electronic components such as sensors, drivers, communication modules, or even microcontrollers. </span><span class="koboSpan" id="kobo.19.3">This, in turn, required firmware modifications to match the new hardware.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.20.1">For well-written firmware, this adaptation was relatively straightforward and involved implementing only hardware-specific interfaces. </span><span class="koboSpan" id="kobo.20.2">For example, if a product used an accelerometer and needed to replace it, a well-designed firmware architecture would require just implementing the interface for the new component, leaving the business logic unchanged.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.21.1">Cross-platform code </span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.22.1">can also run in a simulated environment on a host. </span><span class="koboSpan" id="kobo.22.2">In </span><a href="Chapter_17.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.23.1">Chapter 17</span></em></span></a><span class="koboSpan" id="kobo.24.1">, we ran Pigweed’s demo application on a host. </span><span class="koboSpan" id="kobo.24.2">This was possible, thanks to Pigweed’s well-structured interface design, which allowed host implementations of low-level hardware interfaces. </span><span class="koboSpan" id="kobo.24.3">The same business application code can run on multiple targets, including the host, where inputs and outputs are simulated.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.25.1">Well-structured code is easier to read, change, and maintain. </span><span class="koboSpan" id="kobo.25.2">Good design principles keep projects flexible even as requirements evolve. </span><span class="koboSpan" id="kobo.25.3">Next, we will examine the five SOLID principles.</span></p>
<h1 class="heading-1" id="_idParaDest-252"><span class="koboSpan" id="kobo.26.1">SOLID design principles</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.27.1">The examples throughout this book are aligned with </span><strong class="keyWord"><span class="koboSpan" id="kobo.28.1">SOLID</span></strong><span class="koboSpan" id="kobo.29.1"> design principles, originally described by Robert C. </span><span class="koboSpan" id="kobo.29.2">Martin in his 2000 paper </span><em class="italic"><span class="koboSpan" id="kobo.30.1">Design Principles and Design Patterns</span></em><span class="koboSpan" id="kobo.31.1">. </span><span class="koboSpan" id="kobo.31.2">They serve as a </span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.32.1">
recognized guide for writing code that remains adaptable and easy to work with over time. </span><span class="koboSpan" id="kobo.32.2">Although the SOLID principles were originally introduced in object-oriented programming, their focus on creating modular, maintainable, and extensible code can be applied in broader software design contexts. </span><span class="koboSpan" id="kobo.32.3">Each letter in the SOLID mnemonic acronym stands for one principle:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.33.1">Single Responsibility Principle (SRP)</span></strong><span class="koboSpan" id="kobo.34.1">: A class </span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.35.1">should have only one responsibility, giving it a single reason to change.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.36.1">Open/Closed Principle (OCP)</span></strong><span class="koboSpan" id="kobo.37.1">: A class </span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.38.1">should be open for extension but closed for modification. </span><span class="koboSpan" id="kobo.38.2">A new functionality is added by extending the class through dynamic or static polymorphism, rather than modifying it.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.39.1">Liskov Substitution Principle (LSP)</span></strong><span class="koboSpan" id="kobo.40.1">: Derived classes should be usable in place of their </span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.41.1">parent classes without breaking the software’s behavior.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.42.1">Interface Segregation Principle (ISP)</span></strong><span class="koboSpan" id="kobo.43.1">: Interface classes should remain small and concise </span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.44.1">so that derived classes implement only methods they need.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.45.1">Dependency Inversion Principle (DIP)</span></strong><span class="koboSpan" id="kobo.46.1">: High-level modules (e.g., an accelerometer) should </span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.47.1">not depend on low-level modules (e.g., I2C). </span><span class="koboSpan" id="kobo.47.2">Both should rely on abstractions (interfaces) rather than concrete implementations.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.48.1">Next, we’ll go through an example of designing an accelerometer interface, explain how to use it, and show </span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.49.1">how it aligns with SOLID principles and why that alignment matters. </span><span class="koboSpan" id="kobo.49.2">First, we will design an accelerometer interface class. </span><span class="koboSpan" id="kobo.49.3">The code is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.50.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.51.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.52.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.53.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.54.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.55.1">&lt;cstdint&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.56.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.57.1">accelerometer</span></span><span class="koboSpan" id="kobo.58.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.59.1">public</span></span><span class="koboSpan" id="kobo.60.1">:
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.61.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.62.1">data</span></span><span class="koboSpan" id="kobo.63.1"> {
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.64.1">float</span></span><span class="koboSpan" id="kobo.65.1"> x;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.66.1">float</span></span><span class="koboSpan" id="kobo.67.1"> y;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.68.1">float</span></span><span class="koboSpan" id="kobo.69.1"> z;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.70.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.71.1">sampling_rate</span></span><span class="koboSpan" id="kobo.72.1"> {
    c_20_hz,
    c_50_hz,
    c_100_hz,
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.73.1">enum</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.74.1">error</span></span><span class="koboSpan" id="kobo.75.1"> {
      ok,
      not_supported
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.76.1">virtual</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.77.1"> error </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.78.1">set_sampling_rate</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.79.1">(sampling_rate)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.80.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.81.1">0</span></span><span class="koboSpan" id="kobo.82.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.83.1">virtual</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.84.1"> data </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.85.1">get_data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.86.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.87.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.88.1">0</span></span><span class="koboSpan" id="kobo.89.1">;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.90.1">The interface class accelerometer shown in the preceding code will be implemented by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.91.1">adxl_345</span></code><span class="koboSpan" id="kobo.92.1"> class, which will use the i2c interface to communicate with the actual accelerometer hardware (the ADXL345 integrated circuit is a small accelerometer with an I2C digital interface). </span><span class="koboSpan" id="kobo.92.2">Also, we will </span><a id="_idIndexMarker798"/><span class="koboSpan" id="kobo.93.1">run the code on the STM32 platform, so we will create a (stubbed) implementation of the i2c interface – </span><code class="inlineCode"><span class="koboSpan" id="kobo.94.1">i2c_stm32</span></code><span class="koboSpan" id="kobo.95.1">. </span><span class="koboSpan" id="kobo.95.2">The code is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.96.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.97.1">i2c</span></span><span class="koboSpan" id="kobo.98.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.99.1">public</span></span><span class="koboSpan" id="kobo.100.1">:
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.101.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.102.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.103.1">write</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.104.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.105.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.106.1">0</span></span><span class="koboSpan" id="kobo.107.1">;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.108.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.109.1">i2c_stm32</span></span><span class="koboSpan" id="kobo.110.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.111.1">public</span></span><span class="koboSpan" id="kobo.112.1"> i2c {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.113.1">public</span></span><span class="koboSpan" id="kobo.114.1">:
</span><span class="hljs-type"><span class="koboSpan" id="kobo.115.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.116.1">write</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.117.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.118.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.119.1">{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.120.1">printf</span></span><span class="koboSpan" id="kobo.121.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.122.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.123.1">i2c::write...\r\n"</span></span><span class="koboSpan" id="kobo.124.1">);
}
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.125.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.126.1">adxl_345</span></span><span class="koboSpan" id="kobo.127.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.128.1">public</span></span><span class="koboSpan" id="kobo.129.1"> accelerometer {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.130.1">public</span></span><span class="koboSpan" id="kobo.131.1">:
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.132.1">adxl_345</span></span><span class="koboSpan" id="kobo.133.1">(i2c &amp;i2c_obj) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.134.1">i2c_</span></span><span class="koboSpan" id="kobo.135.1">(i2c_obj) {}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.136.1">error </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.137.1">set_sampling_rate</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.138.1">(sampling_rate)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.139.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.140.1">{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.141.1">printf</span></span><span class="koboSpan" id="kobo.142.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.143.1">"adxl_345: setting sampling rate\r\n"</span></span><span class="koboSpan" id="kobo.144.1">);
    i2c_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.145.1">write</span></span><span class="koboSpan" id="kobo.146.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.147.1">return</span></span><span class="koboSpan" id="kobo.148.1"> error::ok;
}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.149.1">data </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.150.1">get_data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.151.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.152.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.153.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.154.1">return</span></span><span class="koboSpan" id="kobo.155.1"> data{</span><span class="hljs-number"><span class="koboSpan" id="kobo.156.1">0.02f</span></span><span class="koboSpan" id="kobo.157.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.158.1">0.981f</span></span><span class="koboSpan" id="kobo.159.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.160.1">0.03f</span></span><span class="koboSpan" id="kobo.161.1">};
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.162.1">private</span></span><span class="koboSpan" id="kobo.163.1">:
i2c &amp;i2c_;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.164.1">Next, we will design a simple </span><code class="inlineCode"><span class="koboSpan" id="kobo.165.1">tap_detection_algo</span></code><span class="koboSpan" id="kobo.166.1"> class that uses an accelerometer interface to collect motion data and identify short, sudden movements, typically referred to as taps. </span><span class="koboSpan" id="kobo.166.2">The taps are quick spikes in acceleration that can be used as user input or trigger events in the application. </span><span class="koboSpan" id="kobo.166.3">A boilerplate for the tap-detection class is shown in the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.167.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.168.1">tap_detection_algo</span></span><span class="koboSpan" id="kobo.169.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.170.1">public</span></span><span class="koboSpan" id="kobo.171.1">:
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.172.1">tap_detection_algo</span></span><span class="koboSpan" id="kobo.173.1">(accelerometer &amp;accel) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.174.1">accel_</span></span><span class="koboSpan" id="kobo.175.1">(accel) {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.176.1">auto</span></span><span class="koboSpan" id="kobo.177.1"> err = accel_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.178.1">set_sampling_rate</span></span><span class="koboSpan" id="kobo.179.1">(
        accelerometer::sampling_rate::c_100_hz);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.180.1">if</span></span><span class="koboSpan" id="kobo.181.1">(err == accelerometer::error::not_supported) {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.182.1">// try another sampling rate and adapt</span></span><span class="koboSpan" id="kobo.183.1">
    }
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.184.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.185.1">run</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.186.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.187.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.188.1">auto</span></span><span class="koboSpan" id="kobo.189.1"> accel_data = accel_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.190.1">get_data</span></span><span class="koboSpan" id="kobo.191.1">();
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.192.1">printf</span></span><span class="koboSpan" id="kobo.193.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.194.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.195.1">algo: x = %.2f, y = %.2f, z = %.2f\r\n"</span></span><span class="koboSpan" id="kobo.196.1">, accel_data.x, 
                                                     accel_data.y,
                                                     accel_data.z);
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.197.1">// process data</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.198.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.199.1">false</span></span><span class="koboSpan" id="kobo.200.1">;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.201.1">private</span></span><span class="koboSpan" id="kobo.202.1">:
    accelerometer &amp;accel_;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.203.1">Finally, we will </span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.204.1">write code for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.205.1">main</span></code><span class="koboSpan" id="kobo.206.1"> function that instantiates an accelerometer and runs a tap detection algorithm:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.207.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.208.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.209.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.210.1">{
    i2c_stm32 i2c1;
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.211.1">adxl_345 </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.212.1">accel</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.213.1">(i2c1)</span></span><span class="koboSpan" id="kobo.214.1">;
    
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.215.1">tap_detection_algo </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.216.1">algo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.217.1">(accel)</span></span><span class="koboSpan" id="kobo.218.1">;
    algo.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.219.1">run</span></span><span class="koboSpan" id="kobo.220.1">();
    
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.221.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.222.1">0</span></span><span class="koboSpan" id="kobo.223.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.224.1">The preceding code is depicted in the following UML diagram:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.225.1"><img alt="Figure 18.1 – Tap detection algorithm UML diagram" src="../Images/B22402_18-01.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.226.1">Figure 18</span></span><span class="koboSpan" id="kobo.227.1">.1 – Tap detection algorithm UML diagram</span></p>
<p class="normal"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.228.1">Figure 18</span></em></span><em class="italic"><span class="koboSpan" id="kobo.229.1">.1</span></em><span class="koboSpan" id="kobo.230.1"> shows the </span><a id="_idIndexMarker800"/><span class="koboSpan" id="kobo.231.1">architecture of the software components we designed. </span><span class="koboSpan" id="kobo.231.2">The code for the classes shown in the UML diagram is simplified, and it serves to demonstrate the following SOLID principles.</span></p>
<h3 class="heading-3" id="_idParaDest-253"><span class="koboSpan" id="kobo.232.1">Single Responsibility Principle (SRP)</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.233.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.234.1">accelerometer</span></code><span class="koboSpan" id="kobo.235.1"> class is an interface class with all virtual methods. </span><span class="koboSpan" id="kobo.235.2">Its single responsibility is </span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.236.1">to define an interface that will be used by higher-level components and implemented by concrete accelerometer </span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.237.1">implementations such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.238.1">adxl_345</span></code><span class="koboSpan" id="kobo.239.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.240.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.241.1">adxl_345</span></code><span class="koboSpan" id="kobo.242.1"> class implements the accelerometer interface and it’s only responsible for implementing communication with the ADXL 345 accelerometer over a serial interface such as I2C or SPI. </span><span class="koboSpan" id="kobo.242.2">The only reason for this class to change is bug fixing related to the communication with the sensor itself on the higher protocol level, not the serial bus itself.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.243.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.244.1">i2c</span></code><span class="koboSpan" id="kobo.245.1"> class is an interface class with the responsibility of defining an interface for different implementations of the I2C peripheral, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.246.1">i2c_stm32</span></code><span class="koboSpan" id="kobo.247.1"> implements this interface. </span><span class="koboSpan" id="kobo.247.2">The only reason for the concrete implementation to change is bug fixing or optimization related to the serial hardware peripheral.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.248.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.249.1">tap_detection_algo</span></code><span class="koboSpan" id="kobo.250.1"> class takes accelerometer data and implements a tap detection algorithm using the collected data. </span><span class="koboSpan" id="kobo.250.2">The only reason to change this class is to fix or optimize the algorithm.</span></p>
<h3 class="heading-3" id="_idParaDest-254"><span class="koboSpan" id="kobo.251.1">Open/Closed Principle (OCP)</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.252.1">An interface-based design for the I2C and accelerometer components lets us extend the software </span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.253.1">without modifying any existing code. </span><span class="koboSpan" id="kobo.253.2">For example, if we want to run this code on a Texas Instruments microcontroller, all we </span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.254.1">need to do is implement the i2c interface for that platform. </span><span class="koboSpan" id="kobo.254.2">Likewise, if we change the accelerometer sensor (e.g., to an ST LSDO6), we only have to implement the accelerometer interface for the new sensor.</span></p>
<h3 class="heading-3" id="_idParaDest-255"><span class="koboSpan" id="kobo.255.1">The Liskov Substitution Principle (LSP)</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.256.1">The LSP was introduced by Barbara Liskov in 1987. </span><span class="koboSpan" id="kobo.256.2">The LSP focuses on designing robust contracts </span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.257.1">between base classes and their subclasses. </span><span class="koboSpan" id="kobo.257.2">Any client code that relies on a base class’s contract should work correctly </span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.258.1">when using any derived class, without unexpected behavior.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.259.1">In this example, a contract violation by </span><code class="inlineCode"><span class="koboSpan" id="kobo.260.1">adxl_345</span></code><span class="koboSpan" id="kobo.261.1"> would occur if it silently fails when an unsupported sampling rate is requested, rather than handling it in a way that respects the base class contract (e.g., returning an error status).</span></p>
<h3 class="heading-3" id="_idParaDest-256"><span class="koboSpan" id="kobo.262.1">The Interface Segregation Principle (ISP)</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.263.1">The ISP is </span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.264.1">about splitting large, monolithic interfaces into </span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.265.1">more focused ones so that each class only implements the methods it actually needs. </span><span class="koboSpan" id="kobo.265.2">An example of a violation </span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.266.1">of this principle would be having a broad </span><strong class="keyWord"><span class="koboSpan" id="kobo.267.1">Inertial Measurement Unit</span></strong><span class="koboSpan" id="kobo.268.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.269.1">IMU</span></strong><span class="koboSpan" id="kobo.270.1">) interface that includes gyroscope and magnetometer functions, as </span><code class="inlineCode"><span class="koboSpan" id="kobo.271.1">adxl_345</span></code><span class="koboSpan" id="kobo.272.1"> is only an accelerometer and would be forced to provide methods it cannot meaningfully support.</span></p>
<h3 class="heading-3" id="_idParaDest-257"><span class="koboSpan" id="kobo.273.1">The Dependency Inversion Principle (DIP)</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.274.1">The example </span><a id="_idIndexMarker810"/><span class="koboSpan" id="kobo.275.1">code we discussed clearly demonstrates </span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.276.1">the </span><strong class="keyWord"><span class="koboSpan" id="kobo.277.1">Dependency Inversion Principle (DIP)</span></strong><span class="koboSpan" id="kobo.278.1">. </span><span class="koboSpan" id="kobo.278.2">By using an interface-based design, software components are cleanly decoupled:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.279.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.280.1">tap_detection_algo</span></code><span class="koboSpan" id="kobo.281.1"> class depends on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.282.1">accelerometer</span></code><span class="koboSpan" id="kobo.283.1"> interface, which is implemented by </span><code class="inlineCode"><span class="koboSpan" id="kobo.284.1">adxl_345</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.285.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.286.1">adxl_345</span></code><span class="koboSpan" id="kobo.287.1"> class depends on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.288.1">i2c</span></code><span class="koboSpan" id="kobo.289.1"> interface, which is implemented by </span><code class="inlineCode"><span class="koboSpan" id="kobo.290.1">i2c_stm32</span></code></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.291.1">SOLID principles </span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.292.1">allow us to write </span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.293.1">highly decoupled software and create reusable, hardware-independent code. </span><span class="koboSpan" id="kobo.293.2">Decoupled code is more flexible, and it is easier to add new features.</span></p>
<p class="normal"><em class="italic"><span class="koboSpan" id="kobo.294.1">As an exercise, add an accelerometer data logging capability without modifying the existing classes.</span></em></p>
<p class="normal"><span class="koboSpan" id="kobo.295.1">Good software design also improves software testability, which we will explore next.</span></p>
<h1 class="heading-1" id="_idParaDest-258"><span class="koboSpan" id="kobo.296.1">Testability</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.297.1">Interface-based design leads to decoupled software, which improves testability. </span><span class="koboSpan" id="kobo.297.2">Let us analyze the former </span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.298.1">example and see how decoupled design helps with testing. </span><span class="koboSpan" id="kobo.298.2">We’ll focus on the tap detection algorithm.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.299.1">In this example, we create a simple algorithm that detects a tap when the difference between the current sample and the previous sample on any axis exceeds a predefined threshold. </span><span class="koboSpan" id="kobo.299.2">This oversimplified implementation is shown in this code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.300.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.301.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.302.1">&lt;cmath&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.303.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.304.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.305.1">&lt;algorithm&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.306.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.307.1">tap_detection_algo</span></span><span class="koboSpan" id="kobo.308.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.309.1">public</span></span><span class="koboSpan" id="kobo.310.1">:
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.311.1">tap_detection_algo</span></span><span class="koboSpan" id="kobo.312.1">(accelerometer &amp;accel)
                    : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.313.1">accel_</span></span><span class="koboSpan" id="kobo.314.1">(accel), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.315.1">first_sample_</span></span><span class="koboSpan" id="kobo.316.1">(</span><span class="hljs-literal"><span class="koboSpan" id="kobo.317.1">true</span></span><span class="koboSpan" id="kobo.318.1">) {}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.319.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.320.1">run</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.321.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.322.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.323.1">auto</span></span><span class="koboSpan" id="kobo.324.1"> current = accel_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.325.1">get_data</span></span><span class="koboSpan" id="kobo.326.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.327.1">if</span></span><span class="koboSpan" id="kobo.328.1"> (first_sample_) {
        prev_ = current;
        first_sample_ = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.329.1">false</span></span><span class="koboSpan" id="kobo.330.1">;
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.331.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.332.1">false</span></span><span class="koboSpan" id="kobo.333.1">;
    }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.334.1">bool</span></span><span class="koboSpan" id="kobo.335.1"> tap = (std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.336.1">fabs</span></span><span class="koboSpan" id="kobo.337.1">(current.x - prev_.x) &gt; c_threshold) ||
           (std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.338.1">fabs</span></span><span class="koboSpan" id="kobo.339.1">(current.y - prev_.y) &gt; c_threshold) ||
               (std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.340.1">fabs</span></span><span class="koboSpan" id="kobo.341.1">(current.z - prev_.z) &gt; c_threshold);
    prev_ = current;	
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.342.1">return</span></span><span class="koboSpan" id="kobo.343.1"> tap;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.344.1">private</span></span><span class="koboSpan" id="kobo.345.1">:
</span><span class="hljs-type"><span class="koboSpan" id="kobo.346.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.347.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.348.1">float</span></span><span class="koboSpan" id="kobo.349.1"> c_threshold = </span><span class="hljs-number"><span class="koboSpan" id="kobo.350.1">0.5f</span></span><span class="koboSpan" id="kobo.351.1">;
accelerometer &amp;accel_;
accelerometer::data prev_;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.352.1">bool</span></span><span class="koboSpan" id="kobo.353.1"> first_sample_ = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.354.1">true</span></span><span class="koboSpan" id="kobo.355.1">;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.356.1">The preceding code implements a simple tap detection algorithm. </span><span class="koboSpan" id="kobo.356.2">It accepts an accelerometer reference and, on each call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.357.1">run()</span></code><span class="koboSpan" id="kobo.358.1">, retrieves the current sensor data. </span><span class="koboSpan" id="kobo.358.2">If it’s the first sample, it stores the value and returns false (no tap detected). </span><span class="koboSpan" id="kobo.358.3">On subsequent calls, it compares the current reading with the previous one on each axis. </span><span class="koboSpan" id="kobo.358.4">If the absolute difference on any </span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.359.1">axis exceeds a constant threshold, it signals a tap by returning true, then updates the previous sample.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.360.1">For unit testing, we’ll create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.361.1">fake_accel</span></code><span class="koboSpan" id="kobo.362.1"> class that simulates a sequence of accelerometer readings. </span><span class="koboSpan" id="kobo.362.2">This way, we can control the input data to check if </span><code class="inlineCode"><span class="koboSpan" id="kobo.363.1">tap_detection_algo</span></code><span class="koboSpan" id="kobo.364.1"> works. </span><span class="koboSpan" id="kobo.364.2">The code for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.365.1">fake_accel</span></code><span class="koboSpan" id="kobo.366.1"> class is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.367.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.368.1">fake_accel</span></span><span class="koboSpan" id="kobo.369.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.370.1">public</span></span><span class="koboSpan" id="kobo.371.1"> accelerometer {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.372.1">public</span></span><span class="koboSpan" id="kobo.373.1">:
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.374.1">fake_accel</span></span><span class="koboSpan" id="kobo.375.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.376.1">const</span></span><span class="koboSpan" id="kobo.377.1"> std::vector&lt;data&gt;&amp; samples)
: </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.378.1">samples_</span></span><span class="koboSpan" id="kobo.379.1">(samples), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.380.1">index_</span></span><span class="koboSpan" id="kobo.381.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.382.1">0</span></span><span class="koboSpan" id="kobo.383.1">) {}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.384.1">error </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.385.1">set_sampling_rate</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.386.1">(sampling_rate)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.387.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.388.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.389.1">return</span></span><span class="koboSpan" id="kobo.390.1"> error::ok;
}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.391.1">data </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.392.1">get_data</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.393.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.394.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.395.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.396.1">if</span></span><span class="koboSpan" id="kobo.397.1"> (index_ &lt; samples_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.398.1">size</span></span><span class="koboSpan" id="kobo.399.1">()) {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.400.1">return</span></span><span class="koboSpan" id="kobo.401.1"> samples_[index_++];
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.402.1">return</span></span><span class="koboSpan" id="kobo.403.1"> samples_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.404.1">back</span></span><span class="koboSpan" id="kobo.405.1">();
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.406.1">private</span></span><span class="koboSpan" id="kobo.407.1">:
std::vector&lt;data&gt; samples_;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.408.1">size_t</span></span><span class="koboSpan" id="kobo.409.1"> index_;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.410.1">This class, </span><code class="inlineCode"><span class="koboSpan" id="kobo.411.1">fake_accel</span></code><span class="koboSpan" id="kobo.412.1">, is a test double for the accelerometer interface. </span><span class="koboSpan" id="kobo.412.2">It simulates accelerometer data by:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.413.1">Accepting a </span><code class="inlineCode"><span class="koboSpan" id="kobo.414.1">vector</span></code><span class="koboSpan" id="kobo.415.1"> of predefined data samples through its constructor.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.416.1">Implementing </span><code class="inlineCode"><span class="koboSpan" id="kobo.417.1">set_sampling_rate</span></code><span class="koboSpan" id="kobo.418.1"> to always return a successful result.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.419.1">Returning each sample in order via </span><code class="inlineCode"><span class="koboSpan" id="kobo.420.1">get_data()</span></code><span class="koboSpan" id="kobo.421.1">, and once all samples are used, it repeatedly returns the last sample.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.422.1">This makes it useful for testing components that depend on accelerometer readings. </span><span class="koboSpan" id="kobo.422.2">Let us see how to use it </span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.423.1">to test the tap detection algorithm using the GoogleTest framework in the code shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.424.1">TEST</span></span><span class="koboSpan" id="kobo.425.1">(TapDetectionAlgoTest, DetectTapOnSuddenChange) {
std::vector&lt;accelerometer::data&gt; samples = {
    {</span><span class="hljs-number"><span class="koboSpan" id="kobo.426.1">0.0f</span></span><span class="koboSpan" id="kobo.427.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.428.1">1.0f</span></span><span class="koboSpan" id="kobo.429.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.430.1">0.0f</span></span><span class="koboSpan" id="kobo.431.1">}, </span><span class="hljs-comment"><span class="koboSpan" id="kobo.432.1">// initial reading</span></span><span class="koboSpan" id="kobo.433.1">
    {</span><span class="hljs-number"><span class="koboSpan" id="kobo.434.1">0.0f</span></span><span class="koboSpan" id="kobo.435.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.436.1">1.0f</span></span><span class="koboSpan" id="kobo.437.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.438.1">0.0f</span></span><span class="koboSpan" id="kobo.439.1">}, </span><span class="hljs-comment"><span class="koboSpan" id="kobo.440.1">// no change -&gt; false</span></span><span class="koboSpan" id="kobo.441.1">
    {</span><span class="hljs-number"><span class="koboSpan" id="kobo.442.1">0.0f</span></span><span class="koboSpan" id="kobo.443.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.444.1">2.0f</span></span><span class="koboSpan" id="kobo.445.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.446.1">0.0f</span></span><span class="koboSpan" id="kobo.447.1">} </span><span class="hljs-comment"><span class="koboSpan" id="kobo.448.1">// significant change</span></span><span class="koboSpan" id="kobo.449.1">
};
</span><span class="hljs-function"><span class="koboSpan" id="kobo.450.1">fake_accel </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.451.1">fakeAccel</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.452.1">(samples)</span></span><span class="koboSpan" id="kobo.453.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.454.1">tap_detection_algo </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.455.1">algo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.456.1">(fakeAccel)</span></span><span class="koboSpan" id="kobo.457.1">;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.458.1">EXPECT_FALSE</span></span><span class="koboSpan" id="kobo.459.1">(algo.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.460.1">run</span></span><span class="koboSpan" id="kobo.461.1">());
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.462.1">EXPECT_FALSE</span></span><span class="koboSpan" id="kobo.463.1">(algo.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.464.1">run</span></span><span class="koboSpan" id="kobo.465.1">());
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.466.1">EXPECT_TRUE</span></span><span class="koboSpan" id="kobo.467.1">(algo.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.468.1">run</span></span><span class="koboSpan" id="kobo.469.1">());
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.470.1">This test verifies that the tap detection algorithm correctly identifies a sudden change in accelerometer data as a tap. </span><span class="koboSpan" id="kobo.470.2">The test sets up a fake accelerometer with three samples:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.471.1">First sample: </span><code class="inlineCode"><span class="koboSpan" id="kobo.472.1">{0.0f, 1.0f, 0.0f}</span></code><span class="koboSpan" id="kobo.473.1"> – used for initialization (no tap detection).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.474.1">Second sample: </span><code class="inlineCode"><span class="koboSpan" id="kobo.475.1">{0.0f, 1.0f, 0.0f}</span></code><span class="koboSpan" id="kobo.476.1"> – no change compared to the first sample, so no tap is detected.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.477.1">Third sample: </span><code class="inlineCode"><span class="koboSpan" id="kobo.478.1">{0.0f, 2.0f, 0.0f}</span></code><span class="koboSpan" id="kobo.479.1"> – a significant change on the y axis (a difference of 1.0, which exceeds the threshold of 0.5) triggers tap detection.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.480.1">The test expects the first two calls to </span><code class="inlineCode"><span class="koboSpan" id="kobo.481.1">run()</span></code><span class="koboSpan" id="kobo.482.1"> to return false and the third call to return true. </span><span class="koboSpan" id="kobo.482.2">Thanks to interface-based design, we can pass a </span><code class="inlineCode"><span class="koboSpan" id="kobo.483.1">fake_accel</span></code><span class="koboSpan" id="kobo.484.1"> reference to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.485.1">tap_detection_algo</span></code><span class="koboSpan" id="kobo.486.1"> constructor since </span><code class="inlineCode"><span class="koboSpan" id="kobo.487.1">fake_accel</span></code><span class="koboSpan" id="kobo.488.1"> implements the </span><code class="inlineCode"><span class="koboSpan" id="kobo.489.1">accelerometer</span></code><span class="koboSpan" id="kobo.490.1"> interface. </span><span class="koboSpan" id="kobo.490.2">We supply the </span><code class="inlineCode"><span class="koboSpan" id="kobo.491.1">fake_accel</span></code><span class="koboSpan" id="kobo.492.1"> constructor with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.493.1">vector</span></code><span class="koboSpan" id="kobo.494.1"> container of samples to feed into the algorithm. </span><span class="koboSpan" id="kobo.494.2">This allows us to easily test the algorithm with a test dataset.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.495.1">The full example can be found at GitHub (</span><a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter18"><span class="url"><span class="koboSpan" id="kobo.496.1">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter18</span></span></a><span class="koboSpan" id="kobo.497.1">). </span><span class="koboSpan" id="kobo.497.2">Make sure you add the GoogleTest library to Compiler Explorer when running it.</span></p>
<h1 class="heading-1" id="_idParaDest-259"><span class="koboSpan" id="kobo.498.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.499.1">In this chapter, we learned why writing portable, cross-platform code is important for embedded development. </span><span class="koboSpan" id="kobo.499.2">It allows you to easily reuse software components and adapt to hardware changes, and it improves testability.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.500.1">You also learned about SOLID principles and how they apply to the design of software components in embedded systems using C++. </span><span class="koboSpan" id="kobo.500.2">Code readability and flexibility are some of the most important traits of well-designed software.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.501.1">We humans read the code, and the human who reads your code may be the future you. </span><span class="koboSpan" id="kobo.501.2">So, having easy-to-read code should be a priority. </span><span class="koboSpan" id="kobo.501.3">Sacrifice readability and optimize for performance only when absolutely needed. </span><span class="koboSpan" id="kobo.501.4">Having flexible code allows you to adapt to changes or add new features easily.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.502.1">With this chapter, our journey comes to an end. </span><span class="koboSpan" id="kobo.502.2">We began by exploring common myths about C++ and debunking them. </span><span class="koboSpan" id="kobo.502.3">From there, we covered many important aspects of modern C++ and learned how to apply them in embedded application development.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.503.1">We explored how to use lambdas to write expressive code and took advantage of compile-time computation to generate lookup tables, conserving memory and processing power. </span><span class="koboSpan" id="kobo.503.2">We also leveraged C++ type safety to implement a type-safe HAL.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.504.1">Next, we learned how to apply design patterns such as Adapter, Observer, and State to solve typical problems in embedded systems. </span><span class="koboSpan" id="kobo.504.2">We explored the C++ Standard Library, ETL, Pigweed, and cib and learned how to use them in embedded applications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.505.1">Throughout all the examples in this book, we focused on writing readable, maintainable, and loosely coupled code to strengthen our software design and development skills.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.506.1">I hope you enjoyed this journey and wish you happy coding!</span></p>
<h1 class="heading-1" id="_idParaDest-260"><span class="koboSpan" id="kobo.507.1">Join our community on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.508.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="https://packt.link/embeddedsystems"><span class="url"><span class="koboSpan" id="kobo.509.1">https://packt.link/embeddedsystems</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.510.1"><img alt="" role="presentation" src="../Images/QR_code_Discord.png"/></span></p>
</div>


<div class="Basic-Text-Frame" id="_idContainer097">
<p class="BM-packtLogo"><span class="koboSpan" id="kobo.1.1"><img alt="" role="presentation" src="../Images/Packt_Logo_New1.png"/></span></p>
<p class="normal"><a href="https://packtpub.com"><span class="url"><span class="koboSpan" id="kobo.2.1">packtpub.com</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.3.1">Subscribe to our online digital library for full access to over 7,000 books and videos, as well as industry leading tools to help you plan your personal development and advance your career. </span><span class="koboSpan" id="kobo.3.2">For more information, please visit our website.</span></p>
<h1 class="heading-1" id="_idParaDest-261"><span class="koboSpan" id="kobo.4.1">Why subscribe?</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5.1">Spend less time learning and more time coding with practical eBooks and Videos from over 4,000 industry professionals</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.6.1">Improve your learning with Skill Plans built especially for you</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.7.1">Get a free eBook or video every month</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.8.1">Fully searchable for easy access to vital information</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.9.1">Copy and paste, print, and bookmark content</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.10.1">At </span><a href="https://www.packtpub.com"><span class="url"><span class="koboSpan" id="kobo.11.1">www.packtpub.com</span></span></a><span class="koboSpan" id="kobo.12.1">, you can also read a collection of free technical articles, sign up for a range of free newsletters, and receive exclusive discounts and offers on Packt books and eBooks. </span></p>
<p class="eop"/>
<h1 class="mainHeading" id="_idParaDest-262"><span class="koboSpan" id="kobo.13.1">Other Books You May Enjoy</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.14.1">If you enjoyed this book, you may be interested in these other books by Packt:</span></p>
<p class="BM-bookCover"><span class="koboSpan" id="kobo.15.1"><img alt="" role="presentation" src="../Images/9781803239545.jpg"/></span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.16.1">Embedded Systems Architecture, Second Edition</span></strong></p>
<p class="normal"><span class="koboSpan" id="kobo.17.1">Daniele Lacamera</span></p>
<p class="normal"><span class="koboSpan" id="kobo.18.1">ISBN: 978-1-80323-954-5</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.19.1">Participate in the design and definition phase of an embedded product</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.20.1">Get to grips with writing code for ARM Cortex-M microcontrollers</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.21.1">Build an embedded development lab and optimize the workflow</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.22.1">Secure embedded systems with TLS</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.23.1">Demystify the architecture behind the communication interfaces</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.24.1">Understand the design and development patterns for connected and distributed devices in the IoT</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.25.1">Master multitasking parallel execution patterns and real-time operating systems</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.26.1">Become familiar with Trusted Execution Environment (TEE)</span></li>
</ul>
<p class="eop"/>
<p class="BM-bookCover"><span class="koboSpan" id="kobo.27.1"><img alt="" role="presentation" src="../Images/9781835460818.jpg"/></span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.28.1">Bare-Metal Embedded C Programming</span></strong></p>
<p class="normal"><span class="koboSpan" id="kobo.29.1">Israel Gbati</span></p>
<p class="normal"><span class="koboSpan" id="kobo.30.1">ISBN: 978-1-83546-081-8</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.31.1">Decode microcontroller datasheets, enabling precise firmware development</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.32.1">Master register manipulations for optimized Arm-based microcontroller firmware creation</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.33.1">Discover how to navigate hardware intricacies confidently</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.34.1">Find out how to write optimized firmware without any assistance</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.35.1">Work on exercises to create bare-metal drivers for GPIO, timers, ADC, UART, SPI, I2C, DMA, and more</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.36.1">Design energy-efficient embedded systems with power management techniques</span></li>
</ul>
<p class="eop"/>
<h1 class="heading-1" id="_idParaDest-263"><span class="koboSpan" id="kobo.37.1">Packt is searching for authors like you</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.38.1">If you’re interested in becoming an author for Packt, please visit </span><a href="https://authors.packtpub.com"><span class="url"><span class="koboSpan" id="kobo.39.1">authors.packtpub.com</span></span></a><span class="koboSpan" id="kobo.40.1"> and apply today. </span><span class="koboSpan" id="kobo.40.2">We have worked with thousands of developers and tech professionals, just like you, to help them share their insight with the global tech community. </span><span class="koboSpan" id="kobo.40.3">You can make a general application, apply for a specific hot topic that we are recruiting an author for, or submit your own idea.</span></p>
<p class="eop"/>
<h1 class="heading-1" id="_idParaDest-264"><span class="koboSpan" id="kobo.41.1">Share your thoughts</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.42.1">Now you’ve finished </span><em class="italic"><span class="koboSpan" id="kobo.43.1">C++ in Embedded Systems</span></em><span class="koboSpan" id="kobo.44.1">, we’d love to hear your thoughts! </span><span class="koboSpan" id="kobo.44.2">If you purchased the book from Amazon, please </span><span class="url"><span class="koboSpan" id="kobo.45.1">click here to go straight to the Amazon review page</span></span><span class="koboSpan" id="kobo.46.1"> for this book and share your feedback or leave a review on the site that you purchased it from.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.47.1">Your review is important to us and the tech community and will help us make sure we’re delivering excellent quality content. </span></p>
</div>
</body></html>