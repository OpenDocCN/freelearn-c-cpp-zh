["```cpp\n$ git clone https://github.com/PacktPublishing/Extreme-C.git\n...\n$ cd Extreme-C/ch21-integration-with-other-languages\n$\n```", "```cpp\n#ifndef _CSTACK_H_\n#define _CSTACK_H_\n#include <unistd.h>\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n#define TRUE 1\n#define FALSE 0\ntypedef int bool_t;\ntypedef struct {\n  char* data;\n  size_t len;\n} value_t;\ntypedef struct cstack_type cstack_t;\ntypedef void (*deleter_t)(value_t* value);\nvalue_t make_value(char* data, size_t len);\nvalue_t copy_value(char* data, size_t len);\nvoid free_value(value_t* value);\ncstack_t* cstack_new();\nvoid cstack_delete(cstack_t*);\n// Behavior functions\nvoid cstack_ctor(cstack_t*, size_t);\nvoid cstack_dtor(cstack_t*, deleter_t);\nsize_t cstack_size(const cstack_t*);\nbool_t cstack_push(cstack_t*, value_t value);\nbool_t cstack_pop(cstack_t*, value_t* value);\nvoid cstack_clear(cstack_t*, deleter_t);\n#ifdef __cplusplus\n}\n#endif\n#endif\n```", "```cpp\n#include <stdlib.h>\n#include <assert.h>\n#include \"cstack.h\"\nstruct cstack_type {\n  size_t top;\n  size_t max_size;\n  value_t* values;\n};\nvalue_t copy_value(char* data, size_t len) {\n  char* buf = (char*)malloc(len * sizeof(char));\n  for (size_t i = 0; i < len; i++) {\n    buf[i] = data[i];\n  }\n  return make_value(buf, len);\n}\nvalue_t make_value(char* data, size_t len) {\n  value_t value;\n  value.data = data;\n  value.len = len;\n  return value;\n}\nvoid free_value(value_t* value) {\n  if (value) {\n    if (value->data) {\n      free(value->data);\n      value->data = NULL;\n    }\n  }\n}\ncstack_t* cstack_new() {\n  return (cstack_t*)malloc(sizeof(cstack_t));\n}\nvoid cstack_delete(cstack_t* stack) {\n  free(stack);\n}\nvoid cstack_ctor(cstack_t* cstack, size_t max_size) {\n  cstack->top = 0;\n  cstack->max_size = max_size;\n  cstack->values = (value_t*)malloc(max_size * sizeof(value_t));\n}\nvoid cstack_dtor(cstack_t* cstack, deleter_t deleter) {\n  cstack_clear(cstack, deleter);\n  free(cstack->values);\n}\nsize_t cstack_size(const cstack_t* cstack) {\n  return cstack->top;\n}\nbool_t cstack_push(cstack_t* cstack, value_t value) {\n  if (cstack->top < cstack->max_size) {\n    cstack->values[cstack->top++] = value;\n    return TRUE;\n  }\n  return FALSE;\n}\nbool_t cstack_pop(cstack_t* cstack, value_t* value) {\n  if (cstack->top > 0) {\n    *value = cstack->values[--cstack->top];\n    return TRUE;\n  }\n  return FALSE;\n}\nvoid cstack_clear(cstack_t* cstack, deleter_t deleter) {\n  value_t value;\n  while (cstack_size(cstack) > 0) {\n    bool_t popped = cstack_pop(cstack, &value);\n    assert(popped);\n    if (deleter) {\n      deleter(&value);\n    }\n  }\n}\n```", "```cpp\n$ gcc -c -g -fPIC cstack.c -o cstack.o\n$ gcc -shared cstack.o -o libcstack.so\n$\n```", "```cpp\n$ clang -c -g -fPIC cstack.c -o cstack.o\n$ clang -dynamiclib cstack.o -o libcstack.dylib\n$\n```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"cstack.h\"\nvalue_t make_int(int int_value) {\n  value_t value;\n  int* int_ptr = (int*)malloc(sizeof(int));\n  *int_ptr = int_value;\n  value.data = (char*)int_ptr;\n  value.len = sizeof(int);\n  return value;\n}\nint extract_int(value_t* value) {\n  return *((int*)value->data);\n}\nvoid deleter(value_t* value) {\n  if (value->data) {\n    free(value->data);\n  }\n  value->data = NULL;\n}\nint main(int argc, char** argv) {\n  cstack_t* cstack = cstack_new();\n  cstack_ctor(cstack, 100);\n  assert(cstack_size(cstack) == 0);\n  int int_values[] = {5, 10, 20, 30};\n  for (size_t i = 0; i < 4; i++) {\n    cstack_push(cstack, make_int(int_values[i]));\n  }\n  assert(cstack_size(cstack) == 4);\n  int counter = 3;\n  value_t value;\n  while (cstack_size(cstack) > 0) {\n    bool_t popped = cstack_pop(cstack, &value);\n    assert(popped);\n    assert(extract_int(&value) == int_values[counter--]);\n    deleter(&value);\n  }\n  assert(counter == -1);\n  assert(cstack_size(cstack) == 0);\n  cstack_push(cstack, make_int(10));\n  cstack_push(cstack, make_int(20));\n  assert(cstack_size(cstack) == 2);\n  cstack_clear(cstack, deleter);\n  assert(cstack_size(cstack) == 0);\n   // In order to have something in the stack while\n  // calling destructor.\n  cstack_push(cstack, make_int(20));\n  cstack_dtor(cstack, deleter);\n  cstack_delete(cstack);\n  printf(\"All tests were OK.\\n\");\n  return 0;\n}\n```", "```cpp\n$ gcc -c -g cstack_tests.c -o tests.o\n$ gcc tests.o -L$PWD -lcstack -o cstack_tests.out\n$ LD_LIBRARY_PATH=$PWD ./cstack_tests.out\nAll tests were OK.\n$\n```", "```cpp\n$ LD_LIBRARY_PATH=$PWD valgrind --leak-check=full ./cstack_tests.out\n==31291== Memcheck, a memory error detector\n==31291== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\n==31291== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info\n==31291== Command: ./cstack_tests.out\n==31291==\nAll tests were OK.\n==31291==\n==31291== HEAP SUMMARY:\n==31291==     in use at exit: 0 bytes in 0 blocks\n==31291==   total heap usage: 10 allocs, 10 frees, 2,676 bytes allocated\n==31291==\n==31291== All heap blocks were freed -- no leaks are possible\n==31291==\n==31291== For counts of detected and suppressed errors, rerun with: -v\n==31291== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\n$\n```", "```cpp\nint add(int a, int b) {\n  return a + b;\n}\n```", "```cpp\n$ clang -c test.c -o test.o\n$ nm test.o\n0000000000000000 T _add\n$\n```", "```cpp\n$ clang++ -c test.c -o test.o\nclang: warning: treating 'c' input as 'c++' when in C++ mode, this behavior is deprecated [-Wdeprecated]\n$ nm test.o\n0000000000000000 T __Z3addii\n$\n```", "```cpp\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nint add(int a, int b) {\n  return a + b;\n}\n#ifdef __cplusplus\n}\n#endif\n```", "```cpp\n$ clang++ -c test.c -o test.o\nclang: warning: treating 'c' input as 'c++' when in C++ mode, this behavior is deprecated [-Wdeprecated]\n$ nm test.o\n0000000000000000 T _add\n$\n```", "```cpp\n#include <string.h>\n#include <iostream>\n#include <string>\n#include \"cstack.h\"\ntemplate<typename T>\nvalue_t CreateValue(const T& pValue);\ntemplate<typename T>\nT ExtractValue(const value_t& value);\ntemplate<typename T>\nclass Stack {\npublic:\n  // Constructor\n  Stack(int pMaxSize) {\n    mStack = cstack_new();\n    cstack_ctor(mStack, pMaxSize);\n  }\n  // Destructor\n  ~Stack() {\n    cstack_dtor(mStack, free_value);\n    cstack_delete(mStack);\n  }\n  size_t Size() {\n    return cstack_size(mStack);\n  }\n  void Push(const T& pItem) {\n    value_t value = CreateValue(pItem);\n    if (!cstack_push(mStack, value)) {\n      throw \"Stack is full!\";\n    }\n  }\n  const T Pop() {\n    value_t value;\n    if (!cstack_pop(mStack, &value)) {\n      throw \"Stack is empty!\";\n    }\n    return ExtractValue<T>(value);\n  }\n  void Clear() {\n    cstack_clear(mStack, free_value);\n  }\nprivate:\n  cstack_t* mStack;\n};\n```", "```cpp\ntemplate<>\nvalue_t CreateValue(const std::string& pValue) {\n  value_t value;\n  value.len = pValue.size() + 1;\n  value.data = new char[value.len];\n  strcpy(value.data, pValue.c_str());\n  return value;\n}\ntemplate<>\nstd::string ExtractValue(const value_t& value) {\n  return std::string(value.data, value.len);\n}\n```", "```cpp\nint main(int argc, char** argv) {\n  Stack<std::string> stringStack(100);\n  stringStack.Push(\"Hello\");\n  stringStack.Push(\"World\");\n  stringStack.Push(\"!\");\n  std::cout << \"Stack size: \" << stringStack.Size() << std::endl;\n  while (stringStack.Size() > 0) {\n    std::cout << \"Popped > \" << stringStack.Pop() << std::endl;\n  }\n  std::cout << \"Stack size after pops: \" <<\n      stringStack.Size() << std::endl;\n  stringStack.Push(\"Bye\");\n  stringStack.Push(\"Bye\");\n  std::cout << \"Stack size before clear: \" <<\n      stringStack.Size() << std::endl;\n  stringStack.Clear();\n  std::cout << \"Stack size after clear: \" <<\n      stringStack.Size() << std::endl;\n  return 0;\n}\n```", "```cpp\n$ cd c++\n$ g++ -c -g -std=c++11 -I$PWD/.. Stack.cpp -o Stack.o\n$ g++ -L$PWD/.. Stack.o -lcstack -o cstack_cpp.out \n$ LD_LIBRARY_PATH=$PWD/.. ./cstack_cpp.out\nStack size: 3\nPopped > !\nPopped > World\nPopped > Hello\nStack size after pops: 0\nStack size before clear: 2\nStack size after clear: 0\n$\n```", "```cpp\n$ cd c++\n$ LD_LIBRARY_PATH=$PWD/.. valgrind --leak-check=full ./cstack_cpp.out\n==15061== Memcheck, a memory error detector\n==15061== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\n==15061== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info\n==15061== Command: ./cstack_cpp.out\n==15061==\nStack size: 3\nPopped > !\nPopped > World\nPopped > Hello\nStack size after pops: 0\nStack size before clear: 2\nStack size after clear: 0\n==15061==\n==15061== HEAP SUMMARY:\n==15061==     in use at exit: 0 bytes in 0 blocks\n==15061==   total heap usage: 9 allocs, 9 frees, 75,374 bytes allocated\n==15061==\n==15061== All heap blocks were freed -- no leaks are possible\n==15061==\n==15061== For counts of detected and suppressed errors, rerun with: -v\n==15061== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) \n$\n```", "```cpp\npackage com.packt.extreme_c.ch21.ex1;\nclass NativeStack {\n  static {\n    System.loadLibrary(\"NativeStack\");\n  }\n  public static native long newStack();\n  public static native void deleteStack(long stackHandler);\n  public static native void ctor(long stackHandler, int maxSize);\n  public static native void dtor(long stackHandler);\n  public static native int size(long stackHandler);\n  public static native void push(long stackHandler, byte[] item);\n  public static native byte[] pop(long stackHandler);\n  public static native void clear(long stackHandler);\n}\n```", "```cpp\ninterface Marshaller<T> {\n  byte[] marshal(T obj);\n  T unmarshal(byte[] data);\n}\nclass Stack<T> implements AutoCloseable {\n  private Marshaller<T> marshaller;\n  private long stackHandler;\n  public Stack(Marshaller<T> marshaller) {\n    this.marshaller = marshaller;\n    this.stackHandler = NativeStack.newStack();\n    NativeStack.ctor(stackHandler, 100);\n  }\n  @Override\n  public void close() {\n    NativeStack.dtor(stackHandler);\n    NativeStack.deleteStack(stackHandler);\n  }\n  public int size() {\n    return NativeStack.size(stackHandler);\n  }\n  public void push(T item) {\n    NativeStack.push(stackHandler, marshaller.marshal(item));\n  }\n  public T pop() {\n    return marshaller.unmarshal(NativeStack.pop(stackHandler));\n  }\n  public void clear() {\n    NativeStack.clear(stackHandler);\n  }\n}\n```", "```cpp\nclass StringMarshaller implements Marshaller<String> {\n  @Override\n  public byte[] marshal(String obj) {\n    return obj.getBytes();\n  }\n  @Override\n  public String unmarshal(byte[] data) {\n    return new String(data);\n  }\n}\n```", "```cpp\npublic class Main {\n  public static void main(String[] args) {\n    try (Stack<String> stack = new Stack<>(new StringMarshaller())) {\n      stack.push(\"Hello\");\n      stack.push(\"World\");\n      stack.push(\"!\");\n      System.out.println(\"Size after pushes: \" + stack.size());\n      while (stack.size() > 0) {\n        System.out.println(stack.pop());\n      }\n      System.out.println(\"Size after pops: \" + stack.size());\n      stack.push(\"Ba\");\n      stack.push(\"Bye!\");\n      System.out.println(\"Size after before clear: \" + stack.size());\n      stack.clear();\n      System.out.println(\"Size after clear: \" + stack.size());\n    }\n  }\n}\n```", "```cpp\n$ cd java\n$ mkdir -p build/headers\n$ mkdir -p build/classes\n$ javac -cp src -h build/headers -d build/classes \\\nsrc/com/packt/extreme_c/ch21/ex1/Main.java\n$ tree build\nbuild\n├── classes\n│   └── com\n│       └── packt\n│           └── extreme_c\n│               └── ch21\n│                   └── ex1\n│                       ├── Main.class\n│                       ├── Marshaller.class\n│                       ├── NativeStack.class\n│                       ├── Stack.class\n│                       └── StringMarshaller.class\n└── headers\n    └── com_packt_extreme_c_ch21_ex1_NativeStack.h\n7 directories, 6 files\n$\n```", "```cpp\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include <jni.h>\n/* Header for class com_packt_extreme_c_ch21_ex1_NativeStack */\n#ifndef _Included_com_packt_extreme_c_ch21_ex1_NativeStack\n#define _Included_com_packt_extreme_c_ch21_ex1_NativeStack\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/*\n * Class:     com_packt_extreme_c_ch21_ex1_NativeStack\n * Method:    newStack\n * Signature: ()J\n */\nJNIEXPORT jlong JNICALL Java_com_packt_extreme_1c_ch21_ex1_NativeStack_newStack\n  (JNIEnv *, jclass);\n/*\n * Class:     com_packt_extreme_c_ch21_ex1_NativeStack\n * Method:    deleteStack\n * Signature: (J)V\n */\nJNIEXPORT void JNICALL Java_com_packt_extreme_1c_ch21_ex1_NativeStack_deleteStack\n  (JNIEnv *, jclass, jlong);\n\n...\n...\n...\n#ifdef __cplusplus\n}\n#endif\n#endif\n```", "```cpp\n// Filename: NativeStack.h\n// Description: Modified JNI generated header file\n#include <jni.h>\n#ifndef _Included_com_packt_extreme_c_ch21_ex1_NativeStack\n#define _Included_com_packt_extreme_c_ch21_ex1_NativeStack\n#define JNI_FUNC(n) Java_com_packt_extreme_1c_ch21_ex1_NativeStack_##\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nJNIEXPORT jlong JNICALL JNI_FUNC(newStack)(JNIEnv* , jclass);\nJNIEXPORT void JNICALL JNI_FUNC(deleteStack)(JNIEnv* , jclass, jlong);\nJNIEXPORT void JNICALL JNI_FUNC(ctor)(JNIEnv* , jclass, jlong, jint);\nJNIEXPORT void JNICALL JNI_FUNC(dtor)(JNIEnv* , jclass, jlong);\nJNIEXPORT jint JNICALL JNI_FUNC(size)(JNIEnv* , jclass, jlong);\nJNIEXPORT void JNICALL JNI_FUNC(push)(JNIEnv* , jclass, jlong, jbyteArray);\nJNIEXPORT jbyteArray JNICALL JNI_FUNC(pop)(JNIEnv* , jclass, jlong);\nJNIEXPORT void JNICALL JNI_FUNC(clear)(JNIEnv* , jclass, jlong);\n#ifdef __cplusplus\n}\n#endif\n#endif\n```", "```cpp\n#include <stdlib.h>\n#include \"NativeStack.h\"\n#include \"cstack.h\"\nvoid defaultDeleter(value_t* value) {\n  free_value(value);\n}\nvoid extractFromJByteArray(JNIEnv* env,\n                           jbyteArray byteArray,\n                           value_t* value) {\n  jboolean isCopy = false;\n  jbyte* buffer = env->GetByteArrayElements(byteArray, &isCopy);\n  value->len = env->GetArrayLength(byteArray);\n  value->data = (char*)malloc(value->len * sizeof(char));\n  for (size_t i = 0; i < value->len; i++) {\n    value->data[i] = buffer[i];\n  }\n  env->ReleaseByteArrayElements(byteArray, buffer, 0);\n}\nJNIEXPORT jlong JNICALL JNI_FUNC(newStack)(JNIEnv* env,\n                                           jclass clazz) {\n  return (long)cstack_new();\n}\nJNIEXPORT void JNICALL JNI_FUNC(deleteStack)(JNIEnv* env,\n                                            jclass clazz,\n                                            jlong stackPtr) {\n  cstack_t* cstack = (cstack_t*)stackPtr;\n  cstack_delete(cstack);\n}\nJNIEXPORT void JNICALL JNI_FUNC(ctor)(JNIEnv *env,\n                                      jclass clazz,\n                                      jlong stackPtr,\n                                      jint maxSize) {\n  cstack_t* cstack = (cstack_t*)stackPtr;\n  cstack_ctor(cstack, maxSize);\n}\nJNIEXPORT void JNICALL JNI_FUNC(dtor)(JNIEnv* env,\n                                      jclass clazz,\n                                      jlong stackPtr) {\n  cstack_t* cstack = (cstack_t*)stackPtr;\n  cstack_dtor(cstack, defaultDeleter);\n}\nJNIEXPORT jint JNICALL JNI_FUNC(size)(JNIEnv* env,\n                                      jclass clazz,\n                                      jlong stackPtr) {\n  cstack_t* cstack = (cstack_t*)stackPtr;\n  return cstack_size(cstack);\n}\nJNIEXPORT void JNICALL JNI_FUNC(push)(JNIEnv* env,\n                                      jclass clazz,\n                                      jlong stackPtr,\n                                      jbyteArray item) {\n  value_t value;\n  extractFromJByteArray(env, item, &value);\n  cstack_t* cstack = (cstack_t*)stackPtr;\n  bool_t pushed = cstack_push(cstack, value);\n  if (!pushed) {\n    jclass Exception = env->FindClass(\"java/lang/Exception\");\n    env->ThrowNew(Exception, \"Stack is full!\");\n  }\n}\nJNIEXPORT jbyteArray JNICALL JNI_FUNC(pop)(JNIEnv* env,\n                                           jclass clazz,\n                                           jlong stackPtr) {\n  value_t value;\n  cstack_t* cstack = (cstack_t*)stackPtr;\n  bool_t popped = cstack_pop(cstack, &value);\n  if (!popped) {\n    jclass Exception = env->FindClass(\"java/lang/Exception\");\n    env->ThrowNew(Exception, \"Stack is empty!\");\n  }\n  jbyteArray result = env->NewByteArray(value.len);\n  env->SetByteArrayRegion(result, 0,\n          value.len, (jbyte*)value.data);\n  defaultDeleter(&value);\n  return result;\n}\nJNIEXPORT void JNICALL JNI_FUNC(clear)(JNIEnv* env,\n                                       jclass clazz,\n                                       jlong stackPtr) {\n  cstack_t* cstack = (cstack_t*)stackPtr;\n  cstack_clear(cstack, defaultDeleter);\n}\n```", "```cpp\n$ cd java/native\n$ g++ -c -fPIC -I$PWD/../.. -I$JAVA_HOME/include \\\n -I$JAVA_HOME/include/linux NativeStack.cpp -o NativeStack.o\n$ g++ -shared -L$PWD/../.. NativeStack.o -lcstack -o libNativeStack.so\n$\n```", "```cpp\n$ cd java\n$ LD_LIBRARY_PATH=$PWD/.. java -Djava.library.path=$PWD/native \\\n  -cp build/classes com.packt.extreme_c.ch21.ex1.Main\nSize after pushes: 3\n!\nWorld\nHello\nSize after pops: 0\nSize after before clear: 2\nSize after clear: 0\n$\n```", "```cpp\nfrom ctypes import *\nclass value_t(Structure):\n  _fields_ = [(\"data\", c_char_p), (\"len\", c_int)]\nclass _NativeStack:\n  def __init__(self):\n    self.stackLib = cdll.LoadLibrary(\n            \"libcstack.dylib\" if platform.system() == 'Darwin'\n            else \"libcstack.so\")\n    # value_t make_value(char*, size_t)\n    self._makevalue_ = self.stackLib.make_value\n    self._makevalue_.argtypes = [c_char_p, c_int]\n    self._makevalue_.restype = value_t\n    # value_t copy_value(char*, size_t)\n    self._copyvalue_ = self.stackLib.copy_value\n    self._copyvalue_.argtypes = [c_char_p, c_int]\n    self._copyvalue_.restype = value_t\n    # void free_value(value_t*)\n    self._freevalue_ = self.stackLib.free_value\n    self._freevalue_.argtypes = [POINTER(value_t)]\n    # cstack_t* cstack_new()\n    self._new_ = self.stackLib.cstack_new\n    self._new_.argtypes = []\n    self._new_.restype = c_void_p\n    # void cstack_delete(cstack_t*)\n    self._delete_ = self.stackLib.cstack_delete\n    self._delete_.argtypes = [c_void_p]\n    # void cstack_ctor(cstack_t*, int)\n    self._ctor_ = self.stackLib.cstack_ctor\n    self._ctor_.argtypes = [c_void_p, c_int]\n    # void cstack_dtor(cstack_t*, deleter_t)\n    self._dtor_ = self.stackLib.cstack_dtor\n    self._dtor_.argtypes = [c_void_p, c_void_p]\n    # size_t cstack_size(cstack_t*)\n    self._size_ = self.stackLib.cstack_size\n    self._size_.argtypes = [c_void_p]\n    self._size_.restype = c_int\n    # bool_t cstack_push(cstack_t*, value_t)\n    self._push_ = self.stackLib.cstack_push\n    self._push_.argtypes = [c_void_p, value_t]\n    self._push_.restype = c_int\n    # bool_t cstack_pop(cstack_t*, value_t*)\n    self._pop_ = self.stackLib.cstack_pop\n    self._pop_.argtypes = [c_void_p, POINTER(value_t)]\n    self._pop_.restype = c_int\n    # void cstack_clear(cstack_t*, deleter_t)\n    self._clear_ = self.stackLib.cstack_clear\n    self._clear_.argtypes = [c_void_p, c_void_p]\n```", "```cpp\nclass Stack:\n  def __enter__(self):\n    self._nativeApi_ = _NativeStack()\n    self._handler_ = self._nativeApi_._new_()\n    self._nativeApi_._ctor_(self._handler_, 100)\n    return self\n  def __exit__(self, type, value, traceback):\n    self._nativeApi_._dtor_(self._handler_, self._nativeApi_._freevalue_)\n    self._nativeApi_._delete_(self._handler_)\n  def size(self):\n    return self._nativeApi_._size_(self._handler_)\n  def push(self, item):\n    result = self._nativeApi_._push_(self._handler_,\n            self._nativeApi_._copyvalue_(item.encode('utf-8'), len(item)));\n    if result != 1:\n      raise Exception(\"Stack is full!\")\n  def pop(self):\n    value = value_t()\n    result = self._nativeApi_._pop_(self._handler_, byref(value))\n    if result != 1:\n      raise Exception(\"Stack is empty!\")\n    item = string_at(value.data, value.len)\n    self._nativeApi_._freevalue_(value)\n    return item\n  def clear(self):\n    self._nativeApi_._clear_(self._handler_, self._nativeApi_._freevalue_)\n```", "```cpp\nif __name__ == \"__main__\":\n  with Stack() as stack:\n    stack.push(\"Hello\")\n    stack.push(\"World\")\n    stack.push(\"!\")\n    print(\"Size after pushes:\" + str(stack.size()))\n    while stack.size() > 0:\n      print(stack.pop())\n    print(\"Size after pops:\" + str(stack.size()))\n    stack.push(\"Ba\");\n    stack.push(\"Bye!\");\n    print(\"Size before clear:\" + str(stack.size()))\n    stack.clear()\n    print(\"Size after clear:\" + str(stack.size()))\n```", "```cpp\n$ cd python\n$ LD_LIBRARY_PATH=$PWD/.. python stack.py\nSize after pushes:3\n!\nWorld\nHello\nSize after pops:0\nSize before clear:2\nSize after clear:0\n$\n```", "```cpp\npackage main\n/*\n#cgo CFLAGS: -I..\n#cgo LDFLAGS: -L.. -lcstack\n#include \"cstack.h\"\n*/\nimport \"C\"\nimport (\n  \"fmt\"\n)\ntype Stack struct {\n  handler *C.cstack_t\n}\nfunc NewStack() *Stack {\n  s := new(Stack)\n  s.handler = C.cstack_new()\n  C.cstack_ctor(s.handler, 100)\n  return s\n}\nfunc (s *Stack) Destroy() {\n  C.cstack_dtor(s.handler, C.deleter_t(C.free_value))\n  C.cstack_delete(s.handler)\n}\nfunc (s *Stack) Size() int {\n  return int(C.cstack_size(s.handler))\n}\nfunc (s *Stack) Push(item string) bool {\n  value := C.make_value(C.CString(item), C.ulong(len(item) + 1))\n  pushed := C.cstack_push(s.handler, value)\n  return pushed == 1\n}\nfunc (s *Stack) Pop() (bool, string) {\n  value := C.make_value(nil, 0)\n  popped := C.cstack_pop(s.handler, &value)\n  str := C.GoString(value.data)\n  defer C.free_value(&value)\n  return popped == 1, str\n}\nfunc (s *Stack) Clear() {\n  C.cstack_clear(s.handler, C.deleter_t(C.free_value))\n}\n```", "```cpp\nfunc main() {\n  var stack = NewStack()\n  stack.Push(\"Hello\")\n  stack.Push(\"World\")\n  stack.Push(\"!\")\n  fmt.Println(\"Stack size:\", stack.Size())\n  for stack.Size() > 0 {\n    _, str := stack.Pop()\n    fmt.Println(\"Popped >\", str)\n  }\n  fmt.Println(\"Stack size after pops:\", stack.Size())\n  stack.Push(\"Bye\")\n  stack.Push(\"Bye\")\n  fmt.Println(\"Stack size before clear:\", stack.Size())\n  stack.Clear()\n  fmt.Println(\"Stack size after clear:\", stack.Size())\n  stack.Destroy()\n}\n```", "```cpp\n$ cd go\n$ go build -o stack.out stack.go\n$ LD_LIBRARY_PATH=$PWD/.. ./stack.out\nStack size: 3\nPopped > !\nPopped > World\nPopped > Hello\nStack size after pops: 0\nStack size before clear: 2\nStack size after clear: 0\n$\n```"]