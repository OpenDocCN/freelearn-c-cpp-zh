- en: Sorting and Searching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Searching, as the name suggests, is the process of locating a specific element
    in a group of elements. Searching can be broadly classified as one of the following
    two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Linear searching**: Where each element in the list is sequentially searched
    to find the desired item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binary search**: Where the list is assumed to already be sorted, and the
    middle value of the list is compared with the item to be searched to determine
    which half of the list needs to be considered for searching the item. The process
    of dividing the list continues until the item is found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sorting, on the other hand, is the procedure of arranging certain elements
    in a certain order. The order can be ascending, descending, or in another specific
    order. Not only can the individual numerals and strings be sorted, but even records
    can be sorted. Records are sorted on the basis of some key that is unique to every
    record. These are the two main categories of sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internal sorting**: Where all the elements that are being sorted are uploaded
    together in the primary memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External sorting**: Where some elements to be sorted are uploaded to the
    primary memory, and the rest are kept in auxiliary memory, such as on a hard disk
    or pen drive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be able to conduct effective searches, we need to know how to sort data.
    Sorting is essential because it makes the task of searching quite easy and fast.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Searching for an item using binary search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arranging numbers in ascending order using bubble sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arranging numbers in ascending order using insertion sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arranging numbers in ascending order using quick sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arranging numbers in descending order using heap sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin with the first recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Searching for an item using binary search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Binary search uses the *divide and conquer* approach. The item to be searched for
    is compared with the middle item in an array or file. This helps in determining
    which half of the array or file might contain the item being searched for. After
    that, the middle value of the half that was considered is compared with the item
    being searched for to determine which quarter part of the array or file might
    contain the item being searched for. The process continues until either the item
    being searched for is found, or no more divisions of the array or file are possible,
    in which case, it is understood that the item being searched for is not present
    in the file or array.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider an array is `arr` of size `len` elements. We want to search for a
    number, `numb`, in this array, `arr`. Here are the steps to search for `numb` in
    the `arr` array using binary search:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize two variables, `lower` and `upper`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the middle location of the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the value to search, `numb`, is found at location `arr[mid]` then display
    `Value found` and exit (that is, jump to *step 8*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your search value is larger than the array's middle value, confine the search
    to the lower half of the array. So, set the lower limit of the array to the array's
    middle value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your search value is smaller than the array's middle value, confine the search
    to the upper half of the array. So, set the upper limit of the array to the array's middle value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 3* through *5* as long as `upper>=lower`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The execution will proceed with this step only if the value is not found. Then
    display `Value not found` and exit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for searching for an element in a sorted array using the binary
    search technique is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s define a macro called `max` of size 20 and an array, `arr`, of size
    `max`, that is, 20 elements (you can increase the value of the `max` macro to
    any larger value as desired). Next, we will specify the length of the array. Let''s
    say that the length you entered is 8, which is then assigned to the `len` variable.
    When prompted, enter the specified number of sorted elements. The sorted elements
    you enter will be assigned to the `arr` array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/604e1956-f828-45c2-b3b5-bdb2d59af980.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1
  prefs: []
  type: TYPE_NORMAL
- en: Then, you will be prompted to enter the number you want to search for in the
    sorted array. Let's say you picked 45; this number will be assigned to the `numb`
    variable. We will invoke the `binary_search` function and all three items – the `arr` array, the
    `numb` variable containing the number to search for, and the length of the array
    in `len` – are passed to the function. The `arr`, `numb`, and `len` arguments will
    be assigned to the `arr`, `pnumb`, and `plen` parameters respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `binary_search` function, we will initialize two variables: `lindex` to
    `0` and `uindex` to `7`, that is, equal to the length of the array; these two
    indexes represent the lower and upper index locations of the array respectively.
    Because arrays are zero-based, the eighth element of the array will be found at
    index location 7\. We''ll set a `while` loop to execute for as long as the value
    of `uindex` is greater than or equal to the value of `lindex`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compare the search value with the middle value of the array, we will first
    compute the middle value; sum the values of `lindex` and `uindex`, and divide
    the result by 2\. The output of (0+7)/2 is 3\. Then, compare the value of the `numb`
    variable, that is, 45, with the value at location `arr[3]`, derived from your
    computation, that is, with 34 (see *Figure 9.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c26702a9-b1d5-4cc9-94f7-1207bf5ebbfc.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2
  prefs: []
  type: TYPE_NORMAL
- en: Because 45 is greater than 34, we will have to continue our search in the lower
    half of the array. However, since our list is sorted in ascending order, we can
    now concentrate our search in the lower half of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the value of `lindex` is set equal to `mid+1`, that is, 4\. Again, execute
    the `while` loop because `uindex`, that is, 7, is still greater than `lindex`.
    We will now compute the middle value of the upper half of the array: (4+7)/2 =
    5\. The search value 45 will be compared with `arr[5]`, that is, with 80\. Because
    45 is smaller than 80, we will continue our search in the lower half of the array,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a65e061e-bb41-48f0-8581-08c737362a8f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3
  prefs: []
  type: TYPE_NORMAL
- en: Next, the value of `uindex` is set equal to `mid-1`, that is, equal to 4\. And
    the value of `lindex` from our previous computation is also 4\. We will again
    execute the `while` loop because 4=4\. The middle value of the array will be computed
    as (4+4)/2, that is, the search value 45 will be compared with `arr[4]`, which
    is 60.
  prefs: []
  type: TYPE_NORMAL
- en: Because 45 < 60, the value of `uindex` will be set to `mid-1`, that is, equal
    to 3\. The `while` loop will exit because our `uindex (3)` is not greater than
    our `lindex (4)` any more. The `binary_search` function will return the `nfound`
    variable to the `main` function. The `nfound` variable contains some garbage value,
    which is then assigned to the `found` variable in the `main` function. In the
    `main` function, the values in the `found` and `numb` variables are compared.
    Because the garbage value is not equal to the value in the `numb` variable, 45,
    a message, `Value 45 is not found in the list` will be displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to search for the value 15 now. The values of `lindex` and
    `uindex` will again be 0 and 7 initially. The `while` loop will execute and the
    middle value will be computed as (0+7)/2, which will be 3\. The value of 15 will
    be compared with the corresponding location, `arr[3]`, that is, with 34\. The
    value of 15 is smaller than 34, so the upper half of the array will be considered
    to continue the binary search, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d08a84d2-5560-45b2-aa60-11594e9e73cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `uindex` variable is set equal to `mid-1`, that is, 2\. Because
    `uindex` is still greater than `lindex`, that is, 2 >=0, the `while` loop will
    execute again. Again, the middle value is computed as (0+2)/2, which is 1\. This
    means that 15 is compared with the `arr[1]` element.
  prefs: []
  type: TYPE_NORMAL
- en: The value at the `arr[1]` location is 15 only; hence, the `nfound` variable
    is set to 15 in the `binary_search` function and the `nfound` variable is returned
    to the `main` function. In the `main` function, the value of the `nfound` variable
    will be assigned to the `found` variable. Because the value in the `found` and
    `numb` variables are the same, the message `Value 15 is found in the list` will
    be displayed onscreen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears on compilation, that means the `binarysearch.c` program has successfully
    been compiled into an EXE file, that is, to the `binarysearch.exe` file. On executing
    the executable file, if we try searching for a value that is not found in the
    list, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6226a1e8-49aa-46e0-8ecb-5517477411cb.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the executable file again and enter a number that exists in the array,
    we may get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e5e64bd-0eb0-425b-b4b8-31ef42248e3c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We've successfully used binary search to locate an item in a sorted array.
    Now let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Arranging numbers in ascending order using bubble sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to arrange some integers in ascending order
    using the bubble sort technique. In this technique, the first element is compared
    with the second, the second is compared with the third, the third with the fourth,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider an array, `arr`, of size `len` elements. We want to arrange elements
    of the `arr` array in ascending order. Here are the steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a variable, say `i`, to `len -2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow and repeat *steps 3* through *5* as long as `i >=1`.  The value of `i`
    will be decremented by 1 after every iteration, that is, `i=len-2`, `len-3`, `len-4`,
    `....1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize another variable, `j`, to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *step 5* to `j<=i`. The value of `j` will increase after every iteration,
    that is,  `j=1`, `2... i`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `arr[j] > arr[j+1]`, then interchange the two values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit the search.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for sorting elements of an integer array using the bubble sort
    technique is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by defining a macro, `max`, of value 20\. You can always increase
    the value of `max` as required. Then, we will define an array, `arr`, of size
    `max`, that is, of size 20\. You will be asked how many values you want to sort.
    Assuming that you want to sort seven elements, the value you entered will be assigned
    to the `len` variable. You will be prompted to enter the values to be sorted,
    which will then be assigned to the `arr` array. The seven values to be sorted
    in the `arr` array might appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de0e68f8-499b-445a-8ca8-b1b614368e38.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will run two nested `for` loops: the outer `for` loop will execute
    from `len-2`, that is, from value 5 to 1 in descending order, and the inner `for`
    loop will execute for the value from 0 to `i`. That means, in the first iteration,
    the value of `i` will be 5, so the inner `for` `j` loop will execute from 0 to
    5\. Within the inner `for` loop, the first value of `arr` will be compared with
    the second, the second value with the third, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09a44130-05b3-4c2d-90ea-30bc3bd454ce.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8
  prefs: []
  type: TYPE_NORMAL
- en: The tendency is to keep the value at the lower index smaller than the value
    at the higher index. If the first value is larger than the second, they will change
    places; and if the first value is already smaller than the second value, then
    the next two values in line, that is, the second and third values, are taken for
    consideration. Similarly, if the second value is larger than the third, they too
    will swap places; if not, then the next set of values, that is, the third and
    fourth values, will be compared. The process will continue until the last pair,
    that is, the sixth and seventh values in our case, are compared.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire first iteration of comparisons is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e5c9d5f-d2a1-4148-9778-e05077f1b7bc.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that after the first iteration, the largest value has bubbled down
    to the bottom of the list. Now, the value of the outer loop, that is, the value
    of `i` will be decremented by 1, making it 4\. Consequently, the value of `j`
    in the inner loop will make the `for` loop run from value 0 to 4\. It also means
    that now, the first value will be compared with the second, the second with the
    third, and so on. Finally, the fifth value (that is, the value at index location
    4) will be compared with the sixth value (that is, the value at index location
    5). The last element at index location 6 will not be compared as it is already
    at its correct destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21954200-2d6c-445d-8fc6-b91aa6f851d5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, after the second iteration, the value of the outer loop will be decremented
    by 1, making it 3\. As a result, the value of `j` in the inner loop will make
    the `for` loop run from value 0 to 3\. In the last, the fourth value, that is,
    the value at index location 3, will be compared with the fifth value. The last
    two elements at index location 5 and 6 are not compared as both are at their correct
    destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/643fb9eb-beb2-4646-b5e1-22768ada794d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11
  prefs: []
  type: TYPE_NORMAL
- en: 'After the third iteration, the value of `i` will be decremented by 1, making
    it 2\. Hence, the value of `j` will make the `for` loop run from value 0 to 2\.
    The last three elements at index location 4, 5, and 6 are not compared as they
    already are at their correct destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0b5615f-1fe5-42b7-9beb-bdadd83d7853.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12
  prefs: []
  type: TYPE_NORMAL
- en: 'After the fourth iteration, the value of `i` will be decremented again, making
    it 1\. So, the value of `j` in the inner loop will make the `for` loop run from
    value 0 to 1\. The last four elements are not compared as they already are at
    their final destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14eae109-5066-420b-8a9c-b6bc6cb4f7f7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13
  prefs: []
  type: TYPE_NORMAL
- en: 'So, after five iterations, we have successfully arranged the numbers in our
    array in ascending order. The program is compiled using GCC with the following
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Because no error appears on compilation, that means the `bubblesort.c` program has
    successfully been compiled into the `bubblesort.exe` file. On executing this file,
    it will ask us to specify how many numbers there are to be sorted.  Then the program
    will prompt us to enter the numbers to be sorted. After entering the numbers,
    they will appear sorted in ascending order, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0402903-a353-43ca-b18a-0bfc1feae139.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We've successfully used the bubble sort technique to arrange numbers
    in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Arranging numbers in ascending order using insertion sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this sorting technique, a region of the array, which might be the lower or
    upper part, is considered as sorted. An element outside the sorted region is picked
    up and its appropriate place is searched for in the sorted region (so that even
    after the insertion of this element, the region remains sorted) and the element
    is inserted there, hence the name insertion sort.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a function for insertion sort called `InsertionSort`, which we
    will invoke as follows, where `arr` is the array to be sorted and consists of
    `n` number of elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps that are followed in the `InsertionSort` method:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a variable, say `i`, to `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 2 to 5 `n-1` times, that is, while `i >= n-1`. The value of `i`
    is incremented by 1 after every iteration, `i=1,2,3 .... n-1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize a variable, `j`, to the value of `i`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the following step 5  for `j=i` to `j >=0`. The value of `j` is decremented
    by 1 after every iteration, that is, `j=i, i-1, i-2, ....0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `arr[j] <arr[j-1]`, then interchange the values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for sorting the elements of an integer array using the insertion
    sort technique is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume that the numbers that we need to sort are not greater than 20;
    so we will define a macro of size `20`. You can always assign any value to this
    macro. Next, we will define an integer array, `arr`, of size `max`. You will be
    prompted to enter how many numbers you wanted to sort. Let''s say we want to sort
    eight values; so the value `8` entered by us will be assigned to a variable, `len`.
    Thereafter, you will be asked to enter the eight values that need to be sorted.
    So, let''s say we entered the following values, which were assigned to the `arr` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a86bec8f-48b0-479d-96f1-05df34a7301c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15
  prefs: []
  type: TYPE_NORMAL
- en: 'In this sorting method, we will take the help of a nested loop, where the outer
    loop, `i`, runs from 1 to 7 and the inner loop, `j`, runs from the value beginning
    from `i` to its value is more than 0\. So, in the first iteration of the nested
    loop, the inner loop will execute only once where the value of i will be 1\. The
    value at the `arr[1]` index location is compared with that at `arr[0]`. The tendency
    is to keep the lower value at the top, so if the value at `arr[1]` is greater
    than that at `arr[0]`, the place of the two values will be interchanged. Because
    15 is greater than 9 (on the left side of *Figure 9.16*), the values in the two
    index locations will be interchanged (on the right side of *Figure 9.16*) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5191979-73c5-4453-9559-f762fec22845.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16
  prefs: []
  type: TYPE_NORMAL
- en: 'After the first iteration, the value of `i` will be incremented to 2 and the
    inner loop, `j`, will run from the value of 2 to 1, that is, the inner loop will
    execute twice: once with the value of `j` equal to 2 and then when the value of
    `j` is decremented to 1\. Within the inner loop, the value at `arr[2]` will be
    compared with that at `arr[1]`. In addition, the value at `arr[1]` will be compared
    with that at `arr[0]`. If `arr[2] < arr[1]`, then interchanging of the values
    will take place. Similarly, if `arr[1] < arr[0]`, interchanging of their values
    will take place.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The value at `arr[2]` that is 10 is less than the value at `arr[1]`, that is,
    15; so these values will interchange places (see *Figure 9.17*). After interchanging
    the values, we find that the value at `arr[1]` is greater than the value at `arr[0]`.
    So, no interchanging will take place now. *Figure 9.17* shows the procedure of
    the second iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e70e5208-1fa6-4987-a754-2bfddf215e47.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17
  prefs: []
  type: TYPE_NORMAL
- en: 'After the second iteration, the value of `i` will be incremented to 3 and the
    value of `j` will run from the values of 3 to 1\. Hence, the interchanging of
    values will take place if the following conditions are met:'
  prefs: []
  type: TYPE_NORMAL
- en: If `arr[3] < arr[2]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `arr[2] < arr[1]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `arr[1] < arr[0]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see in *Figure 9.18(a)* that `arr[3]`, that is, 5, is smaller than
    `arr[2]`, that is, 15, so their values will be interchanged. Similarly, the values
    at `arr[2]` and `arr[1]`, and then `arr[1]` and `arr[0]`, will also be interchanged
    (see *Figure 9.18(b)* and *(c)*, respectively). *Figure 9.18(d)* shows the array
    after all the interchanges have been performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2aa3af3-9f83-454d-9b44-53603ff62a2b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18
  prefs: []
  type: TYPE_NORMAL
- en: 'After the third iteration, the value of `i` will be incremented to 4 and the
    value of `j` will run from the values of 4 to 1\. So interchanging of values will
    take place if the following conditions are met:'
  prefs: []
  type: TYPE_NORMAL
- en: If `arr[4] < arr[3]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `arr[3] < arr[2]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `arr[2] < arr[1]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `arr[1] < arr[0]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see in *Figure 9.19* that the main tendency of all these comparisons
    is to bring the lower values above the larger values in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c103079-3748-40b2-9037-2aa67993adae.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19
  prefs: []
  type: TYPE_NORMAL
- en: The same procedure will be followed for the rest of the elements in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Because no error appears on compilation, that means the `insertionsort.c` program has
    successfully been compiled into the `insertionsort.exe` file. On execution, it
    will ask you to specify how many numbers have to be sorted. Following this, the
    program will prompt us to enter the numbers to be sorted. After entering the numbers,
    they will appear sorted in ascending order, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69789e87-788c-480c-968b-70fa81397958.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.20
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We've successfully used insertion sort to arrange numbers in ascending
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Arranging numbers in ascending order using quick sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quick sort is a divide-and-conquer algorithm. It divides an array on the basis
    of a pivot, where the pivot is an element in the array, in order that all the
    elements smaller than the pivot are placed before the pivot and all the larger
    ones are placed after it.
  prefs: []
  type: TYPE_NORMAL
- en: So, at the location of the pivot, the array is divided into two subarrays. The
    process of finding the pivot is repeated on both the arrays. The two arrays are
    further subdivided on the basis of the pivot.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, quick sort is a recursive procedure and the procedure of dividing the
    arrays into subarrays continues recursively until the subarray has only one element.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The quick sort process comprises the following important tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the pivot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting the array at the location of the pivot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be using two methods: `QuickSort` and `FindingPivot`.
  prefs: []
  type: TYPE_NORMAL
- en: Quick sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This method takes an array or subarray into consideration. It invokes the method
    to find the pivot of the array or subarray and splits the array or subarray on
    the basis of the pivot. Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, `arr` is the array consisting of `n` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we use this method:'
  prefs: []
  type: TYPE_NORMAL
- en: Let `l=1` and `u=n`, where `l` and `u` represent the lower and upper index location,
    respectively, of the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push `l` into `stack1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push `u` into `stack2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While `stack1` or `stack2` is not empty, repeat steps 5 through 10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pop the lower index location of the array from `stack1` into variable `s`, that
    is, `s` becomes the lower index location of the array to be sorted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pop the upper index location from `stack2` into the variable `e`, that is, the
    `e` variable will get the upper index location of the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find out the pivot by invoking the `FindingPivot` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Recall that a pivot point is an index location in the array where the elements
    smaller than the pivot are before it and elements larger than the pivot are after
    it. The array is split at the pivot point and the quick sort method is recursively
    applied on the two halves individually.
  prefs: []
  type: TYPE_NORMAL
- en: Once the pivot is known, divide the array into two halves. One array will have
    values from `s` (the lower index location) to `pivot-1`, and another array with
    the elements ranges from `pivot+1` to `e` (the upper index location).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the first half of the array, push `s` into `stack1` and `pivot-1` into `stack2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the second half of the array, push `pivot+1` into `stack1` and `e` into
    `stack2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FindingPivot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This method finds the pivot of the array or subarray. Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, `arr` represents the array of `n` elements, `start` represents the starting
    index location of the array, and `end` represents the ending index location of
    the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we use this method:'
  prefs: []
  type: TYPE_NORMAL
- en: Repeat *steps 2* through *8* of the `QuickSort` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the value of the `start` variable in another variable, say, `lower`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start from the right index location and move to the left. Initially, the first
    element is the pivot. The tendency is to keep the elements larger than the pivot
    on the right-hand side of the pivot and the elements smaller than the pivot on
    the left-hand side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `lower=end`, that means, we found the pivot. The pivot is equal to the value
    of lower. Return `lower` as the location of the pivot element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `arr[lower] > arr[end]`, then interchange the values' places. Now, move from
    left to right comparing each value with the pivot, and move up until we get the
    value lower than the value of pivot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While `arr[start] <= arr[lower]` and `lower != start`, repeat:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If `lower=start` then pivot is lower. Return `lower` as the location of the
    pivot element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `arr[start] > arr[lower]`, then interchange the values' places.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for sorting elements of an integer array using the quick sort technique
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be asked to specify how many numbers you require to be sorted. Suppose
    we want to sort 8 numbers; the value 8 entered by the user will be assigned to
    the `len` variable. A `for` loop is executed enabling us to enter the number to
    be sorted. The values we enter will be assigned to the `arr` array as shown in
    *Figure 9.21*.
  prefs: []
  type: TYPE_NORMAL
- en: Two variables, `lindex` and `uindex`, are initialized to represent the desired
    first and last index of the array, that is 0 and 7, respectively. The `lindex`
    and `uindex` locations are supposed to keep the smallest and largest values in
    the array. The values of `lindex` and `uindex`, that is, 0 and 7, will be pushed
    to the stack. In the `pushstk1` function, the value of the top index, whose default
    value is -1, is incremented to 0 and the value of `lindex` is assigned to the `stack1`
    array at the `[0]` index location. Similarly, in the  `pushstk2` function, the
    value of the `top2` index is also incremented to 0, and the value of `uindex`
    is assigned to the `stack2` array at the `[0]` location.
  prefs: []
  type: TYPE_NORMAL
- en: A while loop is set to execute for as long as the value of `top1` is not equal
    to 1\. That means, until `stack1` is empty, the program will keep executing. Within
    the while loop, the values pushed in `stack1` and `stack2` are popped and assigned
    to the two variables of `sindex` and `eindex`, respectively. These variables represent
    the starting and ending index locations of the array or the part of the array
    that we want to sort using `quick sort`.
  prefs: []
  type: TYPE_NORMAL
- en: '`stack1` and `stack2` contain the values of 0 and 7, respectively, which are
    popped and assigned to `sindex` and `eindex`, respectively. The quick function
    is invoked and the values in `sindex` and `eindex` are passed to an argument.
    In the quick functions, the values of `sindex` and `eindex` arguments are assigned
    to the two parameters of `si` and `ei`, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the quick function, the value of `si`, that is 0, is assigned to another
    variable, `li`. A while loop is executed in an infinite loop. Within the while
    loop, another while loop is set to execute that will make `ei` move toward the
    left, that is, it will make the value of `ei` decrement until the element at the `arr[ei]` location
    is greater than the `arr[li]` location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e627ced9-1f08-4264-853c-2d5b850186ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.21
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `arr[ei] < arr[si]`, interchanging of their values will take place
    (see *Figure 9.22(a)*). After interchanging the values at `arr[ei]` and `arr[si]`,
    the `arr` array will appear as shown in *Figure 9.22(b)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1088c771-3bba-4f76-aea6-20574c843f42.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.22
  prefs: []
  type: TYPE_NORMAL
- en: 'After interchanging of values, the index location number of `ei`, that is 7,
    will be assigned to `li`. Another while loop is set to execute while `arr[si]`
    is smaller than `arr[li]`, where `li` represents the `ei` index currently; and
    within the `while` loop, the location of the `si` index pointer is incremented. 
    That is, the `si` index pointer is moved right to `arr[si] < arr[li]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89babd95-8687-4e6c-a655-51b466712c3a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.23
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the following things will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: Because `arr[si] < arr[ei]` (that is, 4 < 6), `si` will move right by one location
    to `arr[1]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because `arr[si] < arr[ei]` (that is, now 3 < 6), `si` will again move right
    by one location to `arr[2]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because `arr[si] < arr[ei]` (that is, now 0 < 6), `si` will again move right
    by one location to `arr[3]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because `arr[si]  < arr[ei]` (that is, now 2 < 6), `si` will again move right
    by one location to `arr[``4]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because `arr[si]  > arr[ei]` (that is, now 7 > 6), interchanging of their values
    will take place (see *Figure 9.24*):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/e80eeb8c-8814-4b76-a4b2-7d9eb2db7bd4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.24
  prefs: []
  type: TYPE_NORMAL
- en: 'After interchanging of values at `arr[ei]` and `arr[si]`, the location number
    of `arr[si]`, that is, 4, will be assigned to `li`. The process is repeated; that
    is, again a while loop is set to execute while `arr[ei] > arr[si]`. Within the
    while loop, the location of `ei` is decremented, or it moves to the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d9f4606-4863-48dd-a7fa-f6c6df23254a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.25
  prefs: []
  type: TYPE_NORMAL
- en: While comparing `arr[ei]` and `arr[si]`, we will find that `arr[ei] > arr[si]`
    (7 > 6), so `ei` will be decremented to value 6 (see *Figure 9.26(a)*). Again,
    because `arr[ei] < arr[si]` (1 < 6), interchanging of values of these index locations
    will take place (see *Figure 9.26(b)*). The location number of `ei`, 6 now, will
    be assigned to variable `li`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another while loop is set to execute while `arr[si] < arr[ei]` (remember the
    location number of ei is assigned to li). The following things will happen in
    this while loop:'
  prefs: []
  type: TYPE_NORMAL
- en: Because `arr[si] < arr[ei]` (that is, 1 < 6), `si` will move right to `arr[5]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because still `arr[si] < arr[ei]` (that is, 5 < 6), `si` will move right to
    `arr[6]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because now the location of `ei` and `si` are the same, the quick function will
    terminate returning the number 6 to the `main` function (see *Figure 9.26(c)*).
    So, the number 6 will become the pivot of the `arr` array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/7e20269a-2da5-4c6a-bc04-00f9ec8a9f96.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.26
  prefs: []
  type: TYPE_NORMAL
- en: 'Two `if` statements are executed and the array is split into two parts: the
    first part ranges from `arr[0]` to `arr[5]` and the other part from `arr[7]` to
    `arr[7]`, that is, of a single element. The first and last index values of the
    two parts of the array are pushed to the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: The first and last index locations of the second part of the array, that is,
    7, will be pushed to both `stack1` and `stack2`. The first and last index locations
    of the first part of array, that is, 0 and 5, will also be pushed to `stack1`
    and `stack2`, respectively (see *Figure 9.27*).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8953bcd-c548-4235-8612-40cee58289f8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.27
  prefs: []
  type: TYPE_NORMAL
- en: The complete quick sort technique is applied on both halves of the array. Again,
    the two halves will be partitioned into two more parts and again the quick sort
    technique is applied on those two parts, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The outer while loop repeats and the `popstk1()` and `popstk2()` functions will
    be invoked to pop off the values in the `stack1` and `stack2` arrays. The values
    of the `top1` and `top2` indices are 1, so the values at the `stack1[1]` and `stack2[1]`
    index locations are picked up and assigned to the two variables, `sindex` and
    `eindex`, respectively. Again, the `quick()` function is invoked and the two variables,
    `sindex` and `eindex`, are passed to it. In the quick function, the values of
    the `sindex` and `eindex` arguments are assigned to the `si` and `ei` parameters
    respectively
  prefs: []
  type: TYPE_NORMAL
- en: Within the `quick()` function, the value of the `si` variable, that is, 0, is
    assigned to another variable, `li`. A while loop is executed in an infinite loop.
    Within the while loop, another while loop is set to execute that will make the
    `ei` index location to move toward the left, that is, it will make the value of
    the `ei` index variable decrement for the time the element at the `arr[ei]` location
    is greater than the `arr[si]` location (see *Figure 9.28(a)*). Because `arr[ei]
    > arr[si]`, the value of the `ei` variable will be decremented to 4 (see *Figure
    9.28(b)*). Now, we find that `arr[ei]`, that is, 1 is less than `arr[si]`, that
    is, 4, so interchanging of their values will take place. After interchanging the
    values at that `arr[ei]` and `arr[si]` index locations, the `arr` array will appear
    as shown in *Figure 9.28(c)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'After interchanging the values, the value of the `ei` variable is assigned
    to the `li` variable, that is, 4, is assigned to the `li` variable. Another while
    loop is set to execute while the `arr[si]` element is smaller than `arr[li]`,
    where `li` represents the `si` index currently; and within the while loop, the
    value of the `si` index pointer is incremented. The following things will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: Because `arr[si]`, that is, 1, is less than `arr[ei]`, that is, 4, `si` will
    be incremented to a value of 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because `arr[si]`, that is, 3, is less than `arr[ei]`, that is, 4, `si` will
    be incremented to a value of 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because `arr[si]`, that is, 0, is less than `arr[ei]`, that is, 4, `si` will
    be incremented to a value of 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because `arr[si]`, that is, 2, is less than `arr[ei]`, that is, 6, `si` will
    be incremented to a value of 4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because the values of the `ei` and `si` variables have become the same, the
    `quick()` function will terminate, returning the value `4` to the `main` function
    (see *Figure 9.28(d )*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/072b772e-ffa9-4f1b-9f87-5dfc45027f75.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.28
  prefs: []
  type: TYPE_NORMAL
- en: 'On returning to the `main` function, two `if` statements are executed and the
    array is split into two parts: the first part ranges from the `arr[0]` to the
    `arr[3]` index locations, and the other part will range from the `arr[5]` to the `arr[5]`
    index locations, that is, of a single element. The starting and ending index values
    of the two parts of the array are pushed to the stack. The starting and ending
    index locations of the second part of the array (that is, 5 and 5) will be pushed
    to `stack1` and `stack2`, respectively. Similarly, the starting and ending index
    locations of the first part of the array (that is, 0 and 3) are pushed to `stack1`
    and `stack2`, respectively (see *Figure 9.29*).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b09305c2-b399-4692-b702-80b1576dd369.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.29
  prefs: []
  type: TYPE_NORMAL
- en: The whole quick sort technique is applied on all the partitions of the array
    until the stacks are empty. That is, the outer while loop repeats and the `popstk1()`
    and `popstk2()` functions will be invoked to pop off the values in the `stack1`
    and `stack2` arrays. Again, the `quick()` function is invoked and the two variables, `sindex`
    and `eindex`, that are popped from the stack are passed to it. The procedure continues
    until the whole array is sorted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC using the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Because no error appears on compilation, that means the `quick sort.c` program has
    successfully been compiled into the `quick sort.exe` file. On executing the file,
    it will ask you to specify how many numbers there are to be sorted. Following
    this, the program will prompt you to enter the numbers to be sorted. After entering
    the numbers, they will appear sorted in ascending order, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9792887-0876-48b9-8964-6d652097e9e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.30
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We have successfully arranged the numbers in our array using quick sort.
    Now let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Arranging numbers in descending order using heap sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn to arrange some integers in descending order using
    the heap sort technique.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The heap sort method is divided into the following two tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a max-heap
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deleting the max-heap
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start with creating a max-heap.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a max-heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps are followed for creating a max-heap:'
  prefs: []
  type: TYPE_NORMAL
- en: The user is asked to enter a number. The number is used to create a heap. The
    number entered by the user is assigned to an array heap at index location `x`,
    where `x` begins with a value of 0 and increments after every insertion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The newly inserted number is compared with the element of its parent node.
    Because we are making use of a max-heap, we need to maintain a rule: the value
    of the parent node should be always larger than its child node. The location of
    the parent node is computed using the formula `parent=(x-1)/2`, where `x` represents
    the index location where the new node is inserted.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if the value of the new node is greater than the value of its parent.
    Interchange the values of `heap[parent]` and `heap[x]` with the help of an extra
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recursively check the value of the parent of the parent node to see whether
    the property of the max-heap is maintained or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the heap is made, the second task of deleting the max-heap will begin.
    Every time a node is deleted from a max-heap, the deleted node is kept in another
    array, say `arr`, that will contain the sorted elements. The task of deleting
    the max-heap is repeated as many times as the number of elements present in the
    max-heap.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting the max-heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Three variables, `leftchild`, `rightchild`, and `root`, are initialized as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following steps are performed to delete a max-heap:'
  prefs: []
  type: TYPE_NORMAL
- en: The element at the root node is temporarily assigned to the `n` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last element of the heap is placed at the root node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the value of the last index location is 1 or 2, that is, if the heap has
    only  1 or 2 elements left, then return to the caller with the `n` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the last element is placed at the root node, reduce the size of the heap
    by 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To maintain the max-heap property, repeat *steps 6* through *9* while `rightchild
    <=last`. Recall, the property of the max-heap is that the value of the parent
    node should be always larger than its children node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the `leftchild` and `rightchild` locations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `heap[root] > heap[leftchild] && heap[root] > heap[rightchild]`, return `n`
    and exit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the value of the left child is greater than the value of the right child,
    then interchange the value of the root and that of the left child. The root will
    come down at the left child to check whether the max-heap property is maintained
    or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the value of the right child is greater than the value of the left child,
    then interchange the value of the root and that of the right child. The root will
    come down at the right child to check whether the max-heap property is maintained
    or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When all the elements of the max-heap are over, that means the `arr` array will
    have all the sorted elements. So, the final step is to print the `arr` array, which
    contains the sorted elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for sorting elements of an integer array using the heap sort technique
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A heap is a complete binary tree that can be either a max-heap or a min-heap.
    The max-heap has the property that the key value of any node must be greater than
    or equal to the key values of its children. In the min-heap, the key value of
    any node must be lower than or equal to the values of its children.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn to create a max-heap of the following list of
    integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 5 | 2 | 9 | 3 | 1 | 4 | 6 |'
  prefs: []
  type: TYPE_TB
- en: 'In this heap sort method, the binary tree is constructed in the form of an
    array. In heap sort, the values in the array are added one by one, keeping the
    max-heap property true (that is, the key value of any node should be larger than
    or equal to its children). While adding the elements of the array, we keep track
    of the key value of the parent node with `(x-1)/2`, where `x` is the element whose
    parent is to be found. If the element inserted in the heap is larger than the
    key value of its parent, then interchanging takes place. For example, suppose
    the first key value entered is `5` (it is considered as the root); it is stored
    as the first element of the array, that is, `heap[0]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69ee9c11-e051-4096-90a4-99d3e54ec928.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.31
  prefs: []
  type: TYPE_NORMAL
- en: 'Then 2 is added to it as a left child. The first child will always be added
    to the left. When another value is entered, it is entered at the location of `heap[1]`.
    After insertion, its parent node location is computed with `(x-1)/2`, where `x`
    is 1\. So, the parent comes out to be location 0\. So, `heap[1]` is compared with
    its parent element, `heap[0]`. If the key element of the parent element, `heap[0]`,
    is larger than `heap[1]`, then we move further; else, we interchange their key
    values. In our example, the second element is 2, so no interchanging is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc9cd259-968f-459e-a7fd-f08fd05312d1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.32
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we move to enter the third element. The third element is 9, and it is
    added as a right child of node 5 (see *Figure 9.33 (a)*). In the array, it is
    stored at the location of `heap[2]`. Again, its parent element location is computed
    by `(x-1)/2`, which again comes out to be 0\. In keeping the property of max-heap
    (that the value of the parent node should be larger than or equal to its children),
    we compare the key values of the `heap[0]` and `heap[2]` elements. Because `heap[0]`
    is less than `heap[2]`, it is violating the max-heap property. Thus, the key values
    of `heap[0]` and `heap[2]` will be interchanged, as shown in *Figure 9.33(b)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e51762b-43ab-457f-96d9-d548cc542d72.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.33
  prefs: []
  type: TYPE_NORMAL
- en: 'Then 3 is added as a left child of node 2, as shown in *Figure 9.34(a)*. In
    the array, the new value is inserted at the index location of `heap[3]`. Again,
    its parent element location is computed using the formula `(x-1)/2`, where `x`
    represents the index location where new value is inserted, that is, 3\. The parent
    element location is computed as 1\. In keeping with the property of max-heap,
    `heap[1]` must be larger than or equal to `heap[3]`.  But because `heap[1]` is
    less than `heap[3]`, it is violating the max-heap property. Thus, the key values
    of `heap[1]` and `heap[3]` will be interchanged, as shown in *Figure 9.34(b)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c166c522-7cb4-4d22-97d8-e891bf871a2b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.34
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, 1 is added as the right child of node 3\. In the array, the new value
    is inserted at the index location of `heap[4]`. Because the property of max-heap
    is still maintained, no interchanging is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a0b1159-5f92-4079-9fc8-6c1c3c1437d3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.35
  prefs: []
  type: TYPE_NORMAL
- en: 'The next value is 4, which is added as the left child of node 5\. In the array,
    the new value is inserted at the index location of `heap[5]`. Again, the property
    of max-heap is maintained, so no interchanging is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6a6fcc9-92d7-4aa1-a716-8ee75eca2a48.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.36
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, 6 is added as the right child of node 5 (see *Figure 9.37 (a)*). In the
    array, it is inserted at the index location of `heap[6]`. Again, its parent element
    location is computed using the formula `(x-1)/2`. The parent element location
    is computed as 2\. In keeping with the property of max-heap, `heap[2]` must be
    larger than or equal to `heap[6]`. But because `heap[2]` is less than `heap[6]`,
    it is violating the max-heap property; so the key values of `heap[2]` and `heap[6]`
    will be interchanged, as shown in *Figure 9.37(b)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7bf8345c-b7ea-4eea-8af7-e25f26064948.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.37
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the max-heap is made, we perform heap sort by repeating the following
    three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing its root element (and storing it in the sorted array)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replacing the root element of the tree (array) by the last node value and removing
    the last node (decrementing the size of the array)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reshuffling the key values to maintain the heap property
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following *Figure 9.38(a)*, you can see that the root element, that
    is, 9, is deleted and is stored in another array called `arr`. The `arr` array
    will contain the sorted elements. The root element is replaced by the last element
    of the tree. The last element of the tree is 5, so it is removed from the `heap[6]`
    index location and is assigned to the root, that is, at `heap[0]`. Now, the property
    of heap is no longer true. So, the values of node elements  5  and 6 are interchanged (see
    *Figure 9.38(b)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15867e24-2047-4b90-9f90-bf75253904b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.38
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the process is repeated again, removing the key element of the root node
    and replacing its value with the last node and reshuffling the heap. That is,
    the root node element 6 is removed and is assigned to the sorted array, `arr`.
    And the root node is replaced by the last element of the tree that is by 4 (see
    *Figure 9.39(a)*). By putting the value 4 at the root, the property of heap is
    no longer true. So  to maintain the property of heap, the value 4 is brought down
    that is the values of node elements 4 and 5 are interchanged, as shown in *Figure
    9.39(b)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff7795a5-45d4-45b6-b804-87b70c96c25c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.39
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are repeated to get the array sorted in descending order, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a503124-9549-4214-b3da-66f621191962.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.40
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC using the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Because no error appears on compilation, this means the `heapsort.c` program has
    successfully been compiled into the `heapsort.exe` file. On executing the file,
    it will ask us to specify how many numbers there are to be sorted. Following this,
    the program will prompt us to enter the numbers to be sorted. After entering the
    numbers, they will appear sorted in descending order, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/629e44a5-848b-4668-882e-d5763c804ee4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.41
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We have successfully arranged numbers in descending order using heap
    sort.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn more sorting methods like selection, merge, shell and radix sort visit
    *Appendix A* found on this link: [https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20A.pdf](https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20A.pdf).
  prefs: []
  type: TYPE_NORMAL
