<html><head></head><body>
		<div id="_idContainer014">
			<h1 id="_idParaDest-67"><em class="italic"><a id="_idTextAnchor067"/>Chapter 5</em>: Exploring Clang's Architecture</h1>
			<p><strong class="bold">Clang</strong> is LLVM's official frontend for <strong class="bold">C-family</strong> programming languages, including C, C++, and Objective-C. It processes the input source code (parsing, type checking, and semantic reasoning, to name a few) and generates equivalent LLVM IR code, which is then taken over by other LLVM subsystems to perform optimization and native code generation. Many <em class="italic">C-like</em> dialects or language extensions also find Clang easy to host their implementations. For example, Clang provides official support for OpenCL, OpenMP, and CUDA C/C++. In addition to normal frontend jobs, Clang has been evolving to partition its functionalities into libraries and modules so that developers can use them to create all kinds of tools related to <strong class="bold">source code processing</strong>; for example, code refactoring, code formatting, and syntax highlighting. Learning Clang development can not only bring you more engagement into the LLVM project but also open up a wide range of possibilities for creating powerful applications and tools.</p>
			<p>Unlike LLVM, which arranges most of its tasks into a single pipeline (that is, <strong class="bold">PassManager</strong>) and runs them sequentially, there is more diversity in how Clang organizes its subcomponents. In this chapter, we will show you a clear picture of how Clang's important subsystems are organized, what their roles are, and which part of the code base you should be looking for. </p>
			<p class="callout-heading">Terminology</p>
			<p class="callout">From this chapter through to the rest of this book, we will be using Clang (which starts with an uppercase C and a Minion Pro font face) to refer to the <em class="italic">project</em> and its <em class="italic">techniques</em> as a whole. Whenever we use <strong class="source-inline">clang</strong> (all in lowercase with a Courier font face), we are referring to the <em class="italic">executable program</em>.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li>Learning Clang's subsystems and their roles</li>
				<li>Exploring Clang's tooling features and extension options</li>
			</ul>
			<p>By the end of this chapter, you will have a roadmap of this system so that you can kickstart your own projects and have some gravity for later chapters related to Clang development.</p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor068"/>Technical requirements</h1>
			<p>In <a href="B14590_01_Final_JC_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Saving Resources When Building LLVM</em>, we showed you how to build LLVM. Those instructions, however, did not build Clang. To include Clang in the build list, please edit the value that's been assigned to the <strong class="source-inline">LLVM_ENABLE_PROJECTS</strong> CMake variable, like so:</p>
			<p class="source-code">$ cmake -G Ninja <strong class="bold">-DLLVM_ENABLE_PROJECTS="clang;clang-tools-extra"</strong> …</p>
			<p>The value of that variable should be a semi-colon-separated list, where each item is one of LLVM's subprojects. In this case, we're including Clang and <strong class="source-inline">clang-tools-extra</strong>, which contains a bunch of useful tools based on Clang's techniques. For example, the <strong class="source-inline">clang-format</strong> tool is used by countless open source projects, especially large-scale ones, to impose a unified coding style in their code base.</p>
			<p class="callout-heading">Adding Clang to an existing build</p>
			<p class="callout">If you already have an LLVM build where Clang was not enabled, you can edit the <strong class="source-inline">LLVM_ENABLE_PROJECTS</strong> CMake argument's value in <strong class="source-inline">CMakeCache.txt</strong> without invoking the original CMake command again. CMake should reconfigure itself once you've edited the file and run Ninja (or a build system of your choice) again.</p>
			<p>You can build <strong class="source-inline">clang</strong>, Clang's driver, and the main program using the following command:</p>
			<p class="source-code">$ ninja clang</p>
			<p>You can run all the Clang tests using the following command:</p>
			<p class="source-code">$ ninja check-clang</p>
			<p>Now, you should have the <strong class="source-inline">clang</strong> executable in the <strong class="source-inline">/&lt;your build directory&gt;/bin</strong> folder.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor069"/>Learning Clang's subsystems and their roles</h1>
			<p>In this section, we will give you an overview of Clang's structures and organizations. We will briefly introduce some of the <a id="_idIndexMarker151"/>important components or subsystems, before using dedicated sections or chapters to expand them further in later parts of this book. We hope this will give you some idea of Clang's internals and how they will benefit your development.</p>
			<p>First, let's look at the <a id="_idIndexMarker152"/>big picture. The following diagram shows the high-level structure of Clang:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/Figure_5.1_B14590.jpg" alt="Figure 5.1 – High-level structure of Clang&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – High-level structure of Clang</p>
			<p>As explained in the legend, rectangles with rounded corners represent subsystems that might consist of multiple components with similar functionalities. For example, the <strong class="bold">frontend</strong> can be further dissected into components such as the preprocessor, parser, and code generation logic, to name a few. In addition, there are intermediate results, depicted as ovals in the preceding diagram. We are <a id="_idIndexMarker153"/>especially interested in <a id="_idIndexMarker154"/>two of them – <strong class="bold">Clang AST</strong> and <strong class="bold">LLVM IR</strong>. The former will be discussed in depth in <a href="B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 7</em></a>, <em class="italic">Handling AST</em>, while the latter is the main character of <em class="italic">Part 3</em>, <em class="italic">Middle-End Development</em>, which will talk about optimizations and analyses you can apply to LLVM IR.</p>
			<p>Let's start by looking at an <a id="_idIndexMarker155"/>overview of the driver. The following subsections will give you a brief introduction to each of these driver components.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor070"/>Driver</h2>
			<p>A common misunderstanding is that <strong class="source-inline">clang</strong>, the <a id="_idIndexMarker156"/>executable, is the compiler frontend. While <strong class="source-inline">clang</strong> does use Clang's frontend components, the executable itself is actually a kind of <a id="_idIndexMarker157"/>program called a <strong class="bold">compiler driver</strong>, or <strong class="bold">driver</strong> for short. </p>
			<p>Compiling source code is a complex process. First, it consists of multiple phases, including the following:</p>
			<ul>
				<li><strong class="bold">Frontend</strong>: Parsing and semantic checking</li>
				<li><strong class="bold">Middle-end</strong>: Program analysis and optimization</li>
				<li><strong class="bold">Backend</strong>: Native code generation</li>
				<li><strong class="bold">Assembling</strong>: Running the assembler</li>
				<li><strong class="bold">Linking</strong>: Running the linker </li>
			</ul>
			<p>Among these phases and their enclosing components, there are countless options/arguments and flags, such as the option to tell compilers where to search for include files (that is, the <strong class="source-inline">-I</strong> command-line option in GCC and Clang). Furthermore, we hope that the compiler can figure out the values for some of these options. For example, it would be great if the compiler could include some folders of C/C++ standard libraries (for example, <strong class="source-inline">/include</strong> and <strong class="source-inline">/usr/include</strong> in Linux systems) in the header file search paths <em class="italic">by default</em>, so that we don't need to assign each of those folders manually in the command line. Continuing with this example, it's clear that we want our compilers to be <strong class="bold">portable</strong> across different operating systems and platforms, but many operating systems use a different C/C++ standard library path. So, how do compilers pick the correct one accordingly?</p>
			<p>In this situation, a driver is designed to come to the rescue. It's a piece of software that acts as a housekeeper for core compiler components, serving them essential information (for example, a OS-specific system include path, as we mentioned earlier) and arranging their executions so that users only need to supply important command-line arguments. A good way to observe the hard work of a driver is to use the <strong class="source-inline">-###</strong> command-line flag on a normal <strong class="source-inline">clang</strong> invocation. For example, you could try to compile a simple hello world program with that flag:</p>
			<p class="source-code">$ clang++ <strong class="bold">-###</strong> -std=c++11 -Wall ./hello_world.cpp -o hello_world</p>
			<p>The following is <a id="_idIndexMarker158"/>part of the <a id="_idIndexMarker159"/>output after running the preceding command on a macOS computer:</p>
			<p class="source-code">"/path/to/clang" "-cc1" "-triple" "x86_64-apple-macosx11.0.0" "-Wdeprecated-objc-isa-usage" "-Werror=deprecated-objc-isa-usage" "-Werror=implicit-function-declaration" "-emit-obj" "-mrelax-all" "-disable-free" "-disable-llvm-verifier" … "-fno-strict-return" "-masm-verbose" "-munwind-tables" "-target-sdk-version=11.0" … "-resource-dir" "/Library/Developer/CommandLineTools/usr/lib/clang/12.0.0" "-isysroot" "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk" "-I/usr/local/include" "-stdlib=libc++" … "-Wall" "-Wno-reorder-init-list" "-Wno-implicit-int-float-conversion" "-Wno-c99-designator" … "-std=c++11" "-fdeprecated-macro" "-fdebug-compilation-dir" "/Users/Rem" "-ferror-limit" "19" "-fmessage-length" "87" "-stack-protector" "1" "-fstack-check" "-mdarwin-stkchk-strong-link" … "-fexceptions" … "-fdiagnostics-show-option" "-fcolor-diagnostics" "-o" "/path/to/temp/hello_world-dEadBeEf.o" "-x" "c++" "hello_world.cpp"…</p>
			<p>These are essentially the flags being passed to the <em class="italic">real</em> Clang frontend after the driver's <em class="italic">translation</em>. While you don't need to understand all these flags, it's true that even for a simple program, the compilation flow consists of an enormous amount of compiler options and many subcomponents. </p>
			<p>The source code for the driver can be found under <strong class="source-inline">clang/lib/Driver</strong>. In <a href="B14590_08_Final_JC_ePub.xhtml#_idTextAnchor108"><em class="italic">Chapter 8</em></a>, <em class="italic">Working with Compiler Flags and Toolchains</em>, we will look at this in more detail.</p>
			<p>Frontend</p>
			<p>A typical compiler textbook <a id="_idIndexMarker160"/>might tell you that a compiler frontend consists of a <strong class="bold">lexer</strong> and a <strong class="bold">parser</strong>, which generates an <strong class="bold">abstract syntax tree</strong> (<strong class="bold">AST</strong>). Clang's frontend also uses this skeleton, but with some major differences. First, the lexer is usually coupled with the <strong class="bold">preprocessor</strong>, and the semantic analysis that's performed on the source code is detached into a separate subsystem, called the <strong class="bold">Sema</strong>. This builds an AST and does all kinds of semantic checking.</p>
			<h3>Lexer and preprocessor</h3>
			<p>Due to the complexity of <a id="_idIndexMarker161"/>programming language standards and the <a id="_idIndexMarker162"/>scale of real-world source code, preprocessing becomes non-trivial. For example, resolving included files becomes tricky when you have 10+ layers of a <a id="_idIndexMarker163"/>header file hierarchy, which is common in large-scale projects. Advanced directives such as <strong class="source-inline">#pragma</strong> can be challenged in <a id="_idIndexMarker164"/>cases where OpenMP uses <strong class="source-inline">#pragma</strong> to parallelize for loops. Solving these challenges requires close cooperation between the preprocessor and the lexer, which provides primitives for all the preprocessing actions. Their source code can be found under <strong class="source-inline">clang/lib/Lex</strong>. In <a href="B14590_06_Final_JC_ePub.xhtml#_idTextAnchor078"><em class="italic">Chapter 6</em></a>, <em class="italic">Extending the Preprocessor</em>, you will become familiar with preprocessor and lexer development, and learn how to implement custom logic with a powerful extension system.</p>
			<h3>Parser and Sema</h3>
			<p>Clang's parser consumes token <a id="_idIndexMarker165"/>streams from the preprocessor and lexer and tries to realize their semantic structures. Here, the Sema sub-system <a id="_idIndexMarker166"/>performs more semantic checking and analysis from the parser's result before generating the AST. Historically, there was another layer of <a id="_idIndexMarker167"/>abstraction where you could create your own <em class="italic">parser action</em> callbacks to specify what actions you <a id="_idIndexMarker168"/>wanted to perform when certain language directives (for example, identifiers such as variable names) were parsed. </p>
			<p>Back then, Sema was one of these parser actions. However, later on, people found that this additional layer of abstraction was not necessary, so the parser only interacts with Sema nowadays. Nevertheless, Sema still retains this kind of callback-style design. For example, the <strong class="source-inline">clang::Sema::ActOnForStmt(…)</strong> function (defined in <strong class="source-inline">clang/lib/Sema/SemaStmt.cpp</strong>) will be invoked when a for loop structure is parsed. It will <a id="_idIndexMarker169"/>then do all kinds of <a id="_idIndexMarker170"/>checking to make sure the <a id="_idIndexMarker171"/>syntax is correct and generate the <a id="_idIndexMarker172"/>AST node for the for loop; that is, a <strong class="source-inline">ForStmt</strong> object.</p>
			<h3>AST </h3>
			<p>The AST is the most important <a id="_idIndexMarker173"/>primitive when it comes to extending Clang with your custom logic. All the common Clang extensions/plugins that we will introduce <a id="_idIndexMarker174"/>operate on an AST. To get a taste of AST, you can use the following command to print out the an AST from the source code:</p>
			<p class="source-code">$ clang <strong class="bold">-Xclang -ast-dump</strong> -fsyntax-only foo.c</p>
			<p>For example, on my computer, I have used the following simple code, which only contains one function:</p>
			<p class="source-code">int foo(int c) { return c + 1; }</p>
			<p>This will yield the following output:</p>
			<p class="source-code">TranslationUnitDecl 0x560f3929f5a8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt;</p>
			<p class="source-code">|…</p>
			<p class="source-code">`-FunctionDecl 0x560f392e1350 &lt;./test.c:2:1, col:30&gt; col:5 foo 'int (int)'</p>
			<p class="source-code">  |-ParmVarDecl 0x560f392e1280 &lt;col:9, col:13&gt; col:13 used c 'int'</p>
			<p class="source-code">  `-CompoundStmt 0x560f392e14c8 &lt;col:16, col:30&gt;</p>
			<p class="source-code">    `-ReturnStmt 0x560f392e14b8 &lt;col:17, col:28&gt;</p>
			<p class="source-code">      `-BinaryOperator 0x560f392e1498 &lt;col:24, col:28&gt; 'int' '+'</p>
			<p class="source-code">        |-ImplicitCastExpr 0x560f392e1480 &lt;col:24&gt; 'int' &lt;LValueToRValue&gt;</p>
			<p class="source-code">        | `-<strong class="bold">DeclRefExpr 0x560f392e1440 &lt;col:24&gt; 'int' lvalue ParmVar 0x560f392e1280 'c' 'int'</strong></p>
			<p class="source-code">        `-IntegerLiteral 0x560f392e1460 &lt;col:28&gt; 'int' 1</p>
			<p>This command is pretty useful <a id="_idIndexMarker175"/>because it tells you the C++ AST class that represents certain language directives, which is crucial for writing AST callbacks – the core of many Clang plugins. For example, from the <a id="_idIndexMarker176"/>previous lines, we can know that a variable reference site (<strong class="source-inline">c</strong> in the <strong class="source-inline">c + 1</strong> expression) is represented by the <strong class="source-inline">DeclRefExpr</strong> class.</p>
			<p>Similar to how the parser was organized, you can register different kinds of <strong class="source-inline">ASTConsumer</strong> instances to visit or manipulate the AST. <strong class="bold">CodeGen</strong>, which we will introduce shortly, is one of them. In <a href="B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 7</em></a>, <em class="italic">Handling AST</em>, we will show you how to implement custom AST processing logic using plugins.</p>
			<h3>CodeGen</h3>
			<p>Though there are no prescriptions for <a id="_idIndexMarker177"/>how you should process the AST (for example, if you use the <strong class="source-inline">-ast-dump</strong> command-line option shown previously, the <a id="_idIndexMarker178"/>frontend will print the textual AST representation), the most common task that's performed by the CodeGen subsystem is emitting the LLVM IR code, which will later be compiled into native assembly or object code by LLVM.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor071"/>LLVM, assemblers, and linkers</h2>
			<p>Once the LLVM IR code has been emitted by the CodeGen subsystem, it will be processed by the LLVM <a id="_idIndexMarker179"/>compilation pipeline to generate native code, either assembly code or object code. LLVM provides a <a id="_idIndexMarker180"/>framework called the <strong class="bold">MC layer</strong>, in which architectures can choose to implement assemblers that have been directly <a id="_idIndexMarker181"/>integrated into LLVM's pipeline. Major architectures such as x86 and ARM use this approach. If you don't do this, any textual assembly code that's emitted at the end of LLVM's pipeline needs to be <a id="_idIndexMarker182"/>processed by external assembler programs invoked by the driver. </p>
			<p>Despite the fact that LLVM already has its <a id="_idIndexMarker183"/>own linker, known as the <strong class="bold">LLD</strong> project, an <em class="italic">integrated</em> linker is still not a mature option yet. Therefore, external linker programs are always invoked by the driver to link the object files and generate the final binary artifacts.</p>
			<p class="callout-heading">External versus integrated</p>
			<p class="callout">Using external assemblers or linkers <a id="_idIndexMarker184"/>means invoking a <em class="italic">separate process</em> to run the program. For example, to run an external assembler, the frontend needs to put assembly code into a temporary file before launching the <a id="_idIndexMarker185"/>assembler with that file path as one of its command-line arguments. On the other hand, using integrated assemblers/linkers means the functionalities of assembling or linking are packaged into <em class="italic">libraries</em> rather than an executable. So, at the end of the compilation pipeline, LLVM will call APIs to process the assembly code's <em class="italic">in-memory</em> instances to emit object code. The advantage of this integrated approach is, of course, saving many indirections (writing into temporary files and reading them back right away). It also makes the code more concise to some extent.</p>
			<p>With that, you have been given an overview of a normal compilation flow, from the source code all the way to the <a id="_idIndexMarker186"/>native code. In the next section, we will go beyond the <strong class="source-inline">clang</strong> executable and provide an <a id="_idIndexMarker187"/>overview of the tooling and extension options provided by <a id="_idIndexMarker188"/>Clang. This not only augments the functionalities of <strong class="source-inline">clang</strong>, but also provides a way to use Clang's amazing techniques in out-of-tree projects.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor072"/>Exploring Clang's tooling features and extension options</h1>
			<p>The Clang project <a id="_idIndexMarker189"/>contains not just the <strong class="source-inline">clang</strong> executable. It also provides interfaces for developers to extend its tools, as well as to export its functionalities as libraries. In this <a id="_idIndexMarker190"/>section, we will give you an overview of all these options. Some of them will be covered in later chapters.</p>
			<p>There are currently three <a id="_idIndexMarker191"/>kinds of tooling and extension <a id="_idIndexMarker192"/>options available <a id="_idIndexMarker193"/>in Clang: <strong class="bold">Clang plugins</strong>, <strong class="bold">libTooling</strong>, and <strong class="bold">Clang Tools</strong>. To explain their differences and provide more background knowledge when we talk about Clang extensions, we need to start from an important data type first: the <strong class="source-inline">clang::FrontendAction</strong> class.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor073"/>The FrontendAction class</h2>
			<p>In the <em class="italic">Learning Clang's subsystems and their roles</em> section, we went through a variety of Clang's frontend components, such as the preprocessor and Sema, to name a few. Many of these important components are encapsulated by a single data type, called <strong class="source-inline">FrontendAction</strong>. A <strong class="source-inline">FrontendAction</strong> instance can be treated as a single task running inside the frontend. It <a id="_idIndexMarker194"/>provides a unified interface for the task to consume and interact with various resources, such as input source files and ASTs, which is <a id="_idIndexMarker195"/>similar to the role of an <strong class="bold">LLVM Pass</strong> from this perspective (an LLVM Pass provides a unified interface to process LLVM IR). However, there are some significant differences with an LLVM Pass:</p>
			<ul>
				<li>Not all of the frontend components are encapsulated into a <strong class="source-inline">FrontendAction</strong>, such as the parser and Sema. They are standalone components that generate materials (for example, the AST) for other FrontendActions to run.</li>
				<li>Except for a few scenarios (the Clang plugin is one of them), a Clang compilation instance rarely runs multiple FrontendActions. Normally, only one <strong class="source-inline">FrontendAction</strong> will be executed.</li>
			</ul>
			<p>Generally speaking, a <strong class="source-inline">FrontendAction</strong> describes the task to be done at one or two important places in the frontend. This explains why it's so important for tooling or extension development – we're basically building our logic into a <strong class="source-inline">FrontendAction</strong> (one of FrontendAction's derived classes, to be more precise) instance to control and customize the behavior of a normal Clang compilation.</p>
			<p>To give you a <a id="_idIndexMarker196"/>feel for the <strong class="source-inline">FrontendAction</strong> module, here are some of its important APIs:</p>
			<ul>
				<li><strong class="source-inline">FrontendAction::BeginSourceFileAction(…)/EndSourceFileAction(…)</strong>: These are callbacks that derived classes can override to perform actions right before processing a source file and once it has been processed, respectively.</li>
				<li><strong class="source-inline">FrontendAction::ExecuteAction(…)</strong>: This callback describes the main actions to do for this <strong class="source-inline">FrontendAction</strong>. Note that while no one stops you from overriding this method directly, many of FrontendAction's derived classes already provide simpler interfaces to describe some common tasks. For example, if you want to process an AST, you should inherit from <strong class="source-inline">ASTFrontendAction</strong> instead and leverage its infrastructures.</li>
				<li><strong class="source-inline">FrontendAction::CreateASTConsumer(…)</strong>: This is a factory function that's used to create an <strong class="source-inline">ASTConsumer</strong> instance, which is a group of callbacks that will be invoked by the frontend when it's traversing different parts of the AST (for example, a callback to be called when the frontend encounters a group of declarations). Note that <a id="_idIndexMarker197"/>while the majority of FrontendActions work after the AST has been generated, the AST might not be generated at all. This may happen if the user only wants to run the preprocessor, for example (such as to dump the preprocessed content using Clang's <strong class="source-inline">-E</strong> command-line option). Thus, you don't always need to implement this function in your custom <strong class="source-inline">FrontendAction</strong>.</li>
			</ul>
			<p>Again, normally, you won't derive your class directly from <strong class="source-inline">FrontendAction</strong>, but understanding FrontendAction's internal role in Clang and its interfaces can give you more material to work with when it comes to tooling or plugin development.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor074"/>Clang plugins</h2>
			<p>A Clang plugin allows you to <a id="_idIndexMarker198"/>dynamically register a new <strong class="source-inline">FrontendAction</strong> (more specifically, an <strong class="source-inline">ASTFrontendAction</strong>) that can process the AST either before or after, or even replace, the main action of <strong class="source-inline">clang</strong>. A real-world example can be found in the <strong class="bold">Chromium</strong> project, in which they use Clang plugins to impose some Chromium-specific rules and make sure their code base is free from any non-ideal syntax. For example, one of the tasks is checking if the <strong class="source-inline">virtual</strong> keyword has been placed on methods that should be virtual.</p>
			<p>A plugin can be easily loaded into a normal <strong class="source-inline">clang</strong> by using simple command-line options:</p>
			<p class="source-code">$ clang <strong class="bold">-fplugin=/path/to/MyPlugin.so</strong> … foo.cpp</p>
			<p>This is really useful if you want to customize the compilation but have no control over the <strong class="source-inline">clang</strong> executable (that is, you can't use a modified version of <strong class="source-inline">clang</strong>). In addition, using the Clang plugin allows you to integrate with the build system more tightly; for example, if you want to rerun your logic once the source files or even arbitrary build dependencies have been modified. Since the Clang plugin is still using <strong class="source-inline">clang</strong> as the driver and modern build systems are pretty good at resolving normal compilation command dependencies, this can be done by making a few compile flag tweaks.</p>
			<p>However, the biggest downside of <a id="_idIndexMarker199"/>using the Clang plugin is its <strong class="bold">API issue</strong>. In theory, you can load and run your plugin in any <strong class="source-inline">clang</strong> executable, but only if the C++ APIs (and the ABI) are used by your plugin and the <strong class="source-inline">clang</strong> executable matches it. Unfortunately, for now, Clang (and also the whole LLVM project) has no intention to make any of its C++ APIs stable. In other words, to take the safest path, you need to make sure both your plugin and <strong class="source-inline">clang</strong> are using the <em class="italic">exact same</em> (major) version of LLVM. This issue makes the Clang plugin pretty hard to be released standalone.</p>
			<p>We will look at this in more detail in <a href="B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 7</em></a>, <em class="italic">Handling AST</em>.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor075"/>LibTooling and Clang Tools</h2>
			<p><strong class="bold">LibTooling</strong> is a library that provides <a id="_idIndexMarker200"/>features for building <em class="italic">standalone tools</em> on top of Clang's techniques. You can use it like a normal library in your project, without having any dependencies on the <strong class="source-inline">clang</strong> executable. Also, the APIs are designed to be more high-level so that you don't need to deal with many of Clang's internal details, making it more friendly to non-Clang developers.</p>
			<p><strong class="bold">Language server</strong> is one of the <a id="_idIndexMarker201"/>most famous use cases of libTooling. A Language server is launched as a daemon process and accepts requests from editors or IDEs. These requests can be as simple as syntax checking a code snippet or complicated tasks such as code completions. While a Language server does not need to compile the incoming source code into native code as normal compilers do, it needs a way to parse and analyze that code, which is non-trivial to build from scratch. libTooling avoids the need to <em class="italic">recreate the wheels</em> in this case by taking Clang's techniques off-the-shelf and providing an easier interface for Language server developers.</p>
			<p>To give you a more concrete idea of how libTooling differs from the Clang plugin, here is a (simplified) code snippet for executing a custom <strong class="source-inline">ASTFrontendAction</strong> called <strong class="source-inline">MyCustomAction</strong>:</p>
			<p class="source-code">int main(int argc, char** argv) {</p>
			<p class="source-code">  <strong class="bold">CommonOptionsParser</strong> OptionsParser(argc, argv,…);</p>
			<p class="source-code">  <strong class="bold">ClangTool</strong> Tool(OptionsParser.getCompilations(), {"foo.cpp"});</p>
			<p class="source-code">  return Tool.run(newFrontendActionFactory&lt;<strong class="bold">MyCustomAction</strong>&gt;().         get());</p>
			<p class="source-code">}</p>
			<p>As shown in the <a id="_idIndexMarker202"/>previous code, you can't just embed this code into <em class="italic">any</em> code base. libTooling also provides lots of nice utilities, such as <strong class="source-inline">CommonOptionsParser</strong>, which parses textual command-line options and transforms them into Clang options for you.</p>
			<p class="callout-heading">libTooling's API Stability</p>
			<p class="callout">Unfortunately, libTooling doesn't provide stable C++ APIs either. Nevertheless, this isn't a problem since you have full control over what LLVM version you're using.</p>
			<p>Last but not least, <strong class="bold">Clang Tools</strong> is a <a id="_idIndexMarker203"/>collection of utility programs build on top of libTooling. You can think of it as the command-line tool version of libTooling in that it provides some common functionalities. For example, you can use <strong class="source-inline">clang-refactor</strong> to refactor the code. This includes renaming a variable, as shown in the following code:</p>
			<p class="source-code">// In foo.cpp…</p>
			<p class="source-code">struct Location {</p>
			<p class="source-code">  float Lat, Lng;</p>
			<p class="source-code">};</p>
			<p class="source-code">float foo(Location *loc) {</p>
			<p class="source-code">  auto Lat = loc-&gt;Lat + 1.0;</p>
			<p class="source-code">  return Lat;</p>
			<p class="source-code">}</p>
			<p>If we want to rename the <strong class="source-inline">Lat</strong> member variable in the <strong class="source-inline">Location</strong> struct <strong class="source-inline">Latitude</strong>, we can use the following command:</p>
			<p class="source-code">$ clang-refactor --selection="foo.cpp:1:1-10:2" \</p>
			<p class="source-code">                 --old-qualified-name="Location::Lat" \</p>
			<p class="source-code">                 --new-qualified-name="Location::Latitude" \</p>
			<p class="source-code">                 foo.cpp</p>
			<p class="callout-heading">Building clang-refactor</p>
			<p class="callout">Be sure to follow the instructions at the beginning of this chapter to include <strong class="source-inline">clang-tools-extra</strong> in the list for the <strong class="source-inline">LLVM_ENABLE_PROJECTS</strong> CMake variable. By doing this, you'll be able to build <strong class="source-inline">clang-refactor</strong> using the <strong class="source-inline">ninja clang-refactor</strong> command.</p>
			<p>You will get the following output:</p>
			<p class="source-code">// In foo.cpp…</p>
			<p class="source-code">struct Location {</p>
			<p class="source-code">  float Latitude, Lng;</p>
			<p class="source-code">};</p>
			<p class="source-code">float foo(Location *loc) {</p>
			<p class="source-code">  auto Lat = loc-&gt;Latitude + 1.0;</p>
			<p class="source-code">  return Lat;</p>
			<p class="source-code">}</p>
			<p>This is done by the <a id="_idIndexMarker204"/>refactoring framework built inside libTooling; <strong class="source-inline">clang-refactor</strong> merely provides a command-line interface for it.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor076"/>Summary</h1>
			<p>In this chapter, we looked at how Clang is organized and the functionalities of some of its important subsystems and components. Then, we learned about the differences between Clang's major extension and tooling options – the Clang plugin, libTooling, and Clang Tools – including what each of them looks like and what their pros and cons are. The Clang plugin provides an easy way to insert custom logic into Clang's compilation pipeline via dynamically loaded plugins but suffers from API stability issues; libTooling has a different focus than the Clang plugin in that it aims to provide a toolbox for developers to create a standalone tool; and Clang Tools provides various applications. </p>
			<p>In the next chapter, we will talk about preprocessor development. We will learn how the preprocessor and the lexer work in Clang, and show you how to write plugins for the sake of customizing preprocessing logic.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor077"/>Further reading</h1>
			<ul>
				<li>Here is a list of checks that are done by Chromium's Clang plugin: <a href="https://chromium.googlesource.com/chromium/src/tools/clang/+/refs/heads/master/plugins/FindBadConstructsAction.h">https://chromium.googlesource.com/chromium/src/tools/clang/+/refs/heads/master/plugins/FindBadConstructsAction.h</a>.</li>
				<li>You can learn more about choosing the right Clang extension interface here: <a href="https://clang.llvm.org/docs/Tooling.html">https://clang.llvm.org/docs/Tooling.html</a>.</li>
				<li>LLVM also has its own libTooling-based Language server, called <strong class="source-inline">clangd</strong>: <a href="http://clangd.llvm.org">http://clangd.llvm.org</a>.</li>
			</ul>
		</div>
	</body></html>