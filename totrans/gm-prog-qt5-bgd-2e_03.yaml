- en: Qt GUI Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt 图形界面编程
- en: This chapter will help you learn how to use Qt to develop applications with
    a graphical user interface using the Qt Creator IDE. We will get familiar with
    the core Qt functionality, widgets, layouts, and the signals and slots mechanism
    that we will later use to create complex systems such as games. We will also cover
    the various actions and resource systems of Qt. By the end of this chapter, you
    will be able to write your own programs that communicate with the user through
    windows and widgets.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助你学习如何使用 Qt Creator IDE 使用 Qt 开发具有图形用户界面的应用程序。我们将熟悉 Qt 的核心功能、小部件、布局以及我们将用于创建复杂系统（如游戏）的信号和槽机制。我们还将介绍
    Qt 的各种操作和资源系统。到本章结束时，你将能够编写自己的程序，通过窗口和小部件与用户进行通信。
- en: 'The main topics covered in this chapter are as listed:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主要主题如下：
- en: Windows and widgets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口和小部件
- en: Creating a Qt Widgets project and implementing a tic-tac-toe game
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Qt Widgets 项目并实现井字棋游戏
- en: Creating widgets with or without the visual form editor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用或不用可视化表单编辑器创建小部件
- en: Using layouts to automatically position widgets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用布局自动定位小部件
- en: Creating and using signals and slots
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用信号和槽
- en: Using the Qt resource system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Qt 资源系统
- en: Creating GUI in Qt
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Qt 中创建 GUI
- en: As described in [Chapter 1](e9cbf2c5-ac0b-494f-9293-2fb16c98524f.xhtml), *Introduction
    to Qt,* Qt consists of multiple modules. In this chapter, you will learn how to
    use the Qt Widgets module. It allows you to create classic desktop applications.
    The **user interface** (**UI**) of these applications consists of *widgets*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 1 章](e9cbf2c5-ac0b-494f-9293-2fb16c98524f.xhtml) 所述，*Qt 简介*，Qt 由多个模块组成。在本章中，你将学习如何使用
    Qt Widgets 模块。它允许你创建经典桌面应用程序。这些应用程序的 **用户界面**（**UI**）由 *小部件* 组成。
- en: 'A widget is a fragment of the UI with a specific look and behavior. Qt provides
    a lot of built-in widgets that are widely used in applications: labels, text boxes,
    checkboxes, buttons, and so on. Each of these widgets is represented as an instance
    of a C++ class derived from `QWidget` and provides methods for reading and writing
    the widget''s content. You may also create your own widgets with custom content
    and behavior.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件是具有特定外观和行为的 UI 片段。Qt 提供了许多内置的小部件，这些小部件在应用程序中广泛使用：标签、文本框、复选框、按钮等等。这些小部件中的每一个都表示为从
    `QWidget` 派生的 C++ 类的实例，并提供读取和写入小部件内容的方法。你也可以创建具有自定义内容和行为的小部件。
- en: The base class of `QWidget` is `QObject`—the most important Qt class that contains
    multiple useful features. In particular, it implements parent–child relationships
    between objects, allowing you to organize a collection of objects in your program.
    Each object can have a parent object and an arbitrary number of children. Making
    a parent–child relationship between two objects has multiple consequences. When
    an object is deleted, all its children will be automatically deleted as well.
    For widgets, there is also a rule that a child occupies an area within the boundaries
    of its parent. For example, a typical form includes multiple labels, input fields,
    and buttons. Each of the form's elements is a widget, and the form is their parent
    widget.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`QWidget` 的基类是 `QObject` —— 这是 Qt 中最重要的类，它包含多个有用的功能。特别是，它实现了对象之间的父子关系，允许你在程序中组织对象集合。每个对象都可以有一个父对象和任意数量的子对象。在两个对象之间建立父子关系有多个后果。当一个对象被删除时，所有其子对象也将自动删除。对于小部件，还有一个规则，即子对象占据其父对象边界内的区域。例如，典型的表单包括多个标签、输入字段和按钮。表单的每个元素都是一个小部件，表单是它们的父小部件。'
- en: Each widget has a separate coordinate system that is used for painting and event
    handling within the widget. By default, the origin of this coordinate system is
    placed in its top-left corner. The child's coordinate system is relative to its
    parent.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个小部件都有一个独立的坐标系，用于小部件内的绘制和事件处理。默认情况下，该坐标系的起点位于其左上角。子坐标系统相对于其父坐标系统。
- en: Any widget that is not included into another widget (that is, any *top-level
    widget*) becomes a window, and the desktop operating system will provide it with
    a window frame, which usually usually allows the user to drag around, resize,
    and close the window (although the presence and content of the window frame can
    be configured).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 任何未包含在其他小部件中（即任何 *顶级小部件*）的小部件都将成为一个窗口，桌面操作系统将为其提供一个窗口框架，通常允许用户拖动、调整大小和关闭窗口（尽管可以配置窗口框架的存在和内容）。
- en: Time for action – Creating a Qt Widgets project
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建 Qt Widgets 项目
- en: The first step to develop an application with Qt Creator is to create a project
    using one of the templates provided by the IDE.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Qt Creator 开发应用程序的第一步是使用 IDE 提供的模板之一创建项目。
- en: 'From the File menu of Qt Creator, choose New File or Project. There are a number
    of project types to choose from. Follow the given steps for creating a Qt Desktop
    project:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Qt Creator 的“文件”菜单中选择“新建文件”或“项目”。有多个项目类型可供选择。按照以下步骤创建 Qt 桌面项目：
- en: 'For a widget-based application, choose the Application group and the Qt Widgets
    Application template, as shown in the following screenshot:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于基于小部件的应用程序，请选择应用程序组以及 Qt 小部件应用程序模板，如下面的截图所示：
- en: '![](img/7fae213c-deb5-4553-93a3-06f55a5ba55f.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7fae213c-deb5-4553-93a3-06f55a5ba55f.png)'
- en: 'The next step is to choose a name and location for your new project:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是选择您新项目的名称和位置：
- en: '![](img/8f6078f9-14e4-4d4b-a70e-0a6e1d22c9b0.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8f6078f9-14e4-4d4b-a70e-0a6e1d22c9b0.png)'
- en: We will create a simple tic-tac-toe game, so we will name our project `tictactoe` and
    provide a nice location for it.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的井字棋游戏，因此我们将我们的项目命名为 `tictactoe` 并为其提供一个合适的位置。
- en: If you have a common directory where you put all your projects, you can tick
    the Use as default project location checkbox for Qt Creator to remember the location
    and suggest it the next time you start a new project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个存放所有项目的公共目录，您可以为 Qt Creator 选择“使用默认项目位置”复选框，以便它记住位置并在您下次启动新项目时建议该位置。
- en: 'Next, you need to select the kit (or multiple kits) you want to use with the
    project. Select the Desktop Qt kit corresponding to the Qt version you want to
    use:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要选择与项目一起使用的工具包（或多个工具包）。选择与您想要使用的 Qt 版本相对应的桌面 Qt 工具包：
- en: '![](img/467d3550-06b1-4e9c-a21b-3dce8473bf43.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/467d3550-06b1-4e9c-a21b-3dce8473bf43.png)'
- en: 'Now you will be presented with the option of creating the first widget for
    your project. We want to create a widget that will represent the main window of
    our application, so we can leave the Class name and Base class fields unchanged.
    We also want to use the visual form editor to edit the content of the main window,
    so Generate form should also be left checked:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您将看到创建项目第一个小部件的选项。我们想要创建一个代表应用程序主窗口的小部件，因此我们可以保持类名和基类字段不变。我们还想要使用可视化表单编辑器来编辑主窗口的内容，因此“生成表单”也应该保持选中状态：
- en: '![](img/7591085e-6445-4456-a9b5-c3b3d00af83a.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7591085e-6445-4456-a9b5-c3b3d00af83a.png)'
- en: Then, click on Next and Finish.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击“下一步”和“完成”。
- en: What just happened?
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Creator created a new subdirectory in the directory that you previously chose
    for the location of the project. This new directory (the **project directory**)
    now contains a number of files. You can use the Projects pane of Qt Creator to
    list and open these files (refer to [Chapter 2](d129202d-f982-4114-b69a-094d0a136fe9.xhtml), *Installation*,
    for an explanation of Qt Creator's basic controls). Let's go through these files.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Creator 在您之前选择的用于项目位置的目录中创建了一个新的子目录。这个新目录（**项目目录**）现在包含了一些文件。您可以使用 Qt Creator
    的“项目”窗格列出和打开这些文件（有关 Qt Creator 基本控件的解释，请参阅[第 2 章](d129202d-f982-4114-b69a-094d0a136fe9.xhtml)，*安装*）。让我们来看看这些文件。
- en: 'The `main.cpp` file contains an implementation of the `main()` function, the
    entry point of the application, as the following code shows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.cpp` 文件包含 `main()` 函数的实现，这是应用程序的入口点，如下面的代码所示：'
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `main()` function creates an instance of the `QApplication` class and feeds
    it with variables containing the command-line arguments. Then, it instantiates
    our `MainWindow` class, calls its `show` method, and finally, returns a value
    returned by the `exec` method of the application object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数创建 `QApplication` 类的实例，并给它提供包含命令行参数的变量。然后，它实例化我们的 `MainWindow` 类，调用其
    `show` 方法，并最终返回应用程序对象 `exec` 方法的返回值。'
- en: '`QApplication` is a singleton class that manages the whole application. In
    particular, it is responsible for processing events that come from within the
    application or from external sources. For events to be processed, an event loop
    needs to be running. The loop waits for incoming events and dispatches them to
    proper routines. Most things in Qt are done through events: input handling, redrawing,
    receiving data over the network, triggering timers, and so on. This is the reason
    we say that Qt is an event-oriented framework. Without an active event loop, the
    event handling would not function properly. The `exec()` call in `QApplication`
    (or, to be more specific, in its base class—`QCoreApplication`) is responsible
    for entering the main event loop of the application. The function does not return
    until your application requests the event loop to be terminated. When that eventually
    happens, the `main` function returns and your application ends.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`QApplication` 是一个单例类，负责管理整个应用程序。特别是，它负责处理来自应用程序内部或外部来源的事件。为了处理事件，需要一个事件循环正在运行。循环等待传入的事件并将它们调度到适当的例程。在
    Qt 中，大多数事情都是通过事件完成的：输入处理、重绘、通过网络接收数据、触发计时器等等。这就是我们说 Qt 是一个面向事件框架的原因。如果没有活跃的事件循环，事件处理将无法正常工作。`QApplication`
    中的 `exec()` 调用（或者更具体地说，在其基类 `QCoreApplication` 中）负责进入应用程序的主事件循环。该函数在应用程序请求事件循环终止之前不会返回。当最终发生这种情况时，`main`
    函数返回，你的应用程序结束。'
- en: The `mainwindow.h` and the `mainwindow.cpp` files implement the `MainWindow`
    class. For now, there is almost no code in it. The class is derived from `QMainWindow`
    (which, in turn, is derived from `QWidget`), so it inherits a lot of methods and
    behavior from its base class. It also contains a `Ui::MainWindow *ui` field, which
    is initialized in the constructor and deleted in the destructor. The constructor
    also calls the `ui->setupUi(this);` function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`mainwindow.h` 和 `mainwindow.cpp` 文件实现了 `MainWindow` 类。目前，其中几乎没有代码。这个类是从 `QMainWindow`（它反过来是从
    `QWidget` 派生的）派生的，因此它从其基类继承了大量的方法和行为。它还包含一个 `Ui::MainWindow *ui` 字段，它在构造函数中初始化并在析构函数中删除。构造函数还调用
    `ui->setupUi(this);` 函数。'
- en: '`Ui::MainWindow` is an *automatically generated* class, so there is no declaration
    of it in the source code. It will be created in the build directory when the project
    is built. The purpose of this class is to set up our widget and fill it with content
    based on changes in the form editor. The automatically generated class is not
    a `QWidget`. In fact, it contains only two methods: `setupUi`, which performs
    the initial setup, and `retranslateUi`, which updates visible text when the UI
    language is changed. All widgets and other objects added in the form editor are
    available as public fields of the `Ui::MainWindow` class, so we can access them
    from within the `MainWindow` method as `ui->objectName`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ui::MainWindow` 是一个**自动生成**的类，因此在源代码中没有它的声明。当项目构建时，它将在构建目录中创建。这个类的作用是根据表单编辑器的变化来设置我们的小部件并填充内容。自动生成的类不是
    `QWidget`。实际上，它只包含两个方法：`setupUi`，它执行初始设置，以及`retranslateUi`，它在 UI 语言更改时更新可见文本。在表单编辑器中添加的所有小部件和其他对象都作为
    `Ui::MainWindow` 类的公共字段可用，因此我们可以从 `MainWindow` 方法中通过 `ui->objectName` 访问它们。'
- en: '`mainwindow.ui` is a form file that can be edited in the visual form editor.
    If you open it in Qt Creator by double-clicking on it in the Projects pane, Qt
    Creator will switch to the Design mode. If you switch back to the Edit mode, you
    will see that this file is actually an XML file containing the hierarchy and properties
    of all objects edited in Design mode. During the building of the project, a special
    tool called the User Interface Compiler converts this XML file to the implementation
    of the `Ui::MainWindow` class used in the `MainWindow` class.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`mainwindow.ui` 是一个可以在可视化表单编辑器中编辑的表单文件。如果你通过在项目面板中双击它来在 Qt Creator 中打开它，Qt
    Creator 将切换到设计模式。如果你切换回编辑模式，你会看到这个文件实际上是一个包含在设计模式中编辑的所有对象的层次结构和属性的 XML 文件。在项目的构建过程中，一个名为用户界面编译器的特殊工具将这个
    XML 文件转换为 `MainWindow` 类中使用的 `Ui::MainWindow` 类的实现。'
- en: Note that you don't need to edit the XML file by hand or edit any code in the `Ui::MainWindow`
    class. Making changes in the visual editor is enough to apply them to your `MainWindow`
    class and make the form's objects available to it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不需要手动编辑 XML 文件或编辑 `Ui::MainWindow` 类中的任何代码。在可视化编辑器中做出更改就足以将它们应用到你的 `MainWindow`
    类中，并使其表单对象可供它使用。
- en: 'The final file that was generated is called `tictactoe.pro` and is the project
    configuration file. It contains all the information that is required to build
    your project using the tools that Qt provides. Let''s analyze this file (less
    important directives are omitted):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的最终文件名为 `tictactoe.pro`，是项目配置文件。它包含构建项目所需的所有信息，使用 Qt 提供的工具。让我们分析这个文件（省略了不太重要的指令）：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first two lines enable Qt's `core`, `gui`, and `widgets` modules. The `TEMPLATE`
    variable is used to specify that your project file describes an application (as
    opposed to, for example, a library). The `TARGET` variable contains the name of
    the produced executable (`tictactoe`). The last three lines list all files that
    should be used to build the project.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行启用了 Qt 的 `core`、`gui` 和 `widgets` 模块。`TEMPLATE` 变量用于指定项目文件描述的是一个应用程序（而不是，例如，一个库）。`TARGET`
    变量包含生成的可执行文件（`tictactoe`）的名称。最后三行列出了构建项目时应使用的所有文件。
- en: In fact, `qmake` enables Qt Core and Qt GUI modules by default, even if you
    don't specify them explicitly in the project file. You can opt out of using a
    default module if you want. For example, you can disable Qt GUI by adding `QT
    -= gui` to the project file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`qmake` 默认启用 Qt Core 和 Qt GUI 模块，即使您在项目文件中没有明确指定它们。如果您想不使用默认模块，可以选择退出。例如，您可以通过在项目文件中添加
    `QT -= gui` 来禁用 Qt GUI。
- en: 'Before we proceed, let''s tell the build system that we want to use C++11 features
    (such as lambda expressions, scoped enumerations, and range-based `for` loops)
    in our project by adding the following line to `tictactoe.pro`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们通过在 `tictactoe.pro` 中添加以下行来告诉构建系统我们想在项目中使用 C++11 功能（如 lambda 表达式、作用域枚举和基于范围的
    `for` 循环）：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we do this, the C++ compiler will receive a flag indicating that C++11 support
    should be enabled. This may not be needed if your compiler has C++11 support enabled
    by default. If you wish to use C++14 instead, use `CONFIG += c++14`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，C++ 编译器将收到一个标志，指示应启用 C++11 支持。如果您的编译器默认启用了 C++11 支持，可能不需要这样做。如果您想使用
    C++14，请使用 `CONFIG += c++14`。
- en: 'What we have now is a complete Qt Widgets project. To build and run it, simply
    choose the Run entry from the Build drop-down menu or click on the green triangle
    icon on the left-hand side of the Qt Creator window. After a while, you should
    see a window pop up. Since we didn''t add anything to the window, it is blank:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个完整的 Qt Widgets 项目。要构建和运行它，只需从构建下拉菜单中选择运行条目，或者在 Qt Creator 窗口的左侧点击绿色三角形图标。过了一会儿，你应该会看到一个窗口弹出。由于我们没有向窗口添加任何内容，所以它是空的：
- en: '![](img/c36a602d-54b2-493c-999d-221be9aee14d.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c36a602d-54b2-493c-999d-221be9aee14d.png)'
- en: Design mode interface
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式界面
- en: 'Open the `mainwindow.ui` file and examine Qt Creator''s Design mode:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `mainwindow.ui` 文件，检查 Qt Creator 的设计模式：
- en: '![](img/ae9da791-315a-46de-a371-c7b5ecbe36da.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae9da791-315a-46de-a371-c7b5ecbe36da.png)'
- en: 'The Design mode consists of five major parts (they are marked on this screenshot):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式由五个主要部分组成（它们在这张截图上已标记）：
- en: The central area **(1)** is the main worksheet. It contains a graphical representation
    of the form being designed where you can move widgets around, compose them into
    layouts, and see how they react. It also allows further manipulation of the form
    using the point-and-click method that we will learn later.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心区域 **(1**) 是主要的工作表。它包含正在设计的表单的图形表示，您可以在其中移动小部件，将它们组合成布局，并查看它们的反应。它还允许使用我们稍后将要学习的点选方法进一步操作表单。
- en: The toolbox **(2)** is located in the left part of the window. It contains a
    list of available types of widget that are arranged into groups containing items
    with a related or similar functionality. Over the list, you can see a box that
    lets you filter widgets that are displayed in the list to show only those that
    match the entered expression. At the beginning of the list, there are also items
    that are not really widgets—one group contains layouts, and the other one contains
    so-called spacers, which are a way to push other items away from each other or
    create an empty space in layouts. The main purpose of the toolbox is to add items
    to the form in the worksheet. You can do that by grabbing a widget from the list
    with the mouse, dragging it to the widget in the central area, and releasing the
    mouse button.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具箱 **(2**) 位于窗口的左侧部分。它包含一组可用的小部件类型，这些类型按具有相关或相似功能的项目分组。在列表上方，您可以看到一个框，允许您过滤列表中显示的小部件，以仅显示与输入的表达式匹配的小部件。列表开头也有一些实际上不是小部件的项目——一个组包含布局，另一个组包含所谓的间隔符，这是一种将其他项彼此推开或创建布局中的空白区域的方法。工具箱的主要目的是将项添加到工作表中的表单。您可以通过用鼠标从列表中拖取小部件，将其拖动到中央区域的小部件上，然后释放鼠标按钮来实现这一点。
- en: The two tabs **(3)** in the lower part of the window—Action Editor and Signal/Slot
    Editor—allow us to create helper entities such as actions for the menus and toolbars
    or signal-slot connections between widgets.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口下方的两个标签 **(3**)——动作编辑器和信号/槽编辑器——允许我们创建辅助实体，例如菜单和工具栏的动作或小部件之间的信号/槽连接。
- en: The object tree **(4)** is situated in the top-right corner and contains the
    hierarchy tree of the form's items. The object name and class name of each item
    added to the form is displayed in the tree. The topmost item corresponds to the
    form itself. You can use both the central area and the object tree to select the
    existing items and access their context menu (for example, if you want to delete
    an item, you can select the Remove... option in the context menu).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象树 **(4**) 位于窗口的右上角，包含表单项的层次结构树。在树中显示每个添加到表单的对象名称和类名称。最顶部的项对应于表单本身。您可以使用中央区域和对象树来选择现有项并访问它们的上下文菜单（例如，如果您想删除一个项，您可以在上下文菜单中选择“移除...”选项）。
- en: The property editor **(5)** is located in the bottom-right corner. It allows
    you to view and change the values of all the properties of the item currently
    selected in the central area and the object tree. Properties are grouped by their
    classes that they have been declared in, starting from `QObject` (the base class
    implementing properties), which declares only one, but an important, property—`objectName`.
    Following `QObject`, there are properties declared in `QWidget`, which is a direct
    descendant of `QObject`. They are mainly related to the geometry and layout policies
    of the widget. Further down the list, you can find properties that come from further
    derivations of `QWidget`, down to the concrete class of the selected widget. The
    Filter field above the properties can help you find the needed property quickly.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性编辑器 **(5**) 位于窗口的右下角。它允许您查看和更改中央区域和对象树中当前选定的项的所有属性值。属性按它们声明的类分组，从 `QObject`（实现属性的基类）开始，它只声明了一个但非常重要的属性——`objectName`。在
    `QObject` 之后，是 `QWidget` 中声明的属性，它是 `QObject` 的直接后代。它们主要与小部件的几何和布局策略相关。在列表的下方，您可以找到来自
    `QWidget` 进一步派生的属性，直到所选小部件的具体系列。属性上方的过滤器可以帮助您快速找到所需的属性。
- en: 'Taking a closer look at the property editor, you can see that some of them
    have ![](img/878f5938-5dc5-4247-815b-fd27c6847e4f.png) arrows, which reveal new
    rows when clicked. These are composed properties where the complete property value
    is determined from more than one subproperty value; for example, if there is a
    property called `geometry` that defines a rectangle, it can be expanded to show
    four subproperties: `x`, `y`, `width`, and `height`. Another thing that you may
    quickly note is that some property names are displayed in bold. This means that
    the property value was modified and is different from the default value for this
    property. This lets you quickly find the properties that you have modified.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看属性编辑器，您可以看到其中一些具有![](img/878f5938-5dc5-4247-815b-fd27c6847e4f.png)箭头，点击时可以显示新行。这些是由多个子属性值确定的复合属性，例如，如果有一个名为`geometry`的属性定义了一个矩形，它可以展开以显示四个子属性：`x`、`y`、`width`和`height`。您可能还会很快注意到，一些属性名以粗体显示。这意味着该属性值已被修改，并且与该属性的默认值不同。这使您可以快速找到您已修改的属性。
- en: If you changed a property's value but decided to stick to the default value
    later, you should click on the corresponding input field and then click on the
    small button with an arrow to its right: ![](img/8f2757a2-9cb3-4982-be2e-51a37e5a5693.png).
    This is not the same as setting the original value by hand. For example, if you
    examine the
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更改了属性值，但后来决定坚持使用默认值，您应该点击相应的输入字段，然后点击右侧带有箭头的小按钮：![](img/8f2757a2-9cb3-4982-be2e-51a37e5a5693.png)。这不同于手动设置原始值。例如，如果您检查
- en: '`spacing` property of some layouts, it would appear as if it had some constant
    default value for (example, 6). However, the actual default value depends on the
    style the application uses and may be different on a different operating system,
    so the only way to set the default value is to use the dedicated button and ensure
    that the property is not displayed in bold anymore.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些布局的`spacing`属性，它可能看起来有一个固定的默认值（例如，6）。然而，实际的默认值取决于应用程序使用的样式，并且可能在不同的操作系统上有所不同，因此设置默认值的唯一方法是使用专用按钮，并确保该属性不再以粗体显示。
- en: If you prefer a purely alphabetical order where properties are not grouped by
    their class, you can switch the view using a pop-up menu that becomes available
    after you click on the wrench icon positioned over the property list; however,
    once you get familiar with the hierarchy of Qt classes, it will be much easier
    to navigate the list when it is sorted by class affinity.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢纯字母顺序，其中属性不是按其类别分组，您可以通过点击位于属性列表上方的扳手图标后出现的弹出菜单来切换视图；然而，一旦您熟悉了Qt类的层次结构，当按类亲和度排序时，导航列表将更容易。
- en: What was described here is the basic tool layout. If you don't like it, you
    can invoke the context menu from the main worksheet, uncheck the Automatically
    Hide View Title Bars entry, and use the title bars that appear to re-arrange all
    the panes to your liking, or even close the ones you don't currently need.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里所描述的是基本工具布局。如果您不喜欢它，您可以从主工作表中的上下文菜单调用，取消选中“自动隐藏视图标题栏”的选项，并使用出现的标题栏来重新排列所有窗格，或者甚至关闭您当前不需要的窗格。
- en: Now that you are familiar with the structure of the visual form editor, you
    can finally add some content to our widget. We are making a tic-tac-toe game with
    local multiplayer, so we need some way of displaying which of the two players
    currently moves. Let's put the game board in the center of the window and display
    the names of the players above and below the board. When a player needs to move,
    we will make the corresponding name's font bold. We also need a button that will
    start a new game.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了视觉表单编辑器的结构，您终于可以向我们的小部件添加一些内容了。我们正在制作一个具有本地多人游戏的井字棋游戏，因此我们需要一种方式来显示哪两位玩家当前在移动。让我们将游戏板放在窗口的中心，并在游戏板上方和下方显示玩家的名字。当一个玩家需要移动时，我们将使相应名字的字体加粗。我们还需要一个按钮来开始新游戏。
- en: Time for action – Adding widgets to the form
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践 - 向表单添加小部件
- en: Locate the Label item in the toolbox (it's in the Display Widgets category)
    and drag it to our form. Use the property editor to set the `objectName` property
    of the label to `player1Name`. `objectName` is a unique identifier of a form item.
    The object name is used as the name of the public field in the `Ui::MainWindow`
    class, so the label will be available as `ui->player1Name` in the `MainWindow`
    class (and will have a `QLabel *` type). Then, locate the `text` property in the
    property editor (it will be in the `QLabel` group, as it is the class that introduces
    the property) and set it to `Player 1`. You will see that the text in the central
    area will be updated accordingly. Add another label, set its `objectName` to `player2Name`
    and its `text` to `Player 2`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在工具箱中找到 `Label` 项（它在 `Display Widgets` 类别中），并将其拖动到我们的表单中。使用属性编辑器将标签的 `objectName`
    属性设置为 `player1Name`。`objectName` 是表单项的唯一标识符。对象名称用作 `Ui::MainWindow` 类中的公共字段名称，因此标签将在 `MainWindow`
    类中作为 `ui->player1Name` 可用（并将具有 `QLabel *` 类型）。然后，在属性编辑器中找到 `text` 属性（它将在 `QLabel`
    组中，因为它引入了该属性）并将其设置为 `Player 1`。你会看到中央区域中的文本将相应更新。添加另一个标签，将其 `objectName` 设置为 `player2Name`
    并将其 `text` 设置为 `Player 2`。
- en: You can select a widget in the central area and press the *F2* key to edit the
    text in place. Another way is to double-click on the widget in the form. It works
    for any widget that can display text.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在中央区域选择一个小部件并按 `F2` 键来就地编辑文本。另一种方法是双击表单中的小部件。这适用于任何可以显示文本的小部件。
- en: Drag a Push Button (from the Buttons group) to the form and use the *F2* key
    to rename it to `Start new game`. If the name does not fit in the button, you
    can resize it using the blue rectangles on its edges. Set the `objectName` of
    the button to `startNewGame`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个按钮（来自 `Buttons` 组）拖动到表单中，并使用 `F2` 键将其重命名为 `Start new game`。如果按钮中放不下这个名称，你可以使用其边缘的蓝色矩形来调整其大小。将按钮的 `objectName`
    设置为 `startNewGame`。
- en: 'There is no built-in widget for our game board, so we will need to create a
    custom widget for it later. For now, we will use an empty widget. Locate Widget
    in the Containers group of the toolbox and drag it to the form. Set its `objectName`
    to `gameBoard`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的游戏板，没有内置的小部件，因此我们稍后需要为它创建一个自定义小部件。现在，我们将使用一个空的小部件。在工具箱的 `Containers` 组中找到 `Widget`，并将其拖动到表单中。将其
    `objectName` 设置为 `gameBoard`：
- en: '![](img/0f1336ea-897d-4ace-9ebd-f5712e43bf78.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0f1336ea-897d-4ace-9ebd-f5712e43bf78.png)'
- en: Layouts
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: If you build and run the project now, you will see the window with two labels
    and a button, but they will remain in the exact positions you left them. This
    is what you almost never want. Usually, it is desired that widgets are automatically
    resized based on their content and the size of their neighbors. They need to adjust
    to the changes of the window's size (or, in contrast, the window size may need
    to be restricted based on possible sizes of the widgets inside of it). This is
    a very important feature for a cross-platform application, as you cannot assume
    any particular screen resolution or size of controls. In Qt, all of this requires
    us to use a special mechanism called **layouts**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在构建并运行项目，你会看到带有两个标签和一个按钮的窗口，但它们将保持你离开时的确切位置。这几乎是你不想要的。通常，人们希望小部件能够根据其内容和相邻小部件的大小自动调整大小。它们需要适应窗口大小的变化（或者相反，窗口的大小可能需要根据其中小部件的可能大小进行限制）。这对于跨平台应用程序来说是一个非常重要的特性，因为你不能假设任何特定的屏幕分辨率或控件大小。在
    Qt 中，所有这些都需要我们使用一种称为**布局**的特殊机制。
- en: Layouts allow us to arrange the content of a widget, ensuring that its space
    is used efficiently. When we set a layout on a widget, we can start adding widgets,
    and even other layouts, and the mechanism will resize and reposition them according
    to the rules that we specify. When something happens in the user interface that
    influences how widgets should be displayed (for example, the label text is replaced
    with longer text, which makes the label require more space to show its content),
    the layout is triggered again, which recalculates all positions and sizes and
    updates widgets, as necessary.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 布局允许我们安排小部件的内容，确保其空间得到有效利用。当我们对一个小部件设置布局时，我们可以开始添加小部件，甚至其他布局，该机制将根据我们指定的规则调整大小和重新定位它们。当用户界面中发生影响小部件显示方式的事件（例如，标签文本被替换为更长的文本，这使得标签需要更多空间来显示其内容）时，布局会被再次触发，这会重新计算所有位置和大小，并根据需要更新小部件。
- en: 'Qt comes with a predefined set of layouts that are derived from the `QLayout`
    class, but you can also create your own. The ones that we already have at our
    disposal are `QHBoxLayout` and `QVBoxLayout`, which position items horizontally
    and vertically; `QGridLayout`, which arranges items in a grid so that an item
    can span across columns or rows; and `QFormLayout`, which creates two columns
    of items with item descriptions in one column and item content in the other. There
    is also `QStackedLayout`, which is rarely used directly and which makes one of
    the items assigned to it possess all the available space. You can see the most
    common layouts in action in the following figure:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 提供了一组预定义的布局，这些布局是从 `QLayout` 类派生出来的，但你也可以创建自己的布局。我们目前可用的布局有 `QHBoxLayout`
    和 `QVBoxLayout`，它们分别用于水平排列和垂直排列项目；`QGridLayout` 用于在网格中排列项目，以便项目可以跨越列或行；还有 `QFormLayout`，它创建两列项目，其中一列包含项目描述，另一列包含项目内容。还有
    `QStackedLayout`，它很少直接使用，并且使分配给它的一个项目拥有所有可用空间。你可以在以下图中看到最常见的布局示例：
- en: '![](img/401450d2-7946-4d74-9b6c-c9633953cf59.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/401450d2-7946-4d74-9b6c-c9633953cf59.png)'
- en: Time for action – Adding a layout to the form
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 为表单添加布局
- en: 'Select the MainWindow top-level item in the object tree and click on ![](img/edc2e5c8-bc8c-41e1-8d0b-44e277ab5230.png) ,
    the Lay Out Vertically icon in the upper toolbar. The button, labels, and the
    empty widget will be automatically resized to take all the available space of
    the form in the central area:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象树中选择 MainWindow 顶级项目，然后点击上工具栏中的 ![](img/edc2e5c8-bc8c-41e1-8d0b-44e277ab5230.png)
    图标，即垂直布局图标。按钮、标签和空白的部件将自动调整大小以占用表单中央区域的所有可用空间：
- en: '![](img/b51f5675-9922-4430-aac7-544903be7cbd.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b51f5675-9922-4430-aac7-544903be7cbd.png)'
- en: If the items were arranged in a different order, you can drag and drop them
    to change the order.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目以不同的顺序排列，你可以拖放它们来改变顺序。
- en: Run the application and check that the window's contents are automatically positioned
    and resized to use all the available space when the window is resized. Unfortunately,
    the labels take more vertical space than they really require, resulting in an
    empty space in the application window. We will fix this issue later in this chapter
    when we learn about size policies.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并检查窗口内容在窗口大小调整时是否自动定位和调整大小以使用所有可用空间。不幸的是，标签占用的垂直空间比实际需要的多，导致应用程序窗口中出现空白空间。我们将在本章后面学习尺寸策略时修复这个问题。
- en: You can test the layouts of your form without building and running the whole
    application. Open the Tools menu, go to the Form Editor submenu, and choose the
    Preview entry. You will see a new window open that looks exactly like the form
    we just designed. You can resize the window and interact with the objects inside
    to monitor the behavior of the layouts and widgets. What really happened here
    is that Qt Creator built a real window for us based on the description that we
    provided in all the areas of the design mode. Without any compilation, in a blink
    of an eye, we received a fully working window with all the layouts working and
    all the properties adjusted to our liking. This is a very important tool, so ensure
    that you use it often to verify that your layouts are controlling all the widgets
    as you intended them to—it is much faster than compiling and running the whole
    application just to check whether the widgets stretch or squeeze properly. You
    can also resize the form in the central area of the form editor by dragging its
    bottom-right corner, and if the layouts are set up correctly, the contents should
    be resized and repositioned.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在不构建和运行整个应用程序的情况下测试表单的布局。打开工具菜单，转到表单编辑器子菜单，并选择预览条目。你将看到一个新窗口打开，其外观与我们刚刚设计的表单完全一样。你可以调整窗口大小并与内部对象交互，以监控布局和部件的行为。实际上，Qt
    Creator 根据我们在设计模式的所有区域提供的描述为我们构建了一个真正的窗口。无需任何编译，瞬间我们就得到了一个完全工作的窗口，其中所有布局都正常工作，所有属性都调整到我们喜欢的样子。这是一个非常重要的工具，所以请确保你经常使用它来验证你的布局是否按照你的意图控制所有部件——这比编译和运行整个应用程序来检查部件是否正确拉伸或挤压要快得多。你还可以通过拖动表单编辑器中央区域的右下角来调整表单的大小，如果布局设置正确，内容应该会调整大小并重新定位。
- en: Now that you can create and display a form, two important operations need to
    be implemented. First, you need to receive notifications when the user interacts
    with your form (for example, presses a button) to perform some actions in the
    code. Second, you need to change the properties of the form's contents programmatically,
    and fill it with real data (for example, set player names from the code).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经可以创建和显示表单了，需要实现两个重要的操作。首先，你需要接收用户与你的表单交互（例如，按下按钮）时的通知，以便在代码中执行一些操作。其次，你需要以编程方式更改表单内容的属性，并用真实数据填充它（例如，从代码中设置玩家名称）。
- en: Signals and slots
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号和槽
- en: To trigger functionality as a response to something that happens in an application,
    Qt uses a mechanism of signals and slots. This is another important feature of
    the `QObject` class. It's based on connecting a notification (which Qt calls a **signal**)
    about a change of state in some object with a function or method (called a **slot**)
    that is executed when such a notification arises. For example, if a button is
    pressed, it **emits** (sends) a `clicked()` signal. If some method is connected
    to this signal, the method will be called whenever the button is pressed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了响应应用程序中发生的事情而触发功能，Qt使用信号和槽机制。这是`QObject`类的重要特性之一。它基于将关于某个对象状态变化的通告（Qt称为**信号**）与一个函数或方法（称为**槽**）连接起来，当这种通告出现时执行该函数或方法。例如，如果按下按钮，它将**发出**（发送）一个`clicked()`信号。如果某个方法连接到这个信号，那么每次按钮被按下时，该方法都会被调用。
- en: Signals can have arguments that serve as a payload. For example, an input box
    widget (`QLineEdit`) has a `textEdited(const QString &text)` signal that's emitted
    when the user edits the text in the input box. A slot connected to this signal
    will receive the new text in the input box as its argument (provided it has an
    argument).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 信号可以有作为有效负载的参数。例如，一个输入框小部件（`QLineEdit`）有一个`textEdited(const QString &text)`信号，当用户编辑输入框中的文本时发出。连接到这个信号的槽将接收输入框中的新文本作为其参数（如果它有参数的话）。
- en: Signals and slots can be used with all classes that inherit `QObject` (including
    all widgets). A signal can be connected to a slot, member function, or functor
    (which includes a regular global function). When an object emits a signal, any
    of these entities that are connected to that signal will be called. A signal can
    also be connected to another signal, in which case emitting the first signal will
    make the other signal be emitted as well. You can connect any number of slots
    to a single signal and any number of signals to a single slot.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 信号和槽可以与所有继承自`QObject`（包括所有小部件）的类一起使用。一个信号可以被连接到一个槽、成员函数或函数对象（这包括一个常规的全局函数）。当一个对象发出一个信号时，连接到该信号的任何这些实体都将被调用。一个信号也可以连接到另一个信号，在这种情况下，发出第一个信号将使另一个信号也被发出。你可以将任意数量的槽连接到单个信号，也可以将任意数量的信号连接到单个槽。
- en: Creating signals and slots
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建信号和槽
- en: If you create a `QObject` subclass (or a `QWidget` subclass, as QWidget inherits
    QObject), you can mark a method of this class as a signal or a slot. If the parent
    class had any signals or non-private slots, your class will also inherit them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了一个`QObject`子类（或者一个`QWidget`子类，因为QWidget继承自QObject），你可以将这个类的某个方法标记为信号或槽。如果父类有任何信号或非私有槽，你的类也将继承它们。
- en: In order for signals and slots to work properly, the class declaration must
    contain the `Q_OBJECT` macro in a private section of its definition (Qt Creator
    has generated it for us). When the project is built, a special tool called **Meta-Object
    Compiler** (**moc**) will examine the class's header and generate some extra code
    necessary for signals and slots to work properly.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使信号和槽正常工作，类声明必须在定义的私有部分包含`Q_OBJECT`宏（Qt Creator已经为我们生成了它）。当项目构建时，一个称为**元对象编译器**（**moc**）的特殊工具将检查类的头文件，并生成一些必要的额外代码，以便信号和槽能够正常工作。
- en: Keep in mind that **moc** and all other Qt build tools do not edit the project
    files. Your C++ files are passed to the compiler without any changes. All special
    effects are achieved by generating separate C++ files and adding them to the compilation
    process.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，**moc**和所有其他Qt构建工具都不会编辑项目文件。你的C++文件在没有任何更改的情况下传递给编译器。所有特殊效果都是通过生成单独的C++文件并将它们添加到编译过程中来实现的。
- en: 'A signal can be created by declaring a class method in the `signals` section
    of the class declaration:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在类声明的`signals`部分声明一个类方法来创建一个信号：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, we don''t implement such a method; this will be done automatically
    by **moc**. We can send (`emit`) the signal by calling the method. There is a
    convention that a signal call should be preceded by the `emit` macro.  This macro
    has no effect (it''s actually a blank macro), but it helps us clarify our intent
    to emit the signal:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会实现这样的方法；这将由**moc**自动完成。我们可以通过调用方法来发送（发出）信号。有一个约定，信号调用应该由`emit`宏 precede。这个宏没有效果（它实际上是一个空宏），但它帮助我们阐明我们发出信号的意图：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You should only emit signals from within the class methods, as if it were a
    protected function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该只从类方法中发出信号，就像它是一个受保护的函数一样。
- en: Slots are class methods declared in the `private slots`, `protected slots`,
    or `public slots` section of the class declaration. Contrary to signals, slots
    need to be implemented. Qt will call the slot when a signal connected to it is
    emitted. The visibility of the slot (private, protected, or public) should be
    chosen using the same principles as for normal methods.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 槽是声明在类声明中的`private slots`、`protected slots`或`public slots`部分的类方法。与信号相反，槽需要实现。Qt将在连接到它的信号发出时调用槽。槽的可见性（私有、保护或公共）应使用与正常方法相同的原理来选择。
- en: 'The C++ standard only describes three types of sections of the class definition
    (`private`, `protected`, and `public`), so you may wonder how these special sections
    work. They are actually simple macros: the `signals`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准只描述了类定义中的三种类型部分（`private`、`protected`和`public`），因此您可能会想知道这些特殊部分是如何工作的。实际上，它们是简单的宏：`signals`
- en: macro expands to `public`, and `slots` is a blank macro. So, the compiler treats
    them as normal methods. These keywords are, however, used by **moc** to determine
    how to generate the extra code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 宏展开为`public`，而`slots`是一个空宏。因此，编译器将它们视为普通方法。然而，这些关键字由**moc**用于确定如何生成额外的代码。
- en: Connecting signals and slots
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接信号和槽
- en: 'Signals and slots can be connected and disconnected dynamically using the 
    `QObject::connect()` and `QObject::disconnect()` functions. A regular, signal-slot
    connection is defined by the following four attributes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 信号和槽可以使用`QObject::connect()`和`QObject::disconnect()`函数动态地连接和断开。常规的信号-槽连接由以下四个属性定义：
- en: An object that changes its state (sender)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变其状态的对象（发送者）
- en: A signal in the sender object
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送者对象中的信号
- en: An object that contains the function to be called (receiver)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含要调用的函数的对象（接收者）
- en: A slot in the receiver
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收者中的槽
- en: 'If you want to make the connection, you need to call the `QObject::connect` function
    and pass these four parameters to it. For example, the following code can be used
    to clear the input box whenever the button is clicked on:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想建立连接，您需要调用`QObject::connect`函数并将这四个参数传递给它。例如，以下代码可以在按钮被点击时清除输入框：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Signals and slots in this code are specified using a standard C++ feature called
    pointers to member functions. Such a pointer contains the name of the class and
    the name of the method (in our case, signal or slot) in that class. Qt Creator's
    code autocompletion will help you write connect statements. In particular, if
    you press *Ctrl* + *Space* after
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，信号和槽是通过称为成员函数指针的标准C++特性来指定的。这样的指针包含类的名称和该类中的方法名称（在我们的情况下，是信号或槽）。Qt Creator的代码自动补全将帮助您编写连接语句。特别是，如果您在按下*Ctrl*
    + *Space*之后
- en: '`connect(button, &`, it will insert the name of the class, and if you do that
    after `connect(button, &QPushButton::`, it will suggest one of the available signals
    (in another context, it would suggest all the existing methods of the class).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect(button, &`，它将插入类的名称，如果您在`connect(button, &QPushButton::`之后这样做，它将建议一个可用的信号（在另一个上下文中，它将建议类中所有现有的方法）。'
- en: 'Note that you can''t set the arguments of signals or slots when making a connection.
    Arguments of the source signal are always determined by the function that emits
    the signal. Arguments of the receiving slot (or signal) are always the same as
    the arguments of the source signal, with two exceptions:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在建立连接时，您不能设置信号或槽的参数。源信号的参数始终由发出信号的函数确定。接收槽（或信号）的参数始终与源信号的参数相同，有两个例外：
- en: If the receiving slot or signal has fewer arguments than the source signal,
    the remaining arguments are ignored. For example, if you want to use the  `valueChanged(int)` signal
    but don't care about the passed value, you can connect this signal to a slot without
    arguments.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果接收槽或信号的参数比源信号少，则忽略剩余的参数。例如，如果你想使用`valueChanged(int)`信号，但不在乎传递的值，你可以将此信号连接到一个不带参数的槽。
- en: If the types of the corresponding arguments are not the same, but an implicit
    conversion between them exists, that conversion is performed. This means that
    you can, for example, connect a signal carrying a `double` value with a slot taking
    an `int` parameter.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对应参数的类型不同，但存在它们之间的隐式转换，则执行该转换。这意味着你可以，例如，将携带`double`值的信号连接到一个接受`int`参数的槽。
- en: If the signal and the slot do not have compatible signatures, you will get a
    compile-time error.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果信号和槽没有兼容的签名，你将得到一个编译时错误。
- en: An existing connection is automatically destroyed after the sender or the receiver
    objects are deleted. Manual disconnection is rarely needed. The `connect()` function
    returns a connection handle that can be passed to `disconnect()`. Alternatively,
    you can call  `disconnect()` with the same arguments the `connect()` was called
    with to undo the connection.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送者或接收者对象被删除后，现有的连接将自动销毁。手动断开连接很少需要。`connect()`函数返回一个连接句柄，可以传递给`disconnect()`。或者，你可以使用与`connect()`相同的参数调用`disconnect()`来撤销连接。
- en: 'You don''t always need to declare a slot to perform a connection. It''s possible
    to connect a signal to a standalone function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你不总是需要声明一个槽来执行连接。可以将信号连接到一个独立的函数：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The function can also be a lambda expression, in which case it is possible
    to write the code directly in the `connect` statement:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以是lambda表达式，在这种情况下，可以在`connect`语句中直接编写代码：
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It can be useful if you want to invoke a slot with a fixed argument value that
    can''t be carried by a signal because it has less arguments. A solution is to
    invoke the slot from a lambda function (or a standalone function):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想调用一个具有固定参数值且无法由信号携带的槽，这可能很有用，因为它的参数较少。一种解决方案是从lambda函数（或独立函数）中调用该槽：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A function can even be replaced with a function object (functor). To do this,
    we create a class, for which we overload the call operator that is compatible
    with the signal that we wish to connect to, as shown in the following code snippet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 函数甚至可以被函数对象（functor）替代。为此，我们创建一个类，为它重载与我们要连接的信号兼容的调用操作符，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is often a nice way to execute a slot with an additional parameter that
    is not carried by the signal, as this is much cleaner than using a lambda expression.
    However, keep in mind that automatic disconnection will not happen when the object
    referenced in the lambda expression or the functor is deleted. This can lead to
    a use-after-free bug.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是一种执行带有信号未携带的额外参数的槽的好方法，因为这比使用lambda表达式要干净得多。然而，请注意，当lambda表达式或functor中引用的对象被删除时，不会发生自动断开连接。这可能导致使用后释放的漏洞。
- en: While it is actually possible to connect a signal to a method of a `QObject`-based
    class that is not a slot, doing this is not recommended. Declaring the method
    as a slot shows your intent better. Additionally, methods that are not slots are
    not available to Qt at runtime, which is required in some cases.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实际上可以将信号连接到一个不是槽的`QObject`类的方法，但这样做并不推荐。将方法声明为槽可以更好地表达你的意图。此外，非槽方法在运行时对Qt不可用，这在某些情况下是必需的。
- en: Old connect syntax
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旧连接语法
- en: 'Before Qt 5, the old connect syntax was the only option. It looks as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt 5之前，旧连接语法是唯一的选择。它看起来如下：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This statement establishes a connection between the signal of the `spinBox` object
    called `valueChanged` that carries an `int` parameter and a `setValue` slot in
    the `dial` object that accepts an `int` parameter. It is forbidden to put argument
    names or values in a
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句在`spinBox`对象的`valueChanged`信号与`dial`对象的`setValue`槽之间建立连接，该槽接受一个`int`参数。不允许在
- en: '`connect` statement. Qt Creator is usually able to suggest all possible inputs
    in this context if you press *Ctrl* + *Space* after `SIGNAL(` or `SLOT(`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect`语句。如果你在`SIGNAL(`或`SLOT(`之后按*Ctrl* + *Space*，Qt Creator通常会能够在此上下文中建议所有可能的输入。'
- en: 'While this syntax is still available, we discourage its wide use, because it
    has the following drawbacks:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然此语法仍然可用，但我们不建议广泛使用，因为它有以下缺点：
- en: If the signal or the slot is incorrectly referenced (for example, its name or
    argument types are incorrect) or if argument types of the signals and the slot
    are not compatible, there will be no compile-time error, only a runtime warning.
    The new syntax approach performs all the necessary checks at compile time.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果信号或槽引用不正确（例如，其名称或参数类型不正确）或如果信号和槽的参数类型不兼容，则不会在编译时出现错误，而只会出现运行时警告。新的语法方法在编译时执行所有必要的检查。
- en: The old syntax doesn't support casting argument values to another type (for
    example, connect a signal carrying a `double` value with a slot taking an  `int` parameter).
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧语法不支持将参数值强制转换为另一种类型（例如，将携带`double`值的信号连接到接受`int`参数的槽）。
- en: The old syntax doesn't support connecting a signal to a standalone function,
    a lambda expression, or a functor.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧语法不支持将信号连接到独立函数、lambda表达式或仿函数。
- en: 'The old syntax also uses macros and may look unclear to developers not familiar
    with Qt. It''s hard to say which syntax is easier to read (the old syntax displays
    argument types, while the new syntax displays the class name instead). However,
    the new syntax has a big disadvantage when using overloaded signals or slots.
    The only way to resolve the overloaded function type is to use an explicit cast:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 旧语法还使用宏，可能对不熟悉Qt的开发者来说不清楚。很难说哪种语法更容易阅读（旧语法显示参数类型，而新语法显示类名）。然而，当使用重载信号或槽时，新语法有一个很大的缺点。解决重载函数类型的唯一方法是通过显式转换：
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The old connect syntax includes argument types, so it doesn't have this issue.
    In this case, the old syntax may look more acceptable, but compile-time checks
    may still be considered more valuable than shorter code. In this book, we prefer
    the new syntax, but use the old syntax when working with overloaded methods for
    the sake of clarity.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 旧连接语法包括参数类型，因此没有这个问题。在这种情况下，旧语法可能看起来更可接受，但编译时检查可能仍然被认为比更短的代码更有价值。在这本书中，我们更喜欢新语法，但在处理重载方法时使用旧语法以提高清晰度。
- en: Signal and slot access specifiers
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号和槽访问指定符
- en: 'As mentioned earlier, you should only emit signals from the class that owns
    it or from its subclasses. However, if signals were really protected or private,
    you would not be able to connect to them using the pointer-to-member function
    syntax. To make such connections possible, signals are made public functions.
    This means that the compiler won''t stop you from calling the signal from outside.
    If you want to prevent such calls, you can declare `QPrivateSignal` as the last
    argument of the signal:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您应该只从拥有该信号或其子类发出信号。然而，如果信号确实是受保护的或私有的，您将无法使用成员指针函数语法连接到它们。为了使这种连接成为可能，信号被定义为公共函数。这意味着编译器不会阻止您从外部调用信号。如果您想防止此类调用，可以将`QPrivateSignal`声明为信号的最后一个参数：
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`QPrivateSignal` is a private struct created in each `QObject` subclass by
    the `Q_OBJECT` macro, so you can only create `QPrivateSignal` objects in the current
    class.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPrivateSignal`是由`Q_OBJECT`宏在每个`QObject`子类中创建的私有结构，因此您只能在当前类中创建`QPrivateSignal`对象。'
- en: Slots can be public, protected, or private, depending on how you want to restrict
    access to them. When using the pointer to a member function syntax for connection,
    you will only be able to create pointers to slots if you have access to them.
    It's also correct to call a slot directly from any other location as long as you
    have access to it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 槽可以是公共的、受保护的或私有的，具体取决于您想如何限制对它们的访问。当使用成员函数指针语法进行连接时，您只能创建对您有访问权限的槽的指针。只要您有访问权限，也可以从任何其他位置直接调用槽。
- en: That being said, Qt doesn't really support restricting access to signals and
    slots. Regardless of how a signal or a slot is declared, you can always access
    it using the old connect syntax. You can also call any signal or slot using the
    `QMetaObject::invokeMethod` method. While you can restrict direct C++ calls to
    reduce the possibility of errors, keep in mind that the users of your API still
    can access any signal or slot if they really want to.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，Qt实际上并不支持限制对信号和槽的访问。无论信号或槽如何声明，您都可以始终使用旧连接语法访问它。您还可以使用`QMetaObject::invokeMethod`方法调用任何信号或槽。虽然您可以限制直接C++调用以减少错误的可能性，但请记住，如果您的API用户真的想访问任何信号或槽，他们仍然可以这样做。
- en: There are some aspects of signals and slots that we have not covered here. We
    will discuss them later when we deal with multithreading (*Online Chapter, *[https://www.packtpub.com/sites/default/files/downloads/MiscellaneousandAdvancedConcepts.pdf](https://www.packtpub.com/sites/default/files/downloads/MiscellaneousandAdvancedConcepts.pdf)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于信号和槽的方面我们没有涉及。当我们处理多线程时，我们将在稍后讨论它们（[在线章节，*[https://www.packtpub.com/sites/default/files/downloads/MiscellaneousandAdvancedConcepts.pdf](https://www.packtpub.com/sites/default/files/downloads/MiscellaneousandAdvancedConcepts.pdf)））。
- en: Time for action – Receiving the button-click signal from the form
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 接收表单的按钮点击信号
- en: 'Open the `mainwindow.h` file and create a `private slots` section in the class
    declaration, then declare the `startNewGame()` private slot, as shown in the following
    code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `mainwindow.h` 文件，在类声明中创建一个 `private slots` 部分，然后声明 `startNewGame()` 私有槽，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To quickly implement a freshly declared method, we can ask Qt Creator to create
    the skeleton code for us by positioning the text cursor at the method declaration,
    pressing  *Alt *+* Enter* on the keyboard, and choosing Add definition in tictactoewidget.cpp from
    the popup.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速实现一个新声明的方法，我们可以让 Qt Creator 为我们创建代码框架，方法是在方法声明处放置文本光标，在键盘上按 `Alt` + `Enter`，然后从弹出菜单中选择在
    `tictactoewidget.cpp` 中添加定义。
- en: It also works the other way round. You can write the method body first and then
    position the cursor on the method signature, press *Alt* + *Enter*, and choose Add
    (...) declaration from the quick-fix menu. There are also various other context-dependent
    fixes that are available in Creator.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来也适用。您可以先编写方法体，然后将光标放在方法签名上，按 `Alt` + `Enter`，并从快速修复菜单中选择添加 (...) 声明。在 Creator
    中还有各种其他上下文相关的修复可用。
- en: 'Write the highlighted code in the implementation of this method:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法的实现中写下高亮显示的代码：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Add `#include <QDebug>` to the top section of the `mainwindow.cpp` file to make
    the `qDebug()` macro available.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `#include <QDebug>` 添加到 `mainwindow.cpp` 文件的最顶部，以便使 `qDebug()` 宏可用。
- en: 'Finally, add a connect statement to the constructor after the `setupUi()` call:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `setupUi()` 调用之后，在构造函数中添加一个连接语句：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the application and try clicking on the button. The `button clicked!` text
    should appear in the Application Output pane in the bottom part of Qt Creator''s
    window (if the pane isn''t activated, use the Application Output button in the
    bottom panel to open it):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并尝试点击按钮。在 Qt Creator 窗口的底部部分的应用程序输出面板中应该会显示 `button clicked!` 文本（如果面板未激活，请使用底部面板中的应用程序输出按钮打开它）：
- en: '![](img/f6122bdb-7985-435f-a2ca-4e2919caa3c0.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f6122bdb-7985-435f-a2ca-4e2919caa3c0.png)'
- en: What just happened?
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We created a new private slot in the `MainWindow` class and connected the `clicked()`
    signal of the Start new game button to the slot. When the user clicks on the button,
    Qt will call our slot, and the code we wrote inside it gets executed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `MainWindow` 类中创建了一个新的私有槽，并将启动新游戏按钮的 `clicked()` 信号连接到该槽。当用户点击按钮时，Qt 将调用我们的槽，并执行我们编写在其中的代码。
- en: Ensure that you put any operations with the form elements after the `setupUi()` 
    call. This function creates the elements, so
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将任何与表单元素相关的操作放在 `setupUi()` 调用之后。这个函数创建了元素，所以
- en: '`ui->startNewGame` will simply be uninitialized before `setupUi()` is called,
    and attempting to use it will result in undefined behavior.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `setupUi()` 之前，`ui->startNewGame` 将会被初始化，尝试使用它将导致未定义行为。
- en: '`qDebug() << ...` is a convenient way to print debug information to the `stderr`
    (standard error output) of the application process. It''s quite similar to the `std::cerr
    << ...` method available in the standard library, but it separates supplied values
    with spaces and appends a new line at the end.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`qDebug() << ...` 是将调试信息打印到应用程序进程的 `stderr`（标准错误输出）的便捷方式。它与标准库中可用的 `std::cerr
    << ...` 方法非常相似，但它使用空格分隔提供的值，并在末尾添加一个新行。'
- en: Putting debug outputs everywhere quickly becomes inconvenient. Luckily, Qt Creator
    has powerful integration with C++ debuggers, so you can use Debug mode to check
    whether some particular line is executing, see the current values of the local
    variables at that location, and so on. For example, try setting a break point
    at the line containing `qDebug()` by clicking on the space to the left of the
    line number (a red circle indicating the break point should appear). Click on
    the Start Debugging button (a green triangle with a bug at the bottom-left corner
    of Qt Creator), wait for the application to launch, and press the Start new game button.
    When the application enters the break point location, it will pause, and Qt Creator's
    window will be brought to the front. The yellow arrow over the break point circle
    will indicate the current step of the execution. You can use the buttons below
    the code editor to continue execution, stop, or execute the process in steps.
    Learning to use the debugger becomes very important when developing large applications.
    We will talk more about using the debugger later (*Online* *Chapter, *[https://www.packtpub.com/sites/default/files/downloads/MiscellaneousandAdvancedConcepts.pdf](https://www.packtpub.com/sites/default/files/downloads/MiscellaneousandAdvancedConcepts.pdf)).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 将调试输出放在任何地方很快就会变得不方便。幸运的是，Qt Creator 与 C++ 调试器有强大的集成，因此您可以使用调试模式来检查是否执行了某些特定的行，查看该位置的局部变量的当前值等。例如，尝试通过单击行号左侧的空间（一个表示断点的红色圆圈应该出现）来设置包含`qDebug()`的行的断点。单击“开始调试”按钮（Qt
    Creator左下角带有虫子的绿色三角形），等待应用程序启动，然后按“开始新游戏”按钮。当应用程序进入断点位置时，它将暂停，Qt Creator 的窗口将置于最前。断点圆圈上的黄色箭头将指示当前执行的步骤。您可以使用代码编辑器下方的按钮继续执行、停止或逐步执行过程。当开发大型应用程序时，学习使用调试器变得非常重要。我们将在稍后更多地讨论使用调试器（*在线*
    *章节，*[https://www.packtpub.com/sites/default/files/downloads/MiscellaneousandAdvancedConcepts.pdf](https://www.packtpub.com/sites/default/files/downloads/MiscellaneousandAdvancedConcepts.pdf)）。
- en: Automatic slot connection and its drawbacks
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动槽连接及其缺点
- en: Qt also offers an easier way to make a connection between signals of the form's
    elements and the slots of the class. You can right-click on the button in the
    central area of the form editor and select the Go to slot... option. You will
    be prompted to select one of the signals available in the button's class (`QPushButton`).
    After you select the `clicked()` signal, Qt Creator will automatically add a new `on_startNewGame_clicked` slot
    to our  `MainWindow` class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 还提供了一种更简单的方法来连接表单元素的信号和类的槽。您可以在表单编辑器的中央区域右键单击按钮，并选择“转到槽...”选项。您将被提示选择按钮类（`QPushButton`）中可用的信号之一。在选择`clicked()`信号后，Qt
    Creator 将自动为我们的`MainWindow`类添加一个新的`on_startNewGame_clicked`槽。
- en: The tricky part is that there is no `connect()` call that enforces the connection.
    How is the button's signal connected to this slot, then? The answer is Qt's automatic
    slot connection feature. When the constructor calls the `ui->setupUi(this)` function,
    it creates the widgets and other objects in the form and then calls the `QMetaObject::connectSlotsByName`
    method. This method looks at the list of slots existing in the widget class (in
    our case, `MainWindow`) and searches for ones that have their name in an `on_<object
    name>_<signal name>`
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 难以理解的部分是没有任何`connect()`调用强制连接。按钮的信号是如何连接到这个槽的呢？答案是 Qt 的自动槽连接功能。当构造函数调用`ui->setupUi(this)`函数时，它创建了表单中的小部件和其他对象，然后调用`QMetaObject::connectSlotsByName`方法。此方法查看小部件类（在我们的情况下，`MainWindow`）中存在的槽列表，并搜索名称为`on_<object
    name>_<signal name>`的槽。
- en: pattern, where `<object name>` is the `objectName` of an existing child widget
    and `<signal name>` is the name of one of this widget's signals. In our case,
    a button called `startNewGame` is a child widget of our widget, and it has a `clicked`
    signal, so this signal is automatically connected to an `on_startNewGame_clicked`
    slot.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 模式，其中`<object name>`是现有子小部件的`objectName`，`<signal name>`是此小部件的信号之一。在我们的例子中，一个名为`startNewGame`的按钮是我们小部件的子小部件，并且它有一个`clicked`信号，因此此信号自动连接到`on_startNewGame_clicked`槽。
- en: 'While this is a really convenient feature, it has many drawbacks:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个非常方便的功能，但它有很多缺点：
- en: It makes your application harder to maintain. If you rename or remove the form
    element, you have to update or remove the slot manually. If you forget to do that,
    the application will only produce a warning at runtime when the automatic connection
    fails. In a large application, especially when not all forms are instantiated
    at the start of the application, there is a significant risk that you will miss
    the warning and the application will not work as intended.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得你的应用程序更难维护。如果你重命名或删除表单元素，你必须手动更新或删除槽。如果你忘记这样做，当自动连接失败时，应用程序将在运行时仅产生警告。在一个大型应用程序中，尤其是在应用程序启动时并非所有表单都实例化的情况下，你可能会错过警告，并且应用程序将无法按预期工作。
- en: You have to use a specific name for the slot (for example,  `on_startNewGame_clicked()` instead
    of a clean-looking `startNewGame()`).
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须为槽指定一个特定的名称（例如，`on_startNewGame_clicked()`而不是看起来干净的`startNewGame()`）。
- en: Sometimes you want to connect signals from multiple objects to the same slot. Automatic
    slot connection doesn't provide a way to do this, and creating multiple slots
    just to call a single function will lead to unnecessary code bloat.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时你希望将多个对象的信号连接到同一个槽。自动槽连接不提供这样做的方法，仅为了调用单个函数而创建多个槽会导致不必要的代码膨胀。
- en: Automatic slot connection has a runtime cost, because it needs to examine the
    available children and slots and find the matching ones, but it's usually insignificant
    since it only runs when the form object is created.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动槽连接有运行时成本，因为它需要检查可用的子元素和槽位并找到匹配项，但由于它仅在表单对象创建时运行，因此通常不显著。
- en: The basic approach shown in the previous section is much more maintainable. Making
    an explicit `connect()` call with pointers to member functions will ensure that
    both signal and slot are specified properly. If you rename or remove the button,
    it will immediately result in a compilation error that is impossible to miss. You
    are also free to choose a meaningful name for the slot, so you can make it part
    of your public API, if desired.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个部分中展示的基本方法更具可维护性。通过使用指向成员函数的指针显式调用`connect()`，将确保信号和槽都正确指定。如果你重命名或删除按钮，它将立即导致无法忽略的编译错误。你也可以自由地为槽选择一个有意义的名称，这样你就可以根据需要将其作为你的公共API的一部分。
- en: Considering all this, we advise against using the automatic slot connection
    feature, as the convenience does not outweigh the drawbacks.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，我们建议不要使用自动槽连接功能，因为便利性并不超过其缺点。
- en: Time for action – Changing the texts on the labels from the code
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 从代码中更改标签上的文本
- en: 'Printing text to the console is not as impressive as changing the text in our
    form. We don''t have GUI for letting users enter their names yet, so we''ll hardcode
    some names for now. Let''s change the implementation of our slot to the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将文本打印到控制台不如更改表单中的文本那么令人印象深刻。我们还没有GUI让用户输入他们的名字，所以现在我们将硬编码一些名字。让我们将我们的槽的实现更改为以下内容：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, when you run the application and click on the button, the labels in the
    form will change. Let''s break down this code into pieces:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行应用程序并点击按钮时，表单中的标签将发生变化。让我们将此代码分解成几个部分：
- en: As mentioned earlier, the first label's object is accessible in our class as `ui->player1Name`
    and has the `QLabel *` type.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，第一个标签的对象在我们的类中可通过`ui->player1Name`访问，其类型为`QLabel *`。
- en: We're calling the `setText` method of the `QLabel` class. This is the setter
    of the `text` property of `QLabel` (the same property that we edited in the property
    editor of the Design mode). As per Qt's naming convention, getters should have
    the same name as the property itself, and setters should have a `set` prefix,
    followed by the property name. You can set the text cursor on `setText` and press
    *F1* to learn more about the property and its access functions.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在调用`QLabel`类的`setText`方法。这是`QLabel`的`text`属性的setter（与我们在设计模式属性编辑器中编辑的相同属性）。根据Qt的命名约定，获取器应该与属性本身具有相同的名称，而设置器应该有一个`set`前缀，后跟属性名称。你可以在`setText`上设置文本光标并按*F1*键了解更多关于属性及其访问函数的信息。
- en: The `tr()` function (which is short for "translate") is used to translate the
    text to the current UI language of the application. We will describe the translation
    infrastructure of Qt in [Chapter 6](ad89bd0a-2ed2-49a8-8701-18449629a1ee.xhtml),
    *Qt Core Essentials*. By default, this function returns the passed string unchanged,
    but it's a good habit to wrap any and all string literals that are displayed to
    the user in this function. Any user-visible text that you enter in the form editor
    is also subject to translation and is passed through a similar function automatically.
    Only strings that should not be affected by translation (for example, object names
    that are used as identifiers) should be created without the `tr()` function.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tr()`函数（其简称为“翻译”）用于将文本翻译为应用程序当前的用户界面语言。我们将在[第6章](ad89bd0a-2ed2-49a8-8701-18449629a1ee.xhtml)中描述Qt的翻译基础设施，*Qt核心基础*。默认情况下，此函数返回未更改的传递字符串，但将任何显示给用户的字符串字面量包装在此函数中是一个好习惯。在表单编辑器中输入的任何可见文本也受翻译影响，并自动通过类似函数传递。只有那些不应受翻译影响的字符串（例如，用作标识符的对象名称）才应不使用`tr()`函数创建。'
- en: Creating a widget for the tic-tac-toe board
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建井字棋游戏板小部件
- en: Let's move on to implementing the board. It should contain nine buttons that
    can display "X" or "O" and allow the players to make their moves. We could add
    the button directly to the empty widget of our form. However, the behavior of
    the board is fairly separate from the rest of the form, and it will have quite
    a bit of logic inside. Following the encapsulation principle, we prefer implementing
    the board as a separate widget class. Then, we'll replace the empty widget in
    our main window with the board widget we created.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续实现游戏板。它应该包含九个可以显示“X”或“O”并允许玩家进行移动的按钮。我们可以直接将按钮添加到表单的空小部件中。然而，游戏板的操作与其他表单的其余部分相对独立，并且其中将包含相当多的逻辑。遵循封装原则，我们更倾向于将游戏板实现为一个独立的小部件类。然后，我们将用我们创建的游戏板小部件替换主窗口中的空小部件。
- en: Choosing between designer forms and plain C++ classes
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在设计表单和纯C++类之间进行选择
- en: One way of creating a custom widget is by adding a Designer Form Class to the
    project. Designer Form Class is a template provided by Qt Creator. It consists
    of a C++ class that inherits `QWidget` (directly or indirectly) and a designer
    form (`.ui` file), tied together by some automatically generated code. Our `MainWindow` class
    also follows this template.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义小部件的一种方法是将设计表单类添加到项目中。设计表单类是Qt Creator提供的一个模板。它由一个继承自`QWidget`（直接或间接）的C++类和一个设计表单（`.ui`文件）组成，通过一些自动生成的代码连接在一起。我们的`MainWindow`类也遵循这个模板。
- en: However, if you try to use the visual form editor to create our tic-tac-toe
    board, you may find it quite inconvenient for this task. One problem is that you
    need to add nine identical buttons to the form manually. Another issue is accessing
    these buttons from the code when you need to make a signal connection or change
    the button's text. The `ui->objectName` approach is not applicable here because
    you can only access a concrete widget this way, so you'd have to resort to other
    means, such as the `findChild()` method that allows you to search for a child
    object by its name.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您尝试使用可视化表单编辑器来创建我们的井字棋游戏板，您可能会发现这个任务非常不方便。一个问题是需要手动将九个相同的按钮添加到表单中。另一个问题是，当您需要建立信号连接或更改按钮文本时，从代码中访问这些按钮。使用`ui->objectName`的方法不适用，因为您只能通过这种方式访问一个具体的控件，因此您将不得不求助于其他方法，例如允许您通过名称搜索子对象的`findChild()`方法。
- en: In this case, we prefer to add the buttons in the code, where we can make a
    loop, set up each button, and put them into an array for easy addressing. The
    process is pretty similar to how the designer forms operate, but we'll do it by
    hand. Of course, anything that the form editor can do is accessible through the
    API.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们更倾向于在代码中添加按钮，这样我们可以创建一个循环，设置每个按钮，并将它们放入数组中以方便引用。这个过程与设计表单的操作非常相似，但我们将通过手动方式完成。当然，任何表单编辑器能做的，都可以通过API访问。
- en: After you build the project, you can hold *Ctrl*and click on `ui_mainwindow.h` at
    the beginning of `mainwindow.cpp` to see the code that actually sets up our main
    window. You should not edit this file, because your changes will not be persistent.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建项目后，您可以在`mainwindow.cpp`的开头按住*Ctrl*并单击`ui_mainwindow.h`，以查看实际设置我们的主窗口的代码。您不应编辑此文件，因为您的更改将不会持久保存。
- en: Time for action – Creating a game board widget
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 创建游戏板小部件
- en: Locate the `tictactoe` folder in the project tree (it's the top-level entry
    corresponding to our whole project), open its context menu, and select Add New...
    Select C++ in the left list and C++ Class in the central list. Click on the Choose
    button, input `TicTacToeWidget` in the Class name field, and select QWidget in
    the Base class drop-down list. Click on Next and Finish. Qt Creator will create
    header and source files for our new class and add them to the project.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目树中定位`tictactoe`文件夹（它是对应于我们整个项目的顶层条目），打开其上下文菜单，并选择添加新... 在左侧列表中选择C++，在中央列表中选择C++类。点击选择按钮，在类名字段中输入`TicTacToeWidget`，并在基类下拉列表中选择QWidget。点击下一步和完成。Qt
    Creator将为我们的新类创建头文件和源文件，并将它们添加到项目中。
- en: 'Open the `tictactoewidget.h` file in Creator and update it by adding the highlighted
    code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在Creator中打开`tictactoewidget.h`文件，并通过添加高亮代码来更新它：
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our additions create a `QVector` object (a container similar to `std::vector`)
    that can hold pointers to instances of the `QPushButton` class, which is the most
    commonly used button class in Qt. We have to include the Qt header containing
    the `QPushButton` declaration. Qt Creator can help us do this quickly. Set the
    text cursor on `QPushButton`, press *Alt *+ *Enter*, and select Add #include <QPushButton>.
    The include directive will appear at the beginning of the file. As you may have
    noted, each Qt class is declared in the header file that is called exactly the
    same as the class itself.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的增加创建了一个`QVector`对象（一个类似于`std::vector`的容器），它可以存储指向`QPushButton`类实例的指针，这是Qt中最常用的按钮类。我们必须包含包含`QPushButton`声明的Qt头文件。Qt
    Creator可以帮助我们快速完成此操作。将文本光标放在`QPushButton`上，按*Alt* + *Enter*，并选择添加#include <QPushButton>。包含指令将出现在文件的开头。如您所注意到的，每个Qt类都在与该类名称完全相同的头文件中声明。
- en: From now on, this book will not remind you about adding the include directives
    to your source code—you will have to take care of this by yourself. This is really
    easy; just remember that to use a Qt class you need to include a file named after
    that class.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，这本书将不再提醒您添加包含指令到您的源代码中——您必须自己负责这一点。这真的很简单；只需记住，要使用Qt类，您需要包含一个以该类命名的文件。
- en: The next step is to create all the buttons and use a layout to manage their
    geometries. Switch to the `tictactoewidget.cpp` file and locate the constructor.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建所有按钮并使用布局来管理它们的几何形状。切换到`tictactoewidget.cpp`文件并定位构造函数。
- en: You can use the *F4* key to switch between the corresponding header and the
    source files. You can also use the *F2* key to navigate from the definition of
    a method to its implementation, and back.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用*F4*键在相应的头文件和源文件之间切换。您还可以使用*F2*键从方法定义导航到其实施，然后返回。
- en: 'First, let''s create a layout that will hold our buttons:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个将包含我们的按钮的布局：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'By passing the `this` pointer to the layout''s constructor, we attached the
    layout to our widget. Then, we can start adding buttons to the layout:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`this`指针传递给布局的构造函数，我们将布局附加到我们的小部件上。然后，我们可以开始向布局中添加按钮：
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code creates a loop over rows and columns of the board. In each iteration,
    it creates an instance of the `QPushButton` class. The content of each button
    is set to a single space so that it gets the correct initial size. Then, we add
    the button to the layout in `row` and `column`. At the end, we store the pointer
    to the button in the vector that was declared earlier. This lets us reference
    any of the buttons later on. They are stored in the vector in such an order that
    the first three buttons of the first row are stored first, then the buttons from
    the second row, and finally those from the last row.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个遍历棋盘行和列的循环。在每次迭代中，它创建一个`QPushButton`类的实例。每个按钮的内容被设置为单个空格，以便它获得正确的初始大小。然后，我们将按钮添加到`row`和`column`中的布局。最后，我们将按钮的指针存储在之前声明的向量中。这使得我们可以在以后引用任何按钮。它们在向量中的存储顺序是，首先存储第一行的前三个按钮，然后是第二行的按钮，最后是最后一行的按钮。
- en: This should be enough for testing the widget. Let's add it to our main window.
    Open the `mainwindow.ui` file. Invoke the context menu of the empty widget called
    `gameBoard` and choose Promote to. This allows us to **promote** a widget to another
    class, that is, substitute a widget in the form with an instance of another class.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于测试小部件应该是足够的。让我们将其添加到主窗口中。打开`mainwindow.ui`文件。调用名为`gameBoard`的空小部件的上下文菜单，并选择提升到。这允许我们将小部件提升到另一个类，即在表单中用另一个类的实例替换小部件。
- en: 'In our case, we will want to replace the empty widget with our game board.
    Select QWidget in the Base class name list, because our `TicTacToeWidget` is inherited
    from `QWidget`. Input `TicTacToeWidget` into the Promoted class name field and
    verify that the Header file field contains the correct name of the class''s header
    file, as illustrated:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们希望用我们的游戏板替换空的小部件。在基类名称列表中选择QWidget，因为我们的`TicTacToeWidget`是从`QWidget`继承的。在提升的类名称字段中输入`TicTacToeWidget`，并验证头文件字段是否包含类头文件的正确名称，如图所示：
- en: '![](img/8ed6868c-75a7-4316-b77e-29c93b01c7ab.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ed6868c-75a7-4316-b77e-29c93b01c7ab.png)'
- en: Then, click on the button labeled Add and then Promote, to close the dialog
    and confirm the promotion. You will not note any changes in the form, because
    the replacement only takes place at runtime (however, you will see the `TicTacToeWidget`
    class name next to `gameBoard` in the object tree).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击标有“添加”和“提升”的按钮，以关闭对话框并确认提升。你将不会在表单中注意到任何变化，因为替换仅在运行时发生（然而，你将在对象树中看到`gameBoard`旁边的`TicTacToeWidget`类名）。
- en: 'Run the application and check whether the game board appears in the main window:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并检查游戏板是否出现在主窗口中：
- en: '![](img/5464969a-5dfc-4cf3-af9b-f75a99f9dde0.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5464969a-5dfc-4cf3-af9b-f75a99f9dde0.png)'
- en: What just happened?
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Not all widget types are directly available in the form designer. Sometimes,
    we need to use widget classes that will only be created in the project that is
    being built. The simplest way to be able to put a custom widget on a form is to
    ask the designer to replace the class name of a standard widget with a custom
    name. By promoting an object to a different class, we saved a lot of work trying
    to otherwise fit our game board into the user interface.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的小部件类型都在表单设计器中直接可用。有时，我们需要使用仅在构建的项目中创建的小部件类。将自定义小部件放置在表单上的最简单方法就是要求设计者将标准小部件的类名替换为自定义名称。通过将对象提升到不同的类，我们节省了大量尝试将游戏板适配到用户界面的工作。
- en: 'You are now familiar with two ways of creating custom widgets: you can use
    the form editor or add widgets from the code. Both approaches are valuable. When
    creating a new widget class in your project, choose the most convenient way depending
    on your current task.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在熟悉了创建自定义小部件的两种方式：你可以使用表单编辑器或从代码中添加小部件。两种方法都很重要。在项目中创建新的小部件类时，根据当前任务选择最方便的方法。
- en: Automatic deletion of objects
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象的自动删除
- en: You might have noted that although we created a number of objects in the constructor
    using the `new` operator, we didn't destroy those objects anywhere (for example,
    in the destructor). This is because of the way the memory is managed by Qt. Qt
    doesn't do any garbage collecting (as C# or Java does), but it has this nice feature
    related to `QObject` parent–child hierarchies. The rule is that whenever a `QObject`
    instance is destroyed, it also deletes all of its children. This is another reason
    to set parents to the objects that we create—if we do this, we don't have to care
    about explicitly freeing any memory.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，尽管我们在构造函数中使用`new`运算符创建了许多对象，但我们没有在任何地方（例如，在析构函数中）销毁这些对象。这是因为Qt管理内存的方式。Qt不执行垃圾回收（如C#或Java所做的那样），但它有一个与`QObject`父子层次结构相关的良好特性。规则是，每当一个`QObject`实例被销毁时，它也会删除其所有子项。这也是为什么我们要将创建的对象设置为父对象的原因之一——如果我们这样做，我们就不必担心显式释放任何内存。
- en: Since all layouts and widgets inside our top-level widget (an instance of `MainWindow`
    class) are its direct or indirect children, they will all be deleted when the
    main window is destroyed. The `MainWindow` object is created in the `main()` function
    without the `new` keyword, so it will be deleted at the end of the application
    after `a.exec()` returns.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们顶级小部件（`MainWindow`类的实例）内部的所有布局和小部件都是其直接或间接的子项，因此当主窗口被销毁时，它们都将被删除。`MainWindow`对象在`main()`函数中创建，没有使用`new`关键字，因此将在`a.exec()`返回后，在应用程序结束时被删除。
- en: When working with widgets, it's pretty easy to verify that every object has
    a proper parent. You can assume that anything that is displayed inside the window
    is a direct or indirect child of that window. However, the parent–child relationship
    becomes less apparent when working with invisible objects, so you should always
    check that each object has a proper parent and therefore will be deleted at some
    point. For example, in our `TicTacToeWidget` class, the `gridLayout` object receives
    its parent through a constructor argument (`this`). The button objects are initially
    created without a parent, but the `addWidget()` function assigns a parent widget
    to them.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当与小部件一起工作时，很容易验证每个对象都有一个合适的父对象。你可以假设显示在窗口内的任何内容都是该窗口的直接或间接子对象。然而，当与不可见对象一起工作时，父子关系变得不那么明显，因此你应该始终检查每个对象是否有一个合适的父对象，并且因此将在某个时候被删除。例如，在我们的`TicTacToeWidget`类中，`gridLayout`对象通过构造函数参数（`this`）接收其父对象。按钮对象最初创建时没有父对象，但`addWidget()`函数将父小部件分配给它们。
- en: Time for action – Functionality of a tic-tac-toe board
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 费用板的功能
- en: We need to implement a function that will be called upon by clicking on any
    of the nine buttons on the board. It has to change the text of the button that
    was clicked on—either "X" or "O"—based on which player made the move. It then
    has to check whether the move resulted in the game being won by the player (or
    a draw if no more moves are possible), and if the game ended, it should emit an
    appropriate signal, informing the environment about the event.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现一个函数，该函数将在点击板上的任意一个九个按钮时被调用。它必须根据哪个玩家移动来更改被点击按钮的文本——要么是“X”要么是“O”。然后它必须检查这个移动是否导致玩家获胜（如果没有更多移动，则为平局），如果游戏结束，它应该发出适当的信号，通知环境有关事件。
- en: 'When the user clicks on a button, the `clicked()` signal is emitted. Connecting
    this signal to a custom slot lets us implement the mentioned functionality, but
    since the signal doesn''t carry any parameters, how do we tell which button caused
    the slot to be triggered? We could connect each button to a separate slot, but
    that''s an ugly solution. Fortunately, there are two ways of working around this
    problem. When a slot is invoked, a pointer to the object that caused the signal
    to be sent is accessible through a special method in `QObject`, called `sender()`.
    We can use that pointer to find out which of the nine buttons stored in the board
    list is the one that caused the signal to fire:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击按钮时，会发出`clicked()`信号。将此信号连接到自定义槽位使我们能够实现所提到的功能，但由于信号不携带任何参数，我们如何知道哪个按钮触发了槽位？我们可以将每个按钮连接到单独的槽位，但这是一种丑陋的解决方案。幸运的是，有两种方法可以解决这个问题。当槽位被调用时，可以通过`QObject`中的特殊方法`sender()`访问导致信号发出的对象的指针。我们可以使用该指针来确定存储在板列表中的九个按钮中哪一个导致了信号的触发：
- en: '[PRE20]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'While `sender()` is a useful call, we should try to avoid it in our own code
    as it breaks some principles of object-oriented programming. Moreover, there are
    situations where calling this function is not safe. A better way is to use a dedicated
    class called `QSignalMapper`, which lets us achieve a similar result without using
    `sender()` directly. Modify the constructor of `TicTacToeWidget`, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`sender()`是一个有用的调用，但我们应该尽量避免在我们的代码中使用它，因为它破坏了一些面向对象编程的原则。此外，有些情况下调用此函数是不安全的。更好的方法是使用一个专门的类`QSignalMapper`，它允许我们在不直接使用`sender()`的情况下实现类似的结果。按照以下方式修改`TicTacToeWidget`的构造函数：
- en: '[PRE21]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we first created an instance of `QSignalMapper` and passed a pointer to
    the board widget as its parent so that the mapper is deleted when the widget is
    deleted.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先创建了一个`QSignalMapper`的实例，并将指向板小部件的指针作为其父对象传递，这样当小部件被删除时，映射器也会被删除。
- en: Almost all subclasses of `QObject` can receive a pointer to the parent object
    in the constructor. In fact, our `MainWindow` and `TicTacToeWidget` classes can
    also do that, thanks to the code Qt Creator generated in their constructors. Following
    this rule in custom `QObject`-based classes is recommended. While the parent argument
    is often optional, it's a good idea to pass it when possible, because objects
    will be automatically deleted when the parent is deleted. However, there are a
    few cases where this is redundant, for example, when you add a widget to a layout,
    the layout will automatically set the parent widget for it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有`QObject`的子类都可以在构造函数中接收父对象的指针。实际上，我们的`MainWindow`和`TicTacToeWidget`类也可以这样做，这要归功于Qt
    Creator在它们的构造函数中生成的代码。在自定义基于`QObject`的类中遵循此规则是推荐的。虽然父参数通常是可选的，但在可能的情况下传递它是好主意，因为当父对象被删除时，对象将被自动删除。然而，有一些情况下这是多余的，例如，当你将小部件添加到布局中时，布局将自动设置父小部件。
- en: Then, when we create buttons, we "teach" the mapper that each of the buttons
    has a number associated with it—the first button will have the number `0`, the
    second one will be bound to the number `1`, and so on. By connecting the `clicked()`
    signal from the button to the mapper's `map()` slot, we tell the mapper to process
    that signal. When the mapper receives the signal from any of the buttons, it will
    find the mapping of the sender of the signal and emit another signal—`mapped()`—with
    the mapped number as its parameter. This allows us to connect to that signal with
    a new slot (`handleButtonClick()`) that takes the index of the button in the board
    list.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们创建按钮时，我们“教”映射器每个按钮都有一个与之关联的数字——第一个按钮将具有数字`0`，第二个按钮将绑定到数字`1`，依此类推。通过将按钮的`clicked()`信号连接到映射器的`map()`槽，我们告诉映射器处理该信号。当映射器从任何按钮接收到信号时，它将找到信号发送者的映射，并发出另一个信号——`mapped()`——其参数为映射的数字。这允许我们通过一个新的槽（`handleButtonClick()`）连接到该信号，该槽接受按钮在板列表中的索引。
- en: 'Before we create and implement the slot, we need to create a useful enum type
    and a few helper methods. First, add the following code to the public section
    of the class declaration in the `tictactoewidget.h` file:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建和实现槽之前，我们需要创建一个有用的枚举类型和一些辅助方法。首先，将以下代码添加到`tictactoewidget.h`文件中的类声明的公共部分：
- en: '[PRE22]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This enum lets us specify information about players in the game. The `Q_ENUM`
    macro will make Qt recognize the enum (for example, it will allow you to pass
    the values of this type to `qDebug()` and also make serialization easier). Generally,
    it's a good idea to use `Q_ENUM` for any enum in a `QObject`-based class.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个枚举让我们可以指定有关游戏中玩家的信息。`Q_ENUM`宏将使Qt识别枚举（例如，它将允许你将此类型的值传递给`qDebug()`，并使序列化更容易）。通常，在基于`QObject`的类中使用`Q_ENUM`是一个好主意。
- en: 'We can use the `Player` enum immediately to mark whose move it is now. To do
    so, add a private field to the class:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即使用`Player`枚举来标记现在是哪个玩家的回合。为此，向类中添加一个私有字段：
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Don''t forget to give the new field an initial value in the constructor:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在构造函数中为新字段提供一个初始值：
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, add the two public methods to manipulate the value of this field:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加两个公共方法来操作该字段的值：
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last method emits a signal, so we have to add the signal declaration to
    the class definition along with another signal that we will use:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法发出一个信号，因此我们必须将信号声明添加到类定义中，以及我们将使用的另一个信号：
- en: '[PRE26]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We only emit the `currentPlayerChanged` signal when the current player really
    changes. You always have to pay attention that you don't emit a "changed" signal
    when you set a value to a field to the same value that it had before the function
    was called. Users of your classes expect that if a signal is called changed, it
    is emitted when the value really changes. Otherwise, this can lead to an infinite
    loop in signal emissions if you have two objects that connect their value setters
    to the other object's changed signal.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只在当前玩家确实改变时发出`currentPlayerChanged`信号。你总是要注意，当你将值设置为一个字段，并且该值与函数调用之前该字段的值相同时，不要发出“已更改”信号。你的类的用户期望如果调用“已更改”信号，则只有在值真正更改时才发出。否则，如果你有两个对象，它们将它们的值设置器连接到另一个对象的更改信号，这可能导致信号发射中的无限循环。
- en: 'Now it is time to implement the slot itself. First, declare it in the header
    file:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现槽本身了。首先，在头文件中声明它：
- en: '[PRE27]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Use  *Alt *+ *Enter* to quickly generate a definition for the new method, as
    we did earlier.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Alt*+*Enter*快速生成新方法的定义，就像我们之前做的那样。
- en: 'When any of the buttons is pressed, the `handleButtonClick()` slot will be
    called. The index of the button clicked on will be received as the argument. We
    can now implement the slot in the `.cpp` file:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下任意按钮时，将调用`handleButtonClick()`槽函数。点击的按钮索引将作为参数接收。现在我们可以在`.cpp`文件中实现这个槽函数：
- en: '[PRE28]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we first retrieve a pointer to the button based on its index. Then, we
    check whether the button contains an empty space—if not, then it's already occupied,
    so we return from the method so that the player can pick another field in the
    board. Next, we set the current player's mark on the button. Then, we check whether
    the player has won the game. If the game didn't end, we switch the current player
    and return; otherwise, we emit a `gameOver()` signal, telling our environment
    who won the game. The `checkWinCondition()` method returns `Player1`, `Player2`,
    or `Draw` if the game has ended, and `Invalid` otherwise. We will not show the
    implementation of this method here, as it is quite lengthy. Try implementing it
    on your own, and if you encounter problems, you can see the solution in the code
    bundle that accompanies this book.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先根据索引检索按钮的指针。然后，我们检查按钮是否包含空格——如果没有，那么它已经被占用，所以我们从方法中返回，让玩家可以在棋盘上选择另一个字段。接下来，我们在按钮上设置当前玩家的标记。然后，我们检查玩家是否赢得了游戏。如果游戏没有结束，我们切换当前玩家并返回；否则，我们发出一个`gameOver()`信号，告诉我们的环境谁赢得了游戏。`checkWinCondition()`方法在游戏结束时返回`Player1`、`Player2`或`Draw`，否则返回`Invalid`。我们不会在这里展示这个方法的实现，因为它相当长。尝试自己实现它，如果遇到问题，你可以在本书附带的代码包中查看解决方案。
- en: 'The last thing we need to do in this class is to add another public method
    for starting a new game. It will clear the board and set the current player:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们最后需要做的是添加另一个公共方法来启动新游戏。这个方法将清除棋盘并设置当前玩家：
- en: '[PRE29]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we only need to call this method in the `MainWindow::startNewGame` method:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要在`MainWindow::startNewGame`方法中调用这个方法：
- en: '[PRE30]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that `ui->gameBoard` actually has a `TicTacToeWidget *` type, and we can
    call its methods even though the form editor doesn't know anything specific about
    our custom class. This is the result of the *promoting* that we did earlier.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ui->gameBoard`实际上有一个`TicTacToeWidget *`类型，我们可以调用它的方法，即使表单编辑器对我们的自定义类没有任何具体了解。这是我们在之前所做的*提升*的结果。
- en: It's time to see how all this works together! Run the application, click on
    the Start new game button, and you should be able to play some tic-tac-toe.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看这一切是如何协同工作的了！运行应用程序，点击“开始新游戏”按钮，你应该能够玩一些井字棋。
- en: Time for action – Reacting to the game board's signals
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 对游戏板信号的响应
- en: While writing a turn-based board game, it is a good idea to always clearly mark
    whose turn it is now to make a move. We will do this by marking the moving player's
    name in bold. There is already a signal in the board class that tells us that
    the current player has changed, which we can react to update the labels.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写回合制棋盘游戏时，始终清楚地标记现在是哪个玩家的回合进行移动是一个好主意。我们将通过在粗体中标记移动玩家的名字来实现这一点。棋盘类中已经有一个信号告诉我们当前玩家已经改变，我们可以对此做出反应来更新标签。
- en: 'We need to connect the board''s `currentPlayerChanged` signal to a new slot
    in the `MainWindow` class. Let''s add appropriate code into the `MainWindow` constructor:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将棋盘的`currentPlayerChanged`信号连接到`MainWindow`类中的一个新的槽函数。让我们在`MainWindow`构造函数中添加适当的代码：
- en: '[PRE31]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, for the slot itself, declare the following methods in the `MainWindow` class:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于槽函数本身，在`MainWindow`类中声明以下方法：
- en: '[PRE32]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now implement them using the following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按照以下代码实现它们：
- en: '[PRE33]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: What just happened?
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: '`QWidget` (and, by extension, any widget class) has a `font` property that
    determines the properties of the font this widget uses. This property has the `QFont`
    type. We can''t just write `label->font()->setBold(isBold);`, because `font()`
    returns a const reference, so we have to make a copy of the `QFont` object. That
    copy has no connection to the label, so we need to call `label->setFont(f)` to
    apply our changes. To avoid repetition of this procedure, we created a helper
    function, called `setLabelBold`.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`QWidget`（以及通过扩展，任何小部件类）有一个`font`属性，它决定了这个小部件使用的字体属性。这个属性具有`QFont`类型。我们不能简单地写`label->font()->setBold(isBold);`，因为`font()`返回一个const引用，所以我们必须复制`QFont`对象。这个副本与标签没有连接，因此我们需要调用`label->setFont(f)`来应用我们的更改。为了避免重复这个程序，我们创建了一个辅助函数，称为`setLabelBold`。'
- en: 'The last thing that needs to be done is to handle the situation when the game
    ends. Connect the `gameOver()` signal from the board to a new slot in the main
    window class. Implement the slot as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 需要完成最后一件事情是处理游戏结束的情况。将来自棋盘的`gameOver()`信号连接到主窗口类中的一个新槽。如下所示实现该槽：
- en: '[PRE34]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This code checks who won the game, assembles the message (we will learn more
    about `QString` in [Chapter 6](ad89bd0a-2ed2-49a8-8701-18449629a1ee.xhtml), *Qt
    Core Essentials*), and shows it using a static method `QMessageBox::information()`
    that shows a modal dialog containing the message and a button that allows us to
    close the dialog.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码检查谁赢得了游戏，组装消息（我们将在[第6章](ad89bd0a-2ed2-49a8-8701-18449629a1ee.xhtml)，*Qt核心基础*)，并使用静态方法`QMessageBox::information()`显示包含消息和允许我们关闭对话框的按钮的模态对话框。
- en: Run the game and check that it now highlights the current player and shows the
    message when the game ends.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并检查它现在是否突出显示了当前玩家，并在游戏结束时显示消息。
- en: Advanced form editor usage
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级表单编辑器使用
- en: Now it's time to give the players a way to input their names. We will do that
    by adding a game configuration dialog that will appear when starting a new game.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候给玩家提供一个输入他们名字的方法了。我们将通过添加一个在开始新游戏时出现的游戏配置对话框来实现这一点。
- en: Time for action – Designing the game configuration dialog
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 设计游戏配置对话框
- en: 'First, select Add New... in the context menu of the tictactoe project and choose
    to create a new Qt Designer Form Class, as shown in the following screenshot:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`tictactoe`项目的上下文菜单中选择“添加新...”，然后选择创建一个新的Qt Designer表单类，如图所示：
- en: '![](img/bdc07682-129e-4dde-8333-1f0d9c9d9814.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bdc07682-129e-4dde-8333-1f0d9c9d9814.png)'
- en: 'In the window that appears, choose Dialog with Buttons Bottom:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现的窗口中，选择“底部按钮对话框”：
- en: '![](img/ce1d80a0-cc52-43b7-8578-c3f657a15be8.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ce1d80a0-cc52-43b7-8578-c3f657a15be8.png)'
- en: Adjust the class name to `ConfigurationDialog`, leave the rest of the settings
    at their default values, and complete the wizard. The files that appear in the
    project (`.cpp`, `.h`, and `.ui`) are very similar to the files generated for
    the `MainWindow` class when we created our project. The only difference is that
    `MainWindow` uses `QMainWindow` as its base class, and `ConfigurationDialog` uses
    `QDialog`. Also, a `MainWindow` instance is created in the `main` function, so
    it shows when the application is started, while we'll need to create a `ConfigurationDialog`
    instance somewhere else in the code. `QDialog` implements behavior that is common
    for dialogs; in addition to the main content, it displays one or multiple buttons.
    When the dialog is selected, the user can interact with the dialog and then press
    one of the buttons. After this, the dialog is usually destroyed. `QDialog` has
    a convenient `exec()` method that doesn't return until the user makes a choice,
    and then it returns information about the pressed button. We will see that in
    action after we finish creating the dialog.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将类名调整为`ConfigurationDialog`，将其他设置保留为默认值，并完成向导。项目中出现的文件（`.cpp`、`.h`和`.ui`）与我们创建项目时为`MainWindow`类生成的文件非常相似。唯一的区别是`MainWindow`使用`QMainWindow`作为其基类，而`ConfigurationDialog`使用`QDialog`。此外，在`main`函数中创建了一个`MainWindow`实例，因此当应用程序启动时它就会显示，而我们需要在代码的其他地方创建一个`ConfigurationDialog`实例。`QDialog`实现了对话框的常见行为；除了主要内容外，它还显示一个或多个按钮。当对话框被选中时，用户可以与对话框交互，然后按下其中一个按钮。之后，对话框通常会被销毁。`QDialog`有一个方便的`exec()`方法，它不会返回直到用户做出选择，然后它返回有关按下的按钮的信息。我们将在创建对话框后看到这一点。
- en: 'Drag and drop two labels and two line edits on the form, position them roughly
    in a grid, double-click on each of the labels, and adjust their captions to receive
    a result similar to the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个标签和两个行编辑拖放到表单上，将它们大致放置在一个网格中，双击每个标签，并调整它们的标题以获得以下类似的结果：
- en: '![](img/eb639bb0-adb9-435b-a282-71a731156d62.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb639bb0-adb9-435b-a282-71a731156d62.png)'
- en: Change the `objectName` property of the line edits to `player1Name` and `player2Name`.
    Then, click on some empty space in the form and choose the Layout in a grid entry
    in the upper toolbar. You should see the widgets snap into place—that's because
    you have just applied a layout to the form. Open the Tools menu, go to the Form
    Editor submenu, and choose the Preview entry to preview the form.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 将行编辑的`objectName`属性更改为`player1Name`和`player2Name`。然后，在表单中点击一些空白区域，并在上工具栏中选择布局中的网格选项。你应该会看到小部件自动对齐——这是因为你刚刚为表单应用了一个布局。打开工具菜单，转到表单编辑器子菜单，并选择预览选项来预览表单。
- en: Accelerators and label buddies
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加速器和标签伙伴
- en: 'Now, we will focus on giving the dialog some more polish. The first thing we
    will do is add accelerators to our widgets. These are keyboard shortcuts that,
    when activated, cause particular widgets to gain keyboard focus or perform a predetermined
    action (for example, toggle a checkbox or push a button). Accelerators are usually
    marked by underlining them, as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将专注于给对话框添加更多润色。我们首先将要做的是为我们的小部件添加加速器。这些是键盘快捷键，当激活时，会导致特定的小部件获得键盘焦点或执行预定的动作（例如，切换复选框或按下按钮）。加速器通常通过以下方式标记：下划线。
- en: '![](img/819ca76d-6b77-4915-ac24-28a12dd42bd1.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/819ca76d-6b77-4915-ac24-28a12dd42bd1.png)'
- en: We will set accelerators to our line edits so that when the user activates an
    accelerator for the first field, it will gain focus. Through this, we can enter
    the name of the first player, and, similarly, when the accelerator for the second
    line edit is triggered, we can start typing in the name for the second player.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的行编辑设置加速器，这样当用户激活第一个字段的加速器时，它将获得焦点。通过这种方式，我们可以输入第一个玩家的名字，同样地，当第二个行编辑的加速器被触发时，我们可以开始输入第二个玩家的名字。
- en: Start by selecting the first label on the left-hand side of the first line edit.
    Press *F2* and change the text to `Player &A Name:`. The `&` character marks the
    character directly after it as an accelerator for the widget. Accelerators may
    not work with digits on some platforms, so we decided to use a letter instead. Similarly,
    rename the second label to `Player &B Name:`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，选择第一个行编辑左侧的第一行标签。按下 *F2* 并将文本更改为 `Player &A Name:`。和号字符（`&`）标记了其后的字符作为小部件的加速器。在某些平台上，加速器可能无法与数字一起工作，所以我们决定使用字母。同样，将第二个标签重命名为
    `Player &B Name:`。
- en: For widgets that are composed of both text and the actual functionality (for
    example, a button), this is enough to make accelerators work. However, since `QLineEdit`
    does not have any text associated with it, we have to use a separate widget for
    that. This is why we have set the accelerator on the label. Now we need to associate
    the label with the line edit so that the activation of the label's accelerator
    will forward it to the widget of our choice. This is done by setting a so-called
    **buddy** for the label. You can do this in code using the `setBuddy` method of
    the `QLabel` class or using Creator's form designer. Since we're already in the
    Design mode, we'll use the latter approach. For that, we need to activate a dedicated
    mode in the form designer.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于由文本和实际功能（例如，按钮）组成的小部件，这足以使加速器工作。然而，由于 `QLineEdit` 没有任何与之关联的文本，我们必须使用一个单独的小部件。这就是为什么我们在标签上设置了加速器。现在我们需要将标签与行编辑关联起来，以便标签加速器的激活可以将其转发到我们选择的小部件。这是通过为标签设置所谓的
    **伙伴** 来实现的。你可以使用 `QLabel` 类的 `setBuddy` 方法在代码中这样做，或者使用创建者的表单设计器。由于我们已经在设计模式中，我们将使用后一种方法。为此，我们需要在表单设计器中激活一个专用模式。
- en: Look at the upper part of Creator's window; directly above the form, you will
    find a toolbar containing a couple of icons. Click on the one labeled Edit buddies ![](img/bd8d678d-e636-412f-9615-94b0a118a51f.png).
    Now, move the mouse cursor over the label, press the mouse button, and drag from
    the label toward the line edit. When you drag the label over the line edit, you'll
    see a graphical visualization of a connection being set between the label and
    the line edit. If you release the button now, the association will be made permanent.
    You should note that when such an association is made, the ampersand character
    (`&`) vanishes from the label, and the character behind it gets an underscore.
    Repeat this for the other label and corresponding line edit. Click on the Edit
    widgets ![](img/20601812-6569-4f11-bf91-8da1075bde0f.png) button above the form to
    return the form editor to the default mode. Now, you can preview the form again
    and check whether accelerators work as expected; pressing *Alt* + *A* and *Alt*
    + *B* should set the text cursor to the first and second text field, respectively.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 查看创建者窗口的上部；在表单上方，你会找到一个包含几个图标的工具栏。点击标有“编辑好友”的图标！[](img/bd8d678d-e636-412f-9615-94b0a118a51f.png)。现在，将鼠标光标移至标签上，按下鼠标按钮，并从标签拖动到行编辑。当你将标签拖动到行编辑上时，你会看到一个图形化的连接设置过程，连接标签和行编辑。如果你现在释放按钮，这个关联将会被永久建立。你应该注意，当这种关联建立后，和号字符（`&`）将从标签中消失，并且它后面的字符会得到一个下划线。重复此过程为其他标签和相应的行编辑设置。点击表单上方的“编辑小部件”按钮！[](img/20601812-6569-4f11-bf91-8da1075bde0f.png)，以将表单编辑器返回到默认模式。现在，你可以再次预览表单，并检查加速器是否按预期工作；按下
    *Alt* + *A* 和 *Alt* + *B* 应该分别将文本光标设置到第一个和第二个文本字段。
- en: The tab order
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签顺序
- en: While you're previewing the form, you can check another aspect of the UI design.
    Note which line edit receives the focus when the form is open. There is a chance
    that the second line edit will be activated first. To check and modify the order
    of focus, close the preview and switch to the tab order editing mode by clicking
    on the icon called Edit Tab Order ![](img/460bf650-c6b2-4fd7-9aee-5964deaa583d.png)
    in the toolbar.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在预览表单时，可以检查UI设计的另一个方面。注意当表单打开时，哪一行编辑框会获得焦点。有可能第二行编辑框会首先被激活。要检查和修改焦点顺序，请关闭预览，并通过点击工具栏中的图标“编辑标签顺序”切换到标签顺序编辑模式！![编辑标签顺序](img/460bf650-c6b2-4fd7-9aee-5964deaa583d.png)。
- en: 'This mode associates a box with a number to each focusable widget. By clicking
    on the rectangle in the order you wish the widgets to gain focus, you can reorder
    values, thus re-ordering focus. Now make it so that the order is as shown here:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式将一个带有数字的框与每个可聚焦的小部件关联起来。通过按照你希望小部件获得焦点的顺序点击矩形，你可以重新排序值，从而重新排序焦点。现在将其设置为如下所示：
- en: '![](img/3acd881b-1e37-4f41-8996-68deac128a55.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![对话框公共接口](img/3acd881b-1e37-4f41-8996-68deac128a55.png)'
- en: Our form only has two widgets that can receive focus (except for the dialog's
    buttons, but their tab order is managed automatically). If you create a form with
    multiple controls, there is a good chance that when you press the *Tab* key repeatedly,
    the focus will start jumping back and forth between buttons and line edits instead
    of a linear progress from top to bottom (which is an intuitive order for this
    particular dialog). You can use this mode to correct the tab order.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的形式只有两个可以接收焦点的小部件（除了对话框的按钮，但它们的标签顺序是自动管理的）。如果你创建了一个包含多个控件的形式，那么当你反复按*Tab*键时，焦点可能会在按钮和行编辑之间来回跳跃，而不是从上到下的线性进度（这对于这个特定的对话框来说是一个直观的顺序）。你可以使用此模式来纠正标签顺序。
- en: Enter the preview again and check whether the focus changes according to what
    you've set.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 再次进入预览并检查焦点是否根据你的设置发生变化。
- en: When deciding about the tab order, it is good to consider which fields in the
    dialog are mandatory and which are optional. It is a good idea to allow the user
    to tab through all the mandatory fields first, then to the dialog confirmation
    button (for example, one that says OK or Accept), and then cycle through all the
    optional fields. Thanks to this, the user will be able to quickly fill all the
    mandatory fields and accept the dialog without the need to cycle through all the
    optional fields that the user wants to leave as their default values.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定标签顺序时，考虑对话框中哪些字段是必填的，哪些是可选的，是个好主意。允许用户首先遍历所有必填字段，然后到对话框确认按钮（例如，一个写着OK或Accept的按钮），然后遍历所有可选字段是个好主意。这样，用户就可以快速填写所有必填字段并接受对话框，而无需遍历所有用户希望保留为默认值的可选字段。
- en: Time for action – Public interface of the dialog
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 对话框的公共接口
- en: The next thing to do is to allow to store and read player names from outside
    the dialog—since the `ui` component is private, there is no access to it from
    outside the class code. This is a common situation and one that Qt is also compliant
    with. Each data field in almost every Qt class is private and may contain accessors
    (a getter and optionally a setter), which are public methods that allow us to
    read and store values for data fields. Our dialog has two such fields—the names
    for the two players.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是允许从对话框外部存储和读取玩家名称——由于`ui`组件是私有的，因此无法从类代码外部访问它。这是一个常见的情况，Qt也符合这种情况。几乎每个Qt类中的每个数据字段都是私有的，可能包含访问器（一个获取器和可选的设置器），这些是公共方法，允许我们读取和存储数据字段的值。我们的对话框有两个这样的字段——两个玩家的名称。
- en: 'Names of setter methods in Qt are usually started with `set`, followed by the
    name of the property with the first letter converted to uppercase. In our situation,
    the two setters will be called `setPlayer1Name` and `setPlayer2Name`, and they
    will both accept `QString` and return `void`. Declare them in the class header,
    as shown in the following code snippet:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Qt中设置器方法的名称通常以`set`开头，后跟属性名称，首字母转换为大写。在我们的情况下，两个设置器将被称为`setPlayer1Name`和`setPlayer2Name`，它们都将接受`QString`并返回`void`。在类头文件中声明它们，如下面的代码片段所示：
- en: '[PRE35]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Implement their bodies in the `.cpp` file:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.cpp`文件中实现它们的主体：
- en: '[PRE36]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Getter methods in Qt are usually called the same as the property that they
    are related to—`player1Name` and `player2Name`. Put the following code in the
    header file:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Qt中的获取器方法通常与它们相关的属性同名——`player1Name`和`player2Name`。将以下代码放入头文件中：
- en: '[PRE37]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Put the following code in the implementation file:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码放入实现文件：
- en: '[PRE38]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Our dialog is now ready. Let''s use it in the `MainWindow::startNewGame` function
    to request player names before starting the game:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的对话框现在已准备就绪。让我们在 `MainWindow::startNewGame` 函数中使用它，在开始游戏之前请求玩家名称：
- en: '[PRE39]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this slot, we create the settings dialog and show it to the user, forcing
    them to enter player names. The `exec()` function doesn't return until the dialog
    is accepted or cancelled. If the dialog was canceled, we abandon the creation
    of a new game. Otherwise, we ask the dialog for player names and set them on appropriate
    labels. Finally, we initialize the board so that users can play the game. The
    dialog object was created without the `new` keyword, so it will be deleted immediately
    after this.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个槽中，我们创建设置对话框并展示给用户，强迫他们输入玩家名称。`exec()` 函数只有在对话框被接受或取消时才会返回。如果对话框被取消，我们将放弃创建新游戏。否则，我们向对话框请求玩家名称并将它们设置在适当的标签上。最后，我们初始化棋盘，以便用户可以玩游戏。对话框对象是在没有使用
    `new` 关键字的情况下创建的，所以它将在之后立即被删除。
- en: Now you can run the application and see how the configuration dialog works.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行应用程序并查看配置对话框是如何工作的。
- en: Polishing the application
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序抛光
- en: We have implemented all the important functionalities of our game, and now we
    will start improving it by exploring other Qt features.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了我们游戏的所有重要功能，现在我们将通过探索其他 Qt 功能来开始改进它。
- en: Size policies
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尺寸策略
- en: 'If you change the height of the main window of our game, you will note that
    different widgets are resized in a different way. In particular, buttons retain
    their original height, and labels gain empty fields to the top and bottom of the
    text:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你改变我们游戏主窗口的高度，你会注意到不同的部件以不同的方式调整大小。特别是，按钮保持其原始高度，而标签在文本的顶部和底部获得空白区域：
- en: '![](img/71d369a8-8ea3-4326-a746-134750868752.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71d369a8-8ea3-4326-a746-134750868752.png)'
- en: 'This is because each widget has a property called `sizePolicy`, which decides
    how a widget is to be resized by a layout. You can set separate size policies
    for horizontal and vertical directions. A button has a vertical size policy of
    `Fixed` by default, which means that the height of the widget will not change
    from the default height regardless of how much space there is available. A label
    has a `Preferred` size policy by default. The following are the available size
    policies:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为每个小部件都有一个名为 `sizePolicy` 的属性，它决定了布局如何调整小部件的大小。您可以分别为水平和垂直方向设置不同的尺寸策略。按钮默认的垂直尺寸策略为
    `Fixed`，这意味着无论有多少可用空间，小部件的高度都不会从默认高度改变。标签默认的尺寸策略为 `Preferred`。以下是可以用的尺寸策略：
- en: '`Ignored`: In this, the default size of the widget is ignored and the widget
    can freely grow and shrink'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ignored`：在这种情况下，小部件的默认大小被忽略，小部件可以自由地增长和缩小'
- en: '`Fixed`: In this, the default size is the only allowed size of the widget'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fixed`：在这种情况下，默认大小是小部件唯一允许的大小'
- en: '`Preferred`: In this, the default size is the desired size, but both smaller
    and bigger sizes are acceptable'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Preferred`：在这种情况下，默认大小是期望的大小，但较小和较大的尺寸都是可接受的'
- en: '`Minimum`: In this, the default size is the smallest acceptable size for the
    widget, but the widget can be made larger without hurting its functionality'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Minimum`：在这种情况下，默认大小是小部件可以接受的最小大小，但小部件可以被放大而不会损害其功能'
- en: '`Maximum`: In this, the default size is the largest size of the widget, and
    the widget can be shrunk (even to nothing) without hurting its functionality'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Maximum`：在这种情况下，默认大小是小部件的最大大小，小部件可以被缩小（甚至缩小到无），而不会损害其功能'
- en: '`Expanding`: In this, the default size is the desired size; a smaller size
    (even zero) is acceptable, but the widget is able to increase its usefulness when
    more and more space is assigned to it'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Expanding`：在这种情况下，默认大小是期望的大小；较小的尺寸（甚至为零）是可接受的，但小部件能够在其分配更多空间时增加其有用性'
- en: '`MinimumExpanding`: This is a combination of `Minimum` and `Expanding`—the
    widget is greedy in terms of space, and it cannot be made smaller than its default
    size'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MinimumExpanding`：这是 `Minimum` 和 `Expanding` 的组合——小部件在空间方面是贪婪的，并且不能被缩小到小于其默认大小'
- en: How do we determine the default size? The answer is by the size returned by
    the `sizeHint` virtual method. For layouts, the size is calculated based on the
    sizes and size policies of their child widgets and nested layouts. For basic widgets,
    the value returned by `sizeHint` depends on the content of the widget. In the
    case of a button, if it holds a line of text and an icon, `sizeHint` will return
    the size that is required to fully encompass the text, icon, some space between
    them, the button frame, and the padding between the frame and content itself.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确定默认大小？答案是`sizeHint`虚拟方法返回的大小。对于布局，大小是根据其子小部件和嵌套布局的大小和大小策略计算的。对于基本小部件，`sizeHint`返回的值取决于小部件的内容。在按钮的情况下，如果它包含一行文本和一个图标，`sizeHint`将返回包含文本、图标、它们之间的一些空间、按钮框架以及框架和内容本身之间的填充所需的大小。
- en: In our form, we prefer that when the main window is resized, the labels will
    keep their height, and the game board buttons will grow. To do this, open `mainwindow.ui`
    in the form editor, select the first label, and then hold *Ctrl* and click on
    the second label. Now both labels are selected, so we can edit their properties
    at the same time. Locate `sizePolicy` in the property editor (if you're having
    trouble locating a property, use the Filter field above the property editor) and
    expand it by clicking on the triangle to its left. Set Vertical Policy to Fixed.
    You will see the changes in the form's layout immediately.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的表单中，我们希望当主窗口大小改变时，标签的高度保持不变，而游戏板按钮则增长。为此，在表单编辑器中打开`mainwindow.ui`，选择第一个标签，然后按住*Ctrl*并点击第二个标签。现在两个标签都被选中，因此我们可以同时编辑它们的属性。在属性编辑器中找到`sizePolicy`（如果你在查找属性时遇到困难，请使用属性编辑器上方的过滤器字段）。通过点击左侧的三角形来展开它。将垂直策略设置为固定。你将立即在表单布局中看到变化。
- en: 'The buttons on the game board are created in the code, so navigate to the constructor
    of `TicTacToeWidget` class and set the size policy using the following code:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏板上的按钮是在代码中创建的，因此导航到`TicTacToeWidget`类的构造函数，并使用以下代码设置大小策略：
- en: '[PRE40]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will change both the horizontal and vertical policy of buttons to `Preferred`.
    Run the game and observe the changes:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这将改变按钮的水平垂直策略为`Preferred`。运行游戏并观察变化：
- en: '![](img/13866103-ac2b-41ff-b074-c4013aa6241f.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13866103-ac2b-41ff-b074-c4013aa6241f.png)'
- en: Protecting against invalid input
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止无效输入
- en: The configuration dialog did not have any validation until now. Let's make it
    such that the button to accept the dialog is only enabled when neither of the
    two line edits is empty (that is, when both the fields contain player names).
    To do this, we need to connect the  `textChanged` signal of each line edit to
    a slot that will perform the task.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 配置对话框之前没有进行任何验证。让我们使其按钮仅在两个行编辑器都不为空（即两个字段都包含玩家名称）时启用。为此，我们需要将每个行编辑的`textChanged`信号连接到一个将执行此任务的槽。
- en: 'First, go to the `configurationdialog.h` file and create a private slot `void
    updateOKButtonState();` in the `ConfigurationDialog` class (you will need to add
    the `private slots` section manually). Use the following code to implement this
    slot:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，转到`configurationdialog.h`文件，并在`ConfigurationDialog`类中创建一个私有槽`void updateOKButtonState();`（你需要手动添加`private
    slots`部分）。使用以下代码来实现此槽：
- en: '[PRE41]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This code asks the button box that currently contains the OK and Cancel buttons
    to give a pointer to the button that accepts the dialog (we have to do that because
    the buttons are not contained in the form directly, so there are no fields for
    them in `ui`). Then, we set the button's `enabled` property based on whether both
    player names contain valid values or not.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码要求包含OK和Cancel按钮的按钮框提供接受对话框的指针（我们必须这样做，因为按钮不是直接包含在表单中，所以在`ui`中没有它们的字段）。然后，我们根据两个玩家名称是否包含有效值来设置按钮的`enabled`属性。
- en: 'Next, edit the constructor of the dialog to connect two signals to our new
    slot. The button state also needs to be updated when we first create the dialog,
    so add an invocation of `updateOKButtonState()` to the constructor:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑对话框的构造函数以将两个信号连接到我们新的槽。当第一次创建对话框时，按钮状态也需要更新，因此将`updateOKButtonState()`的调用添加到构造函数中：
- en: '[PRE42]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Main menu and toolbars
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主菜单和工具栏
- en: As you may remember, any widget that has no parent will be displayed as a window.
    However, when we created our main window, we selected `QMainWindow` as the base
    class. If we had selected `QWidget` instead, we would still be able to do everything
    we did up to this point. However, the `QMainWindow` class provides some unique
    functionality that we will now use.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所记，任何没有父级的小部件都会显示为一个窗口。然而，当我们创建主窗口时，我们选择了 `QMainWindow` 作为基类。如果我们选择了 `QWidget`，我们仍然能够做到这一点。然而，`QMainWindow`
    类提供了一些独特的功能，我们现在将使用这些功能。
- en: 'A main window represents the control center of an application. It can contain
    menus, toolbars, docking widgets, a status bar, and the *central widget* that
    contains the main content of the window, as shown in the following diagram:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 主窗口代表应用程序的控制中心。它可以包含菜单、工具栏、停靠小部件、状态栏以及包含窗口主要内容的*中心小部件*，如下面的图示所示：
- en: '![](img/d1058ef8-d0f9-4068-92b8-2a1520a7134a.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1058ef8-d0f9-4068-92b8-2a1520a7134a.png)'
- en: If you open the `mainwindow.ui` file and take a look at the object tree, you
    will see the mandatory `centralWidget` that actually contains our form. There
    are also optional `menuBar`, `mainToolBar`, and `statusBar` that were added automatically
    when Qt Creator generated the form.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开 `mainwindow.ui` 文件并查看对象树，您将看到包含我们的表单的强制性的 `centralWidget`。还有可选的 `menuBar`、`mainToolBar`
    和 `statusBar`，它们是在 Qt Creator 生成表单时自动添加的。
- en: The central widget part doesn't need any extra explanation; it is a regular
    widget like any other. We will also not focus on dock widgets or the status bar
    here. They are useful components, but you can learn about them yourself. Instead,
    we will spend some time mastering menus and toolbars. You have surely seen and
    used toolbars and menus in many applications, and you know how important they
    are for a good user experience.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 中心小部件部分不需要额外的解释；它就像任何其他常规小部件一样。我们也不会在这里关注停靠小部件或状态栏。它们是有用的组件，但您可以自己学习它们。相反，我们将花一些时间掌握菜单和工具栏。您肯定在许多应用程序中看到并使用过工具栏和菜单，您知道它们对于良好的用户体验是多么重要。
- en: The main menu has a bit of unusual behavior. It's usually positioned in the
    top part of the window, but in macOS and some Linux environments, the main menu
    is separated from the window and displayed in the top area of the screen. Toolbars,
    on the other hand, can be moved freely by the user and docked horizontally or
    vertically to the sides of the main window.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 主菜单有一些不寻常的行为。它通常位于窗口的顶部，但在 macOS 和一些 Linux 环境中，主菜单与窗口分离，显示在屏幕的顶部区域。另一方面，工具栏可以被用户自由移动，并水平或垂直停靠在主窗口的两侧。
- en: The main class shared by both these concepts is `QAction`, which represents
    a functionality that can be invoked by a user. A single action can be used in
    multiple places—it can be an entry in a menu (the `QMenu` instances) or in a toolbar
    (`QToolBar`), a button, or a keyboard shortcut (`QShortcut`). Manipulating the
    action (for example, changing its text) causes all its incarnations to update.
    For example, if you have a Save entry in the menu (with a keyboard shortcut bound
    to it), a Save icon in the toolbar, and maybe also a Save button somewhere else
    in your user interface and you want to disallow saving the document (for example,
    a map in your dungeons and dragons game level editor) because its contents haven't
    changed since the document was last loaded. In this case, if the menu entry, toolbar
    icon, and button are all linked to the same `QAction` instance, then, once you
    set the `enabled` property of the action to `false`, all the three entities will
    become disabled as well. This is an easy way to keep different parts of your application
    in sync—if you disable an action object, you can be sure that all entries that
    trigger the functionality represented by the action are also disabled. Actions
    can be instantiated in code or created graphically using Action Editor in Qt Creator.
    An action can have different pieces of data associated with it—a text, tooltip,
    status bar tip, icons, and others that are less often used. All these are used
    by incarnations of your actions.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个概念共享的主要类是`QAction`，它代表用户可以调用的功能。单个动作可以在多个地方使用——它可以是一个菜单（`QMenu`实例）或工具栏（`QToolBar`）、按钮或键盘快捷键（`QShortcut`）的条目。操作动作（例如，更改其文本）会导致所有其化身更新。例如，如果你在菜单中有一个带有键盘快捷键的“保存”条目（与工具栏中的保存图标和可能还位于用户界面其他位置的保存按钮相关联），并且你想要禁止保存文档（例如，你的地下城与龙游戏关卡编辑器中的地图）因为自上次加载文档以来其内容没有变化。在这种情况下，如果菜单条目、工具栏图标和按钮都链接到同一个`QAction`实例，那么一旦你将动作的`enabled`属性设置为`false`，这三个实体都将被禁用。这是一个保持应用程序不同部分同步的简单方法——如果你禁用动作对象，你可以确信触发动作所代表的功能的所有条目也都已被禁用。动作可以在代码中实例化或使用Qt
    Creator中的动作编辑器图形化创建。动作可以与不同的数据相关联——文本、工具提示、状态栏提示、图标以及其他较少使用的其他内容。所有这些都被你的动作的化身所使用。
- en: Time for action – Creating a menu and a toolbar
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间 – 创建菜单和工具栏
- en: 'Let''s replace our boring Start new game button with a menu entry and a toolbar
    icon. First, select the button and press the *Delete* key to delete it. Then,
    locate Action Editor in the bottom-center part of the form editor and click on
    the New button on its toolbar. Enter the following values in the dialog (you can
    fill the Shortcut field by pressing the key combination you want to use):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把无聊的“开始新游戏”按钮替换成一个菜单项和一个工具栏图标。首先，选择按钮并按*Delete*键删除它。然后，在表单编辑器的底部中央找到动作编辑器，并点击其工具栏上的“新建”按钮。在对话框中输入以下值（你可以通过按下你想要使用的快捷键组合来填充“快捷键”字段）：
- en: '![](img/51eab088-b6dd-4d37-b0a0-2a20a99ed886.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51eab088-b6dd-4d37-b0a0-2a20a99ed886.png)'
- en: Locate the toolbar in the central area (between the Type Here text and the first
    label) and drag the line containing the New Game action from the action editor
    to the toolbar, which results in a button appearing in the toolbar.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在中央区域（在“在此输入文本”和第一个标签之间）找到工具栏，并将包含“新游戏”动作的行从动作编辑器拖到工具栏上，这将导致工具栏中出现一个按钮。
- en: To create a menu for the window, double-click on the Type Here text on the top
    of the form and replace the text with `&File` (although our application doesn't
    work with files, we will follow this tradition). Then, drag the New Game action
    from the action editor over the newly created menu, but do not drop it there yet.
    The menu should open now, and you can drag the action so that a red bar appears
    in the submenu in the position where you want the menu entry to appear; now you
    can release the mouse button to create the entry.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要为窗口创建一个菜单，双击表单顶部的“在此输入文本”并替换文本为`&File`（尽管我们的应用程序不处理文件，但我们将遵循这一传统）。然后，将“新游戏”动作从动作编辑器拖到新创建的菜单上，但不要将其放下。现在菜单应该打开了，你可以拖动动作，直到在子菜单中你想要菜单项出现的位置出现一个红色条，现在你可以释放鼠标按钮来创建该条目。
- en: 'Now we should restore the functionality that was broken when we deleted the
    button. Navigate to the constructor of the `MainWindow` class and adjust the `connect()`
    call:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该恢复在删除按钮时被破坏的功能。导航到`MainWindow`类的构造函数并调整`connect()`调用：
- en: '[PRE43]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Actions, like widgets, are accessible through the `ui` object. The `ui->startNewGame`
    object is now a `QAction` instead of a `QPushButton`, and we use its `triggered()`
    signal to detect whether the action was selected in some way.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 操作，就像小部件一样，可以通过`ui`对象访问。`ui->startNewGame`对象现在是一个`QAction`而不是`QPushButton`，我们使用它的`triggered()`信号来检测操作是否以某种方式被选中。
- en: Now, if you run the application, you can select the menu entry, press a button
    on the toolbar, or press the *Ctrl* + *N* keys. Either of these operations will
    cause the action to emit the `triggered()` signal, and the game configuration
    dialog should appear.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行应用程序，你可以选择菜单项，点击工具栏上的按钮，或者按`*Ctrl* + *N*键。这些操作中的任何一个都会导致操作发出`triggered()`信号，游戏配置对话框应该会出现。
- en: Like widgets, `QAction` objects have some useful methods that are accessible
    in our form class. For example, executing `ui->startNewGame->setEnabled(false)`
    will disable all ways to trigger the New Game action.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 与小部件一样，`QAction`对象有一些有用的方法，可以在我们的表单类中访问。例如，执行`ui->startNewGame->setEnabled(false)`将禁用触发新游戏操作的所有方式。
- en: Let's add another action for quitting the application (although the user can
    already do it just by closing the main window). Use the action editor to add a
    new action with text `Quit`, object name `quit`, and shortcut *Ctrl* + *Q*. Add
    it to the menu and the toolbar, like the first action.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加一个退出应用程序的操作（尽管用户可以通过关闭主窗口来做到这一点）。使用操作编辑器添加一个带有文本`Quit`、对象名`quit`和快捷键*Ctrl*
    + *Q*的新操作。将其添加到菜单和工具栏中，就像第一个操作一样。
- en: 'We can add a new slot that stops the application, but such a slot already exists
    in `QApplication`, so let''s just reuse it. Locate the constructor of our form
    in `mainwindow.cpp` and append the following code:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加一个新的槽来停止应用程序，但这样的槽已经在`QApplication`中存在，所以让我们重用它。在`mainwindow.cpp`中找到我们表单的构造函数，并附加以下代码：
- en: '[PRE44]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: What just happened?
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The `qApp` macro is a shortcut for a function that returns a pointer to the
    application singleton object, so when the action is triggered, Qt will call the
    `quit()` slot on the `QApplication` object created in `main()`, which, in turn,
    will cause the application to end.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`qApp`宏是一个指向应用程序单例对象的函数的快捷方式，因此当操作被触发时，Qt将调用在`main()`中创建的`QApplication`对象的`quit()`槽，这将反过来导致应用程序结束。'
- en: The Qt resource system
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt资源系统
- en: Buttons in the toolbar usually display icons instead of text. To implement this,
    we need to add icon files to our project and assign them to the actions we created.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏中的按钮通常显示图标而不是文本。为了实现这一点，我们需要将图标文件添加到我们的项目中，并将它们分配给创建的操作。
- en: One way of creating icons is by loading images from the filesystem. The problem
    with this is that you have to install a bunch of files along with your application,
    and you need to always know where they are located to be able to provide paths
    to access them. Fortunately, Qt provides a convenient and portable way to embed
    arbitrary files (such as images for icons) directly in the executable file. This
    is done by preparing resource files that are later compiled in the binary. Qt
    Creator provides a graphical tool for this as well.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图标的一种方法是从文件系统中加载图像。问题是你必须安装与应用程序一起的一堆文件，并且你需要始终知道它们的位置，以便能够提供路径来访问它们。幸运的是，Qt提供了一种方便且可移植的方法，可以将任意文件（如图标图像）直接嵌入到可执行文件中。这是通过准备随后编译到二进制中的资源文件来完成的。Qt
    Creator也为此提供了一个图形工具。
- en: Time for action – Adding icons to the project
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 向项目中添加图标
- en: We will add icons to our Start new game and Quit actions. First, use your file
    manager to create a new subdirectory called `icons` in the project directory.
    Place two icon files in the `icons` directory. You can use icons from the files
    provided with the book.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向“开始新游戏”和“退出”操作添加图标。首先，使用你的文件管理器在项目目录中创建一个名为`icons`的新子目录。在该目录中放置两个图标文件。你可以使用书中提供的图标文件。
- en: Click on Add New... in the context menu of the tictactoe project and select
    Qt Resource File (located in Qt category). Name it `resources`, and finish the
    wizard. Qt Creator will add a new `resources.qrc` file to the project (it will
    be displayed under the Resources category in the project tree).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tictactoe`项目的上下文菜单中点击“添加新...”，然后在Qt类别中选择Qt资源文件。将其命名为`resources`，完成向导。Qt Creator将为项目添加一个新的`resources.qrc`文件（它将在项目树中的“资源”类别下显示）。
- en: Locate the new `resources.qrc` file in the project tree of Qt Creator and choose
    Add Existing Files... in its context menu. Select both icons, and confirm their
    addition to the resources.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt Creator 的项目树中定位新的 `resources.qrc` 文件，并在其上下文菜单中选择“添加现有文件...”。选择两个图标，并确认将它们添加到资源中。
- en: 'Open the `mainwindow.ui` form, and double-click on one of the actions in the
    action editor. Click on the "..." button next to the Icon field, select icons
    in the left part of the window, and select the appropriate icon in the right part
    of the window. Once you confirm changes in the dialogs, the corresponding button
    on the toolbar will switch to displaying the icon instead of the text. The menu
    entry will also gain the selected icon. Repeat this operation for the second action.
    Our game should now look like this:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `mainwindow.ui` 表单，并在动作编辑器中双击一个动作。点击图标字段旁边的“...”按钮，在窗口的左侧选择图标，并在窗口的右侧选择合适的图标。一旦你在对话框中确认更改，工具栏上的相应按钮将切换为显示图标而不是文本。菜单项也将获得所选的图标。为第二个动作重复此操作。我们的游戏现在应该看起来像这样：
- en: '![](img/e178a580-a24e-43a2-8da6-929e3eecf922.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e178a580-a24e-43a2-8da6-929e3eecf922.png)'
- en: Have a go hero – Extending the game
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下英雄扩展游戏
- en: There are a lot of subtle improvements you can make in the project. For example,
    you can change the title of the main window (by editing its `windowTitle` property),
    add accelerators to the actions, disable the board buttons that do nothing on
    click, remove the status bar, or use it for displaying the game status.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在项目中做出很多细微的改进。例如，你可以更改主窗口的标题（通过编辑其 `windowTitle` 属性），为动作添加快捷键，禁用点击时无操作的棋盘按钮，移除状态栏，或用它来显示游戏状态。
- en: As an additional exercise, you can try to modify the code we wrote in this chapter
    to allow playing the game on boards bigger than 3 × 3\. Let the user decide the
    size of the board (you can modify the game options dialog for that and use `QSlider`
    and `QSpinBox` to allow the user to choose the size of the board), and you can
    then instruct `TicTacToeWidget` to build the board based on the size it gets.
    Remember to adjust the game-winning logic! If at any point you run into a dead
    end and do not know which classes and functions to use, consult the reference
    manual.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项附加练习，你可以尝试修改本章中我们编写的代码，以便在大于 3 × 3 的棋盘上玩游戏。让用户决定棋盘的大小（你可以修改游戏选项对话框来实现这一点，并使用
    `QSlider` 和 `QSpinBox` 允许用户选择棋盘的大小），然后你可以指导 `TicTacToeWidget` 根据它得到的大小构建棋盘。记住调整游戏胜利逻辑！如果在任何时刻你遇到了死胡同，不知道要使用哪些类和函数，请查阅参考手册。
- en: Pop quiz
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. Which classes can have signals?
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 哪些类可以有信号？
- en: All classes derived from `QWidget`.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有从 `QWidget` 派生的类。
- en: All classes derived from `QObject`.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有从 `QObject` 派生的类。
- en: All classes.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有类。
- en: Q2\. For which of the following do you have to provide your own implementation?
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 对于以下哪个，你必须提供自己的实现？
- en: A signal.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个信号。
- en: A slot.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个槽。
- en: Both.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两者都。
- en: Q3\. A method that returns the preferred size of a widget is called which of
    these?
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 返回小部件首选大小的方法被称为以下哪个？
- en: '`preferredSize`.'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`preferredSize`。'
- en: '`sizeHint`.'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sizeHint`。'
- en: '`defaultSize`.'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`defaultSize`。'
- en: Q4\. What is the purpose of the `QAction` object?
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: Q4. `QAction` 对象的目的是什么？
- en: It represents a functionality that a user can invoke in the program.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它代表用户可以在程序中调用的功能。
- en: It holds a key sequence to move the focus on a widget.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它包含一个键序列，用于将焦点移动到小部件上。
- en: It is a base class for all forms generated using the form editor.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是使用表单编辑器生成的所有表单的基类。
- en: Summary
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, you learned how to create simple graphical user interfaces
    with Qt. We went through two approaches: designing the user interface with a graphical
    tool that generates most of the code for us, and creating user interface classes
    by writing all the code directly. None of them is better than the other. The form
    designer allows you to avoid boilerplate code and helps you handle large forms
    with a lot of controls. On the other hand, the code writing approach gives you
    more control over the process and allows you to create automatically populated
    and dynamic interfaces.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用 Qt 创建简单的图形用户界面。我们介绍了两种方法：使用图形工具设计用户界面，该工具为我们生成大部分代码，以及通过直接编写所有代码来创建用户界面类。它们没有哪一个比另一个更好。表单设计器允许你避免样板代码，并帮助你处理带有大量控件的大型表单。另一方面，编写代码的方法让你对过程有更多的控制，并允许你创建自动填充和动态的界面。
- en: We also learned how to use signals and slots in Qt. You should now be able to
    create simple user interfaces and fill them with logic by connecting signals to
    slots—predefined ones as well as custom ones that you now know how to define and
    fill with code.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何在 Qt 中使用信号和槽。现在您应该能够通过将信号连接到槽（预定义的以及您现在知道如何定义并填充代码的自定义槽）来创建简单的用户界面并填充逻辑。
- en: Qt contains many widget types, but we didn't introduce them to you one by one.
    There is a really nice explanation of many widget types in the Qt manual called
    Qt Widget Gallery, which shows most of them in action. If you have any doubts
    about using any of those widgets, you can check the example code and also look
    up the appropriate class in the Qt reference manual to learn more about them.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 包含许多小部件类型，但我们并没有逐一向您介绍它们。Qt 手册中有一个名为 Qt 小部件画廊的非常棒的说明，其中展示了大多数小部件的实际应用。如果您对使用这些小部件中的任何一个有任何疑问，您可以查看示例代码，并在
    Qt 参考手册中查找相应的类以了解更多信息。
- en: As you already saw, Qt allows you to create custom widget classes, but in this
    chapter our custom classes mostly reused the default widgets. It's also possible
    to modify how the widget responds to events and implement custom painting. We
    will get to this advanced topic in [Chapter 8](2083bd66-78eb-4b33-a103-b7d1158544ef.xhtml),* Custom
    Widgets*. However, if you want to implement a game with custom 2D graphics, there
    is a simpler alternative—the Graphics View Framework that we'll use in the next
    chapter.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经看到的，Qt 允许您创建自定义小部件类，但在这个章节中，我们的自定义类主要重用了默认的小部件。您也可以修改小部件对事件的响应方式，并实现自定义绘制。我们将在第
    8 章[自定义小部件](2083bd66-78eb-4b33-a103-b7d1158544ef.xhtml)中深入探讨这个高级主题。然而，如果您想实现一个带有自定义
    2D 图形的游戏，有一个更简单的替代方案——我们将在下一章中使用的图形视图框架。
