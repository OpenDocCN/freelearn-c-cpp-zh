["```cpp\n        #pragma that allows you to define a JavaScript function below it.\n        ```", "```cpp\n    ./simple_warn.c:2:7: warning: unused variable 'y'…\n      int y = x + 1;\n          ^\n    1 warning generated.\n    ```", "```cpp\n        Tool*\n        MyCompiler – which is a class derived from Tool, if we are trying to compile the code for a certain hardware architecture.Providing an alternative compiler instance is useful when your target platform (for example, the `CUSTOM_HARDWARE` in the preceding snippet) or input file is not supported by Clang, but you still want to use the *same* `clang` command-line interface for all the build jobs. For example, suppose you are trying to cross-compile the same projects to *multiple* different architectures, but some of them are not supported by Clang yet. Therefore, you can create a custom Clang toolchain and redirect the compilation job to an external compiler (for example, `gcc`) when the `clang` command-line tool is asked to build the project for those architectures.\n        ```", "```cpp\n        void\n        MyAssembler::ConstructJob(Compilation &C,\n                                  const JobAction &JA,\n                                  const InputInfo &Output,\n                                  const InputInfoList &Inputs,\n                                  const ArgList &Args,\n                                  const char *LinkingOutput)                           const {\n          if (Arg *A = Args.getLastArg(options::OPT_Wl_COMMA)) {\n            // `A` contains linker-specific flags\n            …\n          }\n          …\n        }\n        ```", "```cpp\n        struct MyPass {\n          static StringRef name() { return \"MyPass\"; }\n          PreservedAnalyses run(Function&, FunctionAnalysisManager&);\n        };\n        ```"]