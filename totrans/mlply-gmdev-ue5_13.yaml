- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling Data During a Session
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work on a multiplayer game, you need a solid system in place to manage the
    flow of data between levels. This means tracking variables – such as character
    inventory or health – to keep players up to date with the information they need.
    In short, an effective multiplayer game requires careful management of data to
    ensure a smooth, engaging experience for all players.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll be adding the final touches to the previous chapter’s
    session system by creating a system that will serve as an entry point for the
    players. This means working on a new level that will let the player create a session
    – if they’re starting the game as a server – or look for available sessions in
    the network – if they’re playing as a client.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you will learn how to customize the player character – by adding
    skin variants – and how to send this data from the session selection level to
    the actual game level. This will make your character special and even more cool
    and colorful than before!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to host a local network game session
    with a computer acting as a listen server and other PCs connecting to it as clients
    and have different skins for every player in the game.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I will guide you through the following sections:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Creating the main menu level
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling data during a session
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making further improvements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the topics presented in this chapter, you should have completed [*Chapter
    12*](B18203_12.xhtml#_idTextAnchor239), *Managing Multiplayer Sessions*, and understood
    its content.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, if you would prefer to begin with the code from the companion
    repository for this book, you can download the `.zip` project files provided in
    this book’s companion project repository: [https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: You can download the files that are up to date with the end of the previous
    chapter by clicking the `Unreal Shadows –` [*Chapter 12*](B18203_12.xhtml#_idTextAnchor239)`End`
    link.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Creating the main menu level
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll be working on creating a new level that will serve as
    a starting point for creating a game session or joining one. You’ll be leveraging
    the power and flexibility of the previously created user interface by adding the
    needed Gameplay Framework classes, such as a dedicated GameMode and a player Pawn.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: First things first, let’s open up your programming IDE and start writing some
    code!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Pawn
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, you’ll be creating a Pawn that will show the character model
    and activate the user interface through its controller. This Actor will also be
    used to show the character model when the player enters the main menu level.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'So, from the Unreal Engine Editor, create a new C++ class extending from `US_MainMenuPawn`.
    Once the class has been created, open the `US_MainMenuPawn.h` header file and
    add the following code just after the `GENERATED_BODY()` macro:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, in the `protected` section, add the corresponding getter functions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All of the previous code is quite straightforward, and you should already be
    familiar with it from the previous chapters; we are declaring the needed components
    – an arrow, a camera, and a mesh – and then we are exposing the corresponding
    getter methods.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the `US_MainMenuPawn.cpp` file and add the needed `include` declarations:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, locate the constructor and add the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We are not adding anything new here. As normal, we are just adding a list of
    components for the Actor, including a utility arrow element, the mesh, and the
    camera.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the basic `Pawn` class has been created, it’s time to implement a
    Blueprint from it and add the previously created user interface. So, return to
    the Unreal Engine Editor and, in the `BP_MainMenuPawn`. Then, open the Blueprint
    and, in the Event Graph, complete the following steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Get Player** **Controller** node.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Create Widget** node to the graph and connect its incoming execution
    pin to the outgoing execution pin of the **Event** **BeginPlay** node.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Class** drop-down menu, select the **WB_MainMenu** class.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Owning Player** pin to the **Return** value of the **Get Player**
    **Controller** node.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the outgoing execution pin of the **Create Widget** node, click and drag
    to add an **Add to Viewport** node. Then, connect the **Target** pin to **Return
    Value** of the **Create** **Widget** node.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag from **Return Value** of the **Get Player Controller** node to
    add **Set Show Mouse Cursor**. Then, tick the **Show Mouse Cursor** checkbox and
    connect the incoming execution pin to the outgoing execution pin of the **Add
    to** **Viewport** node.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final graph is depicted in *Figure 13**.1*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – The final graph for the BP_MainMenuPawn Blueprint](img/Figure_13_01_B18203.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – The final graph for the BP_MainMenuPawn Blueprint
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The `BP_MainMenuPawn` Blueprint is complete and ready to go, so we can now move
    on to working on the GameMode class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Creating the GameMode
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s now time to create the GameMode that will handle the main menu level. In
    the `BP_MainMenuGameMode`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the Blueprint. Then, in the **Details** panel, locate the **Classes**
    category and, in the **Default Pawn Class** drop-down menu, select **BP_MainMenuPawn**,
    as shown in *Figure 13**.2*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – The BP_MainMenuGameMode settings](img/Figure_13_02_B18203.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – The BP_MainMenuGameMode settings
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The GameMode is now ready; we just need to create a new level and use it to
    show the session user interface.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Creating the level
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating the main menu level is quite straightforward:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Content` | `Maps` folder.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the main menu, select `Level_MainMenu`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the level and, in the **Worlds Settings** panel, locate **GameMode Override**.
    In the corresponding drop-down menu, select **BP_MainMenuGameMode**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Editor** main menu, select **Edit** | **Project Settings** and, in
    the newly opened window, locate the **Maps & Modes** section. Then, from the **Editor
    Template Map Overrides** drop-down menu, select **Level_MainMenu**.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations, you’ve made it through this section and built your game’s starting
    level! With this, your players can now create and host game sessions like a boss
    on their LAN or join in on the action as a client. Let’s start testing these features
    by playing the game.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Testing the session system
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start testing a game session, open the **Level_MainMenu** map and play with
    these settings:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Set **Net Mode** set to **Play Standalone**
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `3`
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will see the user interface you’ve created so far, as depicted in *Figure
    13**.3*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – The user interface](img/Figure_13_03_B18203.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – The user interface
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'From this interface, you will be able to create a session, like so:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: From the **Max Players** spinner, set the maximum number of players to **3**
    or more.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create** button; you will start the game and see the game level.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, to join a session, follow these steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Select one of the other opened clients and click the **Find Session** button;
    this operation will start the server search and, after a while, you should see
    the list of available servers in the LAN, along with the number of players already
    connected. *Figure 13**.4* shows a game where there is a player already connected
    (that is, the listen server) with a maximum of 3 players:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.4 – The session search result](img/Figure_13_04_B18203.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – The session search result
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Join Session** button to, well... join the session. Your character
    will be teleported to the game level and you will be able to start playing.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, you were introduced to session management and learned how to
    create, search for, and join sessions in a multiplayer game.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Brace yourself because, in the upcoming section, you’ll be spicing up your game
    with an extra dose of customization. That’s right – get ready to add skin variants
    that will make each player’s character truly one of a kind. It’s time to get creative
    and let your imagination run wild!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Handling data during a session
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you’ll be working on a new topic: passing data from one level
    to another when joining a session. You already possess almost all the knowledge
    necessary to perform this task – you just need to put things together.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to do here is create a skin system for the character model that
    will do the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Select a random skin in the main menu level from a list of possible variants
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store this data while joining a session
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the character skin variant once the session has been joined
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following steps, you will be working on a class that has remained inactive
    until this point, but that will prove to be incredibly useful moving forward.
    So, get ready to put the **US_GameInstance** class to work and see what it can
    do!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Updating the US_GameInstance class
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have forgotten but, at the beginning of this project, you created the
    **US_GameInstance** class. This class offers a couple of interesting peculiarities:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: It is persistent across levels
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is unique for each client (that is, it is not replicated over the network)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These features make it an awesome candidate for transporting data between levels
    while keeping them locally. You can use it to pass things such as the experience
    points gained by a player or their actual equipment. In our case, we will be using
    it to store a really simple piece of information: an index of the selected skin
    of the character (we’ll be implementing the skin list later in this chapter).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `US_GameInstance.h` header file and, in the `public` section, add
    this declaration:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As easy as it may seem, it’s all we need to pass the skin selection from one
    level to another!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: In the next few steps, we will be creating a data structure to handle the character
    skin variants.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Adding the CharacterSkins data
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, you’ll be creating a data structure similar to the one you
    created in [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125), *Replicating Properties*
    *O**ver the Network*, but this time, you will be storing just material references
    that will be used to change the character’s mesh colors.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'The character model has six materials, as shown in *Figure 13**.5*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – The character model materials](img/Figure_13_05_B18203.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – The character model materials
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: For the character customization, we will only need four of them - specifically,
    **Element 0**, **Element 1**, and **Element 2**, all of which will change the
    character’s hair and clothes, and **Element 4**, which will change the character’s
    skin.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Creating the structure
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create the structure that will contain the skin data, open your programming
    IDE and create a file named `US_CharacterSkins.h`. Then, inside that file, add
    the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, we are creating a data structure from `FTableRowBase` – the
    structure that will let us create data tables – and then we are declaring the
    four material references. As a side note, remember that the `UNREALSHADOWS_LOTL_API
    API` identifier may change, depending on your project name.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: In the next steps, you will be creating the actual skin data out of this structure
    by generating a data table.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Creating the data table
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you have created a data structure, you are ready to create the actual
    data from it. To create your skin data table, follow these steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Open your **Blueprints** folder in the Content Browser, right-click, and select
    **Miscellaneous** | **Data Table**.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Pick Row Structure** pop-up window, select **US_CharacterSkins** from
    the drop-down menu.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `DT_CharacterSkins`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the newly created asset to open it. You will get an empty dataset;
    create your character skin rows by using any material from the project (or create
    custom materials!).
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'During the development phase, I like to create debug skins that will help me
    identify each unique character. In this case, I used a single color for all the
    elements in a row set (that is, all green, all red, or all blue), as shown in
    *Figure 13**.6*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – The Skins data table](img/Figure_13_06_B18203.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – The Skins data table
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Once you are satisfied with the skin system and you have battle-tested it, you
    will need some more realistic skins for your thief character; this process will
    be as easy as creating a new data table with the skin colors of your choice and
    setting this table as the selected one in the **Pawn** variable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a skin catalog asset, you can start adding code to the main
    menu `Pawn` class to set its skins at runtime.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Updating the US_MainMenuPawn class
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you’ll be enhancing your character’s appearance by assigning
    a random skin. Every time players connect to the main menu level, their character
    will be allotted a unique set of colors for their skin, taken from the previously
    created data table. So, get ready to see a little more variety in your game!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned previously, you dealt with this in [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125),
    *Replicating Properties Over the Network*, but as the old saying goes, practice
    makes perfect!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'With your programming IDE, open the `US_MainMenuPawn.h` header file and, in
    the implicit `private` section, add the data table and skin declarations:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, in the `public` section, add the getter method for the selected character
    skin:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And in the `protected` section, declare a function that will handle the skin
    randomization process:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, you can open the `US_MainMenuPawn.cpp` file to start adding the skin handling
    implementation. First of all, declare the needed includes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, add the `RandomizeCharacterSkin()` implementation:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, we are retrieving all the data rows from the table reference
    and, after checking that there is at least one item in the table, we get a random
    row and set the pawn mesh materials to its included data. This will update the
    pawn shown in the level. After that, we retrieve the game instance as a `UUS_GameInstance`
    type and assign the previously randomized index to the `SkinIndex` property.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'As a last step, we will be adding the randomization call when the game is started.
    So, in the `BeginPlay()` method, add the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We now need to set the data table from the Blueprint, so let’s switch back to
    the Unreal Engine Editor.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Updating the BP_MainMenuPawn Blueprint
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the `Pawn` class is ready, you just have to assign the previously
    created data table to the Pawn Blueprint. To do so, open `BP_MainMenuPawn` and
    do the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: In the **Details** panel, look for the **Character Skin Data** **Table** property.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From its drop-down menu, select **DT_CharacterSkins**, as shown in *Figure
    13**.7*:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.7 – The character skin data table property](img/Figure_13_07_B18203.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – The character skin data table property
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'If you test the game, you will get a randomized skin for each of the characters,
    as depicted in *Figure 13**.8*:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.8 – The starting skin randomization](img/Figure_13_08_B18203.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – The starting skin randomization
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The character randomization is complete; to take full advantage of it, we just
    need to retrieve the data from the game level side and assign it to the playing
    character.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Updating the US_Character class
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, you will be retrieving the skin index data from the game
    instance and setting it to the player character. This process is quite straightforward
    once you remember that the game instance is persistent across levels and is not
    replicated (that is, each client has its own dedicated one).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by opening the `US_Character.h` header file from your programming IDE
    and declare the needed data table properties in the implicit `private` section:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I know you are already familiar with the previous declarations, so I won’t waste
    your time by explaining them again.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the `protected` section, you need to add the following declarations.
    These will handle the skin update:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And in the `public` section, add the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you may remember from [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125), *Replicating
    Properties Over the Network*, whenever you need to replicate a property, you can
    use the `ReplicatedUsing` property specifier to notify all clients that the property
    value has changed. In this case, we will replicate the `SkinIndex` variable to
    let all of the clients update their character skins once they join a session.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, always keep in mind that, to replicate a property, it should be
    initialized inside the `GetLifetimeReplicatedProps()` method through the `DOREPLIFETIME`
    macro, which is why we declared that method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement all the replication logic and skin update, open the `US_Character.cpp`
    file and start by adding the needed `include` declarations:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, add the `GetLifetimeReplicatedProps()` method implementation to implement
    the property replication:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, add the `OnRep_SkinChanged()` method. This will be executed every time
    the `SkinIndex` value is updated from the server to the clients:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, implement the skin index update from the server side by adding the `SetSkinIndex_Server_Implementation()`
    method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that we are calling the `UpdateCharacerSkin()` event from the server side;
    this is mandatory if you are using a listen server because the previous method
    will be called only on the clients and, in that case, the server will not update
    the skin.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth method, `UpdateCharacterSkin()`, will take care of retrieving the
    data from the game instance and updating the character mesh materials. To do so,
    add the following implementation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What we are doing here is almost identical to the main menu Pawn class; we are
    getting a row from the skin data table and assigning the materials to the character
    mesh. The only difference is that we are not setting the skin index to the game
    instance, and we are getting a replicated version of it instead.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'As a last step, you will need to add the following code at the end of the `BeginPlay()`
    method’s implementation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This portion of the code checks that the instance of this class is locally controlled
    (that is, it is a player-owned character) and gets the skin index from the game
    instance. Then, it calls the `SetSkinIndex()` server function to notify all the
    clients that they should update this character look.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: As for the main menu Pawn class, you now need to update the corresponding Blueprint
    to declare the skin data table.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Updating the BP_Character Blueprint
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the character class is ready, you just have to assign the previously
    created data table to the corresponding Blueprint. To do so, follow these steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Open **BP_Character**.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Details** panel, look for the **Character Skin Data** **Table** property.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From its drop-down menu, select **DT_CharacterSkins**, as shown in *Figure
    13**.9*:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.9 – The character skin data table property](img/Figure_13_09_B18203.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: Figure 13.9 – The character skin data table property
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'If you test the game now, you will be able to get a randomized skin for each
    of the characters and keep that skin once a session is joined, as depicted in
    *Figure 13**.10*:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10 – Gameplay with skinned characters](img/Figure_13_10_B18203.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: Figure 13.10 – Gameplay with skinned characters
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to keep data when creating or joining a session.
    You did this by using the game instance as a sort of data bridge to create a skinning
    feature; this will make each character unique and even more appealing to the players,
    helping you give them a killer makeover that will make the Lichlord quake in his
    boots!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, I won’t be introducing any new topics; instead, I’ll
    give you some additional ideas to help you better manage your game sessions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Making further improvements
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, you did a great job of understanding how to pass data
    between sessions to make your multiplayer game even more engaging. Now, it’s time
    to make your game even better by adding some additional functionalities. In this
    section, I’ll offer some tips to help you add some excitement to your project.
    As always, don’t be afraid to add your personal touch and make it truly yours.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Leaving and destroying sessions
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter and the previous one, you have used three out of four session
    commands – **Create Session**, **Join Session**, and **Find Session** – but the
    **Destroy Session** command has been left unused. Use the **Destroy Session**
    command node to let the player leave a playing session.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: This will be implemented in the game level (and not in the main menu one) as
    the player will need to leave the session after joining one. To implement this
    feature, you may want to create a dedicated user interface that will let players
    leave the game whenever they decide to do so.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'As a side note, keep in mind that clients and the server behave differently
    regarding a session, so you will have to manage two kinds of session destruction:
    the one from the client – which will be almost painless – and, in the case of
    a client/server host, the server one – which will have to destroy all sessions
    from all clients (that is, all clients should leave the session as the server
    is not functional anymore).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Handling player death
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the moment, whenever a player is captured by a Lichlord minion, nothing will
    happen – you will get just a screen message and the player will keep on playing.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'You can manage a player’s death in many ways, but here are a couple of ideas
    for you:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Destroy the player session and reload the main menu level to let the player
    join a new session. Just keep in mind that, if the player that is defeated is
    the server host, all other players will be immediately removed from the session.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a respawn method, where the character will be placed in an available spawn
    point without the need to rejoin the session.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting the player skin
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, you developed a random skin generator, but wouldn’t be cool
    to let the players choose their own skin? You may add a user interface in the
    main menu level that will let the players do the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Randomize the skin again if it does not suit their needs
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the desired skin from the full set using a dedicated selection method
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well, this could be the tip of the iceberg when it comes to creating a skin
    system that works like a charm and gets envious stares from your competitors.
    Who knows? Implementing your in-game purchases might even make games such as Fortnite
    weak in the knees!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you developed a fully functional system to pass data from one
    level to another during a game session. In this case, you focused on a skin system
    for the player character, but the use cases for this feature are almost endless.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, session handling is a huge topic – it took two chapters
    to properly explain its main functionalities – and to succeed in the multiplayer
    world, it is imperative to have a strong grasp of it. If you want to ride the
    wave of success, then mastering this skill is a non-negotiable topic!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, I will guide you through a brand new topic: how to properly
    package your game. Get ready to dive into the exciting world of project packaging
    so that you can deploy your game like a boss on both server and client ends! Are
    you ready for this adventure?'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将引导你探索一个全新的主题：如何正确地打包你的游戏。准备好深入探索项目打包的精彩世界，以便你能在服务器和客户端两端像老板一样部署你的游戏！你准备好迎接这次冒险了吗？
