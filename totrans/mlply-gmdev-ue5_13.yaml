- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Handling Data During a Session
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话期间处理数据
- en: To work on a multiplayer game, you need a solid system in place to manage the
    flow of data between levels. This means tracking variables – such as character
    inventory or health – to keep players up to date with the information they need.
    In short, an effective multiplayer game requires careful management of data to
    ensure a smooth, engaging experience for all players.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发多人游戏，你需要一个稳固的系统来管理层级之间的数据流。这意味着跟踪变量——如角色库存或健康——以使玩家能够及时获取所需的信息。简而言之，一个有效的多人游戏需要仔细管理数据，以确保所有玩家都能获得流畅、吸引人的体验。
- en: In this chapter, you’ll be adding the final touches to the previous chapter’s
    session system by creating a system that will serve as an entry point for the
    players. This means working on a new level that will let the player create a session
    – if they’re starting the game as a server – or look for available sessions in
    the network – if they’re playing as a client.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将通过创建一个系统来完善上一章的会话系统，该系统将作为玩家的入口点。这意味着工作在一个新的层级，让玩家能够创建会话——如果他们是作为服务器开始游戏——或者在网络中寻找可用的会话——如果他们是作为客户端玩游戏。
- en: Additionally, you will learn how to customize the player character – by adding
    skin variants – and how to send this data from the session selection level to
    the actual game level. This will make your character special and even more cool
    and colorful than before!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还将学习如何通过添加皮肤变体来自定义玩家角色，以及如何将此数据从会话选择层级发送到实际游戏层级。这将使你的角色更加特别，甚至比以前更加酷炫和多彩！
- en: By the end of the chapter, you will be able to host a local network game session
    with a computer acting as a listen server and other PCs connecting to it as clients
    and have different skins for every player in the game.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够以计算机作为监听服务器并让其他PC作为客户端连接到它，并为游戏中的每个玩家提供不同的皮肤来托管本地网络游戏会话。
- en: 'In this chapter, I will guide you through the following sections:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将指导你通过以下部分：
- en: Creating the main menu level
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建主菜单层级
- en: Handling data during a session
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话期间处理数据
- en: Making further improvements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步改进
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the topics presented in this chapter, you should have completed [*Chapter
    12*](B18203_12.xhtml#_idTextAnchor239), *Managing Multiplayer Sessions*, and understood
    its content.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章介绍的主题，你应该已经完成了[*第12章*](B18203_12.xhtml#_idTextAnchor239)，*管理多人会话*，并理解其内容。
- en: 'Additionally, if you would prefer to begin with the code from the companion
    repository for this book, you can download the `.zip` project files provided in
    this book’s companion project repository: [https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你希望从本书的配套仓库开始编写代码，你可以下载本书配套项目仓库中提供的`.zip`项目文件：[https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5)。
- en: You can download the files that are up to date with the end of the previous
    chapter by clicking the `Unreal Shadows –` [*Chapter 12*](B18203_12.xhtml#_idTextAnchor239)`End`
    link.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击`Unreal Shadows –` [*第12章*](B18203_12.xhtml#_idTextAnchor239)`结束`链接来下载与上一章结尾保持一致的文件。
- en: Creating the main menu level
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建主菜单层级
- en: In this section, you’ll be working on creating a new level that will serve as
    a starting point for creating a game session or joining one. You’ll be leveraging
    the power and flexibility of the previously created user interface by adding the
    needed Gameplay Framework classes, such as a dedicated GameMode and a player Pawn.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建一个新的层级，该层级将作为创建游戏会话或加入会话的起点。你将通过添加所需的游戏框架类，如专用的GameMode和玩家Pawn，利用之前创建的用户界面的强大功能和灵活性。
- en: First things first, let’s open up your programming IDE and start writing some
    code!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们打开你的编程IDE并开始编写一些代码！
- en: Creating the Pawn
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Pawn
- en: In this subsection, you’ll be creating a Pawn that will show the character model
    and activate the user interface through its controller. This Actor will also be
    used to show the character model when the player enters the main menu level.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，你将创建一个Pawn，该Pawn将显示角色模型并通过其控制器激活用户界面。这个Actor还将被用来在玩家进入主菜单层级时显示角色模型。
- en: 'So, from the Unreal Engine Editor, create a new C++ class extending from `US_MainMenuPawn`.
    Once the class has been created, open the `US_MainMenuPawn.h` header file and
    add the following code just after the `GENERATED_BODY()` macro:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从Unreal Engine编辑器中创建一个新的从`US_MainMenuPawn`扩展的C++类。一旦类被创建，打开`US_MainMenuPawn.h`头文件，并在`GENERATED_BODY()`宏之后添加以下代码：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, in the `protected` section, add the corresponding getter functions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`protected`部分添加相应的获取函数：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All of the previous code is quite straightforward, and you should already be
    familiar with it from the previous chapters; we are declaring the needed components
    – an arrow, a camera, and a mesh – and then we are exposing the corresponding
    getter methods.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述代码都很直接，你应该已经从前面的章节中熟悉了它；我们正在声明所需的组件 – 一个箭头，一个摄像头和一个网格 – 然后我们暴露相应的获取方法。
- en: 'Next, open the `US_MainMenuPawn.cpp` file and add the needed `include` declarations:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开`US_MainMenuPawn.cpp`文件并添加所需的`include`声明：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, locate the constructor and add the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，找到构造函数并添加以下代码：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We are not adding anything new here. As normal, we are just adding a list of
    components for the Actor, including a utility arrow element, the mesh, and the
    camera.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里没有添加任何新内容。像往常一样，我们只是为Actor添加了一组组件列表，包括一个实用箭头元素、网格和摄像头。
- en: 'Now that the basic `Pawn` class has been created, it’s time to implement a
    Blueprint from it and add the previously created user interface. So, return to
    the Unreal Engine Editor and, in the `BP_MainMenuPawn`. Then, open the Blueprint
    and, in the Event Graph, complete the following steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基本的`Pawn`类已经创建，现在是时候从它实现一个蓝图并添加之前创建的用户界面了。因此，返回到Unreal Engine编辑器，在`BP_MainMenuPawn`中。然后，打开蓝图，在事件图表中完成以下步骤：
- en: Add a **Get Player** **Controller** node.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**获取玩家****控制器**节点。
- en: Add a **Create Widget** node to the graph and connect its incoming execution
    pin to the outgoing execution pin of the **Event** **BeginPlay** node.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图表中添加一个**创建小部件**节点，并将其传入的执行引脚连接到**事件****开始播放**节点的输出执行引脚。
- en: From the **Class** drop-down menu, select the **WB_MainMenu** class.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**类**下拉菜单中选择**WB_MainMenu**类。
- en: Connect the **Owning Player** pin to the **Return** value of the **Get Player**
    **Controller** node.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**拥有玩家**引脚连接到**获取玩家****控制器**节点的**返回值**。
- en: From the outgoing execution pin of the **Create Widget** node, click and drag
    to add an **Add to Viewport** node. Then, connect the **Target** pin to **Return
    Value** of the **Create** **Widget** node.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**创建小部件**节点的输出执行引脚，点击并拖动以添加一个**添加到视口**节点。然后，将**目标**引脚连接到**创建****小部件**节点的**返回值**。
- en: Click and drag from **Return Value** of the **Get Player Controller** node to
    add **Set Show Mouse Cursor**. Then, tick the **Show Mouse Cursor** checkbox and
    connect the incoming execution pin to the outgoing execution pin of the **Add
    to** **Viewport** node.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**获取玩家控制器**节点的**返回值**点击并拖动以添加**设置显示鼠标光标**。然后，勾选**显示鼠标光标**复选框并将传入的执行引脚连接到**添加到****视口**节点的输出执行引脚。
- en: 'The final graph is depicted in *Figure 13**.1*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的图表展示在*图13*.*1*中：
- en: '![Figure 13.1 – The final graph for the BP_MainMenuPawn Blueprint](img/Figure_13_01_B18203.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – BP_MainMenuPawn蓝图中的最终图表](img/Figure_13_01_B18203.jpg)'
- en: Figure 13.1 – The final graph for the BP_MainMenuPawn Blueprint
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – BP_MainMenuPawn蓝图中的最终图表
- en: The `BP_MainMenuPawn` Blueprint is complete and ready to go, so we can now move
    on to working on the GameMode class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`BP_MainMenuPawn`蓝图已完成并准备就绪，因此我们现在可以继续工作在GameMode类上。'
- en: Creating the GameMode
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建GameMode
- en: It’s now time to create the GameMode that will handle the main menu level. In
    the `BP_MainMenuGameMode`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建一个将处理主菜单关卡的GameMode了。在`BP_MainMenuGameMode`中。
- en: 'Next, open the Blueprint. Then, in the **Details** panel, locate the **Classes**
    category and, in the **Default Pawn Class** drop-down menu, select **BP_MainMenuPawn**,
    as shown in *Figure 13**.2*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开蓝图。然后在**详细信息**面板中，定位到**类**类别，并在**默认玩家类**下拉菜单中选择**BP_MainMenuPawn**，如图*图13*.*2*所示：
- en: '![Figure 13.2 – The BP_MainMenuGameMode settings](img/Figure_13_02_B18203.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – BP_MainMenuGameMode设置](img/Figure_13_02_B18203.jpg)'
- en: Figure 13.2 – The BP_MainMenuGameMode settings
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – BP_MainMenuGameMode设置
- en: The GameMode is now ready; we just need to create a new level and use it to
    show the session user interface.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在GameMode已经准备好了；我们只需要创建一个新的关卡并使用它来显示会话用户界面。
- en: Creating the level
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建关卡
- en: 'Creating the main menu level is quite straightforward:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 创建主菜单关卡相当直接：
- en: Open the `Content` | `Maps` folder.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Content` | `Maps`文件夹。
- en: From the main menu, select `Level_MainMenu`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单中选择 `Level_MainMenu`。
- en: Open the level and, in the **Worlds Settings** panel, locate **GameMode Override**.
    In the corresponding drop-down menu, select **BP_MainMenuGameMode**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开关卡，在 **Worlds Settings** 面板中找到 **GameMode Override**。在相应的下拉菜单中，选择 **BP_MainMenuGameMode**。
- en: In the **Editor** main menu, select **Edit** | **Project Settings** and, in
    the newly opened window, locate the **Maps & Modes** section. Then, from the **Editor
    Template Map Overrides** drop-down menu, select **Level_MainMenu**.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Editor** 主菜单中，选择 **Edit** | **Project Settings**，并在新打开的窗口中找到 **Maps & Modes**
    部分。然后，从 **Editor Template Map Overrides** 下拉菜单中选择 **Level_MainMenu**。
- en: Congratulations, you’ve made it through this section and built your game’s starting
    level! With this, your players can now create and host game sessions like a boss
    on their LAN or join in on the action as a client. Let’s start testing these features
    by playing the game.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经通过了本节，并构建了游戏的开局关卡！现在，你的玩家可以像老板一样在自己的局域网中创建和托管游戏会话，或者作为客户端加入游戏。让我们通过玩游戏来测试这些功能。
- en: Testing the session system
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试会话系统
- en: 'To start testing a game session, open the **Level_MainMenu** map and play with
    these settings:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始测试游戏会话，打开 **Level_MainMenu** 地图，并使用以下设置进行游戏：
- en: Set **Net Mode** set to **Play Standalone**
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 **Net Mode** 设置为 **Play Standalone**
- en: Set `3`
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 `3`
- en: 'You will see the user interface you’ve created so far, as depicted in *Figure
    13**.3*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到你迄今为止创建的用户界面，如图 *图 13**.3* 所示：
- en: '![Figure 13.3 – The user interface](img/Figure_13_03_B18203.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3 – 用户界面](img/Figure_13_03_B18203.jpg)'
- en: Figure 13.3 – The user interface
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – 用户界面
- en: 'From this interface, you will be able to create a session, like so:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从此界面，你可以创建会话，如下所示：
- en: From the **Max Players** spinner, set the maximum number of players to **3**
    or more.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Max Players** 选择器中，将最大玩家数设置为 **3** 或更多。
- en: Click the **Create** button; you will start the game and see the game level.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Create** 按钮；你将开始游戏并看到游戏关卡。
- en: 'Then, to join a session, follow these steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要加入会话，请按照以下步骤操作：
- en: 'Select one of the other opened clients and click the **Find Session** button;
    this operation will start the server search and, after a while, you should see
    the list of available servers in the LAN, along with the number of players already
    connected. *Figure 13**.4* shows a game where there is a player already connected
    (that is, the listen server) with a maximum of 3 players:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择其他已打开的客户端之一，并点击 **Find Session** 按钮；此操作将启动服务器搜索，一段时间后，你应该能看到局域网中可用的服务器列表，以及已连接的玩家数量。*图
    13**.4* 展示了一个已有玩家连接的游戏（即监听服务器），最多可容纳 3 名玩家：
- en: '![Figure 13.4 – The session search result](img/Figure_13_04_B18203.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4 – 会话搜索结果](img/Figure_13_04_B18203.jpg)'
- en: Figure 13.4 – The session search result
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – 会话搜索结果
- en: Click the **Join Session** button to, well... join the session. Your character
    will be teleported to the game level and you will be able to start playing.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Join Session** 按钮以加入会话。你的角色将被传送到游戏关卡，你将能够开始游戏。
- en: In this section, you were introduced to session management and learned how to
    create, search for, and join sessions in a multiplayer game.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了会话管理，并学习了如何在多人游戏中创建、搜索和加入会话。
- en: Brace yourself because, in the upcoming section, you’ll be spicing up your game
    with an extra dose of customization. That’s right – get ready to add skin variants
    that will make each player’s character truly one of a kind. It’s time to get creative
    and let your imagination run wild!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好，因为在接下来的章节中，你将给你的游戏增添额外的定制化元素。没错——准备好添加皮肤变体，让每个玩家的角色真正独一无二。是时候发挥创意，让你的想象力自由驰骋了！
- en: Handling data during a session
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话期间处理数据
- en: 'In this section, you’ll be working on a new topic: passing data from one level
    to another when joining a session. You already possess almost all the knowledge
    necessary to perform this task – you just need to put things together.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习一个新的主题：在加入会话时，从一个关卡传递数据到另一个关卡。你已经几乎拥有了执行此任务所需的所有知识——你只需要将这些知识整合起来。
- en: 'What we need to do here is create a skin system for the character model that
    will do the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里需要做的是为角色模型创建一个皮肤系统，该系统将执行以下操作：
- en: Select a random skin in the main menu level from a list of possible variants
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从可能的变体列表中选择主菜单关卡中的随机皮肤
- en: Store this data while joining a session
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在加入会话时存储此数据
- en: Update the character skin variant once the session has been joined
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在加入会话后更新角色皮肤变体
- en: In the following steps, you will be working on a class that has remained inactive
    until this point, but that will prove to be incredibly useful moving forward.
    So, get ready to put the **US_GameInstance** class to work and see what it can
    do!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，您将开始处理一个直到现在都保持不活跃的类，但这个类将证明在未来的工作中非常有用。所以，准备好使用**US_GameInstance**类并看看它能做什么！
- en: Updating the US_GameInstance class
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新US_GameInstance类
- en: 'You may have forgotten but, at the beginning of this project, you created the
    **US_GameInstance** class. This class offers a couple of interesting peculiarities:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经忘记了，但在本项目的开始时，您创建了**US_GameInstance**类。这个类提供了一些有趣的特性：
- en: It is persistent across levels
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在各个级别之间是持久的
- en: It is unique for each client (that is, it is not replicated over the network)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对每个客户端都是唯一的（也就是说，它不会在网络中复制）
- en: 'These features make it an awesome candidate for transporting data between levels
    while keeping them locally. You can use it to pass things such as the experience
    points gained by a player or their actual equipment. In our case, we will be using
    it to store a really simple piece of information: an index of the selected skin
    of the character (we’ll be implementing the skin list later in this chapter).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性使它成为在本地保持数据的同时在级别之间传输数据的绝佳候选者。您可以使用它来传递诸如玩家获得的经验点或他们的实际装备等信息。在我们的案例中，我们将使用它来存储一个非常简单的信息：所选皮肤的索引（我们将在本章后面实现皮肤列表）。
- en: 'Open the `US_GameInstance.h` header file and, in the `public` section, add
    this declaration:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`US_GameInstance.h`头文件，在`public`部分添加以下声明：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As easy as it may seem, it’s all we need to pass the skin selection from one
    level to another!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来很简单，但这正是我们需要将皮肤选择从一个级别传递到另一个级别的所有内容！
- en: In the next few steps, we will be creating a data structure to handle the character
    skin variants.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个步骤中，我们将创建一个数据结构来处理角色皮肤变体。
- en: Adding the CharacterSkins data
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加CharacterSkins数据
- en: In this subsection, you’ll be creating a data structure similar to the one you
    created in [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125), *Replicating Properties*
    *O**ver the Network*, but this time, you will be storing just material references
    that will be used to change the character’s mesh colors.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，您将创建一个类似于您在[*第6章*](B18203_06.xhtml#_idTextAnchor125)中创建的数据结构，*在网络中复制属性*，但这次，您将只存储用于更改角色网格颜色的材质引用。
- en: 'The character model has six materials, as shown in *Figure 13**.5*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 角色模型有六个材质，如图*图13.5*所示：
- en: '![Figure 13.5 – The character model materials](img/Figure_13_05_B18203.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5 – 角色模型材质](img/Figure_13_05_B18203.jpg)'
- en: Figure 13.5 – The character model materials
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 – 角色模型材质
- en: For the character customization, we will only need four of them - specifically,
    **Element 0**, **Element 1**, and **Element 2**, all of which will change the
    character’s hair and clothes, and **Element 4**, which will change the character’s
    skin.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于角色定制，我们只需要其中四个——具体来说，是**元素0**、**元素1**和**元素2**，它们都将改变角色的头发和衣服，以及**元素4**，它将改变角色的皮肤。
- en: Creating the structure
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建结构
- en: 'To create the structure that will contain the skin data, open your programming
    IDE and create a file named `US_CharacterSkins.h`. Then, inside that file, add
    the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建包含皮肤数据的结构，打开您的编程IDE，创建一个名为`US_CharacterSkins.h`的文件。然后，在该文件中添加以下代码：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, we are creating a data structure from `FTableRowBase` – the
    structure that will let us create data tables – and then we are declaring the
    four material references. As a side note, remember that the `UNREALSHADOWS_LOTL_API
    API` identifier may change, depending on your project name.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在从`FTableRowBase`创建一个数据结构——这个结构将使我们能够创建数据表——然后我们声明了四个材质引用。顺便提一下，请记住，`UNREALSHADOWS_LOTL_API
    API`标识符可能会根据您的项目名称而改变。
- en: In the next steps, you will be creating the actual skin data out of this structure
    by generating a data table.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，您将通过生成数据表来从该结构创建实际的皮肤数据。
- en: Creating the data table
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建数据表
- en: 'Now that you have created a data structure, you are ready to create the actual
    data from it. To create your skin data table, follow these steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经创建了一个数据结构，您就可以从它创建实际的数据了。要创建您的皮肤数据表，请按照以下步骤操作：
- en: Open your **Blueprints** folder in the Content Browser, right-click, and select
    **Miscellaneous** | **Data Table**.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中打开您的**Blueprints**文件夹，右键单击，然后选择**Miscellaneous** | **Data Table**。
- en: In the **Pick Row Structure** pop-up window, select **US_CharacterSkins** from
    the drop-down menu.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**选择行结构**弹出窗口中，从下拉菜单中选择**US_CharacterSkins**。
- en: Click the `DT_CharacterSkins`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`DT_CharacterSkins`。
- en: Double-click on the newly created asset to open it. You will get an empty dataset;
    create your character skin rows by using any material from the project (or create
    custom materials!).
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击新创建的资产以打开它。你将得到一个空的数据集；使用项目中的任何材质（或创建自定义材质！）创建你的角色皮肤行。
- en: 'During the development phase, I like to create debug skins that will help me
    identify each unique character. In this case, I used a single color for all the
    elements in a row set (that is, all green, all red, or all blue), as shown in
    *Figure 13**.6*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发阶段，我喜欢创建调试皮肤，这有助于我识别每个独特的角色。在这种情况下，我使用单一颜色为行集中的所有元素（即所有绿色、所有红色或所有蓝色），如图*图13.6*所示：
- en: '![Figure 13.6 – The Skins data table](img/Figure_13_06_B18203.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图13.6 – 皮肤数据表](img/Figure_13_06_B18203.jpg)'
- en: Figure 13.6 – The Skins data table
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 – 皮肤数据表
- en: Once you are satisfied with the skin system and you have battle-tested it, you
    will need some more realistic skins for your thief character; this process will
    be as easy as creating a new data table with the skin colors of your choice and
    setting this table as the selected one in the **Pawn** variable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对皮肤系统感到满意并且已经对其进行了实战测试，你将需要为你的盗贼角色添加一些更逼真的皮肤；这个过程将和创建一个新的包含你选择皮肤颜色的数据表并将此表设置为**Pawn**变量中的选中表一样简单。
- en: Now that you have a skin catalog asset, you can start adding code to the main
    menu `Pawn` class to set its skins at runtime.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了皮肤目录资产，你可以开始向主菜单`Pawn`类添加代码以在运行时设置其皮肤。
- en: Updating the US_MainMenuPawn class
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新`US_MainMenuPawn`类
- en: In this section, you’ll be enhancing your character’s appearance by assigning
    a random skin. Every time players connect to the main menu level, their character
    will be allotted a unique set of colors for their skin, taken from the previously
    created data table. So, get ready to see a little more variety in your game!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个部分，你将通过分配随机皮肤来增强角色的外观。每次玩家连接到主菜单级别时，他们的角色将获得一个独特的皮肤颜色组合，这些颜色来自之前创建的数据表。所以，准备好在游戏中看到更多样性吧！
- en: As I mentioned previously, you dealt with this in [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125),
    *Replicating Properties Over the Network*, but as the old saying goes, practice
    makes perfect!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，你在[*第6章*](B18203_06.xhtml#_idTextAnchor125)中处理了这个问题，*在网络中复制属性*，但正如老话所说，熟能生巧！
- en: 'With your programming IDE, open the `US_MainMenuPawn.h` header file and, in
    the implicit `private` section, add the data table and skin declarations:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的编程IDE打开`US_MainMenuPawn.h`头文件，并在隐式的`private`部分添加数据表和皮肤声明：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, in the `public` section, add the getter method for the selected character
    skin:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`public`部分，添加选中角色皮肤的获取方法：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And in the `protected` section, declare a function that will handle the skin
    randomization process:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`protected`部分，声明一个将处理皮肤随机化过程的函数：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, you can open the `US_MainMenuPawn.cpp` file to start adding the skin handling
    implementation. First of all, declare the needed includes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以打开`US_MainMenuPawn.cpp`文件以开始添加皮肤处理实现。首先，声明所需的包含：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, add the `RandomizeCharacterSkin()` implementation:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加`RandomizeCharacterSkin()`的实现：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, we are retrieving all the data rows from the table reference
    and, after checking that there is at least one item in the table, we get a random
    row and set the pawn mesh materials to its included data. This will update the
    pawn shown in the level. After that, we retrieve the game instance as a `UUS_GameInstance`
    type and assign the previously randomized index to the `SkinIndex` property.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在从表引用中检索所有数据行，并在确认表中至少有一个项目后，我们获取一个随机行并将Pawn网格材质设置为其中包含的数据。这将更新级别中显示的Pawn。之后，我们检索游戏实例作为`UUS_GameInstance`类型并将之前随机化的索引分配给`SkinIndex`属性。
- en: 'As a last step, we will be adding the randomization call when the game is started.
    So, in the `BeginPlay()` method, add the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们将在游戏开始时添加随机化调用。因此，在`BeginPlay()`方法中，添加以下代码：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We now need to set the data table from the Blueprint, so let’s switch back to
    the Unreal Engine Editor.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要从蓝图设置数据表，所以让我们切换回Unreal Engine编辑器。
- en: Updating the BP_MainMenuPawn Blueprint
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新`BP_MainMenuPawn`蓝图
- en: 'Now that the `Pawn` class is ready, you just have to assign the previously
    created data table to the Pawn Blueprint. To do so, open `BP_MainMenuPawn` and
    do the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在角色`Pawn`类已经准备好了，你只需将之前创建的数据表分配给Pawn蓝图。要做到这一点，打开`BP_MainMenuPawn`并执行以下操作：
- en: In the **Details** panel, look for the **Character Skin Data** **Table** property.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，查找**角色皮肤数据****表**属性。
- en: 'From its drop-down menu, select **DT_CharacterSkins**, as shown in *Figure
    13**.7*:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择**DT_CharacterSkins**，如图*图13**.7*所示：
- en: '![Figure 13.7 – The character skin data table property](img/Figure_13_07_B18203.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图13.7 – 角色皮肤数据表属性](img/Figure_13_07_B18203.jpg)'
- en: Figure 13.7 – The character skin data table property
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 – 角色皮肤数据表属性
- en: 'If you test the game, you will get a randomized skin for each of the characters,
    as depicted in *Figure 13**.8*:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您测试游戏，您将为每个角色随机分配一个皮肤，如图*图13**.8*所示：
- en: '![Figure 13.8 – The starting skin randomization](img/Figure_13_08_B18203.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图13.8 – 开始时的皮肤随机化](img/Figure_13_08_B18203.jpg)'
- en: Figure 13.8 – The starting skin randomization
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8 – 开始时的皮肤随机化
- en: The character randomization is complete; to take full advantage of it, we just
    need to retrieve the data from the game level side and assign it to the playing
    character.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 角色随机化已完成；为了充分利用它，我们只需从游戏关卡侧检索数据并将其分配给正在玩的角色。
- en: Updating the US_Character class
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新US_Character类
- en: In this subsection, you will be retrieving the skin index data from the game
    instance and setting it to the player character. This process is quite straightforward
    once you remember that the game instance is persistent across levels and is not
    replicated (that is, each client has its own dedicated one).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，您将从游戏实例中检索皮肤索引数据并将其设置到玩家角色。一旦您记住游戏实例在关卡之间是持久的并且不会被复制（即每个客户端都有自己的专用实例），这个过程就相当直接了。
- en: 'Start by opening the `US_Character.h` header file from your programming IDE
    and declare the needed data table properties in the implicit `private` section:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从您的编程IDE中打开`US_Character.h`头文件，并在隐式的`private`部分声明所需的数据表属性：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I know you are already familiar with the previous declarations, so I won’t waste
    your time by explaining them again.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道您已经熟悉之前的声明，所以不会浪费您的时间再次解释它们。
- en: 'Next, in the `protected` section, you need to add the following declarations.
    These will handle the skin update:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`protected`部分，您需要添加以下声明。这些声明将处理皮肤更新：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And in the `public` section, add the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`public`部分，添加以下代码：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you may remember from [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125), *Replicating
    Properties Over the Network*, whenever you need to replicate a property, you can
    use the `ReplicatedUsing` property specifier to notify all clients that the property
    value has changed. In this case, we will replicate the `SkinIndex` variable to
    let all of the clients update their character skins once they join a session.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从[*第6章*](B18203_06.xhtml#_idTextAnchor125)，“通过网络复制属性”中可能记得的，每当您需要复制一个属性时，您可以使用`ReplicatedUsing`属性指定符来通知所有客户端属性值已更改。在这种情况下，我们将复制`SkinIndex`变量，以便所有客户端在加入会话后更新他们的角色皮肤。
- en: Additionally, always keep in mind that, to replicate a property, it should be
    initialized inside the `GetLifetimeReplicatedProps()` method through the `DOREPLIFETIME`
    macro, which is why we declared that method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，始终记住，为了复制一个属性，它应该在`GetLifetimeReplicatedProps()`方法中通过`DOREPLIFETIME`宏进行初始化，这就是我们声明该方法的原因。
- en: 'To implement all the replication logic and skin update, open the `US_Character.cpp`
    file and start by adding the needed `include` declarations:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现所有复制逻辑和皮肤更新，打开`US_Character.cpp`文件，并首先添加所需的`include`声明：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, add the `GetLifetimeReplicatedProps()` method implementation to implement
    the property replication:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加`GetLifetimeReplicatedProps()`方法实现以实现属性复制：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, add the `OnRep_SkinChanged()` method. This will be executed every time
    the `SkinIndex` value is updated from the server to the clients:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加`OnRep_SkinChanged()`方法。每当`SkinIndex`值从服务器更新到客户端时，此方法将被执行：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, implement the skin index update from the server side by adding the `SetSkinIndex_Server_Implementation()`
    method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过添加`SetSkinIndex_Server_Implementation()`方法从服务器端实现皮肤索引更新：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that we are calling the `UpdateCharacerSkin()` event from the server side;
    this is mandatory if you are using a listen server because the previous method
    will be called only on the clients and, in that case, the server will not update
    the skin.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们是从服务器端调用`UpdateCharacerSkin()`事件；如果您使用的是监听服务器，这是强制性的，因为前一个方法只会在客户端调用，在这种情况下，服务器将不会更新皮肤。
- en: 'The fourth method, `UpdateCharacterSkin()`, will take care of retrieving the
    data from the game instance and updating the character mesh materials. To do so,
    add the following implementation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第四种方法，`UpdateCharacterSkin()`，将负责从游戏实例检索数据并更新角色网格材质。为此，请添加以下实现：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What we are doing here is almost identical to the main menu Pawn class; we are
    getting a row from the skin data table and assigning the materials to the character
    mesh. The only difference is that we are not setting the skin index to the game
    instance, and we are getting a replicated version of it instead.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是几乎与主菜单 Pawn 类相同的；我们从一个皮肤数据表中获取一行，并将材质分配给角色网格。唯一的区别是我们没有将皮肤索引设置到游戏实例中，而是获取了它的复制版本。
- en: 'As a last step, you will need to add the following code at the end of the `BeginPlay()`
    method’s implementation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，你需要在 `BeginPlay()` 方法实现的末尾添加以下代码：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This portion of the code checks that the instance of this class is locally controlled
    (that is, it is a player-owned character) and gets the skin index from the game
    instance. Then, it calls the `SetSkinIndex()` server function to notify all the
    clients that they should update this character look.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查这个类的实例是否是本地控制的（也就是说，它是一个玩家拥有的角色），并从游戏实例中获取皮肤索引。然后，它调用 `SetSkinIndex()`
    服务器函数来通知所有客户端他们应该更新这个角色的外观。
- en: As for the main menu Pawn class, you now need to update the corresponding Blueprint
    to declare the skin data table.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主菜单 Pawn 类，你现在需要更新相应的蓝图来声明皮肤数据表。
- en: Updating the BP_Character Blueprint
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 BP_Character 蓝图
- en: 'Now that the character class is ready, you just have to assign the previously
    created data table to the corresponding Blueprint. To do so, follow these steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在角色类别已经准备好了，你只需将之前创建的数据表分配给相应的蓝图。为此，请按照以下步骤操作：
- en: Open **BP_Character**.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **BP_Character**。
- en: In the **Details** panel, look for the **Character Skin Data** **Table** property.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，查找**角色皮肤数据****表**属性。
- en: 'From its drop-down menu, select **DT_CharacterSkins**, as shown in *Figure
    13**.9*:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择**DT_CharacterSkins**，如图 *图 13.9* 所示：
- en: '![Figure 13.9 – The character skin data table property](img/Figure_13_09_B18203.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.9 – 角色皮肤数据表属性](img/Figure_13_09_B18203.jpg)'
- en: Figure 13.9 – The character skin data table property
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9 – 角色皮肤数据表属性
- en: 'If you test the game now, you will be able to get a randomized skin for each
    of the characters and keep that skin once a session is joined, as depicted in
    *Figure 13**.10*:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在测试游戏，你将为每个角色随机分配一个皮肤，并在加入会话后保留该皮肤，如图 *图 13.10* 所示：
- en: '![Figure 13.10 – Gameplay with skinned characters](img/Figure_13_10_B18203.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.10 – 使用皮肤角色的游戏玩法](img/Figure_13_10_B18203.jpg)'
- en: Figure 13.10 – Gameplay with skinned characters
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.10 – 使用皮肤角色的游戏玩法
- en: In this section, you learned how to keep data when creating or joining a session.
    You did this by using the game instance as a sort of data bridge to create a skinning
    feature; this will make each character unique and even more appealing to the players,
    helping you give them a killer makeover that will make the Lichlord quake in his
    boots!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何在创建或加入会话时保留数据。你是通过将游戏实例作为某种数据桥来创建皮肤功能来做到这一点的；这将使每个角色独一无二，甚至更有吸引力，帮助你给他们一个杀手级的改造，让巫妖王都感到脚底发凉！
- en: In the upcoming section, I won’t be introducing any new topics; instead, I’ll
    give you some additional ideas to help you better manage your game sessions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我不会介绍任何新主题；相反，我将给你一些额外的想法，帮助你更好地管理你的游戏会话。
- en: Making further improvements
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步改进
- en: In the previous sections, you did a great job of understanding how to pass data
    between sessions to make your multiplayer game even more engaging. Now, it’s time
    to make your game even better by adding some additional functionalities. In this
    section, I’ll offer some tips to help you add some excitement to your project.
    As always, don’t be afraid to add your personal touch and make it truly yours.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你出色地理解了如何在会话之间传递数据，使你的多人游戏更具吸引力。现在，是时候通过添加一些附加功能来使你的游戏更加出色了。在本节中，我将提供一些技巧来帮助你给你的项目增添一些兴奋感。一如既往，不要害怕加入你个人的风格，让它真正属于你。
- en: Leaving and destroying sessions
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 离开和销毁会话
- en: In this chapter and the previous one, you have used three out of four session
    commands – **Create Session**, **Join Session**, and **Find Session** – but the
    **Destroy Session** command has been left unused. Use the **Destroy Session**
    command node to let the player leave a playing session.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和上一章中，您已经使用了四个会话命令中的三个——**创建会话**、**加入会话**和**查找会话**——但**销毁会话**命令尚未使用。使用**销毁会话**命令节点让玩家离开游戏会话。
- en: This will be implemented in the game level (and not in the main menu one) as
    the player will need to leave the session after joining one. To implement this
    feature, you may want to create a dedicated user interface that will let players
    leave the game whenever they decide to do so.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在游戏关卡（而不是主菜单）中实现，因为玩家在加入会话后需要离开。为了实现这个功能，您可能想要创建一个专门的用户界面，让玩家在决定离开游戏时随时可以离开。
- en: 'As a side note, keep in mind that clients and the server behave differently
    regarding a session, so you will have to manage two kinds of session destruction:
    the one from the client – which will be almost painless – and, in the case of
    a client/server host, the server one – which will have to destroy all sessions
    from all clients (that is, all clients should leave the session as the server
    is not functional anymore).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，请记住，客户端和服务器在会话方面表现不同，因此您将不得不管理两种会话销毁：客户端的——这几乎是无痛的——以及在客户端/服务器主机的情况下，服务器的——这需要销毁所有客户端的会话（也就是说，所有客户端都应该离开会话，因为服务器不再起作用了）。
- en: Handling player death
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理玩家死亡
- en: At the moment, whenever a player is captured by a Lichlord minion, nothing will
    happen – you will get just a screen message and the player will keep on playing.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，当玩家被巫妖领主的小兵捕获时，什么也不会发生——您只会看到一个屏幕信息，玩家将继续游戏。
- en: 'You can manage a player’s death in many ways, but here are a couple of ideas
    for you:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过许多方式管理玩家的死亡，但这里有一些想法供您参考：
- en: Destroy the player session and reload the main menu level to let the player
    join a new session. Just keep in mind that, if the player that is defeated is
    the server host, all other players will be immediately removed from the session.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁玩家会话并重新加载主菜单关卡，让玩家加入新的会话。只是记住，如果被击败的玩家是服务器主机，所有其他玩家将立即被从会话中移除。
- en: Use a respawn method, where the character will be placed in an available spawn
    point without the need to rejoin the session.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用重生方法，将角色放置在可用的出生点，无需重新加入会话。
- en: Selecting the player skin
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择玩家皮肤
- en: 'In this chapter, you developed a random skin generator, but wouldn’t be cool
    to let the players choose their own skin? You may add a user interface in the
    main menu level that will let the players do the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您开发了一个随机皮肤生成器，但让玩家选择自己的皮肤不是更酷吗？您可以在主菜单级别添加一个用户界面，让玩家执行以下操作：
- en: Randomize the skin again if it does not suit their needs
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果皮肤不符合他们的需求，请再次随机化皮肤
- en: Select the desired skin from the full set using a dedicated selection method
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用专用选择方法从完整集合中选择所需的皮肤
- en: Well, this could be the tip of the iceberg when it comes to creating a skin
    system that works like a charm and gets envious stares from your competitors.
    Who knows? Implementing your in-game purchases might even make games such as Fortnite
    weak in the knees!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，当谈到创建一个像魔法一样起作用且让竞争对手羡慕的皮肤系统时，这可能是冰山一角。谁知道呢？实现您的游戏内购买甚至可能让像堡垒之夜这样的游戏感到膝盖发软！
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you developed a fully functional system to pass data from one
    level to another during a game session. In this case, you focused on a skin system
    for the player character, but the use cases for this feature are almost endless.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您开发了一个在游戏会话期间从一个关卡传递到另一个关卡数据的完整功能系统。在这种情况下，您专注于玩家角色的皮肤系统，但这个特性的用例几乎是无限的。
- en: As you may have noticed, session handling is a huge topic – it took two chapters
    to properly explain its main functionalities – and to succeed in the multiplayer
    world, it is imperative to have a strong grasp of it. If you want to ride the
    wave of success, then mastering this skill is a non-negotiable topic!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所注意到的，会话处理是一个巨大的主题——它需要两章来正确解释其主要功能——在多人游戏世界中取得成功，掌握它至关重要。如果您想要乘风破浪，那么掌握这项技能是一个不容商量的主题！
- en: 'In the next chapter, I will guide you through a brand new topic: how to properly
    package your game. Get ready to dive into the exciting world of project packaging
    so that you can deploy your game like a boss on both server and client ends! Are
    you ready for this adventure?'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将引导你探索一个全新的主题：如何正确地打包你的游戏。准备好深入探索项目打包的精彩世界，以便你能在服务器和客户端两端像老板一样部署你的游戏！你准备好迎接这次冒险了吗？
