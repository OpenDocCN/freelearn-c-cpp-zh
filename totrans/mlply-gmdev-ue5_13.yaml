- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling Data During a Session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work on a multiplayer game, you need a solid system in place to manage the
    flow of data between levels. This means tracking variables – such as character
    inventory or health – to keep players up to date with the information they need.
    In short, an effective multiplayer game requires careful management of data to
    ensure a smooth, engaging experience for all players.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll be adding the final touches to the previous chapter’s
    session system by creating a system that will serve as an entry point for the
    players. This means working on a new level that will let the player create a session
    – if they’re starting the game as a server – or look for available sessions in
    the network – if they’re playing as a client.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you will learn how to customize the player character – by adding
    skin variants – and how to send this data from the session selection level to
    the actual game level. This will make your character special and even more cool
    and colorful than before!
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to host a local network game session
    with a computer acting as a listen server and other PCs connecting to it as clients
    and have different skins for every player in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I will guide you through the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the main menu level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling data during a session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making further improvements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the topics presented in this chapter, you should have completed [*Chapter
    12*](B18203_12.xhtml#_idTextAnchor239), *Managing Multiplayer Sessions*, and understood
    its content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, if you would prefer to begin with the code from the companion
    repository for this book, you can download the `.zip` project files provided in
    this book’s companion project repository: [https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5).'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the files that are up to date with the end of the previous
    chapter by clicking the `Unreal Shadows –` [*Chapter 12*](B18203_12.xhtml#_idTextAnchor239)`End`
    link.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the main menu level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll be working on creating a new level that will serve as
    a starting point for creating a game session or joining one. You’ll be leveraging
    the power and flexibility of the previously created user interface by adding the
    needed Gameplay Framework classes, such as a dedicated GameMode and a player Pawn.
  prefs: []
  type: TYPE_NORMAL
- en: First things first, let’s open up your programming IDE and start writing some
    code!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Pawn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, you’ll be creating a Pawn that will show the character model
    and activate the user interface through its controller. This Actor will also be
    used to show the character model when the player enters the main menu level.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, from the Unreal Engine Editor, create a new C++ class extending from `US_MainMenuPawn`.
    Once the class has been created, open the `US_MainMenuPawn.h` header file and
    add the following code just after the `GENERATED_BODY()` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `protected` section, add the corresponding getter functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: All of the previous code is quite straightforward, and you should already be
    familiar with it from the previous chapters; we are declaring the needed components
    – an arrow, a camera, and a mesh – and then we are exposing the corresponding
    getter methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the `US_MainMenuPawn.cpp` file and add the needed `include` declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, locate the constructor and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We are not adding anything new here. As normal, we are just adding a list of
    components for the Actor, including a utility arrow element, the mesh, and the
    camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the basic `Pawn` class has been created, it’s time to implement a
    Blueprint from it and add the previously created user interface. So, return to
    the Unreal Engine Editor and, in the `BP_MainMenuPawn`. Then, open the Blueprint
    and, in the Event Graph, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Get Player** **Controller** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Create Widget** node to the graph and connect its incoming execution
    pin to the outgoing execution pin of the **Event** **BeginPlay** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Class** drop-down menu, select the **WB_MainMenu** class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Owning Player** pin to the **Return** value of the **Get Player**
    **Controller** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the outgoing execution pin of the **Create Widget** node, click and drag
    to add an **Add to Viewport** node. Then, connect the **Target** pin to **Return
    Value** of the **Create** **Widget** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag from **Return Value** of the **Get Player Controller** node to
    add **Set Show Mouse Cursor**. Then, tick the **Show Mouse Cursor** checkbox and
    connect the incoming execution pin to the outgoing execution pin of the **Add
    to** **Viewport** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final graph is depicted in *Figure 13**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – The final graph for the BP_MainMenuPawn Blueprint](img/Figure_13_01_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – The final graph for the BP_MainMenuPawn Blueprint
  prefs: []
  type: TYPE_NORMAL
- en: The `BP_MainMenuPawn` Blueprint is complete and ready to go, so we can now move
    on to working on the GameMode class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the GameMode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s now time to create the GameMode that will handle the main menu level. In
    the `BP_MainMenuGameMode`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the Blueprint. Then, in the **Details** panel, locate the **Classes**
    category and, in the **Default Pawn Class** drop-down menu, select **BP_MainMenuPawn**,
    as shown in *Figure 13**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – The BP_MainMenuGameMode settings](img/Figure_13_02_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – The BP_MainMenuGameMode settings
  prefs: []
  type: TYPE_NORMAL
- en: The GameMode is now ready; we just need to create a new level and use it to
    show the session user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating the main menu level is quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Content` | `Maps` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the main menu, select `Level_MainMenu`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the level and, in the **Worlds Settings** panel, locate **GameMode Override**.
    In the corresponding drop-down menu, select **BP_MainMenuGameMode**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Editor** main menu, select **Edit** | **Project Settings** and, in
    the newly opened window, locate the **Maps & Modes** section. Then, from the **Editor
    Template Map Overrides** drop-down menu, select **Level_MainMenu**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations, you’ve made it through this section and built your game’s starting
    level! With this, your players can now create and host game sessions like a boss
    on their LAN or join in on the action as a client. Let’s start testing these features
    by playing the game.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the session system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start testing a game session, open the **Level_MainMenu** map and play with
    these settings:'
  prefs: []
  type: TYPE_NORMAL
- en: Set **Net Mode** set to **Play Standalone**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `3`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will see the user interface you’ve created so far, as depicted in *Figure
    13**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – The user interface](img/Figure_13_03_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – The user interface
  prefs: []
  type: TYPE_NORMAL
- en: 'From this interface, you will be able to create a session, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **Max Players** spinner, set the maximum number of players to **3**
    or more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create** button; you will start the game and see the game level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, to join a session, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select one of the other opened clients and click the **Find Session** button;
    this operation will start the server search and, after a while, you should see
    the list of available servers in the LAN, along with the number of players already
    connected. *Figure 13**.4* shows a game where there is a player already connected
    (that is, the listen server) with a maximum of 3 players:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.4 – The session search result](img/Figure_13_04_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – The session search result
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Join Session** button to, well... join the session. Your character
    will be teleported to the game level and you will be able to start playing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, you were introduced to session management and learned how to
    create, search for, and join sessions in a multiplayer game.
  prefs: []
  type: TYPE_NORMAL
- en: Brace yourself because, in the upcoming section, you’ll be spicing up your game
    with an extra dose of customization. That’s right – get ready to add skin variants
    that will make each player’s character truly one of a kind. It’s time to get creative
    and let your imagination run wild!
  prefs: []
  type: TYPE_NORMAL
- en: Handling data during a session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you’ll be working on a new topic: passing data from one level
    to another when joining a session. You already possess almost all the knowledge
    necessary to perform this task – you just need to put things together.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to do here is create a skin system for the character model that
    will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select a random skin in the main menu level from a list of possible variants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store this data while joining a session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the character skin variant once the session has been joined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following steps, you will be working on a class that has remained inactive
    until this point, but that will prove to be incredibly useful moving forward.
    So, get ready to put the **US_GameInstance** class to work and see what it can
    do!
  prefs: []
  type: TYPE_NORMAL
- en: Updating the US_GameInstance class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have forgotten but, at the beginning of this project, you created the
    **US_GameInstance** class. This class offers a couple of interesting peculiarities:'
  prefs: []
  type: TYPE_NORMAL
- en: It is persistent across levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is unique for each client (that is, it is not replicated over the network)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These features make it an awesome candidate for transporting data between levels
    while keeping them locally. You can use it to pass things such as the experience
    points gained by a player or their actual equipment. In our case, we will be using
    it to store a really simple piece of information: an index of the selected skin
    of the character (we’ll be implementing the skin list later in this chapter).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `US_GameInstance.h` header file and, in the `public` section, add
    this declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As easy as it may seem, it’s all we need to pass the skin selection from one
    level to another!
  prefs: []
  type: TYPE_NORMAL
- en: In the next few steps, we will be creating a data structure to handle the character
    skin variants.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the CharacterSkins data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, you’ll be creating a data structure similar to the one you
    created in [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125), *Replicating Properties*
    *O**ver the Network*, but this time, you will be storing just material references
    that will be used to change the character’s mesh colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The character model has six materials, as shown in *Figure 13**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – The character model materials](img/Figure_13_05_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – The character model materials
  prefs: []
  type: TYPE_NORMAL
- en: For the character customization, we will only need four of them - specifically,
    **Element 0**, **Element 1**, and **Element 2**, all of which will change the
    character’s hair and clothes, and **Element 4**, which will change the character’s
    skin.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create the structure that will contain the skin data, open your programming
    IDE and create a file named `US_CharacterSkins.h`. Then, inside that file, add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are creating a data structure from `FTableRowBase` – the
    structure that will let us create data tables – and then we are declaring the
    four material references. As a side note, remember that the `UNREALSHADOWS_LOTL_API
    API` identifier may change, depending on your project name.
  prefs: []
  type: TYPE_NORMAL
- en: In the next steps, you will be creating the actual skin data out of this structure
    by generating a data table.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the data table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you have created a data structure, you are ready to create the actual
    data from it. To create your skin data table, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your **Blueprints** folder in the Content Browser, right-click, and select
    **Miscellaneous** | **Data Table**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Pick Row Structure** pop-up window, select **US_CharacterSkins** from
    the drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `DT_CharacterSkins`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the newly created asset to open it. You will get an empty dataset;
    create your character skin rows by using any material from the project (or create
    custom materials!).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'During the development phase, I like to create debug skins that will help me
    identify each unique character. In this case, I used a single color for all the
    elements in a row set (that is, all green, all red, or all blue), as shown in
    *Figure 13**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – The Skins data table](img/Figure_13_06_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – The Skins data table
  prefs: []
  type: TYPE_NORMAL
- en: Once you are satisfied with the skin system and you have battle-tested it, you
    will need some more realistic skins for your thief character; this process will
    be as easy as creating a new data table with the skin colors of your choice and
    setting this table as the selected one in the **Pawn** variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a skin catalog asset, you can start adding code to the main
    menu `Pawn` class to set its skins at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the US_MainMenuPawn class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you’ll be enhancing your character’s appearance by assigning
    a random skin. Every time players connect to the main menu level, their character
    will be allotted a unique set of colors for their skin, taken from the previously
    created data table. So, get ready to see a little more variety in your game!
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned previously, you dealt with this in [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125),
    *Replicating Properties Over the Network*, but as the old saying goes, practice
    makes perfect!
  prefs: []
  type: TYPE_NORMAL
- en: 'With your programming IDE, open the `US_MainMenuPawn.h` header file and, in
    the implicit `private` section, add the data table and skin declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the `public` section, add the getter method for the selected character
    skin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the `protected` section, declare a function that will handle the skin
    randomization process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can open the `US_MainMenuPawn.cpp` file to start adding the skin handling
    implementation. First of all, declare the needed includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the `RandomizeCharacterSkin()` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are retrieving all the data rows from the table reference
    and, after checking that there is at least one item in the table, we get a random
    row and set the pawn mesh materials to its included data. This will update the
    pawn shown in the level. After that, we retrieve the game instance as a `UUS_GameInstance`
    type and assign the previously randomized index to the `SkinIndex` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a last step, we will be adding the randomization call when the game is started.
    So, in the `BeginPlay()` method, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We now need to set the data table from the Blueprint, so let’s switch back to
    the Unreal Engine Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the BP_MainMenuPawn Blueprint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the `Pawn` class is ready, you just have to assign the previously
    created data table to the Pawn Blueprint. To do so, open `BP_MainMenuPawn` and
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Details** panel, look for the **Character Skin Data** **Table** property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From its drop-down menu, select **DT_CharacterSkins**, as shown in *Figure
    13**.7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.7 – The character skin data table property](img/Figure_13_07_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – The character skin data table property
  prefs: []
  type: TYPE_NORMAL
- en: 'If you test the game, you will get a randomized skin for each of the characters,
    as depicted in *Figure 13**.8*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.8 – The starting skin randomization](img/Figure_13_08_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – The starting skin randomization
  prefs: []
  type: TYPE_NORMAL
- en: The character randomization is complete; to take full advantage of it, we just
    need to retrieve the data from the game level side and assign it to the playing
    character.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the US_Character class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, you will be retrieving the skin index data from the game
    instance and setting it to the player character. This process is quite straightforward
    once you remember that the game instance is persistent across levels and is not
    replicated (that is, each client has its own dedicated one).
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by opening the `US_Character.h` header file from your programming IDE
    and declare the needed data table properties in the implicit `private` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: I know you are already familiar with the previous declarations, so I won’t waste
    your time by explaining them again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the `protected` section, you need to add the following declarations.
    These will handle the skin update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the `public` section, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you may remember from [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125), *Replicating
    Properties Over the Network*, whenever you need to replicate a property, you can
    use the `ReplicatedUsing` property specifier to notify all clients that the property
    value has changed. In this case, we will replicate the `SkinIndex` variable to
    let all of the clients update their character skins once they join a session.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, always keep in mind that, to replicate a property, it should be
    initialized inside the `GetLifetimeReplicatedProps()` method through the `DOREPLIFETIME`
    macro, which is why we declared that method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement all the replication logic and skin update, open the `US_Character.cpp`
    file and start by adding the needed `include` declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the `GetLifetimeReplicatedProps()` method implementation to implement
    the property replication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the `OnRep_SkinChanged()` method. This will be executed every time
    the `SkinIndex` value is updated from the server to the clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, implement the skin index update from the server side by adding the `SetSkinIndex_Server_Implementation()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are calling the `UpdateCharacerSkin()` event from the server side;
    this is mandatory if you are using a listen server because the previous method
    will be called only on the clients and, in that case, the server will not update
    the skin.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth method, `UpdateCharacterSkin()`, will take care of retrieving the
    data from the game instance and updating the character mesh materials. To do so,
    add the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: What we are doing here is almost identical to the main menu Pawn class; we are
    getting a row from the skin data table and assigning the materials to the character
    mesh. The only difference is that we are not setting the skin index to the game
    instance, and we are getting a replicated version of it instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a last step, you will need to add the following code at the end of the `BeginPlay()`
    method’s implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This portion of the code checks that the instance of this class is locally controlled
    (that is, it is a player-owned character) and gets the skin index from the game
    instance. Then, it calls the `SetSkinIndex()` server function to notify all the
    clients that they should update this character look.
  prefs: []
  type: TYPE_NORMAL
- en: As for the main menu Pawn class, you now need to update the corresponding Blueprint
    to declare the skin data table.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the BP_Character Blueprint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the character class is ready, you just have to assign the previously
    created data table to the corresponding Blueprint. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **BP_Character**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Details** panel, look for the **Character Skin Data** **Table** property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From its drop-down menu, select **DT_CharacterSkins**, as shown in *Figure
    13**.9*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.9 – The character skin data table property](img/Figure_13_09_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.9 – The character skin data table property
  prefs: []
  type: TYPE_NORMAL
- en: 'If you test the game now, you will be able to get a randomized skin for each
    of the characters and keep that skin once a session is joined, as depicted in
    *Figure 13**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10 – Gameplay with skinned characters](img/Figure_13_10_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.10 – Gameplay with skinned characters
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to keep data when creating or joining a session.
    You did this by using the game instance as a sort of data bridge to create a skinning
    feature; this will make each character unique and even more appealing to the players,
    helping you give them a killer makeover that will make the Lichlord quake in his
    boots!
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, I won’t be introducing any new topics; instead, I’ll
    give you some additional ideas to help you better manage your game sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Making further improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, you did a great job of understanding how to pass data
    between sessions to make your multiplayer game even more engaging. Now, it’s time
    to make your game even better by adding some additional functionalities. In this
    section, I’ll offer some tips to help you add some excitement to your project.
    As always, don’t be afraid to add your personal touch and make it truly yours.
  prefs: []
  type: TYPE_NORMAL
- en: Leaving and destroying sessions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter and the previous one, you have used three out of four session
    commands – **Create Session**, **Join Session**, and **Find Session** – but the
    **Destroy Session** command has been left unused. Use the **Destroy Session**
    command node to let the player leave a playing session.
  prefs: []
  type: TYPE_NORMAL
- en: This will be implemented in the game level (and not in the main menu one) as
    the player will need to leave the session after joining one. To implement this
    feature, you may want to create a dedicated user interface that will let players
    leave the game whenever they decide to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a side note, keep in mind that clients and the server behave differently
    regarding a session, so you will have to manage two kinds of session destruction:
    the one from the client – which will be almost painless – and, in the case of
    a client/server host, the server one – which will have to destroy all sessions
    from all clients (that is, all clients should leave the session as the server
    is not functional anymore).'
  prefs: []
  type: TYPE_NORMAL
- en: Handling player death
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the moment, whenever a player is captured by a Lichlord minion, nothing will
    happen – you will get just a screen message and the player will keep on playing.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can manage a player’s death in many ways, but here are a couple of ideas
    for you:'
  prefs: []
  type: TYPE_NORMAL
- en: Destroy the player session and reload the main menu level to let the player
    join a new session. Just keep in mind that, if the player that is defeated is
    the server host, all other players will be immediately removed from the session.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a respawn method, where the character will be placed in an available spawn
    point without the need to rejoin the session.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting the player skin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, you developed a random skin generator, but wouldn’t be cool
    to let the players choose their own skin? You may add a user interface in the
    main menu level that will let the players do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Randomize the skin again if it does not suit their needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the desired skin from the full set using a dedicated selection method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well, this could be the tip of the iceberg when it comes to creating a skin
    system that works like a charm and gets envious stares from your competitors.
    Who knows? Implementing your in-game purchases might even make games such as Fortnite
    weak in the knees!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you developed a fully functional system to pass data from one
    level to another during a game session. In this case, you focused on a skin system
    for the player character, but the use cases for this feature are almost endless.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, session handling is a huge topic – it took two chapters
    to properly explain its main functionalities – and to succeed in the multiplayer
    world, it is imperative to have a strong grasp of it. If you want to ride the
    wave of success, then mastering this skill is a non-negotiable topic!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, I will guide you through a brand new topic: how to properly
    package your game. Get ready to dive into the exciting world of project packaging
    so that you can deploy your game like a boss on both server and client ends! Are
    you ready for this adventure?'
  prefs: []
  type: TYPE_NORMAL
