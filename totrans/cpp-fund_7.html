<html><head></head><body>
		<div class="Content" id="_idContainer080">
			<h1 id="_idParaDest-218"><em class="italics"><a id="_idTextAnchor250"/>Appendix</em></h1>
		</div>
		<div>
			<div class="Content" id="_idContainer081">
			</div>
		</div>
		<div class="Content" id="_idContainer082">
			<h2>About</h2>
			<p>This section is included to assist the students to perform the activities in the book. It includes detailed steps that are to be performed by the students to achieve the objectives of the activities.</p>
		</div>
		<div class="Content" id="_idContainer083">
			<h2 id="_idParaDest-219"><a id="_idTextAnchor251"/>Lesson 1: Getting Started</h2>
			<h3 id="_idParaDest-220"><a id="_idTextAnchor252"/>Activity 1: Find the Factors of 7 between 1 and 100 Using a while Loop</h3>
			<ol>
				<li>Import all the required header files before the <strong class="inline">main</strong> function:<p class="snippet">#include &lt;iostream&gt;</p></li>
				<li>Inside the <strong class="inline">main</strong> function, create a variable <strong class="inline">i</strong> of type <strong class="inline">unsigned</strong>, and initialize its value as <strong class="inline">1</strong>:<p class="snippet">unsigned i = 1;</p></li>
				<li>Now, use the <strong class="inline">while</strong> loop adding the logic where the value of <strong class="inline">i</strong> should be less than <strong class="inline">100</strong>:<p class="snippet">while ( i &lt; 100){ }</p></li>
				<li>In the scope of the <strong class="inline">while</strong> loop, use the if statement with the following logic:<p class="snippet">if (i%7 == 0) {</p><p class="snippet">   std::cout &lt;&lt; i &lt;&lt; std::endl;</p><p class="snippet">}</p></li>
				<li>Increase the value of the <strong class="inline">i</strong> variable to iterate through the <strong class="inline">while</strong> loop to validate the condition:<p class="snippet">i++;</p><p>The output of the program is as follows:</p><p class="snippet">7</p><p class="snippet">14</p><p class="snippet">21</p><p class="snippet">28</p><p class="snippet">...</p><p class="snippet">98</p></li>
			</ol>
			<h3 id="_idParaDest-221"><a id="_idTextAnchor253"/>Activity 2: Define a Bi-Dimensional Array and Initialize Its Elements</h3>
			<ol>
				<li value="1">After creating a C++ file, include the following header file at the start of the program:<p class="snippet">#include &lt;iostream&gt;</p></li>
				<li>Now, in the <strong class="inline">main</strong> function, create a bi-directional array named <strong class="inline">foo</strong> of type integer, with three rows and three columns, as shown here:<p class="snippet">int main()</p><p class="snippet">{</p><p class="snippet">  int foo[3][3];</p></li>
				<li>Now, we will use the concept of a nested <strong class="inline">for</strong> loop to iterate through each index entry of the <strong class="inline">foo</strong> array:<p class="snippet">for (int x= 0; x &lt; 3; x++){</p><p class="snippet">  for (int y = 0; y &lt; 3; y++){</p><p class="snippet">  }</p><p class="snippet">}</p></li>
				<li>In the second <strong class="inline">for</strong> loop, add the following statement:<p class="snippet">foo[x][y] = x + y;</p></li>
				<li>Finally, iterate over the array again to print its values:<p class="snippet">for (int x = 0; x &lt; 3; x++){</p><p class="snippet">   for (int y = 0; y &lt; 3; y++){</p><p class="snippet">      std::cout &lt;&lt; “foo[“ &lt;&lt; x &lt;&lt; “][“ &lt;&lt; y &lt;&lt; “]: “ &lt;&lt; foo[x][y] &lt;&lt; std::endl;</p><p class="snippet">   }</p><p class="snippet">}</p><p>The output is as follows:</p><p class="snippet">foo[0][0]: 0</p><p class="snippet">foo[0][1]: 1</p><p class="snippet">foo[0][2]: 2</p><p class="snippet">foo[1][0]: 1</p><p class="snippet">foo[1][1]: 2</p><p class="snippet">foo[1][2]: 3</p><p class="snippet">foo[2][0]: 2</p><p class="snippet">foo[2][1]: 3</p><p class="snippet">foo[2][2]: 4</p></li>
			</ol>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor254"/>Lesson 2: Functions</h2>
			<h3 id="_idParaDest-223"><a id="_idTextAnchor255"/>Activity 3: Calculating if a Person is Eligible to Vote or Not</h3>
			<ol>
				<li value="1">Include the header file in the program to print the output as shown here:<p class="snippet">#include &lt;iostream&gt;</p></li>
				<li>Now, create a function named <strong class="inline">byreference_age_in_5_years</strong> and the <strong class="inline">if</strong> loop with the following condition to print the message:<p class="snippet">void byreference_age_in_5_years(int&amp; age) {</p><p class="snippet">  if (age &gt;= 18) {</p><p class="snippet">    std::cout &lt;&lt; “Congratulations! You are eligible to vote for your nation.” &lt;&lt; std::endl;</p><p class="snippet">    return;</p></li>
				<li>Add the <strong class="inline">else</strong> block to provide another condition if the age of the user is less than 18 years:<p class="snippet">  } else{</p><p class="snippet">    int reqAge = 18;</p><p class="snippet">    int yearsToGo = reqAge-age;</p><p class="snippet">    std::cout &lt;&lt; “No worries, just “&lt;&lt; yearsToGo &lt;&lt; “ more years to go.” &lt;&lt; std::endl;</p><p class="snippet">  }</p><p class="snippet">}</p></li>
				<li>In the <strong class="inline">main</strong> function, create a variable of type integer and pass it as a reference in the <strong class="inline">byreference_age_in_5_years</strong> function as shown:<p class="snippet">int main() {</p><p class="snippet">    int age;</p><p class="snippet">    std::cout &lt;&lt; “Please enter your age:”;</p><p class="snippet">    std::cin &gt;&gt; age;</p><p class="snippet">    byreference_age_in_5_years(age);</p><p class="snippet">}</p></li>
			</ol>
			<h3 id="_idParaDest-224"><a id="_idTextAnchor256"/>Activity 4: Apply the Understanding of Passing by Reference or Value in Functions</h3>
			<ol>
				<li value="1">After adding all the required header files, create the first function of type integer as shown here:<p class="snippet">int sum(int a, int b)</p><p class="snippet">{</p><p class="snippet">  return a + b</p><p class="snippet">}</p><p>Take by value, return by value, since the types are small in memory and there is no reason to use references.</p></li>
				<li>The second function should be written as follows:<p class="snippet">int&amp; getMaxOf(std::array&lt;int, 10&gt;&amp; array1, std::array&lt;int, 10&gt;&amp; array2, int index) {</p><p class="snippet">  if (array1[index] &gt;= array2[index]) {</p><p class="snippet">    return array1[index];</p><p class="snippet">  } else {</p><p class="snippet">    return array2[index];</p><p class="snippet">  }</p><p class="snippet">}</p></li>
			</ol>
			<h3 id="_idParaDest-225"><a id="_idTextAnchor257"/>Activity 5: Organizing Functions in Namespaces</h3>
			<ol>
				<li value="1">Include the required header file and namespace to print the required output:<p class="snippet">#include &lt;iostream&gt;</p><p class="snippet">using namespace std;</p></li>
				<li>Now, create a namespace named <strong class="inline">LamborghiniCar</strong> with the following <strong class="inline">output</strong> function:<p class="snippet">namespace LamborghiniCar</p><p class="snippet">{</p><p class="snippet">  int output(){</p><p class="snippet">    std::cout &lt;&lt; “Congratulations! You deserve the Lamborghini.” &lt;&lt; std::endl;</p><p class="snippet">    return NULL;</p><p class="snippet">  }</p><p class="snippet">}</p></li>
				<li>Create another namespace named <strong class="inline">PorscheCar</strong> and add an <strong class="inline">output</strong> function as shown:<p class="snippet">namespace PorscheCar</p><p class="snippet">{</p><p class="snippet">  int output(){</p><p class="snippet">    std::cout &lt;&lt; “Congratulations! You deserve the Porsche.” &lt;&lt; std::endl; </p><p class="snippet">    return NULL;</p><p class="snippet">  }</p><p class="snippet">}</p></li>
			</ol>
			<p>In the main function, create a variable named <strong class="inline">magicNumber</strong> of type integer to accept the input from the user:</p>
			<p class="snippet">int main()</p>
			<p class="snippet">{</p>
			<p class="snippet">  int magicNumber;</p>
			<p class="snippet">  std::cout &lt;&lt; “Select a magic number (1 or 2) to win your dream car: “;</p>
			<p class="snippet">  std::cin &gt;&gt; magicNumber;</p>
			<ol>
				<li value="1">Add the following conditional <strong class="inline">if</strong>…<strong class="inline">else</strong>-<strong class="inline">if</strong>…<strong class="inline">else</strong> statement to complete the program:<p class="snippet">  if (magicNumber == 1){</p><p class="snippet">    std::cout &lt;&lt; LamborghiniCar::output() &lt;&lt; std::endl;</p><p class="snippet">  } else if(magicNumber == 2){</p><p class="snippet">    std::cout &lt;&lt; PorscheCar::output() &lt;&lt; std::endl;</p><p class="snippet">  }else{</p><p class="snippet">    std::cout &lt;&lt; “Please type the correct magic number.” &lt;&lt; std::endl;</p><p class="snippet">  }</p><p class="snippet">}</p></li>
			</ol>
			<h3 id="_idParaDest-226"><a id="_idTextAnchor258"/>Activity 6: Writing a Math Library for use in a 3D Game</h3>
			<ol>
				<li value="1">Add the required header files at the start of the program (<strong class="inline">mathlib.h</strong> file is provided):<p class="snippet">#include &lt;mathlib.h&gt;</p><p class="snippet">#include &lt;array&gt;</p><p class="snippet">#include &lt;iostream&gt;</p></li>
				<li>Create a global <strong class="inline">const</strong> variable of type <strong class="inline">float</strong> as shown here:<p class="snippet">const float ENEMY_VIEW_RADIUS_METERS = 5;</p></li>
				<li>In the <strong class="inline">main</strong> function, create two arrays of type <strong class="inline">float</strong> and assign the following values:<p class="snippet">int main() {</p><p class="snippet">    std::array&lt;float, 3&gt; enemy1_location = {2, 2 ,0};</p><p class="snippet">    std::array&lt;float, 3&gt; enemy2_location = {2, 4 ,0};</p></li>
				<li>Now, create a variable named <strong class="inline">enemy_distance</strong> of type <strong class="inline">float</strong> and use the distance function to assign the value after calculating it:<p class="snippet">    float enemy_distance = johnny::mathlib::distance(enemy1_location, enemy2_location);</p><p class="snippet">    float distance_from_center = johnny::mathlib::distance(enemy1_location);</p></li>
				<li>Using the <strong class="inline">circumference</strong> function of <strong class="inline">mathlib.h</strong>, calculate and assign the enemy visual radius to <strong class="inline">view_circumference_for_enemy</strong> of type <strong class="inline">float</strong>:<p class="snippet">    using johnny::mathlib::circumference;</p><p class="snippet">    float view_circumference_for_enemy = circumference(ENEMY_VIEW_RADIUS_METERS);</p></li>
				<li>Create a variable named <strong class="inline">total_distance</strong> of type <strong class="inline">float</strong> and assign the distance difference between the two enemies as shown in the following code:<p class="snippet">    float total_distance = johnny::mathlib::total_walking_distance({</p><p class="snippet">        enemy1_location,</p><p class="snippet">        {2, 3, 0}, // y += 1</p><p class="snippet">        {2, 3, 3}, // z += 3</p><p class="snippet">        {5, 3, 3}, // x += 3</p><p class="snippet">        {8, 3, 3}, // x += 3</p><p class="snippet">        {8, 3, 2}, // z -= 1</p><p class="snippet">        {2, 3, 2}, // x -= 6</p><p class="snippet">        {2, 3, 1}, // z -= 1</p><p class="snippet">        {2, 3, 0}, // z -= 1</p><p class="snippet">        enemy2_location</p><p class="snippet">    });</p></li>
				<li>Print the output using the following print statement:<p class="snippet">    std::cout &lt;&lt; “The two enemies are “ &lt;&lt; enemy_distance &lt;&lt; “m apart and can see for a circumference of “</p><p class="snippet">              &lt;&lt; view_circumference_for_enemy &lt;&lt; “m. To go to from one to the other they need to walk “</p><p class="snippet">              &lt;&lt; total_distance &lt;&lt; “m.”;</p><p class="snippet">}</p></li>
			</ol>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor259"/>Lesson 3: Classes</h2>
			<h3 id="_idParaDest-228"><a id="_idTextAnchor260"/>Activity 7: Information Hiding Through Getters and Setters</h3>
			<ol>
				<li value="1">Define a class named <strong class="inline">Coordinates</strong> with its members under a <strong class="inline">private</strong> access specifier:<p class="snippet">class Coordinates {</p><p class="snippet">  private:</p><p class="snippet">    float latitude;</p><p class="snippet">    float longitude;</p><p class="snippet">};</p></li>
				<li>Add the four operations as specified above and make them publicly accessible by preceding their declaration with the <strong class="inline">public</strong> access specifier. The setters (<strong class="inline">set_latitude</strong> and <strong class="inline">set_longitude</strong>) should take an <strong class="inline">int</strong> as a parameter and return <strong class="inline">void</strong>, while the getters do not take any parameter and return a <strong class="inline">float</strong>:<p class="snippet">class Coordinates {</p><p class="snippet">  private:</p><p class="snippet">    float latitude;</p><p class="snippet">    float longitude;</p><p class="snippet">  public:</p><p class="snippet">    void set_latitude(float value){}</p><p class="snippet">    void set_longitude(float value){}</p><p class="snippet">    float get_latitude(){}</p><p class="snippet">    float get_longitude(){}</p><p class="snippet">};</p></li>
				<li>The four methods should now be implemented. The setters assign the given value to the corresponding members they are supposed to set; the getters return the values that are stored.<p class="snippet">class Coordinates {</p><p class="snippet">  private:</p><p class="snippet">    float latitude;</p><p class="snippet">    float longitude;</p><p class="snippet">  public:</p><p class="snippet">    void set_latitude(float value){ latitude = value; }</p><p class="snippet">    void set_longitude(float value){ longitude = value; }</p><p class="snippet">    float get_latitude(){ return latitude; }</p><p class="snippet">    float get_longitude(){ return longitude; }</p><p class="snippet">};</p><p>An example is as follows:</p><p class="snippet">#include &lt;iostream&gt;</p><p class="snippet">int main() {</p><p class="snippet">  Coordinates washington_dc;</p><p class="snippet">  std::cout &lt;&lt; “Object named washington_dc of type Coordinates created.” &lt;&lt; std::endl;</p><p class="snippet">  </p><p class="snippet">  washington_dc.set_latitude(38.8951);</p><p class="snippet">  washington_dc.set_longitude(-77.0364);</p><p class="snippet">  std::cout &lt;&lt; “Object’s latitude and longitude set.” &lt;&lt; std::endl;</p><p class="snippet">  </p><p class="snippet">  std::cout &lt;&lt; “Washington DC has a latitude of “ </p><p class="snippet">  &lt;&lt; washington_dc.get_latitude() </p><p class="snippet">  &lt;&lt; “ and longitude of “ &lt;&lt; washington_dc.get_longitude() &lt;&lt; std::endl;</p><p class="snippet">}</p></li>
			</ol>
			<h3 id="_idParaDest-229"><a id="_idTextAnchor261"/>Activity 8: Representing Positions in a 2D Map</h3>
			<ol>
				<li value="1">The first step is to create a class named <strong class="inline">Coordinates</strong> containing the coordinates as data members. These are two floating-point values, <strong class="inline">_latitude</strong> and <strong class="inline">_longitude</strong>, which identify the coordinates on a geographic coordinate system. Additionally, these data members are initialized with a <strong class="inline">private</strong> access specifier:<p class="snippet">class Coordinates {</p><p class="snippet">  private:</p><p class="snippet">    float _latitude;</p><p class="snippet">    float _longitude;</p><p class="snippet">};</p></li>
				<li>Then, the class is extended with a <strong class="inline">public</strong> constructor which takes two arguments used to initialize the data members of the class:<p class="snippet">class Coordinates {</p><p class="snippet">  public:</p><p class="snippet">    Coordinates(float latitude, float longitude) </p><p class="snippet">    : _latitude(latitude), _longitude(longitude) {}</p><p class="snippet">  private:</p><p class="snippet">    int _latitude;</p><p class="snippet">    int _longitude;</p><p class="snippet">};</p></li>
				<li>We can also add getters as seen previously to access the class members. An example is as follows:<p class="snippet">#include &lt;iostream&gt;</p><p class="snippet">int main() {</p><p class="snippet">  Coordinates washington_dc(38.8951, -77.0364);</p><p class="snippet">  std::cout &lt;&lt; “Object named washington_dc of type Coordinates created.” </p><p class="snippet">  &lt;&lt; std::endl;</p><p class="snippet">  </p><p class="snippet">  std::cout &lt;&lt; “Washington DC has a latitude of “ </p><p class="snippet">  &lt;&lt; washington_dc.get_latitude() </p><p class="snippet">  &lt;&lt; “ and longitude of “ &lt;&lt; washington_dc.get_longitude() </p><p class="snippet">  &lt;&lt; std::endl;</p><p class="snippet">}</p></li>
			</ol>
			<h3 id="_idParaDest-230"><a id="_idTextAnchor262"/>Activity 9: Storing Multiple Coordinates of Different Positions in the Map</h3>
			<ol>
				<li value="1"><a id="_idTextAnchor263"/>Using the RAII programming idiom, write a class that manages memory allocation and deletion of an array of <strong class="inline">int</strong>. The class has an array of integers as member data, which will be used to store the values.<a id="_idTextAnchor264"/><p>The constructor takes the size of the array as a parameter.<a id="_idTextAnchor265"/></p><p>The constructor also takes care of allocating memory, which is used to store the coordinates.<a id="_idTextAnchor266"/></p></li>
				<li>Finally, define a destructor and make sure to free the previously allocated array in its implementation.</li>
				<li><a id="_idTextAnchor267"/>We can add print statements to visualize what is happening:<p class="snippet"><a id="_idTextAnchor268"/>class managed_array {</p><p class="snippet">  public:</p><p class="snippet">    explicit managed_array(size_t size) {</p><p class="snippet">      array = new int[size];</p><p class="snippet">      std::cout &lt;&lt; “Array of size “ &lt;&lt; size &lt;&lt; “ created.” &lt;&lt; std::endl;</p><p class="snippet">    }</p><p class="snippet">  ~managed_array() {</p><p class="snippet">    delete[] array;</p><p class="snippet">    std::cout &lt;&lt; “Array deleted.” &lt;&lt; std::endl;</p><p class="snippet">  }</p><p class="snippet">  private:</p><p class="snippet">    int *array;</p><p class="snippet">};</p></li>
				<li>We can use our <strong class="inline">managed_array</strong> class as follows:<p class="snippet">int main() {</p><p class="snippet">    managed_array m(10);</p><p class="snippet">}</p><p>The output will be as follows:</p><p class="snippet">Array of size 10 created.</p><p class="snippet">Array deleted.</p></li>
			</ol>
			<h3 id="_idParaDest-231"><a id="_idTextAnchor269"/>Activity 10: The AppleTree Class, which Creates an Apple Instance</h3>
			<ol>
				<li value="1">First, we need to create a class with a <strong class="inline">private</strong> constructor. In this way, the object cannot be constructed, because the constructor is not publicly accessible:<p class="snippet">class Apple</p><p class="snippet">{</p><p class="snippet">  private:</p><p class="snippet">    Apple() {}</p><p class="snippet">    // do nothing</p><p class="snippet">};</p></li>
				<li>The <strong class="inline">AppleTree</strong> class is defined and contains a method called <strong class="inline">createFruit</strong> that is in charge of creating an <strong class="inline">Apple</strong> and returning it:<p class="snippet">#include &lt;iostream&gt;</p><p class="snippet">class AppleTree</p><p class="snippet">{</p><p class="snippet">  public:</p><p class="snippet">    Apple createFruit(){</p><p class="snippet">      Apple apple;</p><p class="snippet">      std::cout &lt;&lt; “apple created!” &lt;&lt; std::endl;</p><p class="snippet">      return apple;</p><p class="snippet">    }</p><p class="snippet">};</p></li>
				<li>If we compile this code, we will get an error. At this point, the <strong class="inline">Apple</strong> constructor is <strong class="inline">private</strong>, so the <strong class="inline">AppleTree</strong> class cannot access it. We need to declare the <strong class="inline">AppleTree</strong> class as a <strong class="inline">friend</strong> of <strong class="inline">Apple</strong> to allow <strong class="inline">AppleTree</strong> to access the <strong class="inline">private</strong> methods of <strong class="inline">Apple</strong>:<p class="snippet">class Apple</p><p class="snippet">{</p><p class="snippet">  friend class AppleTree;</p><p class="snippet">  private:</p><p class="snippet">    Apple() {}</p><p class="snippet">    // do nothing</p><p class="snippet">}</p></li>
				<li>The <strong class="inline">Apple</strong> object can now be constructed using the following code:<p class="snippet">int main() {</p><p class="snippet">  AppleTree tree;</p><p class="snippet">  Apple apple = tree.createFruit();</p><p class="snippet">}</p><p>This prints the following:</p><p class="snippet">apple created!</p></li>
			</ol>
			<h3 id="_idParaDest-232"><a id="_idTextAnchor270"/>Activity 11: Ordering Point Objects</h3>
			<ol>
				<li value="1">We need to add an overload for the <strong class="inline">&lt;</strong> operator to the <strong class="inline">Point</strong> class that we have previously defined. This takes another object of type <strong class="inline">Point</strong> as an argument and returns a Boolean indicating whether the object is less than the one provided as the parameter, using the previous definition for how to compare the two points:<p class="snippet">class Point</p><p class="snippet">{</p><p class="snippet">  public:</p><p class="snippet">    bool operator&lt; (const Point &amp;other){</p><p class="snippet">      return x &lt; other.x || (x == other.x &amp;&amp; y &lt; other.y);</p><p class="snippet">    }</p><p class="snippet">  int x;</p><p class="snippet">  int y;</p><p class="snippet">};</p></li>
				<li>At this point, we are able to compare the two <strong class="inline">Point</strong> objects:<p class="snippet">#include &lt;iostream&gt;</p><p class="snippet">int main() {</p><p class="snippet">  Point p_1, p_2;</p><p class="snippet">  p_1.x = 1;</p><p class="snippet">  p_1.y = 2;</p><p class="snippet">  p_2.x = 2; </p><p class="snippet">  p_2.y = 1;</p><p class="snippet">  std::cout &lt;&lt; std::boolalpha &lt;&lt; (p_1 &lt; p_2) &lt;&lt; std::endl;</p><p class="snippet">}</p></li>
				<li>Since in our example <strong class="inline">p_1.x</strong> is initialized to <strong class="inline">1</strong> and <strong class="inline">p_2.x</strong> to <strong class="inline">2</strong>, the result of the comparison will be <strong class="inline">true</strong>, which indicates that <strong class="inline">p_1</strong> comes earlier than <strong class="inline">p_2</strong> in the order.</li>
			</ol>
			<h3 id="_idParaDest-233"><a id="_idTextAnchor271"/>Activity 12: Implementing Functors</h3>
			<ol>
				<li value="1">Define a class constituted by a <strong class="inline">private</strong> data member of type <strong class="inline">int</strong> and add a constructor to initialize it:<p class="snippet">class AddX {</p><p class="snippet">  public:</p><p class="snippet">    AddX(int x) : x(x) {}</p><p class="snippet">  private:</p><p class="snippet">    int x;</p><p class="snippet">};</p></li>
				<li>Extend it with the call operator <strong class="inline">operator()</strong> which takes an <strong class="inline">int</strong> as a parameter and returns an <strong class="inline">int</strong>. The implementation in the function body should return the addition of the previously defined <strong class="inline">x</strong> value and the parameter of the function named <strong class="inline">y</strong>:<p class="snippet">class AddX {</p><p class="snippet">  public:</p><p class="snippet">    AddX(int x) : x(x) {}</p><p class="snippet">    int operator() (int y) { return x + y; }</p><p class="snippet">  private:</p><p class="snippet">    int x;</p><p class="snippet">};</p></li>
				<li>Instantiate an object of the class just defined and invoke the call operator:<p class="snippet">int main() {</p><p class="snippet">  AddX add_five(5);</p><p class="snippet">  std::cout &lt;&lt; add_five(4) &lt;&lt; std::endl;</p><p class="snippet">}</p><p>The output will be as follows:</p><p class="snippet">9</p></li>
			</ol>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor272"/>Lesson 04: Generic Programming and Templates</h2>
			<h3 id="_idParaDest-235"><a id="_idTextAnchor273"/>Activity 13: Read Objects from a Connection</h3>
			<ol>
				<li value="1">We start by including the headers of the files that provided the connection and the user account object:<p class="snippet">#include &lt;iostream&gt;</p><p class="snippet">#include &lt;connection.h&gt;</p><p class="snippet">#include &lt;useraccount.h&gt;</p></li>
				<li>We can then start to write the <strong class="inline">writeObjectToConnection</strong> function. Declare a template which takes two <strong class="inline">typename</strong> parameters: an <strong class="inline">Object</strong> and a <strong class="inline">Connection</strong>. Call the <strong class="inline">static</strong> method <strong class="inline">serialize()</strong> on the object to get the <strong class="inline">std::array</strong> representing the object, then call <strong class="inline">writeNext()</strong> on the connection to write the data to it:<p class="snippet">template&lt;typename Object, typename Connection&gt;</p><p class="snippet">void writeObjectToConnection(Connection&amp; con, const Object&amp; obj) {</p><p class="snippet">    std::array&lt;char, 100&gt; data = Object::serialize(obj);</p><p class="snippet">    con.writeNext(data);</p><p class="snippet">}</p></li>
				<li>We can then write <strong class="inline">readObjectFromConnection</strong>. Declare a template taking the same two parameters as before: an <strong class="inline">Object</strong> and a <strong class="inline">Connection</strong>. Inside, we call the connection <strong class="inline">readNext()</strong> to get the data stored inside the connection, then we call the <strong class="inline">static</strong> method on the object type <strong class="inline">deserialize()</strong> to get an instance of the object and return it:<p class="snippet">template&lt;typename Object, typename Connection&gt;</p><p class="snippet">Object readObjectFromConnection(Connection&amp; con) {</p><p class="snippet">    std::array&lt;char, 100&gt; data = con.readNext();</p><p class="snippet">    return Object::deserialize(data);</p><p class="snippet">}</p></li>
				<li>Finally, in the <strong class="inline">main</strong> function, we can call the functions we created to serialize objects. Both with <strong class="inline">TcpConnection</strong>:<p class="snippet">std::cout &lt;&lt; “serialize first user account” &lt;&lt; std::endl;</p><p class="snippet">UserAccount firstAccount;</p><p class="snippet">TcpConnection tcpConnection;</p><p class="snippet">writeObjectToConnection(tcpConnection, firstAccount);</p><p class="snippet">UserAccount transmittedFirstAccount = readObjectFromConnection&lt;UserAccount&gt;(tcpConnection);</p></li>
				<li>And with <strong class="inline">UdpConnection</strong>:<p class="snippet">std::cout &lt;&lt; “serialize second user account” &lt;&lt; std::endl;</p><p class="snippet">UserAccount secondAccount;</p><p class="snippet">UdpConnection udpConnection;</p><p class="snippet">writeObjectToConnection(udpConnection, secondAccount);</p><p class="snippet">UserAccount transmittedSecondAccount = readObjectFromConnection&lt;UserAccount&gt;(udpConnection);</p><p>The output of the program is as follows:</p><p class="snippet">serialize first user account</p><p class="snippet">the user account has been serialized</p><p class="snippet">the data has been written</p><p class="snippet">the data has been read</p><p class="snippet">the user account has been deserialized</p><p class="snippet">serialize second user account</p><p class="snippet">the user account has been serialized</p><p class="snippet">the data has been written</p><p class="snippet">the data has been read</p><p class="snippet">the user account has been deserialized</p></li>
			</ol>
			<h3 id="_idParaDest-236"><a id="_idTextAnchor274"/>Activity 14: UserAccount to Support Multiple Currencies</h3>
			<ol>
				<li value="1">We start by including the file defining the currencies:<p class="snippet">#include &lt;currency.h&gt;</p><p class="snippet">#include &lt;iostream&gt;</p></li>
				<li>We then declare the template class <strong class="inline">Account</strong>. It should take a template parameter: <strong class="inline">Currency</strong>. We store the current balance of the account inside a data member of type <strong class="inline">Currency</strong>. We also provide a method in order to extract the current value of the balance:<p class="snippet">template&lt;typename Currency&gt;</p><p class="snippet">class Account {</p><p class="snippet">  public:</p><p class="snippet">    Account(Currency amount) : balance(amount) {}</p><p class="snippet">    Currency getBalance() const {</p><p class="snippet">        return balance;</p><p class="snippet">    }</p><p class="snippet">  private:</p><p class="snippet">    Currency balance;</p><p class="snippet">};</p></li>
				<li>Next, we create the method <strong class="inline">addToBalance</strong>. It should be a template with one type parameter, the other currency. The method takes a value of <strong class="inline">OtherCurrency</strong> and converts it to the value of the currency of the current account with the <strong class="inline">to()</strong> function, specifying to which currency the value should be converted to. It then adds it to the balance:<p class="snippet">template&lt;typename OtherCurrency&gt;</p><p class="snippet">void addToBalance(OtherCurrency amount) {</p><p class="snippet">    balance.d_value += to&lt;Currency&gt;(amount).d_value;</p><p class="snippet">}</p></li>
				<li>Finally, we can try to call our class in the <strong class="inline">main</strong> function with some data:<p class="snippet">Account&lt;GBP&gt; gbpAccount(GBP(1000));</p><p class="snippet">// Add different currencies</p><p class="snippet">std::cout &lt;&lt; “Balance: “ &lt;&lt; gbpAccount.getBalance().d_value &lt;&lt; “ (GBP)” &lt;&lt; std::endl;</p><p class="snippet">gbpAccount.addToBalance(EUR(100));</p><p class="snippet">std::cout &lt;&lt; “+100 (EUR)” &lt;&lt; std::endl;</p><p class="snippet">std::cout &lt;&lt; “Balance: “ &lt;&lt; gbpAccount.getBalance().d_value &lt;&lt; “ (GBP)” &lt;&lt; std::endl;</p><p>The output of the program is:</p><p class="snippet">Balance: 1000 (GBP)</p><p class="snippet">+100 (EUR)</p><p class="snippet">Balance: 1089 (GBP)</p></li>
			</ol>
			<h3 id="_idParaDest-237"><a id="_idTextAnchor275"/>Activity 15: Write a Matrix Class for Mathematical Operations in a Game</h3>
			<ol>
				<li value="1">We start by defining a <strong class="inline">Matrix</strong> class which takes three template parameters: one type and the two dimensions of the <strong class="inline">Matrix</strong> class. The dimensions are of type <strong class="inline">int</strong>. Internally, we create a <strong class="inline">std::array</strong> with the size of the number of rows times the number of columns, in order to have enough space for all elements of the matrix. We add a constructor to initialize the array to <em class="italics">empty</em>, and a constructor to provide a list of values:<p class="snippet">#include &lt;array&gt;</p><p class="snippet">template&lt;typename T, int R, int C&gt;</p><p class="snippet">class Matrix {</p><p class="snippet">  // We store row_1, row_2, ..., row_C</p><p class="snippet">  std::array&lt;T, R*C&gt; data;</p><p class="snippet">  public:</p><p class="snippet">    Matrix() : data({}) {}</p><p class="snippet">    Matrix(std::array&lt;T, R*C&gt; initialValues) : data(initialValues) {}</p><p class="snippet">};</p></li>
				<li>We add a method <strong class="inline">get()</strong> to the class to return a reference to the element <strong class="inline">T</strong>. The method needs to take the row and column we want to access.</li>
				<li>We make sure that the requested indexes are inside the bounds of the matrix, otherwise we call <strong class="inline">std::abort()</strong>. In the array, we first store all the elements of the first row, then all the elements of the second row, and so on. When we want to access the elements of the <em class="italics">nth</em> row, we need to skip all the elements of the previous rows, which are going to be the number of elements per row (so the number of columns) times the previous rows, resulting in the following method:<p class="snippet">T&amp; get(int row, int col) {</p><p class="snippet">  if (row &gt;= R || col &gt;= C) {</p><p class="snippet">    std::abort();</p><p class="snippet">  }</p><p class="snippet">  return data[row*C + col];</p><p class="snippet">}</p></li>
				<li>For convenience, we define a function to print the class as well. We print all the elements in the columns separated by spaces, with one column per line:<p class="snippet">template&lt;typename T, size_t R, size_t C&gt;</p><p class="snippet">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Matrix&lt;T, R, C&gt; matrix) {</p><p class="snippet">    os &lt;&lt; ‘\n’;</p><p class="snippet">    for(int r=0; r &lt; R; r++) {</p><p class="snippet">        for(int c=0; c &lt; C; c++) {</p><p class="snippet">            os &lt;&lt; matrix.get(r, c) &lt;&lt; ‘ ‘;</p><p class="snippet">        }</p><p class="snippet">        os &lt;&lt; “\n”;</p><p class="snippet">    }</p><p class="snippet">    return os;</p><p class="snippet">}</p></li>
				<li>In the <strong class="inline">main</strong> function, we can now use the functions we have defined:<p class="snippet">Matrix&lt;int, 3, 2&gt; matrix({</p><p class="snippet">  1, 2,</p><p class="snippet">  3, 4,</p><p class="snippet">  5, 6</p><p class="snippet">});</p><p class="snippet">std::cout &lt;&lt; “Initial matrix:” &lt;&lt; matrix &lt;&lt; std::endl;</p><p class="snippet">matrix.get(1, 1) = 7;</p><p class="snippet">std::cout &lt;&lt; “Modified matrix:” &lt;&lt; matrix &lt;&lt; std::endl;</p><p>The output is as follows:</p><p class="snippet">Initial matrix:</p><p class="snippet">1 2 </p><p class="snippet">3 4 </p><p class="snippet">5 6 </p><p class="snippet">Modified matrix:</p><p class="snippet">1 2 </p><p class="snippet">3 7 </p><p class="snippet">5 6</p></li>
			</ol>
			<h3 id="_idParaDest-238"><strong class="bold"><a id="_idTextAnchor276"/>Solution bonus step</strong>:</h3>
			<ol>
				<li value="1">We can add a new method, <strong class="inline">multiply</strong>, which takes a <strong class="inline">std::array</strong> of type <strong class="inline">T</strong> with the length of <strong class="inline">C</strong> by <strong class="inline">const</strong> reference, since we are not modifying it.<p>The function returns an array of the same type, but length <strong class="inline">R</strong>.</p></li>
				<li>We follow the definition of matrix-vector multiplication to compute the result:<p class="snippet">std::array&lt;T, R&gt; multiply(const std::array&lt;T, C&gt;&amp; vector){</p><p class="snippet">    std::array&lt;T, R&gt; result = {};</p><p class="snippet">    for(size_t r = 0; r &lt; R; r++) {</p><p class="snippet">      for(size_t c = 0; c &lt; C; c++) {</p><p class="snippet">        result[r] += get(r, c) * vector[c];</p><p class="snippet">      }</p><p class="snippet">    }</p><p class="snippet">    return result;</p><p class="snippet">}</p></li>
				<li>We can now extend our <strong class="inline">main</strong> function to call the <strong class="inline">multiply</strong> function:<p class="snippet">std::array&lt;int, 2&gt; vector = {8, 9};</p><p class="snippet">std::array&lt;int, 3&gt; result = matrix.multiply(vector);</p><p class="snippet">std::cout &lt;&lt; “Result of multiplication: [“ &lt;&lt; result[0] &lt;&lt; “, “</p><p class="snippet">  &lt;&lt; result[1] &lt;&lt; “, “ &lt;&lt; result[2] &lt;&lt; “]” &lt;&lt; std::endl;</p><p>The output is as follows:</p><p class="snippet">Result of multiplication: [26, 87, 94]</p></li>
			</ol>
			<h3 id="_idParaDest-239"><a id="_idTextAnchor277"/>Activity 16: Make the Matrix Class Easier to Use</h3>
			<ol>
				<li value="1">We start by importing <strong class="inline">&lt;functional&gt;</strong> in order to have access to <strong class="inline">std::multiplies</strong>:<p class="snippet">#include &lt;functional&gt;</p></li>
				<li>We then change the order of the template parameters in the class <strong class="inline">template</strong>, so that the size parameters come first. We also add a new template parameter, <strong class="inline">Multiply</strong>, which is the type we will use for computing the multiplication between the elements in the <strong class="inline">vector</strong> by default, and we store an instance of it in the class:<p class="snippet">template&lt;int R, int C, typename T = int, typename Multiply=std::multiplies&lt;T&gt; &gt;</p><p class="snippet">class Matrix {</p><p class="snippet">  std::array&lt;T, R*C&gt; data;</p><p class="snippet">  Multiply multiplier;</p><p class="snippet">  public:</p><p class="snippet">    Matrix() : data({}), multiplier() {}</p><p class="snippet">    Matrix(std::array&lt;T, R*C&gt; initialValues) : data(initialValues), multiplier() {}</p><p class="snippet">};</p><p>The <strong class="inline">get()</strong> function remains the same as the previous activity.</p></li>
				<li>We now need to make sure that the <strong class="inline">Multiply</strong> method uses the <strong class="inline">Multiply</strong> type provided by the user to perform the multiplication.</li>
				<li>To do so, we need to make sure to call <strong class="inline">multiplier(operand1, operand2)</strong> instead of <strong class="inline">operand1 * operand2</strong>, so that we use the instance we stored inside the class:<p class="snippet">std::array&lt;T, R&gt; multiply(const std::array&lt;T, C&gt;&amp; vector) {</p><p class="snippet">    std::array&lt;T, R&gt; result = {};</p><p class="snippet">    for(int r = 0; r &lt; R; r++) {</p><p class="snippet">        for(int c = 0; c &lt; C; c++) {</p><p class="snippet">            result[r] += multiplier(get(r, c), vector[c]);</p><p class="snippet">        }</p><p class="snippet">    }</p><p class="snippet">    return result;</p><p class="snippet">}</p></li>
				<li>We can now add an example of how we can use the class:<p class="snippet">// Create a matrix of int, with the ‘plus’ operation by default</p><p class="snippet">Matrix&lt;3, 2, int, std::plus&lt;int&gt;&gt; matrixAdd({</p><p class="snippet">    1, 2,</p><p class="snippet">    3, 4,</p><p class="snippet">    5, 6</p><p class="snippet">});</p><p class="snippet">std::array&lt;int, 2&gt; vector = {8, 9};</p><p class="snippet">// This will call std::plus when doing the multiplication</p><p class="snippet">std::array&lt;int, 3&gt; result = matrixAdd.multiply(vector);</p><p class="snippet">std::cout &lt;&lt; “Result of multiplication(with +): [“ &lt;&lt; result[0] &lt;&lt; “, “</p><p class="snippet">          &lt;&lt; result[1] &lt;&lt; “, “ &lt;&lt; result[2] &lt;&lt; “]” &lt;&lt; std::endl;</p><p>The output is as follows:</p><p class="snippet">Result of multiplication(with +): [20, 24, 28]</p></li>
			</ol>
			<h3 id="_idParaDest-240"><a id="_idTextAnchor278"/>Activity 17: Ensure Users are Logged in When Performing Actions on the Account</h3>
			<ol>
				<li value="1">We first declare a template function which takes two type parameters: an <strong class="inline">Action</strong> and a <strong class="inline">Parameter</strong> type.</li>
				<li>The function should take the user identification, the action and the parameter. The parameter should be accepted as a forwarding reference. As a first step, it should check if the user is logged in, by calling the <strong class="inline">isLoggenIn()</strong> function. If the user is logged in, it should call the <strong class="inline">getUserCart()</strong> function, then call the action passing the cart and forwarding the parameter:<p class="snippet">template&lt;typename Action, typename Parameter&gt;</p><p class="snippet">void execute_on_user_cart(UserIdentifier user, Action action, Parameter&amp;&amp; parameter) {</p><p class="snippet">    if(isLoggedIn(user)) {</p><p class="snippet">        Cart cart = getUserCart(user);</p><p class="snippet">        action(cart, std::forward&lt;Parameter&gt;(parameter));</p><p class="snippet">    } else {</p><p class="snippet">        std::cout &lt;&lt; “The user is not logged in” &lt;&lt; std::endl;</p><p class="snippet">    }</p><p class="snippet">}</p></li>
				<li>We can test how <strong class="inline">execute_on_user_cart</strong> works by calling it in the <strong class="inline">main</strong> function:<p class="snippet">Item toothbrush{1023};</p><p class="snippet">Item toothpaste{1024};</p><p class="snippet">UserIdentifier loggedInUser{0};</p><p class="snippet">std::cout &lt;&lt; “Adding items if the user is logged in” &lt;&lt; std::endl;</p><p class="snippet">execute_on_user_cart(loggedInUser, addItems, std::vector&lt;Item&gt;({toothbrush, toothpaste}));</p><p class="snippet">UserIdentifier loggedOutUser{1};</p><p class="snippet">std::cout &lt;&lt; “Removing item if the user is logged in” &lt;&lt; std::endl;</p><p class="snippet">execute_on_user_cart(loggedOutUser, removeItem, toothbrush);</p><p>The output is as follows:</p><p class="snippet">Adding items if the user is logged in</p><p class="snippet">Items added</p><p class="snippet">Removing item if the user is logged in</p><p class="snippet">The user is not logged in</p></li>
			</ol>
			<h3 id="_idParaDest-241"><a id="_idTextAnchor279"/>Activity 18: Safely Perform Operations on User Cart with an Arbitrary Number of Parameters</h3>
			<ol>
				<li value="1">We need to expand the previous activity to accept any number of parameters with any kind of ref-ness and pass it to the action provided. To do so, we need to create a <strong class="inline">variadic</strong> template.</li>
				<li>Declare a <strong class="inline">template</strong> function that takes an action and a <strong class="inline">variadic</strong> number of parameters as template parameters. The function parameters should be the user action, the action to perform, and the expanded template parameter <strong class="inline">pack</strong>, making sure that the parameters are accepted as forwarding references.</li>
				<li>Inside the function, we perform the same checks as before, but now we expand the parameters when we forward them to the action:<p class="snippet">template&lt;typename Action, typename... Parameters&gt;</p><p class="snippet">void execute_on_user_cart(UserIdentifier user, Action action, Parameters&amp;&amp;... parameters) {</p><p class="snippet">    if(isLoggedIn(user)) {</p><p class="snippet">        Cart cart = getUserCart(user);</p><p class="snippet">        action(cart, std::forward&lt;Parameters&gt;(parameters)...);</p><p class="snippet">    } else {</p><p class="snippet">        std::cout &lt;&lt; “The user is not logged in” &lt;&lt; std::endl;</p><p class="snippet">    }</p><p class="snippet">}</p></li>
				<li>Let’s test the new function in our <strong class="inline">main</strong> function:<p class="snippet">Item toothbrush{1023};</p><p class="snippet">Item apples{1024};</p><p class="snippet">UserIdentifier loggedInUser{0};</p><p class="snippet">std::cout &lt;&lt; “Replace items if the user is logged in” &lt;&lt; std::endl;</p><p class="snippet">execute_on_user_cart(loggedInUser, replaceItem, toothbrush, apples);</p><p class="snippet">UserIdentifier loggedOutUser{1};</p><p class="snippet">std::cout &lt;&lt; “Replace item if the user is logged in” &lt;&lt; std::endl;</p><p class="snippet">execute_on_user_cart(loggedOutUser, removeItem, toothbrush);</p><p>The output is as follows:</p><p class="snippet">Replace items if the user is logged in</p><p class="snippet">Replacing item</p><p class="snippet">Item removed</p><p class="snippet">Items added</p><p class="snippet">Replace item if the user is logged in</p><p class="snippet">The user is not logged in</p></li>
			</ol>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor280"/>Lesson 5: Standard Library Containers and Algorithms</h2>
			<h3 id="_idParaDest-243"><a id="_idTextAnchor281"/>Activity 19: Storing User Accounts</h3>
			<ol>
				<li value="1">First, we include the header files for the <strong class="inline">array</strong> class and input/output operations with the required namespace:<p class="snippet">#include &lt;array&gt;</p></li>
				<li>An array of ten elements of type <strong class="inline">int</strong> is declared:<p class="snippet">array&lt;int,10&gt; balances;</p></li>
				<li>Initially, the values of the elements are undefined since it is an array of the fundamental data type <strong class="inline">int</strong>. The array is initialized using a <strong class="inline">for</strong> loop, where each element is initialized with its index. The operator <strong class="inline">size()</strong> is used to evaluate the size of the array and the subscript operator <strong class="inline">[ ]</strong> is used to access every position of the array:<p class="snippet">for (int i=0; i &lt; balances.size(); ++i) </p><p class="snippet">{</p><p class="snippet">  balances[i] = 0;</p><p class="snippet">}</p></li>
				<li>We now want to update the value for the first and last user. We can use <strong class="inline">front()</strong> and <strong class="inline">back()</strong> to access the accounts of these users:<p class="snippet">balances.front() += 100;</p><p class="snippet">balances.back() += 100;</p><p>We would like to store the account balance of an arbitrary number of users. We then want to add 100 users to the account list, with a balance of 500.</p></li>
				<li>We can use <strong class="inline">vector</strong> to store an arbitrary number of users. It is defined in the <strong class="inline">&lt;vector&gt;</strong> header:<p class="snippet">#include &lt;vector&gt;</p></li>
				<li>Then, we declare a vector of type <strong class="inline">int</strong>. Optionally, we reserve enough memory to store the 100 users’ account by calling <strong class="inline">reserve(100)</strong> to avoid memory reallocation:<p class="snippet">std::vector&lt;int&gt; balances;</p><p class="snippet">balances.reserve(100);</p></li>
				<li>Finally, we modify the <strong class="inline">for</strong> loop to add the balance for the users at the end of the accounts vector:<p class="snippet">for (int i=0; i&lt;100; ++i) </p><p class="snippet">{</p><p class="snippet">  balances.push_back(500);</p><p class="snippet">}</p></li>
			</ol>
			<h3 id="_idParaDest-244"><a id="_idTextAnchor282"/>Activity 20: Retrieving a User’s Balance from their Given Username</h3>
			<ol>
				<li value="1">Include the header file for the <strong class="inline">map</strong> class and the header for <strong class="inline">string</strong>:<p class="snippet">#include &lt;map&gt;</p><p class="snippet">#include &lt;string&gt;</p></li>
				<li>Create a map with the key being <strong class="inline">std::string</strong> and the value <strong class="inline">int</strong>:<p class="snippet">std::map&lt;std::string, int&gt; balances;</p></li>
				<li>Insert the balances of the users inside <strong class="inline">map</strong> by using <strong class="inline">insert</strong> and <strong class="inline">std::make_pair</strong>. The first argument is the key, the second one is the value:<p class="snippet">balances.insert(std::make_pair(“Alice”,50));</p><p class="snippet">balances.insert(std::make_pair(“Bob”, 50));</p><p class="snippet">balances.insert(std::make_pair(“Charlie”, 50));</p></li>
				<li>Use the <strong class="inline">find</strong> function providing the name of the user to find the position of the account in the map. Compare it with <strong class="inline">end()</strong> to check whether a position was found:<p class="snippet">auto donaldAccountPos = balances.find(“Donald”);</p><p class="snippet">bool hasAccount = (donaldAccountPos !=  balances.end());</p><p class="snippet">std::cout &lt;&lt; “Donald has an account: “ &lt;&lt; hasAccount &lt;&lt; std::endl;</p></li>
				<li>Now, look for the account of <strong class="inline">Alice</strong>. We know <strong class="inline">Alice</strong> has an account, so there is no need to check whether we found a valid position. We can print the value of the account using <strong class="inline">-&gt;second</strong>:<p class="snippet">auto alicePosition = balances.find(“Alice”);</p><p class="snippet">std::cout &lt;&lt; “Alice balance is: “ &lt;&lt; alicePosition-&gt;second &lt;&lt; std::endl;</p></li>
			</ol>
			<h3 id="_idParaDest-245"><a id="_idTextAnchor283"/>Activity 21: Processing User Registration in Order</h3>
			<ol>
				<li value="1">First, we include the header file for the <strong class="inline">stack</strong> class:<p class="snippet">#include &lt;stack&gt;</p></li>
				<li>Create a <strong class="inline">stack</strong> providing the type to <strong class="inline">store</strong>:<p class="snippet">std::stack&lt;RegistrationForm&gt; registrationForms;</p></li>
				<li>We start by storing the form inside the <strong class="inline">stack</strong> when the user registers. In the body of the <strong class="inline">storeRegistrationForm</strong> function, push the element into the queue:<p class="snippet">stack.push(form);</p><p class="snippet">std::cout &lt;&lt; “Pushed form for user “ &lt;&lt; form.userName &lt;&lt; std::endl;</p></li>
				<li>Now, inside <strong class="inline">endOfDayRegistrationProcessing</strong>, we get all the elements inside the <strong class="inline">stack</strong> and then process them. Use the <strong class="inline">top()</strong> method to access the top element in the <strong class="inline">stack</strong> and <strong class="inline">pop()</strong> to remove the top element. We stop getting and removing the first element when no element is left:<p class="snippet">while(not stack.empty()) {</p><p class="snippet">  processRegistration(stack.top());</p><p class="snippet">  stack.pop();</p><p class="snippet">}</p></li>
				<li>Finally, we call our functions with some test data:<p class="snippet">int main(){</p><p class="snippet">  std::stack&lt;RegistrationForm&gt; registrationForms;</p><p class="snippet">  storeRegistrationForm(registrationForms, RegistrationForm{“Alice”});</p><p class="snippet">  storeRegistrationForm(registrationForms, RegistrationForm{“Bob”});</p><p class="snippet">  storeRegistrationForm(registrationForms, RegistrationForm{“Charlie”});</p><p class="snippet">  endOfDayRegistrationProcessing(registrationForms);</p><p class="snippet">}</p></li>
			</ol>
			<h3 id="_idParaDest-246"><a id="_idTextAnchor284"/>Activity 22: Airport System Management</h3>
			<ol>
				<li value="1">We start by creating the class for <strong class="inline">Airplane</strong>. Make sure to first include the header for <strong class="inline">variant</strong>:<p class="snippet">#include &lt;variant&gt;</p></li>
				<li>Then, create the class with a constructor that sets the current state of the airplane to <strong class="inline">AtGate</strong>:<p class="snippet">class Airplane {</p><p class="snippet">  std::variant&lt;AtGate, Taxi, Flying&gt; state;</p><p class="snippet">  public:</p><p class="snippet">    Airplane(int gate) : state(AtGate{gate}) {</p><p class="snippet">      std::cout &lt;&lt; “At gate “ &lt;&lt; gate &lt;&lt; std::endl;</p><p class="snippet">    }</p><p class="snippet">};</p></li>
				<li>Now, implement the <strong class="inline">startTaxi()</strong> method. First, check the current state of the airplane with <strong class="inline">std::holds_alternative&lt;&gt;()</strong>, and if the airplane is not in the correct state, write an error message and return.</li>
				<li>If the airplane is in the correct state, change the state to taxi by assigning it to the <strong class="inline">variant</strong>:<p class="snippet">void startTaxi(int lane, int numPassengers) {</p><p class="snippet">    if (not std::holds_alternative&lt;AtGate&gt;(state)) {</p><p class="snippet">        std::cout &lt;&lt; “Not at gate: the plane cannot start taxi to lane “ &lt;&lt; lane &lt;&lt; std::endl;</p><p class="snippet">        return;</p><p class="snippet">    }</p><p class="snippet">    std::cout &lt;&lt; “Taxing to lane “ &lt;&lt; lane &lt;&lt; std::endl;</p><p class="snippet">    state = Taxi{lane, numPassengers};   </p><p class="snippet">}</p></li>
				<li>We repeat the same process for the <strong class="inline">takeOff()</strong> method:<p class="snippet">void takeOff(float speed) {</p><p class="snippet">    if (not std::holds_alternative&lt;Taxi&gt;(state)) {</p><p class="snippet">        std::cout &lt;&lt; “Not at lane: the plane cannot take off with speed “ &lt;&lt; speed &lt;&lt; std::endl;</p><p class="snippet">        return;</p><p class="snippet">    }</p><p class="snippet">    std::cout &lt;&lt; “Taking off at speed “ &lt;&lt; speed &lt;&lt; std::endl;</p><p class="snippet">    state = Flying{speed}; </p><p class="snippet">}</p></li>
				<li>We can now start looking at the <strong class="inline">currentStatus()</strong> method. Since we want to perform an operation for each of the states in the <strong class="inline">variant</strong>, we can use a visitor.</li>
				<li>Outside the <strong class="inline">Airplane</strong> class, create a class that has a method <strong class="inline">operator()</strong> for each of the types in the airplane state. Inside the method, print the information of the state. Remember to make the methods public:<p class="snippet">class AirplaneStateVisitor {</p><p class="snippet">  public:</p><p class="snippet">    void operator()(const AtGate&amp; atGate) {</p><p class="snippet">       std::cout &lt;&lt; “AtGate: “ &lt;&lt; atGate.gate &lt;&lt; std::endl;</p><p class="snippet">    }</p><p class="snippet">  void operator()(const Taxi&amp; taxi) {</p><p class="snippet">    std::cout &lt;&lt; “Taxi: lane “ &lt;&lt; taxi.lane &lt;&lt; “ with “ &lt;&lt; taxi.numPassengers &lt;&lt; “ passengers” &lt;&lt; std::endl;</p><p class="snippet">  }</p><p class="snippet">  void operator()(const Flying&amp; flying) {</p><p class="snippet">    std::cout &lt;&lt; “Flaying: speed “ &lt;&lt; flying.speed &lt;&lt; std::endl;</p><p class="snippet">  }</p><p class="snippet">};</p></li>
				<li>Now, create the <strong class="inline">currentStatus()</strong> method and call the visitor on the state using <strong class="inline">std::visit</strong>:<p class="snippet">void currentStatus() {</p><p class="snippet">    AirplaneStateVisitor visitor;</p><p class="snippet">    std::visit(visitor, state);</p><p class="snippet">}</p></li>
				<li>We can now try to call the functions of <strong class="inline">Airplane</strong> from the <strong class="inline">main</strong> function:<p class="snippet">int main()</p><p class="snippet">{</p><p class="snippet">    Airplane airplane(52);</p><p class="snippet">    airplane.currentStatus();</p><p class="snippet">    airplane.startTaxi(12, 250);</p><p class="snippet">    airplane.currentStatus();</p><p class="snippet">    airplane.startTaxi(13, 250);</p><p class="snippet">    airplane.currentStatus();</p><p class="snippet">    airplane.takeOff(800);</p><p class="snippet">    airplane.currentStatus();</p><p class="snippet">    airplane.takeOff(900);</p><p class="snippet">}</p></li>
			</ol>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor285"/>Lesson 6: Object-Oriented Programming</h2>
			<h3 id="_idParaDest-248"><a id="_idTextAnchor286"/>Activity 23: Creating Game Characters</h3>
			<ol>
				<li value="1">Create a <strong class="inline">Character</strong> class that has a <strong class="inline">public</strong> method <strong class="inline">moveTo</strong> that prints <strong class="inline">Moved to position</strong>:<p class="snippet">class Character {</p><p class="snippet">  public:</p><p class="snippet">    void moveTo(Position newPosition) {</p><p class="snippet">      position = newPosition;</p><p class="snippet">      std::cout &lt;&lt; “Moved to position “ &lt;&lt; newPosition.positionIdentifier &lt;&lt; std::endl;</p><p class="snippet">    }</p><p class="snippet">  private:</p><p class="snippet">    Position position;</p><p class="snippet">};</p></li>
				<li>Create a <strong class="inline">struct</strong> named <strong class="inline">Position</strong>:<p class="snippet">struct Position {</p><p class="snippet">  // Fields to describe the position go here</p><p class="snippet">  std::string positionIdentifier;</p><p class="snippet">};</p></li>
				<li>Create two classes <strong class="inline">Hero</strong> and <strong class="inline">Enemy</strong> that are derived from the class <strong class="inline">Character</strong>:<p class="snippet">// Hero inherits publicly from Character: it has</p><p class="snippet">// all the public member of the Character class.</p><p class="snippet">class Hero : public Character {</p><p class="snippet">};</p><p class="snippet">// Enemy inherits publicly from Character, like Hero</p><p class="snippet">class Enemy : public Character {</p><p class="snippet">};</p></li>
				<li>Create a class <strong class="inline">Spell</strong> with the constructor that prints the name of the person casting the spell:<p class="snippet">class Spell {</p><p class="snippet">public:</p><p class="snippet">    Spell(std::string name) : d_name(name) {}</p><p class="snippet">    std::string name() const {</p><p class="snippet">        return d_name;</p><p class="snippet">    }</p><p class="snippet">private:</p><p class="snippet">    std::string d_name;</p><p class="snippet">};</p></li>
				<li>The class <strong class="inline">Hero</strong> should have a public method to cast a spell. Use the value from the <strong class="inline">Spell</strong> class:<p class="snippet">public:</p><p class="snippet">    void cast(Spell spell) {</p><p class="snippet">        // Cast the spell</p><p class="snippet">        std::cout &lt;&lt; “Casting spell “ &lt;&lt; spell.name() &lt;&lt; std::endl;</p><p class="snippet">    }</p></li>
				<li>The class <strong class="inline">Enemy</strong> should have a public method to swing a sword which prints <strong class="inline">Swinging sword</strong>:<p class="snippet">public:</p><p class="snippet">    void swingSword() {</p><p class="snippet">        // Swing the sword</p><p class="snippet">        std::cout &lt;&lt; “Swinging sword” &lt;&lt; std::endl;</p><p class="snippet">    }</p></li>
				<li>Implement the <strong class="inline">main</strong> method that calls these methods in various classes:<p class="snippet">int main()</p><p class="snippet">{</p><p class="snippet">    Position position{“Enemy castle”};</p><p class="snippet">    Hero hero;</p><p class="snippet">    Enemy enemy;</p><p class="snippet">    // We call moveTo on Hero, which calls the method inherited</p><p class="snippet">    // from the Character class</p><p class="snippet">    hero.moveTo(position);</p><p class="snippet">    enemy.moveTo(position);</p><p class="snippet">    // We can still use the Hero and Enemy methods</p><p class="snippet">    hero.cast(Spell(“fireball”));</p><p class="snippet">    enemy.swingSword();</p><p class="snippet">}</p></li>
			</ol>
			<h3 id="_idParaDest-249"><a id="_idTextAnchor287"/>Activity 24: Calculating Employee Salaries</h3>
			<ol>
				<li value="1">We can create a class <strong class="inline">Employee</strong> with two virtual methods, <strong class="inline">getBaseSalary</strong> and <strong class="inline">getBonus</strong>, since we want to change those methods based on the type of employee:<p class="snippet">class Employee {</p><p class="snippet">  public:</p><p class="snippet">    virtual int getBaseSalary() const { return 100; }</p><p class="snippet">    virtual int getBonus(const Deparment&amp; dep) const {</p><p class="snippet">      if (dep.hasReachedTarget()) {</p><p class="snippet">      }</p><p class="snippet">      return 0;</p><p class="snippet">    }</p></li>
				<li>We also define a method, <strong class="inline">getTotalComp</strong>, which does not need to be virtual, but will call the two virtual methods:<p class="snippet">    int getTotalComp(const Deparment&amp; dep) {</p><p class="snippet">      </p><p class="snippet">    }</p><p class="snippet">};</p></li>
				<li>We then derive a <strong class="inline">Manager</strong> class from it, overriding the method for computing the bonus. We might also want to override <strong class="inline">getBaseSalary</strong> if we want to give a different base salary to managers:<p class="snippet">class Manager : public Employee {</p><p class="snippet">  public:</p><p class="snippet">    virtual int getBaseSalary() const override { return 150; }</p><p class="snippet">    virtual int getBonus(const Deparment&amp; dep) const override {</p><p class="snippet">      if (dep.hasReachedTarget()) {</p><p class="snippet">        int additionalDeparmentEarnings = dep.effectiveEarning() - dep.espectedEarning();</p><p class="snippet">        return 0.2 * getBaseSalary() + 0.01 * additionalDeparmentEarnings;</p><p class="snippet">      }</p><p class="snippet">      return 0;</p><p class="snippet">    }</p><p class="snippet">};</p></li>
				<li>Create a class <strong class="inline">Department</strong> as shown:<p class="snippet">class Department {</p><p class="snippet">  public:</p><p class="snippet">    bool hasReachedTarget() const {return true;}</p><p class="snippet">    int espectedEarning() const {return 1000;}</p><p class="snippet">    int effectiveEarning() const {return 1100;}</p><p class="snippet">};</p></li>
				<li>Now, in the <strong class="inline">main</strong> function, call the <strong class="inline">Department</strong>, <strong class="inline">Employee</strong>, and <strong class="inline">Manager</strong> classes as shown:<p class="snippet">int main()</p><p class="snippet">{</p><p class="snippet">  Department dep;</p><p class="snippet">  Employee employee;</p><p class="snippet">  Manager manager;</p><p class="snippet">  std::cout &lt;&lt; “Employee: “ &lt;&lt; employee.getTotalComp(dep) &lt;&lt; “. Manager: “ &lt;&lt; manager.getTotalComp(dep) &lt;&lt; std::endl;</p><p class="snippet">}</p></li>
			</ol>
			<h3 id="_idParaDest-250"><a id="_idTextAnchor288"/>Activity 25: Retrieving User Information</h3>
			<ol>
				<li value="1">We have to write the code that can be independent of where the data is coming from. So, we create an interface <strong class="inline">UserProfileStorage</strong> for retrieving the <strong class="inline">CustomerProfile</strong> from a <strong class="inline">UserId</strong>:<p class="snippet">struct UserProfile {};</p><p class="snippet">struct UserId {};</p><p class="snippet">class UserProfileStorage {</p><p class="snippet">  public:</p><p class="snippet">    virtual UserProfile getUserProfile(const UserId&amp; id) const = 0;</p><p class="snippet">    </p><p class="snippet">    virtual ~UserProfileStorage() = default;</p><p class="snippet">  protected:</p><p class="snippet">    UserProfileStorage() = default;</p><p class="snippet">    UserProfileStorage(const UserProfileStorage&amp;) = default;</p><p class="snippet">    UserProfileStorage&amp; operator=(const UserProfileStorage&amp;) = default;</p><p class="snippet">};</p></li>
				<li>Now, write the <strong class="inline">UserProfileCache</strong> class that inherits from <strong class="inline">UserProfileStorage</strong>:<p class="snippet">class UserProfileCache : public UserProfileStorage {</p><p class="snippet">  public:</p><p class="snippet">    UserProfile getUserProfile(const UserId&amp; id) const override { </p><p class="snippet">    std::cout &lt;&lt; “Getting the user profile from the cache” &lt;&lt; std::endl;</p><p class="snippet">    return UserProfile(); }</p><p class="snippet">};</p><p class="snippet">void exampleOfUsage(const UserProfileStorage&amp; storage) {</p><p class="snippet">    UserId user;</p><p class="snippet">    std::cout &lt;&lt; “About to retrieve the user profile from the storage” &lt;&lt;std::endl;</p><p class="snippet">    UserProfile userProfile = storage.getUserProfile(user);</p><p class="snippet">}</p></li>
				<li>In the <strong class="inline">main</strong> function, call the <strong class="inline">UserProfileCache</strong> class and <strong class="inline">exampleOfUsage</strong> function as shown:<p class="snippet">int main()</p><p class="snippet">{</p><p class="snippet">  UserProfileCache cache;</p><p class="snippet">  exampleOfUsage (cache);</p><p class="snippet">}</p></li>
			</ol>
			<h3 id="_idParaDest-251"><a id="_idTextAnchor289"/>Activity 26: Creating a Factory for UserProfileStorage</h3>
			<ol>
				<li value="1">Write the following code that needs the <strong class="inline">UserProfileStorage</strong> class, as shown. To allow that, we provide a factory class, which has a method <strong class="inline">create</strong> that provides an instance of <strong class="inline">UserProfileStorage</strong>. Write this class making sure that the user does not have to manage the memory for the interface manually:<p class="snippet">#include &lt;iostream&gt;</p><p class="snippet">#include &lt;memory&gt;</p><p class="snippet">#include &lt;userprofile_activity18.h&gt;</p><p class="snippet">class UserProfileStorageFactory {</p><p class="snippet">public:</p><p class="snippet">    std::unique_ptr&lt;UserProfileStorage&gt; create() const {</p><p class="snippet">        return std::make_unique&lt;UserProfileCache&gt;();</p><p class="snippet">    }</p><p class="snippet">}; </p></li>
				<li>We want the <strong class="inline">UserProfileStorageFactory</strong> class to return a <strong class="inline">unique_ptr</strong> so that it manages the lifetime of the interface:<p class="snippet">void getUserProfile(const UserProfileStorageFactory&amp; storageFactory) {</p><p class="snippet">  std::unique_ptr&lt;UserProfileStorage&gt; storage = storageFactory.create();</p><p class="snippet">  UserId user;</p><p class="snippet">  storage-&gt;getUserProfile(user);</p><p class="snippet">  // The storage is automatically destroyed</p><p class="snippet">}</p></li>
				<li>Now, in the <strong class="inline">main</strong> function, call the <strong class="inline">UserProfileStorageFactory</strong> class as shown:<p class="snippet">int main()</p><p class="snippet">{</p><p class="snippet">  UserProfileStorageFactory factory;</p><p class="snippet">  getUserProfile(factory);</p></li>
			</ol>
			<h3 id="_idParaDest-252"><a id="_idTextAnchor290"/>Activity 27: Using a Database Connection for Multiple Operations</h3>
			<ol>
				<li value="1">First, create a <strong class="inline">DatabaseConnection</strong> class that can be used in parallel. We want to reuse it as much as possible, and we know we can use <strong class="inline">std::async</strong> to start a new parallel task:<p class="snippet">#include &lt;future&gt;</p><p class="snippet">struct DatabaseConnection {};</p></li>
				<li>Assuming there are two functions <strong class="inline">updateOrderList(DatabaseConnection&amp;)</strong> and <strong class="inline">scheduleOrderProcessing(DatabaseConnection&amp;)</strong>, write a function that creates a <strong class="inline">DatabaseConnection</strong> and gives it to the two parallel tasks. (Note that we don’t know which task finishes first):<p class="snippet">void updateOrderList(DatabaseConnection&amp;) {}</p><p class="snippet">void scheduleOrderProcessing(DatabaseConnection&amp;) {}</p></li>
				<li>You must understand when and how to create a <strong class="inline">shared_ptr</strong>. You can also use the following code to write the <strong class="inline">shared_ptr</strong> correctly.<p class="snippet">/* We need to get a copy of the shared_ptr so it stays alive until this function finishes */</p><p class="snippet">void updateWithConnection(std::shared_ptr&lt;DatabaseConnection&gt; connection) {</p><p class="snippet">    updateOrderList(*connection);</p><p class="snippet">}</p><p>There are several users of the connection, and we do not know which one is the owner, since the connection needs to stay alive as long as anyone is using it.</p></li>
				<li>To model this, we use a <strong class="inline">shared_ptr</strong>. Remember that we need a copy of the <strong class="inline">shared_ptr</strong> to exist in order for the connection to remain valid:<p class="snippet">/* We need to get a copy of the shared_ptr so it stays alive until this function finishes. */</p><p class="snippet">void scheduleWithConnection(std::shared_ptr&lt;DatabaseConnection&gt; connection) {</p><p class="snippet">    scheduleOrderProcessing(*connection);</p><p class="snippet">}</p></li>
				<li>Create<a id="_idTextAnchor291"/> the <strong class="inline">main</strong> function as follows:<p class="snippet">int main()</p><p class="snippet">{</p><p class="snippet">    std::shared_ptr&lt;DatabaseConnection&gt; connection = std::make_shared&lt;DatabaseConnection&gt;();</p><p class="snippet">    std::async(std::launch::async, updateWithConnection, connection);</p><p class="snippet">    std::async(std::launch::async, scheduleWithConnection, connection);</p><p class="snippet">}</p></li>
			</ol>
		</div>
</body></html>