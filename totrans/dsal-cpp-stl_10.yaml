- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Container View Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At their core, views are non-owning ranges, meaning they provide a view (hence
    the name) of other data structures without taking ownership of the underlying
    data. This makes them incredibly lightweight and versatile. With views, you can
    perform various operations on data without copying it, ensuring efficient code
    that maximizes performance and minimizes overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter focuses on the following containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::span`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::mdspan`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  prefs: []
  type: TYPE_NORMAL
- en: std::span
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::span` is a template class introduced in C++20 that provides a view of
    a contiguous sequence of elements, similar to a lightweight, non-owning reference.
    It represents a range over some contiguous storage, such as an array or a portion
    of a vector, without owning the underlying data.'
  prefs: []
  type: TYPE_NORMAL
- en: The primary purpose of `std::span` is to safely and efficiently pass arrays
    of data to functions without needing to pass the size explicitly, as the size
    information is encapsulated within the `std::span` object. It can be considered
    a safer, more flexible alternative to raw pointer-and-size or pointer-and-length
    parameter passing.
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::span` is a non-owning view of a contiguous sequence, often an array or
    a segment of another container. It is a lightweight, flexible, and safe way to
    refer to such sequences, ensuring no extraneous copies.'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::span` is best suited in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When a temporary view of data is needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the underlying data’s ownership is managed elsewhere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to avoid unnecessary data copying but still need random access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider using `std::span` to provide functions with access to parts of data
    without granting ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases of `std::span`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Processing data segments**: Parsing a subsegment of a large data block, such
    as processing headers in a networking buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function interfaces**: Granting functions a view of data without transferring
    ownership or risking resource leaks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data views**: Quickly and safely offering multiple views on a data source
    without duplicating the source'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of `std::span` is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::span` doesn’t own its data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deletion**: Not applicable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: *O(1)*, just like direct array access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Minimal, as it essentially holds a pointer and a size'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, the performance of `std::span` mainly derives from its non-owning
    characteristic.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No allocations are done by `std::span`. It simply references memory owned elsewhere.
    Thus, concerns about memory behavior primarily relate to the underlying data,
    not the span itself.
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple concurrent reads through a span are safe. However, as with any data
    structure, concurrent writes or write-read combinations require synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::span` is unique in the `std::string_view` offer a similar view concept,
    they cater to specific data types.'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sorting isn’t directly applicable to `std::span`, since it doesn’t own its data.
    Searching, however, is *O(n)* for an unsorted sequence and *O(log n)* for sorted
    data using appropriate STL algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Key functions in this category include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`size()`: Returns the number of elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data()`: Provides access to the underlying data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subspan()`: Generates another span from the current one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to `std::vector` or `std::array`, `std::span` doesn’t manage or own
    data. It offers a way to safely view sections of these containers (or others)
    without copying.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: STL algorithms requiring access (and not structure modification) can interact
    with `std::span` seamlessly. Those requiring insertions or deletions should be
    avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operating beyond the bounds of the span can trigger exceptions. Always ensure
    the underlying data’s validity during the span’s entire lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::span` isn’t typically customized with allocators, comparators, or hash
    functions due to its non-owning nature.'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at an example demonstrating the use of `std::span` to process the
    headers of a **User Datagram Protocol** (**UDP**) packet.
  prefs: []
  type: TYPE_NORMAL
- en: 'UDP headers typically consist of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source port**: 2 bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destination port**: 2 bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Length**: 2 bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Checksum**: 2 bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll create a simple structure representing the header, and then we’ll use
    `std::span` to handle a buffer containing the header and data of a UDP packet.
    Let’s explore the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The key points from the preceding code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We define a `UDPHeader` structure to represent the header fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `processUDPPacket` function, we use `std::span` to handle the buffer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then create a `subspan` for the header and reinterpret it as the `UDPHeader`
    structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining part of the buffer is the data, which we handle using another
    `subspan`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::span` offers a view of a contiguous sequence of objects, making it suitable
    for safely accessing memory regions, such as networking buffers, without owning
    the underlying data.'
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us explore the best practices of using `std::span`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::span` outlives the span itself. This is critical to avoid dangling references.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::span` is not a data-owning container. It only provides a view of the
    data, unlike containers such as `std::vector` that manage their data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::span` view. This joint reflection means data integrity must be maintained
    throughout the span’s life cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::span` judiciously. Always ensure the span’s duration is shorter than
    or equal to the lifetime of the underlying data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::span` in function interfaces to prevent unnecessary data copying. This
    can optimize performance, especially when working with large data blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::span`. Utilize functions such as `size()` for bounds verification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::span` over raw pointer and length pairs. It offers a type-safe, more
    readable alternative, reducing the risk of common pointer errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::span` for abstracting data segments. It’s especially beneficial when
    different components or functions of a program need access to varying data sections
    without full ownership.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::span` offers random access iterators, it’s compatible with most STL algorithms.
    However, be cautious when using algorithms that might expect data ownership or
    mutation capabilities beyond the scope of `std::span`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::span`, given its direct reflection properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::mdspan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::mdspan`, introduced in the C++23 standard, is a multidimensional span
    template class that extends the concept of `std::span` to multiple dimensions.
    It provides a view of a multidimensional contiguous sequence of elements without
    owning the underlying data. This class is handy for numerical computations and
    algorithms that operate on multidimensional data structures, such as matrices
    and tensors.'
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and suitability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::mdspan` is a multidimensional span in the C++ STL. It is a non-owning
    view of a multidimensional array, offering efficient access and manipulation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Its strengths are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Representing and accessing multidimensional data without owning it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facilitating interoperability with other languages and libraries that work with
    multidimensional arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::mdspan` is particularly suitable in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: When you must work with multidimensional data from other libraries or APIs without
    copying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you require flexibility in indexing and slicing through multidimensional
    datasets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideal use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the ideal use cases of `std::mdspan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Image processing**: Accessing pixels in a 2D image or frames in a 3D video
    stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scientific computing**: Manipulating data in matrix formats for mathematical
    computations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data wrangling**: Efficiently re-indexing, slicing, or reshaping multidimensional
    datasets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interoperability**: Interfacing with other languages or libraries that manage
    multidimensional data structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The algorithmic performance of `std::mdspan` is characterized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access**: Typically *O(1)* for any position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::mdspan` only provides a view of existing data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::mdspan` itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since `std::mdspan` doesn’t own its data, it does not control memory allocation
    or deallocation. Ensure the underlying data remains valid during the `mdspan`
    lifespan.
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like `std::span`, multiple concurrent reads are safe, but writes or mixed reads
    and writes necessitate external synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions and variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::span` can be seen as a 1D variant. While `std::span` provides a view
    of linear data, `std::mdspan` extends this concept to multidimensional data.'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and searching complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sorting and searching are not inherently properties of `std::mdspan`, given
    its nature. External algorithms would need to be adapted to their multidimensional
    characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Special interface and member functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::mdspan` offers the following special interface and member functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`extent`: Returns the size in a given dimension'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strides`: Provides the number of elements between successive items in each
    dimension'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rank`: Gives the number of dimensions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Against raw multidimensional arrays or pointers, `std::mdspan` offers a safer
    and more flexible interface, albeit without data ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While many STL algorithms are designed for linear data structures, specific
    algorithms, especially custom ones for multidimensional data, can be adapted to
    work with `std::mdspan`.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given its non-owning nature, accessing data through an invalidated `std::mdspan`
    (if the underlying data is destroyed) is an undefined behavior and won’t throw
    standard exceptions. Always ensure data validity.
  prefs: []
  type: TYPE_NORMAL
- en: Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::mdspan` can be customized using layout policies to define data storage
    patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us explore the best practices of using `std::mdspan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::mdspan` is a non-owning view. Ensure that you never mistakenly treat
    it as a data-owning container. This oversight can introduce dangling references
    and undefined behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::mdspan`. Understanding and adjusting these aspects can optimize your
    data access patterns, making them more cache-friendly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::mdspan`’s layout with the expected convention can prevent subtle bugs
    and inefficiencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::mdspan` points remain valid for the span’s entire lifetime. Avoid situations
    where the underlying data could be destroyed or go out of scope while an active
    `std::mdspan` references it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Explicit layout specification**: When working alongside different libraries,
    especially those external to the C++ STL, be overt about the expected data layouts.
    Such clarity prevents ambiguities and ensures consistent data interpretation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::mdspan` as a parameter. This choice offers safety from dangling references
    (compared to raw pointers) and greater expressiveness regarding multidimensional
    data operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::mdspan`. While `std::mdspan` offers some level of type safety, out-of-bounds
    access still leads to undefined behavior. Consider using functions such as `extents`
    to ascertain dimensions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::mdspan` interprets the underlying data using layout policies for advanced
    use cases. This flexibility can be particularly valuable when needing non-standard
    data arrangements or optimizing for specific hardware architectures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::span`, `std::mdspan` itself doesn’t guarantee thread safety for the underlying
    data. If multithreaded access is anticipated, ensure the underlying data structure
    or its operations are thread-safe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::mdspan` doesn’t naturally fit all STL algorithms due to its multidimensional
    nature, you can still use many algorithms on a flattened view or individual slices
    of the data. Being familiar with STL algorithms can help you avoid reinventing
    the wheel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3: Mastering STL Algorithms'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this Part, you will acquire a robust understanding of the algorithmic backbone
    of the C++ STL. We establish a foundation with fundamental algorithms, emphasizing
    sorting, searching, and element comparison, essential to efficient data manipulation.
    We then dive into the transformative power of STL through copying, moving, filling,
    and generating operations, revealing techniques for optimal data manipulation
    while underpinning the importance of modern idioms like **Return Value** **Optimization
    (RVO)**.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing, we explore numeric operations, from simple summations to complex
    inner products, and extend our focus to range-based operations, underscoring their
    significance in modern C++. The subsequent chapter transitions to the structured
    manipulation of data sets through partitioning, heap operations, and permutations,
    illustrating their pivotal roles in data organization and analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we conclude by introducing the concept of ranges, an evolution in STL
    that brings a more expressive and efficient approach to algorithmic operations.
    We dissect the advantages and best practices of range-based algorithms for sorting
    and searching, advocating for their adoption in contemporary C++ development.
    Best practices are highlighted throughout, providing you with a clear pathway
    to writing clean, efficient, and maintainable code with STL algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B21945_11.xhtml#_idTextAnchor498)*: Fundamental Algorithms and
    Searching*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B21945_12.xhtml#_idTextAnchor507)*: Manipulation and Transformation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B21945_13.xhtml#_idTextAnchor530)*: Numeric and Range-Based
    Operations*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B21945_14.xhtml#_idTextAnchor542)*: Permutations, Partitions,
    and Heaps*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B21945_15.xhtml#_idTextAnchor563)*: Modern STL with Ranges*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
