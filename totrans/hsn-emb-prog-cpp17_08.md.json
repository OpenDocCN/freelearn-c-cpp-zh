["```cpp\nsudo apt install build-essential\nsudo apt install g++-arm-linux-gnueabihf\nsudo apt install gdb-multiarch  \n```", "```cpp\narm-linux-gnueabihf-g++  \n```", "```cpp\narm-linux-gnueabihf-g++ -v  \n```", "```cpp\nmkdir ~/raspberry/sysroot\nscp -r pi@Pi-system:/lib ~/raspberry/sysroot\nscp -r pi@Pi-system:/usr ~/raspberry/sysroot  \n```", "```cpp\n--sysroot=dir  \n```", "```cpp\n#include <Poco/Timer.h>\n\n#define  INPUT              0\n#define  OUTPUT                   1\n#define  PWM_OUTPUT         2\n#define  GPIO_CLOCK         3\n#define  SOFT_PWM_OUTPUT          4\n#define  SOFT_TONE_OUTPUT   5\n#define  PWM_TONE_OUTPUT          6\n```", "```cpp\n#define  LOW                0\n#define  HIGH               1\n\n#define  PUD_OFF                  0\n#define  PUD_DOWN           1\n#define  PUD_UP                   2\n\n#define  INT_EDGE_SETUP          0\n#define  INT_EDGE_FALLING  1\n#define  INT_EDGE_RISING         2\n#define  INT_EDGE_BOTH           3\n```", "```cpp\ntypedef void (*ISRCB)(void); \n```", "```cpp\nclass WiringTimer {\n    Poco::Timer* wiringTimer;\n    Poco::TimerCallback<WiringTimer>* cb;\n    uint8_t triggerCnt;\n\n public:\n    ISRCB isrcb_0;\n    ISRCB isrcb_7;\n    bool isr_0_set;\n    bool isr_7_set;\n\n    WiringTimer();\n    ~WiringTimer();\n    void start();\n    void trigger(Poco::Timer &t);\n };\n```", "```cpp\nint wiringPiSetup(); \nvoid pinMode(int pin, int mode); \nvoid pullUpDnControl(int pin, int pud); \nint digitalRead(int pin);\nint wiringPiISR(int pin, int mode, void (*function)(void));\n```", "```cpp\n#include \"wiringPi.h\"\n\n#include <fstream>\n#include <memory>\n\nWiringTimer::WiringTimer() {\n   triggerCnt = 0;\n   isrcb_0 = 0;\n   isrcb_7 = 0;\n   isr_0_set = false;\n   isr_7_set = false;\n\n   wiringTimer = new Poco::Timer(10 * 1000, 10 * 1000);\n   cb = new Poco::TimerCallback<WiringTimer>(*this, \n   &WiringTimer::trigger);\n}\n```", "```cpp\nWiringTimer::~WiringTimer() {\n   delete wiringTimer;\n   delete cb;\n}\n```", "```cpp\nvoid WiringTimer::start() {\n   wiringTimer->start(*cb);\n}\n```", "```cpp\nvoid WiringTimer::trigger(Poco::Timer &t) {\n    if (triggerCnt == 0) {\n          char val = 0x00;\n          std::ofstream PIN0VAL;\n          PIN0VAL.open(\"pin0val\", std::ios_base::binary | std::ios_base::trunc);\n          PIN0VAL.put(val);\n          PIN0VAL.close();\n\n          isrcb_0();\n\n          ++triggerCnt;\n    }\n    else if (triggerCnt == 1) {\n          char val = 0x01;\n          std::ofstream PIN7VAL;\n          PIN7VAL.open(\"pin7val\", std::ios_base::binary | std::ios_base::trunc);\n          PIN7VAL.put(val);\n          PIN7VAL.close();\n\n          isrcb_7();\n\n          ++triggerCnt;\n    }\n    else if (triggerCnt == 2) {\n          char val = 0x00;\n          std::ofstream PIN7VAL;\n          PIN7VAL.open(\"pin7val\", std::ios_base::binary | std::ios_base::trunc);\n          PIN7VAL.put(val);\n          PIN7VAL.close();\n\n          isrcb_7();\n\n          ++triggerCnt;\n    }\n    else if (triggerCnt == 3) {\n          char val = 0x01;\n          std::ofstream PIN0VAL;\n          PIN0VAL.open(\"pin0val\", std::ios_base::binary | std::ios_base::trunc);\n          PIN0VAL.put(val);\n          PIN0VAL.close();\n\n          isrcb_0();\n\n          triggerCnt = 0;\n    }\n }\n\n```", "```cpp\nnamespace Wiring {\n   std::unique_ptr<WiringTimer> wt;\n   bool initialized = false;\n}\n```", "```cpp\nint wiringPiSetup() {\n    char val = 0x01;\n    std::ofstream PIN0VAL;\n    std::ofstream PIN7VAL;\n    PIN0VAL.open(\"pin0val\", std::ios_base::binary | std::ios_base::trunc);\n    PIN7VAL.open(\"pin7val\", std::ios_base::binary | std::ios_base::trunc);\n    PIN0VAL.put(val);\n    val = 0x00;\n    PIN7VAL.put(val);\n    PIN0VAL.close();\n    PIN7VAL.close();\n\n    Wiring::wt = std::make_unique<WiringTimer>();\n    Wiring::initialized = true;\n\n    return 0;\n }\n```", "```cpp\n void pinMode(int pin, int mode) {\n    // \n\n    return;\n }\n\n void pullUpDnControl(int pin, int pud) {\n    // \n\n    return;\n }\n```", "```cpp\n int digitalRead(int pin) {\n    if (pin == 0) {\n          std::ifstream PIN0VAL;\n          PIN0VAL.open(\"pin0val\", std::ios_base::binary);\n          int val = PIN0VAL.get();\n          PIN0VAL.close();\n\n          return val;\n    }\n    else if (pin == 7) {\n          std::ifstream PIN7VAL;\n          PIN7VAL.open(\"pin7val\", std::ios_base::binary);\n          int val = PIN7VAL.get();\n          PIN7VAL.close();\n\n          return val;\n    }\n\n    return 0;\n }\n```", "```cpp\n//This value is then returned to the calling function.\n\n int wiringPiISR(int pin, int mode, void (*function)(void)) {\n    if (!Wiring::initialized) { \n          return 1;\n    }\n\n    if (pin == 0) { \n          Wiring::wt->isrcb_0 = function;\n          Wiring::wt->isr_0_set = true;\n    }\n    else if (pin == 7) {\n          Wiring::wt->isrcb_7 = function;\n          Wiring::wt->isr_7_set = true;\n    }\n\n    if (Wiring::wt->isr_0_set && Wiring::wt->isr_7_set) {\n          Wiring::wt->start();\n    }\n\n    return 0;\n }\n```", "```cpp\nint wiringPiI2CSetup(const int devId);\nint wiringPiI2CWriteReg8(int fd, int reg, int data);\n```", "```cpp\n#include \"wiringPiI2C.h\"\n\n#include \"../club.h\"\n\n#include <Poco/NumberFormatter.h>\n\nusing namespace Poco;\n\nint wiringPiI2CSetup(const int devId) {\n   Club::log(LOG_INFO, \"wiringPiI2CSetup: setting up device ID: 0x\" \n                                        + NumberFormatter::formatHex(devId));\n\n   return 0;\n}\n```", "```cpp\nint wiringPiI2CWriteReg8(int fd, int reg, int data) {\n    Club::log(LOG_INFO, \"wiringPiI2CWriteReg8: Device handle 0x\" + NumberFormatter::formatHex(fd) \n                                        + \", Register 0x\" + NumberFormatter::formatHex(reg)\n                                        + \" set to: 0x\" + NumberFormatter::formatHex(data));\n\n    return 0;\n}\n```", "```cpp\nmake TEST=1  \n```", "```cpp\n Starting ClubStatus server...\n Initialised C++ Mosquitto library.\n Created listener, entering loop...\n [New Thread 0x7ffff49c9700 (LWP 35462)]\n [New Thread 0x7ffff41c8700 (LWP 35463)]\n [New Thread 0x7ffff39c7700 (LWP 35464)]\n Initialised the HTTP server.\n INFO:       Club: starting up...\n INFO:       Club: Finished wiringPi setup.\n INFO:       Club: Finished configuring pins.\n INFO:       Club: Configured interrupts.\n [New Thread 0x7ffff31c6700 (LWP 35465)]\n INFO:       Club: Started update thread.\n Connected. Subscribing to topics...\n INFO:       ClubUpdater: Starting i2c relay device.\n INFO:       wiringPiI2CSetup: setting up device ID: 0x20\n INFO:       wiringPiI2CWriteReg8: Device handle 0x0, Register 0x6 set to: 0x0\n INFO:       wiringPiI2CWriteReg8: Device handle 0x0, Register 0x2 set to: 0x0\n INFO:       ClubUpdater: Finished configuring the i2c relay device's registers.  \n```", "```cpp\n INFO:       ClubUpdater: starting initial update run.\n INFO:       ClubUpdater: New lights, clubstatus off.\n DEBUG:      ClubUpdater: Power timer not active, using current power state: off\n INFO:       ClubUpdater: Red on.\n DEBUG:      ClubUpdater: Changing output register to: 0x8\n INFO:       wiringPiI2CWriteReg8: Device handle 0x0, Register 0x2 set to: 0x8\n DEBUG:      ClubUpdater: Finished writing relay outputs with: 0x8\n INFO:       ClubUpdater: Initial status update complete.  \n```", "```cpp\n INFO:       ClubUpdater: Entering waiting condition. INFO:       ClubUpdater: lock status changed to unlocked\n INFO:       ClubUpdater: New lights, clubstatus off.\n DEBUG:      ClubUpdater: Power timer not active, using current power state: off\n INFO:       ClubUpdater: Yellow on.\n DEBUG:      ClubUpdater: Changing output register to: 0x4\n INFO:       wiringPiI2CWriteReg8: Device handle 0x0, Register 0x2 set to: 0x4\n DEBUG:      ClubUpdater: Finished writing relay outputs with: 0x4\n INFO:       ClubUpdater: status switch status changed to on\n INFO:       ClubUpdater: Opening club.\n INFO:       ClubUpdater: Started power timer...\n DEBUG:      ClubUpdater: Sent MQTT message.\n INFO:       ClubUpdater: New lights, clubstatus on.\n DEBUG:      ClubUpdater: Power timer active, inverting power state from: on\n INFO:       ClubUpdater: Green on.\n DEBUG:      ClubUpdater: Changing output register to: 0x2\n INFO:       wiringPiI2CWriteReg8: Device handle 0x0, Register 0x2 set to: 0x2\n DEBUG:      ClubUpdater: Finished writing relay outputs with: 0x2\n INFO:       ClubUpdater: status switch status changed to off\n INFO:       ClubUpdater: Closing club.\n INFO:       ClubUpdater: Started timer.\n INFO:       ClubUpdater: Started power timer...\n DEBUG:      ClubUpdater: Sent MQTT message.\n INFO:       ClubUpdater: New lights, clubstatus off.\n DEBUG:      ClubUpdater: Power timer active, inverting power state from: off\n INFO:       ClubUpdater: Yellow on.\n DEBUG:      ClubUpdater: Changing output register to: 0x5\n INFO:       wiringPiI2CWriteReg8: Device handle 0x0, Register 0x2 set to: 0x5\n DEBUG:      ClubUpdater: Finished writing relay outputs with: 0x5\n INFO:       ClubUpdater: setPowerState called.\n DEBUG:      ClubUpdater: Writing relay with: 0x4\n INFO:       wiringPiI2CWriteReg8: Device handle 0x0, Register 0x2 set to: 0x4\n DEBUG:      ClubUpdater: Finished writing relay outputs with: 0x4\n DEBUG:      ClubUpdater: Written relay outputs.\n DEBUG:      ClubUpdater: Finished setPowerState.\n INFO:       ClubUpdater: lock status changed to locked\n INFO:       ClubUpdater: New lights, clubstatus off.\n DEBUG:      ClubUpdater: Power timer not active, using current power state: off\n INFO:       ClubUpdater: Red on.\n DEBUG:      ClubUpdater: Changing output register to: 0x8\n INFO:       wiringPiI2CWriteReg8: Device handle 0x0, Register 0x2 set to: 0x8\n DEBUG:      ClubUpdater: Finished writing relay outputs with: 0x8  \n```", "```cpp\nint wiringPiI2CSetup (const int devId) { \n   int rev; \n   const char *device; \n\n   rev = piGpioLayout(); \n\n   if (rev == 1) { \n         device = \"/dev/i2c-0\"; \n   } \n   else { \n         device = \"/dev/i2c-1\"; \n   } \n\n   return wiringPiI2CSetupInterface (device, devId); \n} \n```", "```cpp\nint wiringPiI2CSetupInterface (const char *device, int devId) { \n   int fd; \n   if ((fd = open (device, O_RDWR)) < 0) { \n         return wiringPiFailure (WPI_ALMOST, \"Unable to open I2C device: %s\\n\", \n                                                                                                strerror (errno)); \n   } \n\n   if (ioctl (fd, I2C_SLAVE, devId) < 0) { \n         return wiringPiFailure (WPI_ALMOST, \"Unable to select I2C device: %s\\n\",                                                                                                strerror (errno)); \n   } \n\n   return fd; \n} \n```", "```cpp\nstatic inline int i2c_smbus_access (int fd, char rw, uint8_t command, int size, union i2c_smbus_data *data) { \n   struct i2c_smbus_ioctl_data args; \n\n   args.read_write = rw; \n   args.command    = command; \n   args.size       = size; \n   args.data       = data; \n   return ioctl(fd, I2C_SMBUS, &args); \n} \n```", "```cpp\nunion i2c_smbus_data { \n   uint8_t byte; \n   uint16_t word; \n   uint8_t block[I2C_SMBUS_BLOCK_MAX + 2]; \n}; \n```", "```cpp\n TARGET_OS = linux\n TARGET_ARCH = x86_64\n\n export CC = gcc\n export CXX = g++\n export CPP = cpp\n export AR = ar\n export LD = g++\n export STRIP = strip\n export OBJCOPY = objcopy\n\n PLATFORM_FLAGS = -D__PLATFORM_LINUX__ -D_LARGEFILE64_SOURCE -D __LINUX__\n STD_FLAGS = $(PLATFORM_FLAGS) -Og -g3 -Wall -c -fmessage-length=0 -ffunction-sections -fdata-sections -DPOCO_HAVE_GCC_ATOMICS -DPOCO_UTIL_NO_XMLCONFIGURATION -DPOCO_HAVE_FD_EPOLL\n STD_CFLAGS = $(STD_FLAGS)\n STD_CXXFLAGS = -std=c++11 $(STD_FLAGS)\n STD_LDFLAGS = -L $(TOP)/build/$(TARGET)/libboost/lib \\\n                         -L $(TOP)/build/$(TARGET)/poco/lib \\\n                         -Wl,--gc-sections\n STD_INCLUDE = -I. -I $(TOP)/build/$(TARGET)/libboost/include \\\n                         -I $(TOP)/build/$(TARGET)/poco/include \\\n                         -I $(TOP)/extern/boost-1.58.0\n STD_LIBDIRS = $(STD_LDFLAGS)\n STD_LIBS = -ldl -lrt -lboost_system -lssl -lcrypto -lpthread\n\n```", "```cpp\nTARGET_OS = osx\n TARGET_ARCH = x86_64\n\n export CC = clang\n export CXX = clang++\n export CPP = cpp\n export AR = ar\n export LD = clang++\n export STRIP = strip\n export OBJCOPY = objcopy\n```", "```cpp\nTARGET_OS = linux\n TARGET_ARCH = armv7\n TOOLCHAIN_NAME = arm-linux-gnueabihf\n\n export CC = $(TOOLCHAIN_NAME)-gcc\n export CXX = $(TOOLCHAIN_NAME)-g++\n export AR = $(TOOLCHAIN_NAME)-ar\n export LD = $(TOOLCHAIN_NAME)-g++\n export STRIP = $(TOOLCHAIN_NAME)-strip\n export OBJCOPY = $(TOOLCHAIN_NAME)-objcopy\n```", "```cpp\nifndef TARGET\n $(error TARGET parameter not provided.)\n endif\n```", "```cpp\nexport TOP := $(CURDIR)\n export TARGET\n```", "```cpp\nUNAME := $(shell uname)\n ifeq ($(UNAME), Linux)\n export HOST = linux\n else\n export HOST = win32\n export FILE_EXT = .exe\n endif\n```", "```cpp\nifeq ($(HOST), linux)\n export MKDIR   = mkdir -p\n export RM            = rm -rf\n export CP            = cp -RL\n else\n export MKDIR   = mkdir -p\n export RM            = rm -rf\n export CP            = cp -RL\n endif\n```", "```cpp\ninclude Makefile.$(TARGET)\n\n export TARGET_OS\n export TARGET_ARCH\n export TOOLCHAIN_NAME\n```", "```cpp\nall: extern-$(TARGET) core\n\n extern:\n    $(MAKE) -C ./extern $(LIBRARY)\n\n extern-$(TARGET):\n    $(MAKE) -C ./extern all-$(TARGET)\n\n core:\n    $(MAKE) -C ./Core\n\n clean: clean-core clean-extern\n\n clean-extern:\n    $(MAKE) -C ./extern clean-$(TARGET)\n\n clean-core:\n    $(MAKE) -C ./Core clean\n\n .PHONY: all clean core extern clean-extern clean-core extern-$(TARGET)\n```", "```cpp\ninclude ../Makefile.$(TARGET) \n\nOUTPUT := CoreProject \n\nINCLUDE = $(STD_INCLUDE) \nLIBDIRS = $(STD_LIBDIRS) \n\ninclude ../version \nVERSIONINFO = -D__VERSION=\"\\\"$(VERSION)\\\"\" \n```", "```cpp\nifdef RELEASE \nTIMESTAMP = $(shell date --date=@`git show -s --format=%ct $(RELEASE)^{commit}` -u +%Y-%m-%dT%H:%M:%SZ) \nelse ifdef GITTIME \nTIMESTAMP = $(shell date --date=@`git show -s --format=%ct` -u +%Y-%m-%dT%H:%M:%SZ) \nTS_SAFE = _$(shell date --date=@`git show -s --format=%ct` -u +%Y-%m-%dT%H%M%SZ) \nelse \nTIMESTAMP = $(shell date -u +%Y-%m-%dT%H:%M:%SZ) \nTS_SAFE = _$(shell date -u +%Y-%m-%dT%H%M%SZ) \nendif \n```", "```cpp\nCFLAGS = $(STD_CFLAGS) $(INCLUDE) $(VERSIONINFO) -D__TIMESTAMP=\"\\\"$(TIMESTAMP)\\\"\" \nCXXFLAGS = $(STD_CXXFLAGS) $(INCLUDE) $(VERSIONINFO) -D__TIMESTAMP=\"\\\"$(TIMESTAMP)\\\"\" \n\nOBJROOT := $(TOP)/build/$(TARGET)/obj \nCPP_SOURCES := $(wildcard *.cpp) \nCPP_OBJECTS := $(addprefix $(OBJROOT)/,$(CPP_SOURCES:.cpp=.o)) \nOBJECTS := $(CPP_OBJECTS) \n```", "```cpp\n.PHONY: all clean \n\nall: makedirs $(CPP_OBJECTS) $(C_OBJECTS) $(TOP)/build/bin/$(TARGET)/$(OUTPUT)_$(VERSION)_$(TARGET)$(TS_SAFE) \n\nmakedirs: \n   $(MKDIR) $(TOP)/build/bin/$(TARGET) \n   $(MKDIR) $(OBJROOT) \n\n$(OBJROOT)/%.o: %.cpp \n   $(CXX) -o $@ $< $(CXXFLAGS) \n```", "```cpp\n$(TOP)/build/bin/$(TARGET)/$(OUTPUT)_$(VERSION)_$(TARGET)$(TS_SAFE): $(OBJECTS) \n   $(LD) -o $@ $(OBJECTS) $(LIBDIRS) $(LIBS) \n   $(CP) $@ $@.debug \nifeq ($(TARGET_OS), osx) \n   $(STRIP) -S $@ \nelse \n   $(STRIP) -S --strip-unneeded $@      \nendif \n```", "```cpp\nclean: \n   $(RM) $(CPP_OBJECTS) \n   $(RM) $(C_OBJECTS) \n```", "```cpp\nifndef TARGET \n$(error TARGET parameter not provided.) \nendif \n\nall: libboost poco \n\nall-linux-%: \n   $(MAKE) libboost poco \n\nall-qnx-%: \n   $(MAKE) libboost poco \n\nall-osx-%: \n   $(MAKE) libboost poco \n\nall-windows: \n   $(MAKE) libboost poco \n```", "```cpp\nlibboost: \n   cd boost-1.58.0 && $(MAKE) \n\npoco: \n   cd poco-1.7.4 && $(MAKE) \n```", "```cpp\nopenssl: \n   $(MKDIR) $(TOP)/build/$(TARGET)/openssl \n   $(MKDIR) $(TOP)/build/$(TARGET)/openssl/include \n   $(MKDIR) $(TOP)/build/$(TARGET)/openssl/lib \n   cd openssl-1.0.2 && ./Configure --openssldir=\"$(TOP)/build/$(TARGET)/openssl\" shared os/compiler:$(TOOLCHAIN_NAME):$(OPENSSL_PARAMS) && \\ \n     $(MAKE) build_libs \n   $(CP) openssl-1.0.2/include $(TOP)/build/$(TARGET)/openssl \n   $(CP) openssl-1.0.2/libcrypto.a $(TOP)/build/$(TARGET)/openssl/lib/. \n   $(CP) openssl-1.0.2/libssl.a $(TOP)/build/$(TARGET)/openssl/lib/. \n```", "```cpp\ninclude ../../Makefile.$(TARGET) \n\nall: poco-foundation poco-json poco-net poco-util \n\npoco-foundation: \n   cd Foundation && $(MAKE) \n\npoco-json: \n   cd JSON && $(MAKE) \n\npoco-net: \n   cd Net && $(MAKE) \n\npoco-util: \n   cd Util && $(MAKE) \n\nclean: \n   cd Foundation && $(MAKE) clean \n   cd JSON && $(MAKE) clean \n   cd Net && $(MAKE) clean \n   cd Util && $(MAKE) clean \n```", "```cpp\ninclude ../../../Makefile.$(TARGET) \n\nOUTPUT = libPocoNet.a \nINCLUDE = $(STD_INCLUDE) -Iinclude \nCFLAGS = $(STD_CFLAGS) $(INCLUDE) \nOBJROOT = $(TOP)/extern/poco-1.7.4/Net/$(TARGET) \nINCLOUT = $(TOP)/build/$(TARGET)/poco \nSOURCES := $(wildcard src/*.cpp) \nHEADERS := $(addprefix $(INCLOUT)/,$(wildcard include/Poco/Net/*.h)) \n\nOBJECTS := $(addprefix $(OBJROOT)/,$(notdir $(SOURCES:.cpp=.o))) \n\nall: makedir $(OBJECTS) $(TOP)/build/$(TARGET)/poco/lib/$(OUTPUT) $(HEADERS) \n\n$(OBJROOT)/%.o: src/%.cpp \n   $(CC) -c -o $@ $< $(CFLAGS) \n\nmakedir: \n   $(MKDIR) $(TARGET) \n   $(MKDIR) $(TOP)/build/$(TARGET)/poco \n   $(MKDIR) $(TOP)/build/$(TARGET)/poco/lib \n   $(MKDIR) $(TOP)/build/$(TARGET)/poco/include \n   $(MKDIR) $(TOP)/build/$(TARGET)/poco/include/Poco \n   $(MKDIR) $(TOP)/build/$(TARGET)/poco/include/Poco/Net \n\n$(INCLOUT)/%.h: %.h \n   $(CP) $< $(INCLOUT)/$< \n\n$(TOP)/build/$(TARGET)/poco/lib/$(OUTPUT): $(OBJECTS) \n   -rm -f $@ \n   $(AR) rcs $@ $^ \n\nclean: \n   $(RM) $(OBJECTS) \n```", "```cpp\nsudo apt install gdbserver  \n```", "```cpp\ngdbserver host:2345 <program> <parameters>  \n```", "```cpp\ngdbserver host:2345 --attach <PID>  \n```", "```cpp\ngdbserver /dev/tty0 <program> <parameters>\ngdbserver --attach /dev/tty0 <PID>  \n```", "```cpp\n$ gdb-multiarch <program>\n(gdb) target remote <IP>:<port>\nRemote debugging using <IP>:<port>  \n```", "```cpp\n$ gdb-multiarch -baud <baud rate> <program>  \n```", "```cpp\ngdbserver --multi <host>:<port>  \n```", "```cpp\ngdbserver --multi <serial port>  \n```", "```cpp\n$ gdb-multiarch <program>\n(gdb) target extended-remote <remote IP>:<port>\n(gdb) set remote exec-file <remote file path>\n(gdb) run  \n```"]