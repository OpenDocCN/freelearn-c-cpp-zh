<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title> Establishing a Build Environment</title>
<link href="../styles/stylesheet1.css" rel="stylesheet" type="text/css"/>
<link href="../styles/stylesheet2.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="sbo-rt-content"><section class="level1 pkt" data-number="2" id="establishing-a-build-environment">
<h1 data-number="2">1 Establishing a Build Environment</h1>
<section class="level2" data-number="2.1" id="join-our-book-community-on-discord">
<h2 data-number="2.1">Join our book community on Discord</h2>
<p>
<img height="301" src="../media/file40.png" style="width:15rem" width="301"/>
</p>
<p><a href="https://packt.link/unitydev">https://packt.link/unitydev</a></p>
<p>In this chapter, you will learn how to set up a 3D graphics development environment on your computer for Windows and Linux operating systems. You will learn which software tools are needed to run the demos from this book’s source code bundle: <a href="https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook-Second-Edition">https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook-Second-Edition</a>. We will cover the following topics:</p>
<ul>
<li>Setting up our development environment on Microsoft Windows</li>
<li>Setting up our development environment on Linux</li>
<li>Installing the Vulkan SDK for Microsoft Windows and Linux</li>
<li>Managing dependencies</li>
<li>Getting the demo data</li>
<li>Creating utilities for CMake projects</li>
<li>Using the GLFW library</li>
<li>Multithreading with Taskflow</li>
</ul>
</section>
<section class="level2" data-number="2.2" id="setting-up-our-development-environment-on-microsoft-windows">
<h2 data-number="2.2">Setting up our development environment on Microsoft Windows</h2>
<p>In this recipe, we will get started by setting up our development environment on Windows. We will go through the installation of each of the required tools individually and in detail.</p>
<section class="level3" data-number="2.2.1" id="getting-ready">
<h3 data-number="2.2.1">Getting ready</h3>
<p>In order to start working with the examples from this book in a Microsoft Windows environment, you will need some essential tools to be installed in your system.</p>
<p>The most important one is Microsoft Visual Studio 2022. Additional tools include the <strong>Git</strong> version control system, the <strong>CMake</strong> build tool, and the <strong>Python</strong> programming language. Throughout this book, we use these tools on the command line only, so no GUI add-ons will be required.</p>
</section>
<section class="level3" data-number="2.2.2" id="how-to-do-it...">
<h3 data-number="2.2.2">How to do it...</h3>
<p>Let’s install each of the required tools individually.</p>
<section class="level4" data-number="2.2.2.1" id="microsoft-visual-studio-2022">
<h4 data-number="2.2.2.1">Microsoft Visual Studio 2022</h4>
<p>Follow the given steps to install Microsoft Visual Studio 2022:</p>
<ol>
<li>Open <a href="https://visualstudio.microsoft.com">https://visualstudio.microsoft.com</a> and download the Visual Studio 2022 Community Edition installer.</li>
<li>Start the installer and follow the on-screen instructions. For the purposes of this book, you need to have a native C++ compiler for the 64-bit Intel platform. Other components of the Visual Studio development environment are not required to run this book’s bundled sample code.</li>
</ol>
</section>
<section class="level4" data-number="2.2.2.2" id="git">
<h4 data-number="2.2.2.2">Git</h4>
<p>Follow the given steps to install Git:</p>
<ol>
<li>Download the latest Git installer from <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>, run it, and follow the on-screen instructions.</li>
<li><p>We assume that Git is added to the system <code>PATH</code> variable. Enable the option shown in the following image during installation:</p>
<figure>
<img alt="Figure 1.1 – Git from the command line and also from third-party software" height="870" src="../media/file1.png" width="1081"/><figcaption aria-hidden="true">Figure 1.1 – Git from the command line and also from third-party software</figcaption>
</figure></li>
<li>Select <strong>Use Windows’ default console window</strong>, as shown in the next screenshot. This option will allow you to build the scripts in this book from any directory on your computer.</li>
</ol>
<figure>
<img alt="Figure 1.2 – Use Windows’ default console window" height="870" src="../media/file2.png" width="1081"/><figcaption aria-hidden="true">Figure 1.2 – Use Windows’ default console window</figcaption>
</figure>
<blockquote>
<p>Git is complex software and a huge topic in itself. We recommend the book <em>Mastering Git</em> written by Jakub Narębski and published by Packt Publishing, <a href="https://www.packtpub.com/application-development/mastering-git">https://www.packtpub.com/application-development/mastering-git</a>, along with <em>Git Essentials: Developer’s Guide to Git</em> by François Dupire and the downloadable ebook <em>ProGit</em>, Second Edition, by Scott Chacon and Ben Straub, <a href="https://git-scm.com/book/en/v2">https://git-scm.com/book/en/v2</a>.</p>
</blockquote>
</section>
<section class="level4" data-number="2.2.2.3" id="cmake">
<h4 data-number="2.2.2.3">CMake</h4>
<p>To install CMake, please follow the given steps:</p>
<ol>
<li>Download the latest 64-bit CMake installer from <a href="https://cmake.org/download/">https://cmake.org/download/</a>.</li>
<li>Run it and follow the on-screen instructions. If you already have an earlier version of CMake installed, it is recommended to uninstall it first.</li>
<li>Select the <strong>Add CMake to the system PATH for all users</strong> option, as shown here:</li>
</ol>
<figure>
<img alt="Figure 1.3: Add CMake to the system PATH for all users" height="866" src="../media/file3.png" width="1114"/><figcaption aria-hidden="true">Figure 1.3: Add CMake to the system PATH for all users</figcaption>
</figure>
</section>
<section class="level4" data-number="2.2.2.4" id="python">
<h4 data-number="2.2.2.4">Python</h4>
<p>To install Python, please follow the given steps:</p>
<ol>
<li>Download the latest Python 3 installer for 64-bit systems from <a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a>.</li>
<li>Run it and follow the on-screen instructions.</li>
<li><p>During the installation, you also need to install the <code>pip</code> feature. Choose <strong>Custom Installation</strong> and make sure that the <strong>pip</strong> checkbox is checked, as shown:</p>
<figure>
<img alt="Figure 1.4 – Custom installation" height="911" src="../media/file4.png" width="1476"/><figcaption aria-hidden="true">Figure 1.4 – Custom installation</figcaption>
</figure></li>
<li>Once the installation has completed, make sure to add the folder containing <code>python.exe</code> to the PATH environment variable.</li>
</ol>
</section>
<section class="level4" data-number="2.2.2.5" id="theres-more...">
<h4 data-number="2.2.2.5">There’s more...</h4>
<p>Besides Git, there are other popular version control systems, like SVN and Mercurial. While developing large software systems, you will inevitably face the need to download some libraries from a non-Git repository. We recommend getting familiar with Mercurial.</p>
<p>While working in the command-line environment, it is useful to have some tools from the Unix environment, like <code>wget</code>, <code>grep</code>, <code>find</code>, etc. The <strong>GnuWin32</strong> project provides precompiled binaries of these tools, which can be downloaded from <a href="http://gnuwin32.sourceforge.net">http://gnuwin32.sourceforge.net</a>.</p>
<p>Furthermore, in the Windows environment, orthodox file managers make file manipulation a lot easier. We definitely recommend giving the open-source Far Manager a try. You can download it from <a href="https://farmanager.com">https://farmanager.com</a>. It looks like this:</p>
<figure>
<img alt="Figure 1.5 – The look and feel of Far Manager" height="1291" src="../media/file5.png" width="2500"/><figcaption aria-hidden="true">Figure 1.5 – The look and feel of Far Manager</figcaption>
</figure>
</section>
</section>
</section>
<section class="level2" data-number="2.3" id="setting-up-our-development-environment-on-linux">
<h2 data-number="2.3">Setting up our development environment on Linux</h2>
<p>Linux is becoming more and more attractive for 3D graphics development, including gaming technology. Let’s go through a list of tools necessary to start working with this book on Linux.</p>
<section class="level3" data-number="2.3.1" id="getting-ready-1">
<h3 data-number="2.3.1">Getting ready</h3>
<p>We assume you have a desktop computer with a Debian-based GNU/Linux operating system installed. We also assume you are familiar with the <code>apt</code> package manager.</p>
<p>To start developing modern graphics programs on Linux, you need to have up-to-date video card drivers installed that support Vulkan 1.3. To build examples from this book, a C++ compiler with C++20 support is required. We tested our code with Clang and the GNU Compiler Collection.</p>
</section>
<section class="level3" data-number="2.3.2" id="how-to-do-it...-1">
<h3 data-number="2.3.2">How to do it...</h3>
<p>On a Debian-based system, the installation process is straightforward; however, before installing any of the required packages, we recommend running the following command to ensure your system is up to date:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo apt-get update</code></pre>
</div>
<p>Let us go through the list of essential software and install whatever is missing.</p>
<ol>
<li>GCC Compiler</li>
</ol>
<p>Assuming you have a properly configured <code>apt</code> <strong></strong> package manager, run the following command to install the GCC compiler and related tools. We tested GCC 12:</p>
<div class="C1-SHConPACKT">
<pre><code>sudo apt-get install build-essential</code></pre>
</div>
<ol>
<li>CMake</li>
</ol>
<p>The CMake build tool is also available in the standard repositories. To install CMake, type the following command:</p>
<div class="C1-SHConPACKT">
<pre><code>sudo apt-get install cmake</code></pre>
</div>
<blockquote>
<p>CMake 3.19 or above is sufficient for the code samples in this book.</p>
</blockquote>
<ol>
<li>Git</li>
</ol>
<p>To install the Git version control system, run the following command:</p>
<div class="C1-SHConPACKT">
<pre><code>sudo apt-get install git</code></pre>
</div>
<ol>
<li>Python 3</li>
</ol>
<p>To install the Python 3 package, run the following command:</p>
<div class="C1-SHConPACKT">
<pre><code>sudo apt-get install python3.7</code></pre>
</div>
<p>The exact version of Python may vary between Linux distributions. Any version of Python 3 will suffice for the scripts in this book.</p>
<p>Now we are done with the basic packages and can install graphics-related software. Let us move on to the next recipe to learn how to set up the Vulkan SDK.</p>
</section>
</section>
<section class="level2" data-number="2.4" id="installing-the-vulkan-sdk-for-windows-and-linux">
<h2 data-number="2.4">Installing the Vulkan SDK for Windows and Linux</h2>
<p>In this recipe, we will learn how to get started with the Vulkan SDK. We will describe the requirements and procedure for installing the LunarG Vulkan SDK for Windows and Linux.</p>
<p>In principle, it is possible to write Vulkan applications without the Vulkan SDK, using only C/C++ header files provided by Khronos. You can get these header files by cloning the Git repository: <a href="https://github.com/KhronosGroup/Vulkan-Headers">https://github.com/KhronosGroup/Vulkan-Headers</a>. However, it is advised to install the complete Vulkan SDK to be able to use Vulkan validation layers and a standalone GLSL compiler.</p>
<section class="level3" data-number="2.4.1" id="getting-ready-2">
<h3 data-number="2.4.1">Getting ready</h3>
<p>Make sure you have the latest up-to-date video card drivers for your operating system. On Windows, you can download video drivers from your GPU vendor’s website. For Ubuntu, refer to the documentation: <a href="https://ubuntu.com/server/docs/nvidia-drivers-installation">https://ubuntu.com/server/docs/nvidia-drivers-installation</a>.</p>
</section>
<section class="level3" data-number="2.4.2" id="how-to-do-it...-2">
<h3 data-number="2.4.2">How to do it...</h3>
<p>To install Vulkan 1.3 on Linux, follow these steps:</p>
<ol>
<li>Open the <a href="https://www.lunarg.com/vulkan-sdk/">https://www.lunarg.com/vulkan-sdk/</a> page in a browser and download the latest Vulkan SDK for Windows or Linux.</li>
<li>After the download has finished, run the Windows installer file and follow the on-screen instructions. If you have Ubuntu 22.04 installed, use the following commands provided on LunarG’s website:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>wget -qO- https://packages.lunarg.com/lunarg-signing-key-pub.asc | sudo tee /etc/apt/trusted.gpg.d/lunarg.asc
sudo wget -qO /etc/apt/sources.list.d/lunarg-vulkan-1.3.250-jammy.list https://packages.lunarg.com/vulkan/1.3.250/lunarg-vulkan-1.3.250-jammy.list
sudo apt update
sudo apt install vulkan-sdk</code></pre>
</div>
<ol>
<li>For other Linux distributions, you may need to download the <code>.tar.gz</code> SDK archive from <a href="https://vulkan.lunarg.com/sdk/home#linux">https://vulkan.lunarg.com/sdk/home#linux</a> and unpack it manually. You need to set environment variables to locate the Vulkan SDK components. Use the <code>source</code> command to run a config script that will do it for you:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>source ~/vulkan/1.3.250.1/setup-env.sh</code></pre>
</div>
</section>
<section class="level3" data-number="2.4.3" id="theres-more...-1">
<h3 data-number="2.4.3">There’s more...</h3>
<p>When developing cross-platform applications, it is good to use similar tools for each platform. Since Linux supports GCC and Clang compilers, using GCC or Clang on Windows ensures that you avoid the most common portability issues. A complete package of C and C++ compilers can be downloaded from <a href="http://www.equation.com/servlet/equation.cmd?fa=fortran">http://www.equation.com/servlet/equation.cmd?fa=fortran</a>.</p>
<p>An alternative way to use GCC on Windows is to install the MSYS2 environment from <a href="https://www.msys2.org">https://www.msys2.org</a>. It features the package management system used in Arch Linux, <strong>Pacman</strong>.</p>
</section>
</section>
<section class="level2" data-number="2.5" id="managing-dependencies">
<h2 data-number="2.5">Managing dependencies</h2>
<p>This book’s examples use multiple open-source libraries. To manage these dependencies, we use a free and open-source tool called <strong>Bootstrap</strong>. The tool is similar to Google’s repo tool and works on both Windows and Linux, as well as on macOS for that matter.</p>
<p>In this recipe, we will learn how to use Bootstrap to download libraries using the Vulkan Headers repository as an example.</p>
<section class="level3" data-number="2.5.1" id="getting-ready-3">
<h3 data-number="2.5.1">Getting ready</h3>
<p>Make sure you have Git and Python installed as described in the previous recipes. After that, clone the Bootstrap repository from GitHub:</p>
<div class="C0-SHConPACKT">
<pre><code>git clone https://github.com/corporateshark/bootstrapping</code></pre>
</div>
</section>
<section class="level3" data-number="2.5.2" id="how-to-do-it...-3">
<h3 data-number="2.5.2">How to do it...</h3>
<p>Let’s look into the source code bundle and run the <code>bootstrap.py</code> script:</p>
<div class="C0-SHConPACKT">
<pre><code>bootstrap.py</code></pre>
</div>
<p>The script will start downloading all the third-party libraries required to compile and run the source code bundle for this book. On Windows, the tail of the output should look as follows.</p>
<div class="C0-SHConPACKT">
<pre><code>Cloning into ‘M:\Projects.CPP\Book_Rendering\Sources\deps\src\assimp’...
remote: Enumerating objects: 25, done.
remote: Counting objects: 100% (25/25), done.
remote: Compressing objects: 100% (24/24), done.
remote: Total 51414 (delta 2), reused 10 (delta 1), pack-reused 51389
Receiving objects: 100% (51414/51414), 148.46 MiB | 3.95 MiB/s, done.
Resolving deltas: 100% (36665/36665), done.
Checking out files: 100% (2163/2163), done.</code></pre>
</div>
<p>Once the download process is complete, we are ready to build the project.</p>
</section>
<section class="level3" data-number="2.5.3" id="how-it-works...">
<h3 data-number="2.5.3">How it works...</h3>
<p><strong>Bootstrap</strong> takes a JSON file as input, opening <code>bootstrap.json</code> from the current directory by default. It contains metadata of libraries we want to download; for example, their names, where to retrieve them from, a specific version to download, and so on. Besides that, each used library can have some additional instructions on how to build it. Those can be patches applied to the original library, unpacking instructions, SHA hashes to check archive integrity, and many others.</p>
<p>The source code for each library can be represented by either a URL of a version control system repository or by an archive file with the library source files.</p>
<p>A typical JSON file entry corresponding to one library looks like this snippet:</p>
<div class="C1-SHCodePACKT">
<pre><code>[{
 “name”: “vulkan”,
 “source”: {
  “type”: “git”,
  “url”: “https://github.com/KhronosGroup/Vulkan-Headers.git”,
   “revision”: “v1.3.252”
 }
}]</code></pre>
</div>
<p>The field <code>type</code> can have one of these values: <code>archive</code>, <code>git</code>, <code>hg</code>, or <code>svn</code>. The first value corresponds to an archive file, such as <code>.zip</code>, <code>.tar.gz</code>, or <code>.tar.bz2</code>, while the last three types describe different version control system repositories. The <code>url</code> field contains a URL of the archive file to be downloaded or a URL of the repository. The <code>revision</code> field can specify a particular revision, tag, or branch to check out.</p>
<p>The complete JSON file is a comma-separated list of such entries. For this recipe, we have only one library to download. We will add more libraries in the next chapters. The accompanying source code bundle contains a JSON file with all the libraries used in this book.</p>
</section>
<section class="level3" data-number="2.5.4" id="theres-more...-2">
<h3 data-number="2.5.4">There’s more...</h3>
<p>There is comprehensive documentation for this tool that describes other command-line options and JSON fields in great detail. It can be downloaded from <a href="https://github.com/corporateshark/bootstrapping">https://github.com/corporateshark/bootstrapping</a>.</p>
<p>The Bootstrap tool does not differentiate between source code and binary assets. All the textures, 3D models, and other resources for your application can also be downloaded and kept up to date and organized in an automated way.</p>
</section>
</section>
<section class="level2" data-number="2.6" id="getting-the-demo-data">
<h2 data-number="2.6">Getting the demo data</h2>
<p>This book makes use of free 3D graphics datasets as much as possible. The comprehensive list of large 3D datasets is maintained by Morgan McGuire – Computer Graphics Archive, July 2017 (<a href="https://casual-effects.com/data">https://casual-effects.com/data</a>). We will use some large 3D models from his archive for demonstration purposes in this book. Let us download and patch one of them.</p>
<section class="level3" data-number="2.6.1" id="how-to-do-it">
<h3 data-number="2.6.1">How to do it…</h3>
<p>The bundled source code contains a Python script, <code>deploy_deps.py</code>, which will download all the required 3D models automatically. To download the entire Bistro dataset manually, follow these simple steps:</p>
<ol>
<li>Open the <a href="https://casual-effects.com/data/">https://casual-effects.com/data/</a> page in a browser and find the <strong>Amazon Lumberyard Bistro</strong> dataset.</li>
<li>Click on the <strong>Download</strong> link and allow the browser to download all the data files. Below is a screenshot of Morgan McGuire’s site with the download link.</li>
</ol>
<figure>
<img alt="Figure 1.6 – Amazon Lumberyard Bistro as pictured on casualeffects.com as a 2.4 GB download" height="589" src="../media/file6.png" width="1126"/><figcaption aria-hidden="true">Figure 1.6 – Amazon Lumberyard Bistro as pictured on casualeffects.com as a 2.4 GB download</figcaption>
</figure>
</section>
</section>
<section class="level2" data-number="2.7" id="create-utilities-for-cmake-projects">
<h2 data-number="2.7">Create utilities for CMake projects</h2>
<p>In this recipe, we will see how CMake is used to configure all the code examples in this book and learn some small tricks along the way.</p>
<blockquote>
<p>For those who are just starting with CMake, we recommend reading the books <em>CMake Cookbook</em> (Radovan Bast and Roberto Di Remigio) by Packt Publishing and <em>Mastering CMake</em> (Ken Martin and Bill Hoffman) by Kitware.</p>
</blockquote>
<section class="level3" data-number="2.7.1" id="getting-ready-4">
<h3 data-number="2.7.1">Getting ready</h3>
<p>For a start, let’s create a minimalistic C++ application with a trivial <code>main()</code> function and build it using CMake:</p>
<div class="C1-SHCodePACKT">
<pre><code>int main() {
  printf(“Hello World!\n”);
  return 0;
}</code></pre>
</div>
</section>
<section class="level3" data-number="2.7.2" id="how-to-do-it...-4">
<h3 data-number="2.7.2">How to do it...</h3>
<p>Let’s introduce two helper macros for CMake. You can find them in the <code>CMake/CommonMacros.txt</code> file of our source code bundle at <a href="https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook-Second-Edition">https://github.com/PacktPublishing/3D-Graphics-Rendering-Cookbook-Second-Edition</a>.</p>
<ol>
<li><p>The <code>SETUP_GROUPS</code> macro iterates over a space-delimited list of C and C++ files, whether it is a header or a source file, and assigns each of them to a separate group. The group name is constructed based on the path of each individual file. This way, we end up with a nice structure similar to a filesystem within a directory in the Visual Studio Solution Explorer window, as we can see on the right in the following figure.</p>
<figure>
<img alt="Figure 1.7 – Without groups (left) and with groups (right)" height="600" src="../media/file7.png" width="1200"/><figcaption aria-hidden="true">Figure 1.7 – Without groups (left) and with groups (right)</figcaption>
</figure></li>
<li>The macro starts by iterating over a list of files passed in the <code>src_files </code>parameter:</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>macro(SETUP_GROUPS src_files)
  foreach(FILE ${src_files})
    get_filename_component(PARENT_DIR “${FILE}” PATH)</code></pre>
</div>
<ol>
<li>We store the parent directory name as a default group name. For any OS, replace all the backslash characters with forward slashes:</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    set(GROUP “${PARENT_DIR}”)
    string(REPLACE “/” “\\” GROUP “${GROUP}”)</code></pre>
</div>
<ol>
<li>Then, we can tell CMake to assign the current file to a source group with this name.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    source_group(“${GROUP}” FILES “${FILE}”)
  endforeach()
endmacro()</code></pre>
</div>
<ol>
<li>The second macro, <code>SETUP_APP</code>, is used as a shortcut to create a new CMake project with all the standard properties we want it to have. It is very convenient when having to deal with a number of very similar subprojects, for example, like in this book.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>macro(SETUP_APP projname chapter)
  set(FOLDER_NAME ${chapter})
  set(PROJECT_NAME ${projname})
  project(${PROJECT_NAME} CXX)</code></pre>
</div>
<ol>
<li>After setting the project name, this macro uses the <code>GLOB_RECURSE</code> function to collect all source and header files into the <code>SRC_FILES</code> and <code>HEADER_FILES</code> variables.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  file(GLOB_RECURSE SRC_FILES LIST_DIRECTORIES false
       RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} src/*.c??)
  file(GLOB_RECURSE HEADER_FILES LIST_DIRECTORIES false
       RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} src/*.h)</code></pre>
</div>
<ol>
<li>In all our code samples, we use the directory <code>src</code> containing the source files as an <code>include</code> directory, too.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  include_directories(src)</code></pre>
</div>
<ol>
<li>All enumerated source and header files are added to an executable inside the current project.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  add_executable(${PROJ_NAME} ${SRC_FILES} ${HEADER_FILES})</code></pre>
</div>
<ol>
<li>We use the <code>SETUP_GROUP</code> macro from <em>Step 1</em> to place each source and header file into an appropriate group inside the project.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  SETUP_GROUPS(“${SRC_FILES}”)
  SETUP_GROUPS(“${HEADER_FILES}”)</code></pre>
</div>
<ol>
<li>The next three properties set different executable file names for each supported build configuration. These lines are optional, yet they are really useful when using CMake with the Visual Studio IDE. The reason is that Visual Studio can change build configurations (or “build types”, as they are called in CMake) dynamically directly from the IDE, and each build configuration can have its own output file name. We add suffixes to these file names so that they can co-exist in a single output folder.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  set_target_properties(${PROJ_NAME}
    PROPERTIES OUTPUT_NAME_DEBUG ${PROJ_NAME}_Debug)
  set_target_properties(${PROJ_NAME}
    PROPERTIES OUTPUT_NAME_RELEASE ${PROJ_NAME}_Release)
  set_target_properties(${PROJ_NAME}
    PROPERTIES OUTPUT_NAME_RELWITHDEBINFO ${PROJ_NAME}_ReleaseDebInfo)</code></pre>
</div>
<ol>
<li>Since we use C++20 throughout this book, we require CMake to enable it.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  set_property(
    TARGET ${PROJ_NAME} PROPERTY CXX_STANDARD 20)
  set_property(
    TARGET ${PROJ_NAME} PROPERTY CXX_STANDARD_REQUIRED ON)</code></pre>
</div>
<ol>
<li>To ease the debugging with Visual Studio, we enable console output by changing the application type to <code>Console</code>. We also set the local debugger working directory to <code>CMAKE_SOURCE_DIR</code>, which will make finding assets a lot more straightforward and consistent. There are some Apple-specific properties to allow building the source code on Mac machines.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  if(MSVC)
    add_definitions(-D_CONSOLE)
    set_property(TARGET ${PROJ_NAME} PROPERTY
      VS_DEBUGGER_WORKING_DIRECTORY “${CMAKE_SOURCE_DIR}”)
  endif()
  if(APPLE)
    set_target_properties(${PROJECT_NAME} PROPERTIES
      XCODE_GENERATE_SCHEME TRUE
      XCODE_SCHEME_WORKING_DIRECTORY “${CMAKE_SOURCE_DIR}”)
  endif()
endmacro()</code></pre>
</div>
<ol>
<li>Finally, the top-level <code>CMakeLists.txt</code> file of our first project will look like this:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>cmake_minimum_required(VERSION 3.16)
project(Chapter01)
include(../../CMake/CommonMacros.txt)
SETUP_APP(Ch01_Sample01_CMake “Chapter 01”)</code></pre>
</div>
<blockquote>
<p>You may notice that the line <code>project(Chapter01)</code> above is overridden by a call to <code>project()</code> inside the <code>SETUP_APP</code> macro. This is due to the following CMake warning, which will be emitted if we do not declare a new project right from the get-go.</p>
</blockquote>
<pre><code>CMake Warning (dev) in CMakeLists.txt:
No project() command is present. The top-level CMakeLists.txt file must contain a literal, direct call to the project() command. Add a line of project(ProjectName) near the top of the file, but after cmake_minimum_required().</code></pre>
<ol>
<li>To build and test the executable, create the <code>build</code> subfolder, change the working directory to <code>build</code>, and run CMake as follows:
<ol>
<li>For Windows and Visual Studio 2022, run the following command to configure our project for the 64-bit target platform architecture.</li>
</ol></li>
</ol>
<div class="C2-SHConPACKT">
<pre><code>cmake .. -G “Visual Studio 17 2022” -A x64</code></pre>
</div>
<ol>
<li>For Linux, we can use the <code>Unix Makefiles</code> CMake generator as follows.</li>
</ol>
<div class="C2-SHConPACKT">
<pre><code>cmake .. -G “Unix Makefiles”</code></pre>
</div>
<ol>
<li>To build an executable for the <code>release</code> build type, you can use the following command on any platform. To build a debug version, use <code>--config Debug</code> or skip that parameter entirely.</li>
</ol>
<div class="C2-SHConPACKT">
<pre><code>cmake --build . --config Release</code></pre>
</div>
<p>All the demo applications from the source code bundle should be run from the folder where the <code>data/</code> subfolder is located.</p>
</section>
<section class="level3" data-number="2.7.3" id="theres-more...-3">
<h3 data-number="2.7.3">There’s more...</h3>
<p>Alternatively, you can use the cross-platform build system Ninja along with CMake. It is possible to do so simply by changing the CMake project generator name.</p>
<div class="C0-SHConPACKT">
<pre><code>cmake .. -G “Ninja”</code></pre>
</div>
<p>Invoke Ninja from the command line to compile the project.</p>
<div class="C0-SHConPACKT">
<pre><code>ninja
[2/2] Linking CXX executable Ch01_Sample01_CMake.exe</code></pre>
</div>
<p>Notice how fast everything gets built now, compared to the classic <code>cmake --build</code> command. See <a href="https://ninja-build.org">https://ninja-build.org</a> for more details.</p>
<p>Now let’s take a look at how to work with some basic open source libraries.</p>
</section>
</section>
<section class="level2" data-number="2.8" id="using-the-glfw-library">
<h2 data-number="2.8">Using the GLFW library</h2>
<p>The GLFW library hides all the complexity of creating windows, graphics contexts, and surfaces and getting input events from the operating system. In this recipe, we build a minimalistic application with GLFW and Vulkan to get some basic 3D graphics onto the screen.</p>
<section class="level3" data-number="2.8.1" id="getting-ready-5">
<h3 data-number="2.8.1">Getting ready</h3>
<p>We build our examples with GLFW 3.4. Here is a JSON snippet for the Bootstrap script so that you can download the proper library version:</p>
<div class="C1-SHCodePACKT">
<pre><code>{
     “name”: “glfw”,
     “source”: {
           “type”: “git”,
           “url”: “https://github.com/glfw/glfw.git”,
           “revision”: “3.4”
     }
}</code></pre>
</div>
<p>The complete source code for this recipe can be found in the source code bundle under the name of <code>Chapter01/02_GLFW</code>.</p>
</section>
<section class="level3" data-number="2.8.2" id="how-to-do-it...-5">
<h3 data-number="2.8.2">How to do it...</h3>
<p>Let’s write a minimalistic application that creates a window and waits for an <code>exit</code> command from the user – pressing the <span class="KeystrokePACKT">Esc</span> key. This functionality will be used in all of our subsequent demos, so we have wrapped it into a helper function <code>initWindow()</code> declared in <code>shared/HelpersGLFW.h</code>. Let’s take a look at how to use it to create an empty GLFW window:</p>
<ol>
<li>Include all necessary headers and decide on the initial window dimensions:</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>#include &lt;shared/HelpersGLFW.h&gt;
int main(void) {
  uint32_t width = 1280;
  uint32_t height = 800;</code></pre>
</div>
<ol>
<li>Invoke the <code>initWindow()</code> function to create a window. The <code>width</code> and <code>height</code> parameters are passed by reference and, after the call, will contain the actual working area of the created window. If we pass the initial values of <code>0</code>, the window will be created to span the entire desktop working area without an overlapping taskbar.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>GLFWwindow* window =
  initWindow(“GLFW example”, width, height);</code></pre>
</div>
<ol>
<li>For this application, the main loop and cleanup are trivial:</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  while (!glfwWindowShouldClose(window)) {
    glfwPollEvents();
  }
  glfwDestroyWindow(window);
  glfwTerminate();
  return 0;
}</code></pre>
</div>
<p>Now we will take a look at the internals of <code>initWindow()</code> for some interesting details.</p>
</section>
<section class="level3" data-number="2.8.3" id="how-it-works...-1">
<h3 data-number="2.8.3">How it works...</h3>
<p>Let’s use this library to create an application that opens an empty window:</p>
<ol>
<li>First, we set the GLFW error callback via a lambda to catch potential errors and then initialize GLFW:</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>GLFWwindow* initWindow(const char* windowTitle,
  uint32_t&amp; outWidth, uint32_t&amp; outHeight) {
  glfwSetErrorCallback([](int error,
                          const char* description) {
    printf(“GLFW Error (%i): %s\n”, error, description);
  });
  if (!glfwInit())return nullptr;</code></pre>
</div>
<ol>
<li>Let’s decide if we want to make a desktop full-screen window. Set the resizable flag for windows that aren’t full-screen and retrieve the desired window dimensions. We are going to initialize Vulkan manually, so no graphics API initialization is required to be done by GLFW. The flag <code>wantsWholeArea</code> determines if we want a true full-screen window or a window that does not overlap the system taskbar.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  const bool wantsWholeArea = !outWidth || !outHeight;
  glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
  glfwWindowHint(GLFW_RESIZABLE,
    wantsWholeArea ? GLFW_FALSE : GLFW_TRUE);
  GLFWmonitor* monitor    = glfwGetPrimaryMonitor();
  const GLFWvidmode* mode = glfwGetVideoMode(monitor);
  int x = 0;
  int y = 0;
  int w = mode-&gt;width;
  int h = mode-&gt;height;
  if (wantsWholeArea) {
    glfwGetMonitorWorkarea(monitor, &amp;x, &amp;y, &amp;w, &amp;h);
  } else {
    w = outWidth;
    h = outHeight;
  }</code></pre>
</div>
<ol>
<li>Create a window and retrieve the actual window dimensions:</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  GLFWwindow* window = glfwCreateWindow(
    w, h, windowTitle, nullptr, nullptr);
  if (!window) {
    glfwTerminate();
    return nullptr;
  }
  if (wantsWholeArea) glfwSetWindowPos(window, x, y);
  glfwGetWindowSize(window, &amp;w, &amp;h);
  outWidth  = (uint32_t)w;
  outHeight = (uint32_t)h;</code></pre>
</div>
<ol>
<li>Set a default keyboard callback to handle the <span class="KeystrokePACKT">Esc</span> key. A simple lambda will do this job for us.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  glfwSetKeyCallback(window, [](GLFWwindow* window,
    int key, int, int action, int) {
    if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS) {
      glfwSetWindowShouldClose(window, GLFW_TRUE);
    }
  });
  return window;
}</code></pre>
</div>
<p>If you run this tiny application, it will create an empty window, as in the following screenshot:</p>
<figure>
<img alt="Figure 1.8 – Our first application" height="473" src="../media/file8.png" width="958"/><figcaption aria-hidden="true">Figure 1.8 – Our first application</figcaption>
</figure>
</section>
<section class="level3" data-number="2.8.4" id="theres-more...-4">
<h3 data-number="2.8.4">There’s more...</h3>
<p>Further details about how to use GLFW can be found at <a href="https://www.glfw.org/documentation.xhtml">https://www.glfw.org/documentation.xhtml</a>.</p>
</section>
</section>
<section class="level2" data-number="2.9" id="multithreading-with-taskflow">
<h2 data-number="2.9">Multithreading with Taskflow</h2>
<p>Modern graphical applications require us to harness the power of multiple CPUs to be performant. <strong>Taskflow</strong> is a fast C++ header-only library that can help you write parallel programs with complex task dependencies quickly. This library is extremely useful as it allows you to jump into the development of multithreaded graphical applications that make use of advanced rendering concepts, such as frame graphs and multithreaded command buffer generation.</p>
<section class="level3" data-number="2.9.1" id="getting-ready-6">
<h3 data-number="2.9.1">Getting ready</h3>
<p>Here, we use Taskflow version 3.7.0. You can download it using the following Bootstrap snippet:</p>
<div class="C1-SHCodePACKT">
<pre><code>{
     “name”: “taskflow”,
     “source”: {
           “type”: “git”,
           “url”:
             “https://github.com/taskflow/taskflow.git”,
           “revision”: “v3.7.0”
     }
}</code></pre>
</div>
<p>To debug dependency graphs produced by Taskflow, it is recommended that you install the <strong>GraphViz</strong> tool from <a href="https://www.graphviz.org">https://www.graphviz.org</a>.</p>
<p>The complete source code for this recipe can be found in <code>Chapter01/03_Taskflow</code>.</p>
</section>
<section class="level3" data-number="2.9.2" id="how-to-do-it...-6">
<h3 data-number="2.9.2">How to do it...</h3>
<p>Let’s create and run a set of concurrent dependent tasks via the <code>for_each_index()</code> algorithm. Each task will print a single value from an array in a concurrent fashion. The processing order can vary between different runs of the program:</p>
<ol>
<li>Include the <code>taskflow.hpp</code> header file. The <code>tf::Taskflow</code> class is the main place to create a task dependency graph. Declare an instance and a data vector to process.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>#include &lt;taskflow/taskflow.hpp&gt;
int main() {
  tf::Taskflow taskflow;
  std::vector&lt;int&gt; items{ 1, 2, 3, 4, 5, 6, 7, 8 };</code></pre>
</div>
<ol>
<li>The <code>for_each_index() </code>member function returns a task that implements a parallel for loop algorithm. We specify the range <code>0..items.size() </code>and the step <code>1</code>. The returned<code> task </code>can be used for synchronization purposes:</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  auto task = taskflow.for_each_index(
    0u, static_cast&lt;uint32_t&gt;(items.size()), 1u, [&amp;](int i) {
      printf(“%i”, items[i]); }).name(“for_each_index”);</code></pre>
</div>
<ol>
<li>Let’s attach some work before and after the parallel for task so that we can view <code>Start</code> and <code>End</code> messages in the output. Let’s call the new <code>S</code> and <code>T</code> tasks accordingly:</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  taskflow.emplace([]() {
    printf(“\nS - Start\n”); }).name(“S”).precede(task);
  taskflow.emplace([]() {
    printf(“\nT - End\n”); }).name(“T”).succeed(task);</code></pre>
</div>
<ol>
<li>Save the generated tasks dependency graph in <code>.dot </code>format so that we can process it later with the GraphViz <code>dot</code> tool:</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  std::ofstream os(“.cache/taskflow.dot”);
  taskflow.dump(os);</code></pre>
</div>
<ol>
<li>Now we can create a <code>tf::executor </code>object and run the constructed Taskflow graph:</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  tf::Executor executor;
  executor.run(taskflow).wait();
  return 0;
}</code></pre>
</div>
<p>One important part to mention here is that the dependency graph can only be constructed once. Then, it can be reused in every frame to run concurrent tasks efficiently.</p>
<p>The output from the preceding program should look similar to the following listing:</p>
<div class="C0-SHConPACKT">
<pre><code>S – Start
18345672
T - End</code></pre>
</div>
<p>Here, we can see our <code>S</code> and <code>T</code> tasks. Between them, there are multiple threads with different IDs processing different elements of the <code>items[]</code> vector in parallel. Your output may vary due to concurrency.</p>
</section>
<section class="level3" data-number="2.9.3" id="theres-more...-5">
<h3 data-number="2.9.3">There’s more...</h3>
<p>The application saved the dependency graph inside the <code>taskflow.dot</code> file. It can be converted into a visual representation by GraphViz, <a href="https://graphviz.org">https://graphviz.org</a>, using the following command:</p>
<div class="C0-SHConPACKT">
<pre><code>dot -Tpng taskflow.dot &gt; output.png</code></pre>
</div>
<p>The resulting <code>.png</code> image should look similar to the following screenshot:</p>
<figure>
<img alt="Figure 1.9 – The Taskflow dependency graph for for_each_index()" height="325" src="../media/file9.png" width="297"/><figcaption aria-hidden="true">Figure 1.9 – The Taskflow dependency graph for for_each_index()</figcaption>
</figure>
<p>This functionality is extremely useful when you are debugging complex dependency graphs (and producing complex-looking images for your books and papers).</p>
<p>The Taskflow library functionality is vast and provides implementations for numerous parallel algorithms and profiling capabilities. Please refer to the official documentation for in-depth coverage at <a href="https://taskflow.github.io/taskflow/index.xhtml">https://taskflow.github.io/taskflow/index.xhtml</a>.</p>
<p>Let’s move on to the next chapter and learn how to start working with Vulkan.</p>
</section>
</section>
</section>
</div></body>
</html>