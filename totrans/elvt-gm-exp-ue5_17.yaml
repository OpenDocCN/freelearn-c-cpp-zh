- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Remote Procedure Calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered some critical multiplayer concepts, including
    the server-client architecture, connections and ownership, roles, and variable
    replication. We also learned how to make 2D Blend Spaces and use the `Transform
    (Modify) Bone` node to modify bones at runtime. We used that knowledge to create
    a basic first-person shooter character that walks, jumps, and looks around.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’re going to cover **remote procedure calls** (**RPCs**),
    which is another important multiplayer concept that allows the server to execute
    functions on the clients and vice versa. So far, we’ve learned about variable
    replication as a form of communication between the server and the clients. However,
    to have proper communication, this isn’t enough. This is because the server may
    need to execute specific logic on the clients that doesn’t involve updating the
    value of a variable. The client also needs a way to tell its intentions to the
    server so that the server can validate the action and let the other clients know
    about it. This will ensure that the multiplayer world is synchronized between
    all of the connected clients. We’ll also cover how to use enumerations and expose
    them to the editor, as well as array index wrapping, which allows you to iterate
    an array in both directions and loop around when you go beyond its limits.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding remote procedure calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing enumerations to the editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using array index wrapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll understand how RPCs work to make the server
    and the clients execute logic on one another. You’ll also be able to expose enumerations
    to the editor and use array index wrapping to cycle through arrays in both directions.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following technical requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Unreal Engine 5 installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio 2019 installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The project for this chapter can be found in the `Chapter17` folder of the
    code bundle for this book, which can be downloaded here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at RPCs.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding remote procedure calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We covered variable replication in [*Chapter 16*](B18531_16.xhtml#_idTextAnchor345),
    *Getting Started with Multiplayer Basics*, and, while a very useful feature, it
    is a bit limited in terms of allowing custom code to be executed in remote game
    instances (client-to-server or server-to-client) for two main reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The first reason is that variable replication is strictly a form of server-to-client
    communication, so there isn’t a way for a client to use variable replication to
    tell the server to execute some custom logic by changing the value of a variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second reason is that variable replication, as the name suggests, is driven
    by the values of variables, so even if variable replication allowed client-to-server
    communication, it would require you to change the value of a variable on the client
    to trigger a `RepNotify` function on the server to run the custom logic, which
    is not very practical.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To solve this problem, Unreal Engine supports RPCs, which work just like normal
    functions that can be defined and called. However, instead of executing them locally,
    they will be executed on a remote game instance, without being tied to a variable.
    To be able to use RPCs, make sure you are defining them in an actor that has a
    valid connection and replication turned on.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of RPCs, and each one serves a different purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: Server RPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multicast RPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client RPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at these three types in detail and explain when to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Server RPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You use a Server RPC every time you want the server to run a function on the
    actor that has defined the RPC. There are two main reasons why you would want
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: The first reason is security. When making multiplayer games, especially competitive
    ones, you always have to assume that the client will try to cheat. The way to
    make sure there is no cheating is by forcing the client to go through the server
    to execute the functions that are critical to gameplay.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second reason is synchronicity. Since the critical gameplay logic is only
    executed on the server, the important variables are only going to be changed there,
    which will automatically trigger the variable replication logic to update the
    clients whenever they are changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of this would be when a client’s character tries to fire a weapon.
    Since there’s always the possibility that the client may try to cheat, you can’t
    just execute the fire weapon logic locally. The correct way of doing this is by
    having the client call a Server RPC that tells the server to validate the `Fire`
    action by making sure the character has enough ammo, has the weapon equipped,
    and so on. If everything checks out, then it will deduct the ammo variable, and
    finally, it will execute a Multicast RPC (covered shortly) that will tell all
    of the clients to play the fire animation on that character.
  prefs: []
  type: TYPE_NORMAL
- en: Declaration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To declare a Server RPC, you can use the `Server` specifier on the `UFUNCTION`
    macro. Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the `Server` specifier is used on the `UFUNCTION`
    macro to state that the function is a Server RPC. You can have parameters on a
    Server RPC just like a normal function, but with some caveats that will be explained
    later in this topic, as well as the purpose of the `Reliable` and `WithValidation`
    specifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To execute a Server RPC, you call it from a client on the actor instance that
    defined it. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet implements the `CallMyOwnServerRPC` function, which
    calls the `ServerMyOwnRPC` RPC function, defined in its own `ARPCTest` class,
    with an integer parameter. This will execute the implementation of the `ServerMyOwnRPC`
    function on the server version of that actor’s instance. We can also call a Server
    RPC from another actor’s instance, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet implements the `CallServerRPCOfAnotherActor` function,
    which calls the `ServerAnotherActorRPC` RPC function, defined in `AAnotherActor`,
    on the `OtherActor` instance, so long as it’s valid. This will execute the implementation
    of the `ServerAnotherActorRPC` function on the server version of the `OtherActor`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Multicast RPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You use a Multicast RPC when you want the server to instruct all of the clients
    to run a function on the actor that has defined the RPC.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this is when a client’s character tries to fire a weapon. After
    the client calls the Server RPC to ask permission to fire the weapon and the server
    has validated the request (the ammo has been deducted and the line trace/projectile
    was processed), we need to do a Multicast RPC so that all of the instances of
    that specific character play the fire animation.
  prefs: []
  type: TYPE_NORMAL
- en: Declaration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To declare a Multicast RPC, you need to use the `NetMulticast` specifier on
    the `UFUNCTION` macro. Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the `NetMulticast` specifier is used on the `UFUNCTION`
    macro to say that the function is a Multicast RPC. You can have parameters on
    a Multicast RPC just like a normal function, but with the same caveats as the
    Server RPC. The `Unreliable` specifier will be explained later in this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To execute a Multicast RPC, you must call it from the server on the actor instance
    that defined it. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet implements the `CallMyOwnMulticastRPC` function,
    which calls the `MulticastMyOwnRPC` RPC function, defined in its own `ARPCTest`
    class, with an integer parameter. This will execute the implementation of the
    `MulticastMyOwnRPC` function on all of the clients’ versions of that actor’s instance.
    We can also call a Multicast RPC from another actor’s instance, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet implements the `CallMulticastRPCOfAnotherActor` function,
    which calls the `MulticastAnotherActorRPC` RPC function, defined in `AAnotherActor`,
    on the `OtherActor` instance, so long as it’s valid. This will execute the implementation
    of the `MulticastAnotherActorRPC` function on all of the clients’ versions of
    the `OtherActor` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Client RPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You use a Client RPC when you want the server to instruct only the owning client
    to run a function on the actor that has defined the RPC. To set the owning client,
    you need to call `SetOwner` on the server and set it with the client’s player
    controller.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this would be when a character is hit by a projectile and plays
    a pain sound that only that client will hear. By calling a Client RPC from the
    server, the sound will only be played on the owning client and not on the other
    clients.
  prefs: []
  type: TYPE_NORMAL
- en: Declaration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To declare a Client RPC, you need to use the `Client` specifier on the `UFUNCTION`
    macro. Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the `Client` specifier is being used on the `UFUNCTION`
    macro to say that the function is a Client RPC. You can have parameters on a Client
    RPC just like a normal function, but with the same caveats as the Server RPC and
    the Multicast RPC. The `Unreliable` specifier will be explained later in this
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: Execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To execute a Client RPC, you must call it from the server on the actor instance
    that defined it. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet implements the `CallMyOwnClientRPC` function, which
    calls the `ClientMyOwnRPC` RPC function, defined in its own `ARPCTest` class,
    with an integer parameter. This will execute the implementation of the `ClientMyOwnRPC`
    function on the owning client’s version of that actor’s instance. We can also
    call a Client RPC from another actor’s instance, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet implements the `CallClientRPCOfAnotherActor` function,
    which calls the `ClientAnotherActorRPC` RPC function, defined in `AAnotherActor`,
    on the `OtherActor` instance, so long as it’s valid. This will execute the implementation
    of the `ClientAnotherActorRPC` function on the owning client’s version of the
    `OtherActor` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Important considerations when using RPCs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RPCs are very useful, but there are a couple of things that you need to take
    into consideration when using them.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The implementation of an RPC differs slightly from that of a typical function.
    Instead of implementing the function as you normally do, you should only implement
    the `_Implementation` version of it, even though you didn’t declare it in the
    header file. Have a look at the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: '**Server RPC**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we implemented the `_Implementation` version
    of the `ServerRPCTest` function, which uses three parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Multicast RPC**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we implemented the `_Implementation` version
    of the `MulticastRPCTest` function, which uses three parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Client RPC**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we implemented the `_Implementation` version
    of the `ClientRPCTest` function, which uses three parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the previous examples, independent of the type of the RPC
    you are implementing, you should only implement the `_Implementation` version
    of the function and not the normal one, as demonstrated in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we’re defining the normal implementation of `ServerRPCFunction`.
    If you implement the RPC like this, you’ll get an error saying that it was already
    implemented. The reason for this is that when you declare the RPC function in
    the header file, Unreal Engine will automatically create the normal implementation
    internally, which once called, will execute the logic to send the RPC request
    through the network and when it reaches the remote computer it will call the `_Implementation`
    version there. Since you cannot have two implementations of the same function,
    it will throw a compilation error. To fix this, just make sure that you only implement
    the `_Implementation` version of the RPC.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at name prefixes.
  prefs: []
  type: TYPE_NORMAL
- en: Name prefixes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Unreal Engine, it’s good practice to prefix RPCs with their corresponding
    types. Have a look at the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: A `RPCFunction` should be named `ServerRPCFunction`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `RPCFunction` should be named `MulticastRPCFunction`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `RPCFunction` should be named `ClientRPCFunction`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the execution of RPCs is typically executed on different machines asynchronously,
    you can’t have a return value, so it always needs to be void.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can override the implementation of an RPC to expand or bypass the parent’s
    functionality by declaring and implementing the `_Implementation` function in
    the child class without the `UFUNCTION` macro. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the declaration of the parent class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we have the declaration of the `ServerRPCTest`
    function in the parent class, which uses one integer parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to override the function on the child class, we would need to use
    the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we have overridden the declaration of the `ServerRPCTest_Implementation`
    function in the child class header file. The implementation of the function is
    just like any other override, with the possibility of calling `Super::ServerRPCTest_Implementation`
    if you still want to execute the parent functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Valid connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For an actor to be able to execute its RPCs, they need to have a valid connection.
    If you try to call an RPC on an actor that doesn’t have a valid connection, then
    nothing will happen on the remote instance. You must make sure that the actor
    is either a player controller, is being possessed by one (if applicable), or that
    its owning actor has a valid connection.
  prefs: []
  type: TYPE_NORMAL
- en: Supported parameter types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using RPCs, you can add parameters just like any other function. At the
    time of writing, most common types are supported (such as `bool`, `int32`, `float`,
    `FText`, `FString`, `FName`, `TArray`, and so on), but not all of them, such as
    `TSet` and `TMap`. Among the types that are supported, the ones that you have
    to pay more attention to are the pointers to any `UObject` class or subclass,
    especially actors.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you create an RPC with an actor parameter, then that actor also needs to
    exist on the remote game instance; otherwise, it will have a value of `nullptr`.
    Another important thing to take into account is that the instance name of each
    version of the actor can be different. This means that if you call an RPC with
    an actor parameter, then the instance name of the actor when calling the RPC might
    be different than the one when executing the RPC on the remote instance. Here
    is an example to help you understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1 – Displaying the name of the character instances in three clients
    ](img/Figure_17.01_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.1 – Displaying the name of the character instances in three clients
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, you can see three clients running (one of them is
    a listen server) and each window is displaying the name of all of the character
    instances. If you look at the `BP_ThirdPersonCharacter_C_0`, but on the `BP_ThirdPersonCharacter_C_1`.
    This means that if `BP_ThirdPersonCharacter_C_0` as an argument, then when the
    RPC is executed on the server, the parameter will be `BP_ThirdPersonCharacter_C_1`,
    which is the instance name of the equivalent character in that game instance.
  prefs: []
  type: TYPE_NORMAL
- en: Executing RPCs on the target machine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can call RPCs directly on their target machine and they will still execute.
    In other words, you can call a Server RPC on the server and it will execute, as
    well as a Multicast/Client RPC on the client, but in the latter case, it will
    only execute the logic on the client that called the RPC. Either way, in these
    cases, you can call the `_Implementation` version directly instead, to execute
    the logic faster.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is that the `_Implementation` version just holds the logic
    to execute and doesn’t have the overhead of creating and sending the RPC request
    through the network that the regular call has.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following example of an actor that has authority on the
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, you have the `CallServerRPC` function, which calls
    `ServerRPCFunction` in two different ways. If the actor is already on the server,
    then it calls `ServerRPCFunction_Implementation`, which will skip the overhead,
    as mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: If the actor is not on the server, then it executes the regular call by using
    `ServerRPCFunction`, which adds the required overhead for creating and sending
    the RPC request through the network.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you define an RPC, you have the option of using an additional function
    to check whether there are any invalid inputs before the RPC is called. This is
    used to avoid processing the RPC if the inputs are invalid due to cheating or
    for some other reason.
  prefs: []
  type: TYPE_NORMAL
- en: To use validation, you need to add the `WithValidation` specifier to the `UFUNCTION`
    macro. When you use that specifier, you will be forced to implement the `_Validate`
    version of the function, which will return a Boolean stating whether the RPC can
    be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we’ve declared a validated Server RPC called
    `ServerSetHealth`, which takes a float parameter for the new value of `Health`.
    Take a look at its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we implemented the `_Validate` function, which
    will check whether the new health is within 0 and the maximum value of the health.
    If a client tries to hack and call `ServerSetHealth` with `200` and `MaxHealth`
    is `100`, then the RPC won’t be called, which prevents the client from changing
    the health with values outside a certain range. If the `_Validate` function returns
    `true`, the `_Implementation` function is called as usual, which sets `Health`
    with the value of `NewHealth`.
  prefs: []
  type: TYPE_NORMAL
- en: Reliability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you declare an RPC, you are required to either use the `Reliable` or `Unreliable`
    specifier in the `UFUNCTION` macro. Here’s a quick overview of what they do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Reliable`: This is used when you want to make sure the RPC is executed, by
    repeating the request until the remote machine confirms its reception. This should
    only be used for RPCs that are very important, such as executing critical gameplay
    logic. Here is an example of how to use it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Unreliable`: This is used when you don’t care whether the RPC is executed
    due to bad network conditions, such as playing a sound or spawning a particle
    effect. This should only be used for RPCs that aren’t very important or are called
    very frequently to update values since it wouldn’t matter if a couple didn’t get
    through. Here is an example of how to use it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on RPCs, please visit [https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/RPCs/index.xhtml](https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/RPCs/index.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercise, you will learn how to implement the different types
    of RPCs.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 17.01 – Using remote procedure calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’re going to create a **C++** project that uses the **Third
    Person** template and we’re going to expand it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new `Ammo` integer variable that defaults to `5` and replicates to all
    of the clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a fire animation that plays a fire sound and also create a **Fire Anim Montage**
    that is played when the server tells the client that the request to fire was valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a **No Ammo Sound** that will play when the server tells the client that
    they didn’t have sufficient ammo.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time the player presses the left mouse button, the client will perform
    a reliable and validated Server RPC that will check whether the character has
    sufficient ammo. If it does, it will subtract `1` from the `Ammo` variable and
    call an unreliable Multicast RPC that plays the fire animation in every client.
    If it doesn’t have ammo, then it will execute an unreliable Client RPC that will
    play `No Ammo Sound` that will only be heard by the owning client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedule a timer that will prevent the client from spamming the fire button
    for `1.5s` after playing the fire animation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `RPC` and save it to a location of your liking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the project has been created, it should open the editor as well as the
    Visual Studio solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the editor and go back to Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `RPCCharacter.h` and declare the protected `FireTimer` variable, which
    will be used to prevent the client from spamming the `Fire` action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the protected replicated `Ammo` variable, which starts with `5` shots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, declare the protected animation montage variable that will be played
    when the character fires:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the protected sound variable that will be played when the character
    has no ammo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `Tick` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the reliable and validated Server RPC for firing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the unreliable Multicast RPC that will play the fire animation on all
    of the clients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the unreliable Client RPC that will play a sound only in the owning
    client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open the `RPCCharacter.cpp` file and include `GameplayStatics.h` for the
    PlaySound2D function and the UnrealNetwork.h so we can use the `DOREPLIFETIME_CONDITION`
    macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the constructor, enable the `Tick` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `GetLifetimeReplicatedProps` function so that the `Ammo` variable
    will replicate to all of the clients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, implement the `Tick` function, which displays the value of the `Ammo`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the `SetupPlayerInputController` function, bind the `Fire` action
    to the `ServerFire` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the fire Server RPC validation function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the fire Server RPC implementation function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the logic to abort the function if the fire timer is still active
    since we fired the last shot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the character has ammo. If it doesn’t, then play `NoAmmoSound`
    only in the client that controls the character and abort the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Deduct the ammo and schedule the `FireTimer` variable to prevent this function
    from being spammed while playing the fire animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the fire Multicast RPC to make all the clients play the fire animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the fire Multicast RPC, which will play the fire animation montage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the Client RPC that plays a 2D sound:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, you can launch the project in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Compile the code and wait for the editor to fully load.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to **Project Settings**, go to **Engine**, then **Input**, and add the **Fire**
    action binding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.2 – Adding the new Fire action binding ](img/Figure_17.02_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.2 – Adding the new Fire action binding
  prefs: []
  type: TYPE_NORMAL
- en: Close **Project Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Content` folder, create a new folder called `Audio`, and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `Exercise17.01\Assets` folder, and import `NoA``mmo.wav` and `Fire.wav`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save both files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `Content\Characters\Mannequins\Animations` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `Exercise17.01\Assets` folder, and import the `ThirdPersonFire.fbx`
    file. Make sure it’s using the `SK_Mannequin` skeleton and click **Import**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the new animation and put a `Play Sound` anim notify at `0.3` seconds using
    the `Fire` sound.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Details** panel, find the **Enable Root Motion** option and set it
    to **true**. This will prevent the character from moving when playing the animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `ThirdPersonFire`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* on `ThirdPersonFire` and pick **Create** | **Create AnimMontage**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Animations` folder should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.3 – The Animations folder for the Mannequin ](img/Figure_17.03_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.3 – The Animations folder for the Mannequin
  prefs: []
  type: TYPE_NORMAL
- en: Open `ABP_Manny` and go to `AnimGraph`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the `Control Rig` node and set `Alpha` to `0.0` to disable the automatic
    feet adjustment. You should get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.4 – Disabling the feet adjustment ](img/Figure_17.04_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.4 – Disabling the feet adjustment
  prefs: []
  type: TYPE_NORMAL
- en: Save and close `ABP_Manny`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `SK_Mannequin` in the `Content\Characters\Mannequins\Meshes` folder and
    retarget (as shown in *Exercise 16.04*) the `root` and `pelvis` bones so that
    they use `Animation`. The remaining bones should use `Skeleton`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `SK_Mannequin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `Content\ThirdPerson\Blueprints` and open the `BP_T``hirdPersonCharacter`
    blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Class Defaults`, set `No Ammo Sound` to use `NoAmmo`, and set `Fire Anim
    Montage` to use `ThirdPersonFire_Montage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `BP_ThirdPersonCharacter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the window size to `800x600` and play using **New Editor Window (PIE)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.5 – The result of this exercise ](img/Figure_17.05_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.5 – The result of this exercise
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you can play on each client. Every time you press
    the left mouse button, the character of the client will play the `1`. If you try
    to fire when the ammo is `0`, that client will hear `No Ammo Sound` and won’t
    do the fire animation, because the server didn’t call the Multicast RPC. If you
    try to spam the fire button, you’ll notice that it will only trigger a new fire
    once the animation has finished.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to use all of the different types of RPCs and
    their caveats. In the next section, we will look at enumerations and how to expose
    them to the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing enumerations to the editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An enumeration is a user-defined data type that holds a list of integer constants,
    where each item has a human-friendly name assigned by you, which makes the code
    easier to read. As an example, if we wanted to represent the different states
    that a character can be in, we could use an integer variable where `0` means it’s
    idle, `1` means it’s walking, and so on. The problem with this approach is that
    when you see code such as `if(State == 0)`, it’s hard to remember what `0` means
    unless you are using some type of documentation or comments to help you. To fix
    this problem, you should use enumerations, where you can write code such as `if(State
    == EState::Idle)`, which is much more explicit and easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: In C++, you have two types of enums – the older raw enums and the new enum classes,
    which were introduced in C++11\. If you want to use the new enum classes in the
    editor, your first instinct might be to do it in the typical way, which is by
    declaring a variable or a function that uses the enumeration with `UPROPERTY`
    or `UFUNCTION`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is, if you try to do that, you’ll get a compilation error. Take
    a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we’ve declared an enum class called `ETestEnum`
    that has three possible values – `EnumValue1`, `EnumValue2`, and `EnumValue3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, try either of the following examples inside a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we declared a `UPROPERTY` variable and a `UFUNCTION`
    function that uses the `ETestEnum` enumeration. If you try to compile, you’ll
    get the following compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In Unreal Engine, it’s good practice to prefix the name of an enumeration with
    the letter `E`. For example, you could have `EWeaponType` and `EAmmoType`.
  prefs: []
  type: TYPE_NORMAL
- en: This error happens because when you try to expose a class, struct, or enumeration
    to the editor with the `UPROPERTY` or `UFUNCTION` macro, you need to add it to
    the Unreal Engine Reflection System by using the `UCLASS`, `USTRUCT`, and `UENUM`
    macros, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about the Unreal Engine Reflection System at [https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection](https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection).
  prefs: []
  type: TYPE_NORMAL
- en: 'With that knowledge in mind, it is simple to fix the previous error. Just do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will look at the `TEnumAsByte` type.
  prefs: []
  type: TYPE_NORMAL
- en: TEnumAsByte
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to expose a variable to the engine that uses a raw enum, then you
    need to use the `TEnumAsByte` type. If you declare a `UPROPERTY` variable using
    a raw enum (not enum classes), you’ll get a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s say you declare a `UPROPERTY` variable using `ETestRawEnum`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll get the following compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix this error, you need to surround the enum type of the variable, which
    in this case is `ETestRawEnum`, with `TEnumAsByte<>`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will look at the `UMETA` macro.
  prefs: []
  type: TYPE_NORMAL
- en: UMETA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you use the `UENUM` macro to add an enumeration to the Unreal Engine Reflection
    System, you can use the `UMETA` macro on each value of the enum. The `UMETA` macro,
    just like with other macros, such as `UPROPERTY` or `UFUNCTION`, can use specifiers
    that will inform Unreal Engine of how to handle that value. Let’s look at the
    most commonly used `UMETA` specifiers.
  prefs: []
  type: TYPE_NORMAL
- en: DisplayName
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This specifier allows you to define a new name that is easier to read for the
    enum value when it’s displayed in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s declare the following variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: When you open the editor and look at the `TestEnum` variable, you will see a
    dropdown where `EnumValue1`, `EnumValue2`, and `EnumValue3` have been replaced
    with `My First Option`, `My Second Option`, and `My Third Option`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Hidden
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This specifier allows you to hide a specific enum value from the dropdown. This
    is typically used when there is an enum value that you only want to be able to
    use in C++ and not in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s declare the following variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: When you open the editor and look at the `TestEnum` variable, you will see a
    dropdown. You should notice that `My Second Option` doesn’t appear in the dropdown
    and therefore can’t be selected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on all of the UMETA specifiers, visit [https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/#enummetadataspecifiers](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/#enummetadataspecifiers).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at the `BlueprintType` specifier for the `UENUM`
    macro.
  prefs: []
  type: TYPE_NORMAL
- en: BlueprintType
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This `UENUM` specifier will expose the enumeration to blueprints. This means
    that there will be an entry for that enumeration in the dropdown that is used
    when making new variables or inputs/outputs for a function, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.6 – Setting a variable to use the ETestEnum variable type ](img/Figure_17.06_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.6 – Setting a variable to use the ETestEnum variable type
  prefs: []
  type: TYPE_NORMAL
- en: 'It will also create additional functions that you can call on the enumeration
    in the editor, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.7 – List of additional functions available when using BlueprintType
    ](img/Figure_17.07_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.7 – List of additional functions available when using BlueprintType
  prefs: []
  type: TYPE_NORMAL
- en: MAX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using enumerations, it’s common to want to know how many values it has.
    In Unreal Engine, the standard way of doing this is by adding `MAX` as the last
    value, which will be automatically hidden in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to know how many values `ETestEnum` has in C++, you just need to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This works because enumerations in C++ are internally stored as numbers, where
    the first value is `0`, the second is `1`, and so on. This means that so long
    as `MAX` is the last value, it will always have the total number of values in
    the enumeration. An important thing to take into consideration is that for `MAX`
    to give you the correct value, you cannot change the internal numbering order
    of the enumeration, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `MAX` will be `101` because it will use the number immediately
    next to the previous value, which is `EnumValue3 = 100`.
  prefs: []
  type: TYPE_NORMAL
- en: Using `MAX` is only meant to be used in C++ and not in the editor because the
    `MAX` value is hidden in blueprints, as mentioned previously. To get the number
    of entries of an enumeration in blueprints, you should use the `BlueprintType`
    specifier in the `UENUM` macro to expose some useful functions on the context
    menu. After that, you just need to type the name of your enumeration in the context
    menu. If you select the **Get number of entries in ETestEnum** option, you will
    have a function that returns the number of entries of that enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will be using C++ enumerations in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 17.02 – Using C++ enumerations in the editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’re going to create a new **C++** project that uses the
    **Third Person** template. We’re going to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An enumeration called `EWeaponType` that contains **three** weapons – a pistol,
    a shotgun, and a rocket launcher.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An enumeration called `EAmmoType` that contains **3** ammo types – bullets,
    shells, and rockets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A variable called `Weapon` that uses `EWeaponType` to tell the type of the current
    weapon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer array variable called `Ammo` that holds the amount of ammo for each
    type, which is initialized with a value of `10`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the player presses the `1`, `2`, or `3` key, the `Weapon` variable will
    be set to `Pistol`, `Shotgun`, or `Rocket Launcher`, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the player presses the left mouse button, the ammo for the current weapon
    will be consumed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With every `Tick` function call, the character will display the current weapon
    type and the equivalent ammo type and amount.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Enumerations` and save it to a location of your liking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the project has been created, it should open the editor as well as the
    Visual Studio solution.
  prefs: []
  type: TYPE_NORMAL
- en: Close the editor and go back to Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Enumerations.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a macro called `ENUM_TO_INT32` that will convert an enumeration into
    an `int32` data type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a macro called `ENUM_TO_FSTRING` that will get the display name for
    a value of an `enum` data type and convert it into an `FString` datatype:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the `EWeaponType` and `EammoType` enumerations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `EnumerationsCharacter.h` file and add the `Enumerations.h` header
    before `EnumerationsCharacter.generated.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the protected `Weapon` variable that holds the weapon type of the selected
    weapon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the protected `Ammo` array that holds the amount of ammo for each type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the protected overrides for the `Begin Play` and `Tick` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the protected input functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `EnumerationsCharacter.cpp` file and bind the new action bindings
    at the end of the `SetupPlayerInputController` function, as shown in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, implement the override for `BeginPlay` that executes the parent logic,
    but also initializes the size of the `Ammo` array with the number of entries in
    the `EAmmoType` enumeration. Each position in the array will also be initialized
    with a value of `10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the override for `Tick`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert the `Weapon` variable into `int32` and the `Weapon` variable into an
    `FString`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert the ammo type into an `FString` and get the ammo count for the current
    weapon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are using `Weapon` to get the ammo type string because the entries in `EAmmoType`
    match the type of ammo of the equivalent `EWeaponType`. In other words, `Pistol
    = 0` uses `Bullets = 0`, `Shotgun = 1` uses `Shells = 1`, and `RocketLauncher
    = 2` uses `Rockets = 2`, so it’s a 1-to-1 mapping that we can use in our favor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Display the name of the current weapon in the character’s location and its
    corresponding ammo type and ammo count, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the equip input functions that set the `Weapon` variable with the
    corresponding value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the fire input function that will use the weapon index to get the
    corresponding ammo type count and subtract `1`, so long as the resulting value
    is greater than or equal to 0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile the code and run the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to **Project Settings**, go to **Engine**, then **Input**, and add the new
    action bindings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.8 – Adding the Pistol, Shotgun, Rocket Launcher, and Fire bindings
    ](img/Figure_17.08_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.8 – Adding the Pistol, Shotgun, Rocket Launcher, and Fire bindings
  prefs: []
  type: TYPE_NORMAL
- en: Close **Project Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure the `1`. Click on **New Editor Window (PIE)**; you should get the
    following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.9 – The result of this exercise ](img/Figure_17.09_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.9 – The result of this exercise
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you can use the `0`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to expose enumerations to the editor so that
    you can use them in blueprints. In the next section, we will look at array index
    wrapping, which allows you to iterate an array beyond its limits and wrap it back
    around from the other side.
  prefs: []
  type: TYPE_NORMAL
- en: Using array index wrapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, when you use arrays to store information, you may want to iterate
    it in both directions and be able to wrap the index so that it doesn’t go beyond
    the index limit and crash the game. An example of this is the previous/next weapon
    logic in shooter games, where you have an array of weapons and you want to be
    able to cycle through them in a particular direction, and when you reach the first
    or the last index, you want to loop back around to the last and first index, respectively.
    The typical way of doing this would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we set the `WeaponIndex` variable (declared as a member
    of the class) to loop back if the new weapon index is outside the limits of the
    weapons array, which can happen in two cases. The first case is when the player
    has the last weapon of the inventory equipped and we want the next weapon. In
    this case, it should go back to the first weapon.
  prefs: []
  type: TYPE_NORMAL
- en: The second case is when the player has the first weapon of the inventory equipped
    and we want the previous weapon. In this case, it should go to the last weapon.
  prefs: []
  type: TYPE_NORMAL
- en: While the example code works, it’s still quite a lot of code to solve such a
    trivial problem. To improve this code, there is a mathematical operation that
    will help you handle these two cases automatically in just one function. It’s
    called the modulo (represented in C++ by the `%` operator), which gives you the
    remainder of a division between two numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we use the modulo to wrap the index of an array? Let’s rewrite the
    previous example using the modulo operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This is the new version, and you can tell right away that it’s a bit harder
    to understand, but it’s more functional and compact. If you don’t use the variables
    to store the intermediate values of each operation, you can probably make the
    entire function in one or two lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const int WeaponCount = Weapons.Num()`: We need to know the size of the array
    to determine the index where it should go back to `0`. In other words, if `WeaponCount
    = 4`, then the array has the `0`, `1`, `2`, and `3` indexes, which tells us that
    index `4` is the cutoff index where it should go back to `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const int32 NewRawIndex = WeaponIndex + Direction`: This is the new raw index
    that doesn’t care about the limits of the array. The `Direction` variable is used
    to indicate the offset we want to add to the current index of the array. This
    is either `-1` if we want the previous index or `1` if we want the next index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const int32 NewWrappedIndex = NewRawIndex % WeaponCount`: This will make sure
    that `NewWrappedIndex` is within the `0` to `WeaponCount - 1` interval and wrap
    around if needed, due to the modulo properties. So, if `NewRawIndex` is `4`, then
    `NewWrappedIndex` will become `0`, because there is no remainder from the division
    of `4 / 4`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If `Direction` is always `1`, meaning we only want the next index, then the
    value of `NewWrappedIndex` is enough for what we need. If we also want to use
    `Direction` with `-1`, then we’ll have a problem, because the modulo operation
    won’t wrap the index correctly for negative indexes. So, if `WeaponIndex` is `0`
    and `Direction` is `-1`, then `NewWrappedIndex` will be `-1`, which is not correct.
    To fix this limitation, we need to do some additional calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WeaponIndex = (NewWrappedIndex + WeaponCount) % WeaponCount`: This will add
    `WeaponCount` to `NewWrappedIndex` to make it positive and apply the modulo again
    to get the correct wrapped index, which fixes the problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return Weapons[WeaponIndex]`: This returns the weapon in the calculated `WeaponIndex`
    index position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a look at a practical example to help you visualize how all this
    works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Weapons:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[0] Knife`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[1] Pistol`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[2] Shotgun`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[3] Rocket Launcher`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeaponCount = Weapons.Num()`, so it has a value of `4`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that `WeaponIndex = 3` and `Direction = 1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we would have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NewRawIndex = WeaponIndex + Direction`, so `3 + 1 = 4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewWrappedIndex = NewRawIndex % WeaponCount`, so `4 % 4 = 0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeaponIndex = (NewWrappedIndex + WeaponCount) % WeaponCount, so (0 + 4) %
    4 = 0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, the starting value for `WeaponIndex` is `3`, which is `Rocket
    Launcher`, and we want the next weapon because `Direction` is set to `1`. Performing
    the calculations, `WeaponIndex` will now be `0`, which is `Knife`. This is the
    desired behavior because we have four weapons, so we circled back to the first
    index. In this case, since `NewRawIndex` is positive, we could’ve just used `NewWrappedIndex`
    without doing the extra calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s debug it again using different values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that `WeaponIndex = 0` and `Direction = -1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NewRawIndex = WeaponIndex + Direction`, so `0 + -1 = -1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewWrappedIndex = NewIndex % WeaponCount`, so `-1 % 4 = -1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeaponIndex = (NewWrappedIndex + WeaponCount) % WeaponCount`, so `(-1 + 4)
    % 4 = 3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, the starting value for `WeaponIndex` is `0`, which is `Knife`,
    and we want the previous weapon because `Direction` is set to -`1`. Doing the
    calculations, `WeaponIndex` will now be `3`, which is `Rocket Launcher`. This
    is the desired behavior because we have four weapons, so we circled back to the
    last index. In this case, since `NewRawIndex` is negative, we can’t just use `NewWrappedIndex`;
    we need to do the extra calculation to get the correct value.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you’re going to use the knowledge you’ve acquired to cycle
    between an enumeration of weapons in both directions.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 17.03 – Using array index wrapping to cycle between an enumeration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we’re going to use the project from *Exercise 17.02 – Using
    C++ enumerations in the editor*, and add two new action mappings for cycling the
    weapons. `Mouse Wheel Up` will go to the previous weapon type, while `Mouse Wheel
    Down` will go to the next weapon type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: First, open the Visual Studio project from *Exercise 17.02 – Using C++ enumerations
    in the editor*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will be updating `Enumerations.h` and adding a macro that will handle
    the array index wrapping in a very convenient way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `Enumerations.h` and add the `GET_WRAPPED_ARRAY_INDEX` macro. This will
    apply the modulo formula that we covered previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `EnumerationsCharacter.h` and declare the new input functions for the
    weapon cycling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the `CycleWeapons` function, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `EnumerationsCharacter.cpp` and bind the new action bindings in the `SetupPlayerInputController`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, implement the new input functions, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code snippet, we defined the functions that handle the action
    mappings for `Previous Weapon` and `Next Weapon`. Each function uses the `CycleWeapons`
    function, with a direction of `-1` for the previous weapon and `1` for the next
    weapon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `CycleWeapons` function, which does the array index wrapping
    using the `Direction` parameter based on the current weapon index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile the code and run the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to **Project Settings**, go to **Engine**, then **Input**, and add the new
    action bindings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.10 – Adding the Previous Weapon and Next Weapon bindings ](img/Figure_17.10_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.10 – Adding the Previous Weapon and Next Weapon bindings
  prefs: []
  type: TYPE_NORMAL
- en: Close **Project Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that the `1`. Click on **New Editor Window (PIE)**; you should get
    the following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.11 – The result of this exercise ](img/Figure_17.11_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.11 – The result of this exercise
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you can use the mouse wheel to cycle between the
    weapons. If you select the rocket launcher and use the mouse wheel down to go
    to the next weapon, it will go back to the pistol. If you use the mouse wheel
    down to go to the previous weapon with the pistol selected, it will go back to
    the rocket launcher.
  prefs: []
  type: TYPE_NORMAL
- en: In the next activity, you will be adding the concept of weapons and ammo to
    the multiplayer FPS project we started in [*Chapter 16*](B18531_16.xhtml#_idTextAnchor345),
    *Getting Started with Multiplayer Basics*.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 17.01 – Adding weapons and ammo to the multiplayer FPS game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this activity, you’ll add the concept of weapons and ammo to the multiplayer
    FPS project that we started in the previous chapter. You will need to use the
    different types of RPCs covered in this chapter to complete this activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MultiplayerFPS` project from *Activity 16.01 – Creating a character
    for the multiplayer FPS project*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `AnimMontage` slot called `Upper Body`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the animations (`Pistol_Fire.fbx`, `MachineGun_Fire.fbx`, and `Railgun_Fire.fbx`)
    from the `Activity17.01\Assets` folder into `Content\Player\Animations`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `AnimMontage` for `Pistol_Fire`, `MachineGun_Fire`, and `Railgun_Fire`,
    and make sure they have the following configurations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Blend In` time of `0.01` and a `Blend Out` time of `0.1`. Make sure it uses
    the `Upper Body` slot.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Blend In` time of `0.01` and a `Blend Out` time of `0.1`. Make sure it uses
    the `Upper Body` slot.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Upper Body` slot.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Import `SK_Weapon.fbx` (with Material Import Method set to Create New Materials),
    `NoAmmo.wav`, `WeaponChange.wav`, and `Hit.wav` from the `Activity17.01\Assets`
    folder into `Content\Weapons`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `Pistol_Fire_Sound.wav` from `Activity17.01\Assets` into `Content\Weapons\Pistol`
    and use it on `Play Sound` in the `Pistol_Fire` animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a simple green-colored material instance from `M_FPGun` called `MI_Pistol`
    and place it on `Content\Weapons\Pistol`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `MachineGun_Fire_Sound.wav` from `Activity17.01\Assets` into `Content\Weapons\MachineGun`
    and use it on `Play Sound` in the `MachineGun_Fire` animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a simple red-colored material instance from `M_FPGun` called `MI_MachineGun`
    and place it on `Content\Weapons\MachineGun`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `Railgun_Fire_Sound.wav` from `Activity17.01\Assets` into `Content\Weapons\Railgun`
    and use it on `Play Sound` in the `Railgun_Fire` animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a simple white-colored material instance from `M_FPGun` called `MI_Railgun`
    and place it on `Content\Weapons\Railgun`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `SK_Mannequin_Skeleton` and create a socket called `GripPoint` from
    `hand_r` with `Relative Location` set to `(X=-10.403845,Y=6.0,Z=-3.124871)` and
    `Relative Rotation` set to `(X=0.0,Y=0.0,Z=90.0)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following input actions to `Content\Player\Inputs`, using the knowledge
    you acquired in [*Chapter 4*](B18531_04.xhtml#_idTextAnchor099), *Getting Started
    with Player Input*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**IA_Fire (Digital)**: *Left Mouse Button*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IA_Pistol (Digital)**: *1*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IA_MachineGun (Digital)**: *2*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IA_Railgun (Digital)**: *3*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IA_PreviousWeapon (Digital)**: *Mouse Wheel Up*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IA_NextWeapon (Digital)**: *Mouse Wheel Down*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the new input actions to `IMC_Player`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `MultiplayerFPS.h`, create the `ENUM_TO_INT32(Enum)` macro, which casts an
    enumeration to `int32`, and the `GET_WRAPPED_ARRAY_INDEX(Index, Count)` macro,
    which uses array indexing wrapping to make sure the index is within the limits
    of the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a header file called `EnumTypes.h` that holds the following enumerations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Pistol`, `MachineGun`, `Railgun`, `MAX`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Single`, `Automatic`'
  prefs: []
  type: TYPE_NORMAL
- en: '`PistolBullets`, `MachineGunBullets`, `Slugs`, `MAX`'
  prefs: []
  type: TYPE_NORMAL
- en: Create a C++ class called `Weapon` that derives from the `Actor` class and has
    a skeletal mesh component called `Mesh` as the root component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In terms of variables, it stores the name, the weapon type, the ammo type, the
    fire mode, how far the hitscan goes, how much damage the hitscan does when it
    hits, the fire rate, the animation montage to use when firing, and the sound to
    play when it has no ammo. In terms of functionality, it needs to be able to start
    the fire (and also stop the fire, because of the automatic fire mode), which checks
    whether the player can fire. If it can, then it plays the fire animation in all
    of the clients and shoots a line trace in the camera position and direction with
    the supplied length to damage the actor it hits. If it doesn’t have ammo, it will
    play a sound only on the owning client.
  prefs: []
  type: TYPE_NORMAL
- en: Edit `FPSCharacter` so that it supports the new input actions for `Fire`, `Pistol`,
    `Machine Gun`, `Railgun`, `Previous Weapon`, and `Next Weapon`. In terms of variables,
    it needs to store the amount of ammo for each type, the currently equipped weapon,
    all of the weapons classes and spawned instances, the sound to play when it hits
    another player, and the sound when it changes weapons. In terms of functions,
    it needs to be able to equip/cycle/add weapons, manage ammo (add, remove, and
    get), handle when the character is damaged, play an anim montage on all of the
    clients, and play a sound on the owning client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create `BP_Pistol` from `AWeapon`, place it on `Content\Weapons\Pistol`, and
    configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Content\Weapons\SK_Weapon`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapons\Pistol\MI_Pistol`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pistol Mk I`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pistol`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pistol Bullets`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Automatic`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`9999.9`, `5.0`, `0.5`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Player\Animations\Pistol_Fire_Montage`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapons\NoAmmo`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create `BP_MachineGun` from `Aweapon`, place it on `Content\Weapons\MachineGun`,
    and configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Content\Weapons\SK_Weapon`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapons\MachineGun\MI_MachineGun`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Machine Gun Mk I`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Machine Gun`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Machine Gun Bullets`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Automatic`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`9999.9`, `5.0`, `0.1`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Player\Animations\MachineGun_Fire_Montage`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapons\NoAmmo`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create `BP_Railgun` from `Aweapon`, place it on `Content\Weapons\Railgun`,
    and configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Content\Weapons\SK_Weapon`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapons\Railgun\MI_Railgun`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Railgun Mk I`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Railgun`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slugs`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Single`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`9999.9`, `100.0`, `1.5`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Player\Animations\Railgun_Fire_Montage`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapons\NoAmmo`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configure `BP_Player` with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BP_Pistol`, `BP_MachineGun`, `BP_Railgun`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapons\Hit`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapons\WeaponChange`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Player\Inputs\IA_Fire`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Player\Inputs\IA_Pistol`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Player\Inputs\IA_MachineGun`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Player\Inputs\IA_Railgun`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Player\Inputs\IA_Previous`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Player\Inputs\IA_NextWeapon`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the mesh component block the visibility channel so that it can be hit by
    the hitscans of the weapons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit `ABP_Player` so that it uses a *Layered blend Per bone* node, with `Mesh
    Space Rotation Blend` enabled, on the `spine_01` bone so that the upper body animations
    use the `Upper Body` slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit `WBP_HUD` so that it displays a white dot crosshair in the middle of the
    screen, the current weapon, and the ammo count under the `Health` and `Armor`
    indicators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Expected output**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result should be a project where each client will have weapons with ammo
    and will be able to use them to fire at and damage other players. You will also
    be able to select weapons by using the *1*, *2*, and *3* keys and by using the
    mouse wheel up and down to select the previous and next weapon, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.12 – The expected result of this activity ](img/Figure_17.12_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.12 – The expected result of this activity
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this activity, you should have a good idea of how RPCs, enumerations,
    and array index wrapping work.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use RPCs to allow the server and the clients
    to execute logic on one another. You also learned how enumerations work in Unreal
    Engine by using the `UENUM` macro and how to use array index wrapping, which helps
    you iterate an array in both directions and loops around when you go beyond its
    index limits.
  prefs: []
  type: TYPE_NORMAL
- en: By completing this chapter’s activity, you learned how to develop a basic playable
    game where players can shoot each other and switch between their weapons.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll learn where the instances of the most common gameplay
    framework classes exist in multiplayer, as well as learn about the `Player State`
    and `Game State` classes. We’ll also cover some new concepts in the game mode
    that are used in multiplayer matches, as well as some useful general-purpose,
    built-in functionality.
  prefs: []
  type: TYPE_NORMAL
