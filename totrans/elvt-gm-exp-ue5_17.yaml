- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Using Remote Procedure Calls
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用远程过程调用
- en: In the previous chapter, we covered some critical multiplayer concepts, including
    the server-client architecture, connections and ownership, roles, and variable
    replication. We also learned how to make 2D Blend Spaces and use the `Transform
    (Modify) Bone` node to modify bones at runtime. We used that knowledge to create
    a basic first-person shooter character that walks, jumps, and looks around.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了一些关键的多人游戏概念，包括服务器-客户端架构、连接和所有权、角色以及变量复制。我们还学习了如何创建2D混合空间，并使用`Transform
    (Modify) Bone`节点在运行时修改骨骼。我们利用这些知识创建了一个基本的单人第一人称射击角色，该角色可以行走、跳跃和四处张望。
- en: In this chapter, we’re going to cover **remote procedure calls** (**RPCs**),
    which is another important multiplayer concept that allows the server to execute
    functions on the clients and vice versa. So far, we’ve learned about variable
    replication as a form of communication between the server and the clients. However,
    to have proper communication, this isn’t enough. This is because the server may
    need to execute specific logic on the clients that doesn’t involve updating the
    value of a variable. The client also needs a way to tell its intentions to the
    server so that the server can validate the action and let the other clients know
    about it. This will ensure that the multiplayer world is synchronized between
    all of the connected clients. We’ll also cover how to use enumerations and expose
    them to the editor, as well as array index wrapping, which allows you to iterate
    an array in both directions and loop around when you go beyond its limits.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，我们将介绍**远程过程调用**（**RPCs**），这是另一个重要的多人游戏概念，允许服务器在客户端上执行函数，反之亦然。到目前为止，我们已经了解了变量复制作为服务器和客户端之间通信的一种形式。然而，为了进行适当的通信，这还不够。这是因为服务器可能需要在客户端上执行特定的逻辑，而不涉及更新变量的值。客户端也需要一种方式来告诉服务器其意图，以便服务器可以验证该操作并让其他客户端知道。这将确保所有连接的客户端之间的多人游戏世界保持同步。我们还将介绍如何使用枚举并将它们暴露给编辑器，以及数组索引包装，这允许你在两个方向上迭代数组，并在超出其限制时循环。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，我们将涵盖以下主要内容：
- en: Understanding remote procedure calls
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解远程过程调用
- en: Exposing enumerations to the editor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将枚举暴露给编辑器
- en: Using array index wrapping
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组索引包装
- en: By the end of this chapter, you’ll understand how RPCs work to make the server
    and the clients execute logic on one another. You’ll also be able to expose enumerations
    to the editor and use array index wrapping to cycle through arrays in both directions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解RPC是如何工作，使服务器和客户端在彼此上执行逻辑。你还将能够将枚举暴露给编辑器，并使用数组索引包装在两个方向上循环遍历数组。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following technical requirements:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下技术要求：
- en: Unreal Engine 5 installed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unreal Engine 5已安装
- en: Visual Studio 2019 installed
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019已安装
- en: 'The project for this chapter can be found in the `Chapter17` folder of the
    code bundle for this book, which can be downloaded here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目可以在本书代码包的`Chapter17`文件夹中找到，该代码包可以在此处下载：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition)。
- en: In the next section, we will look at RPCs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨RPCs。
- en: Understanding remote procedure calls
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解远程过程调用
- en: 'We covered variable replication in [*Chapter 16*](B18531_16.xhtml#_idTextAnchor345),
    *Getting Started with Multiplayer Basics*, and, while a very useful feature, it
    is a bit limited in terms of allowing custom code to be executed in remote game
    instances (client-to-server or server-to-client) for two main reasons:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第16章*](B18531_16.xhtml#_idTextAnchor345)“开始学习多人游戏基础”中介绍了变量复制，虽然这是一个非常有用的功能，但在允许在远程游戏实例（客户端到服务器或服务器到客户端）中执行自定义代码方面还是有点局限，主要有以下两个原因：
- en: The first reason is that variable replication is strictly a form of server-to-client
    communication, so there isn’t a way for a client to use variable replication to
    tell the server to execute some custom logic by changing the value of a variable.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个原因是变量复制严格是一种服务器到客户端的通信形式，因此客户端无法通过更改变量的值来使用变量复制告诉服务器执行一些自定义逻辑。
- en: The second reason is that variable replication, as the name suggests, is driven
    by the values of variables, so even if variable replication allowed client-to-server
    communication, it would require you to change the value of a variable on the client
    to trigger a `RepNotify` function on the server to run the custom logic, which
    is not very practical.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个原因是，如名称所示，变量复制是由变量的值驱动的，因此即使变量复制允许客户端到服务器的通信，它也会要求你更改客户端上的变量值，以在服务器上触发一个`RepNotify`函数来运行自定义逻辑，这并不太实用。
- en: To solve this problem, Unreal Engine supports RPCs, which work just like normal
    functions that can be defined and called. However, instead of executing them locally,
    they will be executed on a remote game instance, without being tied to a variable.
    To be able to use RPCs, make sure you are defining them in an actor that has a
    valid connection and replication turned on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Unreal Engine支持RPCs，它们的工作方式与正常函数一样，可以定义和调用。然而，它们不会在本地执行，而是在远程游戏实例上执行，而不依赖于变量。要使用RPCs，请确保你在具有有效连接和开启复制的actor中定义它们。
- en: 'There are three types of RPCs, and each one serves a different purpose:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种类型的RPC，每种都服务于不同的目的：
- en: Server RPC
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器RPC
- en: Multicast RPC
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Multicast RPC
- en: Client RPC
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端RPC
- en: Let’s look at these three types in detail and explain when to use them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这三种类型，并解释何时使用它们。
- en: Server RPC
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器RPC
- en: 'You use a Server RPC every time you want the server to run a function on the
    actor that has defined the RPC. There are two main reasons why you would want
    to do this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你想让服务器在定义了RPC的actor上运行一个函数时，你都会使用服务器RPC。你想要这样做有两个主要原因：
- en: The first reason is security. When making multiplayer games, especially competitive
    ones, you always have to assume that the client will try to cheat. The way to
    make sure there is no cheating is by forcing the client to go through the server
    to execute the functions that are critical to gameplay.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个原因是安全性。在制作多人游戏，尤其是竞争性游戏时，你总是必须假设客户端会尝试作弊。确保没有作弊的方法是强制客户端通过服务器执行对游戏玩法至关重要的函数。
- en: The second reason is synchronicity. Since the critical gameplay logic is only
    executed on the server, the important variables are only going to be changed there,
    which will automatically trigger the variable replication logic to update the
    clients whenever they are changed.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个原因是同步性。由于关键的游戏逻辑仅在服务器上执行，重要的变量只会在那里更改，这将自动触发变量复制逻辑，在它们更改时更新客户端。
- en: An example of this would be when a client’s character tries to fire a weapon.
    Since there’s always the possibility that the client may try to cheat, you can’t
    just execute the fire weapon logic locally. The correct way of doing this is by
    having the client call a Server RPC that tells the server to validate the `Fire`
    action by making sure the character has enough ammo, has the weapon equipped,
    and so on. If everything checks out, then it will deduct the ammo variable, and
    finally, it will execute a Multicast RPC (covered shortly) that will tell all
    of the clients to play the fire animation on that character.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当客户端的角色试图开火时，由于客户端可能尝试作弊的可能性始终存在，你不能只是本地执行开火逻辑。正确的方法是让客户端调用一个服务器RPC，告诉服务器通过确保角色有足够的弹药、装备了武器等来验证`Fire`动作。如果一切检查无误，那么它将扣除弹药变量，最后，它将执行一个Multicast
    RPC（稍后介绍），告诉所有客户端在该角色上播放开火动画。
- en: Declaration
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 宣告
- en: 'To declare a Server RPC, you can use the `Server` specifier on the `UFUNCTION`
    macro. Have a look at the following example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明服务器RPC，你可以在`UFUNCTION`宏上使用`Server`指定符。看看以下示例：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code snippet, the `Server` specifier is used on the `UFUNCTION`
    macro to state that the function is a Server RPC. You can have parameters on a
    Server RPC just like a normal function, but with some caveats that will be explained
    later in this topic, as well as the purpose of the `Reliable` and `WithValidation`
    specifiers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`Server`指定符用于`UFUNCTION`宏，以表明该函数是一个服务器RPC。你可以在服务器RPC上设置参数，就像正常函数一样，但有一些将在本主题的后面解释的注意事项，以及`Reliable`和`WithValidation`指定符的目的。
- en: Execution
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行
- en: 'To execute a Server RPC, you call it from a client on the actor instance that
    defined it. Take a look at the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行服务器RPC，你从定义它的actor实例上的客户端调用它。看看以下示例：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code snippet implements the `CallMyOwnServerRPC` function, which
    calls the `ServerMyOwnRPC` RPC function, defined in its own `ARPCTest` class,
    with an integer parameter. This will execute the implementation of the `ServerMyOwnRPC`
    function on the server version of that actor’s instance. We can also call a Server
    RPC from another actor’s instance, like so:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段实现了 `CallMyOwnServerRPC` 函数，该函数调用其自身 `ARPCTest` 类中定义的 `ServerMyOwnRPC`
    RPC 函数，并带有整型参数。这将执行该演员实例的服务器版本上的 `ServerMyOwnRPC` 函数的实现。我们也可以从另一个演员实例调用服务器 RPC，如下所示：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code snippet implements the `CallServerRPCOfAnotherActor` function,
    which calls the `ServerAnotherActorRPC` RPC function, defined in `AAnotherActor`,
    on the `OtherActor` instance, so long as it’s valid. This will execute the implementation
    of the `ServerAnotherActorRPC` function on the server version of the `OtherActor`
    instance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段实现了 `CallServerRPCOfAnotherActor` 函数，该函数在 `AAnotherActor` 中定义的 `ServerAnotherActorRPC`
    RPC 函数上调用 `OtherActor` 实例，只要它是有效的。这将执行 `ServerAnotherActorRPC` 函数在 `OtherActor`
    实例的服务器版本上。
- en: Multicast RPC
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多播 RPC
- en: You use a Multicast RPC when you want the server to instruct all of the clients
    to run a function on the actor that has defined the RPC.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望服务器指示所有客户端在定义了 RPC 的演员上运行一个函数时，您会使用多播 RPC。
- en: An example of this is when a client’s character tries to fire a weapon. After
    the client calls the Server RPC to ask permission to fire the weapon and the server
    has validated the request (the ammo has been deducted and the line trace/projectile
    was processed), we need to do a Multicast RPC so that all of the instances of
    that specific character play the fire animation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当客户端的角色尝试开火时。在客户端调用服务器 RPC 请求开火权限并且服务器验证了请求（已扣除弹药并处理了线迹/投射物）之后，我们需要执行一个多播
    RPC，以便所有特定角色的实例都播放开火动画。
- en: Declaration
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明
- en: 'To declare a Multicast RPC, you need to use the `NetMulticast` specifier on
    the `UFUNCTION` macro. Have a look at the following example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个多播 RPC，您需要在 `UFUNCTION` 宏上使用 `NetMulticast` 指定符。请看以下示例：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code snippet, the `NetMulticast` specifier is used on the `UFUNCTION`
    macro to say that the function is a Multicast RPC. You can have parameters on
    a Multicast RPC just like a normal function, but with the same caveats as the
    Server RPC. The `Unreliable` specifier will be explained later in this topic.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，`NetMulticast` 指定符用于 `UFUNCTION` 宏，表示该函数是一个多播 RPC。您可以在多播 RPC 上有参数，就像普通函数一样，但要注意与服务器
    RPC 相同的注意事项。`Unreliable` 指定符将在本主题的后续部分解释。
- en: Execution
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行
- en: 'To execute a Multicast RPC, you must call it from the server on the actor instance
    that defined it. Take a look at the following example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行多播 RPC，您必须从定义它的演员实例的服务器上调用它。请看以下示例：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code snippet implements the `CallMyOwnMulticastRPC` function,
    which calls the `MulticastMyOwnRPC` RPC function, defined in its own `ARPCTest`
    class, with an integer parameter. This will execute the implementation of the
    `MulticastMyOwnRPC` function on all of the clients’ versions of that actor’s instance.
    We can also call a Multicast RPC from another actor’s instance, like so:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段实现了 `CallMyOwnMulticastRPC` 函数，该函数调用其自身 `ARPCTest` 类中定义的 `MulticastMyOwnRPC`
    RPC 函数，并带有整型参数。这将执行 `MulticastMyOwnRPC` 函数在所有客户端的该演员实例版本上。我们也可以从另一个演员实例调用多播 RPC，如下所示：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code snippet implements the `CallMulticastRPCOfAnotherActor` function,
    which calls the `MulticastAnotherActorRPC` RPC function, defined in `AAnotherActor`,
    on the `OtherActor` instance, so long as it’s valid. This will execute the implementation
    of the `MulticastAnotherActorRPC` function on all of the clients’ versions of
    the `OtherActor` instance.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段实现了 `CallMulticastRPCOfAnotherActor` 函数，该函数在 `OtherActor` 实例上调用 `AAnotherActor`
    中定义的 `MulticastAnotherActorRPC` RPC 函数，只要它是有效的。这将执行 `MulticastAnotherActorRPC`
    函数在所有客户端的 `OtherActor` 实例版本上。
- en: Client RPC
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端 RPC
- en: You use a Client RPC when you want the server to instruct only the owning client
    to run a function on the actor that has defined the RPC. To set the owning client,
    you need to call `SetOwner` on the server and set it with the client’s player
    controller.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望服务器仅指示拥有客户端在定义了 RPC 的演员上运行一个函数时，您会使用客户端 RPC。要设置拥有客户端，您需要在服务器上调用 `SetOwner`
    并使用客户端的玩家控制器设置它。
- en: An example of this would be when a character is hit by a projectile and plays
    a pain sound that only that client will hear. By calling a Client RPC from the
    server, the sound will only be played on the owning client and not on the other
    clients.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当一个角色被投射物击中并播放只有该客户端能听到的疼痛声音时。通过从服务器调用客户端RPC，声音将只在该拥有客户端上播放，而不会在其他客户端上播放。
- en: Declaration
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明
- en: 'To declare a Client RPC, you need to use the `Client` specifier on the `UFUNCTION`
    macro. Have a look at the following example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明客户端RPC，您需要在`UFUNCTION`宏上使用`Client`指定符。看看以下示例：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code snippet, the `Client` specifier is being used on the `UFUNCTION`
    macro to say that the function is a Client RPC. You can have parameters on a Client
    RPC just like a normal function, but with the same caveats as the Server RPC and
    the Multicast RPC. The `Unreliable` specifier will be explained later in this
    topic.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`Client`指定符被用于`UFUNCTION`宏，表示该函数是一个客户端RPC。您可以在客户端RPC上使用参数，就像在普通函数上一样，但要注意与服务器RPC和组播RPC相同的注意事项。`Unreliable`指定符将在本主题的后面进行解释。
- en: Execution
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行
- en: 'To execute a Client RPC, you must call it from the server on the actor instance
    that defined it. Take a look at the following example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行客户端RPC，您必须从定义它的服务器上的actor实例调用它。看看以下示例：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code snippet implements the `CallMyOwnClientRPC` function, which
    calls the `ClientMyOwnRPC` RPC function, defined in its own `ARPCTest` class,
    with an integer parameter. This will execute the implementation of the `ClientMyOwnRPC`
    function on the owning client’s version of that actor’s instance. We can also
    call a Client RPC from another actor’s instance, like so:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段实现了`CallMyOwnClientRPC`函数，该函数调用在它自己的`ARPCTest`类中定义的`ClientMyOwnRPC` RPC函数，并带有整型参数。这将执行拥有客户端版本的该actor实例的`ClientMyOwnRPC`函数的实现。我们也可以从另一个actor实例调用客户端RPC，如下所示：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code snippet implements the `CallClientRPCOfAnotherActor` function,
    which calls the `ClientAnotherActorRPC` RPC function, defined in `AAnotherActor`,
    on the `OtherActor` instance, so long as it’s valid. This will execute the implementation
    of the `ClientAnotherActorRPC` function on the owning client’s version of the
    `OtherActor` instance.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段实现了`CallClientRPCOfAnotherActor`函数，该函数在`OtherActor`实例上调用在`AAnotherActor`中定义的`ClientAnotherActorRPC`
    RPC函数，只要它是有效的。这将执行拥有客户端版本的`OtherActor`实例的`ClientAnotherActorRPC`函数的实现。
- en: Important considerations when using RPCs
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RPC时的重要注意事项
- en: RPCs are very useful, but there are a couple of things that you need to take
    into consideration when using them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: RPCs非常有用，但在使用它们时需要考虑几个问题。
- en: Implementation
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现
- en: The implementation of an RPC differs slightly from that of a typical function.
    Instead of implementing the function as you normally do, you should only implement
    the `_Implementation` version of it, even though you didn’t declare it in the
    header file. Have a look at the following examples.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: RPC的实现与典型函数的实现略有不同。您不需要像通常那样实现函数，而应该只实现它的`_Implementation`版本，即使您没有在头文件中声明它。看看以下示例。
- en: '**Server RPC**:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器RPC**：'
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code snippet, we implemented the `_Implementation` version
    of the `ServerRPCTest` function, which uses three parameters.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们实现了`ServerRPCTest`函数的`_Implementation`版本，该函数使用三个参数。
- en: '**Multicast RPC**:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**组播RPC**：'
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code snippet, we implemented the `_Implementation` version
    of the `MulticastRPCTest` function, which uses three parameters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们实现了`MulticastRPCTest`函数的`_Implementation`版本，该函数使用三个参数。
- en: '**Client RPC**:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端RPC**：'
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code snippet, we implemented the `_Implementation` version
    of the `ClientRPCTest` function, which uses three parameters.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们实现了`ClientRPCTest`函数的`_Implementation`版本，该函数使用三个参数。
- en: 'As you can see from the previous examples, independent of the type of the RPC
    you are implementing, you should only implement the `_Implementation` version
    of the function and not the normal one, as demonstrated in the following code
    snippet:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的示例中看到的，无论您实现的是哪种类型的RPC，您都应该只实现函数的`_Implementation`版本，而不是普通版本，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, we’re defining the normal implementation of `ServerRPCFunction`.
    If you implement the RPC like this, you’ll get an error saying that it was already
    implemented. The reason for this is that when you declare the RPC function in
    the header file, Unreal Engine will automatically create the normal implementation
    internally, which once called, will execute the logic to send the RPC request
    through the network and when it reaches the remote computer it will call the `_Implementation`
    version there. Since you cannot have two implementations of the same function,
    it will throw a compilation error. To fix this, just make sure that you only implement
    the `_Implementation` version of the RPC.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在定义 `ServerRPCFunction` 的正常实现。如果你这样实现 RPC，你会得到一个错误，说它已经被实现。原因在于当你将
    RPC 函数声明在头文件中时，虚幻引擎会自动内部创建正常实现，一旦调用，将通过网络发送 RPC 请求的逻辑将被执行，当它到达远程计算机时，它将调用那里的 `_Implementation`
    版本。由于你不能有两个相同函数的实现，它将抛出编译错误。为了解决这个问题，只需确保你只实现 RPC 的 `_Implementation` 版本。
- en: Next, we will look at name prefixes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨名称前缀。
- en: Name prefixes
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称前缀
- en: 'In Unreal Engine, it’s good practice to prefix RPCs with their corresponding
    types. Have a look at the following examples:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，将 RPC 前缀与其对应类型是良好的实践。看看以下例子：
- en: A `RPCFunction` should be named `ServerRPCFunction`
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RPCFunction` 应命名为 `ServerRPCFunction`'
- en: A `RPCFunction` should be named `MulticastRPCFunction`
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RPCFunction` 应命名为 `MulticastRPCFunction`'
- en: A `RPCFunction` should be named `ClientRPCFunction`
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RPCFunction` 应命名为 `ClientRPCFunction`'
- en: Return value
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: Since the execution of RPCs is typically executed on different machines asynchronously,
    you can’t have a return value, so it always needs to be void.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 RPC 的执行通常在不同的机器上异步进行，因此不能有返回值，所以它总是需要是空的。
- en: Overriding
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖
- en: You can override the implementation of an RPC to expand or bypass the parent’s
    functionality by declaring and implementing the `_Implementation` function in
    the child class without the `UFUNCTION` macro. Let’s look at an example.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在子类中声明和实现没有 `UFUNCTION` 宏的 `_Implementation` 函数来覆盖 RPC 的实现，以扩展或绕过父类的功能。让我们看看一个例子。
- en: 'The following is the declaration of the parent class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对父类的声明：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code snippet, we have the declaration of the `ServerRPCTest`
    function in the parent class, which uses one integer parameter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们有父类中 `ServerRPCTest` 函数的声明，它使用一个整型参数。
- en: 'If we want to override the function on the child class, we would need to use
    the following declaration:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在子类中覆盖函数，我们需要使用以下声明：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code snippet, we have overridden the declaration of the `ServerRPCTest_Implementation`
    function in the child class header file. The implementation of the function is
    just like any other override, with the possibility of calling `Super::ServerRPCTest_Implementation`
    if you still want to execute the parent functionality.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在子类头文件中覆盖了 `ServerRPCTest_Implementation` 函数的声明。函数的实现就像任何其他覆盖一样，如果你仍然想执行父类功能，还有可能调用
    `Super::ServerRPCTest_Implementation`。
- en: Valid connection
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有效的连接
- en: For an actor to be able to execute its RPCs, they need to have a valid connection.
    If you try to call an RPC on an actor that doesn’t have a valid connection, then
    nothing will happen on the remote instance. You must make sure that the actor
    is either a player controller, is being possessed by one (if applicable), or that
    its owning actor has a valid connection.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使演员能够执行其 RPC，它们需要有一个有效的连接。如果你尝试在一个没有有效连接的演员上调用 RPC，那么在远程实例上什么都不会发生。你必须确保演员是一个玩家控制器，或者被一个控制器所拥有（如果适用），或者其拥有者有一个有效的连接。
- en: Supported parameter types
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持的参数类型
- en: When using RPCs, you can add parameters just like any other function. At the
    time of writing, most common types are supported (such as `bool`, `int32`, `float`,
    `FText`, `FString`, `FName`, `TArray`, and so on), but not all of them, such as
    `TSet` and `TMap`. Among the types that are supported, the ones that you have
    to pay more attention to are the pointers to any `UObject` class or subclass,
    especially actors.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 RPC 时，你可以像任何其他函数一样添加参数。在撰写本文时，大多数常见类型都受到支持（例如 `bool`、`int32`、`float`、`FText`、`FString`、`FName`、`TArray`
    等），但并非所有类型，例如 `TSet` 和 `TMap`。在受支持的类型中，你必须更加注意指向任何 `UObject` 类或子类的指针，尤其是演员。
- en: 'If you create an RPC with an actor parameter, then that actor also needs to
    exist on the remote game instance; otherwise, it will have a value of `nullptr`.
    Another important thing to take into account is that the instance name of each
    version of the actor can be different. This means that if you call an RPC with
    an actor parameter, then the instance name of the actor when calling the RPC might
    be different than the one when executing the RPC on the remote instance. Here
    is an example to help you understand this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用演员参数创建一个RPC，那么该演员也需要存在于远程游戏实例上；否则，它将具有`nullptr`的值。另一个需要考虑的重要事项是，演员每个版本的实例名称可能不同。这意味着如果你使用演员参数调用RPC，那么调用RPC时演员的实例名称可能与在远程实例上执行RPC时的实例名称不同。以下是一个帮助你理解这个的示例：
- en: '![Figure 17.1 – Displaying the name of the character instances in three clients
    ](img/Figure_17.01_B18531.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图17.1 – 在三个客户端显示角色实例的名称](img/Figure_17.01_B18531.jpg)'
- en: Figure 17.1 – Displaying the name of the character instances in three clients
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1 – 在三个客户端显示角色实例的名称
- en: In the preceding example, you can see three clients running (one of them is
    a listen server) and each window is displaying the name of all of the character
    instances. If you look at the `BP_ThirdPersonCharacter_C_0`, but on the `BP_ThirdPersonCharacter_C_1`.
    This means that if `BP_ThirdPersonCharacter_C_0` as an argument, then when the
    RPC is executed on the server, the parameter will be `BP_ThirdPersonCharacter_C_1`,
    which is the instance name of the equivalent character in that game instance.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你可以看到有三个客户端正在运行（其中一个是监听服务器），每个窗口都显示了所有角色实例的名称。如果你查看`BP_ThirdPersonCharacter_C_0`，但它在`BP_ThirdPersonCharacter_C_1`上。这意味着如果`BP_ThirdPersonCharacter_C_0`作为一个参数，那么当RPC在服务器上执行时，参数将是`BP_ThirdPersonCharacter_C_1`，这是该游戏实例中等效角色的实例名称。
- en: Executing RPCs on the target machine
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在目标机器上执行RPC
- en: You can call RPCs directly on their target machine and they will still execute.
    In other words, you can call a Server RPC on the server and it will execute, as
    well as a Multicast/Client RPC on the client, but in the latter case, it will
    only execute the logic on the client that called the RPC. Either way, in these
    cases, you can call the `_Implementation` version directly instead, to execute
    the logic faster.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接在目标机器上调用RPC，它们仍然会执行。换句话说，你可以在服务器上调用服务器RPC，它将执行，以及在客户端上调用多播/客户端RPC，但在后一种情况下，它只会执行调用RPC的客户端上的逻辑。无论如何，在这些情况下，你可以直接调用`_Implementation`版本，以更快地执行逻辑。
- en: The reason for this is that the `_Implementation` version just holds the logic
    to execute and doesn’t have the overhead of creating and sending the RPC request
    through the network that the regular call has.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于`_Implementation`版本仅包含执行逻辑，而不具备常规调用通过网络创建和发送RPC请求的开销。
- en: 'Have a look at the following example of an actor that has authority on the
    server:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下具有服务器权限的演员示例：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, you have the `CallServerRPC` function, which calls
    `ServerRPCFunction` in two different ways. If the actor is already on the server,
    then it calls `ServerRPCFunction_Implementation`, which will skip the overhead,
    as mentioned previously.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你有`CallServerRPC`函数，它以两种不同的方式调用`ServerRPCFunction`。如果演员已经在服务器上，那么它调用`ServerRPCFunction_Implementation`，这将跳过之前提到的开销。
- en: If the actor is not on the server, then it executes the regular call by using
    `ServerRPCFunction`, which adds the required overhead for creating and sending
    the RPC request through the network.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果演员不在服务器上，那么它通过使用`ServerRPCFunction`执行常规调用，这为通过网络创建和发送RPC请求添加了所需的开销。
- en: Validation
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证
- en: When you define an RPC, you have the option of using an additional function
    to check whether there are any invalid inputs before the RPC is called. This is
    used to avoid processing the RPC if the inputs are invalid due to cheating or
    for some other reason.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义RPC时，你有选项使用一个额外的函数来检查在调用RPC之前是否有任何无效的输入。这用于避免由于作弊或其他原因导致输入无效而处理RPC。
- en: To use validation, you need to add the `WithValidation` specifier to the `UFUNCTION`
    macro. When you use that specifier, you will be forced to implement the `_Validate`
    version of the function, which will return a Boolean stating whether the RPC can
    be executed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用验证，你需要将`WithValidation`指定符添加到`UFUNCTION`宏中。当你使用该指定符时，你将被迫实现函数的`_Validate`版本，它将返回一个布尔值，表示RPC是否可以执行。
- en: 'Have a look at the following example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下示例：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code snippet, we’ve declared a validated Server RPC called
    `ServerSetHealth`, which takes a float parameter for the new value of `Health`.
    Take a look at its implementation:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了一个经过验证的服务器RPC `ServerSetHealth`，它接受一个用于`Health`新值的浮点参数。看看它的实现：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code snippet, we implemented the `_Validate` function, which
    will check whether the new health is within 0 and the maximum value of the health.
    If a client tries to hack and call `ServerSetHealth` with `200` and `MaxHealth`
    is `100`, then the RPC won’t be called, which prevents the client from changing
    the health with values outside a certain range. If the `_Validate` function returns
    `true`, the `_Implementation` function is called as usual, which sets `Health`
    with the value of `NewHealth`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们实现了`_Validate`函数，该函数将检查新的健康值是否在0和健康最大值之间。如果客户端尝试作弊并使用`200`调用`ServerSetHealth`，而`MaxHealth`是`100`，则不会调用RPC，这防止客户端使用超出一定范围的值更改健康。如果`_Validate`函数返回`true`，则通常调用`_Implementation`函数，它使用`NewHealth`的值设置`Health`。
- en: Reliability
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可靠性
- en: 'When you declare an RPC, you are required to either use the `Reliable` or `Unreliable`
    specifier in the `UFUNCTION` macro. Here’s a quick overview of what they do:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明一个RPC时，你必须在使用`UFUNCTION`宏时使用`Reliable`或`Unreliable`指定符。以下是一个快速概述它们的作用：
- en: '`Reliable`: This is used when you want to make sure the RPC is executed, by
    repeating the request until the remote machine confirms its reception. This should
    only be used for RPCs that are very important, such as executing critical gameplay
    logic. Here is an example of how to use it:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`可靠的`：当你想要确保RPC被执行，通过重复请求直到远程机器确认其接收为止时使用。这应该只用于非常重要的RPC，例如执行关键游戏逻辑。以下是如何使用它的示例：'
- en: '[PRE18]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`Unreliable`: This is used when you don’t care whether the RPC is executed
    due to bad network conditions, such as playing a sound or spawning a particle
    effect. This should only be used for RPCs that aren’t very important or are called
    very frequently to update values since it wouldn’t matter if a couple didn’t get
    through. Here is an example of how to use it:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`不可靠的`：当网络条件不佳，例如播放声音或生成粒子效果时，你不在乎RPC是否执行。这应该只用于不太重要或非常频繁调用来更新值的RPC，因为即使有一些没有通过也没有关系。以下是如何使用它的示例：'
- en: '[PRE19]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on RPCs, please visit [https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/RPCs/index.xhtml](https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/RPCs/index.xhtml).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于RPC的信息，请访问[https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/RPCs/index.xhtml](https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/RPCs/index.xhtml)。
- en: In the following exercise, you will learn how to implement the different types
    of RPCs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的练习中，你将学习如何实现不同类型的RPC。
- en: Exercise 17.01 – Using remote procedure calls
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习17.01 – 使用远程过程调用
- en: 'In this exercise, we’re going to create a **C++** project that uses the **Third
    Person** template and we’re going to expand it in the following way:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个使用**第三人称**模板的**C++**项目，并且我们将按以下方式扩展它：
- en: Add a new `Ammo` integer variable that defaults to `5` and replicates to all
    of the clients.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个新的`Ammo`整数变量，默认值为`5`，并复制到所有客户端。
- en: Add a fire animation that plays a fire sound and also create a **Fire Anim Montage**
    that is played when the server tells the client that the request to fire was valid.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个播放射击声音的射击动画，并创建一个当服务器告诉客户端射击请求有效时播放的**射击动画蒙太奇**。
- en: Add a **No Ammo Sound** that will play when the server tells the client that
    they didn’t have sufficient ammo.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个**无弹药声音**，当服务器告诉客户端他们没有足够的弹药时播放。
- en: Every time the player presses the left mouse button, the client will perform
    a reliable and validated Server RPC that will check whether the character has
    sufficient ammo. If it does, it will subtract `1` from the `Ammo` variable and
    call an unreliable Multicast RPC that plays the fire animation in every client.
    If it doesn’t have ammo, then it will execute an unreliable Client RPC that will
    play `No Ammo Sound` that will only be heard by the owning client.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当玩家按下左鼠标按钮时，客户端将执行一个可靠且经过验证的服务器RPC，以检查角色是否有足够的弹药。如果有，它将从`Ammo`变量中减去`1`，并调用一个不可靠的多播RPC，在所有客户端中播放射击动画。如果没有弹药，它将执行一个不可靠的客户端RPC，播放`No
    Ammo Sound`，这个声音只会被拥有客户端听到。
- en: Schedule a timer that will prevent the client from spamming the fire button
    for `1.5s` after playing the fire animation.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排一个计时器，在播放射击动画后`1.5s`防止客户端连续点击射击按钮。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: Create a new `RPC` and save it to a location of your liking.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`RPC`并将其保存到您喜欢的位置。
- en: Once the project has been created, it should open the editor as well as the
    Visual Studio solution.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，它应该也会打开编辑器和Visual Studio解决方案。
- en: Close the editor and go back to Visual Studio.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭编辑器并返回Visual Studio。
- en: 'Open `RPCCharacter.h` and declare the protected `FireTimer` variable, which
    will be used to prevent the client from spamming the `Fire` action:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`RPCCharacter.h`并声明受保护的`FireTimer`变量，该变量将用于防止客户端重复使用`Fire`动作：
- en: '[PRE20]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Declare the protected replicated `Ammo` variable, which starts with `5` shots:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的复制`Ammo`变量，它以`5`发子弹开始：
- en: '[PRE21]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, declare the protected animation montage variable that will be played
    when the character fires:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明将在角色射击时播放的受保护动画蒙版变量：
- en: '[PRE22]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Declare the protected sound variable that will be played when the character
    has no ammo:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明将在角色没有弹药时播放的声音的受保护变量：
- en: '[PRE23]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Override the `Tick` function:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`Tick`函数：
- en: '[PRE24]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Declare the reliable and validated Server RPC for firing:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明可靠的已验证服务器RPC用于射击：
- en: '[PRE25]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Declare the unreliable Multicast RPC that will play the fire animation on all
    of the clients:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个不可靠的多播RPC，它将在所有客户端上播放火焰动画：
- en: '[PRE26]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Declare the unreliable Client RPC that will play a sound only in the owning
    client:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个不可靠的客户端RPC，它只会在拥有客户端播放声音：
- en: '[PRE27]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, open the `RPCCharacter.cpp` file and include `GameplayStatics.h` for the
    PlaySound2D function and the UnrealNetwork.h so we can use the `DOREPLIFETIME_CONDITION`
    macro:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`RPCCharacter.cpp`文件，为`PlaySound2D`函数包含`GameplayStatics.h`，以及`UnrealNetwork.h`以便我们可以使用`DOREPLIFETIME_CONDITION`宏：
- en: '[PRE28]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'At the end of the constructor, enable the `Tick` function:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数的末尾，启用`Tick`函数：
- en: '[PRE29]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Implement the `GetLifetimeReplicatedProps` function so that the `Ammo` variable
    will replicate to all of the clients:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现使`Ammo`变量复制到所有客户端的`GetLifetimeReplicatedProps`函数：
- en: '[PRE30]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, implement the `Tick` function, which displays the value of the `Ammo`
    variable:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现`Tick`函数，它显示`Ammo`变量的值：
- en: '[PRE31]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'At the end of the `SetupPlayerInputController` function, bind the `Fire` action
    to the `ServerFire` function:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SetupPlayerInputController`函数的末尾，将`Fire`动作绑定到`ServerFire`函数：
- en: '[PRE32]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Implement the fire Server RPC validation function:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现火焰服务器RPC验证函数：
- en: '[PRE33]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Implement the fire Server RPC implementation function:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现火焰服务器RPC实现函数：
- en: '[PRE34]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, add the logic to abort the function if the fire timer is still active
    since we fired the last shot:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加逻辑以在发射最后一发子弹后，如果火焰计时器仍然活跃，则中止函数：
- en: '[PRE35]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Check whether the character has ammo. If it doesn’t, then play `NoAmmoSound`
    only in the client that controls the character and abort the function:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查角色是否有弹药。如果没有，则只在该控制角色的客户端播放`NoAmmoSound`并中止函数：
- en: '[PRE36]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Deduct the ammo and schedule the `FireTimer` variable to prevent this function
    from being spammed while playing the fire animation:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减去弹药并安排`FireTimer`变量以防止在播放火焰动画时重复使用此功能：
- en: '[PRE37]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Call the fire Multicast RPC to make all the clients play the fire animation:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用火焰多播RPC以使所有客户端播放火焰动画：
- en: '[PRE38]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Implement the fire Multicast RPC, which will play the fire animation montage:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现播放火焰动画蒙版的火焰多播RPC：
- en: '[PRE39]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Implement the Client RPC that plays a 2D sound:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现播放2D声音的客户端RPC：
- en: '[PRE40]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Finally, you can launch the project in the editor.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在编辑器中启动项目。
- en: Compile the code and wait for the editor to fully load.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码并等待编辑器完全加载。
- en: 'Go to **Project Settings**, go to **Engine**, then **Input**, and add the **Fire**
    action binding:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**项目设置**，然后是**引擎**，接着是**输入**，并添加**Fire**动作绑定：
- en: '![Figure 17.2 – Adding the new Fire action binding ](img/Figure_17.02_B18531.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图17.2 – 添加新的火焰动作绑定](img/Figure_17.02_B18531.jpg)'
- en: Figure 17.2 – Adding the new Fire action binding
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2 – 添加新的火焰动作绑定
- en: Close **Project Settings**.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭**项目设置**。
- en: In the `Content` folder, create a new folder called `Audio`, and open it.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content`文件夹中，创建一个名为`Audio`的新文件夹，并打开它。
- en: Click the `Exercise17.01\Assets` folder, and import `NoA``mmo.wav` and `Fire.wav`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Exercise17.01\Assets`文件夹，并导入`NoAmmo.wav`和`Fire.wav`。
- en: Save both files.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存这两个文件。
- en: Go to the `Content\Characters\Mannequins\Animations` folder.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`Content\Characters\Mannequins\Animations`文件夹。
- en: Click the `Exercise17.01\Assets` folder, and import the `ThirdPersonFire.fbx`
    file. Make sure it’s using the `SK_Mannequin` skeleton and click **Import**.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Exercise17.01\Assets`文件夹，并导入`ThirdPersonFire.fbx`文件。确保它使用`SK_Mannequin`骨架，然后点击**导入**。
- en: Open the new animation and put a `Play Sound` anim notify at `0.3` seconds using
    the `Fire` sound.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新的动画，并在`0.3`秒处使用`Fire`声音添加一个`Play Sound` anim notify。
- en: On the **Details** panel, find the **Enable Root Motion** option and set it
    to **true**. This will prevent the character from moving when playing the animation.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，找到**启用根运动**选项并将其设置为**true**。这将防止角色在播放动画时移动。
- en: Save and close `ThirdPersonFire`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`ThirdPersonFire`。
- en: '*Right-click* on `ThirdPersonFire` and pick **Create** | **Create AnimMontage**.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击* `ThirdPersonFire` 并选择**创建** | **创建 AnimMontage**。'
- en: 'The `Animations` folder should look like this:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Animations`文件夹应该看起来像这样：'
- en: '![Figure 17.3 – The Animations folder for the Mannequin ](img/Figure_17.03_B18531.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.3 – 管理员的动画文件夹](img/Figure_17.03_B18531.jpg)'
- en: Figure 17.3 – The Animations folder for the Mannequin
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.3 – 管理员的动画文件夹
- en: Open `ABP_Manny` and go to `AnimGraph`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ABP_Manny`并转到`AnimGraph`。
- en: 'Find the `Control Rig` node and set `Alpha` to `0.0` to disable the automatic
    feet adjustment. You should get the following output:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`Control Rig`节点并将`Alpha`设置为`0.0`以禁用自动脚部调整。你应该得到以下输出：
- en: '![Figure 17.4 – Disabling the feet adjustment ](img/Figure_17.04_B18531.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.4 – 禁用脚部调整](img/Figure_17.04_B18531.jpg)'
- en: Figure 17.4 – Disabling the feet adjustment
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.4 – 禁用脚部调整
- en: Save and close `ABP_Manny`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`ABP_Manny`。
- en: Open `SK_Mannequin` in the `Content\Characters\Mannequins\Meshes` folder and
    retarget (as shown in *Exercise 16.04*) the `root` and `pelvis` bones so that
    they use `Animation`. The remaining bones should use `Skeleton`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content\Characters\Mannequins\Meshes`文件夹中打开`SK_Mannequin`，并重新定位（如图 *练习 16.04*
    所示）`root`和`pelvis`骨骼，以便它们使用`Animation`。其余骨骼应使用`Skeleton`。
- en: Save and close `SK_Mannequin`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`SK_Mannequin`。
- en: Go to `Content\ThirdPerson\Blueprints` and open the `BP_T``hirdPersonCharacter`
    blueprint.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Content\ThirdPerson\Blueprints`并打开`BP_ThirdPersonCharacter`蓝图。
- en: In `Class Defaults`, set `No Ammo Sound` to use `NoAmmo`, and set `Fire Anim
    Montage` to use `ThirdPersonFire_Montage`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Class Defaults`中，将`No Ammo Sound`设置为使用`NoAmmo`，并将`Fire Anim Montage`设置为使用`ThirdPersonFire_Montage`。
- en: Save and close `BP_ThirdPersonCharacter`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`BP_ThirdPersonCharacter`。
- en: Go to `2`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`2`。
- en: Set the window size to `800x600` and play using **New Editor Window (PIE)**.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将窗口大小设置为`800x600`，并使用**新编辑器窗口 (PIE)** 播放。
- en: 'You should get the following output:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 17.5 – The result of this exercise ](img/Figure_17.05_B18531.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.5 – 本练习的结果](img/Figure_17.05_B18531.jpg)'
- en: Figure 17.5 – The result of this exercise
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.5 – 本练习的结果
- en: By completing this exercise, you can play on each client. Every time you press
    the left mouse button, the character of the client will play the `1`. If you try
    to fire when the ammo is `0`, that client will hear `No Ammo Sound` and won’t
    do the fire animation, because the server didn’t call the Multicast RPC. If you
    try to spam the fire button, you’ll notice that it will only trigger a new fire
    once the animation has finished.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你可以在每个客户端上玩游戏。每次你按下鼠标左键，客户端的角色将播放`1`。如果你在弹药为`0`时尝试开火，该客户端将听到`No Ammo
    Sound`，并且不会执行开火动画，因为服务器没有调用 Multicast RPC。如果你尝试连续按开火按钮，你会注意到它只会在新动画完成时触发一次开火。
- en: In this section, you learned how to use all of the different types of RPCs and
    their caveats. In the next section, we will look at enumerations and how to expose
    them to the editor.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何使用所有不同类型的 RPC 以及它们的注意事项。在下一节中，我们将探讨枚举以及如何将它们暴露给编辑器。
- en: Exposing enumerations to the editor
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将枚举暴露给编辑器
- en: An enumeration is a user-defined data type that holds a list of integer constants,
    where each item has a human-friendly name assigned by you, which makes the code
    easier to read. As an example, if we wanted to represent the different states
    that a character can be in, we could use an integer variable where `0` means it’s
    idle, `1` means it’s walking, and so on. The problem with this approach is that
    when you see code such as `if(State == 0)`, it’s hard to remember what `0` means
    unless you are using some type of documentation or comments to help you. To fix
    this problem, you should use enumerations, where you can write code such as `if(State
    == EState::Idle)`, which is much more explicit and easier to understand.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是一种用户定义的数据类型，它包含一个整数常数的列表，其中每个项目都由你分配一个人类友好的名称，这使得代码更容易阅读。例如，如果我们想表示一个角色可以处于的不同状态，我们可以使用一个整数变量，其中`0`表示空闲，`1`表示行走，依此类推。这种方法的缺点是，当你看到像`if(State
    == 0)`这样的代码时，除非你使用某种类型的文档或注释来帮助你，否则很难记住`0`代表什么。为了解决这个问题，你应该使用枚举，你可以编写像`if(State
    == EState::Idle)`这样的代码，这更加明确且易于理解。
- en: In C++, you have two types of enums – the older raw enums and the new enum classes,
    which were introduced in C++11\. If you want to use the new enum classes in the
    editor, your first instinct might be to do it in the typical way, which is by
    declaring a variable or a function that uses the enumeration with `UPROPERTY`
    or `UFUNCTION`, respectively.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，你有两种类型的枚举 - 较旧的原始枚举和 C++11 中引入的新枚举类。如果你想在编辑器中使用新的枚举类，你的第一反应可能是以典型的方式去做，即通过使用枚举的变量或函数声明
    `UPROPERTY` 或 `UFUNCTION`。
- en: 'The problem is, if you try to do that, you’ll get a compilation error. Take
    a look at the following example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，如果你尝试这样做，你会得到一个编译错误。看看下面的示例：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code snippet, we’ve declared an enum class called `ETestEnum`
    that has three possible values – `EnumValue1`, `EnumValue2`, and `EnumValue3`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了一个名为 `ETestEnum` 的枚举类，它有三个可能的值 - `EnumValue1`、`EnumValue2` 和
    `EnumValue3`。
- en: 'After that, try either of the following examples inside a class:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，尝试在类内部执行以下任一示例：
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the preceding code snippet, we declared a `UPROPERTY` variable and a `UFUNCTION`
    function that uses the `ETestEnum` enumeration. If you try to compile, you’ll
    get the following compilation error:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了一个 `UPROPERTY` 变量和一个使用 `ETestEnum` 枚举的 `UFUNCTION` 函数。如果你尝试编译，你会得到以下编译错误：
- en: '[PRE43]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Unreal Engine, it’s good practice to prefix the name of an enumeration with
    the letter `E`. For example, you could have `EWeaponType` and `EAmmoType`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unreal Engine 中，一个好的做法是在枚举名称前加上字母 `E`。例如，你可以有 `EWeaponType` 和 `EAmmoType`。
- en: This error happens because when you try to expose a class, struct, or enumeration
    to the editor with the `UPROPERTY` or `UFUNCTION` macro, you need to add it to
    the Unreal Engine Reflection System by using the `UCLASS`, `USTRUCT`, and `UENUM`
    macros, respectively.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误发生是因为当你尝试使用 `UPROPERTY` 或 `UFUNCTION` 宏将类、结构体或枚举暴露给编辑器时，你需要通过使用 `UCLASS`、`USTRUCT`
    和 `UENUM` 宏分别将其添加到 Unreal Engine 反射系统中。
- en: Note
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about the Unreal Engine Reflection System at [https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection](https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection](https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection)
    上了解更多关于 Unreal Engine 反射系统的内容。
- en: 'With that knowledge in mind, it is simple to fix the previous error. Just do
    the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个知识，修复前面的错误很简单。只需做以下操作：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the next section, we will look at the `TEnumAsByte` type.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨 `TEnumAsByte` 类型。
- en: TEnumAsByte
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TEnumAsByte
- en: If you want to expose a variable to the engine that uses a raw enum, then you
    need to use the `TEnumAsByte` type. If you declare a `UPROPERTY` variable using
    a raw enum (not enum classes), you’ll get a compilation error.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将一个使用原始枚举的变量暴露给引擎，那么你需要使用 `TEnumAsByte` 类型。如果你使用原始枚举（不是枚举类）声明一个 `UPROPERTY`
    变量，你会得到一个编译错误。
- en: 'Have a look at the following example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的示例：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let’s say you declare a `UPROPERTY` variable using `ETestRawEnum`, like so:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你使用 `ETestRawEnum` 声明一个 `UPROPERTY` 变量，就像这样：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You’ll get the following compilation error:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到以下编译错误：
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To fix this error, you need to surround the enum type of the variable, which
    in this case is `ETestRawEnum`, with `TEnumAsByte<>`, like so:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个错误，你需要将变量的枚举类型（在这种情况下是 `ETestRawEnum`）用 `TEnumAsByte<>` 包围起来，如下所示：
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the next section, we will look at the `UMETA` macro.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨 `UMETA` 宏。
- en: UMETA
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UMETA
- en: When you use the `UENUM` macro to add an enumeration to the Unreal Engine Reflection
    System, you can use the `UMETA` macro on each value of the enum. The `UMETA` macro,
    just like with other macros, such as `UPROPERTY` or `UFUNCTION`, can use specifiers
    that will inform Unreal Engine of how to handle that value. Let’s look at the
    most commonly used `UMETA` specifiers.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `UENUM` 宏将枚举添加到 Unreal Engine 反射系统时，你可以在枚举的每个值上使用 `UMETA` 宏。与 `UPROPERTY`
    或 `UFUNCTION` 等其他宏一样，`UMETA` 宏可以使用指定符来通知 Unreal Engine 如何处理该值。让我们看看最常用的 `UMETA`
    指定符。
- en: DisplayName
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DisplayName
- en: This specifier allows you to define a new name that is easier to read for the
    enum value when it’s displayed in the editor.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指定符允许你定义一个新名称，当它在编辑器中显示时，枚举值更容易阅读。
- en: 'Take a look at the following example:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的示例：
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let’s declare the following variable:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明以下变量：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When you open the editor and look at the `TestEnum` variable, you will see a
    dropdown where `EnumValue1`, `EnumValue2`, and `EnumValue3` have been replaced
    with `My First Option`, `My Second Option`, and `My Third Option`, respectively.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开编辑器并查看 `TestEnum` 变量时，你会看到一个下拉菜单，其中 `EnumValue1`、`EnumValue2` 和 `EnumValue3`
    分别被 `My First Option`、`My Second Option` 和 `My Third Option` 替换。
- en: Hidden
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐藏
- en: This specifier allows you to hide a specific enum value from the dropdown. This
    is typically used when there is an enum value that you only want to be able to
    use in C++ and not in the editor.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此指定符允许您从下拉菜单中隐藏特定的枚举值。这通常用于存在一个枚举值，您只想在 C++ 中使用它，而不在编辑器中使用。
- en: 'Take a look at the following example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下示例：
- en: '[PRE51]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let’s declare the following variable:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明以下变量：
- en: '[PRE52]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When you open the editor and look at the `TestEnum` variable, you will see a
    dropdown. You should notice that `My Second Option` doesn’t appear in the dropdown
    and therefore can’t be selected.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开编辑器并查看 `TestEnum` 变量时，你会看到一个下拉菜单。你应该注意到 `My Second Option` 没有出现在下拉菜单中，因此无法选择。
- en: Note
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on all of the UMETA specifiers, visit [https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/#enummetadataspecifiers](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/#enummetadataspecifiers).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 有关所有 UMETA 指定符的更多信息，请访问 [https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/#enummetadataspecifiers](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/#enummetadataspecifiers)。
- en: In the next section, we will look at the `BlueprintType` specifier for the `UENUM`
    macro.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨 `UENUM` 宏的 `BlueprintType` 指定符。
- en: BlueprintType
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BlueprintType
- en: 'This `UENUM` specifier will expose the enumeration to blueprints. This means
    that there will be an entry for that enumeration in the dropdown that is used
    when making new variables or inputs/outputs for a function, as shown in the following
    example:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `UENUM` 指定符会将枚举暴露给蓝图。这意味着在创建新变量或函数的输入/输出时，下拉菜单中会有该枚举的条目，如下面的示例所示：
- en: '![Figure 17.6 – Setting a variable to use the ETestEnum variable type ](img/Figure_17.06_B18531.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.6 – 将变量设置为使用 ETestEnum 变量类型](img/Figure_17.06_B18531.jpg)'
- en: Figure 17.6 – Setting a variable to use the ETestEnum variable type
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.6 – 将变量设置为使用 ETestEnum 变量类型
- en: 'It will also create additional functions that you can call on the enumeration
    in the editor, as shown in the following example:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 它还会创建额外的函数，你可以在编辑器中对枚举调用这些函数，如下面的示例所示：
- en: '![Figure 17.7 – List of additional functions available when using BlueprintType
    ](img/Figure_17.07_B18531.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.7 – 使用 BlueprintType 时可用的附加函数列表](img/Figure_17.07_B18531.jpg)'
- en: Figure 17.7 – List of additional functions available when using BlueprintType
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.7 – 使用 BlueprintType 时可用的附加函数列表
- en: MAX
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MAX
- en: When using enumerations, it’s common to want to know how many values it has.
    In Unreal Engine, the standard way of doing this is by adding `MAX` as the last
    value, which will be automatically hidden in the editor.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用枚举时，通常想知道它有多少个值。在 Unreal Engine 中，执行此操作的标准方法是在最后添加 `MAX` 作为值，它将在编辑器中自动隐藏。
- en: 'Take a look at the following example:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下示例：
- en: '[PRE53]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If you want to know how many values `ETestEnum` has in C++, you just need to
    do the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道 C++ 中 `ETestEnum` 有多少个值，你只需要做以下操作：
- en: '[PRE54]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This works because enumerations in C++ are internally stored as numbers, where
    the first value is `0`, the second is `1`, and so on. This means that so long
    as `MAX` is the last value, it will always have the total number of values in
    the enumeration. An important thing to take into consideration is that for `MAX`
    to give you the correct value, you cannot change the internal numbering order
    of the enumeration, like so:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为 C++ 中的枚举在内部存储为数字，其中第一个值是 `0`，第二个是 `1`，依此类推。这意味着只要 `MAX` 是最后一个值，它就总是具有枚举中的值总数。需要考虑的一个重要事项是，为了使
    `MAX` 提供正确的值，您不能更改枚举的内部编号顺序，如下所示：
- en: '[PRE55]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this case, `MAX` will be `101` because it will use the number immediately
    next to the previous value, which is `EnumValue3 = 100`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`MAX` 将是 `101`，因为它将使用紧邻前一个值（`EnumValue3 = 100`）的数字。
- en: Using `MAX` is only meant to be used in C++ and not in the editor because the
    `MAX` value is hidden in blueprints, as mentioned previously. To get the number
    of entries of an enumeration in blueprints, you should use the `BlueprintType`
    specifier in the `UENUM` macro to expose some useful functions on the context
    menu. After that, you just need to type the name of your enumeration in the context
    menu. If you select the **Get number of entries in ETestEnum** option, you will
    have a function that returns the number of entries of that enumeration.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `MAX` 仅适用于 C++ 而不是编辑器，因为 `MAX` 值在蓝图中被隐藏，如前所述。要在蓝图中获取枚举的条目数，应在 `UENUM` 宏中使用
    `BlueprintType` 指定符来在上下文菜单中公开一些有用的函数。之后，您只需在上下文菜单中键入您枚举的名称。如果您选择 **Get number
    of entries in ETestEnum** 选项，您将有一个返回该枚举条目数的函数。
- en: In the next exercise, you will be using C++ enumerations in the editor.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将在编辑器中使用 C++ 枚举。
- en: Exercise 17.02 – Using C++ enumerations in the editor
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 17.02 – 在编辑器中使用 C++ 枚举
- en: 'In this exercise, we’re going to create a new **C++** project that uses the
    **Third Person** template. We’re going to add the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个新的 **C++** 项目，该项目使用 **第三人称** 模板。我们将添加以下内容：
- en: An enumeration called `EWeaponType` that contains **three** weapons – a pistol,
    a shotgun, and a rocket launcher.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `EWeaponType` 的枚举，包含 **三种** 武器 – 手枪、霰弹枪和火箭发射器。
- en: An enumeration called `EAmmoType` that contains **3** ammo types – bullets,
    shells, and rockets.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `EAmmoType` 的枚举，包含 **3** 种弹药类型 – 子弹、炮弹和火箭。
- en: A variable called `Weapon` that uses `EWeaponType` to tell the type of the current
    weapon.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `Weapon` 的变量，使用 `EWeaponType` 来表示当前武器的类型。
- en: An integer array variable called `Ammo` that holds the amount of ammo for each
    type, which is initialized with a value of `10`.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `Ammo` 的整型数组变量，用于存储每种类型的弹药数量，其初始值为 `10`。
- en: When the player presses the `1`, `2`, or `3` key, the `Weapon` variable will
    be set to `Pistol`, `Shotgun`, or `Rocket Launcher`, respectively.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家按下 `1`、`2` 或 `3` 键时，`Weapon` 变量将被设置为 `Pistol`、`Shotgun` 或 `Rocket Launcher`。
- en: When the player presses the left mouse button, the ammo for the current weapon
    will be consumed.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家按下左鼠标按钮时，当前武器的弹药将被消耗。
- en: With every `Tick` function call, the character will display the current weapon
    type and the equivalent ammo type and amount.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次调用 `Tick` 函数时，角色将显示当前武器类型和等效的弹药类型和数量。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: Create a new `Enumerations` and save it to a location of your liking.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `Enumerations` 并将其保存到您喜欢的位置。
- en: Once the project has been created, it should open the editor as well as the
    Visual Studio solution.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建项目，它应该也会打开编辑器和 Visual Studio 解决方案。
- en: Close the editor and go back to Visual Studio.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭编辑器并返回 Visual Studio。
- en: Open the `Enumerations.h` file.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Enumerations.h` 文件。
- en: 'Create a macro called `ENUM_TO_INT32` that will convert an enumeration into
    an `int32` data type:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ENUM_TO_INT32` 的宏，该宏将枚举转换为 `int32` 数据类型：
- en: '[PRE56]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a macro called `ENUM_TO_FSTRING` that will get the display name for
    a value of an `enum` data type and convert it into an `FString` datatype:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `ENUM_TO_FSTRING` 的宏，该宏将获取枚举数据类型值的显示名称并将其转换为 `FString` 数据类型：
- en: '[PRE57]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Declare the `EWeaponType` and `EammoType` enumerations:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `EWeaponType` 和 `EammoType` 枚举：
- en: '[PRE58]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Open the `EnumerationsCharacter.h` file and add the `Enumerations.h` header
    before `EnumerationsCharacter.generated.h`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `EnumerationsCharacter.h` 文件，在 `EnumerationsCharacter.generated.h` 之前添加 `Enumerations.h`
    头文件：
- en: '[PRE59]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Declare the protected `Weapon` variable that holds the weapon type of the selected
    weapon:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的 `Weapon` 变量，用于存储所选武器的武器类型：
- en: '[PRE60]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Declare the protected `Ammo` array that holds the amount of ammo for each type:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的 `Ammo` 数组，用于存储每种类型的弹药数量：
- en: '[PRE61]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Declare the protected overrides for the `Begin Play` and `Tick` functions:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `Begin Play` 和 `Tick` 函数的受保护重写：
- en: '[PRE62]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Declare the protected input functions:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的输入函数：
- en: '[PRE63]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Open the `EnumerationsCharacter.cpp` file and bind the new action bindings
    at the end of the `SetupPlayerInputController` function, as shown in the following
    code snippet:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `EnumerationsCharacter.cpp` 文件，并在 `SetupPlayerInputController` 函数的末尾绑定新的动作绑定，如下面的代码片段所示：
- en: '[PRE64]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, implement the override for `BeginPlay` that executes the parent logic,
    but also initializes the size of the `Ammo` array with the number of entries in
    the `EAmmoType` enumeration. Each position in the array will also be initialized
    with a value of `10`:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现对`BeginPlay`的覆盖，它执行父逻辑，但同时也初始化`Ammo`数组的大小为`EAmmoType`枚举中的条目数。数组的每个位置也将初始化为`10`的值：
- en: '[PRE65]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Implement the override for `Tick`:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现对`Tick`的覆盖：
- en: '[PRE66]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Convert the `Weapon` variable into `int32` and the `Weapon` variable into an
    `FString`:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Weapon`变量转换为`int32`并将`Weapon`变量转换为`FString`：
- en: '[PRE67]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Convert the ammo type into an `FString` and get the ammo count for the current
    weapon:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将弹药类型转换为`FString`并获取当前武器的弹药数量：
- en: '[PRE68]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We are using `Weapon` to get the ammo type string because the entries in `EAmmoType`
    match the type of ammo of the equivalent `EWeaponType`. In other words, `Pistol
    = 0` uses `Bullets = 0`, `Shotgun = 1` uses `Shells = 1`, and `RocketLauncher
    = 2` uses `Rockets = 2`, so it’s a 1-to-1 mapping that we can use in our favor.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Weapon`来获取弹药类型字符串，因为`EAmmoType`中的条目与等效`EWeaponType`的弹药类型相匹配。换句话说，`Pistol
    = 0`使用`Bullets = 0`，`Shotgun = 1`使用`Shells = 1`，`RocketLauncher = 2`使用`Rockets
    = 2`，因此这是一个我们可以利用的1对1映射。
- en: 'Display the name of the current weapon in the character’s location and its
    corresponding ammo type and ammo count, as shown in the following code snippet:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在角色的位置显示当前武器的名称及其对应的弹药类型和弹药数量，如下代码片段所示：
- en: '[PRE69]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Implement the equip input functions that set the `Weapon` variable with the
    corresponding value:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现设置`Weapon`变量的装备输入函数：
- en: '[PRE70]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Implement the fire input function that will use the weapon index to get the
    corresponding ammo type count and subtract `1`, so long as the resulting value
    is greater than or equal to 0:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个使用武器索引来获取相应弹药类型数量并减去`1`的火输入函数，只要结果值大于或等于0：
- en: '[PRE71]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Compile the code and run the editor.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码并运行编辑器。
- en: 'Go to **Project Settings**, go to **Engine**, then **Input**, and add the new
    action bindings:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**项目设置**，然后进入**引擎**，接着**输入**，并添加新的动作绑定：
- en: '![Figure 17.8 – Adding the Pistol, Shotgun, Rocket Launcher, and Fire bindings
    ](img/Figure_17.08_B18531.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图17.8 – 添加手枪、霰弹枪、火箭发射器和火绑定](img/Figure_17.08_B18531.jpg)'
- en: Figure 17.8 – Adding the Pistol, Shotgun, Rocket Launcher, and Fire bindings
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.8 – 添加手枪、霰弹枪、火箭发射器和火绑定
- en: Close **Project Settings**.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭**项目设置**。
- en: 'Make sure the `1`. Click on **New Editor Window (PIE)**; you should get the
    following result:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保点击**新建编辑器窗口（PIE**）；你应该得到以下结果：
- en: '![Figure 17.9 – The result of this exercise ](img/Figure_17.09_B18531.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图17.9 – 此练习的结果](img/Figure_17.09_B18531.jpg)'
- en: Figure 17.9 – The result of this exercise
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.9 – 此练习的结果
- en: By completing this exercise, you can use the `0`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成此练习，你可以使用`0`。
- en: In this section, you learned how to expose enumerations to the editor so that
    you can use them in blueprints. In the next section, we will look at array index
    wrapping, which allows you to iterate an array beyond its limits and wrap it back
    around from the other side.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何将枚举暴露给编辑器，以便你可以在蓝图中使用它们。在下一节中，我们将探讨数组索引环绕，这允许你迭代数组超过其限制，并从另一侧环绕回来。
- en: Using array index wrapping
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组索引环绕
- en: 'Sometimes, when you use arrays to store information, you may want to iterate
    it in both directions and be able to wrap the index so that it doesn’t go beyond
    the index limit and crash the game. An example of this is the previous/next weapon
    logic in shooter games, where you have an array of weapons and you want to be
    able to cycle through them in a particular direction, and when you reach the first
    or the last index, you want to loop back around to the last and first index, respectively.
    The typical way of doing this would be as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你使用数组存储信息时，你可能希望双向迭代它，并能够环绕索引，以便它不会超出索引限制并导致游戏崩溃。一个例子是射击游戏中的上一个/下一个武器逻辑，其中你有一个武器数组，并且你想要能够按特定方向循环遍历它们，当你到达第一个或最后一个索引时，你想要分别循环回到最后一个和第一个索引。典型的做法如下：
- en: '[PRE72]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the preceding code, we set the `WeaponIndex` variable (declared as a member
    of the class) to loop back if the new weapon index is outside the limits of the
    weapons array, which can happen in two cases. The first case is when the player
    has the last weapon of the inventory equipped and we want the next weapon. In
    this case, it should go back to the first weapon.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将`WeaponIndex`变量（作为类的成员声明）设置为当新的武器索引超出武器数组的限制时循环回，这可能在两种情况下发生。第一种情况是当玩家装备了库存中的最后一件武器，我们想要下一件武器。在这种情况下，它应该回到第一件武器。
- en: The second case is when the player has the first weapon of the inventory equipped
    and we want the previous weapon. In this case, it should go to the last weapon.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况是当玩家装备了库存中的第一件武器，我们想要前一个武器。在这种情况下，它应该跳到最后一件武器。
- en: While the example code works, it’s still quite a lot of code to solve such a
    trivial problem. To improve this code, there is a mathematical operation that
    will help you handle these two cases automatically in just one function. It’s
    called the modulo (represented in C++ by the `%` operator), which gives you the
    remainder of a division between two numbers.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然示例代码是可行的，但它仍然需要相当多的代码来解决这样一个简单的问题。为了改进这段代码，有一个数学运算可以帮助你在单个函数中自动处理这两种情况。它被称为取模（在C++中由`%`运算符表示），它给出了两个数字相除的余数。
- en: 'So, how do we use the modulo to wrap the index of an array? Let’s rewrite the
    previous example using the modulo operator:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何使用取模运算来包裹数组的索引呢？让我们使用取模运算符重写之前的例子：
- en: '[PRE73]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This is the new version, and you can tell right away that it’s a bit harder
    to understand, but it’s more functional and compact. If you don’t use the variables
    to store the intermediate values of each operation, you can probably make the
    entire function in one or two lines of code.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新版本，你可以立刻看出它稍微难懂一些，但功能更强大，结构更紧凑。如果你不使用变量来存储每个操作的中间值，你可能只用一行或两行代码就能完成整个函数。
- en: 'Let’s break down the preceding code snippet:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解前面的代码片段：
- en: '`const int WeaponCount = Weapons.Num()`: We need to know the size of the array
    to determine the index where it should go back to `0`. In other words, if `WeaponCount
    = 4`, then the array has the `0`, `1`, `2`, and `3` indexes, which tells us that
    index `4` is the cutoff index where it should go back to `0`.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const int WeaponCount = Weapons.Num()`：我们需要知道数组的大小，以确定它应该回到哪个索引。换句话说，如果`WeaponCount
    = 4`，那么数组有`0`、`1`、`2`和`3`索引，这告诉我们索引`4`是截止索引，它应该回到`0`。'
- en: '`const int32 NewRawIndex = WeaponIndex + Direction`: This is the new raw index
    that doesn’t care about the limits of the array. The `Direction` variable is used
    to indicate the offset we want to add to the current index of the array. This
    is either `-1` if we want the previous index or `1` if we want the next index.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const int32 NewRawIndex = WeaponIndex + Direction`：这是新的原始索引，它不考虑数组的限制。`Direction`变量用于指示我们想要添加到当前数组索引的偏移量。这可以是`-1`，如果我们想要前一个索引，或者`1`，如果我们想要下一个索引。'
- en: '`const int32 NewWrappedIndex = NewRawIndex % WeaponCount`: This will make sure
    that `NewWrappedIndex` is within the `0` to `WeaponCount - 1` interval and wrap
    around if needed, due to the modulo properties. So, if `NewRawIndex` is `4`, then
    `NewWrappedIndex` will become `0`, because there is no remainder from the division
    of `4 / 4`.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const int32 NewWrappedIndex = NewRawIndex % WeaponCount`：这将确保`NewWrappedIndex`在`0`到`WeaponCount
    - 1`的区间内，并在需要时通过取模属性进行循环。所以，如果`NewRawIndex`是`4`，那么`NewWrappedIndex`将变为`0`，因为`4
    / 4`的除法没有余数。'
- en: 'If `Direction` is always `1`, meaning we only want the next index, then the
    value of `NewWrappedIndex` is enough for what we need. If we also want to use
    `Direction` with `-1`, then we’ll have a problem, because the modulo operation
    won’t wrap the index correctly for negative indexes. So, if `WeaponIndex` is `0`
    and `Direction` is `-1`, then `NewWrappedIndex` will be `-1`, which is not correct.
    To fix this limitation, we need to do some additional calculations:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Direction`始终为`1`，意味着我们只想获取下一个索引，那么`NewWrappedIndex`的值就足够我们所需。如果我们还想使用`Direction`的`-1`，那么我们会遇到问题，因为取模运算不会正确地包裹负索引。所以，如果`WeaponIndex`是`0`且`Direction`是`-1`，那么`NewWrappedIndex`将是`-1`，这是不正确的。为了解决这个问题，我们需要进行一些额外的计算：
- en: '`WeaponIndex = (NewWrappedIndex + WeaponCount) % WeaponCount`: This will add
    `WeaponCount` to `NewWrappedIndex` to make it positive and apply the modulo again
    to get the correct wrapped index, which fixes the problem.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeaponIndex = (NewWrappedIndex + WeaponCount) % WeaponCount`：这将把`WeaponCount`加到`NewWrappedIndex`上使其变为正数，然后再应用取模运算以获得正确的包裹索引，从而解决问题。'
- en: '`return Weapons[WeaponIndex]`: This returns the weapon in the calculated `WeaponIndex`
    index position.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return Weapons[WeaponIndex]`: 这将返回计算出的 `WeaponIndex` 索引位置的武器。'
- en: Let’s take a look at a practical example to help you visualize how all this
    works.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个实际例子来帮助你可视化这一切是如何工作的。
- en: 'Weapons:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 武器：
- en: '`[0] Knife`'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[0] 刀`'
- en: '`[1] Pistol`'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[1] 手枪`'
- en: '`[2] Shotgun`'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[2] 冲锋枪`'
- en: '`[3] Rocket Launcher`'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[3] 火箭筒`'
- en: '`WeaponCount = Weapons.Num()`, so it has a value of `4`.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeaponCount = Weapons.Num()`, 所以它有一个值为 `4`。'
- en: Let’s assume that `WeaponIndex = 3` and `Direction = 1`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `WeaponIndex = 3` 且 `Direction = 1`。
- en: 'Here, we would have the following:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将有以下内容：
- en: '`NewRawIndex = WeaponIndex + Direction`, so `3 + 1 = 4`'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewRawIndex = WeaponIndex + Direction`, 所以 `3 + 1 = 4`'
- en: '`NewWrappedIndex = NewRawIndex % WeaponCount`, so `4 % 4 = 0`'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewWrappedIndex = NewRawIndex % WeaponCount`, 所以 `4 % 4 = 0`'
- en: '`WeaponIndex = (NewWrappedIndex + WeaponCount) % WeaponCount, so (0 + 4) %
    4 = 0`'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeaponIndex = (NewWrappedIndex + WeaponCount) % WeaponCount, 所以 (0 + 4) %
    4 = 0`'
- en: In this example, the starting value for `WeaponIndex` is `3`, which is `Rocket
    Launcher`, and we want the next weapon because `Direction` is set to `1`. Performing
    the calculations, `WeaponIndex` will now be `0`, which is `Knife`. This is the
    desired behavior because we have four weapons, so we circled back to the first
    index. In this case, since `NewRawIndex` is positive, we could’ve just used `NewWrappedIndex`
    without doing the extra calculations.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`WeaponIndex` 的起始值是 `3`，即 `火箭筒`，因为我们想得到下一个武器，因为 `Direction` 被设置为 `1`。进行计算后，`WeaponIndex`
    现在将是 `0`，即 `刀`。这是期望的行为，因为我们有四个武器，所以我们回到了第一个索引。在这种情况下，由于 `NewRawIndex` 是正数，我们可以直接使用
    `NewWrappedIndex` 而不必进行额外的计算。
- en: Let’s debug it again using different values.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用不同的值进行调试。
- en: 'Let’s assume that `WeaponIndex = 0` and `Direction = -1`:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `WeaponIndex = 0` 且 `Direction = -1`：
- en: '`NewRawIndex = WeaponIndex + Direction`, so `0 + -1 = -1`'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewRawIndex = WeaponIndex + Direction`, 所以 `0 + -1 = -1`'
- en: '`NewWrappedIndex = NewIndex % WeaponCount`, so `-1 % 4 = -1`'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewWrappedIndex = NewIndex % WeaponCount`, 所以 `-1 % 4 = -1`'
- en: '`WeaponIndex = (NewWrappedIndex + WeaponCount) % WeaponCount`, so `(-1 + 4)
    % 4 = 3`'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeaponIndex = (NewWrappedIndex + WeaponCount) % WeaponCount`, 所以 `(-1 + 4)
    % 4 = 3`'
- en: In this example, the starting value for `WeaponIndex` is `0`, which is `Knife`,
    and we want the previous weapon because `Direction` is set to -`1`. Doing the
    calculations, `WeaponIndex` will now be `3`, which is `Rocket Launcher`. This
    is the desired behavior because we have four weapons, so we circled back to the
    last index. In this case, since `NewRawIndex` is negative, we can’t just use `NewWrappedIndex`;
    we need to do the extra calculation to get the correct value.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`WeaponIndex` 的起始值是 `0`，即 `刀`，因为我们想得到前一个武器，因为 `Direction` 被设置为 `-1`。进行计算后，`WeaponIndex`
    现在将是 `3`，即 `火箭筒`。这是期望的行为，因为我们有四个武器，所以我们回到了最后一个索引。在这种情况下，由于 `NewRawIndex` 是负数，我们不能直接使用
    `NewWrappedIndex`；我们需要进行额外的计算以获得正确的值。
- en: In the next exercise, you’re going to use the knowledge you’ve acquired to cycle
    between an enumeration of weapons in both directions.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将使用你获得的知识在两个方向上循环枚举武器。
- en: Exercise 17.03 – Using array index wrapping to cycle between an enumeration
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 17.03 – 使用数组索引循环枚举
- en: In this exercise, we’re going to use the project from *Exercise 17.02 – Using
    C++ enumerations in the editor*, and add two new action mappings for cycling the
    weapons. `Mouse Wheel Up` will go to the previous weapon type, while `Mouse Wheel
    Down` will go to the next weapon type.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用来自 *练习 17.02 – 在编辑器中使用 C++ 枚举* 的项目，并添加两个新的动作映射来循环武器。`鼠标滚轮向上` 将转到前一个武器类型，而
    `鼠标滚轮向下` 将转到下一个武器类型。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: First, open the Visual Studio project from *Exercise 17.02 – Using C++ enumerations
    in the editor*.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开来自 *练习 17.02 – 在编辑器中使用 C++ 枚举* 的 Visual Studio 项目。
- en: Next, you will be updating `Enumerations.h` and adding a macro that will handle
    the array index wrapping in a very convenient way.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将更新 `Enumerations.h` 并添加一个宏，它将以非常方便的方式处理数组索引循环。
- en: 'Open `Enumerations.h` and add the `GET_WRAPPED_ARRAY_INDEX` macro. This will
    apply the modulo formula that we covered previously:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Enumerations.h` 并添加 `GET_WRAPPED_ARRAY_INDEX` 宏。这将应用我们之前提到的模运算公式：
- en: '[PRE74]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Open `EnumerationsCharacter.h` and declare the new input functions for the
    weapon cycling:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `EnumerationsCharacter.h` 并声明用于武器循环的新输入函数：
- en: '[PRE75]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Declare the `CycleWeapons` function, as shown in the following code snippet:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `CycleWeapons` 函数，如下代码片段所示：
- en: '[PRE76]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Open `EnumerationsCharacter.cpp` and bind the new action bindings in the `SetupPlayerInputController`
    function:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `EnumerationsCharacter.cpp` 文件，并在 `SetupPlayerInputController` 函数中绑定新的动作绑定：
- en: '[PRE77]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, implement the new input functions, as shown in the following code snippet:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现新的输入函数，如下面的代码片段所示：
- en: '[PRE78]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In the preceding code snippet, we defined the functions that handle the action
    mappings for `Previous Weapon` and `Next Weapon`. Each function uses the `CycleWeapons`
    function, with a direction of `-1` for the previous weapon and `1` for the next
    weapon.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了处理 `Previous Weapon` 和 `Next Weapon` 动作映射的函数。每个函数都使用 `CycleWeapons`
    函数，其中 `-1` 表示上一把武器，`1` 表示下一把武器。
- en: 'Implement the `CycleWeapons` function, which does the array index wrapping
    using the `Direction` parameter based on the current weapon index:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `CycleWeapons` 函数，该函数根据当前武器索引使用 `Direction` 参数进行数组索引回绕：
- en: '[PRE79]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Compile the code and run the editor.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码并运行编辑器。
- en: 'Go to **Project Settings**, go to **Engine**, then **Input**, and add the new
    action bindings:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **项目设置**，然后前往 **引擎**，接着 **输入**，并添加新的动作绑定：
- en: '![Figure 17.10 – Adding the Previous Weapon and Next Weapon bindings ](img/Figure_17.10_B18531.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.10 – 添加上一把武器和下一把武器的绑定](img/Figure_17.10_B18531.jpg)'
- en: Figure 17.10 – Adding the Previous Weapon and Next Weapon bindings
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.10 – 添加上一把武器和下一把武器的绑定
- en: Close **Project Settings**.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 **项目设置**。
- en: 'Make sure that the `1`. Click on **New Editor Window (PIE)**; you should get
    the following result:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保点击 **新编辑器窗口 (PIE)**；你应该得到以下结果：
- en: '![Figure 17.11 – The result of this exercise ](img/Figure_17.11_B18531.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.11 – 本练习的结果](img/Figure_17.11_B18531.jpg)'
- en: Figure 17.11 – The result of this exercise
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.11 – 本练习的结果
- en: By completing this exercise, you can use the mouse wheel to cycle between the
    weapons. If you select the rocket launcher and use the mouse wheel down to go
    to the next weapon, it will go back to the pistol. If you use the mouse wheel
    down to go to the previous weapon with the pistol selected, it will go back to
    the rocket launcher.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你可以使用鼠标滚轮在武器之间循环。如果你选择了火箭发射器，并使用鼠标滚轮向下切换到下一把武器，它将回到手枪。如果你使用鼠标滚轮向下切换到已选择手枪的上一把武器，它将回到火箭发射器。
- en: In the next activity, you will be adding the concept of weapons and ammo to
    the multiplayer FPS project we started in [*Chapter 16*](B18531_16.xhtml#_idTextAnchor345),
    *Getting Started with Multiplayer Basics*.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，你将向我们在 [*第 16 章*](B18531_16.xhtml#_idTextAnchor345) 中开始的多人 FPS 项目中添加武器和弹药的概念，*多人基础入门*。
- en: Activity 17.01 – Adding weapons and ammo to the multiplayer FPS game
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动十七点零一 – 向多人 FPS 游戏添加武器和弹药
- en: In this activity, you’ll add the concept of weapons and ammo to the multiplayer
    FPS project that we started in the previous chapter. You will need to use the
    different types of RPCs covered in this chapter to complete this activity.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，你将向我们在上一章中开始的多人 FPS 项目中添加武器和弹药的概念。你需要使用本章中介绍的不同类型的 RPC 来完成此活动。
- en: 'Follow these steps to complete this activity:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此活动：
- en: Open the `MultiplayerFPS` project from *Activity 16.01 – Creating a character
    for the multiplayer FPS project*.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *活动 16.01 – 为多人 FPS 项目创建角色* 中打开 `MultiplayerFPS` 项目。
- en: Create an `AnimMontage` slot called `Upper Body`.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Upper Body` 的 `AnimMontage` 插槽。
- en: Import the animations (`Pistol_Fire.fbx`, `MachineGun_Fire.fbx`, and `Railgun_Fire.fbx`)
    from the `Activity17.01\Assets` folder into `Content\Player\Animations`.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将动画 (`Pistol_Fire.fbx`、`MachineGun_Fire.fbx` 和 `Railgun_Fire.fbx`) 从 `Activity17.01\Assets`
    文件夹导入到 `Content\Player\Animations`。
- en: 'Create an `AnimMontage` for `Pistol_Fire`, `MachineGun_Fire`, and `Railgun_Fire`,
    and make sure they have the following configurations:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Pistol_Fire`、`MachineGun_Fire` 和 `Railgun_Fire` 创建 `AnimMontage`，并确保它们具有以下配置：
- en: '`Blend In` time of `0.01` and a `Blend Out` time of `0.1`. Make sure it uses
    the `Upper Body` slot.'
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Blend In` 时间为 `0.01`，`Blend Out` 时间为 `0.1`。确保它使用 `Upper Body` 插槽。'
- en: '`Blend In` time of `0.01` and a `Blend Out` time of `0.1`. Make sure it uses
    the `Upper Body` slot.'
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Blend In` 时间为 `0.01`，`Blend Out` 时间为 `0.1`。确保它使用 `Upper Body` 插槽。'
- en: '`Upper Body` slot.'
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Upper Body` 插槽。'
- en: Import `SK_Weapon.fbx` (with Material Import Method set to Create New Materials),
    `NoAmmo.wav`, `WeaponChange.wav`, and `Hit.wav` from the `Activity17.01\Assets`
    folder into `Content\Weapons`.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `SK_Weapon.fbx`（将材质导入方法设置为创建新材质）、`NoAmmo.wav`、`WeaponChange.wav` 和 `Hit.wav`
    从 `Activity17.01\Assets` 文件夹导入到 `Content\Weapons`。
- en: Import `Pistol_Fire_Sound.wav` from `Activity17.01\Assets` into `Content\Weapons\Pistol`
    and use it on `Play Sound` in the `Pistol_Fire` animation.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Activity17.01\Assets`导入`Pistol_Fire_Sound.wav`到`Content\Weapons\Pistol`，并在`Pistol_Fire`动画中的`Play
    Sound`处使用它。
- en: Create a simple green-colored material instance from `M_FPGun` called `MI_Pistol`
    and place it on `Content\Weapons\Pistol`.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`M_FPGun`创建一个简单的绿色材质实例，命名为`MI_Pistol`，并将其放置在`Content\Weapons\Pistol`上。
- en: Import `MachineGun_Fire_Sound.wav` from `Activity17.01\Assets` into `Content\Weapons\MachineGun`
    and use it on `Play Sound` in the `MachineGun_Fire` animation.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Activity17.01\Assets`导入`MachineGun_Fire_Sound.wav`到`Content\Weapons\MachineGun`，并在`MachineGun_Fire`动画中的`Play
    Sound`处使用它。
- en: Create a simple red-colored material instance from `M_FPGun` called `MI_MachineGun`
    and place it on `Content\Weapons\MachineGun`.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`M_FPGun`创建一个简单的红色材质实例，命名为`MI_MachineGun`，并将其放置在`Content\Weapons\MachineGun`上。
- en: Import `Railgun_Fire_Sound.wav` from `Activity17.01\Assets` into `Content\Weapons\Railgun`
    and use it on `Play Sound` in the `Railgun_Fire` animation.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Activity17.01\Assets`导入`Railgun_Fire_Sound.wav`到`Content\Weapons\Railgun`，并在`Railgun_Fire`动画中的`Play
    Sound`处使用它。
- en: Create a simple white-colored material instance from `M_FPGun` called `MI_Railgun`
    and place it on `Content\Weapons\Railgun`.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`M_FPGun`创建一个简单的白色材质实例，命名为`MI_Railgun`，并将其放置在`Content\Weapons\Railgun`上。
- en: Edit the `SK_Mannequin_Skeleton` and create a socket called `GripPoint` from
    `hand_r` with `Relative Location` set to `(X=-10.403845,Y=6.0,Z=-3.124871)` and
    `Relative Rotation` set to `(X=0.0,Y=0.0,Z=90.0)`.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`SK_Mannequin_Skeleton`，从`hand_r`创建一个名为`GripPoint`的插座，将`相对位置`设置为`(X=-10.403845,Y=6.0,Z=-3.124871)`，将`相对旋转`设置为`(X=0.0,Y=0.0,Z=90.0)`。
- en: 'Add the following input actions to `Content\Player\Inputs`, using the knowledge
    you acquired in [*Chapter 4*](B18531_04.xhtml#_idTextAnchor099), *Getting Started
    with Player Input*:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你在[*第4章*](B18531_04.xhtml#_idTextAnchor099)，“玩家输入入门”中获得的知识，将以下输入操作添加到`Content\Player\Inputs`：
- en: '**IA_Fire (Digital)**: *Left Mouse Button*'
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IA_Fire (数字)**: *左鼠标按钮*'
- en: '**IA_Pistol (Digital)**: *1*'
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IA_Pistol (数字)**: *1*'
- en: '**IA_MachineGun (Digital)**: *2*'
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IA_MachineGun (数字)**: *2*'
- en: '**IA_Railgun (Digital)**: *3*'
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IA_Railgun (数字)**: *3*'
- en: '**IA_PreviousWeapon (Digital)**: *Mouse Wheel Up*'
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IA_PreviousWeapon (数字)**: *鼠标滚轮向上*'
- en: '**IA_NextWeapon (Digital)**: *Mouse Wheel Down*'
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IA_NextWeapon (数字)**: *鼠标滚轮向下*'
- en: Add the new input actions to `IMC_Player`.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的输入操作添加到`IMC_Player`。
- en: In `MultiplayerFPS.h`, create the `ENUM_TO_INT32(Enum)` macro, which casts an
    enumeration to `int32`, and the `GET_WRAPPED_ARRAY_INDEX(Index, Count)` macro,
    which uses array indexing wrapping to make sure the index is within the limits
    of the array.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MultiplayerFPS.h`中，创建`ENUM_TO_INT32(Enum)`宏，它将枚举转换为`int32`，以及`GET_WRAPPED_ARRAY_INDEX(Index,
    Count)`宏，它使用数组索引回绕以确保索引在数组的限制范围内。
- en: 'Create a header file called `EnumTypes.h` that holds the following enumerations:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`EnumTypes.h`的头部文件，其中包含以下枚举：
- en: '`Pistol`, `MachineGun`, `Railgun`, `MAX`'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pistol`，`MachineGun`，`Railgun`，`MAX`'
- en: '`Single`, `Automatic`'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`Single`，`Automatic`'
- en: '`PistolBullets`, `MachineGunBullets`, `Slugs`, `MAX`'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`PistolBullets`，`MachineGunBullets`，`Slugs`，`MAX`'
- en: Create a C++ class called `Weapon` that derives from the `Actor` class and has
    a skeletal mesh component called `Mesh` as the root component.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从`Actor`类派生的C++类`Weapon`，其根组件是一个骨骼网格组件`Mesh`。
- en: In terms of variables, it stores the name, the weapon type, the ammo type, the
    fire mode, how far the hitscan goes, how much damage the hitscan does when it
    hits, the fire rate, the animation montage to use when firing, and the sound to
    play when it has no ammo. In terms of functionality, it needs to be able to start
    the fire (and also stop the fire, because of the automatic fire mode), which checks
    whether the player can fire. If it can, then it plays the fire animation in all
    of the clients and shoots a line trace in the camera position and direction with
    the supplied length to damage the actor it hits. If it doesn’t have ammo, it will
    play a sound only on the owning client.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量方面，它存储名称、武器类型、弹药类型、射击模式、击中扫描的距离、击中时造成的伤害、射击速率、射击时使用的动画蒙太奇以及没有弹药时播放的声音。在功能方面，它需要能够开始射击（以及停止射击，因为自动射击模式），这会检查玩家是否可以射击。如果可以，则在整个客户端播放射击动画，并在摄像机位置和方向上使用提供的长度进行射线投射，以损坏击中的演员。如果没有弹药，它将仅在拥有客户端上播放声音。
- en: Edit `FPSCharacter` so that it supports the new input actions for `Fire`, `Pistol`,
    `Machine Gun`, `Railgun`, `Previous Weapon`, and `Next Weapon`. In terms of variables,
    it needs to store the amount of ammo for each type, the currently equipped weapon,
    all of the weapons classes and spawned instances, the sound to play when it hits
    another player, and the sound when it changes weapons. In terms of functions,
    it needs to be able to equip/cycle/add weapons, manage ammo (add, remove, and
    get), handle when the character is damaged, play an anim montage on all of the
    clients, and play a sound on the owning client.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `FPSCharacter`，使其支持新的 `Fire`、`Pistol`、`Machine Gun`、`Railgun`、`Previous Weapon`
    和 `Next Weapon` 输入动作。在变量方面，它需要存储每种类型的弹药数量、当前装备的武器、所有武器类别和生成的实例、击中其他玩家时播放的声音以及更换武器时的声音。在功能方面，它需要能够装备/循环/添加武器、管理弹药（添加、移除和获取）、处理角色受伤时的情况、在所有客户端上播放动画剪辑，以及在拥有客户端上播放声音。
- en: 'Create `BP_Pistol` from `AWeapon`, place it on `Content\Weapons\Pistol`, and
    configure it with the following values:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `AWeapon` 创建 `BP_Pistol`，将其放置在 `Content\Weapons\Pistol`，并使用以下值进行配置：
- en: '`Content\Weapons\SK_Weapon`'
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Weapons\SK_Weapon`'
- en: '`Content\Weapons\Pistol\MI_Pistol`'
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Weapons\Pistol\MI_Pistol`'
- en: '`Pistol Mk I`'
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pistol Mk I`'
- en: '`Pistol`'
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pistol`'
- en: '`Pistol Bullets`'
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pistol Bullets`'
- en: '`Automatic`'
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Automatic`'
- en: '`9999.9`, `5.0`, `0.5`'
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`9999.9`, `5.0`, `0.5`'
- en: '`Content\Player\Animations\Pistol_Fire_Montage`'
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Player\Animations\Pistol_Fire_Montage`'
- en: '`Content\Weapons\NoAmmo`'
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Weapons\NoAmmo`'
- en: 'Create `BP_MachineGun` from `Aweapon`, place it on `Content\Weapons\MachineGun`,
    and configure it with the following values:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Aweapon` 创建 `BP_MachineGun`，将其放置在 `Content\Weapons\MachineGun`，并使用以下值进行配置：
- en: '`Content\Weapons\SK_Weapon`'
  id: totrans-450
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Weapons\SK_Weapon`'
- en: '`Content\Weapons\MachineGun\MI_MachineGun`'
  id: totrans-451
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Weapons\MachineGun\MI_MachineGun`'
- en: '`Machine Gun Mk I`'
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Machine Gun Mk I`'
- en: '`Machine Gun`'
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Machine Gun`'
- en: '`Machine Gun Bullets`'
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Machine Gun Bullets`'
- en: '`Automatic`'
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Automatic`'
- en: '`9999.9`, `5.0`, `0.1`'
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`9999.9`, `5.0`, `0.1`'
- en: '`Content\Player\Animations\MachineGun_Fire_Montage`'
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Player\Animations\MachineGun_Fire_Montage`'
- en: '`Content\Weapons\NoAmmo`'
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Weapons\NoAmmo`'
- en: 'Create `BP_Railgun` from `Aweapon`, place it on `Content\Weapons\Railgun`,
    and configure it with the following values:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Aweapon` 创建 `BP_Railgun`，将其放置在 `Content\Weapons\Railgun`，并使用以下值进行配置：
- en: '`Content\Weapons\SK_Weapon`'
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Weapons\SK_Weapon`'
- en: '`Content\Weapons\Railgun\MI_Railgun`'
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Weapons\Railgun\MI_Railgun`'
- en: '`Railgun Mk I`'
  id: totrans-462
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Railgun Mk I`'
- en: '`Railgun`'
  id: totrans-463
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Railgun`'
- en: '`Slugs`'
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slugs`'
- en: '`Single`'
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Single`'
- en: '`9999.9`, `100.0`, `1.5`'
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`9999.9`, `100.0`, `1.5`'
- en: '`Content\Player\Animations\Railgun_Fire_Montage`'
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Player\Animations\Railgun_Fire_Montage`'
- en: '`Content\Weapons\NoAmmo`'
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Weapons\NoAmmo`'
- en: 'Configure `BP_Player` with the following values:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下值配置 `BP_Player`：
- en: '`BP_Pistol`, `BP_MachineGun`, `BP_Railgun`)'
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BP_Pistol`, `BP_MachineGun`, `BP_Railgun`)'
- en: '`Content\Weapons\Hit`'
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Weapons\Hit`'
- en: '`Content\Weapons\WeaponChange`'
  id: totrans-472
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Weapons\WeaponChange`'
- en: '`Content\Player\Inputs\IA_Fire`'
  id: totrans-473
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Player\Inputs\IA_Fire`'
- en: '`Content\Player\Inputs\IA_Pistol`'
  id: totrans-474
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Player\Inputs\IA_Pistol`'
- en: '`Content\Player\Inputs\IA_MachineGun`'
  id: totrans-475
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Player\Inputs\IA_MachineGun`'
- en: '`Content\Player\Inputs\IA_Railgun`'
  id: totrans-476
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Player\Inputs\IA_Railgun`'
- en: '`Content\Player\Inputs\IA_Previous`'
  id: totrans-477
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Player\Inputs\IA_Previous`'
- en: '`Content\Player\Inputs\IA_NextWeapon`'
  id: totrans-478
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Player\Inputs\IA_NextWeapon`'
- en: Make the mesh component block the visibility channel so that it can be hit by
    the hitscans of the weapons.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使网格组件阻止可见性通道，以便它可以被武器的击中扫描所击中。
- en: Edit `ABP_Player` so that it uses a *Layered blend Per bone* node, with `Mesh
    Space Rotation Blend` enabled, on the `spine_01` bone so that the upper body animations
    use the `Upper Body` slot.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `ABP_Player`，使其在 `spine_01` 骨骼上使用 *Layered blend Per bone* 节点，并启用 `Mesh Space
    Rotation Blend`，以便上半身动画使用 `Upper Body` 插槽。
- en: Edit `WBP_HUD` so that it displays a white dot crosshair in the middle of the
    screen, the current weapon, and the ammo count under the `Health` and `Armor`
    indicators.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `WBP_HUD`，使其在屏幕中央显示白色十字准星，当前武器，以及位于 `Health` 和 `Armor` 指示器下的弹药计数。
- en: '**Expected output**:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '**预期输出**:'
- en: 'The result should be a project where each client will have weapons with ammo
    and will be able to use them to fire at and damage other players. You will also
    be able to select weapons by using the *1*, *2*, and *3* keys and by using the
    mouse wheel up and down to select the previous and next weapon, respectively:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是一个项目，其中每个客户端都将拥有带有弹药的武器，并且能够使用它们向其他玩家开火并造成伤害。您还可以通过使用 *1*、*2* 和 *3* 键以及通过使用鼠标滚轮上下选择上一个和下一个武器：
- en: '![Figure 17.12 – The expected result of this activity ](img/Figure_17.12_B18531.jpg)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.12 – 此活动的预期结果](img/Figure_17.12_B18531.jpg)'
- en: Figure 17.12 – The expected result of this activity
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.12 – 此活动的预期结果
- en: Note
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在GitHub上找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)。
- en: By completing this activity, you should have a good idea of how RPCs, enumerations,
    and array index wrapping work.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个活动，你应该对RPCs、枚举和数组索引包装的工作原理有了很好的了解。
- en: Summary
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use RPCs to allow the server and the clients
    to execute logic on one another. You also learned how enumerations work in Unreal
    Engine by using the `UENUM` macro and how to use array index wrapping, which helps
    you iterate an array in both directions and loops around when you go beyond its
    index limits.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用RPCs允许服务器和客户端在彼此上执行逻辑。你还学习了如何在Unreal Engine中使用`UENUM`宏来了解枚举的工作原理，以及如何使用数组索引包装，这有助于你在超出索引限制时双向迭代数组并循环。
- en: By completing this chapter’s activity, you learned how to develop a basic playable
    game where players can shoot each other and switch between their weapons.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成本章的活动，你学会了如何开发一个基本的可玩游戏，玩家可以在游戏中互相射击并切换他们的武器。
- en: In the next chapter, we’ll learn where the instances of the most common gameplay
    framework classes exist in multiplayer, as well as learn about the `Player State`
    and `Game State` classes. We’ll also cover some new concepts in the game mode
    that are used in multiplayer matches, as well as some useful general-purpose,
    built-in functionality.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习最常见的游戏框架类实例在多人游戏中的位置，以及了解`Player State`和`Game State`类。我们还将介绍游戏模式中用于多人比赛的一些新概念，以及一些有用的通用内置功能。
