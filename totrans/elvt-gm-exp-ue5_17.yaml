- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Remote Procedure Calls
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered some critical multiplayer concepts, including
    the server-client architecture, connections and ownership, roles, and variable
    replication. We also learned how to make 2D Blend Spaces and use the `Transform
    (Modify) Bone` node to modify bones at runtime. We used that knowledge to create
    a basic first-person shooter character that walks, jumps, and looks around.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’re going to cover **remote procedure calls** (**RPCs**),
    which is another important multiplayer concept that allows the server to execute
    functions on the clients and vice versa. So far, we’ve learned about variable
    replication as a form of communication between the server and the clients. However,
    to have proper communication, this isn’t enough. This is because the server may
    need to execute specific logic on the clients that doesn’t involve updating the
    value of a variable. The client also needs a way to tell its intentions to the
    server so that the server can validate the action and let the other clients know
    about it. This will ensure that the multiplayer world is synchronized between
    all of the connected clients. We’ll also cover how to use enumerations and expose
    them to the editor, as well as array index wrapping, which allows you to iterate
    an array in both directions and loop around when you go beyond its limits.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Understanding remote procedure calls
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing enumerations to the editor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using array index wrapping
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll understand how RPCs work to make the server
    and the clients execute logic on one another. You’ll also be able to expose enumerations
    to the editor and use array index wrapping to cycle through arrays in both directions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following technical requirements:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Unreal Engine 5 installed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio 2019 installed
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The project for this chapter can be found in the `Chapter17` folder of the
    code bundle for this book, which can be downloaded here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at RPCs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Understanding remote procedure calls
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We covered variable replication in [*Chapter 16*](B18531_16.xhtml#_idTextAnchor345),
    *Getting Started with Multiplayer Basics*, and, while a very useful feature, it
    is a bit limited in terms of allowing custom code to be executed in remote game
    instances (client-to-server or server-to-client) for two main reasons:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The first reason is that variable replication is strictly a form of server-to-client
    communication, so there isn’t a way for a client to use variable replication to
    tell the server to execute some custom logic by changing the value of a variable.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second reason is that variable replication, as the name suggests, is driven
    by the values of variables, so even if variable replication allowed client-to-server
    communication, it would require you to change the value of a variable on the client
    to trigger a `RepNotify` function on the server to run the custom logic, which
    is not very practical.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To solve this problem, Unreal Engine supports RPCs, which work just like normal
    functions that can be defined and called. However, instead of executing them locally,
    they will be executed on a remote game instance, without being tied to a variable.
    To be able to use RPCs, make sure you are defining them in an actor that has a
    valid connection and replication turned on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of RPCs, and each one serves a different purpose:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Server RPC
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multicast RPC
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client RPC
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at these three types in detail and explain when to use them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Server RPC
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You use a Server RPC every time you want the server to run a function on the
    actor that has defined the RPC. There are two main reasons why you would want
    to do this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The first reason is security. When making multiplayer games, especially competitive
    ones, you always have to assume that the client will try to cheat. The way to
    make sure there is no cheating is by forcing the client to go through the server
    to execute the functions that are critical to gameplay.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second reason is synchronicity. Since the critical gameplay logic is only
    executed on the server, the important variables are only going to be changed there,
    which will automatically trigger the variable replication logic to update the
    clients whenever they are changed.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of this would be when a client’s character tries to fire a weapon.
    Since there’s always the possibility that the client may try to cheat, you can’t
    just execute the fire weapon logic locally. The correct way of doing this is by
    having the client call a Server RPC that tells the server to validate the `Fire`
    action by making sure the character has enough ammo, has the weapon equipped,
    and so on. If everything checks out, then it will deduct the ammo variable, and
    finally, it will execute a Multicast RPC (covered shortly) that will tell all
    of the clients to play the fire animation on that character.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Declaration
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To declare a Server RPC, you can use the `Server` specifier on the `UFUNCTION`
    macro. Have a look at the following example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code snippet, the `Server` specifier is used on the `UFUNCTION`
    macro to state that the function is a Server RPC. You can have parameters on a
    Server RPC just like a normal function, but with some caveats that will be explained
    later in this topic, as well as the purpose of the `Reliable` and `WithValidation`
    specifiers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Execution
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To execute a Server RPC, you call it from a client on the actor instance that
    defined it. Take a look at the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code snippet implements the `CallMyOwnServerRPC` function, which
    calls the `ServerMyOwnRPC` RPC function, defined in its own `ARPCTest` class,
    with an integer parameter. This will execute the implementation of the `ServerMyOwnRPC`
    function on the server version of that actor’s instance. We can also call a Server
    RPC from another actor’s instance, like so:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code snippet implements the `CallServerRPCOfAnotherActor` function,
    which calls the `ServerAnotherActorRPC` RPC function, defined in `AAnotherActor`,
    on the `OtherActor` instance, so long as it’s valid. This will execute the implementation
    of the `ServerAnotherActorRPC` function on the server version of the `OtherActor`
    instance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Multicast RPC
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You use a Multicast RPC when you want the server to instruct all of the clients
    to run a function on the actor that has defined the RPC.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: An example of this is when a client’s character tries to fire a weapon. After
    the client calls the Server RPC to ask permission to fire the weapon and the server
    has validated the request (the ammo has been deducted and the line trace/projectile
    was processed), we need to do a Multicast RPC so that all of the instances of
    that specific character play the fire animation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Declaration
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To declare a Multicast RPC, you need to use the `NetMulticast` specifier on
    the `UFUNCTION` macro. Have a look at the following example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code snippet, the `NetMulticast` specifier is used on the `UFUNCTION`
    macro to say that the function is a Multicast RPC. You can have parameters on
    a Multicast RPC just like a normal function, but with the same caveats as the
    Server RPC. The `Unreliable` specifier will be explained later in this topic.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Execution
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To execute a Multicast RPC, you must call it from the server on the actor instance
    that defined it. Take a look at the following example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code snippet implements the `CallMyOwnMulticastRPC` function,
    which calls the `MulticastMyOwnRPC` RPC function, defined in its own `ARPCTest`
    class, with an integer parameter. This will execute the implementation of the
    `MulticastMyOwnRPC` function on all of the clients’ versions of that actor’s instance.
    We can also call a Multicast RPC from another actor’s instance, like so:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code snippet implements the `CallMulticastRPCOfAnotherActor` function,
    which calls the `MulticastAnotherActorRPC` RPC function, defined in `AAnotherActor`,
    on the `OtherActor` instance, so long as it’s valid. This will execute the implementation
    of the `MulticastAnotherActorRPC` function on all of the clients’ versions of
    the `OtherActor` instance.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Client RPC
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You use a Client RPC when you want the server to instruct only the owning client
    to run a function on the actor that has defined the RPC. To set the owning client,
    you need to call `SetOwner` on the server and set it with the client’s player
    controller.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: An example of this would be when a character is hit by a projectile and plays
    a pain sound that only that client will hear. By calling a Client RPC from the
    server, the sound will only be played on the owning client and not on the other
    clients.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Declaration
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To declare a Client RPC, you need to use the `Client` specifier on the `UFUNCTION`
    macro. Have a look at the following example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code snippet, the `Client` specifier is being used on the `UFUNCTION`
    macro to say that the function is a Client RPC. You can have parameters on a Client
    RPC just like a normal function, but with the same caveats as the Server RPC and
    the Multicast RPC. The `Unreliable` specifier will be explained later in this
    topic.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Execution
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To execute a Client RPC, you must call it from the server on the actor instance
    that defined it. Take a look at the following example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code snippet implements the `CallMyOwnClientRPC` function, which
    calls the `ClientMyOwnRPC` RPC function, defined in its own `ARPCTest` class,
    with an integer parameter. This will execute the implementation of the `ClientMyOwnRPC`
    function on the owning client’s version of that actor’s instance. We can also
    call a Client RPC from another actor’s instance, like so:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code snippet implements the `CallClientRPCOfAnotherActor` function,
    which calls the `ClientAnotherActorRPC` RPC function, defined in `AAnotherActor`,
    on the `OtherActor` instance, so long as it’s valid. This will execute the implementation
    of the `ClientAnotherActorRPC` function on the owning client’s version of the
    `OtherActor` instance.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Important considerations when using RPCs
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RPCs are very useful, but there are a couple of things that you need to take
    into consideration when using them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The implementation of an RPC differs slightly from that of a typical function.
    Instead of implementing the function as you normally do, you should only implement
    the `_Implementation` version of it, even though you didn’t declare it in the
    header file. Have a look at the following examples.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '**Server RPC**:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code snippet, we implemented the `_Implementation` version
    of the `ServerRPCTest` function, which uses three parameters.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '**Multicast RPC**:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code snippet, we implemented the `_Implementation` version
    of the `MulticastRPCTest` function, which uses three parameters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '**Client RPC**:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code snippet, we implemented the `_Implementation` version
    of the `ClientRPCTest` function, which uses three parameters.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the previous examples, independent of the type of the RPC
    you are implementing, you should only implement the `_Implementation` version
    of the function and not the normal one, as demonstrated in the following code
    snippet:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, we’re defining the normal implementation of `ServerRPCFunction`.
    If you implement the RPC like this, you’ll get an error saying that it was already
    implemented. The reason for this is that when you declare the RPC function in
    the header file, Unreal Engine will automatically create the normal implementation
    internally, which once called, will execute the logic to send the RPC request
    through the network and when it reaches the remote computer it will call the `_Implementation`
    version there. Since you cannot have two implementations of the same function,
    it will throw a compilation error. To fix this, just make sure that you only implement
    the `_Implementation` version of the RPC.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at name prefixes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Name prefixes
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Unreal Engine, it’s good practice to prefix RPCs with their corresponding
    types. Have a look at the following examples:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: A `RPCFunction` should be named `ServerRPCFunction`
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `RPCFunction` should be named `MulticastRPCFunction`
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `RPCFunction` should be named `ClientRPCFunction`
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return value
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the execution of RPCs is typically executed on different machines asynchronously,
    you can’t have a return value, so it always needs to be void.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Overriding
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can override the implementation of an RPC to expand or bypass the parent’s
    functionality by declaring and implementing the `_Implementation` function in
    the child class without the `UFUNCTION` macro. Let’s look at an example.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the declaration of the parent class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code snippet, we have the declaration of the `ServerRPCTest`
    function in the parent class, which uses one integer parameter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to override the function on the child class, we would need to use
    the following declaration:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code snippet, we have overridden the declaration of the `ServerRPCTest_Implementation`
    function in the child class header file. The implementation of the function is
    just like any other override, with the possibility of calling `Super::ServerRPCTest_Implementation`
    if you still want to execute the parent functionality.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Valid connection
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For an actor to be able to execute its RPCs, they need to have a valid connection.
    If you try to call an RPC on an actor that doesn’t have a valid connection, then
    nothing will happen on the remote instance. You must make sure that the actor
    is either a player controller, is being possessed by one (if applicable), or that
    its owning actor has a valid connection.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Supported parameter types
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using RPCs, you can add parameters just like any other function. At the
    time of writing, most common types are supported (such as `bool`, `int32`, `float`,
    `FText`, `FString`, `FName`, `TArray`, and so on), but not all of them, such as
    `TSet` and `TMap`. Among the types that are supported, the ones that you have
    to pay more attention to are the pointers to any `UObject` class or subclass,
    especially actors.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'If you create an RPC with an actor parameter, then that actor also needs to
    exist on the remote game instance; otherwise, it will have a value of `nullptr`.
    Another important thing to take into account is that the instance name of each
    version of the actor can be different. This means that if you call an RPC with
    an actor parameter, then the instance name of the actor when calling the RPC might
    be different than the one when executing the RPC on the remote instance. Here
    is an example to help you understand this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1 – Displaying the name of the character instances in three clients
    ](img/Figure_17.01_B18531.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: Figure 17.1 – Displaying the name of the character instances in three clients
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, you can see three clients running (one of them is
    a listen server) and each window is displaying the name of all of the character
    instances. If you look at the `BP_ThirdPersonCharacter_C_0`, but on the `BP_ThirdPersonCharacter_C_1`.
    This means that if `BP_ThirdPersonCharacter_C_0` as an argument, then when the
    RPC is executed on the server, the parameter will be `BP_ThirdPersonCharacter_C_1`,
    which is the instance name of the equivalent character in that game instance.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Executing RPCs on the target machine
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can call RPCs directly on their target machine and they will still execute.
    In other words, you can call a Server RPC on the server and it will execute, as
    well as a Multicast/Client RPC on the client, but in the latter case, it will
    only execute the logic on the client that called the RPC. Either way, in these
    cases, you can call the `_Implementation` version directly instead, to execute
    the logic faster.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is that the `_Implementation` version just holds the logic
    to execute and doesn’t have the overhead of creating and sending the RPC request
    through the network that the regular call has.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following example of an actor that has authority on the
    server:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, you have the `CallServerRPC` function, which calls
    `ServerRPCFunction` in two different ways. If the actor is already on the server,
    then it calls `ServerRPCFunction_Implementation`, which will skip the overhead,
    as mentioned previously.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: If the actor is not on the server, then it executes the regular call by using
    `ServerRPCFunction`, which adds the required overhead for creating and sending
    the RPC request through the network.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you define an RPC, you have the option of using an additional function
    to check whether there are any invalid inputs before the RPC is called. This is
    used to avoid processing the RPC if the inputs are invalid due to cheating or
    for some other reason.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: To use validation, you need to add the `WithValidation` specifier to the `UFUNCTION`
    macro. When you use that specifier, you will be forced to implement the `_Validate`
    version of the function, which will return a Boolean stating whether the RPC can
    be executed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code snippet, we’ve declared a validated Server RPC called
    `ServerSetHealth`, which takes a float parameter for the new value of `Health`.
    Take a look at its implementation:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code snippet, we implemented the `_Validate` function, which
    will check whether the new health is within 0 and the maximum value of the health.
    If a client tries to hack and call `ServerSetHealth` with `200` and `MaxHealth`
    is `100`, then the RPC won’t be called, which prevents the client from changing
    the health with values outside a certain range. If the `_Validate` function returns
    `true`, the `_Implementation` function is called as usual, which sets `Health`
    with the value of `NewHealth`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Reliability
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you declare an RPC, you are required to either use the `Reliable` or `Unreliable`
    specifier in the `UFUNCTION` macro. Here’s a quick overview of what they do:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '`Reliable`: This is used when you want to make sure the RPC is executed, by
    repeating the request until the remote machine confirms its reception. This should
    only be used for RPCs that are very important, such as executing critical gameplay
    logic. Here is an example of how to use it:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`Unreliable`: This is used when you don’t care whether the RPC is executed
    due to bad network conditions, such as playing a sound or spawning a particle
    effect. This should only be used for RPCs that aren’t very important or are called
    very frequently to update values since it wouldn’t matter if a couple didn’t get
    through. Here is an example of how to use it:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: For more information on RPCs, please visit [https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/RPCs/index.xhtml](https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/RPCs/index.xhtml).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercise, you will learn how to implement the different types
    of RPCs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 17.01 – Using remote procedure calls
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’re going to create a **C++** project that uses the **Third
    Person** template and we’re going to expand it in the following way:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Add a new `Ammo` integer variable that defaults to `5` and replicates to all
    of the clients.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a fire animation that plays a fire sound and also create a **Fire Anim Montage**
    that is played when the server tells the client that the request to fire was valid.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a **No Ammo Sound** that will play when the server tells the client that
    they didn’t have sufficient ammo.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time the player presses the left mouse button, the client will perform
    a reliable and validated Server RPC that will check whether the character has
    sufficient ammo. If it does, it will subtract `1` from the `Ammo` variable and
    call an unreliable Multicast RPC that plays the fire animation in every client.
    If it doesn’t have ammo, then it will execute an unreliable Client RPC that will
    play `No Ammo Sound` that will only be heard by the owning client.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedule a timer that will prevent the client from spamming the fire button
    for `1.5s` after playing the fire animation.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this exercise:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `RPC` and save it to a location of your liking.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the project has been created, it should open the editor as well as the
    Visual Studio solution.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the editor and go back to Visual Studio.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `RPCCharacter.h` and declare the protected `FireTimer` variable, which
    will be used to prevent the client from spamming the `Fire` action:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Declare the protected replicated `Ammo` variable, which starts with `5` shots:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, declare the protected animation montage variable that will be played
    when the character fires:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Declare the protected sound variable that will be played when the character
    has no ammo:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Override the `Tick` function:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Declare the reliable and validated Server RPC for firing:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Declare the unreliable Multicast RPC that will play the fire animation on all
    of the clients:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Declare the unreliable Client RPC that will play a sound only in the owning
    client:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, open the `RPCCharacter.cpp` file and include `GameplayStatics.h` for the
    PlaySound2D function and the UnrealNetwork.h so we can use the `DOREPLIFETIME_CONDITION`
    macro:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'At the end of the constructor, enable the `Tick` function:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Implement the `GetLifetimeReplicatedProps` function so that the `Ammo` variable
    will replicate to all of the clients:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, implement the `Tick` function, which displays the value of the `Ammo`
    variable:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'At the end of the `SetupPlayerInputController` function, bind the `Fire` action
    to the `ServerFire` function:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Implement the fire Server RPC validation function:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Implement the fire Server RPC implementation function:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, add the logic to abort the function if the fire timer is still active
    since we fired the last shot:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Check whether the character has ammo. If it doesn’t, then play `NoAmmoSound`
    only in the client that controls the character and abort the function:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Deduct the ammo and schedule the `FireTimer` variable to prevent this function
    from being spammed while playing the fire animation:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Call the fire Multicast RPC to make all the clients play the fire animation:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Implement the fire Multicast RPC, which will play the fire animation montage:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Implement the Client RPC that plays a 2D sound:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Finally, you can launch the project in the editor.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Compile the code and wait for the editor to fully load.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to **Project Settings**, go to **Engine**, then **Input**, and add the **Fire**
    action binding:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.2 – Adding the new Fire action binding ](img/Figure_17.02_B18531.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: Figure 17.2 – Adding the new Fire action binding
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Close **Project Settings**.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Content` folder, create a new folder called `Audio`, and open it.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `Exercise17.01\Assets` folder, and import `NoA``mmo.wav` and `Fire.wav`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save both files.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `Content\Characters\Mannequins\Animations` folder.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `Exercise17.01\Assets` folder, and import the `ThirdPersonFire.fbx`
    file. Make sure it’s using the `SK_Mannequin` skeleton and click **Import**.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the new animation and put a `Play Sound` anim notify at `0.3` seconds using
    the `Fire` sound.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Details** panel, find the **Enable Root Motion** option and set it
    to **true**. This will prevent the character from moving when playing the animation.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `ThirdPersonFire`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* on `ThirdPersonFire` and pick **Create** | **Create AnimMontage**.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Animations` folder should look like this:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.3 – The Animations folder for the Mannequin ](img/Figure_17.03_B18531.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: Figure 17.3 – The Animations folder for the Mannequin
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Open `ABP_Manny` and go to `AnimGraph`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the `Control Rig` node and set `Alpha` to `0.0` to disable the automatic
    feet adjustment. You should get the following output:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.4 – Disabling the feet adjustment ](img/Figure_17.04_B18531.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: Figure 17.4 – Disabling the feet adjustment
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Save and close `ABP_Manny`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `SK_Mannequin` in the `Content\Characters\Mannequins\Meshes` folder and
    retarget (as shown in *Exercise 16.04*) the `root` and `pelvis` bones so that
    they use `Animation`. The remaining bones should use `Skeleton`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `SK_Mannequin`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `Content\ThirdPerson\Blueprints` and open the `BP_T``hirdPersonCharacter`
    blueprint.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Class Defaults`, set `No Ammo Sound` to use `NoAmmo`, and set `Fire Anim
    Montage` to use `ThirdPersonFire_Montage`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `BP_ThirdPersonCharacter`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `2`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the window size to `800x600` and play using **New Editor Window (PIE)**.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should get the following output:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.5 – The result of this exercise ](img/Figure_17.05_B18531.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: Figure 17.5 – The result of this exercise
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you can play on each client. Every time you press
    the left mouse button, the character of the client will play the `1`. If you try
    to fire when the ammo is `0`, that client will hear `No Ammo Sound` and won’t
    do the fire animation, because the server didn’t call the Multicast RPC. If you
    try to spam the fire button, you’ll notice that it will only trigger a new fire
    once the animation has finished.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to use all of the different types of RPCs and
    their caveats. In the next section, we will look at enumerations and how to expose
    them to the editor.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Exposing enumerations to the editor
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An enumeration is a user-defined data type that holds a list of integer constants,
    where each item has a human-friendly name assigned by you, which makes the code
    easier to read. As an example, if we wanted to represent the different states
    that a character can be in, we could use an integer variable where `0` means it’s
    idle, `1` means it’s walking, and so on. The problem with this approach is that
    when you see code such as `if(State == 0)`, it’s hard to remember what `0` means
    unless you are using some type of documentation or comments to help you. To fix
    this problem, you should use enumerations, where you can write code such as `if(State
    == EState::Idle)`, which is much more explicit and easier to understand.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: In C++, you have two types of enums – the older raw enums and the new enum classes,
    which were introduced in C++11\. If you want to use the new enum classes in the
    editor, your first instinct might be to do it in the typical way, which is by
    declaring a variable or a function that uses the enumeration with `UPROPERTY`
    or `UFUNCTION`, respectively.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is, if you try to do that, you’ll get a compilation error. Take
    a look at the following example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code snippet, we’ve declared an enum class called `ETestEnum`
    that has three possible values – `EnumValue1`, `EnumValue2`, and `EnumValue3`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, try either of the following examples inside a class:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the preceding code snippet, we declared a `UPROPERTY` variable and a `UFUNCTION`
    function that uses the `ETestEnum` enumeration. If you try to compile, you’ll
    get the following compilation error:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: In Unreal Engine, it’s good practice to prefix the name of an enumeration with
    the letter `E`. For example, you could have `EWeaponType` and `EAmmoType`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: This error happens because when you try to expose a class, struct, or enumeration
    to the editor with the `UPROPERTY` or `UFUNCTION` macro, you need to add it to
    the Unreal Engine Reflection System by using the `UCLASS`, `USTRUCT`, and `UENUM`
    macros, respectively.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about the Unreal Engine Reflection System at [https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection](https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'With that knowledge in mind, it is simple to fix the previous error. Just do
    the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the next section, we will look at the `TEnumAsByte` type.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: TEnumAsByte
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to expose a variable to the engine that uses a raw enum, then you
    need to use the `TEnumAsByte` type. If you declare a `UPROPERTY` variable using
    a raw enum (not enum classes), you’ll get a compilation error.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let’s say you declare a `UPROPERTY` variable using `ETestRawEnum`, like so:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You’ll get the following compilation error:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To fix this error, you need to surround the enum type of the variable, which
    in this case is `ETestRawEnum`, with `TEnumAsByte<>`, like so:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the next section, we will look at the `UMETA` macro.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: UMETA
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you use the `UENUM` macro to add an enumeration to the Unreal Engine Reflection
    System, you can use the `UMETA` macro on each value of the enum. The `UMETA` macro,
    just like with other macros, such as `UPROPERTY` or `UFUNCTION`, can use specifiers
    that will inform Unreal Engine of how to handle that value. Let’s look at the
    most commonly used `UMETA` specifiers.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: DisplayName
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This specifier allows you to define a new name that is easier to read for the
    enum value when it’s displayed in the editor.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let’s declare the following variable:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When you open the editor and look at the `TestEnum` variable, you will see a
    dropdown where `EnumValue1`, `EnumValue2`, and `EnumValue3` have been replaced
    with `My First Option`, `My Second Option`, and `My Third Option`, respectively.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Hidden
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This specifier allows you to hide a specific enum value from the dropdown. This
    is typically used when there is an enum value that you only want to be able to
    use in C++ and not in the editor.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let’s declare the following variable:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When you open the editor and look at the `TestEnum` variable, you will see a
    dropdown. You should notice that `My Second Option` doesn’t appear in the dropdown
    and therefore can’t be selected.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: For more information on all of the UMETA specifiers, visit [https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/#enummetadataspecifiers](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/#enummetadataspecifiers).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at the `BlueprintType` specifier for the `UENUM`
    macro.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: BlueprintType
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This `UENUM` specifier will expose the enumeration to blueprints. This means
    that there will be an entry for that enumeration in the dropdown that is used
    when making new variables or inputs/outputs for a function, as shown in the following
    example:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.6 – Setting a variable to use the ETestEnum variable type ](img/Figure_17.06_B18531.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: Figure 17.6 – Setting a variable to use the ETestEnum variable type
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'It will also create additional functions that you can call on the enumeration
    in the editor, as shown in the following example:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.7 – List of additional functions available when using BlueprintType
    ](img/Figure_17.07_B18531.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: Figure 17.7 – List of additional functions available when using BlueprintType
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: MAX
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using enumerations, it’s common to want to know how many values it has.
    In Unreal Engine, the standard way of doing this is by adding `MAX` as the last
    value, which will be automatically hidden in the editor.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If you want to know how many values `ETestEnum` has in C++, you just need to
    do the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This works because enumerations in C++ are internally stored as numbers, where
    the first value is `0`, the second is `1`, and so on. This means that so long
    as `MAX` is the last value, it will always have the total number of values in
    the enumeration. An important thing to take into consideration is that for `MAX`
    to give you the correct value, you cannot change the internal numbering order
    of the enumeration, like so:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this case, `MAX` will be `101` because it will use the number immediately
    next to the previous value, which is `EnumValue3 = 100`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Using `MAX` is only meant to be used in C++ and not in the editor because the
    `MAX` value is hidden in blueprints, as mentioned previously. To get the number
    of entries of an enumeration in blueprints, you should use the `BlueprintType`
    specifier in the `UENUM` macro to expose some useful functions on the context
    menu. After that, you just need to type the name of your enumeration in the context
    menu. If you select the **Get number of entries in ETestEnum** option, you will
    have a function that returns the number of entries of that enumeration.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will be using C++ enumerations in the editor.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 17.02 – Using C++ enumerations in the editor
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’re going to create a new **C++** project that uses the
    **Third Person** template. We’re going to add the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: An enumeration called `EWeaponType` that contains **three** weapons – a pistol,
    a shotgun, and a rocket launcher.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An enumeration called `EAmmoType` that contains **3** ammo types – bullets,
    shells, and rockets.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A variable called `Weapon` that uses `EWeaponType` to tell the type of the current
    weapon.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer array variable called `Ammo` that holds the amount of ammo for each
    type, which is initialized with a value of `10`.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the player presses the `1`, `2`, or `3` key, the `Weapon` variable will
    be set to `Pistol`, `Shotgun`, or `Rocket Launcher`, respectively.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the player presses the left mouse button, the ammo for the current weapon
    will be consumed.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With every `Tick` function call, the character will display the current weapon
    type and the equivalent ammo type and amount.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this exercise:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Enumerations` and save it to a location of your liking.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the project has been created, it should open the editor as well as the
    Visual Studio solution.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Close the editor and go back to Visual Studio.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Enumerations.h` file.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a macro called `ENUM_TO_INT32` that will convert an enumeration into
    an `int32` data type:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a macro called `ENUM_TO_FSTRING` that will get the display name for
    a value of an `enum` data type and convert it into an `FString` datatype:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Declare the `EWeaponType` and `EammoType` enumerations:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Open the `EnumerationsCharacter.h` file and add the `Enumerations.h` header
    before `EnumerationsCharacter.generated.h`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Declare the protected `Weapon` variable that holds the weapon type of the selected
    weapon:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Declare the protected `Ammo` array that holds the amount of ammo for each type:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Declare the protected overrides for the `Begin Play` and `Tick` functions:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Declare the protected input functions:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Open the `EnumerationsCharacter.cpp` file and bind the new action bindings
    at the end of the `SetupPlayerInputController` function, as shown in the following
    code snippet:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, implement the override for `BeginPlay` that executes the parent logic,
    but also initializes the size of the `Ammo` array with the number of entries in
    the `EAmmoType` enumeration. Each position in the array will also be initialized
    with a value of `10`:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Implement the override for `Tick`:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Convert the `Weapon` variable into `int32` and the `Weapon` variable into an
    `FString`:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Convert the ammo type into an `FString` and get the ammo count for the current
    weapon:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We are using `Weapon` to get the ammo type string because the entries in `EAmmoType`
    match the type of ammo of the equivalent `EWeaponType`. In other words, `Pistol
    = 0` uses `Bullets = 0`, `Shotgun = 1` uses `Shells = 1`, and `RocketLauncher
    = 2` uses `Rockets = 2`, so it’s a 1-to-1 mapping that we can use in our favor.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Display the name of the current weapon in the character’s location and its
    corresponding ammo type and ammo count, as shown in the following code snippet:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Implement the equip input functions that set the `Weapon` variable with the
    corresponding value:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Implement the fire input function that will use the weapon index to get the
    corresponding ammo type count and subtract `1`, so long as the resulting value
    is greater than or equal to 0:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Compile the code and run the editor.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to **Project Settings**, go to **Engine**, then **Input**, and add the new
    action bindings:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.8 – Adding the Pistol, Shotgun, Rocket Launcher, and Fire bindings
    ](img/Figure_17.08_B18531.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
- en: Figure 17.8 – Adding the Pistol, Shotgun, Rocket Launcher, and Fire bindings
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Close **Project Settings**.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure the `1`. Click on **New Editor Window (PIE)**; you should get the
    following result:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.9 – The result of this exercise ](img/Figure_17.09_B18531.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: Figure 17.9 – The result of this exercise
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you can use the `0`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to expose enumerations to the editor so that
    you can use them in blueprints. In the next section, we will look at array index
    wrapping, which allows you to iterate an array beyond its limits and wrap it back
    around from the other side.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Using array index wrapping
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, when you use arrays to store information, you may want to iterate
    it in both directions and be able to wrap the index so that it doesn’t go beyond
    the index limit and crash the game. An example of this is the previous/next weapon
    logic in shooter games, where you have an array of weapons and you want to be
    able to cycle through them in a particular direction, and when you reach the first
    or the last index, you want to loop back around to the last and first index, respectively.
    The typical way of doing this would be as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the preceding code, we set the `WeaponIndex` variable (declared as a member
    of the class) to loop back if the new weapon index is outside the limits of the
    weapons array, which can happen in two cases. The first case is when the player
    has the last weapon of the inventory equipped and we want the next weapon. In
    this case, it should go back to the first weapon.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: The second case is when the player has the first weapon of the inventory equipped
    and we want the previous weapon. In this case, it should go to the last weapon.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: While the example code works, it’s still quite a lot of code to solve such a
    trivial problem. To improve this code, there is a mathematical operation that
    will help you handle these two cases automatically in just one function. It’s
    called the modulo (represented in C++ by the `%` operator), which gives you the
    remainder of a division between two numbers.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we use the modulo to wrap the index of an array? Let’s rewrite the
    previous example using the modulo operator:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This is the new version, and you can tell right away that it’s a bit harder
    to understand, but it’s more functional and compact. If you don’t use the variables
    to store the intermediate values of each operation, you can probably make the
    entire function in one or two lines of code.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down the preceding code snippet:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '`const int WeaponCount = Weapons.Num()`: We need to know the size of the array
    to determine the index where it should go back to `0`. In other words, if `WeaponCount
    = 4`, then the array has the `0`, `1`, `2`, and `3` indexes, which tells us that
    index `4` is the cutoff index where it should go back to `0`.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const int32 NewRawIndex = WeaponIndex + Direction`: This is the new raw index
    that doesn’t care about the limits of the array. The `Direction` variable is used
    to indicate the offset we want to add to the current index of the array. This
    is either `-1` if we want the previous index or `1` if we want the next index.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const int32 NewWrappedIndex = NewRawIndex % WeaponCount`: This will make sure
    that `NewWrappedIndex` is within the `0` to `WeaponCount - 1` interval and wrap
    around if needed, due to the modulo properties. So, if `NewRawIndex` is `4`, then
    `NewWrappedIndex` will become `0`, because there is no remainder from the division
    of `4 / 4`.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If `Direction` is always `1`, meaning we only want the next index, then the
    value of `NewWrappedIndex` is enough for what we need. If we also want to use
    `Direction` with `-1`, then we’ll have a problem, because the modulo operation
    won’t wrap the index correctly for negative indexes. So, if `WeaponIndex` is `0`
    and `Direction` is `-1`, then `NewWrappedIndex` will be `-1`, which is not correct.
    To fix this limitation, we need to do some additional calculations:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '`WeaponIndex = (NewWrappedIndex + WeaponCount) % WeaponCount`: This will add
    `WeaponCount` to `NewWrappedIndex` to make it positive and apply the modulo again
    to get the correct wrapped index, which fixes the problem.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return Weapons[WeaponIndex]`: This returns the weapon in the calculated `WeaponIndex`
    index position.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a look at a practical example to help you visualize how all this
    works.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'Weapons:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '`[0] Knife`'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[1] Pistol`'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[2] Shotgun`'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[3] Rocket Launcher`'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeaponCount = Weapons.Num()`, so it has a value of `4`.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that `WeaponIndex = 3` and `Direction = 1`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we would have the following:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '`NewRawIndex = WeaponIndex + Direction`, so `3 + 1 = 4`'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewWrappedIndex = NewRawIndex % WeaponCount`, so `4 % 4 = 0`'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeaponIndex = (NewWrappedIndex + WeaponCount) % WeaponCount, so (0 + 4) %
    4 = 0`'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, the starting value for `WeaponIndex` is `3`, which is `Rocket
    Launcher`, and we want the next weapon because `Direction` is set to `1`. Performing
    the calculations, `WeaponIndex` will now be `0`, which is `Knife`. This is the
    desired behavior because we have four weapons, so we circled back to the first
    index. In this case, since `NewRawIndex` is positive, we could’ve just used `NewWrappedIndex`
    without doing the extra calculations.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Let’s debug it again using different values.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that `WeaponIndex = 0` and `Direction = -1`:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '`NewRawIndex = WeaponIndex + Direction`, so `0 + -1 = -1`'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewWrappedIndex = NewIndex % WeaponCount`, so `-1 % 4 = -1`'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeaponIndex = (NewWrappedIndex + WeaponCount) % WeaponCount`, so `(-1 + 4)
    % 4 = 3`'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, the starting value for `WeaponIndex` is `0`, which is `Knife`,
    and we want the previous weapon because `Direction` is set to -`1`. Doing the
    calculations, `WeaponIndex` will now be `3`, which is `Rocket Launcher`. This
    is the desired behavior because we have four weapons, so we circled back to the
    last index. In this case, since `NewRawIndex` is negative, we can’t just use `NewWrappedIndex`;
    we need to do the extra calculation to get the correct value.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you’re going to use the knowledge you’ve acquired to cycle
    between an enumeration of weapons in both directions.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 17.03 – Using array index wrapping to cycle between an enumeration
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we’re going to use the project from *Exercise 17.02 – Using
    C++ enumerations in the editor*, and add two new action mappings for cycling the
    weapons. `Mouse Wheel Up` will go to the previous weapon type, while `Mouse Wheel
    Down` will go to the next weapon type.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this exercise:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: First, open the Visual Studio project from *Exercise 17.02 – Using C++ enumerations
    in the editor*.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will be updating `Enumerations.h` and adding a macro that will handle
    the array index wrapping in a very convenient way.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `Enumerations.h` and add the `GET_WRAPPED_ARRAY_INDEX` macro. This will
    apply the modulo formula that we covered previously:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Open `EnumerationsCharacter.h` and declare the new input functions for the
    weapon cycling:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Declare the `CycleWeapons` function, as shown in the following code snippet:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Open `EnumerationsCharacter.cpp` and bind the new action bindings in the `SetupPlayerInputController`
    function:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, implement the new input functions, as shown in the following code snippet:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In the preceding code snippet, we defined the functions that handle the action
    mappings for `Previous Weapon` and `Next Weapon`. Each function uses the `CycleWeapons`
    function, with a direction of `-1` for the previous weapon and `1` for the next
    weapon.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `CycleWeapons` function, which does the array index wrapping
    using the `Direction` parameter based on the current weapon index:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Compile the code and run the editor.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to **Project Settings**, go to **Engine**, then **Input**, and add the new
    action bindings:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.10 – Adding the Previous Weapon and Next Weapon bindings ](img/Figure_17.10_B18531.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
- en: Figure 17.10 – Adding the Previous Weapon and Next Weapon bindings
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Close **Project Settings**.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that the `1`. Click on **New Editor Window (PIE)**; you should get
    the following result:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.11 – The result of this exercise ](img/Figure_17.11_B18531.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
- en: Figure 17.11 – The result of this exercise
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you can use the mouse wheel to cycle between the
    weapons. If you select the rocket launcher and use the mouse wheel down to go
    to the next weapon, it will go back to the pistol. If you use the mouse wheel
    down to go to the previous weapon with the pistol selected, it will go back to
    the rocket launcher.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: In the next activity, you will be adding the concept of weapons and ammo to
    the multiplayer FPS project we started in [*Chapter 16*](B18531_16.xhtml#_idTextAnchor345),
    *Getting Started with Multiplayer Basics*.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Activity 17.01 – Adding weapons and ammo to the multiplayer FPS game
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this activity, you’ll add the concept of weapons and ammo to the multiplayer
    FPS project that we started in the previous chapter. You will need to use the
    different types of RPCs covered in this chapter to complete this activity.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this activity:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MultiplayerFPS` project from *Activity 16.01 – Creating a character
    for the multiplayer FPS project*.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `AnimMontage` slot called `Upper Body`.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the animations (`Pistol_Fire.fbx`, `MachineGun_Fire.fbx`, and `Railgun_Fire.fbx`)
    from the `Activity17.01\Assets` folder into `Content\Player\Animations`.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `AnimMontage` for `Pistol_Fire`, `MachineGun_Fire`, and `Railgun_Fire`,
    and make sure they have the following configurations:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Blend In` time of `0.01` and a `Blend Out` time of `0.1`. Make sure it uses
    the `Upper Body` slot.'
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Blend In` time of `0.01` and a `Blend Out` time of `0.1`. Make sure it uses
    the `Upper Body` slot.'
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Upper Body` slot.'
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Import `SK_Weapon.fbx` (with Material Import Method set to Create New Materials),
    `NoAmmo.wav`, `WeaponChange.wav`, and `Hit.wav` from the `Activity17.01\Assets`
    folder into `Content\Weapons`.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `Pistol_Fire_Sound.wav` from `Activity17.01\Assets` into `Content\Weapons\Pistol`
    and use it on `Play Sound` in the `Pistol_Fire` animation.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a simple green-colored material instance from `M_FPGun` called `MI_Pistol`
    and place it on `Content\Weapons\Pistol`.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `MachineGun_Fire_Sound.wav` from `Activity17.01\Assets` into `Content\Weapons\MachineGun`
    and use it on `Play Sound` in the `MachineGun_Fire` animation.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a simple red-colored material instance from `M_FPGun` called `MI_MachineGun`
    and place it on `Content\Weapons\MachineGun`.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `Railgun_Fire_Sound.wav` from `Activity17.01\Assets` into `Content\Weapons\Railgun`
    and use it on `Play Sound` in the `Railgun_Fire` animation.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a simple white-colored material instance from `M_FPGun` called `MI_Railgun`
    and place it on `Content\Weapons\Railgun`.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `SK_Mannequin_Skeleton` and create a socket called `GripPoint` from
    `hand_r` with `Relative Location` set to `(X=-10.403845,Y=6.0,Z=-3.124871)` and
    `Relative Rotation` set to `(X=0.0,Y=0.0,Z=90.0)`.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following input actions to `Content\Player\Inputs`, using the knowledge
    you acquired in [*Chapter 4*](B18531_04.xhtml#_idTextAnchor099), *Getting Started
    with Player Input*:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**IA_Fire (Digital)**: *Left Mouse Button*'
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IA_Pistol (Digital)**: *1*'
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IA_MachineGun (Digital)**: *2*'
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IA_Railgun (Digital)**: *3*'
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IA_PreviousWeapon (Digital)**: *Mouse Wheel Up*'
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IA_NextWeapon (Digital)**: *Mouse Wheel Down*'
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the new input actions to `IMC_Player`.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `MultiplayerFPS.h`, create the `ENUM_TO_INT32(Enum)` macro, which casts an
    enumeration to `int32`, and the `GET_WRAPPED_ARRAY_INDEX(Index, Count)` macro,
    which uses array indexing wrapping to make sure the index is within the limits
    of the array.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a header file called `EnumTypes.h` that holds the following enumerations:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Pistol`, `MachineGun`, `Railgun`, `MAX`'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '`Single`, `Automatic`'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '`PistolBullets`, `MachineGunBullets`, `Slugs`, `MAX`'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Create a C++ class called `Weapon` that derives from the `Actor` class and has
    a skeletal mesh component called `Mesh` as the root component.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In terms of variables, it stores the name, the weapon type, the ammo type, the
    fire mode, how far the hitscan goes, how much damage the hitscan does when it
    hits, the fire rate, the animation montage to use when firing, and the sound to
    play when it has no ammo. In terms of functionality, it needs to be able to start
    the fire (and also stop the fire, because of the automatic fire mode), which checks
    whether the player can fire. If it can, then it plays the fire animation in all
    of the clients and shoots a line trace in the camera position and direction with
    the supplied length to damage the actor it hits. If it doesn’t have ammo, it will
    play a sound only on the owning client.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Edit `FPSCharacter` so that it supports the new input actions for `Fire`, `Pistol`,
    `Machine Gun`, `Railgun`, `Previous Weapon`, and `Next Weapon`. In terms of variables,
    it needs to store the amount of ammo for each type, the currently equipped weapon,
    all of the weapons classes and spawned instances, the sound to play when it hits
    another player, and the sound when it changes weapons. In terms of functions,
    it needs to be able to equip/cycle/add weapons, manage ammo (add, remove, and
    get), handle when the character is damaged, play an anim montage on all of the
    clients, and play a sound on the owning client.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create `BP_Pistol` from `AWeapon`, place it on `Content\Weapons\Pistol`, and
    configure it with the following values:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Content\Weapons\SK_Weapon`'
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapons\Pistol\MI_Pistol`'
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pistol Mk I`'
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pistol`'
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pistol Bullets`'
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Automatic`'
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`9999.9`, `5.0`, `0.5`'
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Player\Animations\Pistol_Fire_Montage`'
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapons\NoAmmo`'
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create `BP_MachineGun` from `Aweapon`, place it on `Content\Weapons\MachineGun`,
    and configure it with the following values:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Content\Weapons\SK_Weapon`'
  id: totrans-450
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapons\MachineGun\MI_MachineGun`'
  id: totrans-451
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Machine Gun Mk I`'
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Machine Gun`'
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Machine Gun Bullets`'
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Automatic`'
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`9999.9`, `5.0`, `0.1`'
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Player\Animations\MachineGun_Fire_Montage`'
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapons\NoAmmo`'
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create `BP_Railgun` from `Aweapon`, place it on `Content\Weapons\Railgun`,
    and configure it with the following values:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Content\Weapons\SK_Weapon`'
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapons\Railgun\MI_Railgun`'
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Railgun Mk I`'
  id: totrans-462
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Railgun`'
  id: totrans-463
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slugs`'
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Single`'
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`9999.9`, `100.0`, `1.5`'
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Player\Animations\Railgun_Fire_Montage`'
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapons\NoAmmo`'
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configure `BP_Player` with the following values:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BP_Pistol`, `BP_MachineGun`, `BP_Railgun`)'
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapons\Hit`'
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Weapons\WeaponChange`'
  id: totrans-472
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Player\Inputs\IA_Fire`'
  id: totrans-473
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Player\Inputs\IA_Pistol`'
  id: totrans-474
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Player\Inputs\IA_MachineGun`'
  id: totrans-475
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Player\Inputs\IA_Railgun`'
  id: totrans-476
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Player\Inputs\IA_Previous`'
  id: totrans-477
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content\Player\Inputs\IA_NextWeapon`'
  id: totrans-478
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the mesh component block the visibility channel so that it can be hit by
    the hitscans of the weapons.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit `ABP_Player` so that it uses a *Layered blend Per bone* node, with `Mesh
    Space Rotation Blend` enabled, on the `spine_01` bone so that the upper body animations
    use the `Upper Body` slot.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit `WBP_HUD` so that it displays a white dot crosshair in the middle of the
    screen, the current weapon, and the ammo count under the `Health` and `Armor`
    indicators.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Expected output**:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'The result should be a project where each client will have weapons with ammo
    and will be able to use them to fire at and damage other players. You will also
    be able to select weapons by using the *1*, *2*, and *3* keys and by using the
    mouse wheel up and down to select the previous and next weapon, respectively:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.12 – The expected result of this activity ](img/Figure_17.12_B18531.jpg)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
- en: Figure 17.12 – The expected result of this activity
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在GitHub上找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)。
- en: By completing this activity, you should have a good idea of how RPCs, enumerations,
    and array index wrapping work.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个活动，你应该对RPCs、枚举和数组索引包装的工作原理有了很好的了解。
- en: Summary
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use RPCs to allow the server and the clients
    to execute logic on one another. You also learned how enumerations work in Unreal
    Engine by using the `UENUM` macro and how to use array index wrapping, which helps
    you iterate an array in both directions and loops around when you go beyond its
    index limits.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用RPCs允许服务器和客户端在彼此上执行逻辑。你还学习了如何在Unreal Engine中使用`UENUM`宏来了解枚举的工作原理，以及如何使用数组索引包装，这有助于你在超出索引限制时双向迭代数组并循环。
- en: By completing this chapter’s activity, you learned how to develop a basic playable
    game where players can shoot each other and switch between their weapons.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成本章的活动，你学会了如何开发一个基本的可玩游戏，玩家可以在游戏中互相射击并切换他们的武器。
- en: In the next chapter, we’ll learn where the instances of the most common gameplay
    framework classes exist in multiplayer, as well as learn about the `Player State`
    and `Game State` classes. We’ll also cover some new concepts in the game mode
    that are used in multiplayer matches, as well as some useful general-purpose,
    built-in functionality.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习最常见的游戏框架类实例在多人游戏中的位置，以及了解`Player State`和`Game State`类。我们还将介绍游戏模式中用于多人比赛的一些新概念，以及一些有用的通用内置功能。
