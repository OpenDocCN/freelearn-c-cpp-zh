["```cpp\n    struct int_allocator_2014 {\n      int *allocate(size_t n, const void *hint = nullptr);\n    };\n\n    struct int_allocator_2017 {\n      int *allocate(size_t n);\n    };\n```", "```cpp\n    struct classical_base {\n      virtual int *allocate(size_t n) = 0;\n    };\n\n    struct classical_derived : public classical_base {\n      int *allocate(size_t n) override;\n    };\n```", "```cpp\n    static char big_buffer[10000];\n    static size_t index = 0;\n\n    void *allocate(size_t bytes) {\n      if (bytes > sizeof big_buffer - index) {\n        throw std::bad_alloc();\n      }\n      index += bytes;\n      return &big_buffer[index - bytes];\n    }\n\n    void deallocate(void *p, size_t bytes) {\n      // drop it on the floor\n    }\n```", "```cpp\n    void deallocate(void *p, size_t bytes) {\n      if ((char*)p + bytes == &big_buffer[index]) {\n        // aha! we can roll back our index!\n        index -= bytes;\n      } else {\n        // drop it on the floor\n      }\n    }\n```", "```cpp\n    class memory_resource {\n      virtual void *do_allocate(size_t bytes, size_t align) = 0;\n      virtual void do_deallocate(void *p, size_t bytes, size_t align) = 0;\n      virtual bool do_is_equal(const memory_resource& rhs) const = 0;\n    public:\n      void *allocate(size_t bytes, size_t align) {\n        return do_allocate(bytes, align);\n      }\n      void deallocate(void *p, size_t bytes, size_t align) {\n        return do_deallocate(p, bytes, align);\n      }\n      bool is_equal(const memory_resource& rhs) const {\n        return do_is_equal(rhs);\n      }\n    };\n```", "```cpp\n    class example_resource : public std::pmr::memory_resource {\n      alignas(std::max_align_t) char big_buffer[10000];\n      size_t index = 0;\n      void *do_allocate(size_t bytes, size_t align) override {\n        if (align > alignof(std::max_align_t) ||\n            (-index % align) > sizeof big_buffer - index ||\n            bytes > sizeof big_buffer - index - (-index % align))\n        {\n            throw std::bad_alloc();\n        }\n        index += (-index % align) + bytes;\n        return &big_buffer[index - bytes];\n      }\n      void do_deallocate(void *, size_t, size_t) override {\n        // drop it on the floor\n      }\n      bool do_is_equal(const memory_resource& rhs) const override {\n        return this == &rhs;\n      }\n    };\n```", "```cpp\n    class UNKNOWN : public std::pmr::memory_resource {\n      void *do_allocate(size_t, size_t) override {\n        throw std::bad_alloc();\n      }\n      void do_deallocate(void *, size_t, size_t) override {}\n      bool do_is_equal(const memory_resource& rhs) const override {\n        return this == &rhs;\n      }\n    };\n\n    std::pmr::memory_resource *null_memory_resource() noexcept {\n      static UNKNOWN singleton;\n      return &singleton;\n    }\n```", "```cpp\n    alignas(16) char big_buffer[10000];\n\n    std::pmr::monotonic_buffer_resource a(\n      big_buffer, sizeof big_buffer,\n      std::pmr::null_memory_resource()\n    );\n\n    void *p1 = a.allocate(100);\n    assert(p1 == big_buffer + 0);\n\n    void *p2 = a.allocate(100, 16); // alignment\n    assert(p1 == big_buffer + 112);\n\n    // Now clear everything allocated so far and start over.\n    a.release();\n    void *p3 = a.allocate(100);\n    assert(p3 == big_buffer + 0);\n\n    // When the buffer is exhausted, a will go upstream\n    // to look for more buffers... and not find any.\n    try {\n      a.allocate(9901);\n    } catch (const std::bad_alloc&) {\n      puts(\"The null_memory_resource did its job!\");\n    }\n```", "```cpp\n    std::pmr::pool_options options;\n    options.max_blocks_per_chunk = 100;\n    options.largest_required_pool_block = 256;\n\n    std::pmr::synchronized_pool_resource a(\n      options,\n      std::pmr::new_delete_resource()\n    );\n```", "```cpp\n    template<class T>\n    struct allocator {\n      using value_type = T;\n\n      T *allocate(size_t n) {\n        return static_cast<T *>(::operator new(n * sizeof (T)));\n      }\n      void deallocate(T *p, size_t) {\n        ::operator delete(static_cast<void *>(p));\n      }\n\n      // NOTE 1\n      template<class U>\n      explicit allocator(const allocator<U>&) noexcept {}\n\n      // NOTE 2\n      allocator() = default;\n      allocator(const allocator&) = default;\n    };\n```", "```cpp\n    template<class T>\n    struct helloworld {\n      using value_type = T;\n\n      T *allocate(size_t n) {\n        printf(\"hello world %zu\\n\", n);\n        return static_cast<T *>(::operator new(n * sizeof (T)));\n      }\n      void deallocate(T *p, size_t) {\n        ::operator delete(static_cast<void *>(p));\n      }\n    };\n\n    void test() {\n      std::vector<int, helloworld<int>> v;\n      v.push_back(42); // prints \"hello world 1\"\n      v.push_back(42); // prints \"hello world 2\"\n      v.push_back(42); // prints \"hello world 4\"\n    }\n```", "```cpp\n    void test() {\n      std::list<int, helloworld<int>> v;\n      v.push_back(42);\n    }\n```", "```cpp\n    using AllocOfInt = helloworld<int>;\n\n    using AllocOfChar =\n      std::allocator_traits<AllocOfInt>::rebind_alloc<char>;\n\n    // Now alloc_of_char is helloworld<char>\n```", "```cpp\n    using PtrToInt = int*;\n\n    using PtrToChar =\n      std::pointer_traits<PtrToInt>::rebind<char>;\n\n    // Now PtrToChar is char*\n\n    using PtrToConstVoid =\n      std::pointer_traits<PtrToInt>::rebind<const void>;\n\n    // Now PtrToConstVoid is const void*\n```", "```cpp\n    template<class T>\n    class ChunkyPtr {\n      T *m_ptr = nullptr;\n      Chunk *m_chunk = nullptr;\n    public:\n      explicit ChunkyPtr(T *p, Chunk *ch) :\n      m_ptr(p), m_chunk(ch) {}\n\n      T& operator *() const {\n        return *m_ptr;\n      }\n      explicit operator T *() const {\n        return m_ptr;\n      }\n      // ... and so on ...\n\n      // ... plus this extra accessor:\n      auto chunk() const {\n        return m_chunk;\n      }\n    };\n```", "```cpp\n    template<class T>\n    struct ChunkyAllocator {\n      using value_type = T;\n      using pointer = ChunkyPtr<T>;\n\n      ChunkyAllocator(ChunkyMemoryResource *mr) :\n        m_resource(mr) {}\n\n      template<class U>\n      ChunkyAllocator(const ChunkyAllocator<U>& rhs) :\n        m_resource(rhs.m_resource) {}\n\n      pointer allocate(size_t n) {\n        return m_resource->allocate(\n          n * sizeof(T), alignof(T));\n      } \n      void deallocate(pointer p, size_t n) {\n        m_resource->deallocate(\n          p, n * sizeof(T), alignof(T));\n      }\n    private:\n      ChunkyMemoryResource *m_resource;\n\n      template<class U>\n      friend struct ChunkyAllocator;\n    };\n```", "```cpp\n    class Chunk {\n      char buffer[10000];\n      int index = 0;\n      int freed = 0;\n    public:\n      bool can_allocate(size_t bytes) {\n        return (sizeof buffer - index) >= bytes;\n      }\n      auto allocate(size_t bytes) {\n        index += bytes;\n        void *p = &buffer[index - bytes];\n        return ChunkyPtr<void>(p, this);\n      }\n      void deallocate(void *, size_t bytes) {\n        freed += bytes;\n        if (freed == index) {\n            index = freed = 0;\n        }\n      }\n    };\n\n    class ChunkyMemoryResource {\n      std::list<Chunk> m_chunks;\n    public:\n      ChunkyPtr<void> allocate(size_t bytes, size_t align) {\n        assert(align <= alignof(std::max_align_t));\n        bytes += -bytes % alignof(std::max_align_t);\n        assert(bytes <= 10000);\n\n        for (auto&& ch : m_chunks) {\n          if (ch.can_allocate(bytes)) {\n            return ch.allocate(bytes);\n          }\n        }\n        return m_chunks.emplace_back().allocate(bytes);\n      }\n      void deallocate(ChunkyPtr<void> p, size_t bytes, size_t) {\n        bytes += -bytes % alignof(std::max_align_t);\n        p.chunk()->deallocate(static_cast<void*>(p), bytes);\n      }\n    };\n```", "```cpp\n    ChunkyMemoryResource mr;\n    std::vector<int, ChunkyAllocator<int>> v{&mr};\n    v.push_back(42);\n    // All the memory for v's underlying array\n    // is coming from blocks owned by \"mr\".\n```", "```cpp\n    static ChunkyPtr<T> pointer_to(T &r) noexcept {\n      return ChunkyPtr<T>(&r, nullptr);\n    }\n```", "```cpp\n    namespace my {\n\n      template<class VoidPtr>\n      class fancy_memory_resource {\n      public:\n        VoidPtr allocate(size_t bytes,\n          size_t align = alignof(std::max_align_t)) {\n          return do_allocate(bytes, align);\n        }\n        void deallocate(VoidPtr p, size_t bytes,\n          size_t align = alignof(std::max_align_t)) {\n          return do_deallocate(p, bytes, align);\n        }\n        bool is_equal(const fancy_memory_resource& rhs) const noexcept {\n          return do_is_equal(rhs);\n        }\n        virtual ~fancy_memory_resource() = default;\n      private:\n        virtual VoidPtr do_allocate(size_t bytes, size_t align) = 0;\n        virtual void do_deallocate(VoidPtr p, size_t bytes,\n          size_t align) = 0;\n        virtual bool do_is_equal(const fancy_memory_resource& rhs)\n          const noexcept = 0;\n      };\n\n      using memory_resource = fancy_memory_resource<void*>;\n\n    } // namespace my\n```", "```cpp\n    template<class T>\n    struct WidgetAlloc {\n      std::pmr::memory_resource *mr;\n\n      using value_type = T;\n\n      WidgetAlloc(std::pmr::memory_resource *mr) : mr(mr) {}\n\n      template<class U>\n      WidgetAlloc(const WidgetAlloc<U>& rhs) : mr(rhs.mr) {}\n\n      T *allocate(size_t n) {\n        return (T *)mr->allocate(n * sizeof(T), alignof(T));\n      }\n      void deallocate(void *p, size_t n) {\n        mr->deallocate(p, n * sizeof(T), alignof(T));\n      }\n    };\n\n    class Widget {\n      char buffer[10000];\n      std::pmr::monotonic_buffer_resource mr {buffer, sizeof buffer};\n      std::vector<int, WidgetAlloc<int>> v {&mr};\n      std::list<int, WidgetAlloc<int>> lst {&mr};\n    public:\n      static void swap_elems(Widget& a, Widget& b) {\n        std::swap(a.v, b.v);\n      }\n    };\n```", "```cpp\n    namespace std::pmr {\n\n      template<class T>\n      using vector = std::vector<T,\n        polymorphic_allocator<T>>;\n\n      template<class K, class V, class Cmp = std::less<K>>\n      using map = std::map<K, V, Cmp,\n        polymorphic_allocator<typename std::map<K, V>::value_type>>;\n\n      // ...\n\n    } // namespace std::pmr\n```", "```cpp\n    std::pmr::vector<int> v2({1, 2, 3}, std::pmr::new_delete_resource());\n        // Specifying a specific memory resource\n\n    std::pmr::vector<int> v1 = {1, 2, 3};\n        // Using the default memory resource\n```", "```cpp\n    template<class T, class A = std::allocator<T>>\n    class uniqueish {\n      using Traits = std::allocator_traits<A>;\n      using FancyPtr = typename Traits::pointer;\n\n      A m_allocator;\n      FancyPtr m_ptr = nullptr;\n\n    public:\n      using allocator_type = A;\n\n      uniqueish(A a = {}) : m_allocator(a) {\n        this->emplace();\n      }\n\n      ~uniqueish() {\n        clear();\n      }\n\n      T& value() { return *m_ptr; }\n      const T& value() const { return *m_ptr; }\n\n      template<class... Args>\n      void emplace(Args&&... args) {\n        clear();\n        m_ptr = Traits::allocate(m_allocator, 1);\n        try {\n          T *raw_ptr = static_cast<T *>(m_ptr);\n          Traits::construct(m_allocator, raw_ptr,\n              std::forward<Args>(args)...\n          );\n        } catch (...) {\n          Traits::deallocate(m_allocator, m_ptr, 1);\n          throw;\n        }\n      }\n\n      void clear() noexcept {\n        if (m_ptr) {\n          T *raw_ptr = static_cast<T *>(m_ptr);\n          Traits::destroy(m_allocator, raw_ptr);\n          Traits::deallocate(m_allocator, m_ptr, 1);\n          m_ptr = nullptr;\n        }\n      }\n    };\n```", "```cpp\n    uniqueish(uniqueish&& rhs) : m_allocator(rhs.m_allocator) \n    {\n      m_ptr = std::exchange(rhs.m_ptr, nullptr);\n    }\n\n    uniqueish& operator=(uniqueish&& rhs)\n    {\n      constexpr bool pocma =\n        Traits::propagate_on_container_move_assignment::value;\n      if constexpr (pocma) {\n        // We can adopt the new allocator, since\n        // our allocator type is not \"sticky\".\n        this->clear(); // using the old allocator\n        this->m_allocator = rhs.m_allocator;\n        this->m_ptr = std::exchange(rhs.m_ptr, nullptr);\n      } else if (m_allocator() == rhs.m_allocator()) {\n        // Our allocator is \"stuck\" to this container;\n        // but since it's equivalent to rhs's allocator,\n        // we can still adopt rhs's memory.\n        this->clear();\n        this->m_ptr = std::exchange(rhs.m_ptr, nullptr);\n      } else {\n        // We must not propagate this new allocator\n        // and thus cannot adopt its memory.\n        if (rhs.m_ptr) {\n          this->emplace(std::move(rhs.value()));\n          rhs.clear();\n        } else {\n          this->clear();\n        }\n      }\n      return *this;\n    }\n```", "```cpp\n    void swap(uniqueish& rhs) noexcept {\n      constexpr bool pocs =\n        Traits::propagate_on_container_swap::value;\n      using std::swap;\n      if constexpr (pocs) {\n        // We can swap allocators, since\n        // our allocator type is not \"sticky\".\n        swap(this->m_allocator, rhs.m_allocator);\n        swap(this->m_ptr, rhs.m_ptr);\n      } else if (m_allocator == rhs.m_allocator) {\n        // Our allocator is \"stuck\" to this container;\n        // but since it's equivalent to rhs's allocator,\n        // we can still adopt rhs's memory and vice versa.\n        swap(this->m_ptr, rhs.m_ptr);\n      } else {\n        // Neither side can adopt the other's memory, and\n        // so one side or the other must allocate.\n        auto temp = std::move(*this);\n        *this = std::move(rhs); // might throw\n        rhs = std::move(temp); // might throw\n      }\n    }\n```", "```cpp\n    void swap(uniqueish& rhs) noexcept {\n      constexpr bool pocs =\n        Traits::propagate_on_container_swap::value;\n      using std::swap;\n      if constexpr (pocs) {\n        swap(this->m_allocator, rhs.m_allocator);\n      }\n      // Don't even check that we know how to free\n      // the adopted pointer; just assume that we can.\n      swap(this->m_ptr, rhs.m_ptr);\n    }\n```", "```cpp\n    char buffer[100];\n    auto mr = std::pmr::monotonic_buffer_resource(buffer, 100);\n\n    std::pmr::vector<int> a {1,2,3};\n    std::pmr::vector<int> b({4,5,6}, &mr);\n\n    std::swap(a, b);\n      // UNDEFINED BEHAVIOR\n\n    a.reserve(a.capacity() + 1);\n      // this line will undoubtedly crash, as\n      // it tries to delete[] a stack pointer\n```", "```cpp\n    auto temp = std::move(a); // OK\n    a = std::move(b); // OK\n    b = std::move(temp); // OK\n```", "```cpp\n    template<class T>\n    struct my_allocator : std::allocator<T> \n    {\n      my_allocator() = default;\n\n      template<class U>\n      my_allocator(const my_allocator<U>&) {}\n\n      template<class... Args>\n      void construct(T *p, Args&&... args) {\n        if (sizeof...(Args) == 0) {\n          ::new ((void*)p) T;\n        } else {\n          ::new ((void*)p) T(std::forward<Args>(args)...);\n        }\n      }\n    };\n```", "```cpp\n    std::vector<std::vector<int>> vv;\n    vv.emplace_back();\n    vv.emplace_back();\n    vv[0].push_back(1);\n    vv[1].push_back(2);\n    vv[1].push_back(3);\n```", "```cpp\n    char buffer[10000];\n    std::pmr::monotonic_buffer_resource mr {buffer, sizeof buffer};\n\n    using InnerAlloc = WidgetAlloc<int>;\n    using InnerVector = std::vector<int, InnerAlloc>;\n    using OuterAlloc = WidgetAlloc<InnerVector>;\n\n    std::vector<InnerVector, OuterAlloc> vv(&mr);\n    vv.emplace_back(&mr);\n    vv.emplace_back(&mr);\n    vv[0].push_back(1);\n    vv[1].push_back(2);\n    vv[1].push_back(3);\n```", "```cpp\n    char buffer[10000];\n    std::pmr::monotonic_buffer_resource mr {buffer, sizeof buffer};\n\n    using InnerAlloc = WidgetAlloc<int>;\n    using InnerVector = std::vector<int, InnerAlloc>;\n    using OuterAlloc = std::scoped_allocator_adaptor<WidgetAlloc<InnerVector>>;\n\n    std::vector<InnerVector, OuterAlloc> vv(&mr);\n    vv.emplace_back();\n    vv.emplace_back();\n    vv[0].push_back(1);\n    vv[1].push_back(2);\n    vv[1].push_back(3);\n```", "```cpp\n    using InnerAlloc = WidgetAlloc<int>;\n    using InnerVector = std::vector<int, InnerAlloc>;\n\n    using MiddleAlloc = std::scoped_allocator_adaptor<\n      WidgetAlloc<InnerVector>,\n      WidgetAlloc<int>\n    >;\n    using MiddleVector = std::vector<InnerVector, MiddleAlloc>;\n\n    using OuterAlloc = std::scoped_allocator_adaptor<\n      WidgetAlloc<MiddleVector>,\n      WidgetAlloc<InnerVector>,\n      WidgetAlloc<int>\n    >;\n    using OuterVector = std::vector<MiddleVector, OuterAlloc>;\n```", "```cpp\n    char bi[1000];\n    std::pmr::monotonic_buffer_resource mri {bi, sizeof bi};\n    char bm[1000];\n    std::pmr::monotonic_buffer_resource mrm {bm, sizeof bm};\n    char bo[1000];\n    std::pmr::monotonic_buffer_resource mro {bo, sizeof bo};\n\n    OuterAlloc saa(&mro, &mrm, &mri);\n```", "```cpp\n    OuterVector vvv(saa);\n\n    vvv.emplace_back();\n      // This allocation comes from buffer \"bo\".\n\n    vvv[0].emplace_back();\n      // This allocation comes from buffer \"bm\".\n\n    vvv[0][0].emplace_back(42);\n      // This allocation comes from buffer \"bi\".\n```", "```cpp\n    using InnerAlloc = WidgetAlloc<int>;\n    using InnerVector = std::vector<int, InnerAlloc>;\n\n    using MiddleAlloc = std::scoped_allocator_adaptor<\n      WidgetAlloc<InnerVector>\n    >;\n    using MiddleVector = std::vector<InnerVector, MiddleAlloc>;\n\n    using TooShortAlloc = std::scoped_allocator_adaptor<\n      WidgetAlloc<MiddleVector>,\n      WidgetAlloc<InnerVector>\n    >;\n    using OuterVector = std::vector<MiddleVector, TooShortAlloc>;\n\n    TooShortAlloc tsa(&mro, WidgetAlloc<InnerVector>(&mri));\n    OuterVector tsv(tsa);\n\n    tsv.emplace_back();\n      // This allocation comes from buffer \"bo\".\n\n    tsv[0].emplace_back();\n      // This allocation comes from buffer \"bi\".\n\n    tsv[0][0].emplace_back(42);\n      // This allocation AGAIN comes from buffer \"bi\"!\n```"]