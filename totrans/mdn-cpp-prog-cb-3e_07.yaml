- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Files and Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important parts of the C++ standard library is the **input/output**
    (**I/O**) stream-based library that enables developers to work with files, memory
    streams, or other types of I/O devices. The first part of this chapter provides
    solutions to some common stream operations, such as reading and writing data,
    localization settings, and manipulating the input and output of a stream. The
    second part of the chapter explores the C++17 `filesystem` library, which enables
    developers to perform operations with the filesystem and its objects, such as
    files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing raw data from/to binary files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing objects from/to binary files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using streams on fixed-size external buffers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using localized settings for streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using I/O manipulators to control the output of a stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using monetary I/O manipulators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using time I/O manipulators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with filesystem paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating, copying, and deleting files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing content from a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the properties of an existing file or directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating the content of a directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start the chapter with a couple of recipes on how to serialize and deserialize
    data to/from files.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing raw data from/to binary files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the data programs you work with must be persisted to disk files in various
    ways, including storing data in a database or flat files, either as text or binary
    data. This recipe, and the next one, are focused on persisting and loading both
    raw data and objects from and to binary files.
  prefs: []
  type: TYPE_NORMAL
- en: In this context, raw data means unstructured data, and, in this recipe, we will
    consider writing and reading the content of a buffer (that is, a contiguous sequence
    of memory), which can either be an array, a `std::vector`, or a `std::array`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you should be familiar with the standard stream I/O library,
    although some explanations, to the extent that is required to understand this
    recipe, are provided next. You should also be familiar with the differences between
    binary and text files.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use the `ofstream` and `ifstream` classes, which are
    available in the `std` namespace in the `<fstream>` header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To write the content of a buffer (in our example, a `std::vector`) to a binary
    file, you should perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a file stream for writing in binary mode by creating an instance of the
    `std::ofstream` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure that the file is actually open before writing data to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the data to the file by providing a pointer to the array of characters
    and the number of characters to write. In the following example, we write the
    content of a local vector; however, typically, this data comes from a different
    context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Optionally, you can flush the content of the stream’s output buffer to the actual
    disk file by calling the `flush()` method. This determines the uncommitted changes
    in the stream to be synchronized with the external destination, which, in this
    case, is a disk file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Close the stream by calling `close()`. This, in turn, calls `flush()`, making
    the preceding step unnecessary in most contexts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To read the entire content of a binary file to a buffer, you should perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a file stream to read from a file in binary mode by creating an instance
    of the `std::ifstream` class. The path to the file can be absolute or relative
    to the current working directory (not to the path of the executable). In this
    example, the path is relative:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure that the file is actually open before reading data from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Determine the length of the file by positioning the input position indicator
    to the end of the file, read its value, and then move the indicator to the beginning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Allocate memory to read the content of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read the content of the file to the allocated buffer by providing a pointer
    to the array of characters for receiving the data and the number of characters
    to read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check that the read operation is completed successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, close the file stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard stream-based I/O library provides various classes that implement
    high-level input, output, or both input and output file stream, string stream
    and character array operations, manipulators that control how these streams behave,
    and several predefined stream objects (`cin`/`wcin`, `cout`/`wcout`, `cerr`/`wcerr`,
    and `clog`/`wclog`).
  prefs: []
  type: TYPE_NORMAL
- en: 'These streams are implemented as class templates and, for files, the library
    provides several (non-copyable) classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`basic_filebuf` implements the I/O operations for a raw file and is similar
    in semantics to a C `FILE` stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`basic_ifstream` implements the high-level file stream input operations defined
    by the `basic_istream` stream interface, internally using a `basic_filebuf` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`basic_ofstream` implements the high-level file stream output operations defined
    by the `basic_ostream` stream interface, internally using a `basic_filebuf` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`basic_fstream` implements the high-level file stream input and output operations
    defined by the `basic_iostream` stream interface, internally using a `basic_filebuf`
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These classes are represented in the following class diagram to better understand
    their relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21549_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Stream class diagram'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this diagram also features several classes designed to work with
    a string-based stream. These streams, however, will not be discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several typedefs for the class templates mentioned earlier are also defined
    in the `<fstream>` header, in the `std` namespace. The `ofstream` and `ifstream`
    objects are the type synonyms used in the preceding examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the previous section, you saw how we can write and read raw data to and from
    a file stream. Now, we’ll cover this process in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: To write data to a file, we instantiated an object of the type `std::ofstream`.
    In the constructor, we passed the name of the file to be opened and the stream’s
    open mode, for which we specified `std::ios::binary` to indicate binary mode.
    Opening the file like this discards the previous file content. If you want to
    append content to an existing file, you should also use the flag `std::ios::app`
    (that is, `std::ios::app | std::ios::binary`). This constructor internally calls
    `open()` on its underlying raw file object (that is, a `basic_filebuf` object).
    If this operation fails, a fail bit is set. To check whether the stream has been
    successfully associated with a file device, we used `is_open()` (this internally
    calls the method with the same name from the underlying `basic_filebuf`). Writing
    data to the file stream is done using the `write()` method, which takes a pointer
    to the string of characters to write and the number of characters to write. Since
    this method operates with strings of characters, a `reinterpret_cast` is necessary
    if data is of another type, such as `unsigned char`, in our example. The write
    operation does not set a fail bit in the case of a failure, but it may throw a
    `std::ios_base::failure` exception. However, data is not written directly to the
    file device but stored in the `basic_filebuf` object. To write it to the file,
    the buffer needs to be flushed, which is done by calling `flush()`. This is done
    automatically when closing the file stream, as shown in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: To read data from a file, we instantiated an object of type `std::ifstream`.
    In the constructor, we passed the same arguments that we used for opening the
    file to write the name of the file and the open mode (that is, `std::ios::binary`).
    The constructor internally calls `open()` on the underlying `std::basic_filebuf`
    object. To check whether the stream has been successfully associated with a file
    device, we use `is_open()` (this internally calls the method with the same name
    from the underlying `basic_filebuf`). In this example, we read the entire content
    of the file to a memory buffer, in particular, a `std::vector`. Before we can
    read the data, we must know the size of the file in order to allocate a buffer
    that is large enough to hold that data. To do this, we used `seekg()` to move
    the input position indicator to the end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we called `tellg()` to return the current position, which, in this case,
    indicates the size of the file, in bytes, and then we moved the input position
    indicator to the beginning of the file to be able to start reading from the beginning.
    Calling `seekg()` to move the position indicator to the end can be avoided by
    opening the file with the position indicator moved directly to the end. This can
    be achieved by using the `std::ios::ate` opening flag in the constructor (or the
    `open()` method). After allocating enough memory for the content of the file,
    we copied the data from the file into memory using the `read()` method. This takes
    a pointer to the string of characters that receives the data read from the stream
    and the number of characters to be read. Since the stream operates on characters,
    a `reinterpret_cast` expression is necessary if the buffer contains other types
    of data, such as `unsigned char` in our example.
  prefs: []
  type: TYPE_NORMAL
- en: This operation throws a `std::basic_ios::failure` exception if an error occurs.
    To determine the number of characters that have been successfully read from the
    stream, we can use the `gcount()` method. Upon completing the read operation,
    we close the file stream.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to the use of the `seekg()`/`tellg()` approach described here
    for determining the size of an open file is to use the `std::filesystem::file_size()`
    function from the filesystem library. This requires a path only; it does not need
    the file to be opened. It can also determine the size of a directory, but this
    is implementation-defined. This function is presented later in the chapter in
    the *Checking the properties of an existing file or directory* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The operations shown in these examples are the minimum ones required to write
    and read data to and from file streams. It is important, though, that you perform
    appropriate checks for the success of the operations and to catch any possible
    exceptions that could occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important thing to notice is the value of the argument representing the
    number of characters to write or read. In the examples seen so far, we have used
    buffers of `unsigned char`. The size of `unsigned char` is 1, as with `char`.
    Therefore, the count of characters is the number of elements in the buffer. However,
    if the buffer contains `int` elements, for instance, things change. An `int` is,
    typically, 32-bit, which means that, reinterpreted as `char`, it is equivalent
    to 4 characters. This means that when we write anything that has a size greater
    than 1, we need to multiply the number of elements by the size of an element,
    as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, when we read, we need to account for the size of the elements we
    read from the file, which is exemplified next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The example code discussed so far in this recipe can be reorganized in the
    form of two general functions for writing and reading data to and from a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`write_data()` is a function that takes the name of a file, a pointer to an
    array of characters, and the length of this array as arguments and writes the
    characters to the specified file. `read_data()` is a function that takes the name
    of a file and a function that allocates a buffer and reads the entire content
    of the file to the buffer that is returned by the allocated function. The following
    is an example of how these functions can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could use a dynamically allocated buffer, instead of the
    `std::vector`; the changes required for this are small in the overall example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: However, this alternative is only provided to show that `read_data()` can be
    used with different kinds of input buffers. It is recommended that you avoid the
    explicit dynamic allocation of memory whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The way of reading data from a file to memory, as shown in this recipe, is
    only one of several. The following is a list of possible alternatives for reading
    data from a file stream:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initializing a `std::vector` directly using `std::istreambuf_iterator` iterators
    (similarly, this can be used with `std::string`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assigning the content of a `std::vector` from `std::istreambuf_iterator` iterators:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copying the content of the file stream to a vector using `std::istreambuf_iterator`
    iterators and a `std::back_inserter` adapter to write to the end of the vector:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compared to these alternatives, however, the method described in the *How to
    do it...* section is the fastest one, even though the alternatives may look more
    appealing from an object-oriented perspective. It is beyond the scope of this
    recipe to compare the performance of these alternatives, but you can try it as
    an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Reading and writing objects from/to binary files*, to learn how to serialize
    and deserialize objects to and from binary files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using I/O manipulators to control the output of a stream*, to learn about
    the use of helper functions, called manipulators, that control input and output
    streams using the `<<` and `>>` stream operators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing objects from/to binary files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to write and read raw data (that is,
    unstructured data) to and from a file. Many times, however, we must persist and
    load objects instead. Writing and reading in the manner shown in the previous
    recipe works for POD types only. For anything else, we must explicitly decide
    what is actually written or read, since writing or reading pointers (including
    those to virtual tables) and any sort of metadata is not only irrelevant but also
    semantically wrong. These operations are commonly referred to as serialization
    and deserialization. In this recipe, we will learn how to serialize and deserialize
    both POD and non-POD types to and from binary files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the examples in this recipe, we will use the `foo` and `foopod` classes,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It is recommended that you first read the previous recipe, *Reading and writing
    raw data from/to binary files*, before you continue. You should also know what
    POD (a type that is both trivial and has a standard layout) and non-POD types
    are and how operators can be overloaded. You can check the closing notes of the
    *Using type traits to query properties of types* recipe, in *Chapter 6*, *General-Purpose
    Utilities*, for further details on POD types.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To serialize/deserialize POD types that do not contain pointers, use `ofstream::write()`
    and `ifstream::read()`, as shown in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Serialize objects to a binary file using `ofstream` and the `write()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Deserialize objects from a binary file using the `ifstream` and `read()` methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To serialize non-POD types (or POD types that contain pointers), you must explicitly
    write the value of the data members to a file, and to deserialize, you must explicitly
    read from the file to the data members in the same order. To demonstrate this,
    we will consider the `foo` class that we defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a member function called `write()` to serialize objects of this class.
    The method takes a reference to an `ofstream` and returns a `bool` indicating
    whether the operation was successful or not:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a member function called `read()` to deserialize the objects of this class.
    This method takes a reference to an `ifstream` and returns a `bool` indicating
    whether the operation was successful or not:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An alternative to the `write()` and `read()` member functions demonstrated
    earlier is to overload `operator<<` and `operator>>`. To do this, you should perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `friend` declarations for the non-member `operator<<` and `operator>>`
    to the class to be serialized/deserialized (in this case, the `foo` class):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Overload `operator<<` for your class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Overload `operator>>` for your class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Regardless of whether we serialize the entire object (for POD types) or only
    parts of it, we use the same stream classes that we discussed in the previous
    recipe: `ofstream` for output file streams and `ifstream` for input file streams.
    Details about writing and reading data using these standard classes have been
    discussed in that recipe and will not be reiterated here.'
  prefs: []
  type: TYPE_NORMAL
- en: When you serialize and deserialize objects to and from files, you should avoid
    writing the values of the pointers to a file. Additionally, you must not read
    pointer values from the file since these represent memory addresses and are meaningless
    across processes, and even in the same process some moments later. Instead, you
    should write data referred by a pointer and read data into objects referred by
    a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: This is a general principle, and, in practice, you may encounter situations
    where a source may have multiple pointers to the same object; in this case, you
    might want to write only one copy and also handle the reading in a corresponding
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the objects you want to serialize are of the POD type, you can do it just
    like we did when we discussed raw data. In the example in this recipe, we serialized
    a sequence of objects of the `foopod` type. When we deserialize, we read from
    the file stream in a loop until the end of the file is read or a failure occurs.
    The way we read, in this case, may look counterintuitive, but doing it differently
    may lead to the duplication of the last read value:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading is done in an infinite loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A read operation is performed in the loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A check for a failure or the end of file is performed, and if either of them
    has occurred, the infinite loop is exited.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value is added to the input sequence and the looping continues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If reading is done using a loop with an exit condition that checks the end of
    the file bit, that is, `while(!ifile.eof())`, the last value will be added to
    the input sequence twice. The reason for this is that upon reading the last value,
    the end of the file has not yet been encountered (as that is a mark beyond the
    last byte of the file). The end of the file mark is only reached at the next read
    attempt, which, therefore, sets the `eofbit` of the stream. However, the input
    variable still has the last value since it hasn’t been overwritten with anything,
    and this is added to the input vector for a second time.
  prefs: []
  type: TYPE_NORMAL
- en: If the objects you want to serialize and deserialize are of non-POD types, writing/reading
    these objects as raw data is not possible. For instance, such an object may have
    a virtual table. Writing the virtual table to a file does not cause problems,
    even though it does not have any value; however, reading from a file, and, therefore,
    overwriting the virtual table of an object, will have catastrophic effects on
    the object and the program.
  prefs: []
  type: TYPE_NORMAL
- en: When serializing/deserializing non-POD types, there are various alternatives,
    and some of them have been discussed in the previous section. All of them provide
    explicit methods for writing and reading or overloading the standard `<<` and
    `>>` operators. The second approach has an advantage in that it enables the use
    of your class in generic code, where objects are written and read to and from
    stream files using these operators.
  prefs: []
  type: TYPE_NORMAL
- en: When you plan to serialize and deserialize your objects, consider versioning
    your data from the very beginning to avoid problems if the structure of your data
    changes over time. How versioning should be done is beyond the scope of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Reading and writing raw data from/to binary files*, to learn how to write
    and read unstructured data to binary files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using I/O manipulators to control the output of a stream*, to learn about
    the use of helper functions, called manipulators, that control input and output
    streams using the `<<` and `>>` stream operators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using streams on fixed-size external buffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `<strstream>` header has been part of the standard I/O library from its
    beginning. It contains classes that provide stream operations on sequences of
    characters stored in an array. However, this header was deprecated a long time
    ago, in C++98, although it’s still available because a replacement wasn’t available.
    The C++20 standard has introduced the `std::span` class, which is a non-owning
    view of a sequence of objects. In C++23, a new header, `<spanstream>`, has been
    added as a replacement for `<strstream>`. This contains classes that provide stream
    operations on externally provided memory buffers. In this recipe, we’ll learn
    how to parse or write text using the I/O span streams.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the new C++23 span streams as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To parse text from an external array, use `std::ispanstream`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To write text to an external array, use `std::ospanstream`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To both read and write to the same external array, use `std::spanstream`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stream input/output operations can be used with externally allocated buffers.
    However, the `<strstream>` header and its `strstream`, `istrstream`, `ostrstream`,
    and `strstreambuf` classes were deprecated in C++98 without any replacement available.
    The reasons for deprecating them include safety, since `strstreambuf` does not
    enforce bounds checking, and inflexibility, due to its limitations in resizing
    the underlying buffer. The `std::stringstream` was the only recommended alternative.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++23, a new set of similar classes is available in the new `<spanstream>`
    header: `basic_spanstream`, `basic_ispanstream`, `basic_ospanstream`, and `basic_spanbuf`.
    These enable stream operations on externally allocated fixed-size buffers. These
    classes do not provide support for ownership or reallocation of the buffer. For
    such scenarios, `std::stringstream` should be used.'
  prefs: []
  type: TYPE_NORMAL
- en: The `std::basic_spanbuf` controls input and output to a sequence of characters.
    Its associated sequence (the source for input, and the sink for output) is an
    externally allocated buffer of a fixed size that can be initialized from or made
    available as a `std::span`. This is wrapped by the `std::basic_ispanstream`, `std::basic_ospanstream`,
    and `std::basic_spanstream`, which provide higher-level interfaces for input/output
    operations, as defined by the `std::basic_istream`, `std::basic_ostream`, and
    `std::basic_stream` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take another example to look at this. Consider we have a string that
    contains a sequence of key-value pairs separated by a comma. We want to read these
    pairs and put them in a map. We can write the following code in C++23:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `std::getline()` function allows us to read characters from an input stream
    either until its end or until a specified delimiter is encountered. Using it,
    we split the text first using the `=` and `,` delimiters. The sequence of characters
    until `=` represents the key, and everything after `=` until the next comma or
    the end is the value. `std::ws` is an I/O manipulator that discards whitespaces
    from an input stream. In simple terms, we read until we find an equals sign; all
    the text until there is the key. Then, we read until we find a comma (or reach
    the end); all the text until there is the value. We do this in a loop as long
    as we keep encountering an equals sign.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading from a fixed-size buffer is not very difficult, but writing requires
    more checks because writing cannot exceed the bounds of the buffer, in which case,
    a write operation fails. Let’s take an example to understand this better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The external array has 3 bytes. We write the text `42`, and this operation succeeds.
    Then, we attempt to write the text `44`. However, this would require that the
    external buffer has 4 bytes, but it only has 3\. Therefore, after writing the
    character `4`, the operation fails. At this point, the content of the text buffer
    is `'``4'`,`'2'`,`'4'`, and there is no null-terminating character. If we print
    this to the console, after `424`, there will be some gibberish based on the content
    found in memory until the first 0\.
  prefs: []
  type: TYPE_NORMAL
- en: To check whether the writing operation failed, we use the `good()` member function.
    If this returns `false`, then we need to clear the error flags. We also set the
    stream’s output position indicator to the value it had before attempting the read
    (which can be retrieved with the `tellp()` member function). At this point, if
    we write a `0` to the output buffer, its content will be `'4'`,`'2'`,`'\0'`, so
    printing it to the console will show the text `42`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to both read and write to the same buffer, you can use the `std::spanstream`
    class, which provides both input and output stream operations. An example was
    shown in the *How to do it…* section.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 6*, *Using std::span for contiguous sequences of objects*, to learn
    how to use non-owning views over contiguous sequences of elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using localized settings for streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How writing or reading to and from streams is performed may depend on the language
    and regional settings. Examples include writing and parsing numbers, time values,
    or monetary values, or comparing (collating) strings. The C++ I/O library provides
    a general-purpose mechanism for handling internationalization features through
    *locales* and *facets*. In this recipe, you will learn how to use locales to control
    the behavior of input/output streams.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of the examples in this recipe use the `std::cout` predefined console stream
    object. However, the same applies to all I/O stream objects. Also, in these recipe
    examples, we will use the following objects and lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The names Øivind and Åke contain the Danish/Norwegian-specific characters Ø
    and Å. In the Danish/Norwegian alphabet, these are the last two letters (in this
    order) of the alphabet. These are used to exemplify the effect of using locales.
  prefs: []
  type: TYPE_NORMAL
- en: 'The locale names used in this recipe (`en_US.utf8`, `de_DE.utf8`, and so on)
    are the ones that are used on UNIX systems. The following table lists their equivalents
    for Windows systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **UNIX** | **Windows** |'
  prefs: []
  type: TYPE_TB
- en: '| `en_US.utf8` | `English_US.1252` |'
  prefs: []
  type: TYPE_TB
- en: '| `en_GB.utf8` | `English_UK.1252` |'
  prefs: []
  type: TYPE_TB
- en: '| `de_DE.utf8` | `German_Germany.1252` |'
  prefs: []
  type: TYPE_TB
- en: '| `no_NO.utf8` | `Norwegian_Norway.1252` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.1: List of UNIX and Windows names of locales used in this recipe'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To control the localization settings of a stream, you must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `std::locale` class to represent the localization settings. There are
    various ways in which to construct locale objects, including the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default construct is to use the global locale (by default, the `C` locale at
    the program startup)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From a local name, such as `C`, `POSIX,` `en_US.utf8`, and so on, if supported
    by the operating system
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From another locale, except for a specified facet
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From another locale, except for all of the facets from a specified category
    that are copied from another specified locale:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'To get a copy of the default `C` locale, use the `std::locale::classic()` static
    method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To change the default locale that is copied every time a locale is default-constructed,
    use the `std::locale::global()` static method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `imbue()` method to change the current locale of an I/O stream:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following list shows examples of using various locales:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a particular locale, indicated by its name. In this example, the locale
    is for German:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a locale that corresponds to the user settings (as defined in the system).
    This is done by constructing a `std::locale` object from an empty string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set and use the global locale:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the default `C` locale:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A locale object does not actually store localized settings. A *locale* is a
    heterogeneous container of facets. A *facet* is an object that defines the localization
    and internationalization settings. The standard defines a list of facets that
    each locale must contain. In addition to this, a locale can contain any other
    user-defined facets. The following is a list of all standard-defined facets:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `std::collate<char>` | `std::collate<wchar_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::ctype<char>` | `std::ctype<wchar_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::codecvt<char,char,mbstate_t>``std::codecvt<char16_t,char,mbstate_t>`
    | `std::codecvt<char32_t,char,mbstate_t>``std::codecvt<wchar_t,char,mbstate_t>`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `std::moneypunct<char>``std::moneypunct<char,true>` | `std::moneypunct<wchar_t>``std::moneypunct<wchar_t,true>`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `std::money_get<char>` | `std::money_get<wchar_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::money_put<char>` | `std::money_put<wchar_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::numpunct<char>` | `std::numpunct<wchar_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::num_get<char>` | `std::num_get<wchar_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::num_put<char>` | `std::num_put<wchar_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::time_get<char>` | `std::time_get<wchar_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::time_put<char>` | `std::time_put<wchar_t>` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::messages<char>` | `std::messages<wchar_t>` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.2: List of standard facets'
  prefs: []
  type: TYPE_NORMAL
- en: It is beyond the scope of this recipe to go through this list and discuss all
    of these facets. However, we will mention that `std::money_get` is a facet that
    encapsulates the rules for parsing monetary values from character streams, while
    `std::money_put` is a facet that encapsulates the rules for formatting monetary
    values as strings. In a similar manner, `std::time_get` encapsulates rules for
    data and time parsing, while `std::time_put` encapsulates rules for data and time
    formatting. These will form the subject of the next couple of recipes.
  prefs: []
  type: TYPE_NORMAL
- en: A locale is an immutable object containing immutable facet objects. Locales
    are implemented as a reference-counted array of reference-counted pointers to
    facets. The array is indexed by `std::locale::id`, and all facets must be derived
    from the base class `std::locale::facet` and must have a public static member
    of the `std::locale::id` type, called `id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is only possible to create a locale object using one of the overloaded constructors
    or with the `combine()` method, which, as the name implies, combines the current
    locale with a new compile-time identifiable facet and returns a new locale object.
    The next example shows the use of the US English locale but with the numerical
    punctuation settings from the Norwegian locale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, it is possible to determine whether a locale contains a particular
    facet using the `std::has_facet()` function template, or to obtain a reference
    to a facet implemented by a particular locale using the `std::use_facet()` function
    template.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding examples, we sorted a vector of strings and passed a locale
    object as the third argument to the `std::sort()` general algorithm. This third
    argument is supposed to be a comparison function object. Passing a locale object
    works because `std::locale` has an `operator()` that lexicographically compares
    two strings using its collate facet. This is actually the only localization functionality
    that is directly provided by `std::locale`; however, what this does is invoke
    the collate facet’s `compare()` method, which performs the string comparison based
    on the facet’s rules.
  prefs: []
  type: TYPE_NORMAL
- en: Every program has a global locale created when the program starts. The content
    of this global locale is copied into every default-constructed locale. The global
    locale can be replaced using the static method `std::locale::global()`. By default,
    the global locale is the `C` locale, which is a locale equivalent to ANSI C’s
    locale with the same name. This locale was created to handle simple English text,
    and it is the default one in C++ that provides compatibility with C. A reference
    to this locale can be obtained with the static method `std::locale::classic()`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, all streams use the classic locale to write or parse text. However,
    it is possible to change the locale used by a stream using the stream’s `imbue()`
    method. This is a member of the `std::ios_base` class, which is the base for all
    I/O streams. A companion member is the `getloc()` method, which returns a copy
    of the current stream’s locale.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding examples, we changed the locale for the `std::cout` stream
    object. In practice, you may want to set the same locale for all stream objects
    associated with the standard C streams: `cin`, `cout`, `cerr`, and `clog` (or
    `wcin`, `wcout`, `wcerr`, and `wclog`).'
  prefs: []
  type: TYPE_NORMAL
- en: When you want to use a particular locale (such as German or Norwegian, as shown
    in this recipe), you must make sure they are available on your system. On Windows,
    this should not be a problem, but on a Linux system, they might not be installed.
    In this case, trying to instantiate a `std::locale` object, such as with `std::locale("de_DE.utf8")`,
    would result in a `std::runtime_error` exception being thrown. To install a locale
    on your system, consult its documentation to find the necessary steps you have
    to perform.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using I/O manipulators to control the output of a stream*, to learn about
    the use of helper functions, called manipulators, that control input and output
    streams using the `<<` and `>>` stream operators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using monetary I/O manipulators*, to learn how to use standard manipulators
    to write and read monetary values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using time I/O manipulators*, to learn how to use standard manipulators to
    write and read date and time values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using I/O manipulators to control the output of a stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from the stream-based I/O library, the standard library provides a series
    of helper functions, called manipulators, that control the input and output streams
    using `operator<<` and `operator>>`. In this recipe, we will look at some of these
    manipulators and demonstrate their use through some examples that format the output
    to the console. We will continue covering more manipulators in the upcoming recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The I/O manipulators are available in the `std` namespace in the headers `<ios>`,
    `<istream>`, `<ostream>`, and `<iomanip>`. In this recipe, we will only discuss
    some of the manipulators from `<ios>` and `<iomanip>`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following manipulators can be used to control the output or input of a
    stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolalpha` and `noboolalpha` enable and disable the textual representation
    of Booleans:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`left`, `right`, and `internal` affect the alignment of the fill characters;
    `left` and `right` affect all text, but `internal` affects only the integer, floating-point,
    and monetary output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`fixed`, `scientific`, `hexfloat`, and `defaultfloat` change the formatting
    used for floating-point types (for both the input and output streams). The latter
    two have only been available since C++11:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`dec`, `hex`, and `oct` control the base that is used for the integer types
    (in both the input and output streams):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`setw` changes the width of the next input or output field. The default width
    is 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setfill` changes the fill character for the output stream; this is the character
    that is used to fill the next fields until the specified width is reached. The
    default fill character is whitespace:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`setprecision` changes the decimal precision (how many digits are generated)
    for the floating-point types in both the input and output streams. The default
    precision is 6:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the I/O manipulators listed earlier (with the exception of `setw`, which
    only refers to the next output field) affect the stream. Additionally, all consecutive
    writing or reading operations use the last specified format until another manipulator
    is used again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of these manipulators are called without arguments. Examples include `boolalpha`/`noboolalpha`
    or `dec`/`hex`/`oct`. These manipulators are functions that take a single argument
    (that is, a reference to a string) and return a reference to the same stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Expressions, such as `std::cout << std::hex`, are possible because both `basic_ostream::operator<<`
    and `basic_istream::operator>>` have special overloads that take a pointer to
    these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other manipulators, including some that are not mentioned here, are invoked
    with arguments. These manipulators are functions that take one or more arguments
    and return an object of an unspecified type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: To better demonstrate the use of these manipulators, we will consider two examples
    that format output to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first example, we will list the table of contents of a book with the
    following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The chapter number is right-aligned and shown with Roman numerals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chapter title is left-aligned and the remaining space until the page number
    is filled with dots.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The page number of the chapter is right-aligned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this example, we will use the following classes and helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`std::left` and `std::right` specify the text alignment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::setw` specifies the width of each output field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::fill` specifies the fill character (a blank space for the chapter number
    and a dot for the chapter title)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation of the `print_toc()` function is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example uses this method with a `Book` object describing the
    table of contents from the book *The Fellowship of the Ring*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'For the second example, our goal is to output a table that lists the largest
    companies in the world by revenue. The table will have columns for the company
    name, the industry, the revenue (in USD billions), the increase/decrease in revenue
    growth, the revenue growth, the number of employees, and the country of origin.
    For this example, we will use the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `print_companies()` function in the following code snippet uses several
    additional manipulators to the ones shown in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::boolalpha` displays Boolean values as `true` and `false` instead of `1`
    and `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::fixed` indicates a fixed floating-point representation, and then `std::defaultfloat`
    reverts to the default floating-point representation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::setprecision` specifies the number of decimal digits to be displayed
    in the output. Together with `std::fixed`, this is used to indicate a fixed representation
    with a decimal digit for the `Growth` field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation of the `print_companies()` function is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of calling this method. The source of the data
    shown here is Wikipedia ([https://en.wikipedia.org/wiki/List_of_largest_companies_by_revenue](https://en.wikipedia.org/wiki/List_of_largest_companies_by_revenue),
    as of 2016):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the output has a table-based format, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise, you can try adding a table heading or even a grid line to precede
    these lines for a better tabulation of the data.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Reading and writing raw data from/to binary files*, to learn how to write
    and read unstructured data to binary files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using monetary I/O manipulators*, to learn how to use standard manipulators
    to write and read monetary values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using time I/O manipulators*, to learn how to use standard manipulators to
    write and read date and time values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using monetary I/O manipulators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we looked at some of the manipulators that can be used
    to control input and output streams. The manipulators that we discussed were related
    to numeric values and text values. In this recipe, we will look at how to use
    standard manipulators to write and read monetary values.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should now be familiar with locales and how to set them for a stream. This
    topic was discussed in the *Using localized settings for streams* recipe. It is
    recommended that you read that recipe before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: The manipulators discussed in this recipe are available in the `std` namespace,
    in the `<iomanip>` header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To write a monetary value to an output stream, you should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the desired locale for controlling the monetary format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use either a `long double` or a `std::basic_string` value for the amount:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a `std::put_money` manipulator with a single argument (the monetary value)
    to display the value using the currency symbol (if any is available):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::put_money` with two arguments (the monetary value and a Boolean flag
    set to `true`) to indicate the use of an international currency string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To read a monetary value from an input stream, you should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the desired locale to control the monetary format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use either a `long double` or `std::basic_string` value to read the amount
    from the input stream:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::get_money()` with a single argument (the variable where the monetary
    value is to be written) if a currency symbol might be used in the input stream:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::get_money()` with two arguments (the variable where the monetary
    value is to be written and a Boolean flag set to `true`) to indicate the presence
    of an international currency string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `put_money()` and `get_money()` manipulators are very similar. They are
    both function templates that take an argument representing either the monetary
    value to be written to the output stream or a variable to hold the monetary value
    read from an input stream, and a second, optional parameter to indicate whether
    an international currency string is used. The default alternative is the currency
    symbol, if one is available. `put_money()` uses the `std::money_put()` facet settings
    to output a monetary value, and `get_money()` uses the `std::money_get()` facet
    to parse a monetary value. Both manipulator function templates return an object
    of an unspecified type. These functions do not throw exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Both of these manipulator functions require the monetary value to be either
    a `long double` or a `std::basic_string`.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is important to note that monetary values are stored as integral
    numbers of the smallest denomination of the currency defined by the locale in
    use. Considering US dollars as that currency, $100.00 is stored as **10000.0**,
    and 1 cent (that is, $0.01) is stored as **1.0**.
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing a monetary value to an output stream, it is important to use the
    `std::showbase` manipulator if you want to display the currency symbol or the
    international currency string. This is normally used to indicate the prefix of
    a numeric base (such as `0x` for hexadecimal); however, for monetary values, it
    is used to indicate whether the currency symbol/string should be displayed or
    not. The following snippet provides an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using I/O manipulators to control the output of a stream*, to learn about
    the use of helper functions, called manipulators, that control input and output
    streams using the `<<` and `>>` stream operators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using time I/O manipulators*, to learn how to use standard manipulators to
    write and read date and time values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using time I/O manipulators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the monetary I/O manipulators that we discussed in the previous recipe,
    the C++11 standard provides manipulators that control the writing and reading
    of time values to and from streams, where time values are represented in the form
    of a `std::tm` object that holds a calendar date and time. In this recipe, you
    will learn how to use these time manipulators.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Time values used by the time I/O manipulators are expressed in `std::tm` values.
    You should be familiar with this structure from the `<ctime>` header.
  prefs: []
  type: TYPE_NORMAL
- en: You should also be familiar with locales and how to set them for a stream. This
    topic was discussed in the *Using localized settings for streams* recipe. It is
    recommended that you read that recipe before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: The manipulators discussed in this recipe are available in the `std` namespace,
    in the `<iomanip>` header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To write a time value to an output stream, you should perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Obtain a calendar date and time value corresponding to a given time. There
    are various ways in which to do this. The following shows several examples of
    how to convert the current time to a local time that is expressed as a calendar
    date and time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use `std::put_time()` to supply a pointer to the `std::tm` object, representing
    the calendar date and time, and a pointer to a null-terminated character string,
    representing the format. The C++11 standard provides a long list of formats that
    can be used; this list can be consulted at [http://en.cppreference.com/w/cpp/io/manip/put_time](http://en.cppreference.com/w/cpp/io/manip/put_time).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To write a standard date and time string according to the settings of a specific
    locale, first set the locale for the stream by calling `imbue()` and then use
    the `std::put_time()` manipulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following list shows some examples of supported time formats:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ISO 8601 date format `"%F"` or `"%Y-%m-%d"`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'ISO 8601 time format `"%T"`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'ISO 8601 combined date and time in UTC format `"%FT%T%z"`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'ISO 8601 week format `"%Y-W%V"`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'ISO 8601 date with week number format `"``%Y-W%V-%u"`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'ISO 8601 ordinal date format `"%Y-%j"`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To read a time value from an input stream, you should perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare an object of the `std::tm` type to hold the time value read from the
    stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::get_time()` to supply a pointer to the `std::tm` object, which will
    hold the time value, and a pointer to a null-terminated character string, which
    represents the format. The list of possible formats can be consulted at [http://en.cppreference.com/w/cpp/io/manip/get_time](http://en.cppreference.com/w/cpp/io/manip/get_time).
    The following example parses an ISO 8601 combined date and time value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To read a standard date and time string according to the settings of a specific
    locale, first set the locale for the stream by calling `imbue()` and then use
    the `std::get_time()` manipulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The two manipulators for time values, `put_time()` and `get_time()`, are very
    similar: they are both function templates with two arguments. The first argument
    is a pointer to a `std::tm` object representing the calendar date and time, which
    holds the value to be written to the stream or the value that is read from the
    stream. The second argument is a pointer to a null-terminated character string
    representing the format of the time text. `put_time()` uses the `std::time_put()`
    facet to output a date and time value, and `get_time()` uses the `std::time_get()`
    facet to parse a date and time value. Both manipulator function templates return
    an object of an unspecified type. These functions do not throw exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The string that results from using `put_time()` to write a date and time value
    to an output stream is the same as the one that results from a call to `std::strftime()`
    or `std::wcsftime()`.
  prefs: []
  type: TYPE_NORMAL
- en: The standard defines a long list of available conversion specifiers that compose
    the format string. These specifiers are prefixed with a `%`, and, in some cases,
    are followed by an `E` or a `0`. Some of them are also equivalent; for instance,
    `%F` is equivalent to `%Y-%m-%d` (this is the ISO 8601 date format), and `%T`
    is equivalent to `%H:%M:%S` (this is the ISO 8601 time format). The examples in
    this recipe mention only a few of the conversion specifiers, referring to ISO
    8601 date and time formats. For the complete list of conversion specifiers, refer
    to the C++ standard or follow the links that were mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that not all of the conversion specifiers supported
    by `put_time()` are also supported by `get_time()`. Examples include the `z` (offset
    from UTC in the ISO 8601 format) and `Z` (time zone name or abbreviation) specifiers,
    which can only be used with `put_time()`. This is demonstrated in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The text represented by some conversion specifiers is locale-dependent. All
    specifiers prefixed with `E` or `0` are locale-dependent. To set a particular
    locale for the stream, use the `imbue()` method, as demonstrated in the examples
    in the *How to do it...* section.
  prefs: []
  type: TYPE_NORMAL
- en: The `std::localtime()` function used in an earlier example returns a pointer
    to a static internal `std::tm` object if it succeeds (or `nullptr` otherwise).
    You should not attempt to free this pointer!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using I/O manipulators to control the output of a stream*, to learn about
    the use of helper functions, called manipulators, that control input and output
    streams using the `<<` and `>>` stream operators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using monetary I/O manipulators*, to learn how to use standard manipulators
    to write and read monetary values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with filesystem paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important addition to the C++17 standard is the `filesystem` library, which
    enables us to work with paths, files, and directories in hierarchical filesystems
    (such as Windows or POSIX filesystems). This standard library has been developed
    based on the `boost.filesystem` library. In the next few recipes, we will explore
    those features of the library that enable us to perform operations with files
    and directories, such as creating, moving, or deleting them, but also querying
    properties and searching. It is important, however, to first look at how this
    library handles paths.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will consider most of the examples using Windows paths.
    In the accompanying code, all examples have both Windows and POSIX alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `filesystem` library is available in the `std::filesystem` namespace, in
    the `<filesystem>` header. To simplify the code, we will use the following namespace
    alias in all of the examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: A path to a filesystem component (file, directory, hard link, or soft link)
    is represented by the `path` class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a list of the most common operations on paths:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a path using the constructor, the assignment operator, or the `assign()`
    method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append elements to a path by including a directory separator using the member
    `operator /=`, the non-member `operator /`, or the `append()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Concatenate elements to a path without including a directory separator by using
    the member `operator +=`, the non-member `operator +`, or the `concat()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Decompose the elements of a path into its parts, such as the root, root directory,
    parent path, filename, extension, and so on, using member functions such as `root_name()`,
    `root_dir()`, `filename()`, `stem()`, `extension()`, and so on (all of them are
    shown in the following example):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Query whether parts of a part are available using member functions such as
    `has_root_name()`, `has_root_directory()`, `has_filename()`, `has_stem()`, and
    `has_extension()` (all of these are shown in the following example):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether a path is relative or absolute:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify individual parts of the path, such as the filename with `replace_filename()`
    and `remove_filename()`, and the extension with `replace_extension()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert the directory separator to the system-preferred separator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::filesystem::path` class models paths to filesystem components. However,
    it only handles the syntax and does not validate the existence of a component
    (such as a file or a directory) represented by the path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The library defines a portable, generic syntax for paths that can accommodate
    various filesystems, such as POSIX or Windows, including the Microsoft Windows
    **Universal Naming Convention** (**UNC**) format. Both of them differ in several
    key aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: POSIX systems have a single tree, no root name, a single root directory called
    `/`, and a single current directory. Additionally, they use `/` as the directory
    separator. Paths are represented as null-terminated strings of `char` encoded
    as UTF-8.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows systems have multiple trees, each with a root name (such as `C:`), a
    root directory (such as `\`), and a current directory (such as `C:\Windows\System32`).
    Paths are represented as null-terminated strings of wide characters encoded as
    UTF-16.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should not mix path formats across different systems. Although Windows can
    handle POSIX paths, the other way around is not true. Use the path format specific
    to each system. Additionally, you can use the `filesystem::path` functionality,
    such as `operator /=` and the `append()` function, as well as the `preferred_separator`
    static member to build paths in a portable manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'A pathname, as defined in the `filesystem` library, has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: An optional root name (`C:` or `//localhost`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional root directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero or more filenames (which may refer to a file, a directory, a hard link,
    or a symbolic link) or directory separators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two special filenames that are recognized: the single dot (`.`),
    which represents the current directory, and the double dot (`..`), which represents
    the parent directory. The directory separator can be repeated, in which case it
    is treated as a single separator (in other words, `/home////docs` is the same
    as `/home/marius/docs`). A path that has no redundant current directory name (`.`),
    no redundant parent directory name (`..`), and no redundant directory separators
    is said to be in a normal form.'
  prefs: []
  type: TYPE_NORMAL
- en: The path operations presented in the previous section are the most common operations
    with paths. However, their implementation defines additional querying and modifying
    methods, iterators, non-member comparison operators, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sample iterates through the parts of a path and prints them to
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The following listing represents its result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `sample.file.txt` is the filename. This is basically the part
    from the last directory separator to the end of the path. This is what the member
    function `filename()` would be returning for the given path. The extension for
    this file is `.txt`, which is the string returned by the `extension()` member
    function. To retrieve the filename without an extension, another member function
    called `stem()` is available. Here, the string returned by this method is `sample.file`.
    For all of these methods, but also all of the other decomposition methods, there
    is a corresponding querying method with the same name and the prefix `has_`, such
    as `has_filename()`, `has_stem()`, and `has_extension()`. All of these methods
    return a `bool` value to indicate whether the path has the corresponding part.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating, copying, and deleting files and directories*, to learn how to perform
    these basic operations with files and directories independently of the filesystem
    in use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Checking the properties of an existing file or directory*, to learn how to
    query the properties of files and directories, such as the type, permissions,
    file times, and more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating, copying, and deleting files and directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operations with files, such as copying, moving, and deleting, or with directories,
    such as creating, renaming, and deleting, are all supported by the `filesystem`
    library. Files and directories are identified using a path (which can be absolute,
    canonical, or relative), a topic that was covered in the previous recipes. In
    this recipe, we will look at what the standard functions for the previously mentioned
    operations are and how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before going forward, you should read the *Working with filesystem paths* recipe.
    The introductory notes from that recipe also apply here. However, all of the examples
    in this recipe are platform-independent.
  prefs: []
  type: TYPE_NORMAL
- en: 'For all of the following examples, we will use the following variables and
    assume the current path is `C:\Users\Marius\Documents` on Windows and `/home/marius/docs`
    for a POSIX system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: We will also assume the presence of a file called `sample.txt` in the `temp`
    subdirectory of the current path (such as `C:\Users\Marius\Documents\temp\sample.txt`
    or `/home/marius/docs/temp/sample.txt`).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following library functions to perform operations with directories:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new directory, use `create_directory()`. This method does nothing
    if the directory already exists; however, it does not create directories recursively:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create new directories recursively, use `create_directories()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To move an existing directory, use `rename()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To rename an existing directory, also use `rename()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To copy an existing directory, use `copy()`. To recursively copy the entire
    content of a directory, use the `copy_options::recursive` flag:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create a symbolic link to a directory, use `create_directory_symlink()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To remove an empty directory, use `remove()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To remove the entire content of a directory recursively and the directory itself,
    use `remove_all()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To change permissions on a directory or a file, use `permissions()`, specifying
    permissions options from the `perms` enum. Unless you specify an operation type
    (replace, add, or remove) from the `perm_options` enum, the default action is
    to replace all existing permissions with the specified ones:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following library functions to perform operations with files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To copy a file, use `copy()` or `copy_file()`. The next section explains the
    difference between the two:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To rename a file, use `rename()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To move a file, use `rename()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create a symbolic link to a file, use `create_symlink()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To delete a file, use `remove()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of the functions mentioned in this recipe, and other similar functions
    that are not discussed here, have multiple overloads that can be grouped into
    two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Overloads that take, as the last argument, a reference to a `std::error_code`:
    these overloads do not throw an exception (they are defined with the `noexcept`
    specification). Instead, they set the value of the `error_code` object to the
    operating system error code if an operating system error has occurred. If no such
    error has occurred, then the `clear()` method on the `error_code` object is called
    to reset any possible previously set code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Overloads that do not take the last argument of the `std::error_code` type:
    these overloads throw exceptions if errors occur. If an operating system error
    occurs, they throw a `std::filesystem::filesystem_error` exception. On the other
    hand, if memory allocation fails, these functions throw a `std::bad_alloc` exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the examples in the previous section used the overload that does not throw
    exceptions but, instead, sets a code when an error occurs. Some functions return
    a `bool` to indicate a success or a failure. You can check whether the `error_code`
    object holds the code of an error by either checking whether the value of the
    error code, returned by the method `value()`, is different from 0, or by using
    the conversion `operator bool`, which returns `true` for the same case and `false`
    otherwise. To retrieve the explanatory string for the error code, use the `message()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Some `filesystem` library functions are common for both files and directories.
    This is the case for `rename()`, `remove()`, and `copy()`. The working details
    of each of these functions can be complex, especially in the case of `copy()`,
    and are beyond the scope of this recipe. You should refer to the reference documentation
    if you need to perform anything other than the simple operations covered here.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to copying files, there are two functions that can be used: `copy()`
    and `copy_file()`. These have equivalent overloads with identical signatures and,
    apparently, work the same way. However, there is an important difference (other
    than the fact that `copy()` also works for directories): `copy_file()` follows
    symbolic links.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid doing that and, instead, copy the actual symbolic link, you must use
    either `copy_symlink()` or `copy()` with the `copy_options::copy_symlinks` flag.
    Both the `copy()` and `copy_file()` functions have an overload that takes an argument
    of the `std::filesystem::copy_options` type, which defines how the operation should
    be performed. `copy_options` is a scoped `enum` with the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table defines how each of these flags affects a copy operation,
    either with `copy()` or `copy_file()`. The table is taken from the 31.12.8.3 paragraph
    from the N4917 version of the C++ standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option group controlling `copy_file` function effects for existing target
    files |'
  prefs: []
  type: TYPE_TB
- en: '| `none` | (Default) Error; file already exists |'
  prefs: []
  type: TYPE_TB
- en: '| `skip_existing` | Do not overwrite existing file; do not report an error
    |'
  prefs: []
  type: TYPE_TB
- en: '| `overwrite_existing` | Overwrite the existing file |'
  prefs: []
  type: TYPE_TB
- en: '| `update_existing` | Overwrite the existing file if it is older than the replacement
    file |'
  prefs: []
  type: TYPE_TB
- en: '| Option group controlling `copy` function effects for subdirectories |'
  prefs: []
  type: TYPE_TB
- en: '| `none` | (Default) Do not copy subdirectories |'
  prefs: []
  type: TYPE_TB
- en: '| `recursive` | Recursively copy subdirectories and their contents |'
  prefs: []
  type: TYPE_TB
- en: '| Option group controlling `copy` function effects for symbolic links |'
  prefs: []
  type: TYPE_TB
- en: '| `none` | (Default) Follow symbolic links |'
  prefs: []
  type: TYPE_TB
- en: '| `copy_symlinks` | Copy symbolic links as symbolic links rather than copying
    the files that they point to |'
  prefs: []
  type: TYPE_TB
- en: '| `skip_symlinks` | Ignore symbolic links |'
  prefs: []
  type: TYPE_TB
- en: '| Option group controlling `copy` function effects for choosing the form of
    copying |'
  prefs: []
  type: TYPE_TB
- en: '| `none` | (Default) Copy contents |'
  prefs: []
  type: TYPE_TB
- en: '| `directories_only` | Copy the directory structure only; do not copy non-directory
    files |'
  prefs: []
  type: TYPE_TB
- en: '| `create_symlinks` | Make symbolic links instead of copies of files; the source
    path will be an absolute path unless the destination path is in the current directory
    |'
  prefs: []
  type: TYPE_TB
- en: '| `create_hard_links` | Make hard links instead of copies of files |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.3: A breakdown of how copy_operation flags affect the copy operation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another aspect that should be mentioned is related to symbolic links: `create_directory_symlink()`
    creates a symbolic link to a directory, whereas `create_symlink()` creates symbolic
    links to either files or directories. On POSIX systems, the two are identical
    when it comes to directories. On other systems (such as Windows), symbolic links
    to directories are created differently than symbolic links to files. Therefore,
    it is recommended that you use `create_directory_symlink()` for directories in
    order to write code that works correctly on all systems.'
  prefs: []
  type: TYPE_NORMAL
- en: When you perform operations with files and directories, such as the ones described
    in this recipe, and you use the overloads that may throw exceptions, ensure that
    you use `try`-`catch` on the calls. Regardless of the type of overload used, you
    should check the success of the operation and take appropriate action in the case
    of a failure.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to change permissions for a file or directory, you can use the `permissions()`
    function. It has several overloads that allow you to specify a range of permission
    options. These are defined in the `std::filesystem::perms` enumeration. If you
    don’t specify a particular change operation, a complete replacement of existing
    permissions is performed. However, you can specify to add or remove permissions
    using the options available from the `std::filesystem::perm_options` enumeration.
    Apart from `replace`, `add`, and `remove`, there is a fourth option, `nofollow`.
    This applies to symlinks, so that the permissions are changed on the symlink itself
    and not to the file it resolves to.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Working with filesystem paths*, to learn about the C++17 standard support
    for filesystem paths'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Removing content from a file*, to explore the possible ways of removing parts
    of the content of a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Checking the properties of an existing file or directory*, to learn how to
    query the properties of files and directories, such as the type, permissions,
    file times, and more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing content from a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operations such as copying, renaming, moving, or deleting files are directly
    provided by the `filesystem` library. However, when it comes to removing content
    from a file, you must perform explicit actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of whether you need to do this for text or binary files, you could
    implement the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a temporary file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy only the content that you want from the original file to the temporary
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the original file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename/move the temporary file to the name/location of the original file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to implement this pattern for a text file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the purpose of this recipe, we will consider removing empty lines, or lines
    that start with a semicolon (`;`), from a text file. For this example, we will
    have an initial file, called `sample.dat`, that contains the names of Shakespeare’s
    plays, but also empty lines and lines that start with a semicolon. The following
    is a partial listing of this file (from the beginning):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The code samples listed in the next section use the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: We will learn how to put this pattern into code in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following operations to remove content from a file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file for reading:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open another temporary file for writing; if the file already exists, truncate
    its content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read, line by line, from the input file and copy the selected content to the
    output file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close both the input and output files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Delete the original file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rename/move the temporary file to the name/location of the original file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The pattern described here is the same for binary files too; however, to keep
    this short, we are only discussing an example with text files. The temporary file
    in this example is in the same directory as the original file. Alternatively,
    this can be located in a separate directory, such as a user temporary directory.
    To get a path to a temporary directory, you can use `std::filesystem::temp_directory_path()`.
    On Windows systems, this function returns the same directory as `GetTempPath()`.
    On POSIX systems, it returns the path specified in one of the environment variables
    `TMPDIR`, `TMP`, `TEMP`, or `TEMPDIR`, or, if none of them are available, it returns
    the path `/tmp`.
  prefs: []
  type: TYPE_NORMAL
- en: How content from the original file is copied to the temporary file varies from
    one case to another, depending on what needs to be copied. In the preceding example,
    we have copied entire lines, unless they are empty or start with a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, we read the content of the original file, line by line, using
    `std::getline()`, until there are no more lines to read. After all the necessary
    content has been copied, the files should be closed so they can be moved or deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the operation, there are three options:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the original file and rename the temporary file to the same name as the
    original one if they are in the same directory, or move the temporary file to
    the original file location if they are in different directories. This is the approach
    taken in this recipe. For this, we used the `remove()` function to delete the
    original file and `rename()` to rename the temporary file to the original filename.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the content of the temporary file to the original file (for this, you can
    use either the `copy()` or `copy_file()` functions) and then delete the temporary
    file (use `remove()` for this).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rename the original file (for instance, changing the extension or the name)
    and then use the original filename to rename/move the temporary file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you take the first approach mentioned here, then you must make sure that
    the temporary file that is later replacing the original file has the same file
    permissions as the original file; otherwise, depending on the context of your
    solution, it can lead to problems.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating, copying, and deleting files and directories*, to learn how to perform
    these basic operations with files and directories independently of the filesystem
    in use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the properties of an existing file or directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `filesystem` library provides functions and types that enable developers
    to check for the existence of a filesystem object, such as a file or directory,
    its properties, such as the type (the file, directory, symbolic link, and more),
    the last write time, permissions, and more. In this recipe, we will look at what
    these types and functions are and how they can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the following code samples, we will use the namespace alias `fs` for the
    `std::filesystem` namespace. The `filesystem` library is available in the header
    with the same name, `<filesystem>`. Also, we will use the variables shown here,
    `path` for the path of a file, and `err` for receiving potential operating system
    error codes from the filesystem APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the function `to_time_t` shown here will be referred to in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Before continuing with this recipe, you should read the *Working with filesystem
    paths* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following library functions to retrieve information about filesystem
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether a path refers to an existing filesystem object, use `exists()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check whether two different paths refer to the same filesystem object, use
    `equivalent()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To retrieve the size of a file in bytes, use `file_size()`. This does not require
    the file to be opened, so it should be preferred over the approach of opening
    the file and then using the `seekg()`/`tellg()` functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To retrieve the count of hard links to a filesystem object, use `hard_link_count()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To retrieve or set the last modification time for a filesystem object, use
    `last_write_time()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To retrieve the file attributes, such as the type and permissions (as if returned
    by the POSIX `stat` function), use the `status()` function. This function follows
    symbolic links. To retrieve the file attributes of a symbolic link without following
    it, use `symlink_status()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check whether a path refers to a particular type of filesystem object, such
    as a file, directory, symbolic link, and so on, use the functions `is_regular_file()`,
    `is_directory()`, `is_symlink()`, and so on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check whether a file or directory is empty, use the `is_empty()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These functions (used to retrieve information about the filesystem files and
    directories) are, in general, simple and straightforward. However, some considerations
    are necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether a filesystem object exists can be done using `exists()`, either
    by passing the path or a `std::filesystem::file_status` object that was previously
    retrieved using the `status()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `equivalent()` function determines whether two filesystem objects have the
    same status, as retrieved by the function `status()`. If neither path exists,
    or if both exist but neither is a file, directory, or symbolic link, then the
    function returns an error. Hard links to the same file object are equivalent.
    A symbolic link and its target are also equivalent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `file_size()` function can only be used to determine the size of regular
    files and symbolic links that target a regular file. For any other types of file
    objects, such as directories, this function fails. This function returns the size
    of the file in bytes, or `-1` if an error has occurred. If you want to determine
    whether a file is empty, you can use the `is_empty()` function. This works for
    all types of filesystem objects, including directories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `last_write_time()` function has two sets of overloads: one that is used
    to retrieve the last modification time of the filesystem object and one that is
    used to set the last modification time. Time is indicated by a `std::filesystem::file_time_type`
    object, which is basically a type alias for `std::chrono::time_point`. The following
    example changes the last write time for a file to 30 minutes earlier than its
    previous value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `status()` function determines the type and permissions of a filesystem
    object. If the file is a symbolic link, the information returned is about the
    target of the symbolic link. To retrieve information about the symbolic link itself,
    the `symlink_status()` function must be used. These functions return a `std::filesystem::file_status`
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This class has a `type()` member function to retrieve the file type, and a
    `permissions()` member function to retrieve the file permissions. The type of
    a file is defined with the `std::filesystem::file_type` enumeration. Permissions
    of a file are defined with the `std::filesystem::perms` enumeration. Not all the
    enumerators of this enumeration represent permissions; some of them represent
    controlling bits, such as `add_perms`, to indicate that permissions should be
    added, or `remove_perms`, to indicate that permissions should be removed. The
    `permissions()` function can be used to modify the permissions of a file or a
    directory. The following example adds all permissions to the owner and user group
    of a file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To determine the type of a filesystem object, such as a file, directory, or
    symbolic link, there are two options available: retrieve the file status and then
    check the `type` property, or use one of the available filesystem functions, such
    as `is_regular_file()`, `is_symlink()`, or `is_directory()`. The following examples
    that check whether a path refers to a regular file are equivalent:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All of the functions discussed in this recipe have an overload that throws
    exceptions if an error occurs, and an overload that does not throw but returns
    an error code via a function parameter. All of the examples in this recipe used
    this approach. More information about these sets of overloads can be found in
    the *Creating, copying, and deleting files and directories* recipe. Although the
    snippets in this recipe don’t show it (for simplicity), it’s important that you
    check the `error_code` value returned by these functions. The actual meaning of
    each value it holds depends on the call that returned it and the value category
    (such as system, I/O streams, or generic) it belongs to. However, the value `0`
    is considered to indicate success in all value categories. Therefore, you can
    check for success as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use the overloads that don’t return an error code but throw an exception,
    then you need to catch that possible exception. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Working with filesystem paths*, to learn about the C++17-standard support
    for filesystem paths'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating, copying, and deleting files and directories*, to learn how to perform
    these basic operations with files and directories independently of the filesystem
    in use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Enumerating the content of a directory*, to learn how to iterate through the
    files and subdirectories of a directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating the content of a directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we have looked at many of the functionalities provided
    by the `filesystem` library, such as working with paths, performing operations
    with files and directories (creating, moving, renaming, deleting, and so on),
    and querying or modifying properties. Another useful functionality when working
    with the filesystem is to iterate through the content of a directory. The `filesystem`
    library provides two directory iterators, one called `directory_iterator`, which
    iterates the content of a directory, and one called `recursive_directory_iterator`,
    which recursively iterates the content of a directory and its subdirectories.
    In this recipe, we will learn how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will consider a directory with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following snippets, we will refer to the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: In this recipe, we will work with filesystem paths and check the properties
    of a filesystem object. Therefore, it is recommended that you first read the *Working
    with filesystem paths* and *Checking the properties of an existing file or directory*
    recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following patterns to enumerate the content of a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To iterate only the content of a directory without recursively visiting its
    subdirectories, use `directory_iterator`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To iterate all the content of a directory, including its subdirectories, use
    `recursive_directory_iterator` when the order of processing the entries does not
    matter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To iterate all the content of a directory, including its subdirectories, in
    a structured manner, such as traversing a tree, use a function similar to the
    one in the first example, which uses `directory_iterator` to iterate the content
    of a directory. However, instead, call it recursively for each subdirectory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both `directory_iterator` and `recursive_directory_iterator` are input iterators
    that iterate over the entries of a directory. The difference is that the first
    one does not visit the subdirectories recursively, while the second one, as its
    name implies, does. They both share a similar behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: The order of iteration is unspecified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each directory entry is visited only once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The special paths dot (`.`) and dot-dot (`..`) are skipped.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A default-constructed iterator is the end iterator, and two end iterators are
    always equal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When iterated past the last directory entries, it becomes equal to the end iterator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard does not specify what happens if a directory entry is added to,
    or deleted from, the iterated directory after the iterator has been created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard defines the non-member functions `begin()` and `end()` for both
    `directory_iterator` and `recursive_directory_iterator`, which enables us to use
    these iterators in range-based `for` loops, as shown in the examples earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both iterators have overloaded constructors. Some overloads of the `recursive_directory_iterator`
    constructor take an argument of the `std::filesystem::directory_options` type,
    which specifies additional options for the iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`none`: This is the default, which does not specify anything.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`follow_directory_symlink`: This specifies that the iteration should follow
    symbolic links instead of serving the link itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skip_permission_denied`: This specifies that you should ignore and skip the
    directories that could trigger an access denied error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The elements that both directory iterators point to are of the `directory_entry`
    type. The `path()` member function returns the path of the filesystem object represented
    by this object. The status of the filesystem object can be retrieved with the
    member functions `status()` and `symlink_status()` for symbolic links.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding examples follow a common pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Verify that the path to iterate actually exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a range-based `for` loop to iterate all the entries of a directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use one of the two directory iterators available in the `filesystem` library,
    depending on the way the iteration is supposed to be done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Process each entry according to the requirements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our examples, we simply printed the names of the directory entries to the
    console. It is important to note, as we specified earlier, that the content of
    the directory is iterated in an unspecified order. If you want to process the
    content in a structured manner, such as showing subdirectories and their entries
    indented (for this particular case) or in a tree (in other types of applications),
    then using `recursive_directory_iterator` is not appropriate. Instead, you should
    use `directory_iterator` in a function that is called recursively from the iteration,
    for each subdirectory, as shown in the last example from the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the directory structure presented at the beginning of this recipe
    (relative to the current path), we get the following output when using the recursive
    iterator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, when using the recursive function from the third example,
    as shown in the following listing, the output is displayed in order of sublevels,
    as intended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the `visit_directory_rec()` function is a non-recursive function
    that uses `recursive_directory_iterator`, while the `visit_directory_rec_ordered()`
    function is a recursive function that uses `directory_iterator`. This example
    should help you to understand the difference between the two iterators.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous recipe, *Checking the properties of an existing file or directory*,
    we discussed, among other things, the `file_size()` function, which returns the
    size of a file in bytes. However, this function fails if the specified path is
    a directory. To determine the size of a directory, we need to iterate recursively
    through the content of a directory, retrieve the size of the regular files or
    symbolic links, and add them together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following function to exemplify this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `dir_size()` function returns the size of all the files in a directory
    (recursively), or `-1`, as a `uintmax_t`, in the case of an error (the path does
    not exist or does not represent a directory).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Checking the properties of an existing file or directory*, to learn how to
    query the properties of files and directories, such as the type, permissions,
    file times, and more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Finding a file*, to learn how to search for files based on their name, extension,
    or other properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to use `directory_iterator` and `recursive_directory_iterator`
    to enumerate the content of a directory. Displaying the content of a directory,
    as we did in the previous recipe, is only one of the scenarios in which this is
    needed. The other major scenario is when searching for particular entries in a
    directory, such as files with a particular name, extension, and so on. In this
    recipe, we will demonstrate how we can use the directory iterators and the iterating
    patterns shown earlier to find files that match a given criterion.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read the previous recipe, *Enumerating the content of a directory*,
    for details about directory iterators. In this recipe, we will also use the same
    test directory structure that was presented in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To find files that match particular criteria, use the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `recursive_directory_iterator` to iterate through all the entries of a directory
    and recursively through its subdirectories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider regular files (and any other types of files you may need to process).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a function object (such as a lambda expression) to filter only the files
    that match your criteria.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the selected entries to a container (such as a vector).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This pattern is exemplified in the `find_files()` function shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we want to find files in a directory, the structure of the directory and
    the order in which its entries, including subdirectories, are visited are probably
    not important. Therefore, we can use the `recursive_directory_iterator` to iterate
    through the entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `find_files()` function takes two arguments: a path and a function wrapper
    that is used to select the entries that should be returned. The return type is
    a vector of `filesystem::path`, though. Alternatively, it could also be a vector
    of `filesystem::directory_entry`. The recursive directory iterator used in this
    example does not follow symbolic links, returning the link itself and not the
    target. This behavior can be changed by using a constructor overload that has
    an argument of the type `filesystem::directory_options` and passing `follow_directory_symlink`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we only consider the regular files and ignore the
    other types of filesystem objects. The predicate is applied to the directory entry
    and, if it returns `true`, the entry is added to the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses the `find_files()` function to find all of the files
    in the test directory that start with the prefix `file_`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of executing this program, with paths relative to the current path,
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'A second example shows how to find files that have a particular extension,
    in this case, the extension `.dat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, again relative to the current path, is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: These two examples are very similar. The only thing that is different is the
    code in the lambda function, which checks the path received as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Checking the properties of an existing file or directory*, to learn how to
    query the properties of files and directories, such as the type, permissions,
    file times, and more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Enumerating the content of a directory*, to learn how to iterate through the
    files and subdirectories of a directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_07.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2659294082093549796.png)'
  prefs: []
  type: TYPE_IMG
