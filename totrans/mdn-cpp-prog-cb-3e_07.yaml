- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Working with Files and Streams
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件和流
- en: One of the most important parts of the C++ standard library is the **input/output**
    (**I/O**) stream-based library that enables developers to work with files, memory
    streams, or other types of I/O devices. The first part of this chapter provides
    solutions to some common stream operations, such as reading and writing data,
    localization settings, and manipulating the input and output of a stream. The
    second part of the chapter explores the C++17 `filesystem` library, which enables
    developers to perform operations with the filesystem and its objects, such as
    files and directories.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库最重要的部分之一是基于输入/输出（I/O）流库，它使开发者能够处理文件、内存流或其他类型的I/O设备。本章的第一部分提供了对一些常见流操作（如读取和写入数据、区域设置和操作流的输入和输出）的解决方案。本章的第二部分探讨了C++17的`filesystem`库，它使开发者能够对文件系统及其对象（如文件和目录）执行操作。
- en: 'The recipes covered in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的食谱如下：
- en: Reading and writing raw data from/to binary files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从/向二进制文件读取和写入原始数据
- en: Reading and writing objects from/to binary files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从/向二进制文件读取和写入对象
- en: Using streams on fixed-size external buffers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在固定大小的外部缓冲区上使用流
- en: Using localized settings for streams
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用区域设置流
- en: Using I/O manipulators to control the output of a stream
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用I/O操作符控制流的输出
- en: Using monetary I/O manipulators
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用货币I/O操作符
- en: Using time I/O manipulators
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用时间I/O操作符
- en: Working with filesystem paths
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理文件系统路径
- en: Creating, copying, and deleting files and directories
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、复制和删除文件和目录
- en: Removing content from a file
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件中删除内容
- en: Checking the properties of an existing file or directory
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查现有文件或目录的属性
- en: Enumerating the content of a directory
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出目录内容
- en: Finding a file
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找文件
- en: We will start the chapter with a couple of recipes on how to serialize and deserialize
    data to/from files.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以几个关于如何将数据序列化和反序列化到/从文件的食谱开始本章。
- en: Reading and writing raw data from/to binary files
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从/向二进制文件读取和写入原始数据
- en: Some of the data programs you work with must be persisted to disk files in various
    ways, including storing data in a database or flat files, either as text or binary
    data. This recipe, and the next one, are focused on persisting and loading both
    raw data and objects from and to binary files.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你处理的一些数据程序必须以各种方式持久化到磁盘文件中，包括将数据存储在数据库或平面文件中，无论是文本还是二进制数据。这个食谱和下一个食谱都专注于从和向二进制文件持久化和加载原始数据和对象。
- en: In this context, raw data means unstructured data, and, in this recipe, we will
    consider writing and reading the content of a buffer (that is, a contiguous sequence
    of memory), which can either be an array, a `std::vector`, or a `std::array`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在此上下文中，原始数据是指无结构数据，在本食谱中，我们将考虑写入和读取缓冲区的内容（即连续的内存序列），这可以是数组、`std::vector`或`std::array`。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you should be familiar with the standard stream I/O library,
    although some explanations, to the extent that is required to understand this
    recipe, are provided next. You should also be familiar with the differences between
    binary and text files.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，你应该熟悉标准流I/O库，尽管提供了一些解释，以帮助理解这个食谱，你应该也熟悉二进制文件和文本文件之间的区别。
- en: In this recipe, we will use the `ofstream` and `ifstream` classes, which are
    available in the `std` namespace in the `<fstream>` header.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用`ofstream`和`ifstream`类，这些类在`<fstream>`头文件中的`std`命名空间中可用。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To write the content of a buffer (in our example, a `std::vector`) to a binary
    file, you should perform the following steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要将缓冲区（在我们的例子中，是一个`std::vector`）的内容写入二进制文件，你应该执行以下步骤：
- en: 'Open a file stream for writing in binary mode by creating an instance of the
    `std::ofstream` class:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建`std::ofstream`类的实例以二进制模式打开文件流：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Ensure that the file is actually open before writing data to the file:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在向文件写入数据之前，请确保文件实际上已打开：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Write the data to the file by providing a pointer to the array of characters
    and the number of characters to write. In the following example, we write the
    content of a local vector; however, typically, this data comes from a different
    context:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提供字符数组的指针和要写入的字符数，将数据写入文件。在以下示例中，我们写入本地向量的内容；然而，通常，这些数据来自不同的上下文：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Optionally, you can flush the content of the stream’s output buffer to the actual
    disk file by calling the `flush()` method. This determines the uncommitted changes
    in the stream to be synchronized with the external destination, which, in this
    case, is a disk file.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，你可以通过调用`flush()`方法将流输出缓冲区的内容刷新到实际的磁盘文件中。这确定了流中的未提交更改将与外部目标同步，在这种情况下，是一个磁盘文件。
- en: 'Close the stream by calling `close()`. This, in turn, calls `flush()`, making
    the preceding step unnecessary in most contexts:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`close()`关闭流。这反过来又调用`flush()`，在大多数情况下使前面的步骤变得不必要：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To read the entire content of a binary file to a buffer, you should perform
    the following steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将整个二进制文件内容读取到缓冲区中，应执行以下步骤：
- en: 'Open a file stream to read from a file in binary mode by creating an instance
    of the `std::ifstream` class. The path to the file can be absolute or relative
    to the current working directory (not to the path of the executable). In this
    example, the path is relative:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建`std::ifstream`类的实例来打开文件流以以二进制模式读取文件。文件路径可以是绝对路径，也可以是相对于当前工作目录的路径（而不是可执行文件的路径）。在此示例中，路径是相对的：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Ensure that the file is actually open before reading data from it:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从文件中读取数据之前，确保文件实际上已经打开：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Determine the length of the file by positioning the input position indicator
    to the end of the file, read its value, and then move the indicator to the beginning:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将输入位置指示器定位到文件末尾，读取其值，然后将指示器移到开始位置来确定文件的长度：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Allocate memory to read the content of the file:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配内存以读取文件的内容：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Read the content of the file to the allocated buffer by providing a pointer
    to the array of characters for receiving the data and the number of characters
    to read:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提供接收数据的字符数组指针和要读取的字符数来将文件内容读取到分配的缓冲区中：
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Check that the read operation is completed successfully:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查读取操作是否成功完成：
- en: '[PRE9]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, close the file stream:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，关闭文件流：
- en: '[PRE10]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The standard stream-based I/O library provides various classes that implement
    high-level input, output, or both input and output file stream, string stream
    and character array operations, manipulators that control how these streams behave,
    and several predefined stream objects (`cin`/`wcin`, `cout`/`wcout`, `cerr`/`wcerr`,
    and `clog`/`wclog`).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 标准基于流的I/O库提供了各种类，这些类实现了高级输入、输出或输入和输出文件流、字符串流和字符数组操作、控制这些流行为的操纵器，以及几个预定义的流对象（`cin`/`wcin`、`cout`/`wcout`、`cerr`/`wcerr`和`clog`/`wclog`）。
- en: 'These streams are implemented as class templates and, for files, the library
    provides several (non-copyable) classes:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些流被实现为类模板，并且对于文件，库提供了几个（不可复制的）类：
- en: '`basic_filebuf` implements the I/O operations for a raw file and is similar
    in semantics to a C `FILE` stream.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`basic_filebuf`实现了原始文件的I/O操作，其语义与C的`FILE`流类似。'
- en: '`basic_ifstream` implements the high-level file stream input operations defined
    by the `basic_istream` stream interface, internally using a `basic_filebuf` object.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`basic_ifstream`实现了由`basic_istream`流接口定义的高级文件流输入操作，内部使用`basic_filebuf`对象。'
- en: '`basic_ofstream` implements the high-level file stream output operations defined
    by the `basic_ostream` stream interface, internally using a `basic_filebuf` object.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`basic_ofstream`实现了由`basic_ostream`流接口定义的高级文件流输出操作，内部使用`basic_filebuf`对象。'
- en: '`basic_fstream` implements the high-level file stream input and output operations
    defined by the `basic_iostream` stream interface, internally using a `basic_filebuf`
    object.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`basic_fstream`实现了由`basic_iostream`流接口定义的高级文件流输入和输出操作，内部使用`basic_filebuf`对象。'
- en: 'These classes are represented in the following class diagram to better understand
    their relationship:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类在以下类图中表示，以更好地理解它们之间的关系：
- en: '![](img/B21549_07_01.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21549_07_01.png)'
- en: 'Figure 7.1: Stream class diagram'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：流类图
- en: Notice that this diagram also features several classes designed to work with
    a string-based stream. These streams, however, will not be discussed here.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此图还包含几个设计用于与基于字符串的流一起工作的类。然而，这里将不会讨论这些流。
- en: 'Several typedefs for the class templates mentioned earlier are also defined
    in the `<fstream>` header, in the `std` namespace. The `ofstream` and `ifstream`
    objects are the type synonyms used in the preceding examples:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<fstream>`头文件中，`std`命名空间中定义了之前提到的类模板的几个`typedef`。`ofstream`和`ifstream`对象是前面示例中使用类型同义词：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the previous section, you saw how we can write and read raw data to and from
    a file stream. Now, we’ll cover this process in more detail.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您看到了我们如何将原始数据写入文件流并从中读取。现在，我们将更详细地介绍这个过程。
- en: To write data to a file, we instantiated an object of the type `std::ofstream`.
    In the constructor, we passed the name of the file to be opened and the stream’s
    open mode, for which we specified `std::ios::binary` to indicate binary mode.
    Opening the file like this discards the previous file content. If you want to
    append content to an existing file, you should also use the flag `std::ios::app`
    (that is, `std::ios::app | std::ios::binary`). This constructor internally calls
    `open()` on its underlying raw file object (that is, a `basic_filebuf` object).
    If this operation fails, a fail bit is set. To check whether the stream has been
    successfully associated with a file device, we used `is_open()` (this internally
    calls the method with the same name from the underlying `basic_filebuf`). Writing
    data to the file stream is done using the `write()` method, which takes a pointer
    to the string of characters to write and the number of characters to write. Since
    this method operates with strings of characters, a `reinterpret_cast` is necessary
    if data is of another type, such as `unsigned char`, in our example. The write
    operation does not set a fail bit in the case of a failure, but it may throw a
    `std::ios_base::failure` exception. However, data is not written directly to the
    file device but stored in the `basic_filebuf` object. To write it to the file,
    the buffer needs to be flushed, which is done by calling `flush()`. This is done
    automatically when closing the file stream, as shown in the preceding example.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据写入文件，我们实例化了一个类型为 `std::ofstream` 的对象。在构造函数中，我们传递了要打开的文件名和流的打开模式，我们指定了 `std::ios::binary`
    来表示二进制模式。以这种方式打开文件会丢弃之前的文件内容。如果您想向现有文件追加内容，也应该使用标志 `std::ios::app`（即 `std::ios::app
    | std::ios::binary`）。这个构造函数内部会在其底层的原始文件对象（即 `basic_filebuf` 对象）上调用 `open()`。如果此操作失败，则会设置失败位。为了检查流是否已成功关联到文件设备，我们使用了
    `is_open()`（这内部调用底层 `basic_filebuf` 的同名方法）。向文件流写入数据是通过 `write()` 方法完成的，该方法接受要写入的字符串字符的指针和要写入的字符数。由于此方法操作的是字符字符串，如果数据是其他类型，例如我们例子中的
    `unsigned char`，则需要使用 `reinterpret_cast`。在失败的情况下，写入操作不会设置失败位，但它可能会抛出 `std::ios_base::failure`
    异常。然而，数据不是直接写入文件设备，而是存储在 `basic_filebuf` 对象中。要将数据写入文件，需要刷新缓冲区，这通过调用 `flush()`
    来完成。正如前一个示例所示，在关闭文件流时，这会自动完成。
- en: To read data from a file, we instantiated an object of type `std::ifstream`.
    In the constructor, we passed the same arguments that we used for opening the
    file to write the name of the file and the open mode (that is, `std::ios::binary`).
    The constructor internally calls `open()` on the underlying `std::basic_filebuf`
    object. To check whether the stream has been successfully associated with a file
    device, we use `is_open()` (this internally calls the method with the same name
    from the underlying `basic_filebuf`). In this example, we read the entire content
    of the file to a memory buffer, in particular, a `std::vector`. Before we can
    read the data, we must know the size of the file in order to allocate a buffer
    that is large enough to hold that data. To do this, we used `seekg()` to move
    the input position indicator to the end of the file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要从文件中读取数据，我们实例化了一个类型为 `std::ifstream` 的对象。在构造函数中，我们传递了用于打开文件的相同参数，即文件名和打开模式（即
    `std::ios::binary`）。构造函数内部会在底层的 `std::basic_filebuf` 对象上调用 `open()`。为了检查流是否已成功关联到文件设备，我们使用了
    `is_open()`（这内部调用底层 `basic_filebuf` 的同名方法）。在这个例子中，我们将整个文件内容读取到一个内存缓冲区中，特别是 `std::vector`。在我们能够读取数据之前，我们必须知道文件的大小，以便分配一个足够大的缓冲区来存储这些数据。为此，我们使用了
    `seekg()` 将输入位置指示器移动到文件末尾。
- en: Then, we called `tellg()` to return the current position, which, in this case,
    indicates the size of the file, in bytes, and then we moved the input position
    indicator to the beginning of the file to be able to start reading from the beginning.
    Calling `seekg()` to move the position indicator to the end can be avoided by
    opening the file with the position indicator moved directly to the end. This can
    be achieved by using the `std::ios::ate` opening flag in the constructor (or the
    `open()` method). After allocating enough memory for the content of the file,
    we copied the data from the file into memory using the `read()` method. This takes
    a pointer to the string of characters that receives the data read from the stream
    and the number of characters to be read. Since the stream operates on characters,
    a `reinterpret_cast` expression is necessary if the buffer contains other types
    of data, such as `unsigned char` in our example.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`tellg()`来返回当前位置，在这种情况下，它表示文件的大小（以字节为单位），然后我们将输入位置指示器移动到文件的开始，以便能够从开始读取。为了避免调用`seekg()`来移动位置指示器到末尾，可以直接将位置指示器移动到末尾来打开文件。这可以通过在构造函数（或`open()`方法）中使用`std::ios::ate`打开标志来实现。在为文件内容分配足够的内存后，我们使用`read()`方法将数据从文件复制到内存中。这需要一个指向接收从流中读取的数据的字符串的指针和要读取的字符数。由于流在字符上操作，如果缓冲区包含其他类型的数据，例如我们例子中的`unsigned
    char`，则需要使用`reinterpret_cast`表达式。
- en: This operation throws a `std::basic_ios::failure` exception if an error occurs.
    To determine the number of characters that have been successfully read from the
    stream, we can use the `gcount()` method. Upon completing the read operation,
    we close the file stream.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，此操作会抛出`std::basic_ios::failure`异常。为了确定从流中成功读取的字符数，我们可以使用`gcount()`方法。在完成读取操作后，我们关闭文件流。
- en: An alternative to the use of the `seekg()`/`tellg()` approach described here
    for determining the size of an open file is to use the `std::filesystem::file_size()`
    function from the filesystem library. This requires a path only; it does not need
    the file to be opened. It can also determine the size of a directory, but this
    is implementation-defined. This function is presented later in the chapter in
    the *Checking the properties of an existing file or directory* recipe.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 作为此处描述的`seekg()`/`tellg()`方法用于确定打开的文件大小的替代方案，可以使用文件系统库中的`std::filesystem::file_size()`函数。这只需要一个路径；不需要打开文件。它还可以确定目录的大小，但这是由实现定义的。这个函数在章节后面的*检查现有文件或目录属性*菜谱中介绍。
- en: The operations shown in these examples are the minimum ones required to write
    and read data to and from file streams. It is important, though, that you perform
    appropriate checks for the success of the operations and to catch any possible
    exceptions that could occur.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子中显示的操作是写入和从文件流中读取数据的最低要求操作。然而，执行适当的检查以验证操作的成功并捕获可能发生的任何异常是很重要的。
- en: 'An important thing to notice is the value of the argument representing the
    number of characters to write or read. In the examples seen so far, we have used
    buffers of `unsigned char`. The size of `unsigned char` is 1, as with `char`.
    Therefore, the count of characters is the number of elements in the buffer. However,
    if the buffer contains `int` elements, for instance, things change. An `int` is,
    typically, 32-bit, which means that, reinterpreted as `char`, it is equivalent
    to 4 characters. This means that when we write anything that has a size greater
    than 1, we need to multiply the number of elements by the size of an element,
    as shown in the following snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意表示要写入或读取的字符数的参数值。在迄今为止看到的例子中，我们使用了`unsigned char`类型的缓冲区。`unsigned char`的大小是1，与`char`相同。因此，字符计数是缓冲区中元素的数量。然而，如果缓冲区包含`int`类型的元素，例如，情况就会改变。`int`通常是32位的，这意味着，如果重新解释为`char`，它相当于4个字符。这意味着当我们写入大小大于1的任何内容时，我们需要将元素的数量乘以元素的大小，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Similarly, when we read, we need to account for the size of the elements we
    read from the file, which is exemplified next:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当我们读取时，我们需要考虑从文件中读取的元素的大小，这将在下面的例子中说明：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The example code discussed so far in this recipe can be reorganized in the
    form of two general functions for writing and reading data to and from a file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中迄今为止讨论的示例代码可以重新组织成两个通用函数，用于将数据写入和从文件中读取：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`write_data()` is a function that takes the name of a file, a pointer to an
    array of characters, and the length of this array as arguments and writes the
    characters to the specified file. `read_data()` is a function that takes the name
    of a file and a function that allocates a buffer and reads the entire content
    of the file to the buffer that is returned by the allocated function. The following
    is an example of how these functions can be used:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`write_data()`是一个函数，它接受文件名、字符数组的指针以及该数组的长度作为参数，并将字符写入指定的文件。`read_data()`是一个函数，它接受文件名和一个分配缓冲区的函数，该函数读取文件的整个内容到由分配函数返回的缓冲区。以下是如何使用这些函数的示例：'
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, we could use a dynamically allocated buffer, instead of the
    `std::vector`; the changes required for this are small in the overall example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用动态分配的缓冲区，而不是`std::vector`；在整体示例中，为此所需更改很小：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: However, this alternative is only provided to show that `read_data()` can be
    used with different kinds of input buffers. It is recommended that you avoid the
    explicit dynamic allocation of memory whenever possible.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个替代方案只是为了说明`read_data()`可以与不同类型的输入缓冲区一起使用。建议尽可能避免显式动态分配内存。
- en: There’s more...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'The way of reading data from a file to memory, as shown in this recipe, is
    only one of several. The following is a list of possible alternatives for reading
    data from a file stream:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如本食谱所示，从文件读取数据到内存的方式只是几种方法之一。以下是从文件流读取数据的可能替代方案列表：
- en: 'Initializing a `std::vector` directly using `std::istreambuf_iterator` iterators
    (similarly, this can be used with `std::string`):'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接使用`std::istreambuf_iterator`迭代器初始化`std::vector`（类似地，这也可以与`std::string`一起使用）：
- en: '[PRE17]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Assigning the content of a `std::vector` from `std::istreambuf_iterator` iterators:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`std::vector`的内容从`std::istreambuf_iterator`迭代器赋值：
- en: '[PRE18]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Copying the content of the file stream to a vector using `std::istreambuf_iterator`
    iterators and a `std::back_inserter` adapter to write to the end of the vector:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::istreambuf_iterator`迭代器和`std::back_inserter`适配器将文件流的内容复制到向量中：
- en: '[PRE19]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Compared to these alternatives, however, the method described in the *How to
    do it...* section is the fastest one, even though the alternatives may look more
    appealing from an object-oriented perspective. It is beyond the scope of this
    recipe to compare the performance of these alternatives, but you can try it as
    an exercise.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与这些替代方案相比，*如何做...*部分中描述的方法是最快的，尽管从面向对象的角度来看，这些替代方案可能看起来更有吸引力。本食谱的范围不包括比较这些替代方案的性能，但你可以将其作为练习尝试。
- en: See also
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Reading and writing objects from/to binary files*, to learn how to serialize
    and deserialize objects to and from binary files'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从/到二进制文件读取和写入对象*，了解如何将对象序列化和反序列化到和从二进制文件中'
- en: '*Using I/O manipulators to control the output of a stream*, to learn about
    the use of helper functions, called manipulators, that control input and output
    streams using the `<<` and `>>` stream operators'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用I/O操作符控制流输出*，了解使用称为操作符的辅助函数，这些函数通过`<<`和`>>`流操作符控制输入和输出流'
- en: Reading and writing objects from/to binary files
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从/到二进制文件读取和写入对象
- en: In the previous recipe, we learned how to write and read raw data (that is,
    unstructured data) to and from a file. Many times, however, we must persist and
    load objects instead. Writing and reading in the manner shown in the previous
    recipe works for POD types only. For anything else, we must explicitly decide
    what is actually written or read, since writing or reading pointers (including
    those to virtual tables) and any sort of metadata is not only irrelevant but also
    semantically wrong. These operations are commonly referred to as serialization
    and deserialization. In this recipe, we will learn how to serialize and deserialize
    both POD and non-POD types to and from binary files.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的食谱中，我们学习了如何将原始数据（即无结构数据）写入和读取到文件中。然而，很多时候，我们必须持久化和加载对象。如前所述的食谱所示的方式仅适用于POD类型。对于其他任何类型，我们必须明确决定实际写入或读取的内容，因为写入或读取指针（包括指向虚拟表的指针）和任何类型的元数据不仅是不相关的，而且在语义上也是错误的。这些操作通常被称为序列化和反序列化。在本食谱中，我们将学习如何将POD和非POD类型序列化和反序列化到和从二进制文件中。
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For the examples in this recipe, we will use the `foo` and `foopod` classes,
    as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本食谱中的示例，我们将使用`foo`和`foopod`类，如下所示：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It is recommended that you first read the previous recipe, *Reading and writing
    raw data from/to binary files*, before you continue. You should also know what
    POD (a type that is both trivial and has a standard layout) and non-POD types
    are and how operators can be overloaded. You can check the closing notes of the
    *Using type traits to query properties of types* recipe, in *Chapter 6*, *General-Purpose
    Utilities*, for further details on POD types.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你在继续之前首先阅读前一个示例，*从/到二进制文件读取和写入原始数据*。你还应该了解 POD（既是平凡的又具有标准布局的类型）和非 POD 类型是什么，以及如何重载运算符。你可以在
    *第 6 章*，*通用工具* 的 *使用类型特性查询类型属性* 的示例中查找有关 POD 类型的更多详细信息。
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To serialize/deserialize POD types that do not contain pointers, use `ofstream::write()`
    and `ifstream::read()`, as shown in the previous recipe:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要序列化/反序列化不包含指针的 POD 类型，使用 `ofstream::write()` 和 `ifstream::read()`，如前一个示例所示：
- en: 'Serialize objects to a binary file using `ofstream` and the `write()` method:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ofstream` 和 `write()` 方法将对象序列化到二进制文件中：
- en: '[PRE21]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Deserialize objects from a binary file using the `ifstream` and `read()` methods:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ifstream` 和 `read()` 方法从二进制文件中反序列化对象：
- en: '[PRE22]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To serialize non-POD types (or POD types that contain pointers), you must explicitly
    write the value of the data members to a file, and to deserialize, you must explicitly
    read from the file to the data members in the same order. To demonstrate this,
    we will consider the `foo` class that we defined earlier:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要序列化非 POD 类型（或包含指针的 POD 类型），必须显式地将数据成员的值写入文件；要反序列化，必须显式地从文件中读取到数据成员，且顺序相同。为了演示这一点，我们将考虑我们之前定义的
    `foo` 类：
- en: 'Add a member function called `write()` to serialize objects of this class.
    The method takes a reference to an `ofstream` and returns a `bool` indicating
    whether the operation was successful or not:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向此类添加一个名为 `write()` 的成员函数以序列化该类的对象。该方法接受一个指向 `ofstream` 的引用，并返回一个 `bool` 值，指示操作是否成功：
- en: '[PRE23]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add a member function called `read()` to deserialize the objects of this class.
    This method takes a reference to an `ifstream` and returns a `bool` indicating
    whether the operation was successful or not:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向此类添加一个名为 `read()` 的成员函数以反序列化该类的对象。此方法接受一个指向 `ifstream` 的引用，并返回一个 `bool` 值，指示操作是否成功：
- en: '[PRE24]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'An alternative to the `write()` and `read()` member functions demonstrated
    earlier is to overload `operator<<` and `operator>>`. To do this, you should perform
    the following steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 之前演示的 `write()` 和 `read()` 成员函数的替代方法是重载 `operator<<` 和 `operator>>`。为此，你应该执行以下步骤：
- en: 'Add `friend` declarations for the non-member `operator<<` and `operator>>`
    to the class to be serialized/deserialized (in this case, the `foo` class):'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向要序列化/反序列化的非成员 `operator<<` 和 `operator>>` 添加 `friend` 声明到类中（在这种情况下，是 `foo`
    类）：
- en: '[PRE25]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Overload `operator<<` for your class:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的类重载 `operator<<`：
- en: '[PRE26]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Overload `operator>>` for your class:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的类重载 `operator>>`：
- en: '[PRE27]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Regardless of whether we serialize the entire object (for POD types) or only
    parts of it, we use the same stream classes that we discussed in the previous
    recipe: `ofstream` for output file streams and `ifstream` for input file streams.
    Details about writing and reading data using these standard classes have been
    discussed in that recipe and will not be reiterated here.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是否序列化整个对象（对于 POD 类型）还是其部分，我们都使用之前讨论过的相同流类：`ofstream` 用于输出文件流，`ifstream`
    用于输入文件流。关于使用这些标准类写入和读取数据的详细信息已在那个示例中讨论，此处不再重复。
- en: When you serialize and deserialize objects to and from files, you should avoid
    writing the values of the pointers to a file. Additionally, you must not read
    pointer values from the file since these represent memory addresses and are meaningless
    across processes, and even in the same process some moments later. Instead, you
    should write data referred by a pointer and read data into objects referred by
    a pointer.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当将对象序列化和反序列化到文件时，你应该避免将指针的值写入文件。此外，你不得从文件中读取指针值，因为这些代表内存地址，在进程间没有意义，甚至在同一进程中的某些时刻也是无意义的。相反，你应该写入指针引用的数据，并将数据读入由指针引用的对象中。
- en: This is a general principle, and, in practice, you may encounter situations
    where a source may have multiple pointers to the same object; in this case, you
    might want to write only one copy and also handle the reading in a corresponding
    manner.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个一般原则，在实践中，你可能会遇到源中可能存在多个指向同一对象的指针的情况；在这种情况下，你可能只想写一个副本，并且以相应的方式处理读取。
- en: 'If the objects you want to serialize are of the POD type, you can do it just
    like we did when we discussed raw data. In the example in this recipe, we serialized
    a sequence of objects of the `foopod` type. When we deserialize, we read from
    the file stream in a loop until the end of the file is read or a failure occurs.
    The way we read, in this case, may look counterintuitive, but doing it differently
    may lead to the duplication of the last read value:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要序列化的对象是POD类型，你可以像我们在讨论原始数据时做的那样进行。在本食谱的示例中，我们序列化了`foopod`类型的对象序列。当我们反序列化时，我们通过循环从文件流中读取，直到读取到文件末尾或发生失败。在这种情况下，我们的读取方式可能看起来不太直观，但以不同的方式做可能会导致读取的最后一个值的重复：
- en: Reading is done in an infinite loop.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取是在一个无限循环中进行的。
- en: A read operation is performed in the loop.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环中执行读取操作。
- en: A check for a failure or the end of file is performed, and if either of them
    has occurred, the infinite loop is exited.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行对失败或文件末尾的检查，如果发生其中之一，则退出无限循环。
- en: The value is added to the input sequence and the looping continues.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该值被添加到输入序列，并且循环继续。
- en: If reading is done using a loop with an exit condition that checks the end of
    the file bit, that is, `while(!ifile.eof())`, the last value will be added to
    the input sequence twice. The reason for this is that upon reading the last value,
    the end of the file has not yet been encountered (as that is a mark beyond the
    last byte of the file). The end of the file mark is only reached at the next read
    attempt, which, therefore, sets the `eofbit` of the stream. However, the input
    variable still has the last value since it hasn’t been overwritten with anything,
    and this is added to the input vector for a second time.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用带有退出条件的循环来读取文件，即检查文件末尾的位，即`while(!ifile.eof())`，最后一个值将被添加到输入序列两次。这是因为读取最后一个值时，尚未遇到文件末尾（因为那是一个超出文件最后一个字节的标记）。文件末尾的标记只有在下一次读取尝试时才会达到，因此设置了流的`eofbit`。然而，输入变量仍然保留最后一个值，因为它没有被任何东西覆盖，并且这个值第二次被添加到输入向量中。
- en: If the objects you want to serialize and deserialize are of non-POD types, writing/reading
    these objects as raw data is not possible. For instance, such an object may have
    a virtual table. Writing the virtual table to a file does not cause problems,
    even though it does not have any value; however, reading from a file, and, therefore,
    overwriting the virtual table of an object, will have catastrophic effects on
    the object and the program.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要序列化和反序列化的对象是非POD类型，将它们作为原始数据写入/读取是不可能的。例如，这样的对象可能有一个虚表。将虚表写入文件不会引起问题，即使它没有任何值；然而，从文件中读取，因此覆盖对象的虚表，将对对象和程序产生灾难性的影响。
- en: When serializing/deserializing non-POD types, there are various alternatives,
    and some of them have been discussed in the previous section. All of them provide
    explicit methods for writing and reading or overloading the standard `<<` and
    `>>` operators. The second approach has an advantage in that it enables the use
    of your class in generic code, where objects are written and read to and from
    stream files using these operators.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在序列化/反序列化非POD类型时，有各种替代方案，其中一些在上一节中已经讨论过。所有这些都提供了明确的写入和读取或重载标准`<<`和`>>`运算符的方法。第二种方法的优势在于它允许在泛型代码中使用你的类，其中对象使用这些运算符写入和读取到流文件。
- en: When you plan to serialize and deserialize your objects, consider versioning
    your data from the very beginning to avoid problems if the structure of your data
    changes over time. How versioning should be done is beyond the scope of this recipe.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你计划序列化和反序列化你的对象时，考虑从一开始就对数据进行版本控制，以避免随着时间的推移数据结构发生变化时出现问题。如何进行版本控制超出了本食谱的范围。
- en: See also
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Reading and writing raw data from/to binary files*, to learn how to write
    and read unstructured data to binary files'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从/到二进制文件读取和写入原始数据*，以了解如何将非结构化数据写入二进制文件'
- en: '*Using I/O manipulators to control the output of a stream*, to learn about
    the use of helper functions, called manipulators, that control input and output
    streams using the `<<` and `>>` stream operators'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用I/O操作符控制流的输出*，以了解使用称为操作符的辅助函数的使用，这些函数使用`<<`和`>>`流运算符来控制输入和输出流'
- en: Using streams on fixed-size external buffers
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在固定大小的外部缓冲区上使用流
- en: The `<strstream>` header has been part of the standard I/O library from its
    beginning. It contains classes that provide stream operations on sequences of
    characters stored in an array. However, this header was deprecated a long time
    ago, in C++98, although it’s still available because a replacement wasn’t available.
    The C++20 standard has introduced the `std::span` class, which is a non-owning
    view of a sequence of objects. In C++23, a new header, `<spanstream>`, has been
    added as a replacement for `<strstream>`. This contains classes that provide stream
    operations on externally provided memory buffers. In this recipe, we’ll learn
    how to parse or write text using the I/O span streams.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`<strstream>`头文件从其开始就是标准I/O库的一部分。它包含提供对存储在数组中字符序列的流操作的类。然而，这个头文件在C++98时就已被弃用，尽管它仍然可用，因为没有提供替代品。C++20标准引入了`std::span`类，它是对对象序列的非拥有视图。在C++23中，一个新的头文件`<spanstream>`被添加作为`<strstream>`的替代。这个头文件包含提供对外部提供的内存缓冲区进行流操作的类。在这个菜谱中，我们将学习如何使用I/O
    span流解析或写入文本。'
- en: How to do it…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Use the new C++23 span streams as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如下使用新的C++23 span流：
- en: 'To parse text from an external array, use `std::ispanstream`:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从外部数组解析文本，使用`std::ispanstream`：
- en: '[PRE28]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To write text to an external array, use `std::ospanstream`:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将文本写入外部数组，使用`std::ospanstream`：
- en: '[PRE29]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To both read and write to the same external array, use `std::spanstream`:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要同时读取和写入同一个外部数组，使用`std::spanstream`：
- en: '[PRE30]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Stream input/output operations can be used with externally allocated buffers.
    However, the `<strstream>` header and its `strstream`, `istrstream`, `ostrstream`,
    and `strstreambuf` classes were deprecated in C++98 without any replacement available.
    The reasons for deprecating them include safety, since `strstreambuf` does not
    enforce bounds checking, and inflexibility, due to its limitations in resizing
    the underlying buffer. The `std::stringstream` was the only recommended alternative.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用外部分配的缓冲区进行流输入/输出操作。然而，`<strstream>`头文件及其`strstream`、`istrstream`、`ostrstream`和`strstreambuf`类在C++98中被弃用，且没有提供替代品。弃用它们的原因包括安全性，因为`strstreambuf`不执行边界检查，以及由于其在调整底层缓冲区大小方面的限制而导致的灵活性不足。《std::stringstream》是唯一推荐的替代方案。
- en: 'In C++23, a new set of similar classes is available in the new `<spanstream>`
    header: `basic_spanstream`, `basic_ispanstream`, `basic_ospanstream`, and `basic_spanbuf`.
    These enable stream operations on externally allocated fixed-size buffers. These
    classes do not provide support for ownership or reallocation of the buffer. For
    such scenarios, `std::stringstream` should be used.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++23中，在新的`<spanstream>`头文件中提供了一组类似的类：`basic_spanstream`、`basic_ispanstream`、`basic_ospanstream`和`basic_spanbuf`。这些类允许对外部分配的固定大小缓冲区执行流操作。这些类不提供对缓冲区所有权或重新分配的支持。对于此类场景，应使用`std::stringstream`。
- en: The `std::basic_spanbuf` controls input and output to a sequence of characters.
    Its associated sequence (the source for input, and the sink for output) is an
    externally allocated buffer of a fixed size that can be initialized from or made
    available as a `std::span`. This is wrapped by the `std::basic_ispanstream`, `std::basic_ospanstream`,
    and `std::basic_spanstream`, which provide higher-level interfaces for input/output
    operations, as defined by the `std::basic_istream`, `std::basic_ostream`, and
    `std::basic_stream` classes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::basic_spanbuf`控制对字符序列的输入和输出。其关联的序列（输入的源，输出的汇）是一个外部分配的固定大小缓冲区，可以从或作为`std::span`提供初始化。这被`std::basic_ispanstream`、`std::basic_ospanstream`和`std::basic_spanstream`所包装，它们提供了由`std::basic_istream`、`std::basic_ostream`和`std::basic_stream`类定义的输入/输出操作的高级接口。'
- en: 'Let’s take another example to look at this. Consider we have a string that
    contains a sequence of key-value pairs separated by a comma. We want to read these
    pairs and put them in a map. We can write the following code in C++23:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个例子来观察这个问题。假设我们有一个包含由逗号分隔的键值对的字符串。我们想要读取这些对并将它们放入一个映射中。我们可以在C++23中编写以下代码：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `std::getline()` function allows us to read characters from an input stream
    either until its end or until a specified delimiter is encountered. Using it,
    we split the text first using the `=` and `,` delimiters. The sequence of characters
    until `=` represents the key, and everything after `=` until the next comma or
    the end is the value. `std::ws` is an I/O manipulator that discards whitespaces
    from an input stream. In simple terms, we read until we find an equals sign; all
    the text until there is the key. Then, we read until we find a comma (or reach
    the end); all the text until there is the value. We do this in a loop as long
    as we keep encountering an equals sign.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::getline()` 函数允许我们从输入流中读取字符，直到遇到其结束或指定的分隔符。使用它，我们首先使用 `=` 和 `,` 分隔符拆分文本。直到
    `=` 的字符序列表示键，而 `=` 之后直到下一个逗号或结束的所有内容是值。`std::ws` 是一个 I/O 操作符，它从输入流中丢弃空白字符。简单来说，我们读取直到找到等号；直到那里是键的所有文本。然后，我们读取直到找到逗号（或达到末尾）；直到那里是值。我们这样做，只要我们继续遇到等号，就在循环中。'
- en: 'Reading from a fixed-size buffer is not very difficult, but writing requires
    more checks because writing cannot exceed the bounds of the buffer, in which case,
    a write operation fails. Let’s take an example to understand this better:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从固定大小的缓冲区中读取并不困难，但写入需要更多的检查，因为写入不能超出缓冲区的界限，在这种情况下，写入操作将失败。让我们通过一个例子来更好地理解这一点：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The external array has 3 bytes. We write the text `42`, and this operation succeeds.
    Then, we attempt to write the text `44`. However, this would require that the
    external buffer has 4 bytes, but it only has 3\. Therefore, after writing the
    character `4`, the operation fails. At this point, the content of the text buffer
    is `'``4'`,`'2'`,`'4'`, and there is no null-terminating character. If we print
    this to the console, after `424`, there will be some gibberish based on the content
    found in memory until the first 0\.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 外部数组有 3 个字节。我们写入文本 `42`，这个操作成功。然后，我们尝试写入文本 `44`。然而，这需要外部缓冲区有 4 个字节，但它只有 3 个。因此，在写入字符
    `4` 后，操作失败。此时，文本缓冲区的内容是 `'``4'`,`'2'`,`'4'`，并且没有空终止字符。如果我们将其打印到控制台，在 `424` 之后，将出现一些基于内存中找到的内容的乱码，直到第一个
    0。
- en: To check whether the writing operation failed, we use the `good()` member function.
    If this returns `false`, then we need to clear the error flags. We also set the
    stream’s output position indicator to the value it had before attempting the read
    (which can be retrieved with the `tellp()` member function). At this point, if
    we write a `0` to the output buffer, its content will be `'4'`,`'2'`,`'\0'`, so
    printing it to the console will show the text `42`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查写入操作是否失败，我们使用 `good()` 成员函数。如果它返回 `false`，那么我们需要清除错误标志。我们还将流输出位置指示器设置回尝试读取之前的位置（可以使用
    `tellp()` 成员函数检索）。此时，如果我们向输出缓冲区写入一个 `0`，其内容将是 `'4'`,`'2'`,`'\0'`，因此将其打印到控制台将显示文本
    `42`。
- en: If you want to both read and write to the same buffer, you can use the `std::spanstream`
    class, which provides both input and output stream operations. An example was
    shown in the *How to do it…* section.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要同时读取和写入同一个缓冲区，你可以使用 `std::spanstream` 类，它提供了输入和输出流操作。一个例子在 *如何做…* 部分中已经展示。
- en: See also
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 6*, *Using std::span for contiguous sequences of objects*, to learn
    how to use non-owning views over contiguous sequences of elements'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 6 章*，*使用 std::span 对象处理对象的连续序列*，学习如何使用非拥有视图来处理元素的连续序列'
- en: Using localized settings for streams
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流本地化设置
- en: How writing or reading to and from streams is performed may depend on the language
    and regional settings. Examples include writing and parsing numbers, time values,
    or monetary values, or comparing (collating) strings. The C++ I/O library provides
    a general-purpose mechanism for handling internationalization features through
    *locales* and *facets*. In this recipe, you will learn how to use locales to control
    the behavior of input/output streams.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 写入或从流中读取的方式可能取决于语言和区域设置。例如，写入和解析数字、时间值或货币值，或比较（整理）字符串。C++ I/O 库通过 *locales*
    和 *facets* 提供了一般用途的机制来处理国际化特性。在本食谱中，你将学习如何使用 locales 来控制输入/输出流的行为。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'All of the examples in this recipe use the `std::cout` predefined console stream
    object. However, the same applies to all I/O stream objects. Also, in these recipe
    examples, we will use the following objects and lambda function:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的所有示例都使用 `std::cout` 预定义的控制台流对象。然而，这同样适用于所有 I/O 流对象。此外，在这些食谱示例中，我们将使用以下对象和
    lambda 函数：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The names Øivind and Åke contain the Danish/Norwegian-specific characters Ø
    and Å. In the Danish/Norwegian alphabet, these are the last two letters (in this
    order) of the alphabet. These are used to exemplify the effect of using locales.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 名称 Øivind 和 Åke 包含丹麦/挪威特有的字符 Ø 和 Å。在丹麦/挪威字母表中，这些是字母表的最后两个字母（按此顺序）。这些被用来举例说明使用区域设置的效果。
- en: 'The locale names used in this recipe (`en_US.utf8`, `de_DE.utf8`, and so on)
    are the ones that are used on UNIX systems. The following table lists their equivalents
    for Windows systems:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方中使用的区域设置名称（`en_US.utf8`、`de_DE.utf8`等）是UNIX系统上使用的名称。以下表格列出了Windows系统上的等效名称：
- en: '| **UNIX** | **Windows** |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| **UNIX** | **Windows** |'
- en: '| `en_US.utf8` | `English_US.1252` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `en_US.utf8` | `English_US.1252` |'
- en: '| `en_GB.utf8` | `English_UK.1252` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `en_GB.utf8` | `English_UK.1252` |'
- en: '| `de_DE.utf8` | `German_Germany.1252` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `de_DE.utf8` | `German_Germany.1252` |'
- en: '| `no_NO.utf8` | `Norwegian_Norway.1252` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `no_NO.utf8` | `Norwegian_Norway.1252` |'
- en: 'Table 7.1: List of UNIX and Windows names of locales used in this recipe'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1：此配方中使用的 UNIX 和 Windows 区域设置名称列表
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To control the localization settings of a stream, you must do the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制流的本地化设置，必须执行以下操作：
- en: 'Use the `std::locale` class to represent the localization settings. There are
    various ways in which to construct locale objects, including the following:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::locale`类来表示本地化设置。有各种构造区域对象的方法，包括以下方法：
- en: Default construct is to use the global locale (by default, the `C` locale at
    the program startup)
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认构造是使用全局区域设置（默认情况下，程序启动时的`C`区域设置）
- en: From a local name, such as `C`, `POSIX,` `en_US.utf8`, and so on, if supported
    by the operating system
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本地名称，如`C`、`POSIX`、`en_US.utf8`等，如果操作系统支持
- en: From another locale, except for a specified facet
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从另一个区域设置，除了指定的特性
- en: 'From another locale, except for all of the facets from a specified category
    that are copied from another specified locale:'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从另一个区域设置，除了从另一个指定的区域设置复制的指定类别的所有特性：
- en: '[PRE34]'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To get a copy of the default `C` locale, use the `std::locale::classic()` static
    method:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取默认的`C`区域设置的副本，请使用`std::locale::classic()`静态方法：
- en: '[PRE35]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To change the default locale that is copied every time a locale is default-constructed,
    use the `std::locale::global()` static method:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要更改每次默认构造区域设置时复制的默认区域设置，请使用`std::locale::global()`静态方法：
- en: '[PRE36]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Use the `imbue()` method to change the current locale of an I/O stream:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`imbue()`方法更改I/O流的当前区域设置：
- en: '[PRE37]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following list shows examples of using various locales:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了使用各种区域设置的示例：
- en: 'Use a particular locale, indicated by its name. In this example, the locale
    is for German:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特定的区域设置，通过其名称指示。在这个例子中，区域设置是为德语：
- en: '[PRE38]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Use a locale that corresponds to the user settings (as defined in the system).
    This is done by constructing a `std::locale` object from an empty string:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用与用户设置相对应的区域设置（如系统中所定义）。这通过从一个空字符串构造一个`std::locale`对象来完成：
- en: '[PRE39]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Set and use the global locale:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和使用全局区域设置：
- en: '[PRE40]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Use the default `C` locale:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认的`C`区域设置：
- en: '[PRE41]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A locale object does not actually store localized settings. A *locale* is a
    heterogeneous container of facets. A *facet* is an object that defines the localization
    and internationalization settings. The standard defines a list of facets that
    each locale must contain. In addition to this, a locale can contain any other
    user-defined facets. The following is a list of all standard-defined facets:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 区域对象实际上并不存储本地化设置。一个 *区域* 是一个异构的特件容器。一个 *特件* 是一个定义本地化和国际化设置的对象。标准定义了一个每个区域必须包含的特件列表。此外，区域还可以包含任何其他用户定义的特件。以下是一个所有标准定义的特件的列表：
- en: '| `std::collate<char>` | `std::collate<wchar_t>` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `std::collate<char>` | `std::collate<wchar_t>` |'
- en: '| `std::ctype<char>` | `std::ctype<wchar_t>` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `std::ctype<char>` | `std::ctype<wchar_t>` |'
- en: '| `std::codecvt<char,char,mbstate_t>``std::codecvt<char16_t,char,mbstate_t>`
    | `std::codecvt<char32_t,char,mbstate_t>``std::codecvt<wchar_t,char,mbstate_t>`
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `std::codecvt<char,char,mbstate_t>``std::codecvt<char16_t,char,mbstate_t>`
    | `std::codecvt<char32_t,char,mbstate_t>``std::codecvt<wchar_t,char,mbstate_t>`
    |'
- en: '| `std::moneypunct<char>``std::moneypunct<char,true>` | `std::moneypunct<wchar_t>``std::moneypunct<wchar_t,true>`
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `std::moneypunct<char>``std::moneypunct<char,true>` | `std::moneypunct<wchar_t>``std::moneypunct<wchar_t,true>`
    |'
- en: '| `std::money_get<char>` | `std::money_get<wchar_t>` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `std::money_get<char>` | `std::money_get<wchar_t>` |'
- en: '| `std::money_put<char>` | `std::money_put<wchar_t>` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `std::money_put<char>` | `std::money_put<wchar_t>` |'
- en: '| `std::numpunct<char>` | `std::numpunct<wchar_t>` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `std::numpunct<char>` | `std::numpunct<wchar_t>` |'
- en: '| `std::num_get<char>` | `std::num_get<wchar_t>` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `std::num_get<char>` | `std::num_get<wchar_t>` |'
- en: '| `std::num_put<char>` | `std::num_put<wchar_t>` |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `std::num_put<char>` | `std::num_put<wchar_t>` |'
- en: '| `std::time_get<char>` | `std::time_get<wchar_t>` |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `std::time_get<char>` | `std::time_get<wchar_t>` |'
- en: '| `std::time_put<char>` | `std::time_put<wchar_t>` |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `std::time_put<char>` | `std::time_put<wchar_t>` |'
- en: '| `std::messages<char>` | `std::messages<wchar_t>` |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `std::messages<char>` | `std::messages<wchar_t>` |'
- en: 'Table 7.2: List of standard facets'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.2：标准特性的列表
- en: It is beyond the scope of this recipe to go through this list and discuss all
    of these facets. However, we will mention that `std::money_get` is a facet that
    encapsulates the rules for parsing monetary values from character streams, while
    `std::money_put` is a facet that encapsulates the rules for formatting monetary
    values as strings. In a similar manner, `std::time_get` encapsulates rules for
    data and time parsing, while `std::time_put` encapsulates rules for data and time
    formatting. These will form the subject of the next couple of recipes.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论这个列表中的所有这些特性超出了本食谱的范围。然而，我们将提到 `std::money_get` 是一个封装从字符流解析货币值规则的特性，而 `std::money_put`
    是一个封装将货币值格式化为字符串的规则的特性。以类似的方式，`std::time_get` 封装了解析日期和时间的规则，而 `std::time_put`
    封装了格式化日期和时间的规则。这些将是下一两个食谱的主题。
- en: A locale is an immutable object containing immutable facet objects. Locales
    are implemented as a reference-counted array of reference-counted pointers to
    facets. The array is indexed by `std::locale::id`, and all facets must be derived
    from the base class `std::locale::facet` and must have a public static member
    of the `std::locale::id` type, called `id`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 区域设置是一个不可变对象，包含不可变的特性对象。区域设置作为引用计数的数组实现，该数组由引用计数的特性指针组成。数组通过 `std::locale::id`
    进行索引，并且所有特性都必须从基类 `std::locale::facet` 派生，并且必须有一个公共静态成员，其类型为 `std::locale::id`，称为
    `id`。
- en: 'It is only possible to create a locale object using one of the overloaded constructors
    or with the `combine()` method, which, as the name implies, combines the current
    locale with a new compile-time identifiable facet and returns a new locale object.
    The next example shows the use of the US English locale but with the numerical
    punctuation settings from the Norwegian locale:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 只能使用重载构造函数之一或使用 `combine()` 方法来创建区域设置对象，正如其名称所暗示的，`combine()` 方法将当前区域设置与一个新的编译时可识别的特性组合，并返回一个新的区域设置对象。下一个示例显示了使用美国英语区域设置，但带有来自挪威区域设置的数值标点设置的情况：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: On the other hand, it is possible to determine whether a locale contains a particular
    facet using the `std::has_facet()` function template, or to obtain a reference
    to a facet implemented by a particular locale using the `std::use_facet()` function
    template.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，可以使用 `std::has_facet()` 函数模板来确定区域设置是否包含特定的特性，或者使用 `std::use_facet()` 函数模板获取特定区域设置实现的特性的引用。
- en: In the preceding examples, we sorted a vector of strings and passed a locale
    object as the third argument to the `std::sort()` general algorithm. This third
    argument is supposed to be a comparison function object. Passing a locale object
    works because `std::locale` has an `operator()` that lexicographically compares
    two strings using its collate facet. This is actually the only localization functionality
    that is directly provided by `std::locale`; however, what this does is invoke
    the collate facet’s `compare()` method, which performs the string comparison based
    on the facet’s rules.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们对字符串向量进行了排序，并将区域设置对象作为 `std::sort()` 通用算法的第三个参数传递。这个第三个参数应该是一个比较函数对象。传递区域设置对象之所以有效，是因为
    `std::locale` 有一个 `operator()`，它使用其排序特性按字典顺序比较两个字符串。这实际上是 `std::locale` 直接提供的唯一本地化功能；然而，这实际上调用的是排序特性的
    `compare()` 方法，该方法根据特性的规则执行字符串比较。
- en: Every program has a global locale created when the program starts. The content
    of this global locale is copied into every default-constructed locale. The global
    locale can be replaced using the static method `std::locale::global()`. By default,
    the global locale is the `C` locale, which is a locale equivalent to ANSI C’s
    locale with the same name. This locale was created to handle simple English text,
    and it is the default one in C++ that provides compatibility with C. A reference
    to this locale can be obtained with the static method `std::locale::classic()`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序在启动时都会创建一个全局区域设置。这个全局区域设置的内容会被复制到每个默认构造的区域设置中。可以使用静态方法 `std::locale::global()`
    来替换全局区域设置。默认情况下，全局区域设置是 `C` 区域设置，它与具有相同名称的 ANSI C 区域设置等效。这个区域设置是为了处理简单的英文文本而创建的，并且在
    C++ 中是默认的区域设置，它提供了与 C 的兼容性。可以通过静态方法 `std::locale::classic()` 获取对这个区域设置的引用。
- en: By default, all streams use the classic locale to write or parse text. However,
    it is possible to change the locale used by a stream using the stream’s `imbue()`
    method. This is a member of the `std::ios_base` class, which is the base for all
    I/O streams. A companion member is the `getloc()` method, which returns a copy
    of the current stream’s locale.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding examples, we changed the locale for the `std::cout` stream
    object. In practice, you may want to set the same locale for all stream objects
    associated with the standard C streams: `cin`, `cout`, `cerr`, and `clog` (or
    `wcin`, `wcout`, `wcerr`, and `wclog`).'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: When you want to use a particular locale (such as German or Norwegian, as shown
    in this recipe), you must make sure they are available on your system. On Windows,
    this should not be a problem, but on a Linux system, they might not be installed.
    In this case, trying to instantiate a `std::locale` object, such as with `std::locale("de_DE.utf8")`,
    would result in a `std::runtime_error` exception being thrown. To install a locale
    on your system, consult its documentation to find the necessary steps you have
    to perform.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using I/O manipulators to control the output of a stream*, to learn about
    the use of helper functions, called manipulators, that control input and output
    streams using the `<<` and `>>` stream operators'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using monetary I/O manipulators*, to learn how to use standard manipulators
    to write and read monetary values'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using time I/O manipulators*, to learn how to use standard manipulators to
    write and read date and time values'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using I/O manipulators to control the output of a stream
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from the stream-based I/O library, the standard library provides a series
    of helper functions, called manipulators, that control the input and output streams
    using `operator<<` and `operator>>`. In this recipe, we will look at some of these
    manipulators and demonstrate their use through some examples that format the output
    to the console. We will continue covering more manipulators in the upcoming recipes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The I/O manipulators are available in the `std` namespace in the headers `<ios>`,
    `<istream>`, `<ostream>`, and `<iomanip>`. In this recipe, we will only discuss
    some of the manipulators from `<ios>` and `<iomanip>`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following manipulators can be used to control the output or input of a
    stream:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '`boolalpha` and `noboolalpha` enable and disable the textual representation
    of Booleans:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`left`, `right`, and `internal` affect the alignment of the fill characters;
    `left` and `right` affect all text, but `internal` affects only the integer, floating-point,
    and monetary output:'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`fixed`, `scientific`, `hexfloat`, and `defaultfloat` change the formatting
    used for floating-point types (for both the input and output streams). The latter
    two have only been available since C++11:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`dec`, `hex`, and `oct` control the base that is used for the integer types
    (in both the input and output streams):'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`setw` changes the width of the next input or output field. The default width
    is 0.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setw` 改变下一个输入或输出字段的宽度。默认宽度为 0。'
- en: '`setfill` changes the fill character for the output stream; this is the character
    that is used to fill the next fields until the specified width is reached. The
    default fill character is whitespace:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setfill` 改变输出流的填充字符；这是用于填充下一个字段直到达到指定宽度的字符。默认填充字符是空白字符：'
- en: '[PRE47]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`setprecision` changes the decimal precision (how many digits are generated)
    for the floating-point types in both the input and output streams. The default
    precision is 6:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setprecision` 改变输入和输出流中浮点类型的十进制精度（即生成的数字位数）。默认精度为 6：'
- en: '[PRE48]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All of the I/O manipulators listed earlier (with the exception of `setw`, which
    only refers to the next output field) affect the stream. Additionally, all consecutive
    writing or reading operations use the last specified format until another manipulator
    is used again.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的先前列出的 I/O 操纵符（除了 `setw`，它只针对下一个输出字段）都会影响流。此外，所有连续的写入或读取操作都会使用最后指定的格式，直到再次使用另一个操纵符。
- en: 'Some of these manipulators are called without arguments. Examples include `boolalpha`/`noboolalpha`
    or `dec`/`hex`/`oct`. These manipulators are functions that take a single argument
    (that is, a reference to a string) and return a reference to the same stream:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些操纵符是无参数调用的。例如，`boolalpha`/`noboolalpha` 或 `dec`/`hex`/`oct`。这些操纵符是接受单个参数（即字符串的引用）并返回同一流引用的函数：
- en: '[PRE49]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Expressions, such as `std::cout << std::hex`, are possible because both `basic_ostream::operator<<`
    and `basic_istream::operator>>` have special overloads that take a pointer to
    these functions.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如 `std::cout << std::hex` 这样的表达式是可能的，因为 `basic_ostream::operator<<` 和 `basic_istream::operator>>`
    都有特殊的重载，可以接受对这些函数的指针。
- en: 'Other manipulators, including some that are not mentioned here, are invoked
    with arguments. These manipulators are functions that take one or more arguments
    and return an object of an unspecified type:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 其他操纵符，包括这里未提及的一些，都是通过参数调用的。这些操纵符是接受一个或多个参数并返回一个未指定类型的对象的函数：
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: To better demonstrate the use of these manipulators, we will consider two examples
    that format output to the console.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地展示这些操纵符的使用，我们将考虑两个示例，这些示例将格式化输出到控制台。
- en: 'In the first example, we will list the table of contents of a book with the
    following requirements:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们将列出满足以下要求的书籍目录：
- en: The chapter number is right-aligned and shown with Roman numerals.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 章节编号右对齐，并使用罗马数字表示。
- en: The chapter title is left-aligned and the remaining space until the page number
    is filled with dots.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 章节标题左对齐，直到页码的剩余空间用点填充。
- en: The page number of the chapter is right-aligned.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 章节的页码右对齐。
- en: 'For this example, we will use the following classes and helper function:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用以下类和辅助函数：
- en: '[PRE51]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`std::left` and `std::right` specify the text alignment'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::left` 和 `std::right` 指定文本对齐方式'
- en: '`std::setw` specifies the width of each output field'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::setw` 指定每个输出字段的宽度'
- en: '`std::fill` specifies the fill character (a blank space for the chapter number
    and a dot for the chapter title)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fill` 指定填充字符（章节编号为空白字符，章节标题为点）'
- en: 'The implementation of the `print_toc()` function is listed here:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_toc()` 函数的实现如下：'
- en: '[PRE52]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following example uses this method with a `Book` object describing the
    table of contents from the book *The Fellowship of the Ring*:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用此方法与描述书籍《指环王》目录的 `Book` 对象：
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In this case, the output is as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出如下：
- en: '[PRE54]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'For the second example, our goal is to output a table that lists the largest
    companies in the world by revenue. The table will have columns for the company
    name, the industry, the revenue (in USD billions), the increase/decrease in revenue
    growth, the revenue growth, the number of employees, and the country of origin.
    For this example, we will use the following class:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个例子，我们的目标是输出一个列表，列出按收入排名的世界最大公司。该表格将包含公司名称、行业、收入（以十亿美元为单位）、收入增长/下降、收入增长率、员工人数和起源国家。对于这个例子，我们将使用以下类：
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `print_companies()` function in the following code snippet uses several
    additional manipulators to the ones shown in the previous example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段中的 `print_companies()` 函数使用了几个额外的操纵符，这些操纵符在先前的例子中已经展示过：
- en: '`std::boolalpha` displays Boolean values as `true` and `false` instead of `1`
    and `0`.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::boolalpha` 将布尔值显示为 `true` 和 `false` 而不是 `1` 和 `0`。'
- en: '`std::fixed` indicates a fixed floating-point representation, and then `std::defaultfloat`
    reverts to the default floating-point representation.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fixed` 表示固定浮点表示，然后 `std::defaultfloat` 恢复到默认浮点表示。'
- en: '`std::setprecision` specifies the number of decimal digits to be displayed
    in the output. Together with `std::fixed`, this is used to indicate a fixed representation
    with a decimal digit for the `Growth` field.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::setprecision` 指定在输出中显示的小数位数。与 `std::fixed` 一起使用，这用于表示具有小数位的 `Growth`
    字段。'
- en: 'The implementation of the `print_companies()` function is listed here:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_companies()` 函数的实现如下所示：'
- en: '[PRE56]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following is an example of calling this method. The source of the data
    shown here is Wikipedia ([https://en.wikipedia.org/wiki/List_of_largest_companies_by_revenue](https://en.wikipedia.org/wiki/List_of_largest_companies_by_revenue),
    as of 2016):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个调用此方法的示例。此处数据的来源是维基百科（[https://en.wikipedia.org/wiki/List_of_largest_companies_by_revenue](https://en.wikipedia.org/wiki/List_of_largest_companies_by_revenue)，截至2016年）：
- en: '[PRE57]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In this case, the output has a table-based format, as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出具有基于表格的格式，如下所示：
- en: '[PRE58]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As an exercise, you can try adding a table heading or even a grid line to precede
    these lines for a better tabulation of the data.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以尝试添加表头或甚至网格线来 precede 这些行，以更好地表格化数据。
- en: See also
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Reading and writing raw data from/to binary files*, to learn how to write
    and read unstructured data to binary files'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从/向二进制文件读取和写入原始数据*，以学习如何将非结构化数据写入和读取到二进制文件'
- en: '*Using monetary I/O manipulators*, to learn how to use standard manipulators
    to write and read monetary values'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用货币I/O操作符*，以学习如何使用标准操作符来写入和读取货币值'
- en: '*Using time I/O manipulators*, to learn how to use standard manipulators to
    write and read date and time values'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用时间I/O操作符*，以学习如何使用标准操作符来写入和读取日期和时间值'
- en: Using monetary I/O manipulators
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用货币I/O操作符
- en: In the previous recipe, we looked at some of the manipulators that can be used
    to control input and output streams. The manipulators that we discussed were related
    to numeric values and text values. In this recipe, we will look at how to use
    standard manipulators to write and read monetary values.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中，我们查看了一些可以用于控制输入和输出流的操作符。我们讨论的操作符与数值和文本值相关。在本配方中，我们将探讨如何使用标准操作符来写入和读取货币值。
- en: Getting ready
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should now be familiar with locales and how to set them for a stream. This
    topic was discussed in the *Using localized settings for streams* recipe. It is
    recommended that you read that recipe before continuing.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该熟悉区域设置以及如何为流设置它们。这个主题在 *使用流的本地区域设置* 配方中讨论过。建议你在继续之前阅读该配方。
- en: The manipulators discussed in this recipe are available in the `std` namespace,
    in the `<iomanip>` header.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方中讨论的操作符在 `std` 命名空间中，在 `<iomanip>` 头文件中可用。
- en: How to do it...
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To write a monetary value to an output stream, you should do the following:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要将货币值写入输出流，你应该执行以下操作：
- en: 'Set the desired locale for controlling the monetary format:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置所需的区域设置以控制货币格式：
- en: '[PRE59]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Use either a `long double` or a `std::basic_string` value for the amount:'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `long double` 或 `std::basic_string` 值作为金额：
- en: '[PRE60]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Use a `std::put_money` manipulator with a single argument (the monetary value)
    to display the value using the currency symbol (if any is available):'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::put_money` 操作符并带一个参数（货币值）来显示使用货币符号（如果有的话）的值：
- en: '[PRE61]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Use `std::put_money` with two arguments (the monetary value and a Boolean flag
    set to `true`) to indicate the use of an international currency string:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::put_money` 并带两个参数（货币值和设置为 `true` 的布尔标志）来指示使用国际货币字符串：
- en: '[PRE62]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To read a monetary value from an input stream, you should do the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 从输入流中读取货币值，你应该执行以下操作：
- en: 'Set the desired locale to control the monetary format:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置所需的区域设置以控制货币格式：
- en: '[PRE63]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Use either a `long double` or `std::basic_string` value to read the amount
    from the input stream:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `long double` 或 `std::basic_string` 值从输入流中读取金额：
- en: '[PRE64]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Use `std::get_money()` with a single argument (the variable where the monetary
    value is to be written) if a currency symbol might be used in the input stream:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入流中可能使用货币符号，请使用 `std::get_money()` 并带一个参数（要写入货币值的变量）：
- en: '[PRE65]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Use `std::get_money()` with two arguments (the variable where the monetary
    value is to be written and a Boolean flag set to `true`) to indicate the presence
    of an international currency string:'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::get_money()` 并带两个参数（要写入货币值的变量和设置为 `true` 的布尔标志）来指示存在国际货币字符串：
- en: '[PRE66]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works...
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `put_money()` and `get_money()` manipulators are very similar. They are
    both function templates that take an argument representing either the monetary
    value to be written to the output stream or a variable to hold the monetary value
    read from an input stream, and a second, optional parameter to indicate whether
    an international currency string is used. The default alternative is the currency
    symbol, if one is available. `put_money()` uses the `std::money_put()` facet settings
    to output a monetary value, and `get_money()` uses the `std::money_get()` facet
    to parse a monetary value. Both manipulator function templates return an object
    of an unspecified type. These functions do not throw exceptions:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`put_money()`和`get_money()`操作符非常相似。它们都是函数模板，接受一个表示要写入输出流的货币值或从输入流读取的货币值变量的参数，以及一个可选的参数，用于指示是否使用国际货币字符串。默认选项是货币符号，如果可用。`put_money()`使用`std::money_put()`面设置来输出货币值，而`get_money()`使用`std::money_get()`面来解析货币值。这两个操作符函数模板都返回一个未指定类型的对象。这些函数不抛出异常：'
- en: '[PRE67]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Both of these manipulator functions require the monetary value to be either
    a `long double` or a `std::basic_string`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个操作符函数都需要货币值是`long double`或`std::basic_string`。
- en: However, it is important to note that monetary values are stored as integral
    numbers of the smallest denomination of the currency defined by the locale in
    use. Considering US dollars as that currency, $100.00 is stored as **10000.0**,
    and 1 cent (that is, $0.01) is stored as **1.0**.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，货币值以使用中的区域设置的货币最小面额的整数形式存储。以美元为例，$100.00存储为**10000.0**，而1分（即$0.01）存储为**1.0**。
- en: 'When writing a monetary value to an output stream, it is important to use the
    `std::showbase` manipulator if you want to display the currency symbol or the
    international currency string. This is normally used to indicate the prefix of
    a numeric base (such as `0x` for hexadecimal); however, for monetary values, it
    is used to indicate whether the currency symbol/string should be displayed or
    not. The following snippet provides an example:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当将货币值写入输出流时，如果你想显示货币符号或国际货币字符串，则必须使用`std::showbase`操作符。这通常用于表示数字基的前缀（例如，十六进制的`0x`）；然而，对于货币值，它用于指示是否应显示货币符号/字符串。以下代码片段提供了一个示例：
- en: '[PRE68]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: See also
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Using I/O manipulators to control the output of a stream*, to learn about
    the use of helper functions, called manipulators, that control input and output
    streams using the `<<` and `>>` stream operators'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用I/O操作符控制流输出*，了解使用辅助函数，即操作符，它们通过`<<`和`>>`流操作符来控制输入和输出流。'
- en: '*Using time I/O manipulators*, to learn how to use standard manipulators to
    write and read date and time values'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用时间I/O操作符*，了解如何使用标准操作符写入和读取日期和时间值'
- en: Using time I/O manipulators
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用时间I/O操作符
- en: Similar to the monetary I/O manipulators that we discussed in the previous recipe,
    the C++11 standard provides manipulators that control the writing and reading
    of time values to and from streams, where time values are represented in the form
    of a `std::tm` object that holds a calendar date and time. In this recipe, you
    will learn how to use these time manipulators.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在上一个菜谱中讨论的货币I/O操作符类似，C++11标准提供了控制时间值写入和读取流中的操作符，其中时间值以`std::tm`对象的形式表示，该对象包含日历日期和时间。在本菜谱中，你将学习如何使用这些时间操作符。
- en: Getting ready
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: Time values used by the time I/O manipulators are expressed in `std::tm` values.
    You should be familiar with this structure from the `<ctime>` header.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 时间I/O操作符使用的时间值以`std::tm`值表示。你应该熟悉这个结构，它来自`<ctime>`头文件。
- en: You should also be familiar with locales and how to set them for a stream. This
    topic was discussed in the *Using localized settings for streams* recipe. It is
    recommended that you read that recipe before continuing.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该熟悉区域设置以及如何为流设置它们。这个主题在*使用流区域设置*菜谱中讨论过。建议你在继续之前阅读那个菜谱。
- en: The manipulators discussed in this recipe are available in the `std` namespace,
    in the `<iomanip>` header.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱中讨论的操作符在`std`命名空间中，在`<iomanip>`头文件中可用。
- en: How to do it...
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To write a time value to an output stream, you should perform the following
    steps:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要将时间值写入输出流，你应该执行以下步骤：
- en: 'Obtain a calendar date and time value corresponding to a given time. There
    are various ways in which to do this. The following shows several examples of
    how to convert the current time to a local time that is expressed as a calendar
    date and time:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取与给定时间对应的日历日期和时间值。有多种方法可以实现这一点。以下展示了如何将当前时间转换为以日历日期和时间表示的本地时间的几个示例：
- en: '[PRE69]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Use `std::put_time()` to supply a pointer to the `std::tm` object, representing
    the calendar date and time, and a pointer to a null-terminated character string,
    representing the format. The C++11 standard provides a long list of formats that
    can be used; this list can be consulted at [http://en.cppreference.com/w/cpp/io/manip/put_time](http://en.cppreference.com/w/cpp/io/manip/put_time).
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`std::put_time()`提供一个指向表示日历日期和时间的`std::tm`对象的指针，以及一个指向以空字符结尾的字符字符串的指针，表示格式。C++11标准提供了一长串可用的格式；此列表可以在[http://en.cppreference.com/w/cpp/io/manip/put_time](http://en.cppreference.com/w/cpp/io/manip/put_time)中查阅。
- en: 'To write a standard date and time string according to the settings of a specific
    locale, first set the locale for the stream by calling `imbue()` and then use
    the `std::put_time()` manipulator:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要根据特定区域的设置写入标准日期和时间字符串，首先通过调用`imbue()`设置流的区域，然后使用`std::put_time()`操纵符：
- en: '[PRE70]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The following list shows some examples of supported time formats:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一些受支持的时间格式示例：
- en: 'ISO 8601 date format `"%F"` or `"%Y-%m-%d"`:'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISO 8601日期格式`"%F"`或`"%Y-%m-%d"`：
- en: '[PRE71]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'ISO 8601 time format `"%T"`:'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISO 8601时间格式`"%T"`：
- en: '[PRE72]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'ISO 8601 combined date and time in UTC format `"%FT%T%z"`:'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISO 8601 UTC格式组合日期和时间`"%FT%T%z"`：
- en: '[PRE73]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'ISO 8601 week format `"%Y-W%V"`:'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISO 8601周格式`"%Y-W%V"`：
- en: '[PRE74]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'ISO 8601 date with week number format `"``%Y-W%V-%u"`:'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISO 8601带周数日期格式`"%Y-W%V-%u"`：
- en: '[PRE75]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'ISO 8601 ordinal date format `"%Y-%j"`:'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISO 8601序数日期格式`"%Y-%j"`：
- en: '[PRE76]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To read a time value from an input stream, you should perform the following
    steps:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 要从输入流中读取时间值，应执行以下步骤：
- en: 'Declare an object of the `std::tm` type to hold the time value read from the
    stream:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`std::tm`类型的对象来保存从流中读取的时间值：
- en: '[PRE77]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Use `std::get_time()` to supply a pointer to the `std::tm` object, which will
    hold the time value, and a pointer to a null-terminated character string, which
    represents the format. The list of possible formats can be consulted at [http://en.cppreference.com/w/cpp/io/manip/get_time](http://en.cppreference.com/w/cpp/io/manip/get_time).
    The following example parses an ISO 8601 combined date and time value:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`std::get_time()`提供一个指向`std::tm`对象的指针，该对象将保存时间值，以及一个指向以空字符结尾的字符字符串的指针，该字符串表示格式。可能的格式列表可以在[http://en.cppreference.com/w/cpp/io/manip/get_time](http://en.cppreference.com/w/cpp/io/manip/get_time)中查阅。以下示例解析了ISO
    8601组合日期和时间值：
- en: '[PRE78]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To read a standard date and time string according to the settings of a specific
    locale, first set the locale for the stream by calling `imbue()` and then use
    the `std::get_time()` manipulator:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要根据特定区域的设置读取标准日期和时间字符串，首先通过调用`imbue()`设置流的区域，然后使用`std::get_time()`操纵符：
- en: '[PRE79]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: How it works...
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The two manipulators for time values, `put_time()` and `get_time()`, are very
    similar: they are both function templates with two arguments. The first argument
    is a pointer to a `std::tm` object representing the calendar date and time, which
    holds the value to be written to the stream or the value that is read from the
    stream. The second argument is a pointer to a null-terminated character string
    representing the format of the time text. `put_time()` uses the `std::time_put()`
    facet to output a date and time value, and `get_time()` uses the `std::time_get()`
    facet to parse a date and time value. Both manipulator function templates return
    an object of an unspecified type. These functions do not throw exceptions:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 时间值操纵符`put_time()`和`get_time()`非常相似：它们都是具有两个参数的函数模板。第一个参数是指向表示日历日期和时间的`std::tm`对象的指针，该对象包含要写入流或从流中读取的值。第二个参数是指向表示时间文本格式的以空字符结尾的字符字符串的指针。`put_time()`使用`std::time_put()`方面来输出日期和时间值，而`get_time()`使用`std::time_get()`方面来解析日期和时间值。这两个操纵符函数模板都返回一个未指定类型的对象。这些函数不抛出异常：
- en: '[PRE80]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The string that results from using `put_time()` to write a date and time value
    to an output stream is the same as the one that results from a call to `std::strftime()`
    or `std::wcsftime()`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`put_time()`将日期和时间值写入输出流的结果字符串与调用`std::strftime()`或`std::wcsftime()`的结果相同。
- en: The standard defines a long list of available conversion specifiers that compose
    the format string. These specifiers are prefixed with a `%`, and, in some cases,
    are followed by an `E` or a `0`. Some of them are also equivalent; for instance,
    `%F` is equivalent to `%Y-%m-%d` (this is the ISO 8601 date format), and `%T`
    is equivalent to `%H:%M:%S` (this is the ISO 8601 time format). The examples in
    this recipe mention only a few of the conversion specifiers, referring to ISO
    8601 date and time formats. For the complete list of conversion specifiers, refer
    to the C++ standard or follow the links that were mentioned earlier.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 标准定义了一系列可用的转换说明符，它们构成了格式字符串。这些说明符以 `%` 开头，在某些情况下，后面跟着 `E` 或 `0`。其中一些也是等效的；例如，`%F`
    等同于 `%Y-%m-%d`（这是 ISO 8601 日期格式），而 `%T` 等同于 `%H:%M:%S`（这是 ISO 8601 时间格式）。本配方中提到的示例仅涉及少数转换说明符，指的是
    ISO 8601 日期和时间格式。对于转换说明符的完整列表，请参阅 C++ 标准，或遵循之前提到的链接。
- en: 'It is important to note that not all of the conversion specifiers supported
    by `put_time()` are also supported by `get_time()`. Examples include the `z` (offset
    from UTC in the ISO 8601 format) and `Z` (time zone name or abbreviation) specifiers,
    which can only be used with `put_time()`. This is demonstrated in the following
    snippet:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`put_time()` 支持的所有转换说明符并不一定都由 `get_time()` 支持。例如，`z`（UTC 偏移量，ISO 8601
    格式）和 `Z`（时区名称或缩写）说明符只能与 `put_time()` 一起使用。以下代码片段展示了这一点：
- en: '[PRE81]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The text represented by some conversion specifiers is locale-dependent. All
    specifiers prefixed with `E` or `0` are locale-dependent. To set a particular
    locale for the stream, use the `imbue()` method, as demonstrated in the examples
    in the *How to do it...* section.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 由某些转换说明符表示的文本是区域相关的。所有以 `E` 或 `0` 开头的说明符都是区域相关的。要为流设置特定的区域，请使用 `imbue()` 方法，如
    *如何做...* 部分中的示例所示。
- en: The `std::localtime()` function used in an earlier example returns a pointer
    to a static internal `std::tm` object if it succeeds (or `nullptr` otherwise).
    You should not attempt to free this pointer!
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中使用的 `std::localtime()` 函数在成功时返回一个指向静态内部 `std::tm` 对象的指针（否则返回 `nullptr`）。你不应该尝试释放这个指针！
- en: See also
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using I/O manipulators to control the output of a stream*, to learn about
    the use of helper functions, called manipulators, that control input and output
    streams using the `<<` and `>>` stream operators'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 I/O 操作符控制流输出*，了解如何使用称为操作符的辅助函数来控制输入和输出流，这些操作符使用 `<<` 和 `>>` 流运算符。'
- en: '*Using monetary I/O manipulators*, to learn how to use standard manipulators
    to write and read monetary values'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用货币 I/O 操作符*，了解如何使用标准操作符来写入和读取货币值'
- en: Working with filesystem paths
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与文件系统路径一起工作
- en: An important addition to the C++17 standard is the `filesystem` library, which
    enables us to work with paths, files, and directories in hierarchical filesystems
    (such as Windows or POSIX filesystems). This standard library has been developed
    based on the `boost.filesystem` library. In the next few recipes, we will explore
    those features of the library that enable us to perform operations with files
    and directories, such as creating, moving, or deleting them, but also querying
    properties and searching. It is important, however, to first look at how this
    library handles paths.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: C++17 标准的一个重要补充是 `filesystem` 库，它使我们能够处理分层文件系统（如 Windows 或 POSIX 文件系统）中的路径、文件和目录。这个标准库是基于
    `boost.filesystem` 库开发的。在接下来的几个配方中，我们将探讨该库的这些功能，这些功能使我们能够执行文件和目录操作，例如创建、移动或删除它们，以及查询属性和搜索。然而，首先查看这个库如何处理路径是很重要的。
- en: Getting ready
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will consider most of the examples using Windows paths.
    In the accompanying code, all examples have both Windows and POSIX alternatives.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将考虑大多数使用 Windows 路径的示例。在配套代码中，所有示例都有 Windows 和 POSIX 的替代方案。
- en: 'The `filesystem` library is available in the `std::filesystem` namespace, in
    the `<filesystem>` header. To simplify the code, we will use the following namespace
    alias in all of the examples:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`filesystem` 库位于 `std::filesystem` 命名空间中，在 `<filesystem>` 头文件中。为了简化代码，我们将在所有示例中使用以下命名空间别名：'
- en: '[PRE82]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: A path to a filesystem component (file, directory, hard link, or soft link)
    is represented by the `path` class.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统组件（文件、目录、硬链接或软链接）的路径由 `path` 类表示。
- en: How to do it...
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following is a list of the most common operations on paths:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对路径最常见的操作列表：
- en: 'Create a path using the constructor, the assignment operator, or the `assign()`
    method:'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用构造函数、赋值运算符或`assign()`方法创建路径：
- en: '[PRE83]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Append elements to a path by including a directory separator using the member
    `operator /=`, the non-member `operator /`, or the `append()` method:'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用成员`operator /=`、非成员`operator /`或`append()`方法通过包含目录分隔符将元素附加到路径：
- en: '[PRE84]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Concatenate elements to a path without including a directory separator by using
    the member `operator +=`, the non-member `operator +`, or the `concat()` method:'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用成员`operator +=`、非成员`operator +`或`concat()`方法将元素连接到路径，而不包括目录分隔符：
- en: '[PRE85]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Decompose the elements of a path into its parts, such as the root, root directory,
    parent path, filename, extension, and so on, using member functions such as `root_name()`,
    `root_dir()`, `filename()`, `stem()`, `extension()`, and so on (all of them are
    shown in the following example):'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用成员函数（如`root_name()`、`root_dir()`、`filename()`、`stem()`、`extension()`等）将路径的元素分解为其部分，例如根、根目录、父路径、文件名、扩展名等（所有这些都在以下示例中展示）：
- en: '[PRE86]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Query whether parts of a part are available using member functions such as
    `has_root_name()`, `has_root_directory()`, `has_filename()`, `has_stem()`, and
    `has_extension()` (all of these are shown in the following example):'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用成员函数（如`has_root_name()`、`has_root_directory()`、`has_filename()`、`has_stem()`和`has_extension()`）查询路径部分是否可用（所有这些都在以下示例中展示）：
- en: '[PRE87]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Check whether a path is relative or absolute:'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查路径是相对的还是绝对的：
- en: '[PRE88]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Modify individual parts of the path, such as the filename with `replace_filename()`
    and `remove_filename()`, and the extension with `replace_extension()`:'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`replace_filename()`和`remove_filename()`修改路径的各个部分，如文件名，以及使用`replace_extension()`修改扩展名：
- en: '[PRE89]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Convert the directory separator to the system-preferred separator:'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将目录分隔符转换为系统首选的分隔符：
- en: '[PRE90]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: How it works...
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `std::filesystem::path` class models paths to filesystem components. However,
    it only handles the syntax and does not validate the existence of a component
    (such as a file or a directory) represented by the path.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::filesystem::path`类模拟文件系统组件的路径。然而，它只处理语法，并不验证路径表示的组件（如文件或目录）的存在性。'
- en: 'The library defines a portable, generic syntax for paths that can accommodate
    various filesystems, such as POSIX or Windows, including the Microsoft Windows
    **Universal Naming Convention** (**UNC**) format. Both of them differ in several
    key aspects:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 该库定义了一个可移植的通用路径语法，可以适应各种文件系统，如POSIX或Windows，包括Microsoft Windows **通用命名约定**（**UNC**）格式。两者在几个关键方面有所不同：
- en: POSIX systems have a single tree, no root name, a single root directory called
    `/`, and a single current directory. Additionally, they use `/` as the directory
    separator. Paths are represented as null-terminated strings of `char` encoded
    as UTF-8.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX系统有一个单一的树，没有根名称，一个名为`/`的单个根目录，以及一个单个当前目录。此外，它们使用`/`作为目录分隔符。路径表示为以UTF-8编码的`char`的空终止字符串。
- en: Windows systems have multiple trees, each with a root name (such as `C:`), a
    root directory (such as `\`), and a current directory (such as `C:\Windows\System32`).
    Paths are represented as null-terminated strings of wide characters encoded as
    UTF-16.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows系统有多个树，每个树都有一个根名称（如`C:`），一个根目录（如`\`），以及一个当前目录（如`C:\Windows\System32`）。路径表示为以UTF-16编码的宽字符的空终止字符串。
- en: You should not mix path formats across different systems. Although Windows can
    handle POSIX paths, the other way around is not true. Use the path format specific
    to each system. Additionally, you can use the `filesystem::path` functionality,
    such as `operator /=` and the `append()` function, as well as the `preferred_separator`
    static member to build paths in a portable manner.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该在不同系统之间混合路径格式。尽管Windows可以处理POSIX路径，但反之则不然。请使用每个系统特定的路径格式。此外，你可以使用`filesystem::path`功能，例如`operator
    /=`和`append()`函数，以及`preferred_separator`静态成员来以可移植的方式构建路径。
- en: 'A pathname, as defined in the `filesystem` library, has the following syntax:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义在`filesystem`库中的`pathname`具有以下语法：
- en: An optional root name (`C:` or `//localhost`)
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的根名称（`C:`或`//localhost`）
- en: An optional root directory
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的根目录
- en: Zero or more filenames (which may refer to a file, a directory, a hard link,
    or a symbolic link) or directory separators
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零个或多个文件名（可能指文件、目录、硬链接或符号链接）或目录分隔符
- en: 'There are two special filenames that are recognized: the single dot (`.`),
    which represents the current directory, and the double dot (`..`), which represents
    the parent directory. The directory separator can be repeated, in which case it
    is treated as a single separator (in other words, `/home////docs` is the same
    as `/home/marius/docs`). A path that has no redundant current directory name (`.`),
    no redundant parent directory name (`..`), and no redundant directory separators
    is said to be in a normal form.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个特殊的文件名被识别：单个点（`.`），它代表当前目录，和双点（`..`），它代表父目录。目录分隔符可以重复，在这种情况下，它被视为单个分隔符（换句话说，`/home////docs`与`/home/marius/docs`相同）。一个没有冗余当前目录名（`.`）、没有冗余父目录名（`..`）和没有冗余目录分隔符的路径被认为是正常形式。
- en: The path operations presented in the previous section are the most common operations
    with paths. However, their implementation defines additional querying and modifying
    methods, iterators, non-member comparison operators, and more.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中介绍的路径操作是最常见的路径操作。然而，它们的实现定义了额外的查询和修改方法、迭代器、非成员比较运算符等等。
- en: 'The following sample iterates through the parts of a path and prints them to
    the console:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例遍历路径的部分并将它们打印到控制台：
- en: '[PRE91]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The following listing represents its result:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表表示其结果：
- en: '[PRE92]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: In this example, `sample.file.txt` is the filename. This is basically the part
    from the last directory separator to the end of the path. This is what the member
    function `filename()` would be returning for the given path. The extension for
    this file is `.txt`, which is the string returned by the `extension()` member
    function. To retrieve the filename without an extension, another member function
    called `stem()` is available. Here, the string returned by this method is `sample.file`.
    For all of these methods, but also all of the other decomposition methods, there
    is a corresponding querying method with the same name and the prefix `has_`, such
    as `has_filename()`, `has_stem()`, and `has_extension()`. All of these methods
    return a `bool` value to indicate whether the path has the corresponding part.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，`sample.file.txt`是文件名。这基本上是从最后一个目录分隔符到路径末尾的部分。这就是成员函数`filename()`对于给定路径会返回的内容。该文件的扩展名是`.txt`，这是由`extension()`成员函数返回的字符串。要获取不带扩展名的文件名，可以使用另一个名为`stem()`的成员函数。在这里，该方法返回的字符串是`sample.file`。对于所有这些方法，以及所有其他分解方法，都有一个具有相同名称和前缀`has_`的相应查询方法，例如`has_filename()`、`has_stem()`和`has_extension()`。所有这些方法都返回一个`bool`值，以指示路径是否有相应的部分。
- en: See also
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating, copying, and deleting files and directories*, to learn how to perform
    these basic operations with files and directories independently of the filesystem
    in use'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建、复制和删除文件和目录*，以了解如何独立于使用的文件系统执行这些基本操作'
- en: '*Checking the properties of an existing file or directory*, to learn how to
    query the properties of files and directories, such as the type, permissions,
    file times, and more'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查现有文件或目录的属性*，以了解如何查询文件和目录的属性，例如类型、权限、文件时间等'
- en: Creating, copying, and deleting files and directories
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建、复制和删除文件和目录
- en: Operations with files, such as copying, moving, and deleting, or with directories,
    such as creating, renaming, and deleting, are all supported by the `filesystem`
    library. Files and directories are identified using a path (which can be absolute,
    canonical, or relative), a topic that was covered in the previous recipes. In
    this recipe, we will look at what the standard functions for the previously mentioned
    operations are and how they work.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 文件操作，如复制、移动和删除，或目录操作，如创建、重命名和删除，都由`filesystem`库支持。文件和目录使用路径（可以是绝对路径、规范路径或相对路径）来标识，这在之前的菜谱中已经介绍过。在本菜谱中，我们将查看之前提到的操作的标准化函数以及它们的工作方式。
- en: Getting ready
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before going forward, you should read the *Working with filesystem paths* recipe.
    The introductory notes from that recipe also apply here. However, all of the examples
    in this recipe are platform-independent.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你应该阅读*使用文件系统路径*菜谱。该菜谱的简介说明也适用于此处。然而，本菜谱中的所有示例都是平台无关的。
- en: 'For all of the following examples, we will use the following variables and
    assume the current path is `C:\Users\Marius\Documents` on Windows and `/home/marius/docs`
    for a POSIX system:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下所有示例，我们将使用以下变量，并假设在Windows上的当前路径是`C:\Users\Marius\Documents`，而在POSIX系统上是`/home/marius/docs`：
- en: '[PRE93]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We will also assume the presence of a file called `sample.txt` in the `temp`
    subdirectory of the current path (such as `C:\Users\Marius\Documents\temp\sample.txt`
    or `/home/marius/docs/temp/sample.txt`).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将假设在当前路径的`temp`子目录中存在一个名为`sample.txt`的文件（例如`C:\Users\Marius\Documents\temp\sample.txt`或`/home/marius/docs/temp/sample.txt`）。
- en: How to do it...
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use the following library functions to perform operations with directories:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下库函数执行目录操作：
- en: 'To create a new directory, use `create_directory()`. This method does nothing
    if the directory already exists; however, it does not create directories recursively:'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建一个新的目录，使用`create_directory()`。如果目录已存在，此方法不会执行任何操作；然而，它不会递归地创建目录：
- en: '[PRE94]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'To create new directories recursively, use `create_directories()`:'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要递归地创建新目录，使用`create_directories()`：
- en: '[PRE95]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'To move an existing directory, use `rename()`:'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要移动现有的目录，使用`rename()`：
- en: '[PRE96]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'To rename an existing directory, also use `rename()`:'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要重命名现有的目录，也使用`rename()`：
- en: '[PRE97]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'To copy an existing directory, use `copy()`. To recursively copy the entire
    content of a directory, use the `copy_options::recursive` flag:'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要复制现有的目录，使用`copy()`。要递归地复制目录的全部内容，使用`copy_options::recursive`标志：
- en: '[PRE98]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'To create a symbolic link to a directory, use `create_directory_symlink()`:'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建指向目录的符号链接，使用`create_directory_symlink()`：
- en: '[PRE99]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'To remove an empty directory, use `remove()`:'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要删除空目录，使用`remove()`：
- en: '[PRE100]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'To remove the entire content of a directory recursively and the directory itself,
    use `remove_all()`:'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要递归地删除目录的全部内容及其自身，使用`remove_all()`：
- en: '[PRE101]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'To change permissions on a directory or a file, use `permissions()`, specifying
    permissions options from the `perms` enum. Unless you specify an operation type
    (replace, add, or remove) from the `perm_options` enum, the default action is
    to replace all existing permissions with the specified ones:'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要更改目录或文件的权限，使用`permissions()`，指定来自`perms`枚举的权限选项。除非您从`perm_options`枚举中指定操作类型（替换、添加或删除），否则默认操作是用指定的权限替换所有现有权限：
- en: '[PRE102]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Use the following library functions to perform operations with files:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下库函数执行文件操作：
- en: 'To copy a file, use `copy()` or `copy_file()`. The next section explains the
    difference between the two:'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要复制文件，使用`copy()`或`copy_file()`。下一节将解释这两个函数之间的区别：
- en: '[PRE103]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'To rename a file, use `rename()`:'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要重命名文件，使用`rename()`：
- en: '[PRE104]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'To move a file, use `rename()`:'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要移动文件，使用`rename()`：
- en: '[PRE105]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'To create a symbolic link to a file, use `create_symlink()`:'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建指向文件的符号链接，使用`create_symlink()`：
- en: '[PRE106]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'To delete a file, use `remove()`:'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要删除文件，使用`remove()`：
- en: '[PRE107]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: How it works...
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'All of the functions mentioned in this recipe, and other similar functions
    that are not discussed here, have multiple overloads that can be grouped into
    two categories:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中提到的所有函数，以及此处未讨论的其他类似函数，都有多个重载，可以归纳为两类：
- en: 'Overloads that take, as the last argument, a reference to a `std::error_code`:
    these overloads do not throw an exception (they are defined with the `noexcept`
    specification). Instead, they set the value of the `error_code` object to the
    operating system error code if an operating system error has occurred. If no such
    error has occurred, then the `clear()` method on the `error_code` object is called
    to reset any possible previously set code.'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载函数，其最后一个参数是`std::error_code`的引用：这些重载函数不会抛出异常（它们使用`noexcept`指定）。相反，如果发生操作系统错误，它们将`error_code`对象的值设置为操作系统错误代码。如果没有发生此类错误，则调用`error_code`对象的`clear()`方法来重置任何可能之前设置的代码。
- en: 'Overloads that do not take the last argument of the `std::error_code` type:
    these overloads throw exceptions if errors occur. If an operating system error
    occurs, they throw a `std::filesystem::filesystem_error` exception. On the other
    hand, if memory allocation fails, these functions throw a `std::bad_alloc` exception.'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不接受`std::error_code`类型最后一个参数的重载函数：如果发生错误，这些重载函数会抛出异常。如果发生操作系统错误，它们会抛出`std::filesystem::filesystem_error`异常。另一方面，如果内存分配失败，这些函数会抛出`std::bad_alloc`异常。
- en: All the examples in the previous section used the overload that does not throw
    exceptions but, instead, sets a code when an error occurs. Some functions return
    a `bool` to indicate a success or a failure. You can check whether the `error_code`
    object holds the code of an error by either checking whether the value of the
    error code, returned by the method `value()`, is different from 0, or by using
    the conversion `operator bool`, which returns `true` for the same case and `false`
    otherwise. To retrieve the explanatory string for the error code, use the `message()`
    method.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的所有示例都使用了不抛出异常的重载，而是在发生错误时设置一个代码。一些函数返回一个 `bool` 来指示成功或失败。您可以通过检查方法 `value()`
    返回的错误代码的值是否不同于 0，或者通过使用转换 `operator bool` 来检查 `error_code` 对象是否包含错误代码，该转换在相同情况下返回
    `true`，否则返回 `false`。要获取错误代码的解释性字符串，请使用 `message()` 方法。
- en: Some `filesystem` library functions are common for both files and directories.
    This is the case for `rename()`, `remove()`, and `copy()`. The working details
    of each of these functions can be complex, especially in the case of `copy()`,
    and are beyond the scope of this recipe. You should refer to the reference documentation
    if you need to perform anything other than the simple operations covered here.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 `filesystem` 库函数对文件和目录都适用。`rename()`、`remove()` 和 `copy()` 就是这种情况。这些函数的工作细节可能很复杂，尤其是在
    `copy()` 的情况下，并且超出了本食谱的范围。如果您需要执行这里未涵盖的任何其他操作，请参阅参考文档。
- en: 'When it comes to copying files, there are two functions that can be used: `copy()`
    and `copy_file()`. These have equivalent overloads with identical signatures and,
    apparently, work the same way. However, there is an important difference (other
    than the fact that `copy()` also works for directories): `copy_file()` follows
    symbolic links.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制文件时，可以使用两个函数：`copy()` 和 `copy_file()`。它们具有等效的重载，具有相同的签名，并且显然以相同的方式工作。然而，有一个重要的区别（除了
    `copy()` 也可以用于目录之外）：`copy_file()` 会跟随符号链接。
- en: 'To avoid doing that and, instead, copy the actual symbolic link, you must use
    either `copy_symlink()` or `copy()` with the `copy_options::copy_symlinks` flag.
    Both the `copy()` and `copy_file()` functions have an overload that takes an argument
    of the `std::filesystem::copy_options` type, which defines how the operation should
    be performed. `copy_options` is a scoped `enum` with the following definition:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这样做，而是复制实际的符号链接，您必须使用 `copy_symlink()` 或带有 `copy_options::copy_symlinks`
    标志的 `copy()`。`copy()` 和 `copy_file()` 函数都有一个重载，它接受 `std::filesystem::copy_options`
    类型的参数，该参数定义了操作应该如何执行。`copy_options` 是一个具有以下定义的局部 `enum`：
- en: '[PRE108]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The following table defines how each of these flags affects a copy operation,
    either with `copy()` or `copy_file()`. The table is taken from the 31.12.8.3 paragraph
    from the N4917 version of the C++ standard:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格定义了这些标志如何影响使用 `copy()` 或 `copy_file()` 进行的复制操作。该表格来自 N4917 版本 C++ 标准的 31.12.8.3
    段落：
- en: '| Option group controlling `copy_file` function effects for existing target
    files |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| 选项组控制现有目标文件对 `copy_file` 函数的影响 |'
- en: '| `none` | (Default) Error; file already exists |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| `none` | (默认) 错误；文件已存在 |'
- en: '| `skip_existing` | Do not overwrite existing file; do not report an error
    |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| `skip_existing` | 不覆盖现有文件；不报告错误 |'
- en: '| `overwrite_existing` | Overwrite the existing file |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| `overwrite_existing` | 覆盖现有文件 |'
- en: '| `update_existing` | Overwrite the existing file if it is older than the replacement
    file |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| `update_existing` | 如果现有文件比替换文件旧，则覆盖现有文件 |'
- en: '| Option group controlling `copy` function effects for subdirectories |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| 选项组控制子目录对 `copy` 函数的影响 |'
- en: '| `none` | (Default) Do not copy subdirectories |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| `none` | (默认) 不复制子目录 |'
- en: '| `recursive` | Recursively copy subdirectories and their contents |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| `recursive` | 递归复制子目录及其内容 |'
- en: '| Option group controlling `copy` function effects for symbolic links |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| 选项组控制符号链接对 `copy` 函数的影响 |'
- en: '| `none` | (Default) Follow symbolic links |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| `none` | (默认) 跟随符号链接 |'
- en: '| `copy_symlinks` | Copy symbolic links as symbolic links rather than copying
    the files that they point to |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| `copy_symlinks` | 将符号链接作为符号链接复制，而不是复制它们指向的文件 |'
- en: '| `skip_symlinks` | Ignore symbolic links |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| `skip_symlinks` | 忽略符号链接 |'
- en: '| Option group controlling `copy` function effects for choosing the form of
    copying |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| 选项组控制复制函数效果以选择复制形式 |'
- en: '| `none` | (Default) Copy contents |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| `none` | (默认) 复制内容 |'
- en: '| `directories_only` | Copy the directory structure only; do not copy non-directory
    files |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| `directories_only` | 仅复制目录结构；不复制非目录文件 |'
- en: '| `create_symlinks` | Make symbolic links instead of copies of files; the source
    path will be an absolute path unless the destination path is in the current directory
    |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| `create_symlinks` | 使用符号链接代替文件的副本；除非目标路径在当前目录中，否则源路径将是一个绝对路径 |'
- en: '| `create_hard_links` | Make hard links instead of copies of files |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| `create_hard_links` | 使用硬链接代替文件的副本 |'
- en: 'Table 7.3: A breakdown of how copy_operation flags affect the copy operation'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.3：copy_operation标志如何影响复制操作
- en: 'Another aspect that should be mentioned is related to symbolic links: `create_directory_symlink()`
    creates a symbolic link to a directory, whereas `create_symlink()` creates symbolic
    links to either files or directories. On POSIX systems, the two are identical
    when it comes to directories. On other systems (such as Windows), symbolic links
    to directories are created differently than symbolic links to files. Therefore,
    it is recommended that you use `create_directory_symlink()` for directories in
    order to write code that works correctly on all systems.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个应该提到的方面与符号链接有关：`create_directory_symlink()`创建指向目录的符号链接，而`create_symlink()`创建指向文件或目录的符号链接。在POSIX系统上，当涉及到目录时，这两个是相同的。在其他系统（如Windows）上，目录的符号链接与文件的符号链接创建方式不同。因此，建议您为目录使用`create_directory_symlink()`，以便编写适用于所有系统的正确代码。
- en: When you perform operations with files and directories, such as the ones described
    in this recipe, and you use the overloads that may throw exceptions, ensure that
    you use `try`-`catch` on the calls. Regardless of the type of overload used, you
    should check the success of the operation and take appropriate action in the case
    of a failure.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 当您对文件和目录执行操作，例如本食谱中描述的操作，并使用可能抛出异常的重载时，请确保您在调用上使用`try`-`catch`。无论使用哪种重载类型，您都应该检查操作的成功，并在失败的情况下采取适当的行动。
- en: If you need to change permissions for a file or directory, you can use the `permissions()`
    function. It has several overloads that allow you to specify a range of permission
    options. These are defined in the `std::filesystem::perms` enumeration. If you
    don’t specify a particular change operation, a complete replacement of existing
    permissions is performed. However, you can specify to add or remove permissions
    using the options available from the `std::filesystem::perm_options` enumeration.
    Apart from `replace`, `add`, and `remove`, there is a fourth option, `nofollow`.
    This applies to symlinks, so that the permissions are changed on the symlink itself
    and not to the file it resolves to.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更改文件或目录的权限，可以使用`permissions()`函数。它有几个重载，允许您指定一系列权限选项。这些在`std::filesystem::perms`枚举中定义。如果您不指定特定的更改操作，则执行现有权限的完全替换。但是，您可以使用从`std::filesystem::perm_options`枚举中可用的选项来指定添加或删除权限。除了`replace`、`add`和`remove`之外，还有一个第四个选项，`nofollow`。这适用于符号链接，因此权限更改是在符号链接本身上进行的，而不是在它解析到的文件上。
- en: See also
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Working with filesystem paths*, to learn about the C++17 standard support
    for filesystem paths'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理文件系统路径*，了解C++17标准对文件系统路径的支持'
- en: '*Removing content from a file*, to explore the possible ways of removing parts
    of the content of a file'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从文件中删除内容*，探索删除文件内容部分的可能方法'
- en: '*Checking the properties of an existing file or directory*, to learn how to
    query the properties of files and directories, such as the type, permissions,
    file times, and more'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查现有文件或目录的属性*，了解如何查询文件和目录的属性，如类型、权限、文件时间等'
- en: Removing content from a file
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件中删除内容
- en: Operations such as copying, renaming, moving, or deleting files are directly
    provided by the `filesystem` library. However, when it comes to removing content
    from a file, you must perform explicit actions.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`filesystem`库直接提供了复制、重命名、移动或删除文件等操作。然而，当涉及到从文件中删除内容时，您必须执行显式操作。'
- en: 'Regardless of whether you need to do this for text or binary files, you could
    implement the following pattern:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您需要为文本文件还是二进制文件执行此操作，您都可以实现以下模式：
- en: Create a temporary file.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个临时文件。
- en: Copy only the content that you want from the original file to the temporary
    file.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅从原始文件复制您想要的内容到临时文件。
- en: Delete the original file.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除原始文件。
- en: Rename/move the temporary file to the name/location of the original file.
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将临时文件重命名/移动到原始文件的名字/位置。
- en: In this recipe, we will learn how to implement this pattern for a text file.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何为文本文件实现此模式。
- en: Getting ready
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For the purpose of this recipe, we will consider removing empty lines, or lines
    that start with a semicolon (`;`), from a text file. For this example, we will
    have an initial file, called `sample.dat`, that contains the names of Shakespeare’s
    plays, but also empty lines and lines that start with a semicolon. The following
    is a partial listing of this file (from the beginning):'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本食谱的目的，我们将考虑从文本文件中删除空行或以分号（`;`）开头的行。对于这个示例，我们将有一个初始文件，称为`sample.dat`，其中包含莎士比亚戏剧的名称，但也包含空行和以分号开头的行。以下是该文件的部分列表（从开头）：
- en: '[PRE109]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The code samples listed in the next section use the following variables:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分列出的代码示例使用以下变量：
- en: '[PRE110]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: We will learn how to put this pattern into code in the following section.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何将此模式放入代码。
- en: How to do it...
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following operations to remove content from a file:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作以从文件中删除内容：
- en: 'Open the file for reading:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件进行读取：
- en: '[PRE111]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Open another temporary file for writing; if the file already exists, truncate
    its content:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开另一个临时文件进行写入；如果文件已存在，则截断其内容：
- en: '[PRE112]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Read, line by line, from the input file and copy the selected content to the
    output file:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐行读取输入文件，并将选定的内容复制到输出文件：
- en: '[PRE113]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Close both the input and output files:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭输入和输出文件：
- en: '[PRE114]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Delete the original file:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除原始文件：
- en: '[PRE115]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Rename/move the temporary file to the name/location of the original file:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将临时文件重命名/移动到原始文件的名字/位置：
- en: '[PRE116]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: How it works...
  id: totrans-506
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The pattern described here is the same for binary files too; however, to keep
    this short, we are only discussing an example with text files. The temporary file
    in this example is in the same directory as the original file. Alternatively,
    this can be located in a separate directory, such as a user temporary directory.
    To get a path to a temporary directory, you can use `std::filesystem::temp_directory_path()`.
    On Windows systems, this function returns the same directory as `GetTempPath()`.
    On POSIX systems, it returns the path specified in one of the environment variables
    `TMPDIR`, `TMP`, `TEMP`, or `TEMPDIR`, or, if none of them are available, it returns
    the path `/tmp`.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的模式也适用于二进制文件；然而，为了保持简洁，我们只讨论了与文本文件相关的示例。在这个示例中，临时文件与原始文件位于同一目录下。或者，它也可以位于一个单独的目录中，例如用户临时目录。要获取临时目录的路径，您可以使用`std::filesystem::temp_directory_path()`。在Windows系统上，此函数返回与`GetTempPath()`相同的目录。在POSIX系统上，它返回在环境变量`TMPDIR`、`TMP`、`TEMP`或`TEMPDIR`中指定的路径，如果没有这些变量，则返回路径`/tmp`。
- en: How content from the original file is copied to the temporary file varies from
    one case to another, depending on what needs to be copied. In the preceding example,
    we have copied entire lines, unless they are empty or start with a semicolon.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 从原始文件复制到临时文件的内容因情况而异，取决于需要复制的内容。在前面的示例中，我们复制了整个行，除非它们是空的或以分号（`;`）开头。
- en: For this purpose, we read the content of the original file, line by line, using
    `std::getline()`, until there are no more lines to read. After all the necessary
    content has been copied, the files should be closed so they can be moved or deleted.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们使用`std::getline()`逐行读取原始文件的内容，直到没有更多的行可以读取。在复制所有必要的内容后，应该关闭文件以便它们可以被移动或删除。
- en: 'To complete the operation, there are three options:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成操作，有三个选项：
- en: Delete the original file and rename the temporary file to the same name as the
    original one if they are in the same directory, or move the temporary file to
    the original file location if they are in different directories. This is the approach
    taken in this recipe. For this, we used the `remove()` function to delete the
    original file and `rename()` to rename the temporary file to the original filename.
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们位于同一目录中，则删除原始文件并将临时文件重命名为与原始文件相同的名称；如果它们位于不同的目录中，则将临时文件移动到原始文件的位置。这是本食谱采用的方法。为此，我们使用了`remove()`函数来删除原始文件，并使用`rename()`将临时文件重命名为原始文件名。
- en: Copy the content of the temporary file to the original file (for this, you can
    use either the `copy()` or `copy_file()` functions) and then delete the temporary
    file (use `remove()` for this).
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将临时文件的内容复制到原始文件（为此，您可以使用`copy()`或`copy_file()`函数）然后删除临时文件（使用`remove()`进行此操作）。
- en: Rename the original file (for instance, changing the extension or the name)
    and then use the original filename to rename/move the temporary file.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名原始文件（例如，更改扩展名或名称），然后使用原始文件名重命名/移动临时文件。
- en: If you take the first approach mentioned here, then you must make sure that
    the temporary file that is later replacing the original file has the same file
    permissions as the original file; otherwise, depending on the context of your
    solution, it can lead to problems.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你采用这里提到的第一种方法，那么你必须确保后来替换原始文件的临时文件具有与原始文件相同的文件权限；否则，根据你解决方案的上下文，可能会导致问题。
- en: See also
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating, copying, and deleting files and directories*, to learn how to perform
    these basic operations with files and directories independently of the filesystem
    in use'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建、复制和删除文件和目录*，以了解如何独立于使用的文件系统执行这些基本操作'
- en: Checking the properties of an existing file or directory
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查现有文件或目录的属性
- en: The `filesystem` library provides functions and types that enable developers
    to check for the existence of a filesystem object, such as a file or directory,
    its properties, such as the type (the file, directory, symbolic link, and more),
    the last write time, permissions, and more. In this recipe, we will look at what
    these types and functions are and how they can be used.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '`filesystem` 库提供了函数和类型，使开发者能够检查文件系统对象的存在，例如文件或目录，其属性，例如类型（文件、目录、符号链接等），最后写入时间、权限等。在本配方中，我们将探讨这些类型和函数是什么以及如何使用它们。'
- en: Getting ready
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For the following code samples, we will use the namespace alias `fs` for the
    `std::filesystem` namespace. The `filesystem` library is available in the header
    with the same name, `<filesystem>`. Also, we will use the variables shown here,
    `path` for the path of a file, and `err` for receiving potential operating system
    error codes from the filesystem APIs:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下代码示例，我们将使用命名空间别名 `fs` 来表示 `std::filesystem` 命名空间。`filesystem` 库在具有相同名称的标题中可用，即
    `<filesystem>`。此外，我们将使用这里显示的变量，`path` 表示文件的路径，`err` 用于从文件系统 API 接收潜在的操作系统错误代码：
- en: '[PRE117]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Also, the function `to_time_t` shown here will be referred to in this recipe:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里显示的函数 `to_time_t` 将在本配方中引用：
- en: '[PRE118]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Before continuing with this recipe, you should read the *Working with filesystem
    paths* recipe.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续此配方之前，你应该阅读 *使用文件系统路径* 配方。
- en: How to do it...
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Use the following library functions to retrieve information about filesystem
    objects:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下库函数来检索关于文件系统对象的信息：
- en: 'To check whether a path refers to an existing filesystem object, use `exists()`:'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查路径是否指向一个现有的文件系统对象，请使用 `exists()`：
- en: '[PRE119]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'To check whether two different paths refer to the same filesystem object, use
    `equivalent()`:'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查两个不同的路径是否指向相同的文件系统对象，请使用 `equivalent()`：
- en: '[PRE120]'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'To retrieve the size of a file in bytes, use `file_size()`. This does not require
    the file to be opened, so it should be preferred over the approach of opening
    the file and then using the `seekg()`/`tellg()` functions:'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检索文件的字节数，请使用 `file_size()`。这不需要打开文件，因此应该优先于打开文件然后使用 `seekg()`/`tellg()` 函数的方法：
- en: '[PRE121]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'To retrieve the count of hard links to a filesystem object, use `hard_link_count()`:'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检索文件系统对象的硬链接数量，请使用 `hard_link_count()`：
- en: '[PRE122]'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'To retrieve or set the last modification time for a filesystem object, use
    `last_write_time()`:'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检索或设置文件系统对象的最后修改时间，请使用 `last_write_time()`：
- en: '[PRE123]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'To retrieve the file attributes, such as the type and permissions (as if returned
    by the POSIX `stat` function), use the `status()` function. This function follows
    symbolic links. To retrieve the file attributes of a symbolic link without following
    it, use `symlink_status()`:'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检索文件属性，例如类型和权限（类似于 POSIX `stat` 函数返回的值），请使用 `status()` 函数。此函数会跟随符号链接。要检索不跟随符号链接的符号链接的文件属性，请使用
    `symlink_status()`：
- en: '[PRE124]'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'To check whether a path refers to a particular type of filesystem object, such
    as a file, directory, symbolic link, and so on, use the functions `is_regular_file()`,
    `is_directory()`, `is_symlink()`, and so on:'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查路径是否指向特定类型的文件系统对象，例如文件、目录、符号链接等，请使用 `is_regular_file()`、`is_directory()`、`is_symlink()`
    等函数：
- en: '[PRE125]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'To check whether a file or directory is empty, use the `is_empty()` function:'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查文件或目录是否为空，请使用 `is_empty()` 函数：
- en: '[PRE126]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: How it works...
  id: totrans-543
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'These functions (used to retrieve information about the filesystem files and
    directories) are, in general, simple and straightforward. However, some considerations
    are necessary:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数（用于检索关于文件系统文件和目录的信息）通常简单直接。然而，需要考虑一些因素：
- en: Checking whether a filesystem object exists can be done using `exists()`, either
    by passing the path or a `std::filesystem::file_status` object that was previously
    retrieved using the `status()` function.
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查文件系统对象是否存在可以使用 `exists()`，通过传递路径或使用 `status()` 函数之前检索的 `std::filesystem::file_status`
    对象。
- en: The `equivalent()` function determines whether two filesystem objects have the
    same status, as retrieved by the function `status()`. If neither path exists,
    or if both exist but neither is a file, directory, or symbolic link, then the
    function returns an error. Hard links to the same file object are equivalent.
    A symbolic link and its target are also equivalent.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equivalent()` 函数确定两个文件系统对象的状态是否相同，状态是通过 `status()` 函数获取的。如果两个路径都不存在，或者两个路径都存在但都不是文件、目录或符号链接，则该函数返回错误。指向同一文件对象的硬链接是等效的。符号链接及其目标也是等效的。'
- en: The `file_size()` function can only be used to determine the size of regular
    files and symbolic links that target a regular file. For any other types of file
    objects, such as directories, this function fails. This function returns the size
    of the file in bytes, or `-1` if an error has occurred. If you want to determine
    whether a file is empty, you can use the `is_empty()` function. This works for
    all types of filesystem objects, including directories.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_size()` 函数只能用来确定指向常规文件的常规文件和符号链接的大小。对于其他类型的文件对象，例如目录，此函数将失败。此函数返回文件的字节数，或者在发生错误时返回
    `-1`。如果你想确定一个文件是否为空，你可以使用 `is_empty()` 函数。这适用于所有类型的文件系统对象，包括目录。'
- en: 'The `last_write_time()` function has two sets of overloads: one that is used
    to retrieve the last modification time of the filesystem object and one that is
    used to set the last modification time. Time is indicated by a `std::filesystem::file_time_type`
    object, which is basically a type alias for `std::chrono::time_point`. The following
    example changes the last write time for a file to 30 minutes earlier than its
    previous value:'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`last_write_time()` 函数有两个重载集：一个用于检索文件系统对象的最后修改时间，另一个用于设置最后修改时间。时间由一个 `std::filesystem::file_time_type`
    对象表示，这基本上是 `std::chrono::time_point` 的类型别名。以下示例将文件的最后写入时间更改为比之前值早 30 分钟：'
- en: '[PRE127]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The `status()` function determines the type and permissions of a filesystem
    object. If the file is a symbolic link, the information returned is about the
    target of the symbolic link. To retrieve information about the symbolic link itself,
    the `symlink_status()` function must be used. These functions return a `std::filesystem::file_status`
    object.
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status()` 函数确定文件系统对象类型和权限。如果文件是符号链接，返回的信息是关于符号链接的目标。要检索关于符号链接本身的信息，必须使用 `symlink_status()`
    函数。这些函数返回一个 `std::filesystem::file_status` 对象。'
- en: 'This class has a `type()` member function to retrieve the file type, and a
    `permissions()` member function to retrieve the file permissions. The type of
    a file is defined with the `std::filesystem::file_type` enumeration. Permissions
    of a file are defined with the `std::filesystem::perms` enumeration. Not all the
    enumerators of this enumeration represent permissions; some of them represent
    controlling bits, such as `add_perms`, to indicate that permissions should be
    added, or `remove_perms`, to indicate that permissions should be removed. The
    `permissions()` function can be used to modify the permissions of a file or a
    directory. The following example adds all permissions to the owner and user group
    of a file:'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此类有一个 `type()` 成员函数用于检索文件类型，以及一个 `permissions()` 成员函数用于检索文件权限。文件类型是通过 `std::filesystem::file_type`
    枚举定义的。文件权限是通过 `std::filesystem::perms` 枚举定义的。此枚举的所有枚举值并不都代表权限；其中一些代表控制位，例如 `add_perms`，表示应该添加权限，或者
    `remove_perms`，表示应该移除权限。`permissions()` 函数可以用来修改文件或目录的权限。以下示例向文件的所有者和用户组添加所有权限：
- en: '[PRE128]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'To determine the type of a filesystem object, such as a file, directory, or
    symbolic link, there are two options available: retrieve the file status and then
    check the `type` property, or use one of the available filesystem functions, such
    as `is_regular_file()`, `is_symlink()`, or `is_directory()`. The following examples
    that check whether a path refers to a regular file are equivalent:'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要确定文件系统对象（如文件、目录或符号链接）的类型，有两种选择：检索文件状态然后检查 `type` 属性，或者使用可用的文件系统函数之一，例如 `is_regular_file()`、`is_symlink()`
    或 `is_directory()`。以下检查路径是否指向常规文件的示例是等效的：
- en: '[PRE129]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'All of the functions discussed in this recipe have an overload that throws
    exceptions if an error occurs, and an overload that does not throw but returns
    an error code via a function parameter. All of the examples in this recipe used
    this approach. More information about these sets of overloads can be found in
    the *Creating, copying, and deleting files and directories* recipe. Although the
    snippets in this recipe don’t show it (for simplicity), it’s important that you
    check the `error_code` value returned by these functions. The actual meaning of
    each value it holds depends on the call that returned it and the value category
    (such as system, I/O streams, or generic) it belongs to. However, the value `0`
    is considered to indicate success in all value categories. Therefore, you can
    check for success as follows:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方中讨论的所有函数都有一个在发生错误时抛出异常的重载版本，以及一个不抛出异常但通过函数参数返回错误代码的重载版本。本配方中的所有示例都使用了这种方法。有关这些重载版本的更多信息，请参阅*创建、复制和删除文件和目录*配方。虽然本配方中的代码片段没有显示（为了简单起见），但检查这些函数返回的`error_code`值非常重要。它所持有的实际意义取决于返回它的调用以及它所属的值类别（例如系统、I/O流或通用）。然而，值`0`在所有值类别中都被认为是表示成功。因此，您可以按以下方式检查成功：
- en: '[PRE130]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'If you use the overloads that don’t return an error code but throw an exception,
    then you need to catch that possible exception. Here is an example:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用不返回错误代码但抛出异常的重载版本，则需要捕获该可能的异常。以下是一个示例：
- en: '[PRE131]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: See also
  id: totrans-559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Working with filesystem paths*, to learn about the C++17-standard support
    for filesystem paths'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用文件系统路径*，了解C++17标准对文件系统路径的支持'
- en: '*Creating, copying, and deleting files and directories*, to learn how to perform
    these basic operations with files and directories independently of the filesystem
    in use'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建、复制和删除文件和目录*，了解如何独立于使用的文件系统执行这些基本操作'
- en: '*Enumerating the content of a directory*, to learn how to iterate through the
    files and subdirectories of a directory'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*列举目录内容*，了解如何遍历目录的文件和子目录'
- en: Enumerating the content of a directory
  id: totrans-563
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列举目录内容
- en: So far in this chapter, we have looked at many of the functionalities provided
    by the `filesystem` library, such as working with paths, performing operations
    with files and directories (creating, moving, renaming, deleting, and so on),
    and querying or modifying properties. Another useful functionality when working
    with the filesystem is to iterate through the content of a directory. The `filesystem`
    library provides two directory iterators, one called `directory_iterator`, which
    iterates the content of a directory, and one called `recursive_directory_iterator`,
    which recursively iterates the content of a directory and its subdirectories.
    In this recipe, we will learn how to use them.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经探讨了`filesystem`库提供的许多功能，例如处理路径、对文件和目录执行操作（创建、移动、重命名、删除等）、查询或修改属性。当与文件系统一起工作时，另一个有用的功能是遍历目录的内容。`filesystem`库提供了两个目录迭代器，一个称为`directory_iterator`，它遍历目录的内容，另一个称为`recursive_directory_iterator`，它递归遍历目录及其子目录的内容。在本配方中，我们将学习如何使用它们。
- en: Getting ready
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will consider a directory with the following structure:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本配方，我们将考虑具有以下结构的目录：
- en: '[PRE132]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'In the following snippets, we will refer to the following function:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们将引用以下函数：
- en: '[PRE133]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: In this recipe, we will work with filesystem paths and check the properties
    of a filesystem object. Therefore, it is recommended that you first read the *Working
    with filesystem paths* and *Checking the properties of an existing file or directory*
    recipes.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将使用文件系统路径并检查文件系统对象属性。因此，建议您首先阅读*使用文件系统路径*和*检查现有文件或目录属性*配方。
- en: How to do it...
  id: totrans-571
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Use the following patterns to enumerate the content of a directory:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下模式来枚举目录的内容：
- en: 'To iterate only the content of a directory without recursively visiting its
    subdirectories, use `directory_iterator`:'
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '要迭代目录的内容而不递归访问其子目录，请使用`directory_iterator`:'
- en: '[PRE134]'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'To iterate all the content of a directory, including its subdirectories, use
    `recursive_directory_iterator` when the order of processing the entries does not
    matter:'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要迭代目录的所有内容，包括其子目录，当处理条目的顺序不重要时，请使用`recursive_directory_iterator`：
- en: '[PRE135]'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'To iterate all the content of a directory, including its subdirectories, in
    a structured manner, such as traversing a tree, use a function similar to the
    one in the first example, which uses `directory_iterator` to iterate the content
    of a directory. However, instead, call it recursively for each subdirectory:'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以结构化的方式遍历目录的所有内容，包括其子目录，例如像遍历树一样，可以使用与第一个示例中类似的功能，该功能使用`directory_iterator`遍历目录的内容。然而，相反，为每个子目录递归地调用它：
- en: '[PRE136]'
  id: totrans-578
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: How it works...
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Both `directory_iterator` and `recursive_directory_iterator` are input iterators
    that iterate over the entries of a directory. The difference is that the first
    one does not visit the subdirectories recursively, while the second one, as its
    name implies, does. They both share a similar behavior:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '`directory_iterator`和`recursive_directory_iterator`都是输入迭代器，它们遍历目录的条目。区别在于第一个不递归访问子目录，而第二个，正如其名称所暗示的，确实会递归访问。它们都有类似的行为：'
- en: The order of iteration is unspecified.
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代顺序是不确定的。
- en: Each directory entry is visited only once.
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个目录条目只访问一次。
- en: The special paths dot (`.`) and dot-dot (`..`) are skipped.
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊路径点（`.`）和点-点（`..`）被跳过。
- en: A default-constructed iterator is the end iterator, and two end iterators are
    always equal.
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认构造的迭代器是结束迭代器，并且两个结束迭代器始终相等。
- en: When iterated past the last directory entries, it becomes equal to the end iterator.
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当迭代到最后的目录条目之后，它将等于结束迭代器。
- en: The standard does not specify what happens if a directory entry is added to,
    or deleted from, the iterated directory after the iterator has been created.
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准没有指定在迭代器创建之后向迭代目录中添加或从迭代目录中删除目录条目会发生什么。
- en: The standard defines the non-member functions `begin()` and `end()` for both
    `directory_iterator` and `recursive_directory_iterator`, which enables us to use
    these iterators in range-based `for` loops, as shown in the examples earlier.
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准为`directory_iterator`和`recursive_directory_iterator`定义了非成员函数`begin()`和`end()`，这使得我们可以在前面的示例中使用的基于范围的`for`循环中使用这些迭代器。
- en: 'Both iterators have overloaded constructors. Some overloads of the `recursive_directory_iterator`
    constructor take an argument of the `std::filesystem::directory_options` type,
    which specifies additional options for the iteration:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 两个迭代器都有重载的构造函数。`recursive_directory_iterator`构造函数的一些重载接受`std::filesystem::directory_options`类型的参数，该参数指定了迭代的附加选项：
- en: '`none`: This is the default, which does not specify anything.'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none`：这是默认值，不指定任何内容。'
- en: '`follow_directory_symlink`: This specifies that the iteration should follow
    symbolic links instead of serving the link itself.'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`follow_directory_symlink`：这指定了迭代应该跟随符号链接而不是提供链接本身。'
- en: '`skip_permission_denied`: This specifies that you should ignore and skip the
    directories that could trigger an access denied error.'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skip_permission_denied`：这指定了应该忽略并跳过可能触发访问拒绝错误的目录。'
- en: The elements that both directory iterators point to are of the `directory_entry`
    type. The `path()` member function returns the path of the filesystem object represented
    by this object. The status of the filesystem object can be retrieved with the
    member functions `status()` and `symlink_status()` for symbolic links.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 两个目录迭代器指向的元素都是`directory_entry`类型。`path()`成员函数返回由该对象表示的文件系统对象的路径。可以通过成员函数`status()`和`symlink_status()`获取文件系统对象的状态，对于符号链接。
- en: 'The preceding examples follow a common pattern:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例遵循一个常见的模式：
- en: Verify that the path to iterate actually exists.
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证要迭代的路径实际上存在。
- en: Use a range-based `for` loop to iterate all the entries of a directory.
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用基于范围的`for`循环来迭代目录的所有条目。
- en: Use one of the two directory iterators available in the `filesystem` library,
    depending on the way the iteration is supposed to be done.
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据迭代的方式，使用`filesystem`库中可用的两个目录迭代器之一。
- en: Process each entry according to the requirements.
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据要求处理每个条目。
- en: In our examples, we simply printed the names of the directory entries to the
    console. It is important to note, as we specified earlier, that the content of
    the directory is iterated in an unspecified order. If you want to process the
    content in a structured manner, such as showing subdirectories and their entries
    indented (for this particular case) or in a tree (in other types of applications),
    then using `recursive_directory_iterator` is not appropriate. Instead, you should
    use `directory_iterator` in a function that is called recursively from the iteration,
    for each subdirectory, as shown in the last example from the previous section.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们只是简单地将目录条目的名称打印到控制台。重要的是要注意，正如我们之前指定的那样，目录的内容是按未指定的顺序迭代的。如果你想要以结构化的方式处理内容，例如显示缩进的子目录及其条目（对于这个特定情况）或树（在其他类型的应用程序中），那么使用`recursive_directory_iterator`是不合适的。相反，你应该在从迭代中递归调用的函数中使用`directory_iterator`，对于每个子目录，就像上一节中的最后一个示例所示。
- en: 'Considering the directory structure presented at the beginning of this recipe
    (relative to the current path), we get the following output when using the recursive
    iterator, as follows:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到本配方开头提供的目录结构（相对于当前路径），当我们使用递归迭代器时，会得到以下输出，如下所示：
- en: '[PRE137]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'On the other hand, when using the recursive function from the third example,
    as shown in the following listing, the output is displayed in order of sublevels,
    as intended:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当使用第三个示例中的递归函数时，如下所示，输出将按子级顺序显示，正如预期的那样：
- en: '[PRE139]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Remember that the `visit_directory_rec()` function is a non-recursive function
    that uses `recursive_directory_iterator`, while the `visit_directory_rec_ordered()`
    function is a recursive function that uses `directory_iterator`. This example
    should help you to understand the difference between the two iterators.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`visit_directory_rec()`函数是一个非递归函数，它使用`recursive_directory_iterator`，而`visit_directory_rec_ordered()`函数是一个递归函数，它使用`directory_iterator`。这个例子应该有助于你理解这两个迭代器之间的区别。
- en: There’s more...
  id: totrans-606
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: In the previous recipe, *Checking the properties of an existing file or directory*,
    we discussed, among other things, the `file_size()` function, which returns the
    size of a file in bytes. However, this function fails if the specified path is
    a directory. To determine the size of a directory, we need to iterate recursively
    through the content of a directory, retrieve the size of the regular files or
    symbolic links, and add them together.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，*检查现有文件或目录的属性*，我们讨论了诸如`file_size()`函数等内容，该函数返回文件的字节数。然而，如果指定的路径是目录，则此函数会失败。为了确定目录的大小，我们需要递归地遍历目录的内容，检索常规文件或符号链接的大小，并将它们相加。
- en: 'Consider the following function to exemplify this case:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下函数来举例说明这种情况：
- en: '[PRE141]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: The preceding `dir_size()` function returns the size of all the files in a directory
    (recursively), or `-1`, as a `uintmax_t`, in the case of an error (the path does
    not exist or does not represent a directory).
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的`dir_size()`函数返回目录中所有文件的大小（递归），或者在出现错误（路径不存在或不代表目录）的情况下，以`uintmax_t`返回`-1`。
- en: See also
  id: totrans-611
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Checking the properties of an existing file or directory*, to learn how to
    query the properties of files and directories, such as the type, permissions,
    file times, and more'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查现有文件或目录的属性*，了解如何查询文件和目录的属性，例如类型、权限、文件时间等'
- en: '*Finding a file*, to learn how to search for files based on their name, extension,
    or other properties'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*查找文件*，了解如何根据文件名、扩展名或其他属性搜索文件'
- en: Finding a file
  id: totrans-614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找文件
- en: In the previous recipe, we learned how to use `directory_iterator` and `recursive_directory_iterator`
    to enumerate the content of a directory. Displaying the content of a directory,
    as we did in the previous recipe, is only one of the scenarios in which this is
    needed. The other major scenario is when searching for particular entries in a
    directory, such as files with a particular name, extension, and so on. In this
    recipe, we will demonstrate how we can use the directory iterators and the iterating
    patterns shown earlier to find files that match a given criterion.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们学习了如何使用`directory_iterator`和`recursive_directory_iterator`来枚举目录的内容。显示目录内容，就像我们在之前的配方中所做的那样，这只是需要这样做的一种场景。另一个主要场景是在目录中搜索特定条目，例如具有特定名称、扩展名等的文件。在这个配方中，我们将演示如何使用目录迭代器和之前展示的迭代模式来查找符合给定标准的文件。
- en: Getting ready
  id: totrans-616
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should read the previous recipe, *Enumerating the content of a directory*,
    for details about directory iterators. In this recipe, we will also use the same
    test directory structure that was presented in the previous recipe.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该阅读之前的配方，*列出目录内容*，以了解有关目录迭代器的详细信息。在本配方中，我们也将使用之前配方中展示的相同的测试目录结构。
- en: How to do it...
  id: totrans-618
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To find files that match particular criteria, use the following pattern:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找符合特定标准的文件，请使用以下模式：
- en: Use `recursive_directory_iterator` to iterate through all the entries of a directory
    and recursively through its subdirectories.
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`recursive_directory_iterator`遍历目录的所有条目及其子目录。
- en: Consider regular files (and any other types of files you may need to process).
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑常规文件（以及您可能需要处理的任何其他类型的文件）。
- en: Use a function object (such as a lambda expression) to filter only the files
    that match your criteria.
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用函数对象（例如lambda表达式）来过滤仅匹配您条件的文件。
- en: Add the selected entries to a container (such as a vector).
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将选定的条目添加到容器中（例如向量）。
- en: 'This pattern is exemplified in the `find_files()` function shown here:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式在下面的`find_files()`函数中得到了体现：
- en: '[PRE142]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: How it works...
  id: totrans-626
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When we want to find files in a directory, the structure of the directory and
    the order in which its entries, including subdirectories, are visited are probably
    not important. Therefore, we can use the `recursive_directory_iterator` to iterate
    through the entries.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在目录中查找文件时，目录的结构以及其条目（包括子目录）的访问顺序可能并不重要。因此，我们可以使用`recursive_directory_iterator`遍历条目。
- en: 'The `find_files()` function takes two arguments: a path and a function wrapper
    that is used to select the entries that should be returned. The return type is
    a vector of `filesystem::path`, though. Alternatively, it could also be a vector
    of `filesystem::directory_entry`. The recursive directory iterator used in this
    example does not follow symbolic links, returning the link itself and not the
    target. This behavior can be changed by using a constructor overload that has
    an argument of the type `filesystem::directory_options` and passing `follow_directory_symlink`.'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_files()`函数接受两个参数：一个路径和一个用于选择应返回的条目的函数包装器。返回类型是`filesystem::path`的向量，但也可以是`filesystem::directory_entry`的向量。在此示例中使用的递归目录迭代器不跟随符号链接，返回链接本身而不是目标。这种行为可以通过使用具有`filesystem::directory_options`类型参数的构造函数重载并传递`follow_directory_symlink`来改变。'
- en: In the preceding example, we only consider the regular files and ignore the
    other types of filesystem objects. The predicate is applied to the directory entry
    and, if it returns `true`, the entry is added to the result.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们只考虑常规文件并忽略其他类型的文件系统对象。谓词应用于目录条目，如果它返回`true`，则条目被添加到结果中。
- en: 'The following example uses the `find_files()` function to find all of the files
    in the test directory that start with the prefix `file_`:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用`find_files()`函数查找测试目录中以`file_`为前缀的所有文件：
- en: '[PRE143]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The output of executing this program, with paths relative to the current path,
    is as follows:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此程序后的输出，相对于当前路径，如下所示：
- en: '[PRE144]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'A second example shows how to find files that have a particular extension,
    in this case, the extension `.dat`:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例展示了如何查找具有特定扩展名的文件，在这种情况下，扩展名为`.dat`：
- en: '[PRE145]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The output, again relative to the current path, is shown here:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 输出，同样相对于当前路径，如下所示：
- en: '[PRE146]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: These two examples are very similar. The only thing that is different is the
    code in the lambda function, which checks the path received as an argument.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例非常相似。唯一不同的是lambda函数中的代码，它检查作为参数接收的路径。
- en: See also
  id: totrans-639
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: '*Checking the properties of an existing file or directory*, to learn how to
    query the properties of files and directories, such as the type, permissions,
    file times, and more'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查现有文件或目录的属性*，了解如何查询文件和目录的属性，例如类型、权限、文件时间等'
- en: '*Enumerating the content of a directory*, to learn how to iterate through the
    files and subdirectories of a directory'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*列出目录内容*，了解如何遍历目录的文件和子目录'
- en: Learn more on Discord
  id: totrans-642
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多信息
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_07.xhtml)'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/7xRaTCeEhx](Chapter_07.xhtml)'
- en: '![](img/QR_Code2659294082093549796.png)'
  id: totrans-645
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code2659294082093549796.png)'
