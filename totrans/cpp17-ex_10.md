# Advanced Domain-Specific Language

In the previous chapter, we developed a **domain-specific language** (**DSL**). In this chapter, we will improve the language in several ways:

*   We will add **selection** and **iteration**. More specifically, we will add the `if` and `while` instructions. In the language of the previous chapter, the actions were executed in a straightforward manner. In this chapter, it is possible to select between alternatives and to iterate over a part of the code.
*   We will add **variables**. In the previous chapter, we could assign values to a name once. In this chapter, however, values are assigned to names that can be reassigned during the execution of the program.
*   We add **functions**, with parameters and return values. In the previous chapter, a program was made up of a sequence of instructions. In this chapter, it is a sequence of functions. Similar to C++, there must be a `main` function where the execution starts.
*   Finally, we will add another module in the process from the source code to the viewer. In the previous chapter, the parser generated a sequence of actions that were displayed by the viewer. In this chapter, the parser generates a sequence of **directives**, which in turn are evaluated to actions by the **evaluator**.
*   Since the language of this chapter supports selection, iteration, variables, and functions calls, it starts to look like a traditional programming language.

Topics we will cover in this chapter include:

*   Just as in the previous chapter, we will informally look into the source code of our DSL by looking at an example. However, in this example we will use variables and function calls, we will also use the `if` and `while` instructions.
*   We will then formally define our language with **grammar**. The grammar is an extension of the grammar of the last chapter. We will add instructions for functions definitions, calls, and returns, as well as selection (`if`) and iteration (`while`).
*   When we have defined the grammar, we will write the **scanner**. The scanner of this chapter is almost identical to the scanner of the previous chapter. The only difference is that we will add a few keywords.
*   When we have written the scanner, we will write the **parser**. The parser is an extension of the parser of the previous chapter, we add methods for functions, selection, and iteration. However, the parser of the previous chapter generated a sequence of **actions**, which were read and executed by the **viewer**. In this chapter, however, the parser instead generates a sequence of directives that are read by the evaluator.
*   In this chapter, the next step is the evaluator rather than the viewer. The evaluator takes the directive sequence generated by the parser, and generates a sequence of actions which are read and executed by the viewer. The evaluator works with maps that assign values to names. There is a **stack of value maps** that make sure that each called function gets its own fresh value map. There is also a **value stack** that stores temporary values when evaluating expressions. Finally, there is the **call stack**, holding return addresses for function calls.
*   Finally, the viewer works in the same way as in the previous chapter. It iterates through the action list generated by the evaluator and displays the graphical objects in a Qt widget.

# Improving the source language – an example

Let's look at a new example, where we define and call a function named `triangle` that draws a triangle with different pens in different sizes. Note that the functions do not have to occur in any particular order.

We start by setting the `left` and `length` variables to `50`. They hold the *x* coordinate of the left-most corner of the first triangle, and its base length. We also set the `index` variable to zero; its value will be used in the `while` iteration:

```cpp
function main() { 
  left = 50; 
  length = 50; 
  index = 0; 
```

We continue to iterate as long as `index` is less than four. Note that in this chapter we add Boolean values to the `Value` class. When `index` holds an even value, we set the pen style to a solid line, and when it holds an odd value, we set the pen style to a dashed line. Note that we have extended the language with relational expressions and the modulus (`%`) operator:

```cpp
  while (index < 4) { 
    if ((index % 2) == 0) { 
      SetPenStyle(SolidLine); 
    } 
    else { 
      SetPenStyle(DashLine); 
    } 
```

We set the top-left point of the triangle, and call the `drawTriangle` function to perform the actual drawing of the triangle:

```cpp
            topLeft = point(left, 25); 
            call drawTriangle(topLeft, length); 
```

After the call to `triangle`, we increase the base length of the next triangle, and the left-most corner:

```cpp
    length = length + 25; 
    left = left + length; 
    index = index + 1; 
  } 
} 
```

In the `drawTriangle` function, we call `getTopRight` and `getBottomMiddle` functions to obtain the top-right and bottom-middle points of the triangle. Finally, we draw the three lines of the triangle by calling `drawLine`:

```cpp
function drawTriangle(topLeft, length) { 
  topRight = call getTopRight(topLeft, length); 
  bottomMiddle = call getBottomMiddle(topLeft, length); 
  drawLine(topLeft, topRight); 
  drawLine(topRight, bottomMiddle); 
  drawLine(bottomMiddle, topLeft); 
} 
```

The `getTopRight` function extracts the *x* and *y* coordinate of the top-left point, and returns a point where the *x* coordinate has been increased by the length of the base of the triangle:

```cpp
function getTopRight(topLeft, length) { 
  return point(xCoordinate(topLeft) + length, 
               yCoordinate(topLeft)); 
} 
```

The `getBottomMiddle` function also extracts the *x* and *y* coordinates of the top-left point. Then it calculates the *x* and *y* coordinates of the middle-bottom point and returns `point`:

```cpp
function getBottomMiddle(topLeft, length) { 
  left = xCoordinate(topLeft); 
  top = yCoordinate(topLeft); 
  middle = left + length / 2; 
  bottom = top + length; 
  return point(middle, bottom); 
} 
```

The output of the execution of the code is shown in the following screenshot:

![](img/2f238186-dcca-40cf-8b90-2a24bbf9da4d.png)

# Improving the grammar

In this chapter, we will improve the grammar of our language. To begin with, a program is made up by a sequence of functions rather than instructions. Technically, a program can hold zero functions. However, a semantic error will report that the `main` function is missing:

```cpp
program -> functionDefinitionList 
functionDefinitionList -> functionDefinition*
```

The definition of a function is made up by the keyword `function`, a list of names enclosed by parentheses and a list of instructions enclosed by brackets. The `nameList` is made up of zero or more names, separated by commas:

```cpp
functionDefinition -> function name(nameList) { instructionList } 
```

When it comes to instructions, we add the calling of a function. We can either call the function directly, as an instruction (`call``drawTriangle` in the preceding example), or as a part of an expression (`callgetTopRight` and `call``getBottomMiddle`).

We also add the `while` instruction and the `if` instructions, with or without the `else` part. Finally, there is also the block instruction: a list of instructions enclosed by brackets:

```cpp
instruction -> callExpression ; 
             | while (expression) instruction 
             | if (expression) instruction 
             | if (expression) instruction else instruction 
             | { instructionList } 
             | ... 

callInstruction -> callExpression ; 
```

When it comes to expressions, the only difference is that we have added function calls. The `expressionList` is a list of zero or more expressions, separated by commas:

```cpp
primaryExpression -> call name(expressionList) 
                   |
```

# The Token and the Scanner

Similar to the previous chapter, the final target code of the language is the actions, even though they are generated by an evaluator rather than the parser. The `Action` class is identical to the class of the previous chapter. So are the `Value` and `ViewerWidget` classes, as well as the colors and error handling. However, the `Token` and `Scanner` classes have been extended. The `TokenId` enumeration has been extended with more token identities.

**Token.h:**

```cpp
class Token { 
  // ... 
  enum TokenId {BlockId, CallId, ElseId, FunctionId, GotoId, 
                IfId, IfNotGotoId, ReturnId, WhileId, // ... 
               }; 
  // ... 
}; 
```

In the same way, `init` in `Scanner` has been extended with the keywords.

**Scanner.cpp:**

```cpp
void Scanner::init() { 
  ADD_TO_KEYWORD_MAP(CallId) 
  ADD_TO_KEYWORD_MAP(ElseId) 
  ADD_TO_KEYWORD_MAP(FunctionId) 
  ADD_TO_KEYWORD_MAP(IfId) 
  ADD_TO_KEYWORD_MAP(ReturnId) 
  ADD_TO_KEYWORD_MAP(WhileId) 
// ... 
} 
```

# The parser

The parser has been extended with methods corresponding to the new rules of the grammar. Moreover, the parser of this chapter does not generate actions; instead, it generates **directives**. The reason for this is that, while the source code of the previous chapter holds instructions that were executed from the beginning to the end, the source code of this chapter holds selection, iteration, and function calls that can alter the flow of the instructions. Therefore, it makes sense to introduce a middle layer—the parser generates directives that are evaluated to become actions.

Since the language of this chapter supports functions, we need the `Function` class to store the functions. It stores the names of the formal parameters and the start address of the function.

**Function.h:**

```cpp
#ifndef FUNCTION_H 
#define FUNCTION_H 

#include <QtWidgets> 

#include "Value.h" 
#include "Action.h" 

class Function { 
  public: 
    Function() {} 
    Function(const QList<QString>& nameList, int address); 
    const QList<QString>& nameList() const {return m_nameList;} 
    int address() {return m_address;} 

    Function(const Function& function); 
    Function operator=(const Function& function); 

  private: 
    QList<QString> m_nameList; 
    int m_address; 
}; 

#endif // FUNCTION_H 
```

The `Function.cpp` file holds the definitions of the methods of the `Function` class.

**Function.cpp:**

```cpp
#include "Function.h" 

Function::Function(const QList<QString>& nameList, int address) 
 :m_nameList(nameList), 
  m_address(address) { 
  // Empty. 
} 

Function::Function(const Function& function) 
 :m_nameList(function.m_nameList), 
  m_address(function.m_address) { 
  // Empty. 
} 

Function Function::operator=(const Function& function) { 
  m_nameList = function.m_nameList; 
  m_address = function.m_address; 
  return *this; 
} 
```

Since the parser in this chapter generates a sequence of directives rather than actions, we also need the `Directive` class to hold the directives. In most cases, a `Directive` object only holds its identity of the `TokenId` enumeration. However, in the case of a function call, we need to store the name of the function and the number of actual parameters. In the case of a function definition, we store a reference to the `Function` object. In the case of an expression made up by a name of a value, we need to store the name or value. Finally, there are several kinds of jump directives, in which case we need to store the address.

**Directive.h:**

```cpp
#ifndef DIRECTIVE_H 
#define DIRECTIVE_H 

#include <QtWidgets> 

#include "Token.h" 
#include "Value.h" 
#include "Function.h" 

class Directive { 
  public: 
    Directive(TokenId tokenId); 
    Directive(TokenId tokenId, int address); 
    Directive(TokenId tokenId, const QString& name); 
    Directive(TokenId tokenId, const QString& name, 
              int parameters); 
    Directive(TokenId tokenId, const Value& value); 
    Directive(TokenId tokenId, const Function& function); 

    Directive(const Directive& directive); 
    Directive operator=(const Directive& directive); 

    TokenId directiveId() {return m_directiveId;} 
    const QString& name() {return m_name;} 
    const Value& value() {return m_value;} 
    const Function& function() {return m_function;} 

    int parameters() const {return m_parameters;} 
    int address() const {return m_address;} 
    void setAddress(int address) {m_address = address;} 

  private:          
    TokenId m_directiveId; 
    QString m_name; 
    int m_parameters, m_address; 
    Value m_value; 
    Function m_function; 
}; 

#endif // DIRECTIVE_H 
```

The `Directive.cpp` file holds the definitions of the methods of the `Directive` class.

**Directive.cpp:**

```cpp
#include "Directive.h"
```

In most cases, we only create an object of the `Directive` class with a directive identity:

```cpp
Directive::Directive(TokenId directiveId) 
 :m_directiveId(directiveId) { 
  // Empty. 
} 
```

The jump directives need the jump address:

```cpp
Directive::Directive(TokenId directiveId, int address) 
 :m_directiveId(directiveId), 
  m_address(address) { 
  // Empty. 
} 
```

When assigning a value to a variable, we need the name of the variable. However, we do not need the value since it will be stored on a stack. Also, when an expression is made up of a name, we need to store the name:

```cpp
Directive::Directive(TokenId directiveId, const QString& name) 
 :m_directiveId(directiveId), 
  m_name(name) { 
  // Empty. 
} 
```

The directive for function calls needs the name of the function and the number of actual parameters:

```cpp
Directive::Directive(TokenId directiveId, const QString& name, 
                     int parameters) 
 :m_directiveId(directiveId), 
  m_name(name), 
  m_parameters(parameters) { 
  // Empty. 
} 
```

When an expression is made up simply of a value, we just store the value in the directive:

```cpp
Directive::Directive(TokenId directiveId, const Value& value) 
 :m_directiveId(directiveId), 
  m_value(value) { 
  // Empty. 
} 
```

Finally, in a function definition we store an object of the `Function` class:

```cpp
Directive::Directive(TokenId directiveId, 
                     const Function& function) 
 :m_directiveId(directiveId), 
  m_function(function) { 
  // Empty. 
} 
```

The `Parser` class has been extended with the methods for the new rules in the grammar: function definitions and the `if`, `while`, `call`, and `return` instructions.

**Parser.h:**

```cpp
// ... 

class Parser { 
  private: 
    void functionDefinitionList(); 
    void functionDefinition(); 

```

The `nameList` method gathers the formal parameters of the function, while `expressionList` gathers the actual parameters of the function call:

```cpp
            QList<QString> nameList(); 
            int expressionList(); 
```

The `callExpression` method has also been added to the `Parser` class, since a function can be explicitly called as an **instruction**, or as a part of an expression:

```cpp
    void callExpression(); 
    // ... 
}; 
```

The `Parser.cpp` file holds the definitions of the methods of the `Parser` class.

The start method of the parser of this chapter is `functionDefinitionList`. It calls `functionDefinition` as long as it does not reach end-of-file.

**Parser.cpp:**

```cpp
void Parser::functionDefinitionList() { 
  while (m_lookAHead.id() != EndOfFileId) { 
    functionDefinition(); 
  } 
} 
```

The `functionDefinition` method parses a function definition. We start by matching the `function` keyword and store the name of the function:

```cpp
void Parser::functionDefinition() { 
  match(FunctionId); 
  QString name = m_lookAHead.name(); 
  match(NameId); 
```

The function name is followed by the parameter name list enclosed by parenthesis. We store the name list in the `nList` field. We cannot call the field `nameList`, since that name has already been taken by the method:

```cpp
  match(LeftParenthesisId); 
  QList<QString> nList = nameList(); 
  match(RightParenthesisId); 
```

We store the current size of the directive list size as the start address of the function, create a `Function` object with the name list and start address, and add a `Directive` object with the function to the directive list:

```cpp
   int startAddress = (int) m_directiveList.size(); 
   Function function(nList, startAddress); 
   m_directiveList.push_back(Directive(FunctionId, function)); 
```

The name list is followed by a list of instructions enclosed by brackets:

```cpp
  match(LeftBracketId); 
  instructionList(); 
  match(RightBracketId); 
```

Just to be sure the function really returns the controls back to the calling function, we add a `Directive` object with the `return` token identity:

```cpp
  m_directiveList.push_back(Directive(ReturnId)); 
```

When the function has been defined, we check that there is no other function with the same name:

```cpp
  check(!m_functionMap.contains(name), 
        "function "" + name + "" already defined"); 
```

If the function is named `"main"`, it is the start function of the program and it cannot have parameters:

```cpp
  check(!((name == "main") && (nList.size() > 0)), 
        "function "main" cannot have parameters"); 
```

Finally, we add the function to the `functionMap`:

```cpp
  m_functionMap[name] = function; 
}
```

The `nameList` method parses a comma-separated list of names enclosed in parentheses:

```cpp
QList<QString> Parser::nameList() { 
  QList <QString> nameList; 
```

We continue as long as we do not encounter a right parenthesis:

```cpp
  while (m_lookAHead.id() != RightParenthesisId) { 
    QString name = m_lookAHead.name(); 
    nameList.push_back(name); 
    match(NameId); 
```

After we have matched the name, we check whether the next token is a right parenthesis. If it is, we have reached the end of the name list and break the iteration:

```cpp
    if (m_lookAHead.id() == RightParenthesisId) { 
      break; 
    } 
```

If the next token is not a right parenthesis, we instead assume that it is a comma, match it, and continue to iterate with the next expression:

```cpp
    match(CommaId); 
  } 
```

Finally, before we return the name list, we need to check that no name occurs twice in the name list. We iterate through the name list and add the names to a set:

```cpp
  QSet<QString> nameSet; 
  for (const QString& name : nameList) { 
    if (nameSet.contains(name)) { 
      semanticError("parameter "" + name + "" defined twice"); 
    } 

    nameSet.insert(name); 
  } 

  return nameList; 
} 

```

The `instructionList` method looks a little bit different in this chapter since it is placed inside a block of instructions. We iterate as long as we do not encounter a right bracket:

```cpp
void Parser::instructionList() { 
  while (m_lookAHead.id() != RightBracketId) { 
    instruction(); 
  } 
}
```

As a function can be explicitly called as an instruction, or as part of an expression, we simply call `callExpression` and match the semicolon in the case of a call instruction:

```cpp
void Parser::instruction() { 
  switch (m_lookAHead.id()) { 
    case CallId: 
      callExpression(); 
      match(SemicolonId); 
      break; 
```

In the return instruction, we match the `return` keyword and check whether it is followed by a semicolon. If it is not followed by a semicolon, we parse an expression and then assume that the next token is a semicolon. Note that we do not store the result of the expression. The evaluator will place its value on a stack later in the process:

```cpp
    case ReturnId: 
      match(ReturnId); 

      if (m_lookAHead.id() != SemicolonId) { 
        expression(); 
      } 

      m_directiveList.push_back(Directive(ReturnId)); 
      match(SemicolonId); 
      break; 
```

In the case of the `if` keyword, we match it and parse an expression enclosed by parentheses:

```cpp
    case IfId: { 
        match(IfId); 
        match(LeftParenthesisId); 
        expression(); 
        match(RightParenthesisId); 
```

If the expression becomes evaluated to a false value, we shall jump over the instruction following the `if` expression. Therefore, we add a `IfNotGoto` directive, intending to jump over the instruction following the `if` keyword:

```cpp
        int ifNotIndex = (int) m_directiveList.size(); 
        m_directiveList.push_back(Directive(IfNotGotoId, 0)); 
        instruction();
```

If the instruction is followed by the `else` keyword, we match it and add a `Goto` directive, that is intended to jump over the `else` part in the case of a true value of the expression of the `if` instruction:

```cpp
        if (m_lookAHead.id() == ElseId) { 
          match(ElseId); 
          int elseIndex = (int) m_directiveList.size(); 
          m_directiveList.push_back(Directive(GotoId, 0)); 
```

We then set the jump address of the preceding `IfNotTrue` directive. If the expression is not true, the program shall jump to this point:

```cpp
          m_directiveList[ifNotIndex]. 
            setAddress((int) m_directiveList.size()); 
          instruction(); 
```

On the other hand, if the expression of the `if` instruction is true, the program shall jump over the `else` part to this point:

```cpp
          m_directiveList[elseIndex]. 
            setAddress((int) m_directiveList.size()); 
        } 
```

If the `if` instruction is not followed by the `else` keyword, it shall jump to this point in the program if the expression is not true:

```cpp
        else { 
          m_directiveList[ifNotIndex]. 
            setAddress((int) m_directiveList.size()); 
        } 
      } 
      break; 
```

In the case of the `while` keyword, we match it and store the current index of the directive list in order for the program to jump back to this point after every iteration:

```cpp
    case WhileId: { 
        match(WhileId); 
        int whileIndex = (int) m_directiveList.size(); 
```

We then parse the expression and its enclosing parentheses:

```cpp
        match(LeftParenthesisId); 
        expression(); 
        match(RightParenthesisId);
```

In the case that the expression is not true, we add an `IfNotGoto` directive in order for the program to jump out of the iteration:

```cpp
        int ifNotIndex = (int) m_directiveList.size(); 
        m_directiveList.push_back(Directive(IfNotGotoId, 0)); 
        instruction(); 
```

We add a `Goto` directive after the instruction following the `while` expression, so that the program can jump back to the expression at the end of each iteration:

```cpp
        m_directiveList.push_back(Directive(GotoId, whileIndex)); 
```

Finally, we set the address of the `IfNotTrue` directive at the beginning of the `while` instruction, so that it can jump to this point in the program if the expression is not true:

```cpp
        m_directiveList[ifNotIndex]. 
          setAddress((int) m_directiveList.size()); 
      } 
      break; 
```

In the case of a left bracket, we have a sequence of instructions enclosed by brackets. We parse the pair of brackets and call `instructionList`:

```cpp
    case LeftBracketId: 
      match(LeftBracketId); 
      instructionList(); 
      match(RightBracketId); 
      break; 
```

Finally, in the case of a name, we have an assignment. We match the `name` keyword, and the assignment operator (`=`), parse the expression, and match the semicolon. We then add an `Assign` object to the directive list holding the name to be assigned a value. Note that we do not store the value of the expression, since it will be pushed on a value stack by the evaluator:

```cpp
    case NameId: { 
        QString name = m_lookAHead.name(); 
        match(NameId); 
        match(AssignId); 
        expression(); 
        match(SemicolonId); 
        m_directiveList.push_back(Directive(AssignId, name)); 
      } 
      break; 

      // ... 
  } 
} 
```

The `callExpression` method matches the `call` keyword, stores the name of the function, parses the parameter expressions, and adds a `Directive` object holding the call to the directive list. Note that we do not check whether the function exists or count the number of parameters at this point, since the function may be not yet defined. All type checking is taken care of by the evaluator later in the process:

```cpp
void Parser::callExpression() { 
  match(CallId); 
  QString name = m_lookAHead.name(); 
  match(NameId); 
  match(LeftParenthesisId); 
  int size = expressionList(); 
  match(RightParenthesisId); 
  m_directiveList.push_back(Directive(CallId, name, size)); 
} 
```

The `expressionList` method parses a list of expressions. Unlike the preceding name list case, we do not return the list itself, only its size. The expressions generate directives of their own, their values are stored on a stack by the evaluator later in the process:

```cpp
int Parser::expressionList() { 
  int size = 0; 
```

We iterate as long as we do not encounter a right parenthesis:

```cpp
  while (m_lookAHead.id() != RightParenthesisId) { 
    expression(); 
    ++size; 
```

After parsing the expression, we check whether the next token is a right parenthesis. If it is, the expression list is finished and we break the iteration:

```cpp
    if (m_lookAHead.id() == RightParenthesisId) { 
      break; 
    } 
```

If the next token is not a right parenthesis, we assume it is a comma, match it, and continue the iteration:

```cpp
    match(CommaId); 
  }
```

Finally, after the iteration, we return the number of expressions:

```cpp
  return size; 
} 
```

# The evaluator

The **evaluator** evaluates a sequence of directives and generates a list of actions that are later read and executed by the viewer. The evaluation starts with the directive on the first line, which is a jump to the start address of the `main` function. The evaluation stops when it encounters a `return` directive without a return address. In that case, we have reached the end of `main` and the execution shall be finished.

The evaluator works against a stack of values. Each time a value has been evaluated it is pushed on the stack, and each time values are needed to evaluate an expression they are popped from the stack.

**Evaluator.h:**

```cpp
#ifndef EVALUATOR_H 
#define EVALUATOR_H 

#include <QtWidgets> 

#include "Error.h" 
#include "Directive.h" 
#include "Action.h" 
#include "Function.h" 
```

The constructor of the `Evaluator` class evaluates the directive list with the help of the functions map:

```cpp
class Evaluator { 
  public: 
    Evaluator(const QList<Directive>& directiveList, 
              QList<Action>& actionList, 
              QMap<QString,Function> functionMap);
```

The `checkType` and `evaluate` methods are identical to the previous chapter. They have been moved from `Parser` to `Evaluator`. The `checkType` methods check that the expressions associated with the token have the correct types, and the `evaluate` methods evaluates the expressions:

```cpp
  private: 
    void checkType(TokenId tokenId, const Value& value); 
    void checkType(TokenId tokenId, const Value& leftValue, 
                   const Value& rightValue); 

    Value evaluate(TokenId tokenId, const Value& value); 
    Value evaluate(TokenId tokenId, const Value& leftValue, 
                   const Value& rightValue); 
```

When an expression is being evaluated, its value is pushed on `m_valueStack`. When a variable is assigned a value, its name and the value are stored in `m_valueMap`. Note that, in this chapter, a value can be assigned to a variable more than once. When a function calls another function, the value map of the calling function is pushed on `m_valueMapStack` in order to give the called function a fresh value map, and the return address is pushed on `m_returnAddressStack`:

```cpp
    QStack<Value> m_valueStack; 
    QMap<QString,Value> m_valueMap; 
    QStack<QMap<QString,Value>> m_valueMapStack; 
    QStack<int> m_returnAddressStack; 
}; 

#endif // EVALUATOR_H 
```

The `Evaluator.cpp` file holds the definitions of the methods of the `Evaluator` class:

**Evaluator.cpp:**

```cpp
#include <CAssert> 
using namespace std; 

#include "Error.h" 
#include "Evaluator.h" 
```

The constructor of the `Evaluator` class can be regarded as the heart of the evaluator.

The `directiveIndex` field in the constructor is the index of the current `Directive` object in the directive list. Normally, it is increased for each iteration. However, it can be assigned different values due to `if` or `while` instructions as well as function calls and returns:

```cpp
Evaluator::Evaluator(const QList<Directive>& directiveList, 
                     QList<Action>& actionList, 
                     QMap<QString,Function> functionMap) { 
  int directiveIndex = 0; 

  while (true) { 
    Directive directive = directiveList[directiveIndex]; 
    TokenId directiveId = directive.directiveId(); 
```

When a function is called, we start by looking up the function name in the function map and report a semantic error if we do not find it. Then we check that the number of actual parameters equals the number of formal parameters (the size of the name list in the `Function` object):

```cpp
    switch (directiveId) { 
      case CallId: { 
          QString name = directive.name(); 
          check(functionMap.contains(name), 
                "missing function: "" + name + """); 
          Function function = functionMap[name]; 
          check(directive.parameters() == 
                function.nameList().size(), 
                "invalid number of parameters"); 
```

When we call the function, we push the index of the next directive on the return address stack, so that the called function can return to the correct address. We push the value map of the calling function at the value map stack, so we can retrieve it after the call. We then clear the value map so that it is fresh to be used by the called function. Finally, we set the directive index to the start address of the called function, which moves the control to the beginning of the called function. Note that we do nothing about the actual parameter expressions. They have already been evaluated, and their values are pushed at the value stack:

```cpp
          m_returnAddressStack.push(directiveIndex + 1); 
          m_valueMapStack.push(m_valueMap); 
          m_valueMap.clear(); 
          directiveIndex = function.address(); 
        } 
        break;
```

At the beginning of a function, we pop the value stack for each parameter and associate each parameter name with its value in the value map. Remember that the parameter expressions were evaluated before the call to the function, and that their values were pushed on the value stack. Also remember that the first parameter was pushed first and is placed below the other parameters in the stack, which is why we assign the parameters in reverse order. Finally, remember that the value map of the calling function was pushed on the value map stack, and that the value stack was cleared during the function call, so that the current value map is empty at the beginning of the function:

```cpp
      case FunctionId: { 
          const Function& function = directive.function(); 
          const QList<QString>& nameList = function.nameList(); 

          for (int listIndex = ((int) nameList.size() - 1); 
               listIndex >= 0; --listIndex) { 
            const QString& name = nameList[listIndex]; 
            m_valueMap[name] = m_valueStack.pop(); 
          } 
        } 
        ++directiveIndex; 
        break; 
```

When returning from a function, we first check whether the return address stack is empty. If it is not empty, we perform a normal function return. We restore the value map of the calling function by popping the value map stack. We also set the directive index to the address following the function call by popping the return address stack:

```cpp
      case ReturnId: 
        if (!m_returnAddressStack.empty()) { 
          m_valueMap = m_valueMapStack.pop(); 
          directiveIndex = m_returnAddressStack.pop(); 
        } 
```

If the return address stack is empty, however, we have a special case—we have reached the end of the `main` function. In that case, we shall not return to a calling function (there is no calling function). Instead, we shall just finish the execution of the evaluator by calling return. Remember that we are in the constructor of the `Evaluator` class, and that we return from the constructor:

```cpp
        else { 
          return; 
        } 
        break;
```

The `IfNotGoto` directive has been added by the parser when parsing the `if` or `while` instructions. We pop the value stack; if it is false we perform a jump by setting the directive index by calling the `address` method of the directive. Remember that we, in this chapter, have added Boolean values to the `Value` class:

```cpp
      case IfNotGotoId: { 
          Value value = m_valueStack.pop(); 

          if (!value.booleanValue()) { 
            directiveIndex = directive.address(); 
          } 
```

If the value is true, we do not perform a jump; we simply increase the directive index:

```cpp
          else { 
            ++directiveIndex; 
          } 
        } 
        break; 
```

The `Goto` directive performs an unconditional jump; we simply set the new directive index. Since the `IfNotGoto` and `Goto` directives have been generated by the parser, we do not need to perform any type checking:

```cpp
      case GotoId: 
        directiveIndex = directive.address(); 
        break; 
```

The set directives work in a way corresponding to the parser of the previous chapter. The value of the expression has been pushed to the value stack during the evaluation of an earlier directive. We pop the value of the value stack and check that it holds the correct type. Then we add the action with the value to the action list and increase the directive index:

```cpp
      case SetPenColorId: 
      case SetPenStyleId: 
      case SetBrushColorId: 
      case SetBrushStyleId: 
      case SetFontId: 
      case SetHorizontalAlignmentId: 
      case SetVerticalAlignmentId: { 
          Value value = m_valueStack.pop(); 
          checkType(directiveId, value); 
          actionList.push_back(Action(directiveId, value)); 
          ++directiveIndex; 
        } 
        break;
```

Also, the draw directives are similar to the parser in the previous chapter. Their first and second value are popped in reverse order, since the first value was pushed first and thereby is placed below the second value on the stack. We then check that the values have correct types, add the action to the action list, and increase the directive index:

```cpp
      case DrawLineId: 
      case DrawRectangleId: 
      case DrawEllipseId: 
      case DrawTextId: { 
          Value secondValue = m_valueStack.pop(); 
          Value firstValue = m_valueStack.pop(); 
          checkType(directiveId, firstValue, secondValue); 
          actionList.push_back(Action(directiveId, firstValue, 
                                      secondValue)); 
          ++directiveIndex; 
        } 
        break; 
```

The assignment directive associates a name with the value in the value map. Note that if the name already has been associated with a value, the previous value is overwritten. Also note that the value map is local to the current function, potential calling functions have their own value maps pushed on the value map stack:

```cpp
      case AssignId: { 
          Value value = m_valueStack.pop(); 
          m_valueMap[directive.name()] = value; 
          ++directiveIndex; 
        } 
        break; 
```

In an expression with one value, its value is popped from the stack, its type is checked, and the resulting value of the expression is evaluated and pushed on the value stack. Finally, the directive index is increased:

```cpp
      case XCoordinateId: 
      case YCoordinateId: { 
          Value value = m_valueStack.pop(); 
          checkType(directiveId, value); 
          Value resultValue = evaluate(directiveId, value); 
          m_valueStack.push(resultValue); 
          ++directiveIndex; 
        } 
        break;
```

In an expression with two values, its first and second value are popped from the stack (in reverse order), their types are checked, and the resulting value of the expression is evaluated and pushed on the value stack. Finally, the directive index is increased:

```cpp
      case AddId: 
      case SubtractId: 
      case MultiplyId: 
      case DivideId: 
      case PointId: { 
          Value rightValue = m_valueStack.pop(); 
          Value leftValue = m_valueStack.pop(); 
          checkType(directiveId, leftValue, rightValue); 
          Value resultValue = 
            evaluate(directiveId, leftValue, rightValue); 
          m_valueStack.push(resultValue); 
          ++directiveIndex; 
        } 
        break; 
```

In a color expression, the red, green, and blue component values are popped from the value stack (in reverse order), their types are checked, and the resulting color is pushed on the value stack. Finally, the directive index is increased:

```cpp
      case ColorId: { 
          Value blueValue = m_valueStack.pop(); 
          Value greenValue = m_valueStack.pop(); 
          Value redValue = m_valueStack.pop(); 
          checkColorType(redValue, greenValue, blueValue); 
          QColor color(redValue.numericalValue(), 
                       greenValue.numericalValue(), 
                       blueValue.numericalValue()); 
          m_valueStack.push(Value(color)); 
          ++directiveIndex; 
        } 
        break; 
```

In a font expression, the values of the name and size are popped from the value stack (in reverse order) and their types are checked. The resulting font is pushed on the value stack and the directive index is increased:

```cpp
      case FontId: { 
          Value sizeValue = m_valueStack.pop(); 
          Value nameValue = m_valueStack.pop(); 
          checkFontType(nameValue, sizeValue, 
                        boldValue, italicValue); 
          QFont font(nameValue.stringValue(), 
                     sizeValue.numericalValue()); 
          m_valueStack.push(Value(font)); 
          ++directiveIndex; 
        } 
        break; 
```

In the case of a name, we look up its value and push it on the value stack and increase the directive index. If there is no value associated with the name, a semantic error is reported:

```cpp
      case NameId: { 
          QString name = directive.name(); 
          check(m_valueMap.contains(name), 
                "unknown name: "" + name +"""); 
          m_valueStack.push(m_valueMap[name]); 
          ++directiveIndex; 
        } 
        break; 
```

Finally, when we have a value, we just push it on the value stack and increase the directive index:

```cpp
      case ValueId: 
        m_valueStack.push(directive.value()); 
        ++directiveIndex; 
        break; 
    } 
  } 
} 
```

# The main function

Finally, the `main` function is almost identical to the previous function.

**Main.cpp:**

```cpp
#include <QApplication> 
#include <QMessageBox> 
#include <IOStream> 
using namespace std; 

#include "Action.h" 
#include "Error.h" 
#include "Scanner.h" 
#include "Parser.h" 
#include "Evaluator.h" 
#include "ViewerWidget.h" 

int main(int argc, char *argv[]) { 
  Scanner::init(); 
  QApplication application(argc, argv); 

  try { 
    QString path = "C:\Input.dsl"; 

    QFile file(path); 
    if (!file.open(QIODevice::ReadOnly)) { 
      error("Cannot open file "" + path + "" for reading."); 
    } 

    QString buffer(file.readAll()); 
    Scanner scanner(buffer); 
```

The only difference is that the parser generates a sequence of directives rather than actions, as well as a function map, which is sent to the evaluator that generates the final action list that is read and executed by the viewer that displays the graphical objects:

```cpp
    QList<Directive> directiveList; 
    QMap<QString,Function> functionMap; 
    Parser(scanner, directiveList, functionMap); 

    QList<Action> actionList; 
    Evaluator evaluator(directiveList, actionList, functionMap); 

    ViewerWidget mainWidget(actionList); 
    mainWidget.show(); 
    return application.exec(); 
  } 
  catch (exception e) { 
    QMessageBox messageBox(QMessageBox::Information, 
                           QString("Error"), QString(e.what())); 
    messageBox.exec(); 
  } 
}
```

# Summary

In this chapter, we have improved the DSL that we started to work on in the previous chapter. We have added selection, iteration, variables, and function calls. We have also added the evaluator, which takes the directives generated by the parser and generates the actions read and executed by the viewer. When the directives are being executed, the values of the expressions are stored on a stack, the values assigned to names are stored in a map, and the return address of function calls are stored on a stack.

This was the final chapter, I hope you have enjoyed the book!