["```cpp\nvoid WordDocument::OnChar(TCHAR tChar) { \n  if (isprint(tChar) || (tChar == NewLine)) { \n    if (wordMode == WordMark) { \n      OnDelete(); \n    } \n\n    Paragraph* paragraphPtr = charList[editIndex].ParagraphPtr(); \n\n    switch (GetKeyboardMode()) { \n      case InsertKeyboard: \n        OnInsertChar(tChar, paragraphPtr); \n        break; \n\n      case OverwriteKeyboard: \n        OnOverwriteChar(tChar, paragraphPtr); \n        break; \n    } \n\n    SetDirty(true); \n    GenerateParagraph(paragraphPtr); \n    CalculateDocument(); \n\n    if (MakeVisible()) { \n      Invalidate(); \n      UpdateWindow(); \n    } \n\n    UpdateCaret(); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnInsertChar(TCHAR tChar, \n                                Paragraph* paragraphPtr) { \n  if (nextFont != SystemFont) { \n    charList.Insert(editIndex++, \n                    CharInfo(paragraphPtr, tChar, nextFont)); \n    ClearNextFont(); \n  } \n\n```", "```cpp\n  else if (charList[editIndex].ParagraphPtr()->First() < \n           editIndex) { \n    Font font = charList[editIndex - 1].CharFont(); \n    charList.Insert(editIndex++, \n                    CharInfo(paragraphPtr, tChar, font)); \n  } \n\n```", "```cpp\n  else { \n    Font font = charList[editIndex].CharFont(); \n    charList.Insert(editIndex++, \n                    CharInfo(paragraphPtr, tChar, font)); \n  } \n\n```", "```cpp\n  ++paragraphPtr->Last(); \n\n  for (int parIndex = paragraphPtr->Index() + 1; \n       parIndex <= paragraphList.Size() - 1; ++parIndex) { \n    ++paragraphList[parIndex]->First(); \n    ++paragraphList[parIndex]->Last(); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnOverwriteChar(TCHAR tChar, \n                                   Paragraph* paragraphPtr) { \n  if (editIndex == (charList.Size() - 1)) { \n    if (nextFont != SystemFont) { \n      charList.Insert(editIndex++, \n        CharInfo(paragraphPtr, tChar, nextFont)); \n      charList[editIndex] = \n        CharInfo(paragraphPtr, NewLine, nextFont); \n      ClearNextFont(); \n    } \n    else { \n      Font font = charList[editIndex].CharFont(); \n      charList.Insert(editIndex++, \n                      CharInfo(paragraphPtr, tChar, font)); \n    } \n\n    ++paragraphPtr->Last(); \n  } \n  else { \n    if (nextFont != SystemFont) { \n      charList[editIndex++] = \n        CharInfo(paragraphPtr, tChar, nextFont); \n      ClearNextFont(); \n    } \n    else { \n      Font font = charList[editIndex].CharFont(); \n      charList[editIndex++] = CharInfo(paragraphPtr, tChar, font); \n    } \n  } \n} \n\n```", "```cpp\nvoid WordDocument::ClearNextFont() { \n  if (nextFont != SystemFont) { \n    nextFont = SystemFont; \n    Paragraph* paragraphPtr = charList[editIndex].ParagraphPtr(); \n    GenerateParagraph(paragraphPtr); \n    CalculateDocument(); \n    UpdateWindow(); \n  } \n} \n\n```", "```cpp\nbool WordDocument::OnKeyDown(WORD key, bool shiftPressed, \n                             bool /* controlPressed */) { \n  switch (key) { \n    case KeyLeft: \n    case KeyRight: \n    case KeyUp: \n    case KeyDown: \n    case KeyHome: \n    case KeyEnd: { \n\n        if (shiftPressed) { \n          OnShiftKey(key); \n        } \n        else { \n          OnRegularKey(key); \n        } \n      } \n      return true; \n\n    case KeyBackspace: \n    case KeyReturn: \n      OnNeutralKey(key); \n      return true; \n  } \n\n  return false; \n} \n\n```", "```cpp\nvoid WordDocument::OnRegularKey(WORD key) { \n  EnsureEditStatus(); \n\n  switch (key) { \n    case KeyLeft: \n      OnLeftArrowKey(); \n      break; \n\n    case KeyRight: \n      OnRightArrowKey(); \n      break; \n\n    case KeyUp: \n      OnUpArrowKey(); \n      break; \n\n    case KeyDown: \n      OnDownArrowKey(); \n      break; \n\n    case KeyHome: \n      OnHomeKey(); \n      break; \n\n    case KeyEnd: \n      OnEndKey(); \n      break; \n  } \n\n  if (MakeVisible()) { \n    Invalidate(); \n    UpdateWindow(); \n    UpdateCaret(); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::EnsureEditStatus() { \n  if (wordMode == WordMark) { \n    wordMode = WordEdit; \n    editIndex = lastMarkIndex; \n    InvalidateBlock(firstMarkIndex, lastMarkIndex); \n    UpdateCaret(); \n    UpdateWindow(); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnLeftArrowKey() { \n  if (editIndex > 0) { \n    ClearNextFont(); \n    --editIndex; \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnRightArrowKey() { \n  if (editIndex < (charList.Size() - 1)) { \n    ClearNextFont(); \n    ++editIndex; \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnUpArrowKey() { \n  CharInfo charInfo = charList[editIndex]; \n\n  Paragraph* paragraphPtr = charInfo.ParagraphPtr(); \n  Point topLeft(0, paragraphPtr->Top()); \n\n  LineInfo* lineInfoPtr = charInfo.LineInfoPtr(); \n  Rect lineRect = \n    topLeft + Rect(0, lineInfoPtr->Top(), PageInnerWidth(), \n                      lineInfoPtr->Top() + lineInfoPtr->Height()); \n\n```", "```cpp\n  if (lineRect.Top() > 0) { \n    ClearNextFont(); \n    Rect charRect = topLeft + charInfo.CharRect(); \n    editIndex = \n      MousePointToIndex(Point(charRect.Left(), lineRect.Top()-1)); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnDownArrowKey() { \n  CharInfo charInfo = charList[editIndex];  \n  Paragraph* paragraphPtr = charInfo.ParagraphPtr(); \n  Point topLeft(0, paragraphPtr->Top());  \n  LineInfo* lineInfoPtr = charInfo.LineInfoPtr(); \n  Rect lineRect = \n    topLeft + Rect(0, lineInfoPtr->Top(), PageInnerWidth(), \n                      lineInfoPtr->Top() + lineInfoPtr->Height()); \n\n```", "```cpp\n  Paragraph* lastParagraphPtr = paragraphList.Back(); \n  int bottom = lastParagraphPtr->Top() + \n               lastParagraphPtr->Height(); \n\n  if (lineRect.Bottom() < bottom) { \n    ClearNextFont(); \n    Rect charRect = topLeft + charInfo.CharRect(); \n    editIndex = \n      MousePointToIndexDown(Point(charRect.Left(), \n                                  lineRect.Bottom() + 1)); \n  } \n} \n\n```", "```cpp\nint WordDocument::MousePointToIndexDown(Point mousePoint) const{ \n  for (int parIndex = 0; parIndex < paragraphList.Size(); \n       ++parIndex) { \n    Paragraph* paragraphPtr = paragraphList[parIndex]; \n\n    if (mousePoint.Y() <= \n        (paragraphPtr->Top() + paragraphPtr->Height())) { \n      return MousePointToParagraphIndex \n             (paragraphList[parIndex], mousePoint); \n    } \n  } \n\n```", "```cpp\n  assert(false); \n  return 0; \n} \n\n```", "```cpp\nvoid WordDocument::OnPageUpKey() { \n  CharInfo charInfo = charList[editIndex]; \n  Rect editRect = charInfo.CharRect(); \n\n  Paragraph* paragraphPtr = charInfo.ParagraphPtr(); \n  Point topLeft(0, paragraphPtr->Top()); \n\n  int scrollPage = GetVerticalScrollPageHeight(); \n  Point editPoint((editRect.Left() + editRect.Right()) / 2, \n        ((editRect.Top() + editRect.Bottom()) / 2) - scrollPage); \n\n  editIndex = MousePointToIndex(topLeft + editPoint); \n} \n\nvoid WordDocument::OnPageDownKey() { \n  CharInfo charInfo = charList[editIndex]; \n  Rect editRect = charInfo.CharRect(); \n\n  Paragraph* paragraphPtr = charInfo.ParagraphPtr(); \n  Point topLeft(0, paragraphPtr->Top()); \n\n  int scrollPage = GetVerticalScrollPageHeight(); \n  Point editPoint((editRect.Left() + editRect.Right()) / 2, \n        ((editRect.Top() + editRect.Bottom()) / 2) + scrollPage); \n\n  editIndex = MousePointToIndex(topLeft + editPoint); \n} \n\n```", "```cpp\nvoid WordDocument::OnHomeKey() { \n  CharInfo charInfo = charList[editIndex]; \n  int homeCharIndex = charInfo.ParagraphPtr()->First() + \n                      charInfo.LineInfoPtr()->First(); \n\n```", "```cpp\n  if (homeCharIndex < editIndex) { \n    ClearNextFont(); \n    editIndex = homeCharIndex; \n    UpdateCaret(); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnEndKey() { \n  CharInfo charInfo = charList[editIndex]; \n  int endCharIndex = charInfo.ParagraphPtr()->First() + \n                     charInfo.LineInfoPtr()->Last(); \n\n```", "```cpp\n  if (editIndex < endCharIndex) { \n    ClearNextFont(); \n    editIndex = endCharIndex; \n    UpdateCaret(); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnShiftKey(WORD key) { \n  EnsureMarkStatus(); \n  switch (key) { \n    case KeyLeft: \n      OnShiftLeftArrowKey(); \n      break; \n\n    case KeyRight: \n      OnShiftRightArrowKey(); \n      break; \n\n    case KeyUp: \n      OnShiftUpArrowKey(); \n      break; \n\n    case KeyDown: \n      OnShiftDownArrowKey(); \n      break; \n\n    case KeyPageUp: \n      OnShiftPageUpKey(); \n      break; \n\n    case KeyPageDown: \n      OnShiftPageDownKey(); \n      break; \n\n    case KeyHome: \n      OnShiftHomeKey(); \n      break; \n\n    case KeyEnd: \n      OnShiftEndKey(); \n      break; \n  } \n\n  if (MakeVisible()) { \n    Invalidate(); \n    UpdateWindow(); \n    UpdateCaret(); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::EnsureMarkStatus() { \n  if (wordMode == WordEdit) { \n    ClearNextFont(); \n    wordMode = WordMark; \n    firstMarkIndex = editIndex; \n    lastMarkIndex = editIndex; \n    UpdateCaret(); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnShiftLeftArrowKey() { \n  if (lastMarkIndex > 0) { \n    InvalidateBlock(lastMarkIndex, --lastMarkIndex); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnShiftRightArrowKey() { \n  if (lastMarkIndex < charList.Size()) { \n    InvalidateBlock(lastMarkIndex, lastMarkIndex++); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnShiftUpArrowKey() { \n  CharInfo charInfo = charList[lastMarkIndex]; \n\n  Paragraph* paragraphPtr = charInfo.ParagraphPtr(); \n  Point topLeft(0, paragraphPtr->Top()); \n\n  LineInfo* lineInfoPtr = charInfo.LineInfoPtr(); \n\n  Rect lineRect = \n    topLeft + Rect(0, lineInfoPtr->Top(), PageInnerWidth(), \n                      lineInfoPtr->Top() + lineInfoPtr->Height()); \n\n  if ((paragraphPtr->Top() + lineRect.Top()) > 0) { \n    Rect charRect = topLeft + charInfo.CharRect(); \n    int newLastMarkIndex = \n      MousePointToIndex(Point(charRect.Left(), lineRect.Top()-1)); \n    InvalidateBlock(lastMarkIndex, newLastMarkIndex); \n    lastMarkIndex = newLastMarkIndex; \n  } \n} \n\nvoid WordDocument::OnShiftDownArrowKey() { \n  CharInfo charInfo = charList[lastMarkIndex]; \n\n  Paragraph* paragraphPtr = charInfo.ParagraphPtr(); \n  Point topLeft(0, paragraphPtr->Top()); \n\n  LineInfo* lineInfoPtr = charInfo.LineInfoPtr(); \n  Rect lineRect = \n    topLeft + Rect(0, lineInfoPtr->Top(), PageInnerWidth(), \n                      lineInfoPtr->Top() + lineInfoPtr->Height()); \n\n  Paragraph* lastParagraphPtr = paragraphList.Back(); \n  int bottom = lastParagraphPtr->Top() + \n               lastParagraphPtr->Height(); \n\n  if (lineRect.Bottom() < bottom) { \n    Rect charRect = topLeft + charInfo.CharRect(); \n    int newLastMarkIndex = \n      MousePointToIndexDown(Point(charRect.Left(), \n                                  lineRect.Bottom() + 1)); \n    InvalidateBlock(lastMarkIndex, newLastMarkIndex); \n    lastMarkIndex = newLastMarkIndex; \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnShiftPageUpKey() { \n  Rect lastRectMark = charList[lastMarkIndex].CharRect(); \n  int scrollPage = GetVerticalScrollPageHeight(); \n  Point lastPointMark \n    ((lastRectMark.Left() + lastRectMark.Right()) / 2, \n     (lastRectMark.Top()+lastRectMark.Bottom()) / 2 - scrollPage); \n\n  int newLastMarkIndex = MousePointToIndex(lastPointMark); \n  InvalidateBlock(lastMarkIndex, newLastMarkIndex); \n  lastMarkIndex = newLastMarkIndex; \n} \n\nvoid WordDocument::OnShiftPageDownKey() { \n  Rect lastRectMark = charList[lastMarkIndex].CharRect(); \n\n  int scrollPage = GetVerticalScrollPageHeight(); \n  Point lastPointMark \n    ((lastRectMark.Left() + lastRectMark.Right()) / 2, \n     (lastRectMark.Top()+lastRectMark.Bottom())/2 + scrollPage); \n\n  int newLastMarkIndex = MousePointToIndexDown(lastPointMark); \n  InvalidateBlock(lastMarkIndex, newLastMarkIndex); \n  lastMarkIndex = newLastMarkIndex; \n} \n\n```", "```cpp\nvoid WordDocument::OnShiftHomeKey() { \n  CharInfo charInfo = charList[editIndex]; \n  int homeCharIndex = charInfo.ParagraphPtr()->First() + \n                      charInfo.LineInfoPtr()->First(); \n\n  if (homeCharIndex < lastMarkIndex) { \n    InvalidateBlock(lastMarkIndex, homeCharIndex); \n    lastMarkIndex = homeCharIndex; \n  } \n} \n\nvoid WordDocument::OnShiftEndKey() { \n  CharInfo charInfo = charList[editIndex]; \n  int endCharIndex = charInfo.ParagraphPtr()->First() + \n                     charInfo.LineInfoPtr()->Last(); \n\n  if (lastMarkIndex < endCharIndex) { \n    InvalidateBlock(lastMarkIndex, endCharIndex); \n    lastMarkIndex = endCharIndex; \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnControlHomeKey() { \n  EnsureEditStatus(); \n\n  if (editIndex > 0) { \n    editIndex = 0; \n\n    if (MakeVisible()) { \n      Invalidate(); \n      UpdateWindow(); \n    } \n\n    UpdateCaret(); \n  } \n} \n\nvoid WordDocument::OnControlEndKey() { \n  EnsureEditStatus(); \n\n  if (editIndex < (charList.Size() - 1)) { \n    editIndex = charList.Size() - 1; \n\n    if (MakeVisible()) { \n      Invalidate(); \n      UpdateWindow(); \n    } \n\n    UpdateCaret(); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnShiftControlHomeKey() { \n  EnsureMarkStatus(); \n  ClearNextFont(); \n\n  if (lastMarkIndex > 0) { \n    InvalidateBlock(0, lastMarkIndex); \n    lastMarkIndex = 0; \n\n    if (MakeVisible()) { \n      Invalidate(); \n      UpdateWindow(); \n    } \n\n    UpdateCaret(); \n  } \n} \n\nvoid WordDocument::OnShiftControlEndKey() { \n  EnsureMarkStatus(); \n\n  if (lastMarkIndex < (charList.Size() - 1)) { \n    int lastIndex = charList.Size() - 1; \n    InvalidateBlock(lastMarkIndex, lastIndex); \n    lastMarkIndex = lastIndex; \n\n    if (MakeVisible()) { \n      Invalidate(); \n      UpdateWindow(); \n    } \n\n    UpdateCaret(); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnNeutralKey(WORD key) { \n  switch (key) { \n    case KeyBackspace: \n      OnBackspaceKey(); \n      break; \n    case KeyReturn: \n      OnReturnKey(); \n      break; \n  } \n\n  if (MakeVisible()) { \n    Invalidate(); \n    UpdateWindow(); \n    UpdateCaret(); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnBackspaceKey() { \n  switch (wordMode) { \n    case WordEdit: \n      if (editIndex > 0) { \n        OnLeftArrowKey(); \n        OnDelete(); \n      } \n      break; \n\n    case WordMark: \n      OnDelete(); \n      break; \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnReturnKey() { \n  OnChar(NewLine); \n\n```", "```cpp\n  Paragraph* firstParagraphPtr = \n    charList[editIndex].ParagraphPtr(); \n  Paragraph* secondParagraphPtr = \n    new Paragraph(editIndex, firstParagraphPtr->Last(), \n                  firstParagraphPtr->AlignmentField(), \n                  firstParagraphPtr->Index() + 1); \n  assert(firstParagraphPtr != nullptr); \n  firstParagraphPtr->Last() = editIndex - 1; \n\n```", "```cpp\n  paragraphList.Insert(firstParagraphPtr->Index() + 1, \n                       secondParagraphPtr); \n  for (int charIndex = secondParagraphPtr->First(); \n       charIndex <= secondParagraphPtr->Last(); ++charIndex) { \n    charList[charIndex].ParagraphPtr() = secondParagraphPtr; \n  } \n\n```", "```cpp\n  GenerateParagraph(firstParagraphPtr); \n  GenerateParagraph(secondParagraphPtr); \n\n```", "```cpp\n  for (int parIndex = secondParagraphPtr->Index() + 1; \n       parIndex < paragraphList.Size(); ++parIndex) { \n    ++paragraphList[parIndex]->Index(); \n  } \n\n  SetDirty(true); \n  CalculateDocument(); \n  UpdateCaret(); \n  UpdateWindow(); \n} \n\n```", "```cpp\nbool WordDocument::MakeVisible() { \n  Rect visibleArea; \n\n  switch (wordMode) { \n    case WordEdit: { \n        Paragraph* editParagraphPtr = \n          charList[editIndex].ParagraphPtr(); \n        Point topLeft(0, editParagraphPtr->Top()); \n        visibleArea = topLeft + charList[editIndex].CharRect(); \n      } \n      break; \n\n    case WordMark: { \n        Paragraph* lastParagraphPtr = \n          charList[max(0, lastMarkIndex - 1)].ParagraphPtr(); \n        Point topLeft(0, lastParagraphPtr->Top()); \n        visibleArea = \n          topLeft + charList[max(0,lastMarkIndex - 1)].CharRect(); \n      } \n      break; \n  } \n\n```", "```cpp\n  int horiScrollLeft = GetHorizontalScrollPosition(), \n      horiScrollPage = GetHorizontalScrollPageWidth(), \n      vertScrollTop = GetVerticalScrollPosition(), \n      vertScrollPage = GetVerticalScrollPageHeight();  \n  int horiScrollRight = horiScrollLeft + horiScrollPage, \n      vertScrollBottom = vertScrollTop + vertScrollPage; \n\n```", "```cpp\n  if (visibleArea.Left() < horiScrollLeft) { \n    SetHorizontalScrollPosition(visibleArea.Left()); \n    return true; \n  } \n\n  if (visibleArea.Top() < vertScrollTop) { \n    SetVerticalScrollPosition(visibleArea.Top()); \n    return true; \n  } \n\n```", "```cpp\n  if (visibleArea.Right() > horiScrollRight) { \n    int horiDifference = visibleArea.Right() - horiScrollRight; \n    SetHorizontalScrollPosition(horiScrollLeft + horiDifference); \n    return true; \n  } \n\n  if (visibleArea.Bottom() > vertScrollBottom) { \n    int vertDifference = visibleArea.Bottom() - vertScrollBottom; \n    SetVerticalScrollPosition(vertScrollTop + vertDifference); \n    return true; \n  } \n\n  return false; \n} \n\n```", "```cpp\nvoid WordDocument::GenerateParagraph(Paragraph* paragraphPtr) { \n  if (!charList.Empty()) { \n    DynamicList<Size> sizeList; \n    DynamicList<int> ascentList; \n    DynamicList<CharInfo> prevCharList; \n\n    charList.Copy(prevCharList, paragraphPtr->First(), \n                  paragraphPtr->Last()); \n\n    GenerateSizeAndAscentList(paragraphPtr, sizeList, ascentList); \n    GenerateLineList(paragraphPtr, sizeList, ascentList); \n\n    for (LineInfo* lineInfoPtr : paragraphPtr->LinePtrList()) { \n      if (paragraphPtr->AlignmentField() == Justified) { \n        GenerateJustifiedLineRectList(paragraphPtr, lineInfoPtr, \n                                      sizeList, ascentList); \n      } \n      else {      \n        GenerateRegularLineRectList(paragraphPtr, lineInfoPtr, \n                                    sizeList, ascentList); \n      } \n    } \n\n    GenerateRepaintSet(paragraphPtr, prevCharList); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::GenerateSizeAndAscentList \n         (Paragraph* paragraphPtr, DynamicList<Size>& sizeList, \n             DynamicList<int>& ascentList) { \n  int index = 0; \n\n  for (int charIndex = paragraphPtr->First(); \n       charIndex <= paragraphPtr->Last(); ++charIndex) { \n    CharInfo charInfo = charList[charIndex]; \n    TCHAR tChar = (charInfo.Char() == NewLine) ? Space \n                                               : charInfo.Char(); \n\n    int width = GetCharacterWidth(charInfo.CharFont(), tChar), \n        height = GetCharacterHeight(charInfo.CharFont()), \n        ascent = GetCharacterAscent(charInfo.CharFont()); \n\n    sizeList.PushBack(Size(width, height)); \n    ascentList.PushBack(ascent); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::GenerateLineList(Paragraph* paragraphPtr, \n                                    DynamicList<Size>& sizeList, \n                                    DynamicList<int>& ascentList){ \n  int maxHeight = 0, maxAscent = 0, lineWidth = 0, \n      spaceLineHeight = 0, spaceLineAscent = 0, \n      startIndex = paragraphPtr->First(), spaceIndex = -1; \n\n```", "```cpp\n  for (LineInfo* lineInfoPtr : paragraphPtr->LinePtrList()) { \n    delete lineInfoPtr; \n  } \n\n  paragraphPtr->Height() = 0; \n  paragraphPtr->LinePtrList().Clear(); \n  int lineTop = 0; \n\n  for (int charIndex = paragraphPtr->First(); \n       charIndex <= paragraphPtr->Last(); ++charIndex) { \n    CharInfo charInfo = charList[charIndex]; \n\n    if (charInfo.Char() != NewLine) { \n      lineWidth += \n        sizeList[charIndex - paragraphPtr->First()].Width(); \n    } \n\n```", "```cpp\n    if ((nextFont != SystemFont) && (charIndex == editIndex) && \n        (wordMode == WordEdit)) { \n      maxHeight = max(maxHeight, GetCharacterHeight(nextFont)); \n      maxAscent = max(maxAscent, GetCharacterAscent(nextFont)); \n    } \n\n```", "```cpp\n    else { \n      maxHeight = max(maxHeight, \n        sizeList[charIndex - paragraphPtr->First()].Height()); \n      maxAscent = max(maxAscent, \n        ascentList[charIndex - paragraphPtr->First()]); \n    } \n\n    if (charInfo.Char() == Space) { \n      spaceIndex = charIndex; \n\n      spaceLineHeight = max(spaceLineHeight, maxHeight); \n      spaceLineAscent = max(spaceLineAscent, maxAscent); \n\n      maxHeight = 0; \n      maxAscent = 0; \n    } \n\n```", "```cpp\n    if (charInfo.Char() == NewLine) { \n      spaceLineHeight = max(spaceLineHeight, maxHeight); \n      spaceLineAscent = max(spaceLineAscent, maxAscent); \n\n      LineInfo* lineInfoPtr = \n        new LineInfo(startIndex - paragraphPtr->First(), \n                     charIndex - paragraphPtr->First(), \n                     lineTop, spaceLineHeight, spaceLineAscent); \n      assert(lineInfoPtr != nullptr); \n\n      for (int index = lineInfoPtr->First(); \n           index <= lineInfoPtr->Last(); ++index) { \n        charList[paragraphPtr->First() + index].LineInfoPtr() = \n          lineInfoPtr; \n      } \n\n      paragraphPtr->Height() += spaceLineHeight; \n      paragraphPtr->LinePtrList().PushBack(lineInfoPtr); \n      break; \n    } \n\n```", "```cpp\n    if (lineWidth > PageInnerWidth()) { \n      LineInfo* lineInfoPtr = new LineInfo(); \n      assert(lineInfoPtr != nullptr); \n      lineInfoPtr->Top() = lineTop; \n      lineTop += spaceLineHeight; \n\n```", "```cpp\n      if (spaceIndex != -1) { \n        lineInfoPtr->First() = startIndex - paragraphPtr->First(); \n        lineInfoPtr->Last() = spaceIndex - paragraphPtr->First(); \n        lineInfoPtr->Ascent() = spaceLineAscent; \n        lineInfoPtr->Height() = spaceLineHeight; \n        startIndex = spaceIndex + 1; \n      } \n\n```", "```cpp\n      else { \n        if (charIndex > startIndex) { \n          lineInfoPtr->First() = \n            startIndex - paragraphPtr->First(); \n          lineInfoPtr->Last() = \n            charIndex - paragraphPtr->First() - 1; \n          startIndex = charIndex; \n        } \n\n```", "```cpp\n        else { \n          lineInfoPtr->First() =charIndex - paragraphPtr->First(); \n          lineInfoPtr->Last() = charIndex - paragraphPtr->First(); \n          startIndex = charIndex + 1; \n        } \n\n```", "```cpp\n        lineInfoPtr->Height() = maxHeight; \n        lineInfoPtr->Ascent() = maxAscent; \n      } \n\n```", "```cpp\n      for (int index = lineInfoPtr->First(); \n           index <= lineInfoPtr->Last(); ++index) { \n        charList[paragraphPtr->First() + index].LineInfoPtr() = \n          lineInfoPtr; \n      } \n\n```", "```cpp\n      paragraphPtr->Height() += spaceLineHeight; \n      paragraphPtr->LinePtrList().PushBack(lineInfoPtr); \n\n```", "```cpp\n      lineWidth = 0; \n      maxAscent = 0; \n      maxHeight = 0; \n\n```", "```cpp\n      charIndex = startIndex; \n      spaceIndex = -1; \n    } \n  } \n} \n\n```", "```cpp\nvoid WordDocument::GenerateRegularLineRectList \n                   (Paragraph* paragraphPtr,LineInfo* lineInfoPtr, \n                    DynamicList<Size>& sizeList, \n                    DynamicList<int>& ascentList) { \n\n```", "```cpp\n  for (int charIndex = lineInfoPtr->First(); \n       charIndex < lineInfoPtr->Last(); ++charIndex) { \n    if (charList[paragraphPtr->First() + charIndex].Char() != \n        NewLine) { \n      lineWidth += \n        sizeList[charIndex - lineInfoPtr->First()].Width(); \n    } \n  } \n\n  if ((charList[paragraphPtr->First()+lineInfoPtr->Last()].Char() \n      != Space) && \n      (charList[paragraphPtr->First()+lineInfoPtr->Last()].Char() \n      !=NewLine)) { \n    lineWidth += \n      sizeList[lineInfoPtr->Last()-lineInfoPtr->First()].Width(); \n  } \n\n```", "```cpp\n  int leftPos; \n\n  switch (paragraphPtr->AlignmentField()) { \n    case Left: \n      leftPos = 0; \n      break; \n\n    case Center: \n      leftPos = (PageInnerWidth() - lineWidth) / 2; \n      break; \n\n    case Right: \n      leftPos = PageInnerWidth() - lineWidth; \n      break; \n  } \n\n```", "```cpp\n  for (int charIndex = lineInfoPtr->First(); \n       charIndex <= lineInfoPtr->Last(); ++charIndex) { \n    Size charSize = sizeList[charIndex]; \n    int ascent = ascentList[charIndex]; \n    int topPos = lineInfoPtr->Top() + \n                 lineInfoPtr->Ascent() - ascent; \n    charList[paragraphPtr->First() + charIndex].CharRect() = \n      Rect(leftPos, topPos, leftPos + charSize.Width(), \n           topPos + charSize.Height()); \n    leftPos += charSize.Width(); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::GenerateJustifiedLineRectList \n     (Paragraph* paragraphPtr, LineInfo* lineInfoPtr, \n      DynamicList<Size>& sizeList, DynamicList<int>& ascentList) { \n  int spaceCount = 0, lineWidth = 0; \n\n  for (int charIndex = lineInfoPtr->First(); \n       charIndex <= lineInfoPtr->Last(); ++charIndex) { \n    CharInfo charInfo = \n      charList[paragraphPtr->First() + charIndex]; \n\n```", "```cpp\n    if (charInfo.Char() == Space) { \n      ++spaceCount; \n    } \n    else if (charInfo.Char() != NewLine) { \n      lineWidth += sizeList[charIndex].Width(); \n    } \n  } \n\n  if ((charList[paragraphPtr->First()+lineInfoPtr->Last()].Char() \n      != Space) && \n      (charList[paragraphPtr->First()+lineInfoPtr->Last()].Char()  \n      !=NewLine)) { \n    lineWidth += sizeList[lineInfoPtr->Last()].Width(); \n  } \n\n```", "```cpp\n  int leftPos = 0, spaceWidth; \n  if (spaceCount > 0) { \n    spaceWidth = (PageInnerWidth() - lineWidth) / spaceCount; \n  } \n\n  for (int charIndex = lineInfoPtr->First(); \n       charIndex <= lineInfoPtr->Last(); ++charIndex) { \n    Size charSize = sizeList[charIndex]; \n    int ascent = ascentList[charIndex], charWidth; \n\n```", "```cpp\n    if (charList[paragraphPtr->First() + charIndex].Char() == \n        Space) { \n      charWidth = spaceWidth; \n    } \n    else { \n      charWidth = charSize.Width(); \n    } \n\n    int topPos = \n      lineInfoPtr->Top() + lineInfoPtr->Ascent() - ascent; \n    charList[paragraphPtr->First() + charIndex].CharRect() = \n      Rect(leftPos, topPos, leftPos + charWidth, \n           topPos + charSize.Height()); \n    leftPos += charWidth; \n  } \n} \n\n```", "```cpp\nvoid WordDocument::GenerateRepaintSet(Paragraph* paragraphPtr, \n                           DynamicList<CharInfo>& prevCharList) { \n  Point topLeft(0, paragraphPtr->Top()); \n\n  for (int charIndex = paragraphPtr->First(); \n       charIndex <= paragraphPtr->Last(); ++ charIndex) { \n    Rect prevRect = \n      prevCharList[charIndex - paragraphPtr->First()].CharRect(), \n         currRect = charList[charIndex].CharRect(); \n\n    if (prevRect != currRect) { \n      Invalidate(topLeft + prevRect); \n      Invalidate(topLeft + currRect); \n    } \n  }  \n  int pageWidth = PageInnerWidth(); \n\n  for (LineInfo* lineInfoPtr : paragraphPtr->LinePtrList()) { \n    Rect firstRect = charList[paragraphPtr->First() + \n                              lineInfoPtr->First()].CharRect(); \n\n    if (firstRect.Left() > 0) { \n      Rect leftRect(0, lineInfoPtr->Top(), firstRect.Left(), \n                    lineInfoPtr->Top() + lineInfoPtr->Height()); \n      Invalidate(topLeft + leftRect); \n    } \n\n    Rect lastRect = charList[paragraphPtr->First() + \n                             lineInfoPtr->Last()].CharRect(); \n\n    if (lastRect.Right() < pageWidth) { \n      Rect rightRect(lastRect.Right(), lineInfoPtr->Top(), \n             pageWidth, lineInfoPtr->Top()+lineInfoPtr->Height()); \n      Invalidate(topLeft + rightRect); \n    } \n  } \n} \n\n```"]