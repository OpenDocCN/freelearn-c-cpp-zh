<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-124"><a id="_idTextAnchor125"/>6</h1>
<h1 id="_idParaDest-125"><a id="_idTextAnchor126"/>Replicating Properties Over the Network</h1>
<p>Replication is an important concept when it comes to creating multiplayer games with Unreal Engine. In particular, <strong class="bold">property replication</strong> allows for the synchronization of objects between multiple players, letting them interact in a shared environment. This feature also handles things such as character movement and physics calculations, ensuring everyone has a consistent experience and view of the game world, regardless of the platform type, and that no one has an advantage due to cheating or latency issues.</p>
<p>In this chapter, you’ll start working on replication, mainly focusing on property replication of your character skills. Next, starting from the base pickup you created in the last chapter, you’ll implement a coin pickup that will grant the character experience points that will give the character a level-up during gameplay. Finally, you’ll apply replication by updating a simple user interface that will show the character experience points and level.</p>
<p>At the end of this chapter, you will have a good grasp of how an Actor replicates in a multiplayer setting and the properties that come with it. Essentially, you’ll understand how Actors behave and operate in a multi-player environment.</p>
<p>In the next sections, I will present the following topics:</p>
<ul>
<li>Adding character stats</li>
<li>Understanding property replication</li>
<li>Handling characters level-ups</li>
<li>Adding a HUD to the game</li>
</ul>
<h1 id="_idParaDest-126"><a id="_idTextAnchor127"/>Technical requirements</h1>
<p>To follow the topics presented in this chapter, you should have completed the previous ones and understood their content.</p>
<p>Additionally, if you would prefer to begin with code from the companion repository for this book, you can download the <code>.zip</code> project files provided in this book’s companion project repository:</p>
<p><a href="https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5">https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5</a>.</p>
<p>You can download the files that are up to date with the end of the last chapter by clicking the <code>Unreal Shadows – </code><code>Chapter 05</code><code> </code><code>End</code> link.</p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor128"/>Adding character stats</h1>
<p>Before introducing property replication and implementing it in the project, our thief hero needs to be ready for such a big step: that’s why I’ll guide you through the creation of a set of statistics that will be plugged into the Character class.</p>
<p>The first thing to do is to <a id="_idIndexMarker347"/>define your character stats. In particular, you will need the following data:</p>
<ul>
<li>A walk and a sprint speed, to handle the different paces of your character during gameplay</li>
<li>A damage multiplier to manage more powerful hits whenever the character levels up</li>
<li>A level-up value to check whenever the character has reached the next level</li>
<li>A stealth multiplier that will handle how much noise the character makes when walking or sprinting</li>
</ul>
<p>You may have noticed that your character has no health – that is because this is a stealth game and players will have to move carefully through the dungeon. Once they are discovered, they won’t have the option of facing a swarm of undead lackeys in this particular game! As a consequence, gameplay will be more focused on defeating enemies from a distance or slipping silently away from them.</p>
<p>With the previous information, you’ll create a data structure containing all the data points for initializing the character, and then you’ll create a data table that will let you manage the experience <a id="_idIndexMarker348"/>your thief will gain during gameplay. So, let’s get started.</p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor129"/>Creating the stats structure</h2>
<p>To begin, you need to<a id="_idIndexMarker349"/> create a structure that will include all the aforementioned statistics. As this is not a class, you won’t need to create it from Unreal Engine Editor but from the IDE instead.</p>
<p class="callout-heading">Note</p>
<p class="callout">Non-class entities cannot be made directly from within Unreal Editor.</p>
<p>Open your IDE and create a file in your <code>UnrealShadows_LOTL</code> | <code>Source</code> | <code>UnrealShadows_LOTL</code> folder called <code>US_CharacterStats.h</code> (as this is a data structure, you won’t need a <code>.cpp</code> file). Then, open the file and insert the following code:</p>
<pre class="source-code">
#pragma once
#include "CoreMinimal.h"
#include "Engine/DataTable.h"
#include "US_CharacterStats.generated.h"
USTRUCT(BlueprintType)
struct UNREALSHADOWS_LOTL_API FUS_CharacterStats : public FTableRowBase
{
 GENERATED_BODY()
 UPROPERTY(BlueprintReadWrite, EditAnywhere)
 float WalkSpeed = 200.0f;
 UPROPERTY(BlueprintReadWrite, EditAnywhere)
 float SprintSpeed = 400.0f;
 UPROPERTY(BlueprintReadWrite, EditAnywhere)
 float DamageMultiplier = 1.0f;
 UPROPERTY(BlueprintReadWrite, EditAnywhere)
 int32 NextLevelXp = 10.0f;
 UPROPERTY(BlueprintReadWrite, EditAnywhere)
 float StealthMultiplier = 1.0f;
};</pre>
<p>The <code>include</code> section is<a id="_idIndexMarker350"/> self-explanatory – after that, along with the standard C++ <code>struct</code> keyword to declare a structure, you will notice an <code>USTRUCT()</code> declaration instead of <code>UCLASS()</code> and an <code>F</code> prefix on the structure name (i.e., <code>FUS_CharacterStats</code>). This is the standard method to declare a structure in Unreal Engine. Then, in order to let Unreal Editor create data tables from this structure (more on this in a few moments), the <code>FTableRowBase</code> type is extended.</p>
<p>Inside the structure declaration, we are just adding a list of properties – all of them are marked <code>BlueprintReadWrite</code> to let Blueprints access and modify the data, and <code>EditAnywhere</code> to let you edit the values inside the data table you are going to create in the next steps.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor130"/>Creating a stats data table</h2>
<p>Now you have created a data structure for your character and are ready to create the actual data from it. In Unreal Engine, we will<a id="_idIndexMarker351"/> use a <code>UObject</code> property – including asset references from the projects, such as<a id="_idIndexMarker352"/> materials or textures.</p>
<p>To create your character data table, see the following steps:</p>
<ol>
<li>Open your <code>Blueprints</code> folder in the Content Browser.</li>
<li>Compile your project in order to make the C++ structure available in the Editor.</li>
<li>Right-click in the Content Browser and select <strong class="bold">Miscellaneous</strong> | <strong class="bold">Data Table</strong>.</li>
<li>In the <strong class="bold">Pick Row Structure</strong> pop-up window, select <strong class="bold">US_CharacterStats</strong> from the drop-down menu, as depicted in <em class="italic">Figure 6</em><em class="italic">.1</em>:</li>
</ol>
<div><div><img alt="Figure 6.1 – The data table creation panel" src="img/Figure_06_01_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The data table creation panel</p>
<ol>
<li value="5">Click the <code>US_CharacterStats</code>.</li>
<li>Double-click on the newly created asset to open it. You will get an empty dataset as shown in <em class="italic">Figure 6</em><em class="italic">.2</em>:</li>
</ol>
<div><div><img alt="Figure 6.2 – The empty data table" src="img/Figure_06_02_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – The empty data table</p>
<p class="callout-heading">Note</p>
<p class="callout">A data table can also be generated by importing a <code>.csv</code> or <code>.json</code> file into your project. Additionally, Unreal Engine will let you easily export your project tables in <code>.csv</code> and <code>.json</code> formats. For more information about the importing and exporting processes, check the official documentation linked here: <a href="https://docs.unrealengine.com/5.1/en-US/data-driven-gameplay-elements-in-unreal-engine/">https://docs.unrealengine.com/5.1/en-US/data-driven-gameplay-elements-in-unreal-engine/</a>.</p>
<p>With your table open, it’s time to add some data rows organized by character levels – you do want to let your <a id="_idIndexMarker353"/>character grow when they gain enough experience, don’t you?</p>
<p>Let’s start by adding a single row for your character base level:</p>
<ol>
<li>Click on the <strong class="bold">Add</strong> button in the <strong class="bold">Table</strong> panel.</li>
<li>The <code>level_01</code>.</li>
<li>You are now ready to set some stats for the first experience level of your character. Look for the <code>250,0</code></li><li><code>800,0</code></li><li><code>1,0</code></li><li><code>10</code></li><li><code>1,0</code></li></ul></li>
</ol>
<p>The final result should <a id="_idIndexMarker354"/>be the same as the settings shown in <em class="italic">Figure 6</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 6.3 – Settings for the level_01 character" src="img/Figure_06_03_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Settings for the level_01 character</p>
<p>We are going to add a couple more levels to handle the experience growth of the character during gameplay. Repeat the same steps as before, but call the two new rows <code>level_02</code> and <code>level_03</code> respectively. Then use the following values for the <strong class="bold">level_02</strong> row:</p>
<ul>
<li><code>275,0</code></li>
<li><code>850,0</code></li>
<li><code>1,1</code></li>
<li><code>25</code></li>
<li><code>1,5</code></li>
</ul>
<p>And add the <a id="_idIndexMarker355"/>following values for the <strong class="bold">level_03</strong> row:</p>
<ul>
<li><code>300,0</code></li>
<li><code>900,0</code></li>
<li><code>1,0</code></li>
<li><code>50</code></li>
<li><code>2</code></li>
</ul>
<p>These are purely indicative values – you are free to tweak them to suit your own needs and add as many additional levels as you wish.</p>
<p>Now that you have added a dataset for your character’s experience, you are ready to read the info included directly from your code. That’s why I need you to go back to the <code>US_Character.h</code> header file to add the data table declaration.</p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor131"/>Reading the data table from the character</h2>
<p>In this section, you are going to<a id="_idIndexMarker356"/> add the data table to the character in order to read its values depending on the experience level. The first thing to do is to add a reference to the <code>US_Character.h</code> header file. So, in the <code>private</code> section of the header file, after all the existing declarations, add this code:</p>
<pre class="source-code">
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Character Data", meta = (AllowPrivateAccess = "true"))
class UDataTable* CharacterDataTable;
struct FUS_CharacterStats* CharacterStats;</pre>
<p>The first declaration will let you reference the data table directly from the child Blueprint Classes, while the structure declaration will let you reference a single row from the data table and use it as the character statistics.</p>
<p>After that, you will need to create a function that will allow the system to update the current level of the <a id="_idIndexMarker357"/>character. In the <code>public</code> section, add the following method declaration:</p>
<pre class="source-code">
void UpdateCharacterStats(int32 CharacterLevel);</pre>
<p>The last thing you need to add to the class header is a getter function for the stats structure. Still in the <code>public</code> section, just before the last closing bracket, add the following line of code:</p>
<pre class="source-code">
FORCEINLINE FUS_CharacterStats* GetCharacterStats() const { return CharacterStats; }</pre>
<p>You can now save this file and open <code>US_Character.cpp</code> to handle the data retrieval. At the top of the file, add the <code>include</code> declarations for the classes you’ll be using in a moment:</p>
<pre class="source-code">
#include "US_CharacterStats.h"
#include "Engine/DataTable.h"</pre>
<p>Next, implement the <code>UpdateCharacterStats()</code> method by adding the following code at the end of the file:</p>
<pre class="source-code">
void AUS_Character::UpdateCharacterStats(int32 CharacterLevel)
{
 if(CharacterDataTable)
 {
  TArray&lt;FUS_CharacterStats*&gt; CharacterStatsRows;
  CharacterDataTable-&gt;GetAllRows&lt;FUS_CharacterStats&gt;(TEXT("US_Character"), CharacterStatsRows);
  if(CharacterStatsRows.Num() &gt; 0)
  {
   const auto NewCharacterLevel = FMath::Clamp(CharacterLevel, 1, CharacterStatsRows.Num());
   CharacterStats = CharacterStatsRows[NewCharacterLevel - 1];
   GetCharacterMovement()-&gt;MaxWalkSpeed = GetCharacterStats()-&gt;WalkSpeed;
  }
 }
}</pre>
<p>As you can see, first we check that the data table is referenced (you’ll add it later, from the character Blueprint) and then use the <code>GetAllRows&lt;T&gt;()</code> method to fetch all the table rows into a local array (i.e., the <code>CharacterStatsRows</code> variable). If there is at least one row in the<a id="_idIndexMarker358"/> data table, we get the one corresponding to the level of the character minus 1 (i.e., for a level 1 character, we will get the row number 0). Notice, as well, the <code>FMath::Clamp()</code> method, which guarantees we are not trying to get a level value that’s higher than the available rows in the dataset.</p>
<p>After that, we retrieve the <code>WalkSpeed</code> column from the row and assign its value to the <code>MaxWalkSpeed</code> property of the character movement component – this means that, if there is a data table assigned, your character will start the game with a value from the dataset and not from the constructor.</p>
<p>You are now ready to update your character stats to level 1 – something you are about to do in the <code>BeginPlay()</code> function. To do so, inside the <code>BeginPlay()</code> function, and just before the closing bracket, add this code:</p>
<pre class="source-code">
UpdateCharacterStats(1);</pre>
<p>The last thing you need to do is to update the two sprint methods that, at the moment, are using hardcoded values <a id="_idIndexMarker359"/>but need to use the data table stats. To do so, search for the <code>SprintStart()</code> method and find the following line:</p>
<pre class="source-code">
GetCharacterMovement()-&gt;MaxWalkSpeed = 3000.f;</pre>
<p>Then, change it to the following code:</p>
<pre class="source-code">
if (GetCharacterStats())
{
 GetCharacterMovement()-&gt;MaxWalkSpeed = GetCharacterStats()-&gt;SprintSpeed;
}</pre>
<p>Let’s do the same with the <code>SprintEnd()</code> method, which should be positioned just after the previous one. Find the following line:</p>
<pre class="source-code">
GetCharacterMovement()-&gt;MaxWalkSpeed = 500.f;</pre>
<p>Then change it using the following code block:</p>
<pre class="source-code">
if(GetCharacterStats())
{
 GetCharacterMovement()-&gt;MaxWalkSpeed = GetCharacterStats()-&gt;WalkSpeed;
}</pre>
<p>In both cases, the code is self-explanatory – we just check that there is valid data referenced in the character stats and assign the sprint or walk speed to the character movement component.</p>
<p>Now save your file and compile the project, just to be sure that everything is fine and ready for the next step.</p>
<p>Your character is now ready to accept the data table we created at the beginning of this chapter.</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor132"/>Adding the data table to the character</h2>
<p>To add the data table<a id="_idIndexMarker360"/> asset to the character, switch back to Unreal Editor and follow these steps:</p>
<ol>
<li>Open the <strong class="bold">BP_Character</strong> Blueprint.</li>
<li>Select the <strong class="bold">Class Defaults</strong> tab and, in the <strong class="bold">Details</strong> panel, look for the <strong class="bold">Character </strong><strong class="bold">Data</strong> category.</li>
<li>In the <strong class="bold">Character Data Table</strong> attribute, click on the drop-down menu and select <strong class="bold">DT_CharacterStats</strong>.</li>
</ol>
<p>Your character is now ready to use the statistics from the dataset – even though the poor thief is locked into a level 1 experience level, later on, you will set them free in the dungeon and see how they fare!</p>
<p>Test the game to check that everything works properly. Just remember what I said in the previous chapter: movement is still buggy as the client and the server are trying to force the character to conform to different speed values, but you are nearing the solution.</p>
<p>So, in this section, you have improved the character by adding some statistics retrieved from a data table and using them to initialize some properties. At the moment, you have just used the movement ones, but don’t be afraid! Once the character is completed, everything will fall into place.</p>
<p>In the upcoming section, we’ll dive into the topic of property replication in Unreal – something that will come in handy when it’s time to level up your character and something you’ll be doing by the end of this chapter.</p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor133"/>Understanding property replication</h1>
<p>As stated before, property <a id="_idIndexMarker361"/>replication allows for the synchronization of objects in an Unreal multiplayer environment. It should be noted that, as the server is authoritative, updates will never be sent by the client. Obviously, the client may (politely) ask the server to change a property value, and the server will behave accordingly. Additionally, property replication acts as a reliable service: consequently, the Actor on the client will have the same value as the server sooner or later.</p>
<p>This means that if you’re trying to modify, from the client, a property that is replicated, any changes you make to that property will only be temporary. You should be already familiar with this topic as the character’s movement logic, at the moment, is a bit buggy – we are trying to make the character run from the client, but the server is blocking our commands as soon as the network is updated.</p>
<p>This is happening because, as soon as the server sends an update to the client with a new value for that property, any changes that you made locally on the client will be overwritten and<a id="_idIndexMarker362"/> replaced with the new, correct value from the server. Consequently, if the server does not update frequently, it may take a while for the client to be notified about the new, correct value.</p>
<p>Fixing that nasty bug is something we will be doing in <a href="B18203_07.xhtml#_idTextAnchor147"><em class="italic">Chapter 7</em></a>, <em class="italic">Using Remote Procedure Calls (RPCs)</em>, where you’ll need to learn how to call a function from the client to the server. The main focus of this chapter, however, is to understand how to replicate properties. So, without further ado, let’s check how things work under the hood!</p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor134"/>Enabling property replication</h2>
<p>In order for a property to <a id="_idIndexMarker363"/>be replicated, you need to set up a few things. First of all, in the Actor constructor that will contain the property, you will need to set the <code>bReplicates</code> flag to <code>true</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">A class or Blueprint extending from <code>APawn</code> or <code>ACharacter</code> will have the <code>bReplicates</code> property set to <code>true</code> by default, while a regular Actor won’t.</p>
<p>Then, the property that should be replicated will need to have the <code>Replicated</code> specifier added to the <code>UPROPERTY()</code> macro. As an example, you can replicate the score for your character with the following code:</p>
<pre class="source-code">
UPROPERTY(Replicated)
int32 Score;</pre>
<p>If you are in need of a callback function to be executed when a property is updated, you can use <code>ReplicatedUsing=[FunctionName]</code> instead – this attribute will let you specify a function that will be executed when an update is sent to the client. For example, if you want to execute a method called <code>OnRep_Score()</code> whenever your character score is replicated, you will write something similar to the following code:</p>
<pre class="source-code">
UPROPERTY(ReplicatedUsing="OnRep_Score")
int32 Score;</pre>
<p>You will then need to<a id="_idIndexMarker364"/> implement the <code>OnRep_Score()</code> method in the same class; this function must declare the <code>UFUNCTION()</code> macro.</p>
<p>Once all the replication properties are properly decorated by the previous attributes, they need to be declared inside the <code>AActor::GetLifetimeReplicatedProps()</code> function by using the <code>DOREPLIFETIME()</code> macro. Using the previous score example, you will need to declare the <code>Score</code> property by using the following code:</p>
<pre class="source-code">
DOREPLIFETIME(AMyActor, Score);</pre>
<p>After a property is registered for replication, it cannot be unregistered, as Unreal Engine will optimize data storage to reduce the computation time: this means that, by default, you will not have much control over how a property replicates.</p>
<p>Luckily, you can use the <code>DOREPLIFETIME_CONDITION()</code> macro instead, which will let you add an additional condition for more precise control over replication. Values for these conditions are predefined – one example is <code>COND_OwnerOnly</code>, which will only send data to the Actor’s owner (we will use this value later in the chapter). As another example, if you need even more fine-grained control in property replication, you can use the <code>DOREPLIFETIME_ACTIVE_OVERRIDE()</code> macro, which will let you use your own conditions defined inside the Actor.</p>
<p>The major downside of using additional conditions for replication is performance, as the engine will need to do additional checks before replicating a property – this means that it is advisable to use the <code>DOREPLIFETIME()</code> macro in situations where no pressing requirements dictate the use of an alternative option.</p>
<p>Now that you understand how an object can be replicated, it’s time for me to introduce how objects are referenced across the network.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor135"/>Referencing Actors and components over the network</h2>
<p>Sooner or later, you will need to<a id="_idIndexMarker365"/> reference an Actor or a component from your code – this means that, in a multiplayer game, you will need to know whether the reference can be replicated or not. Simply put, an Actor or a component can be referenced over the network only if it is supported for networking.</p>
<p>There are some simple rules that will help you determine whether your object can be referenced over the network:</p>
<ul>
<li>If an Actor is replicated, it can also be replicated as a reference</li>
<li>If a component is replicated, it can also be replicated as a reference</li>
<li>Non-replicated Actors and components need to be stably named in order to be replicated as references</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">An object that is <strong class="bold">stably named</strong> means that an<a id="_idIndexMarker366"/> entity that will be present in both the server and the client that has the same name. For instance, an Actor is stably named if it was not spawned during gameplay but was loaded directly in the level from a package.</p>
<p>This section has provided you with an introduction to the fundamental concepts of network replication in Unreal Engine, explaining how it interacts with Actors and components. If you feel a bit lost about too much theory, don’t be afraid! You’ll be taking all that theory and transforming it into a tangible, working example by creating a level-up system for your character.</p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor136"/>Handling character level-ups</h1>
<p>As I previously<a id="_idIndexMarker367"/> mentioned, in this section, you are going to level up your hero’s experience and skills. As usual, you’ll be dabbling in code magic to make it happen! After all, you are programming a fantasy game.</p>
<p>I know it might seem like a good idea to write your code inside the Character class but trust me when I say that there’s actually a much better spot for it. That is the <code>PlayerState</code> class, which we incidentally have already set for this occasion – a while ago, I asked you to create the <code>US_PlayerState</code> class and now is the time to add some valuable code in it.</p>
<p>As introduced in <em class="italic">Chapter 4</em>, <em class="italic">Setting Up Your First Multiplayer Environment</em>, <code>PlayerState</code> is a class that holds information about a player’s game state and exists on both the server and clients. As we need to synchronize experience points and levels for the character, this is the ideal location to place everything.</p>
<p>What we need to do here is to keep track of experience points and, as soon as the character reaches a new level, broadcast the information across the network and update the character<a id="_idIndexMarker368"/> statistics.</p>
<p>But first, the most important thing is to have a clear idea of what we are going to do.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor137"/>Planning ahead</h2>
<p>As the <code>PlayerState</code> class will keep important information about the character, it’s mandatory to think ahead about what you want to achieve and how to get to that point – this means we have to plan exactly what we will be adding to this class.</p>
<p>Here are some of the<a id="_idIndexMarker369"/> main features this gameplay framework class will implement:</p>
<ul>
<li>Keeping track of the character’s current level and experience points</li>
<li>Synchronizing the aforementioned properties over the network</li>
<li>Updating the Character class whenever the player levels up</li>
<li>Broadcasting events whenever the character gets some experience points or levels up</li>
</ul>
<p>As a starting point, in the next subsection, we’ll start by declaring the required properties and functions.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor138"/>Declaring PlayerState properties and functions</h2>
<p>In the following steps, we are <a id="_idIndexMarker370"/>going to define the main properties that will let the character level up whenever they have enough experience – this means we will need to track the thief’s experience points and level. Additionally, whenever values change, we will replicate these properties over the network and notify this event to each registered Actor in the game.</p>
<p>So, let’s start by <a id="_idIndexMarker371"/>opening the <code>US_PlayerState.h</code> file and adding the following code in the <code>protected</code> section:</p>
<pre class="source-code">
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, ReplicatedUsing="OnRep_Xp", Category = "Experience")
int Xp = 0;
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, ReplicatedUsing="OnRep_CharacterLevelUp", Category = "Experience")
int CharacterLevel = 1;
UFUNCTION()
void OnRep_Xp(int32 OldValue) const;
UFUNCTION()
void OnRep_CharacterLevelUp(int32 OldValue) const;</pre>
<p>As you can see, the first thing we have done is declare the two properties <code>Xp</code> (short for experience points) and <code>CharacterLevel</code>; both can be modified in Unreal’s <code>EditDefaultsOnly</code> attribute, but <code>BlueprintsReadOnly</code> makes them non-modifiable in a Blueprint, to keep all the level-up logic inside the C++ source code.</p>
<p>As an additional attribute, we use the <code>ReplicatedUsing</code> attribute, which I introduced in the previous section. This will let us execute a function whenever a property is updated – in this case, we have set <code>OnRep_Xp</code> for the <code>Xp</code> property and <code>OnRep_CharacterLevelUp</code> for <code>CharacterLevel</code>.</p>
<p>Next, create a <code>public</code> section in your header file and add this code:</p>
<pre class="source-code">
UFUNCTION(BlueprintCallable, Category="Experience")
void AddXp(int32 Value);</pre>
<p>This function will let us assign new experience points to the <code>PlayerState</code>. We need to make it <code>BlueprintCallable</code> in order to use this function from our Blueprints – for instance, from a pickup.</p>
<p>Just after that, add this declaration:</p>
<pre class="source-code">
virtual void GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const override;</pre>
<p>As explained in the <a id="_idIndexMarker372"/>previous section, we need to override this method in order to declare the properties that will be replicated (more on this in a moment).</p>
<p>All the necessary setup for implementing replication in our two properties has been completed, but a few additional elements still need to be incorporated to ensure everything works properly. We need to broadcast some information whenever these properties change – this will come in handy when you implement a user interface later in this chapter.</p>
<p>To implement such <a id="_idIndexMarker373"/>functionality, you’ll be using <strong class="bold">delegates</strong>. You may be already familiar with this topic in C++, but you should be aware that, in Unreal Engine, a delegate provides a way to call member functions on C++ objects in a generic, type-safe manner through dedicated macros.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you want more information about the types of delegates supported by Unreal Engine and how they can be used in your project, check out the official documentation, which can be found here: <a href="https://docs.unrealengine.com/5.1/en-US/delegates-and-lamba-functions-in-unreal-engine/">https://docs.unrealengine.com/5.1/en-US/delegates-and-lamba-functions-in-unreal-engine/</a>.</p>
<p>As we want broadcast events for the two properties, we will be declaring two delegates – one for each property. At the beginning of the header file, just before the <code>UCLASS()</code> declaration, add the following code:</p>
<pre class="source-code">
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnXpChanged, int32, NewXp);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCharacterLevelUp, int32, NewLevelXp);</pre>
<p>These two lines are pretty similar – they<a id="_idIndexMarker374"/> both declare a <code>Broadcast()</code> method to notify every listener of changes in your <a id="_idIndexMarker375"/>system. We will use these features in our Blueprint classes to bind events and react accordingly.</p>
<p>Let’s declare our <code>delegate</code> function. Create a <code>protected</code> section, and add the following two lines of code, which will be used to broadcast the events:</p>
<pre class="source-code">
UPROPERTY(BlueprintAssignable, Category = "Events")
FOnXpChanged OnXpChanged;
UPROPERTY(BlueprintAssignable, Category = "Events")
FOnCharacterLevelUp OnCharacterLevelUp;</pre>
<p>As their purpose is self-explanatory, I guess it’s time stop talking and start writing down the implementation!</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor139"/>Implementing the PlayerState logic</h2>
<p>Now that all the <a id="_idIndexMarker376"/>properties and methods have been declared, you are going to implement the PlayerState logic – whenever the character gains some experience, you should check whether it has reached enough points to level up. Experience points gained and level-ups should be broadcast to the system, in order to keep everything synchronized.</p>
<p>Start by opening the <code>US_PlayerState.cpp</code> file and adding the required <code>include</code> declarations:</p>
<pre class="source-code">
#include "US_Character.h"
#include "US_CharacterStats.h"
#include "Net/UnrealNetwork.h"</pre>
<p>Next, add the implementation for the <code>GetLifetimeReplicatedProps()</code> method:</p>
<pre class="source-code">
void AUS_PlayerState::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const
{
 Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 DOREPLIFETIME_CONDITION(AUS_PlayerState, Xp, COND_OwnerOnly);
 DOREPLIFETIME_CONDITION(AUS_PlayerState, CharacterLevel, COND_OwnerOnly);
}</pre>
<p>As you can see, we are using the <code>DOREPLIFETIME_CONDITION()</code> macro, introduced in the previous section, to declare that the <code>Xp</code> and <code>CharacterLevel</code> properties should be replicated – in this case, we just want the property to be replicated on the owning player of the character (i.e., in the player’s client), and we do so by using the <code>COND_OwnerOnly</code> flag.</p>
<p>Next, add the<a id="_idIndexMarker377"/> implementation for the <code>AddXp()</code> method using the following code:</p>
<pre class="source-code">
void AUS_PlayerState::AddXp(const int32 Value)
{
 Xp += Value;
 OnXpChanged.Broadcast(Xp);
 GEngine-&gt;AddOnScreenDebugMessage(0, 5.f, FColor::Yellow, FString::Printf(TEXT("Total Xp: %d"), Value));
 if (const auto Character = Cast&lt;AUS_Character&gt;(GetPawn()))
 {
  if(Character-&gt;GetCharacterStats()-&gt;NextLevelXp &lt; Xp)
  {
   GEngine-&gt;AddOnScreenDebugMessage(3, 5.f, FColor::Red, TEXT("Level Up!"));
   CharacterLevel++;
   Character-&gt;UpdateCharacterStats(CharacterLevel);
   OnCharacterLevelUp.Broadcast(CharacterLevel);
  }
 }
}</pre>
<p>Here, whenever we receive an experience point update, we simply add the value to the character pool (i.e., the <code>Xp</code> property). Next, we ascertain that the character is an <code>AUS_Character</code> type through a cast and, if the cast is successful, we retrieve its statistics to check whether it should level up. If the check is successful, we simply increase the character level and call the <code>UpdateCharacterStats()</code> method to make the thief update<a id="_idIndexMarker378"/> the skill row. As we change the values for the properties, we then broadcast the new value to all listeners. A couple of (temporary) debug messages complete the code.</p>
<p>The PlayerState is now almost finished – we just need to broadcast the values to the clients whenever values are updated from the server side. To do so, add this last block of code to the file:</p>
<pre class="source-code">
void AUS_PlayerState::OnRep_Xp(int32 OldValue) const
{
 OnXpChanged.Broadcast(Xp);
}
void AUS_PlayerState::OnRep_CharacterLevelUp(int32 OldValue) const
{
 OnCharacterLevelUp.Broadcast(CharacterLevel);
}</pre>
<p>The broadcast call is self-explanatory – every registered Actor will receive the notification, along with the new value for the <code>Xp</code> and <code>CharacterLevel</code> properties.</p>
<p>So, in the preceding steps, you have successfully developed a fully operational replication system that effectively manages the character experience gained and skill development. I’m aware that the task at hand may feel daunting and even sometimes counter-intuitive, but <a id="_idIndexMarker379"/>with time and practice, you can rest assured that everything will become easier and more manageable!</p>
<p>There’s still something missing in our game: actual experience points. Let’s not waste any time and work on adding an item that our character can use to gain experience points. In the next steps, you’ll be creating some coins, starting with the previously created <code>US_BasePickup</code> class, to grant your thief the much-desired experience.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor140"/>Adding coin pickups to the level</h2>
<p>So, we are ready to <a id="_idIndexMarker380"/>create some coins that will be used in the game to add experience points to the character – this will be a simple Blueprint that will be spawned whenever enemies are killed or that will be available in the level.</p>
<p>To do this, go back to Unreal Editor and compile the project, in order to update it with all your improvements. Then, navigate to the <code>Blueprints</code> folder and complete the following steps:</p>
<ol>
<li>Right-click in the Content Browser and select <strong class="bold">Blueprint Class</strong> | <strong class="bold">US_BasePickup</strong> to create a new Blueprint from it.</li>
<li>Name the Blueprint <code>BP_GoldCoinPickup</code> and double-click on it to open it.</li>
<li>In the <strong class="bold">Components</strong> panel, select the <strong class="bold">Mesh</strong> component and assign to the <strong class="bold">Static Mesh</strong> attribute the <strong class="bold">coin</strong> static mesh. Change its scale to <strong class="bold">2</strong>, in order to make it more visible in the game.</li>
</ol>
<p>Your Blueprint <a id="_idIndexMarker381"/>should now be similar to the one shown in <em class="italic">Figure 6</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 6.4 – The gold coin Blueprint" src="img/Figure_06_04_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – The gold coin Blueprint</p>
<p>Now that the pickup has a base shape, it’s time to add some code logic to make things fully functional. Open the <strong class="bold">Event Graph</strong> tab and take the following steps:</p>
<ol>
<li value="4">Create a variable of type <strong class="bold">Integer</strong> and call it <strong class="bold">EarnedXp</strong>, giving it a default value of <strong class="bold">5</strong>.</li>
<li>Right-click in the canvas and look for <strong class="bold">Event Pickup</strong>, adding it to the graph.</li>
<li>Add a <strong class="bold">Cast To US_PlayerState</strong> node and connect its incoming execution pin to the outgoing execution pin of the event.</li>
<li>Click and drag from the <strong class="bold">Owning Character</strong> pin of the <strong class="bold">Event</strong> node and, after releasing the button, add a <strong class="bold">Get PlayerState</strong> node from the options that appear.</li>
<li>Connect the <strong class="bold">PlayerState</strong> outgoing pin to the <strong class="bold">Object</strong> pin of the <strong class="bold">Cast</strong> node.</li>
<li>Click and drag<a id="_idIndexMarker382"/> from the outgoing <strong class="bold">As Us PlayerState</strong> pin to create an <strong class="bold">Add </strong><strong class="bold">Xp</strong> node.</li>
<li>Connect the success execution pin of the cast node to the incoming execution pin of the <strong class="bold">Add </strong><strong class="bold">Xp</strong> node.</li>
<li>Drag a <strong class="bold">Get Earned Xp</strong> node from the <strong class="bold">Variables</strong> section into the canvas and connect its pin to the <strong class="bold">Value</strong> pin of the <strong class="bold">Add </strong><strong class="bold">Xp</strong> node.</li>
<li>Finally, add a <strong class="bold">Destroy Actor</strong> node and connect it to the outgoing execution pin of the <strong class="bold">Add </strong><strong class="bold">Xp</strong> node.</li>
</ol>
<p>The final result of the graph is shown in <em class="italic">Figure 6</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 6.5 – The Coin Event graph" src="img/Figure_06_05_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – The Coin Event graph</p>
<p>As you can see, the visual scripting code is quite straightforward – whenever a character picks up a coin, its PlayerState will be updated with the experience points granted by it.</p>
<p>To test the game, just drag a bunch of coins inside your level and play the game. Every time a character picks up a coin, you should see a display message, and when the character has enough experience, you should get another message, the level-up one.</p>
<p>It should be noted that, in the previous code, the pickup event will be called both on the client and on the server – this is something that should not be done as it may provoke issues in your game. Luckily, in this case, the PlayerState will correctly handle the data, so we don’t have to <a id="_idIndexMarker383"/>worry about it. You will learn how to handle trickier situations in <a href="B18203_06.xhtml#_idTextAnchor125"><em class="italic">Chapter 6</em></a>, <em class="italic">Replicating Properties </em><em class="italic">O</em><em class="italic">ver </em><em class="italic">the Network</em>.</p>
<p>As an extra exercise, you can add a floating animation to the coin, just like you did for the spell book in <a href="B18203_05.xhtml#_idTextAnchor107"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing Actors in a </em><em class="italic">Multiplayer Environment</em>.</p>
<h3>Adding coin subclasses</h3>
<p>As an optional step, you can <a id="_idIndexMarker384"/>create different coin pickups with different values for experience points. Here’s how to do so:</p>
<ol>
<li>Right-click on <code>BP_SilverCoinPickup</code>.</li>
<li>Assign a value of <strong class="bold">3</strong> to <strong class="bold">Earned Xp</strong> and <strong class="bold">MI_Metal</strong> as the mesh material.</li>
</ol>
<p>To provide your character with various items to search for, repeat this step as many times as you desire. This will grant your character a diverse set of treasures to seek out.</p>
<p>In this section, you have created a level-up system for your thief hero. With the help of replication, a character will get the correct level-up notification upon reaching enough experience points. At the moment, this can be achieved by collecting coin pickups around the level – later on, you’ll spawn treasure upon defeating those nasty Lichlord minions!</p>
<p>In the next section, I will guide you through the creation of a simple UI that will show the character level and the experience points that have been gained; you’ll perform this task by listening to PlayerState notifications and reacting accordingly.</p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor141"/>Adding a HUD to the game</h1>
<p>In this section, you will create a <strong class="bold">Heads Up Display</strong> (<strong class="bold">HUD</strong>) for the game that will assist in monitoring the player character’s progress during the game. As you may already know, the best way to create <a id="_idIndexMarker385"/>such information is through the <strong class="bold">Unreal Motion Graphics</strong> (<strong class="bold">UMG</strong>) system – a GUI-based editor that allows developers to <a id="_idIndexMarker386"/>create user interface elements for their game, such as menus, HUDs, and other display screens. You’ll be using this system to create the HUD widget with the relative info.</p>
<p>What we need to show at the moment is quite simple – one set of text showing the character’s experience points and another set showing the level.</p>
<p>Let’s start by creating the Blueprint and the visual elements.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor142"/>Creating the Widget Blueprint</h2>
<p>To create the <a id="_idIndexMarker387"/>Widget Blueprint, within Unreal Editor, take the following steps:</p>
<ol>
<li>Open your <code>Blueprints</code> folder, right-click on the Content Browser, and select <code>WB_HUD</code> and double-click on the asset to open it.</li>
<li>Drag a <strong class="bold">Canvas</strong> element from the <strong class="bold">Palette</strong> tab into the <strong class="bold">Designer</strong> view. This canvas will act as the <a id="_idIndexMarker388"/>main container for your visual elements.</li>
<li>Drag a <strong class="bold">Text</strong> element into the previously added <strong class="bold">Canvas</strong> and call it <strong class="bold">XpLabel</strong>. Make sure that the <strong class="bold">Is Variable</strong> field in the <strong class="bold">Details</strong> panel is checked to expose this element in the graph you’ll be using later.</li>
<li>Position the label somewhere on the canvas that suits your needs; in my case, I opted for the top-left corner of the screen.</li>
<li>Drag another <strong class="bold">Text</strong> element into the <strong class="bold">Canvas</strong> instance and call it <strong class="bold">CharacterLevelLabel</strong>. Again, make sure that the <strong class="bold">Is Variable</strong> field in the <strong class="bold">Details</strong> panel is checked to expose this element in the graph you’ll be using later.</li>
<li>Position the label somewhere on the canvas that suits your needs; in my case, I opted for the<a id="_idIndexMarker389"/> top-right corner of the screen.</li>
</ol>
<p>The final result of <a id="_idIndexMarker390"/>your HUD should be similar to <em class="italic">Figure 6</em><em class="italic">.6</em>:</p>
<div><div><img alt="Figure 6.6 – The HUD designer panel" src="img/Figure_06_06_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – The HUD designer panel</p>
<p>Now that you have created the widget, it’s time to add some Visual Scripting code to make it fully functional.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor143"/>Adding code logic to the Widget Blueprint</h2>
<p>In the following steps, you’ll <a id="_idIndexMarker391"/>add some code logic to the Blueprint, in order to listen to events from the PlayerState and react accordingly.</p>
<h3>Creating a custom event for the experience points label</h3>
<p>Let’s start by creating a custom event that will update the experience points label. To do this, open the <strong class="bold">Graph</strong> panel of your widget and take the following steps:</p>
<ol>
<li>Create a custom <a id="_idIndexMarker392"/>event and call it <code>OnXpChanged_Event</code>.</li>
<li>Select it and, in the <code>NewXp</code>.</li>
<li>From the <strong class="bold">MyBlueprint</strong> panel, drag a getter node for <strong class="bold">XpLabel</strong>.</li>
<li>From the <strong class="bold">XpLabel</strong> outgoing pin, click and drag, adding a <strong class="bold">SetText (</strong><strong class="bold">Text)</strong> node.</li>
<li>Connect the <strong class="bold">OnXpChanged_Event</strong> execution pin to the incoming <strong class="bold">SetText (Text)</strong> execution pin.</li>
<li>Connect the <strong class="bold">New Xp</strong> pin of the <strong class="bold">Event</strong> node to the <strong class="bold">In Text</strong> pin of the <strong class="bold">SetText (Text)</strong> node. This operation will automatically add a <strong class="bold">To Text (Integer)</strong> node converter.</li>
</ol>
<p>The final result of this piece of code is shown in <em class="italic">Figure 6</em><em class="italic">.7</em>:</p>
<div><div><img alt="Figure 6.7 – The Xp custom event" src="img/Figure_06_07_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – The Xp custom event</p>
<p>As an additional, optional step, you may want to add an <code>Experience Points</code> (for example, <code>Experience </code><code>Points: 150</code>).</p>
<p>Now that you have a custom event to handle the experience points label, it’s time to do the same for the character level.</p>
<h3>Creating a custom event for the character level label</h3>
<p>Let’s now create a custom event that <a id="_idIndexMarker393"/>will update the character level label:</p>
<ol>
<li>Create a custom event and call it <code>OnCharacterLevelUp_Event</code>.</li>
<li>Select it and, in the <code>NewLevel</code>.</li>
<li>From the <strong class="bold">MyBlueprint</strong> panel, drag a getter node for <strong class="bold">CharacterLevelLabel</strong>.</li>
<li>From the <strong class="bold">CharacterLevelLabel</strong> outgoing pin, click and drag and, after releasing the mouse button, select a <strong class="bold">SetText (Text)</strong> node from the options that appear.</li>
<li>Connect the <strong class="bold">OnLevelLabelChanged_Event</strong> execution pin to the incoming <strong class="bold">SetText (Text)</strong> execution pin.</li>
<li>Connect the <strong class="bold">New Level</strong> pin of the <strong class="bold">Event</strong> node to the <strong class="bold">In Text</strong> pin of the <strong class="bold">SetText (Text)</strong> node. This operation will automatically add a <strong class="bold">To Text (Integer)</strong> node converter.</li>
</ol>
<p>The final result of this piece of code is shown in <em class="italic">Figure 6</em><em class="italic">.8</em>:</p>
<div><div><img alt="Figure 6.8 – The character level custom event" src="img/Figure_06_08_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – The character level custom event</p>
<p>Just like the previous label, you may want to use the <code>Level:</code> (for example, <code>Level: 1</code>).</p>
<p>Now that you have a<a id="_idIndexMarker394"/> custom event to handle the character level label, it’s time to bind these events to the notifications broadcast by the PlayerState.</p>
<h3>Binding to PlayerState events</h3>
<p>In this final step of the <a id="_idIndexMarker395"/>Widget Blueprint, you will bind the previously created events to the PlayerState, in order to update the HUD every time an update notification is dispatched:</p>
<ol>
<li>Add an <strong class="bold">Event on Initialized</strong> node to the graph. This node is executed only once during the game (i.e., when the object has been initialized) and is the best place to add bindings.</li>
<li>Connect the event to a <strong class="bold">Delay</strong> node with <strong class="bold">Duration</strong> equal to <strong class="bold">0,2</strong>. As the PlayerState won’t be available at initialization time, waiting until it is available is a quick solution to solve the issue.</li>
<li>Add a <strong class="bold">Branch</strong> node and connect its incoming execution pin to the <strong class="bold">Completed</strong> execution pin of the <strong class="bold">Delay</strong> node. Connect the <strong class="bold">False</strong> execution pin of the <strong class="bold">Branch</strong> node to the incoming execution pin of the <strong class="bold">Delay</strong> node; this will create a loop that will go on until the PlayerState has been properly initialized.</li>
</ol>
<p>Now we are going to recover the PlayerState from the player owning this widget.</p>
<ol>
<li value="4">Add a <strong class="bold">Get Owning Player</strong> node to the graph. This node returns the player that is controlling (i.e., owns) the HUD.</li>
<li>From the <strong class="bold">Return Value</strong> pin of this node, click and drag to create a <strong class="bold">Get </strong><strong class="bold">PlayerState</strong> node.</li>
<li>From the <code>US_PlayerState</code> class, we<a id="_idIndexMarker396"/> are pretty sure that we are going to recover that type of PlayerState, so we don’t need to worry about validation.</li>
<li>Connect the <strong class="bold">Success</strong> pin of the <strong class="bold">Cast To US_PlayerState</strong> node to the <strong class="bold">Condition</strong> pin of the <strong class="bold">Branch</strong> node.</li>
<li>From the outgoing <code>PlayerState</code>.</li>
<li>Connect the <strong class="bold">True</strong> execution pin of the <strong class="bold">Branch</strong> node to the incoming <strong class="bold">Set PlayerState</strong> execution pin.</li>
</ol>
<p>The visual scripting code created so far is shown in <em class="italic">Figure 6</em><em class="italic">.9</em>:</p>
<div><div><img alt="Figure 6.9 – The first part of the PlayerState binding" src="img/Figure_06_09_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – The first part of the PlayerState binding</p>
<p>Now that you have a reference to the PlayerState, it’s time to bind the custom events to the delegate<a id="_idIndexMarker397"/> you created in the previous sections.</p>
<ol>
<li value="10">From the outgoing pin of the <code>US_PlayerState</code> class.</li>
<li>Connect the outgoing execution pin of <strong class="bold">Set PlayerState</strong> to the incoming execution pin of the <strong class="bold">Bind Event to On Xp </strong><strong class="bold">Changed</strong> node.</li>
<li>From the <strong class="bold">Event</strong> pin of the bind node, click and drag to add a <strong class="bold">Create Event</strong> node. This node has a drop-down menu – here, select <strong class="bold">OnXpChanged_Event (NewXp)</strong>, which will execute the <strong class="bold">OnXpChanged_Event</strong> custom event whenever the system receives the corresponding notification from the PlayerState.</li>
<li>Connect the outgoing execution pin of the <strong class="bold">Bind </strong><strong class="bold">Event to On Xp Changed</strong> node to an <strong class="bold">On Xp Changed Event</strong> node; this will call the event upon initialization, to update the HUD.</li>
<li>From the <strong class="bold">Variables</strong> section, drag a <strong class="bold">Get PlayerState</strong> node and from it, create a <strong class="bold">Get Xp</strong> node. Connect the outgoing pin of the <strong class="bold">Get Xp</strong> node to the <strong class="bold">New Xp</strong> pin of the <strong class="bold">On Xp Changed </strong><strong class="bold">Event</strong> node.</li>
</ol>
<p>This portion of the<a id="_idIndexMarker398"/> Visual Scripting code is shown in <em class="italic">Figure 6</em><em class="italic">.10</em>:</p>
<div><div><img alt="Figure 6.10 – The second part of the PlayerState binding" src="img/Figure_06_10_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – The second part of the PlayerState binding</p>
<p>The last part of the binding phase is almost identical to the steps you have just taken, with the exception that we are creating a binding for the player level.</p>
<ol>
<li value="15">From the outgoing pin of the <strong class="bold">On Xp Changed Event</strong> node, click and drag to create a <strong class="bold">Bind Event to On Character Level </strong><strong class="bold">Up</strong> node.</li>
<li>Drag a <strong class="bold">Get PlayerState</strong> node from the <strong class="bold">Variables</strong> section and connect it to the <strong class="bold">Target</strong> pin of the <strong class="bold">Bind Event to On Character Level </strong><strong class="bold">Up</strong> node.</li>
<li>From the <strong class="bold">Event</strong> pin of the <strong class="bold">Bind </strong><strong class="bold">Event to On Character Level Up</strong> node, click and drag to add a <strong class="bold">Create Event</strong> node. From the drop-down menu, select <strong class="bold">OnCharacterLevelUp_Event (NewLevel)</strong>. This selection will execute the <strong class="bold">OnCharacterLevelUp_Event</strong> custom event whenever the system receives the corresponding notification from the PlayerState.</li>
<li>Connect the outgoing execution pin of the <strong class="bold">Bind</strong> node to an <strong class="bold">On Character Level Up Event</strong> node; this will call the<a id="_idIndexMarker399"/> event upon initialization, to update the HUD.</li>
<li>From the <strong class="bold">Variables</strong> section, drag a <strong class="bold">Get PlayerState</strong> node to create a <strong class="bold">Get Character Level</strong> node. Connect the outgoing pin of the <strong class="bold">Get Character Level</strong> node to the <strong class="bold">New Level</strong> pin of the <strong class="bold">On Character Level Up </strong><strong class="bold">Event</strong> node.</li>
</ol>
<p>This final part of the graph is shown in <em class="italic">Figure 6</em><em class="italic">.11</em>:</p>
<div><div><img alt="Figure 6.11 – The final part of the PlayerState binding" src="img/Figure_06_11_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – The final part of the PlayerState binding</p>
<p>You have finally created all the bindings to listen to any PlayerState notifications and update the HUD<a id="_idIndexMarker400"/> accordingly. It’s now time to add the final step – showing the HUD in-game.</p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor144"/>Adding the HUD to the character</h2>
<p>Now you will add the HUD to the <a id="_idIndexMarker401"/>player viewport. If you are already familiar with Unreal Engine user interfaces in standalone games, you may already know how things work.</p>
<p>However, you should be aware that, in a multiplayer environment, a user interface widget should be attached to the game viewport only if the character is controlled locally (i.e., is the owning client). If you don’t check whether the character creating the widget is controlled locally, you will create a widget for each character spawned in the level – including those controlled by other players and replicated in the client. Having a cluttered mess of superimposed HUDs is obviously something you don’t want to have in your game!</p>
<p>To add the HUD to the character, follow these steps:</p>
<ol>
<li>Start by finding the <strong class="bold">BP_Character</strong> Blueprint and opening it.</li>
<li>In the Event Graph, find the <strong class="bold">Begin Play</strong> event. Then, add a <strong class="bold">Branch</strong> node to the execution pin of the event.</li>
<li>Connect the <strong class="bold">Condition</strong> pin of the <strong class="bold">Branch</strong> node to an <strong class="bold">Is Locally Controlled</strong> node – this will guarantee we are attaching the HUD only to the character controlled by the client.</li>
<li>From the <strong class="bold">True</strong> execution pin of the <strong class="bold">Branch</strong> node, create a <strong class="bold">Create Widget</strong> node. From the <strong class="bold">Class</strong> drop-down menu, choose <strong class="bold">WB_HUD</strong> to select our HUD.</li>
<li>Connect the outgoing execution pin of the <strong class="bold">Create Widget</strong> node to an <strong class="bold">Add to Viewport</strong> node. Connect the <strong class="bold">Return Value</strong> pin to the <strong class="bold">Target</strong> pin.</li>
</ol>
<p>The final result of the graph can be seen in <em class="italic">Figure 6</em><em class="italic">.12</em>:</p>
<div><div><img alt="Figure 6.12 – Adding the HUD to the viewport" src="img/Figure_06_12_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – Adding the HUD to the viewport</p>
<p>The previous Visual Scripting code is pretty easy to understand, but it is important to mention that the viewport is only added to the character controlled by the client, as having multiple<a id="_idIndexMarker402"/> HUDs overlaying each other would not be desirable!</p>
<p>Now that everything has been properly set, you are going to test your game to see how it works!</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor145"/>Testing the game</h2>
<p>To test the game, start <a id="_idIndexMarker403"/>playing it as a listen server and check that everything works fine. In particular, you should see the following behaviors:</p>
<ul>
<li>At the start of the game, the HUD should show 0 experience points and the character level equal to 1</li>
<li>Every time a character picks a coin up, the HUD should update the total experience points</li>
<li>If the target experience points are reached, the player should level up and the HUD will show the new level</li>
</ul>
<p>The final result should be pretty similar to the one shown in <em class="italic">Figure 6</em><em class="italic">.13</em>:</p>
<div><div><img alt="Figure 6.13 – The Final HUD" src="img/Figure_06_13_B18203.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – The Final HUD</p>
<p>If everything goes<a id="_idIndexMarker404"/> according to plan, you’re all set to embark on the next exciting chapter of the Lichlord multiplayer epic: client-server communication!</p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor146"/>Summary</h1>
<p>In this chapter, I have introduced you to one of the most important topics in the Unreal Engine multiplayer framework: replication.</p>
<p>As a first step, you created some statistics for the player, in order to make your gameplay more flexible. You did this through structures and data tables – a topic that will come in handy even if you are developing a standalone game.</p>
<p>Next, I explained the topic of property replication and how to apply it to your project. Once the main concepts were defined, you started using them on the PlayerState, in order to keep track of the character’s progress during gameplay.</p>
<p>As a last step, you created a HUD to show this progress to the player. Replication is mostly important here as each client should get its own updates and show them to the player.</p>
<p>In the next chapter, you’ll dive deeper into the mystical realm of replication, flexing your skills in the delicate art of calling methods from client to server and back again like it’s nobody’s business.</p>
<p>Get ready to take things to the next level – we’re about to climb the staircase of multiplayer development, two steps at a time!</p>
</div>
</body></html>