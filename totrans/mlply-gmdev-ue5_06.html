<html><head></head><body>
<div id="_idContainer104">
<h1 class="chapter-number" id="_idParaDest-124"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-125"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.2.1">Replicating Properties Over the Network</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Replication is an important concept when it comes to creating multiplayer games with Unreal Engine. </span><span class="koboSpan" id="kobo.3.2">In particular, </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">property replication</span></strong><span class="koboSpan" id="kobo.5.1"> allows for the synchronization of objects between multiple players, letting them interact in a shared environment. </span><span class="koboSpan" id="kobo.5.2">This feature also handles things such as character movement and physics calculations, ensuring everyone has a consistent experience and view of the game world, regardless of the platform type, and that no one has an advantage due to cheating or </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">latency issues.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, you’ll start working on replication, mainly focusing on property replication of your character skills. </span><span class="koboSpan" id="kobo.7.2">Next, starting from the base pickup you created in the last chapter, you’ll implement a coin pickup that will grant the character experience points that will give the character a level-up during gameplay. </span><span class="koboSpan" id="kobo.7.3">Finally, you’ll apply replication by updating a simple user interface that will show the character experience points </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">and level.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">At the end of this chapter, you will have a good grasp of how an Actor replicates in a multiplayer setting and the properties that come with it. </span><span class="koboSpan" id="kobo.9.2">Essentially, you’ll understand how Actors behave and operate in a </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">multi-player environment.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In the next sections, I will present the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Adding </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">character stats</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">property replication</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Handling </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">characters level-ups</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Adding a HUD to </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">the game</span></span></li>
</ul>
<h1 id="_idParaDest-126"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">To follow the topics presented in this chapter, you should have completed the previous ones and understood </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">their content.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">Additionally, if you would prefer to begin with code from the companion repository for this book, you can download the </span><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">.zip</span></strong><span class="koboSpan" id="kobo.26.1"> project files provided in this book’s companion </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">project repository:</span></span></p>
<p><a href="https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5"><span class="No-Break"><span class="koboSpan" id="kobo.28.1">https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.29.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">You can download the files that are up to date with the end of the last chapter by clicking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">Unreal Shadows – </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">Chapter 05</span></strong></span><strong class="source-inline"> </strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">End</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.34.1"> link.</span></span></p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.35.1">Adding character stats</span></h1>
<p><span class="koboSpan" id="kobo.36.1">Before introducing property replication and implementing it in the project, our thief hero needs to be ready for such a big step: that’s why I’ll guide you through the creation of a set of statistics that will be plugged into the </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">Character class.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">The first thing to do is to </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.39.1">define your character stats. </span><span class="koboSpan" id="kobo.39.2">In particular, you will need the </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">following data:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.41.1">A walk and a sprint speed, to handle the different paces of your character </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">during gameplay</span></span></li>
<li><span class="koboSpan" id="kobo.43.1">A damage multiplier to manage more powerful hits whenever the character </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">levels up</span></span></li>
<li><span class="koboSpan" id="kobo.45.1">A level-up value to check whenever the character has reached the </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">next level</span></span></li>
<li><span class="koboSpan" id="kobo.47.1">A stealth multiplier that will handle how much noise the character makes when walking </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">or sprinting</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.49.1">You may have noticed that your character has no health – that is because this is a stealth game and players will have to move carefully through the dungeon. </span><span class="koboSpan" id="kobo.49.2">Once they are discovered, they won’t have the option of facing a swarm of undead lackeys in this particular game! </span><span class="koboSpan" id="kobo.49.3">As a consequence, gameplay will be more focused on defeating enemies from a distance or slipping silently away </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">from them.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">With the previous information, you’ll create a data structure containing all the data points for initializing the character, and then you’ll create a data table that will let you manage the experience </span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.52.1">your thief will gain during gameplay. </span><span class="koboSpan" id="kobo.52.2">So, let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">get started.</span></span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.54.1">Creating the stats structure</span></h2>
<p><span class="koboSpan" id="kobo.55.1">To begin, you need to</span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.56.1"> create a structure that will include all the aforementioned statistics. </span><span class="koboSpan" id="kobo.56.2">As this is not a class, you won’t need to create it from Unreal Engine Editor but from the </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">IDE instead.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.58.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.59.1">Non-class entities cannot be made directly from within </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">Unreal Editor.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">Open your IDE and create a file in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">UnrealShadows_LOTL</span></strong><span class="koboSpan" id="kobo.63.1"> | </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">Source</span></strong><span class="koboSpan" id="kobo.65.1"> | </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">UnrealShadows_LOTL</span></strong><span class="koboSpan" id="kobo.67.1"> folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">US_CharacterStats.h</span></strong><span class="koboSpan" id="kobo.69.1"> (as this is a data structure, you won’t need a </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">.cpp</span></strong><span class="koboSpan" id="kobo.71.1"> file). </span><span class="koboSpan" id="kobo.71.2">Then, open the file and insert the </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.73.1">
#pragma once
#include "CoreMinimal.h"
#include "Engine/DataTable.h"
#include "US_CharacterStats.generated.h"
USTRUCT(BlueprintType)
struct UNREALSHADOWS_LOTL_API FUS_CharacterStats : public FTableRowBase
{
 GENERATED_BODY()
 UPROPERTY(BlueprintReadWrite, EditAnywhere)
 float WalkSpeed = 200.0f;
 UPROPERTY(BlueprintReadWrite, EditAnywhere)
 float SprintSpeed = 400.0f;
 UPROPERTY(BlueprintReadWrite, EditAnywhere)
 float DamageMultiplier = 1.0f;
 UPROPERTY(BlueprintReadWrite, EditAnywhere)
 int32 NextLevelXp = 10.0f;
 UPROPERTY(BlueprintReadWrite, EditAnywhere)
 float StealthMultiplier = 1.0f;
};</span></pre>
<p><span class="koboSpan" id="kobo.74.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">include</span></strong><span class="koboSpan" id="kobo.76.1"> section is</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.77.1"> self-explanatory – after that, along with the standard C++ </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">struct</span></strong><span class="koboSpan" id="kobo.79.1"> keyword to declare a structure, you will notice an </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">USTRUCT()</span></strong><span class="koboSpan" id="kobo.81.1"> declaration instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">UCLASS()</span></strong><span class="koboSpan" id="kobo.83.1"> and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">F</span></strong><span class="koboSpan" id="kobo.85.1"> prefix on the structure name (i.e., </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">FUS_CharacterStats</span></strong><span class="koboSpan" id="kobo.87.1">). </span><span class="koboSpan" id="kobo.87.2">This is the standard method to declare a structure in Unreal Engine. </span><span class="koboSpan" id="kobo.87.3">Then, in order to let Unreal Editor create data tables from this structure (more on this in a few moments), the </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">FTableRowBase</span></strong><span class="koboSpan" id="kobo.89.1"> type </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">is extended.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">Inside the structure declaration, we are just adding a list of properties – all of them are marked </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">BlueprintReadWrite</span></strong><span class="koboSpan" id="kobo.93.1"> to let Blueprints access and modify the data, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">EditAnywhere</span></strong><span class="koboSpan" id="kobo.95.1"> to let you edit the values inside the data table you are going to create in the </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">next steps.</span></span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.97.1">Creating a stats data table</span></h2>
<p><span class="koboSpan" id="kobo.98.1">Now you have created a data structure for your character and are ready to create the actual data from it. </span><span class="koboSpan" id="kobo.98.2">In Unreal Engine, we will</span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.99.1"> use a </span><strong class="bold"><span class="koboSpan" id="kobo.100.1">DataTable</span></strong><span class="koboSpan" id="kobo.101.1"> object, a tabular structure that organizes interconnected data in a coherent and practical manner. </span><span class="koboSpan" id="kobo.101.2">The data fields can include any valid </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">UObject</span></strong><span class="koboSpan" id="kobo.103.1"> property – including asset references from the projects, such as</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.104.1"> materials </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">or textures.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">To create your character data table, see the </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.108.1">Open your </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">Blueprints</span></strong><span class="koboSpan" id="kobo.110.1"> folder in the </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">Content Browser.</span></span></li>
<li><span class="koboSpan" id="kobo.112.1">Compile your project in order to make the C++ structure available in </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">the Editor.</span></span></li>
<li><span class="koboSpan" id="kobo.114.1">Right-click in the Content Browser and select </span><strong class="bold"><span class="koboSpan" id="kobo.115.1">Miscellaneous</span></strong><span class="koboSpan" id="kobo.116.1"> | </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.117.1">Data Table</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.119.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">Pick Row Structure</span></strong><span class="koboSpan" id="kobo.121.1"> pop-up window, select </span><strong class="bold"><span class="koboSpan" id="kobo.122.1">US_CharacterStats</span></strong><span class="koboSpan" id="kobo.123.1"> from the drop-down menu, as depicted in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.124.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.125.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer091">
<span class="koboSpan" id="kobo.127.1"><img alt="Figure 6.1 – The data table creation panel" src="image/Figure_06_01_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.128.1">Figure 6.1 – The data table creation panel</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.129.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.130.1">OK</span></strong><span class="koboSpan" id="kobo.131.1"> button to generate the data table and name </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">US_CharacterStats</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.135.1">Double-click on the newly created asset to open it. </span><span class="koboSpan" id="kobo.135.2">You will get an empty dataset as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.136.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.137.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer092">
<span class="koboSpan" id="kobo.139.1"><img alt="Figure 6.2 – The empty data table" src="image/Figure_06_02_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.140.1">Figure 6.2 – The empty data table</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.141.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.142.1">A data table can also be generated by importing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">.csv</span></strong><span class="koboSpan" id="kobo.144.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">.json</span></strong><span class="koboSpan" id="kobo.146.1"> file into your project. </span><span class="koboSpan" id="kobo.146.2">Additionally, Unreal Engine will let you easily export your project tables in </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">.csv</span></strong><span class="koboSpan" id="kobo.148.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">.json</span></strong><span class="koboSpan" id="kobo.150.1"> formats. </span><span class="koboSpan" id="kobo.150.2">For more information about the importing and exporting processes, check the official documentation linked </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">here: </span></span><a href="https://docs.unrealengine.com/5.1/en-US/data-driven-gameplay-elements-in-unreal-engine/"><span class="No-Break"><span class="koboSpan" id="kobo.152.1">https://docs.unrealengine.com/5.1/en-US/data-driven-gameplay-elements-in-unreal-engine/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.153.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">With your table open, it’s time to add some data rows organized by character levels – you do want to let your </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.155.1">character grow when they gain enough experience, </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">don’t you?</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">Let’s start by adding a single row for your character </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">base level:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.159.1">Click on the </span><strong class="bold"><span class="koboSpan" id="kobo.160.1">Add</span></strong><span class="koboSpan" id="kobo.161.1"> button in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.162.1">Table</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.163.1"> panel.</span></span></li>
<li><span class="koboSpan" id="kobo.164.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.165.1">Row Name</span></strong><span class="koboSpan" id="kobo.166.1"> field will be named </span><strong class="bold"><span class="koboSpan" id="kobo.167.1">NewRow</span></strong><span class="koboSpan" id="kobo.168.1">; however, right-click on it and select </span><strong class="bold"><span class="koboSpan" id="kobo.169.1">Rename</span></strong><span class="koboSpan" id="kobo.170.1">. </span><span class="koboSpan" id="kobo.170.2">Change the name of this field </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">level_01</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.174.1">You are now ready to set some stats for the first experience level of your character. </span><span class="koboSpan" id="kobo.174.2">Look for the </span><strong class="bold"><span class="koboSpan" id="kobo.175.1">Row Editor</span></strong><span class="koboSpan" id="kobo.176.1"> section in the data table and insert the </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">following values:</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.178.1">Walk Speed</span></strong><span class="koboSpan" id="kobo.179.1"> = </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">250,0</span></strong></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.181.1">Sprint Speed</span></strong><span class="koboSpan" id="kobo.182.1"> = </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">800,0</span></strong></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.184.1">Damage Multiplier</span></strong><span class="koboSpan" id="kobo.185.1"> = </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">1,0</span></strong></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.187.1">Next Level Xp</span></strong><span class="koboSpan" id="kobo.188.1"> = </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">10</span></strong></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.190.1">Stealth Multiplier</span></strong><span class="koboSpan" id="kobo.191.1"> = </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">1,0</span></strong></span></li></ul></li>
</ol>
<p><span class="koboSpan" id="kobo.193.1">The final result should </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.194.1">be the same as the settings shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.195.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.196.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer093">
<span class="koboSpan" id="kobo.198.1"><img alt="Figure 6.3 – Settings for the level_01 character" src="image/Figure_06_03_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.199.1">Figure 6.3 – Settings for the level_01 character</span></p>
<p><span class="koboSpan" id="kobo.200.1">We are going to add a couple more levels to handle the experience growth of the character during gameplay. </span><span class="koboSpan" id="kobo.200.2">Repeat the same steps as before, but call the two new rows </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">level_02</span></strong><span class="koboSpan" id="kobo.202.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">level_03</span></strong><span class="koboSpan" id="kobo.204.1"> respectively. </span><span class="koboSpan" id="kobo.204.2">Then use the following values for the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.205.1">level_02</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.206.1"> row:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.207.1">Walk Speed</span></strong><span class="koboSpan" id="kobo.208.1"> = </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">275,0</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.210.1">Sprint Speed</span></strong><span class="koboSpan" id="kobo.211.1"> = </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">850,0</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.213.1">Damage Multiplier</span></strong><span class="koboSpan" id="kobo.214.1"> = </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">1,1</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.216.1">Next Level Xp</span></strong><span class="koboSpan" id="kobo.217.1"> = </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">25</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.219.1">Stealth Multiplier</span></strong><span class="koboSpan" id="kobo.220.1"> = </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">1,5</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.222.1">And add the </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.223.1">following values for the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.224.1">level_03</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.225.1"> row:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.226.1">Walk Speed</span></strong><span class="koboSpan" id="kobo.227.1"> = </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">300,0</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.229.1">Sprint Speed</span></strong><span class="koboSpan" id="kobo.230.1"> = </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">900,0</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.232.1">Damage Multiplier</span></strong><span class="koboSpan" id="kobo.233.1"> = </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">1,0</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.235.1">Next Level Xp</span></strong><span class="koboSpan" id="kobo.236.1"> = </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">50</span></strong></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.238.1">Stealth Multiplier</span></strong><span class="koboSpan" id="kobo.239.1"> = </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">2</span></strong></li>
</ul>
<p><span class="koboSpan" id="kobo.241.1">These are purely indicative values – you are free to tweak them to suit your own needs and add as many additional levels as </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">you wish.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">Now that you have added a dataset for your character’s experience, you are ready to read the info included directly from your code. </span><span class="koboSpan" id="kobo.243.2">That’s why I need you to go back to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">US_Character.h</span></strong><span class="koboSpan" id="kobo.245.1"> header file to add the data </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">table declaration.</span></span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.247.1">Reading the data table from the character</span></h2>
<p><span class="koboSpan" id="kobo.248.1">In this section, you are going to</span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.249.1"> add the data table to the character in order to read its values depending on the experience level. </span><span class="koboSpan" id="kobo.249.2">The first thing to do is to add a reference to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">US_Character.h</span></strong><span class="koboSpan" id="kobo.251.1"> header file. </span><span class="koboSpan" id="kobo.251.2">So, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">private</span></strong><span class="koboSpan" id="kobo.253.1"> section of the header file, after all the existing declarations, add </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">this code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.255.1">
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Character Data", meta = (AllowPrivateAccess = "true"))
class UDataTable* CharacterDataTable;
struct FUS_CharacterStats* CharacterStats;</span></pre>
<p><span class="koboSpan" id="kobo.256.1">The first declaration will let you reference the data table directly from the child Blueprint Classes, while the structure declaration will let you reference a single row from the data table and use it as the </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">character statistics.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">After that, you will need to create a function that will allow the system to update the current level of the </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.259.1">character. </span><span class="koboSpan" id="kobo.259.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">public</span></strong><span class="koboSpan" id="kobo.261.1"> section, add the following </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">method declaration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.263.1">
void UpdateCharacterStats(int32 CharacterLevel);</span></pre>
<p><span class="koboSpan" id="kobo.264.1">The last thing you need to add to the class header is a getter function for the stats structure. </span><span class="koboSpan" id="kobo.264.2">Still in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">public</span></strong><span class="koboSpan" id="kobo.266.1"> section, just before the last closing bracket, add the following line </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.268.1">
FORCEINLINE FUS_CharacterStats* GetCharacterStats() const { return CharacterStats; }</span></pre>
<p><span class="koboSpan" id="kobo.269.1">You can now save this file and open </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">US_Character.cpp</span></strong><span class="koboSpan" id="kobo.271.1"> to handle the data retrieval. </span><span class="koboSpan" id="kobo.271.2">At the top of the file, add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">include</span></strong><span class="koboSpan" id="kobo.273.1"> declarations for the classes you’ll be using in </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">a moment:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.275.1">
#include "US_CharacterStats.h"
#include "Engine/DataTable.h"</span></pre>
<p><span class="koboSpan" id="kobo.276.1">Next, implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">UpdateCharacterStats()</span></strong><span class="koboSpan" id="kobo.278.1"> method by adding the following code at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.280.1">
void AUS_Character::UpdateCharacterStats(int32 CharacterLevel)
{
 if(CharacterDataTable)
 {
  TArray&lt;FUS_CharacterStats*&gt; CharacterStatsRows;
  CharacterDataTable-&gt;GetAllRows&lt;FUS_CharacterStats&gt;(TEXT("US_Character"), CharacterStatsRows);
  if(CharacterStatsRows.Num() &gt; 0)
  {
   const auto NewCharacterLevel = FMath::Clamp(CharacterLevel, 1, CharacterStatsRows.Num());
   CharacterStats = CharacterStatsRows[NewCharacterLevel - 1];
   GetCharacterMovement()-&gt;MaxWalkSpeed = GetCharacterStats()-&gt;WalkSpeed;
  }
 }
}</span></pre>
<p><span class="koboSpan" id="kobo.281.1">As you can see, first we check that the data table is referenced (you’ll add it later, from the character Blueprint) and then use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">GetAllRows&lt;T&gt;()</span></strong><span class="koboSpan" id="kobo.283.1"> method to fetch all the table rows into a local array (i.e., the </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">CharacterStatsRows</span></strong><span class="koboSpan" id="kobo.285.1"> variable). </span><span class="koboSpan" id="kobo.285.2">If there is at least one row in the</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.286.1"> data table, we get the one corresponding to the level of the character minus 1 (i.e., for a level 1 character, we will get the row number 0). </span><span class="koboSpan" id="kobo.286.2">Notice, as well, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">FMath::Clamp()</span></strong><span class="koboSpan" id="kobo.288.1"> method, which guarantees we are not trying to get a level value that’s higher than the available rows in </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">the dataset.</span></span></p>
<p><span class="koboSpan" id="kobo.290.1">After that, we retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">WalkSpeed</span></strong><span class="koboSpan" id="kobo.292.1"> column from the row and assign its value to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">MaxWalkSpeed</span></strong><span class="koboSpan" id="kobo.294.1"> property of the character movement component – this means that, if there is a data table assigned, your character will start the game with a value from the dataset and not from </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">the constructor.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">You are now ready to update your character stats to level 1 – something you are about to do in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">BeginPlay()</span></strong><span class="koboSpan" id="kobo.298.1"> function. </span><span class="koboSpan" id="kobo.298.2">To do so, inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">BeginPlay()</span></strong><span class="koboSpan" id="kobo.300.1"> function, and just before the closing bracket, add </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">this code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.302.1">
UpdateCharacterStats(1);</span></pre>
<p><span class="koboSpan" id="kobo.303.1">The last thing you need to do is to update the two sprint methods that, at the moment, are using hardcoded values </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.304.1">but need to use the data table stats. </span><span class="koboSpan" id="kobo.304.2">To do so, search for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">SprintStart()</span></strong><span class="koboSpan" id="kobo.306.1"> method and find the </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">following line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.308.1">
GetCharacterMovement()-&gt;MaxWalkSpeed = 3000.f;</span></pre>
<p><span class="koboSpan" id="kobo.309.1">Then, change it to the </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.311.1">
if (GetCharacterStats())
{
 GetCharacterMovement()-&gt;MaxWalkSpeed = GetCharacterStats()-&gt;SprintSpeed;
}</span></pre>
<p><span class="koboSpan" id="kobo.312.1">Let’s do the same with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">SprintEnd()</span></strong><span class="koboSpan" id="kobo.314.1"> method, which should be positioned just after the previous one. </span><span class="koboSpan" id="kobo.314.2">Find the </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">following line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.316.1">
GetCharacterMovement()-&gt;MaxWalkSpeed = 500.f;</span></pre>
<p><span class="koboSpan" id="kobo.317.1">Then change it using the following </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">code block</span></span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.320.1">
if(GetCharacterStats())
{
 GetCharacterMovement()-&gt;MaxWalkSpeed = GetCharacterStats()-&gt;WalkSpeed;
}</span></pre>
<p><span class="koboSpan" id="kobo.321.1">In both cases, the code is self-explanatory – we just check that there is valid data referenced in the character stats and assign the sprint or walk speed to the character </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">movement component.</span></span></p>
<p><span class="koboSpan" id="kobo.323.1">Now save your file and compile the project, just to be sure that everything is fine and ready for the </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">next step.</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">Your character is now ready to accept the data table we created at the beginning of </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">this chapter.</span></span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.327.1">Adding the data table to the character</span></h2>
<p><span class="koboSpan" id="kobo.328.1">To add the data table</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.329.1"> asset to the character, switch back to Unreal Editor and follow </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.331.1">Open the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.332.1">BP_Character</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.333.1"> Blueprint.</span></span></li>
<li><span class="koboSpan" id="kobo.334.1">Select the </span><strong class="bold"><span class="koboSpan" id="kobo.335.1">Class Defaults</span></strong><span class="koboSpan" id="kobo.336.1"> tab and, in the </span><strong class="bold"><span class="koboSpan" id="kobo.337.1">Details</span></strong><span class="koboSpan" id="kobo.338.1"> panel, look for the </span><strong class="bold"><span class="koboSpan" id="kobo.339.1">Character </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.340.1">Data</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.341.1"> category.</span></span></li>
<li><span class="koboSpan" id="kobo.342.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.343.1">Character Data Table</span></strong><span class="koboSpan" id="kobo.344.1"> attribute, click on the drop-down menu and </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.346.1">DT_CharacterStats</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.348.1">Your character is now ready to use the statistics from the dataset – even though the poor thief is locked into a level 1 experience level, later on, you will set them free in the dungeon and see how </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">they fare!</span></span></p>
<p><span class="koboSpan" id="kobo.350.1">Test the game to check that everything works properly. </span><span class="koboSpan" id="kobo.350.2">Just remember what I said in the previous chapter: movement is still buggy as the client and the server are trying to force the character to conform to different speed values, but you are nearing </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">the solution.</span></span></p>
<p><span class="koboSpan" id="kobo.352.1">So, in this section, you have improved the character by adding some statistics retrieved from a data table and using them to initialize some properties. </span><span class="koboSpan" id="kobo.352.2">At the moment, you have just used the movement ones, but don’t be afraid! </span><span class="koboSpan" id="kobo.352.3">Once the character is completed, everything will fall </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">into place.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">In the upcoming section, we’ll dive into the topic of property replication in Unreal – something that will come in handy when it’s time to level up your character and something you’ll be doing by the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">this chapter.</span></span></p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.356.1">Understanding property replication</span></h1>
<p><span class="koboSpan" id="kobo.357.1">As stated before, property </span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.358.1">replication allows for the synchronization of objects in an Unreal multiplayer environment. </span><span class="koboSpan" id="kobo.358.2">It should be noted that, as the server is authoritative, updates will never be sent by the client. </span><span class="koboSpan" id="kobo.358.3">Obviously, the client may (politely) ask the server to change a property value, and the server will behave accordingly. </span><span class="koboSpan" id="kobo.358.4">Additionally, property replication acts as a reliable service: consequently, the Actor on the client will have the same value as the server sooner </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">or later.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">This means that if you’re trying to modify, from the client, a property that is replicated, any changes you make to that property will only be temporary. </span><span class="koboSpan" id="kobo.360.2">You should be already familiar with this topic as the character’s movement logic, at the moment, is a bit buggy – we are trying to make the character run from the client, but the server is blocking our commands as soon as the network </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">is updated.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">This is happening because, as soon as the server sends an update to the client with a new value for that property, any changes that you made locally on the client will be overwritten and</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.363.1"> replaced with the new, correct value from the server. </span><span class="koboSpan" id="kobo.363.2">Consequently, if the server does not update frequently, it may take a while for the client to be notified about the new, </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">correct value.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">Fixing that nasty bug is something we will be doing in </span><a href="B18203_07.xhtml#_idTextAnchor147"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.366.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.367.1">, </span><em class="italic"><span class="koboSpan" id="kobo.368.1">Using Remote Procedure Calls (RPCs)</span></em><span class="koboSpan" id="kobo.369.1">, where you’ll need to learn how to call a function from the client to the server. </span><span class="koboSpan" id="kobo.369.2">The main focus of this chapter, however, is to understand how to replicate properties. </span><span class="koboSpan" id="kobo.369.3">So, without further ado, let’s check how things work under </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">the hood!</span></span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.371.1">Enabling property replication</span></h2>
<p><span class="koboSpan" id="kobo.372.1">In order for a property to </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.373.1">be replicated, you need to set up a few things. </span><span class="koboSpan" id="kobo.373.2">First of all, in the Actor constructor that will contain the property, you will need to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">bReplicates</span></strong><span class="koboSpan" id="kobo.375.1"> flag </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.379.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.380.1">A class or Blueprint extending from </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">APawn</span></strong><span class="koboSpan" id="kobo.382.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">ACharacter</span></strong><span class="koboSpan" id="kobo.384.1"> will have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">bReplicates</span></strong><span class="koboSpan" id="kobo.386.1"> property set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">true</span></strong><span class="koboSpan" id="kobo.388.1"> by default, while a regular </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">Actor won’t.</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">Then, the property that should be replicated will need to have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">Replicated</span></strong><span class="koboSpan" id="kobo.392.1"> specifier added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">UPROPERTY()</span></strong><span class="koboSpan" id="kobo.394.1"> macro. </span><span class="koboSpan" id="kobo.394.2">As an example, you can replicate the score for your character with the </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.396.1">
UPROPERTY(Replicated)
int32 Score;</span></pre>
<p><span class="koboSpan" id="kobo.397.1">If you are in need of a callback function to be executed when a property is updated, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">ReplicatedUsing=[FunctionName]</span></strong><span class="koboSpan" id="kobo.399.1"> instead – this attribute will let you specify a function that will be executed when an update is sent to the client. </span><span class="koboSpan" id="kobo.399.2">For example, if you want to execute a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">OnRep_Score()</span></strong><span class="koboSpan" id="kobo.401.1"> whenever your character score is replicated, you will write something similar to the </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.403.1">
UPROPERTY(ReplicatedUsing="OnRep_Score")
int32 Score;</span></pre>
<p><span class="koboSpan" id="kobo.404.1">You will then need to</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.405.1"> implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">OnRep_Score()</span></strong><span class="koboSpan" id="kobo.407.1"> method in the same class; this function must declare the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">UFUNCTION()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.409.1"> macro.</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">Once all the replication properties are properly decorated by the previous attributes, they need to be declared inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">AActor::GetLifetimeReplicatedProps()</span></strong><span class="koboSpan" id="kobo.412.1"> function by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">DOREPLIFETIME()</span></strong><span class="koboSpan" id="kobo.414.1"> macro. </span><span class="koboSpan" id="kobo.414.2">Using the previous score example, you will need to declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">Score</span></strong><span class="koboSpan" id="kobo.416.1"> property by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.418.1">
DOREPLIFETIME(AMyActor, Score);</span></pre>
<p><span class="koboSpan" id="kobo.419.1">After a property is registered for replication, it cannot be unregistered, as Unreal Engine will optimize data storage to reduce the computation time: this means that, by default, you will not have much control over how a </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">property replicates.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">Luckily, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">DOREPLIFETIME_CONDITION()</span></strong><span class="koboSpan" id="kobo.423.1"> macro instead, which will let you add an additional condition for more precise control over replication. </span><span class="koboSpan" id="kobo.423.2">Values for these conditions are predefined – one example is </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">COND_OwnerOnly</span></strong><span class="koboSpan" id="kobo.425.1">, which will only send data to the Actor’s owner (we will use this value later in the chapter). </span><span class="koboSpan" id="kobo.425.2">As another example, if you need even more fine-grained control in property replication, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">DOREPLIFETIME_ACTIVE_OVERRIDE()</span></strong><span class="koboSpan" id="kobo.427.1"> macro, which will let you use your own conditions defined inside </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">the Actor.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">The major downside of using additional conditions for replication is performance, as the engine will need to do additional checks before replicating a property – this means that it is advisable to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">DOREPLIFETIME()</span></strong><span class="koboSpan" id="kobo.431.1"> macro in situations where no pressing requirements dictate the use of an </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">alternative option.</span></span></p>
<p><span class="koboSpan" id="kobo.433.1">Now that you understand how an object can be replicated, it’s time for me to introduce how objects are referenced across </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">the network.</span></span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.435.1">Referencing Actors and components over the network</span></h2>
<p><span class="koboSpan" id="kobo.436.1">Sooner or later, you will need to</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.437.1"> reference an Actor or a component from your code – this means that, in a multiplayer game, you will need to know whether the reference can be replicated or not. </span><span class="koboSpan" id="kobo.437.2">Simply put, an Actor or a component can be referenced over the network only if it is supported </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">for networking.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">There are some simple rules that will help you determine whether your object can be referenced over </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">the network:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.441.1">If an Actor is replicated, it can also be replicated as </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">a reference</span></span></li>
<li><span class="koboSpan" id="kobo.443.1">If a component is replicated, it can also be replicated as </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">a reference</span></span></li>
<li><span class="koboSpan" id="kobo.445.1">Non-replicated Actors and components need to be stably named in order to be replicated </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">as references</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.447.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.448.1">An object that is </span><strong class="bold"><span class="koboSpan" id="kobo.449.1">stably named</span></strong><span class="koboSpan" id="kobo.450.1"> means that an</span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.451.1"> entity that will be present in both the server and the client that has the same name. </span><span class="koboSpan" id="kobo.451.2">For instance, an Actor is stably named if it was not spawned during gameplay but was loaded directly in the level from </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">a package.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">This section has provided you with an introduction to the fundamental concepts of network replication in Unreal Engine, explaining how it interacts with Actors and components. </span><span class="koboSpan" id="kobo.453.2">If you feel a bit lost about too much theory, don’t be afraid! </span><span class="koboSpan" id="kobo.453.3">You’ll be taking all that theory and transforming it into a tangible, working example by creating a level-up system for </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">your character.</span></span></p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.455.1">Handling character level-ups</span></h1>
<p><span class="koboSpan" id="kobo.456.1">As I previously</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.457.1"> mentioned, in this section, you are going to level up your hero’s experience and skills. </span><span class="koboSpan" id="kobo.457.2">As usual, you’ll be dabbling in code magic to make it happen! </span><span class="koboSpan" id="kobo.457.3">After all, you are programming a </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">fantasy game.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">I know it might seem like a good idea to write your code inside the Character class but trust me when I say that there’s actually a much better spot for it. </span><span class="koboSpan" id="kobo.459.2">That is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">PlayerState</span></strong><span class="koboSpan" id="kobo.461.1"> class, which we incidentally have already set for this occasion – a while ago, I asked you to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">US_PlayerState</span></strong><span class="koboSpan" id="kobo.463.1"> class and now is the time to add some valuable code </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">in it.</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">As introduced in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.466.1">Chapter 4</span></em></span><span class="koboSpan" id="kobo.467.1">, </span><em class="italic"><span class="koboSpan" id="kobo.468.1">Setting Up Your First Multiplayer Environment</span></em><span class="koboSpan" id="kobo.469.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">PlayerState</span></strong><span class="koboSpan" id="kobo.471.1"> is a class that holds information about a player’s game state and exists on both the server and clients. </span><span class="koboSpan" id="kobo.471.2">As we need to synchronize experience points and levels for the character, this is the ideal location to </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">place everything.</span></span></p>
<p><span class="koboSpan" id="kobo.473.1">What we need to do here is to keep track of experience points and, as soon as the character reaches a new level, broadcast the information across the network and update the </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">character</span></span><span class="No-Break"><a id="_idIndexMarker368"/></span><span class="No-Break"><span class="koboSpan" id="kobo.475.1"> statistics.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">But first, the most important thing is to have a clear idea of what we are going </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">to do.</span></span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.478.1">Planning ahead</span></h2>
<p><span class="koboSpan" id="kobo.479.1">As the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">PlayerState</span></strong><span class="koboSpan" id="kobo.481.1"> class will keep important information about the character, it’s mandatory to think ahead about what you want to achieve and how to get to that point – this means we have to plan exactly what we will be adding to </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">this class.</span></span></p>
<p><span class="koboSpan" id="kobo.483.1">Here are some of the</span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.484.1"> main features this gameplay framework class </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">will implement:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.486.1">Keeping track of the character’s current level and </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">experience points</span></span></li>
<li><span class="koboSpan" id="kobo.488.1">Synchronizing the aforementioned properties over </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">the network</span></span></li>
<li><span class="koboSpan" id="kobo.490.1">Updating the Character class whenever the player </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">levels up</span></span></li>
<li><span class="koboSpan" id="kobo.492.1">Broadcasting events whenever the character gets some experience points or </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">levels up</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.494.1">As a starting point, in the next subsection, we’ll start by declaring the required properties </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">and functions.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.496.1">Declaring PlayerState properties and functions</span></h2>
<p><span class="koboSpan" id="kobo.497.1">In the following steps, we are </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.498.1">going to define the main properties that will let the character level up whenever they have enough experience – this means we will need to track the thief’s experience points and level. </span><span class="koboSpan" id="kobo.498.2">Additionally, whenever values change, we will replicate these properties over the network and notify this event to each registered Actor in </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">the game.</span></span></p>
<p><span class="koboSpan" id="kobo.500.1">So, let’s start by </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.501.1">opening the </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">US_PlayerState.h</span></strong><span class="koboSpan" id="kobo.503.1"> file and adding the following code in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">protected</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.505.1"> section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.506.1">
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, ReplicatedUsing="OnRep_Xp", Category = "Experience")
int Xp = 0;
UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, ReplicatedUsing="OnRep_CharacterLevelUp", Category = "Experience")
int CharacterLevel = 1;
UFUNCTION()
void OnRep_Xp(int32 OldValue) const;
UFUNCTION()
void OnRep_CharacterLevelUp(int32 OldValue) const;</span></pre>
<p><span class="koboSpan" id="kobo.507.1">As you can see, the first thing we have done is declare the two properties </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">Xp</span></strong><span class="koboSpan" id="kobo.509.1"> (short for experience points) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">CharacterLevel</span></strong><span class="koboSpan" id="kobo.511.1">; both can be modified in Unreal’s </span><strong class="bold"><span class="koboSpan" id="kobo.512.1">Details</span></strong><span class="koboSpan" id="kobo.513.1"> panel for playtesting purposes thanks to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">EditDefaultsOnly</span></strong><span class="koboSpan" id="kobo.515.1"> attribute, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">BlueprintsReadOnly</span></strong><span class="koboSpan" id="kobo.517.1"> makes them non-modifiable in a Blueprint, to keep all the level-up logic inside the C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">source code.</span></span></p>
<p><span class="koboSpan" id="kobo.519.1">As an additional attribute, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">ReplicatedUsing</span></strong><span class="koboSpan" id="kobo.521.1"> attribute, which I introduced in the previous section. </span><span class="koboSpan" id="kobo.521.2">This will let us execute a function whenever a property is updated – in this case, we have set </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">OnRep_Xp</span></strong><span class="koboSpan" id="kobo.523.1"> for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">Xp</span></strong><span class="koboSpan" id="kobo.525.1"> property and </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">OnRep_CharacterLevelUp</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.527.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">CharacterLevel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.530.1">Next, create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">public</span></strong><span class="koboSpan" id="kobo.532.1"> section in your header file and add </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">this code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.534.1">
UFUNCTION(BlueprintCallable, Category="Experience")
void AddXp(int32 Value);</span></pre>
<p><span class="koboSpan" id="kobo.535.1">This function will let us assign new experience points to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">PlayerState</span></strong><span class="koboSpan" id="kobo.537.1">. </span><span class="koboSpan" id="kobo.537.2">We need to make it </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">BlueprintCallable</span></strong><span class="koboSpan" id="kobo.539.1"> in order to use this function from our Blueprints – for instance, from </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">a pickup.</span></span></p>
<p><span class="koboSpan" id="kobo.541.1">Just after that, add </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">this declaration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.543.1">
virtual void GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const override;</span></pre>
<p><span class="koboSpan" id="kobo.544.1">As explained in the </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.545.1">previous section, we need to override this method in order to declare the properties that will be replicated (more on this in </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">a moment).</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">All the necessary setup for implementing replication in our two properties has been completed, but a few additional elements still need to be incorporated to ensure everything works properly. </span><span class="koboSpan" id="kobo.547.2">We need to broadcast some information whenever these properties change – this will come in handy when you implement a user interface later in </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.549.1">To implement such </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.550.1">functionality, you’ll be using </span><strong class="bold"><span class="koboSpan" id="kobo.551.1">delegates</span></strong><span class="koboSpan" id="kobo.552.1">. </span><span class="koboSpan" id="kobo.552.2">You may be already familiar with this topic in C++, but you should be aware that, in Unreal Engine, a delegate provides a way to call member functions on C++ objects in a generic, type-safe manner through </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">dedicated macros.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.554.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.555.1">If you want more information about the types of delegates supported by Unreal Engine and how they can be used in your project, check out the official documentation, which can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">here: </span></span><a href="https://docs.unrealengine.com/5.1/en-US/delegates-and-lamba-functions-in-unreal-engine/"><span class="No-Break"><span class="koboSpan" id="kobo.557.1">https://docs.unrealengine.com/5.1/en-US/delegates-and-lamba-functions-in-unreal-engine/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.558.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.559.1">As we want broadcast events for the two properties, we will be declaring two delegates – one for each property. </span><span class="koboSpan" id="kobo.559.2">At the beginning of the header file, just before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">UCLASS()</span></strong><span class="koboSpan" id="kobo.561.1"> declaration, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.563.1">
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnXpChanged, int32, NewXp);
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnCharacterLevelUp, int32, NewLevelXp);</span></pre>
<p><span class="koboSpan" id="kobo.564.1">These two lines are pretty similar – they</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.565.1"> both declare a </span><strong class="bold"><span class="koboSpan" id="kobo.566.1">dynamic multi-cast delegate</span></strong><span class="koboSpan" id="kobo.567.1"> with a single parameter. </span><span class="koboSpan" id="kobo.567.2">Being dynamic, the delegate can be serialized, and so, used in a Blueprint, while the multi-cast declaration will allow you to attach multiple function delegates and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">Broadcast()</span></strong><span class="koboSpan" id="kobo.569.1"> method to notify every listener of changes in your </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.570.1">system. </span><span class="koboSpan" id="kobo.570.2">We will use these features in our Blueprint classes to bind events and </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">react accordingly.</span></span></p>
<p><span class="koboSpan" id="kobo.572.1">Let’s declare our </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">delegate</span></strong><span class="koboSpan" id="kobo.574.1"> function. </span><span class="koboSpan" id="kobo.574.2">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">protected</span></strong><span class="koboSpan" id="kobo.576.1"> section, and add the following two lines of code, which will be used to broadcast </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">the events:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.578.1">
UPROPERTY(BlueprintAssignable, Category = "Events")
FOnXpChanged OnXpChanged;
UPROPERTY(BlueprintAssignable, Category = "Events")
FOnCharacterLevelUp OnCharacterLevelUp;</span></pre>
<p><span class="koboSpan" id="kobo.579.1">As their purpose is self-explanatory, I guess it’s time stop talking and start writing down </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">the implementation!</span></span></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.581.1">Implementing the PlayerState logic</span></h2>
<p><span class="koboSpan" id="kobo.582.1">Now that all the </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.583.1">properties and methods have been declared, you are going to implement the PlayerState logic – whenever the character gains some experience, you should check whether it has reached enough points to level up. </span><span class="koboSpan" id="kobo.583.2">Experience points gained and level-ups should be broadcast to the system, in order to keep </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">everything synchronized.</span></span></p>
<p><span class="koboSpan" id="kobo.585.1">Start by opening the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">US_PlayerState.cpp</span></strong><span class="koboSpan" id="kobo.587.1"> file and adding the required </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">include</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.589.1"> declarations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.590.1">
#include "US_Character.h"
#include "US_CharacterStats.h"
#include "Net/UnrealNetwork.h"</span></pre>
<p><span class="koboSpan" id="kobo.591.1">Next, add the implementation for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">GetLifetimeReplicatedProps()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.593.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.594.1">
void AUS_PlayerState::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const
{
 Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 DOREPLIFETIME_CONDITION(AUS_PlayerState, Xp, COND_OwnerOnly);
 DOREPLIFETIME_CONDITION(AUS_PlayerState, CharacterLevel, COND_OwnerOnly);
}</span></pre>
<p><span class="koboSpan" id="kobo.595.1">As you can see, we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">DOREPLIFETIME_CONDITION()</span></strong><span class="koboSpan" id="kobo.597.1"> macro, introduced in the previous section, to declare that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">Xp</span></strong><span class="koboSpan" id="kobo.599.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">CharacterLevel</span></strong><span class="koboSpan" id="kobo.601.1"> properties should be replicated – in this case, we just want the property to be replicated on the owning player of the character (i.e., in the player’s client), and we do so by using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">COND_OwnerOnly</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.603.1"> flag.</span></span></p>
<p><span class="koboSpan" id="kobo.604.1">Next, add the</span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.605.1"> implementation for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">AddXp()</span></strong><span class="koboSpan" id="kobo.607.1"> method using the </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.609.1">
void AUS_PlayerState::AddXp(const int32 Value)
{
 Xp += Value;
 OnXpChanged.Broadcast(Xp);
 GEngine-&gt;AddOnScreenDebugMessage(0, 5.f, FColor::Yellow, FString::Printf(TEXT("Total Xp: %d"), Value));
 if (const auto Character = Cast&lt;AUS_Character&gt;(GetPawn()))
 {
  if(Character-&gt;GetCharacterStats()-&gt;NextLevelXp &lt; Xp)
  {
   GEngine-&gt;AddOnScreenDebugMessage(3, 5.f, FColor::Red, TEXT("Level Up!"));
   CharacterLevel++;
   Character-&gt;UpdateCharacterStats(CharacterLevel);
   OnCharacterLevelUp.Broadcast(CharacterLevel);
  }
 }
}</span></pre>
<p><span class="koboSpan" id="kobo.610.1">Here, whenever we receive an experience point update, we simply add the value to the character pool (i.e., the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">Xp</span></strong><span class="koboSpan" id="kobo.612.1"> property). </span><span class="koboSpan" id="kobo.612.2">Next, we ascertain that the character is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">AUS_Character</span></strong><span class="koboSpan" id="kobo.614.1"> type through a cast and, if the cast is successful, we retrieve its statistics to check whether it should level up. </span><span class="koboSpan" id="kobo.614.2">If the check is successful, we simply increase the character level and call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">UpdateCharacterStats()</span></strong><span class="koboSpan" id="kobo.616.1"> method to make the thief update</span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.617.1"> the skill row. </span><span class="koboSpan" id="kobo.617.2">As we change the values for the properties, we then broadcast the new value to all listeners. </span><span class="koboSpan" id="kobo.617.3">A couple of (temporary) debug messages complete </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.619.1">The PlayerState is now almost finished – we just need to broadcast the values to the clients whenever values are updated from the server side. </span><span class="koboSpan" id="kobo.619.2">To do so, add this last block of code to </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.621.1">
void AUS_PlayerState::OnRep_Xp(int32 OldValue) const
{
 OnXpChanged.Broadcast(Xp);
}
void AUS_PlayerState::OnRep_CharacterLevelUp(int32 OldValue) const
{
 OnCharacterLevelUp.Broadcast(CharacterLevel);
}</span></pre>
<p><span class="koboSpan" id="kobo.622.1">The broadcast call is self-explanatory – every registered Actor will receive the notification, along with the new value for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">Xp</span></strong><span class="koboSpan" id="kobo.624.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">CharacterLevel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.626.1"> properties.</span></span></p>
<p><span class="koboSpan" id="kobo.627.1">So, in the preceding steps, you have successfully developed a fully operational replication system that effectively manages the character experience gained and skill development. </span><span class="koboSpan" id="kobo.627.2">I’m aware that the task at hand may feel daunting and even sometimes counter-intuitive, but </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.628.1">with time and practice, you can rest assured that everything will become easier and </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">more manageable!</span></span></p>
<p><span class="koboSpan" id="kobo.630.1">There’s still something missing in our game: actual experience points. </span><span class="koboSpan" id="kobo.630.2">Let’s not waste any time and work on adding an item that our character can use to gain experience points. </span><span class="koboSpan" id="kobo.630.3">In the next steps, you’ll be creating some coins, starting with the previously created </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">US_BasePickup</span></strong><span class="koboSpan" id="kobo.632.1"> class, to grant your thief the </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">much-desired experience.</span></span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.634.1">Adding coin pickups to the level</span></h2>
<p><span class="koboSpan" id="kobo.635.1">So, we are ready to </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.636.1">create some coins that will be used in the game to add experience points to the character – this will be a simple Blueprint that will be spawned whenever enemies are killed or that will be available in </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">the level.</span></span></p>
<p><span class="koboSpan" id="kobo.638.1">To do this, go back to Unreal Editor and compile the project, in order to update it with all your improvements. </span><span class="koboSpan" id="kobo.638.2">Then, navigate to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">Blueprints</span></strong><span class="koboSpan" id="kobo.640.1"> folder and complete the </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.642.1">Right-click in the Content Browser and select </span><strong class="bold"><span class="koboSpan" id="kobo.643.1">Blueprint Class</span></strong><span class="koboSpan" id="kobo.644.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.645.1">US_BasePickup</span></strong><span class="koboSpan" id="kobo.646.1"> to create a new Blueprint </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">from it.</span></span></li>
<li><span class="koboSpan" id="kobo.648.1">Name the Blueprint </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">BP_GoldCoinPickup</span></strong><span class="koboSpan" id="kobo.650.1"> and double-click on it to </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">open it.</span></span></li>
<li><span class="koboSpan" id="kobo.652.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.653.1">Components</span></strong><span class="koboSpan" id="kobo.654.1"> panel, select the </span><strong class="bold"><span class="koboSpan" id="kobo.655.1">Mesh</span></strong><span class="koboSpan" id="kobo.656.1"> component and assign to the </span><strong class="bold"><span class="koboSpan" id="kobo.657.1">Static Mesh</span></strong><span class="koboSpan" id="kobo.658.1"> attribute the </span><strong class="bold"><span class="koboSpan" id="kobo.659.1">coin</span></strong><span class="koboSpan" id="kobo.660.1"> static mesh. </span><span class="koboSpan" id="kobo.660.2">Change its scale to </span><strong class="bold"><span class="koboSpan" id="kobo.661.1">2</span></strong><span class="koboSpan" id="kobo.662.1">, in order to make it more visible in </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">the game.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.664.1">Your Blueprint </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.665.1">should now be similar to the one shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.666.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.667.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<span class="koboSpan" id="kobo.669.1"><img alt="Figure 6.4 – The gold coin Blueprint" src="image/Figure_06_04_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.670.1">Figure 6.4 – The gold coin Blueprint</span></p>
<p><span class="koboSpan" id="kobo.671.1">Now that the pickup has a base shape, it’s time to add some code logic to make things fully functional. </span><span class="koboSpan" id="kobo.671.2">Open the </span><strong class="bold"><span class="koboSpan" id="kobo.672.1">Event Graph</span></strong><span class="koboSpan" id="kobo.673.1"> tab and take the </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">following steps:</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.675.1">Create a variable of type </span><strong class="bold"><span class="koboSpan" id="kobo.676.1">Integer</span></strong><span class="koboSpan" id="kobo.677.1"> and call it </span><strong class="bold"><span class="koboSpan" id="kobo.678.1">EarnedXp</span></strong><span class="koboSpan" id="kobo.679.1">, giving it a default value </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">of </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.681.1">5</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.683.1">Right-click in the canvas and look for </span><strong class="bold"><span class="koboSpan" id="kobo.684.1">Event Pickup</span></strong><span class="koboSpan" id="kobo.685.1">, adding it to </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">the graph.</span></span></li>
<li><span class="koboSpan" id="kobo.687.1">Add a </span><strong class="bold"><span class="koboSpan" id="kobo.688.1">Cast To US_PlayerState</span></strong><span class="koboSpan" id="kobo.689.1"> node and connect its incoming execution pin to the outgoing execution pin of </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">the event.</span></span></li>
<li><span class="koboSpan" id="kobo.691.1">Click and drag from the </span><strong class="bold"><span class="koboSpan" id="kobo.692.1">Owning Character</span></strong><span class="koboSpan" id="kobo.693.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.694.1">Event</span></strong><span class="koboSpan" id="kobo.695.1"> node and, after releasing the button, add a </span><strong class="bold"><span class="koboSpan" id="kobo.696.1">Get PlayerState</span></strong><span class="koboSpan" id="kobo.697.1"> node from the options </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">that appear.</span></span></li>
<li><span class="koboSpan" id="kobo.699.1">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.700.1">PlayerState</span></strong><span class="koboSpan" id="kobo.701.1"> outgoing pin to the </span><strong class="bold"><span class="koboSpan" id="kobo.702.1">Object</span></strong><span class="koboSpan" id="kobo.703.1"> pin of the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.704.1">Cast</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.705.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.706.1">Click and drag</span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.707.1"> from the outgoing </span><strong class="bold"><span class="koboSpan" id="kobo.708.1">As Us PlayerState</span></strong><span class="koboSpan" id="kobo.709.1"> pin to create an </span><strong class="bold"><span class="koboSpan" id="kobo.710.1">Add </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.711.1">Xp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.712.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.713.1">Connect the success execution pin of the cast node to the incoming execution pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.714.1">Add </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.715.1">Xp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.716.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.717.1">Drag a </span><strong class="bold"><span class="koboSpan" id="kobo.718.1">Get Earned Xp</span></strong><span class="koboSpan" id="kobo.719.1"> node from the </span><strong class="bold"><span class="koboSpan" id="kobo.720.1">Variables</span></strong><span class="koboSpan" id="kobo.721.1"> section into the canvas and connect its pin to the </span><strong class="bold"><span class="koboSpan" id="kobo.722.1">Value</span></strong><span class="koboSpan" id="kobo.723.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.724.1">Add </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.725.1">Xp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.726.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.727.1">Finally, add a </span><strong class="bold"><span class="koboSpan" id="kobo.728.1">Destroy Actor</span></strong><span class="koboSpan" id="kobo.729.1"> node and connect it to the outgoing execution pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.730.1">Add </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.731.1">Xp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.732.1"> node.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.733.1">The final result of the graph is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.734.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.735.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer095">
<span class="koboSpan" id="kobo.737.1"><img alt="Figure 6.5 – The Coin Event graph" src="image/Figure_06_05_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.738.1">Figure 6.5 – The Coin Event graph</span></p>
<p><span class="koboSpan" id="kobo.739.1">As you can see, the visual scripting code is quite straightforward – whenever a character picks up a coin, its PlayerState will be updated with the experience points granted </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">by it.</span></span></p>
<p><span class="koboSpan" id="kobo.741.1">To test the game, just drag a bunch of coins inside your level and play the game. </span><span class="koboSpan" id="kobo.741.2">Every time a character picks up a coin, you should see a display message, and when the character has enough experience, you should get another message, the </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">level-up one.</span></span></p>
<p><span class="koboSpan" id="kobo.743.1">It should be noted that, in the previous code, the pickup event will be called both on the client and on the server – this is something that should not be done as it may provoke issues in your game. </span><span class="koboSpan" id="kobo.743.2">Luckily, in this case, the PlayerState will correctly handle the data, so we don’t have to </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.744.1">worry about it. </span><span class="koboSpan" id="kobo.744.2">You will learn how to handle trickier situations in </span><a href="B18203_06.xhtml#_idTextAnchor125"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.745.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.746.1">, </span><em class="italic"><span class="koboSpan" id="kobo.747.1">Replicating Properties </span></em><em class="italic"><span class="koboSpan" id="kobo.748.1">O</span></em><em class="italic"><span class="koboSpan" id="kobo.749.1">ver </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.750.1">the Network</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.752.1">As an extra exercise, you can add a floating animation to the coin, just like you did for the spell book in </span><a href="B18203_05.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.753.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.754.1">, </span><em class="italic"><span class="koboSpan" id="kobo.755.1">Managing Actors in a </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.756.1">Multiplayer Environment</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.758.1">Adding coin subclasses</span></h3>
<p><span class="koboSpan" id="kobo.759.1">As an optional step, you can </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.760.1">create different coin pickups with different values for experience points. </span><span class="koboSpan" id="kobo.760.2">Here’s how to </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">do so:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.762.1">Right-click on </span><strong class="bold"><span class="koboSpan" id="kobo.763.1">PB_GoldCoinPickup</span></strong><span class="koboSpan" id="kobo.764.1"> and select </span><strong class="bold"><span class="koboSpan" id="kobo.765.1">Create Child Blueprint Class</span></strong><span class="koboSpan" id="kobo.766.1">, naming the </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">asset </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">BP_SilverCoinPickup</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.770.1">Assign a value of </span><strong class="bold"><span class="koboSpan" id="kobo.771.1">3</span></strong><span class="koboSpan" id="kobo.772.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.773.1">Earned Xp</span></strong><span class="koboSpan" id="kobo.774.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.775.1">MI_Metal</span></strong><span class="koboSpan" id="kobo.776.1"> as the </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">mesh material.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.778.1">To provide your character with various items to search for, repeat this step as many times as you desire. </span><span class="koboSpan" id="kobo.778.2">This will grant your character a diverse set of treasures to </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">seek out.</span></span></p>
<p><span class="koboSpan" id="kobo.780.1">In this section, you have created a level-up system for your thief hero. </span><span class="koboSpan" id="kobo.780.2">With the help of replication, a character will get the correct level-up notification upon reaching enough experience points. </span><span class="koboSpan" id="kobo.780.3">At the moment, this can be achieved by collecting coin pickups around the level – later on, you’ll spawn treasure upon defeating those nasty </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">Lichlord minions!</span></span></p>
<p><span class="koboSpan" id="kobo.782.1">In the next section, I will guide you through the creation of a simple UI that will show the character level and the experience points that have been gained; you’ll perform this task by listening to PlayerState notifications and </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">reacting accordingly.</span></span></p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.784.1">Adding a HUD to the game</span></h1>
<p><span class="koboSpan" id="kobo.785.1">In this section, you will create a </span><strong class="bold"><span class="koboSpan" id="kobo.786.1">Heads Up Display</span></strong><span class="koboSpan" id="kobo.787.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.788.1">HUD</span></strong><span class="koboSpan" id="kobo.789.1">) for the game that will assist in monitoring the player character’s progress during the game. </span><span class="koboSpan" id="kobo.789.2">As you may already know, the best way to create </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.790.1">such information is through the </span><strong class="bold"><span class="koboSpan" id="kobo.791.1">Unreal Motion Graphics</span></strong><span class="koboSpan" id="kobo.792.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.793.1">UMG</span></strong><span class="koboSpan" id="kobo.794.1">) system – a GUI-based editor that allows developers to </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.795.1">create user interface elements for their game, such as menus, HUDs, and other display screens. </span><span class="koboSpan" id="kobo.795.2">You’ll be using this system to create the HUD widget with the </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">relative info.</span></span></p>
<p><span class="koboSpan" id="kobo.797.1">What we need to show at the moment is quite simple – one set of text showing the character’s experience points and another set showing </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">the level.</span></span></p>
<p><span class="koboSpan" id="kobo.799.1">Let’s start by creating the Blueprint and the </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">visual elements.</span></span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.801.1">Creating the Widget Blueprint</span></h2>
<p><span class="koboSpan" id="kobo.802.1">To create the </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.803.1">Widget Blueprint, within Unreal Editor, take the </span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.805.1">Open your </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">Blueprints</span></strong><span class="koboSpan" id="kobo.807.1"> folder, right-click on the Content Browser, and select </span><strong class="bold"><span class="koboSpan" id="kobo.808.1">User Interface</span></strong><span class="koboSpan" id="kobo.809.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.810.1">Widget Blueprint</span></strong><span class="koboSpan" id="kobo.811.1"> to create a </span><strong class="bold"><span class="koboSpan" id="kobo.812.1">User Widget</span></strong><span class="koboSpan" id="kobo.813.1"> Blueprint. </span><span class="koboSpan" id="kobo.813.2">Name the newly created asset </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">WB_HUD</span></strong><span class="koboSpan" id="kobo.815.1"> and double-click on the asset to </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">open it.</span></span></li>
<li><span class="koboSpan" id="kobo.817.1">Drag a </span><strong class="bold"><span class="koboSpan" id="kobo.818.1">Canvas</span></strong><span class="koboSpan" id="kobo.819.1"> element from the </span><strong class="bold"><span class="koboSpan" id="kobo.820.1">Palette</span></strong><span class="koboSpan" id="kobo.821.1"> tab into the </span><strong class="bold"><span class="koboSpan" id="kobo.822.1">Designer</span></strong><span class="koboSpan" id="kobo.823.1"> view. </span><span class="koboSpan" id="kobo.823.2">This canvas will act as the </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.824.1">main container for your </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">visual elements.</span></span></li>
<li><span class="koboSpan" id="kobo.826.1">Drag a </span><strong class="bold"><span class="koboSpan" id="kobo.827.1">Text</span></strong><span class="koboSpan" id="kobo.828.1"> element into the previously added </span><strong class="bold"><span class="koboSpan" id="kobo.829.1">Canvas</span></strong><span class="koboSpan" id="kobo.830.1"> and call it </span><strong class="bold"><span class="koboSpan" id="kobo.831.1">XpLabel</span></strong><span class="koboSpan" id="kobo.832.1">. </span><span class="koboSpan" id="kobo.832.2">Make sure that the </span><strong class="bold"><span class="koboSpan" id="kobo.833.1">Is Variable</span></strong><span class="koboSpan" id="kobo.834.1"> field in the </span><strong class="bold"><span class="koboSpan" id="kobo.835.1">Details</span></strong><span class="koboSpan" id="kobo.836.1"> panel is checked to expose this element in the graph you’ll be </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">using later.</span></span></li>
<li><span class="koboSpan" id="kobo.838.1">Position the label somewhere on the canvas that suits your needs; in my case, I opted for the top-left corner of </span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">the screen.</span></span></li>
<li><span class="koboSpan" id="kobo.840.1">Drag another </span><strong class="bold"><span class="koboSpan" id="kobo.841.1">Text</span></strong><span class="koboSpan" id="kobo.842.1"> element into the </span><strong class="bold"><span class="koboSpan" id="kobo.843.1">Canvas</span></strong><span class="koboSpan" id="kobo.844.1"> instance and call it </span><strong class="bold"><span class="koboSpan" id="kobo.845.1">CharacterLevelLabel</span></strong><span class="koboSpan" id="kobo.846.1">. </span><span class="koboSpan" id="kobo.846.2">Again, make sure that the </span><strong class="bold"><span class="koboSpan" id="kobo.847.1">Is Variable</span></strong><span class="koboSpan" id="kobo.848.1"> field in the </span><strong class="bold"><span class="koboSpan" id="kobo.849.1">Details</span></strong><span class="koboSpan" id="kobo.850.1"> panel is checked to expose this element in the graph you’ll be </span><span class="No-Break"><span class="koboSpan" id="kobo.851.1">using later.</span></span></li>
<li><span class="koboSpan" id="kobo.852.1">Position the label somewhere on the canvas that suits your needs; in my case, I opted for the</span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.853.1"> top-right corner of </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">the screen.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.855.1">The final result of </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.856.1">your HUD should be similar to </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.857.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.858.1">.6</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer096">
<span class="koboSpan" id="kobo.860.1"><img alt="Figure 6.6 – The HUD designer panel" src="image/Figure_06_06_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.861.1">Figure 6.6 – The HUD designer panel</span></p>
<p><span class="koboSpan" id="kobo.862.1">Now that you have created the widget, it’s time to add some Visual Scripting code to make it </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">fully functional.</span></span></p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.864.1">Adding code logic to the Widget Blueprint</span></h2>
<p><span class="koboSpan" id="kobo.865.1">In the following steps, you’ll </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.866.1">add some code logic to the Blueprint, in order to listen to events from the PlayerState and </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">react accordingly.</span></span></p>
<h3><span class="koboSpan" id="kobo.868.1">Creating a custom event for the experience points label</span></h3>
<p><span class="koboSpan" id="kobo.869.1">Let’s start by creating a custom event that will update the experience points label. </span><span class="koboSpan" id="kobo.869.2">To do this, open the </span><strong class="bold"><span class="koboSpan" id="kobo.870.1">Graph</span></strong><span class="koboSpan" id="kobo.871.1"> panel of your widget and take the </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">following steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.873.1">Create a custom </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.874.1">event and call </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">OnXpChanged_Event</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.878.1">Select it and, in the </span><strong class="bold"><span class="koboSpan" id="kobo.879.1">Details</span></strong><span class="koboSpan" id="kobo.880.1"> panel, add an input of type </span><strong class="bold"><span class="koboSpan" id="kobo.881.1">Integer</span></strong><span class="koboSpan" id="kobo.882.1">. </span><span class="koboSpan" id="kobo.882.2">Name </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">NewXp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.886.1">From the </span><strong class="bold"><span class="koboSpan" id="kobo.887.1">MyBlueprint</span></strong><span class="koboSpan" id="kobo.888.1"> panel, drag a getter node </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">for </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.890.1">XpLabel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.892.1">From the </span><strong class="bold"><span class="koboSpan" id="kobo.893.1">XpLabel</span></strong><span class="koboSpan" id="kobo.894.1"> outgoing pin, click and drag, adding a </span><strong class="bold"><span class="koboSpan" id="kobo.895.1">SetText (</span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.896.1">Text)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.897.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.898.1">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.899.1">OnXpChanged_Event</span></strong><span class="koboSpan" id="kobo.900.1"> execution pin to the incoming </span><strong class="bold"><span class="koboSpan" id="kobo.901.1">SetText (Text)</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.902.1">execution pin.</span></span></li>
<li><span class="koboSpan" id="kobo.903.1">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.904.1">New Xp</span></strong><span class="koboSpan" id="kobo.905.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.906.1">Event</span></strong><span class="koboSpan" id="kobo.907.1"> node to the </span><strong class="bold"><span class="koboSpan" id="kobo.908.1">In Text</span></strong><span class="koboSpan" id="kobo.909.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.910.1">SetText (Text)</span></strong><span class="koboSpan" id="kobo.911.1"> node. </span><span class="koboSpan" id="kobo.911.2">This operation will automatically add a </span><strong class="bold"><span class="koboSpan" id="kobo.912.1">To Text (Integer)</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.913.1">node converter.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.914.1">The final result of this piece of code is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.915.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.916.1">.7</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.917.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer097">
<span class="koboSpan" id="kobo.918.1"><img alt="Figure 6.7 – The Xp custom event" src="image/Figure_06_07_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.919.1">Figure 6.7 – The Xp custom event</span></p>
<p><span class="koboSpan" id="kobo.920.1">As an additional, optional step, you may want to add an </span><strong class="bold"><span class="koboSpan" id="kobo.921.1">Append</span></strong><span class="koboSpan" id="kobo.922.1"> node – this is usually used to prefix some descriptive text to be shown in the text label, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">Experience Points</span></strong><span class="koboSpan" id="kobo.924.1"> (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">Experience </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">Points: 150</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.928.1">Now that you have a custom event to handle the experience points label, it’s time to do the same for the </span><span class="No-Break"><span class="koboSpan" id="kobo.929.1">character level.</span></span></p>
<h3><span class="koboSpan" id="kobo.930.1">Creating a custom event for the character level label</span></h3>
<p><span class="koboSpan" id="kobo.931.1">Let’s now create a custom event that </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.932.1">will update the character </span><span class="No-Break"><span class="koboSpan" id="kobo.933.1">level label:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.934.1">Create a custom event and call </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">OnCharacterLevelUp_Event</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.938.1">Select it and, in the </span><strong class="bold"><span class="koboSpan" id="kobo.939.1">Details</span></strong><span class="koboSpan" id="kobo.940.1"> panel, add an input of type </span><strong class="bold"><span class="koboSpan" id="kobo.941.1">Integer</span></strong><span class="koboSpan" id="kobo.942.1">. </span><span class="koboSpan" id="kobo.942.2">Name </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">NewLevel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.945.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.946.1">From the </span><strong class="bold"><span class="koboSpan" id="kobo.947.1">MyBlueprint</span></strong><span class="koboSpan" id="kobo.948.1"> panel, drag a getter node </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">for </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.950.1">CharacterLevelLabel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.951.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.952.1">From the </span><strong class="bold"><span class="koboSpan" id="kobo.953.1">CharacterLevelLabel</span></strong><span class="koboSpan" id="kobo.954.1"> outgoing pin, click and drag and, after releasing the mouse button, select a </span><strong class="bold"><span class="koboSpan" id="kobo.955.1">SetText (Text)</span></strong><span class="koboSpan" id="kobo.956.1"> node from the options </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">that appear.</span></span></li>
<li><span class="koboSpan" id="kobo.958.1">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.959.1">OnLevelLabelChanged_Event</span></strong><span class="koboSpan" id="kobo.960.1"> execution pin to the incoming </span><strong class="bold"><span class="koboSpan" id="kobo.961.1">SetText (Text)</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.962.1">execution pin.</span></span></li>
<li><span class="koboSpan" id="kobo.963.1">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.964.1">New Level</span></strong><span class="koboSpan" id="kobo.965.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.966.1">Event</span></strong><span class="koboSpan" id="kobo.967.1"> node to the </span><strong class="bold"><span class="koboSpan" id="kobo.968.1">In Text</span></strong><span class="koboSpan" id="kobo.969.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.970.1">SetText (Text)</span></strong><span class="koboSpan" id="kobo.971.1"> node. </span><span class="koboSpan" id="kobo.971.2">This operation will automatically add a </span><strong class="bold"><span class="koboSpan" id="kobo.972.1">To Text (Integer)</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.973.1">node converter.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.974.1">The final result of this piece of code is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.975.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.976.1">.8</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer098">
<span class="koboSpan" id="kobo.978.1"><img alt="Figure 6.8 – The character level custom event" src="image/Figure_06_08_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.979.1">Figure 6.8 – The character level custom event</span></p>
<p><span class="koboSpan" id="kobo.980.1">Just like the previous label, you may want to use the </span><strong class="bold"><span class="koboSpan" id="kobo.981.1">Append</span></strong><span class="koboSpan" id="kobo.982.1"> node to prefix the character level label with descriptive text such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">Level:</span></strong><span class="koboSpan" id="kobo.984.1"> (for example, </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">Level: 1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.986.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.987.1">Now that you have a</span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.988.1"> custom event to handle the character level label, it’s time to bind these events to the notifications broadcast by </span><span class="No-Break"><span class="koboSpan" id="kobo.989.1">the PlayerState.</span></span></p>
<h3><span class="koboSpan" id="kobo.990.1">Binding to PlayerState events</span></h3>
<p><span class="koboSpan" id="kobo.991.1">In this final step of the </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.992.1">Widget Blueprint, you will bind the previously created events to the PlayerState, in order to update the HUD every time an update notification </span><span class="No-Break"><span class="koboSpan" id="kobo.993.1">is dispatched:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.994.1">Add an </span><strong class="bold"><span class="koboSpan" id="kobo.995.1">Event on Initialized</span></strong><span class="koboSpan" id="kobo.996.1"> node to the graph. </span><span class="koboSpan" id="kobo.996.2">This node is executed only once during the game (i.e., when the object has been initialized) and is the best place to </span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">add bindings.</span></span></li>
<li><span class="koboSpan" id="kobo.998.1">Connect the event to a </span><strong class="bold"><span class="koboSpan" id="kobo.999.1">Delay</span></strong><span class="koboSpan" id="kobo.1000.1"> node with </span><strong class="bold"><span class="koboSpan" id="kobo.1001.1">Duration</span></strong><span class="koboSpan" id="kobo.1002.1"> equal to </span><strong class="bold"><span class="koboSpan" id="kobo.1003.1">0,2</span></strong><span class="koboSpan" id="kobo.1004.1">. </span><span class="koboSpan" id="kobo.1004.2">As the PlayerState won’t be available at initialization time, waiting until it is available is a quick solution to solve </span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1">the issue.</span></span></li>
<li><span class="koboSpan" id="kobo.1006.1">Add a </span><strong class="bold"><span class="koboSpan" id="kobo.1007.1">Branch</span></strong><span class="koboSpan" id="kobo.1008.1"> node and connect its incoming execution pin to the </span><strong class="bold"><span class="koboSpan" id="kobo.1009.1">Completed</span></strong><span class="koboSpan" id="kobo.1010.1"> execution pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1011.1">Delay</span></strong><span class="koboSpan" id="kobo.1012.1"> node. </span><span class="koboSpan" id="kobo.1012.2">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.1013.1">False</span></strong><span class="koboSpan" id="kobo.1014.1"> execution pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1015.1">Branch</span></strong><span class="koboSpan" id="kobo.1016.1"> node to the incoming execution pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1017.1">Delay</span></strong><span class="koboSpan" id="kobo.1018.1"> node; this will create a loop that will go on until the PlayerState has been </span><span class="No-Break"><span class="koboSpan" id="kobo.1019.1">properly initialized.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1020.1">Now we are going to recover the PlayerState from the player owning </span><span class="No-Break"><span class="koboSpan" id="kobo.1021.1">this widget.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.1022.1">Add a </span><strong class="bold"><span class="koboSpan" id="kobo.1023.1">Get Owning Player</span></strong><span class="koboSpan" id="kobo.1024.1"> node to the graph. </span><span class="koboSpan" id="kobo.1024.2">This node returns the player that is controlling (i.e., owns) </span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1">the HUD.</span></span></li>
<li><span class="koboSpan" id="kobo.1026.1">From the </span><strong class="bold"><span class="koboSpan" id="kobo.1027.1">Return Value</span></strong><span class="koboSpan" id="kobo.1028.1"> pin of this node, click and drag to create a </span><strong class="bold"><span class="koboSpan" id="kobo.1029.1">Get </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1030.1">PlayerState</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1031.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.1032.1">From the </span><strong class="bold"><span class="koboSpan" id="kobo.1033.1">PlayerState</span></strong><span class="koboSpan" id="kobo.1034.1"> outgoing pin of the newly created node, click and drag to create a </span><strong class="bold"><span class="koboSpan" id="kobo.1035.1">Cast To US_PlayerState</span></strong><span class="koboSpan" id="kobo.1036.1"> node. </span><span class="koboSpan" id="kobo.1036.2">Right-click on this node and, from the options, select </span><strong class="bold"><span class="koboSpan" id="kobo.1037.1">Convert to Pure Cast</span></strong><span class="koboSpan" id="kobo.1038.1">. </span><span class="koboSpan" id="kobo.1038.2">As the game is based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">US_PlayerState</span></strong><span class="koboSpan" id="kobo.1040.1"> class, we</span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.1041.1"> are pretty sure that we are going to recover that type of PlayerState, so we don’t need to worry </span><span class="No-Break"><span class="koboSpan" id="kobo.1042.1">about validation.</span></span></li>
<li><span class="koboSpan" id="kobo.1043.1">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.1044.1">Success</span></strong><span class="koboSpan" id="kobo.1045.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1046.1">Cast To US_PlayerState</span></strong><span class="koboSpan" id="kobo.1047.1"> node to the </span><strong class="bold"><span class="koboSpan" id="kobo.1048.1">Condition</span></strong><span class="koboSpan" id="kobo.1049.1"> pin of the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1050.1">Branch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1051.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.1052.1">From the outgoing </span><strong class="bold"><span class="koboSpan" id="kobo.1053.1">As US PlayerState</span></strong><span class="koboSpan" id="kobo.1054.1"> pin, click and drag to create a new variable by selecting </span><strong class="bold"><span class="koboSpan" id="kobo.1055.1">Promote to variable</span></strong><span class="koboSpan" id="kobo.1056.1">. </span><span class="koboSpan" id="kobo.1056.2">You will automatically get a </span><strong class="bold"><span class="koboSpan" id="kobo.1057.1">Set PlayerState</span></strong><span class="koboSpan" id="kobo.1058.1"> node in the graph – name the </span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">variable </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">PlayerState</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1061.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1062.1">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.1063.1">True</span></strong><span class="koboSpan" id="kobo.1064.1"> execution pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1065.1">Branch</span></strong><span class="koboSpan" id="kobo.1066.1"> node to the incoming </span><strong class="bold"><span class="koboSpan" id="kobo.1067.1">Set PlayerState</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1068.1">execution pin.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1069.1">The visual scripting code created so far is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1070.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1071.1">.9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1072.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer099">
<span class="koboSpan" id="kobo.1073.1"><img alt="Figure 6.9 – The first part of the PlayerState binding" src="image/Figure_06_09_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1074.1">Figure 6.9 – The first part of the PlayerState binding</span></p>
<p><span class="koboSpan" id="kobo.1075.1">Now that you have a reference to the PlayerState, it’s time to bind the custom events to the delegate</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.1076.1"> you created in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1077.1">previous sections.</span></span></p>
<ol>
<li value="10"><span class="koboSpan" id="kobo.1078.1">From the outgoing pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1079.1">Set PlayerState</span></strong><span class="koboSpan" id="kobo.1080.1"> node, click and drag to create a </span><strong class="bold"><span class="koboSpan" id="kobo.1081.1">Bind Event to On Xp Changed</span></strong><span class="koboSpan" id="kobo.1082.1"> event; this event is available thanks to the delegate declaration included in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1083.1">US_PlayerState</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1084.1"> class.</span></span></li>
<li><span class="koboSpan" id="kobo.1085.1">Connect the outgoing execution pin of </span><strong class="bold"><span class="koboSpan" id="kobo.1086.1">Set PlayerState</span></strong><span class="koboSpan" id="kobo.1087.1"> to the incoming execution pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1088.1">Bind Event to On Xp </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1089.1">Changed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1090.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.1091.1">From the </span><strong class="bold"><span class="koboSpan" id="kobo.1092.1">Event</span></strong><span class="koboSpan" id="kobo.1093.1"> pin of the bind node, click and drag to add a </span><strong class="bold"><span class="koboSpan" id="kobo.1094.1">Create Event</span></strong><span class="koboSpan" id="kobo.1095.1"> node. </span><span class="koboSpan" id="kobo.1095.2">This node has a drop-down menu – here, select </span><strong class="bold"><span class="koboSpan" id="kobo.1096.1">OnXpChanged_Event (NewXp)</span></strong><span class="koboSpan" id="kobo.1097.1">, which will execute the </span><strong class="bold"><span class="koboSpan" id="kobo.1098.1">OnXpChanged_Event</span></strong><span class="koboSpan" id="kobo.1099.1"> custom event whenever the system receives the corresponding notification from </span><span class="No-Break"><span class="koboSpan" id="kobo.1100.1">the PlayerState.</span></span></li>
<li><span class="koboSpan" id="kobo.1101.1">Connect the outgoing execution pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1102.1">Bind </span></strong><strong class="bold"><span class="koboSpan" id="kobo.1103.1">Event to On Xp Changed</span></strong><span class="koboSpan" id="kobo.1104.1"> node to an </span><strong class="bold"><span class="koboSpan" id="kobo.1105.1">On Xp Changed Event</span></strong><span class="koboSpan" id="kobo.1106.1"> node; this will call the event upon initialization, to update </span><span class="No-Break"><span class="koboSpan" id="kobo.1107.1">the HUD.</span></span></li>
<li><span class="koboSpan" id="kobo.1108.1">From the </span><strong class="bold"><span class="koboSpan" id="kobo.1109.1">Variables</span></strong><span class="koboSpan" id="kobo.1110.1"> section, drag a </span><strong class="bold"><span class="koboSpan" id="kobo.1111.1">Get PlayerState</span></strong><span class="koboSpan" id="kobo.1112.1"> node and from it, create a </span><strong class="bold"><span class="koboSpan" id="kobo.1113.1">Get Xp</span></strong><span class="koboSpan" id="kobo.1114.1"> node. </span><span class="koboSpan" id="kobo.1114.2">Connect the outgoing pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1115.1">Get Xp</span></strong><span class="koboSpan" id="kobo.1116.1"> node to the </span><strong class="bold"><span class="koboSpan" id="kobo.1117.1">New Xp</span></strong><span class="koboSpan" id="kobo.1118.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1119.1">On Xp Changed </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1120.1">Event</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1121.1"> node.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1122.1">This portion of the</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.1123.1"> Visual Scripting code is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1124.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1125.1">.10</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1126.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer100">
<span class="koboSpan" id="kobo.1127.1"><img alt="Figure 6.10 – The second part of the PlayerState binding" src="image/Figure_06_10_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1128.1">Figure 6.10 – The second part of the PlayerState binding</span></p>
<p><span class="koboSpan" id="kobo.1129.1">The last part of the binding phase is almost identical to the steps you have just taken, with the exception that we are creating a binding for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1130.1">player level.</span></span></p>
<ol>
<li value="15"><span class="koboSpan" id="kobo.1131.1">From the outgoing pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1132.1">On Xp Changed Event</span></strong><span class="koboSpan" id="kobo.1133.1"> node, click and drag to create a </span><strong class="bold"><span class="koboSpan" id="kobo.1134.1">Bind Event to On Character Level </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1135.1">Up</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1136.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.1137.1">Drag a </span><strong class="bold"><span class="koboSpan" id="kobo.1138.1">Get PlayerState</span></strong><span class="koboSpan" id="kobo.1139.1"> node from the </span><strong class="bold"><span class="koboSpan" id="kobo.1140.1">Variables</span></strong><span class="koboSpan" id="kobo.1141.1"> section and connect it to the </span><strong class="bold"><span class="koboSpan" id="kobo.1142.1">Target</span></strong><span class="koboSpan" id="kobo.1143.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1144.1">Bind Event to On Character Level </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1145.1">Up</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1146.1"> node.</span></span></li>
<li><span class="koboSpan" id="kobo.1147.1">From the </span><strong class="bold"><span class="koboSpan" id="kobo.1148.1">Event</span></strong><span class="koboSpan" id="kobo.1149.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1150.1">Bind </span></strong><strong class="bold"><span class="koboSpan" id="kobo.1151.1">Event to On Character Level Up</span></strong><span class="koboSpan" id="kobo.1152.1"> node, click and drag to add a </span><strong class="bold"><span class="koboSpan" id="kobo.1153.1">Create Event</span></strong><span class="koboSpan" id="kobo.1154.1"> node. </span><span class="koboSpan" id="kobo.1154.2">From the drop-down menu, select </span><strong class="bold"><span class="koboSpan" id="kobo.1155.1">OnCharacterLevelUp_Event (NewLevel)</span></strong><span class="koboSpan" id="kobo.1156.1">. </span><span class="koboSpan" id="kobo.1156.2">This selection will execute the </span><strong class="bold"><span class="koboSpan" id="kobo.1157.1">OnCharacterLevelUp_Event</span></strong><span class="koboSpan" id="kobo.1158.1"> custom event whenever the system receives the corresponding notification from </span><span class="No-Break"><span class="koboSpan" id="kobo.1159.1">the PlayerState.</span></span></li>
<li><span class="koboSpan" id="kobo.1160.1">Connect the outgoing execution pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1161.1">Bind</span></strong><span class="koboSpan" id="kobo.1162.1"> node to an </span><strong class="bold"><span class="koboSpan" id="kobo.1163.1">On Character Level Up Event</span></strong><span class="koboSpan" id="kobo.1164.1"> node; this will call the</span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.1165.1"> event upon initialization, to update </span><span class="No-Break"><span class="koboSpan" id="kobo.1166.1">the HUD.</span></span></li>
<li><span class="koboSpan" id="kobo.1167.1">From the </span><strong class="bold"><span class="koboSpan" id="kobo.1168.1">Variables</span></strong><span class="koboSpan" id="kobo.1169.1"> section, drag a </span><strong class="bold"><span class="koboSpan" id="kobo.1170.1">Get PlayerState</span></strong><span class="koboSpan" id="kobo.1171.1"> node to create a </span><strong class="bold"><span class="koboSpan" id="kobo.1172.1">Get Character Level</span></strong><span class="koboSpan" id="kobo.1173.1"> node. </span><span class="koboSpan" id="kobo.1173.2">Connect the outgoing pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1174.1">Get Character Level</span></strong><span class="koboSpan" id="kobo.1175.1"> node to the </span><strong class="bold"><span class="koboSpan" id="kobo.1176.1">New Level</span></strong><span class="koboSpan" id="kobo.1177.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1178.1">On Character Level Up </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1179.1">Event</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1180.1"> node.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1181.1">This final part of the graph is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1182.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1183.1">.11</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1184.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer101">
<span class="koboSpan" id="kobo.1185.1"><img alt="Figure 6.11 – The final part of the PlayerState binding" src="image/Figure_06_11_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1186.1">Figure 6.11 – The final part of the PlayerState binding</span></p>
<p><span class="koboSpan" id="kobo.1187.1">You have finally created all the bindings to listen to any PlayerState notifications and update the HUD</span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.1188.1"> accordingly. </span><span class="koboSpan" id="kobo.1188.2">It’s now time to add the final step – showing the </span><span class="No-Break"><span class="koboSpan" id="kobo.1189.1">HUD in-game.</span></span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.1190.1">Adding the HUD to the character</span></h2>
<p><span class="koboSpan" id="kobo.1191.1">Now you will add the HUD to the </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.1192.1">player viewport. </span><span class="koboSpan" id="kobo.1192.2">If you are already familiar with Unreal Engine user interfaces in standalone games, you may already know how </span><span class="No-Break"><span class="koboSpan" id="kobo.1193.1">things work.</span></span></p>
<p><span class="koboSpan" id="kobo.1194.1">However, you should be aware that, in a multiplayer environment, a user interface widget should be attached to the game viewport only if the character is controlled locally (i.e., is the owning client). </span><span class="koboSpan" id="kobo.1194.2">If you don’t check whether the character creating the widget is controlled locally, you will create a widget for each character spawned in the level – including those controlled by other players and replicated in the client. </span><span class="koboSpan" id="kobo.1194.3">Having a cluttered mess of superimposed HUDs is obviously something you don’t want to have in </span><span class="No-Break"><span class="koboSpan" id="kobo.1195.1">your game!</span></span></p>
<p><span class="koboSpan" id="kobo.1196.1">To add the HUD to the character, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.1197.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1198.1">Start by finding the </span><strong class="bold"><span class="koboSpan" id="kobo.1199.1">BP_Character</span></strong><span class="koboSpan" id="kobo.1200.1"> Blueprint and </span><span class="No-Break"><span class="koboSpan" id="kobo.1201.1">opening it.</span></span></li>
<li><span class="koboSpan" id="kobo.1202.1">In the Event Graph, find the </span><strong class="bold"><span class="koboSpan" id="kobo.1203.1">Begin Play</span></strong><span class="koboSpan" id="kobo.1204.1"> event. </span><span class="koboSpan" id="kobo.1204.2">Then, add a </span><strong class="bold"><span class="koboSpan" id="kobo.1205.1">Branch</span></strong><span class="koboSpan" id="kobo.1206.1"> node to the execution pin of </span><span class="No-Break"><span class="koboSpan" id="kobo.1207.1">the event.</span></span></li>
<li><span class="koboSpan" id="kobo.1208.1">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.1209.1">Condition</span></strong><span class="koboSpan" id="kobo.1210.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1211.1">Branch</span></strong><span class="koboSpan" id="kobo.1212.1"> node to an </span><strong class="bold"><span class="koboSpan" id="kobo.1213.1">Is Locally Controlled</span></strong><span class="koboSpan" id="kobo.1214.1"> node – this will guarantee we are attaching the HUD only to the character controlled by </span><span class="No-Break"><span class="koboSpan" id="kobo.1215.1">the client.</span></span></li>
<li><span class="koboSpan" id="kobo.1216.1">From the </span><strong class="bold"><span class="koboSpan" id="kobo.1217.1">True</span></strong><span class="koboSpan" id="kobo.1218.1"> execution pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1219.1">Branch</span></strong><span class="koboSpan" id="kobo.1220.1"> node, create a </span><strong class="bold"><span class="koboSpan" id="kobo.1221.1">Create Widget</span></strong><span class="koboSpan" id="kobo.1222.1"> node. </span><span class="koboSpan" id="kobo.1222.2">From the </span><strong class="bold"><span class="koboSpan" id="kobo.1223.1">Class</span></strong><span class="koboSpan" id="kobo.1224.1"> drop-down menu, choose </span><strong class="bold"><span class="koboSpan" id="kobo.1225.1">WB_HUD</span></strong><span class="koboSpan" id="kobo.1226.1"> to select </span><span class="No-Break"><span class="koboSpan" id="kobo.1227.1">our HUD.</span></span></li>
<li><span class="koboSpan" id="kobo.1228.1">Connect the outgoing execution pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.1229.1">Create Widget</span></strong><span class="koboSpan" id="kobo.1230.1"> node to an </span><strong class="bold"><span class="koboSpan" id="kobo.1231.1">Add to Viewport</span></strong><span class="koboSpan" id="kobo.1232.1"> node. </span><span class="koboSpan" id="kobo.1232.2">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.1233.1">Return Value</span></strong><span class="koboSpan" id="kobo.1234.1"> pin to the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1235.1">Target</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1236.1"> pin.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1237.1">The final result of the graph can be seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1238.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1239.1">.12</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1240.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer102">
<span class="koboSpan" id="kobo.1241.1"><img alt="Figure 6.12 – Adding the HUD to the viewport" src="image/Figure_06_12_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1242.1">Figure 6.12 – Adding the HUD to the viewport</span></p>
<p><span class="koboSpan" id="kobo.1243.1">The previous Visual Scripting code is pretty easy to understand, but it is important to mention that the viewport is only added to the character controlled by the client, as having multiple</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.1244.1"> HUDs overlaying each other would not </span><span class="No-Break"><span class="koboSpan" id="kobo.1245.1">be desirable!</span></span></p>
<p><span class="koboSpan" id="kobo.1246.1">Now that everything has been properly set, you are going to test your game to see how </span><span class="No-Break"><span class="koboSpan" id="kobo.1247.1">it works!</span></span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.1248.1">Testing the game</span></h2>
<p><span class="koboSpan" id="kobo.1249.1">To test the game, start </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.1250.1">playing it as a listen server and check that everything works fine. </span><span class="koboSpan" id="kobo.1250.2">In particular, you should see the </span><span class="No-Break"><span class="koboSpan" id="kobo.1251.1">following behaviors:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1252.1">At the start of the game, the HUD should show 0 experience points and the character level equal </span><span class="No-Break"><span class="koboSpan" id="kobo.1253.1">to 1</span></span></li>
<li><span class="koboSpan" id="kobo.1254.1">Every time a character picks a coin up, the HUD should update the total </span><span class="No-Break"><span class="koboSpan" id="kobo.1255.1">experience points</span></span></li>
<li><span class="koboSpan" id="kobo.1256.1">If the target experience points are reached, the player should level up and the HUD will show the </span><span class="No-Break"><span class="koboSpan" id="kobo.1257.1">new level</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1258.1">The final result should be pretty similar to the one shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1259.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1260.1">.13</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1261.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer103">
<span class="koboSpan" id="kobo.1262.1"><img alt="Figure 6.13 – The Final HUD" src="image/Figure_06_13_B18203.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1263.1">Figure 6.13 – The Final HUD</span></p>
<p><span class="koboSpan" id="kobo.1264.1">If everything goes</span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.1265.1"> according to plan, you’re all set to embark on the next exciting chapter of the Lichlord multiplayer epic: </span><span class="No-Break"><span class="koboSpan" id="kobo.1266.1">client-server communication!</span></span></p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.1267.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1268.1">In this chapter, I have introduced you to one of the most important topics in the Unreal Engine multiplayer </span><span class="No-Break"><span class="koboSpan" id="kobo.1269.1">framework: replication.</span></span></p>
<p><span class="koboSpan" id="kobo.1270.1">As a first step, you created some statistics for the player, in order to make your gameplay more flexible. </span><span class="koboSpan" id="kobo.1270.2">You did this through structures and data tables – a topic that will come in handy even if you are developing a </span><span class="No-Break"><span class="koboSpan" id="kobo.1271.1">standalone game.</span></span></p>
<p><span class="koboSpan" id="kobo.1272.1">Next, I explained the topic of property replication and how to apply it to your project. </span><span class="koboSpan" id="kobo.1272.2">Once the main concepts were defined, you started using them on the PlayerState, in order to keep track of the character’s progress </span><span class="No-Break"><span class="koboSpan" id="kobo.1273.1">during gameplay.</span></span></p>
<p><span class="koboSpan" id="kobo.1274.1">As a last step, you created a HUD to show this progress to the player. </span><span class="koboSpan" id="kobo.1274.2">Replication is mostly important here as each client should get its own updates and show them to </span><span class="No-Break"><span class="koboSpan" id="kobo.1275.1">the player.</span></span></p>
<p><span class="koboSpan" id="kobo.1276.1">In the next chapter, you’ll dive deeper into the mystical realm of replication, flexing your skills in the delicate art of calling methods from client to server and back again like it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1277.1">nobody’s business.</span></span></p>
<p><span class="koboSpan" id="kobo.1278.1">Get ready to take things to the next level – we’re about to climb the staircase of multiplayer development, two steps at </span><span class="No-Break"><span class="koboSpan" id="kobo.1279.1">a time!</span></span></p>
</div>
</body></html>