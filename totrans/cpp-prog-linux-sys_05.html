<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer039">
<h1 class="chapter-number" id="_idParaDest-75"><a id="_idTextAnchor075"/>5</h1>
<h1 id="_idParaDest-76"><a id="_idTextAnchor076"/>Handling Errors with C++</h1>
<p>This chapter will focus on error handling in C++. As a programmer, you will inevitably encounter situations where you need to determine the best approach to propagate program errors. Whether you use error codes or exceptions, we will delve into them to gain a better understanding of how to use <span class="No-Break">them effectively.</span></p>
<p>In this chapter, we will examine how to handle errors reported by POSIX APIs using C++. We will begin by covering the <strong class="source-inline">errno</strong> thread-local variable and the <strong class="source-inline">strerror</strong> function. After that, we will introduce <strong class="source-inline">std::error_code</strong> and <strong class="source-inline">std::error_condition</strong> and demonstrate how they help to wrap POSIX errors that come from POSIX APIs. We will also investigate custom error categories, which allow us to compare errors produced by various sources and develop platform-independent <span class="No-Break">error-handling code.</span></p>
<p>As we progress, we will learn about exceptions in C++ and how to convert <strong class="source-inline">std::error_code</strong> into a <strong class="source-inline">std::system_error</strong> exception. We will also explore some best practices for working with exceptions, such as throwing exceptions by value and catching them by reference. Additionally, we will become acquainted with object slicing, a side effect that can occur when we catch exceptions by value rather than by reference. Finally, we will delve into the RAII technique in C++, which eliminates the need for a <strong class="source-inline">finally</strong> construct in <span class="No-Break">the language.</span></p>
<p>By the end of this chapter, you will have a thorough understanding of the various ways to handle errors in C++, and you will be familiar with several techniques for creating <span class="No-Break">error-resistant code.</span></p>
<p>Summing up, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Handling errors from POSIX APIs <span class="No-Break">with C++</span></li>
<li>From error codes <span class="No-Break">to exceptions</span></li>
</ul>
<p>Alright, it’s time <span class="No-Break">to begin!</span></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor077"/>Technical requirements</h1>
<p>All examples in this chapter have been tested in an environment with the <span class="No-Break">following configuration:</span></p>
<ul>
<li>Linux Mint 21 <span class="No-Break">Cinnamon edition</span></li>
<li>GCC 12.2 with <span class="No-Break">compiler flags:</span><ul><li><strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">std=c++20</strong></span></li></ul></li>
<li>A stable <span class="No-Break">internet connection</span></li>
<li>Please make sure your environment is at least that recent. For all the examples, you can alternatively <span class="No-Break">use </span><a href="https://godbolt.org/"><span class="No-Break">https://godbolt.org/</span></a><span class="No-Break">.</span></li>
<li>All code examples in this chapter are available for download <span class="No-Break">from </span><a href="https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%205"><span class="No-Break">https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%205</span></a><span class="No-Break">.</span></li>
</ul>
<h1 id="_idParaDest-78"><a id="_idTextAnchor078"/>Handling errors from POSIX APIs with C++</h1>
<p>In<a id="_idIndexMarker412"/> POSIX-compliant systems, such as Unix and Linux, error handling is based on the use of error codes and error messages to communicate errors between functions <span class="No-Break">and applications.</span></p>
<p>In <a id="_idIndexMarker413"/>general, when a function encounters an error, it returns a non-zero error code and sets the <strong class="source-inline">errno</strong> global variable to a specific error value that indicates the nature of the error. The application can then use the <strong class="source-inline">errno</strong> variable to determine the cause of the error and take <span class="No-Break">appropriate action.</span></p>
<p>In addition to error codes, POSIX-compliant functions often provide error messages that describe the nature of the error in more detail. These error messages are typically accessed using the <strong class="source-inline">strerror</strong> function, which takes an error code as input and returns a pointer to a sequence of characters terminated with a null character containing the corresponding <span class="No-Break">error message.</span></p>
<p>The POSIX error-handling style requires developers to check for errors after each system call or function call that may fail and to handle errors in a consistent and meaningful way. This can include logging error messages, retrying failed operations, or terminating the program in the event of a <span class="No-Break">critical error.</span></p>
<p>Let’s look <a id="_idIndexMarker414"/>at the following example where we demonstrate how to use the <strong class="source-inline">errno</strong> variable and the <strong class="source-inline">strerror()</strong> function to handle <a id="_idIndexMarker415"/>errors from POSIX functions in C++. </p>
<p>The example uses the <strong class="source-inline">open()</strong> and <strong class="source-inline">close()</strong> POSIX functions, which try to open and close a file from the filesystem of our Linux <span class="No-Break">test environment:</span></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;cstring&gt;
int main() {
    const int fd{open("no-such-file.txt", O_RDONLY)}; //
      {1}
    if (fd == -1) {
        std::cerr &lt;&lt; "Error opening file: " &lt;&lt;
          strerror(errno) &lt;&lt; '\n';
        std::cerr &lt;&lt; "Error code: " &lt;&lt; errno &lt;&lt; '\n';
        return  EXIT_FAILURE;
    }
    // Do something with the file...
    if (close(fd) == -1) {
        std::cerr &lt;&lt; "Error closing file: " &lt;&lt;
          strerror(errno) &lt;&lt; '\n';
        std::cerr &lt;&lt; "Error code: " &lt;&lt; errno &lt;&lt; '\n';
        return  EXIT_FAILURE;
    }
    return 0;
}</pre> <p>In this <a id="_idIndexMarker416"/>example, we attempt to open a file for reading called <strong class="source-inline">no-such-file.txt</strong> using the <strong class="source-inline">open()</strong> function; see marker <strong class="source-inline">{1}</strong>. In case <a id="_idIndexMarker417"/>of success, <strong class="source-inline">open()</strong> returns a non-negative integer, which corresponds to the file descriptor ID of the successfully opened file. If <strong class="source-inline">open()</strong> returns <strong class="source-inline">-1</strong>, we know an error occurred, so we print the error message using <strong class="source-inline">strerror(errno)</strong> and return the value of <strong class="source-inline">errno</strong> where the corresponding error code <span class="No-Break">is written.</span></p>
<p>If <strong class="source-inline">open()</strong> succeeds, we do something with the file and then close it using the <strong class="source-inline">close()</strong> function. If <strong class="source-inline">close()</strong> returns <strong class="source-inline">-1</strong>, we print the error message again using <strong class="source-inline">strerror(errno)</strong> and return the value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">errno</strong></span><span class="No-Break">.</span></p>
<p>This is a common error-handling technique for POSIX functions. In case of an error, they return <strong class="source-inline">-1</strong> and set the <strong class="source-inline">errno</strong> variable with the corresponding error code. The <strong class="source-inline">errno</strong> variable is<a id="_idIndexMarker418"/> a <em class="italic">thread-local</em> modifiable variable of the <strong class="source-inline">int</strong> type. This means that it is safe for you to use it in a multithreaded environment. Each thread will have its own copy, and POSIX methods invoked by this thread will use this instance to <span class="No-Break">report errors.</span></p>
<p>In order to print a meaningful message in the case of an error, we use the <strong class="source-inline">strerror()</strong> function, which accepts an integer and tries to match its value to a well-known list of descriptions of system-specific error codes. The <strong class="source-inline">open()</strong> function can report several errors and set different values to <strong class="source-inline">errno</strong> depending on the type of the occurred error. Let’s see the output of <span class="No-Break">the example:</span></p>
<pre class="console">
Error opening file: No such file or directory
Error code: 2</pre> <p>As we can see, the <strong class="source-inline">open()</strong> method has failed to open the file because it doesn’t exist. In this case, it sets <strong class="source-inline">errno</strong> to a value of <strong class="source-inline">2</strong>, which corresponds to the <strong class="source-inline">ENOENT</strong> value specified in the documentation of the function. It is a good practice to explicitly set <strong class="source-inline">errno</strong> to <strong class="source-inline">0</strong> before you do a system call to ensure that after the call, you can read its <span class="No-Break">real response.</span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor079"/>Using std::error_code and std::error_condition</h2>
<p>The C++ Standard Library <a id="_idIndexMarker419"/>provides several classes for handling errors from low-level APIs such as the POSIX interface. These classes are <strong class="source-inline">std::error_code</strong> for handling system-specific errors and <strong class="source-inline">std::error_condition</strong>, which deals with portable error codes. Let us explore both styles in <span class="No-Break">more detail.</span></p>
<h3>std::error_code</h3>
<p>Let’s rework<a id="_idIndexMarker420"/> our previous example in such a way that we provide a function for the creation of a directory with a specific <span class="No-Break">directory path:</span></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;sys/stat.h&gt;
std::error_code CreateDirectory(const std::string&amp; dirPath) {
    std::error_code ecode{};
    if (mkdir(dirPath.c_str(), 0777) != 0) {
        ecode = std::error_code{errno,
          std::generic_category()}; // {1}
    }
    return ecode;
}
int main() {
    auto ecode{CreateDirectory("/tmp/test")};
    if (ecode){ // {2}
        std::cerr &lt;&lt; "Error 1: " &lt;&lt; ecode.message() &lt;&lt;
          '\n';
    }
    ecode = CreateDirectory("/tmp/test"); // {3}
    if (ecode){
        std::cerr &lt;&lt; "Error 2: " &lt;&lt; ecode.message() &lt;&lt;
          '\n';
    }
    if (ecode.value() == EEXIST) {
        std::cout &lt;&lt; "This is platform specific and not
          portable.\n";
    }
    return 0;
}</pre> <p>Rather <a id="_idIndexMarker421"/>than the client of our new function, <strong class="source-inline">CreateDirectory</strong>, using the <strong class="source-inline">errno</strong> variable directly to determine whether the operation was successful, we will make use of a utility class provided by the Standard Library – <strong class="source-inline">std::error_code</strong>. <strong class="source-inline">std::error_code</strong> is used to store and transmit error codes as they were generated by libraries or system calls. It is a kind of wrapper class for which there are predefined categories of errors to work with. The errors returned by the POSIX functions are mostly standard and, as such, are predefined in the Standard Library. Therefore, it is straightforward to create a <strong class="source-inline">std::error_code</strong> instance from the <strong class="source-inline">errno</strong> value and specify that this value corresponds to <strong class="source-inline">std::generic_category()</strong>, as done in marker <strong class="source-inline">{1}</strong> in the preceding example. The <strong class="source-inline">errno</strong> value is de facto casted to a constant of the <span class="No-Break"><strong class="source-inline">std::errc</strong></span><span class="No-Break"> enumerator.</span></p>
<p>The created <strong class="source-inline">std::error_code</strong> object has two methods that can give you details about the underlying error. The <strong class="source-inline">std::error_code::message()</strong> method returns a meaningful string that can be used for logging purposes. The <strong class="source-inline">std::error_code::value()</strong>method, in our example, returns the value initially stored in the <strong class="source-inline">errno</strong> variable. But probably the most notable operation that the user can use from the <strong class="source-inline">std::error_code</strong> object is the predefined <strong class="source-inline">operator bool()</strong> of the class. In the case of an error stored in the object, it returns <strong class="source-inline">true</strong>; otherwise, it <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p>
<p>As you <a id="_idIndexMarker422"/>can see from the preceding example, the caller of the <strong class="source-inline">CreateCategory()</strong> method checks whether an error occurred, and if so, it gets the message stored for this error; see marker <strong class="source-inline">{2}</strong>. Here, you can find the output of the program run on our <span class="No-Break">test environment:</span></p>
<pre class="console">
Error 2: File exists
This is platform specific and not portable.</pre> <p>As is visible from the program’s output, the first <strong class="source-inline">CreateDirectory()</strong> invocation succeeds but the second one fails; see marker <strong class="source-inline">{3}</strong>. This is because the implementation of <strong class="source-inline">CreateDirectory()</strong> first checks whether such a directory already exists and if not, it creates it for us. But if the directory exists, the <strong class="source-inline">mkdir()</strong> system call returns <strong class="source-inline">–1</strong> and sets <strong class="source-inline">errno</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">EEXIST</strong></span><span class="No-Break">.</span></p>
<p>Something important about the <strong class="source-inline">std::error_code</strong> class is that it is platform specific. This means that the error values stored in it strongly depend on the underlying OS. In the case of a POSIX-like system, which Linux is, the error value we have is <strong class="source-inline">EEXIST</strong>. But this is not necessarily true for <span class="No-Break">other OSs.</span></p>
<p>Therefore, if we design our code to be as platform agnostic as possible, we need to avoid comparations such as <span class="No-Break">the following:</span></p>
<pre class="source-code">
if (ecode.value() == EEXIST)</pre> <p>But we also need a way to ensure that a directory that already exists doesn’t break our program logic. Yes, from a POSIX standpoint this is an error, but in our specific business logic, this is not a problem for the program execution <span class="No-Break">to continue.</span></p>
<h3>std::error_condition</h3>
<p>The<a id="_idIndexMarker423"/> right approach to address this problem is with the help of another Standard Library class – <strong class="source-inline">std::error_condition</strong>. As the name suggests, its main purpose is to provide conditional program logic. Let’s slightly rework the <strong class="source-inline">CreateDirectory()</strong> method from the <span class="No-Break">earlier example:</span></p>
<pre class="source-code">
std::error_code CreateDirectory(const std::string&amp; dirPath) {
    std::error_code ecode{};
    if (mkdir(dirPath.c_str(), 0777) != 0) {
        std::errc cond{errno}; // {1}
        ecode = std::make_error_code(cond); // {2}
    }
    return ecode;
}</pre> <p>As you can see, the <a id="_idIndexMarker424"/>difference from the previous example is how we construct the <strong class="source-inline">error_code</strong> object. In the reworked code, we first create an object of the <strong class="source-inline">std::errc</strong> type and initialize it with the value of POSIX <strong class="source-inline">errno</strong>; see marker <strong class="source-inline">{1}</strong>. The <strong class="source-inline">std::errc</strong> class is a scoped enumerator class. It defines <em class="italic">portable error conditions</em> that correspond to the specific POSIX error codes. This implies that instead of relying on a platform-specific macro that corresponds to a particular POSIX error code, such as <strong class="source-inline">EEXIST</strong>, we switch to an error that will have the same error condition regardless of the platform it <span class="No-Break">comes from.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">You can find the predefined portable error conditions<a id="_idIndexMarker425"/> of the <strong class="source-inline">std::errc</strong> scoped enumerator, which correspond to their equivalent POSIX error codes, <span class="No-Break">here: </span><a href="https://en.cppreference.com/w/cpp/error/errc"><span class="No-Break">https://en.cppreference.com/w/cpp/error/errc</span></a><span class="No-Break">.</span></p>
<p>Once we create an instance of <strong class="source-inline">std::errc</strong>, we pass it to the factory method for the creation of error codes – <strong class="source-inline">std::make_error_code()</strong> (see marker <strong class="source-inline">{2}</strong>) – which generates for us a <strong class="source-inline">std::error_code</strong> of a <span class="No-Break">generic category.</span></p>
<p>Now, let’s see how the <strong class="source-inline">main()</strong> method is changed in order to be <span class="No-Break">platform independent:</span></p>
<pre class="source-code">
int main() {
    auto ecode{CreateDirectory("/tmp/test")};
    if (ecode){
        std::cerr &lt;&lt; "Error 1: " &lt;&lt; ecode.message() &lt;&lt;
          '\n';
    }
    ecode = CreateDirectory("/tmp/test");
    if (ecode){
        std::cerr &lt;&lt; "Error 2: " &lt;&lt; ecode.message() &lt;&lt;
          '\n';
    }
    if (ecode == std::errc::file_exists) { // {3}
        std::cout &lt;&lt; "This is platform agnostic and is
          portable.\n";
    }
    return 0;
}</pre> <p>We still <a id="_idIndexMarker426"/>have two invocations of the <strong class="source-inline">CreateDirectory()</strong> method, and the second one still returns an <strong class="source-inline">error_code</strong>. But the main difference comes from how we compare the <strong class="source-inline">ecode</strong> object; see marker <strong class="source-inline">{3}</strong>. Instead of comparing it with an integer value of the error POSIX code, we compare it against an object that holds a portable error condition – <strong class="source-inline">std::errc::file_exists</strong>. It has the same semantics, saying that the file already exists, but it is platform independent. In the next section, we will see how useful this <span class="No-Break">could be.</span></p>
<h3>Using custom error categories</h3>
<p>Every<a id="_idIndexMarker427"/> software developer should strive as much as possible to write portable code. Writing portable code provides reusability, which can significantly reduce development costs. Of course, this is not always possible. There are use cases where the code you write is dedicated to a specific system. But for all the rest, abstracting your code from the underlying system allows you to easily migrate it to other systems without carrying out huge refactoring to make it work. This is safer <span class="No-Break">and cheaper.</span></p>
<p>Let’s get back to our previous example, where we tried to abstract the error code received from a POSIX system call. It should be comparable against a portable error condition such as <strong class="source-inline">std::errc::file_exists</strong>. We will extend this with the following use case. Imagine that we have a custom library that also works with files. Let’s call it <strong class="source-inline">MyFileLibrary</strong>. But this library doesn’t support the POSIX error codes. It provides a different <em class="italic">category</em> of custom error codes that semantically correspond to some of the POSIX codes but with different <span class="No-Break">error values.</span></p>
<p>The<a id="_idIndexMarker428"/> library supports the following errors with their corresponding <span class="No-Break">error codes:</span></p>
<pre class="source-code">
enum class MyFileLibraryError {
    FileNotFound = 1000,
    FileAlreadyExists = 2000,
    FileBusy = 3000,
    FileTooBig = 4000
};</pre> <p>As you can see, our library can return the <strong class="source-inline">FileAlreadyExists</strong> enumerated constant, just like the <strong class="source-inline">mkdir()</strong> system call does, but with a different error value – <strong class="source-inline">1000</strong>. So, the main logic that consumes both <strong class="source-inline">MyFileLibrary</strong> and <strong class="source-inline">mkdir()</strong> should be able to handle these errors in the same way, because they are semantically equal. Let’s see how this can <span class="No-Break">be done.</span></p>
<p>In our previous example, we created the error code returned by the <span class="No-Break">POSIX API:</span></p>
<pre class="source-code">
ecode = std::error_code{errno, std::generic_category()};</pre> <p>We used <strong class="source-inline">std::generic_category</strong>, which is a derived class from the base category class – <strong class="source-inline">std::error_category</strong>. It is predefined for us in the Standard Library in such a way that it <em class="italic">knows</em> POSIX error codes. This is effectively the place where the translation between the real error code returned by the API and <strong class="source-inline">std::error_condition</strong> is done. So, in order to expose the same capability for <strong class="source-inline">MyFileLibrary</strong>, we need to define a new <strong class="source-inline">std::error_category</strong> derived class. We will name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">MyFileLibraryCategory</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
class MyFileLibraryCategory : public std::error_category {
public:
    const char* name() const noexcept override { // {1}
        return "MyFileLibrary";
    }
    std::string message(int ev) const override { // {2}
        switch (static_cast&lt;MyFileLibraryError&gt;(ev)) {
        case MyFileLibraryError::FileAlreadyExists:
            return "The file already exists";
        default:
            return "Unsupported error";
        }
    }
    bool equivalent(int code,
                    const std::error_condition&amp; condition)
                      const noexcept override { // {3}
        switch (static_cast&lt;MyFileLibraryError&gt;(code)) {
        case MyFileLibraryError::FileAlreadyExists:
            return condition == std::errc::file_exists; //
                {4}
        default:
            return false;
        }
    }
};</pre> <p>The <strong class="source-inline">std::error_category</strong> base class<a id="_idIndexMarker429"/> has several <em class="italic">virtual</em> methods that, if overridden in the derived class, allow custom behavior. In our example, we have overridden <span class="No-Break">the following:</span></p>
<ul>
<li>The <strong class="source-inline">name()</strong> method, which is used to report which category this error belongs to; see <span class="No-Break">marker </span><span class="No-Break"><strong class="source-inline">{1}</strong></span></li>
<li>The <strong class="source-inline">message()</strong> method, which is used to report a message string that corresponds to a specific error value; see <span class="No-Break">marker </span><span class="No-Break"><strong class="source-inline">{2}</strong></span></li>
<li>The <strong class="source-inline">equivalent()</strong> method, which is used to make a comparison between the custom error code generated by our library and the predefined <span class="No-Break"><strong class="source-inline">std::error_condition</strong></span><span class="No-Break"> values</span></li>
</ul>
<p>The <strong class="source-inline">equivalent()</strong> method <a id="_idIndexMarker430"/>gets the custom error code, casts it to a value of <strong class="source-inline">MyFileLibraryError</strong>, and, for each specific case, decides what <strong class="source-inline">condition</strong> it matches; see <span class="No-Break">marker </span><span class="No-Break"><strong class="source-inline">{3}</strong></span><span class="No-Break">.</span></p>
<p>Now, since we have our new, shiny custom error category – <strong class="source-inline">MyFileLibraryCategory</strong> – let’s see how to <span class="No-Break">use it:</span></p>
<pre class="source-code">
const MyFileLibraryCategory my_file_lib_category{}; // {1}
int main() {
    std::error_code file_exists{static_cast&lt;int&gt;
      (MyFileLibraryError::FileAlreadyExists),
       my_file_lib_category}; // {2}
    if (file_exists == std::errc::file_exists) { // {3}
        std::cout &lt;&lt; "Msg: " &lt;&lt; file_exists.message() &lt;&lt;
          '\n'; // {4}
        std::cout &lt;&lt; "Category: " &lt;&lt; file_exists
          .default_error_condition().category().name() &lt;&lt;
             '\n'; // {5}
    }
    return 0;
}</pre> <p>The first step we need to take is to instantiate an object of our custom category; see marker <strong class="source-inline">{1}</strong>. Then, we create an <strong class="source-inline">error_code</strong> instance, which we initialize with the <strong class="source-inline">FileAlreadyExists</strong> error value and specify that it is from the <strong class="source-inline">MyFileLibraryCategory</strong> category; see marker <strong class="source-inline">{2}</strong>. Since we have a valid instance of an error code – <strong class="source-inline">file_exists</strong> – we are ready to compare it against the platform-independent <strong class="source-inline">std::errc::file_exists</strong> <span class="No-Break">error condition.</span></p>
<p>The following is the output of <span class="No-Break">the program:</span></p>
<pre class="console">
Msg: The file already exists
Category: MyFileLibrary</pre> <p>As you <a id="_idIndexMarker431"/>can see, the comparation between an error generated from <strong class="source-inline">MyFileLibrary</strong> and the generic <strong class="source-inline">std::errc::file_exists</strong> is now possible with the help of the custom error category we defined – <strong class="source-inline">MyFileLibraryCategory</strong>. The corresponding error message is displayed (see marker <strong class="source-inline">{3}</strong>) and the category as well (see <span class="No-Break">marker </span><span class="No-Break"><strong class="source-inline">{4}</strong></span><span class="No-Break">).</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Here, you can find the full description with all virtual methods that the <strong class="source-inline">std::error_category</strong> base class <a id="_idIndexMarker432"/><span class="No-Break">exposes: </span><a href="https://en.cppreference.com/w/cpp/error/error_category"><span class="No-Break">https://en.cppreference.com/w/cpp/error/error_category</span></a><span class="No-Break">.</span></p>
<p>Now that we are familiar with the usage of error codes and error conditions, let’s see how we can use the powerful mechanism of C++ exceptions and <span class="No-Break">propagate errors.</span></p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor080"/>From error codes to exceptions</h1>
<p>Exception handling<a id="_idIndexMarker433"/> is an important aspect of programming, especially when dealing with errors that can disrupt the normal flow of a program. While there are several ways to handle errors in a code base, exceptions provide a powerful mechanism for handling errors in a way that separates error flow from normal <span class="No-Break">program flow.</span></p>
<p>When working with <a id="_idIndexMarker434"/>error codes, it can be challenging to ensure that all error cases are properly handled and that the code remains maintainable. By wrapping error codes in exceptions, we can create a more pragmatic approach to error handling that makes it easier to reason about code and catch errors in a more <span class="No-Break">centralized manner.</span></p>
<p>It’s hard to<a id="_idIndexMarker435"/> say which<a id="_idIndexMarker436"/> approach is better when dealing with error handling in a code base, and the decision to use exceptions should be based on pragmatic considerations. While exceptions can provide significant benefits in terms of code organization and maintainability, they may come with a performance penalty that may not be acceptable in <span class="No-Break">certain systems.</span></p>
<p>At their core, exceptions are a way to segregate the normal program flow from the error flow. Unlike error codes, which can be ignored, exceptions cannot be easily overlooked, making them a more reliable way to ensure that errors are handled in a consistent and <span class="No-Break">centralized manner.</span></p>
<p>While exceptions may not be the right choice for every code base, they offer a powerful way to handle errors that can make code easier to maintain and reason about. By understanding how to correctly use exceptions, programmers can make informed decisions about how to handle errors in their code. Let’s get deeper <span class="No-Break">into this.</span></p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor081"/>std::system_error</h2>
<p>In the previous<a id="_idIndexMarker437"/> section, we created a program that properly handles<a id="_idIndexMarker438"/> errors reported by the POSIX system call – <strong class="source-inline">mkdir()</strong>. Now, let’s see how we can improve the error handling in this program using exceptions instead of error codes. Here is the revisited <span class="No-Break"><strong class="source-inline">CreateDirectory()</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
void CreateDirectory(const std::string&amp; dirPath) { // {1}
    using namespace std;
    if (mkdir(dirPath.c_str(), 0777) != 0) {
        const auto ecode{make_error_code(errc{errno})}; //
           {2}
        cout &lt;&lt; "CreateDirectory reports error: " &lt;&lt;
          ecode.message() &lt;&lt; '\n';
        system_error exception{ecode}; // {3}
        throw exception; // {4}
    }
}</pre> <p>In the <strong class="source-inline">CreateDirectory()</strong> method, we make a system call using the <strong class="source-inline">mkdir()</strong> API, which, in the case of failure, returns a non-zero result and stores a POSIX error code in the <strong class="source-inline">errno</strong> variable. Nothing new so far. Just as in our previous example, we create an <strong class="source-inline">std::error_code</strong> from the value of <strong class="source-inline">errno</strong> (see marker <strong class="source-inline">{2}</strong>) to report it to the caller of our <strong class="source-inline">CreateDirectory()</strong> method. But instead of returning the error directly as a result of the function, we prefer to use an exception for this and make our function <strong class="bold">void</strong>; see <span class="No-Break">marker </span><span class="No-Break"><strong class="source-inline">{1}</strong></span><span class="No-Break">.</span></p>
<p>Since we <a id="_idIndexMarker439"/>already <a id="_idIndexMarker440"/>have an error code object created, we will use it to create an exception from it. In order to do so, we will use a predefined exception class from the Standard Library that is explicitly defined to wrap <strong class="source-inline">std::error_code</strong> objects – <span class="No-Break"><strong class="source-inline">std::system_error</strong></span><span class="No-Break">.</span></p>
<p><strong class="source-inline">std::system_error</strong> is a derived type from the <strong class="source-inline">std::exception</strong> interface class from the C++ Standard Library. It is used by various library functions, which typically interface with OS facilities and can report errors either by generating <strong class="source-inline">std::error_code</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">std::error_condition</strong></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<img alt="Figure 5.1 – Inheritance diagram of std::system_error exception" height="328" src="image/Figure_5.1_B20833.jpg" width="358"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Inheritance diagram of std::system_error exception</p>
<p>In our example, in order to create an <strong class="source-inline">std::system_error</strong> object, we have to pass to its constructor the instance of <strong class="source-inline">std::error_code ecode</strong>, which we already created; see <span class="No-Break">marker </span><span class="No-Break"><strong class="source-inline">{3}</strong></span><span class="No-Break">.</span></p>
<p>As with any other exception derived from the base exception class from the Standard Library – <strong class="source-inline">std::exception</strong> – <strong class="source-inline">std::system_error</strong> has the <strong class="source-inline">what()</strong> method. It aims to report a meaningful string explaining details about the error behind the exception. More specifically, it calls under the hood the <strong class="source-inline">message()</strong> method of the <strong class="source-inline">std::error_code</strong> object it wraps and returns <span class="No-Break">its result.</span></p>
<p>Since<a id="_idIndexMarker441"/> we <a id="_idIndexMarker442"/>already have a new, shiny exception object created, we now need to <em class="italic">throw</em> it back to the caller of our API. This is done with the <strong class="source-inline">throw</strong> keyword; see marker <strong class="source-inline">{4}</strong>. An important note is that we throw the exception object by <em class="italic">value</em>; we don’t throw a reference or a pointer <span class="No-Break">to it.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">As a rule of thumb, wherever possible, throw your exceptions <span class="No-Break">by value.</span></p>
<p>One of the key advantages of exceptions over error codes is that they <em class="italic">can’t be omitted</em> by the caller. When a function returns an error code, it is up to the function’s caller to decide whether to check the return value or not. There are some cases where the return value is not checked by mistake, and this leads to bugs in the program. When using exceptions as an error-handling mechanism, there is no such possibility. Once an exception is thrown, it propagates up the call stack until it is either caught by the appropriate program exception-handling logic or reaches the top of the function stack. If the exception is not caught anywhere during its propagation path, known also as <em class="italic">stack unwinding</em>, then it terminates the program by invoking the <span class="No-Break"><strong class="source-inline">std::terminate</strong></span><span class="No-Break"> function.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Check out the<a id="_idIndexMarker443"/> following <strong class="source-inline">std::system_error</strong> reference <span class="No-Break">page: </span><a href="https://en.cppreference.com/w/cpp/error/system_error"><span class="No-Break">https://en.cppreference.com/w/cpp/error/system_error</span></a><span class="No-Break">.</span></p>
<p>Now, let’s get back to our example and see how the <strong class="source-inline">main()</strong> method should be reworked in order to handle the exception thrown from the <span class="No-Break"><strong class="source-inline">CreateDirectory()</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
int main() {
    try {
        CreateDirectory("/tmp/test"); // First try succeeds
        CreateDirectory("/tmp/test"); // Second try throws
    } catch (const std::system_error&amp; se) { // {5}
        const auto econd{se.code()
          .default_error_condition()}; // {6}
        if (econd != std::errc::file_exists) { // {7}
            std::cerr &lt;&lt; "Unexpected system error: " &lt;&lt;
              se.what() &lt;&lt; '\n';
            throw; // {8}
        }
        std::cout &lt;&lt; "Nothing unexpected, safe to
          continue.\n";
    }
    return 0;
}</pre> <p>Unlike error<a id="_idIndexMarker444"/> codes, which, once returned by a function, need to be assigned and checked, the exceptions need to be caught and appropriate actions should be taken. Catching exceptions in C++ is done with the help of the try-catch construction in the language. In the preceding example, you can see that we invoke the <strong class="source-inline">CreateDirectory()</strong> method twice because the second invocation will generate an error, which will be propagated up the stack as an exception. This exception will be caught by the <strong class="source-inline">catch</strong> clause in marker <strong class="source-inline">{5}</strong>. As you can see, the <strong class="source-inline">catch</strong> clause expects a parameter that specifies what should be caught; see marker <strong class="source-inline">{5}</strong>. Its syntax is similar to the function’s parameter list, where you can pass objects either by value or <span class="No-Break">by reference.</span></p>
<p>In our example, we catch the exception thrown by the <strong class="source-inline">CreateDirectory()</strong> method by <em class="italic">constant reference</em>. The reason why we don’t catch by value is to avoid unnecessary object copying and – more importantly – to avoid <em class="italic">object slicing</em>. We will get deeper into the specifics of the exception-catching techniques in C++ soon, but for now, let’s focus on our current example. Once we catch the exception, we can extract the <strong class="source-inline">error_condition</strong> object from it; see marker <strong class="source-inline">{6}</strong>. This is possible because the <strong class="source-inline">system_error</strong> class supports error codes and error conditions and enables us to fetch them. When we have <strong class="source-inline">error_condition</strong>, we can successfully check against the well-known <strong class="source-inline">errc</strong> codes whether this exception is a real problem for our program or it can be omitted; see <span class="No-Break">marker </span><span class="No-Break"><strong class="source-inline">{7}</strong></span><span class="No-Break">.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Wherever possible, catch exceptions by reference (prefer constant) rather than by value to avoid potential object slicing and additional overhead due to <span class="No-Break">object copying.</span></p>
<p>Our business<a id="_idIndexMarker445"/> program logic expects that errors reporting that a file already exists are normal and should not break program execution. Ultimately, it says that we try to create a directory that already exists, and that’s fine and we can continue. But if the error is something else that we don’t know what to do with, then we have to report that error and rethrow it to the upper methods in the call stack, which could better know what to do with such a kind of error. This is done with the <strong class="source-inline">throw</strong> clause in the language; see marker <strong class="source-inline">{8}</strong>. An important detail here is that in order to <em class="italic">rethrow an existing exception</em> rather than throwing a new one, you have to just use <strong class="source-inline">throw;</strong> with <span class="No-Break"><em class="italic">no arguments</em></span><span class="No-Break">.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Use the <strong class="source-inline">throw;</strong> clause with no arguments to rethrow an <span class="No-Break">existing exception.</span></p>
<p>Of course, if the error is what we expect, such as <strong class="source-inline">std::errc::file_exists</strong>, then we can safely continue the program execution without the need to rethrow this exception. You can find the output of the program <span class="No-Break">as follows:</span></p>
<pre class="console">
CreateDirectory reports error: File exists
Nothing unexpected, safe to continue.</pre> <p>We can see that the exception is thrown by the <strong class="source-inline">CreateDirectory()</strong> method and it is caught by the <strong class="source-inline">catch</strong> clause in the <strong class="source-inline">main()</strong> method. In this example, we saw that using exceptions instead of error codes clearly segregates the normal program execution path from the error path and makes it easier to rethrow errors that we can’t properly <span class="No-Break">deal with.</span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor082"/>Throw by value, catch by reference</h2>
<p>In C++, we can literally throw every object. You could successfully do this <span class="No-Break">as follows:</span></p>
<pre class="source-code">
throw 42;</pre> <p>The preceding statement throws an integer object with a value of <strong class="source-inline">42</strong>. But just because you can do something, it doesn’t mean it’s a good idea to do so. The goal of the exception is to bring context to the error that occurred. Throwing the value of <strong class="source-inline">42</strong> doesn’t provide much context, right? What does <strong class="source-inline">42</strong> mean for the recipient of your exception? <span class="No-Break">Not much!</span></p>
<p>This statement is fully confirmed <a id="_idIndexMarker446"/>by the C++ Core Guidelines project developed by some of the key members of the C++ Standards Committee. The C++ Core Guidelines are a really useful guide for every C++ developer no matter what level of expertise you have. It gathers recommendations and best practices about different features <span class="No-Break">in C++.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Make sure to get familiar <a id="_idIndexMarker447"/>with the C++ Core Guidelines, which you can find <span class="No-Break">at </span><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c-core-guidelines"><span class="No-Break">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c-core-guidelines</span></a><span class="No-Break">.</span></p>
<p>The C++ Core Guidelines say that we have to make sure that we throw meaningful exceptions. If you don’t have a standard defined exception that works for your case, you can throw a user-defined type that derives from some of the <span class="No-Break">standard exceptions:</span></p>
<p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types"><span class="No-Break">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types</span></a></p>
<p>The C++ Core Guidelines also suggest throwing our exceptions by value and catching them by reference. Of course, even better if we catch by constant reference. Throwing by value ensures that the lifetime of the thrown object will be managed by the runtime of your system. Otherwise, if you throw a pointer to an object that you have allocated on the heap whose responsibility will be to delete this object when it is no longer needed, it is quite possible you will end up with <span class="No-Break">leaked memory:</span></p>
<p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e15-throw-by-value-catch-exceptions-from-a-hierarchy-by-reference"><span class="No-Break">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e15-throw-by-value-catch-exceptions-from-a-hierarchy-by-reference</span></a></p>
<p>Let’s go through an<a id="_idIndexMarker448"/> example. We will define a method – <strong class="source-inline">Throw()</strong> – which <a id="_idIndexMarker449"/>throws by value a <strong class="source-inline">std::system_error</strong> exception with an error code – <span class="No-Break"><strong class="source-inline">bad_file_descriptor</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
void Throw() {
    using namespace std;
    throw system_error{make_error_code
      (errc::bad_file_descriptor)};
}</pre> <p>This method will be invoked by the <strong class="source-inline">main()</strong> method in which we will catch the <span class="No-Break">thrown exception:</span></p>
<pre class="source-code">
int main() {
    using namespace std;
    try {
        try {
            Throw(); // {1}
        } catch (runtime_error e) { // {2}
            throw e; // {3}
        }
    } catch (const exception&amp; e) { // {4}
        const system_error&amp; se{dynamic_cast&lt;const
          system_error&amp;&gt;(e)}; // {5}
        const auto econd{se.code()
          .default_error_condition()};
        std::cerr &lt;&lt; econd.message() &lt;&lt; '\n';
    }
    return 0;
}</pre> <p>As you can see in<a id="_idIndexMarker450"/> the preceding example, we have defined two <strong class="source-inline">try-catch</strong> blocks – one inner and one outer. The reason behind this is that exceptions thrown in <a id="_idIndexMarker451"/>the <strong class="source-inline">catch</strong> branch can’t be caught by another <strong class="source-inline">catch</strong> branch in the same try-catch block. They are propagated out and, therefore, in order to catch them, we need an outer <span class="No-Break">try-catch block.</span></p>
<p>In marker <strong class="source-inline">{1}</strong>, we invoke the <strong class="source-inline">Throw()</strong> method, which throws an exception. But in marker <strong class="source-inline">{2}</strong>, we catch the thrown exception. Actually, we don’t catch <strong class="source-inline">std::system_error</strong> directly but we catch its parent class – <strong class="source-inline">std::runtime_error</strong>. Also, you can see that we catch this exception by value with <span class="No-Break"><strong class="source-inline">runtime_error e</strong></span><span class="No-Break">.</span></p>
<p>The only action we take once we catch the <strong class="source-inline">runtime_error</strong> exception is to throw it away from the inner try-catch block with the <span class="No-Break">following statement:</span></p>
<pre class="source-code">
throw e;</pre> <p>Always be careful when you rethrow an existing exception. The upper statement <em class="italic">doesn’t rethrow</em> the exception caught in the <strong class="source-inline">catch</strong> clause but it throws a new instance of the <strong class="source-inline">runtime_error</strong> exception, which is a copy of the caught <span class="No-Break">exception, instead.</span></p>
<p>Once the new exception is thrown, it is caught by the outer <strong class="source-inline">catch</strong> clause in marker <strong class="source-inline">{4}</strong>. As you can see, following the recommendation from the C++ Core Guidelines, we catch a constant reference instead of a value to the Standard Library’s base exception class – <strong class="source-inline">std::exception</strong> – which is also a base class <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">std::runtime_error</strong></span><span class="No-Break">.</span></p>
<p>In the <strong class="source-inline">catch</strong> clause, we try to downcast it back to its original type – <strong class="source-inline">std::system_error</strong> – and print the message from its <strong class="source-inline">std::error_condition</strong>. Let’s see the output from <span class="No-Break">the program:</span></p>
<pre class="console">
terminate called after throwing an instance of 'std::bad_cast'
  what():  std::bad_cast</pre> <p>But surprisingly, we don’t get the expected result. The downcast has failed, and when it fails, it generates a standard exception – <strong class="source-inline">std::bad_cast</strong> – which is thrown away from the outer <strong class="source-inline">catch</strong> clause. But this exception is not guarded by another try-catch block, and therefore, it propagates out of the <strong class="source-inline">main()</strong> method, which is de facto the top of the function stack of the program. As we explained earlier, if an exception is not caught during its propagation upwind in the function stack, then the <strong class="source-inline">std::terminate</strong> function will <span class="No-Break">be called.</span></p>
<p>But why did the <a id="_idIndexMarker452"/>cast fail when we tried to downcast to <strong class="source-inline">std::system_error</strong>? The reason is that the <strong class="source-inline">Throw()</strong> method throws <strong class="source-inline">std::system_error</strong> and everything should work fine. Well, it should, but it doesn’t really. Let’s get deeper <span class="No-Break">into this.</span></p>
<p>The <strong class="source-inline">Throw()</strong> method really throws an instance of <strong class="source-inline">std::system_error</strong> by <em class="italic">value</em>. But the inner <strong class="source-inline">catch</strong> clause catches a <em class="italic">base class exception</em> also <em class="italic">by value</em> and throws a <em class="italic">copy</em> <span class="No-Break">of it:</span></p>
<pre class="source-code">
catch (runtime_error e) {
    throw e;
}</pre> <p>This leads to a problem because the object we rethrow is no longer an instance of <strong class="source-inline">std::system_error</strong>. It has been sliced to its base class – <strong class="source-inline">std::runtime_error</strong>. All the information that has been part of the <em class="italic">original</em> <strong class="source-inline">std::system_error</strong> object is no longer part of the newly created <em class="italic">copy</em> of the <strong class="source-inline">std::runtime_error</strong> – <span class="No-Break"><strong class="source-inline">e</strong></span><span class="No-Break"> type.</span></p>
<p>Therefore, the downcast to <strong class="source-inline">std::system_error</strong> doesn’t succeed and our <span class="No-Break">program terminates.</span></p>
<p>To conclude, we can say that these kinds of errors can be successfully prevented by following the rules of throwing exceptions by value, catching them by reference, and rethrowing the existing exceptions rather than their copy wherever this <span class="No-Break">is possible.</span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor083"/>try/catch … finally</h2>
<p>You probably noticed that in the C++ language, we have<a id="_idIndexMarker453"/> the <strong class="source-inline">try-catch</strong> block, but we don’t have the <strong class="source-inline">finally</strong> construct. If you have experience in languages such as C# or Java, you will be used to releasing the resource that you have acquired using <a id="_idIndexMarker454"/>the <strong class="source-inline">finally</strong> clause. But this works only for exceptional cases where the <strong class="source-inline">try</strong> clause is preceding the usage <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">finally</strong></span><span class="No-Break">.</span></p>
<p>But how do we do<a id="_idIndexMarker455"/> it in C++ without <strong class="source-inline">finally</strong>? Let’s revisit our initial example for opening and closing a file using the <strong class="source-inline">open()</strong> and <strong class="source-inline">close()</strong> <span class="No-Break">POSIX functions:</span></p>
<pre class="source-code">
int main() {
    try {
        const int fd{open("/tmp/cpp-test-file", O_RDONLY)};
          // {1}
        if (fd == -1) { return errno; }
        // Do something with the file and suddenly
          something throws {2}
        if (close(fd) == -1) { return errno; } // {3}
    } catch (...) {
        std::cerr &lt;&lt; "Something somewhere went terribly
          wrong!\n";
        return -1;
    }
    return 0;
}</pre> <p>As we already discussed earlier in the chapter, opening a file using the <strong class="source-inline">open()</strong> POSIX method returns the ID of the file descriptor if the function successfully opens the file; otherwise, as with many of the POSIX functions, it returns <strong class="source-inline">-1</strong>; see <span class="No-Break">marker </span><span class="No-Break"><strong class="source-inline">{1}</strong></span><span class="No-Break">.</span></p>
<p>Once you have your file opened, it is your responsibility to ensure that <em class="italic">finally</em>, when you finish with it, it will be closed. Therefore, we invoke the <strong class="source-inline">close()</strong> method at the end of the <strong class="source-inline">main()</strong> method to ensure that the file will be closed (see marker <strong class="source-inline">{3}</strong>) just before we leave <strong class="source-inline">main()</strong>. But how can you be sure that some abnormal situation won’t occur, and an exception won’t be thrown before you close your file? Actually, the only case in which you can be sure that this won’t happen is if exceptions are not supported in your system. But in our test Linux environment, this is not the case. Even worse, when working in real code <a id="_idIndexMarker456"/>bases, it’s hard to be sure that some of the methods you invoke during your normal business logic execution <span class="No-Break">won’t throw.</span></p>
<p>Imagine what <a id="_idIndexMarker457"/>happens if your program throws before you close your file; see marker <strong class="source-inline">{2}</strong>. Effectively, you will <em class="italic">leak</em> a resource. As a rule of thumb, we should never leak resources, no matter whether this will lead to a problem <span class="No-Break">or not.</span></p>
<p>But how can we protect ourselves from leaking resources without having the <strong class="source-inline">finally</strong> clause in the language? Let’s have a look into one of the most typical C++ <span class="No-Break">programming techniques:</span></p>
<pre class="source-code">
void Throw() {
    cout &lt;&lt; "Ops, I need to throw ...\n";
    throw system_error{make_error_code
      (errc::bad_file_descriptor)};
}
int main() {
    const string_view myFileName{"/tmp/cpp-test-file"}; //
      {1}
    ofstream theFile(myFileName.data()); // {2}
    try {
        file_guard guard(myFileName, O_RDONLY); // {3}
        const auto fd = guard.getFileDescriptor();
        Throw(); // {4}
    } catch (const exception&amp; e) {
        cout &lt;&lt; e.what();
        return -1;
    }
    return 0;
}</pre> <p>We have reworked <a id="_idIndexMarker458"/>our <strong class="source-inline">main()</strong> method in such a way that we just create a<a id="_idIndexMarker459"/> file (see marker <strong class="source-inline">{2}</strong>) and pass its filename (see marker <strong class="source-inline">{1}</strong>) to a new object of the <strong class="source-inline">file_guard</strong> type (see marker <strong class="source-inline">{3}</strong>), which we will look at it just in a moment. The <strong class="source-inline">file_guard</strong> object is responsible for opening and closing a file with a <span class="No-Break">specific name:</span></p>
<pre class="source-code">
using namespace std;
class file_guard final {
public:
    file_guard(string_view file, mode_t mode) : // {5}
        fd{open(file.data(), mode)}
    {
        if (fd == -1) {
            throw system_error
              {make_error_code(errc{errno})};
        }
        cout &lt;&lt; "File '" &lt;&lt; file &lt;&lt;
        "' with file descriptor '" &lt;&lt;
        fd &lt;&lt; "' is opened.\n";
    }
    explicit file_guard(const file_guard&amp;) = delete; // {6}
    file_guard&amp; operator=(const file_guard&amp;) = delete;
    explicit file_guard(file_guard&amp;&amp; other) noexcept : //
      {7}
        fd{move(other.fd)} { other.fd = -1; }
    file_guard&amp; operator=(file_guard&amp;&amp; other) noexcept
    {
        fd = move(other.fd);
        other.fd = -1;
        return *this;
    }
    int getFileDescriptor() const noexcept { // {8}
        return fd;
    }
    ~file_guard() noexcept { // {9}
        if (fd != -1) {
            close(fd);
            cout &lt;&lt; "File with file descriptor '" &lt;&lt; fd &lt;&lt;
              "' is closed.\n";
        }
    }
private:
    int fd;
};</pre> <p>The class gets in its <a id="_idIndexMarker460"/>constructor the file path and the mode in which the file <a id="_idIndexMarker461"/>should be opened; see marker <strong class="source-inline">{5}</strong>. In the initializer list of the constructor, the POSIX <strong class="source-inline">open()</strong> method is invoked. The result, which is the file descriptor ID, is assigned to the <strong class="source-inline">_fd</strong> member of the class. If <strong class="source-inline">open()</strong> fails, an exception is thrown away from the <strong class="source-inline">file_guard</strong> constructor. We should not care about closing the file in this case because we didn’t open <span class="No-Break">it successfully.</span></p>
<p>In the destructor of the class, we have the reversed operation; see marker <strong class="source-inline">{9}</strong>. If the file descriptor is different from <strong class="source-inline">-1</strong>, which means that the file has been successfully opened before that, we <span class="No-Break">close it.</span></p>
<p>This C++ programming <a id="_idIndexMarker462"/>technique is called <strong class="bold">Resource Acquisition Is Initialization</strong>, or just <strong class="bold">RAII</strong>. It is a resource management technique that acquires the resource during the construction of the RAII object and releases it during the destruction of that <a id="_idIndexMarker463"/>object. Unlike in languages such as Java and C# that use automatic garbage collection and whose resource release timing is not entirely clear to the user, C++ objects have a precisely defined storage duration and lifetime. Thus, we can rely on this characteristic and utilize RAII objects to manage <span class="No-Break">our resources.</span></p>
<p>Going back to our <strong class="source-inline">main()</strong> method, if the file is opened (see marker <strong class="source-inline">{3}</strong>) and something goes wrong before it has been explicitly closed (see marker <strong class="source-inline">{4}</strong>), we will be sure that it will be automatically closed once the <strong class="source-inline">file_guard</strong> object goes out <span class="No-Break">of scope.</span></p>
<p>This technique is widely used no matter whether exceptions are available in the system or not. You can wrap your resources using RAII and be assured that they will be automatically released whenever you leave the scope where the RAII <span class="No-Break">object lives.</span></p>
<p>In our <strong class="source-inline">file_guard</strong> example, we have removed the copy constructor and the copy assignment operator and left the move constructor and move operator only, claiming that this RAII object is <span class="No-Break">not copyable.</span></p>
<p>C++ is often questioned about not having the <strong class="source-inline">finally</strong> construct. However, the inventor of C++, Bjarne Stroustrup, has explained that RAII is a better <span class="No-Break">substitute:</span><span class="No-Break"><span class="hidden"> </span></span><a href="https://www.stroustrup.com/bs_faq2.xhtml#finally"><span class="No-Break">https://www.stroustrup.com/bs_faq2.xhtml#finally</span></a><span class="No-Break">.</span></p>
<p>Stroustrup argues that in practical code bases, there are many more resource acquisitions and releases, and using RAII instead of <strong class="source-inline">finally</strong> results in less code. Additionally, it is less susceptible to errors since the RAII wrapper only needs to be coded once, and there is no need to remember to release the <span class="No-Break">resource manually.</span></p>
<p>The Standard Library has many examples of RAII objects, such as <strong class="source-inline">std::unique_ptr</strong>, <strong class="source-inline">std::lock_guard</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">std::fstreams</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor084"/>Summary</h1>
<p>This chapter has covered various techniques for error handling when working with POSIX APIs in C++. We discussed the use of <strong class="source-inline">errno</strong>, a thread-local variable, and the <strong class="source-inline">strerror</strong> function. We also explored how <strong class="source-inline">std::error_code</strong> and <strong class="source-inline">std::error_condition</strong> can wrap POSIX errors and how custom error categories enable us to compare errors generated by different sources and develop platform-independent error-handling code. Furthermore, we delved into exceptions in C++ and how to convert <strong class="source-inline">std::error_code</strong> into an exception of the <span class="No-Break"><strong class="source-inline">std::system_error</strong></span><span class="No-Break"> type.</span></p>
<p>We also examined best practices for working with exceptions, such as throwing them by value and catching them by reference, to avoid issues such as object slicing. Finally, we learned about the RAII technique in C++, which eliminates the need for a <strong class="source-inline">finally</strong> construct in <span class="No-Break">the language.</span></p>
<p>In the next chapter, we will explore the topic of concurrency <span class="No-Break">with C++.</span></p>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer040">
<h1 id="_idParaDest-85" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor085"/>Part 2:Advanced Techniques for System Programming</h1>
</div>
<div id="_idContainer041">
<p>In this part, you will learn about expert-level C++20 features, which will further improve both your OS and C++ development expertise. The examples, though still practical, become more complex and require some preliminary understanding of the subject of <span class="No-Break">system programming.</span></p>
<p>This part has the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B20833_06.xhtml#_idTextAnchor086"><em class="italic">Chapter 6</em></a><em class="italic">, Concurrent System Programming with C++</em></li>
<li><a href="B20833_07.xhtml#_idTextAnchor101"><em class="italic">Chapter 7</em></a><em class="italic">, Proceeding with Inter-Process Communication</em></li>
<li><a href="B20833_08.xhtml#_idTextAnchor116"><em class="italic">Chapter 8</em></a><em class="italic">, Using Clocks, Timers, and Signals in Linux</em></li>
<li><a href="B20833_09.xhtml#_idTextAnchor129"><em class="italic">Chapter 9</em></a><em class="italic">, Understanding the C++ Memory Model</em></li>
<li><a href="B20833_10.xhtml#_idTextAnchor147"><em class="italic">Chapter 10</em></a><em class="italic">, Using Coroutines in C++ for System Programming</em></li>
</ul>
</div>
<div>
<div id="_idContainer042">
</div>
</div>
<div>
<div id="_idContainer043">
</div>
</div>
<div>
<div id="_idContainer044">
</div>
</div>
<div>
<div id="_idContainer045">
</div>
</div>
<div>
<div id="_idContainer046">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer047">
</div>
</div>
<div>
<div id="_idContainer048">
</div>
</div>
<div>
<div id="_idContainer049">
</div>
</div>
</div></body></html>