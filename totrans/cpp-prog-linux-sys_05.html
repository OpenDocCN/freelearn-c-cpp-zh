<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-75"><a id="_idTextAnchor075"/>5</h1>
<h1 id="_idParaDest-76"><a id="_idTextAnchor076"/>Handling Errors with C++</h1>
<p>This chapter will focus on error handling in C++. As a programmer, you will inevitably encounter situations where you need to determine the best approach to propagate program errors. Whether you use error codes or exceptions, we will delve into them to gain a better understanding of how to use them effectively.</p>
<p>In this chapter, we will examine how to handle errors reported by POSIX APIs using C++. We will begin by covering the <code>errno</code> thread-local variable and the <code>strerror</code> function. After that, we will introduce <code>std::error_code</code> and <code>std::error_condition</code> and demonstrate how they help to wrap POSIX errors that come from POSIX APIs. We will also investigate custom error categories, which allow us to compare errors produced by various sources and develop platform-independent error-handling code.</p>
<p>As we progress, we will learn about exceptions in C++ and how to convert <code>std::error_code</code> into a <code>std::system_error</code> exception. We will also explore some best practices for working with exceptions, such as throwing exceptions by value and catching them by reference. Additionally, we will become acquainted with object slicing, a side effect that can occur when we catch exceptions by value rather than by reference. Finally, we will delve into the RAII technique in C++, which eliminates the need for a <code>finally</code> construct in the language.</p>
<p>By the end of this chapter, you will have a thorough understanding of the various ways to handle errors in C++, and you will be familiar with several techniques for creating error-resistant code.</p>
<p>Summing up, we will cover the following topics:</p>
<ul>
<li>Handling errors from POSIX APIs with C++</li>
<li>From error codes to exceptions</li>
</ul>
<p>Alright, it’s time to begin!</p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor077"/>Technical requirements</h1>
<p>All examples in this chapter have been tested in an environment with the following configuration:</p>
<ul>
<li>Linux Mint 21 Cinnamon edition</li>
<li>GCC 12.2 with compiler flags:<ul><li><code>-</code><code>std=c++20</code></li></ul></li>
<li>A stable internet connection</li>
<li>Please make sure your environment is at least that recent. For all the examples, you can alternatively use <a href="https://godbolt.org/">https://godbolt.org/</a>.</li>
<li>All code examples in this chapter are available for download from <a href="https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%205">https://github.com/PacktPublishing/C-Programming-for-Linux-Systems/tree/main/Chapter%205</a>.</li>
</ul>
<h1 id="_idParaDest-78"><a id="_idTextAnchor078"/>Handling errors from POSIX APIs with C++</h1>
<p>In<a id="_idIndexMarker412"/> POSIX-compliant systems, such as Unix and Linux, error handling is based on the use of error codes and error messages to communicate errors between functions and applications.</p>
<p>In <a id="_idIndexMarker413"/>general, when a function encounters an error, it returns a non-zero error code and sets the <code>errno</code> global variable to a specific error value that indicates the nature of the error. The application can then use the <code>errno</code> variable to determine the cause of the error and take appropriate action.</p>
<p>In addition to error codes, POSIX-compliant functions often provide error messages that describe the nature of the error in more detail. These error messages are typically accessed using the <code>strerror</code> function, which takes an error code as input and returns a pointer to a sequence of characters terminated with a null character containing the corresponding error message.</p>
<p>The POSIX error-handling style requires developers to check for errors after each system call or function call that may fail and to handle errors in a consistent and meaningful way. This can include logging error messages, retrying failed operations, or terminating the program in the event of a critical error.</p>
<p>Let’s look <a id="_idIndexMarker414"/>at the following example where we demonstrate how to use the <code>errno</code> variable and the <code>strerror()</code> function to handle <a id="_idIndexMarker415"/>errors from POSIX functions in C++. </p>
<p>The example uses the <code>open()</code> and <code>close()</code> POSIX functions, which try to open and close a file from the filesystem of our Linux test environment:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;cstring&gt;
int main() {
    const int fd{open("no-such-file.txt", O_RDONLY)}; //
      {1}
    if (fd == -1) {
        std::cerr &lt;&lt; "Error opening file: " &lt;&lt;
          strerror(errno) &lt;&lt; '\n';
        std::cerr &lt;&lt; "Error code: " &lt;&lt; errno &lt;&lt; '\n';
        return  EXIT_FAILURE;
    }
    // Do something with the file...
    if (close(fd) == -1) {
        std::cerr &lt;&lt; "Error closing file: " &lt;&lt;
          strerror(errno) &lt;&lt; '\n';
        std::cerr &lt;&lt; "Error code: " &lt;&lt; errno &lt;&lt; '\n';
        return  EXIT_FAILURE;
    }
    return 0;
}</pre> <p>In this <a id="_idIndexMarker416"/>example, we attempt to open a file for reading called <code>no-such-file.txt</code> using the <code>open()</code> function; see marker <code>{1}</code>. In case <a id="_idIndexMarker417"/>of success, <code>open()</code> returns a non-negative integer, which corresponds to the file descriptor ID of the successfully opened file. If <code>open()</code> returns <code>-1</code>, we know an error occurred, so we print the error message using <code>strerror(errno)</code> and return the value of <code>errno</code> where the corresponding error code is written.</p>
<p>If <code>open()</code> succeeds, we do something with the file and then close it using the <code>close()</code> function. If <code>close()</code> returns <code>-1</code>, we print the error message again using <code>strerror(errno)</code> and return the value of <code>errno</code>.</p>
<p>This is a common error-handling technique for POSIX functions. In case of an error, they return <code>-1</code> and set the <code>errno</code> variable with the corresponding error code. The <code>errno</code> variable is<a id="_idIndexMarker418"/> a <em class="italic">thread-local</em> modifiable variable of the <code>int</code> type. This means that it is safe for you to use it in a multithreaded environment. Each thread will have its own copy, and POSIX methods invoked by this thread will use this instance to report errors.</p>
<p>In order to print a meaningful message in the case of an error, we use the <code>strerror()</code> function, which accepts an integer and tries to match its value to a well-known list of descriptions of system-specific error codes. The <code>open()</code> function can report several errors and set different values to <code>errno</code> depending on the type of the occurred error. Let’s see the output of the example:</p>
<pre class="console">
Error opening file: No such file or directory
Error code: 2</pre> <p>As we can see, the <code>open()</code> method has failed to open the file because it doesn’t exist. In this case, it sets <code>errno</code> to a value of <code>2</code>, which corresponds to the <code>ENOENT</code> value specified in the documentation of the function. It is a good practice to explicitly set <code>errno</code> to <code>0</code> before you do a system call to ensure that after the call, you can read its real response.</p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor079"/>Using std::error_code and std::error_condition</h2>
<p>The C++ Standard Library <a id="_idIndexMarker419"/>provides several classes for handling errors from low-level APIs such as the POSIX interface. These classes are <code>std::error_code</code> for handling system-specific errors and <code>std::error_condition</code>, which deals with portable error codes. Let us explore both styles in more detail.</p>
<h3>std::error_code</h3>
<p>Let’s rework<a id="_idIndexMarker420"/> our previous example in such a way that we provide a function for the creation of a directory with a specific directory path:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;sys/stat.h&gt;
std::error_code CreateDirectory(const std::string&amp; dirPath) {
    std::error_code ecode{};
    if (mkdir(dirPath.c_str(), 0777) != 0) {
        ecode = std::error_code{errno,
          std::generic_category()}; // {1}
    }
    return ecode;
}
int main() {
    auto ecode{CreateDirectory("/tmp/test")};
    if (ecode){ // {2}
        std::cerr &lt;&lt; "Error 1: " &lt;&lt; ecode.message() &lt;&lt;
          '\n';
    }
    ecode = CreateDirectory("/tmp/test"); // {3}
    if (ecode){
        std::cerr &lt;&lt; "Error 2: " &lt;&lt; ecode.message() &lt;&lt;
          '\n';
    }
    if (ecode.value() == EEXIST) {
        std::cout &lt;&lt; "This is platform specific and not
          portable.\n";
    }
    return 0;
}</pre> <p>Rather <a id="_idIndexMarker421"/>than the client of our new function, <code>CreateDirectory</code>, using the <code>errno</code> variable directly to determine whether the operation was successful, we will make use of a utility class provided by the Standard Library – <code>std::error_code</code>. <code>std::error_code</code> is used to store and transmit error codes as they were generated by libraries or system calls. It is a kind of wrapper class for which there are predefined categories of errors to work with. The errors returned by the POSIX functions are mostly standard and, as such, are predefined in the Standard Library. Therefore, it is straightforward to create a <code>std::error_code</code> instance from the <code>errno</code> value and specify that this value corresponds to <code>std::generic_category()</code>, as done in marker <code>{1}</code> in the preceding example. The <code>errno</code> value is de facto casted to a constant of the <code>std::errc</code> enumerator.</p>
<p>The created <code>std::error_code</code> object has two methods that can give you details about the underlying error. The <code>std::error_code::message()</code> method returns a meaningful string that can be used for logging purposes. The <code>std::error_code::value()</code>method, in our example, returns the value initially stored in the <code>errno</code> variable. But probably the most notable operation that the user can use from the <code>std::error_code</code> object is the predefined <code>operator bool()</code> of the class. In the case of an error stored in the object, it returns <code>true</code>; otherwise, it returns <code>false</code>.</p>
<p>As you <a id="_idIndexMarker422"/>can see from the preceding example, the caller of the <code>CreateCategory()</code> method checks whether an error occurred, and if so, it gets the message stored for this error; see marker <code>{2}</code>. Here, you can find the output of the program run on our test environment:</p>
<pre class="console">
Error 2: File exists
This is platform specific and not portable.</pre> <p>As is visible from the program’s output, the first <code>CreateDirectory()</code> invocation succeeds but the second one fails; see marker <code>{3}</code>. This is because the implementation of <code>CreateDirectory()</code> first checks whether such a directory already exists and if not, it creates it for us. But if the directory exists, the <code>mkdir()</code> system call returns <code>–1</code> and sets <code>errno</code> to <code>EEXIST</code>.</p>
<p>Something important about the <code>std::error_code</code> class is that it is platform specific. This means that the error values stored in it strongly depend on the underlying OS. In the case of a POSIX-like system, which Linux is, the error value we have is <code>EEXIST</code>. But this is not necessarily true for other OSs.</p>
<p>Therefore, if we design our code to be as platform agnostic as possible, we need to avoid comparations such as the following:</p>
<pre class="source-code">
if (ecode.value() == EEXIST)</pre> <p>But we also need a way to ensure that a directory that already exists doesn’t break our program logic. Yes, from a POSIX standpoint this is an error, but in our specific business logic, this is not a problem for the program execution to continue.</p>
<h3>std::error_condition</h3>
<p>The<a id="_idIndexMarker423"/> right approach to address this problem is with the help of another Standard Library class – <code>std::error_condition</code>. As the name suggests, its main purpose is to provide conditional program logic. Let’s slightly rework the <code>CreateDirectory()</code> method from the earlier example:</p>
<pre class="source-code">
std::error_code CreateDirectory(const std::string&amp; dirPath) {
    std::error_code ecode{};
    if (mkdir(dirPath.c_str(), 0777) != 0) {
        std::errc cond{errno}; // {1}
        ecode = std::make_error_code(cond); // {2}
    }
    return ecode;
}</pre> <p>As you can see, the <a id="_idIndexMarker424"/>difference from the previous example is how we construct the <code>error_code</code> object. In the reworked code, we first create an object of the <code>std::errc</code> type and initialize it with the value of POSIX <code>errno</code>; see marker <code>{1}</code>. The <code>std::errc</code> class is a scoped enumerator class. It defines <em class="italic">portable error conditions</em> that correspond to the specific POSIX error codes. This implies that instead of relying on a platform-specific macro that corresponds to a particular POSIX error code, such as <code>EEXIST</code>, we switch to an error that will have the same error condition regardless of the platform it comes from.</p>
<p class="callout-heading">Important note</p>
<p class="callout">You can find the predefined portable error conditions<a id="_idIndexMarker425"/> of the <code>std::errc</code> scoped enumerator, which correspond to their equivalent POSIX error codes, here: <a href="https://en.cppreference.com/w/cpp/error/errc">https://en.cppreference.com/w/cpp/error/errc</a>.</p>
<p>Once we create an instance of <code>std::errc</code>, we pass it to the factory method for the creation of error codes – <code>std::make_error_code()</code> (see marker <code>{2}</code>) – which generates for us a <code>std::error_code</code> of a generic category.</p>
<p>Now, let’s see how the <code>main()</code> method is changed in order to be platform independent:</p>
<pre class="source-code">
int main() {
    auto ecode{CreateDirectory("/tmp/test")};
    if (ecode){
        std::cerr &lt;&lt; "Error 1: " &lt;&lt; ecode.message() &lt;&lt;
          '\n';
    }
    ecode = CreateDirectory("/tmp/test");
    if (ecode){
        std::cerr &lt;&lt; "Error 2: " &lt;&lt; ecode.message() &lt;&lt;
          '\n';
    }
    if (ecode == std::errc::file_exists) { // {3}
        std::cout &lt;&lt; "This is platform agnostic and is
          portable.\n";
    }
    return 0;
}</pre> <p>We still <a id="_idIndexMarker426"/>have two invocations of the <code>CreateDirectory()</code> method, and the second one still returns an <code>error_code</code>. But the main difference comes from how we compare the <code>ecode</code> object; see marker <code>{3}</code>. Instead of comparing it with an integer value of the error POSIX code, we compare it against an object that holds a portable error condition – <code>std::errc::file_exists</code>. It has the same semantics, saying that the file already exists, but it is platform independent. In the next section, we will see how useful this could be.</p>
<h3>Using custom error categories</h3>
<p>Every<a id="_idIndexMarker427"/> software developer should strive as much as possible to write portable code. Writing portable code provides reusability, which can significantly reduce development costs. Of course, this is not always possible. There are use cases where the code you write is dedicated to a specific system. But for all the rest, abstracting your code from the underlying system allows you to easily migrate it to other systems without carrying out huge refactoring to make it work. This is safer and cheaper.</p>
<p>Let’s get back to our previous example, where we tried to abstract the error code received from a POSIX system call. It should be comparable against a portable error condition such as <code>std::errc::file_exists</code>. We will extend this with the following use case. Imagine that we have a custom library that also works with files. Let’s call it <code>MyFileLibrary</code>. But this library doesn’t support the POSIX error codes. It provides a different <em class="italic">category</em> of custom error codes that semantically correspond to some of the POSIX codes but with different error values.</p>
<p>The<a id="_idIndexMarker428"/> library supports the following errors with their corresponding error codes:</p>
<pre class="source-code">
enum class MyFileLibraryError {
    FileNotFound = 1000,
    FileAlreadyExists = 2000,
    FileBusy = 3000,
    FileTooBig = 4000
};</pre> <p>As you can see, our library can return the <code>FileAlreadyExists</code> enumerated constant, just like the <code>mkdir()</code> system call does, but with a different error value – <code>1000</code>. So, the main logic that consumes both <code>MyFileLibrary</code> and <code>mkdir()</code> should be able to handle these errors in the same way, because they are semantically equal. Let’s see how this can be done.</p>
<p>In our previous example, we created the error code returned by the POSIX API:</p>
<pre class="source-code">
ecode = std::error_code{errno, std::generic_category()};</pre> <p>We used <code>std::generic_category</code>, which is a derived class from the base category class – <code>std::error_category</code>. It is predefined for us in the Standard Library in such a way that it <em class="italic">knows</em> POSIX error codes. This is effectively the place where the translation between the real error code returned by the API and <code>std::error_condition</code> is done. So, in order to expose the same capability for <code>MyFileLibrary</code>, we need to define a new <code>std::error_category</code> derived class. We will name it <code>MyFileLibraryCategory</code>:</p>
<pre class="source-code">
class MyFileLibraryCategory : public std::error_category {
public:
    const char* name() const noexcept override { // {1}
        return "MyFileLibrary";
    }
    std::string message(int ev) const override { // {2}
        switch (static_cast&lt;MyFileLibraryError&gt;(ev)) {
        case MyFileLibraryError::FileAlreadyExists:
            return "The file already exists";
        default:
            return "Unsupported error";
        }
    }
    bool equivalent(int code,
                    const std::error_condition&amp; condition)
                      const noexcept override { // {3}
        switch (static_cast&lt;MyFileLibraryError&gt;(code)) {
        case MyFileLibraryError::FileAlreadyExists:
            return condition == std::errc::file_exists; //
                {4}
        default:
            return false;
        }
    }
};</pre> <p>The <code>std::error_category</code> base class<a id="_idIndexMarker429"/> has several <em class="italic">virtual</em> methods that, if overridden in the derived class, allow custom behavior. In our example, we have overridden the following:</p>
<ul>
<li>The <code>name()</code> method, which is used to report which category this error belongs to; see marker <code>{1}</code></li>
<li>The <code>message()</code> method, which is used to report a message string that corresponds to a specific error value; see marker <code>{2}</code></li>
<li>The <code>equivalent()</code> method, which is used to make a comparison between the custom error code generated by our library and the predefined <code>std::error_condition</code> values</li>
</ul>
<p>The <code>equivalent()</code> method <a id="_idIndexMarker430"/>gets the custom error code, casts it to a value of <code>MyFileLibraryError</code>, and, for each specific case, decides what <code>condition</code> it matches; see marker <code>{3}</code>.</p>
<p>Now, since we have our new, shiny custom error category – <code>MyFileLibraryCategory</code> – let’s see how to use it:</p>
<pre class="source-code">
const MyFileLibraryCategory my_file_lib_category{}; // {1}
int main() {
    std::error_code file_exists{static_cast&lt;int&gt;
      (MyFileLibraryError::FileAlreadyExists),
       my_file_lib_category}; // {2}
    if (file_exists == std::errc::file_exists) { // {3}
        std::cout &lt;&lt; "Msg: " &lt;&lt; file_exists.message() &lt;&lt;
          '\n'; // {4}
        std::cout &lt;&lt; "Category: " &lt;&lt; file_exists
          .default_error_condition().category().name() &lt;&lt;
             '\n'; // {5}
    }
    return 0;
}</pre> <p>The first step we need to take is to instantiate an object of our custom category; see marker <code>{1}</code>. Then, we create an <code>error_code</code> instance, which we initialize with the <code>FileAlreadyExists</code> error value and specify that it is from the <code>MyFileLibraryCategory</code> category; see marker <code>{2}</code>. Since we have a valid instance of an error code – <code>file_exists</code> – we are ready to compare it against the platform-independent <code>std::errc::file_exists</code> error condition.</p>
<p>The following is the output of the program:</p>
<pre class="console">
Msg: The file already exists
Category: MyFileLibrary</pre> <p>As you <a id="_idIndexMarker431"/>can see, the comparation between an error generated from <code>MyFileLibrary</code> and the generic <code>std::errc::file_exists</code> is now possible with the help of the custom error category we defined – <code>MyFileLibraryCategory</code>. The corresponding error message is displayed (see marker <code>{3}</code>) and the category as well (see marker <code>{4}</code>).</p>
<p class="callout-heading">Important note</p>
<p class="callout">Here, you can find the full description with all virtual methods that the <code>std::error_category</code> base class <a id="_idIndexMarker432"/>exposes: <a href="https://en.cppreference.com/w/cpp/error/error_category">https://en.cppreference.com/w/cpp/error/error_category</a>.</p>
<p>Now that we are familiar with the usage of error codes and error conditions, let’s see how we can use the powerful mechanism of C++ exceptions and propagate errors.</p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor080"/>From error codes to exceptions</h1>
<p>Exception handling<a id="_idIndexMarker433"/> is an important aspect of programming, especially when dealing with errors that can disrupt the normal flow of a program. While there are several ways to handle errors in a code base, exceptions provide a powerful mechanism for handling errors in a way that separates error flow from normal program flow.</p>
<p>When working with <a id="_idIndexMarker434"/>error codes, it can be challenging to ensure that all error cases are properly handled and that the code remains maintainable. By wrapping error codes in exceptions, we can create a more pragmatic approach to error handling that makes it easier to reason about code and catch errors in a more centralized manner.</p>
<p>It’s hard to<a id="_idIndexMarker435"/> say which<a id="_idIndexMarker436"/> approach is better when dealing with error handling in a code base, and the decision to use exceptions should be based on pragmatic considerations. While exceptions can provide significant benefits in terms of code organization and maintainability, they may come with a performance penalty that may not be acceptable in certain systems.</p>
<p>At their core, exceptions are a way to segregate the normal program flow from the error flow. Unlike error codes, which can be ignored, exceptions cannot be easily overlooked, making them a more reliable way to ensure that errors are handled in a consistent and centralized manner.</p>
<p>While exceptions may not be the right choice for every code base, they offer a powerful way to handle errors that can make code easier to maintain and reason about. By understanding how to correctly use exceptions, programmers can make informed decisions about how to handle errors in their code. Let’s get deeper into this.</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor081"/>std::system_error</h2>
<p>In the previous<a id="_idIndexMarker437"/> section, we created a program that properly handles<a id="_idIndexMarker438"/> errors reported by the POSIX system call – <code>mkdir()</code>. Now, let’s see how we can improve the error handling in this program using exceptions instead of error codes. Here is the revisited <code>CreateDirectory()</code> method:</p>
<pre class="source-code">
void CreateDirectory(const std::string&amp; dirPath) { // {1}
    using namespace std;
    if (mkdir(dirPath.c_str(), 0777) != 0) {
        const auto ecode{make_error_code(errc{errno})}; //
           {2}
        cout &lt;&lt; "CreateDirectory reports error: " &lt;&lt;
          ecode.message() &lt;&lt; '\n';
        system_error exception{ecode}; // {3}
        throw exception; // {4}
    }
}</pre> <p>In the <code>CreateDirectory()</code> method, we make a system call using the <code>mkdir()</code> API, which, in the case of failure, returns a non-zero result and stores a POSIX error code in the <code>errno</code> variable. Nothing new so far. Just as in our previous example, we create an <code>std::error_code</code> from the value of <code>errno</code> (see marker <code>{2}</code>) to report it to the caller of our <code>CreateDirectory()</code> method. But instead of returning the error directly as a result of the function, we prefer to use an exception for this and make our function <code>{1}</code>.</p>
<p>Since we <a id="_idIndexMarker439"/>already <a id="_idIndexMarker440"/>have an error code object created, we will use it to create an exception from it. In order to do so, we will use a predefined exception class from the Standard Library that is explicitly defined to wrap <code>std::error_code</code> objects – <code>std::system_error</code>.</p>
<p><code>std::system_error</code> is a derived type from the <code>std::exception</code> interface class from the C++ Standard Library. It is used by various library functions, which typically interface with OS facilities and can report errors either by generating <code>std::error_code</code> or <code>std::error_condition</code>.</p>
<div><div><img alt="Figure 5.1 – Inheritance diagram of std::system_error exception" height="328" src="img/Figure_5.1_B20833.jpg" width="358"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Inheritance diagram of std::system_error exception</p>
<p>In our example, in order to create an <code>std::system_error</code> object, we have to pass to its constructor the instance of <code>std::error_code ecode</code>, which we already created; see marker <code>{3}</code>.</p>
<p>As with any other exception derived from the base exception class from the Standard Library – <code>std::exception</code> – <code>std::system_error</code> has the <code>what()</code> method. It aims to report a meaningful string explaining details about the error behind the exception. More specifically, it calls under the hood the <code>message()</code> method of the <code>std::error_code</code> object it wraps and returns its result.</p>
<p>Since<a id="_idIndexMarker441"/> we <a id="_idIndexMarker442"/>already have a new, shiny exception object created, we now need to <em class="italic">throw</em> it back to the caller of our API. This is done with the <code>throw</code> keyword; see marker <code>{4}</code>. An important note is that we throw the exception object by <em class="italic">value</em>; we don’t throw a reference or a pointer to it.</p>
<p class="callout-heading">Important note</p>
<p class="callout">As a rule of thumb, wherever possible, throw your exceptions by value.</p>
<p>One of the key advantages of exceptions over error codes is that they <em class="italic">can’t be omitted</em> by the caller. When a function returns an error code, it is up to the function’s caller to decide whether to check the return value or not. There are some cases where the return value is not checked by mistake, and this leads to bugs in the program. When using exceptions as an error-handling mechanism, there is no such possibility. Once an exception is thrown, it propagates up the call stack until it is either caught by the appropriate program exception-handling logic or reaches the top of the function stack. If the exception is not caught anywhere during its propagation path, known also as <em class="italic">stack unwinding</em>, then it terminates the program by invoking the <code>std::terminate</code> function.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Check out the<a id="_idIndexMarker443"/> following <code>std::system_error</code> reference page: <a href="https://en.cppreference.com/w/cpp/error/system_error">https://en.cppreference.com/w/cpp/error/system_error</a>.</p>
<p>Now, let’s get back to our example and see how the <code>main()</code> method should be reworked in order to handle the exception thrown from the <code>CreateDirectory()</code> method:</p>
<pre class="source-code">
int main() {
    try {
        CreateDirectory("/tmp/test"); // First try succeeds
        CreateDirectory("/tmp/test"); // Second try throws
    } catch (const std::system_error&amp; se) { // {5}
        const auto econd{se.code()
          .default_error_condition()}; // {6}
        if (econd != std::errc::file_exists) { // {7}
            std::cerr &lt;&lt; "Unexpected system error: " &lt;&lt;
              se.what() &lt;&lt; '\n';
            throw; // {8}
        }
        std::cout &lt;&lt; "Nothing unexpected, safe to
          continue.\n";
    }
    return 0;
}</pre> <p>Unlike error<a id="_idIndexMarker444"/> codes, which, once returned by a function, need to be assigned and checked, the exceptions need to be caught and appropriate actions should be taken. Catching exceptions in C++ is done with the help of the try-catch construction in the language. In the preceding example, you can see that we invoke the <code>CreateDirectory()</code> method twice because the second invocation will generate an error, which will be propagated up the stack as an exception. This exception will be caught by the <code>catch</code> clause in marker <code>{5}</code>. As you can see, the <code>catch</code> clause expects a parameter that specifies what should be caught; see marker <code>{5}</code>. Its syntax is similar to the function’s parameter list, where you can pass objects either by value or by reference.</p>
<p>In our example, we catch the exception thrown by the <code>CreateDirectory()</code> method by <em class="italic">constant reference</em>. The reason why we don’t catch by value is to avoid unnecessary object copying and – more importantly – to avoid <em class="italic">object slicing</em>. We will get deeper into the specifics of the exception-catching techniques in C++ soon, but for now, let’s focus on our current example. Once we catch the exception, we can extract the <code>error_condition</code> object from it; see marker <code>{6}</code>. This is possible because the <code>system_error</code> class supports error codes and error conditions and enables us to fetch them. When we have <code>error_condition</code>, we can successfully check against the well-known <code>errc</code> codes whether this exception is a real problem for our program or it can be omitted; see marker <code>{7}</code>.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Wherever possible, catch exceptions by reference (prefer constant) rather than by value to avoid potential object slicing and additional overhead due to object copying.</p>
<p>Our business<a id="_idIndexMarker445"/> program logic expects that errors reporting that a file already exists are normal and should not break program execution. Ultimately, it says that we try to create a directory that already exists, and that’s fine and we can continue. But if the error is something else that we don’t know what to do with, then we have to report that error and rethrow it to the upper methods in the call stack, which could better know what to do with such a kind of error. This is done with the <code>throw</code> clause in the language; see marker <code>{8}</code>. An important detail here is that in order to <em class="italic">rethrow an existing exception</em> rather than throwing a new one, you have to just use <code>throw;</code> with <em class="italic">no arguments</em>.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Use the <code>throw;</code> clause with no arguments to rethrow an existing exception.</p>
<p>Of course, if the error is what we expect, such as <code>std::errc::file_exists</code>, then we can safely continue the program execution without the need to rethrow this exception. You can find the output of the program as follows:</p>
<pre class="console">
CreateDirectory reports error: File exists
Nothing unexpected, safe to continue.</pre> <p>We can see that the exception is thrown by the <code>CreateDirectory()</code> method and it is caught by the <code>catch</code> clause in the <code>main()</code> method. In this example, we saw that using exceptions instead of error codes clearly segregates the normal program execution path from the error path and makes it easier to rethrow errors that we can’t properly deal with.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor082"/>Throw by value, catch by reference</h2>
<p>In C++, we can literally throw every object. You could successfully do this as follows:</p>
<pre class="source-code">
throw 42;</pre> <p>The preceding statement throws an integer object with a value of <code>42</code>. But just because you can do something, it doesn’t mean it’s a good idea to do so. The goal of the exception is to bring context to the error that occurred. Throwing the value of <code>42</code> doesn’t provide much context, right? What does <code>42</code> mean for the recipient of your exception? Not much!</p>
<p>This statement is fully confirmed <a id="_idIndexMarker446"/>by the C++ Core Guidelines project developed by some of the key members of the C++ Standards Committee. The C++ Core Guidelines are a really useful guide for every C++ developer no matter what level of expertise you have. It gathers recommendations and best practices about different features in C++.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Make sure to get familiar <a id="_idIndexMarker447"/>with the C++ Core Guidelines, which you can find at <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c-core-guidelines">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c-core-guidelines</a>.</p>
<p>The C++ Core Guidelines say that we have to make sure that we throw meaningful exceptions. If you don’t have a standard defined exception that works for your case, you can throw a user-defined type that derives from some of the standard exceptions:</p>
<p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types</a></p>
<p>The C++ Core Guidelines also suggest throwing our exceptions by value and catching them by reference. Of course, even better if we catch by constant reference. Throwing by value ensures that the lifetime of the thrown object will be managed by the runtime of your system. Otherwise, if you throw a pointer to an object that you have allocated on the heap whose responsibility will be to delete this object when it is no longer needed, it is quite possible you will end up with leaked memory:</p>
<p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e15-throw-by-value-catch-exceptions-from-a-hierarchy-by-reference">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e15-throw-by-value-catch-exceptions-from-a-hierarchy-by-reference</a></p>
<p>Let’s go through an<a id="_idIndexMarker448"/> example. We will define a method – <code>Throw()</code> – which <a id="_idIndexMarker449"/>throws by value a <code>std::system_error</code> exception with an error code – <code>bad_file_descriptor</code>:</p>
<pre class="source-code">
void Throw() {
    using namespace std;
    throw system_error{make_error_code
      (errc::bad_file_descriptor)};
}</pre> <p>This method will be invoked by the <code>main()</code> method in which we will catch the thrown exception:</p>
<pre class="source-code">
int main() {
    using namespace std;
    try {
        try {
            Throw(); // {1}
        } catch (runtime_error e) { // {2}
            throw e; // {3}
        }
    } catch (const exception&amp; e) { // {4}
        const system_error&amp; se{dynamic_cast&lt;const
          system_error&amp;&gt;(e)}; // {5}
        const auto econd{se.code()
          .default_error_condition()};
        std::cerr &lt;&lt; econd.message() &lt;&lt; '\n';
    }
    return 0;
}</pre> <p>As you can see in<a id="_idIndexMarker450"/> the preceding example, we have defined two <code>try-catch</code> blocks – one inner and one outer. The reason behind this is that exceptions thrown in <a id="_idIndexMarker451"/>the <code>catch</code> branch can’t be caught by another <code>catch</code> branch in the same try-catch block. They are propagated out and, therefore, in order to catch them, we need an outer try-catch block.</p>
<p>In marker <code>{1}</code>, we invoke the <code>Throw()</code> method, which throws an exception. But in marker <code>{2}</code>, we catch the thrown exception. Actually, we don’t catch <code>std::system_error</code> directly but we catch its parent class – <code>std::runtime_error</code>. Also, you can see that we catch this exception by value with <code>runtime_error e</code>.</p>
<p>The only action we take once we catch the <code>runtime_error</code> exception is to throw it away from the inner try-catch block with the following statement:</p>
<pre class="source-code">
throw e;</pre> <p>Always be careful when you rethrow an existing exception. The upper statement <em class="italic">doesn’t rethrow</em> the exception caught in the <code>catch</code> clause but it throws a new instance of the <code>runtime_error</code> exception, which is a copy of the caught exception, instead.</p>
<p>Once the new exception is thrown, it is caught by the outer <code>catch</code> clause in marker <code>{4}</code>. As you can see, following the recommendation from the C++ Core Guidelines, we catch a constant reference instead of a value to the Standard Library’s base exception class – <code>std::exception</code> – which is also a base class for <code>std::runtime_error</code>.</p>
<p>In the <code>catch</code> clause, we try to downcast it back to its original type – <code>std::system_error</code> – and print the message from its <code>std::error_condition</code>. Let’s see the output from the program:</p>
<pre class="console">
terminate called after throwing an instance of 'std::bad_cast'
  what():  std::bad_cast</pre> <p>But surprisingly, we don’t get the expected result. The downcast has failed, and when it fails, it generates a standard exception – <code>std::bad_cast</code> – which is thrown away from the outer <code>catch</code> clause. But this exception is not guarded by another try-catch block, and therefore, it propagates out of the <code>main()</code> method, which is de facto the top of the function stack of the program. As we explained earlier, if an exception is not caught during its propagation upwind in the function stack, then the <code>std::terminate</code> function will be called.</p>
<p>But why did the <a id="_idIndexMarker452"/>cast fail when we tried to downcast to <code>std::system_error</code>? The reason is that the <code>Throw()</code> method throws <code>std::system_error</code> and everything should work fine. Well, it should, but it doesn’t really. Let’s get deeper into this.</p>
<p>The <code>Throw()</code> method really throws an instance of <code>std::system_error</code> by <em class="italic">value</em>. But the inner <code>catch</code> clause catches a <em class="italic">base class exception</em> also <em class="italic">by value</em> and throws a <em class="italic">copy</em> of it:</p>
<pre class="source-code">
catch (runtime_error e) {
    throw e;
}</pre> <p>This leads to a problem because the object we rethrow is no longer an instance of <code>std::system_error</code>. It has been sliced to its base class – <code>std::runtime_error</code>. All the information that has been part of the <em class="italic">original</em> <code>std::system_error</code> object is no longer part of the newly created <em class="italic">copy</em> of the <code>std::runtime_error</code> – <code>e</code> type.</p>
<p>Therefore, the downcast to <code>std::system_error</code> doesn’t succeed and our program terminates.</p>
<p>To conclude, we can say that these kinds of errors can be successfully prevented by following the rules of throwing exceptions by value, catching them by reference, and rethrowing the existing exceptions rather than their copy wherever this is possible.</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor083"/>try/catch … finally</h2>
<p>You probably noticed that in the C++ language, we have<a id="_idIndexMarker453"/> the <code>try-catch</code> block, but we don’t have the <code>finally</code> construct. If you have experience in languages such as C# or Java, you will be used to releasing the resource that you have acquired using <a id="_idIndexMarker454"/>the <code>finally</code> clause. But this works only for exceptional cases where the <code>try</code> clause is preceding the usage of <code>finally</code>.</p>
<p>But how do we do<a id="_idIndexMarker455"/> it in C++ without <code>finally</code>? Let’s revisit our initial example for opening and closing a file using the <code>open()</code> and <code>close()</code> POSIX functions:</p>
<pre class="source-code">
int main() {
    try {
        const int fd{open("/tmp/cpp-test-file", O_RDONLY)};
          // {1}
        if (fd == -1) { return errno; }
        // Do something with the file and suddenly
          something throws {2}
        if (close(fd) == -1) { return errno; } // {3}
    } catch (...) {
        std::cerr &lt;&lt; "Something somewhere went terribly
          wrong!\n";
        return -1;
    }
    return 0;
}</pre> <p>As we already discussed earlier in the chapter, opening a file using the <code>open()</code> POSIX method returns the ID of the file descriptor if the function successfully opens the file; otherwise, as with many of the POSIX functions, it returns <code>-1</code>; see marker <code>{1}</code>.</p>
<p>Once you have your file opened, it is your responsibility to ensure that <em class="italic">finally</em>, when you finish with it, it will be closed. Therefore, we invoke the <code>close()</code> method at the end of the <code>main()</code> method to ensure that the file will be closed (see marker <code>{3}</code>) just before we leave <code>main()</code>. But how can you be sure that some abnormal situation won’t occur, and an exception won’t be thrown before you close your file? Actually, the only case in which you can be sure that this won’t happen is if exceptions are not supported in your system. But in our test Linux environment, this is not the case. Even worse, when working in real code <a id="_idIndexMarker456"/>bases, it’s hard to be sure that some of the methods you invoke during your normal business logic execution won’t throw.</p>
<p>Imagine what <a id="_idIndexMarker457"/>happens if your program throws before you close your file; see marker <code>{2}</code>. Effectively, you will <em class="italic">leak</em> a resource. As a rule of thumb, we should never leak resources, no matter whether this will lead to a problem or not.</p>
<p>But how can we protect ourselves from leaking resources without having the <code>finally</code> clause in the language? Let’s have a look into one of the most typical C++ programming techniques:</p>
<pre class="source-code">
void Throw() {
    cout &lt;&lt; "Ops, I need to throw ...\n";
    throw system_error{make_error_code
      (errc::bad_file_descriptor)};
}
int main() {
    const string_view myFileName{"/tmp/cpp-test-file"}; //
      {1}
    ofstream theFile(myFileName.data()); // {2}
    try {
        file_guard guard(myFileName, O_RDONLY); // {3}
        const auto fd = guard.getFileDescriptor();
        Throw(); // {4}
    } catch (const exception&amp; e) {
        cout &lt;&lt; e.what();
        return -1;
    }
    return 0;
}</pre> <p>We have reworked <a id="_idIndexMarker458"/>our <code>main()</code> method in such a way that we just create a<a id="_idIndexMarker459"/> file (see marker <code>{2}</code>) and pass its filename (see marker <code>{1}</code>) to a new object of the <code>file_guard</code> type (see marker <code>{3}</code>), which we will look at it just in a moment. The <code>file_guard</code> object is responsible for opening and closing a file with a specific name:</p>
<pre class="source-code">
using namespace std;
class file_guard final {
public:
    file_guard(string_view file, mode_t mode) : // {5}
        fd{open(file.data(), mode)}
    {
        if (fd == -1) {
            throw system_error
              {make_error_code(errc{errno})};
        }
        cout &lt;&lt; "File '" &lt;&lt; file &lt;&lt;
        "' with file descriptor '" &lt;&lt;
        fd &lt;&lt; "' is opened.\n";
    }
    explicit file_guard(const file_guard&amp;) = delete; // {6}
    file_guard&amp; operator=(const file_guard&amp;) = delete;
    explicit file_guard(file_guard&amp;&amp; other) noexcept : //
      {7}
        fd{move(other.fd)} { other.fd = -1; }
    file_guard&amp; operator=(file_guard&amp;&amp; other) noexcept
    {
        fd = move(other.fd);
        other.fd = -1;
        return *this;
    }
    int getFileDescriptor() const noexcept { // {8}
        return fd;
    }
    ~file_guard() noexcept { // {9}
        if (fd != -1) {
            close(fd);
            cout &lt;&lt; "File with file descriptor '" &lt;&lt; fd &lt;&lt;
              "' is closed.\n";
        }
    }
private:
    int fd;
};</pre> <p>The class gets in its <a id="_idIndexMarker460"/>constructor the file path and the mode in which the file <a id="_idIndexMarker461"/>should be opened; see marker <code>{5}</code>. In the initializer list of the constructor, the POSIX <code>open()</code> method is invoked. The result, which is the file descriptor ID, is assigned to the <code>_fd</code> member of the class. If <code>open()</code> fails, an exception is thrown away from the <code>file_guard</code> constructor. We should not care about closing the file in this case because we didn’t open it successfully.</p>
<p>In the destructor of the class, we have the reversed operation; see marker <code>{9}</code>. If the file descriptor is different from <code>-1</code>, which means that the file has been successfully opened before that, we close it.</p>
<p>This C++ programming <a id="_idIndexMarker462"/>technique is called <strong class="bold">Resource Acquisition Is Initialization</strong>, or just <strong class="bold">RAII</strong>. It is a resource management technique that acquires the resource during the construction of the RAII object and releases it during the destruction of that <a id="_idIndexMarker463"/>object. Unlike in languages such as Java and C# that use automatic garbage collection and whose resource release timing is not entirely clear to the user, C++ objects have a precisely defined storage duration and lifetime. Thus, we can rely on this characteristic and utilize RAII objects to manage our resources.</p>
<p>Going back to our <code>main()</code> method, if the file is opened (see marker <code>{3}</code>) and something goes wrong before it has been explicitly closed (see marker <code>{4}</code>), we will be sure that it will be automatically closed once the <code>file_guard</code> object goes out of scope.</p>
<p>This technique is widely used no matter whether exceptions are available in the system or not. You can wrap your resources using RAII and be assured that they will be automatically released whenever you leave the scope where the RAII object lives.</p>
<p>In our <code>file_guard</code> example, we have removed the copy constructor and the copy assignment operator and left the move constructor and move operator only, claiming that this RAII object is not copyable.</p>
<p>C++ is often questioned about not having the <code>finally</code> construct. However, the inventor of C++, Bjarne Stroustrup, has explained that RAII is a better substitute: <a href="https://www.stroustrup.com/bs_faq2.xhtml#finally">https://www.stroustrup.com/bs_faq2.xhtml#finally</a>.</p>
<p>Stroustrup argues that in practical code bases, there are many more resource acquisitions and releases, and using RAII instead of <code>finally</code> results in less code. Additionally, it is less susceptible to errors since the RAII wrapper only needs to be coded once, and there is no need to remember to release the resource manually.</p>
<p>The Standard Library has many examples of RAII objects, such as <code>std::unique_ptr</code>, <code>std::lock_guard</code>, and <code>std::fstreams</code>.</p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor084"/>Summary</h1>
<p>This chapter has covered various techniques for error handling when working with POSIX APIs in C++. We discussed the use of <code>errno</code>, a thread-local variable, and the <code>strerror</code> function. We also explored how <code>std::error_code</code> and <code>std::error_condition</code> can wrap POSIX errors and how custom error categories enable us to compare errors generated by different sources and develop platform-independent error-handling code. Furthermore, we delved into exceptions in C++ and how to convert <code>std::error_code</code> into an exception of the <code>std::system_error</code> type.</p>
<p>We also examined best practices for working with exceptions, such as throwing them by value and catching them by reference, to avoid issues such as object slicing. Finally, we learned about the RAII technique in C++, which eliminates the need for a <code>finally</code> construct in the language.</p>
<p>In the next chapter, we will explore the topic of concurrency with C++.</p>
</div>
</div>

<div><div><h1 id="_idParaDest-85" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor085"/>Part 2:Advanced Techniques for System Programming</h1>
</div>
<div><p>In this part, you will learn about expert-level C++20 features, which will further improve both your OS and C++ development expertise. The examples, though still practical, become more complex and require some preliminary understanding of the subject of system programming.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B20833_06.xhtml#_idTextAnchor086"><em class="italic">Chapter 6</em></a><em class="italic">, Concurrent System Programming with C++</em></li>
<li><a href="B20833_07.xhtml#_idTextAnchor101"><em class="italic">Chapter 7</em></a><em class="italic">, Proceeding with Inter-Process Communication</em></li>
<li><a href="B20833_08.xhtml#_idTextAnchor116"><em class="italic">Chapter 8</em></a><em class="italic">, Using Clocks, Timers, and Signals in Linux</em></li>
<li><a href="B20833_09.xhtml#_idTextAnchor129"><em class="italic">Chapter 9</em></a><em class="italic">, Understanding the C++ Memory Model</em></li>
<li><a href="B20833_10.xhtml#_idTextAnchor147"><em class="italic">Chapter 10</em></a><em class="italic">, Using Coroutines in C++ for System Programming</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</div></body></html>