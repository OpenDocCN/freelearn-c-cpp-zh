["```cpp\nglDispatchCompute( 4, 5, 1 ); \n```", "```cpp\nlayout (local_size_x = 3, local_size_y = 3) in; \n```", "```cpp\ngl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID \n```", "```cpp\nvector<GLfloat> initPos; \n\n... // Set initial positions \n\nGLuint bufSize = totalParticles * 4 * sizeof(GLfloat); \n\nGLuint posBuf; \nglGenBuffers(1, &posBuf); \nglBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, posBuf); \nglBufferData(GL_SHADER_STORAGE_BUFFER, bufSize, &initPos[0], \n               GL_DYNAMIC_DRAW); \n```", "```cpp\nglBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, velBuf); \n```", "```cpp\nlayout( local_size_x = 1000 ) in; \n\nuniform float Gravity1 = 1000.0; \nuniform vec3 BlackHolePos1; \nuniform float Gravity2 = 1000.0; \nuniform vec3 BlackHolePos2; \n\nuniform float ParticleInvMass = 1.0 / 0.1; \nuniform float DeltaT = 0.0005; \n\nlayout(std430, binding=0) buffer Pos { \n  vec4 Position[]; \n}; \nlayout(std430, binding=1) buffer Vel { \n  vec4 Velocity[]; \n}; \n\nvoid main() { \n  uint idx = gl_GlobalInvocationID.x; \n\n  vec3 p = Position[idx].xyz; \n  vec3 v = Velocity[idx].xyz; \n\n  // Force from black hole #1 \n  vec3 d = BlackHolePos1 - p; \n  vec3 force = (Gravity1 / length(d)) * normalize(d); \n\n  // Force from black hole #2 \n  d = BlackHolePos2 - p; \n  force += (Gravity2 / length(d)) * normalize(d); \n\n  // Apply simple Euler integrator \n  vec3 a = force * ParticleInvMass; \n  Position[idx] = vec4( \n        p + v * DeltaT + 0.5 * a * DeltaT * DeltaT, 1.0); \n  Velocity[idx] = vec4( v + a * DeltaT, 0.0); \n} \n```", "```cpp\nglDispatchCompute(totalParticles / 1000, 1, 1); \n```", "```cpp\nglMemoryBarrier( GL_SHADER_STORAGE_BARRIER_BIT ); \n```", "```cpp\nlayout( local_size_x = 1000 ) in; \n```", "```cpp\nGLuint imgTex; \nglGenTextures(1, &imgTex); \nglActiveTexture(GL_TEXTURE0); \nglBindTexture(GL_TEXTURE_2D, imgTex); \nglTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA8, 256, 256);  \nglBindImageTexture(0, imgTex, 0, GL_FALSE, 0, GL_READ_WRITE,  \n                   GL_RGBA8); \n```", "```cpp\nlayout( local_size_x = 32, local_size_y = 32 ) in; \n```", "```cpp\nlayout( binding = 0, rgba8) uniform image2D ColorImg; \n#define MAX_ITERATIONS 100 \nuniform vec4 CompWindow; \nuniform uint Width = 256; \nuniform uint Height = 256; \n```", "```cpp\nuint mandelbrot( vec2 c ) { \n  vec2 z = vec2(0.0,0.0); \n  uint i = 0; \n  while(i < MAX_ITERATIONS && (z.x*z.x + z.y*z.y) < 4.0) { \n    z = vec2( z.x*z.x-z.y*z.y+c.x, 2 * z.x*z.y + c.y );  \n    i++; \n  } \n  return i; \n} \n```", "```cpp\nvoid main() { \n  float dx = (CompWindow.z - CompWindow.x) / Width;  \n  float dy = (CompWindow.w - CompWindow.y) / Height;\n```", "```cpp\n  vec2 c = vec2(  \n      dx * gl_GlobalInvocationID.x + CompWindow.x, \n      dy * gl_GlobalInvocationID.y + CompWindow.y); \n```", "```cpp\n  uint i = mandelbrot(c);  \n  vec4 color = vec4(0.0,0.5,0.5,1); \n  if( i < MAX_ITERATIONS ) { \n    if( i < 5 )  \n         color = vec4(float(i)/5.0,0,0,1); \n    else if( i < 10 )  \n         color = vec4((float(i)-5.0)/5.0,1,0,1); \n    else if( i < 15 )  \n         color = vec4(1,0,(float(i)-10.0)/5.0,1); \n    else color = vec4(0,0,1,0); \n  } \n  else \n    color = vec4(0,0,0,1); \n```", "```cpp\n  imageStore(ColorImg,  \n             ivec2(gl_GlobalInvocationID.xy), color);  \n} \n```", "```cpp\nglDispatchCompute(256/32, 256/32, 1); \nglMemoryBarrier( GL_SHADER_IMAGE_ACCESS_BARRIER_BIT ); \n```", "```cpp\nlayout( local_size_x = 10, local_size_y = 10 ) in; \n```", "```cpp\nuniform vec3 Gravity = vec3(0,-10,0); \nuniform float ParticleMass = 0.1; \nuniform float ParticleInvMass = 1.0 / 0.1; \nuniform float SpringK = 2000.0; \nuniform float RestLengthHoriz; \nuniform float RestLengthVert; \nuniform float RestLengthDiag; \nuniform float DeltaT = 0.000005; \nuniform float DampingConst = 0.1; \n```", "```cpp\nlayout(std430, binding=0) buffer PosIn { \n  vec4 PositionIn[]; \n}; \nlayout(std430, binding=1) buffer PosOut { \n  vec4 PositionOut[]; \n}; \nlayout(std430, binding=2) buffer VelIn { \n  vec4 VelocityIn[]; \n}; \nlayout(std430, binding=3) buffer VelOut { \n  vec4 VelocityOut[]; \n}; \n```", "```cpp\nvoid main() { \n  uvec3 nParticles = gl_NumWorkGroups * gl_WorkGroupSize; \n  uint idx = gl_GlobalInvocationID.y * nParticles.x +  \n             gl_GlobalInvocationID.x; \n\n  vec3 p = vec3(PositionIn[idx]); \n  vec3 v = vec3(VelocityIn[idx]), r; \n```", "```cpp\n  vec3 force = Gravity * ParticleMass; \n```", "```cpp\n  if( gl_GlobalInvocationID.y < nParticles.y - 1 ) { \n    r = PositionIn[idx + nParticles.x].xyz - p; \n    force += normalize(r)*SpringK*(length(r) -  \n                                 RestLengthVert); \n  }  \n```", "```cpp\n  if( gl_GlobalInvocationID.x > 0 &&  \n      gl_GlobalInvocationID.y < nParticles.y - 1 ) { \n    r = PositionIn[idx + nParticles.x - 1].xyz - p; \n    force += normalize(r)*SpringK*(length(r) -  \n                                 RestLengthDiag); \n  } \n```", "```cpp\n  force += -DampingConst * v;\n```", "```cpp\n  vec3 a = force * ParticleInvMass; \n  PositionOut[idx] = vec4( \n      p + v * DeltaT + 0.5 * a * DeltaT * DeltaT, 1.0); \n  VelocityOut[idx] = vec4( v + a * DeltaT, 0.0); \n```", "```cpp\n  if( gl_GlobalInvocationID.y == nParticles.y - 1 &&  \n      (gl_GlobalInvocationID.x == 0 ||  \n       gl_GlobalInvocationID.x == nParticles.x / 4 || \n       gl_GlobalInvocationID.x == nParticles.x * 2 / 4 || \n       gl_GlobalInvocationID.x == nParticles.x * 3 / 4 || \n       gl_GlobalInvocationID.x == nParticles.x - 1)) { \n    PositionOut[idx] = vec4(p, 1.0); \n    VelocityOut[idx] = vec4(0,0,0,0); \n  } \n} \n```", "```cpp\nfor( int i = 0; i < 1000; i++ ) { \n  glDispatchCompute(nParticles.x/10, nParticles.y/10, 1); \n  glMemoryBarrier( GL_SHADER_STORAGE_BARRIER_BIT ); \n\n  // Swap buffers \n  readBuf = 1 - readBuf; \n\n  glBindBufferBase(GL_SHADER_STORAGE_BUFFER,0, \n                    posBufs[readBuf]); \n  glBindBufferBase(GL_SHADER_STORAGE_BUFFER,1, \n                   posBufs[1-readBuf]); \n  glBindBufferBase(GL_SHADER_STORAGE_BUFFER,2, \n                   velBufs[readBuf]); \n  glBindBufferBase(GL_SHADER_STORAGE_BUFFER,3, \n                   velBufs[1-readBuf]); \n} \n```", "```cpp\nlayout( local_size_x = 10, local_size_y = 10 ) in; \n```", "```cpp\nlayout (local_size_x = 25, local_size_y = 25) in; \n```", "```cpp\nuniform float EdgeThreshold = 0.1; \nlayout(binding=0, rgba8) uniform image2D InputImg; \nlayout(binding=1, rgba8) uniform image2D OutputImg; \n```", "```cpp\nshared float \n     localData[gl_WorkGroupSize.x+2][gl_WorkGroupSize.y+2]; \n```", "```cpp\nvoid applyFilter() \n{ \n  uvec2 p = gl_LocalInvocationID.xy + uvec2(1,1); \n\n  float sx = localData[p.x-1][p.y-1] +  \n            2*localData[p.x-1][p.y] + \n            localData[p.x-1][p.y+1] - \n           (localData[p.x+1][p.y-1] +  \n            2 * localData[p.x+1][p.y] +  \n            localData[p.x+1][p.y+1]); \n  float sy = localData[p.x-1][p.y+1] +  \n             2*localData[p.x][p.y+1] +  \n             localData[p.x+1][p.y+1] -  \n            (localData[p.x-1][p.y-1] +  \n             2 * localData[p.x][p.y-1] +  \n             localData[p.x+1][p.y-1]); \n  float g = sx * sx + sy * sy; \n\n  if( g > EdgeThreshold ) \n    imageStore(OutputImg,  \n       ivec2(gl_GlobalInvocationID.xy), vec4(1.0)); \n  else \n    imageStore(OutputImg,  \n       ivec2(gl_GlobalInvocationID.xy), vec4(0,0,0,1)); \n} \n```", "```cpp\nvoid main() \n{ \n  localData \n   [gl_LocalInvocationID.x+1][gl_LocalInvocationID.y+1] =  \n   luminance(imageLoad(InputImg,  \n             ivec2(gl_GlobalInvocationID.xy)).rgb); \n```", "```cpp\n  barrier(); \n\n  // Apply the filter using local memory \n  applyFilter(); \n}\n```", "```cpp\nglDispatchCompute(width/25, height/25, 1); \nglMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT); \n```", "```cpp\np = gl_LocalInvocationID.xy + uvec2(1,1); \n```"]