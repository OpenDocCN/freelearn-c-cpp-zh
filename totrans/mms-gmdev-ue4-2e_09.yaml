- en: Adding an In-game Cutscene with Sequencer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many games made with UE4 are known for having excellent in-engine and in-game
    cutscenes. Traditionally, these were made with the tool/system known as Matinee.
    These days, Sequencer is the new-and-improved system for creating these scenes
    and is being widely adopted in modern UE4 titles. The last section of this chapter
    will deal a bit with Matinee, namely, why it isn't used anymore. Games going back
    many years have done just fine with Matinee and it's still a viable tool; but
    first, let's get to know Sequencer and its capabilities and a bit of what working
    with it is like.
  prefs: []
  type: TYPE_NORMAL
- en: Sequencer basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Track editing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequencer alternatives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dialog system, blueprint scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matinee
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will use specific assets added over the course of the GitHub project.
    To follow the practical examples, please start with the `Chapter 9` GitHub branch: [https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-9](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-9).
  prefs: []
  type: TYPE_NORMAL
- en: 'Engine version used: 4.19.2.'
  prefs: []
  type: TYPE_NORMAL
- en: Sequencer – UE4's newest cutscene tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sequencer was launched around UE4 4.12 to replace (or rather, succeed) Matinee,
    and if a content developer or team has no experience with Matinee, and even if
    you do, it's the best place to work. It's similar enough that those with experience
    with any other sort of keyframe track-based tool can use it, it's easy enough
    to pick up, and will be the technology that Epic is using and improving going
    forward. Getting familiar with its capabilities is key for any game hoping to
    incorporate great-quality cutscenes into their game, whether they're simple arrangements
    of actors in a level that the player can passively view, or cinematic-quality
    fully-controlled scenes to help convey narrative and story. So let's take a look
    at what it can do.
  prefs: []
  type: TYPE_NORMAL
- en: Why use sequencer?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed, sequencer is the technology to use going forward and has a massive
    amount of options and power for proficient users. As this is designed to help
    give a holistic knowledge of the engine's capabilities, and not a content-creation
    specialization course, we'll likely only scratch the surface of what's possible
    with the tool; but knowing what it can do, and how it can help you, is crucial
    to making those early decisions in content pipeline and delivering the best experience
    possible to your audience.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick aside, for those following the GitHub project closely, you''ll notice
    some commits in this chapter''s beginning, which get it to build and run for HTML5
    (tested on PC/Chrome, and Mac/Safari – the latter seems to have some stability
    issues, but is testable now). Code-side, most of these are simply headers that
    the build does not otherwise pick up on as the Windows build did, this is fairly
    common with various platforms, but things like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In `MasteringInventory.cpp` are harmless to the Windows build as it already
    picked up on the header elsewhere. But back to Sequencer.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the history of sequencer''s addition and its ongoing and future support
    are reason enough to use it, a quick overview of its capabilities is in order.
    What does it do? Is there anything it can''t do? Let''s list a few of its more
    common features and their uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Level Sequences**: These are where the bulk of the work is done in Sequencer
    Cinematics, they can be individual end-to-end scenes, or a hierarchy of subsequences
    (more level-sequence objects)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Master Sequences**: Generally used to manage groups or dynamic-level sequence
    and shot objects, but can work as a thin wrapper for a standalone level sequence
    (adding a few options)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shot Track**: This is a track that can be added to a sequence, but is also
    saved as a standalone asset, it is the most fundamental track, typically controlling
    camera, focus, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Takes**: Upon arranging multiple shots in a shot track, a take object can
    be made, which is that particular sequence of the shot track, and takes can be
    swapped with each other to quickly iterate the feel and flow of a shot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actor to Sequencer Track**: These are used to add individual actors from
    the level to a sequence, this is how things in the world are moved and animated
    within a sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While there are many other components, these are the primary ones we can use
    to get immediately familiar with Sequencer''s basic and most commonly used features.
    First however, we''ll also need to just lay some background changes into our FirstPersonExampleMap
    to get prepared. In the GitHub project, you''ll notice several changes without
    much direct effect at the moment: lighting was brightened back up again, the boxes
    except for the one special one were made to not use their special flashing (distracting)
    material, and a "backstage" area was added just under our main floor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec06bcc3-b140-40d7-98f9-68d628afb5d3.png)'
  prefs: []
  type: TYPE_IMG
- en: A super convenient way to duplicate an object is just to drag its transform
    in a direction while holding the *Alt* key (the *command* key on Mac); this will
    make a copy and move it in the direction you want – in this case, a duplicated
    floor moving directly below our existing floor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a plane to place our scene''s actors on, we some new items to
    make our scene interesting. First, we''ll head to the content browser''s Add New
    button and at the very top is the option for Add Feature or Content Pack..., we''ll
    use this twice. Be sure to first click on the root, Content folder, in the content
    browser so everything goes to the right level; you''re welcome to organize assets
    as you or your team see fit; but this will make it match what is in GitHub and
    if you''re clever can save the GitHub download time (as this content is already
    on your computer from getting the full source of the engine, in [Chapter 1](dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml), *Making
    a C++ Project for a First Person Shooter, *adding it just copies it over from
    the engine''s content folder to your project). We''ll add from the Blueprint Feature
    tab the Third Person pack, and from the Content Packs tab, Starter Content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0610540-f87a-47e2-a5c4-9e4a40a2e32d.png)'
  prefs: []
  type: TYPE_IMG
- en: These have a number of assets that we likely won't use, which adds to the overall
    size in GitHub; but will *not* add to the game's package size on platforms unless
    directly referenced in a level by another asset (or the level itself), or added
    to the force cook list, which will be gone over in great detail in the next chapter!
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we can add our new assets to the backstage area. Keep two things in
    mind when making such a backstage area:'
  prefs: []
  type: TYPE_NORMAL
- en: The player should never be able to see it or access it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should have similar lighting to where you place the actors there so their
    lighting doesn't noticeably "pop" when added to another area during a sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note also, you can make characters in a sequence "spawn" on cue, so they''re
    not visible anyway (we''ll demonstrate this); but then you are also potentially
    paying the cost of a synchronous load (if the character was not otherwise previously
    loaded) at the time you do, so beware. Here''s how our backstage is shaping up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03a84bae-4fd5-4430-9c72-c04f8fa49c96.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now notice, this is a plain skeletal mesh, not even a pawn, and importantly,
    is using as its animation "mode" on the right: Use Animation Asset *not* using
    the Animation Blueprint we made elsewhere as this will override what we try to
    do animation-wise in our sequence. The mannequin character, which most readers
    probably know well from Epic''s templates, is similarly setup to not use the AnimBP,
    for our sequence''s benefit. You can also see here that we can add that main-level
    sequence from the Cinematics button in the top main menu. I prefer to add these
    in the content folder, where the map is housed, since they tend to be closely
    associated; but it''s certainly possible and reasonable to make a separate Cinematics
    folder or something similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2835a708-30e7-4096-897e-13411e995555.png)'
  prefs: []
  type: TYPE_IMG
- en: As I had already added the scene when this shot was taken, you can see it in
    the editable cinematics, where it is named CountessIntro and kept in FirstPersonExampleMap.
    From here, we can get on with the fun of actually making and triggering a cutscene!
  prefs: []
  type: TYPE_NORMAL
- en: Adding a scene and triggering it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve added an empty barebones-level sequence to our map now, but how do we
    use it? Let''s quickly go over the triggering side of things, then we can get
    to making a fairly basic scene and watching it play. We''ll then up the quality
    and detail it with some interesting options. The very first thing to do when working
    on a scene such as this, though, is to give yourself a proper view to do it from,
    so in the viewport drop-down, select the Two Panes layout seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b899bc7-d594-44df-bf2b-2f30e07961ac.png)'
  prefs: []
  type: TYPE_IMG
- en: Make sure when using the cinematic preview window that you have your cinematic
    camera selected, it's easy to forget and that's the one that will be used during
    the scene of course.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the left pane selected, set it (in the same drop-down arrow in the top-left)
    to Cinematic Preview. So now with a dedicated cinematic preview pane, it''s easy
    to work quickly on the scene itself. But there''s one more step before we get
    started there – we need a space we can use and a trigger volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e91e5c0-81b2-4608-9a9b-f07448092a8c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also note that in the GitHub project, the platform, which begins up in the
    air in the scene, is just one of our level''s boxes scaled flat, and with Simulate
    Physics and Enable Gravity both unchecked in its properties. The trigger volume
    is set to only detect overlapping pawns and, as will be seen in the level blueprint,
    destroys itself upon being triggered once by a mastering character:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0dbd74f-2771-4647-b81c-330f626eaf0c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'though to show that this blueprint needed to be split to two shots, but you
    can see the trigger volume is then the immediate actor destroyed, and we have
    then created a level sequence player and done one other clever thing or two at
    the end of the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7ec551d-9b77-49bd-9c22-0c7e66f74df4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, our sequence actually plays, but until we have it do something,
    it should just immediately end and destroy the platform and spawn BP_Countess.
    So before we get to the "how" of the scene, let''s jump ahead for a second to
    the "what" of the scene: when the player walks into this corner, the countess
    rides down to the ground on a platform, playing her turn-in-place animation to
    face outward, pauses with an idle for a moment at the bottom, then plays a taunt
    animation in front of her. This is all from, of course, our backstage skeletal
    mesh countess, so this one can''t take damage and has no running AI. At the end
    of the sequence (noted by the event we bound to that), we destroy the platform
    she rode in on, the skeletal mesh is automatically returned backstage, and we
    replace at the same transform (with a 90-degree turn since we have that set in
    the BP_Countess class'' mesh) a fully-functional AI version.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now on to the basic sequence itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1e66477-059d-4959-8510-189a63cad941.png)'
  prefs: []
  type: TYPE_IMG
- en: First, we need to add our two actors for this basic scene to the sequence, so
    double-click the CountessIntro to open it up and click the +Track button near
    the top. It's easiest if you already have the actor selected in the world (in
    this case our platform, and the countess skeletal mesh instance respectively)
    as they will then appear at the top to add instead of searching. Once added, it's
    best to add a transform keyframe right where they are currently at (assuming this
    is the desired start point for each actor). You can do this by clicking the transform
    as a whole, or like for our platform, you really only need its location selected.
    When the track is selected and the time slider (red notch at top with the line
    down the tracks) is at the start (click the <|| looking icon at the bottom to
    send it there), hit *Enter*, or you can click the tiny + icon between the left
    and right arrows in the track selector section to add one. Most content developer
    used to any sort of keyframing interface (animation in the major packages, other
    cinematic tools) should quickly get the hang of changing transforms and keyframing.
  prefs: []
  type: TYPE_NORMAL
- en: For the simplest example, selecting this platform, scrubbing the time slider
    forward to 125 , moving the platform down to ground level, and adding another
    keyframe in the sequence editor, will now let you scrub between, or play from
    the start, the sequence and see the platform move between the keyframes. You'll
    notice the keyframe is an orange circle by default; in this case, I right-clicked
    that starting keyframe and set its interpolation to linear (green triangle) so
    there's no acceleration on the motion as it moves from the start keyframe to the
    end keyframe. Similarly, for the countess, you'll see a square at the -1 unit
    mark, which moves her to be standing on the platform. Along with this, right-click
    the countess instance name/area itself and set it to Convert to Spawnable, this
    prevents a super-fast, but visible, motion from underground to the top of the
    platform. There are a number of alternate solutions to this; but since the backstage
    countess is always spawned at the start of the level, there's no load-time hit
    for keyframing the spawn. So at time 0, uncheck the Spawned box and add a keyframe
    to the Spawned track. At time 1, check it, add another keyframe. See also of course
    that there is a Constant type keyframe (blue box) of her translation and rotation
    (simply snaps to these) at time zero. Now she neatly appears there at the start
    of the scene (you could add a nice effect to this or whatever else makes sense
    for your design). To have the translation with the platform exactly match, I actually
    keyframed them, selected together with both of their translation tracks set as
    I moved the two actors down to the ground and set the first keyframe at time zero,
    then scrubbed to 125, moved them both down, and set both actors' second keyframes
    (and again, both to linear motion). I then did a curved rotation from facing away
    from the inside of the map, to facing in towards it, but in that case only selecting
    her rotation track as I set the initial rotation at 0, left it defaulted to Cubic
    (auto) transform type, and then at time 125, rotated her to face in the map and
    set the second keyframe.
  prefs: []
  type: TYPE_NORMAL
- en: If you view it as it stands, you can walk around wherever you like, see the
    scene play out once it's triggered, and then interact with a "normal" version
    of the countess upon its completion (which should be based on its vision sense,
    generally immediately comes after the player). She's currently not animating,
    so adding from her instance's Track+ button (to the right of her name, SM_Countess_Instance),
    you'll notice in the screenshot and GitHub, you can add multiple animations to
    one animation track, or multiple animation tracks. Here, one of each is done,
    picking her turning animation until down to the ground, putting a bit of overlap
    on her idle animation so there's not a visible pop between, and then adding a
    track to play her taunt and scrubbing its start until it also just overlaps the
    idle a little. In many games, this is exactly the level of "cinematic" experience
    needed. We'll put some audio on this for a more authentic feel; this is a fairly
    traditional "in-game" scene, rather than a dedicated "cinematic" cutscene which
    typically takes away player control and directly manipulates the camera. We'll
    handle this quickly here with the aforementioned audio.
  prefs: []
  type: TYPE_NORMAL
- en: When working with the vast majority of tracks in Sequencer, double-clicking
    will size that track in your editor window to the length of the sequence, double-clicking
    again will bring it back to a typically more zoomed-in level. This is great when
    you want an overall look at your sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under Content/FirstPersonCPP/Maps, add one more LevelSequence object (found
    under Animation if you right-click in the content browser) to it: IntroShot1\.
    Opening shot 1, it''s not very helpful as it''s not "attached" to our sequence,
    but for rapidly making a number of shots focusing on actors that don''t have to
    keyframe into existence as ours does, this can be a very useful tool, making many
    level sequences used as shots in a single sequence. For reference, I did use several
    shots in experimenting with this scene (and again, we''re learning the tech and
    its capabilities, not proving artistic talent here!), but in the end found using
    a few select keyframe types in a single shot worked best for this scene, so that
    is the only one checked in to GitHub. However, using multiple shots, combining
    them into Takes, and quickly swapping those in and out of a single sequence has
    a very handy link from Epic in the *Further reading* section for those interested.
    The sheer depth and breadth of what is capable with Sequencer can be overwhelming,
    but once again: know your project''s level of expectations and your team''s ability
    to deliver, and you''ll succeed every time where other teams fail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, on to finishing up our screen; in the countess intro sequence, add a track
    with the + button at the top and select Shot Track. Using the + shot button, add
    our IntroShot1\. Again just for the sake of learning, it''s fair to point out
    that I did lay out much of this track in the level as its own sequence, before
    importing, but had to do a bit of tweaking afterwards, which is a bit more difficult
    as you''re manipulating CineCameraActor directly in the level in viewports at
    that point, though you can always dedicate a viewport specifically to that camera
    actor for keyframing. Looking at the shot, you''ll see linear keyframes as we
    follow the countess descending, a pair of constant keyframes I use as a jump cut
    (rather than an alternate shot, but that''s always an option as noted), and then
    some more cubic keyframes as the camera pans out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45c6b61c-d238-4b62-b396-739d0a36d260.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note: your subtracks only exist for as long as they are set to in their parent
    sequence! In many cases, you may need to drag their end-time in the parent sequence
    to snap to the end of itself, to edit that subtrack in the sequence editor. Another is
    you can right click many tracks to allow the end-result to persist after the cinematic
    plays, this is very useful for moving entities around and then having them resume
    the game after the sequence exactly where they were placed, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: Back in the intro sequence itself, it's then just a matter of adding an audio
    track with a taunt at the right time (of course the scene could do with a good
    deal more audio). Lastly, add the mannequin to the scene to give the player a
    sense of their own location in perspective, but note that this is a fixed location
    as we're spawning the skeletal mesh into the cutscene once again, since the player's
    first-person pawn is even less palatable to look at. If you compare the first
    version of the scene where the player views it from their perspective against
    this final version, the differences should be highly obvious – and professional
    content creators can do even more impressive things once made aware of the tools
    available!
  prefs: []
  type: TYPE_NORMAL
- en: CineCamera Actors are immensely powerful in and of themselves. Now that we have
    one in this scene, feel free to explore what it can do, and check out the link
    from Epic in the *Further reading* section for some more useful info.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do one final bit of cleanup while the camera is in the scene, hide our
    reticle. Via the triggering and ending blueprint events, we hide the whole HUD,
    but this is the only visible piece in our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9aea769-6adc-4435-a5be-1a3578bd1ef4.png)'
  prefs: []
  type: TYPE_IMG
- en: And that's it! Without too much pain, the essentials of getting a cutscene are
    in and can be built upon for any level of professionalism needed with a little
    more experimentation and invested time.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget that when working with embedded sequences, you will frequently
    need to save the shot, the sequence the shot is contained in, and the level the
    sequence is in. Keep the volume of changes and the versioning-control of your
    levels in mind when creating a workflow. It's entirely possible to create a duplicate
    level and have cinematic artists work here while level designers work in the "real"
    level so they don't collide with binary assets you can't merge; but of course
    that means extra work making sure what each does remains in sync as they both
    evolve their pieces!
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to sequencer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main goal of this chapter is to build familiarity and confidence with Sequencer.
    That said, if a team doesn't have time (or the need!) to generate such cinematic
    cutscenes, what else is available? Most games will require some level of scripted
    scenes to help the story learn the game (tutorials) or give story exposition,
    immersion, and emotional impact at certain moments. But given all that UE4 has
    to offer and that we've touched on several of these things, it's worth diving
    in a bit further to ensure the right tool is being used for the job.
  prefs: []
  type: TYPE_NORMAL
- en: Fast and easy in-game scenes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few important ways to consider in-game scenes without the full
    Sequencer-based cinematic demonstrated in the last section. Here is a quick list
    of options and common uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Dialog system**: This was discussed in some detail in [Chapter 7](1ce4a5c3-9cf2-4833-bd1f-d81fc181e789.xhtml), *Getting
    Audio in Your Game* with additional reading to help those using it further. Dialog
    is great for characters interacting with audio (and potentially animations) in
    the game, with customized localization text and tunable audio between individual
    character types (so dialog to a male character can differ from female, or friends
    versus enemies in a scene). That said, the flow of dialog, animations played,
    and the level of player control is largely up to the designer making these interactions,
    Dialog is more of an audio and flow-control tool than a full scene-creating device,
    hence our next possibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blueprint**: With enough effort, you can do just about anything you can imagine
    (including, as noted in [Chapter 3](267b875d-60d1-4f92-abf5-76d2e682a12d.xhtml), *Blueprint
    Review and When to Use BP Scripting*, creating entire games) in blueprint. It''s
    all just a matter of managing complexity in the end; but taking away player control,
    setting a specific camera actor, triggering that to play movement along a spline,
    delayed animations with audio playing, and special FX are all completely doable
    with blueprint. There is a huge amount of information on any subsection of blueprint
    you might want to learn more about for this context, too, and great community
    support if you run into any problems. The biggest drawback is that there is a
    steep learning curve to using blueprint this fully, and there is a huge amount
    of risk both for error when used by team members not deeply trained in what should
    maybe be "off-limits" without a deep level of training, and maintaining these
    massive graphs of logic can get overwhelming. Constantly reducing reused bits
    of logic into function libraries and oversight (or content being created) by highly
    technical people often mitigate these issues, but beware before launching it on
    unsuspecting artists!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple Sequences**: Our intro scene from the last section should be entirely
    manageable in a matter of hours simply going through this lesson even without
    any familiarity with Sequencer. The simple version in the first half will take
    a fraction of that time, if merely positioning actors, playing some animations,
    and maybe putting in a few cool effects is all that''s needed, technical and non-technical
    types should be able to manage these with minimal training.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And what was that way back at the top about Matinee? Read on!
  prefs: []
  type: TYPE_NORMAL
- en: Matinee
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As has probably been hammered home enough by now, basically anything Epic''s
    previous tool, which is kept for legacy purposes, could do, Sequencer can also
    do. That said, there can arise situations where someone has a great deal of experience
    with Matinee, or maybe an outsourcing group still uses it, and they want to quickly
    bring that to bear on a project. Other than the already-stated reasons of Sequencer
    being the supported tool going forward, there''s not a specific reason Matinee
    can''t be used still. Matinee has been a classic for having flying cars loop around
    buildings in smooth parabolic curved circuits. It was the mainstay of cinematic
    work in any number of classic UE3 and all early UE4 titles. Anyone having just
    gone through the Sequencer work should immediately recognize a lot of familiar
    themes opening up the Matinee editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82aa1587-0b4d-4aa3-80f9-d28b825c4810.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While the main striking difference is the curve-editing tools on the front
    face of Matinee, fear not, all these controls and some new perks are available
    in Sequencer (check out the tool button near the top of sequencer to view as a
    curve, and select a transform or other track with keyframes):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0e51e53-1ce1-480a-a8ff-8db3a2bd2c98.png)'
  prefs: []
  type: TYPE_IMG
- en: Regardless of what ultimately works best, knowing the options available is the
    name of the game in making your project a success, and in all likelihood, you'll
    end up using any number of the options available in some combination; but by now
    at least the risks and possibilities should be clear from the start.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sequencer is an amazing tool, people are literally making cinematic-quality
    movies in it in realtime these days with the technology Epic has made available,
    which is a wondrous thing. Like most aspects of UE4, these are deep topics and
    each of these can (and likely will) have experts in their field; but as a leader
    and driver of technology in a team, using them all with a level of comfort and
    knowing how they can and do all interact is held in extremely high value. Sequencer,
    and other available tools, can enhance any game and get it out the door to eager
    players hungry for more. Speaking of that, our next chapter will cover how to
    actually *reach* those players with your project.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the main reason to become familiar with Sequencer and use it going forward?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the most commonly-used tracks added in Sequencer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you get an actor into a track?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why not use a pawn with an animation blueprint directly in Sequencer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose and benefit of using level-sequence Shots? How do they relate
    to tracks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a major risk of having sequences embedded in your map levels directly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If blueprint scripting can do almost anything a sequence can do, what's the
    risk of using it for cutscenes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you fine-tune the curves of keyframes in Sequencer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Multiple Shots and Takes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unrealengine.com/en-US/Engine/Sequencer/HowTo/TracksShot](https://docs.unrealengine.com/en-US/Engine/Sequencer/HowTo/TracksShot)'
  prefs: []
  type: TYPE_NORMAL
- en: 'CineCamera Actors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unrealengine.com/en-US/Engine/Sequencer/HowTo/CineCameraActors](https://docs.unrealengine.com/en-US/Engine/Sequencer/HowTo/CineCameraActors)'
  prefs: []
  type: TYPE_NORMAL
