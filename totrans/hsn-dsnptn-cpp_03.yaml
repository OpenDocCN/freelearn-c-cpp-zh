- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory and Ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory mismanagement is one of the most common problems in C++ programs. Many
    of these problems boil down to incorrect assumptions about which part of the code
    or which entity owns a particular memory. Then, we get memory leaks, accessing
    unallocated memory, excessive memory use, and other problems that are difficult
    to debug. Modern C++ has a set of memory ownership idioms that, taken together,
    allow the programmer to clearly express their design intent when it comes to memory
    ownership. This, in turn, makes it much easier to write code that correctly allocates,
    accesses, and deallocates memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is memory ownership and resource ownership?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the characteristics of well-designed resource ownership? When and how
    should we be agnostic about resource ownership? How do we express exclusive memory
    ownership in C++?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we express shared memory ownership in C++?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the cost of different memory ownership language constructs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the C++ Core Guidelines at [https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md).
  prefs: []
  type: TYPE_NORMAL
- en: You can find the C++ **Guidelines Support Library** (**GSL**) at [https://github.com/Microsoft/GSL](https://github.com/Microsoft/GSL).
    Examples are available at [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: What is memory ownership?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++, the term *memory ownership* refers to the entity that is responsible
    for enforcing the lifetime of a particular memory allocation. In reality, we rarely
    talk about the ownership of raw memory. Usually, we manage the ownership and the
    lifetime of the objects that reside in said memory and memory ownership is really
    just shorthand for *object ownership*. The concept of memory ownership is closely
    tied to that of *resource ownership*. First of all, memory is a resource. It is
    not the only resource a program can manage, but it is by far the most commonly
    used one. Second, the C++ way of managing resources is to have objects own them.
    Thus, the problem of managing resources is reduced to the problem of managing
    the owning objects, which, as we just learned, is what we really mean when we
    talk about memory ownership. In this context, memory ownership is about owning
    more than memory, and mismanaged ownership can leak, miscount, or lose track of
    any resource that can be controlled by the program—memory, mutexes, files, database
    handles, cat videos, airline seat reservations, or nuclear warheads.
  prefs: []
  type: TYPE_NORMAL
- en: Well-designed memory ownership
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What does well-designed memory ownership look like? The naive answer that first
    comes up is that, at every point in the program, it is clear who owns which object.
    This, however, is overly constraining—most of the program does not deal with ownership
    of resources, including memory. These parts of the program merely use resources.
    When writing such code, it is sufficient to know that a particular function or
    class does not own the memory. It is completely irrelevant to know who does what:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'How about this, then—at every point in the program, is it clear who owns that
    object, or is it clear that the owner is not changing? This is better since most
    of the code will fall under the second part of our answer. However, it’s still
    too constraining—when taking ownership of an object, it is usually not important
    to know who it is taken from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the whole point of shared ownership (expressed through the reference-counted
    `std::shared_ptr`) is that we don’t need to know who else owns the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A more accurate description of well-designed memory ownership takes more than
    one quoted sentence. Generally, the following are the attributes of good memory
    ownership practices:'
  prefs: []
  type: TYPE_NORMAL
- en: If a function or a class does not alter memory ownership in any way, this should
    be clear to every client of this function or class, as well as the implementer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a function or a class takes exclusive ownership of some of the objects passed
    to it, this should be clear to the client (we assume that the implementer knows
    this already since they have to write the code).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a function or a class shares ownership of an object passed to it, this should
    be clear to the client (or anyone who reads the client code, for that matter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For every object that is created, for every unit of code where it’s used, it
    is clear whether this code is expected to delete the object or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Poorly designed memory ownership
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as good memory ownership defies a simple description and instead is characterized
    by a set of criteria it satisfies, so can bad memory ownership practices be recognized
    by their common manifestations. In general, where a good design makes it clear
    whether a particular piece of code owns a resource or not, a bad design requires
    additional knowledge that cannot be deduced from the context. For example, who
    owns the object returned by the following `MakeWidget()` function?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Is the client expected to delete the widget when it’s no longer needed? If
    yes, how should it be deleted? If we decide to delete the widget and do it in
    the wrong way, for example, by calling `operator delete` on a widget that was
    not, in fact, allocated by `operator new`, memory corruption will certainly result.
    In the best-case scenario, the program will just crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Does the Factory own the widgets it created? Will it delete them when the Factory
    object is deleted? Alternatively, is the client expected to do that? If we decide
    that the Factory probably knows what it created and will delete all such objects
    in due time, we may end up with a memory leak (or worse, if the objects owned
    some other resources):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Does `Transmogrify()` take ownership of the widget? Is the `w` widget still
    around after `Transmogrify()` is done with it? If the widget is deleted to construct
    a new, transmogrified, `w1` widget, we now have a dangling pointer. If the widget
    is not deleted, but we assume it might be, we have a memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lest you think that all bad memory management practices can be recognized by
    the presence of raw pointers somewhere, here is an example of a rather poor approach
    to memory management that often arises as a knee-jerk response to the problems
    caused by the use of raw pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `Double()` function is claiming in its interface that it takes shared ownership
    of the vector. However, that ownership is entirely gratuitous—there is no reason
    for `Double()` to own its argument—it does not attempt to extend its lifetime
    and, it does not transfer ownership to anyone else; it merely modifies a vector
    passed in by the caller. We can reasonably expect that the caller owns the vector
    (or that somebody else even higher in the call stack does), and that the vector
    will still be around when `Double()` returns control to the caller—after all,
    the caller wanted us to double the elements, presumably so that they can do something
    else with them.
  prefs: []
  type: TYPE_NORMAL
- en: While this list is hardly complete, it serves to demonstrate the spectrum of
    problems that can be caused by a slap-dash approach to memory ownership. In the
    next section, we review the patterns and guidelines developed by the C++ community
    to help to avoid these problems and express the programmer’s intent clearly.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing memory ownership in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout its history, the C++ language has evolved in its approach to expressing
    memory ownership. The same syntactic constructs have been, at times, imbued with
    different assumed semantics. This evolution was partially driven by new features
    added to the language (it’s hard to talk about shared memory ownership if you
    don’t have any shared pointers). On the other hand, most of the memory management
    tools added in C++ 11 and later were not new ideas or new concepts. The notion
    of a shared pointer has been around for a long time. This language support makes
    it easier to implement one (and having a shared pointer in the standard library
    makes most custom implementations unnecessary), but shared pointers were used
    in C++ long before C++ 11 added them to the standard. The more important change
    that has occurred was the evolution of the understanding of the C++ community
    and the emergence of common practices and idioms. It is in this sense, as a set
    of conventions and semantics commonly associated with different syntactic features,
    that we can talk about the set of memory management practices as a design pattern
    of the C++ language. Let’s now learn the different ways that we can express different
    types of memory ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing non-ownership
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with the most common kind of memory ownership. Most code does not
    allocate, deallocate, construct, or delete. It just does its work on objects that
    were created by someone else earlier and will be deleted by someone else later.
    How do you express the notion that a function is going to operate on an object
    but will not attempt to delete it or, conversely, extend its lifetime past the
    completion of the function itself?
  prefs: []
  type: TYPE_NORMAL
- en: 'Very easily, in fact, and every C++ programmer has done it many times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In a well-written program, a function with a raw pointer parameter signals
    that it is not involved with the ownership of the corresponding object in any
    way; the same goes for references. Similarly, a class that contains a member function
    pointer refers to an object but expects someone else to own it and manage its
    lifetime. Note that the destructor of the `WidgetProcessor` class in the next
    example does not delete the object the class points to – this is a sure sign that
    we refuse ownership of that object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Non-owning access to an object should be granted by using raw pointers or references.
    Yes—even in C++ 14, with all its smart pointers, there is a place for raw pointers.
    Not only that but in the bulk of the code, the majority of pointers will be raw
    pointers—all the non-owning ones (as we will see in the next section, C++17 and
    C++20 take this point much further).
  prefs: []
  type: TYPE_NORMAL
- en: You might reasonably point out at this time that the preceding example of recommended
    practices for granting non-owning access looks exactly like one of the examples
    of bad practices shown earlier. The distinction is in the context—in a well-designed
    program, only non-owning access is granted through raw pointers and references.
    Actual ownership is always expressed in some other way. Thus, it is clear that
    when a raw pointer is encountered, the function or class is not going to mess
    with the ownership of the object in any way. This, of course, creates some confusion
    when it comes to converting old legacy code, with raw pointers everywhere, to
    modern practices. As a matter of clarity, it is recommended to convert such code
    one part at a time, with clearly indicated transitions between code that follows
    the modern guidelines and code that does not.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue to discuss here is the use of pointers versus references. As a
    matter of syntax, the reference is basically a pointer that is never null and
    cannot be left uninitialized. It is tempting to adopt a convention that any pointer
    passed to a function may be null and must, therefore, be checked, and any function
    that cannot accept a null pointer must instead take a reference. It is a good
    convention and widely used, but not widely enough to be considered an accepted
    design pattern. Perhaps in recognition of this, the C++ Core Guidelines library
    offers an alternative for expressing non-null pointers—`not_null<T*>`. Note that
    this is not a part of the language itself, but can be implemented in standard
    C++ without any language extension.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing exclusive ownership
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second most common type of ownership is exclusive ownership—the code creates
    an object and will delete it later. The task of deletion will not be delegated
    to someone else, and no extension of the lifetime of the object is permitted.
    This type of memory ownership is so common that we do it all the time without
    even thinking about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: All local (stack) variables express unique memory ownership! Note that ownership
    in this context does not mean that someone else will not modify the object. It
    merely means that when the creator of the `w` widget—the `DoWork()` function,
    in our case—decides to delete it; the deletion will succeed (nobody has deleted
    it already) and the object will actually be deleted (nobody attempted to keep
    the object alive after the end of its scope).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the oldest way to construct an object in C++, and it’s still the best
    one. If a stack variable does what you need, use it. C++ 11 provides another way
    to express unique ownership, and it is mainly used in cases where an object cannot
    be created on the stack but must be allocated on the heap. Heap allocation often
    happens when ownership is shared or transferred—after all, the stack-allocated
    object will be deleted at the end of the containing scope; there is no way around
    it. If we need to keep the object alive for longer, it has to be allocated somewhere
    else. The other reason to create objects on the heap is that the size or type
    of the object may not be known at compile time. This usually happens when the
    object is polymorphic—a derived object is created, but the base class pointer
    is used. Whatever the reason for not allocating objects on the stack, we have
    a way of expressing the exclusive ownership of such objects using `std::unique_ptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a technical reason why you may have to construct objects on the
    heap even when a stack-allocated object seems sufficient: the stack size is quite
    limited, usually anywhere between 2 MB and 10 MB. That is the space for all stack
    allocations in one thread, and when it is exceeded, the program crashes. A large
    enough object can exhaust the stack space or push it too close to the limit for
    subsequent allocations. Such objects must be created on the heap and owned by
    stack-allocated unique pointers or other resource-owning objects.'
  prefs: []
  type: TYPE_NORMAL
- en: What if the way to create an object is more complex than just `operator new`,
    and we need a Factory function? That is the type of ownership we will consider
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing transfer of exclusive ownership
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding example, a new object was created and immediately bound to
    a unique pointer, `std::unique_ptr`, which guarantees exclusive ownership. The
    client code looks exactly the same if the object is created by a Factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: But what should the Factory function return? It could certainly return a raw
    pointer, `Widget*`. After all, that is what `new` returns. But this opens the
    way to incorrect use of `WidgetFactory`—for example, instead of capturing the
    returned raw pointer in a unique pointer, we could pass it to a function such
    as `Transmogrify` that takes a raw pointer because it does not deal with the ownership.
    Now, nobody owns the widget, and it ends up as a memory leak. Ideally, `WidgetFactory`
    would be written in a way that would force the caller to take ownership of the
    returned object.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need here is an ownership transfer—`WidgetFactory` is certainly an
    exclusive owner of the object it constructs, but at some point, it needs to hand
    off that ownership to a new, also exclusive, owner. The code to do so is very
    simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This works exactly the way we want it to, but why? Doesn’t the unique pointer
    provide exclusive ownership? The answer is, it does, but it is also a movable
    object (it has a move constructor). Moving the content of a unique pointer into
    another one transfers the ownership of the object; the original pointer is left
    in the moved-from state (its destruction will not delete any objects). What is
    so good about this idiom? It clearly expresses, and forces at compile time, that
    the Factory expects the caller to take exclusive (or shared) ownership of the
    object. For example, the following code, which would have left the new widget
    with no owner, does not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'So, how do we call `Transmogrify()` on a widget after we properly assumed ownership?
    This is still done with a raw pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'But what about the stack variables? Can exclusive ownership be transferred
    to someone else before the variable is destroyed? This is going to be slightly
    more complicated—the memory for the object is allocated on the stack and is going
    away, so some amount of copying is involved. Exactly how much copying depends
    on whether the object is movable. Moving, in general, transfers the ownership
    from the moved-from object to the moved-to one. This can be used for return values
    but is more often used for passing arguments to functions that take exclusive
    ownership. Such functions must be declared to take the parameters by the `rvalue`
    reference `T&&`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that the caller must explicitly give up ownership by wrapping the argument
    in `std::move`. This is one of the advantages of this idiom; without it, an ownership-transferring
    call would look exactly the same as a regular call.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing shared ownership
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last type of ownership we need to cover is shared ownership, where multiple
    entities own the object equally. First, a word of caution—shared ownership is
    often misused, or over-used. Consider the preceding example, where a function
    was passed a shared pointer to an object it did not need to own. It is tempting
    to let the reference counting deal with the ownership of objects and *not worry
    about deletion*. However, this is often a sign of poor design. In most systems,
    at some level, there is clear ownership of resources, and this should be reflected
    in the chosen design of resource management. The *not worry about deletion* concern
    remains valid; explicit deletion of objects should be rare, but automatic deletion
    does not require shared ownership, merely a clearly expressed one (unique pointers,
    data members, and containers provide automatic deletion just as well).
  prefs: []
  type: TYPE_NORMAL
- en: That being said, there are definite cases for shared ownership. The most common
    valid applications of shared ownership are at a low level, inside data structures
    such as lists, trees, and more. A data element may be owned by other nodes of
    the same data structure, by any number of iterators currently pointing to it,
    and, possibly by some temporary variables inside data structure member functions
    that operate on the entire structure or a part of it (such as rebalancing a tree).
    The ownership of the entire data structure is usually clear in a well-thought-out
    design. But the ownership of each node, or data element, may be truly shared in
    the sense that any owner is equal to any other; none is privileged or primary.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++, the notion of shared ownership is expressed through a shared pointer,
    `std::shared_ptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of this design is that a list element that was unlinked from the
    list remains alive for as long as there is a way to access it through an iterator.
    This is not the way `std::list` is done, and it does not provide such guarantees
    (deleting a `std::list` object invalidates all iterators). Note that the doubly
    linked list of shared pointers makes it so any two consecutive nodes in the list
    own each other and neither is deleted even when the list head is deleted; this
    leaks the owned objects. For this reason, a real design would likely use `std::weak_pointer`
    for one of `next` or `prev`.
  prefs: []
  type: TYPE_NORMAL
- en: Such complications aside, this may be a valid design for certain applications
    where the iterators need to own the data they refer to even after the list is
    deleted or some elements are erased from the list. One example is a thread-safe
    list, where it is very difficult to guarantee that one thread does not erase a
    list element while another still has an iterator pointing to it. Note that this
    particular application would also require atomic shared pointers, which are only
    available in C++ 20 (or you can write your own using C++ 11).
  prefs: []
  type: TYPE_NORMAL
- en: Now, what about functions taking shared pointers as parameters? In a program
    that follows good memory ownership practices, such a function conveys to the caller
    that it intends to take partial ownership that lasts longer than the function
    call itself—a copy of the shared pointer will be created. In the concurrent context,
    it may also indicate that the function needs to protect the object from deletion
    by another thread for at least as long as it’s executing.
  prefs: []
  type: TYPE_NORMAL
- en: There are several disadvantages to shared ownership that you must keep in mind.
    The best-known one is the bane of shared pointers, that is, the circular dependency.
    If two objects with shared pointers point to each other, the entire pair remains
    *in use* indefinitely. C++ offers a solution to that in the form of `std::weak_ptr`,
    a counterpart to the shared pointer that provides a safe pointer to an object
    that may have already been deleted. If the previously mentioned pair of objects
    uses one shared and one weak pointer, the circular dependency is broken.
  prefs: []
  type: TYPE_NORMAL
- en: The circular dependency problem is real, but it happens more often in designs
    where shared ownership is used to conceal the larger problem of unclear resource
    ownership. However, there are other downsides to shared ownership. The performance
    of a shared pointer is always going to be lower than that of a raw pointer. On
    the other hand, a unique pointer can be just as efficient as a raw pointer (and
    in fact, `std::unique_ptr` is). When the shared pointer is first created, an additional
    memory allocation for the reference count must take place.
  prefs: []
  type: TYPE_NORMAL
- en: In C++ 11, `std::make_shared` can be used to combine the allocations for the
    object itself and the reference counter, but this implies that the object is created
    with the intent to share (often, the object Factory returns unique pointers, some
    of which are later converted to shared pointers). Copying or deleting a shared
    pointer must also increment or decrement the reference counter. Shared pointers
    are often attractive in concurrent data structures, where, at least at the low
    level, the notion of ownership may indeed be fuzzy, with several accesses to the
    same object happening at the same time. However, designing a shared pointer to
    be thread-safe in all contexts is not easy and carries additional runtime overhead.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have mostly restricted ourselves to pointers as means of owning objects
    (and their memory and other resources). Non-ownership has been similarly expressed
    through raw pointers and references or simple non-owning pointers. However, this
    is not the only way to own resources (and we did mention that the most common
    form of exclusive ownership is a stack variable). We are now going to see how
    resource-owning objects can be used directly to express both ownership and non-ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Owning objects and views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ has not been limited to owning pointers since its creation: any object
    can own resources, and we already mentioned that the simplest way to express exclusive
    ownership is to create a local variable on the stack. Of course, any of such objects
    can also be owned by a pointer (unique or shared) and when non-owning access is
    desired, these objects are commonly accessed through raw pointers or references.
    However, in C++17 and C++20 a different pattern has emerged, and it is worth exploring.'
  prefs: []
  type: TYPE_NORMAL
- en: Resource-owning objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every C++ programmer is familiar with resource-owning objects; perhaps the most
    common one is `std::string` – an object that owns a character string. Of course,
    it also has a lot of specialized member functions for operating on strings, but
    from the point of view of memory ownership, `std::string` is essentially an owning
    `char*` pointer. Similarly, `std::vector` is an owning object for an array of
    objects of arbitrary type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common way to construct such objects is either as local variables
    or as data members of a class. In the latter case, the issue of who owns the entire
    class is managed elsewhere, but, within the class, all data members are owned
    exclusively by the object itself. Consider this simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have not said anything new compared to the section on exclusive
    ownership just a few pages earlier in this chapter. However, we have subtly changed
    the focus from owning pointers to owning objects. As long as we focus on the ownership
    aspect, these objects are essentially specialized owning (unique) pointers. There
    is an important difference, however: most such objects convey additional information,
    such as the length of the string for `std::string` or the size of the array for
    `std::vector`. Keep this in mind: it is going to come up again when we get to
    the changes brought by C++17/20.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While resource-owning objects have been around since the beginning of C++,
    they themselves have been often owned through pointers. There are, perhaps, two
    main reasons for this; both have been rendered obsolete by C++ advances. The first
    reason to own, for example, a string via an owning pointer is the need to transfer
    ownership. A stack object is destroyed at the end of the scope. A class data member
    is destroyed when the object is destroyed. In either case, there is no way to
    transfer the ownership of the object itself, such as `std::string`, to someone
    else. However, if we focus on the ownership aspect, then the string object itself
    is just a (decorated) owning pointer, and the goal is to transfer the ownership
    of the underlying resource (the character string for `std::string`) to another
    owner. When we put it this way, the answer is obvious: since C++11, the string
    has move semantics, and moving a string is barely more expensive than moving a
    pointer (remember, the string is an owning pointer that also knows the length,
    so that has to be moved too).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can say, more generally, that there is no reason to own a cheap-to-move
    owning object via a pointer if the only reason is ownership transfer. For example,
    consider this string builder class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'While it gets the job done, a much better way to write the same class is to
    simply move the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The same is true for factories that construct owning cheap-to-move objects.
    Instead of returning them via `std::unique_ptr`, the factory can return the object
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The return value may benefit from the return-value optimization (the compiler
    constructs the return value directly in the memory allocated for the final object,
    `my_string`). But even without this optimization, we have a guarantee that there
    is no copying of the string here, only moving (if this move is optimized away,
    the optimization is sometimes called **move elision**, similar to the better-known
    **copy elision**, which optimizes away copy constructors).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second reason to use owning pointers for resource-owning objects is that
    the object’s existence itself may be conditional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In many cases, an “*empty*” object can be used instead, such as a zero-length
    string. Again, for many owning objects, and certainly for all cheap-to-move STL
    containers, the cost of constructing such an object is trivial. But there could
    be a meaningful difference between the empty string and no string at all (that
    is, an empty string could be a valid result, and an absence of any string signifies
    something to the rest of the program). In C++17, we have a straightforward way
    to express this behavior using `std::optional`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The object of the `std::optional<std::string>` type may contain a string or
    be empty. The non-empty `std::optional` owns the object it contains (deleting
    the `std::optional` will also delete the string). Unlike `std::unique_pointer`,
    there are no heap memory allocations here: the `std::optional` object contains
    enough space within it to store a `std::string` object. `std::optional` is also
    movable, just like the string itself, so this pattern can be combined with the
    previous one. In general, we can say that in modern C++ there is no reason to
    own lightweight owning objects such as `std::string` indirectly. However, expressing
    the non-ownership of such objects has not received as much attention until recently.'
  prefs: []
  type: TYPE_NORMAL
- en: Non-owning access to resource-owning objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen how a `std::string` object can, for most purposes, replace an
    owning pointer to `char*` (or to `std::string`). How do we, then, express non-owning
    access? Let us say that we need to pass a string to a function that operates on
    the string but does not take ownership of it (does not destroy it). This is a
    trivial exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we have been doing since C++ was created. But this simplicity
    hides a profound distinction: remember that, as long as we don’t care about all
    the extra methods and the features they provide, `std::string` is just an owning
    pointer to a character string that also knows its length. So, how would we handle
    the same situation if we used an owning pointer instead of a string? The corresponding
    pointer is `std::unique_ptr<char[]>`, so we would write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the earlier guidelines, we passed a non-owning raw pointer to the
    function. We definitely would not write this declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Yet we do this without a second thought when the same character array is owned
    by a `std::string` object. Why do we approach these very similar problems so differently?
    This is the time to remember why a string is not just an owning pointer restricted
    to character arrays; it contains more information than just the pointer: it also
    knows the length of the string. There was no good way in C++ to grant non-owning
    access to such “*rich*” owning pointers, short of passing the entire pointer object
    by reference. By contrast, a unique pointer (or any other owning pointer) contains
    the same information as a basic pointer, so when ownership is not required, the
    owning pointer naturally reduces to a raw pointer without any information loss.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference is about more than just symmetry. Consider that passing a string
    by a `const` reference prevents the function `work_on_string` from changing the
    content of the string. On the other hand, a non-`const` reference allows the function
    to clear the string (release the memory it owns), which is an ownership aspect.
    We are forced to muddle the clarity of intent by mixing together two unrelated
    types of access we can grant to a function: the ability to change the content
    of the data and the ownership of the data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'C++17 addressed this problem in a very limited context: specifically for strings,
    it introduced a new type `std::string_view`. A string view is a (`const`) non-owning
    pointer to a string that also stores the length of the string. In other words,
    it is a perfect non-owning equivalent to `std::string`: a string view to a string
    is exactly what a `const` raw pointer is to a unique pointer. Now, to grant non-owning
    access to a `std::string` object, we write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, a function that takes ownership of a `std::string` object must
    still take it by reference. Specifically, use an rvalue reference to transfer
    the ownership:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Use a non-`const` lvalue reference only to allow the function to change the
    string; in C++17, there is no good *rich pointer* equivalent to a non-`const`
    raw pointer. There is probably no need to use `const std::string&` except when
    the existing interfaces require it since `std::string_view` offers equivalent
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: There are other benefits and advantages of using `std::string_view` (in particular,
    it greatly simplifies writing common code for processing C and C++ strings), but
    in this chapter, we focus on the ownership aspect. Also, remember that the string
    view is limited to character strings. We could have the exact same discussion
    about another owning class, for example, `std::vector<int>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now see a new pattern emerge: for a “*rich*” owning pointer that, in addition
    to owning memory, contains some information about the data it owns, the corresponding
    non-owning object (the equivalent of a raw pointer) should be a view object that
    contains the same information but does not own the resource. We find this view
    object in C++20 as `std::span`. Until then, the only good way to grant non-owning
    access to a vector of integers was to pass it by reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++20, we can use the span to clearly differentiate the non-owning view
    (raw pointer equivalent) from the owning object (unique pointer equivalent):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, `std::span<int>` is a *rich pointer* equivalent to `int*`—it contains
    a non-`const` pointer and the size is cheap to copy and does not own the resource
    it points to. Unlike `std::string_view`, we can modify the object accessed through
    a span. But if we want the equivalent to a `const` pointer, we can use `std::span<const
    int>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Since `std::string` contains a contiguous array of characters, it too can be
    used with a span, in this case, `std::span<char>` or `std::span<const char>`.
    The latter is essentially the same as `std::string_view`, including the option
    to construct them from string literals. The former is the equivalent of a non-`const`
    pointer to `char`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The span pairs well with a vector or a string because they offer a non-owning
    view of an array. But it does not work for other STL containers since they all
    allocate memory in multiple non-contiguous allocations. For that, we need to use
    the C++20 ranges library. For example, the generalization of the preceding non-owning
    vector access to an arbitrary container can be written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have never seen a C++20 template, this takes some getting used to. The
    first line is a template function: `auto` parameters make “*ordinary*” functions
    into templates even without the `template` keyword. The incantation `std::ranges::view`
    before `auto` restricts the template parameters to those that satisfy the view
    concept. A view is a container-like object that has `begin()` and `end()` member
    functions and, in addition, must be cheap to move and either cheap to copy or
    non-copyable (this is, of course, a loose paraphrasing of the exact requirements
    enumerated by the standard). We could have written the same function with the
    `template` and `requires` keywords, but this compact syntax is idiomatic in C++20.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, in this concept-based coding style, the restrictions on the function
    arguments are specified by the concept requirements. We could have written the
    same template function to require ranges instead of views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Ranges are essentially arbitrary objects with `begin()` and `end()`, so `std::list`
    is a range (but not a view, it can be copied but not cheaply). Note that, as written,
    the function takes the argument by value, so a copy is made. Unless that was the
    intent (and in this case, it is not), the correct way to write this function is
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A `const` reference would also work if we wanted to express non-modifying access.
    But the important point to note is that we did not have to do the same for views:
    by restricting the `work_on_data` function to accept only views, we have limited
    it to cheap-to-copy types similar to `std::string_view` (or a raw pointer, for
    that matter). Indeed, passing a range by reference is exactly like passing a string
    or a vector itself: this gives the callee access to the ownership. If we want
    to write a function that explicitly does not take ownership of a range, the view
    is the right way to express this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is still too early to talk about patterns for C++20 ranges: they have not
    been around long enough to establish commonly recognized and accepted use practices
    (a necessary requirement for a pattern) and the library is still incomplete. C++23
    is expected to contain several significant enhancements (in particular, there
    is no good equivalent to `std::span<const char>` in C++20 ranges – it is going
    to be added in C++23).'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can confidently talk about the more general pattern becoming established
    in C++: resource ownership, including memory, should be handled by owning objects,
    while non-owning access should be granted through views. The owning objects can
    be smart pointers or more complex and specialized container objects. These containers,
    in addition to managing the memory in more complex ways, embed more information
    about the data they contain. In general, for each container, there should be a
    corresponding view that grants non-owning access while preserving all the additional
    information. For smart pointers, this view is a raw pointer or a reference. For
    `std::string`, this view is `std::string_view`. For `std::vector`, arrays, and
    any other containers that own contiguous memory, you will want `std::span`. For
    arbitrary containers, the corresponding views may be found in the C++20 ranges
    library; for a custom container, you may have to write your own view objects as
    well (just make sure they satisfy the relevant view concepts).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++, memory ownership is really just shorthand for object ownership, which,
    in turn, is the way to manage arbitrary resources, their ownership, and access.
    We have reviewed the contemporary idioms that the C++ community has developed
    to express different types of memory ownership. C++ allows the programmer to express
    exclusive or shared memory ownership. Just as important is expressing *non-ownership*
    in programs that are agnostic about the ownership of resources. We have also learned
    about the practices and attributes of resource ownership in a well-designed program.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have the idiomatic language to clearly express which entity in the program
    owns each object or resource, and when non-owning access is granted. The next
    chapter covers the idiom for the simplest operation on resources: the exchange,
    or swap.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is it important to clearly express memory ownership in a program?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the common problems that arise from unclear memory ownership?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What types of memory ownership can be expressed in C++?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you write non-memory-owning functions and classes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should exclusive memory ownership be preferred to a shared one?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you express exclusive memory ownership in C++?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you express shared memory ownership in C++?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the potential downsides of shared memory ownership?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are views? How is a string view better than passing a string by reference?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*C++20 STL Cookbook* by *Bill* *Weinman*: [https://www.packtpub.com/product/c20-stl-cookbook/9781803248714](https://www.packtpub.com/product/c20-stl-cookbook/9781803248714)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Template Metaprogramming with C++* by *Marius* *Bancila*: [https://www.packtpub.com/product/template-metaprogramming-with-c/9781803243450](https://www.packtpub.com/product/template-metaprogramming-with-c/9781803243450)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C++ Data Structures and Algorithms* by *Wisnu* *Anggoro*: [https://www.packtpub.com/application-development/c-data-structures-and-algorithms](https://www.packtpub.com/application-development/c-data-structures-and-algorithms)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Expert C++ Programming* by *Jeganathan Swaminathan*, *Maya Posch*, and *Jacek*
    *Galowicz*: [https://www.packtpub.com/application-development/expert-c-programming](https://www.packtpub.com/application-development/expert-c-programming)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 2: Common C++ Idioms'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This part describes some of the more common C++ idioms: established, universally
    recognized ways to express a specific idea or implement a frequently needed task.
    The boundary between “patterns” and “idioms” is fuzzy at best. In this book, we
    consider more complete design solutions to be patterns, while simpler techniques
    are idioms. In other words, choosing a pattern may influence the design of your
    entire application or its major component, while using an idiom is more of an
    implementation decision that has been learned from someone else’s mistakes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B19262_04.xhtml#_idTextAnchor152), *Swap - From Simple to Subtle*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B19262_05.xhtml#_idTextAnchor199), *A Comprehensive Look at RAII*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19262_06.xhtml#_idTextAnchor266), *Understanding Type Erasure*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19262_07.xhtml#_idTextAnchor314), *SFINAE, Concepts, and Overload
    Resolution Management*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
