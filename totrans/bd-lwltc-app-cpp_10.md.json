["```cpp\n  enum class AlgoType : int8_t {\n    INVALID = 0,\n    RANDOM = 1,\n    MAKER = 2,\n    TAKER = 3,\n    MAX = 4\n  };\n```", "```cpp\n  inline auto algoTypeToString(AlgoType type) -> std::string {\n    switch (type) {\n      case AlgoType::RANDOM:\n        return \"RANDOM\";\n      case AlgoType::MAKER:\n        return \"MAKER\";\n      case AlgoType::TAKER:\n        return \"TAKER\";\n      case AlgoType::INVALID:\n        return \"INVALID\";\n      case AlgoType::MAX:\n        return \"MAX\";\n    }\n    return \"UNKNOWN\";\n  }\n```", "```cpp\n  inline auto stringToAlgoType(const std::string &str) ->\n    AlgoType {\n    for (auto i = static_cast<int>(AlgoType::INVALID); i <=\n      static_cast<int>(AlgoType::MAX); ++i) {\n      const auto algo_type = static_cast<AlgoType>(i);\n      if (algoTypeToString(algo_type) == str)\n        return algo_type;\n    }\n    return AlgoType::INVALID;\n  }\n```", "```cpp\n#pragma once\n#include \"common/macros.h\"\n#include \"common/logging.h\"\n#include \"order_manager.h\"\n#include \"feature_engine.h\"\nusing namespace Common;\n```", "```cpp\nnamespace Trading {\n  class MarketMaker {\n  private:\n    const FeatureEngine *feature_engine_ = nullptr;\n    OrderManager *order_manager_ = nullptr;\n    std::string time_str_;\n    Common::Logger *logger_ = nullptr;\n    const TradeEngineCfgHashMap ticker_cfg_;\n  };\n}\n```", "```cpp\n    #include \"market_maker.h\"\n    ```", "```cpp\n    #include \"trade_engine.h\"\n    ```", "```cpp\n    namespace Trading {\n    ```", "```cpp\n      MarketMaker::MarketMaker(Common::Logger *logger,\n    ```", "```cpp\n        TradeEngine *trade_engine, const FeatureEngine\n    ```", "```cpp\n          *feature_engine,\n    ```", "```cpp\n    OrderManager *order_manager, const\n    ```", "```cpp\n      TradeEngineCfgHashMap &ticker_cfg)\n    ```", "```cpp\n          : feature_engine_(feature_engine),\n    ```", "```cpp\n            order_manager_(order_manager),\n    ```", "```cpp\n              logger_(logger),\n    ```", "```cpp\n            ticker_cfg_(ticker_cfg) {\n    ```", "```cpp\n    trade_engine->algoOnOrderBookUpdate_ = [this](auto\n      ticker_id, auto price, auto side, auto book) {\n      onOrderBookUpdate(ticker_id, price, side, book);\n    };\n    trade_engine->algoOnTradeUpdate_ = [this](auto\n      market_update, auto book) {\n        onTradeUpdate(market_update, book); };\n    trade_engine->algoOnOrderUpdate_ = [this](auto\n      client_response) { onOrderUpdate(client_response); };\n  }\n}\n```", "```cpp\n    auto onOrderBookUpdate(TickerId ticker_id, Price price,\n      Side side, const MarketOrderBook *book) noexcept -> void {\n      logger_->log(\"%:% %() % ticker:% price:% side:%\\n\",\n        __FILE__, __LINE__, __FUNCTION__,\n                   Common::getCurrentTimeStr(&time_str_),\n                     ticker_id, Common::\n                       priceToString(price).c_str(),\n                   Common::sideToString(side).c_str());\n```", "```cpp\n      const auto bbo = book->getBBO();\n      const auto fair_price = feature_engine_->\n        getMktPrice();\n```", "```cpp\n      if (LIKELY(bbo->bid_price_ != Price_INVALID && bbo->\n        ask_price_ != Price_INVALID && fair_price !=\n          Feature_INVALID)) {\n        logger_->log(\"%:% %() % % fair-price:%\\n\",\n          __FILE__, __LINE__, __FUNCTION__,\n                     Common::getCurrentTimeStr(&time_str_),\n                     bbo->toString().c_str(), fair_price);\n```", "```cpp\n        const auto clip = ticker_cfg_.at(ticker_id).clip_;\n        const auto threshold =\n          ticker_cfg_.at(ticker_id).threshold_;\n```", "```cpp\n        const auto bid_price = bbo->bid_price_ -\n          (fair_price - bbo->bid_price_ >= threshold ? 0 :\n            1);\n        const auto ask_price = bbo->ask_price_ + (bbo->\n          ask_price_ - fair_price >= threshold ? 0 : 1);\n```", "```cpp\n        order_manager_->moveOrders(ticker_id, bid_price,\n          ask_price, clip);\n      }\n    }\n```", "```cpp\n    auto onTradeUpdate(const Exchange::MEMarketUpdate\n      *market_update, MarketOrderBook * /* book */)\n       noexcept -> void {\n      logger_->log(\"%:% %() % %\\n\", __FILE__, __LINE__,\n        __FUNCTION__, Common::\n         getCurrentTimeStr(&time_str_),\n                   market_update->toString().c_str());\n    }\n```", "```cpp\n    auto onOrderUpdate(const Exchange::MEClientResponse\n      *client_response) noexcept -> void {\n      logger_->log(\"%:% %() % %\\n\", __FILE__, __LINE__,\n        __FUNCTION__, Common::\n         getCurrentTimeStr(&time_str_),\n                   client_response->toString().c_str());\n      order_manager_->onOrderUpdate(client_response);\n    }\n```", "```cpp\n#pragma once\n#include \"common/macros.h\"\n#include \"common/logging.h\"\n#include \"order_manager.h\"\n#include \"feature_engine.h\"\nusing namespace Common;\n```", "```cpp\nnamespace Trading {\n  class LiquidityTaker {\n  private:\n    const FeatureEngine *feature_engine_ = nullptr;\n    OrderManager *order_manager_ = nullptr;\n    std::string time_str_;\n    Common::Logger *logger_ = nullptr;\n    const TradeEngineCfgHashMap ticker_cfg_;\n  };\n}\n```", "```cpp\n#include \"liquidity_taker.h\"\n#include \"trade_engine.h\"\nnamespace Trading {\n  LiquidityTaker::LiquidityTaker(Common::Logger *logger,\n    TradeEngine *trade_engine, FeatureEngine\n      *feature_engine,\n    OrderManager *order_manager,\n    const TradeEngineCfgHashMap &ticker_cfg):\n      feature_engine_(feature_engine),\n        order_manager_(order_manager), logger_(logger),\n        ticker_cfg_(ticker_cfg) {\n```", "```cpp\n    trade_engine->algoOnOrderBookUpdate_ = [this](auto\n      ticker_id, auto price, auto side, auto book) {\n      onOrderBookUpdate(ticker_id, price, side, book);\n    };\n    trade_engine->algoOnTradeUpdate_ = [this](auto\n      market_update, auto book) {\n       onTradeUpdate(market_update, book); };\n    trade_engine->algoOnOrderUpdate_ = [this](auto\n      client_response) { onOrderUpdate(client_response); };\n  }\n}\n```", "```cpp\n    auto onTradeUpdate(const Exchange::MEMarketUpdate\n      *market_update, MarketOrderBook *book) noexcept -> void {\n      logger_->log(\"%:% %() % %\\n\", __FILE__, __LINE__,\n        __FUNCTION__, Common::\n          getCurrentTimeStr(&time_str_),\n                   market_update->toString().c_str());\n```", "```cpp\n      const auto bbo = book->getBBO();\n      const auto agg_qty_ratio = feature_engine_->\n        getAggTradeQtyRatio();\n```", "```cpp\n      if (LIKELY(bbo->bid_price_ != Price_INVALID && bbo->\n        ask_price_ != Price_INVALID && agg_qty_ratio !=\n          Feature_INVALID)) {\n        logger_->log(\"%:% %() % % agg-qty-ratio:%\\n\",\n          __FILE__, __LINE__, __FUNCTION__,\n                     Common::getCurrentTimeStr(&time_str_),\n                     bbo->toString().c_str(),\n                       agg_qty_ratio);\n```", "```cpp\n        const auto clip = ticker_cfg_.at(market_update->\n          ticker_id_).clip_;\n        const auto threshold = ticker_cfg_\n          .at(market_update->ticker_id_).threshold_;\n```", "```cpp\n        if (agg_qty_ratio >= threshold) {\n```", "```cpp\n          if (market_update->side_ == Side::BUY)\n            order_manager_->moveOrders(market_update->\n              ticker_id_, bbo->ask_price_, Price_INVALID,\n                clip);\n          else\n            order_manager_->moveOrders(market_update->\n              ticker_id_, Price_INVALID, bbo->bid_price_,\n                clip);\n        }\n      }\n    }\n```", "```cpp\n    auto onOrderBookUpdate(TickerId ticker_id, Price price,\n      Side side, MarketOrderBook *) noexcept -> void {\n      logger_->log(\"%:% %() % ticker:% price:% side:%\\n\",\n        __FILE__, __LINE__, __FUNCTION__,\n                   Common::getCurrentTimeStr(&time_str_),\n                     ticker_id, Common::\n                       priceToString(price).c_str(),\n                   Common::sideToString(side).c_str());\n    }\n```", "```cpp\n    auto onOrderUpdate(const Exchange::MEClientResponse\n      *client_response) noexcept -> void {\n      logger_->log(\"%:% %() % %\\n\", __FILE__, __LINE__,\n        __FUNCTION__, Common::\n          getCurrentTimeStr(&time_str_),\n                   client_response->toString().c_str());\n      order_manager_->onOrderUpdate(client_response);\n    }\n```", "```cpp\n#pragma once\n#include <functional>\n#include \"common/thread_utils.h\"\n#include \"common/time_utils.h\"\n#include \"common/lf_queue.h\"\n#include \"common/macros.h\"\n#include \"common/logging.h\"\n#include \"exchange/order_server/client_request.h\"\n#include \"exchange/order_server/client_response.h\"\n#include \"exchange/market_data/market_update.h\"\n#include \"market_order_book.h\"\n#include \"feature_engine.h\"\n#include \"position_keeper.h\"\n#include \"order_manager.h\"\n#include \"risk_manager.h\"\n#include \"market_maker.h\"\n#include \"liquidity_taker.h\"\n```", "```cpp\nnamespace Trading {\n  class TradeEngine {\n  private:\n    const ClientId client_id_;\n    MarketOrderBookHashMap ticker_order_book_;\n    Exchange::ClientRequestLFQueue *outgoing_ogw_requests_\n      = nullptr;\n    Exchange::ClientResponseLFQueue\n      *incoming_ogw_responses_ = nullptr;\n    Exchange::MEMarketUpdateLFQueue *incoming_md_updates_ =\n      nullptr;\n    Nanos last_event_time_ = 0;\n    volatile bool run_ = false;\n    std::string time_str_;\n    Logger logger_;\n```", "```cpp\n    FeatureEngine feature_engine_;\n    PositionKeeper position_keeper_;\n    OrderManager order_manager_;\n    RiskManager risk_manager_;\n    MarketMaker *mm_algo_ = nullptr;\n    LiquidityTaker *taker_algo_ = nullptr;\n```", "```cpp\n    std::function<void(TickerId ticker_id, Price price,\n      Side side, MarketOrderBook *book)>\n        algoOnOrderBookUpdate_;\n    std::function<void(const Exchange::MEMarketUpdate\n      *market_update, MarketOrderBook *book)>\n        algoOnTradeUpdate_;\n    std::function<void(const Exchange::MEClientResponse\n      *client_response)> algoOnOrderUpdate_;\n```", "```cpp\n    auto defaultAlgoOnOrderBookUpdate(TickerId ticker_id,\n      Price price, Side side, MarketOrderBook *) noexcept\n       -> void {\n      logger_.log(\"%:% %() % ticker:% price:% side:%\\n\",\n        __FILE__, __LINE__, __FUNCTION__,\n                  Common::getCurrentTimeStr(&time_str_),\n                    ticker_id, Common::\n                      priceToString(price).c_str(),\n                  Common::sideToString(side).c_str());\n    }\n    auto defaultAlgoOnTradeUpdate(const\n      Exchange::MEMarketUpdate *market_update,\n        MarketOrderBook *) noexcept -> void {\n      logger_.log(\"%:% %() % %\\n\", __FILE__, __LINE__,\n        __FUNCTION__, Common::\n          getCurrentTimeStr(&time_str_),\n                  market_update->toString().c_str());\n    }\n    auto defaultAlgoOnOrderUpdate(const\n      Exchange::MEClientResponse *client_response) noexcept\n        -> void {\n      logger_.log(\"%:% %() % %\\n\", __FILE__, __LINE__,\n        __FUNCTION__, Common::\n          getCurrentTimeStr(&time_str_),\n                  client_response->toString().c_str());\n    }\n```", "```cpp\n  TradeEngine::TradeEngine(Common::ClientId client_id,\n    AlgoType algo_type,\nconst TradeEngineCfgHashMap &ticker_cfg,\nExchange::ClientRequestLFQueue *client_requests,\nExchange::ClientResponseLFQueue *client_responses,\nExchange::MEMarketUpdateLFQueue *market_updates)\n      : client_id_(client_id),\n        outgoing_ogw_requests_(client_requests),\n          incoming_ogw_responses_(client_responses),\n        incoming_md_updates_(market_updates),\n          logger_(\"trading_engine_\" + std::\n            to_string(client_id) + \".log\"),\n        feature_engine_(&logger_),\n        position_keeper_(&logger_),\n        order_manager_(&logger_, this, risk_manager_),\n        risk_manager_(&logger_, &position_keeper_,\n          ticker_cfg) {\n    for (size_t i = 0; i < ticker_order_book_.size(); ++i) {\n      ticker_order_book_[i] = new MarketOrderBook(i, &logger_);\n      ticker_order_book_[i]->setTradeEngine(this);\n    }\n```", "```cpp\n    algoOnOrderBookUpdate_ = [this](auto ticker_id, auto\n      price, auto side, auto book) {\n      defaultAlgoOnOrderBookUpdate(ticker_id, price, side,\n        book);\n    };\n    algoOnTradeUpdate_ = [this](auto market_update, auto\n      book) { defaultAlgoOnTradeUpdate(market_update,\n        book); };\n    algoOnOrderUpdate_ = [this](auto client_response) {\n      defaultAlgoOnOrderUpdate(client_response); };\n```", "```cpp\n    if (algo_type == AlgoType::MAKER) {\n      mm_algo_ = new MarketMaker(&logger_, this,\n        &feature_engine_, &order_manager_, ticker_cfg);\n    } else if (algo_type == AlgoType::TAKER) {\n      taker_algo_ = new LiquidityTaker(&logger_, this,\n        &feature_engine_, &order_manager_, ticker_cfg);\n    }\n    for (TickerId i = 0; i < ticker_cfg.size(); ++i) {\n      logger_.log(\"%:% %() % Initialized % Ticker:% %.\\n\",\n        __FILE__, __LINE__, __FUNCTION__,\n                  Common::getCurrentTimeStr(&time_str_),\n                  algoTypeToString(algo_type), i,\n                  ticker_cfg.at(i).toString());\n    }\n  }\n```", "```cpp\n    auto start() -> void {\n      run_ = true;\n      ASSERT(Common::createAndStartThread(-1,\n        \"Trading/TradeEngine\", [this] { run(); }) !=\n          nullptr, \"Failed to start TradeEngine thread.\");\n    }\n```", "```cpp\n  TradeEngine::~TradeEngine() {\n    run_ = false;\n    using namespace std::literals::chrono_literals;\n    std::this_thread::sleep_for(1s);\n    delete mm_algo_; mm_algo_ = nullptr;\n    delete taker_algo_; taker_algo_ = nullptr;\n    for (auto &order_book: ticker_order_book_) {\n      delete order_book;\n      order_book = nullptr;\n    }\n    outgoing_ogw_requests_ = nullptr;\n    incoming_ogw_responses_ = nullptr;\n    incoming_md_updates_ = nullptr;\n  }\n```", "```cpp\n    auto stop() -> void {\n      while(incoming_ogw_responses_->size() ||\n        incoming_md_updates_->size()) {\n        logger_.log(\"%:% %() % Sleeping till all updates\n          are consumed ogw-size:% md-size:%\\n\", __FILE__,\n            __LINE__, __FUNCTION__,\n                    Common::getCurrentTimeStr(&time_str_),\n                       incoming_ogw_responses_->size(),\n                         incoming_md_updates_->size());\n        using namespace std::literals::chrono_literals;\n        std::this_thread::sleep_for(10ms);\n      }\n      logger_.log(\"%:% %() % POSITIONS\\n%\\n\", __FILE__,\n        __LINE__, __FUNCTION__, Common::\n         getCurrentTimeStr(&time_str_),\n                  position_keeper_.toString());\n      run_ = false;\n    }\n```", "```cpp\n  auto TradeEngine::sendClientRequest(const\n    Exchange::MEClientRequest *client_request) noexcept ->\n    void {\n    logger_.log(\"%:% %() % Sending %\\n\", __FILE__,\n      __LINE__, __FUNCTION__, Common::\n        getCurrentTimeStr(&time_str_),\n                client_request->toString().c_str());\n    auto next_write = outgoing_ogw_requests_->\n      getNextToWriteTo();\n    *next_write = std::move(*client_request);\n    outgoing_ogw_requests_->updateWriteIndex();\n  }\n```", "```cpp\n  auto TradeEngine::run() noexcept -> void {\n    logger_.log(\"%:% %() %\\n\", __FILE__, __LINE__,\n      __FUNCTION__, Common::getCurrentTimeStr(&time_str_));\n    while (run_) {\n      for (auto client_response = incoming_ogw_responses_->\n        getNextToRead(); client_response; client_response =\n          incoming_ogw_responses_->getNextToRead()) {\n        logger_.log(\"%:% %() % Processing %\\n\", __FILE__,\n          __LINE__, __FUNCTION__, Common::\n            getCurrentTimeStr(&time_str_),\n                    client_response->toString().c_str());\n        onOrderUpdate(client_response);\n        incoming_ogw_responses_->updateReadIndex();\n        last_event_time_ = Common::getCurrentNanos();\n      }\n```", "```cpp\n      for (auto market_update = incoming_md_updates_->\n        getNextToRead(); market_update; market_update =\n          incoming_md_updates_->getNextToRead()) {\n        logger_.log(\"%:% %() % Processing %\\n\", __FILE__,\n         __LINE__, __FUNCTION__, Common::\n           getCurrentTimeStr(&time_str_),\n                    market_update->toString().c_str());\n        ASSERT(market_update->ticker_id_ <\n         ticker_order_book_.size(),\n               \"Unknown ticker-id on update:\" +\n                 market_update->toString());\n        ticker_order_book_[market_update->ticker_id_]->\n          onMarketUpdate(market_update);\n        incoming_md_updates_->updateReadIndex();\n        last_event_time_ = Common::getCurrentNanos();\n      }\n    }\n  }\n```", "```cpp\n  auto TradeEngine::onOrderBookUpdate(TickerId ticker_id,\n    Price price, Side side, MarketOrderBook *book) noexcept\n      -> void {\n    logger_.log(\"%:% %() % ticker:% price:% side:%\\n\",\n      __FILE__, __LINE__, __FUNCTION__,\n                Common::getCurrentTimeStr(&time_str_),\n                  ticker_id, Common::priceToString\n                     (price).c_str(),\n                Common::sideToString(side).c_str());\n    const auto bbo = book->getBBO();\n    position_keeper_.updateBBO(ticker_id, bbo);\n    feature_engine_.onOrderBookUpdate(ticker_id, price,\n       side, book);\n    algoOnOrderBookUpdate_(ticker_id, price, side, book);\n  }\n```", "```cpp\n  auto TradeEngine::onTradeUpdate(const\n    Exchange::MEMarketUpdate *market_update,\n      MarketOrderBook *book) noexcept -> void {\n    logger_.log(\"%:% %() % %\\n\", __FILE__, __LINE__,\n      __FUNCTION__, Common::getCurrentTimeStr(&time_str_),\n                market_update->toString().c_str());\n    feature_engine_.onTradeUpdate(market_update, book);\n    algoOnTradeUpdate_(market_update, book);\n  }\n```", "```cpp\n  auto TradeEngine::onOrderUpdate(const\n    Exchange::MEClientResponse *client_response) noexcept\n      -> void {\n    logger_.log(\"%:% %() % %\\n\", __FILE__, __LINE__,\n      __FUNCTION__, Common::getCurrentTimeStr(&time_str_),\n                client_response->toString().c_str());\n    if (UNLIKELY(client_response->type_ ==\n     Exchange::ClientResponseType::FILLED))\n      position_keeper_.addFill(client_response);\n    algoOnOrderUpdate_(client_response);\n  }\n```", "```cpp\n    auto initLastEventTime() {\n      last_event_time_ = Common::getCurrentNanos();\n    }\n```", "```cpp\n    auto silentSeconds() {\n      return (Common::getCurrentNanos() - last_event_time_)\n        / NANOS_TO_SECS;\n    }\n```", "```cpp\n    auto clientId() const {\n      return client_id_;\n    }\n```", "```cpp\n#include <csignal>\n#include \"strategy/trade_engine.h\"\n#include \"order_gw/order_gateway.h\"\n#include \"market_data/market_data_consumer.h\"\n#include \"common/logging.h\"\nCommon::Logger *logger = nullptr;\nTrading::TradeEngine *trade_engine = nullptr;\nTrading::MarketDataConsumer *market_data_consumer = nullptr;\nTrading::OrderGateway *order_gateway = nullptr;\n```", "```cpp\nint main(int argc, char **argv) {\n  const Common::ClientId client_id = atoi(argv[1]);\n  srand(client_id);\n```", "```cpp\n  const auto algo_type = stringToAlgoType(argv[2]);\n```", "```cpp\n  TradeEngineCfgHashMap ticker_cfg;\n  size_t next_ticker_id = 0;\n  for (int i = 3; i < argc; i += 5, ++next_ticker_id) {\n    ticker_cfg.at(next_ticker_id) =\n      {static_cast<Qty>(std::atoi(argv[i])),\n        std::atof(argv[i + 1]),\n                                     {static_cast<Qty>(std:\n                                     :atoi(argv[i + 2])),\n                                      static_cast<Qty>(std:\n                                     :atoi(argv[i + 3])),\n                                      std::atof(argv[i +\n                                       4])}};\n  }\n```", "```cpp\n  logger = new Common::Logger(\"trading_main_\" +\n    std::to_string(client_id) + \".log\");\n  const int sleep_time = 20 * 1000;\n  Exchange::ClientRequestLFQueue\n    client_requests(ME_MAX_CLIENT_UPDATES);\n  Exchange::ClientResponseLFQueue\n    client_responses(ME_MAX_CLIENT_UPDATES);\n  Exchange::MEMarketUpdateLFQueue\n    market_updates(ME_MAX_MARKET_UPDATES);\n  std::string time_str;\n```", "```cpp\n  logger->log(\"%:% %() % Starting Trade Engine...\\n\",\n    __FILE__, __LINE__, __FUNCTION__,\n     Common::getCurrentTimeStr(&time_str));\n  trade_engine = new Trading::TradeEngine(client_id,\n    algo_type,ticker_cfg,&client_requests,\n        &client_responses,&market_updates);\n  trade_engine->start();\n```", "```cpp\n  const std::string order_gw_ip = \"127.0.0.1\";\n  const std::string order_gw_iface = \"lo\";\n  const int order_gw_port = 12345;\n  logger->log(\"%:% %() % Starting Order Gateway...\\n\",\n    __FILE__, __LINE__, __FUNCTION__,\n      Common::getCurrentTimeStr(&time_str));\n  order_gateway = new Trading::OrderGateway(client_id,\n    &client_requests, &client_responses, order_gw_ip,\n      order_gw_iface, order_gw_port);\n  order_gateway->start();\n```", "```cpp\n  const std::string mkt_data_iface = \"lo\";\n  const std::string snapshot_ip = \"233.252.14.1\";\n  const int snapshot_port = 20000;\n  const std::string incremental_ip = \"233.252.14.3\";\n  const int incremental_port = 20001;\n  logger->log(\"%:% %() % Starting Market Data\n    Consumer...\\n\", __FILE__, __LINE__, __FUNCTION__,\n      Common::getCurrentTimeStr(&time_str));\n  market_data_consumer = new\n    Trading::MarketDataConsumer(client_id, &market_updates,\n      mkt_data_iface, snapshot_ip, snapshot_port,\n        incremental_ip, incremental_port);\n  market_data_consumer->start();\n```", "```cpp\n  usleep(10 * 1000 * 1000);\n```", "```cpp\n  trade_engine->initLastEventTime();\n```", "```cpp\n  if (algo_type == AlgoType::RANDOM) {\n```", "```cpp\n  Common::OrderId order_id = client_id * 1000;\n```", "```cpp\n  std::vector<Exchange::MEClientRequest>\n    client_requests_vec;\n  std::array<Price, ME_MAX_TICKERS> ticker_base_price;\n  for(size_t i = 0; i < ME_MAX_TICKERS; ++i)\n    ticker_base_price[i] = (rand() % 100) + 100;\n```", "```cpp\n  trade_engine->initLastEventTime();\n```", "```cpp\n  for (size_t i = 0; i < 10000; ++i) {\n      const Common::TickerId ticker_id = rand() %\n        Common::ME_MAX_TICKERS;\n      const Price price = ticker_base_price[ticker_id] +\n        (rand() % 10) + 1;\n      const Qty qty = 1 + (rand() % 100) + 1;\n      const Side side = (rand() % 2 ? Common::Side::BUY :\n        Common::Side::SELL);\n```", "```cpp\n    Exchange::MEClientRequest\n      new_request{Exchange::ClientRequestType::NEW,\n        client_id, ticker_id, order_id++, side, price,\n          qty};\n    trade_engine->sendClientRequest(&new_request);\n    usleep(sleep_time);\n    client_requests_vec.push_back(new_request);\n```", "```cpp\n    const auto cxl_index = rand() %\n      client_requests_vec.size();\n    auto cxl_request = client_requests_vec[cxl_index];\n    cxl_request.type_ =\n      Exchange::ClientRequestType::CANCEL;\n    trade_engine->sendClientRequest(&cxl_request);\n    usleep(sleep_time);\n  }\n}\n```", "```cpp\n  while (trade_engine->silentSeconds() < 60) {\n    logger->log(\"%:% %() % Waiting till no activity, been\n      silent for % seconds...\\n\", __FILE__, __LINE__,\n        __FUNCTION__,\n                Common::getCurrentTimeStr(&time_str),\n                  trade_engine->silentSeconds());\n    using namespace std::literals::chrono_literals;\n    std::this_thread::sleep_for(10s);\n  }\n```", "```cpp\n  trade_engine->stop();\n  market_data_consumer->stop();\n  order_gateway->stop();\n  using namespace std::literals::chrono_literals;\n  std::this_thread::sleep_for(10s);\n  delete logger;\n  logger = nullptr;\n  delete trade_engine;\n  trade_engine = nullptr;\n  delete market_data_consumer;\n  market_data_consumer = nullptr;\n  delete order_gateway;\n  order_gateway = nullptr;\n  std::this_thread::sleep_for(10s);\n  exit(EXIT_SUCCESS);\n}\n```", "```cpp\n./cmake-build-release/trading_main  1 MAKER 100 0.6 150 300 -100 60 0.6 150 300 -100 150 0.5 250 600 -100 200 0.4 500 3000 -100 1000 0.9 5000 4000 -100 300 0.8 1500 3000 -100 50 0.7 150 300 -100 100 0.3 250 300 -100 &\n```", "```cpp\nsghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter10$ bash scripts/run_exchange_and_clients.sh\n...\n-- Build files have been written to: /home/sghosh/Building-Low-Latency-Applications-with-CPP/Chapter10/cmake-build-release\n...\n[36/37] Linking CXX executable trading_main\n[37/37] Linking CXX executable exchange_main\n```", "```cpp\n-----------------------------------------\nStarting Exchange...\n-----------------------------------------\nSet core affinity for Common/Logger exchange_main.log 140716464399936 to -1\nSet core affinity for Common/Logger exchange_matching_engine.log 140716293985856 to -1\n...\n```", "```cpp\n-----------------------------------------\nStarting TradingClient 1...\n-----------------------------------------\nSet core affinity for Common/Logger trading_main_1.log 139636947019328 to -1\n...\n-----------------------------------------\nStarting TradingClient 5...\n-----------------------------------------\nSet core affinity for Common/Logger trading_main_5.log 139837285852736 to -1\n...\n```", "```cpp\nSet core affinity for Trading/MarketDataConsumer 139836325348928 to –1\n...\nThu Apr  6 12:37:04 2023 Flushing and closing Logger for trading_main_1.log\n...\nThu Apr  6 12:37:21 2023 Logger for trading_order_gateway_5.log exiting.\n-----------------------------------------\nStopping Exchange...\n-----------------------------------------\n...\nThu Apr  6 12:38:09 2023 Logger for exchange_order_server.log exiting.\n```", "```cpp\nexchange_main.log  exchange_market_data_publisher.log  exchange_matching_engine.log  exchange_order_server.log  exchange_snapshot_synthesizer.log\ntrading_engine_1.log  trading_main_1.log  trading_market_data_consumer_1.log  trading_order_gateway_1.log\n… trading_order_gateway_5.log\n```", "```cpp\n    trading_engine_5.log:trade_engine.cpp:33 sendClientRequest() Thu Apr  6 12:26:47 2023 Sending MEClientRequest [type:NEW client:1 ticker:0 oid:1445 side:BUY qty:10 price:184]\n    ```", "```cpp\n    trading_order_gateway_5.log:order_gateway.cpp:19 run() Thu Apr  6 12:26:47 2023 Sending cid:1 seq:891 MEClientRequest [type:NEW client:1 ticker:0 oid:1445 side:BUY qty:10 price:184]\n    ```", "```cpp\n    exchange_order_server.log:order_server.h:55 recvCallback() Thu Apr  6 12:26:47 2023 Received OMClientRequest [seq:891 MEClientRequest [type:NEW client:1 ticker:0 oid:1445 side:BUY qty:10 price:184]]\n    ```", "```cpp\n    exchange_order_server.log:fifo_sequencer.h:38 sequenceAndPublish() Thu Apr  6 12:26:47 2023 Writing RX:1680802007777361000 Req:MEClientRequest [type:NEW client:1 ticker:0 oid:1445 side:BUY qty:10 price:184] to FIFO.\n    ```", "```cpp\n    exchange_matching_engine.log:matching_engine.h:66 run() Thu Apr  6 12:26:47 2023 Processing MEClientRequest [type:NEW client:1 ticker:0 oid:1445 side:BUY qty:10 price:184]\n    ```", "```cpp\n    exchange_matching_engine.log:matching_engine.h:48 sendClientResponse() Thu Apr  6 12:26:47 2023 Sending MEClientResponse [type:ACCEPTED client:1 ticker:0 coid:1445 moid:53 side:BUY exec_qty:0 leaves_qty:10 price:184]\n    ```", "```cpp\n    exchange_matching_engine.log:matching_engine.h:55 sendMarketUpdate() Thu Apr  6 12:26:47 2023 Sending MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]\n    ```", "```cpp\n    exchange_order_server.log:order_server.h:32 run() Thu Apr  6 12:26:47 2023 Processing cid:1 seq:1343 MEClientResponse [type:ACCEPTED client:1 ticker:0 coid:1445 moid:53 side:BUY exec_qty:0 leaves_qty:10 price:184]\n    ```", "```cpp\n    exchange_market_data_publisher.log:market_data_publisher.cpp:19 run() Thu Apr  6 12:26:47 2023 Sending seq:902 MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]\n    ```", "```cpp\n    exchange_snapshot_synthesizer.log:snapshot_synthesizer.cpp:107 run() Thu Apr  6 12:26:47 2023 Processing MDPMarketUpdate [ seq:902 MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]]\n    ```", "```cpp\n    exchange_snapshot_synthesizer.log:snapshot_synthesizer.cpp:88 publishSnapshot() Thu Apr  6 12:27:40 2023 MDPMarketUpdate [ seq:7 MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]]\n    ```", "```cpp\n    trading_order_gateway_5.log:order_gateway.cpp:37 recvCallback() Thu Apr  6 12:26:47 2023 Received OMClientResponse [seq:1343 MEClientResponse [type:ACCEPTED client:1 ticker:0 coid:1445 moid:53 side:BUY exec_qty:0 leaves_qty:10 price:184]]\n    ```", "```cpp\n    trading_market_data_consumer_5.log:market_data_consumer.cpp:177 recvCallback() Thu Apr  6 12:26:47 2023 Received incremental socket len:42 MDPMarketUpdate [ seq:902 MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]]\n    ```", "```cpp\n    trading_market_data_consumer_5.log:market_data_consumer.cpp:193 recvCallback() Thu Apr  6 12:26:47 2023 MDPMarketUpdate [ seq:902 MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]]\n    ```", "```cpp\n    trading_engine_5.log:trade_engine.cpp:44 run() Thu Apr  6 12:26:47 2023 Processing MEClientResponse [type:ACCEPTED client:1 ticker:0 coid:1445 moid:53 side:BUY exec_qty:0 leaves_qty:10 price:184]\n    ```", "```cpp\n    trading_engine_5.log:trade_engine.cpp:75 onOrderUpdate() Thu Apr  6 12:26:47 2023 MEClientResponse [type:ACCEPTED client:1 ticker:0 coid:1445 moid:53 side:BUY exec_qty:0 leaves_qty:10 price:184]\n    ```", "```cpp\n    trading_engine_5.log:trade_engine.cpp:52 run() Thu Apr  6 12:26:47 2023 Processing MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]\n    ```", "```cpp\n    trading_engine_5.log:trade_engine.cpp:64 onOrderBookUpdate() Thu Apr  6 12:26:47 2023 ticker:0 price:184 side:BUY\n    ```", "```cpp\n    trading_engine_1.log:feature_engine.h:23 onOrderBookUpdate() Thu May 11 16:10:45 2023 ticker:7 price:152 side:BUY mkt-price:152.394 agg-trade-ratio:0.0994475\n    ```", "```cpp\n    trading_engine_1.log:feature_engine.h:34 onTradeUpdate() Thu May 11 16:10:45 2023 MEMarketUpdate [ type:TRADE ticker:1 oid:INVALID side:SELL qty:50 price:170 priority:INVALID] mkt-price:170.071 agg-trade-ratio:1\n    ```", "```cpp\n    trading_engine_1.log:feature_engine.h:23 onOrderBookUpdate() Thu May 11 16:10:45 2023 ticker:2 price:119 side:SELL mkt-price:115.299 agg-trade-ratio:0.262712\n    ```", "```cpp\n    trading_engine_1.log:feature_engine.h:34 onTradeUpdate() Thu May 11 16:10:45 2023 MEMarketUpdate [ type:TRADE ticker:3 oid:INVALID side:BUY qty:18 price:180 priority:INVALID] mkt-price:115.299 agg-trade-ratio:0.00628931\n    ```", "```cpp\n    trading_engine_1.log:feature_engine.h:23 onOrderBookUpdate() Thu May 11 16:10:45 2023 ticker:3 price:180 side:SELL mkt-price:178.716 agg-trade-ratio:0.00628931\n    ```", "```cpp\n    trading_engine_1.log:feature_engine.h:34 onTradeUpdate() Thu May 11 16:10:45 2023 MEMarketUpdate [ type:TRADE ticker:3 oid:INVALID side:BUY qty:30 price:180 priority:INVALID] mkt-price:178.716 agg-trade-ratio:0.0105485\n    ```", "```cpp\n    trading_engine_1.log:position_keeper.h:75 addFill() Thu May 11 16:10:38 2023 Position{pos:476 u-pnl:-120.715 r-pnl:6248.71 t-pnl:6128 vol:8654 vwaps:[114.254X0] BBO{21@115X116@296}} MEClientResponse [type:FILLED client:1 ticker:2 coid:962 moid:1384 side:BUY exec_qty:25 leaves_qty:102 price:114]\n    ```", "```cpp\n    trading_engine_1.log:position_keeper.h:98 updateBBO() Thu May 11 16:10:42 2023 Position{pos:194 u-pnl:15.8965 r-pnl:311.103 t-pnl:327 vol:802 vwaps:[180.918X0] BBO{730@180X182@100}} BBO{730@180X182@100}\n    ```", "```cpp\n    trading_engine_1.log:position_keeper.h:75 addFill() Thu May 11 16:10:42 2023 Position{pos:392 u-pnl:688.98 r-pnl:6435.02 t-pnl:7124 vol:8782 vwaps:[114.242X0] BBO{44@114X116@150}} MEClientResponse [type:FILLED client:1 ticker:2 coid:970 moid:1394 side:SELL exec_qty:83 leaves_qty:44 price:116]\n    ```", "```cpp\n    trading_engine_1.log:position_keeper.h:98 updateBBO() Thu May 11 16:10:44 2023 Position{pos:373 u-pnl:282.585 r-pnl:6468.41 t-pnl:6751 vol:8801 vwaps:[114.242X0] BBO{19@114X116@131}} BBO{19@114X116@131}\n    ```", "```cpp\n    trading_engine_1.log:order_manager.h:69 moveOrder() Thu May 11 16:10:41 2023 Ticker:1 Side:BUY Qty:60 RiskCheckResult:POSITION_TOO_LARGE\n    ```", "```cpp\n    trading_engine_1.log:order_manager.h:69 moveOrder() Thu May 11 16:10:41 2023 Ticker:4 Side:SELL Qty:1000 RiskCheckResult:LOSS_TOO_LARGE\n    ```", "```cpp\n    trading_engine_1.log:order_manager.h:69 moveOrder() Thu May 11 16:10:42 2023 Ticker:2 Side:BUY Qty:150 RiskCheckResult:POSITION_TOO_LARGE\n    ```", "```cpp\n    trading_engine_1.log:order_manager.h:26 onOrderUpdate() Thu May 11 16:10:36 2023 OMOrder[tid:6 oid:965 side:SELL price:125 qty:15 state:PENDING_CANCEL]\n    ```", "```cpp\n    trading_engine_1.log:order_manager.cpp:13 newOrder() Thu May 11 16:10:37 2023 Sent new order MEClientRequest [type:NEW client:1 ticker:6 oid:966 side:SELL qty:50 price:126] for OMOrder[tid:6 oid:966 side:SELL price:126 qty:50 state:PENDING_NEW]\n    ```", "```cpp\n    trading_engine_1.log:order_manager.h:23 onOrderUpdate() Thu May 11 16:10:37 2023 MEClientResponse [type:ACCEPTED client:1 ticker:6 coid:966 moid:1806 side:SELL exec_qty:0 leaves_qty:50 price:126]\n    ```", "```cpp\n    trading_engine_1.log:order_manager.h:26 onOrderUpdate() Thu May 11 16:10:37 2023 OMOrder[tid:6 oid:966 side:SELL price:126 qty:50 state:PENDING_NEW]\n    ```", "```cpp\n    trading_engine_1.log:order_manager.cpp:26 cancelOrder() Thu May 11 16:10:37 2023 Sent cancel MEClientRequest [type:CANCEL client:1 ticker:1 oid:927 side:SELL qty:60 price:170] for OMOrder[tid:1 oid:927 side:SELL price:170 qty:60 state:PENDING_CANCEL]\n    ```", "```cpp\n    trading_engine_1.log:order_manager.h:23 onOrderUpdate() Thu May 11 16:10:37 2023 MEClientResponse [type:CANCELED client:1 ticker:1 coid:927 moid:1826 side:SELL exec_qty:INVALID leaves_qty:60 price:170]\n    ```", "```cpp\n    trading_engine_1.log:liquidity_taker.h:19 onOrderBookUpdate() Thu May 11 16:07:48 2023 ticker:4 price:183 side:SELL\n    ```", "```cpp\n    trading_engine_1.log:liquidity_taker.h:19 onOrderBookUpdate() Thu May 11 16:07:48 2023 ticker:7 price:153 side:BUY\n    ```", "```cpp\n    trading_engine_1.log:liquidity_taker.h:25 onTradeUpdate() Thu May 11 16:07:48 2023 MEMarketUpdate [ type:TRADE ticker:7 oid:INVALID side:SELL qty:90 price:154 priority:INVALID]\n    ```", "```cpp\n    trading_engine_1.log:liquidity_taker.h:32 onTradeUpdate() Thu May 11 16:07:48 2023 BBO{368@154X155@2095} agg-qty-ratio:0.244565\n    ```", "```cpp\n    trading_engine_1.log:liquidity_taker.h:19 onOrderBookUpdate() Thu May 11 16:07:48 2023 ticker:7 price:154 side:BUY\n    ```", "```cpp\n    trading_engine_1.log:liquidity_taker.h:49 onOrderUpdate() Thu May 11 16:07:48 2023 MEClientResponse [type:FILLED client:3 ticker:7 coid:202 moid:792 side:BUY exec_qty:90 leaves_qty:183 price:154]\n    ```", "```cpp\n    trading_engine_1.log:liquidity_taker.h:19 onOrderBookUpdate() Thu May 11 16:07:48 2023 ticker:0 price:180 side:BUY\n    ```", "```cpp\n    trading_engine_1.log:market_maker.h:47 onOrderUpdate() Thu May 11 16:06:12 2023 MEClientResponse [type:FILLED client:1 ticker:5 coid:418 moid:552 side:BUY exec_qty:62 leaves_qty:160 price:137]\n    ```", "```cpp\n    trading_engine_1.log:market_maker.h:42 onTradeUpdate() Thu May 11 16:06:12 2023 MEMarketUpdate [ type:TRADE ticker:3 oid:INVALID side:BUY qty:47 price:180 priority:INVALID]\n    ```", "```cpp\n    trading_engine_1.log:market_maker.h:19 onOrderBookUpdate() Thu May 11 16:06:12 2023 ticker:3 price:180 side:SELL\n    ```", "```cpp\n    trading_engine_1.log:market_maker.h:27 onOrderBookUpdate() Thu May 11 16:06:12 2023 BBO{2759@178X180@2409} fair-price:179.068\n    ```", "```cpp\n    trading_engine_1.log:market_maker.h:19 onOrderBookUpdate() Thu May 11 16:06:12 2023 ticker:0 price:183 side:SELL\n    ```", "```cpp\n    trading_engine_1.log:market_maker.h:27 onOrderBookUpdate() Thu May 11 16:06:12 2023 BBO{4395@181X182@534} fair-price:181.892\n    ```", "```cpp\n    trading_engine_1.log:market_maker.h:42 onTradeUpdate() Thu May 11 16:06:12 2023 MEMarketUpdate [ type:TRADE ticker:5 oid:INVALID side:SELL qty:62 price:137 priority:INVALID]\n    ```", "```cpp\n    trading_engine_1.log:market_maker.h:19 onOrderBookUpdate() Thu May 11 16:06:12 2023 ticker:5 price:137 side:BUY\n    ```"]