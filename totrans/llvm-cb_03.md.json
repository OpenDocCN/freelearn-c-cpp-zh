["```cpp\nif x < 2 then\nx + y\nelse\nx - y\n```", "```cpp\nstatic void init_precedence() {\n  Operator_Precedence['<'] = 0;\n  …\n  …\n}\n```", "```cpp\nValue* BinaryAST::Codegen() {\n…\n…\n…\ncase '<' :\nL = Builder.CreateICmpULT(L, R, \"cmptmp\");\nreturn Builder.CreateZExt(L, Type::getInt32Ty(getGlobalContext()),\n                                \"booltmp\");…\n…\n}\n```", "```cpp\n    enum Token_Type{\n    …\n    …\n    IF_TOKEN,\n    THEN_TOKEN,\n    ELSE_TOKEN\n    }\n    ```", "```cpp\n    static int get_token() {\n    …\n    …\n    …\n    if (Identifier_string == \"def\")  return DEF_TOKEN;\n    if(Identifier_string == \"if\") return IF_TOKEN;\n    if(Identifier_string == \"then\") return THEN_TOKEN;\n    if(Identifier_string == \"else\") return ELSE_TOKEN;\n    …\n    …\n    }\n    ```", "```cpp\n    class ExprIfAST : public BaseAST {\n      BaseAST *Cond, *Then, *Else;\n\n    public:\n      ExprIfAST(BaseAST *cond, BaseAST *then, BaseAST * else_st)\n          : Cond(cond), Then(then), Else(else_st) {}\n      Value *Codegen() override;\n    };\n    ```", "```cpp\n    static BaseAST *If_parser() {\n      next_token();\n\n      BaseAST *Cond = expression_parser();\n      if (!Cond)\n        return 0;\n\n      if (Current_token != THEN_TOKEN)\n        return 0;\n      next_token();\n\n      BaseAST *Then = expression_parser();\n      if (Then == 0)\n        return 0;\n\n      if (Current_token != ELSE_TOKEN)\n        return 0;\n\n      next_token();\n\n      BaseAST *Else = expression_parser();\n      if (!Else)\n        return 0;\n\n      return new ExprIfAST(Cond, Then, Else);\n    }\n    ```", "```cpp\n    static BaseAST* Base_Parser() {\n    switch(Current_token) {\n    …\n    …\n    …\n    case IF_TOKEN : return If_parser();\n    …\n    }\n    ```", "```cpp\n    Value *ExprIfAST::Codegen() {\n      Value *Condtn = Cond->Codegen();\n      if (Condtn == 0)\n        return 0;\n\n      Condtn = Builder.CreateICmpNE(\n          Condtn, Builder.getInt32(0), \"ifcond\");\n\n      Function *TheFunc = Builder.GetInsertBlock()->getParent();\n\n      BasicBlock *ThenBB =\n          BasicBlock::Create(getGlobalContext(), \"then\", TheFunc);\n      BasicBlock *ElseBB = BasicBlock::Create(getGlobalContext(), \"else\");\n      BasicBlock *MergeBB = BasicBlock::Create(getGlobalContext(), \"ifcont\");\n\n      Builder.CreateCondBr(Condtn, ThenBB, ElseBB);\n\n      Builder.SetInsertPoint(ThenBB);\n\n      Value *ThenVal = Then->Codegen();\n      if (ThenVal == 0)\n        return 0;\n\n      Builder.CreateBr(MergeBB);\n      ThenBB = Builder.GetInsertBlock();\n\n      TheFunc->getBasicBlockList().push_back(ElseBB);\n      Builder.SetInsertPoint(ElseBB);\n\n      Value *ElseVal = Else->Codegen();\n      if (ElseVal == 0)\n        return 0;\n\n      Builder.CreateBr(MergeBB);\n      ElseBB = Builder.GetInsertBlock();\n\n      TheFunc->getBasicBlockList().push_back(MergeBB);\n      Builder.SetInsertPoint(MergeBB);\n      PHINode *Phi = Builder.CreatePHI(Type::getInt32Ty(getGlobalContext()), 2, \"iftmp\");\n\n      Phi->addIncoming(ThenVal, ThenBB);\n      Phi->addIncoming(ElseVal, ElseBB);\n      return Phi;\n    }\n    ```", "```cpp\n    $ g++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core ` -O3 -o toy\n\n    ```", "```cpp\n    $ vi example\n\n    ```", "```cpp\n    def fib(x)\n      if x < 3 then\n        1\n      Else\n        fib(x-1)+fib(x-2);\n    ```", "```cpp\n    $ ./toy example\n\n    ```", "```cpp\n; ModuleID = 'my compiler'\ntarget datalayout = \"e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128\"\n\ndefine i32 @fib(i32 %x) {\nentry:\n  %cmptmp = icmp ult i32 %x, 3\n  br i1 %cmptmp, label %ifcont, label %else\n\nelse:                                             ; preds = %entry\n  %subtmp = add i32 %x, -1\n  %calltmp = call i32 @fib(i32 %subtmp)\n  %subtmp1 = add i32 %x, -2\n  %calltmp2 = call i32 @fib(i32 %subtmp1)\n  %addtmp = add i32 %calltmp2, %calltmp\n  br label %ifcont\n\nifcont:                                           ; preds = %entry, %else\n  %iftmp = phi i32 [ %addtmp, %else ], [ 1, %entry ]\n  ret i32 %iftmp\n}\n```", "```cpp\nfor i = 1, i < n, 1 in\n     x + y;\n```", "```cpp\n%i = phi i32 [ 1, %entry ], [ %nextvar, %loop ]\n```", "```cpp\n    enum Token_Type {\n      …\n      …\n      FOR_TOKEN,\n      IN_TOKEN\n      …\n      …\n    };\n    ```", "```cpp\n    static int get_token() {\n      …\n      …\n    if (Identifier_string == \"else\")\n          return ELSE_TOKEN;\n        if (Identifier_string == \"for\")\n          return FOR_TOKEN;\n        if (Identifier_string == \"in\")\n          return IN_TOKEN;\n      …\n      …\n    }\n    ```", "```cpp\n    class ExprForAST  : public BaseAST {\n      std::string Var_Name;\n      BaseAST *Start, *End, *Step, *Body;\n\n    public:\n      ExprForAST (const std::string &varname, BaseAST *start, BaseAST *end,\n                 BaseAST *step, BaseAST *body)\n          : Var_Name(varname), Start(start), End(end), Step(step), Body(body) {}\n      Value *Codegen() override;\n    };\n    ```", "```cpp\n    static BaseAST *For_parser() {\n      next_token();\n\n      if (Current_token != IDENTIFIER_TOKEN)\n        return 0;\n\n      std::string IdName = Identifier_string;\n      next_token();\n\n      if (Current_token != '=')\n        return 0;\n      next_token();\n\n      BaseAST *Start = expression_parser();\n      if (Start == 0)\n        return 0;\n      if (Current_token != ',')\n        return 0;\n      next_token();\n\n      BaseAST *End = expression_parser();\n      if (End == 0)\n        return 0;\n\n      BaseAST *Step = 0;\n      if (Current_token == ',') {\n        next_token();\n        Step = expression_parser();\n        if (Step == 0)\n          return 0;\n      }\n\n      if (Current_token != IN_TOKEN)\n        return 0;\n      next_token();\n\n      BaseAST *Body = expression_parser();\n      if (Body == 0)\n        return 0;\n\n      return new ExprForAST (IdName, Start, End, Step, Body);\n    }\n    ```", "```cpp\n    Value *ExprForAST::Codegen() {\n\n      Value *StartVal = Start->Codegen();\n      if (StartVal == 0)\n        return 0;\n\n      Function *TheFunction = Builder.GetInsertBlock()->getParent();\n      BasicBlock *PreheaderBB = Builder.GetInsertBlock();\n      BasicBlock *LoopBB =\n          BasicBlock::Create(getGlobalContext(), \"loop\", TheFunction);\n\n      Builder.CreateBr(LoopBB);\n\n      Builder.SetInsertPoint(LoopBB);\n\n      PHINode *Variable = Builder.CreatePHI(Type::getInt32Ty(getGlobalContext()), 2, Var_Name.c_str());\n      Variable->addIncoming(StartVal, PreheaderBB);\n\n      Value *OldVal = Named_Values[Var_Name];\n      Named_Values[Var_Name] = Variable;\n\n      if (Body->Codegen() == 0)\n        return 0;\n\n      Value *StepVal;\n      if (Step) {\n        StepVal = Step->Codegen();\n        if (StepVal == 0)\n          return 0;\n      } else {\n        StepVal = ConstantInt::get(Type::getInt32Ty(getGlobalContext()), 1);\n      }\n\n      Value *NextVar = Builder.CreateAdd(Variable, StepVal, \"nextvar\");\n\n      Value *EndCond = End->Codegen();\n      if (EndCond == 0)\n        return EndCond;\n\n      EndCond = Builder.CreateICmpNE(\n          EndCond, ConstantInt::get(Type::getInt32Ty(getGlobalContext()), 0), \"loopcond\");\n\n      BasicBlock *LoopEndBB = Builder.GetInsertBlock();\n      BasicBlock *AfterBB =\n          BasicBlock::Create(getGlobalContext(), \"afterloop\", TheFunction);\n\n      Builder.CreateCondBr(EndCond, LoopBB, AfterBB);\n\n      Builder.SetInsertPoint(AfterBB);\n\n      Variable->addIncoming(NextVar, LoopEndBB);\n\n      if (OldVal)\n        Named_Values[Var_Name] = OldVal;\n      else\n        Named_Values.erase(Var_Name);\n\n      return Constant::getNullValue(Type::getInt32Ty(getGlobalContext()));\n    }\n    ```", "```cpp\n    $ g++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core ` -O3 -o toy\n\n    ```", "```cpp\n    $ vi example\n\n    ```", "```cpp\n    def printstar(n x)\n      for i = 1, i < n, 1.0 in\n        x + 1\n    ```", "```cpp\n    $ ./toy example\n\n    ```", "```cpp\n    ; ModuleID = 'my compiler'\n    target datalayout = \"e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128\"\n\n    define i32 @printstar(i32 %n, i32 %x) {\n    entry:\n      br label %loop\n\n    loop:                                             ; preds = %loop, %entry\n      %i = phi i32 [ 1, %entry ], [ %nextvar, %loop ]\n      %nextvar = add i32 %i, 1\n      %cmptmp = icmp ult i32 %i, %n\n      br i1 %cmptmp, label %loop, label %afterloop\n\n    afterloop:                                        ; preds = %loop\n      ret i32 0\n    }\n    ```", "```cpp\ndef binary | (LHS RHS)\nif LHS then\n1\nelse if RHS then\n1\nelse\n0;\n```", "```cpp\n     enum Token_Type {\n    …\n    …\n    BINARY_TOKEN\n    }\n    static int get_token() {\n    …\n    …\n    if (Identifier_string == \"in\") return IN_TOKEN;\n    if (Identifier_string == \"binary\") return BINARY_TOKEN;\n    …\n    …\n    }\n    ```", "```cpp\n    class FunctionDeclAST {\n      std::string Func_Name;\n      std::vector<std::string> Arguments;\n      bool isOperator;\n      unsigned Precedence;\n    public:\n      FunctionDeclAST(const std::string &name, const std::vector<std::string> &args,\n                   bool isoperator = false, unsigned prec = 0)\n          : Func_Name(name), Arguments(args), isOperator(isoperator), Precedence(prec) {}\n\n      bool isUnaryOp() const { return isOperator && Arguments.size() == 1; }\n      bool isBinaryOp() const { return isOperator && Arguments.size() == 2; }\n\n      char getOperatorName() const {\n        assert(isUnaryOp() || isBinaryOp());\n        return Func_Name[Func_Name.size() - 1];\n      }\n\n      unsigned getBinaryPrecedence() const { return Precedence; }\n\n      Function *Codegen();\n    };\n    ```", "```cpp\n    static FunctionDeclAST *func_decl_parser() {\n      std::string FnName;\n\n      unsigned Kind = 0;\n      unsigned BinaryPrecedence = 30;\n\n      switch (Current_token) {\n      default:\n        return 0;\n      case IDENTIFIER_TOKEN:\n        FnName = Identifier_string;\n        Kind = 0;\n        next_token();\n        break;\n      case UNARY_TOKEN:\n        next_token();\n        if (!isascii(Current_token))\n          return 0;\n        FnName = \"unary\";\n        FnName += (char)Current_token;\n        Kind = 1;\n        next_token();\n        break;\n      case BINARY_TOKEN:\n        next_token();\n        if (!isascii(Current_token))\n          return 0;\n        FnName = \"binary\";\n        FnName += (char)Current_token;\n        Kind = 2;\n        next_token();\n\n        if (Current_token == NUMERIC_TOKEN) {\n          if (Numeric_Val < 1 || Numeric_Val > 100)\n            return 0;\n          BinaryPrecedence = (unsigned)Numeric_Val;\n          next_token();\n        }\n        break;\n      }\n\n      if (Current_token != '(')\n        return 0;\n\n      std::vector<std::string> Function_Argument_Names;\n      while (next_token() == IDENTIFIER_TOKEN)\n        Function_Argument_Names.push_back(Identifier_string);\n      if (Current_token != ')')\n        return 0;\n\n      next_token();\n\n      if (Kind && Function_Argument_Names.size() != Kind)\n        return 0;\n\n      return new FunctionDeclAST(FnName, Function_Argument_Names, Kind != 0, BinaryPrecedence);\n    }\n    ```", "```cpp\n    Value* BinaryAST::Codegen() {\n     Value* L = LHS->Codegen();\n    Value* R = RHS->Codegen();\n    switch(Bin_Operator) {\n    case '+' : return Builder.CreateAdd(L, R, \"addtmp\");\n    case '-' : return Builder.CreateSub(L, R, \"subtmp\");\n    case '*': return Builder.CreateMul(L, R, \"multmp\");\n    case '/': return Builder.CreateUDiv(L, R, \"divtmp\");\n    case '<' :\n    L = Builder.CreateICmpULT(L, R, \"cmptmp\");\n    return Builder.CreateUIToFP(L, Type::getIntTy(getGlobalContext()), \"booltmp\");\n    default :\n    break;\n    }\n    Function *F = TheModule->getFunction(std::string(\"binary\")+Op);\n      Value *Ops[2] = { L, R };\n      return Builder.CreateCall(F, Ops, \"binop\");\n    }\n    ```", "```cpp\n    Function* FunctionDefnAST::Codegen() {\n    Named_Values.clear();\n    Function *TheFunction = Func_Decl->Codegen();\n    if (!TheFunction) return 0;\n    if (Func_Decl->isBinaryOp())\n        Operator_Precedence [Func_Decl->getOperatorName()] = Func_Decl->getBinaryPrecedence();\n    BasicBlock *BB = BasicBlock::Create(getGlobalContext(), \"entry\", TheFunction);\n    Builder.SetInsertPoint(BB);\n    if (Value* Return_Value = Body->Codegen()) {\n        Builder.CreateRet(Return_Value);\n    …\n    …\n    ```", "```cpp\n    $ g++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core ` -O3 -o toy\n\n    ```", "```cpp\n    $ vi example\n\n    ```", "```cpp\n    def binary| 5 (LHS RHS)\n      if LHS then\n        1\n      else if RHS then\n        1\n      else\n        0;\n    ```", "```cpp\n    $ ./toy example\n\n    output :\n\n    ; ModuleID = 'my compiler'\n    target datalayout = \"e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128\"\n\n    define i32 @\"binary|\"(i32 %LHS, i32 %RHS) {\n    entry:\n     %ifcond = icmp eq i32 %LHS, 0\n     %ifcond1 = icmp eq i32 %RHS, 0\n     %. = select i1 %ifcond1, i32 0, i32 1\n     %iftmp5 = select i1 %ifcond, i32 %., i32 1\n     ret i32 %iftmp5\n    }\n\n    ```", "```cpp\ndef unary!(v)\n  if v then\n    0\n  else\n    1;\n```", "```cpp\n    enum Token_Type {\n    …\n    …\n    BINARY_TOKEN,\n    UNARY_TOKEN\n    }\n    ```", "```cpp\n    static int get_token() {\n    …\n    …\n    if (Identifier_string == \"in\") return IN_TOKEN;\n    if (Identifier_string == \"binary\") return BINARY_TOKEN;\n    if (Identifier_string == \"unary\") return UNARY_TOKEN;\n\n    …\n    …\n    }\n    ```", "```cpp\n    class ExprUnaryAST : public BaseAST {\n      char Opcode;\n      BaseAST *Operand;\n    public:\n      ExprUnaryAST(char opcode, BaseAST *operand)\n        : Opcode(opcode), Operand(operand) {}\n      virtual Value *Codegen();\n    };\n    ```", "```cpp\n    static BaseAST *unary_parser() {\n\n      if (!isascii(Current_token) || Current_token == '(' || Current_token == ',')\n        return Base_Parser();\n\n        int Op = Current_token;\n\n      next_token();\n\n      if (ExprAST *Operand = unary_parser())\n        return new ExprUnaryAST(Opc, Operand);\n\n    return 0;\n    }\n    ```", "```cpp\n    static BaseAST *binary_op_parser(int Old_Prec, BaseAST *LHS) {\n\n      while (1) {\n        int Operator_Prec = getBinOpPrecedence();\n\n        if (Operator_Prec < Old_Prec)\n          return LHS;\n\n        int BinOp = Current_token;\n        next_token();\n\n        BaseAST *RHS = unary_parser();\n        if (!RHS)\n          return 0;\n\n        int Next_Prec = getBinOpPrecedence();\n        if (Operator_Prec < Next_Prec) {\n          RHS = binary_op_parser(Operator_Prec + 1, RHS);\n          if (RHS == 0)\n            return 0;\n        }\n\n        LHS = new BinaryAST(std::to_string(BinOp), LHS, RHS);\n      }\n    }\n    ```", "```cpp\n    static BaseAST *expression_parser() {\n      BaseAST *LHS = unary_parser();\n      if (!LHS)\n        return 0;\n\n      return binary_op_parser(0, LHS);\n    }\n    ```", "```cpp\n    static FunctionDeclAST* func_decl_parser() {\n    std::string Function_Name = Identifier_string;\n    unsigned Kind = 0;\n    unsigned BinaryPrecedence = 30;\n    switch (Current_token) {\n      default:\n        return 0;\n      case IDENTIFIER_TOKEN:\n        Function_Name = Identifier_string;\n        Kind = 0;\n        next_token();\n        break;\n      case UNARY_TOKEN:\n      next_token();\n    if (!isascii(Current_token))\n          return0;\n        Function_Name = \"unary\";\n        Function_Name += (char)Current_token;\n        Kind = 1;\n        next_token();\n        break;\n      case BINARY_TOKEN:\n        next_token();\n        if (!isascii(Current_token))\n          return 0;\n        Function_Name = \"binary\";\n        Function_Name += (char)Current_token;\n        Kind = 2;\n       next_token();\n       if (Current_token == NUMERIC_TOKEN) {\n          if (Numeric_Val < 1 || Numeric_Val > 100)\n            return 0;\n          BinaryPrecedence = (unsigned)Numeric_Val;\n          next_token();\n        }\n        break;\n      }\n    if (Current_token ! = '(') {\n    printf(\"error in function declaration\");\n    return 0;\n    }\n    std::vector<std::string> Function_Argument_Names;\n    while(next_token() == IDENTIFIER_TOKEN) Function_Argument_Names.push_back(Identifier_string);\n    if(Current_token != ')')  {                      printf(\"Expected ')' \");                      return 0;\n    }\n    next_token();\n    if (Kind && Function_Argument_Names.size() != Kind)\n        return 0;\n    return new FunctionDeclAST(Function_Name, Function_Arguments_Names, Kind !=0, BinaryPrecedence);\n    }\n    ```", "```cpp\n    Value *ExprUnaryAST::Codegen() {\n\n      Value *OperandV = Operand->Codegen();\n\n      if (OperandV == 0) return 0;\n\n      Function *F = TheModule->getFunction(std::string(\"unary\")+Opcode);\n\n      if (F == 0)\n        return 0;\n\n      return Builder.CreateCall(F, OperandV, \"unop\");\n    }\n    ```", "```cpp\n    $ g++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core ` -O3 -o toy\n\n    ```", "```cpp\n    $ vi example\n\n    ```", "```cpp\n    def unary!(v)\n      if v then\n        0\n      else\n        1;\n    ```", "```cpp\n    $ ./toy example\n\n    ```", "```cpp\n    ; ModuleID = 'my compiler'\n    target datalayout = \"e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128\"\n\n    define i32 @\"unary!\"(i32 %v) {\n    entry:\n     %ifcond = icmp eq i32 %v, 0\n     %. = select i1 %ifcond, i32 1, i32 0\n     ret i32 %.\n    }\n\n    ```", "```cpp\n    static ExecutionEngine *TheExecutionEngine;\n    ```", "```cpp\n    int main() {\n    …\n    …\n    init_precedence();\n    TheExecutionEngine = EngineBuilder(TheModule).create();\n    …\n    …\n    }\n    ```", "```cpp\n    static void HandleTopExpression() {\n\n    if (FunctionDefAST *F = expression_parser())\n       if (Function *LF = F->Codegen()) {\n            LF -> dump();\n           void *FPtr = TheExecutionEngine->getPointerToFunction(LF);\n          int (*Int)() = (int (*)())(intptr_t)FPtr;\n\n        printf(\"Evaluated to %d\\n\", Int());\n    }\n       else\n    next_token();\n    }\n    ```", "```cpp\n    $ g++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native` -O3 -o toy\n\n    ```", "```cpp\n    $ vi example\n\n    ```", "```cpp\n    …\n    4+5;\n    ```", "```cpp\n    $ ./toy example\n    The output will be\n    define i32 @0() {\n    entry:\n     ret i32 9\n    }\n\n    ```"]