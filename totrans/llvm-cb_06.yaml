- en: Chapter 6. Target-independent Code Generator
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章：目标无关代码生成器
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: The life of an LLVM IR instruction
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM IR 指令的生命周期
- en: Visualizing the LLVM IR CFG using GraphViz
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GraphViz 可视化 LLVM IR CFG
- en: Describing the target using TableGen
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TableGen 描述目标
- en: Defining an instruction set
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义指令集
- en: Adding a machine code descriptor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加机器代码描述符
- en: Implementing the MachineInstrBuilder class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 MachineInstrBuilder 类
- en: Implementing the MachineBasicBlock class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 MachineBasicBlock 类
- en: Implementing the MachineFunction class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 MachineFunction 类
- en: Writing an instruction selector
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写指令选择器
- en: Legalizing SelectionDAG
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合法化 SelectionDAG
- en: Optimizing SelectionDAG
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化 SelectionDAG
- en: Selecting instructions from the DAG
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 DAG 中选择指令
- en: Scheduling instructions in SelectionDAG
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 SelectionDAG 中调度指令
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: After optimizing the LLVM IR, it needs to be converted into machine instructions
    for execution. The machine-independent code generator interface gives an abstract
    layer that helps convert IR into machine instructions. In this phase, the IR is
    converted into SelectionDAG (**DAG** stands for **Directed Acyclic Graph**). Various
    phases work on the nodes of SelectionDAG. This chapter describes the important
    phases in target-independent code generation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化 LLVM IR 之后，需要将其转换为执行所需的机器指令。机器无关的代码生成器接口提供了一个抽象层，帮助将 IR 转换为机器指令。在这个阶段，IR
    转换为 SelectionDAG（**DAG** 代表 **有向无环图**）。各种阶段在 SelectionDAG 的节点上工作。本章描述了目标无关代码生成中的重要阶段。
- en: The life of an LLVM IR instruction
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LLVM IR 指令的生命周期
- en: In previous chapters, we saw how high-level language instructions, statements,
    logical blocks, function calls, loops, and so on get transformed into the LLVM
    IR. Various optimization passes then process the IR to make it more optimal. The
    IR generated is in the SSA form and, in abstract format, almost independent of
    any high- or low-level language constraints, which facilitates optimization passes
    running on it. There might be some optimizations that are target-specific and
    take place later, when the IR gets converted into machine instructions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了高级语言指令、语句、逻辑块、函数调用、循环等如何被转换成 LLVM IR。然后，各种优化过程处理 IR 以使其更优化。生成的
    IR 是 SSA 形式，在抽象格式上几乎独立于任何高级或低级语言约束，这有助于优化过程在其上运行。可能存在一些特定于目标的优化，它们在 IR 转换为机器指令时发生。
- en: 'After we get an optimal LLVM IR, the next phase is to convert it into target-machine-specific
    instructions. LLVM uses the SelectionDAG approach to convert the IR into machine
    instructions. The Linear IR is converted into SelectionDAG, a DAG that represents
    instructions as nodes. The SDAG then goes through various phases:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们得到最优的 LLVM IR 之后，下一个阶段是将它转换为特定于目标机的指令。LLVM 使用 SelectionDAG 方法将 IR 转换为机器指令。线性
    IR 转换为 SelectionDAG，一个表示指令为节点的 DAG。SDAG 然后经过各种阶段：
- en: The SelectionDAG is created out of LLVM IR
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SelectionDAG 是由 LLVM IR 创建的
- en: Legalizing SDAG nodes
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合法化 SDAG 节点
- en: DAG combine optimization
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DAG 合并优化
- en: Instruction selection from the target instruction
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从目标指令中选择指令
- en: Scheduling and emitting a machine instruction
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度和生成机器指令
- en: Register allocation—SSA destruction, register assignment, and register spilling
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器分配——SSA 摧毁、寄存器分配和寄存器溢出
- en: Emitting code
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成代码
- en: All the preceding stages are modularized in LLVM.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前一个阶段在 LLVM 中都是模块化的。
- en: C Code to LLVM IR
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C 代码到 LLVM IR
- en: 'The first step is to convert the front end language example to LLVM IR. Let''s
    take an example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将前端语言示例转换为 LLVM IR。让我们举一个例子：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Its LLVM IR will be as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 其 LLVM IR 将如下所示：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: IR optimization
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IR 优化
- en: The IR then goes through various optimization passes, as described in previous
    chapters. The IR, in the transformation phase, goes through the `InstCombiner::visitSDiv()`
    function in the `InstCombine` pass. In that function, it also goes through the
    `SimplifySDivInst()` function and tries to check whether an opportunity exists
    to further simplify the instruction.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 IR 经过各种优化过程，如前几章所述。在转换阶段，IR 经过 `InstCombiner::visitSDiv()` 函数在 `InstCombine`
    过程中。在该函数中，它还经过 `SimplifySDivInst()` 函数，并尝试检查是否存在进一步简化指令的机会。
- en: LLVM IR to SelectionDAG
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LLVM IR 到 SelectionDAG
- en: After the IR transformations and optimizations are over, the LLVM IR instruction
    passes through a **Selection DAG node** incarnation. Selection DAG nodes are created
    by the `SelectionDAGBuilder` class. The `SelectionDAGBuilder::visit()` function
    call from the `SelectionDAGISel` class visits each IR instruction for creating
    an `SDAGNode` node. The method that handles an `SDiv` instruction is `SelectionDAGBuilder::visitSDiv`.
    It requests a new `SDNode` node from the DAG with the`ISD::SDIV` opcode, which
    then becomes a node in the DAG.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在IR转换和优化完成后，LLVM IR指令通过一个**选择DAG节点**阶段。选择DAG节点由`SelectionDAGBuilder`类创建。`SelectionDAGISel`类中的`SelectionDAGBuilder::visit()`函数调用遍历每个IR指令以创建一个`SDAGNode`节点。处理`SDiv`指令的方法是`SelectionDAGBuilder::visitSDiv`。它从DAG请求一个新的`SDNode`节点，具有`ISD::SDIV`操作码，然后成为DAG中的一个节点。
- en: SelectionDAG legalization
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择DAG合法化
- en: The `SelectionDAG` node created may not be supported by the target architecture.
    In the initial phase of Selection DAG, these unsupported nodes are called *illegal*.
    Before the `SelectionDAG` machinery actually emits machine instructions from the
    DAG nodes, these undergo a few other transformations, legalization being one of
    the important phases.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的`SelectionDAG`节点可能不被目标架构支持。在Selection DAG的初始阶段，这些不支持的节点被称为*非法*。在实际从DAG节点发出机器指令之前，这些节点会经历几个其他转换，合法化是其中重要阶段之一。
- en: The legalization of `SDNode` involves type and operation legalization. The target-specific
    information is conveyed to the target-independent algorithms via an interface
    called `TargetLowering`. This interface is implemented by the target and, describes
    how LLVM IR instructions should be lowered to legal `SelectionDAG` operations.
    For instance, x86 lowering is implemented in the `X86TargetLowering` interface.
    The `setOperationAction()` function specifies whether the ISD node needs to be
    expanded or customized by operation legalization. When `SelectionDAGLegalize::LegalizeOp`
    sees the expand flag, it replaces the `SDNode` node with the parameter specified
    in the `setOperationAction()` call.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`SDNode`的合法化涉及类型和操作的合法化。目标特定的信息通过一个名为`TargetLowering`的接口传递给目标无关的算法。这个接口由目标实现，并描述了LLVM
    IR指令应该如何降低到合法的`SelectionDAG`操作。例如，x86降低是通过`X86TargetLowering`接口实现的。`setOperationAction()`函数指定ISD节点是否需要通过操作合法化进行展开或定制。当`SelectionDAGLegalize::LegalizeOp`看到展开标志时，它将`SDNode`节点替换为`setOperationAction()`调用中指定的参数。'
- en: Conversion from target-independent DAG to machine DAG
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从目标无关的DAG转换为机器DAG
- en: Now that we have legalized the instruction, `SDNode` should be converted to
    `MachineSDNode`. The machine instructions are described in a generic table-based
    fashion in the target description `.td` files. Using `tablegen`, these files are
    then converted into `.inc` files that have registers/instructions as enums to
    refer to in the C++ code. Instructions can be selected by an automated selector,
    `SelectCode`, or they can be handled specifically by writing a customized `Select`
    function in the `SelectionDAGISel` class. The DAG node created at this step is
    a `MachineSDNode` node, a subclass of `SDNode` that holds the information required
    to construct an actual machine instruction but is still in the DAG node form.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经合法化了指令，`SDNode`应该转换为`MachineSDNode`。机器指令在目标描述`.td`文件中以通用的基于表的格式描述。使用`tablegen`，这些文件随后被转换为具有寄存器/指令枚举的`.inc`文件，以便在C++代码中引用。指令可以通过自动选择器`SelectCode`选择，或者可以通过在`SelectionDAGISel`类中编写定制的`Select`函数来专门处理。在此步骤中创建的DAG节点是一个`MachineSDNode`节点，它是`SDNode`的子类，它包含构建实际机器指令所需的信息，但仍然以DAG节点形式存在。
- en: Scheduling instructions
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调度说明
- en: A machine executes a linear set of instructions. So far, we have had machine
    instructions that are still in the DAG form. To convert a DAG into a linear set
    of instructions, a topological sort of the DAG can yield the instructions in linear
    order. However, the linear set of instructions generated might not result in the
    most optimized code, and may cause execution delays due to dependencies among
    instructions, register pressure, and pipeline stalling issues. Therein comes the
    concept of scheduling instructions. Since each target has its own set of registers
    and customized pipelining of the instructions, each target has its own hook for
    scheduling and calculating heuristics to produce optimized, faster code. After
    calculating the best possible way to arrange instructions, the scheduler emits
    the machine instructions in the machine basic block, and finally destroys the
    DAG.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一台机器执行一系列线性指令。到目前为止，我们仍然有以DAG（有向无环图）形式存在的机器指令。要将DAG转换为线性指令集，可以通过对DAG进行拓扑排序来得到线性顺序的指令。然而，生成的线性指令集可能不会产生最优化代码，并且由于指令之间的依赖性、寄存器压力和流水线停滞问题，可能会导致执行延迟。因此，出现了指令调度的概念。由于每个目标都有自己的寄存器集和指令的定制流水线，每个目标都有自己的调度钩子和计算启发式算法来生成优化、更快的代码。在计算最佳指令排列方式后，调度器将机器指令输出到机器基本块中，并最终销毁DAG。
- en: Register allocation
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寄存器分配
- en: The registers allocated are virtual registers after the machine instructions
    are emitted. Practically, an infinite number of virtual registers can be allocated,
    but the actual target has a limited number of registers. These limited registers
    need to be allocated efficiently. If this is not done, some registers have to
    be spilled onto the memory, and this may result in redundant load/store operations.
    This will also result in wastage of CPU cycles, slowing down the execution as
    well as increasing the memory footprint.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在发射机器指令之后，分配的寄存器是虚拟寄存器。实际上，可以分配无限数量的虚拟寄存器，但实际的目标具有有限的寄存器数量。这些有限的寄存器需要有效地分配。如果没有这样做，一些寄存器必须溢出到内存中，这可能会导致冗余的加载/存储操作。这也会导致CPU周期的浪费，从而减慢执行速度并增加内存占用。
- en: There are various register allocation algorithms. An important analysis is done
    when allocating registers—liveness of variables and live interval analysis. If
    two variables live in the same interval (that is, if there exists an interval
    interference), then they cannot be allocated the same register. An interference
    graph is created by analyzing liveness, and a graph coloring algorithm can be
    used to allocate the registers. This algorithm, however, takes quadratic time
    to run. Hence, it may result in longer compilation time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着各种寄存器分配算法。在分配寄存器时进行的一个重要分析是变量的存活性和存活区间分析。如果两个变量在同一个区间内存活（即存在区间干扰），则它们不能分配到同一个寄存器。通过分析存活性创建一个干扰图，可以使用图着色算法来分配寄存器。然而，这个算法的运行时间是二次的。因此，它可能会导致编译时间更长。
- en: LLVM employs a greedy approach for register allocation, where variables that
    have large live ranges are allocated registers first. Small ranges fit into the
    gaps of registers available, resulting in less spill weight. Spilling is a load-store
    operation that occurs because no registers are available to be allocated. Spill
    weight is the cost of operations involved in the spilling. Sometimes, live range
    splitting also takes place to accommodate variables into the registers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM在寄存器分配上采用贪婪算法，首先为具有大存活范围的变量分配寄存器。小范围适合填充可用的寄存器间隙，从而减少溢出重量。溢出是一种由于没有可分配的寄存器而发生的加载/存储操作。溢出重量是涉及溢出操作的成本。有时，为了将变量放入寄存器，还会进行存活范围分割。
- en: Note that the instructions are in the SSA form before register allocation. Now,
    the SSA form cannot exist in the real world because of the limited number of registers
    available. In some types of architecture, some instructions require fixed registers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在寄存器分配之前，指令处于SSA（单赋值）形式。然而，由于可用的寄存器数量有限，SSA形式在现实世界中无法存在。在某些类型的架构中，某些指令需要固定的寄存器。
- en: Code emission
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码发射
- en: Now that the original high-level code has been translated into machine instructions,
    the next step is to emit the code. LLVM does this in two ways; the first is JIT,
    which directly emits the code to the memory. The second way is by using the MC
    framework to emit assembly and object files for all backend targets.The `LLVMTargetMachine::addPassesToEmitFile`
    function is responsible for defining the sequence of actions required to emit
    an object file. The actual MI-to-MCInst translation is done in the `EmitInstruction`
    function of the `AsmPrinter` interface. The static compiler tool, llc, generates
    assembly instructions for a target. Object file (or assembly code) emission is
    done by implementing the `MCStreamer` interface.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在原始的高级代码已经被翻译成机器指令，下一步是生成代码。LLVM 以两种方式完成此操作；第一种是 JIT，它直接将代码输出到内存。第二种方式是通过使用
    MC 框架为所有后端目标生成汇编和目标文件。《LLVMTargetMachine::addPassesToEmitFile》函数负责定义生成对象文件所需的操作序列。实际的
    MI 到 MCInst 转换是在 `AsmPrinter` 接口的 `EmitInstruction` 函数中完成的。静态编译器工具 llc 为目标生成汇编指令。通过实现
    `MCStreamer` 接口来完成对象文件（或汇编代码）的生成。
- en: Visualizing LLVM IR CFG using GraphViz
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GraphViz 可视化 LLVM IR CFG
- en: The LLVM IR control flow graph can be visualized using the **GraphViz** tool.
    It gives a visual depiction of the nodes formed and how the code flow follows
    in the IR generated. Since the important data structures in LLVM are graphs, this
    can be a very useful way to understand the IR flow when writing a custom pass
    or studying the behavior of the IR pattern.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **GraphViz** 工具可以可视化 LLVM IR 控制流图。它以可视化的方式展示了形成的节点以及代码流如何在生成的 IR 中遵循。由于 LLVM
    中的重要数据结构是图，这可以在编写自定义传递或研究 IR 模式行为时，成为一种非常有用的理解 IR 流的方式。
- en: Getting ready
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To install `graphviz` on Ubuntu, first add its `ppa` repository:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 Ubuntu 上安装 `graphviz`，首先添加其 `ppa` 仓库：
- en: '[PRE2]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Update the package repository:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新软件包仓库：
- en: '[PRE3]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Install `graphviz`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `graphviz`：
- en: '[PRE4]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you get the `graphviz : Depends: libgraphviz4 (>= 2.18) but it is not going
    to be installed` error, run the following commands:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '如果遇到 `graphviz : Depends: libgraphviz4 (>= 2.18) but it is not going to be
    installed` 错误，请运行以下命令：'
- en: '[PRE5]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then install `graphviz` again with the following command:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后使用以下命令再次安装 `graphviz`：
- en: '[PRE6]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How to do it…
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Once the IR has been converted to DAG, it can be viewed in different phases.
    Create a test.ll file with the following code:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 IR 转换为 DAG，它可以在不同的阶段进行查看。创建一个包含以下代码的 test.ll 文件：
- en: '[PRE7]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To display the DAG after it is built, before the first optimization pass, enter
    the following command:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在构建后但在第一次优化传递之前显示 DAG，请输入以下命令：
- en: '[PRE8]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following diagram shows the DAG before the first optimization pass:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下图显示了第一次优化传递之前的 DAG：
- en: '![How to do it…](img/image00255.jpeg)'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点…](img/image00255.jpeg)'
- en: 'To display the DAG before legalization, run this command:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示合法化之前的 DAG，请运行以下命令：
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is a diagram that shows the DAG before the legalization phase:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是一个显示合法化阶段之前 DAG 的图：
- en: '![How to do it…](img/image00256.jpeg)'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点…](img/image00256.jpeg)'
- en: 'To display the DAG before the second optimization pass, run the following command:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示第二次优化传递之前的 DAG，请运行以下命令：
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following diagram shows the DAG before the second optimization pass:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下图显示了第二次优化传递之前的 DAG：
- en: '![How to do it…](img/image00257.jpeg)'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点…](img/image00257.jpeg)'
- en: 'To display the DAG before the selection phase, enter this command:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示选择阶段之前的 DAG，请输入以下命令：
- en: '[PRE11]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is a diagram that shows the DAG before the selection phase:'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是一个显示选择阶段之前 DAG 的图：
- en: '![How to do it…](img/image00258.jpeg)'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点…](img/image00258.jpeg)'
- en: 'To display the DAG before scheduling, run the following command:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示调度之前的 DAG，请运行以下命令：
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following diagram shows the DAG before the scheduling phase:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下图显示了调度阶段之前的 DAG：
- en: '![How to do it…](img/image00259.jpeg)'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点…](img/image00259.jpeg)'
- en: 'To display the scheduler''s dependency graph, run this command:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示调度器的依赖图，请运行以下命令：
- en: '[PRE13]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This diagram shows the scheduler''s dependency graph:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此图显示了调度器的依赖图：
- en: '![How to do it…](img/image00260.jpeg)'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点…](img/image00260.jpeg)'
- en: Notice the difference in the DAG before and after the legalize phase. The `sdiv`
    node has been converted into an `sdivrem` node. The x86 target doesn't support
    the `sdiv` node but supports the `sdivrem` instruction. In a way, the `sdiv` instruction
    is illegal for the x86 target. The legalize phase converted it into an `sdivrem`
    instruction, which is supported by the x86 target.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意合法化阶段前后 DAG 的差异。`sdiv` 节点已被转换为 `sdivrem` 节点。x86 目标不支持 `sdiv` 节点，但支持 `sdivrem`
    指令。从某种意义上说，`sdiv` 指令对于 x86 目标是不合法的。合法化阶段将其转换为 x86 目标支持的 `sdivrem` 指令。
- en: Also note the difference in the DAG before and after the instruction selection
    (ISel) phase. Target-machine-independent instructions such as `Load` are converted
    into the `MOV32rm` machine code (which means, move 32-bit data from the memory
    to the register). The ISel phase is an important phase that will be described
    in later recipes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意指令选择 (ISel) 阶段前后 DAG 的差异。像 `Load` 这样的目标机无关指令被转换为 `MOV32rm` 机器代码（这意味着，将 32
    位数据从内存移动到寄存器）。ISel 阶段是一个重要的阶段，将在后面的菜谱中描述。
- en: Observe the scheduling units for the DAG. Each unit is linked to other units,
    which shows the dependency between them. This dependency information is very important
    for deciding scheduling algorithms. In the preceding case, scheduling unit 0 (SU0)
    is dependent on scheduling unit 1 (SU1). So, the instructions in SU0 cannot be
    scheduled before the instructions in SU1\. SU1 is dependent on SU2, and so is
    SU2 on SU3.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 观察 DAG 的调度单元。每个单元都与其他单元相连接，这显示了它们之间的依赖关系。这些依赖信息对于决定调度算法非常重要。在前面的例子中，调度单元 0 (SU0)
    依赖于调度单元 1 (SU1)。因此，SU0 中的指令不能在 SU1 中的指令之前调度。SU1 依赖于 SU2，同样 SU2 也依赖于 SU3。
- en: See also
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For more details on how to view graphs in debug mode, go to [http://llvm.org/docs/ProgrammersManual.html#viewing-graphs-while-debugging-code](http://llvm.org/docs/ProgrammersManual.html#viewing-graphs-while-debugging-code)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于如何在调试模式下查看图的更多详细信息，请访问 [http://llvm.org/docs/ProgrammersManual.html#viewing-graphs-while-debugging-code](http://llvm.org/docs/ProgrammersManual.html#viewing-graphs-while-debugging-code)
- en: Describing targets using TableGen
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TableGen 描述目标
- en: The target architecture can be described in terms of the registers present,
    the instruction set, and so on. Describing each of them manually is a tedious
    task. `TableGen` is a tool for backend developers that describes their target
    machine with a declarative language—`*.td`. The `*.td` files will be converted
    to enums, DAG-pattern matching functions, instruction encoding/decoding functions,
    and so on, which can then be used in other C++ files for coding.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 目标架构可以用现有的寄存器、指令集等来描述。手动描述每一个都是一项繁琐的任务。`TableGen` 是一个用于后端开发者的工具，它使用声明性语言 `*.td`
    来描述他们的目标机器。`*.td` 文件将被转换为枚举、DAG 模式匹配函数、指令编码/解码函数等，这些可以在其他 C++ 文件中用于编码。
- en: To define registers and the register set in the target description's `.td` files,
    `tablegen` will convert the intended `.td` file into `.inc` files, which will
    be `#include` syntax in our `.cpp` files referring to the registers.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在目标描述的 `.td` 文件中定义寄存器和寄存器集，`tablegen` 将目标 `.td` 文件转换为 `.inc` 文件，这些文件将在我们的
    `.cpp` 文件中以 `#include` 语法引用寄存器。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's assume that the sample target machine has four registers, `r0-r3`; a stack
    register, `sp`; and a link register, `lr`. These can be specified in the `SAMPLERegisterInfo.td`
    file. `TableGen` provides the `Register` class, which can be extended to specify
    registers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设示例目标机器有四个寄存器，`r0-r3`；一个栈寄存器，`sp`；以及一个链接寄存器，`lr`。这些可以在 `SAMPLERegisterInfo.td`
    文件中指定。`TableGen` 提供了 `Register` 类，它可以扩展以指定寄存器。
- en: How to do it
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Create a new folder in `lib/Target` named `SAMPLE`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `lib/Target` 目录下创建一个名为 `SAMPLE` 的新文件夹：
- en: '[PRE14]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a new file called `SAMPLERegisterInfo.td` in the new `SAMPLE` folder:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 `SAMPLE` 文件夹中创建一个名为 `SAMPLERegisterInfo.td` 的新文件：
- en: '[PRE15]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Define the hardware encoding, namespace, registers, and register class:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义硬件编码、命名空间、寄存器和寄存器类：
- en: '[PRE16]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: '`TableGen` processes this `.td` file to generate the `.inc` files, which have
    registers represented in the form of enums that can be used in the `.cpp` files.
    These `.inc` files will be generated when we build the LLVM project.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`TableGen` 处理这个 `.td` 文件以生成 `.inc` 文件，这些文件以枚举的形式表示寄存器，可以在 `.cpp` 文件中使用。当我们构建
    LLVM 项目时，将生成这些 `.inc` 文件。'
- en: See also
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To get more details on how registers are defined for more advanced architecture,
    such as the x86, refer to the `X86RegisterInfo.td` file located at `llvm_source_code/lib/Target/X86/`
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取关于如何为更高级的架构（如x86）定义寄存器的详细信息，请参考位于`llvm_source_code/lib/Target/X86/`的`X86RegisterInfo.td`文件。
- en: Defining an instruction set
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义指令集
- en: The instruction set of an architecture varies according to various features
    present in the architecture. This recipe demonstrates how instruction sets are
    defined for the target architecture.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 架构的指令集根据架构中存在的各种特性而有所不同。这个配方演示了如何为目标架构定义指令集。
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Three things are defined in the instruction target description file: operands,
    an assembly string, and an instruction pattern. The specification contains a list
    of definitions or outputs and a list of uses or inputs. There can be different
    operand classes such as the register class, and immediate or more complex `register
    + imm` operands.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在指令目标描述文件中定义了三件事：操作数、汇编字符串和指令模式。规范包含一个定义或输出列表和一个使用或输入列表。可以有不同类型的操作数类，如寄存器类，以及立即数或更复杂的`register
    + imm`操作数。
- en: Here, a simple add instruction definition is demonstrated. It takes two registers
    for the input and one register for the output.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，演示了一个简单的加法指令定义。它接受两个寄存器作为输入，一个寄存器作为输出。
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create a new file called `SAMPLEInstrInfo.td` in the `lib/Target/SAMPLE` folder:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`lib/Target/SAMPLE`文件夹中创建一个名为`SAMPLEInstrInfo.td`的新文件：
- en: '[PRE17]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Specify the operands, assembly string, and instruction pattern for the add
    instruction between two register operands:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定两个寄存器操作数之间加法指令的操作数、汇编字符串和指令模式：
- en: '[PRE18]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `add` register instruction specifies `$dst` as the resultant operand, which
    belongs to the general register type class; the `$src1` and `$src2` inputs as
    two input operands, which also belong to the general register class; and the instruction
    assembly string as `add $dst, $src1, $src2`, which is of the 32-bit integer type.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`寄存器指令指定`$dst`作为结果操作数，它属于通用寄存器类型类；`$src1`和`$src2`输入作为两个输入操作数，它们也属于通用寄存器类；指令汇编字符串为`add
    $dst, $src1, $src2`，它是32位整型。'
- en: 'So, an assembly will be generated for add between two registers, like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将生成两个寄存器之间加法的汇编，如下所示：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This tells us to add the `r0` and `r1` registers' content and store the result
    in the `r0` register.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们将`r0`和`r1`寄存器的内容相加，并将结果存储在`r0`寄存器中。
- en: See also
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For more detailed information on various types of instruction sets for advanced
    architecture, such as the x86, refer to the `X86InstrInfo.td` file located at
    `lib/Target/X86/`
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取关于高级架构（如x86）各种类型指令集的更详细信息，请参考位于`lib/Target/X86/`的`X86InstrInfo.td`文件。
- en: Detailed information of how target-specific things are defined will be covered
    in [Chapter 8](part0087.xhtml#aid-2IV0U1 "Chapter 8. Writing an LLVM Backend"),
    *Writing an LLVM Backend*. Some concepts might get repetitive, as the preceding
    recipes were described in brief to get a glimpse of the target architecture description
    and get a foretaste of the upcoming recipes
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细介绍了如何定义特定目标的相关信息将在[第8章](part0087.xhtml#aid-2IV0U1 "第8章。编写LLVM后端")中介绍，*编写LLVM后端*。一些概念可能会重复，因为前面的配方只是简要描述，以了解目标架构描述并预览即将到来的配方。
- en: Adding a machine code descriptor
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加机器代码描述符
- en: The LLVM IR has functions, which have basic blocks. Basic blocks in turn have
    instructions. The next logical step is to convert those IR abstract blocks into
    machine-specific blocks. LLVM code is translated into a machine-specific representation
    formed from the `MachineFunction`, `MachineBasicBlock`, and `MachineInstr` instances.
    This representation contains instructions in their most abstract form—that is,
    having an opcode and a series of operands.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM IR有函数，这些函数包含基本块。基本块反过来又包含指令。下一步合乎逻辑的操作是将这些IR抽象块转换为特定机器的块。LLVM代码被转换成由`MachineFunction`、`MachineBasicBlock`和`MachineInstr`实例组成的特定机器表示形式。这种表示形式包含最抽象形式的指令——即具有操作码和一系列操作数。
- en: How it's done…
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何完成…
- en: Now the LLVM IR instruction has to be represented in the machine instruction.
    Machine instructions are instances of the `MachineInstr` class. This class is
    an extremely abstract way of representing machine instructions. In particular,
    it only keeps track of an opcode number and a set of operands. The opcode number
    is a simple unsigned integer that has a meaning only for a specific backend.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在必须将 LLVM IR 指令表示为机器指令。机器指令是 `MachineInstr` 类的实例。这个类是一种极端抽象的方式来表示机器指令。特别是，它只跟踪一个操作码数字和一组操作数。操作码数字是一个只有对特定后端有意义的简单无符号整数。
- en: 'Let''s look at some important functions defined in the `MachineInstr.cpp` file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在 `MachineInstr.cpp` 文件中定义的一些重要函数：
- en: 'The `MachineInstr` constructor:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`MachineInstr` 构造函数：'
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This constructor creates an object of `MachineInstr` class and adds the implicit
    operands. It reserves space for the number of operands specified by the `MCInstrDesc`
    class.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此构造函数创建一个 `MachineInstr` 类对象并添加隐式操作数。它为 `MCInstrDesc` 类指定的操作数数量预留空间。
- en: 'One of the important functions is `addOperand`. It adds the specified operand
    to the instruction. If it is an implicit operand, it is added at the end of the
    operand list. If it is an explicit operand, it is added at the end of the explicit
    operand list, as shown here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个重要的函数是 `addOperand`。它将指定的操作数添加到指令中。如果是隐式操作数，它将被添加到操作数列表的末尾。如果是显式操作数，它将被添加到显式操作数列表的末尾，如下所示：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The target architecture has some memory operands as well. To add those memory
    operands, a function called `addMemOperands()` is defined:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 目标架构也有一些内存操作数。为了添加这些内存操作数，定义了一个名为 `addMemOperands()` 的函数：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `setMemRefs()` function is the primary method for setting up a `MachineInstr`
    `MemRefs` list.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`setMemRefs()` 函数是设置 `MachineInstr` `MemRefs` 列表的主要方法。'
- en: How it works…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `MachineInstr` class has an MCID member, with the `MCInstrDesc` type for
    describing the instruction, a `uint8_t` flags member, a memory reference member
    (`mmo_iterator` `MemRefs`), and a vector member of the `std::vector<MachineOperand`>
    operands. In terms of methods, the `MachineInstr` class provides the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`MachineInstr` 类有一个 MCID 成员，用于描述指令的 `MCInstrDesc` 类型，一个 `uint8_t` 标志成员，一个内存引用成员
    (`mmo_iterator` `MemRefs`)，以及一个 `std::vector<MachineOperand>` 的操作数成员。在方法方面，`MachineInstr`
    类提供了以下功能：'
- en: A basic set of `get**` and `set**` functions for information queries, for example,
    `getOpcode()`, `getNumOperands()`, and so on
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组基本的 `get**` 和 `set**` 函数用于信息查询，例如，`getOpcode()`，`getNumOperands()` 等
- en: Bundle-related operations, for example, `isInsideBundle()`
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与捆绑相关的操作，例如，`isInsideBundle()`
- en: Checking whether the instruction has certain properties, for example, `isVariadic()`,
    `isReturn()`, `isCall()`, and so on
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查指令是否具有某些属性，例如，`isVariadic()`，`isReturn()`，`isCall()` 等
- en: Machine instruction manipulation, for example, `eraseFromParent()`
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器指令操作，例如，`eraseFromParent()`
- en: Register-related operations, such as `ubstituteRegister()`, `addRegisterKilled()`,
    and so on
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与寄存器相关的操作，例如，`ubstituteRegister()`，`addRegisterKilled()` 等
- en: Machine-instruction-creating methods, for example, `addOperand()`, `setDesc()`,
    and so on
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建机器指令的方法，例如，`addOperand()`，`setDesc()` 等
- en: Note that, although the `MachineInstr` class provides machine-instruction-creating
    methods, a dedicated function called `BuildMI()`, based on the `MachineInstrBuilder`
    class, is more convenient.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管 `MachineInstr` 类提供了创建机器指令的方法，但基于 `MachineInstrBuilder` 类的专用函数 `BuildMI()`
    更方便。
- en: Implementing the MachineInstrBuilder class
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 `MachineInstrBuilder` 类
- en: The `MachineInstrBuilder` class exposes a function called `BuildMI()`. This
    function is used to build machine instructions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`MachineInstrBuilder` 类公开了一个名为 `BuildMI()` 的函数。此函数用于构建机器指令。'
- en: How to do it…
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Machine instructions are created by using the `BuildMI` functions, located in
    the `include/llvm/CodeGen/MachineInstrBuilder.h` file. The `BuildMI` functions
    make it easy to build arbitrary machine instructions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用位于 `include/llvm/CodeGen/MachineInstrBuilder.h` 文件中的 `BuildMI` 函数创建机器指令。`BuildMI`
    函数使得构建任意机器指令变得容易。
- en: 'For example, you can use `BuildMI` in code snippets for the following purposes:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以在代码片段中使用 `BuildMI` 来实现以下目的：
- en: 'To create a `DestReg = mov 42` (rendered in the x86 assembly as `mov DestReg,
    42`) instruction:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个 `DestReg = mov 42`（在 x86 汇编中表示为 `mov DestReg, 42`）指令：
- en: '[PRE23]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To create the same instruction, but insert it at the end of a basic block:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建相同的指令，但将其插入到基本块的末尾：
- en: '[PRE24]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To create the same instruction, but insert it before a specified iterator point:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建相同的指令，但将其插入到指定的迭代器点之前：
- en: '[PRE25]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To create a self-looping branch instruction:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个循环分支指令：
- en: '[PRE26]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `BuildMI()` function is required for specifying the number of operands that
    the machine instruction will take, which facilitates efficient memory allocation.
    It is also required to specify whether operands use values or definitions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`BuildMI()` 函数用于指定机器指令将采用的操作数数量，这有助于有效的内存分配。它还必须指定操作数使用值还是定义。'
- en: Implementing the MachineBasicBlock class
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 `MachineBasicBlock` 类
- en: Similar to basic blocks in the LLVM IR, a `MachineBasicBlock` class has a set
    of machine instructions in sequential order. Mostly, a `MachineBasicBlock` class
    maps to a single LLVM IR basic block. However, there can be cases where multiple
    `MachineBasicBlocks` classes map to a single LLVM IR basic block. The `MachineBasicBlock`
    class has a method, called `getBasicBlock()`, that returns the IR basic block
    to which it is mapping.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与 LLVM IR 中的基本块类似，`MachineBasicBlock` 类按顺序包含一组机器指令。大多数情况下，`MachineBasicBlock`
    类映射到单个 LLVM IR 基本块。然而，也可能存在多个 `MachineBasicBlock` 类映射到单个 LLVM IR 基本块的情况。`MachineBasicBlock`
    类有一个名为 `getBasicBlock()` 的方法，它返回映射到的 IR 基本块。
- en: How to do it…
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following steps show how machine basic blocks are added:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何添加机器基本块：
- en: 'The `getBasicBlock` method will return only the current basic block:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getBasicBlock` 方法将仅返回当前的基本块：'
- en: '[PRE27]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The basic blocks have successor as well as predecessor basic blocks. To keep
    track of those, vectors are defined as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本块有后继和前驱基本块。为了跟踪这些，定义了如下向量：
- en: '[PRE28]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'An `insert` function should be added to insert a machine instruction into the
    basic block:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应添加一个 `insert` 函数，用于将机器指令插入到基本块中：
- en: '[PRE29]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A function called `SplitCriticalEdge()` splits the critical edges from this
    block to the given successor block, and returns the newly created block, or null
    if splitting is not possible. This function updates the `LiveVariables`, `MachineDominatorTree`,
    and `MachineLoopInfo` classes:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个名为 `SplitCriticalEdge()` 的函数将从这个块到给定后继块的临界边拆分出来，并返回新创建的块，如果拆分不可行则返回 null。此函数更新
    `LiveVariables`、`MachineDominatorTree` 和 `MachineLoopInfo` 类：
- en: '[PRE30]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The full implementation of the preceding code is shown in the `MachineBasicBlock.cpp`
    file located at `lib/CodeGen/`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的完整实现位于 `lib/CodeGen/` 目录下的 `MachineBasicBlock.cpp` 文件中。
- en: How it works…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As listed previously, several representative functions of different categories
    form the interface definition of the `MachineBasicBlock` class. The `MachineBasicBlock`
    class keeps a list of machine instructions such as `typedef ilist<MachineInstr>`
    instructions, instructions `Insts`, and the original LLVM BB (basic block). It
    also provides methods for purposes such as these:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，不同类别的几个代表性函数构成了 `MachineBasicBlock` 类的接口定义。`MachineBasicBlock` 类保持一个包含机器指令的列表，例如
    `typedef ilist<MachineInstr>` 指令、`Insts` 指令和原始的 LLVM BB（基本块）。它还提供了如下目的的方法：
- en: BB information querying (for example, `getBasicBlock()` and `setHasAddressTaken()`)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BB 信息查询（例如，`getBasicBlock()` 和 `setHasAddressTaken()`）
- en: BB-level manipulation (for example, `moveBefore()`, `moveAfter()`, and `addSuccessor()`)
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BB 级别操作（例如，`moveBefore()`、`moveAfter()`、`addSuccessor()`）
- en: Instruction-level manipulation (for example, `push_back()`, `insertAfter()`,
    and so on)
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令级操作（例如，`push_back()`、`insertAfter()` 等）
- en: See also
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To see a detailed implementation of the `MachineBasicBlock class`, go through
    the `MachineBasicBlock.cpp` file located at `lib/CodeGen/`
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查看 `MachineBasicBlock` 类的详细实现，请查阅位于 `lib/CodeGen/` 的 `MachineBasicBlock.cpp`
    文件。
- en: Implementing the MachineFunction class
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 `MachineFunction` 类
- en: Similar to the LLVM IR `FunctionBlock` class, a `MachineFunction` class contains
    a series of `MachineBasicBlocks` classes. These `MachineFunction` classes map
    to LLVM IR functions that are given as input to the instruction selector. In addition
    to a list of basic blocks, the `MachineFunction` class contains the `MachineConstantPool`,
    `MachineFrameInfo`, `MachineFunctionInfo`, and `MachineRegisterInfo` classes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与 LLVM IR 的 `FunctionBlock` 类类似，`MachineFunction` 类包含一系列 `MachineBasicBlocks`
    类。这些 `MachineFunction` 类映射到指令选择器输入的 LLVM IR 函数。除了基本块列表外，`MachineFunction` 类还包含
    `MachineConstantPool`、`MachineFrameInfo`、`MachineFunctionInfo` 和 `MachineRegisterInfo`
    类。
- en: How to do it…
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Many functions are defined in the `MachineFunction` class, which does specific
    tasks. There are also many class member objects that keep information, such as
    the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 许多函数定义在 `MachineFunction` 类中，该类执行特定任务。还有许多类成员对象保持信息，如下所示：
- en: '`RegInfo` keeps information about each register that is in use in the function:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegInfo`跟踪函数中每个正在使用的寄存器的信息：'
- en: '[PRE31]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`MachineFrameInfo` keeps track of objects allocated on the stack:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MachineFrameInfo`跟踪堆栈上分配的对象：'
- en: '[PRE32]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`ConstantPool` keeps track of constants that have been spilled to the memory:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConstantPool`跟踪已溢出到内存中的常量：'
- en: '[PRE33]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`JumpTableInfo` keeps track of jump tables for switch instructions:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JumpTableInfo`跟踪跳转表的switch指令：'
- en: '[PRE34]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The list of machine basic blocks in the function:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数中机器基本块的列表：
- en: '[PRE35]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `getFunction` function returns the LLVM function that the current machine
    code represents:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFunction`函数返回当前机器代码表示的LLVM函数：'
- en: '[PRE36]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`CreateMachineInstr` allocates a new `MachineInstr` class:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateMachineInstr`分配一个新的`MachineInstr`类：'
- en: '[PRE37]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works…
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `MachineFunction` class primarily contains a list of `MachineBasicBlock`
    objects (`typedef ilist<MachineBasicBlock> BasicBlockListType; BasicBlockListType
    BasicBlocks;`), and defines various methods for retrieving information about the
    machine function and manipulating the objects in the basic blocks member. A very
    important point to note is that the `MachineFunction` class maintains the **control
    flow graph** (**CFG**) of all basic blocks in a function. Control flow information
    in CFG is crucial for many optimizations and analyses. So, it is important to
    know how the `MachineFunction` objects and the corresponding CFGs are constructed.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`MachineFunction`类主要包含一个`MachineBasicBlock`对象列表（`typedef ilist<MachineBasicBlock>
    BasicBlockListType; BasicBlockListType BasicBlocks;`），并定义了各种用于检索机器函数信息以及操作基本块成员中对象的方法。一个需要注意的重要点是，`MachineFunction`类维护函数中所有基本块的**控制流图**（**CFG**）。CFG中的控制流信息对于许多优化和分析至关重要。因此，了解`MachineFunction`对象和相应的CFG是如何构建的非常重要。'
- en: See also
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: A detailed implementation of the `MachineFunction` class can be found in the
    `MachineFunction.cpp` file located at `lib/Codegen/`
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MachineFunction`类的详细实现可以在位于`lib/Codegen/`目录下的`MachineFunction.cpp`文件中找到。'
- en: Writing an instruction selector
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写指令选择器
- en: LLVM uses the `SelectionDAG` representation to represent the LLVM IR in a low-level
    data-dependence DAG for instruction selection. Various simplifications and target-specific
    optimizations can be applied to the `SelectionDAG` representation. This representation
    is target-independent. It is a significant, simple, and powerful representation
    used to implement IR lowering to target instructions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 'LLVM使用`SelectionDAG`表示法来表示LLVM IR的低级数据依赖DAG，用于指令选择。可以对`SelectionDAG`表示法应用各种简化和特定于目标的优化。这种表示法是目标无关的。它是一个重要、简单且强大的表示法，用于实现IR降低到目标指令。 '
- en: How to do it…
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'The following code shows a brief skeleton of the `SelectionDAG` class, its
    data members, and various methods used to set/retrieve useful information from
    this class. The `SelectionDAG` class is defined as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`SelectionDAG`类的简要框架，其数据成员以及用于从该类设置/检索有用信息的各种方法。`SelectionDAG`类定义如下：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works…
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: From the preceding code, it can be seen that the `SelectionDAG` class provides
    lots of target-independent methods to create `SDNode` of various kinds, and retrieves/computes
    useful information from the nodes in the `SelectionDAG` graph. There are also
    update and replace methods provided in the `SelectionDAG` class. Most of these
    methods are defined in the `SelectionDAG.cpp` file. Note that the `SelectionDAG`
    graph and its node type, `SDNode`, are designed in a way that is capable of storing
    both target-independent and target-specific information. For example, the `isTargetOpcode()`
    and `isMachineOpcode()` methods in the `SDNode` class can be used to determine
    whether an opcode is a target opcode or a machine opcode (target-independent).
    This is because the same class type, `NodeType`, is used to represent both the
    opcode of a real target and the opcode of a machine instruction, but with separate
    ranges.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看出，`SelectionDAG`类提供了许多目标无关的方法来创建各种类型的`SDNode`，并从`SelectionDAG`图中的节点检索/计算有用信息。`SelectionDAG`类还提供了更新和替换方法。这些方法中的大多数都在`SelectionDAG.cpp`文件中定义。请注意，`SelectionDAG`图及其节点类型`SDNode`的设计能够存储目标无关和目标特定的信息。例如，`SDNode`类中的`isTargetOpcode()`和`isMachineOpcode()`方法可以用来确定操作码是否是目标操作码或机器操作码（目标无关）。这是因为相同的类类型`NodeType`被用来表示真实目标的操作码和机器指令的操作码，但范围是分开的。
- en: Legalizing SelectionDAG
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Legalizing SelectionDAG
- en: A `SelectionDAG` representation is a target-independent representation of instructions
    and operands. However, a target may not always support the instruction or data
    type represented by `SelectionDAG`. In that sense, the initial `SelectionDAG`
    graph constructed can be called illegal. The DAG legalize phase converts the illegal
    DAG into a legal DAG supported by the target architecture.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectionDAG` 表示是指令和操作数的目标无关表示。然而，目标可能并不总是支持由 `SelectionDAG` 表示的指令或数据类型。从这个意义上说，最初构建的
    `SelectionDAG` 图可以称为非法图。DAG 合法化阶段将非法 DAG 转换为目标架构支持的合法 DAG。'
- en: A DAG legalize phase can follow two ways to convert unsupported data types into
    supported data types—by promoting smaller data types to larger data types, or
    by truncating larger data types into smaller ones. For example, suppose that a
    type of target architecture supports only i32 data types. In that case, smaller
    data types such as i8 and i16 need to be promoted to the i32 type. A larger data
    type, such as i64, can be expanded to give two i32 data types. The `Sign` and
    `Zero` extensions can be added so that the result remains consistent in the process
    of promoting or expanding data types.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: DAG 合法化阶段可以通过两种方式将不支持的数据类型转换为支持的数据类型——通过将较小的数据类型提升为较大的数据类型，或者通过截断较大的数据类型为较小的数据类型。例如，假设目标架构只支持
    i32 数据类型。在这种情况下，较小的数据类型，如 i8 和 i16，需要提升为 i32 类型。较大的数据类型，如 i64，可以扩展为两个 i32 数据类型。可以添加
    `Sign` 和 `Zero` 扩展，以确保在提升或扩展数据类型的过程中结果保持一致。
- en: Similarly, vector types can be legalized to supported vector types by either
    splitting the vector into smaller sized vectors (by extracting the elements from
    the vector), or by widening smaller vector types to larger, supported vector types.
    If vectors are not supported in the target architecture, then every element of
    the vector in the IR needs to be extracted in the scalar form.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，可以通过将向量拆分为更小的向量（通过从向量中提取元素）或将较小的向量类型扩展为较大的、受支持的向量类型来将向量类型合法化为受支持的向量类型。如果目标架构不支持向量，那么
    IR 中的向量中的每个元素都需要以标量形式提取。
- en: The legalize phase can also instruct the kind of classes of registers supported
    for given data.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 合法化阶段还可以指示支持给定数据的寄存器类。
- en: How to do it…
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The `SelectionDAGLegalize` class consists of various data members, tracking
    data structures to keep a track of legalized nodes, and various methods that are
    used to operate on nodes to legalize them. A sample snapshot of the legalize phase
    code from the LLVM trunk shows the basic skeleton of implementation of the legalize
    phase, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectionDAGLegalize` 类包含各种数据成员，跟踪数据结构以跟踪合法化节点，以及各种用于操作节点以合法化它们的方法。从 LLVM
    主干中合法化阶段代码的示例快照显示了合法化阶段实现的基本框架，如下所示：'
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works…
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: Many function members of the `SelectionDAGLegalize` class, such as `LegalizeOp`,
    rely on target-specific information provided by the `const TargetLowering &TLI`
    member (other function members may also depend on the `const TargetMachine &TM`
    member) in the `SelectionDAGLegalize` class. Let's take an example to demonstrate
    how legalization works.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectionDAGLegalize` 类的许多函数成员，如 `LegalizeOp`，依赖于 `SelectionDAGLegalize` 类中由
    `const TargetLowering &TLI` 成员提供的特定于目标的详细信息（其他函数成员也可能依赖于 `SelectionDAGLegalize`
    类中的 `const TargetMachine &TM` 成员）。让我们通过一个例子来演示合法化是如何工作的。'
- en: 'There are two types of legalization: type legalization and instruction legalization.
    Let''s first see how type legalization works. Create a `test.ll` file using the
    following commands:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 合法化有两种类型：类型合法化和指令合法化。让我们首先看看类型合法化是如何工作的。使用以下命令创建一个 `test.ll` 文件：
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The data type in this case is i64\. For the x86 target, which supports only
    the 32-bit data type, the data type you just saw is illegal. To run the preceding
    code, the data type has to be converted to i32\. This is done by the DAG Legalization
    phase.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，数据类型是 i64。对于只支持 32 位数据类型的 x86 目标，您刚才看到的数据类型是非法的。要运行前面的代码，数据类型必须转换为 i32。这是由
    DAG 合法化阶段完成的。
- en: 'To view the DAG before type legalization, run the following command line:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看类型合法化前的 DAG，请运行以下命令行：
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following figure shows the DAG before type legalization:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了类型合法化前的 DAG：
- en: '![How it works…](img/image00261.jpeg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/image00261.jpeg)'
- en: 'To see DAG after type legalization, enter the following command line:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看类型合法化后的 DAG，请输入以下命令行：
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following figure shows the DAG after type legalization:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了类型合法化后的 DAG：
- en: '![How it works…](img/image00262.jpeg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/image00262.jpeg)'
- en: On observing the DAG nodes carefully, you can see that every operation before
    legalization had the i64 type. This was because the IR had the data type i64—one-to-one
    mapping from the IR instruction to the DAG nodes. However, the target x86 machine
    supports only the i32 type (32-bit integer type). The DAG legalize phase converts
    unsupported i64 types to supported i32 types. This operation is called expanding—splitting
    larger types into smaller types. For example, in a target accepting only i32 values,
    all i64 values are broken down to pairs of i32 values. So, after legalization,
    you can see that all the operations now have i32 as the data type.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察 DAG 节点，你可以看到在合法化之前每个操作都有 i64 类型。这是因为 IR 有 i64 数据类型——IR 指令到 DAG 节点的单一映射。然而，目标
    x86 机器只支持 i32 类型（32 位整数类型）。DAG 合法化阶段将不支持的 i64 类型转换为支持的 i32 类型。这个操作被称为扩展——将较大的类型拆分成较小的类型。例如，在一个只接受
    i32 值的目标中，所有 i64 值都被分解成 i32 值的对。因此，在合法化之后，你可以看到所有操作现在都有 i32 作为数据类型。
- en: 'Let''s see how instructions are legalized; create a `test.ll` file using the
    following commands:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看指令是如何合法化的；使用以下命令创建一个 `test.ll` 文件：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To view the DAG before legalization, enter the following command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看合法化前的 DAG，请输入以下命令：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following figure shows the DAG before legalization:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了合法化前的 DAG：
- en: '![How it works…](img/image00263.jpeg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/image00263.jpeg)'
- en: 'To view the DAG after legalization, enter the following command:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看合法化后的 DAG，请输入以下命令：
- en: '[PRE45]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following figure shows the DAG after the legalization phase:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了合法化阶段后的 DAG：
- en: '![How it works…](img/image00264.jpeg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/image00264.jpeg)'
- en: The DAG, before instruction legalization, consists of `sdiv` instructions. Now,
    the x86 target does not support the `sdiv` instruction, hence it is illegal for
    the target. It does, however, support the `sdivrem` instruction. So, the legalization
    phase involves conversion of the `sdiv` instruction to the `sdivrem` instruction,
    as visible in the preceding two DAGs.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在指令合法化之前，DAG 由 `sdiv` 指令组成。现在，x86 目标不支持 `sdiv` 指令，因此对于目标来说是不合法的。然而，它支持 `sdivrem`
    指令。因此，合法化阶段涉及将 `sdiv` 指令转换为 `sdivrem` 指令，如前述两个 DAG 所示。
- en: Optimizing SelectionDAG
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化 `SelectionDAG`
- en: A `SelectionDAG` representation shows data and instructions in the form of nodes.
    Similar to the `InstCombine` pass in the LLVM IR, these nodes can be combined
    and optimized to form a minimized `SelectionDAG`. But, it's not just a `DAGCombine`
    operation that optimizes the SelectionDAG. A `DAGLegalize` phase may generate
    some unnecessary DAG nodes, which are cleaned up by subsequent runs of the DAG
    optimization pass. This finally represents the `SelectionDAG` in a more simple
    and elegant way.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectionDAG` 表示法以节点形式展示数据和指令。类似于 LLVM IR 中的 `InstCombine` 阶段，这些节点可以被合并和优化，形成一个最小化的
    `SelectionDAG`。但是，优化 `SelectionDAG` 的不仅仅是 `DAGCombine` 操作。`DAGLegalize` 阶段可能会生成一些不必要的
    DAG 节点，这些节点会在后续的 DAG 优化阶段运行中被清理。这最终以更简单、更优雅的方式表示了 `SelectionDAG`。'
- en: How to do it…
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'There are lots and lots of function members (most of them are named like this:
    `visit**()`) provided in the `DAGCombiner` class to perform optimizations by folding,
    reordering, combining, and modifying `SDNode` nodes. Note that, from the `DAGCombiner`
    constructor, we can guess that some optimizations require alias analysis information:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DAGCombiner` 类中提供了大量的函数成员（大多数命名方式如下：`visit**()`），用于通过折叠、重排、合并和修改 `SDNode`
    节点来执行优化。请注意，从 `DAGCombiner` 构造函数中，我们可以推测一些优化需要别名分析信息：
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works…
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As seen in the preceding code, some `DAGCombine` passes search for a pattern
    and then fold the patterns into a single DAG. This basically reduces the number
    of DAGs, while lowering DAGs. The result is an optimized `SelectionDAG` class.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，一些 `DAGCombine` 阶段会搜索一个模式，然后将模式折叠成一个单一的 DAG。这基本上减少了 DAG 的数量，同时降低了 DAG
    的复杂度。结果是优化后的 `SelectionDAG` 类。
- en: See also
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For a more detailed implementation of the optimized `SelectionDAG` class, see
    the `DAGCombiner.cpp` file located at `lib/CodeGen/SelectionDAG/`
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查看优化后的 `SelectionDAG` 类的更详细实现，请参阅位于 `lib/CodeGen/SelectionDAG/` 目录下的 `DAGCombiner.cpp`
    文件。
- en: Selecting instruction from the DAG
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 DAG 中选择指令
- en: After legalization and DAG combination, the `SelectionDAG` representation is
    in the optimized phase. However, the instructions represented are still target-independent
    and need to be mapped on target-specific instructions. The instruction selection
    phase takes the target-independent DAG nodes as the input, matches patterns in
    them, and gives the output DAG nodes, which are target-specific.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在合法化和DAG组合之后，`SelectionDAG`表示处于优化阶段。然而，表示的指令仍然是目标无关的，需要映射到特定于目标的指令上。指令选择阶段以目标无关的DAG节点作为输入，匹配其中的模式，并给出输出DAG节点，这些节点是特定于目标的。
- en: The `TableGen` DAG instruction selector generator reads the instruction patterns
    from the `.td` file, and automatically builds parts of the pattern matching code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`TableGen` DAG指令选择器从`.td`文件中读取指令模式，并自动构建部分模式匹配代码。'
- en: How to do it…
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: '`SelectionDAGISel` is the common base class used for pattern-matching instruction
    selectors that are based on `SelectionDAG`. It inherits the `MachineFunctionPass`
    class. It has various functions used to determine the legality and profitability
    of operations such as folding. The basic skeleton of this class is as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectionDAGISel`是用于基于`SelectionDAG`的模式匹配指令选择器的通用基类。它继承自`MachineFunctionPass`类。它包含用于确定折叠等操作的合法性和盈利性的各种函数。此类的基本结构如下：'
- en: '[PRE47]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works…
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: The instruction selection phase involves converting target-independent instructions
    to target-specific instructions. The `TableGen` class helps select target-specific
    instructions. This phase basically matches target-independent input nodes, which
    gives an output consisting of target-supported nodes.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 指令选择阶段涉及将目标无关指令转换为特定于目标的指令。`TableGen`类帮助选择特定于目标的指令。此阶段基本上匹配目标无关的输入节点，从而给出由目标支持的节点组成的输出。
- en: 'The `CodeGenAndEmitDAG()` function calls the `DoInstructionSelection()` function,
    which visits each DAG node and calls the `Select()` function for each node, like
    this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`CodeGenAndEmitDAG()`函数调用`DoInstructionSelection()`函数，该函数遍历每个DAG节点，并为每个节点调用`Select()`函数，如下所示：'
- en: '[PRE48]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `Select()` function is an abstract method implemented by the targets. The
    x86 target implements it in the `X86DAGToDAGISel::Select()` function. The `X86DAGToDAGISel::Select()`
    function intercepts some nodes for manual matching, but delegates the bulk of
    the work to the `X86DAGToDAGISel::SelectCode()` function.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`Select()`函数是由目标实现的抽象方法。x86目标在`X86DAGToDAGISel::Select()`函数中实现它。`X86DAGToDAGISel::Select()`函数拦截一些节点进行手动匹配，但将大部分工作委托给`X86DAGToDAGISel::SelectCode()`函数。'
- en: The `X86DAGToDAGISel::SelectCod`e function is autogenerated by `TableGen`. It
    contains the matcher table, followed by a call to the generic `SelectionDAGISel::SelectCodeCommon()`
    function, passing it the table.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`X86DAGToDAGISel::SelectCode`函数由`TableGen`自动生成。它包含匹配器表，随后调用通用的`SelectionDAGISel::SelectCodeCommon()`函数，并传递该表。'
- en: 'For example:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE49]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To see the DAG before instruction selection, enter the following command line:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看指令选择之前的DAG，请输入以下命令行：
- en: '[PRE50]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following figure shows the DAG before the instruction selection:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了指令选择之前的DAG：
- en: '![How it works…](img/image00265.jpeg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/image00265.jpeg)'
- en: 'To see how DAG looks like after the instruction selection, enter the following
    command:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看指令选择之后的DAG看起来如何，请输入以下命令：
- en: '[PRE51]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following figure shows the DAG after the instruction selection:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了指令选择之后的DAG：
- en: '![How it works…](img/image00266.jpeg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/image00266.jpeg)'
- en: As seen, the `Load` operation is converted into the `MOV32rm` machine code by
    the instruction selection phase.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，指令选择阶段将`Load`操作转换为`MOV32rm`机器代码。
- en: See also
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To see the detailed implementation of the instruction selection, take a look
    at the `SelectionDAGISel.cpp` file located at `lib/CodeGen/SelectionDAG/`
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查看指令选择的详细实现，请查看位于`lib/CodeGen/SelectionDAG/`的`SelectionDAGISel.cpp`文件。
- en: Scheduling instructions in SelectionDAG
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SelectionDAG中的调度指令
- en: So far, we have had `SelectionDAG` nodes consisting of target-supported instructions
    and operands. However, the code is still in DAG representation. The target architecture
    executes instructions in sequential form. So, the next logical step is to schedule
    the `SelectionDAG` nodes.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有由目标支持的指令和操作数组成的`SelectionDAG`节点。然而，代码仍然以DAG表示形式存在。目标架构以顺序形式执行指令。因此，下一步合乎逻辑的步骤是对`SelectionDAG`节点进行调度。
- en: A scheduler assigns the order of execution of instructions from the DAG. In
    this process, it takes into account various heuristics, such as register pressure,
    to optimize the execution order of instructions and to minimize latencies in instruction
    execution. After assigning the order of execution to the DAG nodes, the nodes
    are converted into a list of `MachineInstrs` and the `SelectionDAG` nodes are
    destroyed.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器从DAG（有向无环图）中分配指令的执行顺序。在这个过程中，它考虑了各种启发式方法，例如寄存器压力，以优化指令的执行顺序并最小化指令执行中的延迟。在将执行顺序分配给DAG节点之后，节点被转换成一个`MachineInstrs`列表，并且`SelectionDAG`节点被销毁。
- en: How to do it…
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'There are several basic structures that are defined in the `ScheduleDAG.h`
    file and implemented in the `ScheduleDAG.cpp` file. The `ScheduleDAG` class is
    a base class for other schedulers to inherit, and it provides only graph-related
    manipulation operations such as an iterator, DFS, topological sorting, functions
    for moving nodes around, and so on:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ScheduleDAG.h`文件中定义了几个基本结构，并在`ScheduleDAG.cpp`文件中实现。`ScheduleDAG`类是其他调度器继承的基类，它仅提供与图相关的操作，例如迭代器、DFS（深度优先搜索）、拓扑排序、移动节点的函数等：
- en: '[PRE52]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works…
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The scheduling algorithm implements the scheduling of instructions in the `SelectionDAG`
    class, which involves a variety of algorithms such as topological sorting, depth-first
    searching, manipulating functions, moving nodes, and iterating over a list of
    instructions. It takes into account various heuristics, such as register pressure,
    spilling cost, live interval analysis, and so on to determine the best possible
    scheduling of instructions.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 调度算法在`SelectionDAG`类中实现了指令的调度，涉及多种算法，如拓扑排序、深度优先搜索、函数操作、节点移动和遍历指令列表。它考虑了各种启发式方法，例如寄存器压力、溢出成本、活跃区间分析等，以确定指令的最佳调度方案。
- en: See also
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: For a detailed implementation of scheduling instructions, see the `ScheduleDAGSDNodes.cpp`,
    `ScheduleDAGSDNodes.h`, `ScheduleDAGRRList.cpp`, `ScheduleDAGFast.cpp`, and `ScheduleDAGVLIW.cpp`
    files located in the `lib/CodeGen/SelectionDAG` folder
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关调度指令的详细实现，请参阅位于`lib/CodeGen/SelectionDAG`文件夹中的`ScheduleDAGSDNodes.cpp`、`ScheduleDAGSDNodes.h`、`ScheduleDAGRRList.cpp`、`ScheduleDAGFast.cpp`和`ScheduleDAGVLIW.cpp`文件
