["```cpp\n#include <stdint.h>\n#include \"uart.h\"\n#define GPIOAEN        (1U<<0)\n#define UART2EN        (1U<<17)\n#define DBG_UART_BAUDRATE        115200\n#define SYS_FREQ                16000000\n#define APB1_CLK                SYS_FREQ\n#define CR1_TE                (1U<<3)\n#define CR1_UE                (1U<<13)\n#define SR_TXE                (1U<<7)\nstatic void uart_set_baudrate(uint32_t periph_clk,uint32_t baudrate);\nstatic void uart_write(int ch);\nint __io_putchar(int ch)\n{\n    uart_write(ch);\n    return ch;\n}\nvoid uart_init(void)\n{\n    /*Enable clock access to GPIOA*/\n    RCC->AHB1ENR |= GPIOAEN;\n    /*Set the mode of PA2 to alternate function mode*/\n    GPIOA->MODER &=~(1U<<4);\n    GPIOA->MODER |=(1U<<5);\n    /*Set alternate function type to AF7(UART2_TX)*/\n    GPIOA->AFR[0] |=(1U<<8);\n    GPIOA->AFR[0] |=(1U<<9);\n    GPIOA->AFR[0] |=(1U<<10);\n    GPIOA->AFR[0] &=~(1U<<11);\n    /*Enable clock access to UART2*/\n     RCC->APB1ENR |=    UART2EN;\n    /*Configure uart baudrate*/\n      uart_set_baudrate(APB1_CLK,DBG_UART_BAUDRATE);\n    /*Configure transfer direction*/\n     USART2->CR1 = CR1_TE;\n    /*Enable UART Module*/\n     USART2->CR1 |= CR1_UE;\n}\nstatic void uart_write(int ch)\n{\n    /*Make sure transmit data register is empty*/\n    while(!(USART2->SR & SR_TXE)){}\n    /*Write to transmit data register*/\n    USART2->DR =(ch & 0xFF);\n}\nstatic uint16_t compute_uart_bd(uint32_t periph_clk,uint32_t baudrate)\n{\n    return((periph_clk + (baudrate/2U))/baudrate);\n}\nstatic void uart_set_baudrate(uint32_t periph_clk,uint32_t baudrate)\n{\n    USART2->BRR = compute_uart_bd(periph_clk,baudrate);\n}\n```", "```cpp\n#include <stdint.h>\n#include \"uart.h\"\n#define GPIOAEN (1U<<0)\n#define UART2EN (1U<<17)\n#define DBG_UART_BAUDRATE 115200\n#define SYS_FREQ 16000000\n#define APB1_CLK SYS_FREQ\n#define CR1_TE (1U<<3)\n#define CR1_UE (1U<<13)\n#define SR_TXE (1U<<7)\n```", "```cpp\nstatic uint16_t compute_uart_bd(uint32_t periph_clk, uint32_t baudrate)\n{\n    return ((periph_clk + (baudrate / 2U)) / baudrate);\n}\n```", "```cpp\nstatic void uart_set_baudrate(uint32_t periph_clk, uint32_t baudrate)\n{\n    USART2->BRR = compute_uart_bd(periph_clk, baudrate);\n}\n```", "```cpp\nRCC->AHB1ENR |= GPIOAEN;\n```", "```cpp\nGPIOA->MODER &= ~(1U << 4);\nGPIOA->MODER |= (1U << 5);\n```", "```cpp\nGPIOA->AFR[0] |= (1U << 8);\nGPIOA->AFR[0] |= (1U << 9);\nGPIOA->AFR[0] |= (1U << 10);\nGPIOA->AFR[0] &= ~(1U << 11);\n```", "```cpp\n RCC->APB1ENR |= UART2EN;\n```", "```cpp\nuart_set_baudrate(APB1_CLK, DBG_UART_BAUDRATE);\n```", "```cpp\nUSART2->CR1 = CR1_TE;\n```", "```cpp\nUSART2->CR1 |= CR1_UE;\n```", "```cpp\nstatic void uart_write(int ch)\n{\n    /* Make sure transmit data register is empty */\n    while (!(USART2->SR & SR_TXE)) {}\n    /* Write to transmit data register */\n    USART2->DR = (ch & 0xFF);\n}\n```", "```cpp\nwhile (!(USART2->SR & SR_TXE)) {}\n```", "```cpp\nUSART2->DR = (ch & 0xFF);\n```", "```cpp\nint __io_putchar(int ch)\n{\n    uart_write(ch);\n    return ch;\n}\n```", "```cpp\n#ifndef __UART_H__\n#define __UART_H__\n#include \"stm32f4xx.h\"\nvoid uart_init(void);\nuart.c, making it callable from other files. We are now ready to test our driver in main.c. Update your main.c file, like so:\n\n```", "```cpp\n\n\t\t\tThis main function simply initializes the UART2 peripheral and then continuously prints the sentence `Hello` `from STM32…`.\n\t\t\tLet’s test the project. To do so, we’ll need to install a program on our computer that can display the data that’s received through the computer’s serial port. In this setup, our development board acts as the transmitter, while the computer is the receiver.\n\n\t\t\t\t1.  **Install a serial** **terminal program**:\n    *   Choose a serial terminal program that’s appropriate for your operating system. Options include *Realterm*, *Tera Term*, *Hercules*, and *Cool Term*.\n    *   If you’re using Windows, I recommend Realterm. You can download it from SourceForge: [https://sourceforge.net/projects/realterm/](https://sourceforge.net/projects/realterm/).\n    *   Follow the installation wizard to complete the setup.\n\t\t\t\t2.  **Prepare to identify your development board’s** **serial port**:\n    1.  Disconnect your development board from your computer.\n    2.  Open Realterm and navigate to the **Port** tab.\n    3.  Click on the **Port** drop-down menu; you’ll see a list of available ports. Since your development board is currently disconnected, its port won’t appear in the list. **Take note** of the listed ports.\n\t\t\t\t3.  **Identify the development** **board’s port**:\n    1.  Close Realterm and connect your development board to the computer.\n    2.  Reopen Realterm and go back to the **Port** drop-down menu. You should now see a new port in the list, which corresponds to your development board.\n    3.  Select this newly added port.\n\t\t\t\t4.  **Set the** **baud rate**:\n\n    Click the **Baud** drop-down menu and select **115200**. This is the baud rate we configured in our driver.\n\n\t\t\t\t5.  **Build and run** **the project**:\n\n    Return to your IDE, build the project, and run the firmware on your microcontroller.\n\n\t\t\t\t6.  `Hello from STM32…` continuously being printed in the Terminal window.\n\n\t\t\t*Figure 1**0**.5* shows the settings described for Realterm:\n\t\t\t![Figure 10.5: Realterm settings](img/B21914_10_5.jpg)\n\n\t\t\tFigure 10.5: Realterm settings\n\t\t\tSummary\n\t\t\tIn this chapter, we learned about the UART protocol, a fundamental communication method that’s widely used in embedded systems. We began by discussing the importance of communication protocols in embedded systems, emphasizing how UART, alongside SPI and I2C, facilitates seamless communication between microcontrollers and peripheral devices.\n\t\t\tNext, we provided a detailed overview of the UART protocol while covering its operational principles, including how data is transmitted asynchronously using start and stop bits, and the role of parity in error checking. We also discussed how the baud rate, a critical aspect of UART communication, is configured to ensure synchronized data transfer between devices.\n\t\t\tThen, we delved into the specifics of the STM32 UART peripheral, examining key registers such as the Status Register (`USART_SR`), Data Register (`USART_DR`), Baud Rate Register (`USART_BRR`), and Control Register 1 (`USART_CR1`). Understanding these registers is essential for configuring UART for effective communication in STM32 microcontrollers.\n\t\t\tFinally, we applied our theoretical understanding by developing a bare-metal UART driver for the STM32F4 microcontroller. This involved initializing the UART peripheral, setting the baud rate, and implementing functions for transmitting data. We also demonstrated how to redirect `printf` output to the UART, enabling easy debugging and data logging through a serial terminal.\n\t\t\tIn the next chapter, we will learn about the **analog-to-digital** **converter** (**ADC**).\n\n```"]