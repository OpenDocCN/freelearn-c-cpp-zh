- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mastering Algorithms with std::vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore the interaction of `std::vector` with C++ **Standard
    Template Library** (**STL**) algorithms to unlock the potential of the C++ STL.
    This chapter delineates the process of efficiently sorting, searching, and manipulating
    vectors, leveraging the algorithms provided in the header. Moreover, focusing
    on lambda expressions, custom comparators, and predicates establishes a clear
    path to customizable, concise, and efficient vector operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting a vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom comparators and predicates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding container invariants and iterator invalidation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting a vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s a common requirement in software: organizing data. In C++, `std::vector`
    is frequently the container of choice for many, and quite naturally, one would
    want to sort its elements. Enter the `std::sort` algorithm, a versatile tool from
    the `<algorithm>` header that elevates your `std::vector` game to the next level.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with std::sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`std::sort` isn’t just for vectors; it can sort any sequential container. However,
    its symbiotic relationship with `std::vector` is particularly noteworthy. At its
    simplest, using `std::sort` to sort a vector is a straightforward task, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After execution, `numbers` would store `{1, 2, 3, 4, 5}`. The beauty lies in
    simplicity: pass the start and end iterators of the vector to `std::sort`, and
    it takes care of the rest.'
  prefs: []
  type: TYPE_NORMAL
- en: The engine under the hood – introsort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the vast array of algorithms offered by the C++ STL, one that consistently
    stands out for its efficacy is `std::sort`. When paired with the dynamic nature
    of `std::vector`, it becomes an unstoppable force, propelling your code’s efficiency
    to new heights. But what makes it tick?
  prefs: []
  type: TYPE_NORMAL
- en: 'To appreciate the genius behind `std::sort`, one must first get acquainted
    with the introsort algorithm. Introsort isn’t just any ordinary sorting algorithm.
    It’s a magnificent hybrid, artfully melding the strengths of three celebrated
    sorting algorithms: quicksort, heapsort, and insertion sort. This combination
    ensures that `std::sort` can adapt and perform optimally in myriad scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While we could plunge deep into algorithmic intricacies, what truly matters
    for everyday use is this: introsort ensures that `std::sort` remains blazingly
    fast. The underlying mechanics have been refined and optimized to suit various
    data patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency unparalleled – O(n log n)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For those not deep into computer science jargon, time complexities might sound
    like arcane chants. However, there’s a simple beauty to them. When we say that
    `std::sort` has an average time complexity of *O(n log n)*, we express its commitment
    to speed.
  prefs: []
  type: TYPE_NORMAL
- en: Think of *O(n log n)* as a promise. Even as your vector grows, scaling to vast
    sizes, `std::sort` ensures that the number of operations doesn’t explode uncontrollably.
    It strikes a balance, ensuring that the time taken to sort grows at a manageable
    rate, making it a reliable choice for even the largest vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting in descending order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While ascending order is the default behavior, there are scenarios where you’d
    want the largest values at the front. C++ has got you covered. With the aid of
    `std::greater<>()`, a predefined comparator from the `<functional>` header, you
    can sort your vector in descending order as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After execution, if `numbers` originally had `{1, 2, 3, 4, 5}`, it would now
    store `{5, 4, 3,` `2, 1}`.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting custom data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vectors aren’t limited to primitive types. You might have vectors of custom
    objects. To demonstrate this, we will use an example. We will use a `Person` class
    and a vector of `Person` objects. The goal is to sort the vector first by name
    (using an inline comparator) and then by age (using a lambda function object as
    a comparator).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of a custom sort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We define a `Person` class with a name and age as attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also provide an inline comparator function (`compareByName`) to sort `Person`
    objects by name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then sort the `people` vector using the inline comparator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Afterward, we sort the `people` vector by age using a lambda function as a comparator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The results are displayed to verify that the sorting operations work as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pitfalls and precautions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s a temptation to view `std::sort` as a magic wand, but remember that
    while it is powerful, it is not omniscient. The algorithm assumes that the range
    `(``begin, end)` is valid; passing invalid iterators can lead to undefined behavior.
    Additionally, the comparator provided must establish a strict weak ordering; failing
    to do so might produce unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: Strict weak ordering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The term `std::sort`. This concept pertains to the comparison function that
    is used to order the elements in a collection. Let’s break it down for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strictness**: This means that for any two distinct elements *a* and *b*,
    the comparison function comp must not report both *comp(a, b)* and *comp(b, a)*
    as true. In simpler terms, if *a* is considered less than *b*, then *b* cannot
    be less than *a*. This ensures a consistent ordering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Weakness**: The term *weak* in this context refers to the allowance of equivalence
    classes. In a strict ordering (such as a strict total ordering), two different
    elements cannot be equivalent. However, in a strict weak ordering, different elements
    can be considered equivalent. For example, if you have a list of people sorted
    by age, two people of the same age are in the same equivalence class even if they
    are different individuals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transitivity of comparison**: If *comp(a, b)* is true and *comp(b, c)* is
    true, then *comp(a, c)* must also be true. This ensures that the ordering is consistent
    across the entire set of elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transitivity of equivalence**: If *a* is not less than *b* and *b* is not
    less than *a* (meaning they are equivalent in terms of the sorting criteria),
    and similarly *b* and *c* are equivalent, then *a* and *c* must also be considered
    equivalent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comparator providing a strict weak ordering allows `std::sort` to correctly
    and efficiently sort elements. It ensures that the order is consistent, allows
    for the grouping of equivalent elements, and respects the logical transitivity
    both in terms of comparison and equivalence. Failing to adhere to these rules
    can lead to unpredictable behavior in sorting algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s illustrate the concepts mentioned in the text with a code example. We
    will show what happens when an invalid range is provided to `std::sort`, and what
    can occur if the comparator doesn’t establish a strict weak ordering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We see how mistakenly providing an end iterator beyond the vector’s end can
    lead to undefined behavior. (This portion is commented out for safety reasons.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We provide a comparator that does not maintain a strict weak ordering because
    it returns true even when two numbers are equal. Using such a comparator with
    `std::sort` can lead to unexpected results or other undefined behaviors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `std::sort` at your disposal, you have an efficient and adaptable tool.
    You can handle a broad spectrum of sorting tasks with confidence and finesse by
    understanding its default behaviors, harnessing the power of standard comparators,
    and crafting custom comparators for unique scenarios. As we proceed in this chapter,
    remember this foundational skill as we delve deeper into the vast landscape of
    STL algorithms and `std::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we optimized element sorting in `std::vector` with the `std::sort`
    algorithm, unpacking its introsort mechanism—a hybrid of quicksort, heapsort,
    and insertion sort—to ensure top performance, usually with *O(n log n)* complexity.
    This understanding is pivotal for data processing efficiency in algorithmic design
    and high-performance application development.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll shift our focus from sorting to searching, contrasting the linear
    and binary search techniques to effectively find elements in `std::vector`, dissecting
    their efficiency in various use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Searching elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finding elements in a collection is as crucial as storing them. In the C++ STL,
    there’s a buffet of algorithms tailored for searching. Whether `std::vector` is
    sorted or unsorted, the STL provides an array of functions that’ll lead you straight
    to your target using the classic linear or faster binary search. With `std::vector`,
    these techniques become indispensable in many scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Linear search with std::find
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most basic and intuitive searching algorithm is the **linear search**. If
    you’re not sure about the order of your vector or it is simply unsorted, this
    method comes to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider `std::vector<int> numbers = {21, 12, 46, 2};`. To find the position
    of the element `46`, we will use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the element exists, it will point to its location; otherwise, it’ll point
    to `numbers.end()`. It’s a direct, no-frills approach, checking each element from
    the beginning to the end. However, the time it takes grows linearly with the size
    of the vector, making it less ideal for massive datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Binary search techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Few algorithmic searching strategies stand out for their sheer elegance and
    efficiency, quite like the `std::vector`, binary search offers a masterclass in
    how strategic thinking can transform how we tackle problems. Let’s delve deeper
    into the world of halves to unearth the brilliance behind binary search.
  prefs: []
  type: TYPE_NORMAL
- en: 'Binary search operates on a beautifully simple principle: divide and conquer.
    Instead of tediously scanning each element one by one, binary search makes a beeline
    to the center of the dataset. A quick assessment determines whether the desired
    element lies in the dataset’s first or second half. This insight allows it to
    dismiss half of the remaining elements, continually narrowing down the search
    field until the desired element emerges.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the binary search to work its magic, there’s one non-negotiable requirement:
    the dataset, or `std::vector`, must be sorted in our context. This precondition
    is vital because the efficiency of binary search hinges on predictability. Each
    decision to halve the search space is made with the confidence that elements are
    organized in a specific order. This structured arrangement allows the algorithm
    to confidently exclude large data portions, making the search incredibly efficient.'
  prefs: []
  type: TYPE_NORMAL
- en: Using std::lower_bound and std::upper_bound
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'But what if you want more than just existence? Sometimes, the questions we
    seek to answer are more nuanced: If this element isn’t in the vector, where would
    it fit best based on the current ordering? Or, given multiple occurrences of an
    element, where do they commence or conclude? The C++ STL offers two powerful tools
    to address these queries: `std::lower_bound` and `std::upper_bound`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `std::lower_bound` function plays a pivotal role in the realm of sorted
    vectors. When presented with a specific element, this function ventures to find
    the position where this element either first appears in the vector or where it
    would be rightly placed, ensuring the vector’s order remains intact. It effectively
    returns an iterator pointing to the first element that is not less than (i.e.,
    greater than or equal to) the specified value.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if our vector contains `{1, 3, 3, 5, 7}` and we’re seeking `3`
    using `std::lower_bound`, the function would point to the first occurrence of
    `3`. However, if we were searching for `4`, the function would indicate the position
    right before `5`, highlighting where `4` would fit best while preserving the vector’s
    sorted nature.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `std::upper_bound` provides insight into the ending of a
    sequence. When given an element, it identifies the first position where an element
    greater than the specified value resides. Effectively, if you have multiple occurrences
    of an element, `std::upper_bound` will point just past the last occurrence.
  prefs: []
  type: TYPE_NORMAL
- en: Referring back to our vector `{1, 3, 3, 5, 7}`, if we employ `std::upper_bound`
    in search of `3`, it would direct us to the position right before `5`, showcasing
    the end of the `3` sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a complete example of using `std::upper_bound` and `std::lower_bound`
    with `std::vector` of integers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the preceding code, the following output will be generated for
    the specified values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The explanation of the code example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For `std::lower_bound` with `3`, it returns an iterator pointing to the first
    occurrence of `3`, which is at index `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `std::lower_bound` with `4`, it indicates where `4` would fit best, right
    before `5` (i.e., at index `3`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `std::upper_bound` with `3`, it points just past the last occurrence of
    `3`, right before `5` (i.e., at index `3`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While confirming the existence of an element is undoubtedly essential, the actual
    depth of algorithmic exploration with `std::vector` comes when we pose more detailed
    questions. With the combined capabilities of `std::lower_bound` and `std::upper_bound`,
    we begin to appreciate the data analysis capabilities supported by the STL.
  prefs: []
  type: TYPE_NORMAL
- en: Binary search versus linear search – efficiency and versatility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within the realm of algorithmic searching techniques, both binary and linear
    search emerge as fundamental strategies. Each has unique strengths and ideal use
    cases, mainly applied to the versatile `std::vector`. Let’s delve deeper into
    understanding the nuances of these two approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Binary search – the speedster with a condition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Binary search is a highly efficient method renowned for its logarithmic time
    complexity. This efficiency translates into significant speed, especially when
    dealing with large vectors. However, this swiftness has a caveat: `std::vector`
    must be sorted. The essence of binary search is its ability to eliminate half
    of the remaining elements with each step, making educated guesses based on the
    order of the elements.'
  prefs: []
  type: TYPE_NORMAL
- en: But what happens if this order isn’t maintained? Simply put, the results become
    unpredictable. If a vector isn’t sorted, binary search might fail to locate an
    element even if it exists or return inconsistent results. Thus, it is imperative
    to ensure a sorted landscape before venturing into a binary search on `std::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: Linear search – the reliable workhorse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linear search, on the other hand, is characterized by its straightforward approach.
    It methodically checks each element in the vector until it finds the desired item
    or concludes it isn’t present. This simplicity is its strength; the method doesn’t
    require any prior conditions on the arrangement of elements, making it versatile
    and applicable to sorted and unsorted vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this step-by-step examination comes at a cost: linear search has a
    linear time complexity. While it might be efficient for smaller vectors, its performance
    can be noticeably slower as the size of the vector increases, especially when
    compared to the swift binary search in sorted vectors.'
  prefs: []
  type: TYPE_NORMAL
- en: Searching is fundamental, and mastering linear and binary techniques amplifies
    your proficiency with `std::vector`. Whether you’re hunting down a single element,
    gauging the position of an item in a sorted sequence, or finding the range of
    an element’s occurrences, the STL grants you robust and efficient tools to accomplish
    these tasks. As you venture further into `std::vector` and the STL, understanding
    these searching methods is a bedrock, ensuring that no element remains elusive
    in your C++ journey.
  prefs: []
  type: TYPE_NORMAL
- en: This section honed our skills in element discovery within `std::vector`, starting
    with `std::find` for linear searches and advancing to binary searches with `std::lower_bound`
    and `std::upper_bound` for sorted data. Unlike linear search, we recognized binary
    search’s speed advantage, though it requires a pre-sorted vector. Choosing the
    correct search technique is crucial for performance optimization in various applications.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll next explore altering vector contents with methods such as `std::copy`,
    focusing on practical manipulation techniques and the key considerations for preserving
    data structure integrity and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vectors in C++ are dynamic arrays that not only store data but offer a suite
    of operations to manipulate that data, especially when paired with the algorithms
    provided by the STL. These algorithms allow developers to optimize data movement
    and transformation tasks with elegance. Let’s delve into the art of manipulating
    `std::vector` with some powerful algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming with std::copy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine you’ve got one vector and wish to copy its elements to another. Simple
    looping might come to mind, but there’s a more efficient and expressive way: `std::copy`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider two vectors as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Copying the elements is as straightforward as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`destination` holds `{1, 2, 3, 4, 5}`. It’s worth noting that the `destination`
    vector should have enough space to accommodate the copied elements.'
  prefs: []
  type: TYPE_NORMAL
- en: Reversing elements with std::reverse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, you might need to reverse the elements of a vector. Instead of manually
    swapping elements, `std::reverse` comes to the rescue, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The vector numbers now read `{5, 4, 3,` `2, 1}`.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating vectors with std::rotate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another handy algorithm for manipulating vectors is `std::rotate`, which allows
    you to rotate elements. Let’s say you have a vector as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to rotate it so that `3` becomes the first element, you will do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Your vector `values` now hold `{3, 4, 5, 1, 2}`. This shifts the elements, wrapping
    them around the vector.
  prefs: []
  type: TYPE_NORMAL
- en: Filling a vector with std::fill
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There might be scenarios where you wish to reset or initialize all vector elements
    to a specific value. `std::fill` is the perfect tool for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Every element in the `data` is now `42`.
  prefs: []
  type: TYPE_NORMAL
- en: Putting manipulation to use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A music streaming service wants to allow users to manage their playlists in
    the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the year, they have a unique feature: users can take their top
    10 songs and move them to the beginning of the playlist as a *Year* *in Review*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can reverse their playlist to rediscover old songs they haven’t listened
    to in a while for a specific promotion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Occasionally, when a user buys a new album, they like to insert its tracks in
    the middle of their current playlist and rotate the old favorites to the end to
    have a mix of new and old songs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a fresh start in spring, users can fill their playlist with calm and refreshing
    spring-themed music.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows how users can manage their playlists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output (truncated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `std::rotate` function brings the user’s top 10 songs to the beginning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `std::reverse` function helps rediscover old songs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user’s new album purchase demonstrates a more practical use of `std::rotate.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `std::fill` function fills the playlist with spring-themed songs for a fresh
    start.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considerations in manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While these functions provide a robust and efficient way to transform vectors,
    there are a few things to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the destination vectors, especially with functions such as `std::copy`
    have adequate space to accommodate the data. Using `std::back_inserter` can be
    helpful if you’re unsure about the size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Algorithms such as `std::rotate` are highly efficient. They minimize the number
    of element moves. However, the order in which elements are shifted might not be
    apparent initially. Practicing with different scenarios will instill a more precise
    understanding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions such as `std::fill` and `std::reverse` work in place, transforming
    the original vector. Always ensure you won’t need the original order or values
    before applying these functions or backing up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vectors paired with STL algorithms empower developers to create efficient, expressive,
    and concise manipulations. Whether you’re copying, rotating, reversing, or filling,
    there’s an algorithm tailored to the task. As you continue your journey with `std::vector`,
    embracing these tools ensures you handle data with finesse and speed, crafting
    efficient code that is a pleasure to read and write.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ve mastered modifying the contents of `std::vector` with
    STL algorithms, particularly `std::copy`, central to performing secure and efficient
    data operations. We’ve also covered critical considerations such as avoiding iterator
    invalidation to maintain data integrity and performance. This expertise is invaluable
    for C++ developers, as streamlining the execution of complex data manipulations
    is critical in practical applications.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we’ll delve into customizing STL algorithm behavior using comparators
    and predicates, enabling the definition of bespoke sorting and searching criteria
    for user-defined data types.
  prefs: []
  type: TYPE_NORMAL
- en: Custom comparators and predicates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with `std::vector` and STL algorithms, you’ll often encounter scenarios
    where the default behavior doesn’t fit the bill. Sometimes, the way two elements
    are compared or the criteria for selecting elements must deviate from the norm.
    Here’s where custom comparators and predicates come into play. They are a testament
    to the power and flexibility of the C++ STL, allowing you to inject your logic
    seamlessly into established algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding comparators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `bool`. It’s used to dictate the order of elements, especially in sorting
    or searching operations. By default, operations such as `std::sort` use the `(<)`
    operator to compare elements, but with a custom comparator, you can redefine this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a `std::vector` of integers, and you want to sort them in descending
    order. Instead of writing another algorithm, you can use `std::sort` with a comparator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the lambda expression acts as a comparator, reversing the usual
    less-than behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The power of predicates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While comparators define ordering, predicates help in making decisions. A `bool`
    like a comparator. Predicates are commonly used with algorithms that need to make
    a selection or decision based on some criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if you wanted to count how many numbers in a vector are even,
    you could employ `std::count_if` with a predicate as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, the lambda predicate checks whether a number is even, allowing `std::count_if`
    to tally accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Crafting effective comparators and predicates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the best practices to be kept in mind to craft effective
    comparators and predicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clarity**: Ensure that the logic within is clear. The purpose of a comparator
    or predicate should be evident upon reading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Statelessness**: A comparator or predicate should be stateless, meaning it
    should not have any side effects or change behavior between calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency**: Since comparators and predicates might be called repeatedly
    in algorithms, they should be efficient. Avoid unnecessary computations or calls
    within them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-defined structs and classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While lambdas are concise and convenient, defining a struct or class allows
    us to define behavior that is more complex or better lends itself to reusability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a vector of students with names and grades. If you want to sort by
    grade and then by name, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'While the lambda approach works, using a struct might be clearer for complex
    logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Custom comparators and predicates are like giving you the keys to the STL’s
    engine room. They allow you to harness the raw power of the library but tailor
    it precisely to your needs. This fine-tuned control makes C++ a standout language
    for algorithmic tasks and data processing.
  prefs: []
  type: TYPE_NORMAL
- en: This section introduced us to custom comparators and predicates, enhancing our
    ability to sort and filter elements in `std::vector`. We learned how to define
    sorting criteria with comparators and set conditions with predicates, particularly
    for user-defined types, allowing for intricate data organization within algorithms.
    Understanding and utilizing these tools is crucial for developers to customize
    and optimize data operations in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll explore container invariants and iterator invalidation, learning
    to manage container stability and avoid the common issue of invalidation, which
    is essential for ensuring robustness, especially in multi-threaded contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding container invariants and iterator invalidation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within the C++ STL, there lies a crucial consideration often overlooked by
    many: `std::vector`, one such invariant might be that the elements are stored
    in contiguous memory locations. However, certain operations can disrupt these
    invariants, leading to potential pitfalls such as iterator invalidation. Armed
    with this knowledge, we can craft more resilient and efficient code.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding iterator invalidation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A study of `std::vector` is incomplete without a grasp of **iterator invalidation**.
    Iterator invalidation is akin to trying to use a bookmark after someone’s reshuffled
    the pages in your book. You think you’re pointing to one location, but the data
    there might have changed or ceased to exist.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, when we push an element to a vector (`push_back`), the element
    is added without any hitches if there’s enough reserved memory (`capacity`). But,
    if the vector needs to allocate new memory due to space constraints, it may relocate
    all its elements to this new memory block. As a result, any iterator, pointer,
    or reference pointing to an element in the old memory block will now be invalidated.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, other operations, such as `insert`, `erase`, or `resize`, can also
    invalidate an iterator. The crux is to recognize when these operations might disrupt
    the vector’s layout and be prepared to deal with the consequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a code example that demonstrates iterator invalidation with
    `std::vector` and how certain operations might disrupt the container’s layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We first set an iterator to point to the third element of the `numbers` vector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After pushing many elements to the vector, the original memory block might be
    reallocated to a new one, causing the iterator to become invalidated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We further demonstrate how the `insert` and `erase` operations can invalidate
    an iterator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s emphasized that using an invalidated iterator can lead to undefined behavior,
    and therefore, one should always re-acquire iterators after modifying a vector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always be cautious after modifying operations on a vector, as they might invalidate
    your iterators. Re-acquire your iterators after such operations to ensure they’re
    valid.
  prefs: []
  type: TYPE_NORMAL
- en: Strategies to counteract invalidation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a clue about when our iterators might become invalidated, it
    is time to uncover ways to circumvent or handle these scenarios gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: '`reserve` method. This pre-allocates memory, reducing the need for reallocation
    and subsequent iterator invalidation during additions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prefer positions over iterators**: Consider storing positions (e.g., index
    values) instead of storing iterators. After an operation that may lead to iterator
    invalidation, you can easily recreate a valid iterator using the position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refresh iterators post-operation**: After any disruptive operation, avoid
    using any old iterators, pointers, or references. Instead, obtain fresh iterators
    to ensure they point to the correct elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<algorithm>` header offers many algorithms optimized for containers such as
    `std::vector`. These often handle potential invalidations internally, safeguarding
    your code against such pitfalls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caution with custom comparators and predicates**: When using algorithms that
    require comparators or predicates, ensure they don’t internally modify the vector
    in a way that could cause invalidation. Maintain the principle of separation of
    concerns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at an example that integrates key strategies to avoid iterator invalidation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This example does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrates how to use `reserve` to pre-allocate memory, anticipating the size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shows positions (index values) instead of iterators to handle potential invalidations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refreshes iterators after a disruptive operation (`insert`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses the `<algorithm>` header (i.e., `std::sort` and `std::count_if`) that is
    optimized for containers and respect invariants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emphasizes the importance of read-only operations (through the `isOdd` lambda)
    to avoid possible invalidations. (The `isOdd` lambda function is just a read-only
    operation and doesn’t modify the vector, ensuring we don’t have to worry about
    invalidation.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with invalidation in multi-threaded scenarios
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While iterator invalidation in a single-threaded application is easier to manage,
    things can get trickier in multi-threaded contexts. Imagine one thread modifying
    a vector while another attempts to read from it using an iterator. The chaos!
    The catastrophe! The following are the ways to tackle invalidation in multi-threaded
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use mutexes and locks**: Safeguard sections of your code that modify the
    vector with **mutexes**. This ensures that only one thread can change the vector
    at a given time, preventing concurrent operations that might lead to unpredictable
    invalidations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use atomic operations**: Some operations might be made atomic, ensuring they’re
    completed fully without interruption, reducing the chances of unsynchronized access
    and modification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consider thread-safe containers**: If multi-threading is central to your
    application, consider using **thread-safe containers** designed to handle concurrent
    accesses and modifications without compromising on invariants.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutex
  prefs: []
  type: TYPE_NORMAL
- en: A mutex, short for **mutual exclusion**, is a synchronization primitive used
    in concurrent programming to protect shared resources or critical sections of
    code from being accessed by multiple threads simultaneously. By locking a mutex
    before accessing a shared resource and unlocking it afterward, a thread ensures
    that no other thread can access the resource while it’s being used, thus preventing
    race conditions and ensuring data consistency in multi-threaded applications.
  prefs: []
  type: TYPE_NORMAL
- en: Thread-safe containers
  prefs: []
  type: TYPE_NORMAL
- en: A thread-safe container refers to a data structure that allows multiple threads
    to access and modify its contents concurrently without causing data corruption
    or inconsistencies. This is achieved through internal mechanisms such as locking
    or atomic operations that ensure synchronization and mutual exclusion, thereby
    maintaining the integrity of the container’s data even in a multi-threaded environment.
    Such containers are crucial in concurrent programming for safe and efficient data
    sharing between threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a practical example of multi-threaded access to `std::vector`.
    This example will demonstrate the use of mutexes to prevent concurrent modifications,
    ensuring thread safety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This example illustrates the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: We use a mutex (`vecMutex`) to protect the shared `std::vector` from concurrent
    access and modification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `add_to_vector` and `print_vector` functions lock the mutex using `std::lock_guard`,
    ensuring exclusive access to the vector during their scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `std::thread` to run functions that concurrently modify or read from
    the vector. The use of mutexes ensures that these operations are thread-safe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, while mutexes safeguard against concurrent modifications, they can
    also introduce potential deadlocks and reduce parallelism. If multi-threading
    is deeply integrated into your application, you might consider other thread-safe
    containers or advanced synchronization techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and respecting container invariants is paramount in harnessing
    the full power of STL containers and the `<algorithm>` header. Knowing when and
    why certain invariants might be disrupted allows for the creation of robust, efficient,
    and reliable code. As we continue our exploration of algorithms beyond `std::vector`,
    always keep these principles in mind.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we addressed the importance of preserving `std::vector` stability
    and the risks of iterator invalidation during container modification. We identified
    actions that cause invalidation and their potential to disrupt program integrity.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding iterator behavior is vital for bug prevention and ensuring the
    robustness of our applications. We’ve also learned methods to mitigate invalidation
    risks, maintaining vector consistency throughout operations that might jeopardize
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we have deepened our understanding of the STL through
    the lens of `std::vector` and its interaction with various algorithms. We commenced
    with sorting vectors, where we explored the `std::sort` algorithm and its underlying
    engine, introsort, appreciating its *O(n log n)* efficiency. We progressed to
    searching within vectors, contrasting the conditions and efficiencies of linear
    and binary search techniques.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter then guided us through effective vector manipulation, including
    transformation with `std::copy` and the considerations necessary to prevent performance
    degradation or logical errors. We learned to use custom comparators and predicates
    to extend the functionality of standard algorithms when working with user-defined
    structs and classes. Finally, we explored container invariants and iterator invalidation,
    acquiring strategies to maintain data integrity even in complex, multi-threaded
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: Critically, this information provides us with practical and detailed insights
    into how to leverage `std::vector` effectively. Mastery of these algorithms allows
    developers to write efficient, robust, and adaptable code to various programming
    challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will shift our focus from the technical intricacies of algorithms to
    a broader discussion on why `std::vector` should be our default container of choice.
    We will compare `std::vector` with other containers, dive into its memory advantages,
    and reflect on practical use cases, from data processing to game development.
    This will underscore the versatility and efficiency of `std::vector`, solidifying
    its status as a safe and powerful default choice, yet one among many tools available
    to the adept C++ programmer.
  prefs: []
  type: TYPE_NORMAL
