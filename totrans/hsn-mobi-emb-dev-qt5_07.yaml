- en: Qt Network for Communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Networking is almost as important to mobile devices as the device being mobile.
    Without networking, data would have to be physically moved from one place to another.
    Luckily, Qt has extensive networking features in `QNetwork`. In this chapter,
    we will discuss the following APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QNetworkReply`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QNetworkRequest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QDnsLookup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QHostInfo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QLocalServer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QTcpSocket`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To show available Wi-Fi networks that are nearby, we will also go over the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QNetworkSession`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QNetworkConfiguration`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will also learn how to use Qt APIs for standard networking tasks, such as
    **Domain Name Service** (**DNS**) lookups, download and upload files, and how
    to use Qt's socket classes for communication.
  prefs: []
  type: TYPE_NORMAL
- en: High level – request, reply, and access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networking in Qt is quite feature-rich. Networking in Qt Quick is more behind
    the scenes than in your face. In **Qt Modeling Language** (**QML**), you can download
    remote components and use them in your application, but any other arbitrary download
    or network functionality you will have to bake yourself in the C++ backend or
    use JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Even though `QNetworkRequest`, `QNetworkReply`, and `QNetworkAccessManager`
    are all used to make network requests, let's split them up and see how to use
    them.
  prefs: []
  type: TYPE_NORMAL
- en: QNetworkRequest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QNetworkRequest` is a part of the access functionality. It constructs a `request`,
    which can be one of the following verbs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: `get(...)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: `post(...)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: `put(...)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: `deleteResource(...)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEAD`: `head(...)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also send custom verbs using `sendCustomRequest`, which takes the custom
    verb as a `QByteArray` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Headers can be set as known headers using `setHeader` and can be one of the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ContentDispositionHeader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ContentTypeHeader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ContentLengthHeader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocationHeader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LastModifiedHeader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CookieHeader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetCookieHeader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserAgentHeader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ServerHeader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raw or custom headers can be set with `setRawHeader`. HTTP attributes can help
    to control the request cache, redirect, and cookies. They can be set with, you
    guessed it, `setAttribute`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's put this into the following code.
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter05-1` directory,
    in the `cp5` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the networking module, in the `.pro` project, add `network` to the `QT`
    variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can now use Qt Networking.
  prefs: []
  type: TYPE_NORMAL
- en: '`QNetworkRequest` is what needs to be used to request operations from the network
    such as `get` and `put`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple implementation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`QNetworkRequest` can also take `QUrl` as its argument. `QNetworkRequest` is
    not based on `QObject`, so it has no parent, nor does it have any of its own signals.
    All communication is done through `QNetworkAccessManager`.'
  prefs: []
  type: TYPE_NORMAL
- en: The one signal you want to connect to is the `finished` signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose I have some form data I need to transfer; I would need to add a standard
    header with `setHeader`. I could also add the following custom header I call `X-UUID`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a viable `QNetworkRequest`, we need to send it to `QNetworkAccessManager`.
    Let's take a look at how we can do that.
  prefs: []
  type: TYPE_NORMAL
- en: QNetworkAccessManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bring in the manager—`QNetworkAccessManager` (**QNAM**). It is used to send
    and receive asynchronous requests over a network. Usually, there is one instance
    of QNAM in an application, as here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: At its simplest, you can make a QNAM request using the `get`, `put`, `post`,
    `deleteResource`, or `head` functions.
  prefs: []
  type: TYPE_NORMAL
- en: QNAM uses signals to transfer data and request information and the `finished()`
    signal is used to signal when a request has finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a signal handler for that, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This would call your `replyFinished` slot with the data and headers within
    the `QNetworkReply` argument, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, call the `get` method on `QNetworkAccessManager` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It's as simple as that to download something! QNAM will work its magic and download
    the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also just as easy a method to create a file upload. Of course, your web
    server needs to support the `put` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The source code can be found on the Git repository under the `Chapter05-2` directory,
    in the `cp5` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to send some query parameters in the URL, you can use `QUrlQuery`
    to construct the `form` query data, and then send the `request` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Form data can be uploaded with the `post` function as a `QByteArray` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To send a multipart form data, such as form data and an image, you can use
    `QHttpMultiPart` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Of course, none of these examples keeps track of the reply. `QNetworkReply`
    is returned by the `get`, `post`, and `put` methods of `QNetworkAccessManager`,
    which can be used to track download or upload progress or if there are any errors.
  prefs: []
  type: TYPE_NORMAL
- en: QNetworkReply
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All calls to QNAM's `get`, `post`, and so on, will return `QNetworkReply`.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to delete this pointer, otherwise it will leak memory, but do
    not delete it in the `finished` signal handler. You can use `deleteLater()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`QNetworkReply` has an interesting signal we would most likely need to handle.
    Let''s start with the two most important—`error` and `readyRead`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s handle that `QNetworkReply` properly. Since we do not have the valid
    object beforehand, we need to connect the signals after the network request action.
    It seems a bit backward to me, but this is the way it needs to be and it works.
    The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'I am using the legacy style of signal connections, but you could and should
    write connections like the following because it allows compile time checking for
    syntax and other errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So, now we have done a request and are waiting for a reply from the server.
    Let's look at the signal handlers one by one.
  prefs: []
  type: TYPE_NORMAL
- en: '`error(QNetworkReply::NetworkError)` is emitted when there is an error with
    the error code as argument. If you need a user-friendly string, you can retrieve
    that with `QNetworkReply::errorString()`. `finished()` is emitted when the request
    is finished. The reply is still open, so you can read it here: `readyRead()` .Since
    the reply is derived from `QIODevice`, it has the `readyRead` signal, which is
    emitted whenever more data is ready to read.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On large downloads, you might want to monitor the progress of the download,
    which is a common thing to do. Usually, every download has some kind of progress
    bar. `QNetworkReply` emits the `downloadProgress(qint64 bytesReceived, qint64
    bytesTotal)` signal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There is the corresponding `uploadProgress` for uploads.
  prefs: []
  type: TYPE_NORMAL
- en: '`preSharedKeyAuthenticationRequired(QSslPreSharedKeyAuthenticator *authenticator)`
    gets emitted when the download needs authentication. The `QSslPreSharedKeyAuthenticator`
    object should be loaded with the pre-shader key and other details to authenticate
    the user.'
  prefs: []
  type: TYPE_NORMAL
- en: The `sslErrors(const QList<QSslError> &errors)` signal is called when **Secure
    Sockets Layer** (**SSL**) encounters problems, including certificate verification
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: '`QNetworkManager` can also do simple **File Transfer Protocol** (**FTP**) transfers.'
  prefs: []
  type: TYPE_NORMAL
- en: QFtp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two ways to use FTP with Qt. `QNetworkAccessManager` has simple FTP
    `get` and `put` support, we can easily use that.
  prefs: []
  type: TYPE_NORMAL
- en: 'FTP servers usually require some sort of username and password. We use `setUserName()`
    and `setPassword()` of `QUrl` to set these, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The source code can be found on the Git repository under the `Chapter05-5` directory,
    in the `cp5` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we know the file''s name, we need to add that to the `url`, as it will
    use this to write the fail, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, set the request `url`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can hook up slots to the `QNetworkReply` signals, once we call `put` on
    the QNAM, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not forget that `error` signal needs `QOverload` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you need to do more complicated things other than `get` and `put`, you will
    need to use something else besides `QNetworkAccessManager`.
  prefs: []
  type: TYPE_NORMAL
- en: '`QFtp` is not included with Qt, but you can access the standalone `QFtp` module
    that was ported from Qt 4 to run with Qt 5 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We will need to build `QFtp`, so we can open the `qtftp.pro` in Qt Creator.
    Run Build and install that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the command line the commands would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We will need to install this into Qt 5.12, so in Qt Creator, navigate to Projects
    | Build | Build Steps and select Add Build Step | Make. In the arguments field,
    type `install`.
  prefs: []
  type: TYPE_NORMAL
- en: Build this and it will also install.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the project''s `.pro` file, to tell `qmake` to use the `network` and `ftp`
    modules, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QT += network ftp`'
  prefs: []
  type: TYPE_NORMAL
- en: '`QFtp` works very typically; log in, do operations, and then log out, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We connect to the `commandFinished` signal, which can tell us whether there
    was an error.
  prefs: []
  type: TYPE_NORMAL
- en: The `stateChanged` signal will tell us when we are logged in and the `dataTransferProgress` signal
    will tell us when bytes are being transferred.
  prefs: []
  type: TYPE_NORMAL
- en: '`QFtp` supports other operations, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`list`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mkdir`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rmdir`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rename`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QNAM also touches upon my favorite part of Qt Network—Bearer Management. Let's
    move on to learning about Bearer Management.
  prefs: []
  type: TYPE_NORMAL
- en: Bearer Management of good news
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bearer Management was meant to facilitate user control over the network connections.
    There are `open` and `close` functions for found connections. One thing it does
    not do is actually configure these connections. They must already be configured
    by the system.
  prefs: []
  type: TYPE_NORMAL
- en: It is also meant to be able to group connections together to make it easier
    to smoothly switch between connections, such as migrating from Wi-Fi to mobile
    cellular data, somewhat like **Media Independent Handover** (**MIH**) or also
    **Unlicensed Mobile Access** (**UMA**) specification. If you are interested in
    an open source library to help with handovers, look at Open MIH at SourceForge.
  prefs: []
  type: TYPE_NORMAL
- en: At the time Qt's Bearer Management was first developed, Symbian was the most
    used and arguably the most important mobile OS. Symbian had the ability to seamlessly
    migrate connections between technologies without dropping the connection or data,
    kind of like the way mobile phone connections get migrated from cell tower to
    cell tower.
  prefs: []
  type: TYPE_NORMAL
- en: Apple seems to call this Wi-Fi Assist; Samsung has Auto Network Switching.
  prefs: []
  type: TYPE_NORMAL
- en: Years ago, mobile data connections were very expensive, so the connection was
    often closed after a specific upload or download happened. The opening and closing
    of connections was more dynamic and needed automatic controls.
  prefs: []
  type: TYPE_NORMAL
- en: At any rate, `QtConfigurationManager` will use what the system supports; it
    does not implement its own connection data migration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt has the following three main classes that make up Bearer Management:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QNetworkConfiguration`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QNetworkConfigurationManager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QNetworkSession`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also `QBearerEngine`, which is the base class for bearer plugins.
  prefs: []
  type: TYPE_NORMAL
- en: QNetworkConfiguration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QNetworkConfiguration` represents a network connection configuration, such
    as a Wi-Fi connection to a particular access point with its **Service Set Identifier**
    (**SSID**) as the configuration name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The network configuration can be one of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QNetworkConfiguration::InternetAccessPoint`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This type is a typical access point, such as a Wi-Fi **Access Point** (**AP**)
    or it could represent an Ethernet or mobile network.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QNetworkConfiguration::ServiceNetwork`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ServiceNetwork` type is a group of access points known as a **Service Network
    Access Point** (**SNAP**). The system will determine which of the service networks
    is best to connect with based on criteria such as cost, speed, and availability.
    A configuration of the `QNetworkConfiguration::ServiceNetwork` type may also roam
    between its children `QNetworkConfiguration::InternetAccessPoint`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QNetworkConfiguration::UserChoice`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This type can represent a user preferred configuration. It was used by Nokia's
    Maemo and Symbian platforms in which the system could pop up a dialog asking the
    user to choose which AP was best. None of the current bearer backends use this
    type of `QNetworkConfiguration`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Often, we need to know the type of bearer, which is to say, what communication
    protocol the connection is using. Let's find out about `BearerType`.
  prefs: []
  type: TYPE_NORMAL
- en: QNetworkConfiguration::BearerType
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is an `enum` that specifies what the underlying technology of `QNetworkConfiguration`
    is and can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BearerEthernet`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BearerWLAN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bearer2G`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BearerCDMA2000`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BearerWCDMA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BearerHSPA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BearerBluetooth`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BearerWiMAX`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BearerEVDO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BearerLTE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bearer3G`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bearer4G`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can be determined by calling the `bearerType()` function of the `QNetworkConfiguration`
    object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can open or connect.
  prefs: []
  type: TYPE_NORMAL
- en: QNetworkConfiguration::StateFlags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`StateFlags` are an OR''d `||`,combination of the `StateFlag` values, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Defined`: Known to the system but not yet configured'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Discovered`: Known and configured, can be used to `open()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Active`: Currently online'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `QNetworkConfiguration` that has an `Active` flag will also have the `Discovered`
    and `Defined` flags as well. You can check to see whether a configuration is active
    by doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: QNetworkConfigurationManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QNetworkConfigurationManager` allows you to obtain `QNetworkConfigurations`
    of the system, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It's always wise to wait for the `updateCompleted` signal from `QNetworkConfigurationManager`
    before using it, to be sure the configurations are set up properly.
  prefs: []
  type: TYPE_NORMAL
- en: A default configuration is the configuration that the system defines as the
    default. It could have a state of `Active` or just `Discovered`.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to simply determine whether the system is currently online, `manager->isOnline();`
    will return `true` if the system is considered online. Online is when it is connected
    to another device via a network, which may or may nor be the internet, and may
    or may not be routed correctly. So, it could be online, but cannot access the
    internet.
  prefs: []
  type: TYPE_NORMAL
- en: You may need to call `updateConfigurations()`, which will ask the system to
    update the list of configurations, and then you need to listen for the `updateCompleted`
    signal before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: You can get all configurations known to the system with a call to `allConfigurations()`,
    or filter it to the ones that have a certain state with `allConfigurations(QNetworkConfiguration::Discovered);`.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, it returns a list of `Discovered` configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the system''s capabilities with a call to `capabilities()`, which
    can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CanStartAndStopInterfaces`: System allows user to start and stop connections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DirectConnectionRouting`: Connection routing is bound directly to a specified
    device interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SystemSessionSupport`: System keeps connection open until all sessions are
    closed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ApplicationLevelRoaming`: Apps can control roaming/migrating'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ForcedRoaming`: System will reconnect when roaming/migrating'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataStatics`: System provides information about transmitted and received data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NetworkSessionRequired`: System requires a session'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QNetworkSession
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QNetworkSession` provides a way to start and stop connections as well as providing
    management of connection sessions. In the case of instantiating `QNetworkSession`
    with a `QNetworkConfiguration` that is a `ServiceNetwork` type, it can provide
    roaming features. On most systems, roaming will entail actually disconnecting
    and then connecting a new interface and/or connection. On others, roaming can
    be seamless and without disturbing the user''s data stream.'
  prefs: []
  type: TYPE_NORMAL
- en: If the capabilities of `QNetworkConfigurationManager` reports that it supports
    `CanStartAndStopInterfaces`, then you use `QNetworkSession` to `open()` (connect)
    and `stop()` (close) `QNetworkConfigurations`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The QNAM will use `QNetworkSession` when making network requests behind the
    scenes. You can use `QNetworkSession` to monitor the connection as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter05-3` directory,
    in the `cp5` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To monitor bytes received and sent from a QNAM request, connect up to the `bytesReceived`
    and `bytesWritten` signals, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Roaming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By roaming, I mean roaming between Wi-Fi and mobile data, not roaming as in
    out of the home network, which can be very expensive mobile data to use.
  prefs: []
  type: TYPE_NORMAL
- en: In order to facilitate roaming, a client app can connect to the `preferredConfigurationChanged`
    signal and then begin the process by calling `migrate()` or cancel it by calling
    `ignore()`. Migrating a connection could be as simple as pausing the download,
    disconnecting and reconnecting to the new connection, and then resuming the download.
    This method is called forced roaming. It can, on some platforms, seamlessly migrate
    the data stream to the new connection, similar to what a mobile phone does when
    a call gets migrated to another cell tower.
  prefs: []
  type: TYPE_NORMAL
- en: At this time, there are no currently supported backends that support migrating
    sessions. A system integrator could implement a backend that does true connection
    migration and handovers. It would also help if the system allows this.
  prefs: []
  type: TYPE_NORMAL
- en: That said, both Samsung's Android and iOS support roaming features seem to have
    caught up to where Nokia was years ago. Samsung calls it Adaptive Wi-Fi, previously
    known as Smart Network Switch. iOS calls it Wi-Fi Assist. These happen at the
    system level and allow roaming between Wi-Fi and mobile data connections. Neither
    of these platforms allows applications to control the handover.
  prefs: []
  type: TYPE_NORMAL
- en: QBearerEngine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Qt comes with the following bearer backend plugins based off of the `QBearerEngine`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Android`: Android'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Connman`: Linux desktop & embedded, SailfishOS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Corewlan`: Mac OS and iOS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Generic`: All'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NativeWifi`: Windows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NetworkManager`: Linux'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NLA`: Windows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the platform, some of these work in conjunction with the generic
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: Low level – of sockets and servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QTcpSocket` and `QTcpServer` are two classes for sockets used in Qt. They
    work in much the same way as your web browser and a WWW server. These connect
    to a network address host, whereas `QLocalSocket` and `QLocalServer` connect to
    a local file descriptor.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at `QLocalServer` and `QLocalSocket` first.
  prefs: []
  type: TYPE_NORMAL
- en: 'In socket server programming, the basic procedure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a socket
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set socket options
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind a socket address
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Listen for connections
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept new connection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Qt simplifies these steps to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a socket
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Listen for connections
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept new connection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: QLocalServer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need communication on the same machine, then `QLocalServer` will be slightly
    more performant than using a TCP-based socket server. It can be used for **Inter-process
    communication** (**IPC**).
  prefs: []
  type: TYPE_NORMAL
- en: First, we create the server, and then call the `listen` function with a string
    name that clients use to connect. We hook up to the `newConnection` signal, so
    we know when a new client connects.
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter05-5a`
    directory, in the `cp5` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a client tries to connect, we then send a small message using the `write`
    function, and finally `flush` the message, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It's that simple! Anytime you need to write to the client, simply use `nextPendingConnection()`
    to get the next `QLocalSocket` object and use `write` to send the data. Be sure
    to add `\r\n` to all lines you need to send, including the last line. The call
    to `flush()` is not required, but it sends the data immediately.
  prefs: []
  type: TYPE_NORMAL
- en: You can keep this object around to send more messages when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Our app is now waiting and listening for connections. Let's do that next.
  prefs: []
  type: TYPE_NORMAL
- en: QLocalSocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QLocalSocket` is used to communicate with `QLocalServer`. You will want to
    connect to the `readyRead` signal. Other signals are `connected()`, `disconnected()`,
    `error(...)`, and `stateChanged(...)`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter05-5b`
    directory, in the `cp5` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need state changes, you connect to `stateChanged` and will be notified
    when the following states change:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UnconnectedState`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConnectingState`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConnectedState`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClosingState`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we need to actually connect to the server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Like `QLocalServer`, `QLocalSocket` uses the `write` function to send messages
    to the server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Remember to add the **End Of Line** (**EOL**) `\r\n` to mark the end of the
    data feed line.
  prefs: []
  type: TYPE_NORMAL
- en: That is a simple local sockets based communication. Now, let's look at a TCP-based
    socket over a network.
  prefs: []
  type: TYPE_NORMAL
- en: QTcpServer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `QTcpServer` API is much like `QLocalServer` and can be pretty much a drop-in
    replacement with a few small changes. Most notably, the arguments for the listen
    call are slightly different, in which you need to specify `QHostAddress` for `QTcpServer`
    instead of a `QString` name, and a port number. Here, I use `QHostAddress::Any`,
    which means it will listen on all network interfaces. If you don''t care about
    which port is used, set it to `0` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Does it look familiar? `QHostAddress` can be an IPv4 or IPv6 address. You can
    also specify different ranges of address by using the `QHostAddress::SpecialAddress`
    `enum` as I did, which can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LocalHost`: `127.0.0.1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalHostIPv6`: `::1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Broadcast`: `255.255.255.255`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnyIPv4`: `0.0.0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnyIPv6`: `::`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Any`: `all IPv4 and IPv6 addresses`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QTcpServer` has an additional signal to `QLocalServer`—`acceptError`, which
    gets emitted when an error occurs during the accept phase of a new connection.
    You can also `pauseAccepting()` and `resumeAccepting()` the accepting of the connections
    in the pending connection queue.'
  prefs: []
  type: TYPE_NORMAL
- en: QTcpSocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QTcpSocket` is similar to `QLocalSocket` as well. Except, among other things,
    `QTcpSocket` has `connectToHost` as a way to connect to a server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To make a simple `HTTP` request, we can write to the socket after we are connected,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will request the `index.html` file from the server. The data can be read
    in the `readyRead` signal handler, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `waitForConnected`, `waitForBytesWritten`, and `waitForReadyRead`
    functions if you do not want to use this more synchronously, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, close the connection with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: QSctpServer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SCTP** stands for **Stream Control Transmission Protocol**. `QSctpServer`
    sends messages as groups of bytes like UDP, rather than a stream of bytes like
    a TCP socket. It also ensures reliable delivery of the packets, like TCP. It can
    send several messages in parallel or at the same time. It does this by using several
    connections.'
  prefs: []
  type: TYPE_NORMAL
- en: '`QSctpServer` can also send a stream of bytes like TCP by setting `setMaximumChannelCount`
    to `-1`. The first thing you want to do after creating the `QSctpServer` object
    is `setMaximumChannelCount`. Setting this to `0` will let this use the number
    of channels that the client uses, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If you intend to use TCP byte streams, you use the `nextPendingConnection()`
    function like `QTcpServer` to get a `QTcpSocket` object to communicate with. `QSctpServer`
    has the additional `nextPendingDatagramConnection()` to communicate with `QSctpSocket`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To receive bytes in the `newConnection` signal handler, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: QSctpSocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QSctpSocket` also has controls for channel count, and as with `QSctpServer`,
    if you set the maximum channel count to `-1`, it will behave more like TCP sockets
    and send a data stream instead of message packets. The message blob is called
    a `datagram`.'
  prefs: []
  type: TYPE_NORMAL
- en: To read and write these datagrams, use `readDatagram()` and `writeDatagram()`.
    Let's examine `QNetworkDatagram`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To construct `QNetworkDatagram`, you need a `QByteArray` that holds the data
    message, a `QHostAddress` for the destination, and optionally, a port number.
    It can be as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This will send the `"Hello Mobile!"` message to the corresponding server.
  prefs: []
  type: TYPE_NORMAL
- en: QUdpSocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QUdpSocket` sends datagrams such as `QSctpSocket`, but they are not reliable,
    which means it will not retry to send any datagrams. It is also connectionless
    and has a restriction on data length of 65,536 bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to set up `QUdpSocket`—`bind(...)` and `connectToHost(...)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use `connectToHost`, you can use `QIODevice` `read()`, `write()`, `readAll()`
    to send and receive datagrams. Using the `bind(...)` method, you need to use `readDatagram`
    and `writeDatagram` instead, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: QSslSocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Encrypted socket communications can be handled by `QSslSocket`, which uses
    SSL to encrypt the TCP connection. The encrypted signal is emitted when the connection
    is secured, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The source code can be found on the Git repository under the `Chapter05-6a`
    directory, in the `cp5` branch.
  prefs: []
  type: TYPE_NORMAL
- en: This will start the connection and immediately start the secure handshake procedure.
    Once the handshake is finished with no error, the encrypted signal will be emitted
    and the connection will be ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to add key/certificate pair to `QSslSocket` to utilize the encryption
    capabilities. You can easily generate key-certificate fail pair for testing by
    using this web site: [https://www.selfsignedcertificate.com/](https://www.selfsignedcertificate.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we are using a self-signed certificate, we will need to add `ignoreSslErrors`
    in our error handling slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To add the encryption key and certificate, you need to open and read both files,
    and use the resulting `QByteArrays` to create `QSslKey` and `QSslCertificate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: When you run this code, you will need to use `QFileDialog` to navigate and find
    the `localhost.key` and `localhost.cert` files in the source directory.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we use `setPrivateKey` to set the key file, and `addCaCertificate` and
    `setLocalCertificate` to add the certificate.
  prefs: []
  type: TYPE_NORMAL
- en: To read from the socket, you can connect to the `readReady` signal like in `QTcpSocket`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write to the socket, which transmits to the server, simply use the `write`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You can then use `QSslSocket` to connect to `QTcpServer` that opens `QSslSocket`.
    This brings us to our next step.
  prefs: []
  type: TYPE_NORMAL
- en: QSslServer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ok, there is no `QSslServer` class, but since the `QSslSocket` class is just
    derived from `QTcpSocket` with some extra SSL stuff on top, you can create your
    own SSL server using the functions from `QSslSocket`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to generate SSL key and certificates. If they are self-signed,
    the same rules apply, in which we need to set the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You can create an SSL server by subclassing `QTcpServer` and overriding `incomingConnection()`
    ,as follows.
  prefs: []
  type: TYPE_NORMAL
- en: The source code can be found on the Git repository under the `Chapter05-6` directory,
    in the `cp5` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We implement the `header` file with the `override` function, as well as a slot
    to connect to when the server changes into encrypted mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the implementation of the SSL server class, pay attention to the call to
    `startServerEncryption()`. This will initiate the encryption of the `server` channels
    and create a `Server`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add the encruption key and certificate, as this uses `QSslSocket`
    like in the last section, *QSslSocket*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here, we connect to the `QSslSocket` `encrypted` signal, which signals when `QSslSocket`
    enters encrypted mode. From then on, all bytes sent or received are encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Errors are handled by connecting to the `sslErrors(const QList<QSslError> &errors)`
    signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to connect to the `QAbstractSocket::socketError` signal to handle
    those errors as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Other signals you will also want to connect to are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QSslSocket::connected`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QSslSocket::disconnected`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QSslSocket::encrypted`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QSslSocket::modeChanged`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QSslSocket::stateChanged`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up till now, we have been using local IP addresses, but what happens when the
    server is remote and we need not just the server name, but it's IP address? Let's
    explore how we can use Qt to do domain name lookups.
  prefs: []
  type: TYPE_NORMAL
- en: Lookups – look me up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computer networks such as the internet rely on **Domain Name Service** (**DNS**)
    lookups. This is usually done on remote central servers, but can also be used
    locally.
  prefs: []
  type: TYPE_NORMAL
- en: There are two classes for doing network lookups—`QDnsLookup` and `QHostInfo`.
    `QHostInfo` will provide simple IP address lookups for a hostname. It is really
    just looking up an IP address using a hostname. Let's look at how we can use this.
  prefs: []
  type: TYPE_NORMAL
- en: QHostInfo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QHostInfo` is a simple class to do address lookups provided by the platform
    system. It has synchronous, blocking method for lookup, or you can use signal/slots,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This method blocks until a response is received.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lookupHost` function does asynchronous lookups and takes a slot as an
    argument, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The slot we need to implement receives `QHostInfo` as an argument, as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To get an address from either of these responses, do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Let's now proceed to `QDnsLookup`.
  prefs: []
  type: TYPE_NORMAL
- en: QDnsLookup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QDnsLookup` can look up different types of records, not just IP addresses.
    The values you can use to set the type of lookup are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`A`: IPv4 addresses, access with `hostAddressRecords()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AAAA`: IPv6 addresses, access with `hostAddressRecords()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ANY`: Any record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CNAME`: Canonical name, access with `canonicalNameRecords()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MX`: Mail exchange, access with `mailExchangeRecords()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NS`: Name server, access with `nameServerRecords()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PTR`: Pointer, access with `pointerRecords()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SRV`: Service, access with `serviceRecords()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TXT`: Text, access with `textRecords()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at how this can be implemented. We connect the `QDnsLookup` signal
    named `finished` to our `lookupFinished` slot. We set the type here to `TXT` to
    access text records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to `lookup()` will start a lookup of the text records for the name
    that we set, which is `example.com`. We still need to handle the response, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: You can then use these records in the manner you need.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QNetwork` is quite extensive in what it can do. I have touched upon a few
    features, such as `QNetworkRequest`, `QNetworkAccessManager`, and `QNetworkReply`
    to make network requests, such as `get` and `put`. You can use Qt''s Bearer Management
    features to control the online state and `QNetworkSession` to group connections
    together to roam between connections. We discussed socket development with `QLocalSocket`,
    `QLocalServer`, `QTcpSocket`, and `QTcpServer`. You can perform host and DNS lookups
    with `QHostInfo` and `QDnsLookup`.'
  prefs: []
  type: TYPE_NORMAL
- en: Connectivity can mean a few things, and in the next chapter, we explore connectivity
    using Bluetooth **Low Energy** (**LE**).
  prefs: []
  type: TYPE_NORMAL
