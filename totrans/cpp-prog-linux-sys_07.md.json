["```cpp\n$ ls /dev/mqueue\n```", "```cpp\nconstexpr auto MAX_SIZE = 1024;\nstring_view QUEUE_NAME  = \"/test_queue\";\n```", "```cpp\nvoid readFromQueue() {\n...\n    mqd_t          mq   = { 0 };\n    struct mq_attr attr = { 0 };\n    array<char, MAX_SIZE> buffer{};\n    attr.mq_flags = 0;\n    attr.mq_maxmsg = 10;\n    attr.mq_msgsize = MAX_SIZE;\n    attr.mq_curmsgs = 0;\n    if (mq = mq_open(QUEUE_NAME.data(), O_CREAT | O_RDONLY,\n                     0700, &attr); mq > -1) { // {1}\n        for (;;) {\n            if (auto bytes_read = mq_receive(mq,\n                                             buffer.data(),\n                                             buffer.size(),\n                                             NULL);\n                                  bytes_read > 0) { // {2}\n                buffer[bytes_read] = '\\0';\n                cout << \"Received: \"\n                     << buffer.data()\n                     << endl; // {3}\n            }\n            else if (bytes_read == -1) {\n                cerr << \"Receive message failed!\";\n            }\n```", "```cpp\n            else {\n                cout << \"\\n\\n\\n***Receiving ends***\"\n                     << endl;\n                mq_close(mq); // {4}\n                break;\n            }\n        }\n    }\n    else {\n        cerr << \"Receiver: Failed to load queue: \"\n             << strerror(errno);\n    }\n    mq_unlink(QUEUE_NAME.data());\n}\n```", "```cpp\nvoid writeToQueue() {\n...\n   if (mq = mq_open(QUEUE_NAME.data(), O_WRONLY,\n                     0700, NULL); mq > -1) { // {5}\n        int fd = open(\"test.dat\", O_RDONLY); // {6}\n        if (fd > 0) {\n            for (;;) {\n                // This could be taken from cin.\n                array<char, MAX_SIZE> buffer{};\n                if (auto bytes_to_send =\n                        read(fd,\n                             buffer.data(),\n                        buffer.size());\n                             bytes_to_send > 0) { // {7}\n                    if (auto b_sent =\n                            mq_send(mq,\n                                    buffer.data(),\n                                    buffer.size(),\n                                    0);\n                                    b_sent == -1) {// {8}\n                        cerr << \"Sent failed!\"\n                             << strerror(errno);\n                    }\n```", "```cpp\n...\n                else if (bytes_to_send == 0) {\n                    cout << \"Sending ends....\" << endl;\n                    if (auto b_sent =\n                            mq_send(mq,\n                                    buffer.data(),\n                                    0,\n                                    0); b_sent == -1) {\n                                    // {9}\n                        cerr << \"Sent failed!\"\n                             << strerror(errno);\n```", "```cpp\nThread READER starting...\nThread WRITER starting...\nSending ends....\nReceived: This is a testing file...\nReceived: ing fileThis is a testing file...\n***Receiving ends***\nMain: program completed. Exiting.\n```", "```cpp\nint shrd_res = 0; //Some shared resource.\nvoid thread_func(){\n    shrd_res ++;\n    std::cout << shrd_res;\n}\n```", "```cpp\n...\nint shrd_res = 0;      store 0\nshrd_res++;            load value\n                       add 1\n                       store value\nstd::cout << shrd_res; load value\n...\n```", "```cpp\nThread 1: shrd_res++; T1: load value\n                      T1: add 1\nThread 2: shrd_res++; T2: load value\n                      T2: add 1\n                      T2: store value\n                      T1: store value\n```", "```cpp\nT1: add 1\n```", "```cpp\nunsigned int S = 0;\nV(S):\n    S=S+1;\nP(S):\n    while(S==0):\n        // Do nothing.\n    S = S – 1;\n```", "```cpp\nsem_t sem;\nsem_init(sem_t *sem, int pshared, unsigned int value);\nint sem_destroy(sem_t *sem);\nint sem_post(sem_t *sem);\nint sem_wait(sem_t *sem);\n```", "```cpp\n    sem_t *global_sem = sem_open(\"/sem\", O_CREAT, 0644,\n      0);\n    ```", "```cpp\n    sem_close(global_sem);\n    sem_unlink(\"/sem\");\n    ```", "```cpp\n...\nuint32_t shared_resource = 0;\nbinary_semaphore sem_to_produce(0);\nbinary_semaphore sem_to_consume(0);\nconstexpr uint32_t limit = 65536;\n```", "```cpp\nvoid producer() {\n    for (auto i = 0; i <= limit; i++) {\n        sem_to_produce.acquire(); // {1}\n        ++shared_resource;\n        osyncstream(cout) << \"Before: \"\n                          << shared_resource << endl;\n        sem_to_consume.release(); // {2}\n        osyncstream(cout) << \"Producer finished!\" << endl;\n    }\n}\n```", "```cpp\nvoid consumer() {\n    for (auto i = 0; i <= limit; i++) {\n        osyncstream(cout)  << \"Waiting for data...\"\n                           << endl;\n        sem_to_consume.acquire();\n        --shared_resource;\n        osyncstream(cout)  << \"After: \"\n                           << shared_resource << endl;\n        sem_to_produce.release();\n        osyncstream(cout)  << \"Consumer finished!\" << endl;\n    } }\nint main() {\n    sem_to_produce.release();\n    jthread t1(producer); jthread t2(consumer);\n    t1.join(); t2.join();}\n```", "```cpp\nWaiting for data...\nBefore: 1\nProducer finished!\nAfter: 0\nConsumer finished!\n...\n```", "```cpp\npthread_mutex_t global_lock;\npthread_mutex_init(&global_lock, NULL);\npthread_mutex_destroy(&global_lock);\npthread_mutex_lock(&global_lock);\npthread_mutex_unlock(&global_lock);\n```", "```cpp\n    NULL, but we could use them to decide on the mutex kind. The default one, known as a fast mutex, is not deadlock-safe. The recursive mutex type will not cause a deadlock; it will count the number of lock requests by the same thread. The error-checking mutex will detect and mark a double lock. We encourage you to give them a try.\n    ```", "```cpp\n...\nuint32_t shared_resource = 0;\nmutex shres_guard;\nconstexpr uint32_t limit = INT_MAX;\n```", "```cpp\nvoid increment() {\n    for (auto i = 0; i < limit; i++) {\n        lock_guard<mutex> lock(shres_guard); // {1}\n        ++shared_resource;\n    }\n    cout << \"\\nIncrement finished!\" << endl;\n}\n...\n```", "```cpp\n$ time ./test\nIncrement finished!\nIncrement finished!\nreal    3m34,169s\nuser    4m21,676s\nsys     2m43,331s\n```", "```cpp\natomic<uint32_t> shared_resource = 0;\n```", "```cpp\n$ time ./test\nIncrement finished!\nIncrement finished!\nreal    0m0,003s\nuser    0m0,002s\nsys     0m0,000s\n```", "```cpp\n...\nstring_view SHM_ID      = \"/test_shm\";\nstring_view SEM_PROD_ID = \"/test_sem_prod\";\nstring_view SEM_CONS_ID = \"/test_sem_cons\";\nconstexpr auto SHM_SIZE = 1024;\nsem_t *sem_prod; sem_t *sem_cons;\nvoid process_creator() {\n...\n    if (int pid = fork(); pid == 0) {\n        // Child - used for consuming data.\n        if (fd = shm_open(SHM_ID.data(),\n                          O_RDONLY,\n                          0700); // {1}\n            fd == -1) {\n....\n```", "```cpp\n        shm_addr = mmap(NULL, SHM_SIZE,\n                        PROT_READ, MAP_SHARED,\n                        fd, 0); // {2}\n        if (shm_addr == MAP_FAILED) {\n...\n        }\n        array<char, SHM_SIZE> buffer{};\n```", "```cpp\n        sem_wait(sem_cons);\n        memcpy(buffer.data(),\n               shm_addr,\n               buffer.size()); // {3}\n        if(strlen(buffer.data()) != 0) {\n            cout << \"PID : \" << getpid()\n                 << \"consumed: \" << buffer.data();\n        }\n        sem_post(sem_prod); exit(EXIT_SUCCESS);\n```", "```cpp\n    else if (pid > 0) {\n        // Parent - used for producing data.\n        fd = shm_open(SHM_ID.data(),\n                      O_CREAT | O_RDWR,\n                      0700); // {4}\n        if (fd == -1) {\n...\n        res = ftruncate(fd, SHM_SIZE); // {5}\n```", "```cpp\n        if (res == -1) {\n...\n        shm_addr = mmap(NULL, SHM_SIZE,\n                        PROT_WRITE, MAP_SHARED,\n                        fd, 0); // {6}\n        if (shm_addr == MAP_FAILED) {\n...\n        sem_wait(sem_prod);\n        string_view produced_data\n            {\"Some test data, coming!\"};\n        memcpy(shm_addr,\n               produced_data.data(),\n               produced_data.size());\n        sem_post(sem_cons);    // {7}\n        waitpid(pid, NULL, 0); // {8}\n        res = munmap(shm_addr, SHM_SIZE); // {9}\n        if (res == -1) {\n...\n        fd = shm_unlink(SHM_ID.data()); //{10}\n        if (fd == -1) {\n```", "```cpp\n...\n}\nint main() {\n    sem_prod = sem_open(SEM_PROD_ID.data(),\n                        O_CREAT, 0644, 0); // {11}\n...\n    sem_post(sem_prod);\n    process_creator();\n    sem_close(sem_prod); // {12}\n    sem_close(sem_cons);\n    sem_unlink(SEM_PROD_ID.data());\n    sem_unlink(SEM_CONS_ID.data());\n    return 0;\n}\n```", "```cpp\nPID 3530: consumed: \"Some test data, coming!\"\n```", "```cpp\n...\nconstexpr auto PORT     = 8080;\nconstexpr auto BUF_SIZE = 16;\nauto die_roll() {\n...\nvoid process_creator() {\n    auto sockfd = 0;\n    array<char, BUF_SIZE> buffer{};\n    string_view stop{ \"No more requests!\" };\n    string_view request{ \"Throw dice!\" };\n    struct sockaddr_in servaddr {};\n    struct sockaddr_in cliaddr {};\n```", "```cpp\n    servaddr.sin_family = AF_INET; // {1}\n    servaddr.sin_addr.s_addr = INADDR_ANY;\n    servaddr.sin_port = htons(PORT);\n    if (int pid = fork(); pid == 0) {\n        // Child\n        if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0))\n                < 0) {\n            const auto ecode\n                { make_error_code(errc{errno}) };\n            cerr << \"Error opening socket!\";\n            system_error exception{ ecode };\n            throw exception;\n        } // {2}\n        if (bind(sockfd,\n            (const struct sockaddr*)&servaddr,\n            sizeof(servaddr)) < 0) {\n            const auto ecode\n                { make_error_code(errc{errno}) };\n            cerr << \"Bind failed!\";\n            system_error exception{ ecode };\n            throw exception;\n        } // {3}\n```", "```cpp\n        socklen_t len = sizeof(cliaddr);\n        for (;;) {\n            if (auto bytes_received =\n                recvfrom(sockfd, buffer.data(),\n                    buffer.size(),\n                    MSG_WAITALL,\n                    (struct sockaddr*)&cliaddr,\n                    &len);\n                bytes_received >= 0) { // {4}\n                buffer.data()[bytes_received] = '\\0';\n                cout << \"Request received: \"\n                     << buffer.data() << endl;\n                if (request.compare(0,\n                                    bytes_received,\n                                    buffer.data()) == 0) {\n                                                    // {5}\n                    string_view res_data\n                        { to_string(die_roll()) };\n```", "```cpp\n                    sendto(sockfd, res_data.data(),\n                           res_data.size(),\n                           MSG_WAITALL,\n                           (struct sockaddr*)&cliaddr,\n                           len);\n                }\n                else break; // {6}\n...\n        }\n        if (auto res = close(sockfd); res == -1) { // {8}\n            const auto ecode\n                { make_error_code(errc{errno}) };\n            cerr << \"Error closing socket!\";\n            system_error exception{ ecode };\n            throw exception;\n        }\n        exit(EXIT_SUCCESS);\n```", "```cpp\n       for (auto i = 1; i <= dice_rolls; i++) { // {11}\n            if (auto b_sent = sendto(sockfd,\n                                     request.data(),\n                                     request.size(),\n                                     MSG_DONTWAIT,\n                                     (const struct\n                                      sockaddr*)&servaddr,\n                                     sizeof(servaddr));\n                                     b_sent >= 0) { // {12}\n...\n            if (auto b_recv =\n                    recvfrom(sockfd,\n                             buffer.data(),\n                             buffer.size(),\n                             MSG_WAITALL,\n...                             { // {13}\n                buffer.data()[b_recv] = '\\0';\n                cout << \"Dice roll result for throw number\"\n                     << i << \" is \"\n                     << buffer.data() << endl;\n            }\n```", "```cpp\n       sendto(sockfd,\n              stop.data(),\n              stop.size(),\n              MSG_CONFIRM,\n              (const struct sockaddr*)&servaddr,\n              sizeof(servaddr)); // {14}\n       if (auto res = close(sockfd); res == -1) {\n            const auto ecode\n                { make_error_code(errc{errno}) };\n            cerr << \"Error closing socket!\";\n            system_error exception{ ecode };\n            throw exception; // {15}\n        }\n...\n```", "```cpp\nChoose a number of dice throws between 1 and 256.\n5\nRequest received: Throw dice!\nDice roll result for throw number 1 is 2\n....\nDice roll result for throw number 5 is 6\nRequest received: No more requests\n```", "```cpp\n$ ip addr show\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host\n       valid_lft forever preferred_lft forever\n2: ens32: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000\n    link/ether 00:0c:29:94:a5:25 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.136.128/24 brd 192.168.136.255 scope global dynamic noprefixroute ens32\n       valid_lft 1345sec preferred_lft 1345sec\n    inet6 fe80::b11f:c011:ba44:35e5/64 scope link noprefixroute\n       valid_lft forever preferred_lft forever...\n```", "```cpp\nservaddr.sin_addr.s_addr = inet_addr(\"192.168.136.128\");\n```", "```cpp\n$ ping 192.168.136.128\nPinging 192.168.136.128 with 32 bytes of data:\nReply from 192.168.136.128: bytes=32 time<1ms TTL=64\nReply from 192.168.136.128: bytes=32 time<1ms TTL=64\nReply from 192.168.136.128: bytes=32 time<1ms TTL=64\n```", "```cpp\n...\nconstexpr auto PORT     = 8080;\nconstexpr auto BUF_SIZE = 256;\nconstexpr auto BACKLOG  = 5;\nconstexpr auto SIG_MAX  = 128;\nvoid exitHandler(int sig) {\n    cerr << \"Exit command called - terminating server!\"\n         << endl;\n    exit(SIG_MAX + sig);\n}\nint main() {\n    signal(SIGINT, exitHandler);\n    constexpr auto ip = \"192.168.136.128\";\n...\n```", "```cpp\n    if (auto server_sock =\n            socket(AF_INET, SOCK_STREAM, 0);\n            server_sock < 0) {\n```", "```cpp\n...\n        server_addr.sin_addr.s_addr = inet_addr(ip);\n        result = bind(server_sock,\n            (struct sockaddr*)&server_addr,\n            sizeof(server_addr));\n...\n        result = listen(server_sock, BACKLOG);\n        if (result != 0) {\n            cerr << \"Cannot accept connection\";\n        }\n        cout << \"Listening...\" << endl;\n        for (;;) {\n            addr_size = sizeof(client_addr);\n            client_sock =\n                accept(server_sock,\n                       (struct sockaddr*)&client_addr,\n                       &addr_size);\n```", "```cpp\n$ ./server\nListening...\n```", "```cpp\n            if (client_sock > 0) {\n                cout << \"Client connected.\" << endl;\n                array<char, BUF_SIZE> buffer{};\n                if (auto b_recv = recv(client_sock,\n                                       buffer.data(),\n                                       buffer.size(),\n                                       MSG_PEEK);\n                                  b_recv > 0) {\n                    buffer.data()[b_recv] = '\\0';\n                    cout << \"Client request: \"\n                         << buffer.data() << endl;\n                    string_view response =\n                        { to_string(getpid()) };\n                    cout << \"Server response: \"\n                         << response << endl;\n                    send(client_sock,\n                         response.data(),\n                         response.size(),\n                         MSG_DONTWAIT);\n                }\n```", "```cpp\n...\n           if (auto res =\n                        close(client_sock); res == -1) {\n...\n```", "```cpp\n...\n       if (auto res =\n                connect(serv_sock,\n                        (struct sockaddr*)&addr,\n                        sizeof(addr)); res == -1) {\n            const auto ecode\n                { make_error_code(errc{errno}) };\n            cerr << \"Error connecting to socket!\";\n            system_error exception{ ecode };\n            throw exception;\n        }\n        string_view req = { to_string(getpid()) };\n        cout << \"Client request: \" << req << endl;\n```", "```cpp\n$ ./server\nListening...\nClient connected.\nClient request: 12502\nServer response: 12501\n```", "```cpp\n        if (auto res =\n                send(serv_sock,\n                     req.data(),\n                     req.size(),\n                     MSG_DONTWAIT);\n                res >= 0) {\n            array<char, BUF_SIZE> buffer{};\n            if (auto b_recv =\n                    recv(serv_sock,\n                         buffer.data(),\n                         buffer.size(),\n                         MSG_PEEK);\n                    res > 0) {\n                buffer.data()[b_recv] = '\\0';\n                cout << \"Server response: \"\n                     << buffer.data();\n...\n       if (auto res = close(serv_sock); res == -1) {\n...\n      cout << \"\\nJob done! Disconnecting.\" << endl;\n```", "```cpp\n$ ./client\nClient request: 12502\nServer response: 12501\nJob done! Disconnecting.\n```", "```cpp\nListening...\nClient connected.\nClient request: 12502\nServer response: 12501\nClient connected.\nClient request: 12503\nServer response: 12501\n```", "```cpp\n...\nClient request: 12503\nServer response: 12501\n^CExit command called - terminating server!\n```", "```cpp\n$ ss -tnlp\nState Recv-Q Send-Q Local Address:Port Peer Address:Port  Process\nLISTEN 0           5            192.168.136.128:8080 0.0.0.0:*      users:((\"server\",pid=9965,fd=3))\nLISTEN   0         4096         127.0.0.53%lo:53         0.0.0.0:*\nLISTEN   0         5            127.0.0.1:631            0.0.0.0:*\nLISTEN   0         5            [::1]:631                [::]:*\n```", "```cpp\n$ lsof -P -i:8080\nCOMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nserver  10116  oem    3u  IPv4  94617      0t0  TCP oem-virtual-machine:8080 (LISTEN)\n```"]