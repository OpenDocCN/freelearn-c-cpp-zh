<html><head></head><body>
        

                            
                    <h1 class="header-title">What Are Embedded Systems?</h1>
                
            
            
                
<p>Essentially , the <em>embedded</em> part of an <em>embedded system</em> refers to the state of being embedded into a larger system. The system that has been embedded is a computer system of some description, which has one or more very specific functions in the overall system, rather than being a general-purpose component. This larger system can be digital, mechanical, or analog in nature, while the additional integrated digital circuitry tightly interacts with data from and to interfaces, sensors and memory to implement the actual system functionality.</p>
<p>In this chapter, we will look at the following topics:</p>
<ul>
<li>Different categories of embedded platforms</li>
<li>Examples of each category</li>
<li>Development challenges of each category</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The many faces of embedded systems</h1>
                
            
            
                
<p>Every computerized function in today's devices is implemented using one or multiple microprocessors, meaning a computer processor (central processing unit, or CPU) usually contained in a single <strong>integrated circuit</strong> (<strong>IC</strong>). The microprocessor comprises at least the <strong>arithmetic logic unit</strong> (<strong>ALU</strong>) and control circuitry, but logically also registers, and <strong>input/output</strong> (<strong>I/O</strong>) banks, in addition to more advanced features commonly tailored to a specific product category (wearables, low power sensors, mixed signal, ...) or market (consumer, medical, automotive, ...).</p>
<p>At this point in history, almost all microprocessors are found in embedded systems. Even though people are likely to possess a computer, laptop, and smartphone, maybe even a tablet, the number of embedded microprocessors in a given household far dwarfs the number of general-purpose microprocessors.</p>
<p>Even within a laptop or PC, there are a number of embedded microprocessors in addition to its general-purpose CPU. These microprocessors have tasks like handling keyboard or mouse input, processing touch-screen inputs, converting streams of data into Ethernet packages, or creating video or audio output.</p>
<p>In older systems, such as the Commodore 64, this same pattern can be seen, with a CPU IC, sound IC, video IC, and so on. Whereas the CPU runs whatever code the application developer has written, the other chips in the system have very specific purposes, down to the controller IC for the floppy or hard disk drive.</p>
<p>Outside of general-purpose computers, we find embedded microprocessors everywhere, often in the form of even further integrated MCUs. They control kitchen devices, washing machines, and the engines of our cars, in addition to the higher-level functions and the processing of sensor information.</p>
<p>While the first microwaves were analog devices, using mechanical timers and variable resistors to set power level and duration, today's microwaves contain at least one microcontroller, which is responsible for handling user input, driving a display of some type, and configuring the microwave's systems. The display itself can have its own microcontroller, depending on the complexity of the chosen configuration.</p>
<p>Perhaps more excitingly, embedded systems also provide monitoring, automation and fail-safe features that keep airplanes flying, ensure that guided missiles and space rockets perform as intended, and enable ever-increasing possibilities in areas such as medicine and robotics. The avionics of an airplane constantly monitor countless parameters from a multitude of sensors, running the same code on its triple-redundant configuration to detect any possible glitches.</p>
<p>Tiny yet powerful microprocessors enable the rapid analysis of chemicals and DNA or RNA strands, which would have taken racks of equipment before. With the progress of technology, an embedded system has become small enough that it can be sent through the human body to monitor its health.</p>
<p>Beyond Earth, space probes and rovers on Mars, the Moon, and asteroids are performing a myriad of duties every day, again with the courtesy of well-tested embedded systems. The Moon missions themselves were made possible due to the first major example of an embedded system in the form of the Apollo Guidance Computer. This 1966-era embedded system consisted of wire-wrapped boards full of triple-input NOR logic gates, built for the explicit purpose of handling navigation, guidance, and control of the Command Module and Lunar Module launched by the Saturn V rockets.</p>
<p>The ubiquitous and versatile nature of embedded systems has made them an inseparable part of modern life.</p>
<p>For embedded systems, they are usually distinguished between the following categories:</p>
<ul>
<li><strong>Microcontrollers</strong> (<strong>MCUs</strong>)</li>
<li><strong>System-on-Chip</strong> (<strong>SoC</strong>), often as a <strong>Single-Board Computer</strong> (<strong>SBC</strong>)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Microcontrollers</h1>
                
            
            
                
<p>One of the driving factors of innovation in the field of embedded systems is cost, since they will often be high-volume, cheap consumer products. To that end, it helps to have the entire microprocessor, memory, storage, and input/output peripherals on a single chip, simplifying implementation effort, reducing PCB real estate, all with the added benefit of faster and simpler design and production with higher yield. This led to the development of <strong>microcontrollers</strong> (<strong>MCUs</strong>) during the 1970s: single-chip computer systems that could be added to a new design for a minimal cost.</p>
<p>With the introduction of <strong>Electrically Erasable Programmable Read-Only Memory</strong> (<strong>EEPROM</strong>) to MCUs in the early 1990s, it first became possible to rewrite the program memory of MCUs repeatedly without having to resort to erasing memory content using ultraviolet light through a special quartz window in the MCU's packaging. This allowed for much easier prototyping and further reduced cost and - as far as development and lower-volume production is concerned - in-circuit programming.</p>
<p>As a result of this, many systems that were previously controlled by intricate mechanical and analog mechanisms (like elevators and temperature controllers) now contain one or more MCUs, which handle the same functionality while reducing costs and increasing reliability. By having the features handled in software, developers were also free to add advanced features such as complex preset programs (for washing machines, microwaves, and so on) and simple to complex displays to provide feedback to the user.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">TMS 1000</h1>
                
            
            
                
<p>The first commercially available MCU was Texas Instrument's TMS 1000, a general-purpose 4-bit, single-chip system. It was first made available for sale in 1974. The original model had 1 KB of ROM, 64 x 4 bits of RAM, and 23 I/O pins. They could be clocked at speeds from 100 to 400 KHz, with each instruction executing in six clock cycles.</p>
<p>Later models would increase the ROM and RAM sizes, though the basic design remained largely unchanged until production ceased in 1981:</p>
<div><img src="img/3b757a88-54d0-4f2c-a0d1-367c2523d7c2.png" style="width:21.83em;height:16.00em;"/></div>
<p>The size of the MCU die was roughly 5 x 5 millimeters, small enough to fit in a DIP package. This type of MCU used mask-programmable ROM, meaning that you could not get a blank TMS 1000 chip and program it. Instead, you would have to send the debugged program to Texas Instruments to have it physically produced using a photolithography mask, resulting in a metallic bridge for each bit.</p>
<p>Being a fairly primitive design (relative to later MCUs), it lacked a stack and interrupts, had a set of 43 instructions and two general-purpose registers, making it quite similar to the Intel 4004 CPU. Some models had special peripherals for driving <strong>vacuum fluorescent displays</strong> (<strong>VFD</strong>) and for continuously reading inputs to handle user input via a keyboard without interrupting the main program. Its basic pinout looked as follows:</p>
<div><img src="img/d3dc0886-0ef2-4ab9-906d-8c68a6eeff37.png" style="width:12.58em;height:18.33em;"/></div>
<p>Obviously the pin functions predate the <strong>general purpose input/output</strong> (<strong>GPIO</strong>) pins we know today - the <strong>K</strong> pins can only be used for input, while output pins are denoted as <strong>O</strong> and control pins are marked with <strong>R</strong>. The <strong>OSC</strong> pins are to be connected to an external oscillator circuit. Much like with discrete logic ICs, the <strong>Init</strong> pin is used to initialize the chip on power-up and has to be kept high for at least six cycles, whereas recent MCUs have integrated Power-On Reset (POR) and a reset pin that needs at most a discrete resistor and capacitor.</p>
<p>According to the original Texas Instruments press release from 1974, these microcontroller<em> </em>could be had for as little as $3 or less if you bought them in large quantity. They would be used in popular toys such as the Speak and Spell, but also just about everywhere else, including household appliances, automobiles, and scientific equipment. By the time production ceased in the early 1980s, many millions had been sold.</p>
<p>It's also interesting to note that while one-time programmable low cost microcontrollers have gone down in price a lot, the class of products has persevered - as an example, the Padauk PMS150C can now be had for $0.03 and whilst offering an 8 bit architecture, its 1K words of ROM and 64 bytes of RAM sound oddly familiar.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Intel MCS-48</h1>
                
            
            
                
<p>Intel's response to Texas Instrument's successful TMS 1000 MCU was the MCS-48 series, with the 8048, 8035, and 8748 being the first models released in 1976. The 8048 has 1 KB of ROM and 64 bytes of RAM. It is an 8-bit design with a Harvard architecture (split code/data memory), introducing a native word size of 8 bits and interrupt support (two single-level) and is compatible with 8080/8085 peripherals, making it a highly versatile MCU. The advantage of wider ALU and register word sizes is still perceivable today, where for example a 32 bit addition is sequentially executed on an 8 bit MCU as a series of 8 bit additions with carry.</p>
<p>The MCS-48 features over 96 instructions, most of them a single byte in length, and allows for external memory to be added in addition to the internal memory. In a community effort, available information on the MCS-48 family has been compiled and released at <a href="https://devsaurus.github.io/mcs-48/mcs-48.pdf">https://devsaurus.github.io/mcs-48/mcs-48.pdf</a> .</p>
<p>Here we consider the simplicity of the MCS-48 functional block diagram and compare it to that of its successors as follows:</p>
<div><img src="img/b5d1ac0d-9dea-45f2-a35b-77b9c74a8ade.png" style="width:26.50em;height:21.25em;"/></div>
<p>Even for a design that was introduced just a few years after the TMS 1000, the rapid evolution of MCU designs is evident. Since MCU design evolved alongside popular CPU designs of the time, including the 6502, its 16-bit version, and what would eventually become the M68K processor family, there are many similarities to be found.</p>
<p>Due to its flexible design, it remained popular and in production until the 1990s, until the MCS-51 (8051) series gradually replaced it. See the next section for more details on the 8051.</p>
<p>The MCS-48 was used in the keyboard of the original IBM PC as its controller. It was also used with the 80286 and 80386 to perform A20 line gating and reset functions in the case of the former. Later PCs would integrate these features into Super I/O devices.</p>
<p>Other notable uses of the MCS-48 include the Magnavox Odyssey video game console and a range of Korg and Roland analog synthesizers. While masked ROM (up to 2 KB) was an option with the MCS-48 family, the 87P50 used an external ROM module for its programming, and the 8748 and 8749 featured up to 2 KB EPROM, which allowed for the MCU's internal programming to be altered repeatedly.</p>
<p>Like with standalone EPROM modules, this requires the package to contain a fused quartz window, which allows for ultraviolet light to reach the MCU die, as can clearly be seen in the following photograph of an 8749 MCU with EPROM (by Konstantin Lanzet, CC BY-SA 3.0):</p>
<div><img src="img/4ad70b0c-1c97-4323-ae7e-4c79e53867d6.png" style="width:26.92em;height:12.42em;"/></div>
<p>The charge stored in the EPROM cells that defines bits as written dissipates within a 20-30 minute exposure to strong ultraviolet light. The same can be achieved in direct sunlight over the course of a few weeks. The erase cycle usually implies removing the package and putting it in the light tight erasing device. After this, the EPROM can be programmed anew. The specified data retention of an EPROM is about 10-20 years at 85°C, and because the degradation accelerates exponentially with temperature, statements of 100 years or more at room temperature are not uncommon (27C512A: 200 years).</p>
<p>Due to the expense of creating the quartz window and integrating it into the package, one-time programmable EPROMs were used for a while, which allow for the easy programming of an EPROM, but mounted the programmed die in an opaque package so that it could not be reprogrammed any more. Ultimately, EEPROMs became available in the early 1980s, which replaced EPROMs almost completely. EEPROMs can be rewritten about a million times before they begin to develop issues when retaining stored data. Their data retention performance is similar to that of EPROMs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Intel MCS-51</h1>
                
            
            
                
<p>Recent chips from Cypress CY7C68013A (USB peripheral controller) to Ti CC2541 (a Bluetooth SoC) feature commodity 8051 cores, demonstrating that the Intel MCS-51 family design remains popular to this day. There's a plethora of derived MCUs by other manufacturers as well, even though Intel stopped producing this series of MCUs in March of 2007. First introduced in the 1980s, it's an 8-bit MCU like the 8048, but expands heavily on its feature set.</p>
<p>The functional block diagram as depicted in the Intel 80xxAH datasheet is shown as follows:</p>
<div><img src="img/893fbdf4-9c16-48cd-8446-bc058a32f4f0.png"/></div>
<p class="mce-root">It's very similar to the Atmel (now microchip) AT89S51  which is still in production today.<br/></p>
<p>Datasheets commonly address size and performance metrics in a <em>Features</em> list, as quoted below for the AT89S51:</p>
<ul>
<li>4K Bytes of <strong>in-system programmable</strong> (<strong>ISP</strong>) flash memory<br/>
- Endurance: 10,000 write/erase cycles (was 1,000,000 for EEPROM)</li>
<li>4.0 V to 5.5 V operating range</li>
<li>Fully static operation: 0 Hz to 33 MHz (was 12 MHz)</li>
<li>Three-level program memory lock</li>
<li>128 x 8-bit internal RAM</li>
<li>32 programmable I/O lines</li>
</ul>
<p>but then the list goes on with modern core, peripheral, low power and usability features:</p>
<ul>
<li>Two 16-bit timer/counters</li>
<li>Six interrupt sources</li>
<li>Full duplex UART serial channel</li>
<li>Low-power Idle and power-down modes</li>
<li>Interrupt recovery from power-down mode</li>
<li>Watchdog timer</li>
<li>Dual data pointer</li>
<li>Power-off flag</li>
<li>Fast programming time</li>
<li>Flexible ISP programming, byte- and page-mode</li>
</ul>
<p>The only major changes to the 8051 architecture over the past decades involved migrating from the original <strong>n-type metal oxide semiconductor</strong> (<strong>NMOS</strong>) transistor technology to <strong>complementary MOS</strong> (<strong>CMOS</strong>) – usually denoted as 80C51 – and more recently the addition of USB, I2C, and SPI interfaces, as well as advanced power management and debugging interfaces that have become ubiquitous since the beginning of this century. The Atmel application note 3487A doesn't give a concise explanation for the letter S, however the then new in-circuit serial programming (ISP) might thereby be highlighted.</p>
<p>The pinout diagram of the AT89S51 documents the SPI pins (MOSI, MISO, SCK):</p>
<div><img src="img/a764f469-f62f-4b51-99ee-5cc20c141900.png" style="width:18.00em;height:27.67em;"/></div>
<p>Beyond standalone MCUs, 8051 cores are also integrated into larger systems where a low-power, basic MCU is dedicated to diverse, low speed, real-time or high I/O count tasks. A broad range of chips from the likes of Ti CC2541 (Bluetooth low energy SoC) to Cypress CY7C68013A (FX2LP™ USB peripheral controller) underline the utility and relevance of the 8051 architecture to this day. </p>
<p>In <strong>field-programmable gate array</strong> (<strong>FPGA</strong>) or <strong>application specific integration circuit</strong> (<strong>ASIC</strong>) development, 8051-type processors are also commonly deployed as soft cores, where they are adapted and added to VHDL and Verilog HDL projects to handle tasks that lend themselves better to sequential execution without the need for tight timing or large bandwidth. Last but not least, the charm of soft cores lies in the ability to use full-featured development and debugging tools while maintaining tight integration with the remaining hardware design. The equivalent of only a few hundred bytes of program code run by a soft core might well be a large state machine, memories, counters and ALU-like logic, all of which raises the question which implementation is easier to validate and maintain. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">PIC</h1>
                
            
            
                
<p>The PIC family of MCUs was first introduced in 1976 by General Instrument, using their new CP1600 16-bit CPU. This CPU was nearly compatible with the PDP-11 series of processors with its instruction set.</p>
<p>In 1987, General Instrument spun off its microelectronics division to create Microchip Technology, which became an independent company in 1989. Microchip technology produces new PIC designs to this day.  Alongside the evolution of PIC cores and peripherals, on-chip memory technology development yielded the introduction of light tight encapsulated EPROM for on-time programmable and later EEPROM for in-circuit reprogramming capabilities. Like most MCUs, PIC MCUs have a Harvard architecture. Today, PIC designs range from 8-bit to 32-bit, with a wide range of features. These are the PIC families as the time of writing this book:</p>
<table border="1" style="border-collapse: collapse;width: 103.439%">
<tbody>
<tr>
<td style="width: 18%">
<p class="CDPAlignCenter CDPAlign"><strong>Family</strong></p>
</td>
<td style="width: 10%">
<p class="CDPAlignCenter CDPAlign"><strong>Pins</strong></p>
</td>
<td style="width: 33%">
<p class="CDPAlignCenter CDPAlign"><strong>Memories</strong></p>
</td>
<td style="width: 52.5813%">
<p class="CDPAlignCenter CDPAlign"><strong>Details</strong></p>
</td>
</tr>
<tr>
<td style="width: 18%">
<p>PIC10</p>
</td>
<td style="width: 10%">
<p>6-8</p>
</td>
<td style="width: 33%">
<p>384-896 bytes ROM, 64-512 bytes RAM<br/></p>
</td>
<td style="width: 52.5813%">
<p>8-bit, 8-16 MHz, modified Harvard</p>
</td>
</tr>
<tr>
<td style="width: 18%">
<p>PIC12</p>
</td>
<td style="width: 10%">
<p>8</p>
</td>
<td style="width: 33%">
<p>2-16 KB ROM, 256 bytes RAM</p>
</td>
<td style="width: 52.5813%">
<p>8-bit, 16 MHz, modified Harvard</p>
</td>
</tr>
<tr>
<td style="width: 18%">
<p>PIC16</p>
</td>
<td style="width: 10%">
<p>8-64</p>
</td>
<td style="width: 33%">
<p>3.5-56 KB ROM,  1-4 KB RAM<br/></p>
</td>
<td style="width: 52.5813%">8-bit modified Harvard</td>
</tr>
<tr>
<td style="width: 18%">
<p>PIC17</p>
</td>
<td style="width: 10%">
<p>40-68</p>
</td>
<td style="width: 33%">
<p>4-16 KB ROM, 232-454 bytes RAM</p>
</td>
<td style="width: 52.5813%">
<p>8-bit, 33 MHz, superseded by the PIC18, though third-party clones exist.</p>
</td>
</tr>
<tr>
<td style="width: 18%">
<p>PIC18</p>
</td>
<td style="width: 10%">
<p>28-100</p>
</td>
<td style="width: 33%">
<p>16-128 KB ROM, 3,728-4,096 bytes RAM<br/></p>
</td>
<td style="width: 52.5813%">
<p>8-bit modified Harvard</p>
</td>
</tr>
<tr>
<td style="width: 18%">
<p>PIC24 (dsPIC)</p>
</td>
<td style="width: 10%">
<p>14-144</p>
</td>
<td style="width: 33%">
<p>64-1,024KB ROM, 8-16 KB RAM</p>
</td>
<td style="width: 52.5813%">
<p>16-bit, DsPIC (dsPIC33) MCUs have digital signal processing (DSP) peripherals built in.</p>
</td>
</tr>
<tr>
<td style="width: 18%">
<p>PIC32MX</p>
</td>
<td style="width: 10%">
<p>64-100</p>
</td>
<td style="width: 33%">
<p>32-512 KB ROM, 8-32 KB RAM</p>
</td>
<td style="width: 52.5813%">
<p>32-bit, 200 MHz MIPS M4K with MIPS16e mode, released in 2007.</p>
</td>
</tr>
<tr>
<td style="width: 18%">
<p>PIC32MZ EC</p>
<p>PIC32MZ EF</p>
<p>PIC32MZ DA</p>
</td>
<td style="width: 10%">
<p>64-288</p>
</td>
<td style="width: 33%">
<p>512-2,048 KB ROM, 256-640 KB static RAM (32 MB DDR2 DRAM)</p>
</td>
<td style="width: 52.5813%">
<p>32-bit, MIPS ISA (2013), PIC32MZ DA version (2017) having a graphics core. Core speeds of 200 MHz (EC, DA) and 252 MHz (EF).</p>
</td>
</tr>
<tr>
<td style="width: 18%">
<p>PIC32MM</p>
</td>
<td style="width: 10%">
<p>20-64</p>
</td>
<td style="width: 33%">
<p>16-256 KB RAM, 4-32 KB RAM</p>
</td>
<td style="width: 52.5813%">
<p>32-bit microMIPS, 25 MHz,<br/>
variant optimized for low cost and low power.</p>
</td>
</tr>
<tr>
<td style="width: 18%">
<p>PIC32MK</p>
</td>
<td style="width: 10%">
<p>64-100</p>
</td>
<td style="width: 33%">
<p>512-1,024 KB ROM, 128-256 KB RAM</p>
</td>
<td style="width: 52.5813%">
<p>32-bit, 120 MHz, MIPS ISA, variant introduced in 2017. Targeted at industrial control and other forms of deeply integrated applications.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The PIC32 families are interesting in that they're based on an MIPS processor core, and use this <strong>Instruction Set Architecture</strong> (<strong>ISA</strong>) instead of the PIC ISA that's used by all other PIC MCUs. The processor core design they share is the M4K, a 32-bit MIPS32 core from MIPS Technology. Between these families, the differences are easy to spot when looking at the block diagrams from their respective datasheets.</p>
<p>The decades of development in the PIC line of microcontrollers are perhaps best made tangible in the form of functional block diagrams, so we start by looking at the PIC10:</p>
<div><img src="img/90869401-7d48-4657-b198-ad7556ad1ca8.png"/></div>
<p>These are very small MCUs, with barely any peripherals around a processor core not more closely defined here—and the referenced table only mentions the memory layout. The I/O port is very minimal and the I2C and UART interfaces we know today are not implemented as peripheral logic. To pick an example for a controller next in line, the PIC16F84 datasheet is very detailed in terms of processor architecture and shows that more power-up and reset circuitry has been added while also expanding GPIO and adding EEPROM for easy integrated non-volatile storage.  Self-contained serial peripherals are still absent.</p>
<p>Next, we'll have a look at the PIC18:</p>
<div><img src="img/e6ce1ab5-1c0f-4c29-b0c3-7e061f2310c5.png" style="width:43.92em;height:53.25em;"/></div>
<p>The PIC18 family is the latest 8-bit PIC architecture, with MCUs covering a wide range of applications. It has significantly more I/O options than the PIC10, PIC12, and PIC16 families, while also offering more options in terms of ROM and RAM and now providing USART in conjunction with a synchronous serial port for 4-wire SPI. Also note that the ports now have alternate pin functions and the routing from peripherals to the pins and the corresponding configuration registers are not shown for simplicity.</p>
<p>Next, let's observe the focus shifting from the core to Port and Peripheral capabilities in the  PIC24 functional block diagram:</p>
<div><img src="img/7c2d613d-7ecb-41b3-b888-92bc4c9eb493.png" style="width:57.17em;height:52.08em;"/></div>
<p>The diagram is similar to that of the PIC10, with the CPU abstracted away as a single block relative to the rest of the MCU. Each of the <kbd>PORT</kbd> blocks being a set of I/O pins, we're running out of space to display all the possible pin functions.</p>
<p>Each I/O pin can have a fixed function (linked with a peripheral module), or have an assignable function (hardware-level rerouting, or done in software). Generally, the more complex the MCU, the more likely it is that I/O pins are generic and not fixed-function.</p>
<p>Finally we have look at the PIC32:</p>
<div><img src="img/473399ca-4ada-4083-8265-cae721ce7a90.png"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This block diagram is for PIC32MX1XX/2XX devices in the PIC32MX family. It is usually clocked at 50 MHz.</p>
<p>An interesting property of the PIC32 architecture is that it effectively turns the Harvard architecture M4K MIPS CPU into a more John von Neumann-like architecture by having both program instructions and data travel over the System Bus Matrix.  Note that the space dedicated to a single processor register in the PIC10 diagram now casually depicts a complex digital or mixed signal peripheral, or the powerful JTAG in-circuit programming and debugging interface.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">AVR</h1>
                
            
            
                
<p>The AVR architecture was developed by two students at the Norwegian Institute of Technology, with the original AVR MCU developed at Nordic VLSI (now Nordic Semiconductor). It was originally known as μRISC and available for licensing until the technology was sold to Atmel. The first Atmel AVR MCU was released in 1997.</p>
<p>Today, we can look back on a multitude of 8-bit AVR families:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 9%">
<p><strong>Family</strong></p>
</td>
<td style="width: 10%">
<p><strong>Pins</strong></p>
</td>
<td style="width: 21.8896%">
<p><strong>Memories</strong></p>
</td>
<td style="width: 74.1104%">
<p><strong>Details</strong></p>
</td>
</tr>
<tr>
<td style="width: 9%">
<p>ATtiny</p>
</td>
<td style="width: 10%">
<p>6-32</p>
</td>
<td style="width: 21.8896%">
<p>0.5-16KB ROM<br/>
0-2 KB RAM</p>
</td>
<td style="width: 74.1104%">
<p>1.6-20 MHz. Compact, power-efficient MCUs, with limited peripherals.</p>
</td>
</tr>
<tr>
<td style="width: 9%">
<p>ATmega</p>
</td>
<td style="width: 10%">
<p>32-100</p>
</td>
<td style="width: 21.8896%">
<p>4-256 KB ROM<br/>
0.5-32 KB RAM</p>
</td>
<td style="width: 74.1104%">
<p> </p>
</td>
</tr>
<tr>
<td style="width: 9%">
<p>ATxmega</p>
</td>
<td style="width: 10%">
<p>44-100</p>
</td>
<td style="width: 21.8896%">
<p>16-384 KB ROM,<br/>
1-32 KB RAM</p>
</td>
<td style="width: 74.1104%">
<p>32 MHz, largest AVR MCUs, with extensive peripherals and performance-enhancing features such as DMA.</p>
</td>
</tr>
</tbody>
</table>
<p><br/>
There also used to be an 32-bit AVR32 architecture, but it was deprecated by Atmel as it moved to the ARM 32-bit architecture instead (SAM). See the <em>ARM-based MCU</em> section for more details on SAM. More detailed information is found in the corresponding <a href="http://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-45154-Product-Selection-Guide_Brochure.pdf">Product Selection Guide</a>.</p>
<p>Additionally, Atmel used to have so-called <strong>Field Programmable System Level Integrated Circuit</strong> (<strong>FPSLIC</strong>) MCUs: hybrid AVR/FPGA systems. These essentially allowed you to add your own peripherals and functionality to the hardware of an AVR MCU.</p>
<p class="mce-root"/>
<p>Let's look at the ATtiny family. This is the block diagram of the ATtiny212/412 series of MCUs:</p>
<div><img src="img/05383bb6-99ec-434c-b603-09548ed2532e.png"/></div>
<p class="mce-root"/>
<p class="mce-root CDPAlignLeft CDPAlign">This series of ATtiny MCUs can run up to 20 MHz, with up to 4 KB of Flash ROM and 256 bytes of SRAM, as well as up to 128 bytes of EEPROM, all in an 8-pin package. Despite its small size, it has a large number of peripherals, which can be routed to any supported pin:</p>
<div><img src="img/ad999a59-ffc7-4ab8-9089-7bf6be05bb22.png" style="width:30.58em;height:24.17em;"/></div>
<p>Contrast this with the popular ATmega2560 and related MCUs, which have the following properties:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Device</strong></p>
</td>
<td>
<p><strong>Flash (KB)</strong></p>
</td>
<td>
<p><strong>EEPROM (KB)</strong></p>
</td>
<td>
<p><strong>RAM (KB)</strong></p>
</td>
<td>
<p><strong>General purpose I/O pins</strong></p>
</td>
<td>
<p><strong>16-bit PWM channels</strong></p>
</td>
<td>
<p><strong>UART</strong></p>
</td>
<td>
<p><strong>ADC channels</strong></p>
</td>
</tr>
<tr>
<td>
<p>ATmega640</p>
</td>
<td>
<p>64</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>8</p>
</td>
<td>
<p>86</p>
</td>
<td>
<p>12</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>16</p>
</td>
</tr>
<tr>
<td>
<p>ATmega1280</p>
</td>
<td>
<p>128</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>8</p>
</td>
<td>
<p>86</p>
</td>
<td>
<p>12</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>16</p>
</td>
</tr>
<tr>
<td>
<p>ATmega1281</p>
</td>
<td>
<p>128</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>8</p>
</td>
<td>
<p>54</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>2</p>
</td>
<td>
<p>8</p>
</td>
</tr>
<tr>
<td>
<p>ATmega2560</p>
</td>
<td>
<p>256</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>8</p>
</td>
<td>
<p>86</p>
</td>
<td>
<p>12</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>16</p>
</td>
</tr>
<tr>
<td>
<p>ATmega2561</p>
</td>
<td>
<p>256</p>
</td>
<td>
<p>4</p>
</td>
<td>
<p>8</p>
</td>
<td>
<p>54</p>
</td>
<td>
<p>6</p>
</td>
<td>
<p>2</p>
</td>
<td>
<p>8</p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p class="mce-root"/>
<p>With GPIO pins numbering in the dozens, the block diagram is correspondingly more complex, with many more port blocks for the I/O pins:</p>
<div><img src="img/ce7750cb-a33d-49af-842d-a414db0e2b60.png"/></div>
<p>Here, all the incoming and outgoing arrows indicate a single pin or block of pins, most of them general-purpose. Because of the large number of pins, it is no longer practical to use an inline package format (DIP, SOIC, and so on) for the physical chip.</p>
<p>For the ATmega640, 1280 and 2560, a 100-pin TQFP package is used, here with the functionality of each pin indicated as found in its datasheet:</p>
<div><img src="img/7d0a8e35-d4cb-4e8b-825f-247338630835.png"/></div>
<p class="mce-root"/>
<p>The ATxmega family is very similar to the ATmega, with a similar pinout, mostly differentiating themselves using architectural changes and optimizations, more ROM and RAM, and peripheral options.</p>
<p>Whether to pick an ATtiny, ATmega, or ATxmega MCU depends first and foremost on the requirements you have for your project, specifically the required input and output, types of peripherals (serial, SPI, I2C, CAN, and so on), and the size of both the code and the RAM required to run this code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">M68k and Z80-based</h1>
                
            
            
                
<p>The Zilog Z80 8-bit processor is an Intel 8080-compatible processor, which competed with other microprocessors during the 1980s, powering home computers and gaming systems including the Nintendo Game Boy, Sega Master System, Sinclair ZX80/ZX81/Spectrum, MSX, and Tandy TRS-80.</p>
<p>Zilog introduced an MCU (Z380) based around the Z80 microprocessor in 1994, with various updates over the years, including the Z8, eZ80, and others. Z80 clones are also quite common.</p>
<p>Another popular 1980s era microprocessor is the Motorola 68k (or 68000). It's 16-bit for its ALU and external data bus, but with 32-bit registers and 32-bit internal data bus. After its introduction in 1979, its architecture is still in use today, with Freescale Semiconductor (now NXP) producing a number of 68k microprocessors.</p>
<p>Motorola introduced numerous MCUs based around the 68k architecture, including the MC68320 communications controller in 1989. Current 68k-based MCU designs include the ColdFire, which is a fully 32-bit design.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">ARM Cortex-M</h1>
                
            
            
                
<p>A very common type of 32-bit MCU is the ARM Cortex-M family. It includes the M0, M0+, M1, M3, M4, M7, M23, and M33, with a number of them having a <strong>floating point unit</strong> (<strong>FPU</strong>) option for increased floating point performance.</p>
<p>Not only are they used as standalone MCUs, they are also commonly integrated into <strong>System-on-Chip</strong> (<strong>SoC</strong>) devices to provide specific functionality, such as touchscreen, sensor, or power management functionality. As Arm Holdings doesn't manufacture any MCUs themselves, many third-party manufacturers have licensed the designs, sometimes making their own modifications and improvements.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here is a brief overview of these MCUs:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Core</strong></p>
</td>
<td>
<p><strong>Announced</strong></p>
</td>
<td>
<p><strong>Architecture</strong></p>
</td>
<td>
<p><strong>Instruction set</strong></p>
</td>
</tr>
<tr>
<td>
<p>M0</p>
</td>
<td>
<p>2009</p>
</td>
<td>
<p>Armv6-M</p>
</td>
<td>
<p>Thumb-1, some of Thumb-2.</p>
</td>
</tr>
<tr>
<td>
<p>M0+</p>
</td>
<td>
<p>2012</p>
</td>
<td>
<p>Armv6-M</p>
</td>
<td>
<p>Thumb-1, some of Thumb-2.</p>
</td>
</tr>
<tr>
<td>
<p>M1</p>
</td>
<td>
<p>2007</p>
</td>
<td>
<p>Armv6-M</p>
</td>
<td>
<p>Thumb-1, some of Thumb-2.</p>
</td>
</tr>
<tr>
<td>
<p>M3</p>
</td>
<td>
<p>2004</p>
</td>
<td>
<p>Armv7-M</p>
</td>
<td>
<p>Thumb-1, Thumb-2.</p>
</td>
</tr>
<tr>
<td>
<p>M4</p>
</td>
<td>
<p>2010</p>
</td>
<td>
<p>Armv7-M</p>
</td>
<td>
<p>Thumb1, Thumb-2, optional FPU.</p>
</td>
</tr>
<tr>
<td>
<p>M7</p>
</td>
<td>
<p>2014</p>
</td>
<td>
<p>Armv7E-M</p>
</td>
<td>
<p>Thumb-1, Thumb-2, optional FPU.</p>
</td>
</tr>
<tr>
<td>
<p>M23</p>
</td>
<td>
<p>2016</p>
</td>
<td>
<p>Armv8-M</p>
</td>
<td>
<p>Thumb-1, some of Thumb-2.</p>
</td>
</tr>
<tr>
<td>
<p>M33</p>
</td>
<td>
<p>2016</p>
</td>
<td>
<p>Armv8-M</p>
</td>
<td>
<p>Thumb 1, Thumb-2, optional FPU.</p>
</td>
</tr>
</tbody>
</table>
<p><br/>
The <strong>Thumb</strong> instruction sets are compact, 16-bit-length instructions, making them ideal for embedded, resource-restricted systems. Other ARM microprocessor families can also support this Thumb instruction set in addition to the 32-bit instruction set.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">H8 (SuperH)</h1>
                
            
            
                
<p>H8 family MCUs were commonly used with 8-, 16-, and 32-bit variations. Originally created in the early 1990s by Hitachi, new designs were still being created by Renesas Technology until a few years ago, though the latter recommends new designs use the RX (32-bit) or RL78 (16-bit) families. A notable use of an H8 MCU is in the Lego Mindstorms RCX controller, which uses an H8/300 MCU.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">ESP8266/ESP32</h1>
                
            
            
                
<p>The ESP family are 32-bit MCUs that are produced by Espressif Systems, with integrated Wi-Fi (both) and Bluetooth (ESP32) functionality.</p>
<p>The ESP8266 first appeared in 2014, when it was sold by a third-party manufacturer, Ai-Thinker, in the form of a module (ESP-01) that could be used by another MCU or microprocessor-based systems to provide Wi-Fi functionality. The ESP-01 module contained firmware for this purpose, which allowed the module to be addressed using Hayes-style modem commands.</p>
<p class="mce-root"/>
<p>Its system specifications are as follows:</p>
<ul>
<li>Tensilica Xtensa Diamond Standard L106 microprocessor (32-bit)</li>
<li>80-160 MHz CPU speed</li>
<li>Less than 50 KB of RAM available for user applications (with Wi-Fi stack loaded)</li>
<li>External SPI ROM (512 KB to 16 MB)</li>
<li>Wi-Fi support for 802.11 b/g/n</li>
</ul>
<p>As the 32-bit MCU on the ESP-01 module was found to be capable of far more than the simple modem task assigned to it, it soon came to be used for more general-purpose tasks, with a range of upgraded ESP8266 modules (with integrated EEPROM chip), as well as breakout boards. Of the latter, the NodeMCU-style board has become very popular, though a number of other third-party manufacturers have made their own breakout boards, which provide different form factors and functionality.</p>
<p>The basic block diagram for the ESP8266EX looks as follows:</p>
<div><img src="img/f0bed65c-4e5c-4765-9d54-34ed7cdd3ee6.png"/></div>
<p class="mce-root"/>
<p>After the immense success of the ESP8266, Espressif Systems developed the ESP32, which used an upgraded, dual-core CPU, among other changes. Its block diagram looks like this:</p>
<div><img src="img/56fe4fde-18fb-4f1c-b82f-4f07034f5fc3.png" style="width:36.25em;height:32.50em;"/></div>
<p class="mce-root"/>
<p>Its specifications are as follows:</p>
<ul>
<li>Xtensa 32-bit LX6 (dual-core) microprocessor</li>
<li>160-240 MHz CPU speed</li>
<li>520 KB of SRAM</li>
<li>Wi-Fi support for 802.11 b/g/n</li>
<li>Bluetooth v4.2 and BLE (low energy)</li>
</ul>
<p>Both the ESP8266 and ESP32 are generally sold as complete modules, with the MCU, external ROM module, and a Wi-Fi antenna either integrated into the board or with an external antenna option:</p>
<div><img src="img/e66a9c6a-5202-4624-ac38-6a6d2b8273ca.png" style="width:38.42em;height:38.42em;"/></div>
<p>The metal shielding can covering the board helps to protect the board from electromagnetic interference,  benefiting its Wi-Fi (and Bluetooth, in the case of the ESP32) transceiver, but the whole design with a fixed antenna and geometry is required for FCC certification and later use as an approved module. Connecting an external antenna with higher gain may violate local regulations. The FCC ID it comes with is instrumental in getting a product containing such a module approved for commercialization.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Others</h1>
                
            
            
                
<p>In addition to the previously listed MCUs, there is a wide range of MCUs available from a number of manufacturers with different architectures. Some, like the Propeller MCU from Parallax with its multi-core architecture, are fairly unique, whereas most simply implement the usual single-core CPU architecture with a number of peripherals, RAM, and internal or external ROM.</p>
<p>Beyond physical chips, Altera (now Intel), Lattice Semiconductor, and Xilinx provide so-called soft cores, which are MCUs that are meant to be run on a FPGA chip, either as standalone components or as part of a larger design on that FPGA. These can also be targeted by C/C++ compilers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Challenges</h1>
                
            
            
                
<p>The main development challenges with MCUs lie in the relatively limited resources that are available. Especially with the small, low-pin-count MCUs, you have to have a good idea of how many resources (CPU cycles, RAM, and ROM) a particular piece of code takes up, and whether it's realistic to add a specific feature.</p>
<p>This also means that picking the right MCU for a particular project takes both technical knowledge and experience. The former is required to pick an MCU that will suit the task; the latter is very helpful for the optimal MCU and helps to shorten the time that's required to make a choice.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">System-on-Chip/Single Board Computer</h1>
                
            
            
                
<p><strong>Systems-on-Chips</strong> (<strong>SoCs</strong>) are similar to MCUs, but distinguish themselves from those types of embedded systems by having some level of integration while still requiring a number of external components to function. They are commonly found as part of a single board implementation (<strong>Single Board Computer</strong> (<strong>SBC</strong>)), including the PC/104 standard, and more recently form factors such as the Raspberry Pi and derivative boards:</p>
<div><img src="img/4dae667e-c4de-480b-9abb-3fda933f6019.png"/></div>
<p>This diagram was used from <a href="https://xdevs.com/article/rpi3_oc/">https://xdevs.com/article/rpi3_oc/</a>. It clearly shows how an SBC (in this case, the Raspberry Pi 3) is laid out. The BCM2837 is the ARM-based SoC, providing the CPU core and basic peripherals (mostly broken out into the header section). All of the RAM is in an external module, as are the Ethernet and Wi-Fi peripherals. ROM is provided in the form of an SD (Flash) card, which also provides storage.</p>
<p>Most SoCs are ARM-based (Cortex-A family), though MIPS is quite common as well. SBCs are commonly used in industrial settings.</p>
<p>Other instances are mass produced boards, such as those for smartphones, which do not form a predefined form factor, but still follow the same pattern of having the SoC and external RAM, ROM, and storage, as well as various peripherals. This is in contrast with the MCUs of the previous section, which would always be able to function by themselves, except for the few requiring an external ROM.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Challenges</h1>
                
            
            
                
<p>Compared to MCUs, the development challenges of SoCs tend to be far less severe. Some of them are on the level and have an interface where you can even develop directly on the device, even doing compilation cycles on the device without having to do cross-compilation on a PC and copying over the binary. This is also helped by running a full OS instead of developing for the bare hardware.</p>
<p>The obvious disadvantage is that with this increase in features comes an increase in complexity, and the resulting complications, such as having to deal with user accounts, setting permissions, managing device drivers, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we got an in-depth look at what constitutes an embedded system. We learned how to distinguish between the various types of embedded systems, as well as how to determine the basics of picking the right MCU or SoC for a project.</p>
<p>After this chapter, the reader should feel comfortable reading through datasheets for MCUs and SoCs, explaining the differences between both, and determining what is needed for a given project.</p>
<p>The next chapter will look at why C++ is a highly suitable choice for the programming of embedded systems.</p>


            

            
        
    </body></html>