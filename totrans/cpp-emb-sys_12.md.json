["```cpp\n    #include <cstdio>\n    void print_int(int value) {\n        printf(\"value = %d\\n\", value);\n    }\n    int main() {\n        float pi = 3.14f;\n     // int implicitly converts to float\n     print_int(pi);\n     return 0;\n    } \n    ```", "```cpp\n    int get_int() {\n        float pi = 3.14;\n     // float implicitly converts to int\n     return pi;\n    } \n    ```", "```cpp\n    #include <cstdio>\n    int main() {\n        int int_value = 5;\n        float float_value = 4.2;\n     // int converts to float\n     auto result = int_value + float_value;\n     printf(\"result = %f\\n\", result);\n\n     return 0;\n    } \n    ```", "```cpp\n    char input = 'B';\n    // implicit conversion from char to int\n    switch (input) {\n     case 65:\n     printf(\"Input is 'A'\\n\");\n     break;\n     case 66:\n     printf(\"Input is 'B'\\n\");\n     break;\n     default:\n     printf(\"Unknown input\");\n    } \n    ```", "```cpp\n    #include <cstdio>\n    int main() {\n        int int_value = 10;\n     // int implicitly converts to bool\n     if (int_value) {\n     printf(\"true\\n\");\n     }\n     return 0;\n    } \n    ```", "```cpp\n#include <cstdint>\n#include <type_traits>\nint main() {\n    std::uint8_t a = 1;\n    std::uint16_t b = 42;\n    auto res1 = a + b;\n    static_assert(std::is_same_v<int, decltype(res1)>);\n    return 0;\n} \n```", "```cpp\n#include <type_traits>\nint main() {\n    struct bitfield{\n        long long a:31;\n    };\n    bitfield b {4};\n    int c = 1;\n    auto res1 = b.a + c;  \n    static_assert(sizeof(int) == 4);\n    static_assert(sizeof(long long) == 8);\n    static_assert(std::is_same_v<int, decltype(res1)>);\n    long e = 5;\n    auto res2 = e - b.a;\n    static_assert(std::is_same_v<long, decltype(res2)>);\n    return 0;\n} \n```", "```cpp\n$ cmake -B build -DMAIN_CPP_FILE_NAME=\"main_usual_arithmetic_conversion.cpp\"\n$ cmake --build build --target run_in_renode \n```", "```cpp\n#include <cstdio>\nint main() {\n    int a = -4;\n    unsigned int b = 3;\n    if(a + b > 0) {\n        printf(\"%d + % u is greater than 0\\r\\n\", a, b);\n    }\n    return 0;\n} \n```", "```cpp\n#include <cstdio> \nvoid print_ints(int * arr, std::size_t len) {\n    for(std::size_t i = 0; i < len; i++) {\n        printf(\"%d\\r\\n\", arr[i]);\n    }\n}\n int main() { \n    int array_ints[3] = {1, 2, 3};\n    print_ints(array_ints, 3);\n    return 0; \n} \n```", "```cpp\n#include <cstdio> \n#include <span>\nvoid print_ints(const std::span<int> arr) {\n    for(int elem: arr) {\n        printf(\"%d\\r\\n\", elem);\n    }\n}\nint main() { \n    int arr[3] = {1, 2, 3};\n    print_ints(arr);\n    return 0; \n} \n```", "```cpp\n#include <cstdio> \n#include <type_traits>\nvoid print_hello() {\n    printf(\"Hello!\\r\\n\");\n}\nint main() { \n    void(*fptr)() = print_hello;\n    fptr();\n    fptr = &print_hello;\n    (*fptr)();\n    static_assert(std::is_same_v<decltype(fptr), void(*)()>);\n    static_assert(std::is_same_v<decltype(print_hello), void()>);\n    return 0; \n} \n```", "```cpp\n#include <cstdio>\nvoid print_num(int & num) {\n    printf(\"num is %d\\r\\n\", num);\n}\nint main() {\n    const int num = 42;\n    print_num(const_cast<int&>(num));\n    int & num_ref = const_cast<int&>(num);\n    num_ref = 16;\n    return num;\n} \n```", "```cpp\nProgram returned: 42\nnum is 42 \n```", "```cpp\n#include <cstdio>\nstruct Base {\n    void hi() {\n        printf(\"Hi from Base\\r\\n\");\n    }\n};\nstruct Derived : public Base {\n    void hi() {\n        printf(\"Hi from Derived\\r\\n\");\n    }\n};\nint main() {\n    // unsigned to signed int \nint a = -4; \n    unsigned int b = 3; \n    if(a + static_cast<int>(b) > 0) { \n        printf(\"%d + %d is greater than 0\\r\\n\", a, b); \n    } \n    else {\n        printf(\"%d + %d is not greater than 0\\r\\n\", a,b); \n    }\n    // discard an expression\nint c;\n    static_cast<void>(c);\n    Derived derived;\n    // implicit upcast\n    Base * base_ptr = &derived;\n    base_ptr->hi();\n    // downcast\n    Derived *derived_p = static_cast<Derived*>(base_ptr);\n    derived_p->hi();\n    return 0;\n} \n```", "```cpp\n-4 + 3 is not greater than 0\nHi from Base\nHi from Derived \n```", "```cpp\n#include <cstdio>\nstruct Base {\n    void hi() {\n printf(\"Hi from Base\\r\\n\");\n }\n};\nstruct Derived : public Base {\n    void hi() {\n printf(\"Hi from Derived, x = %d\\r\\n\", x);\n }\n    int x = 42;\n};\nint main() {\n Base base;\n Derived *derived_ptr = static_cast<Derived*>(&base);\n derived_ptr->hi();\n return 0;\n} \n```", "```cpp\nHi from Derived, x = 1574921984 \n```", "```cpp\n#include <cstdio>\nstruct Base {\n    virtual void hi() {\n        printf(\"Hi from Base\\r\\n\");\n    }\n};\nstruct Derived : public Base {\n    void hi() override {\n        printf(\"Hi from Derived\\r\\n\");\n    }\n    void derived_only() {\n        printf(\"Derived only method\\r\\n\");\n    }\n};\nvoid process(Base *base) {\n    base->hi();\n    if(auto ptr = dynamic_cast<Derived*>(base); ptr ! = nullptr) \n    {\n        ptr->derived_only();\n    }\n}\nint main() {\n    Base base;\n    Derived derived;\n    Base * base_ptr = &derived;\n    process(&base);\n    process(base_ptr);\n    return 0;\n} \n```", "```cpp\n#include <cstdio>\n#include <cstdint>\nint fun() {\n    printf(\"fun\\r\\n\");\n    return 42;\n}\nint main() {\n    float f = 3.14f;\n    // initialize pointer to an int with float address\nauto a = reinterpret_cast<int*>(&f);\n    printf(\"a = %d\\r\\n\", *a);\n    // the above is same as:\n    a = static_cast<int*>(static_cast<void*>(&f));\n    printf(\"a = %d\\r\\n\", *a);\n    // casting back to float pointer\nauto fptr = reinterpret_cast<float*>(a);\n    printf(\"f = %.2f\\r\\n\", *fptr);\n    // converting a pointer to integer\nauto int_val = reinterpret_cast<std::uintptr_t>(fptr);\n    printf(\"Address of float f is 0x%8X\\r\\n\", int_val);\n    auto fun_void_ptr = reinterpret_cast<void(*)()>(fun);\n    // undefined behavior\nfun_void_ptr();\n    auto fun_int_ptr = reinterpret_cast<int(*)()>(fun);\n    // safe call\nprintf(\"fun_int_ptr returns %d\\r\\n\", fun_int_ptr());\n    return 0;\n} \n```", "```cpp\n$ cmake -B build -DMAIN_CPP_FILE_NAME=\"main_reinterpret_cast.cpp\"\n$ cmake --build build --target run_in_renode \n```", "```cpp\na = 1078523331\na = 1078523331\nf = 3.14\nAddress of float f is 0x20003F18\nfun\nfun\nfun_int_ptr returns 42 \n```", "```cpp\n#include <cstdio>\n#include <cstdint>\n#include <cstring>\nnamespace {\nstruct my_struct {\n    int a;\n    char c;\n};\nvoid print_my_struct (const my_struct & str) {\n    printf(\"a = %d, c = %c\\r\\n\", str.a, str.c);\n}\nvoid process_data(const char * data) {\n    const auto *pstr = reinterpret_cast<const my_struct *>(data);\n    printf(\"%s\\r\\n\", __func__);\n    print_my_struct(pstr[0]);\n    print_my_struct(pstr[1]);\n}\nvoid process_data_memcpy(const char * data) {\n    my_struct my_structs[2];\n    std::memcpy(my_structs, data, sizeof(my_structs));\n    printf(\"%s\\r\\n\", __func__);\n    print_my_struct(my_structs[0]);\n    print_my_struct(my_structs[1]);\n}\n};\nint main() {\n    int i = 42;\n    auto * i_ptr = reinterpret_cast<char*>(&i);\n    if(i_ptr[0]==42) {\n        printf(\"Little endian!\\r\\n\");\n    }\n    else {\n        printf(\"Big endian!\\r\\n\");\n    }\n    my_struct my_structs_arr[] = {{4, 'a'}, {5, 'b'}};\n    char arr[128];\n    std::memcpy(&arr, my_structs_arr, sizeof(my_structs_arr));\n    process_data(arr);\n    process_data_memcpy(arr);\n    return 0;\n} \n```", "```cpp\n$ cmake -B build -DMAIN_CPP_FILE_NAME=\"main_type_punning.cpp\"\n$ cmake --build build --target run_in_renode \n```", "```cpp\nLittle endian!\nprocess_data\na = 4, c = a\na = 5, c = b\nprocess_data_memcpy\na = 4, c = a\na = 5, c = b \n```", "```cpp\n#include <cstdio>\n#include <bit>\nint main() {\n    float f = 3.14f;\n    auto a = std::bit_cast<int>(f);\n    printf(\"a = %d\\r\\n\", a);\n    return 0;\n} \n```", "```cpp\na = 1078523331 \n```", "```cpp\n/**\n  * @brief Start the direct connection establishment procedure.\nA LE_Create_Connection call will be made to the controller by GAP with the initiator filter policy set to \"ignore whitelist and\nprocess connectable advertising packets only for the specified\ndevice\".\n  * @param LE_Scan_Interval This is defined as the time interval from when the Controller started its last LE scan until it begins the subsequent LE scan.\nTime = N * 0.625 msec.\n  * Values:\n  - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms)\n  * @param LE_Scan_Window Amount of time for the duration of the LE scan. LE_Scan_Window\nshall be less than or equal to LE_Scan_Interval.\nTime = N * 0.625 msec.\n  * Values:\n  - 0x0004 (2.500 ms)  ... 0x4000 (10240.000 ms)\n  * @param Peer_Address_Type The address type of the peer device.\n  * Values:\n  - 0x00: Public Device Address\n  - 0x01: Random Device Address\n  * @param Peer_Address Public Device Address or Random Device Address of the device\nto be connected.\n    * @param Conn_Interval_Min Minimum value for the connection event interval. This shall be less than or equal to Conn_Interval_Max.\nTime = N * 1.25 msec.\n  * Values:\n  - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)\n  * @param Conn_Interval_Max Maximum value for the connection event interval. This shall be\ngreater than or equal to Conn_Interval_Min.\nTime = N * 1.25 msec.\n  * Values:\n  - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)\n  * @param Conn_Latency Slave latency for the connection in number of connection events.\n  * Values:\n  - 0x0000 ... 0x01F3\n  * @param Supervision_Timeout Supervision timeout for the LE Link.\nIt shall be a multiple of 10 ms and larger than (1 + connSlaveLatency) * connInterval * 2.\nTime = N * 10 msec.\n  * Values:\n  - 0x000A (100 ms)  ... 0x0C80 (32000 ms)\n  * @param Minimum_CE_Length Information parameter about the minimum length of connection needed for this LE connection.\nTime = N * 0.625 msec.\n  * Values:\n  - 0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms)\n  * @param Maximum_CE_Length Information parameter about the maximum length of connection needed\nfor this LE connection.\nTime = N * 0.625 msec.\n  * Values:\n  - 0x0000 (0.000 ms)  ... 0xFFFF (40959.375 ms)\n  * @retval Value indicating success or error code.\n*/\ntBleStatus aci_gap_create_connection(\n uint16_t LE_Scan_Interval,\n uint16_t LE_Scan_Window,\n uint8_t Peer_Address_Type,\n uint8_t Peer_Address[6],\n uint16_t Conn_Interval_Min,\n uint16_t Conn_Interval_Max,\n uint16_t Conn_Latency,\n uint16_t Supervision_Timeout,\n uint16_t Minimum_CE_Length,\n uint16_t Maximum_CE_Length); \n```", "```cpp\n#define CONN_L(x) ((int)((x) / 0.625f))\n#define CONN_P(x) ((int)((x) / 1.25f)) \n```", "```cpp\ntBleStatus status = aci_gap_create_connection(CONN_L(80), CONN_L(120), PUBLIC_ADDR, mac_addr, CONN_P(50), CONN_P(60), 0, SUPERV_TIMEOUT, CONN_L(10), CONN_L(15)); \n```", "```cpp\ntBleStatus aci_gap_create_connection_wrapper(\n                            conn_l LE_Scan_Interval,\n                            conn_l LE_Scan_Window,\n uint8_t Peer_Address_Type,\n uint8_t Peer_Address[6],\n                            conn_p Conn_Interval_Min,\n                            conn_p Conn_Interval_Max,\n uint16_t Conn_Latency,\n uint16_t Supervision_Timeout,\n                            conn_l Minimum_CE_Length,\n                            conn_l Maximum_CE_Length); \n```", "```cpp\nclass conn_l {\nprivate:\n    uint16_t time_;\npublic:\n explicit conn_l(float time_ms) : time_(time_ms/0.625f){}\n    uint16_t & get() {return time_;}\n};\nclass conn_p {\nprivate:\n    uint16_t time_;\npublic:\n explicit conn_p(float time_ms) : time_(time_ms/1.25f){}\n    uint16_t & get() {return time_;}\n}; \n```", "```cpp\n tBleStatus stat = aci_gap_create_connection_wrapper(\n            conn_l(80),\n            conn_l(120),\n            PUBLIC_ADDR,\n            nullptr,\n            conn_p(50),\n            conn_p(60),\n            0,\n            SUPERV_TIMEOUT,\n            conn_l(10),\n            conn_l(15)\n    ); \n```", "```cpp\n$ cmake -B build -DMAIN_CPP_FILE_NAME=\"main_strong_types.cpp\"\n$ cmake --build build --target run_in_renode \n```", "```cpp\nclass time {\nprivate:\n    uint16_t time_in_ms_;\npublic:\n explicit time(uint16_t time_in_ms) : time_in_ms_(time_in_ms){}\n    uint16_t & get_ms() {return time_in_ms_;}\n};\ntime operator\"\"_ms(unsigned long long t) {\n    return time(t);\n}\nclass conn_l {\nprivate:\n    uint16_t val_;\npublic:\n explicit conn_l(time t) : val_(t.get_ms()/0.625f){}\n    uint16_t & get() {return val_;}\n};\nclass conn_p {\nprivate:\n    uint16_t val_;\npublic:\n explicit conn_p(time t) : val_(t.get_ms()/1.25f){}\n    uint16_t & get() {return val_;}\n}; \n```", "```cpp\n tBleStatus stat = aci_gap_create_connection_wrapper(\n            conn_l(80_ms),\n            conn_l(120_ms),\n            PUBLIC_ADDR,\n            nullptr,\n            conn_p(50_ms),\n            conn_p(60_ms),\n            0_ms,\n            4000_ms,\n            conn_l(10_ms),\n            conn_l(15_ms)\n    ); \n```"]