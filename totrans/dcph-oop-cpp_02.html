<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-39"><a id="_idTextAnchor072"/>2</h1>
<h1 id="_idParaDest-40"><a id="_idTextAnchor073"/>Adding Language Necessities</h1>
<p>This chapter will introduce necessary non-OO features of C++ that are critical building blocks for C++’s object-oriented features. The features presented in this chapter represent topics that you will see matter-of-factly used from this point onward in the book. C++ is a language shrouded in areas of gray; from this chapter forward, you will become versed in not only language features, but in language nuances. The goal of this chapter will be to begin enhancing your skills from those of an average C++ programmer to one who is capable of operating among language subtleties successfully while creating maintainable code.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>The <code>const</code> qualifier</li>
<li>Function prototyping</li>
<li>Function overloading</li>
</ul>
<p>By the end of this chapter, you will understand non-OO features such as the <code>const</code> qualifier, function prototyping (including using default values), and function overloading (including how standard type conversion affects overloaded function choices and may create potential ambiguities). Many of these seemingly straightforward topics include an assortment of interesting details and nuances. These skills will be necessary in order to move forward with the next chapters in the book successfully.</p>
<h1 id="_idParaDest-41"><a id="_idTextAnchor074"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter02">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter02</a>. Each full program example can be found in the GitHub under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in <a href="B19087_02.xhtml#_idTextAnchor072"><em class="italic">Chapter 2</em></a>, <em class="italic">Adding Language Necessities</em>, can be found in the subdirectory <code>Chapter02</code> in a file named <code>Chp2-Ex1.cpp</code> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3CM65dF">https://bit.ly/3CM65dF</a>.</p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor075"/>Using the const and constexpr qualifiers</h1>
<p>In this section, we will add the <code>const</code> and <code>constexpr</code> qualifiers to variables, and discuss how <a id="_idIndexMarker095"/>they can be added to functions in both their input parameters and as return values. These qualifiers will be used quite liberally as we move <a id="_idIndexMarker096"/>forward in the C++ language. The use of <code>const</code> and <code>constexpr</code> can enable values to be initialized, yet never again modified. Functions can advertise that they will not modify their input parameters, or that their return value may only be captured (but not modified) by using <code>const</code> or <code>constexpr</code>. These qualifiers help make C++ a more secure language. Let’s take a look a<a id="_idTextAnchor076"/>t <code>const</code> and <code>constexpr</code> in action<a id="_idTextAnchor077"/>.</p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor078"/>const and constexpr variables</h2>
<p>A <code>const</code> qualified <a id="_idIndexMarker097"/>variable is a variable that must be initialized, and may never be assigned a new value. It is seemingly a paradox to pair the usage of <code>const</code> and a variable together – <code>const</code> implies not to change, yet the concept of a <a id="_idIndexMarker098"/>variable is to inherently hold different values. Nonetheless, it is useful to have a strongly type-checked variable whose one and only value can be determined at run time. The keyword <code>const</code> is added to the variable declaration. </p>
<p>Similarly, a variable declared using <code>constexpr</code> is a constant qualified variable – one that may be initialized and never assigned a new value. The usage of <code>constexpr</code> is becoming preferred whenever its use is possible. </p>
<p>In some situations, the value of a constant is not known at compile time. An example might be if user input or the return value of a function is used to initialize a constant. A <code>const</code> variable may be easily initialized at runtime. A <code>constexpr</code> can often, but not always be initialized at runtime. We will consider various scenarios in our example.</p>
<p>Let’s consider a few examples in the following program. We will break this program into two segments for a more targeted explanation, however, the full program example can be <a id="_idIndexMarker099"/>found in <a id="_idIndexMarker100"/>its entirety at the following link:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex1.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;cstring&gt; // though, we'll prefer std:: string,
// char [ ] demos the const qualifier easily in cases below
using std::cout;     // preferable to: using namespace std;
using std::cin;
using std::endl;
using std::setw;
// simple const variable declaration and initialization
// Convention will capitalize those known at compile time
// (those taking the place of a former macro #define)
<strong class="bold">const int MAX = 50; </strong>
// simple constexpr var. declaration and init. (preferred)
<strong class="bold">constexpr int LARGEST = 50;</strong>
constexpr int Minimum(int a, int b)  
// function definition w formal parameters
<a id="_idTextAnchor079"/>{
    return (a &lt; b)? a : b;   // conditional operator ?: 
}</pre>
<p>In the previous program segment, notice how we declare a variable with the <code>const</code> qualifier preceding the data type. Here, <code>const int MAX = 50;</code> simply initializes <code>MAX</code> to 50. <code>MAX</code> may not be modified via assignment later in the code. Out of convention, simple <code>const</code> and <code>constexpr</code> qualified variables (taking the place of once used <code>#define</code> macros) are often capitalized, whereas values that are calculated (or might be calculated) are declared using typical naming conventions. Next, we introduce a constant variable using <code>constexpr int LARGEST = 50;</code> to declare a variable that likewise cannot be modified. This option is becoming the preferred usage but is not always possible to utilize.</p>
<p>Next, we have <a id="_idIndexMarker101"/>the definition for function <code>Minimum()</code>; notice the use of the ternary conditi<a id="_idTextAnchor080"/>onal operator <code>?:</code> in this function body. Also notice <a id="_idIndexMarker102"/>that this function’s return value is qualified with <code>constexpr</code> (we will examine this shortly). Next, let’s examine the body of the <code>main()</code> function as we continue with the remainder of this program:</p>
<pre class="source-code">
int main()
{
    int x = 0, y = 0;
    // Since 'a', 'b' could be calculated at runtime
    // (such as from values read in), we will use lowercase
    <strong class="bold">constexpr int a = 10, b = 15</strong>;<a id="_idTextAnchor081"/>// both 'a', 'b' are const
    cout &lt;&lt; "Enter two &lt;int&gt; values: ";
    cin &gt;&gt; x &gt;&gt; y;
    // const variable initialized w return val. of a fn.
    <strong class="bold">const int min = Minimum(x, y);</strong>  
    cout &lt;&lt; "Minimum is: " &lt;&lt; min &lt;&lt; endl;
    // constexpr initialized with return value of function
    <strong class="bold">constexpr int smallest = Minimum(a, b);</strong>           
    cout &lt;&lt; "Smallest of " &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " is: " 
         &lt;&lt; smallest &lt;&lt; endl;
    char bigName[<strong class="bold">MAX</strong>] = {""};  // const used to size array
    char largeName[<strong class="bold">LARGEST</strong>] = {""}; // same for constexpr 
    cout &lt;&lt; "Enter two names: ";
    cin &gt;&gt; setw(MAX) &gt;&gt; bigName &gt;&gt; setw(LARGEST) &gt;&gt;
           largeName;
    <strong class="bold">const int namelen = strlen(bigName);</strong>   
    cout &lt;&lt; "Length of name 1: " &lt;&lt; namelen &lt;&lt; endl;
    cout &lt;&lt; "Length of name 2: " &lt;&lt; strlen(largeName) &lt;&lt;
             endl;
    return 0;
}</pre>
<p>In <code>main()</code>, let’s consider <a id="_idIndexMarker103"/>the sequence of code in which we <a id="_idIndexMarker104"/>prompt the user to <code>"Enter two values: "</code> into variables <code>x</code> and <code>y</code>, respectively. Here, we call a function <code>Minimum(x,y)</code> and pass as actual parameters our two values <code>x</code> and <code>y</code>, which were just read in using <code>cin</code> and the extraction operator <code>&gt;&gt;</code>. Notice that alongside the <code>const</code> variable declaration of <code>min</code>, we initialize <code>min</code> with the return value of the function call <code>Minimum()</code>. It is important to note that setting <code>min</code> is bundled as a single declaration and initialization. Had this been broken into two lines of code – a variable declaration followed by an assignment – the compiler would have flagged an error. Variables qualified with <code>const</code> may only be initialized with a value, and never assigned a value after declaration. </p>
<p>Next, we initialize <code>smallest</code> with the return value of function <code>Minimum(a, b);</code>. Notice that the parameters <code>a</code> and <code>b</code> are literal values that can be determined at compile time. Also notice the return value of the <code>Minimum()</code> function has been qualified with <code>constexpr</code>. This qualification is necessary in order for <code>constexpr smallest</code> to be initialized with the function’s return value. Note that had we tried to pass <code>x</code> and <code>y</code> to <code>Minimum()</code> to set <code>smallest</code>, we would get an error, as the values of <code>x</code> and <code>y</code> are not literal values. </p>
<p>In the last sequence <a id="_idIndexMarker105"/>of code in the previous example, notice <a id="_idIndexMarker106"/>that we use <code>MAX</code> (defined in the earlier segment of this full program example) to define a size for the fixed-sized array <code>bigName</code> in the declaration <code>char bigName[MAX];</code>. We similarly use <code>LARGEST</code> to define a size for the fixed-size array <code>largeName</code>. Here we see that either the <code>const</code> or <code>constexpr</code> can be used to size an array in this manner. We then further use <code>MAX</code> in <code>setw(MAX)</code> and <code>LARGEST</code> in <code>setw(LARGEST)</code> to ensure that we do not overflow <code>bigName</code> or <code>largeName</code>, while reading keyboard input with <code>cin</code> using the extraction operator <code>&gt;&gt;</code>. Finally, we initialize variable <code>const int namelen</code> with the return value of function <code>strlen(bigname)</code> and print this value out using <code>cout</code>. Note that because <code>strlen()</code> is not a function whose value is qualified with <code>constexpr</code>, we cannot use this return value to initialize a <code>constexpr</code>. </p>
<p>The output to accompany the aforementioned full program example is as follows:</p>
<pre>Enter two &lt;int&gt; values: 39 17
Minimum is: 17
Smallest of 10 15 is: 10
Enter two names: Gabby Dorothy
Length of name 1: 5
Length of name 2: 7</pre>
<p>Now that we have seen how to <code>const</code> and <code>constexpr</code> qualify variables, let’s consider constant qualification with functions.</p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor082"/>const qualification with functions</h2>
<p>The keywords <code>const</code> and <code>constexpr</code> can also be used in conjunction with functions. These qualifiers can be<a id="_idTextAnchor083"/> used among parameters to indicate that the parameters themselves will <a id="_idIndexMarker107"/>not be modified. This is a useful feature—the caller of the function will understand that the function will not <a id="_idTextAnchor084"/>modify input parameters qualified in these manners. However, because non-pointer (and non-reference) variables are passed <em class="italic">by value</em> to functions as copies of the actual parameters on the stack, <code>const</code> or <code>constexpr</code> qualifying these inherent copies of parameters does not serve a purpose. Hence, <code>const</code> or <code>constexpr</code> qualifying parameters that are of standard data types is not necessary.</p>
<p>The same principle applies to return values from functions. A return value from a function can be <code>const</code> or <code>constexpr</code> qualified; however, unless a pointer (or reference) is returned, the item passed back on the stack as the return value is a copy. For this reason, <code>const</code> qualified return values are more meaningful when the return type is a pointer to a constant object (which we will cover in <a href="B19087_03.xhtml#_idTextAnchor118"><em class="italic">Chapter 3</em></a>, <em class="italic">Indirect Addressing: Pointers</em>, and beyond). Note that a <code>constexpr</code> qualified return value is required of a function whose return value will be used to initialize a <code>constexpr</code> variable, as we <a id="_idIndexMarker108"/>have seen in our previous example. As one final use of <code>const</code>, we can utilize this keyword when we move onto OO details for a class to specify that a particular member function will not modify any data members of that class. We will look at this scenario in <a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Classes in Detail</em>.</p>
<p>Now that we understand the use of the <code>const</code> and <code>constexpr</code> qualifiers for variables and have seen pote<a id="_idTextAnchor085"/>ntial uses of <code>const</code> and <code>constexpr</code> in conjunction with functions, let us move onward to the next language feature in this chapter: function prototypes.</p>
<h1 id="_idParaDest-45"><a id="_idTextAnchor086"/>Working with function prototypes</h1>
<p>In this section, we will examine the mechanics of function prototyping, such as necessary <a id="_idIndexMarker109"/>placement in files and across multiple files for greater program flexibility. We will also add optional names to prototype arguments, as well as understand how and why we may choose to add default values to C++ prototypes. Function prototypes ensure C++ code is strongly type-checked. </p>
<p>Prior to proceeding to function prototypes, let’s take a moment to review some necessary <a id="_idIndexMarker110"/>programming terms. A <strong class="bold">function definition</strong> refers to the body of code comprising a function, whereas a declaration of a function (also known <a id="_idIndexMarker111"/>as a <strong class="bold">forward declaration</strong>) merely introduces a function name with its return type and argument types. Forward declarations allow the compiler to perform strong type checking between the function call and its definition by instead comparing the call with the forward declaration. Forward declarations are useful because function definitions do not always appear in a file prior to a function call; sometimes, function definitions appear in a separate file <a id="_idTextAnchor087"/>from their calls.</p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor088"/>Defining function prototypes</h2>
<p>A <strong class="bold">function prototype</strong> is a forward declaration of a function that describes how a function should <a id="_idIndexMarker112"/>be correctly invoked. A prototype ensures strong type checking between a function call and its definition. A simple function prototype consists of the following:</p>
<ul>
<li>Function’s return type</li>
<li>Function’s name</li>
<li>Function’s type and number of arguments</li>
</ul>
<p>A function prototype allows a function call to precede the function’s definition or allows for calls to functions that exist in separate files. As we learn about more C++ language features, such as exceptions, we will see that additional elements contribute to a function’s extended prototype (and extended signature). For now, let’s examine<a id="_idTextAnchor089"/> a simple example:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex2.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;     // preferred to: using namespace std;
u<a id="_idTextAnchor090"/>sing std:: endl;
<strong class="bold">[[nodiscard]] int Minimum(int, int);</strong>   // fn. prototype
    
int main()
{
    int x = 5, y = 89;
    // function call with actual parameters
    cout &lt;&lt; Minimum(x, y) &lt;&lt; endl;     
    return 0;                          
}
[[nodiscard]] int Minimum(int a, int b) // fn. definition
                                 // with formal parameters 
{
    return (a &lt; b)? a : b;  
}</pre>
<p>Notice that we prototype <code>int Minimum(int, int);</code> near the beginning of the aforementioned example. This prototype lets the compiler know that any calls to <code>Minimum()</code> should take two integer arguments and should return an integer value (we’ll discuss type conversions later in this section). </p>
<p>Also notice <a id="_idIndexMarker113"/>the use of <code>[[nodiscard]]</code> preceding the return type of the function. This indicates that the programmer should store the return value or otherwise utilize the return value (such as in an expression). The compiler will issue a warning if the return value of this function is ignored.  </p>
<p>Next, in the <code>main()</code> function, we call the function <code>Minimum(x, y)</code>. At this point, the compiler checks that the function call matches the aforementioned prototype with respect to type and number of arguments, and return type. Namely, that the two arguments are integers (or could easily be converted to integers) and that the return type is an integer (or could easily be converted to an integer). The return value will be utilized as a value to print using <code>cout</code>. Lastly, the function <code>Minimum()</code> is defined in the file. Should the function definition not match the prototype, the compiler will raise an error.</p>
<p>The existence of the prototype allows the call of a given function to be fully type-checked prior to the function’s definition being seen by the compiler. The current example is of course contrived to demonstrate this point; we could have instead switched the order in which <code>Minimum()</code> and <code>main()</code> appear in the file. However, imagine that the definition of <code>Minimum()</code> was contained in a separate file (the more typical scenario). In this case, the prototype will appear at the top of the file that will call this function (along with header file inclusions) so that the function call can be fully type-checked against the prototype.</p>
<p>In the aforementioned multiple file scenario, the file containing the function definition will be separately compiled. It will then be the linker’s job to ensure that when multiple files are linked together, the function definition and all prototypes match so that the linker can resolve <a id="_idIndexMarker114"/>any references to such function calls. Should the prototypes not match the function definition, the linker will not be able to link the various sections of code together into one compiled unit.</p>
<p>Let’s take a look at this example’s output:</p>
<pre>5</pre>
<p>Now that we understand function prototype basics, let’s see how we can add optional argument names to f<a id="_idTextAnchor091"/>unction prototypes.</p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor092"/>Naming arguments in function prototypes</h2>
<p>Function prototypes may optionally contain names that may differ from those in either the formal <a id="_idIndexMarker115"/>or actual parameter lists. Argument names are ignored by the compiler, yet can often enhance readability. Let’s revisit our previous example, adding optional argument names in th<a id="_idTextAnchor093"/>e function prototype:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex3.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;    // preferred to: using namespace std;
using std::endl;
// function prototype with opt<a id="_idTextAnchor094"/>ional argument names
[[nodiscard]] int Minimum(int <strong class="bold">arg1</strong>, int <strong class="bold">arg2</strong>);
 
int main()
{
    int x = 5, y = 89;
    cout &lt;&lt; Minimum(x, y) &lt;&lt; endl;      // function call
    return 0;
}
[[nodiscard]] int Minimum(int a, int b) // fn. definition
{
    return (a &lt; b)? a : b;  
}</pre>
<p>This example is nearly identical to the one preceding it. However, notice that the function prototype contains named arguments <code>arg1</code> and <code>arg2</code>. These identifiers are immediately <a id="_idIndexMarker116"/>ignored by the compiler. As such, these named arguments do not need to match either the formal or actual parameters of the function and are optionally present merely to <a id="_idTextAnchor095"/>enhance readability. </p>
<p>The output to accompany this example is the same as the previous example:</p>
<pre>5</pre>
<p>Next, let’s move forward with our discussion by adding a useful feature to function prototypes: default values.</p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor096"/>Adding default values to function prototypes</h2>
<p><strong class="bold">Default values</strong> may be <a id="_idIndexMarker117"/>specified in function prototypes. These values will be <a id="_idIndexMarker118"/>used in the absence of actual paramet<a id="_idTextAnchor097"/><a id="_idTextAnchor098"/>ers in the function call and will serve as the actual parameters themselves. Default values adhere to the following criteria:</p>
<ul>
<li>Default values must be specified from right to left in the function prototype, without omitting any values. </li>
<li>Actual parameters are substituted from left to right in the function call; hence the right to left order for default value specification in the prototype is significant.</li>
</ul>
<p>A function prototype may have all, some, or none of its values filled with default values, as long as the default values adhere to the aforementioned specifications.</p>
<p>Let’s see <a id="_idIndexMarker119"/>an example using default values:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex4.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex4.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;    // preferred to: using namespaces std;
using std::endl;
// fn. prototype with one default value
[[nodiscard]] int Minimum(int arg1, <strong class="bold">int arg2 = 100000</strong>);  
int main()
{
    int x = 5, y = 89;
    cout &lt;&lt; <strong class="bold">Minimum(x)</strong> &lt;&lt; endl; // function call with only
                             // one argument (uses default)
    cout &lt;&lt; <strong class="bold">Minimum(x, y)</strong> &lt;&lt; endl; // no default vals used
    return 0;
}
[[nodiscard]] int Minimum(int a, int b) // fn. definition
{
    return (a &lt; b)? a : b;  
}</pre>
<p>In this example, notice that a default value is added to the rightmost argument in the function prototype for <code>int Minimum(int arg1, int arg2 = 100000);</code>. This means that when <a id="_idTextAnchor099"/><code>Minimum()</code> is called from <code>main()</code>, it may be called with either one argument, <code>Minimum(x)</code>, or with two arguments, <code>Minimum(x, y)</code>. When <code>Minimum()</code> is called with a single argument, the single argument is bound to the leftmost <a id="_idIndexMarker120"/>argument in the formal parameters of the function, and the default value is bound to the next sequential argument in the formal parameter list. However, when <code>Minimum()</code> is called with two arguments, both of the actual parameters are bound to the formal parameters in the function; the de<a id="_idTextAnchor100"/>fault value is not used. </p>
<p>Here is the output for this example:</p>
<pre>5
5</pre>
<p>Now that we have a handle on default values within a function prototype, let’s expand on this idea by using different default values with prototypes in various program scopes.</p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor101"/>Prototyping with different default values in different scopes</h2>
<p>Functions may be prototyped in different scopes with different default values. This allows <a id="_idIndexMarker121"/>functions to be built generically and customized through prototypes within multiple applications or for use in multiple sections of code.</p>
<p>Here is an example illustrating multiple prototypes for the same function (in different scopes) using different default values:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex5.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex5.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;    // preferred to: using namespace std;
using std::endl;
// standard function prototype
[[nodiscard]] int Minimum(int, int);   
void Function1(int x)
{   
    // local prototype with default value
    <strong class="bold">[[nodiscard]] int Minimum(int arg1, int arg2 = 500);</strong> 
    cout &lt;&lt; Minimum(x) &lt;&lt; endl; 
}
void Function2(int x)
{
    // local prototype with default value
    <strong class="bold">[[nodiscard]] int Minimum(int arg1, int arg2 = 90);</strong>  
    cout &lt;&lt; Minimum(x) &lt;&lt; endl; 
}
    
[[nodiscard]] int Minimum(int a, int b) // fn. definition
{ 
    return (a &lt; b)? a : b;   
}
int main()
{
    Function1(30);    
    Function2(450);
    return 0;
}</pre>
<p>In this example, notice that <code>int Minimum(int, int);</code> is prototyped near the top of the file. Then notice that <code>Minimum()</code> is re-prototyped in the more local scope of <code>Function1()</code> as <code>int Minimum(int arg1, int arg2 = 500);</code>, spe<a id="_idTextAnchor102"/>cifying a default value of <code>500</code> for its rightmost argument. Likewise, in the scope of <code>Function2()</code>, function <code>Minimum()</code> is re-prototyped as <code>int Minimum(int arg1, int arg2 = 90);</code>, specifying a default value of <code>90</code> in the rightmost argument. When <code>Minimum()</code> is called from within <code>Function1()</code> or <code>Function2()</code>, the local prototypes in each of these function scopes, respectively, will be used – each with their own default values. </p>
<p>In <a id="_idIndexMarker122"/>this fashion, specific areas of a program may be easily customized with default values that may be meaningful within a specific portion of an application. However, be sure to <em class="italic">only</em> employ re-prototyping of a function with individualized default values within the scope of a calling function to ensure that this customization can be easily contained within the safety of a very limited scope. Never re-prototype a function in global scope with differing default values – this could lead to unexpect<a id="_idTextAnchor103"/>ed and error-prone results.</p>
<p>The output for the example is as follows:</p>
<pre>30
90</pre>
<p>Having now explored function prototypes with respect to default usage in single and multiple files, using default values in prototypes, and re-prototyping functions in different scopes with individual default values, we are now able to move forward with the last major topic in this chapter: function overloading.</p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor104"/>Understanding function overloading</h1>
<p>C++ allows for two or more functions that share a similar purpose, yet differ in the types or number <a id="_idIndexMarker123"/>of arguments they take, to co-exist with the same function name. This is known as <strong class="bold">function overloading</strong>. This allows more generic function calls to be made, leaving the compiler to choose the correct version of the function based on the type of the variable (object) using the function. In this section, we will add default values to the basics of function overloading to provide flexibility and customization. We will also learn how standard type conversions may impact function overloading, and <a id="_idIndexMarker124"/>potential ambiguities that may arise (as well as how to resolve those types of uncertainties).</p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor105"/>Learning the basics of function overloading</h2>
<p>When two or more functions with the same name exist, the differentiating factor between <a id="_idIndexMarker125"/>these similar functions will be their signature. By varying a function’s signature, two or more functions with otherwise identical names may exist in the same namespace. Function overloading depends on the signature of a function as follows:</p>
<ul>
<li>The <strong class="bold">signature of a function</strong> refers <a id="_idIndexMarker126"/>to a function’s name, plus its type and number of arguments.</li>
<li>A function’s return type is not included as part of its signature.</li>
<li>Two or more functions with the same purpose may share the same name, provided that their signatures differ.</li>
</ul>
<p>A function’s signature helps provide an internal, “mangled” name for each function. This encoding scheme guarantees that each function is uniquely represen<a id="_idTextAnchor106"/>ted internally to the compiler.</p>
<p>Let’s take a few minutes to understand a slightly larger example that will incorporate function overloading. To simplify the explanation, this example is broken into three segments; nonetheless, the full program can be found in its entirety at the following link:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex6.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex6.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;cmath&gt;
using std::cout;    // preferred to: using namespace std;
using std::endl;
constexpr float PI = 3.14159;
class Circle     // simple user defined type declarations
{
public:
   float radius;
   float area;
};
class Rectangle
{
public:
   float length;
   float width;
   float area;
};
<strong class="bold">void Display(Circle);</strong>     // 'overloaded' fn. prototypes
<strong class="bold">void Display(Rectangle);</strong>  // since they differ in signature</pre>
<p>At the <a id="_idIndexMarker127"/>beginning of this example, notice that we include the math library with <code>#include &lt;cmath&gt;</code>, to provide access to basic math functions, such as <code>pow()</code>. Next, notice the class definitions for <code>Circle</code> and <code>Rectangle</code>, each with relevant data members (<code>radius</code> and <code>area</code> for <code>Circle</code>; <code>length</code>, <code>width</code>, and <code>area</code> for <code>Rectangle</code>). Once these types have been defined, prototypes for two overloaded <code>Display()</code> functions are shown. Since the prototypes for the two display functions utilize user defined types <code>Circle</code> and <code>Rectangle</code>, it is important that <code>Circle</code> and <code>Rectangle</code> have both previously been defined. Now, let’s examine the body of the <code>main()</code> function as we continue with the next segment of this <a id="_idIndexMarker128"/>program:</p>
<pre class="source-code">
int main()
{
    Circle myCircle;
    Rectangle myRect;
    Rectangle mySquare;
    myCircle.radius = 5.0;
    myCircle.area = PI * pow(myCircle.radius, 2.0);
    myRect.length = 2.0;
    myRect.width = 4.0;
    myRect.area = myRect.length * myRect.width;
    mySquare.length = 4.0;
    mySquare.width = 4.0;
    mySquare.area = mySquare.length * mySquare.width;
    <strong class="bold">Display(myCircle);</strong>   // invoke: void display(Circle)
    <strong class="bold">Display(myRect);</strong>     // invoke: void display(Rectangle)
    <strong class="bold">Display(mySquare);</strong>
    return 0;
}</pre>
<p>Now, in the <code>main()</code> function, we declare a variable of type <code>Circle</code> and two variables of type <code>Rectangle</code>. We then proceed to load the data members for each of these variables in <code>main()</code> using the dot operator (<code>.</code>) with appropriate values. Next in<a id="_idTextAnchor107"/> <code>main()</code>, there are three calls to <code>Display()</code>. The first function call, <code>Display(my<a id="_idTextAnchor108"/>Circle)</code>, will call the version of <code>Display()</code> that takes a <code>Circle</code> as a formal parameter because the actual parameter passed to this function is in fact of user defined type <code>Cir<a id="_idTextAnchor109"/>cle</code>. The next two function calls, <code>Display(myRect)</code> and <code>Display(mySquare)</code>, will call the overloaded version of <code>Display()</code> that takes a <code>Rectangle</code> as a formal parameter because the actual parameters passed in each of these two calls are of type <code>Rectangle</code> themselves. Let’s complete this program by examining <a id="_idIndexMarker129"/>both function definitions for <code>Display()</code>:</p>
<pre class="source-code">
<strong class="bold">void Display (Circle c)</strong>
{
   cout &lt;&lt; "Circle with radius " &lt;&lt; c.radius;
   cout &lt;&lt; " has an area of " &lt;&lt; c.area &lt;&lt; endl; 
}
   
<strong class="bold">void Display (Rectangle r)</strong>
{
   cout &lt;&lt; "Rectangle with length " &lt;&lt; r.length;
   cout &lt;&lt; " and width " &lt;&lt; r.width;
   cout &lt;&lt; " has an area of " &lt;&lt; r.area &lt;&lt; endl; 
}</pre>
<p>Notice in the final segment of this example that both versions of <code>Display()</code> are defined. One of the functions takes a <code>Circle</code> as the formal parameter, and the overloaded version takes a <code>Rectangle</code> as its formal parameter. Each function body accesses data members specific to each of its formal parameter types, yet the overall functionality of each function is similar in that, in each case, a specific shape (<code>Circle</code> or <code>Rectangle</code>) is displayed.</p>
<p>Let’s take a look at the output for this full program example:</p>
<pre>Circle with radius 5 has an area of 78.5397
Rectangle with length 2 and width 4 has an area of 8
Rectangle with length 4 and width 4 has an area of 16</pre>
<p>Next, let’s <a id="_idIndexMarker130"/>add to our discussion of function overloading by understanding how standard type conversion allows for one function to be used by multiple data types. This can allow function overloading to be used more selectively.</p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor110"/>Eliminating excessive overloading with standard type conversion</h2>
<p>Basic language types can be converted from one type to another automatically by the compiler. This allows the language to supply a smaller set of operators to manipulate standard <a id="_idIndexMarker131"/>types than <a id="_idIndexMarker132"/>would otherwise be necessary. Standard type conversion can also eliminate the need for function overloading when preserving the exact data type of the function parameters is not crucial. Promotion and demotion between standard types are often handled transparently, without explicit casting, in expressions including assignments and operations.</p>
<p>Here is an example illustrating simple standard type conversions. This example does not include function overloading:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex7.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex7.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;    // preferred to: using namespace std;
using std::endl;
int Maximum(double, double);      // function prototype
                                    
int main()
{
    int result = 0;
    int m = 6, n = 10;
    float x = 5.7, y = 9.89;
    
    <strong class="bold">result =  Maximum(x, y);</strong> 
    cout &lt;&lt; "Result is: " &lt;&lt; result &lt;&lt; endl;
    cout &lt;&lt; "The maximum is: " &lt;&lt; <strong class="bold">Maximum(m, n)</strong> &lt;&lt; endl;
    return 0;
}
int Maximum(double a, double b)  // function definition
{
    return (a &gt; b)? a : b;
}</pre>
<p>In <a id="_idIndexMarker133"/>this example, the <code>Maximum()</code> function takes two double precision floating-point numbers as parameters, and the function returns the result as an <code>int</code>. First, notice that <code>int Maximum(double, double);</code> is prototyped near the top of the program and is defined <a id="_idIndexMarker134"/>at the bottom of this same file. </p>
<p>Now, in the <code>main()</code> function, notice that we have three <code>int</code> variables defined: <code>result</code>, <code>a</code>, and <code>x</code>. The latter two are initialized with values of <code>6</code> and <code>10</code>, respectively. We also have two floats defined and initialized: <code>float x = 5.7, y = 9.89;</code>. In the first c<a id="_idTextAnchor111"/>all to function <code>Maximum()</code>, we use <code>x</code> and <code>y</code> as actual parameters. These two floating-point numbers are promoted to double precision floating-point numbers, and the function is called as expected.</p>
<p>This is an example of standard type conversion. Let’s notice that the return value of <code>int Maximum(double, double)</code> is an integer – not a double. This means that the value returned from this function (either formal parameter <code>a</code> or <code>b</code>) will be a copy of <code>a</code> or <code>b</code>, first truncated to an integer before being used as a return value. This return value is neatly assigned to <code>result</code>, which has been declared an <code>int</code> in <code>main()</code>. These are all examples of standard type conversion.</p>
<p>Next, <code>Maximum()</code> is called with actual parameters <code>m</code> and <code>n</code>. Similar to the previous function <a id="_idIndexMarker135"/>call, the <a id="_idIndexMarker136"/>integers <code>m</code> and <code>n</code> are promoted to doubles and the function is called as expected. The return value will also be truncated back to an <code>int</code>, and this value will be passed to <code>cout</code> for printing as an integer. </p>
<p>The output for this example is as follows:</p>
<pre>Result is: 9
The maximum is: 10</pre>
<p>Now that we understand how function overloading and standard type conversions work, let’s examine a situation where the two combined could create an ambiguous function call.</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor112"/>Ambiguities arising from function overloading and type conversion</h2>
<p>When a function is invoked and the formal and actual parameters match exactly in type, no ambiguities <a id="_idIndexMarker137"/>arise with respect to which of a selection of overloaded functions should be called – the function with the exact match <a id="_idIndexMarker138"/>is the obvious choice. However, when a function is called and the formal and actual parameters differ in type, standard type conversion may be performed on the actual parameters, as necessary. There are situations, however, when the formal and actual parameter types do not match, and overloaded functions exist. In these cases, it may be difficult for the compiler to select which function should be selected as the best match. In these cases, a compiler error is generated indicating that the available choices paired with the function call itself are ambiguous. Explicit type casting or re-prototyping the desired choice in a more local scope can help correct these otherwise ambiguous situations.</p>
<p>Let’s review a simple function illustrating the function overloading, standard type conversion, and potential ambiguity:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex8.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex8.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;    // preferred to: using namespace std;
using std::endl;
int Maximum (int, int);   // overloaded function prototypes
float Maximum (float, float); 
int main()
{
    char a = 'A', b = 'B';
    float x = 5.7, y = 9.89;
    int m = 6, n = 10;
    cout &lt;&lt; "The max is: " &lt;&lt; Maximum(a, b) &lt;&lt; endl;
    cout &lt;&lt; "The max is: " &lt;&lt; Maximum(x, y) &lt;&lt; endl;
    cout &lt;&lt; "The max is: " &lt;&lt; Maximum(m, n) &lt;&lt; endl;
    <strong class="bold">// The following (ambiguous) line generates a compiler </strong>
<strong class="bold">    // error - there are two equally good fn. candidates </strong>
<strong class="bold">    // cout &lt;&lt; "The maximum is: " &lt;&lt; Maximum(a, y) &lt;&lt; endl;</strong>
    <strong class="bold">// We can force a choice by using an explicit typecast</strong>
    cout &lt;&lt; "The max is: " &lt;&lt; 
             Maximum(<strong class="bold">static_cast&lt;float&gt;(</strong>a<strong class="bold">)</strong>, y) &lt;&lt; endl;
    return 0;
}
int Maximum (int arg1<a id="_idTextAnchor113"/>, int arg2)    // function definition
{
    return (arg1 &gt; arg2)? arg1 : arg2;
}
float Maximum (float arg1, float arg2)  // overloaded fn.
{                                    
    return (arg1 &gt; arg2)? arg1 : arg2;
}</pre>
<p>In this preceding simple example, two versions of <code>Maximum()</code> are both prototyped and defined. These <a id="_idIndexMarker139"/>functions are overloaded; notice that their names are the same, but they differ in the types of arguments <a id="_idIndexMarker140"/>that they utilize. Also note that their return types differ; however, since return type is not part of a function’s signature, the return types need not match.</p>
<p>Next, in <code>main()</code>, two variables each of type <code>char</code>, <code>int</code>, and <code>float</code> are declared and initialized. Next, <code>Maximum(a, b)</code> is called and the two <code>char</code> actual parameters are converted to integers (using their ASCII equivalents) to match the <code>Maximum(int, int)</code> version of this function. This is the match closest to the <code>char</code> argument types of <code>a</code> and <code>b</code>: <code>Maximum(int, int)</code> versus <code>Maximum(float, float)</code>. Then, <code>Maximum(x, y)</code> is called with two floats, and this call will exactly match the <code>Maximum(float, float)</code> version of this function. Similarly, <code>Maximum(m, n<a id="_idTextAnchor114"/>)</code> will be called and will perfectly match the <code>Maximum(int, int)</code> version of this function.</p>
<p>Now, notice the next function call (which, not coincidentally, is commented out): <code>Maximum(a, y)</code>. Here, the first actual parameter perfectly matches the first argument in <code>Maximum(int, int)</code>, yet the second actual parameter perfectly matches the second argument in <code>Maximum(float, float)</code>. And for the non-matching parameter, a type conversion <em class="italic">could</em> be applied – but it is not! Instead, this function call is flagged by the compiler as an ambiguous function call since either of the overloaded functions could be an appropriate match.</p>
<p>On the line of code <code>Maximum<a id="_idTextAnchor115"/>((float) a, y)</code>, notice that the function call to <code>Maximum((float) a, y)</code> forces an explicit typecast to the first actual parameter <code>a</code>, resolving <a id="_idIndexMarker141"/>any potential ambiguity of which <a id="_idIndexMarker142"/>overloaded function to call. With parameter <code>a</code> now cast to be a <code>float</code>, this function call easily matches <code>Maximum(float, float)</code>, and is no longer considered ambiguous. Type casting can be a tool to disambiguate crazy situations such as these.</p>
<p>Here is the output to accompany our example:</p>
<pre>The maximum is: 66
The maximum is: 9.89
The maximum is: 10
The maximum is: 65</pre>
<h1 id="_idParaDest-54"><a id="_idTextAnchor116"/>Summary</h1>
<p>In this chapter, we learned about additional non-OO C++ features that are essential building blocks needed to base C++’s object-oriented features. These language necessities include using the <code>const</code> qualifier, understanding function prototypes, using default values in prototypes, function overloading, how standard type conversion affects overloaded function choices, and how possible ambiguities may arise (and be resolved).</p>
<p>Very importantly, you are now ready to move forward to the next chapter in which we will explore indirect addressing using pointers in reasonable detail. The matter-of-fact skills that you have accumulated in this chapter will help you more easily navigate each progressively more detailed chapter to ensure you are ready to easily tackle the OO concepts starting in <a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Classes in Detail</em>.</p>
<p>Remember, C++ is a language filled with more gray areas than most other languages. The subtle nuances you are accumulating with your skill set will enhance your value as a C++ developer – one who can not only navigate and understand existing nuanced code but one who can create easily maintainable code. </p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor117"/>Questions</h1>
<ol>
<li>What is the signature of a function and how is a function’s signature related to name mangling in C++? How do you think this facilitates how overloaded functions are handled internally by the compiler?</li>
<li>Write a small C++ program to prompt a user to enter information regarding a <code>Student</code>, and print out the data. Use the following steps to write your code:<ol><li>Create a data type for <code>Student</code> using a <code>class</code> or <code>struct</code>. <code>Student</code> information should minimally include <code>firstName</code>, <code>lastName</code>, <code>gpa</code>, and the <code>currentCourse</code> in which the <code>Student</code> is registered. This information may be stored in a simple class. You may utilize either <code>char</code> arrays to represent the string fields since we have not yet covered pointers, or you may (preferably) utilize the <code>string</code> type. Also, you may read in this information in the <code>main()</code> function rather than creating a separate function to read in the data (since the latter will require knowledge of pointers or references). Please do not use global (that is, external variables).</li><li>Create a function to print out all the data for the <code>Student</code>. Remember to prototype this function. Use a default value of <code>4.0</code> for <code>gpa</code> in the prototype of this function. Call this function two ways: once passing in each argument explicitly, and once using the default <code>gpa</code>.</li><li>Now, overload the print function with one that either prints out selected data (for example, <code>lastName</code> and <code>gpa</code>) or with a version of this function that takes a <code>Student</code> as an argument (but not a pointer or reference to a <code>Student</code> – we’ll do that later). Remember to prototype this function.</li><li>Use iostreams for I/O.</li></ol></li>
</ol>
</div>
</div></body></html>