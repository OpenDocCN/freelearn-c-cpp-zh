<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-188"><a id="_idTextAnchor217"/>3</h1>
<h1 id="_idParaDest-189"><a id="_idTextAnchor218"/>Implementing GPU-Driven Rendering</h1>
<p>In this chapter, we embark on a deep dive into the intricacies of manipulating geometry specifically for GPU rendering. The traditional approach heavily relies on the CPU for various tasks, which can be a bottleneck in many scenarios. Our goal here is to liberate your rendering techniques from such constraints. We aim to put the GPU in the driver’s seat, ensuring efficient processing by capitalizing on its parallel processing prowess. We will unravel the technique of generating and drawing lines, not from the traditional space of the CPU but directly from shaders, such as vertex or fragment shaders. This not only enhances efficiency but also opens new realms of creativity. Taking a step further, we’ll demonstrate how to extend this novel line-drawing feature to display numbers right from shaders. This capability paves the way for real-time displays and feedback without toggling between GPU and CPU. We then shift our gaze to a more intricate topic – rendering text on the GPU. By employing the <strong class="bold">Signed Distance Fields</strong> (<strong class="bold">SDF</strong>) approach, we’ll guide you in achieving smoother and more versatile text rendering on the GPU.</p>
<p>Lastly, we’ll address one of the classic challenges in rendering: frustum culling. <strong class="bold">Frustum culling</strong> involves avoiding the rendering of objects that are outside the camera’s <strong class="bold">field of view</strong> (<strong class="bold">FOV</strong>). <strong class="bold">Frustum</strong> refers to the volume of space that is visible through the camera. <strong class="bold">Culling</strong> means discarding or ignoring objects that fall outside this frustum, thus they are not processed for rendering. Instead of the traditional approach, we’ll show you how to implement this directly on the GPU using compute shaders, ensuring objects outside the camera view do not consume valuable GPU resources. By the chapter’s close, you’ll have a holistic grasp of GPU-driven rendering, enabling you to harness the GPU’s capabilities to its fullest and streamline your rendering tasks.</p>
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Implementing GPU-driven line rendering</li>
<li>Expanding line-drawing techniques to render textual values from shaders</li>
<li>Drawing text using SDF</li>
<li>Frustum culling using compute shaders</li>
</ul>
<h1 id="_idParaDest-190"><a id="_idTextAnchor219"/>Technical requirements</h1>
<p>For this chapter, you will need to make sure you have VS 2022 installed along with the Vulkan SDK. Basic familiarity with the C++ programming language and an understanding of OpenGL or any other graphics API will be useful. Please revisit <a href="B18491_01.xhtml#_idTextAnchor019"><em class="italic">Chapter 1</em></a><em class="italic">, Vulkan Core Concepts</em>, under the <em class="italic">Technical requirements</em> section for details on setting up and building executables for this chapter. This chapter has multiple recipes, which can be launched using the following executables:</p>
<ol>
<li><code>Chapter03_GPU_Lines.exe</code></li>
<li><code>Chapter03_GPU_Text.exe</code></li>
<li><code>Chapter03_GPU_Text_SDF.exe</code></li>
<li><code>Chapter03_GPU_Culling.exe</code></li>
</ol>
<h1 id="_idParaDest-191"><a id="_idTextAnchor220"/>Implementing GPU-driven line rendering</h1>
<p>In this recipe, you <a id="_idIndexMarker265"/>will learn a technique that allows drawing lines directly from shaders such as vertex or fragment shaders. In many graphics applications, the challenge arises when one wishes to draw lines directly and efficiently using the inherent capabilities of shaders, particularly vertex or fragment shaders. To address this, our recipe delves into a specialized technique tailored for this very purpose. We’ll be presenting a recipe that seamlessly integrates with a variety of pipelines and render passes. Through our approach, data, be it vertices or colors, gets stored in a device buffer, ensuring a streamlined process. The culmination of this procedure is the utilization of this accumulated data in a subsequent pass, where these lines are then masterfully rendered onto a framebuffer. By the end, you will have a robust and efficient method to directly render lines using shaders.</p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor221"/>Getting ready</h2>
<p>Before diving into the recipe, you should make sure you have VS 2022 installed and that you are able to build the repository as per the steps provided in <a href="B18491_01.xhtml#_idTextAnchor019"><em class="italic">Chapter 1</em></a><em class="italic">, Vulkan </em><em class="italic">Core Concepts</em>.</p>
<p>You should be able to launch the executable named <code>Chapter03_GPU_Lines.exe</code> from VS 2022.</p>
<p>The code covered in this recipe can be found in the repository, in <code>chapter3/mainGPULines.cpp</code> and <code>chapter3/resources/shaders</code>, in the <code>gpuLines.frag</code>, <code>gpuLines.vert</code>, <code>gpuLinesDraw.frag</code>, and <code>gpuLinesDraw.vert</code> files.</p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor222"/>How to do it…</h2>
<p>In this section, we’ll guide you through the comprehensive procedure of directly drawing lines from shaders and integrating them into the final rendered frame using GPU-driven techniques. By leveraging a dedicated device buffer and carefully orchestrated render passes, this technique allows for real-time visual feedback and streamlined graphical processes. By the end of this walkthrough, you’ll have a robust mechanism in place for efficiently rendering lines directly from the GPU with minimal CPU involvement.</p>
<p>The idea relies on having a device buffer that serves as a repository for lines and parameters for the indirect draw structure used to render those lines. After all render passes are complete, one additional render pass is performed to draw lines in the buffer. Here are the steps to do it:</p>
<ol>
<li>The first step<a id="_idIndexMarker266"/> is to create a buffer that will contain not only the line data but also metadata that is used for determining how many lines can fit into the buffer and other parameters used by the final indirect draw call. The following snippet defines the buffer structure in C++, with <code>GPULineBuffer</code> being the structure of the buffer used to store/draw lines:<pre class="source-code">
constexpr uint32_t kNumLines = 65'536;
struct Line {
  glm::vec4 v0_;
  glm::vec4 color0_;
  glm::vec4 v1_;
  glm::vec4 color1_;
};
struct Header {
  uint32_t maxNumlines_;
  uint32_t padding0 = 0u;
  uint32_t padding1 = 0u;
  uint32_t padding2 = 0u;
  VkDrawIndirectCommand cmd_;
};
struct GPULineBuffer {
  Header header_;
  Line lines_[kNumLines];
};</pre><p class="list-inset">This structure defines the device buffer we’ll use to store the GPU-generated lines and can store up to 65,536 lines plus the data in the <code>Header</code> section.</p><p class="list-inset"><em class="italic">Figure 3</em><em class="italic">.1</em> shows<a id="_idIndexMarker267"/> the buffer’s layout as <em class="italic">seen</em> by the GPU:</p></li> </ol>
<p class="IMG---Figure"><a id="_idTextAnchor223"/></p>
<div><div><img alt="Figure 3.1 – The GPU lines’ buffer structure" src="img/B18491_03_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – The GPU lines’ buffer structure</p>
<p class="list-inset">This buffer is <a id="_idIndexMarker268"/>created with the following usage bits:</p>
<ul>
<li><code>VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT</code></li>
<li><code>VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</code></li>
<li><code>VK_BUFFER_USAGE_TRANSFER_DST_BIT</code></li>
</ul>
<p class="list-inset">This buffer should be made available to all render passes you wish to be able to draw/generate lines from:</p>
<pre class="source-code">
std::shared_ptr&lt;VulkanCore::Buffer&gt; gpuLineBuffer;
gpuLineBuffer = context.createBuffer(
    kGPULinesBufferSize,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT |
        VK_BUFFER_USAGE_STORAGE_BUFFER_BIT |
        VK_BUFFER_USAGE_TRANSFER_DST_BIT,
    static_cast&lt;VmaMemoryUsage&gt;(
        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT));</pre> <ol>
<li value="2">The provided code snippet initializes a <code>gpuLineBuffer</code> buffer using the Vulkan API. This buffer, created via the <code>context.createBuffer</code> method, is given a specified size (<code>kGPULinesBufferSize</code>) and is designated for multiple purposes, including indirect draw commands, shader data storage, and as a destination for buffer-to-buffer copy operations. Additionally, the buffer’s memory is set<a id="_idIndexMarker269"/> to reside on the GPU, ensuring fast access:<pre class="source-code">
struct Line {
  vec3 v0;
  vec4 c0;
  vec3 v1;
  vec4 c1;
};
struct VkDrawIndirectCommand {
  uint vertexCount;
  uint instanceCount;
  uint firstVertex;
  uint firstInstance;
};
layout(set = 4, binding = 0) buffer GPULinesBuffer
{
  uint size;
  uint row;
  uint pad1;
  uint pad2;
  VkDrawIndirectCommand cmd;
  Line lines[];
} lineBuffer;
void addLine(vec3 v0, vec3 v1, vec4 c0, vec4 c1) {
  const uint idx =
      atomicAdd(lineBuffer.cmd.instanceCount, 1);
  if (idx &gt;= lineBuffer.size) {
    atomicMin(lineBuffer.cmd.instanceCount,
              lineBuffer.size);
    return;
  }
  lineBuffer.lines[idx].v0 = v0;
  lineBuffer.lines[idx].v1 = v1;
  lineBuffer.lines[idx].c0 = c0;
  lineBuffer.lines[idx].c1 = c1;
}</pre><p class="list-inset">The function first <a id="_idIndexMarker270"/>checks for the next available index for storing the line information by retrieving the number of lines already in the buffer with <code>atomicAdd</code>. If the index returned by the function is greater than the maximum number of lines that can fit into the buffer, the function returns early and is a no-op. Otherwise, the line data is stored in the buffer.</p></li> <li>Rendering the lines is done with an extra render pass once all other passes have finished processing since the data from previous passes is required. The vertex shader code to<a id="_idIndexMarker271"/> render the lines looks like the following snippet:<pre class="source-code">
#version 460
#extension GL_EXT_nonuniform_qualifier : require
struct Line {
  vec3 v0;
  vec4 c0;
  vec3 v1;
  vec4 c1;
};
struct VkDrawIndirectCommand {
  uint vertexCount;
  uint instanceCount;
  uint firstVertex;
  uint firstInstance;
};
layout(set = 1, binding = 0) readonly buffer
GPULinesBuffer {
  Line lines[];
} lineBuffer;
layout (location = 0) out vec4 outColor;
void main() {
  if (gl_VertexIndex == 0) {
    vec3 vertex =
        lineBuffer.lines[gl_InstanceIndex].v0;
    gl_Position = vec4(vertex, 1.0).xyww;
    outColor =
        lineBuffer.lines[gl_InstanceIndex].c0;
  } else {
    vec3 vertex =
        lineBuffer.lines[gl_InstanceIndex].v1;
    gl_Position = vec4(vertex, 1.0).xyww;
    outColor =
        lineBuffer.lines[gl_InstanceIndex].c1;
  }
}</pre><p class="list-inset">In the preceding<a id="_idIndexMarker272"/> code, two structures are introduced: <code>Line</code> and <code>VkDrawIndirectCommand</code>. The <code>Line</code> structure represents a colored line segment, defined by two 3D endpoints (<code>v0</code> and <code>v1</code>) and their corresponding colors (<code>c0</code> and <code>c1</code>). The <code>VkDrawIndirectCommand</code> structure represents a Vulkan command for indirect drawing. The shader also establishes a <code>GPULinesBuffer</code> buffer containing an array of <code>Line</code> structures. In the main function, depending on the value of <code>gl_VertexIndex</code>, the shader selects the starting or ending point of a line instance and assigns the respective color to <code>outColor</code>. Also, notice how in this shader, we only define the <code>GPULinesBuffer</code> structure without the header structure. That’s because for drawing lines, we bind the buffer at an offset, bypassing the need to define the <code>Header</code> segment in the shader.</p><p class="list-inset">The fragment shader just outputs the color provided through the vertex shader:</p><pre class="source-code">#version 460
layout(location = 0) in vec4 inColor;
layout(location = 0) out vec4 outColor;
void main() {
  outColor = inColor;
}</pre><p class="list-inset">Before rendering the lines, we need to make sure that the previous steps have finished writing<a id="_idIndexMarker273"/> into the buffer, so we issue a buffer barrier:</p><pre class="source-code">const VkBufferMemoryBarrier bufferBarrier = {
    .sType =
        VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
    .srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT,
    .dstAccessMask =
        VK_ACCESS_INDIRECT_COMMAND_READ_BIT,
    .srcQueueFamilyIndex =
        VK_QUEUE_FAMILY_IGNORED,
    .dstQueueFamilyIndex =
        VK_QUEUE_FAMILY_IGNORED,
    .buffer = gpuLineBuffer-&gt;vkBuffer(),
    .offset = 0,
    .size = VK_WHOLE_SIZE,
};
vkCmdPipelineBarrier(
    commandBuffer,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT, 0, 0,
    nullptr, 1, &amp;bufferBarrier, 0, nullptr);</pre><p class="list-inset">After that, we issue an indirect draw command that derives its parameters directly from the buffer itself. We cleverly stored the number of lines stored in the buffer in the previous passes in <code>VkDrawIndirectCommand:: instanceCount</code>:</p><pre class="source-code">vkCmdDrawIndirect(commandBuffer,
                  gpuLineBuffer-&gt;vkBuffer(),
                  sizeof(uint32_t) * 4, 1,
                  sizeof(VkDrawIndirectCommand));</pre></li> <li>The final step<a id="_idIndexMarker274"/> consists of clearing the buffer, which is required for clearing the number of lines in the buffer (<code>VkDrawIndirectCommand:: instanceCount</code>). Before clearing the buffer, we must ensure that the GPU has finished drawing lines, which we can verify by issuing another buffer barrier:<pre class="source-code">
const VkBufferMemoryBarrier bufferBarrierClear = {
    .sType =
        VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
    .srcAccessMask =
        VK_ACCESS_INDIRECT_COMMAND_READ_BIT,
    .dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT,
    .srcQueueFamilyIndex =
        VK_QUEUE_FAMILY_IGNORED,
    .dstQueueFamilyIndex =
        VK_QUEUE_FAMILY_IGNORED,
    .buffer = gpuLineBuffer-&gt;vkBuffer(),
    .offset = 0,
    .size = VK_WHOLE_SIZE,
};
// Reset the number of lines in the buffer
vkCmdFillBuffer(commandBuffer,
                gpuLineBuffer-&gt;vkBuffer(),
                sizeof(uint32_t) * 5,
                sizeof(uint32_t), 0);</pre></li> </ol>
<p>In this recipe, we have unpacked a powerful technique for rendering lines directly from shaders. The utility of this method extends to diverse rendering applications, and it lays the groundwork for <a id="_idIndexMarker275"/>more advanced graphical outputs, elevating your skills to an even higher level in the realm of GPU programming using Vulkan.</p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor224"/>Expanding line-drawing techniques to render textual values from shaders</h1>
<p>Continuing<a id="_idIndexMarker276"/> from our <a id="_idIndexMarker277"/>previous exploration, where we developed the capability to draw lines directly from shaders, our next challenge is to further refine this capability to facilitate the rendering of text values. Drawing inspiration from the foundational concepts established in the preceding recipe, we aim to implement a methodology that permits the conversion of numerical values into line segments, much like digital LCD displays. By doing so, not only do we breathe life into bare numerical data, making it more visual and interpretable, but we also harness the power and efficiency of shaders in crafting these representations. Upon completion, you will be equipped with a robust toolset, allowing them to render clear, scalable, and visually appealing textual data, right from their shaders.</p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor225"/>Getting ready</h2>
<p>Before diving into the recipe, you should make sure you have VS 2022 installed and that you are able to build the repository as per the steps provided in <a href="B18491_01.xhtml#_idTextAnchor019"><em class="italic">Chapter 1</em></a><em class="italic">, Vulkan </em><em class="italic">Core Concepts.</em></p>
<p>You should be able to launch the executable named <code>Chapter03_GPU_Text.exe</code> from VS 2022.</p>
<p>Since this recipe is heavily based on the previous recipe, we recommend reading the previous recipe on GPU line drawing first. The code covered in this recipe can be found in<a id="_idIndexMarker278"/> the <a id="_idIndexMarker279"/>repository, in <code>chapter3/mainGPUText.cpp</code> and <code>chapter3/resources/shaders</code>, in the <code>gpuText.frag</code>, <code>gpuText.vert</code>, <code>gpuTextDraw.frag</code>, and <code>gpuTexDraw.vert</code> files.</p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor226"/>How to do it…</h2>
<p>The idea is to decompose numbers into segments (like LCD segment displays) and print values by drawing lines for each digit. The previous recipe covered how to store and draw lines; this recipe builds on top of that to print numbers. Since in this recipe we need to draw numbers, we will need to parse numbers and decompose them into lines:</p>
<ol>
<li>First, we need to use a strategy to represent digits with only lines. We chose to implement a simple 7-segment approach that can be used to display all digits from 0 to 9 plus a minus sign. We also added an extra segment to represent a decimal separator. <em class="italic">Figure 3</em><em class="italic">.2</em> shows the seven segments plus the decimal separator and their indices as used by the code in t<a id="_idTextAnchor227"/>he shader:</li>
</ol>
<div><div><img alt="Figure 3.2 – Segments used to represent all digits from 0 to 9 plus a decimal separator and a minus sign" src="img/B18491_03_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Segments used to represent all digits from 0 to 9 plus a decimal separator and a minus sign</p>
<ol>
<li value="2">In addition to the structures defined in the previous recipe, we will replace the <code>pad0</code> member of the <code>GPULinesBuffer</code> buffer so that it stores the row number:<pre class="source-code">
layout(set = 4, binding = 0) buffer GPULinesBuffer
{
  uint size;
  <strong class="bold">uint row;</strong>
  uint pad1;
  uint pad2;
  VkDrawIndirectCommand cmd;
  Line lines[];
} lineBuffer;</pre></li> <li>We’ll also <a id="_idIndexMarker280"/>need the <a id="_idIndexMarker281"/>definition of the segments shown in <em class="italic">Figure 3</em><em class="italic">.2</em> as two vectors:<pre class="source-code">
vec2 v[] = {vec2(-0.5f,  1.0f), vec2(0.5f,  1.f),
            vec2(-0.5f,  0.0f), vec2(0.5f,  0.f),
            vec2(-0.5f, -1.0f), vec2(0.5f, -1.f),
           vec2( 0.0f, -0.8f), vec2(0.0f, -1.f) };
uvec2 i[] = {uvec2(0, 1), uvec2(2, 3), uvec2(4, 5), uvec2(0, 2), uvec2(1, 3), uvec2(2, 4), uvec2(3, 5), uvec2(6, 7)};</pre><p class="list-inset">Array <code>v</code> represents the coordinates of all vertices shown in <em class="italic">Figure 3</em><em class="italic">.2 </em>normalized into the range [<code>-0.5</code>, <code>0.5</code>] in the <em class="italic">x</em> direction and [<code>-1.0</code>, <code>1.0</code>] in the <em class="italic">y</em> direction. Array <code>i</code> describes all segments and their vertices. For instance, the first element of the array describes segment 0 in the picture, from vertex 0 (<code>-0.5</code>, <code>1.0</code>) to vertex 1 (<code>0.5</code>, <code>1.0</code>).</p></li> <li>The <code>printSegment</code> function adds one segment, given its index, a scale, and a translation, to the GPU buffer where lines are stored:<pre class="source-code">
void printSegment(int segment, vec2 pos, vec2 scale) {
  uint idx = i[segment].x;
  uint idy = i[segment].y;
  vec3 v0 = vec3(v[idx] * scale + pos, 1.0);
  vec3 v1 = vec3(v[idy] * scale + pos, 1.0);
  addLine(v0, v1, vec4(0,0,0,1), vec4(0,0,0,1));
}</pre><p class="list-inset">This function calls the <code>addLine</code> function presented before to record the final vertices and colors of lines in the buffer.</p></li> <li>The <code>printDigit</code> function prints all segments for a digit at a specific line and column, passed<a id="_idIndexMarker282"/> in as<a id="_idIndexMarker283"/> parameters:<pre class="source-code">
void printDigit(int digit, uint linenum,
                uint column) {
  const float charWidthPixel = 10;
  const float charHeightPixels = 10;
  const float horSpacePixels = 5;
  const float verSpacePixels = 5;
  const float charWidthNDC =
      charWidthPixels / screenWidth;
  const float charHeightNDC =
      charHeightPixels / screenHeight;
  const float horSpaceNDC =
      horSpacePixels / screenWidth;
  const float verSpaceNDC =
      verSpacePixels / screenHeight;
  const float colx =
      (column + 1) *
      (charWidthNDC + horSpaceNDC);
  const float coly =
      (linenum + 1) *
      (charHeightNDC + 3 * verSpaceNDC);</pre><p class="list-inset">Initially, it calculates the width and height of the characters in <code>switch</code> statement to decide which digit to print. The following snippet only shows how to print the digits 0 and 1, the decimal separator, and the minus sign for brevity:</p><pre class="source-code">  const vec2 pos(colx, coly);
  const vec2 scale(charWidthNDC, -charHeightNDC);
  switch (digit) {
  case 0:
    printSegment(0, pos, scale);
    printSegment(3, pos, scale);
    printSegment(4, pos, scale);
    printSegment(5, pos, scale);
    printSegment(6, pos, scale);
    printSegment(2, pos, scale);
    break;
  case 1:
    printSegment(4, pos, scale);
    printSegment(6, pos, scale);
    break;
  case 10: // decimal separator
    printSegment(7, pos, scale);
    break;
  case 11: // minus sign
    printSegment(1, pos, scale);
    break;
  }
}</pre><p class="list-inset">The preceding<a id="_idIndexMarker287"/> code employs a switch-case structure to identify which segments should be activated based on the digit or symbol passed. For example, the number <code>0</code> requires several segments to depict its round shape. Therefore, when the digit is <code>0</code>, multiple <code>printSegment</code> calls are made to render each segment required for the <code>0</code> digit. Similarly, <code>1</code> is formed using two segments on its side. Beyond the digits, the function also has provisions to depict a decimal separator and a minus sign, distinguished by their unique segment arrangements.</p></li> <li>The <code>printNumber</code> function is designed to display an integer on a specified line, starting from a given column. After executing, it provides the next available column following the last digit printed. If the integer is zero, it simply prints <code>'0'</code>. For nonzero integers, the function efficiently computes the number of digits and<a id="_idIndexMarker288"/> iteratively <a id="_idIndexMarker289"/>prints each one, advancing the column accordingly:<pre class="source-code">
uint printNumber(highp int value,
                 uint linenum, uint column) {
  if (value == 0) {
    printDigit(0, linenum, column);
    return column + 1;
  }
  int counter = 0;
  int copy = value;
  int tens = 1;
  while (copy &gt; 0) {
    counter++;
    copy = copy / 10;
    tens *= 10;
  }
  tens /= 10;
  for (int i = counter; i &gt; 0; --i) {
    int digit = int(value / tens);
    printDigit(digit, linenum, column);
    value = value - (digit * tens);
    tens /= 10;
    column++;
  }
  return column;
}</pre><p class="list-inset">This function parses the integer parameter and prints each digit individually, while incrementing the <code>column</code> index.</p></li> <li>Finally, the <code>parse</code> function<a id="_idIndexMarker290"/> parses<a id="_idIndexMarker291"/> a float and prints it with a certain number of decimal places:<pre class="source-code">
void parse(float val, uint decimals) {
  int d = int(log(val));
  int base = int(pow(10, d));
  const float tens = pow(10, decimals);
  const uint line = atomicAdd(lineBuffer.row, 1);
  uint column = 0;
  // Minus sign
  if (val &lt; 0) {
    printDigit(11, line, column);
    column++;
  }
  // Prints only positive values
  val = abs(val);
  // Integer part
  const int intPart = int(val);
  column = printNumber(intPart, line, column);
  // Decimal
  if (decimals &gt; 0) {
    // Dot
    printDigit(10, line, column);
    column++;
    const int decimal =
        int(val * tens - intPart * tens);
    printNumber(decimal, line, column);
  }
}</pre><p class="list-inset">The function splits the float into two parts, the integer part and the decimal part, and prints them separately. If the number is negative, it prints the minus sign.</p></li> <li>The next <a id="_idIndexMarker292"/>step<a id="_idIndexMarker293"/> is to clear the buffer once the lines text has been rendered. In the previous recipe, we cleared the number of lines in the buffer. Here, we also need to clear the row number:<pre class="source-code">
vkCmdFillBuffer(commandBuffer,
                gpuLineBuffer-&gt;vkBuffer(),
                sizeof(uint32_t),
                sizeof(uint32_t), 0);</pre></li> <li>The last step is to use the <code>parse</code> function. Just call it from any shader that includes those functions. Each call to <code>parse</code> will print the value on a new line. <em class="italic">Figure 3</em><em class="italic">.3</em> shows the result of printing some values with the following code in the vertex shader:<pre class="source-code">
if (gl_VertexIndex == 0) {
  parse(123456, 0);
  parse(789, 0);
  parse(780.12, 3);
  parse(-23, 1);
  parse(0.3, 2);
}</pre><p class="list-inset">The following<a id="_idIndexMarker294"/> screenshot shows how we can use this technique for debugging purp<a id="_idTextAnchor228"/>oses or to display text:</p></li> </ol>
<div><div><img alt="Figure 3.3 – The result of printing values from the vertex shader" src="img/B18491_03_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – The result of printing values from the vertex shader</p>
<p>In this recipe, we delved into the intricate process of representing numerical values using line segments, reminiscent of LCD displays. By breaking down numbers into their individual segments and leveraging our foundational line-drawing methods from shaders, we <a id="_idIndexMarker295"/>provided <a id="_idIndexMarker296"/>you with an innovative technique to visualize numbers. The end result is a seamless integration of numbers into your graphics, with clarity reminiscent of digital segment displays, enriching the overall visual experience.</p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor229"/>Drawing text using SDF</h1>
<p>In this recipe, we<a id="_idIndexMarker297"/> address the challenge of rendering crisp and scalable text, regardless<a id="_idIndexMarker298"/> of its size. By utilizing the principles of SDF, we transform traditional text rendering into a more fluid process, ensuring sharpness and clarity. The outcome is beautifully rendered text that remains clear and legible, whether you’re zooming in closely or viewing from a distance.</p>
<p>SDFs provide a way to represent surfaces. An SDF is basically a function that, for every point in space, returns the shortest distance to the surface of the shape. SDFs can be used for a variety of use cases such as volume rendering or to perform operations on shapes such as dilation, erosion, and other morphological operations.</p>
<p>Traditionally, text is rendered using bitmap fonts. One can use a 2D canvas to render text and then use that as a texture to draw a quad in a 3D context. However, this method creates bitmaps that are resolution-dependent and need to be generated and uploaded to the device by the CPU. Each font style, such as bold, italics, and so on, also needs to be processed by the CPU, which causes an extra overhead for the computation and transfer of the textures for each style needed for rendering.</p>
<p>Rendering text using SDFs is a modern approach that uses distance fields for each character. These are grids in which each of the values represents the distance from each pixel to the nearest edge of the character. SDFs help avoid all the problems mentioned before by offering resolution-independent scaling as well as using the GPU for most of the work. Styles such as bold, outline, and so on require only changes to shaders.</p>
<p>Each letter of a font (a glyph) is described by a combination of straight lines and Bézier curves. One example of a glyph is shown in <em class="italic">Figure 3</em><em class="italic">.4</em>, which shows the<a id="_idTextAnchor230"/> detail of a glyph’s serif:</p>
<div><div><img alt="Figure 3.4 – Detail of a glyph definition: circles, triangles, and squares represent the start and end points of each segment (curves or straight lines)" src="img/B18491_03_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Detail of a glyph definition: circles, triangles, and squares represent the start and end points of each segment (curves or straight lines)</p>
<p>Traditional SDF algorithms encode the distance from a pixel to the glyph’s boundary for each pixel in a grid, store that information in a texture, and upload that to the CPU. The algorithm presented in this recipe implements a different approach, in which the distances from a pixel to the nearest curves are computed on the GPU. To do that, each glyph in the font<a id="_idIndexMarker299"/> is <a id="_idIndexMarker300"/>preprocessed on the CPU against a grid of fixed size of 8 x 8 cells. This preprocessing detects curves that intersect each cell and stores the information in a 32-bit inte<a id="_idTextAnchor231"/>ger, as shown in <em class="italic">Figure 3</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 3.5 – Cell encoding stores the initial index of three separate curves that intersect the cell along with the length of each loop" src="img/B18491_03_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Cell encoding stores the initial index of three separate curves that intersect the cell along with the length of each loop</p>
<p>Each cell contains the information of up to three loops that intersect it by storing the initial index of each loop plus their lengths. For example, the glyph shown in cell (2, 0) intersects two curves, curve 1 and curve 2. The information encoded for that cell would contain the index to curve 1 and a length of 2. The other indices would remain 0, as the cell doesn’t intersect any other curves.</p>
<p>The following diagram demonstrates how the letter <em class="italic">S</em> can be represented using glyphs:</p>
<div><div><img alt="Figure 3.6 – Curves representing an ﻿S glyph; cell (2, 0) intersects two curves: curve 1 and curve 2" src="img/B18491_03_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Curves representing an S glyph; cell (2, 0) intersects two curves: curve 1 and curve 2</p>
<p>The vertex shader <a id="_idIndexMarker301"/>passes<a id="_idIndexMarker302"/> the cell indices for each corner of the rectangle to the fragment shader, which receives the interpolated coordinate of the cell, uses it to retrieve the information of which curve loops and their lengths to inspect, and calculates the minimum distance to each one of the curves in the three loops, choosing the minimum distance.</p>
<p>This information is then used to calculate the opacity of the current fragment, along with the color and the sharpness of the edge of the font.</p>
<p>In this recipe, we use a third-party library to capture the definition of the glyphs and store that information in a shader-friendly format. The library is authored by Dávid Kocsis and can be found here: <a href="https://github.com/kocsis1david/font-demo">https://github.com/kocsis1david/font-demo</a>.</p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor232"/>Getting ready</h2>
<p>Before diving into the recipe, you should make sure you have VS 2022 installed and that you are able to build the repo as per the steps provided in <a href="B18491_01.xhtml#_idTextAnchor019"><em class="italic">Chapter 1</em></a><em class="italic">, Vulkan </em><em class="italic">Core Concepts.</em></p>
<p>You should be <a id="_idIndexMarker303"/>able<a id="_idIndexMarker304"/> to launch the executable named <code>Chapter03_GPU_Text_SDF.exe</code> from VS 2022.</p>
<p>A complete example with the code covered in this recipe can be found in the repository, in <code>chapter3/mainGPUTextSDF.cpp</code>, <code>chapter3/FontManager.hpp</code>, <code>chapter3/FontManager.cpp</code>, and <code>chapter3/resources/shaders</code>, in the <code>font.frag</code> and <code>font.vert</code> files.</p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor233"/>How to do it…</h2>
<p>The steps to render text using SDFs on the device are as follows:</p>
<ol>
<li>The initial task involves loading the font file through the <code>FreeType</code> library. This step is crucial because it’s where we obtain the glyph data for each character. Glyph data, in essence, represents the basic design of a character in a font, describing its unique shape and appearance. Once we have this, the subsequent objective is to transform this glyph data into outline data. The outline data captures the essence of the glyph’s shape, breaking it down into components such as points, cells, and a bounding box specific to each character. These components essentially dictate how a character will be rendered on a screen or display. To achieve this transformation from <code>FreeType</code>’s intricate glyph data to more structured outline data, we employ the <code>fd_outline_convert</code> function. The data for each character is combined into a single stream of points and cells that is <a id="_idIndexMarker305"/>uploaded<a id="_idIndexMarker306"/> to the GPU as a <em class="italic">vertex buffer</em>:<pre class="source-code">
FontManager fontManager;
const auto &amp;glyphData = fontManager.loadFont(
    (fontsFolder / "times.ttf").string());
std::vector&lt;GlyphInfo&gt; glyhInfoData;
std::vector&lt;uint32_t&gt; cellsData;
std::vector&lt;glm::vec2&gt; pointsData;
uint32_t pointOffset = 0;
uint32_t cellOffset = 0;
for (const auto &amp;glyph : glyphData) {
  glyhInfoData.push_back(
      {glyph.bbox,
       glm::uvec4(pointOffset, cellOffset,
                  glyph.cellX,
                  glyph.cellY)});
  cellsData.insert(cellsData.end(),
                   glyph.cellData.begin(),
                   glyph.cellData.end());
  pointsData.insert(pointsData.end(),
                    glyph.points.begin(),
                    glyph.points.end());
  pointOffset += glyph.points.size();
  cellOffset += glyph.cellData.size();
}</pre><p class="list-inset">The code delves deeply into font rendering by handling the glyphs, which are the backbone of font representation. One of the main elements here is the point data. This crucial piece captures every point that makes up the Bézier curves of each glyph. Right now, our focus is mainly on the uppercase letters. But looking at how the code is structured, it’s clear that we could easily expand it to embrace other characters if we wished to. Parallel to the point data, we also work with the cell data. It has a special role when we’re in the rendering phase, especially in the fragment shader. It’s this data that aids in navigating the curves that intersect with a given cell, making sure that every glyph is depicted accurately and precisely on the screen. All in all, by marrying the point and cell data with the capabilities of the fragment shader, we’re able to render the font’s visual intricacies effectively.</p></li> <li>Next, we build a <a id="_idIndexMarker307"/>buffer <a id="_idIndexMarker308"/>that contains the bounding rectangles of each glyph. This buffer serves as the vertex buffer, and we draw as many instances as the number of characters in the display string:<pre class="source-code">
std::string textToDisplay = "GPUSDFTEXTDEMO";
std::vector&lt;CharInstance&gt;
    charsData(textToDisplay.length());
int startX =
    context.swapchain()-&gt;extent().width / 6.0f;
int startY =
    context.swapchain()-&gt;extent().height / 2.0f;
const float scale = 0.09f;
for (int i = 0; i &lt; textToDisplay.length();
     ++i) {
  int glpyIndex = textToDisplay[i] - 'A';
  charsData[i].glyphIndex = glpyIndex;
  charsData[i].sharpness = scale;
  charsData[i].bbox.x =
      (startX +
       glyphData[glpyIndex].bbox.x * scale) /
          (context.swapchain()
               -&gt;extent()
               .width /
           2.0) -
      1.0;
  charsData[i].bbox.y =
      (startY -
       glyphData[glpyIndex].bbox.y * scale) /
          (context.swapchain()
               -&gt;extent()
               .height /
           2.0) -
      1.0;
  charsData[i].bbox.z =
      (startX +
       glyphData[glpyIndex].bbox.z * scale) /
          (context.swapchain()
               -&gt;extent()
               .width /
           2.0) -
      1.0;
  charsData[i].bbox.w =
      (startY -
       glyphData[glpyIndex].bbox.w * scale) /
          (context.swapchain()
               -&gt;extent()
               .height /
           2.0) -
      1.0;
  startX += glyphData[glpyIndex]
                .horizontalAdvance *
            scale;
}
"GPUSDFTEXTDEMO"</strong> onscreen. Here, <code>textToDisplay</code> holds the desired text, and <code>charsData</code> is primed to store individual character details. The starting position, calculated from the<a id="_idIndexMarker309"/> screen<a id="_idIndexMarker310"/> dimensions, suggests a slightly offset start from the left and a vertical centering of the text. A scaling factor shrinks the characters, likely aiding design or screen fit. As we progress character by character, a mapping correlates each letter to its respective data in <code>glyphData</code>. The bounding box coordinates for every character are meticulously scaled and normalized to ensure their optimal display on screen. To sidestep overlap, the horizontal placement (<code>startX</code>) gets an update for each character, relying on its width and the scaling factor. In sum, this snippet efficiently prepares the specifics for a neatly rendered, scaled, and centered display of <code>"GPUSDFTEXTDEMO"</code> on the screen.</pre></li> <li>In the following step, we transfer the points, cell data, glyph data, and string to the GPU as separate buffers. Subsequently, we execute a <code>vkCmdDraw</code> command:<pre class="source-code">
// 4 vertex (Quad) and x (charData) instances
vkCmdDraw(commandBuffer, 4, charsData.size(), 0, 0);</pre></li> <li>The vertex<a id="_idIndexMarker311"/> shader <a id="_idIndexMarker312"/>needs access to an array of glyph data (<code>GlyphInfo</code>) that is packed into the <code>glyph_buffer</code> buffer. The other inputs are <code>in_rect</code>,<code> in_glyph_index</code>, and <code>in_sharpness</code>, which come from the <em class="italic">vertex buffer</em>:<pre class="source-code">
#version 460
// Stores glyph information
struct GlyphInfo {
  vec4 bbox; // Bounding box of the glyph
  // cell_info.x: point offset
  // cell_info.x: cell offset
  // cell_info.x: cell count in x
  // cell_info.x: cell count in y
  uvec4 cell_info;
};
// Storage buffer object for glyphs
layout(set = 0, binding = 0) buffer GlyphBuffer {
  GlyphInfo glyphs[];
} glyph_buffer;
layout(location = 0) in vec4 in_rect;
layout(location = 1) in uint in_glyph_index;
layout(location = 2) in float in_sharpness;
layout(location = 0) out vec2 out_glyph_pos;
layout(location = 1) out uvec4 out_cell_info;
layout(location = 2) out float out_sharpness;
layout(location = 3) out vec2 out_cell_coord;
void main() {
  // Get the glyph information
  GlyphInfo gi = glyph_buffer.glyphs[in_glyph_index];
  // Corners of the rectangle
  vec2 pos[4] = vec2[](
      vec2(in_rect.x, in_rect.y), // Bottom-left
      vec2(in_rect.z, in_rect.y), // Bottom-right
      vec2(in_rect.x, in_rect.w), // Top-left
      vec2(in_rect.z, in_rect.w) // Top-right
  );
  // Corners of the glyph
  vec2 glyph_pos[4] = vec2[](
      vec2(gi.bbox.x, gi.bbox.y), // Bottom-left
      vec2(gi.bbox.z, gi.bbox.y), // Bottom-right
      vec2(gi.bbox.x, gi.bbox.w), // Top-left
      vec2(gi.bbox.z, gi.bbox.w) // Top-right
  );
  // Cell coordinates
  vec2 cell_coord[4] = vec2[](
      vec2(0, 0), // Bottom-left
      vec2(gi.cell_info.z, 0), // Bottom-right
      vec2(0, gi.cell_info.w), // Top-left
      vec2(gi.cell_info.z,
           gi.cell_info.w) // Top-right
  );
  gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);
  out_glyph_pos = glyph_pos[gl_VertexIndex];
  out_cell_info = gi.cell_info;
  out_sharpness = in_sharpness;
  out_cell_coord = cell_coord[gl_VertexIndex];
}</pre><p class="list-inset">The preceding <a id="_idIndexMarker313"/>vertex<a id="_idIndexMarker314"/> shader is tailored for glyph rendering. The shader works with a structure named <code>GlyphInfo</code> that encapsulates information about each glyph, including its bounding box and details related to the cell positioning of the glyph. Within the <code>main</code> function, the shader fetches data for a specific glyph using an input index. It subsequently determines the positions of both the input rectangle’s corners and the corresponding glyph’s bounding box and calculates the cell coordinates for the glyph. Using <code>gl_VertexIndex</code>, which indicates which vertex of the rectangle is currently being processed, the shader sets the position for that vertex and assigns necessary values to the output variables. This preprocessed information is leveraged by the fragment shader to produce a final visual representation of the glyph.</p></li> <li>Next are the steps for calculating the text’s glyph color using the fragment shader:<ul><li>Calculates the cell index for a given fragment/pixel.</li><li>Fetches the cell from the cell buffer based on the cell index.</li><li>Calculates<a id="_idIndexMarker315"/> the <a id="_idIndexMarker316"/>SDF of the cell from the glyph’s bounding box. Based on the distance, an alpha value is computed:<pre class="source-code">
// Main function of the fragment shader
void main() {
  // Calculate the cell index
  uvec2 c = min(uvec2(in_cell_coord),
                in_cell_info.zw - 1);
  uint cell_index = in_cell_info.y +
                    in_cell_info.z * c.y + c.x;
  // Get the cell
  uint cell = cell_buffer.cells[cell_index];
  // Calculate the signed distance from the
  // glyph position to the cell
  float v = cell_signed_dist(
      in_cell_info.x, cell, in_glyph_pos);
  // Calculate the alpha value
  float alpha = clamp(v * in_sharpness + 0.5,
                      0.0, 1.0);
  out_color = vec4(1.0, 1.0, 1.0, alpha);
}</pre></li></ul><p class="list-inset">The resul<a id="_idTextAnchor234"/>t of the recipe can be seen in <em class="italic">Figure 3</em><em class="italic">.7</em>:</p></li> </ol>
<div><div><img alt="Figure 3.7 – The output of the recipe" src="img/B18491_03_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – The output of the recipe</p>
<p>In this recipe, we<a id="_idIndexMarker317"/> showcased <a id="_idIndexMarker318"/>the application of SDF for rendering text with the assistance of a GPU.</p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor235"/>See also</h2>
<p>Inigo Quilez demonstrates how to use SDFs to create shapes in an excellent video:</p>
<p>https://www.youtube.com/watch?v=8--5LwHRhjk</p>
<p>There are multiple libraries that generate SDF textures – for example, <a href="https://libgdx.com/wiki/tools/hiero">https://libgdx.com/wiki/tools/hiero</a> and https://github.com/Chlumsky/msdfgen.</p>
<h1 id="_idParaDest-201"><a id="_idTextAnchor236"/>Frustum culling using compute shaders</h1>
<p>In this recipe, we <a id="_idIndexMarker319"/>will show how to do frustum culling<a id="_idIndexMarker320"/> using the GPU and compute shaders.</p>
<p>In the world of real-time rendering, efficient rendering is key to achieving smooth performance and high-quality visuals. One of the most widely used techniques to optimize rendering is frustum culling. Frustum culling is a process that improves rendering speed by ignoring or <em class="italic">culling</em> objects that are not visible within the camera’s FOV, or <em class="italic">frustum</em>. The following diagram demonstrates it visually:</p>
<div><div><img alt="Figure 3.8 – Frustum culling works by ignoring objects that fall outside of the camera’s view (the frustum)" src="img/B18491_03_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Frustum culling works by ignoring objects that fall outside of the camera’s view (the frustum)</p>
<p>Frustum culling works by testing each object in the scene to see if it lies within the camera’s frustum. If an object is entirely outside the frustum, it gets culled; that is, it’s not drawn. This can significantly reduce the number of primitives that need to be drawn. Traditionally, culling was done on the CPU, but this meant it needed to be done every time the camera moved. We demonstrate culling by using the compute shader, eliminating the need to upload data from the CPU to the GPU every time the view changes. Compute shaders do not necessarily need to be related to rendering and can process data structures and perform operations such as sorting, physics simulations, and, in our case, frustum culling.</p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor237"/>Getting ready</h2>
<p>Before diving into the recipe, you should make sure you have VS 2022 installed and that you are able to build the repository as per the steps provided in <a href="B18491_01.xhtml#_idTextAnchor019"><em class="italic">Chapter 1</em></a><em class="italic">, Vulkan </em><em class="italic">Core Concepts.</em></p>
<p>You should be able to launch the executable named <code>Chapter03_GPU_Culling.exe</code> from VS 2022.</p>
<p>This recipe is <a id="_idIndexMarker321"/>based <a id="_idIndexMarker322"/>on the <em class="italic">Implementing Programmable Vertex Pulling and Multi-Draw Indirect</em> recipe from <a href="B18491_02.xhtml#_idTextAnchor126"><em class="italic">Chapter 2</em></a><em class="italic">, Working with Modern Vulkan.</em> The code covered in this recipe can be found in the repository, in <code>chapter3/mainCullingCompute.cpp</code>, <code>chapter3/CullingComputePass.cpp</code>, and <code>chapter3/resources/shaders</code>, in the <code>gpuculling.comp</code>, <code>indirectdraw.frag</code>, and <code>indirectdraw.vert</code> files.</p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor238"/>How to do it…</h2>
<p>We will be building on a recipe from <a href="B18491_02.xhtml#_idTextAnchor126"><em class="italic">Chapter 2</em></a><em class="italic">, Working with Modern Vulkan.</em> that implemented Multi-Draw Indirect. We demonstrated during that recipe the use of <code>vkCmdDrawIndexedIndirect</code>. In this recipe, we will use a command that derives the number of its parameters from a device buffer, <code>vkCmdDrawIndexedIndirectCount</code>. This Vulkan API lets you specify a GPU buffer that contains the draw count instead of providing it by the CPU.</p>
<p>This recipe’s technique relies on three buffers: the first two each contain the indirect draw parameters’ structures, <code>InputIndirectDraws</code> and <code>OutputIndirectDraws</code> respectively; the third one contains the number of meshes to be rendered. The first buffer contains the parameters for all meshes in the scene. The second buffer is populated by the compute shader: meshes that are <em class="italic">not</em> culled have their indirect parameters atomically copied from the <code>InputIndirectDraws</code> buffer to <code>OutputIndirectDraws</code>; meshes tha<a id="_idTextAnchor239"/>t are culled don’t have their parameters copied:</p>
<div><div><img alt="Figure 3.9 – Top buffer: all mesh parameters; bottom buffer: unculled meshes set to render" src="img/B18491_03_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Top buffer: all mesh parameters; bottom buffer: unculled meshes set to render</p>
<p>Additionally, the compute shader needs information about each mesh’s bounding box and their center, and the six planes of the frustum. With this information, the compute pass can cull (or not) each mesh. At the end of the pass, the <code>OutputIndirectDraws</code> buffer contains parameters only for the meshes that will be rendered and is used by the indirect draw command.</p>
<p>Next is the recipe broken down into steps, along with snippets from <code>mainCullingCompute.cpp</code>. It provides a high-level view of how culling and drawing passes are used in tandem to perform frustum culling using compute shaders in Vulkan. The <a id="_idIndexMarker323"/>compute shade<a id="_idIndexMarker324"/>r takes care of determining which meshes should be drawn, and then the graphics pipeline takes care of drawing those meshes.</p>
<ol>
<li>Initialize the culling pass by using scene information and a scene buffer:<pre class="source-code">
cullingPass.init(&amp;context, &amp;camera,
                 *bistro.get(), buffers[3]);
cullingPass.upload(commandMgr);</pre><p class="list-inset">The first step consists of initializing the two buffers shown in <em class="italic">Figure 3</em><em class="italic">.9</em> and uploading them to the device. The details are encapsulated by the <code>CullingComputePass</code> class.</p></li> <li>The compute pass is also encapsulated by the <code>CullingComputePass</code> class:<pre class="source-code">
auto commandBuffer = commandMgr.getCmdBufferToBegin();
cullingPass.cull(commandBuffer, index);</pre><p class="list-inset">We will discuss the cull method shown next in more detail.</p></li> <li>To prevent a race condition between the compute pass and the rendering pass, we add a barrier for the culled indirect draw and the draw count buffer. This is necessary because the subsequent drawing commands rely on the results of the culling pass:<pre class="source-code">
cullingPass.addBarrierForCulledBuffers(
    commandBuffer,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
    context.physicalDevice()
        .graphicsFamilyIndex()
        .value(),
    context.physicalDevice()
        .graphicsFamilyIndex()
        .value());</pre></li> <li>The draw call<a id="_idIndexMarker325"/> is <a id="_idIndexMarker326"/>recorded with the <code>vkCmdDrawIndexedIndirectCount</code> command:<pre class="source-code">
vkCmdDrawIndexedIndirectCount(
    commandBuffer,
    cullingPass.culledIndirectDrawBuffer()
        -&gt;vkBuffer(),
    0,
    cullingPass
        .culledIndirectDrawCountBuffer()
        -&gt;vkBuffer(),
    0, numMeshes,
    sizeof(
        EngineCore::
            IndirectDrawCommandAndMeshData));</pre></li> </ol>
<p>Having grasped the essential elements of code for the culling pass, let’s delve into its operational mechanism.</p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor240"/>How it works…</h2>
<p>The <code>CullingComputePass::cull</code> method is responsible for updating frustum data, binding the compute pipeline, updating push constants, and calling <code>vkCmdDispatch</code>. <code>vkCmdDispatch</code> dispatches the compute work to the GPU. The compute work is divided into smaller units, each of which is called a workgroup. The <code>(pushConst.drawCount / 256) + 1, 1, 1)</code> parameters specify the number of workgroups that<a id="_idIndexMarker327"/> are <a id="_idIndexMarker328"/>dispatched in the <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> dimensions, respectively:</p>
<pre class="source-code">
void CullingComputePass::cull(
    VkCommandBuffer cmd, int frameIndex) {
  GPUCullingPassPushConstants pushConst{
      .drawCount =
          uint32_t(meshesBBoxData_.size()),
  };
  // Compute and store the six planes of the frustum
  for (int i = 0;
       auto &amp;plane :
       camera_-&gt;calculateFrustumPlanes()) {
    frustum_.frustumPlanes[i] = plane;
    ++i;
  }
  // Upload the data to the device
  camFrustumBuffer_-&gt;buffer()
      -&gt;copyDataToBuffer(&amp;frustum_,
                         sizeof(ViewBuffer));
  // Bind the compute pipeline, update push constants
  pipeline_-&gt;bind(cmd);
  pipeline_-&gt;updatePushConstant(
      cmd, VK_SHADER_STAGE_COMPUTE_BIT,
      sizeof(GPUCullingPassPushConstants),
      &amp;pushConst);
  // Bind descriptor sets
  pipeline_-&gt;bindDescriptorSets(
      cmd,
      {
          {.set = MESH_BBOX_SET,
           .bindIdx = 0},
          {.set = INPUT_INDIRECT_BUFFER_SET,
           .bindIdx = 0},
          {.set = OUTPUT_INDIRECT_BUFFER_SET,
           .bindIdx = 0},
          {.set =
               OUTPUT_INDIRECT_COUNT_BUFFER_SET,
           .bindIdx = 0},
          {.set = CAMERA_FRUSTUM_SET,
           .bindIdx = uint32_t(frameIndex)},
      });
  // Update descriptor sets
  pipeline_-&gt;updateDescriptorSets();
  // Dispatch the compute pass
  vkCmdDispatch(
      cmd, (pushConst.drawCount / 256) + 1, 1, 1);
}</pre> <p>The <code>CullingComputePass::addBarrierForCulledBuffers</code> method adds a pipeline barrier that ensures the culling operation has finished before the results are read. The barrier is <a id="_idIndexMarker329"/>set <a id="_idIndexMarker330"/>up so that it blocks the indirect command read access (which will be used in the draw call) until the shader write (the culling operation) has completed:</p>
<pre class="source-code">
void CullingComputePass::
    addBarrierForCulledBuffers(
        VkCommandBuffer cmd,
        VkPipelineStageFlags dstStage,
        uint32_t computeFamilyIndex,
        uint32_t graphicsFamilyIndex) {
  std::array&lt;VkBufferMemoryBarrier, 2&gt; barriers{
      VkBufferMemoryBarrier{
          .sType =
              VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
          .srcAccessMask =
              VK_ACCESS_SHADER_WRITE_BIT,
          .dstAccessMask =
              VK_ACCESS_INDIRECT_COMMAND_READ_BIT,
          .srcQueueFamilyIndex =
              computeFamilyIndex,
          .dstQueueFamilyIndex =
              graphicsFamilyIndex,
          .buffer = outputIndirectDrawBuffer_
                        -&gt;vkBuffer(),
          .size = outputIndirectDrawBuffer_
                      -&gt;size(),
      },
      VkBufferMemoryBarrier{
          .sType =
              VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
          .srcAccessMask =
              VK_ACCESS_SHADER_WRITE_BIT,
          .dstAccessMask =
              VK_ACCESS_INDIRECT_COMMAND_READ_BIT,
          .srcQueueFamilyIndex =
              computeFamilyIndex,
          .dstQueueFamilyIndex =
              graphicsFamilyIndex,
          .buffer =
              outputIndirectDrawCountBuffer_
                  -&gt;vkBuffer(),
          .size =
              outputIndirectDrawCountBuffer_
                  -&gt;size(),
      },
  };
  vkCmdPipelineBarrier(
      cmd,
      VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
      dstStage, 0, 0, nullptr,
      (uint32_t)barriers.size(),
      barriers.data(), 0, nullptr);
}</pre> <p>In the compute shader, we need a function that tells whether a bounding box falls completely outside of <a id="_idIndexMarker331"/>the<a id="_idIndexMarker332"/> frustum by comparing its extents and its center point against the six planes of the frustum:</p>
<pre class="source-code">
void cullMesh(uint id) {
  MeshBboxData meshBBoxData = meshBboxDatas[id];
  bool isVisible = true;
  for (int i = 0; i &lt; 6 &amp;&amp; isVisible; i++) {
    vec3 planeNormal =
        viewData.frustumPlanes[i].xyz;
    float distFromPlane = dot(
        meshBBoxData.centerPos.xyz, planeNormal);
    float absDiff = dot(abs(planeNormal),
                        meshBBoxData.extents.xyz);
    if (distFromPlane + absDiff +
            viewData.frustumPlanes[i].w &lt; 0.0) {
      isVisible = false;
    }
  }
  if (isVisible) {
    uint index = atomicAdd(outDrawCount.count, 1);
    outputIndirectDraws[index] = inputIndirectDraws[id];
  }
}</pre> <p>If the mesh is culled, the function returns early. Otherwise, it atomically increments the number of visible meshes in the <code>IndirectDrawCount</code> buffer and copies the indirect draw parameters from the input to the output buffer using the previous number of meshes in the buffer <a id="_idIndexMarker333"/>as <a id="_idIndexMarker334"/>the index of the destination.</p>
<p>The only remaining work for the main function is to call <code>cullMesh</code>:</p>
<pre class="source-code">
layout(local_size_x = 256, local_size_y = 1,
       local_size_z = 1) in;
void main() {
  uint currentThreadId = gl_GlobalInvocationID.x;
  if (currentThreadId == 0) {
    atomicExchange(outDrawCount.count, 0);
  }
  barrier();
  if (currentThreadId &lt; cullData.count) {
    cullMesh(currentThreadId);
  }
}</pre> <p>Through this recipe, we’ve harnessed the power of the GPU to effectively filter out non-essential objects, optimizing<a id="_idIndexMarker335"/> our rendering workflow. By<a id="_idIndexMarker336"/> implementing this method, you will achieve a more responsive and resource-efficient visualization, especially vital for intricate 3D scenes.</p>
</div>
</body></html>