<html><head></head><body>
<div id="_idContainer042">
<h1 class="chapter-number" id="_idParaDest-188"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-189"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.2.1">Implementing GPU-Driven Rendering</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we embark on a deep dive into the intricacies of manipulating geometry specifically for GPU rendering. </span><span class="koboSpan" id="kobo.3.2">The traditional approach heavily relies on the CPU for various tasks, which can be a bottleneck in many scenarios. </span><span class="koboSpan" id="kobo.3.3">Our goal here is to liberate your rendering techniques from such constraints. </span><span class="koboSpan" id="kobo.3.4">We aim to put the GPU in the driver’s seat, ensuring efficient processing by capitalizing on its parallel processing prowess. </span><span class="koboSpan" id="kobo.3.5">We will unravel the technique of generating and drawing lines, not from the traditional space of the CPU but directly from shaders, such as vertex or fragment shaders. </span><span class="koboSpan" id="kobo.3.6">This not only enhances efficiency but also opens new realms of creativity. </span><span class="koboSpan" id="kobo.3.7">Taking a step further, we’ll demonstrate how to extend this novel line-drawing feature to display numbers right from shaders. </span><span class="koboSpan" id="kobo.3.8">This capability paves the way for real-time displays and feedback without toggling between GPU and CPU. </span><span class="koboSpan" id="kobo.3.9">We then shift our gaze to a more intricate topic – rendering text on the GPU. </span><span class="koboSpan" id="kobo.3.10">By employing the </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Signed Distance Fields</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">SDF</span></strong><span class="koboSpan" id="kobo.7.1">) approach, we’ll guide you in achieving smoother and more versatile text rendering on </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">the GPU.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">Lastly, we’ll address one of the classic challenges in rendering: frustum culling. </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">Frustum culling</span></strong><span class="koboSpan" id="kobo.11.1"> involves avoiding the rendering of objects that are outside the camera’s </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">field of view</span></strong><span class="koboSpan" id="kobo.13.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.14.1">FOV</span></strong><span class="koboSpan" id="kobo.15.1">). </span><strong class="bold"><span class="koboSpan" id="kobo.16.1">Frustum</span></strong><span class="koboSpan" id="kobo.17.1"> refers to the volume of space that is visible through the camera. </span><strong class="bold"><span class="koboSpan" id="kobo.18.1">Culling</span></strong><span class="koboSpan" id="kobo.19.1"> means discarding or ignoring objects that fall outside this frustum, thus they are not processed for rendering. </span><span class="koboSpan" id="kobo.19.2">Instead of the traditional approach, we’ll show you how to implement this directly on the GPU using compute shaders, ensuring objects outside the camera view do not consume valuable GPU resources. </span><span class="koboSpan" id="kobo.19.3">By the chapter’s close, you’ll have a holistic grasp of GPU-driven rendering, enabling you to harness the GPU’s capabilities to its fullest and streamline your </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">rendering tasks.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">following recipes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.23.1">Implementing GPU-driven </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">line rendering</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Expanding line-drawing techniques to render textual values </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">from shaders</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Drawing text </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">using SDF</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Frustum culling using </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">compute shaders</span></span></li>
</ul>
<h1 id="_idParaDest-190"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.31.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.32.1">For this chapter, you will need to make sure you have VS 2022 installed along with the Vulkan SDK. </span><span class="koboSpan" id="kobo.32.2">Basic familiarity with the C++ programming language and an understanding of OpenGL or any other graphics API will be useful. </span><span class="koboSpan" id="kobo.32.3">Please revisit </span><a href="B18491_01.xhtml#_idTextAnchor019"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.33.1">Chapter 1</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.34.1">, Vulkan Core Concepts</span></em><span class="koboSpan" id="kobo.35.1">, under the </span><em class="italic"><span class="koboSpan" id="kobo.36.1">Technical requirements</span></em><span class="koboSpan" id="kobo.37.1"> section for details on setting up and building executables for this chapter. </span><span class="koboSpan" id="kobo.37.2">This chapter has multiple recipes, which can be launched using the </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">following executables:</span></span></p>
<ol>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">Chapter03_GPU_Lines.exe</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">Chapter03_GPU_Text.exe</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">Chapter03_GPU_Text_SDF.exe</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">Chapter03_GPU_Culling.exe</span></strong></span></li>
</ol>
<h1 id="_idParaDest-191"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.43.1">Implementing GPU-driven line rendering</span></h1>
<p><span class="koboSpan" id="kobo.44.1">In this recipe, you </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.45.1">will learn a technique that allows drawing lines directly from shaders such as vertex or fragment shaders. </span><span class="koboSpan" id="kobo.45.2">In many graphics applications, the challenge arises when one wishes to draw lines directly and efficiently using the inherent capabilities of shaders, particularly vertex or fragment shaders. </span><span class="koboSpan" id="kobo.45.3">To address this, our recipe delves into a specialized technique tailored for this very purpose. </span><span class="koboSpan" id="kobo.45.4">We’ll be presenting a recipe that seamlessly integrates with a variety of pipelines and render passes. </span><span class="koboSpan" id="kobo.45.5">Through our approach, data, be it vertices or colors, gets stored in a device buffer, ensuring a streamlined process. </span><span class="koboSpan" id="kobo.45.6">The culmination of this procedure is the utilization of this accumulated data in a subsequent pass, where these lines are then masterfully rendered onto a framebuffer. </span><span class="koboSpan" id="kobo.45.7">By the end, you will have a robust and efficient method to directly render lines </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">using shaders.</span></span></p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.47.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.48.1">Before diving into the recipe, you should make sure you have VS 2022 installed and that you are able to build the repository as per the steps provided in </span><a href="B18491_01.xhtml#_idTextAnchor019"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.49.1">Chapter 1</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.50.1">, Vulkan </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.51.1">Core Concepts</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">You should be able to launch the executable named </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">Chapter03_GPU_Lines.exe</span></strong><span class="koboSpan" id="kobo.55.1"> from </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">VS 2022.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">The code covered in this recipe can be found in the repository, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">chapter3/mainGPULines.cpp</span></strong><span class="koboSpan" id="kobo.59.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">chapter3/resources/shaders</span></strong><span class="koboSpan" id="kobo.61.1">, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">gpuLines.frag</span></strong><span class="koboSpan" id="kobo.63.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">gpuLines.vert</span></strong><span class="koboSpan" id="kobo.65.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">gpuLinesDraw.frag</span></strong><span class="koboSpan" id="kobo.67.1">, and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">gpuLinesDraw.vert</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.69.1"> files.</span></span></p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.70.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.71.1">In this section, we’ll guide you through the comprehensive procedure of directly drawing lines from shaders and integrating them into the final rendered frame using GPU-driven techniques. </span><span class="koboSpan" id="kobo.71.2">By leveraging a dedicated device buffer and carefully orchestrated render passes, this technique allows for real-time visual feedback and streamlined graphical processes. </span><span class="koboSpan" id="kobo.71.3">By the end of this walkthrough, you’ll have a robust mechanism in place for efficiently rendering lines directly from the GPU with minimal </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">CPU involvement.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">The idea relies on having a device buffer that serves as a repository for lines and parameters for the indirect draw structure used to render those lines. </span><span class="koboSpan" id="kobo.73.2">After all render passes are complete, one additional render pass is performed to draw lines in the buffer. </span><span class="koboSpan" id="kobo.73.3">Here are the steps to </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">do it:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.75.1">The first step</span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.76.1"> is to create a buffer that will contain not only the line data but also metadata that is used for determining how many lines can fit into the buffer and other parameters used by the final indirect draw call. </span><span class="koboSpan" id="kobo.76.2">The following snippet defines the buffer structure in C++, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">GPULineBuffer</span></strong><span class="koboSpan" id="kobo.78.1"> being the structure of the buffer used to </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">store/draw lines:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.80.1">
constexpr uint32_t kNumLines = 65'536;
struct Line {
  glm::vec4 v0_;
  glm::vec4 color0_;
  glm::vec4 v1_;
  glm::vec4 color1_;
};
struct Header {
  uint32_t maxNumlines_;
  uint32_t padding0 = 0u;
  uint32_t padding1 = 0u;
  uint32_t padding2 = 0u;
  VkDrawIndirectCommand cmd_;
};
struct GPULineBuffer {
  Header header_;
  Line lines_[kNumLines];
};</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.81.1">This structure defines the device buffer we’ll use to store the GPU-generated lines and can store up to 65,536 lines plus the data in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">Header</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.83.1"> section.</span></span></p><p class="list-inset"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.84.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.85.1">.1</span></em><span class="koboSpan" id="kobo.86.1"> shows</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.87.1"> the buffer’s layout as </span><em class="italic"><span class="koboSpan" id="kobo.88.1">seen</span></em><span class="koboSpan" id="kobo.89.1"> by </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">the GPU:</span></span></p></li> </ol>
<p class="IMG---Figure"><a id="_idTextAnchor223"/></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.91.1"><img alt="Figure 3.1 – The GPU lines’ buffer structure" src="image/B18491_03_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.92.1">Figure 3.1 – The GPU lines’ buffer structure</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.93.1">This buffer is </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.94.1">created with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">usage bits:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">VK_BUFFER_USAGE_TRANSFER_DST_BIT</span></strong></span></li>
</ul>
<p class="list-inset"><span class="koboSpan" id="kobo.99.1">This buffer should be made available to all render passes you wish to be able to draw/generate </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">lines from:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.101.1">
std::shared_ptr&lt;VulkanCore::Buffer&gt; gpuLineBuffer;
gpuLineBuffer = context.createBuffer(
    kGPULinesBufferSize,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT |
        VK_BUFFER_USAGE_STORAGE_BUFFER_BIT |
        VK_BUFFER_USAGE_TRANSFER_DST_BIT,
    static_cast&lt;VmaMemoryUsage&gt;(
        VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT));</span></pre> <ol>
<li value="2"><span class="koboSpan" id="kobo.102.1">The provided code snippet initializes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">gpuLineBuffer</span></strong><span class="koboSpan" id="kobo.104.1"> buffer using the Vulkan API. </span><span class="koboSpan" id="kobo.104.2">This buffer, created via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">context.createBuffer</span></strong><span class="koboSpan" id="kobo.106.1"> method, is given a specified size (</span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">kGPULinesBufferSize</span></strong><span class="koboSpan" id="kobo.108.1">) and is designated for multiple purposes, including indirect draw commands, shader data storage, and as a destination for buffer-to-buffer copy operations. </span><span class="koboSpan" id="kobo.108.2">Additionally, the buffer’s memory is set</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.109.1"> to reside on the GPU, ensuring </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">fast access:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.111.1">
struct Line {
  vec3 v0;
  vec4 c0;
  vec3 v1;
  vec4 c1;
};
struct VkDrawIndirectCommand {
  uint vertexCount;
  uint instanceCount;
  uint firstVertex;
  uint firstInstance;
};
layout(set = 4, binding = 0) buffer GPULinesBuffer
{
  uint size;
  uint row;
  uint pad1;
  uint pad2;
  VkDrawIndirectCommand cmd;
  Line lines[];
} lineBuffer;
void addLine(vec3 v0, vec3 v1, vec4 c0, vec4 c1) {
  const uint idx =
      atomicAdd(lineBuffer.cmd.instanceCount, 1);
  if (idx &gt;= lineBuffer.size) {
    atomicMin(lineBuffer.cmd.instanceCount,
              lineBuffer.size);
    return;
  }
  lineBuffer.lines[idx].v0 = v0;
  lineBuffer.lines[idx].v1 = v1;
  lineBuffer.lines[idx].c0 = c0;
  lineBuffer.lines[idx].c1 = c1;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.112.1">The function first </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.113.1">checks for the next available index for storing the line information by retrieving the number of lines already in the buffer with </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">atomicAdd</span></strong><span class="koboSpan" id="kobo.115.1">. </span><span class="koboSpan" id="kobo.115.2">If the index returned by the function is greater than the maximum number of lines that can fit into the buffer, the function returns early and is a no-op. </span><span class="koboSpan" id="kobo.115.3">Otherwise, the line data is stored in </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">the buffer.</span></span></p></li> <li><span class="koboSpan" id="kobo.117.1">Rendering the lines is done with an extra render pass once all other passes have finished processing since the data from previous passes is required. </span><span class="koboSpan" id="kobo.117.2">The vertex shader code to</span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.118.1"> render the lines looks like the </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">following snippet:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.120.1">
#version 460
#extension GL_EXT_nonuniform_qualifier : require
struct Line {
  vec3 v0;
  vec4 c0;
  vec3 v1;
  vec4 c1;
};
struct VkDrawIndirectCommand {
  uint vertexCount;
  uint instanceCount;
  uint firstVertex;
  uint firstInstance;
};
layout(set = 1, binding = 0) readonly buffer
GPULinesBuffer {
  Line lines[];
} lineBuffer;
layout (location = 0) out vec4 outColor;
void main() {
  if (gl_VertexIndex == 0) {
    vec3 vertex =
        lineBuffer.lines[gl_InstanceIndex].v0;
    gl_Position = vec4(vertex, 1.0).xyww;
    outColor =
        lineBuffer.lines[gl_InstanceIndex].c0;
  } else {
    vec3 vertex =
        lineBuffer.lines[gl_InstanceIndex].v1;
    gl_Position = vec4(vertex, 1.0).xyww;
    outColor =
        lineBuffer.lines[gl_InstanceIndex].c1;
  }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.121.1">In the preceding</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.122.1"> code, two structures are introduced: </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">Line</span></strong><span class="koboSpan" id="kobo.124.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">VkDrawIndirectCommand</span></strong><span class="koboSpan" id="kobo.126.1">. </span><span class="koboSpan" id="kobo.126.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">Line</span></strong><span class="koboSpan" id="kobo.128.1"> structure represents a colored line segment, defined by two 3D endpoints (</span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">v0</span></strong><span class="koboSpan" id="kobo.130.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">v1</span></strong><span class="koboSpan" id="kobo.132.1">) and their corresponding colors (</span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">c0</span></strong><span class="koboSpan" id="kobo.134.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">c1</span></strong><span class="koboSpan" id="kobo.136.1">). </span><span class="koboSpan" id="kobo.136.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">VkDrawIndirectCommand</span></strong><span class="koboSpan" id="kobo.138.1"> structure represents a Vulkan command for indirect drawing. </span><span class="koboSpan" id="kobo.138.2">The shader also establishes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">GPULinesBuffer</span></strong><span class="koboSpan" id="kobo.140.1"> buffer containing an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">Line</span></strong><span class="koboSpan" id="kobo.142.1"> structures. </span><span class="koboSpan" id="kobo.142.2">In the main function, depending on the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">gl_VertexIndex</span></strong><span class="koboSpan" id="kobo.144.1">, the shader selects the starting or ending point of a line instance and assigns the respective color to </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">outColor</span></strong><span class="koboSpan" id="kobo.146.1">. </span><span class="koboSpan" id="kobo.146.2">Also, notice how in this shader, we only define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">GPULinesBuffer</span></strong><span class="koboSpan" id="kobo.148.1"> structure without the header structure. </span><span class="koboSpan" id="kobo.148.2">That’s because for drawing lines, we bind the buffer at an offset, bypassing the need to define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">Header</span></strong><span class="koboSpan" id="kobo.150.1"> segment in </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">the shader.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.152.1">The fragment shader just outputs the color provided through the </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">vertex shader:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.154.1">#version 460
layout(location = 0) in vec4 inColor;
layout(location = 0) out vec4 outColor;
void main() {
  outColor = inColor;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.155.1">Before rendering the lines, we need to make sure that the previous steps have finished writing</span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.156.1"> into the buffer, so we issue a </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">buffer barrier:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.158.1">const VkBufferMemoryBarrier bufferBarrier = {
    .sType =
        VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
    .srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT,
    .dstAccessMask =
        VK_ACCESS_INDIRECT_COMMAND_READ_BIT,
    .srcQueueFamilyIndex =
        VK_QUEUE_FAMILY_IGNORED,
    .dstQueueFamilyIndex =
        VK_QUEUE_FAMILY_IGNORED,
    .buffer = gpuLineBuffer-&gt;vkBuffer(),
    .offset = 0,
    .size = VK_WHOLE_SIZE,
};
vkCmdPipelineBarrier(
    commandBuffer,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT, 0, 0,
    nullptr, 1, &amp;bufferBarrier, 0, nullptr);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.159.1">After that, we issue an indirect draw command that derives its parameters directly from the buffer itself. </span><span class="koboSpan" id="kobo.159.2">We cleverly stored the number of lines stored in the buffer in the previous passes in </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">VkDrawIndirectCommand:: instanceCount</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.162.1">vkCmdDrawIndirect(commandBuffer,
                  gpuLineBuffer-&gt;vkBuffer(),
                  sizeof(uint32_t) * 4, 1,
                  sizeof(VkDrawIndirectCommand));</span></pre></li> <li><span class="koboSpan" id="kobo.163.1">The final step</span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.164.1"> consists of clearing the buffer, which is required for clearing the number of lines in the buffer (</span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">VkDrawIndirectCommand:: instanceCount</span></strong><span class="koboSpan" id="kobo.166.1">). </span><span class="koboSpan" id="kobo.166.2">Before clearing the buffer, we must ensure that the GPU has finished drawing lines, which we can verify by issuing another </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">buffer barrier:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.168.1">
const VkBufferMemoryBarrier bufferBarrierClear = {
    .sType =
        VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
    .srcAccessMask =
        VK_ACCESS_INDIRECT_COMMAND_READ_BIT,
    .dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT,
    .srcQueueFamilyIndex =
        VK_QUEUE_FAMILY_IGNORED,
    .dstQueueFamilyIndex =
        VK_QUEUE_FAMILY_IGNORED,
    .buffer = gpuLineBuffer-&gt;vkBuffer(),
    .offset = 0,
    .size = VK_WHOLE_SIZE,
};
// Reset the number of lines in the buffer
vkCmdFillBuffer(commandBuffer,
                gpuLineBuffer-&gt;vkBuffer(),
                sizeof(uint32_t) * 5,
                sizeof(uint32_t), 0);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.169.1">In this recipe, we have unpacked a powerful technique for rendering lines directly from shaders. </span><span class="koboSpan" id="kobo.169.2">The utility of this method extends to diverse rendering applications, and it lays the groundwork for </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.170.1">more advanced graphical outputs, elevating your skills to an even higher level in the realm of GPU programming </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">using Vulkan.</span></span></p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.172.1">Expanding line-drawing techniques to render textual values from shaders</span></h1>
<p><span class="koboSpan" id="kobo.173.1">Continuing</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.174.1"> from our </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.175.1">previous exploration, where we developed the capability to draw lines directly from shaders, our next challenge is to further refine this capability to facilitate the rendering of text values. </span><span class="koboSpan" id="kobo.175.2">Drawing inspiration from the foundational concepts established in the preceding recipe, we aim to implement a methodology that permits the conversion of numerical values into line segments, much like digital LCD displays. </span><span class="koboSpan" id="kobo.175.3">By doing so, not only do we breathe life into bare numerical data, making it more visual and interpretable, but we also harness the power and efficiency of shaders in crafting these representations. </span><span class="koboSpan" id="kobo.175.4">Upon completion, you will be equipped with a robust toolset, allowing them to render clear, scalable, and visually appealing textual data, right from </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">their shaders.</span></span></p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.177.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.178.1">Before diving into the recipe, you should make sure you have VS 2022 installed and that you are able to build the repository as per the steps provided in </span><a href="B18491_01.xhtml#_idTextAnchor019"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.179.1">Chapter 1</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.180.1">, Vulkan </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.181.1">Core Concepts.</span></em></span></p>
<p><span class="koboSpan" id="kobo.182.1">You should be able to launch the executable named </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">Chapter03_GPU_Text.exe</span></strong><span class="koboSpan" id="kobo.184.1"> from </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">VS 2022.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">Since this recipe is heavily based on the previous recipe, we recommend reading the previous recipe on GPU line drawing first. </span><span class="koboSpan" id="kobo.186.2">The code covered in this recipe can be found in</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.187.1"> the </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.188.1">repository, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">chapter3/mainGPUText.cpp</span></strong><span class="koboSpan" id="kobo.190.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">chapter3/resources/shaders</span></strong><span class="koboSpan" id="kobo.192.1">, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">gpuText.frag</span></strong><span class="koboSpan" id="kobo.194.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">gpuText.vert</span></strong><span class="koboSpan" id="kobo.196.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">gpuTextDraw.frag</span></strong><span class="koboSpan" id="kobo.198.1">, and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">gpuTexDraw.vert</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.200.1"> files.</span></span></p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.201.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.202.1">The idea is to decompose numbers into segments (like LCD segment displays) and print values by drawing lines for each digit. </span><span class="koboSpan" id="kobo.202.2">The previous recipe covered how to store and draw lines; this recipe builds on top of that to print numbers. </span><span class="koboSpan" id="kobo.202.3">Since in this recipe we need to draw numbers, we will need to parse numbers and decompose them </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">into lines:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.204.1">First, we need to use a strategy to represent digits with only lines. </span><span class="koboSpan" id="kobo.204.2">We chose to implement a simple 7-segment approach that can be used to display all digits from 0 to 9 plus a minus sign. </span><span class="koboSpan" id="kobo.204.3">We also added an extra segment to represent a decimal separator. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.205.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.206.1">.2</span></em><span class="koboSpan" id="kobo.207.1"> shows the seven segments plus the decimal separator and their indices as used by the code in </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">t</span><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.209.1">he shader:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.210.1"><img alt="Figure 3.2 – Segments used to represent all digits from 0 to 9 plus a decimal separator and a minus sign" src="image/B18491_03_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.211.1">Figure 3.2 – Segments used to represent all digits from 0 to 9 plus a decimal separator and a minus sign</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.212.1">In addition to the structures defined in the previous recipe, we will replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">pad0</span></strong><span class="koboSpan" id="kobo.214.1"> member of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">GPULinesBuffer</span></strong><span class="koboSpan" id="kobo.216.1"> buffer so that it stores the </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">row number:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.218.1">
layout(set = 4, binding = 0) buffer GPULinesBuffer
{
  uint size;
  </span><strong class="bold"><span class="koboSpan" id="kobo.219.1">uint row;</span></strong><span class="koboSpan" id="kobo.220.1">
  uint pad1;
  uint pad2;
  VkDrawIndirectCommand cmd;
  Line lines[];
} lineBuffer;</span></pre></li> <li><span class="koboSpan" id="kobo.221.1">We’ll also </span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.222.1">need the </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.223.1">definition of the segments shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.224.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.225.1">.2</span></em><span class="koboSpan" id="kobo.226.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">two vectors:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.228.1">
vec2 v[] = {vec2(-0.5f,  1.0f), vec2(0.5f,  1.f),
            vec2(-0.5f,  0.0f), vec2(0.5f,  0.f),
            vec2(-0.5f, -1.0f), vec2(0.5f, -1.f),
           vec2( 0.0f, -0.8f), vec2(0.0f, -1.f) };
uvec2 i[] = {uvec2(0, 1), uvec2(2, 3), uvec2(4, 5), uvec2(0, 2), uvec2(1, 3), uvec2(2, 4), uvec2(3, 5), uvec2(6, 7)};</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.229.1">Array </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">v</span></strong><span class="koboSpan" id="kobo.231.1"> represents the coordinates of all vertices shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.232.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.233.1">.2 </span></em><span class="koboSpan" id="kobo.234.1">normalized into the range [</span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">-0.5</span></strong><span class="koboSpan" id="kobo.236.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">0.5</span></strong><span class="koboSpan" id="kobo.238.1">] in the </span><em class="italic"><span class="koboSpan" id="kobo.239.1">x</span></em><span class="koboSpan" id="kobo.240.1"> direction and [</span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">-1.0</span></strong><span class="koboSpan" id="kobo.242.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">1.0</span></strong><span class="koboSpan" id="kobo.244.1">] in the </span><em class="italic"><span class="koboSpan" id="kobo.245.1">y</span></em><span class="koboSpan" id="kobo.246.1"> direction. </span><span class="koboSpan" id="kobo.246.2">Array </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">i</span></strong><span class="koboSpan" id="kobo.248.1"> describes all segments and their vertices. </span><span class="koboSpan" id="kobo.248.2">For instance, the first element of the array describes segment 0 in the picture, from vertex 0 (</span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">-0.5</span></strong><span class="koboSpan" id="kobo.250.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">1.0</span></strong><span class="koboSpan" id="kobo.252.1">) to vertex 1 (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">0.5</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">1.0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">).</span></span></p></li> <li><span class="koboSpan" id="kobo.257.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">printSegment</span></strong><span class="koboSpan" id="kobo.259.1"> function adds one segment, given its index, a scale, and a translation, to the GPU buffer where lines </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">are stored:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.261.1">
void printSegment(int segment, vec2 pos, vec2 scale) {
  uint idx = i[segment].x;
  uint idy = i[segment].y;
  vec3 v0 = vec3(v[idx] * scale + pos, 1.0);
  vec3 v1 = vec3(v[idy] * scale + pos, 1.0);
  addLine(v0, v1, vec4(0,0,0,1), vec4(0,0,0,1));
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.262.1">This function calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">addLine</span></strong><span class="koboSpan" id="kobo.264.1"> function presented before to record the final vertices and colors of lines in </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">the buffer.</span></span></p></li> <li><span class="koboSpan" id="kobo.266.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">printDigit</span></strong><span class="koboSpan" id="kobo.268.1"> function prints all segments for a digit at a specific line and column, passed</span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.269.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">as</span></span><span class="No-Break"><a id="_idIndexMarker283"/></span><span class="No-Break"><span class="koboSpan" id="kobo.271.1"> parameters:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.272.1">
void printDigit(int digit, uint linenum,
                uint column) {
  const float charWidthPixel = 10;
  const float charHeightPixels = 10;
  const float horSpacePixels = 5;
  const float verSpacePixels = 5;
  const float charWidthNDC =
      charWidthPixels / screenWidth;
  const float charHeightNDC =
      charHeightPixels / screenHeight;
  const float horSpaceNDC =
      horSpacePixels / screenWidth;
  const float verSpaceNDC =
      verSpacePixels / screenHeight;
  const float colx =
      (column + 1) *
      (charWidthNDC + horSpaceNDC);
  const float coly =
      (linenum + 1) *
      (charHeightNDC + 3 * verSpaceNDC);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.273.1">Initially, it calculates the width and height of the characters in </span><strong class="bold"><span class="koboSpan" id="kobo.274.1">normalized device coordinates</span></strong><span class="koboSpan" id="kobo.275.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.276.1">NDC</span></strong><span class="koboSpan" id="kobo.277.1">) space </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.278.1">as well as the spacing between them. </span><span class="koboSpan" id="kobo.278.2">For that, we need the dimensions of the viewport. </span><span class="koboSpan" id="kobo.278.3">A viewport is a 2D rectangle representing the area into which the rendering result will be displayed on the screen. </span><span class="koboSpan" id="kobo.278.4">The</span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.279.1"> function</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.280.1"> uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">switch</span></strong><span class="koboSpan" id="kobo.282.1"> statement to decide which digit to print. </span><span class="koboSpan" id="kobo.282.2">The following snippet only shows how to print the digits 0 and 1, the decimal separator, and the minus sign </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">for brevity:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.284.1">  const vec2 pos(colx, coly);
  const vec2 scale(charWidthNDC, -charHeightNDC);
  switch (digit) {
  case 0:
    printSegment(0, pos, scale);
    printSegment(3, pos, scale);
    printSegment(4, pos, scale);
    printSegment(5, pos, scale);
    printSegment(6, pos, scale);
    printSegment(2, pos, scale);
    break;
  case 1:
    printSegment(4, pos, scale);
    printSegment(6, pos, scale);
    break;
  case 10: // decimal separator
    printSegment(7, pos, scale);
    break;
  case 11: // minus sign
    printSegment(1, pos, scale);
    break;
  }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.285.1">The preceding</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.286.1"> code employs a switch-case structure to identify which segments should be activated based on the digit or symbol passed. </span><span class="koboSpan" id="kobo.286.2">For example, the number </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">0</span></strong><span class="koboSpan" id="kobo.288.1"> requires several segments to depict its round shape. </span><span class="koboSpan" id="kobo.288.2">Therefore, when the digit is </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">0</span></strong><span class="koboSpan" id="kobo.290.1">, multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">printSegment</span></strong><span class="koboSpan" id="kobo.292.1"> calls are made to render each segment required for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">0</span></strong><span class="koboSpan" id="kobo.294.1"> digit. </span><span class="koboSpan" id="kobo.294.2">Similarly, </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">1</span></strong><span class="koboSpan" id="kobo.296.1"> is formed using two segments on its side. </span><span class="koboSpan" id="kobo.296.2">Beyond the digits, the function also has provisions to depict a decimal separator and a minus sign, distinguished by their unique </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">segment arrangements.</span></span></p></li> <li><span class="koboSpan" id="kobo.298.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">printNumber</span></strong><span class="koboSpan" id="kobo.300.1"> function is designed to display an integer on a specified line, starting from a given column. </span><span class="koboSpan" id="kobo.300.2">After executing, it provides the next available column following the last digit printed. </span><span class="koboSpan" id="kobo.300.3">If the integer is zero, it simply prints </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">'0'</span></strong><span class="koboSpan" id="kobo.302.1">. </span><span class="koboSpan" id="kobo.302.2">For nonzero integers, the function efficiently computes the number of digits and</span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.303.1"> iteratively </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.304.1">prints each one, advancing the </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">column accordingly:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.306.1">
uint printNumber(highp int value,
                 uint linenum, uint column) {
  if (value == 0) {
    printDigit(0, linenum, column);
    return column + 1;
  }
  int counter = 0;
  int copy = value;
  int tens = 1;
  while (copy &gt; 0) {
    counter++;
    copy = copy / 10;
    tens *= 10;
  }
  tens /= 10;
  for (int i = counter; i &gt; 0; --i) {
    int digit = int(value / tens);
    printDigit(digit, linenum, column);
    value = value - (digit * tens);
    tens /= 10;
    column++;
  }
  return column;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.307.1">This function parses the integer parameter and prints each digit individually, while incrementing the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">column</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.309.1"> index.</span></span></p></li> <li><span class="koboSpan" id="kobo.310.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">parse</span></strong><span class="koboSpan" id="kobo.312.1"> function</span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.313.1"> parses</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.314.1"> a float and prints it with a certain number of </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">decimal places:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.316.1">
void parse(float val, uint decimals) {
  int d = int(log(val));
  int base = int(pow(10, d));
  const float tens = pow(10, decimals);
  const uint line = atomicAdd(lineBuffer.row, 1);
  uint column = 0;
  // Minus sign
  if (val &lt; 0) {
    printDigit(11, line, column);
    column++;
  }
  // Prints only positive values
  val = abs(val);
  // Integer part
  const int intPart = int(val);
  column = printNumber(intPart, line, column);
  // Decimal
  if (decimals &gt; 0) {
    // Dot
    printDigit(10, line, column);
    column++;
    const int decimal =
        int(val * tens - intPart * tens);
    printNumber(decimal, line, column);
  }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.317.1">The function splits the float into two parts, the integer part and the decimal part, and prints them separately. </span><span class="koboSpan" id="kobo.317.2">If the number is negative, it prints the </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">minus sign.</span></span></p></li> <li><span class="koboSpan" id="kobo.319.1">The next </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.320.1">step</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.321.1"> is to clear the buffer once the lines text has been rendered. </span><span class="koboSpan" id="kobo.321.2">In the previous recipe, we cleared the number of lines in the buffer. </span><span class="koboSpan" id="kobo.321.3">Here, we also need to clear the </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">row number:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.323.1">
vkCmdFillBuffer(commandBuffer,
                gpuLineBuffer-&gt;vkBuffer(),
                sizeof(uint32_t),
                sizeof(uint32_t), 0);</span></pre></li> <li><span class="koboSpan" id="kobo.324.1">The last step is to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">parse</span></strong><span class="koboSpan" id="kobo.326.1"> function. </span><span class="koboSpan" id="kobo.326.2">Just call it from any shader that includes those functions. </span><span class="koboSpan" id="kobo.326.3">Each call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">parse</span></strong><span class="koboSpan" id="kobo.328.1"> will print the value on a new line. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.329.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.330.1">.3</span></em><span class="koboSpan" id="kobo.331.1"> shows the result of printing some values with the following code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">vertex shader:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.333.1">
if (gl_VertexIndex == 0) {
  parse(123456, 0);
  parse(789, 0);
  parse(780.12, 3);
  parse(-23, 1);
  parse(0.3, 2);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.334.1">The following</span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.335.1"> screenshot shows how we can use this technique for debugging purp</span><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.336.1">oses or to </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">display text:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.338.1"><img alt="Figure 3.3 – The result of printing values from the vertex shader" src="image/B18491_03_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.339.1">Figure 3.3 – The result of printing values from the vertex shader</span></p>
<p><span class="koboSpan" id="kobo.340.1">In this recipe, we delved into the intricate process of representing numerical values using line segments, reminiscent of LCD displays. </span><span class="koboSpan" id="kobo.340.2">By breaking down numbers into their individual segments and leveraging our foundational line-drawing methods from shaders, we </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.341.1">provided </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.342.1">you with an innovative technique to visualize numbers. </span><span class="koboSpan" id="kobo.342.2">The end result is a seamless integration of numbers into your graphics, with clarity reminiscent of digital segment displays, enriching the overall </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">visual experience.</span></span></p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.344.1">Drawing text using SDF</span></h1>
<p><span class="koboSpan" id="kobo.345.1">In this recipe, we</span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.346.1"> address the challenge of rendering crisp and scalable text, regardless</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.347.1"> of its size. </span><span class="koboSpan" id="kobo.347.2">By utilizing the principles of SDF, we transform traditional text rendering into a more fluid process, ensuring sharpness and clarity. </span><span class="koboSpan" id="kobo.347.3">The outcome is beautifully rendered text that remains clear and legible, whether you’re zooming in closely or viewing from </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">a distance.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">SDFs provide a way to represent surfaces. </span><span class="koboSpan" id="kobo.349.2">An SDF is basically a function that, for every point in space, returns the shortest distance to the surface of the shape. </span><span class="koboSpan" id="kobo.349.3">SDFs can be used for a variety of use cases such as volume rendering or to perform operations on shapes such as dilation, erosion, and other </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">morphological operations.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">Traditionally, text is rendered using bitmap fonts. </span><span class="koboSpan" id="kobo.351.2">One can use a 2D canvas to render text and then use that as a texture to draw a quad in a 3D context. </span><span class="koboSpan" id="kobo.351.3">However, this method creates bitmaps that are resolution-dependent and need to be generated and uploaded to the device by the CPU. </span><span class="koboSpan" id="kobo.351.4">Each font style, such as bold, italics, and so on, also needs to be processed by the CPU, which causes an extra overhead for the computation and transfer of the textures for each style needed </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">for rendering.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">Rendering text using SDFs is a modern approach that uses distance fields for each character. </span><span class="koboSpan" id="kobo.353.2">These are grids in which each of the values represents the distance from each pixel to the nearest edge of the character. </span><span class="koboSpan" id="kobo.353.3">SDFs help avoid all the problems mentioned before by offering resolution-independent scaling as well as using the GPU for most of the work. </span><span class="koboSpan" id="kobo.353.4">Styles such as bold, outline, and so on require only changes </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">to shaders.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">Each letter of a font (a glyph) is described by a combination of straight lines and Bézier curves. </span><span class="koboSpan" id="kobo.355.2">One example of a glyph is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.356.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.357.1">.4</span></em><span class="koboSpan" id="kobo.358.1">, which shows the</span><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.359.1"> detail of a </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">glyph’s serif:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.361.1"><img alt="Figure 3.4 – Detail of a glyph definition: circles, triangles, and squares represent the start and end points of each segment (curves or straight lines)" src="image/B18491_03_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.362.1">Figure 3.4 – Detail of a glyph definition: circles, triangles, and squares represent the start and end points of each segment (curves or straight lines)</span></p>
<p><span class="koboSpan" id="kobo.363.1">Traditional SDF algorithms encode the distance from a pixel to the glyph’s boundary for each pixel in a grid, store that information in a texture, and upload that to the CPU. </span><span class="koboSpan" id="kobo.363.2">The algorithm presented in this recipe implements a different approach, in which the distances from a pixel to the nearest curves are computed on the GPU. </span><span class="koboSpan" id="kobo.363.3">To do that, each glyph in the font</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.364.1"> is </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.365.1">preprocessed on the CPU against a grid of fixed size of 8 x 8 cells. </span><span class="koboSpan" id="kobo.365.2">This preprocessing detects curves that intersect each cell and stores the information in a 32-bit inte</span><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.366.1">ger, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.367.1">Figure 3</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.368.1">.5</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.370.1"><img alt="Figure 3.5 – Cell encoding stores the initial index of three separate curves that intersect the cell along with the length of each loop" src="image/B18491_03_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.371.1">Figure 3.5 – Cell encoding stores the initial index of three separate curves that intersect the cell along with the length of each loop</span></p>
<p><span class="koboSpan" id="kobo.372.1">Each cell contains the information of up to three loops that intersect it by storing the initial index of each loop plus their lengths. </span><span class="koboSpan" id="kobo.372.2">For example, the glyph shown in cell (2, 0) intersects two curves, curve 1 and curve 2. </span><span class="koboSpan" id="kobo.372.3">The information encoded for that cell would contain the index to curve 1 and a length of 2. </span><span class="koboSpan" id="kobo.372.4">The other indices would remain 0, as the cell doesn’t intersect any </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">other curves.</span></span></p>
<p><span class="koboSpan" id="kobo.374.1">The following diagram demonstrates how the letter </span><em class="italic"><span class="koboSpan" id="kobo.375.1">S</span></em><span class="koboSpan" id="kobo.376.1"> can be represented </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">using glyphs:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<span class="koboSpan" id="kobo.378.1"><img alt="Figure 3.6 – Curves representing an ﻿S glyph; cell (2, 0) intersects two curves: curve 1 and curve 2" src="image/B18491_03_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.379.1">Figure 3.6 – Curves representing an S glyph; cell (2, 0) intersects two curves: curve 1 and curve 2</span></p>
<p><span class="koboSpan" id="kobo.380.1">The vertex shader </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.381.1">passes</span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.382.1"> the cell indices for each corner of the rectangle to the fragment shader, which receives the interpolated coordinate of the cell, uses it to retrieve the information of which curve loops and their lengths to inspect, and calculates the minimum distance to each one of the curves in the three loops, choosing the </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">minimum distance.</span></span></p>
<p><span class="koboSpan" id="kobo.384.1">This information is then used to calculate the opacity of the current fragment, along with the color and the sharpness of the edge of </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">the font.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">In this recipe, we use a third-party library to capture the definition of the glyphs and store that information in a shader-friendly format. </span><span class="koboSpan" id="kobo.386.2">The library is authored by Dávid Kocsis and can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">here: </span></span><a href="https://github.com/kocsis1david/font-demo"><span class="No-Break"><span class="koboSpan" id="kobo.388.1">https://github.com/kocsis1david/font-demo</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.389.1">.</span></span></p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.390.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.391.1">Before diving into the recipe, you should make sure you have VS 2022 installed and that you are able to build the repo as per the steps provided in </span><a href="B18491_01.xhtml#_idTextAnchor019"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.392.1">Chapter 1</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.393.1">, Vulkan </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.394.1">Core Concepts.</span></em></span></p>
<p><span class="koboSpan" id="kobo.395.1">You should be </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.396.1">able</span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.397.1"> to launch the executable named </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">Chapter03_GPU_Text_SDF.exe</span></strong><span class="koboSpan" id="kobo.399.1"> from </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">VS 2022.</span></span></p>
<p><span class="koboSpan" id="kobo.401.1">A complete example with the code covered in this recipe can be found in the repository, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">chapter3/mainGPUTextSDF.cpp</span></strong><span class="koboSpan" id="kobo.403.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">chapter3/FontManager.hpp</span></strong><span class="koboSpan" id="kobo.405.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">chapter3/FontManager.cpp</span></strong><span class="koboSpan" id="kobo.407.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">chapter3/resources/shaders</span></strong><span class="koboSpan" id="kobo.409.1">, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">font.frag</span></strong><span class="koboSpan" id="kobo.411.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">font.vert</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.413.1"> files.</span></span></p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.414.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.415.1">The steps to render text using SDFs on the device are </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.417.1">The initial task involves loading the font file through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">FreeType</span></strong><span class="koboSpan" id="kobo.419.1"> library. </span><span class="koboSpan" id="kobo.419.2">This step is crucial because it’s where we obtain the glyph data for each character. </span><span class="koboSpan" id="kobo.419.3">Glyph data, in essence, represents the basic design of a character in a font, describing its unique shape and appearance. </span><span class="koboSpan" id="kobo.419.4">Once we have this, the subsequent objective is to transform this glyph data into outline data. </span><span class="koboSpan" id="kobo.419.5">The outline data captures the essence of the glyph’s shape, breaking it down into components such as points, cells, and a bounding box specific to each character. </span><span class="koboSpan" id="kobo.419.6">These components essentially dictate how a character will be rendered on a screen or display. </span><span class="koboSpan" id="kobo.419.7">To achieve this transformation from </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">FreeType</span></strong><span class="koboSpan" id="kobo.421.1">’s intricate glyph data to more structured outline data, we employ the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">fd_outline_convert</span></strong><span class="koboSpan" id="kobo.423.1"> function. </span><span class="koboSpan" id="kobo.423.2">The data for each character is combined into a single stream of points and cells that is </span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.424.1">uploaded</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.425.1"> to the GPU as a </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.426.1">vertex buffer</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.428.1">
FontManager fontManager;
const auto &amp;glyphData = fontManager.loadFont(
    (fontsFolder / "times.ttf").string());
std::vector&lt;GlyphInfo&gt; glyhInfoData;
std::vector&lt;uint32_t&gt; cellsData;
std::vector&lt;glm::vec2&gt; pointsData;
uint32_t pointOffset = 0;
uint32_t cellOffset = 0;
for (const auto &amp;glyph : glyphData) {
  glyhInfoData.push_back(
      {glyph.bbox,
       glm::uvec4(pointOffset, cellOffset,
                  glyph.cellX,
                  glyph.cellY)});
  cellsData.insert(cellsData.end(),
                   glyph.cellData.begin(),
                   glyph.cellData.end());
  pointsData.insert(pointsData.end(),
                    glyph.points.begin(),
                    glyph.points.end());
  pointOffset += glyph.points.size();
  cellOffset += glyph.cellData.size();
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.429.1">The code delves deeply into font rendering by handling the glyphs, which are the backbone of font representation. </span><span class="koboSpan" id="kobo.429.2">One of the main elements here is the point data. </span><span class="koboSpan" id="kobo.429.3">This crucial piece captures every point that makes up the Bézier curves of each glyph. </span><span class="koboSpan" id="kobo.429.4">Right now, our focus is mainly on the uppercase letters. </span><span class="koboSpan" id="kobo.429.5">But looking at how the code is structured, it’s clear that we could easily expand it to embrace other characters if we wished to. </span><span class="koboSpan" id="kobo.429.6">Parallel to the point data, we also work with the cell data. </span><span class="koboSpan" id="kobo.429.7">It has a special role when we’re in the rendering phase, especially in the fragment shader. </span><span class="koboSpan" id="kobo.429.8">It’s this data that aids in navigating the curves that intersect with a given cell, making sure that every glyph is depicted accurately and precisely on the screen. </span><span class="koboSpan" id="kobo.429.9">All in all, by marrying the point and cell data with the capabilities of the fragment shader, we’re able to render the font’s visual </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">intricacies effectively.</span></span></p></li> <li><span class="koboSpan" id="kobo.431.1">Next, we build a </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.432.1">buffer </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.433.1">that contains the bounding rectangles of each glyph. </span><span class="koboSpan" id="kobo.433.2">This buffer serves as the vertex buffer, and we draw as many instances as the number of characters in the </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">display string:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.435.1">
std::string textToDisplay = "GPUSDFTEXTDEMO";
std::vector&lt;CharInstance&gt;
    charsData(textToDisplay.length());
int startX =
    context.swapchain()-&gt;extent().width / 6.0f;
int startY =
    context.swapchain()-&gt;extent().height / 2.0f;
const float scale = 0.09f;
for (int i = 0; i &lt; textToDisplay.length();
     ++i) {
  int glpyIndex = textToDisplay[i] - 'A';
  charsData[i].glyphIndex = glpyIndex;
  charsData[i].sharpness = scale;
  charsData[i].bbox.x =
      (startX +
       glyphData[glpyIndex].bbox.x * scale) /
          (context.swapchain()
               -&gt;extent()
               .width /
           2.0) -
      1.0;
  charsData[i].bbox.y =
      (startY -
       glyphData[glpyIndex].bbox.y * scale) /
          (context.swapchain()
               -&gt;extent()
               .height /
           2.0) -
      1.0;
  charsData[i].bbox.z =
      (startX +
       glyphData[glpyIndex].bbox.z * scale) /
          (context.swapchain()
               -&gt;extent()
               .width /
           2.0) -
      1.0;
  charsData[i].bbox.w =
      (startY -
       glyphData[glpyIndex].bbox.w * scale) /
          (context.swapchain()
               -&gt;extent()
               .height /
           2.0) -
      1.0;
  startX += glyphData[glpyIndex]
                .horizontalAdvance *
            scale;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.436.1">The code snippet is dedicated to rendering the phrase </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">"GPUSDFTEXTDEMO"</span></strong><span class="koboSpan" id="kobo.438.1"> onscreen. </span><span class="koboSpan" id="kobo.438.2">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">textToDisplay</span></strong><span class="koboSpan" id="kobo.440.1"> holds the desired text, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">charsData</span></strong><span class="koboSpan" id="kobo.442.1"> is primed to store individual character details. </span><span class="koboSpan" id="kobo.442.2">The starting position, calculated from the</span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.443.1"> screen</span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.444.1"> dimensions, suggests a slightly offset start from the left and a vertical centering of the text. </span><span class="koboSpan" id="kobo.444.2">A scaling factor shrinks the characters, likely aiding design or screen fit. </span><span class="koboSpan" id="kobo.444.3">As we progress character by character, a mapping correlates each letter to its respective data in </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">glyphData</span></strong><span class="koboSpan" id="kobo.446.1">. </span><span class="koboSpan" id="kobo.446.2">The bounding box coordinates for every character are meticulously scaled and normalized to ensure their optimal display on screen. </span><span class="koboSpan" id="kobo.446.3">To sidestep overlap, the horizontal placement (</span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">startX</span></strong><span class="koboSpan" id="kobo.448.1">) gets an update for each character, relying on its width and the scaling factor. </span><span class="koboSpan" id="kobo.448.2">In sum, this snippet efficiently prepares the specifics for a neatly rendered, scaled, and centered display of </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">"GPUSDFTEXTDEMO"</span></strong><span class="koboSpan" id="kobo.450.1"> on </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">the screen.</span></span></p></li> <li><span class="koboSpan" id="kobo.452.1">In the following step, we transfer the points, cell data, glyph data, and string to the GPU as separate buffers. </span><span class="koboSpan" id="kobo.452.2">Subsequently, we execute a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">vkCmdDraw</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.454.1"> command:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.455.1">
// 4 vertex (Quad) and x (charData) instances
vkCmdDraw(commandBuffer, 4, charsData.size(), 0, 0);</span></pre></li> <li><span class="koboSpan" id="kobo.456.1">The vertex</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.457.1"> shader </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.458.1">needs access to an array of glyph data (</span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">GlyphInfo</span></strong><span class="koboSpan" id="kobo.460.1">) that is packed into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">glyph_buffer</span></strong><span class="koboSpan" id="kobo.462.1"> buffer. </span><span class="koboSpan" id="kobo.462.2">The other inputs are </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">in_rect</span></strong><span class="koboSpan" id="kobo.464.1">,</span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1"> in_glyph_index</span></strong><span class="koboSpan" id="kobo.466.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">in_sharpness</span></strong><span class="koboSpan" id="kobo.468.1">, which come from the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.469.1">vertex buffer</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.471.1">
#version 460
// Stores glyph information
struct GlyphInfo {
  vec4 bbox; // Bounding box of the glyph
  // cell_info.x: point offset
  // cell_info.x: cell offset
  // cell_info.x: cell count in x
  // cell_info.x: cell count in y
  uvec4 cell_info;
};
// Storage buffer object for glyphs
layout(set = 0, binding = 0) buffer GlyphBuffer {
  GlyphInfo glyphs[];
} glyph_buffer;
layout(location = 0) in vec4 in_rect;
layout(location = 1) in uint in_glyph_index;
layout(location = 2) in float in_sharpness;
layout(location = 0) out vec2 out_glyph_pos;
layout(location = 1) out uvec4 out_cell_info;
layout(location = 2) out float out_sharpness;
layout(location = 3) out vec2 out_cell_coord;
void main() {
  // Get the glyph information
  GlyphInfo gi = glyph_buffer.glyphs[in_glyph_index];
  // Corners of the rectangle
  vec2 pos[4] = vec2[](
      vec2(in_rect.x, in_rect.y), // Bottom-left
      vec2(in_rect.z, in_rect.y), // Bottom-right
      vec2(in_rect.x, in_rect.w), // Top-left
      vec2(in_rect.z, in_rect.w) // Top-right
  );
  // Corners of the glyph
  vec2 glyph_pos[4] = vec2[](
      vec2(gi.bbox.x, gi.bbox.y), // Bottom-left
      vec2(gi.bbox.z, gi.bbox.y), // Bottom-right
      vec2(gi.bbox.x, gi.bbox.w), // Top-left
      vec2(gi.bbox.z, gi.bbox.w) // Top-right
  );
  // Cell coordinates
  vec2 cell_coord[4] = vec2[](
      vec2(0, 0), // Bottom-left
      vec2(gi.cell_info.z, 0), // Bottom-right
      vec2(0, gi.cell_info.w), // Top-left
      vec2(gi.cell_info.z,
           gi.cell_info.w) // Top-right
  );
  gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);
  out_glyph_pos = glyph_pos[gl_VertexIndex];
  out_cell_info = gi.cell_info;
  out_sharpness = in_sharpness;
  out_cell_coord = cell_coord[gl_VertexIndex];
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.472.1">The preceding </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.473.1">vertex</span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.474.1"> shader is tailored for glyph rendering. </span><span class="koboSpan" id="kobo.474.2">The shader works with a structure named </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">GlyphInfo</span></strong><span class="koboSpan" id="kobo.476.1"> that encapsulates information about each glyph, including its bounding box and details related to the cell positioning of the glyph. </span><span class="koboSpan" id="kobo.476.2">Within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">main</span></strong><span class="koboSpan" id="kobo.478.1"> function, the shader fetches data for a specific glyph using an input index. </span><span class="koboSpan" id="kobo.478.2">It subsequently determines the positions of both the input rectangle’s corners and the corresponding glyph’s bounding box and calculates the cell coordinates for the glyph. </span><span class="koboSpan" id="kobo.478.3">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">gl_VertexIndex</span></strong><span class="koboSpan" id="kobo.480.1">, which indicates which vertex of the rectangle is currently being processed, the shader sets the position for that vertex and assigns necessary values to the output variables. </span><span class="koboSpan" id="kobo.480.2">This preprocessed information is leveraged by the fragment shader to produce a final visual representation of </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">the glyph.</span></span></p></li> <li><span class="koboSpan" id="kobo.482.1">Next are the steps for calculating the text’s glyph color using the </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">fragment shader:</span></span><ul><li><span class="koboSpan" id="kobo.484.1">Calculates the cell index for a </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">given fragment/pixel.</span></span></li><li><span class="koboSpan" id="kobo.486.1">Fetches the cell from the cell buffer based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">cell index.</span></span></li><li><span class="koboSpan" id="kobo.488.1">Calculates</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.489.1"> the </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.490.1">SDF of the cell from the glyph’s bounding box. </span><span class="koboSpan" id="kobo.490.2">Based on the distance, an alpha value </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">is computed:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.492.1">
// Main function of the fragment shader
void main() {
  // Calculate the cell index
  uvec2 c = min(uvec2(in_cell_coord),
                in_cell_info.zw - 1);
  uint cell_index = in_cell_info.y +
                    in_cell_info.z * c.y + c.x;
  // Get the cell
  uint cell = cell_buffer.cells[cell_index];
  // Calculate the signed distance from the
  // glyph position to the cell
  float v = cell_signed_dist(
      in_cell_info.x, cell, in_glyph_pos);
  // Calculate the alpha value
  float alpha = clamp(v * in_sharpness + 0.5,
                      0.0, 1.0);
  out_color = vec4(1.0, 1.0, 1.0, alpha);
}</span></pre></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.493.1">The resul</span><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.494.1">t of the recipe can be seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.495.1">Figure 3</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.496.1">.7</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.498.1"><img alt="Figure 3.7 – The output of the recipe" src="image/B18491_03_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.499.1">Figure 3.7 – The output of the recipe</span></p>
<p><span class="koboSpan" id="kobo.500.1">In this recipe, we</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.501.1"> showcased </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.502.1">the application of SDF for rendering text with the assistance of </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">a GPU.</span></span></p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.504.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.505.1">Inigo Quilez demonstrates how to use SDFs to create shapes in an </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">excellent video:</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.507.1">https://www.youtube.com/watch?v=8--5LwHRhjk</span></span></p>
<p><span class="koboSpan" id="kobo.508.1">There are multiple libraries that generate SDF textures – for example, </span><a href="https://libgdx.com/wiki/tools/hiero"><span class="koboSpan" id="kobo.509.1">https://libgdx.com/wiki/tools/hiero</span></a> <span class="No-Break"><span class="koboSpan" id="kobo.510.1">and </span></span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">https://github.com/Chlumsky/msdfgen</span></span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">.</span></span></p>
<h1 id="_idParaDest-201"><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.513.1">Frustum culling using compute shaders</span></h1>
<p><span class="koboSpan" id="kobo.514.1">In this recipe, we </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.515.1">will show how to do frustum culling</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.516.1"> using the GPU and </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">compute shaders.</span></span></p>
<p><span class="koboSpan" id="kobo.518.1">In the world of real-time rendering, efficient rendering is key to achieving smooth performance and high-quality visuals. </span><span class="koboSpan" id="kobo.518.2">One of the most widely used techniques to optimize rendering is frustum culling. </span><span class="koboSpan" id="kobo.518.3">Frustum culling is a process that improves rendering speed by ignoring or </span><em class="italic"><span class="koboSpan" id="kobo.519.1">culling</span></em><span class="koboSpan" id="kobo.520.1"> objects that are not visible within the camera’s FOV, or </span><em class="italic"><span class="koboSpan" id="kobo.521.1">frustum</span></em><span class="koboSpan" id="kobo.522.1">. </span><span class="koboSpan" id="kobo.522.2">The following diagram demonstrates </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">it visually:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.524.1"><img alt="Figure 3.8 – Frustum culling works by ignoring objects that fall outside of the camera’s view (the frustum)" src="image/B18491_03_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.525.1">Figure 3.8 – Frustum culling works by ignoring objects that fall outside of the camera’s view (the frustum)</span></p>
<p><span class="koboSpan" id="kobo.526.1">Frustum culling works by testing each object in the scene to see if it lies within the camera’s frustum. </span><span class="koboSpan" id="kobo.526.2">If an object is entirely outside the frustum, it gets culled; that is, it’s not drawn. </span><span class="koboSpan" id="kobo.526.3">This can significantly reduce the number of primitives that need to be drawn. </span><span class="koboSpan" id="kobo.526.4">Traditionally, culling was done on the CPU, but this meant it needed to be done every time the camera moved. </span><span class="koboSpan" id="kobo.526.5">We demonstrate culling by using the compute shader, eliminating the need to upload data from the CPU to the GPU every time the view changes. </span><span class="koboSpan" id="kobo.526.6">Compute shaders do not necessarily need to be related to rendering and can process data structures and perform operations such as sorting, physics simulations, and, in our case, </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">frustum culling.</span></span></p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.528.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.529.1">Before diving into the recipe, you should make sure you have VS 2022 installed and that you are able to build the repository as per the steps provided in </span><a href="B18491_01.xhtml#_idTextAnchor019"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.530.1">Chapter 1</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.531.1">, Vulkan </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.532.1">Core Concepts.</span></em></span></p>
<p><span class="koboSpan" id="kobo.533.1">You should be able to launch the executable named </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">Chapter03_GPU_Culling.exe</span></strong><span class="koboSpan" id="kobo.535.1"> from </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">VS 2022.</span></span></p>
<p><span class="koboSpan" id="kobo.537.1">This recipe is </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.538.1">based </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.539.1">on the </span><em class="italic"><span class="koboSpan" id="kobo.540.1">Implementing Programmable Vertex Pulling and Multi-Draw Indirect</span></em><span class="koboSpan" id="kobo.541.1"> recipe from </span><a href="B18491_02.xhtml#_idTextAnchor126"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.542.1">Chapter 2</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.543.1">, Working with Modern Vulkan.</span></em><span class="koboSpan" id="kobo.544.1"> The code covered in this recipe can be found in the repository, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">chapter3/mainCullingCompute.cpp</span></strong><span class="koboSpan" id="kobo.546.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">chapter3/CullingComputePass.cpp</span></strong><span class="koboSpan" id="kobo.548.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">chapter3/resources/shaders</span></strong><span class="koboSpan" id="kobo.550.1">, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">gpuculling.comp</span></strong><span class="koboSpan" id="kobo.552.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">indirectdraw.frag</span></strong><span class="koboSpan" id="kobo.554.1">, and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">indirectdraw.vert</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.556.1"> files.</span></span></p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.557.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.558.1">We will be building on a recipe from </span><a href="B18491_02.xhtml#_idTextAnchor126"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.559.1">Chapter 2</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.560.1">, Working with Modern Vulkan.</span></em><span class="koboSpan" id="kobo.561.1"> that implemented Multi-Draw Indirect. </span><span class="koboSpan" id="kobo.561.2">We demonstrated during that recipe the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">vkCmdDrawIndexedIndirect</span></strong><span class="koboSpan" id="kobo.563.1">. </span><span class="koboSpan" id="kobo.563.2">In this recipe, we will use a command that derives the number of its parameters from a device buffer, </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">vkCmdDrawIndexedIndirectCount</span></strong><span class="koboSpan" id="kobo.565.1">. </span><span class="koboSpan" id="kobo.565.2">This Vulkan API lets you specify a GPU buffer that contains the draw count instead of providing it by </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">the CPU.</span></span></p>
<p><span class="koboSpan" id="kobo.567.1">This recipe’s technique relies on three buffers: the first two each contain the indirect draw parameters’ structures, </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">InputIndirectDraws</span></strong><span class="koboSpan" id="kobo.569.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">OutputIndirectDraws</span></strong><span class="koboSpan" id="kobo.571.1"> respectively; the third one contains the number of meshes to be rendered. </span><span class="koboSpan" id="kobo.571.2">The first buffer contains the parameters for all meshes in the scene. </span><span class="koboSpan" id="kobo.571.3">The second buffer is populated by the compute shader: meshes that are </span><em class="italic"><span class="koboSpan" id="kobo.572.1">not</span></em><span class="koboSpan" id="kobo.573.1"> culled have their indirect parameters atomically copied from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">InputIndirectDraws</span></strong><span class="koboSpan" id="kobo.575.1"> buffer to </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">OutputIndirectDraws</span></strong><span class="koboSpan" id="kobo.577.1">; meshes tha</span><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.578.1">t are culled don’t have their </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">parameters copied:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.580.1"><img alt="Figure 3.9 – Top buffer: all mesh parameters; bottom buffer: unculled meshes set to render" src="image/B18491_03_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.581.1">Figure 3.9 – Top buffer: all mesh parameters; bottom buffer: unculled meshes set to render</span></p>
<p><span class="koboSpan" id="kobo.582.1">Additionally, the compute shader needs information about each mesh’s bounding box and their center, and the six planes of the frustum. </span><span class="koboSpan" id="kobo.582.2">With this information, the compute pass can cull (or not) each mesh. </span><span class="koboSpan" id="kobo.582.3">At the end of the pass, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">OutputIndirectDraws</span></strong><span class="koboSpan" id="kobo.584.1"> buffer contains parameters only for the meshes that will be rendered and is used by the indirect </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">draw command.</span></span></p>
<p><span class="koboSpan" id="kobo.586.1">Next is the recipe broken down into steps, along with snippets from </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">mainCullingCompute.cpp</span></strong><span class="koboSpan" id="kobo.588.1">. </span><span class="koboSpan" id="kobo.588.2">It provides a high-level view of how culling and drawing passes are used in tandem to perform frustum culling using compute shaders in Vulkan. </span><span class="koboSpan" id="kobo.588.3">The </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.589.1">compute shade</span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.590.1">r takes care of determining which meshes should be drawn, and then the graphics pipeline takes care of drawing </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">those meshes.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.592.1">Initialize the culling pass by using scene information and a </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">scene buffer:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.594.1">
cullingPass.init(&amp;context, &amp;camera,
                 *bistro.get(), buffers[3]);
cullingPass.upload(commandMgr);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.595.1">The first step consists of initializing the two buffers shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.596.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.597.1">.9</span></em><span class="koboSpan" id="kobo.598.1"> and uploading them to the device. </span><span class="koboSpan" id="kobo.598.2">The details are encapsulated by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">CullingComputePass</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.600.1"> class.</span></span></p></li> <li><span class="koboSpan" id="kobo.601.1">The compute pass is also encapsulated by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">CullingComputePass</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.603.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.604.1">
auto commandBuffer = commandMgr.getCmdBufferToBegin();
cullingPass.cull(commandBuffer, index);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.605.1">We will discuss the cull method shown next in </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">more detail.</span></span></p></li> <li><span class="koboSpan" id="kobo.607.1">To prevent a race condition between the compute pass and the rendering pass, we add a barrier for the culled indirect draw and the draw count buffer. </span><span class="koboSpan" id="kobo.607.2">This is necessary because the subsequent drawing commands rely on the results of the </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">culling pass:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.609.1">
cullingPass.addBarrierForCulledBuffers(
    commandBuffer,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
    context.physicalDevice()
        .graphicsFamilyIndex()
        .value(),
    context.physicalDevice()
        .graphicsFamilyIndex()
        .value());</span></pre></li> <li><span class="koboSpan" id="kobo.610.1">The draw call</span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.611.1"> is </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.612.1">recorded with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">vkCmdDrawIndexedIndirectCount</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.614.1"> command:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.615.1">
vkCmdDrawIndexedIndirectCount(
    commandBuffer,
    cullingPass.culledIndirectDrawBuffer()
        -&gt;vkBuffer(),
    0,
    cullingPass
        .culledIndirectDrawCountBuffer()
        -&gt;vkBuffer(),
    0, numMeshes,
    sizeof(
        EngineCore::
            IndirectDrawCommandAndMeshData));</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.616.1">Having grasped the essential elements of code for the culling pass, let’s delve into its </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">operational mechanism.</span></span></p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.618.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.619.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">CullingComputePass::cull</span></strong><span class="koboSpan" id="kobo.621.1"> method is responsible for updating frustum data, binding the compute pipeline, updating push constants, and calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">vkCmdDispatch</span></strong><span class="koboSpan" id="kobo.623.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">vkCmdDispatch</span></strong><span class="koboSpan" id="kobo.625.1"> dispatches the compute work to the GPU. </span><span class="koboSpan" id="kobo.625.2">The compute work is divided into smaller units, each of which is called a workgroup. </span><span class="koboSpan" id="kobo.625.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">(pushConst.drawCount / 256) + 1, 1, 1)</span></strong><span class="koboSpan" id="kobo.627.1"> parameters specify the number of workgroups that</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.628.1"> are </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.629.1">dispatched in the </span><em class="italic"><span class="koboSpan" id="kobo.630.1">x</span></em><span class="koboSpan" id="kobo.631.1">, </span><em class="italic"><span class="koboSpan" id="kobo.632.1">y</span></em><span class="koboSpan" id="kobo.633.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.634.1">z</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.635.1">dimensions, respectively:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.636.1">
void CullingComputePass::cull(
    VkCommandBuffer cmd, int frameIndex) {
  GPUCullingPassPushConstants pushConst{
      .drawCount =
          uint32_t(meshesBBoxData_.size()),
  };
  // Compute and store the six planes of the frustum
  for (int i = 0;
       auto &amp;plane :
       camera_-&gt;calculateFrustumPlanes()) {
    frustum_.frustumPlanes[i] = plane;
    ++i;
  }
  // Upload the data to the device
  camFrustumBuffer_-&gt;buffer()
      -&gt;copyDataToBuffer(&amp;frustum_,
                         sizeof(ViewBuffer));
  // Bind the compute pipeline, update push constants
  pipeline_-&gt;bind(cmd);
  pipeline_-&gt;updatePushConstant(
      cmd, VK_SHADER_STAGE_COMPUTE_BIT,
      sizeof(GPUCullingPassPushConstants),
      &amp;pushConst);
  // Bind descriptor sets
  pipeline_-&gt;bindDescriptorSets(
      cmd,
      {
          {.set = MESH_BBOX_SET,
           .bindIdx = 0},
          {.set = INPUT_INDIRECT_BUFFER_SET,
           .bindIdx = 0},
          {.set = OUTPUT_INDIRECT_BUFFER_SET,
           .bindIdx = 0},
          {.set =
               OUTPUT_INDIRECT_COUNT_BUFFER_SET,
           .bindIdx = 0},
          {.set = CAMERA_FRUSTUM_SET,
           .bindIdx = uint32_t(frameIndex)},
      });
  // Update descriptor sets
  pipeline_-&gt;updateDescriptorSets();
  // Dispatch the compute pass
  vkCmdDispatch(
      cmd, (pushConst.drawCount / 256) + 1, 1, 1);
}</span></pre> <p><span class="koboSpan" id="kobo.637.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">CullingComputePass::addBarrierForCulledBuffers</span></strong><span class="koboSpan" id="kobo.639.1"> method adds a pipeline barrier that ensures the culling operation has finished before the results are read. </span><span class="koboSpan" id="kobo.639.2">The barrier is </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.640.1">set </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.641.1">up so that it blocks the indirect command read access (which will be used in the draw call) until the shader write (the culling operation) </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">has completed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.643.1">
void CullingComputePass::
    addBarrierForCulledBuffers(
        VkCommandBuffer cmd,
        VkPipelineStageFlags dstStage,
        uint32_t computeFamilyIndex,
        uint32_t graphicsFamilyIndex) {
  std::array&lt;VkBufferMemoryBarrier, 2&gt; barriers{
      VkBufferMemoryBarrier{
          .sType =
              VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
          .srcAccessMask =
              VK_ACCESS_SHADER_WRITE_BIT,
          .dstAccessMask =
              VK_ACCESS_INDIRECT_COMMAND_READ_BIT,
          .srcQueueFamilyIndex =
              computeFamilyIndex,
          .dstQueueFamilyIndex =
              graphicsFamilyIndex,
          .buffer = outputIndirectDrawBuffer_
                        -&gt;vkBuffer(),
          .size = outputIndirectDrawBuffer_
                      -&gt;size(),
      },
      VkBufferMemoryBarrier{
          .sType =
              VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER,
          .srcAccessMask =
              VK_ACCESS_SHADER_WRITE_BIT,
          .dstAccessMask =
              VK_ACCESS_INDIRECT_COMMAND_READ_BIT,
          .srcQueueFamilyIndex =
              computeFamilyIndex,
          .dstQueueFamilyIndex =
              graphicsFamilyIndex,
          .buffer =
              outputIndirectDrawCountBuffer_
                  -&gt;vkBuffer(),
          .size =
              outputIndirectDrawCountBuffer_
                  -&gt;size(),
      },
  };
  vkCmdPipelineBarrier(
      cmd,
      VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
      dstStage, 0, 0, nullptr,
      (uint32_t)barriers.size(),
      barriers.data(), 0, nullptr);
}</span></pre> <p><span class="koboSpan" id="kobo.644.1">In the compute shader, we need a function that tells whether a bounding box falls completely outside of </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.645.1">the</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.646.1"> frustum by comparing its extents and its center point against the six planes of </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">the frustum:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.648.1">
void cullMesh(uint id) {
  MeshBboxData meshBBoxData = meshBboxDatas[id];
  bool isVisible = true;
  for (int i = 0; i &lt; 6 &amp;&amp; isVisible; i++) {
    vec3 planeNormal =
        viewData.frustumPlanes[i].xyz;
    float distFromPlane = dot(
        meshBBoxData.centerPos.xyz, planeNormal);
    float absDiff = dot(abs(planeNormal),
                        meshBBoxData.extents.xyz);
    if (distFromPlane + absDiff +
            viewData.frustumPlanes[i].w &lt; 0.0) {
      isVisible = false;
    }
  }
  if (isVisible) {
    uint index = atomicAdd(outDrawCount.count, 1);
    outputIndirectDraws[index] = inputIndirectDraws[id];
  }
}</span></pre> <p><span class="koboSpan" id="kobo.649.1">If the mesh is culled, the function returns early. </span><span class="koboSpan" id="kobo.649.2">Otherwise, it atomically increments the number of visible meshes in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">IndirectDrawCount</span></strong><span class="koboSpan" id="kobo.651.1"> buffer and copies the indirect draw parameters from the input to the output buffer using the previous number of meshes in the buffer </span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.652.1">as </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.653.1">the index of </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">the destination.</span></span></p>
<p><span class="koboSpan" id="kobo.655.1">The only remaining work for the main function is to </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">cullMesh</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.659.1">
layout(local_size_x = 256, local_size_y = 1,
       local_size_z = 1) in;
void main() {
  uint currentThreadId = gl_GlobalInvocationID.x;
  if (currentThreadId == 0) {
    atomicExchange(outDrawCount.count, 0);
  }
  barrier();
  if (currentThreadId &lt; cullData.count) {
    cullMesh(currentThreadId);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.660.1">Through this recipe, we’ve harnessed the power of the GPU to effectively filter out non-essential objects, optimizing</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.661.1"> our rendering workflow. </span><span class="koboSpan" id="kobo.661.2">By</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.662.1"> implementing this method, you will achieve a more responsive and resource-efficient visualization, especially vital for intricate </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">3D scenes.</span></span></p>
</div>
</body></html>