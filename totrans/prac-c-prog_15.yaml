- en: Improving the Performance of Your Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to speed up the execution of any C program.
    We will learn to keep the frequently used content in CPU registers, and we will
    learn how to take input faster from the user. We will also learn to apply loop
    unrolling in C programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the recipes we will work through in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `register` keyword in C code for better efficiency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking input faster in C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying loop unrolling for faster results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin with the first recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Using the register keyword in C code for better efficiency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The access time when using registers is quite a bit lower than that of accessing
    content from any memory variable. So, to take advantage of this, content that
    is frequently used in any program is kept in registers. The `register` keyword
    is used to indicate the content that needs to be kept in these registers.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will find out the cost of renting a car for a specified distance.
    The car rent not only depends on the distance but also on the type of car, that
    is, whether the car has **air conditioning** (**AC**) or not. The rent of the
    AC car per kilometer, the rent of the non-AC car per kilometer, and the service
    tax percentage values are all stored in register variables.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for finding total car rent for a specified distance with a specified
    car type using register variables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user is asked to enter the distance of the planned journey.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is asked to specify the type of the car, that is, whether the car should
    have AC or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two register variables are defined to indicate the rent per kilometer for the
    AC and non-AC car, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One more register variable is defined that is set to represent the service tax
    percentage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the basis of the type of the car chosen by the user, the distance value is
    multiplied by the respective register variable to find out the total amount.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service tax is computed and added to the total amount. The service tax percentage
    is accessed from the respective register variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The total rent of the car is displayed on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for computing the total rent of the car for the specified car type
    and journey length using the register variables is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The user is asked to specify how many kilometers the vehicle is required to
    be rented for. The value entered by the user is assigned to the `distance` variable.
    Thereafter, the user is asked to specify what kind of car they want to rent: an
    AC car or a non-AC car. The option entered by the user is assigned to the `car_type` variable. Three
    register variables are defined by the names `Acperkm`, `Nonacperkm`, and `servicetax`.'
  prefs: []
  type: TYPE_NORMAL
- en: Because the register variables stay closer to the CPU and their access time
    is very low when compared to accessing content from memory variables, the register
    variables are used for those values that are frequently required in computation.
    The three register variables, `Acperkm`, `Nonacperkm`, and `servicetax`, are initialized
    to 3, 2, and 1, respectively, to indicate that the rate for an AC car is $3 per
    kilometer and that of a non-AC car is $2 per kilometer. The service tax is assumed
    to be 1% of the total amount.
  prefs: []
  type: TYPE_NORMAL
- en: String comparison is done to know the type of car that is specified by the user.
    If the type of car selected is an AC car, the values in the `distance` variable
    and the `Acperkm` register variable are multiplied.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if the type of car selected is a non-AC car, the values in the `distance` and
    `Nonacperkm` variables are multiplied together. The result of the multiplication
    is the total amount to be assigned to the `carRent` variable. To this total amount,
    a 1% service tax rate is added to find out the total rent. The total rent of the
    car for the specified distance and type of car is then displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no errors appear on compilation, that means the `tourvehicle.c` program has successfully
    been compiled into an EXE file, `tourvehicle.exe`. On executing the file, the
    user is prompted to enter the number of kilometers for which the car is required
    on rent. The user will also be asked to specify the type of car that is required
    on rent. The program then displays the total rent of the car, as shown in the
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fb9c91b-a0a1-4c7a-83b8-95b09bb6454a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We have successfully used register variables to speed up processing in
    C. Now let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Taking input faster in C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn to take input faster from the user. We will ask
    the user to enter a number and the entered number will be displayed on the screen.
    We will make use of the `getchar_unlocked()` function for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The `getchar_unlocked()` function works similarly to `getchar()` function, with
    the difference that it is not thread-safe. As a result, it overlooks certain input
    constraints and so is quite a bit faster than `getchar()`. It is used for taking
    long input data in a situation where a single thread is being used for handling
    input and other streams.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for taking a number from the user using a faster input approach are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user is asked to enter a number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number that will be entered by the user is accepted by the `getchar_unlocked()`
    function. Only one digit at a time is accepted by this function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value entered by the user is first checked to ensure that it is a digit
    only. If it is not, the user is asked to re-enter the value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the value entered by the user is a digit, its ASCII value is saved in the
    variable. This is because `getchar_unlocked()` assigns the ASCII value of the
    entered value to the variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the ASCII of the entered value, 48 is subtracted to convert it into the
    actual digit that the user has entered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the digit is the first digit entered by the user, then it is simply assigned
    to another variable. But if it is not the first digit, then the existing digit
    in the variable is multiplied by 10 and the new digit is then added to the variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Steps 2* through *7* are repeated for every digit entered by the user until
    the user presses the *Enter* key.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number in the variable is the actual number entered by the user and, hence,
    is displayed on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for entering a number using a fast input technique is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The user is asked to enter a number. A user-defined `getdata()` function is invoked
    and the value returned by the function is assigned to the `numb` variable, which
    in return is then displayed on the screen. The `getdata` function will keep asking
    for the digits of the number and will return the number when the *Enter* key is
    pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that the user wants to enter `20`. Within the `getdata` function,
    the `getchar_unlocked()` function is invoked. So, on entering the first digit,
    2 (of the number 20), it will be assigned to the `cdigit` variable, which is of
    the character data type. The ASCII value of 2 is 50, so the value 50 is actually
    assigned to the `cdigit` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding further, we ensure that the value entered by the user is a
    digit, and not a character or some other symbol. If the user enters something
    other than a digit, the `getchar_unlocked()` function is again invoked, asking
    the user to enter a valid digit. If the value entered is a digit, then 48 is subtracted
    from its ASCII value to convert it to its actual value. This is because the ASCII
    value of 2 is 50; on subtracting 48 from 50, the result will be 2, which is the
    actual digit that was entered by the user. The value of 2 is assigned to the `cnumb`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Since the next digit of the number 20 is 0, the `getchar_unlocked ()` function
    is invoked and the value 0 is assigned to the `cdigit` variable. Again, it is
    checked that the value entered by the user is a digit and nothing else. The ASCII
    value of 0 is 48\. From the ASCII value of 0, the value 48 is subtracted to make
    its value 0\. The current value in `cnumb` is 2, which is then multiplied by 10
    and the value of `cdigit` is added to the result. The result of this computation
    will be 20 and it is assigned to the `cnumb` variable. The value in the `cnumb`
    variable is returned to the main function to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In short, whatever digit is entered by the user, its ASCII value is assigned
    to the variable and the numerical value 48 is subtracted from the ASCII value
    of the digit to convert it into the actual digit that was entered by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears on compilation, that means the `fastinp.c` program has successfully
    been compiled into an EXE file, `fastinp.exe`. On executing the file, the user
    is prompted to enter a number. The number is accepted using a fast input technique.
    After entering all the digits of the number, when the user presses the *Enter*
    key, the entered number is displayed on the screen as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fde6641-6ea1-4041-8752-3f6cd84bb150.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.2
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We have successfully configured faster input of numbers in C. Now let's
    move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Applying loop unrolling for faster results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn to print the sum of a sequence of numbers from
    1 to a limit entered by the user using the loop unrolling technique. Loop unrolling
    means reducing or removing the loops from the program to reduce overheads applied
    while running the loops. Basically, for running a loop, the operating system has
    to manage two overheads – the first overhead is to maintain the count of the loop
    and the second overhead is to do conditional branching. Loop unrolling helps in
    avoiding these two overheads. Let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for finding the sum of the first *n* sequence of numbers using the
    loop unrolling technique are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `sum` variable in which the addition of sequence numbers will be stored
    is initialized to 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is asked to enter the limit up to which the sum of the sequence of
    numbers is desired. The value entered by the user is assigned to the `limit` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to find the number between 9 to 1 that perfectly divides the value in
    the `limit` variable. To find this, we set a `for` loop to execute from 9 to 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `for` loop, the value in the `limit` variable is divided by the `for`
    loop variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the number in the `limit` variable is divisible by the `for` loop variable,
    the `for` loop will break.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the number in the `limit` variable is not divisible by the `for` loop variable,
    the next iteration of the loop is executed with a reduced value, that is, with
    the value of 8\. The steps are repeated until the value in the `limit` variable
    is perfectly divisible by the `for` loop variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we get the integer by which the limit is divisible, we reduce the number
    of `for` loops by that integer, that is, the increment of the `for` loop is set
    to that integer value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `for` loop, a `while` loop is used that adds the sequence of numbers
    into the `sum` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the addition of the sequence of numbers in the `sum` variable is displayed
    on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for printing the sum of a sequence of numbers using the loop unrolling
    technique is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This program finds the sum of sequence numbers from 1 up to the limit entered
    by the user. The user is asked to enter the limit, and the value entered by the
    user is assigned to the `limit` variable. For adding the sequence numbers, we
    will make use of a `for` loop. To do loop unrolling or to reduce the number of
    iterations of the loop, we find the integer by which the limit can be divided.
    That is, we divide the value in the `limit` variable by integers from 9 to 1\.
    Once we get the integer by which the limit is divisible, we reduce the number
    of `for` loops by that integer.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that the user enters a limit of 40, which is assigned to the `limit` variable. A
    `for` loop is set to run from the values 9 to 1, and every value from 9 to 1 will
    be used to try to divide the value in the `limit` variable. On any division, if
    the remainder appears as 0, the `for` loop will break; else, the next iteration
    will execute with the decreased value. Currently, the value in the `limit` variable
    is 40 and the value of `i` in the first iteration is 9\. The remainder of dividing
    40 by 9 is a non zero value, so the next iteration of the `for` loop will begin
    with the next decreased value, 8.
  prefs: []
  type: TYPE_NORMAL
- en: Because, on dividing 40 by 8, you get a remainder of 0, the `for` loop will
    break and the control will jump to the statement immediately after the `for` loop.
    The value of `i` at that time is 8, so the value of 8 is assigned to the `incr` variable. That
    is, the `for` loop will increment by a value of 8\. It also means that we are
    applying loop unrolling by reducing the iterations of the `for` loop by 8 times.
    In other words, the `for` loop will be set to run from 1 until the limit, which
    is 40, with an increment of 8 after every iteration.
  prefs: []
  type: TYPE_NORMAL
- en: In the first iteration, the value of `i` is 1\. The `sum` variable, in which
    the addition of the sequence of numbers will be computed, is initialized to 0\.
    The value of `i` is added to the `sum` variable. As said earlier, the next iteration
    of the `for` loop will increment the value of `i` by 8\. So, within the `for`
    loop, a `while` loop is used. Within the `while` loop, a variable, `x`, is used
    that executes from 0 to the value of the `incr` variable (that is, until the value
    of 8). In other words, the `while` loop will add the sequence of numbers from
    1 to 8 into the `sum` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sum of the first eight values of the sequence of numbers is computed
    and assigned to the `sum` variable, the next iteration of the `for` loop will
    begin with the value of `i` incremented to 9\. Again within the `for` loop, the
    `while` loop will execute to compute the sum of the sequence of numbers from 9
    to 16\. Again, the next iteration of the `for` loop will increase the value of
    `i` to 17\. The process continues until the `for` loop completes. In short, the
    `for` loop is unrolled to the value assigned to the `incr` variable. Finally,
    the sum of the sequence of numbers is displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears on compilation, that means the `loopunrolling.c` program has
    successfully been compiled into an EXE file, `loopunrolling.exe`. On executing
    the file, the user is prompted to enter the limit up to which the sum of the sequence
    of numbers is desired. The program will not only print the sum of the sequence
    of numbers but will also print how many loop iterations it took for the sum to
    be computed, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e620d676-79ab-408a-8c1e-b2142318be78.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.3
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We have successfully executed loop unrolling to generate a faster result.
  prefs: []
  type: TYPE_NORMAL
