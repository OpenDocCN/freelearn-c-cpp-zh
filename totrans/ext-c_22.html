<html><head></head><body>
		<div><h1 class="chapterNumber">Chapter 22</h1>
			<h1 id="_idParaDest-321" class="chapterTitle" lang="en-GB" xml:lang="en-GB">Unit Testing and Debuggin<a id="_idTextAnchor619"/>g</h1>
			<p class="normal">It doesn't really matter which programming language you are using or what type of application you are developing, it is always important to thoroughly test it before delivering it to the customer.</p>
			<p class="normal">Writing tests is not a new thing and as of today, you can find hundreds or even thousands of tests in almost every software project. Nowadays writing tests for software is a must and delivering a piece of code or feature without having it tested properly is strongly discouraged. That's why we have a dedicated chapter to talk about testing software written in C, and various libraries that exist today for this purpose.</p>
			<p class="normal"><a id="_idTextAnchor620"/>Testing is not the only topic in this chapter, however. We will also be discussing the debugging tools and techniques that can be used to troubleshoot a C program. Testing and debugging have complimented one another from the start, and whenever a test fails, a series of investigations are followed and debugging the target code is a common follow-up action.</p>
			<p class="normal">In this chapter, we won't go through the philosophy of testing and we assume that testing is good. Instead, we will give you a short introduction about the basic terminology and the guidelines that a developer should follow in order to write testable code.</p>
			<p class="normal">This chapter has two sections. In the first section, we talk about testing and the existing libraries that can be used in modern C development. The second section of this chapter is going to talk about debugging, starting with a discussion about various categories of bugs. Memory issues, concurrency issues, and performance issues are the most common cases in which further debugging seems to be necessary in order to establish a successful investigation.</p>
			<p class="normal">We will also cover the most used debugging tools available for C (and C++). The final goal of this chapter is to let you know about the testing and debugging utilities available for C and give you some basic background knowledge about them.</p>
			<p class="normal">The first section introduces you to the basic terminology of software testing in general. It is not specific to C, and the ideas and concepts can be applied to other programming languages and technologies as well.</p>
			<h1 id="_idParaDest-322" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor621"/>Software testing</h1>
			<p class="normal">Software testing is a big and important subject in computer programming, and it has its own specific terminology and <a id="_idIndexMarker1618"/>many concepts. In this section, we are going to give you a very basic introduction to software testing. Our purpose is to define some terms that we are going to use in the first half of this chapter. Therefore, you should be aware that this is not a thorough chapter about testing and further study is strongly encouraged.</p>
			<p class="normal">When it comes to testing software, the first question that comes to mind is, what are we testing, and what is this testing about? In general, we test an aspect of a software system. This aspect can be <em class="italics">functional</em> or <em class="italics">non-functional</em>. In other words, the aspect may be related to a certain functionality of the system, or it can be related to a certain variable of a system when performing a functionality. Next, we give some examples.</p>
			<p class="normal"><em class="italics">Functional testing</em> is about testing a defined functionality requested as part of the <em class="italics">functional requirements</em>. These tests provide a certain input to a <em class="italics">software element</em> such as a <em class="italics">function</em>, a <em class="italics">module</em>, a <em class="italics">component</em>, or a <em class="italics">software system</em>, and expect a certain output from them. Only if the expected output is seen as part of a test is that test considered as <em class="italics">passed</em>.</p>
			<p class="normal"><em class="italics">Non-functional testing</em> is about the <em class="italics">quality level</em> to which a software element, such as a function, a module, a component, or a software system as a whole, completes a specific functionality. These tests are usually supposed to <em class="italics">measure</em> various <em class="italics">variables</em> like <em class="italics">memory usage</em>, <em class="italics">time to completion</em>, <em class="italics">lock contention</em>, and <em class="italics">level of security</em>, and assess how well that element has done its job. A test is passed only when the measured variables are within the expected ranges. The <em class="italics">expectations</em> for these variables are derived from the <em class="italics">non-functional requirements</em> defined for the system.</p>
			<p class="normal">Apart from functional and non-functional testing, we can have different <em class="italics">levels</em> of testing. These levels are designed in a way to cover some orthogonal aspects. Some of these aspects are size of the tested element, the actor of the test, and the extent of the functionalities that should be tested.</p>
			<p class="normal">For instance, regarding the size of the element, these levels are defined from the smallest possible piece of functionality, which we know as a function (or a method), up to the biggest possible piece of functionality that it is exposed from a software system as a whole.</p>
			<p class="normal">In the following section, we <a id="_idIndexMarker1619"/>are going to introduce these levels in a deeper sense</p>
			<p class="normal">Testing levels</p>
			<p class="normal">For every software system, the <a id="_idIndexMarker1620"/>following levels of testing can be considered and planned. These are not the only existing testing levels and you can find more of them in other references:</p>
			<ul>
				<li class="list">Unit testing</li>
				<li class="list">Integration testing</li>
				<li class="list">System testing</li>
				<li class="list">Acceptance testing</li>
				<li class="list">Regression testing</li>
			</ul>
			<p class="normal">In <em class="italics">unit testing</em>, we test a <em class="italics">unit</em> of functionality. This unit can be a function that performs a certain job, or a group of functions together to satisfy a need, or a class that has a final goal to perform a certain functionality, or even a component that has a specific task to do. A <em class="italics">component</em> is a part of a software system that has a well-defined set of functionalities and, together with other components, joins and becomes the whole software system.</p>
			<p class="normal">In the case of having components as units, we call the testing process <em class="italics">component testing</em>. Both functional and non-functional testing can be done at the level of units. When testing a unit, that unit should become isolated from its surrounding units, and for this to happen, the surrounding environment should be simulated in some way. This level would be the only level that we cover as part of this chapter and we provide real code to demonstrate how unit testing and component testing can be done in C.</p>
			<p class="normal">When the units join together, they form a component. In component testing, a component is tested alone in isolation. But when we group some of these components, we need a different level of testing that checks the functionality or the variables for that specific group of components. This level is <em class="italics">integration testing</em>. As the name implies, the tests in this level check if the integration of some of the components works well and they together still satisfy the defined requirements for the system.</p>
			<p class="normal">At a different level, we test the functionality of the whole system. This will contain a complete set of all components fully integrated. This way, we test if the exposed system functionalities and system variables are in accordance with the requirements defined for the software system.</p>
			<p class="normal">On a different level, we evaluate a software system to check if it is in accordance with the business requirements defined for that system from the <em class="italics">stakeholder</em> or <em class="italics">end user</em> point of view. This level is called <em class="italics">acceptance testing</em>. While both system testing and acceptance testing is about the whole software system, they are actually quite different. To name a few differences:</p>
			<ul>
				<li class="list">System testing is done by developers and testers, but acceptance testing is usually done by the end user or the stakeholder.</li>
				<li class="list">System testing is about checking both functional and non-functional requirements, but acceptance testing is only about functional requirements.</li>
				<li class="list">In system <a id="_idIndexMarker1621"/>testing, we usually use a prepared small set of data as the input, but in acceptance testing, the actual real-time data is fed to the system.</li>
			</ul>
			<p class="normal">A great link that explains all the differences can be found <a href="https://www.javatpoint.com/acceptance-testing">at https://www.javatpoint.com/acceptance-tes</a>ting.</p>
			<p class="normal">When a change is introduced to a software system, it is required to check if the current functional and non-functional tests are still in a good shape. This is done at a different level known as <em class="italics">regression testing</em>. The purpose of regression testing is to confirm that there is no <em class="italics">regression</em> after introducing a change. As part of regression testing, all the functional and non-functional tests found as unit tests, integration tests, and end-to-end (system) tests are run again to see if any of them fail following a change.</p>
			<p class="normal">In this section, we introduced various levels of testing. For the rest of this chapter, we are going to discuss unit testing. In the upcoming section, we start talking about it by giving a C example and trying to write test cases for <a id="_idTextAnchor622"/><a id="_idTextAnchor623"/>it.</p>
			<h1 id="_idParaDest-323" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor624"/>Unit testing</h1>
			<p class="normal">As we explained in the previous section, as part of unit testing, we test isolated units and a unit can be as small<a id="_idIndexMarker1622"/> as a function or as big as a component. In C, it can be a function or a whole component written in C. The same discussion can be applied to C++ as well, but there we can have other units like classes.</p>
			<p class="normal">The most important thing about unit testing is that units should be tested in isolation. For example, if the target function depends on the output of another function, we need to find a way to test the target function in isolation. We are going to explain this using a real example.</p>
			<p class="normal"><em class="italics">Example 22.1</em> prints the factorials of even numbers less than 10, but not in the usual way. The code is well-organized in one header and two source files. The example is about two functions; one of them generates the even numbers less than 10 and the other function receives a function pointer and uses it as a source for reading an integer number, and finally <a id="_idIndexMarker1623"/>calculates its factorial.</p>
			<p class="normal">The following code box contains the header file containing the function declarations:</p>
			<pre>#ifndef _EXTREME_C_EXAMPLE_22_1_
#define _EXTREME_C_EXAMPLE_22_1_
#include &lt;stdint.h&gt;
#include &lt;unistd.h&gt;
typedef int64_t (*int64_feed_t)();
int64_t next_even_number();
int64_t calc_factorial(int64_feed_t feed);
#endif</pre>
			<p class="packt_figref">Code Box 22-1 [ExtremeC_examples_chapter22_1.h]: The header file of example 22.1</p>
			<p class="normal">As you can see, the function <code class="Code-In-Text--PACKT-">calc_factorial</code> accepts a function pointer that returns an integer. It will use the function pointer in order to read an integer and calculate its factorial. The following code is the definition of the preceding functions:</p>
			<pre>#include "ExtremeC_examples_chapter22_1.h"
int64_t next_even_number() {
  static int feed = -2;
  feed += 2;
  if (feed &gt;= 10) {
    feed = 0;
  }
  return feed;
}
int64_t calc_factorial(int64_feed_t feed) {
  int64_t fact = 1;
  int64_t number = feed();
  for (int64_t i = 1; i &lt;= number; i++) {
    fact *= i;
  }
  return fact;
}</pre>
			<p class="packt_figref">Code Box 22-2 [ExtremeC_examples_chapter22_1.c]: The definitions of the functions used in example 22.1</p>
			<p class="normal">The <code class="Code-In-Text--PACKT-">next_even_number</code> function has an internal static variable that acts as a feed for the caller function. Note that it never exceeds 8 and after that, it goes back to 0. Therefore, you can<a id="_idIndexMarker1624"/> simply call this function as many times as you like, and you never get a number greater than 8 and lower than zero. The following code box contains the content of the source file that contains the <code class="Code-In-Text--PACKT-">main</code> function:</p>
			<pre>#include &lt;stdio.h&gt;
#include "ExtremeC_examples_chapter22_1.h"
int main(int argc, char** argv) {
  for (size_t i = 1; i &lt;= 12; i++) {
    printf("%lu\n", calc_factorial(next_even_number));
  }
  return 0;
}</pre>
			<p class="packt_figref">Code Box 22-3 [ExtremeC_examples_chapter22_1_main.c]: The main function of example 22.1</p>
			<p class="normal">As you see, the <code class="Code-In-Text--PACKT-">main</code> function calls the <code class="Code-In-Text--PACKT-">calc_function</code> 12 times and prints the returned factorials. In order to run the preceding example, you need to compile both source files first and then link their corresponding relocatable object files together. The following shell box contains the required commands to build and run the example:</p>
			<pre><strong class="screen-text">$ gcc -c ExtremeC_examples_chapter22_1.c -o impl.o</strong>
<strong class="screen-text">$ gcc -c ExtremeC_examples_chapter22_1_main.c -o main.o</strong>
<strong class="screen-text">$ gcc impl.o main.o -o ex22_1.out</strong>
<strong class="screen-text">$ ./ex22_1.out</strong>
1
2
24
720
40320
1
2
24
720
40320
1
2
<strong class="screen-text">$</strong></pre>
			<p class="packt_figref">Shell Box 22-1: Building and running example 22.1</p>
			<p class="normal">In order to write tests for the preceding functions, we need to give a bit of introduction first. As you can see, we have two functions (not including the <code class="Code-In-Text--PACKT-">main</code> function) in the example. Therefore, there are two different units, in this case functions, that should be tested separately and in isolation from each other; one is the <code class="Code-In-Text--PACKT-">next_even_number</code> function and the other one is the <code class="Code-In-Text--PACKT-">calc_factorial</code> function. But as it is clear in the main function, the <code class="Code-In-Text--PACKT-">calc_factorial</code> function depends on the <code class="Code-In-Text--PACKT-">next_even_number</code> function and one might think that this dependency is going to make the isolation of the <code class="Code-In-Text--PACKT-">calc_factorial</code> function much harder than we anticipated. But this is not true.</p>
			<p class="normal">In fact, the <code class="Code-In-Text--PACKT-">calc_factorial</code> function does not depend on the <code class="Code-In-Text--PACKT-">next_even_number</code> function at all. It only depends on the <em class="italics">signature</em> of <code class="Code-In-Text--PACKT-">next_even_number</code> and not its definition. Therefore, it<a id="_idIndexMarker1625"/> is possible to replace <code class="Code-In-Text--PACKT-">next_even_number</code> with a function that follows the same signature, but always returns a fixed integer. In other words, we can provide a simplified version of <code class="Code-In-Text--PACKT-">next_even_number</code> that is intended to be used only in the <em class="italics">test cases</em>.</p>
			<p class="normal">So, what is a test case? As you know, there are various scenarios to test a specific unit. The simplest example is to provide various inputs to a certain unit and <em class="italics">expect</em> a predetermined output. In the preceding example, we can provide <code class="Code-In-Text--PACKT-">0</code> as the input for the <code class="Code-In-Text--PACKT-">calc_factorial</code> function and wait for <code class="Code-In-Text--PACKT-">1</code> as its output. We can also provide <code class="Code-In-Text--PACKT-">-1</code> and wait for <code class="Code-In-Text--PACKT-">1</code>.</p>
			<p class="normal">Every one of these scenarios can be a test case. Therefore, regarding a single unit, we can have multiple test cases addressing all different corner cases of that unit. A collection of test cases is called a <em class="italics">test suite</em>. All the test cases found in a test suite are not necessarily related to the same unit.</p>
			<p class="normal">We start by creating a test suite for the <code class="Code-In-Text--PACKT-">next_even_number</code> function. Since <code class="Code-In-Text--PACKT-">next_even_number</code> can be easily tested in isolation, there is no need for extra work. Following are the test cases written for the <code class="Code-In-Text--PACKT-">next_even_number</code> function:</p>
			<pre>#include &lt;assert.h&gt;
#include "ExtremeC_examples_chapter22_1.h"
void TESTCASE_next_even_number__even_numbers_should_be_returned() {
  assert(next_even_number() == 0);
  assert(next_even_number() == 2);
  assert(next_even_number() == 4);
  assert(next_even_number() == 6);
  assert(next_even_number() == 8);
}
void TESTCASE_next_even_number__numbers_should_rotate() {
  int64_t number = next_even_number();
  next_even_number();
  next_even_number();
  next_even_number();
  next_even_number();
  int64_t number2 = next_even_number();
  assert(number == number2);
}</pre>
			<p class="packt_figref">Code Box 22-4 [ExtremeC_examples_chapter22_1 __next_even_number__tests.c]: The test cases written for the next_even_number function</p>
			<p class="normal">As you see, we have defined two test cases in the preceding test suite. Note that I have used my own convention to give names to the above test cases; however, there is no standard regarding <a id="_idIndexMarker1626"/>this. The whole purpose of naming test cases is to realize what a test case does from its name and more important than that, to find it easily in the code when the test case fails or needs to be modified.</p>
			<p class="normal">I used the capital <code class="Code-In-Text--PACKT-">TESTCASE</code> as a prefix to function names to make them distinguished from other ordinary functions. The names of the functions also try to describe the test case and the concern it is addressing.</p>
			<p class="normal">Both test cases have <code class="Code-In-Text--PACKT-">assert</code> at the end. This is the thing that all test case functions do when evaluating the expectations. If the condition inside the parentheses of <code class="Code-In-Text--PACKT-">assert</code> is not true, the <em class="italics">test runner</em>, a program that is running the tests, quits and an error message is printed. More than that, the test runner returns a non-zero <em class="italics">exit code</em> that indicates one or more of the test cases have failed. The test runner program must return 0 when all tests have been successful.</p>
			<p class="normal">It would be nice to go through the test cases on your own and try to understand how they evaluate our expectations by calling the <code class="Code-In-Text--PACKT-">next_even_number</code> function in the preceding two scenarios.</p>
			<p class="normal">Now, it's time to write test cases for the <code class="Code-In-Text--PACKT-">calc_factorial</code> function. Writing test cases for the <code class="Code-In-Text--PACKT-">calc_factorial</code> function needs a <em class="italics">stub function</em> as its feed that returns the test input. We explain<a id="_idIndexMarker1627"/> what stubs are shortly.</p>
			<p class="normal">Following are three test cases that are only testing the <code class="Code-In-Text--PACKT-">calc_factorial</code> unit:</p>
			<pre>#include &lt;assert.h&gt;
#include "ExtremeC_examples_chapter22_1.h"
int64_t input_value = -1;
int64_t feed_stub() {
  return input_value;
}
void TESTCASE_calc_factorial__fact_of_zero_is_one() {
  input_value = 0;
  int64_t fact = calc_factorial(feed_stub);
  assert(fact == 1);
}
void TESTCASE_calc_factorial__fact_of_negative_is_one() {
  input_value = -10;
  int64_t fact = calc_factorial(feed_stub);
  assert(fact == 1);
}
void TESTCASE_calc_factorial__fact_of_5_is_120() {
  input_value = 5;
  int64_t fact = calc_factorial(feed_stub);
  assert(fact == 120);
}</pre>
			<p class="packt_figref">Code Box 22-5 [ExtremeC_examples_chapter22_1 __calc_factorial__tests.c]: The test cases written for the calc_factorial function</p>
			<p class="normal">As you can see, we have defined three test cases for the <code class="Code-In-Text--PACKT-">calc_factorial</code> function. Note the <code class="Code-In-Text--PACKT-">feed_stub</code> function. It follows the same contract that <code class="Code-In-Text--PACKT-">next_even_number</code> is following, as can be seen in <em class="italics">Code Box 22-2</em>, but it has a very simple definition. It just returns a value stored in the static variable <code class="Code-In-Text--PACKT-">input_value</code>. This variable can be set by the test cases before calling the <code class="Code-In-Text--PACKT-">calc_facorial</code> function.</p>
			<p class="normal">Using the preceding stub function, we could isolate <code class="Code-In-Text--PACKT-">calc_factorial</code> and test it individually. The same approach is valid for object-oriented programming languages like C++ or Java, but there we define <em class="italics">stub classes</em> and <em class="italics">stub objects</em>.</p>
			<p class="normal">In C, a <em class="italics">stub</em> is a function definition that conforms to a function declaration that the target unit would use as part of its logic, and more importantly, the stub doesn't have a complex logic and it just returns a value that is going to be used just by the test case.</p>
			<p class="normal">In C++, a stub can still be a function definition that conforms to a function declaration, or a class that<a id="_idIndexMarker1628"/> implements an interface. In other object-oriented languages where you cannot have standalone functions, for instance Java, a stub can only be a class that implements an interface. Then, a stub object is an object from such stub classes. Note that in all cases, a stub should have a simple definition that is only usable in tests, and not in production.</p>
			<p class="normal">Finally, we need to be able to run the test cases. As we said previously, we need a test runner to run tests. Therefore, we need a specific source file with a <code class="Code-In-Text--PACKT-">main</code> function that only runs the test cases one after another. The following code box contains the code of the test runner:</p>
			<pre>#include &lt;stdio.h&gt;
void TESTCASE_next_even_number__even_numbers_should_be_returned();
void TESTCASE_next_even_number__numbers_should_rotate();
void TESTCASE_calc_factorial__fact_of_zero_is_one();
void TESTCASE_calc_factorial__fact_of_negative_is_one();
void TESTCASE_calc_factorial__fact_of_5_is_120();
int main(int argc, char** argv) {
  TESTCASE_next_even_number__even_numbers_should_be_returned();
  TESTCASE_next_even_number__numbers_should_rotate();
  TESTCASE_calc_factorial__fact_of_zero_is_one();
  TESTCASE_calc_factorial__fact_of_negative_is_one();
  TESTCASE_calc_factorial__fact_of_5_is_120();
  printf("All tests are run successfully.\n");
  return 0;
}</pre>
			<p class="packt_figref">Code Box 22-6 [ExtremeC_examples_chapter22_1 _tests.c]: The test runner used in example 22.1</p>
			<p class="normal">The above code returns <code class="Code-In-Text--PACKT-">0</code> only if all the test cases within the <code class="Code-In-Text--PACKT-">main</code> functions are executed successfully. For building the test runner, we need to run the following commands. Note the <code class="Code-In-Text--PACKT-">-g</code> option that adds debugging symbols to the final test runner executable. Performing a <em class="italics">debug build</em> is the most common way to build tests since if a test case fails, we immediately need the precise <em class="italics">stack trace</em> and further debugging information to<a id="_idIndexMarker1629"/> proceed with investigation. More than that, the <code class="Code-In-Text--PACKT-">assert</code> statements are usually removed from <em class="italics">release builds</em>, but we need to have them in the test runner executable:</p>
			<pre><strong class="screen-text">$ gcc -g -c ExtremeC_examples_chapter22_1.c -o impl.o</strong>
<strong class="screen-text">$ gcc -g -c ExtremeC_examples_chapter22_1__next_even_number__tests.c -o tests1.o</strong>
<strong class="screen-text">$ gcc -g -c ExtremeC_examples_chapter22_1__calc_factorial__tests.c -o tests2.o</strong>
<strong class="screen-text">$ gcc -g -c ExtremeC_examples_chapter22_1_tests.c -o main.o</strong>
<strong class="screen-text">$ gcc impl.o tests1.o tests2.o main.o -o ex22_1_tests.out</strong>
<strong class="screen-text">$ ./ex22_1_tests.out</strong>
All tests are run successfully.
<strong class="screen-text">$ echo $?</strong>
0
<strong class="screen-text">$</strong></pre>
			<p class="packt_figref">Shell Box 22-2: Building and running the test runner of example 22.1</p>
			<p class="normal">The preceding shell box shows that all the tests have been passed. You can also check the exit code of the test runner process by using the <code class="Code-In-Text--PACKT-">echo $?</code> command and see that it has returned zero.</p>
			<p class="normal">Now, by applying a simple change in one of the functions, we can fail the tests. Let's see what happens when we change <code class="Code-In-Text--PACKT-">calc_factorial</code> as follows:</p>
			<pre>int64_t calc_factorial(int64_feed_t feed) {
  int64_t fact = 1;
  int64_t number = feed();
  for (int64_t i = 1; i &lt;= <strong class="highlight">(number + 1)</strong>; i++) {
    fact *= i;
  }
  return fact;
}</pre>
			<p class="packt_figref">Code Box 22-7: Changing the calc_factorial function to fail the tests</p>
			<p class="normal">With the preceding change, shown in bold font, the test cases about the <code class="Code-In-Text--PACKT-">0</code> and negative inputs still pass, but the <a id="_idIndexMarker1630"/>last test case, which is about the calculation of the factorial of <code class="Code-In-Text--PACKT-">5</code>, fails. We are going to build the test runner again and the following is the output of the execution on a macOS machine:</p>
			<pre><strong class="screen-text">$ gcc -g -c ExtremeC_examples_chapter22_1.c -o impl.o</strong>
<strong class="screen-text">$ gcc -g -c ExtremeC_examples_chapter22_1_tests.c -o main.o</strong>
<strong class="screen-text">$ ./ex22_1_tests.out</strong>
Assertion failed: (fact == 120), function TESTCASE_calc_factorial__fact_of_5_is_120, 
file .../22.1/ExtremeC_examples_chapter22_1__calc_factorial__tests.c, line 29.
Abort trap: 6
<strong class="screen-text">$ echo $?</strong>
134
<strong class="screen-text">$</strong></pre>
			<p class="packt_figref">Shell Box 22-3: Building and running the test runner after changing the calc_factorial function</p>
			<p class="normal">As you can see, <code class="Code-In-Text--PACKT-">Assertion failed</code> appears in the output and the exit code is <code class="Code-In-Text--PACKT-">134</code>. This exit code is usually used and reported by the systems running the tests periodically, such as <em class="italics">Jenkins</em>, to check if the tests have been run successfully.</p>
			<p class="normal">As a rule of thumb, whenever you have a unit that should be tested in isolation, you need to find a way to provide its dependencies as some kind of input. Therefore, the unit itself should be written in a way that makes it <em class="italics">testable</em>. Not all code is testable, and testability is not limited to unit testing, and this is very important to be aware of. This link provides good<a id="_idIndexMarker1631"/> information on how to write t<a href="https://blog.gurock.com/highly-testable-code/">estable code: https://blog.gurock.com/highly-</a>testable-code/.</p>
			<p class="normal">To clarify the above discussion, suppose that we have written the <code class="Code-In-Text--PACKT-">calc_factorial</code> function like below to use the <code class="Code-In-Text--PACKT-">next_even_number</code> function directly instead of using a function pointer. Note that in the following code box, the function doesn't receive a function pointer argument and it calls the <code class="Code-In-Text--PACKT-">next_even_number</code> function directly:</p>
			<pre>int64_t calc_factorial() {
  int64_t fact = 1;
  int64_t number = next_even_number();
  for (int64_t i = 1; i &lt;= number; i++) {
    fact *= i;
  }
  return fact;
}</pre>
			<p class="packt_figref">Code Box 22-8: Changing the calc_factorial function's signature to not accept a function pointer</p>
			<p class="normal">The preceding code is less testable. There is no way to test <code class="Code-In-Text--PACKT-">calc_factorial</code> without having the <code class="Code-In-Text--PACKT-">next_even_number</code> called – that is, without employing some hacks to change the definition behind the symbol <code class="Code-In-Text--PACKT-">next_even_number</code> as part of the final executable, as we do in <em class="italics">example 22.2</em>.</p>
			<p class="normal">In fact, both versions of <code class="Code-In-Text--PACKT-">calc_factorial</code> do the same thing, but the definition in <em class="italics">Code Box 22-2</em> is more testable because we could test it in isolation. Writing testable code is not easy, and you should always think carefully in order to implement code and have it be testable.</p>
			<p class="normal">Writing testable code usually demands more work. There are various opinions about the overhead percentage of writing testable code but it is certain that writing tests brings some extra cost in terms <a id="_idIndexMarker1632"/>of time and effort. But this extra cost surely has great benefits. Without having tests for a unit, you will lose track of it as time goes by and more changes are introduced to the unit.</p>
			<h2 id="_idParaDest-324" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor625"/>Test doubles</h2>
			<p class="normal">In the preceding example, while writing test cases, we introduced stub functions. There are a few other terms about<a id="_idIndexMarker1633"/> the objects that try to mimic a unit's dependencies. These objects are called <em class="italics">test doubles</em>. Next, we are going to introduce two other test doubles: <em class="italics">mock</em> and <em class="italics">fake</em> functions. First, let's briefly explain again what stub functions are.</p>
			<p class="normal">Note two things in this short section. Firstly, there are never-ending debates on the definition of these test doubles, and we try to give a proper definition that matches our usage in this chapter. Secondly, we keep our discussion only relevant to C, so there is no object and everything we have is a function.</p>
			<p class="normal">When a unit is dependent on another function, it simply depends on the signature of that function, therefore that function can be replaced by a new one. This new function, based on some properties that it might have, can be called a stub, a mock, or a fake function. These functions are just written to satisfy the test requirements and they cannot be used in production.</p>
			<p class="normal">We explained a stub to be a function that is very simple, usually just returning a constant value. As you saw in <em class="italics">example 22.1</em>, it was indirectly returning a value just set by the running test case. In the following link, you can read more about the test doubles that we are talking about <a id="_idIndexMarker1634"/>and a f<a href="https://en.wikipedia.org/wiki/Test_double">ew more of them: https://en.wikipedia.org</a>/wiki/Test_double. If you <a id="_idIndexMarker1635"/>open the link, a stub is defined as something that provides an <em class="italics">indirect input</em> to the testing code. If you accept this definition, the <code class="Code-In-Text--PACKT-">feed_stub</code> function seen in <em class="italics">Code Box 22-5</em> is a stub function.</p>
			<p class="normal">Mock functions, or generally mock objects as part of object-oriented languages, can be manipulated by specifying the output for a certain input. This way, you set whatever should be returned from a mock function for a certain input before running the test logic and during the logic it will act as you have set beforehand. Mock objects in general can have expectations as well and they perform the required assertions accordingly. As stated in the preceding link, for mock objects, we set expectations before running the test. We are going to give a C example of mock functions as part of the component testing section.</p>
			<p class="normal">Finally, a fake function can be used to give a very simplified functionality for a real and maybe complex functionality as part of the running test. For example, instead of using a real filesystem, one may use some simplified in-memory storage. In component testing, for instance, other components that have complex functionalities can be replaced by fake implementations in the tests.</p>
			<p class="normal">Before ending this section, I want to talk about <em class="italics">code coverage</em>. In theory, all units should have corresponding test suites and each test suite should contain all test cases that go through all possible branches of code. As we said, this is in theory, but in practice you usually have test units only for a percentage of units. Often, you don't have test cases that cover all possible branches of code.</p>
			<p class="normal">The proportion of units that have proper test cases is called code coverage or <em class="italics">test coverage</em>. The higher the proportion, the better placed you are for getting notified about unwanted modifications. These unwanted modifications are not usually introduced by bad developers. In fact, these breaking changes are usually introduced while someone is working on a piece of code for fixing a bug or implementing a new feature.</p>
			<p class="normal">Having covered test doubles, we talk about component testing in <a id="_idTextAnchor626"/>the next section.</p>
			<h1 id="_idParaDest-325" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor627"/>Component testing</h1>
			<p class="normal">As we explained in the previous section, units can be defined as a single function, a group of functions, or a whole component. Therefore, component testing is a special type of unit testing. In this section, we want to define a hypothetical component as part of <em class="italics">example 22.1</em> and put the two functions found in the example into this component. Note that<a id="_idIndexMarker1636"/> a component usually results in an executable or a library. We can suppose that our hypothetical component would result in a library that contains the two functions.</p>
			<p class="normal">As we said before, we have to be able to test the functionality of a component. In this section, we still want to write test cases but the difference between the tests written in this section and the previous section is to do with the units that should be isolated. In the previous section, we had functions that should have been isolated, but in this section, we have a component, compromising of two functions working hand in hand, that needs to be isolated. So, the functions must be tested when they are working together.</p>
			<p class="normal">Next, you can find the test cases we have written for the component defined as part of <em class="italics">example 22.1</em>:</p>
			<pre>#include &lt;assert.h&gt;
#include "ExtremeC_examples_chapter22_1.h"
void TESTCASE_component_test__factorials_from_0_to_8() {
  assert(calc_factorial(next_even_number) == 1);
  assert(calc_factorial(next_even_number) == 2);
  assert(calc_factorial(next_even_number) == 24);
  assert(calc_factorial(next_even_number) == 720);
  assert(calc_factorial(next_even_number) == 40320);
}
void TESTCASE_component_test__factorials_should_rotate() {
  int64_t number = calc_factorial(next_even_number);
  for (size_t i = 1; i &lt;= 4; i++) {
    calc_factorial(next_even_number);
  }
  int64_t number2 = calc_factorial(next_even_number);
  assert(number == number2);
}
int main(int argc, char** argv) {
  TESTCASE_component_test__factorials_from_0_to_8();
  TESTCASE_component_test__factorials_should_rotate();
  return 0;
}</pre>
			<p class="packt_figref">Code Box 22-9 [ExtremeC_examples_chapter22_1_component_tests.c]: Some component tests written for our hypothetical component as part of example 22.1</p>
			<p class="normal">As you see, we have written two test cases. Like we said before, in our hypothetical component, the functions <code class="Code-In-Text--PACKT-">calc_factorial</code> and <code class="Code-In-Text--PACKT-">next_even_number</code> must work together, and as you see, we have passed <code class="Code-In-Text--PACKT-">next_even_number</code> as the feed to <code class="Code-In-Text--PACKT-">calc_factorial</code>. The preceding test cases, and other similar test cases, should guarantee that the component is working properly.</p>
			<p class="normal">It requires a lot of effort<a id="_idIndexMarker1637"/> to prepare a basis for writing test cases. Therefore, it is very common to use a testing library for this purpose. These libraries prepare the playground for the test cases; they initialize every test case, run the test case, and finally tear down the test case. In the upcoming section, we are going to talk about two of the testing librari<a id="_idTextAnchor628"/><a id="_idTextAnchor629"/>es available for C.</p>
			<h1 id="_idParaDest-326" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor630"/>Testing libraries for C</h1>
			<p class="normal">In this section, we are going to demonstrate two of the well-known libraries used to write tests for<a id="_idIndexMarker1638"/> C programs. For unit testing in C, we use libraries that are written in C or C++. That's because we can integrate them easily and use the units directly <a id="_idIndexMarker1639"/>from a C or C++ testing environment. In this section, our focus is on unit testing and component testing in C.</p>
			<p class="normal">For integration testing, we are free to choose other programming languages. Generally, the integration and system testing are much more complex, and we therefore need to use some testing automation frameworks in order to write tests easier and run them without too much <a id="_idIndexMarker1640"/>hassle. Using a <strong class="bold">domain-specific language</strong> (<strong class="bold">DSL</strong>) is part of this automation, in order to write test scenarios more easily and make test execution much simpler. Many languages can be used for this purpose, but scripting languages like Unix shell, Python, JavaScript, and Ruby are among the most favorite ones. Some other programming languages like Java are also used heavily in test automation.</p>
			<p class="normal">The following is a list of some <a id="_idIndexMarker1641"/>well-known unit testing frameworks which can be used to write unit tests for C programs. This list below can be found at the following link: http://check.sourceforge.net/doc/check_html/check_2.html#SEC3:</p>
			<ul>
				<li class="list">Check (from the author of the preceding link)</li>
				<li class="list">AceUnit</li>
				<li class="list">GNU Autounit</li>
				<li class="list">cUnit</li>
				<li class="list">CUnit</li>
				<li class="list">CppUnit</li>
				<li class="list">CuTest</li>
				<li class="list">embUnit</li>
				<li class="list">MinUnit</li>
				<li class="list">Google Test</li>
				<li class="list">CMocka</li>
			</ul>
			<p class="normal">In the following sections, we will introduce two popular testing frameworks: <em class="italics">CMocka</em>, which is written in C, and <em class="italics">Google Test</em>, which is written in C++. We won't explore all features of these<a id="_idIndexMarker1642"/> frameworks, but this is just to give you an initial feeling about a unit<a id="_idIndexMarker1643"/> testing framework. Further study is highly encouraged in this domain.</p>
			<p class="normal">In the next section, we are going to write unit tests for <em class="italics">e<a id="_idTextAnchor631"/>xample 22.1</em> using CMocka.</p>
			<h2 id="_idParaDest-327" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor632"/>CMocka</h2>
			<p class="normal">The first great thing about CMocka is that it is written purely in C, and it only depends on the C standard library – not on any other libraries. So, you can use a C compiler to compile the tests, and <a id="_idIndexMarker1644"/>this gives you the confidence that the test environment is very close to the actual production environment. CMocka is available on many platforms like macOS, Linux, and even Microsoft Windows.</p>
			<p class="normal">CMocka is the <em class="italics">de facto</em> framework for unit testing in C. It supports <em class="italics">test fixtures</em>. Test fixtures may allow you to initialize and clear the testing environment before and after each test case. CMocka also supports <em class="italics">function mocking</em>, which is very useful when trying to mock any C function. As a reminder, a mock function can be configured to return a certain value when a certain input is provided. We will give an example of mocking the <code class="Code-In-Text--PACKT-">rand</code> standard function used in <em class="italics">example 22.2</em>.</p>
			<p class="normal">The following code box contains the same test cases that we saw for <em class="italics">example 22.1</em> but written in CMocka this time. We have put all test cases in just one file, which has its own <code class="Code-In-Text--PACKT-">main</code> function:</p>
			<pre>// Required by CMocka
#include &lt;stdarg.h&gt;
#include &lt;stddef.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;cmocka.h&gt;
#include "ExtremeC_examples_chapter22_1.h"
int64_t input_value = -1;
int64_t feed_stub() {
  return input_value;
}
void calc_factorial__fact_of_zero_is_one(void** state) {
  input_value = 0;
  int64_t fact = calc_factorial(feed_stub);
  assert_int_equal(fact, 1);
}
void calc_factorial__fact_of_negative_is_one(void** state) {
  input_value = -10;
  int64_t fact = calc_factorial(feed_stub);
  assert_int_equal(fact, 1);
}
void calc_factorial__fact_of_5_is_120(void** state) {
  input_value = 5;
  int64_t fact = calc_factorial(feed_stub);
  assert_int_equal(fact, 120);
}
void next_even_number__even_numbers_should_be_returned(void** state) {
  assert_int_equal(next_even_number(), 0);
  assert_int_equal(next_even_number(), 2);
  assert_int_equal(next_even_number(), 4);
  assert_int_equal(next_even_number(), 6);
  assert_int_equal(next_even_number(), 8);
}
void next_even_number__numbers_should_rotate(void** state) {
  int64_t number = next_even_number();
  for (size_t i = 1; i &lt;= 4; i++) {
    next_even_number();
  }
  int64_t number2 = next_even_number();
  assert_int_equal(number, number2);
}
int setup(void** state) {
  return 0;
}
int tear_down(void** state) {
  return 0;
}
int main(int argc, char** argv) {
  const struct CMUnitTest tests[] = {
    cmocka_unit_test(calc_factorial__fact_of_zero_is_one),
    cmocka_unit_test(calc_factorial__fact_of_negative_is_one),
    cmocka_unit_test(calc_factorial__fact_of_5_is_120),
    cmocka_unit_test(next_even_number__even_numbers_should_be_returned),
    cmocka_unit_test(next_even_number__numbers_should_rotate),
  };
  return cmocka_run_group_tests(tests, setup, tear_down);
}</pre>
			<p class="packt_figref">Code Box 22-10 [ExtremeC_examples_chapter22_1_cmocka_tests.c]: CMocka test cases for example 22.1</p>
			<p class="normal">In CMocka, every test case should return <code class="Code-In-Text--PACKT-">void</code> and receive a <code class="Code-In-Text--PACKT-">void**</code> argument. The pointer argument will<a id="_idIndexMarker1645"/> be used to receive a piece of information, called a <code class="Code-In-Text--PACKT-">state</code>, which is specific to a test case. In the <code class="Code-In-Text--PACKT-">main</code> function, we create a list of test cases, and then finally we call the <code class="Code-In-Text--PACKT-">cmocka_run_group_tests</code> function to run all the unit tests.</p>
			<p class="normal">In addition to test case functions, you see two new functions: <code class="Code-In-Text--PACKT-">setup</code> and <code class="Code-In-Text--PACKT-">tear_down</code>. As we said before, these functions are called test fixtures. Test fixtures are called before and after every test case and their responsibility is to set up and tear down the test case. The fixture <code class="Code-In-Text--PACKT-">setup</code> is called before every test case and the fixture <code class="Code-In-Text--PACKT-">tear_down</code> is called after every test case. Note that the names are optional, and they could be named anything, but we use <code class="Code-In-Text--PACKT-">setup</code> and <code class="Code-In-Text--PACKT-">tear_down</code> for clarity.</p>
			<p class="normal">Another important difference between the test cases we wrote before and the test cases written using CMocka is the use of different assertion functions. This is one of the advantages of using a unit testing framework. There are a wide range of assertion functions as part of a testing library that can give you more information about their failure, rather than the standard <code class="Code-In-Text--PACKT-">assert</code> function, which terminates the program immediately and without giving much information. As you can see, we have used <code class="Code-In-Text--PACKT-">assert_int_equal</code> in the preceding code, which checks the equality of two integers.</p>
			<p class="normal">In order to compile the <a id="_idIndexMarker1646"/>preceding program, you need to have CMocka installed first. On a Debian-based Linux system, it is enough to run <code class="Code-In-Text--PACKT-">sudo apt-get install libcmocka-dev</code>, and on macOS systems, it is enough to install it by using the command <code class="Code-In-Text--PACKT-">brew install cmocka</code>. There will be a lot of help available online that can help you get through the installation process.</p>
			<p class="normal">After having CMocka installed, you can use the following commands to build the preceding code:</p>
			<pre><strong class="screen-text">$ gcc -g -c ExtremeC_examples_chapter22_1.c -o impl.o</strong>
<strong class="screen-text">$ gcc -g -c ExtremeC_examples_chapter22_1_cmocka_tests.c -o cmocka_tests.o</strong>
<strong class="screen-text">$ gcc impl.o cmocka_tests.o -lcmocka -o ex22_1_cmocka_tests.out</strong>
<strong class="screen-text">$ ./ex22_1_cmocka_tests.out</strong>
[==========] Running 5 test(s).
[ RUN      ] calc_factorial__fact_of_zero_is_one
[       OK ] calc_factorial__fact_of_zero_is_one
[ RUN      ] calc_factorial__fact_of_negative_is_one
[       OK ] calc_factorial__fact_of_negative_is_one
[ RUN      ] calc_factorial__fact_of_5_is_120
[       OK ] calc_factorial__fact_of_5_is_120
[ RUN      ] next_even_number__even_numbers_should_be_returned
[       OK ] next_even_number__even_numbers_should_be_returned
[ RUN      ] next_even_number__numbers_should_rotate
[       OK ] next_even_number__numbers_should_rotate
[==========] 5 test(s) run.
[  PASSED  ] 5 test(s).
<strong class="screen-text">$</strong></pre>
			<p class="packt_figref">Shell Box 22-4: Building and running CMocka unit tests written for example 22.1</p>
			<p class="normal">As you can see, we had to use <code class="Code-In-Text--PACKT-">-lcmocka</code> in order to link the preceding program with the installed CMocka library. The output shows the test case names and the number of passed tests. Next, we <a id="_idIndexMarker1647"/>change one of the test cases to make it fail. We just modify the first assertion in the <code class="Code-In-Text--PACKT-">next_even_number__even_numbers_should_be_returned</code> test case:</p>
			<pre>void next_even_number__even_numbers_should_be_returned(void** state) {
  assert_int_equal(next_even_number(), 1);
  ...
}</pre>
			<p class="packt_figref">Code Box 22-11: Changing one of the CMocka test cases in example 22.1</p>
			<p class="normal">Now, build the tests and run them again:</p>
			<pre><strong class="screen-text">$ gcc -g -c ExtremeC_examples_chapter22_1_cmocka_tests.c -o cmocka_tests.o</strong>
<strong class="screen-text">$ gcc impl.o cmocka_tests.o -lcmocka -o ex22_1_cmocka_tests.out</strong>
<strong class="screen-text">$ ./ex22_1_cmocka_tests.out</strong>
[==========] Running 5 test(s).
[ RUN      ] calc_factorial__fact_of_zero_is_one
[       OK ] calc_factorial__fact_of_zero_is_one
[ RUN      ] calc_factorial__fact_of_negative_is_one
[       OK ] calc_factorial__fact_of_negative_is_one
[ RUN      ] calc_factorial__fact_of_5_is_120
[       OK ] calc_factorial__fact_of_5_is_120
[ RUN      ] next_even_number__even_numbers_should_be_returned
<strong class="highlight">[  ERROR   ] --- 0 != 0x1</strong>
<strong class="highlight">[   LINE   ] --- .../ExtremeC_examples_chapter22_1_cmocka_tests.c:37: error: Failure!</strong>
<strong class="highlight">[  FAILED  ] next_even_number__even_numbers_should_be_returned</strong>
[ RUN      ] next_even_number__numbers_should_rotate
[       OK ] next_even_number__numbers_should_rotate
[==========] 5 test(s) run.
[  PASSED  ] 4 test(s).
[  FAILED  ] 1 test(s), listed below:
[  FAILED  ] next_even_number__even_numbers_should_be_returned
 1 FAILED TEST(S)
<strong class="screen-text"> $</strong></pre>
			<p class="packt_figref">Shell Box 22-5: Building and running CMocka unit tests after modifying one of them</p>
			<p class="normal">In the preceding output, you see that one of the test cases has been failed and the reason is shown as an error in the middle of the logs. It shows an integer equality assertion failure. As we have explained before, using <code class="Code-In-Text--PACKT-">assert_int_equal</code> instead of using an ordinary <code class="Code-In-Text--PACKT-">assert</code> call allows CMocka to print a helpful message in the execution log instead of just terminating the program.</p>
			<p class="normal">Our next example is about using CMocka's function mocking feature. CMocka allows you to mock a function and this way, you can instrument the function to return a specific result when a certain input is provided.</p>
			<p class="normal">In the next example, <em class="italics">example 22.2</em>, we want to demonstrate how to use the mocking feature. In this example, the standard function <code class="Code-In-Text--PACKT-">rand</code> is used to generate random numbers. There is also <a id="_idIndexMarker1648"/>a function, named <code class="Code-In-Text--PACKT-">random_boolean</code>, that returns a Boolean based on the oddity of the number returned from the <code class="Code-In-Text--PACKT-">rand</code> function. Before showing CMocka's mocking feature, we want to show how to create a stub for the <code class="Code-In-Text--PACKT-">rand</code> function. You see that this example is different from <em class="italics">example 22.1</em>. Next, you can see the declaration of the <code class="Code-In-Text--PACKT-">random_boolean</code> function:</p>
			<pre>#ifndef _EXTREME_C_EXAMPLE_22_2_
#define _EXTREME_C_EXAMPLE_22_2_
#define TRUE 1
#define FALSE 0
typedef int bool_t;
bool_t random_boolean();
#endif</pre>
			<p class="packt_figref">Code Box 22-12 [ExtremeC_examples_chapter22_2.h]: The header file of example 22.2</p>
			<p class="normal">And the following code box contains the definition:</p>
			<pre>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include "ExtremeC_examples_chapter22_2.h"
bool_t random_boolean() {
  int number = rand();
  return (number % 2);
}</pre>
			<p class="packt_figref">Code Box 22-13 [ExtremeC_examples_chapter22_2.c]: The definition of the random_boolean function in example 22.2</p>
			<p class="normal">First of all, we cannot let <code class="Code-In-Text--PACKT-">random_boolean</code> use the actual <code class="Code-In-Text--PACKT-">rand</code> definition in the tests because, as its name implies, it generates random numbers and we cannot have a random element in our tests. Tests are about checking expectations and the expectations, and the provided inputs, must be predictable. More than that, the definition of the <code class="Code-In-Text--PACKT-">rand</code> function is part of the C standard library, for instance <em class="italics">glibc</em> in Linux, and using a stub function for it won't be easy like what we did in <em class="italics">example 22.1</em>.</p>
			<p class="normal">In the previous<a id="_idIndexMarker1649"/> example, we could send a function pointer to the stub definition very easily. But in this example, we are using the <code class="Code-In-Text--PACKT-">rand</code> function directly. We cannot change the definition of <code class="Code-In-Text--PACKT-">random_boolean</code>, and we have to come up with another trick to use the stub function for <code class="Code-In-Text--PACKT-">rand</code>.</p>
			<p class="normal">In order to use a different definition for the <code class="Code-In-Text--PACKT-">rand</code> function, one of the easiest ways in C is to play with <em class="italics">symbols</em> in the final object file. In the <em class="italics">symbol table</em> of the resulting object file, there is an entry for <code class="Code-In-Text--PACKT-">rand</code> which refers to its actual definition in the C standard library. If we change this entry to refer to a different definition of the <code class="Code-In-Text--PACKT-">rand</code> function in our testing binaries, we can easily substitute the definition of <code class="Code-In-Text--PACKT-">rand</code> with our stub one.</p>
			<p class="normal">In the following code box, you can see how we have defined the stub function and the tests together. This would be very similar to what we did for <em class="italics">example 22.1</em>:</p>
			<pre>#include &lt;stdlib.h&gt;
// Required by CMocka
#include &lt;stdarg.h&gt;
#include &lt;stddef.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;cmocka.h&gt;
#include "ExtremeC_examples_chapter22_2.h"
int next_random_num = 0;
int __wrap_rand() {
  return next_random_num;
}
void test_even_random_number(void** state) {
  next_random_num = 10;
  assert_false(random_boolean());
}
void test_odd_random_number(void** state) {
  next_random_num = 13;
  assert_true(random_boolean());
}
int main(int argc, char** argv) {
  const struct CMUnitTest tests[] = {
    cmocka_unit_test(test_even_random_number),
    cmocka_unit_test(test_odd_random_number)
  };
  return cmocka_run_group_tests(tests, NULL, NULL);
}</pre>
			<p class="packt_figref">Code Box 22-14 [ExtremeC_examples_chapter22_2_cmocka_tests_with_stub.c]: Writing CMocka test cases using a stub function</p>
			<p class="normal">As you can see, the preceding code is mostly following the same pattern that we saw as part of the CMocka tests written for <em class="italics">example 22.1</em> in <em class="italics">Code Box 22-10</em>. Let's build the preceding file and<a id="_idIndexMarker1650"/> run the tests. What we expect is to have all tests failed because, no matter how you define the stub function, the <code class="Code-In-Text--PACKT-">random_boolean</code> is picking the <code class="Code-In-Text--PACKT-">rand</code> from the C standard library:</p>
			<pre><strong class="screen-text">$ gcc -g -c ExtremeC_examples_chapter22_2.c -o impl.o</strong>
<strong class="screen-text">$ gcc -g -c ExtremeC_examples_chapter22_2_cmocka_tests_with_stub.c -o tests.o</strong>
<strong class="screen-text">$ gcc impl.o tests.o -lcmocka -o ex22_2_cmocka_tests_with_stub.out</strong>
<strong class="screen-text">$ ./ex22_2_cmocka_tests_with_stub.out</strong>
[==========] Running 2 test(s).
[ RUN      ] test_even_random_number
[  ERROR   ] --- random_boolean()
[   LINE   ] --- ExtremeC_examples_chapter22_2_cmocka_tests_with_stub.c:23: error: Failure!
[  FAILED  ] test_even_random_number
[ RUN      ] test_odd_random_number
[  ERROR   ] --- random_boolean()
[   LINE   ] --- ExtremeC_examples_chapter22_2_cmocka_tests_with_stub.c:28: error: Failure!
[  FAILED  ] test_odd_random_number
[==========] 2 test(s) run.
[  PASSED  ] 0 test(s).
[  FAILED  ] 2 test(s), listed below:
[  FAILED  ] test_even_random_number
[  FAILED  ] test_odd_random_number
 2 FAILED TEST(S)
<strong class="screen-text">$</strong></pre>
			<p class="packt_figref">Shell Box 22-6: Building and running CMocka unit tests for example 22.2</p>
			<p class="normal">Now it's time do the trick and change the definition behind the <code class="Code-In-Text--PACKT-">rand</code> symbol defined as part of the <code class="Code-In-Text--PACKT-">ex22_2_cmocka_tests_with_stub.out</code> executable file. Note that the following<a id="_idIndexMarker1651"/> commands are only applicable to Linux systems. We do it as follows:</p>
			<pre><strong class="screen-text">$ gcc impl.o tests.o -lcmocka -Wl,--wrap=rand -o ex22_2_cmocka_tests_with_stub.out</strong>
<strong class="screen-text">$ ./ex22_2_cmocka_tests_with_stub.out</strong>
[==========] Running 2 test(s).
[ RUN      ] test_even_random_number
[       OK ] test_even_random_number
[ RUN      ] test_odd_random_number
[       OK ] test_odd_random_number
[==========] 2 test(s) run.
[  PASSED  ] 2 test(s).
<strong class="screen-text">$</strong></pre>
			<p class="packt_figref">Shell Box 22-7: Building and running CMocka unit tests for example 22.2 after wrapping the rand symbol</p>
			<p class="normal">As you see in the output, the standard <code class="Code-In-Text--PACKT-">rand</code> function is not being called anymore and instead, the stub function returns what we have told it to return. The main trick that makes the function <code class="Code-In-Text--PACKT-">__wrap_rand</code> be called instead of standard <code class="Code-In-Text--PACKT-">rand</code> function lies in using the option <code class="Code-In-Text--PACKT-">-Wl</code>,<code class="Code-In-Text--PACKT-">--wrap=rand</code> in the <code class="Code-In-Text--PACKT-">gcc</code> link command.</p>
			<p class="normal">Note that this option is only available for the <code class="Code-In-Text--PACKT-">ld</code> program in Linux and you have to use other tricks like <em class="italics">inter-positioning</em> to call a different function in macOS or other systems using a linker other than the GNU linker.</p>
			<p class="normal">The option <code class="Code-In-Text--PACKT-">--wrap=rand</code> tells the linker to update the entry for the symbol <code class="Code-In-Text--PACKT-">rand</code> in the final executable's symbol table, which is going to refer to the definition of the <code class="Code-In-Text--PACKT-">__wrap_rand</code> function. Note that this is not a custom name and you have to name the stub function like that. The function <code class="Code-In-Text--PACKT-">__wrap_rand</code> is said to be a <em class="italics">wrapper function</em>. After updating the symbol table, any call to the <code class="Code-In-Text--PACKT-">rand</code> function results in calling the <code class="Code-In-Text--PACKT-">__wrap_func</code> function. This can be verified by looking at the symbol table of the final test binary.</p>
			<p class="normal">Apart from updating the <code class="Code-In-Text--PACKT-">rand</code> symbol in the symbol table, the linker also creates another entry. The new entry has the symbol <code class="Code-In-Text--PACKT-">__real_rand</code>, which refers to the actual definition of the standard <code class="Code-In-Text--PACKT-">rand</code> function. Therefore, if we needed to run the standard <code class="Code-In-Text--PACKT-">rand</code>, we still can use the function name <code class="Code-In-Text--PACKT-">__real_rand</code>. This is a great usage of the symbol table and the<a id="_idIndexMarker1652"/> symbols in it, in order to call a wrapper function, despite the fact that some people don't like it and they prefer to preload a shared object that wraps the actual <code class="Code-In-Text--PACKT-">rand</code> function. Whichever method you use, you need to finally redirect the calls to the <code class="Code-In-Text--PACKT-">rand</code> symbol to another stub function.</p>
			<p class="normal">The preceding mechanism would be the basis to demonstrate how function mocking works in CMocka. Instead of having a global variable <code class="Code-In-Text--PACKT-">next_random_num</code>, as seen in <em class="italics">Code Box 22-14</em>, we can use a mocked function to return the specified value. Next, you can see the same CMocka tests but using a mocked function to read the test inputs:</p>
			<pre>#include &lt;stdlib.h&gt;
// Required by CMocka
#include &lt;stdarg.h&gt;
#include &lt;stddef.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;cmocka.h&gt;
#include "ExtremeC_examples_chapter22_2.h"
int __wrap_rand() {
  return mock_type(int);
}
void test_even_random_number(void** state) {
  will_return(__wrap_rand, 10);
  assert_false(random_boolean());
}
void test_odd_random_number(void** state) {
  will_return(__wrap_rand, 13);
  assert_true(random_boolean());
}
int main(int argc, char** argv) {
  const struct CMUnitTest tests[] = {
    cmocka_unit_test(test_even_random_number),
    cmocka_unit_test(test_odd_random_number)
  };
  return cmocka_run_group_tests(tests, NULL, NULL);
}</pre>
			<p class="packt_figref">Code Box 22-15 [ExtremeC_examples_chapter22_2_cmocka_tests_with_mock.c]: Writing CMocka test cases using a mock function</p>
			<p class="normal">Now that we know how the wrapper function <code class="Code-In-Text--PACKT-">__wrap_rand</code> is called, we can explain the mocking part. Mocking functionality is provided by the pair of functions <code class="Code-In-Text--PACKT-">will_return</code> and <code class="Code-In-Text--PACKT-">mock_type</code>. First, <code class="Code-In-Text--PACKT-">will_return</code> should be called, which specifies the value that the mock function should return. Then, when the mock function, in this case <code class="Code-In-Text--PACKT-">__wrap_rand</code>, is called, the function <code class="Code-In-Text--PACKT-">mock_type</code> returns the specified value.</p>
			<p class="normal">As an example, we define <code class="Code-In-Text--PACKT-">10</code> to be returned from <code class="Code-In-Text--PACKT-">__wrap_rand</code> by using <code class="Code-In-Text--PACKT-">will_return(__wrap_rand, 10)</code>, and then the value <code class="Code-In-Text--PACKT-">10</code> is returned when the function <code class="Code-In-Text--PACKT-">mock_type</code> is called inside <code class="Code-In-Text--PACKT-">__wrap_rand</code>. Note that every <code class="Code-In-Text--PACKT-">will_return</code> must pair with a <code class="Code-In-Text--PACKT-">mock_type</code> call; otherwise, the test fails. Therefore, if <code class="Code-In-Text--PACKT-">__wrap_rand</code> is not called because<a id="_idIndexMarker1653"/> of any reason, the test fails.</p>
			<p class="normal">As the last note in this section, the output of the preceding code would be the same as we saw in Shell Boxes <em class="italics">22-6</em> and <em class="italics">22-7</em>. In addition, the same commands, of course for the source file <code class="Code-In-Text--PACKT-">ExtremeC_examples_chapter22_2_cmocka_tests_with_mock.c</code>, must be used to build the code and run the tests.</p>
			<p class="normal">In this section, we showed how we can use the CMocka library to write test cases, perform assertions, and write mock functions. In the next section, we talk about Google Test, another testing framework that c<a id="_idTextAnchor633"/>an be used to unit test C programs.</p>
			<h2 id="_idParaDest-328" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor634"/>Google Test</h2>
			<p class="normal">Google Test is a C++ testing <a id="_idIndexMarker1654"/>framework that can be used for unit testing both C and C++ programs. Despite being developed in C++, it can be used for testing C code. Some consider this as a bad practice, because the test environment is not set up using the same compiler and linker that you are going to use for setting up the production environment.</p>
			<p class="normal">Before being able to use Google Test for writing test cases for <em class="italics">example 22.1</em>, we need to modify the header file in <em class="italics">example 22.1</em> a bit. The following is the new header file:</p>
			<pre>#ifndef _EXTREME_C_EXAMPLE_22_1_
#define _EXTREME_C_EXAMPLE_22_1_
#include &lt;stdint.h&gt;
#include &lt;unistd.h&gt;
<strong class="screen-text">#if __cplusplus</strong>
<strong class="screen-text">extern "C" {</strong>
<strong class="screen-text">#endif</strong>
typedef int64_t (*int64_feed_t)();
int64_t next_even_number();
int64_t calc_factorial(int64_feed_t feed);
<strong class="screen-text">#if __cplusplus</strong>
<strong class="screen-text">}</strong>
<strong class="screen-text">#endif</strong>
#endif</pre>
			<p class="packt_figref">Code Box 22-16 [ExtremeC_examples_chapter22_1.h]: The modified header file as part of example 22.1</p>
			<p class="normal">As you can see, we have put the declarations in the <code class="Code-In-Text--PACKT-">extern C { ... }</code> block. We do that only if the macro <code class="Code-In-Text--PACKT-">_cplusplus</code> is defined. The preceding change simply means that when the compiler<a id="_idIndexMarker1655"/> is C++, we want to have the symbols <em class="italics">unmangled</em> in the resulting object files, otherwise we will get link errors when the linker tries to find definitions for <em class="italics">mangled symbols</em>. If you don't know about C++ <em class="italics">name mangling</em>, please refer to the last section in <em class="italics">Chapter 2</em>, <em class="italics">Compilation and Linking</em>.</p>
			<p class="normal">Now, let's continue and write the test cases using Google Test:</p>
			<pre>// Required by Google Test
#include &lt;gtest/gtest.h&gt;
#include "ExtremeC_examples_chapter22_1.h"
int64_t input_value = -1;
int64_t feed_stub() {
  return input_value;
}
TEST(calc_factorial, fact_of_zero_is_one) {
  input_value = 0;
  int64_t fact = calc_factorial(feed_stub);
  ASSERT_EQ(fact, 1);
}
TEST(calc_factorial, fact_of_negative_is_one) {
  input_value = -10;
  int64_t fact = calc_factorial(feed_stub);
  ASSERT_EQ(fact, 1);
}
TEST(calc_factorial, fact_of_5_is_120) {
  input_value = 5;
  int64_t fact = calc_factorial(feed_stub);
  ASSERT_EQ(fact, 120);
}
TEST(next_even_number, even_numbers_should_be_returned) {
  ASSERT_EQ(next_even_number(), 0);
  ASSERT_EQ(next_even_number(), 2);
  ASSERT_EQ(next_even_number(), 4);
  ASSERT_EQ(next_even_number(), 6);
  ASSERT_EQ(next_even_number(), 8);
}
TEST(next_even_number, numbers_should_rotate) {
  int64_t number = next_even_number();
  for (size_t i = 1; i &lt;= 4; i++) {
    next_even_number();
  }
  int64_t number2 = next_even_number();
   ASSERT_EQ(number, number2);
}
int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&amp;argc, argv);
  return RUN_ALL_TESTS();
}</pre>
			<p class="packt_figref">Code Box 22-17 [ExtremeC_examples_chapter22_1_gtests.cpp]: The test cases written using Google Test for example 22.1</p>
			<p class="normal">The test cases are defined using the <code class="Code-In-Text--PACKT-">TEST(...)</code> macro. This is an example of how well macros can be used to form a DSL. There are also other macros like <code class="Code-In-Text--PACKT-">TEST_F(...)</code> and <code class="Code-In-Text--PACKT-">TEST_P(...)</code>, which are C++ specific. The first argument passed to the macro is the test's class name (Google Test is written for object-oriented C++), which can be thought of as the test suite that contains a number of test cases. The second argument is the name of the test case.</p>
			<p class="normal">Note the <code class="Code-In-Text--PACKT-">ASSERT_EQ</code> macro, which is used to assert the equality of objects, not just integers. There are a<a id="_idIndexMarker1656"/> great number of expectation checker macros in Google Test, which makes it a complete unit testing framework. The final part is the <code class="Code-In-Text--PACKT-">main</code> function, which runs all the defined tests. Note that the above code should be compiled using a C++11-compliant compiler like <code class="Code-In-Text--PACKT-">g++</code> and <code class="Code-In-Text--PACKT-">clang++</code>.</p>
			<p class="normal">The following commands build the preceding code. Note using the <code class="Code-In-Text--PACKT-">g++</code> compiler and the option <code class="Code-In-Text--PACKT-">-std=c++11</code> which is passed to it. It indicates that C++11 should be used:</p>
			<pre><strong class="screen-text">$ gcc -g -c ExtremeC_examples_chapter22_1.c -o impl.o</strong>
<strong class="screen-text">$ g++ -std=c++11 -g -c ExtremeC_examples_chapter22_1_gtests.cpp -o gtests.o</strong>
<strong class="screen-text">$ g++ impl.o gtests.o -lgtest -lpthread -o ex19_1_gtests.out</strong>
<strong class="screen-text">$ ./ex19_1_gtests.out</strong>
[==========] Running 5 tests from 2 test suites.
[----------] Global test environment set-up.
[----------] 3 tests from calc_factorial
[ RUN      ] calc_factorial.fact_of_zero_is_one
[       OK ] calc_factorial.fact_of_zero_is_one (0 ms)
[ RUN      ] calc_factorial.fact_of_negative_is_one
[       OK ] calc_factorial.fact_of_negative_is_one (0 ms)
[ RUN      ] calc_factorial.fact_of_5_is_120
[       OK ] calc_factorial.fact_of_5_is_120 (0 ms)
[----------] 3 tests from calc_factorial (0 ms total)
[----------] 2 tests from next_even_number
[ RUN      ] next_even_number.even_numbers_should_be_returned
[       OK ] next_even_number.even_numbers_should_be_returned (0 ms)
[ RUN      ] next_even_number.numbers_should_rotate
[       OK ] next_even_number.numbers_should_rotate (0 ms)
[----------] 2 tests from next_even_number (0 ms total)
[----------] Global test environment tear-down
[==========] 5 tests from 2 test suites ran. (1 ms total)
[  PASSED  ] 5 tests.
<strong class="screen-text">$</strong></pre>
			<p class="packt_figref">Shell Box 22-8: Building and running Google Test unit tests for example 22.1</p>
			<p class="normal">The above output shows a similar output to the CMocka output. It indicates that five test cases have been<a id="_idIndexMarker1657"/> passed. Let's change the same test case as we did for CMocka to break the test suite:</p>
			<pre>TEST(next_even_number, even_numbers_should_be_returned) {
  ASSERT_EQ(next_even_number(), 1);
  ...
}</pre>
			<p class="packt_figref">Code Box 22-18: Changing one of the test cases written in Google Test</p>
			<p class="normal">Let's build the tests again and run them:</p>
			<pre><strong class="screen-text">$ g++ -std=c++11 -g -c ExtremeC_examples_chapter22_1_gtests.cpp -o gtests.o</strong>
<strong class="screen-text">$ g++ impl.o gtests.o -lgtest -lpthread -o ex22_1_gtests.out</strong>
<strong class="screen-text">$ ./ex22_1_gtests.out</strong>
[==========] Running 5 tests from 2 test suites.
[----------] Global test environment set-up.
[----------] 3 tests from calc_factorial
[ RUN      ] calc_factorial.fact_of_zero_is_one
[       OK ] calc_factorial.fact_of_zero_is_one (0 ms)
[ RUN      ] calc_factorial.fact_of_negative_is_one
[       OK ] calc_factorial.fact_of_negative_is_one (0 ms)
[ RUN      ] calc_factorial.fact_of_5_is_120
[       OK ] calc_factorial.fact_of_5_is_120 (0 ms)
[----------] 3 tests from calc_factorial (0 ms total)
[----------] 2 tests from next_even_number
[ RUN      ] next_even_number.even_numbers_should_be_returned
<strong class="highlight">.../ExtremeC_examples_chapter22_1_gtests.cpp:34: Failure</strong>
<strong class="highlight">Expected equality of these values:</strong>
  <strong class="highlight">next_even_number()</strong>
    <strong class="highlight">Which is: 0</strong>
  <strong class="highlight">1</strong>
<strong class="highlight">[  FAILED  ] next_even_number.even_numbers_should_be_returned (0 ms)</strong>
[ RUN      ] next_even_number.numbers_should_rotate
[       OK ] next_even_number.numbers_should_rotate (0 ms)
[----------] 2 tests from next_even_number (0 ms total)
[----------] Global test environment tear-down
[==========] 5 tests from 2 test suites ran. (0 ms total)
[  PASSED  ] 4 tests.
[  FAILED  ] 1 test, listed below:
[  FAILED  ] next_even_number.even_numbers_should_be_returned
 1 FAILED TEST
<strong class="screen-text">$</strong></pre>
			<p class="packt_figref">Shell Box 22-9: Building and running Google Test unit tests for example 22.1 after modifying one of the test cases</p>
			<p class="normal">As you can see and exactly like CMocka, Google Test also prints out where the tests are broken and shows a<a id="_idIndexMarker1658"/> helpful report. As a final note on Google Test, it supports test fixtures but not in the same way that CMocka supports. Test fixtures should be defined in a <em class="italics">test class</em>.</p>
			<div><div><p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">For having mock objects and the mocking functionality, the <em class="italics">Google Mock</em> (or <em class="italics">gmock</em>) library can be used, but we don't cover it in this book.</p>
				</div>
			</div>
			<p class="normal">In this section, we went through two of the most well-known unit testing libraries for C. In the next part of the chapter, we dive into the topic of debugging, which is of course<a id="_idTextAnchor635"/> a necessary skill for every programmer.</p>
			<h1 id="_idParaDest-329" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor636"/>Debugging</h1>
			<p class="normal">There are situations in which one test or a group of tests fail. Also, there are times when you find a bug. <a id="_idTextAnchor637"/>In both <a id="_idIndexMarker1659"/>of these situations, there is a bug, and you need to find the root cause and fix it. This involves many sessions of debugging and going through the source code to search for the cause of the bug and planning the required fixes. But what does it mean to <em class="italics">debug</em> a piece of software?</p>
			<div><div><p class="Information-Box--PACKT-"><strong class="screen-text">Note</strong>:</p>
					<p class="Information-Box--PACKT-">It is a popularly held belief that the term "debug" originates from the days when computers were so large that real bugs (such as moths) could get caught in the system's machinery and lead to malfunctions. Therefore, some people, officially called <em class="italics">debuggers</em>, were sent into the hardware room to<a id="_idIndexMarker1660"/> remove the bugs from the equipment. See this link for more information: https://en.wikipedia.org/wiki/Debugging.</p>
				</div>
			</div>
			<p class="normal">Debugging is an investigative task to find the root cause of an observed bug by looking inside and/or outside of a program. When running a program, you usually look at it as a black box. When something is wrong with the results or something interrupts the execution, however, you need to have a deeper look inside and see how the issue is produced. This means that you have to observe the program as a white box in which everything can be seen.</p>
			<p class="normal">That's basically why we can have two different builds for a program: <em class="italics">release</em> and <em class="italics">build</em>. In release builds, the focus is on the execution and the functionality, and the program is mostly seen as a black box, but in debug builds, we can trace all the events happening and see the inside of the program as a white box. Debug builds are generally useful for development and test environments, but release builds are targeted at deployment and production environments.</p>
			<p class="normal">In order to have a debug build, all of the products of a software project, or a limited set of them, need to contain <em class="italics">debugging</em> symbols, which enable a developer to track and see the <em class="italics">stack trace</em> and the execution flow of the program. Usually, a release product (executable or libraries) is not suitable for debugging purposes because it is not transparent enough to let an observer examine the internals of a program. In <em class="italics">Chapter 4</em>, <em class="italics">Process Memory Structure</em>, and <em class="italics">Chapter 5</em>, <em class="italics">Stack and Heap</em>, we discussed how we can build C sources for debugging purposes.</p>
			<p class="normal">For debugging a program, we mainly use debuggers. Debuggers are standalone programs that attach to the target process in order to control or monitor it. While debuggers are our main tools for our investigation when working on an issue, other debugging tools can also be used to study the memory, concurrent execution flows, or the performance of a program. We will talk about these tools in the following sections.</p>
			<p class="normal">A great portion of bugs are <em class="italics">reproducible</em>, but there are bugs that cannot be reproduced or observed in debugging sessions; this is mostly because of the <em class="italics">observer effect</em>. It says, when you want to look at the internals of a program, you alter the way it works, and it might prevent some bugs from happening. These sorts of issues are disastrous, and they are usually very hard to fix because you cannot use your debugging tools to investigate the root cause of the <a id="_idIndexMarker1661"/>problem!</p>
			<p class="normal">Some threading bugs in high-performance environments can be categorized in this group.</p>
			<p class="normal">In the following sections, we are going to talk about different categories of bugs. Then, we introduce the tools that we use in modern C/C++<a id="_idTextAnchor638"/> development in order to investigate bugs.</p>
			<h2 id="_idParaDest-330" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor639"/>Bug categories</h2>
			<p class="normal">There can be thousands of bugs reported in a piece of software throughout the years that it is in use by a customer. But if you look at the types of these bugs, they are not many. Next, you can see a list of bug categories<a id="_idIndexMarker1662"/> that we think are important  and require special skills to deal with. For sure, this list is not complete and there can be other types of bugs that we are missing:</p>
			<ul>
				<li class="list"><strong class="bold">Logical bugs</strong>: In order to investigate these bugs, you need to know the code and the execution <a id="_idIndexMarker1663"/>flow of the code. To see the actual<a id="_idIndexMarker1664"/> execution flow of a program, a debugger should be attached to a running process. Only then, the execution flow can be <em class="italics">traced</em> and analyzed. <em class="italics">Execution logs</em> can also be used when debugging a program, especially when debugging symbols are not available in the final binaries or a debugger cannot be used to attach to an actual running instance of the program.</li>
				<li class="list"><strong class="bold">Memory bugs</strong>: These bugs are memory related. They occur usually because of dangling<a id="_idIndexMarker1665"/> pointers, buffer overflows, double frees, and so on. These bugs should be investigated using a <em class="italics">memory profiler</em>, which acts as a<a id="_idIndexMarker1666"/> debugging tool for observing and monitoring memory.</li>
				<li class="list"><strong class="bold">Concurrency bugs</strong>: Multi-processing and multithreading programs have always been the <a id="_idIndexMarker1667"/>birthplace of some of the hardest-to-solve bugs<a id="_idIndexMarker1668"/> found in the software industry. You need special tools like <em class="italics">thread sanitizers</em> in order to detect particularly difficult issues such as race conditions and data races.</li>
				<li class="list"><strong class="bold">Performance bugs</strong>: New developments may result in <em class="italics">performance degradation</em> or performance bugs. These bugs should be investigated using further and more<a id="_idIndexMarker1669"/> focused testing and even debugging. Execution logs, which contain annotated historical data for the previous<a id="_idIndexMarker1670"/> executions, can be useful in order to find the exact change or changes that have initiated the degradation.</li>
			</ul>
			<p class="normal">In the following sections, we are going to talk a<a id="_idTextAnchor640"/>bout various tools introduced in the preceding list.</p>
			<h2 id="_idParaDest-331" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor641"/>Debuggers</h2>
			<p class="normal">We have talked about debuggers, especially <code class="Code-In-Text--PACKT-">gdb</code>, in <em class="italics">Chapter 4</em>, <em class="italics">Process Memory Structure</em>, and we used it to see inside<a id="_idIndexMarker1671"/> a process's memory. In this section, we are going to give debuggers a second look and describe their role in daily software development. The following is a list of common features provided by most modern debuggers:</p>
			<ul>
				<li class="list">A debugger is a program, and like all other programs, it runs as a process. The debugger process can<a id="_idIndexMarker1672"/> attach to another process given the target process ID.</li>
				<li class="list">A debugger can control the execution of the instructions in the target process after a successful attachment; therefore, the user is able to pause and continue the flow of the execution in the target process, using an interactive debugging session.</li>
				<li class="list">Debuggers can see inside the protected memory of a process. They can also modify the contents, therefore a developer can run the same group of instructions while the memory content is being changed deliberately.</li>
				<li class="list">Almost all of the known debuggers, if the debugging symbols are provided while compiling the sources to relocatable object files, can trace back the instructions to the source code. In other words, when you pause on an instruction, you can go to its corresponding line of code in the source file.</li>
				<li class="list">If the debugging symbols are not provided in the target object file, the debugger can show the disassembly code of a target instruction, which can still be useful.</li>
				<li class="list">Some debuggers are language-specific, but most of them are not. <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>) languages<a id="_idIndexMarker1673"/> such as Java, Scala, and Groovy have to use JVM debuggers in order to see and control the internals of a JVM instance.</li>
				<li class="list">Interpreted languages like Python have also their own debuggers, which can be used to pause and control a script. While the low-level debuggers like <code class="Code-In-Text--PACKT-">gdb</code> are still usable for <a id="_idIndexMarker1674"/>JVM or scripting languages, they try to debug the JVM or interpreter processes instead of the executing Java bytecode or Python script.</li>
			</ul>
			<p class="normal">A list of the debuggers can <a id="_idIndexMarker1675"/>be found on Wikipedia as part of the following link: https://en.wikipedia.org/wiki/List_of_debuggers. From this list, the following debuggers are eye-catching:</p>
			<ol>
				<li class="list"><strong class="bold">Advanced Debugger</strong> (<strong class="bold">adb</strong>): The default<a id="_idIndexMarker1676"/> Unix debugger. It has different implementations based on the actual Unix implementation. It has been the default debugger on Solaris Unix.</li>
				<li class="list"><strong class="bold">GNU Debugger</strong> (<strong class="bold">gdb</strong>): The GNU version of the Unix debugger, which is the default debugger on<a id="_idIndexMarker1677"/> many Unix-like operating systems including Linux.</li>
				<li class="list"><strong class="bold">LLDB</strong>: A debugger mainly<a id="_idIndexMarker1678"/> designed for debugging object files produced by LLVM compilers.</li>
				<li class="list"><strong class="bold">Python Debugger</strong>: Used in<a id="_idIndexMarker1679"/> Python to debug Python script.</li>
				<li class="list"><strong class="bold">Java Platform Debugger Architecture</strong> (<strong class="bold">JPDA</strong>): This one is not a debugger, but it is an API designed <a id="_idIndexMarker1680"/>for debugging programs running inside a JVM instance.</li>
				<li class="list"><strong class="bold">OllyDbg</strong>: A debugger<a id="_idIndexMarker1681"/> and disassembler used in Microsoft Windows for debugging GUI applications.</li>
			</ol>
			<ol>
				<li class="list" value="7"><strong class="bold">Microsoft Visual Studio Debugger</strong>: The main <a id="_idIndexMarker1682"/>debugger used by Microsoft Visual Studio.</li>
			</ol>
			<p class="normal">In addition to <code class="Code-In-Text--PACKT-">gdb</code>, one can use <code class="Code-In-Text--PACKT-">cgdb</code>. The <code class="Code-In-Text--PACKT-">cgdb</code> program shows a terminal code editor next to the <code class="Code-In-Text--PACKT-">gdb</code> interactive shell that allows you to move between the code lines easier.</p>
			<p class="normal">In this section, we discussed <a id="_idIndexMarker1683"/>debuggers as the main tools for investigating an issue. In the next section, we will be talking about memory<a id="_idTextAnchor642"/> profilers, which are vital for investigating memory-related bugs.</p>
			<h2 id="_idParaDest-332" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor643"/>Memory checkers</h2>
			<p class="normal">Sometimes when you encounter a memory-related bug or a crash, a debugger alone cannot help much. You need another<a id="_idIndexMarker1684"/> tool that can detect the memory corruptions and invalid read or writes to the memory cells. The tool you need is a <em class="italics">memory checker</em> or a <em class="italics">memory profiler</em>. It could be part of a debugger, but it is usually provided as a separate program and the way it detects memory misbehaviors is different from a debugger.</p>
			<p class="normal">We usually can expect the following features from a memory checker:</p>
			<ul>
				<li class="list">Reporting the total<a id="_idIndexMarker1685"/> amount of allocated memory, freed memory, used static memory, Heap allocations, Stack allocations, and so on.</li>
				<li class="list">Memory-leak detection, which can be considered as the most important feature that a memory checker provides.</li>
				<li class="list">Detection of invalid memory read/write operations like out-of-bound access regarding buffers and arrays, writes to an already freed memory region, and so on.</li>
				<li class="list">Detection of a <em class="italics">double free</em> issue. It happens when a program tries to free an already freed memory region.</li>
			</ul>
			<p class="normal">So far, we have seen memory checkers like <em class="italics">Memcheck</em> (one of the Valgrind's tools) in some of the chapters, particularly <em class="italics">Chapter 5</em>, <em class="italics">Stack and Heap</em>. We have also discussed the different types of memory checkers and memory profilers in chapter 5. Here, we want to explain them again, and give more details about each of them.</p>
			<p class="normal">Memory checkers all do the same thing, but the underlying technique they use to monitor memory operations can be different. Therefore, we group them based on the technique they use:</p>
			<ol>
				<li class="list" value="1"><strong class="bold">Compile-time overriding</strong>: For using a memory checker employing this technique, you need to make some, usually slight, changes to your source code like including a header file from the memory checker library. Then, you need to compile your<a id="_idIndexMarker1686"/> binaries again. Sometimes, it is necessary to link the binaries against the libraries provided by the memory checker. The advantage is that the performance drop of the executing binary is less than the other techniques, but the disadvantage is that you need to recompile <a id="_idIndexMarker1687"/>your binaries. <strong class="bold">LLVM AddressSanitizer</strong> (<strong class="bold">ASan</strong>), Memwatch, Dmalloc, and Mtrace are memory profilers using this technique.</li>
				<li class="list"><strong class="bold">Link-time overriding</strong>: This group of memory checkers is like the previous group of memory checkers, but the difference is that you don't need to change your source code. Instead, you only have to link the resulting binaries with the provided libraries from the memory checker and no change is made to the source code. The <em class="italics">heap checker</em> utility in <em class="italics">gperftools</em> can be used as a link-time memory checker.</li>
				<li class="list"><strong class="bold">Runtime interception</strong>: A memory checker using this technique sits between the program and the OS and tries to intercept and track all memory-related operations and report whenever a misbehavior or invalid access is seen. It also can give leak reports based on the total allocations and freed memory blocks. The main advantage of using this technique is that you don't need to recompile or relink your program in order to use the memory checker. The big <a id="_idIndexMarker1688"/>disadvantage is the significant overhead it introduces to the execution of the program. Also, the memory footprint would be much higher than when running the program without the memory checker. This is definitely not an ideal environment to debug high-performance and embedded programs. The Memcheck tool in Valgrind can be used as a runtime interceptor memory checker. These memory profilers should be used with a debug build of the code base.</li>
			</ol>
			<ol>
				<li class="list" value="4"><strong class="bold">Preloading libraries</strong>: Some memory checkers use <em class="italics">inter-positioning</em> in order to wrap standard memory functions. Therefore, by preloading the memory checker's shared libraries using the <code class="Code-In-Text--PACKT-">LD_PRELOAD</code> environment variable, the program can use the wrapper functions and the memory checker can intercept the calls to underlying standard memory functions. The <em class="italics">heap checker</em> utility in <em class="italics">gperftools</em> can be used like this.</li>
			</ol>
			<p class="normal">Usually, it is not enough to use a specific tool for all memory issues because each of them has its own advantages and<a id="_idIndexMarker1689"/> disadvantages, which make that tool specific to a certain context.</p>
			<p class="normal">In this section, we went through the available memory profilers and categorized them based on the technique they use to record memory allocations and deallocati<a id="_idTextAnchor644"/>ons. In the next section, we are going to talk about thread sanitizers.</p>
			<h2 id="_idParaDest-333" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor645"/>Thread debuggers</h2>
			<p class="normal"><em class="italics">Thread sanitizers</em> or <em class="italics">thread debuggers</em> are programs that are used to debug multithreading programs to find concurrency-related issues while the program is running. Some of the<a id="_idIndexMarker1690"/> issues they can find are as follows:</p>
			<ul>
				<li class="list">Data races, and the exact places in different threads where the read/write operations have caused the data race</li>
				<li class="list">Misusing the threading API, especially POSIX threading API in POSIX-compliant systems</li>
				<li class="list">Possible deadlocks</li>
				<li class="list">Lock ordering issues</li>
			</ul>
			<p class="normal">Both thread debuggers and memory checkers can detect issues as <em class="italics">false positives</em>. In other words, they may find and report some issues but after being investigated, it becomes clear that they<a id="_idIndexMarker1691"/> are not issues. This really depends on the technique these libraries use for tracking the events, and making a final decision about that event.</p>
			<p class="normal">In the following list, you can find a number<a id="_idIndexMarker1692"/> of well-known available thread debuggers:</p>
			<ul>
				<li class="list"><strong class="bold">Helgrind</strong> (<strong class="bold">from Valgrind</strong>): It is another tool inside Valgrind mainly used for thread debugging. DRD is<a id="_idIndexMarker1693"/> also another thread<a id="_idIndexMarker1694"/> debugger as part of the Valgri<a href="http://valgrind.org/docs/manual/hg-manual.html">nd toolkit. The list of features and differenc</a>es ca<a href="http://valgrind.org/docs/manual/drd-manual.html">n be seen in these links: http://valgrind.org/d</a>ocs/manual/hg-manual.html and http://valgrind.org/docs/manual/drd-manual.html. Like all other tools from<a id="_idIndexMarker1695"/> Valgrind, using Helgrind doesn't need you to modify your source. For running Helgrind, you need to run the command <code class="Code-In-Text--PACKT-">valgrind --tool=helgrind [path-to-executable]</code>.</li>
				<li class="list"><strong class="bold">Intel Inspector</strong>: This successor to <em class="italics">Intel Thread Checker</em> performs an analysis of threading errors and memory <a id="_idIndexMarker1696"/>issues. Therefore, it is a thread debugger as well as a memory <a id="_idIndexMarker1697"/>checker. It is not free like Valgrind, and proper licenses must be purchased in order to use the tool.</li>
				<li class="list"><strong class="bold">LLVM ThreadSanitizer</strong> (<strong class="bold">TSan</strong>): This is part of the LLVM toolkit, and it comes with LLVM AddressSanitizer, described in the previous section. Some slight compile-time<a id="_idIndexMarker1698"/> modifications <a id="_idIndexMarker1699"/>are needed in order to use the debugger and the code base should be recompiled.</li>
			</ul>
			<p class="normal">In this section, we discussed thread debuggers and we introduced some of the available thread debuggers in order to debug threading issues. In the next section, we prov<a id="_idTextAnchor646"/>ide the programs and toolkits that are used to tune the performance of a program.</p>
			<h2 id="_idParaDest-334" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor647"/>Performance profilers</h2>
			<p class="normal">Sometimes the results of a group of non-functional tests indicate a degradation in performance. There are<a id="_idIndexMarker1700"/> specialized tools for investigating the cause of the degradation. In this section, we are going to have a quick look at the tools which can be used to analyze performance and find performance bottlenecks.</p>
			<p class="normal">These performance debuggers usually offer a subset of the following features:</p>
			<ul>
				<li class="list">Gather statistics <a id="_idIndexMarker1701"/>about every single function call</li>
				<li class="list">Provide a <em class="italics">function call graph</em> used to trace function calls</li>
				<li class="list">Gather memory-related statistics for each function call</li>
				<li class="list">Gather lock contention statistics</li>
				<li class="list">Gather memory allocation/deallocation statistics</li>
				<li class="list">Cache analysis, giving cache usage statistics and showing parts of the code that are not cache-friendly</li>
				<li class="list">Gather statistics about threading and synchronization events</li>
			</ul>
			<p class="normal">The following is a list of the most well-known programs and toolkits that can be used for performance profiling:</p>
			<ul>
				<li class="list"><strong class="bold">Google Performance Tools</strong> (<strong class="bold">gperftools</strong>): This is actually a performant <code class="Code-In-Text--PACKT-">malloc</code> implementation, but as<a id="_idIndexMarker1702"/> it says on its home page, it provides some performance analytics tools like <em class="italics">heap checker</em>, which was introduced in the previous sections as a memory profiler. It should be linked with the final binary in order to be usable.</li>
				<li class="list"><strong class="bold">Callgrind</strong> (<strong class="bold">as part of Valgrind</strong>): Mainly gathers statistics about the function calls and the caller/callee relationship between two functions. There is no need to change the source code or link the final binaries and it can be used on the fly, with a debug build, of course.</li>
				<li class="list"><strong class="bold">Intel VTune</strong>: This is a performance profiling suite from Intel that is a complete set of all the feature<a id="_idTextAnchor648"/>s given in the preceding list. Proper licenses must be purchased in order to use it.</li>
			</ul>
			<h1 id="_idParaDest-335" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor649"/>Summary</h1>
			<p class="normal">This chapter was about unit testing and debugging C programs. As a summary, in this chapter:</p>
			<ul>
				<li class="list">We talked about testing, and why it is important to us as software engineers and development teams.</li>
				<li class="list">We also discussed the different levels of testing like unit testing, integration testing, and system testing.</li>
				<li class="list">Functional and non-functional testing were also covered.</li>
				<li class="list">Regression testing was explained.</li>
				<li class="list">CMocka and Google Test, as two well-known testing libraries for C, were explored and some examples were given.</li>
				<li class="list">We talked about debugging and various types of bugs.</li>
				<li class="list">We discussed debuggers, memory profilers, thread debuggers, and performance debuggers which can help us to have a more successful investigation while working on a bug.</li>
			</ul>
			<p class="normal">The next chapter is about the <em class="italics">build systems</em> available for C projects. We will discuss what a build system is and what features it can bring in, which will eventually help us to automate the process of building a huge C project.</p>
		</div>
</body></html>