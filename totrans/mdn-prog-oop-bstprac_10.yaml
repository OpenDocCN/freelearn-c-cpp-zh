- en: '*Chapter 8*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The amount of documentation produced as part of a software project varies dramatically.
    Before digging in to when and how it's appropriate to document your code, I'll
    first define how I'm using the term.
  prefs: []
  type: TYPE_NORMAL
- en: 'Documentation in the context of this chapter means things that are produced
    to help other developers understand the software product and code, but that aren''t
    the executable code or any of the other resources that go into the product itself.
    Comments in the code, not being executable, are part of the documentation. Unit
    tests, while executable, don''t go into the product—they *would* be documentation,
    except that I cover automated testing in *Chapter 5, Coding Practices*. UML diagrams,
    developer wikis, commit messages, descriptions in bug reports, whiteboard meetings:
    these all fulfil the goal of explaining to other developers – not to the computer
    – what the code does, how, and why.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, documentation prepared for other stakeholders, like user
    manuals, online help, and marketing material for your users, or project schedules
    and overviews for managers, will not be considered here. That's all important
    too, and if you need to produce it then you need to do a good job of it. But charity
    begins at home and saving someone time by helping them understand the code they're
    working on is definitely a charitable act.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation Is More Useful Than You Might Think
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common reason given for not documenting code is that the *source code is accurate
    documentation*—[http://www.codinghorror.com/blog/2012/04/learn-to-read-the-source-luke.html](http://www.codinghorror.com/blog/2012/04/learn-to-read-the-source-luke.html);
    that, while documentation can be created with errors in it or can become inaccurate
    as the software changes, the source is guaranteed to be both an exactly accurate
    *and* exactly precise description of what the software does.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you assume that framework and compiler bugs don''t exist, then this idea
    is correct: the source *is* complete and exact documentation of the software''s
    behavior. The problem is, it''s not always the most appropriate documentation
    to read.'
  prefs: []
  type: TYPE_NORMAL
- en: Sure, source code is entirely accurate, but it's also at the lowest possible
    level of abstraction. If you've just been brought onto a project and need to get
    to grips with the unfamiliar software, reading each operation in sequence (once
    you've even worked out the correct sequence) is not the easiest way to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you leave this point aside, there are still problems with using source
    code as your only source of information about the software. It does indeed tell
    you exactly *what* the product does. Given a bit of time studying, you can discover
    *how* it does it, too. But will the programming language instructions tell you
    *why* the software does what it does? Is that weird `if` statement there to fix
    a bug reported by a customer? Maybe it's there to work around a problem in the
    APIs? Maybe the original developer just couldn't work out a different way to solve
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: So, good documentation should tell you *why* the code does what it does, and
    also let you quickly discover *how*. It should provide the context at the expense
    of the details, whereas the source provides all of the details at the expense
    of making the context hard to discover. In other words, where the source code
    represents an exact plan to the virtual world you're creating, your documentation
    should be the **tourist's guide—**[http://www.infoq.com/presentations/The-Frustrated-Architect](http://www.infoq.com/presentations/The-Frustrated-Architect)
    (This idea was first presented, to my knowledge, by *Simon Brown*—[http://www.codingthearchitecture.com](http://www.codingthearchitecture.com)),
    with maps, recommendations of places to go (and to avoid), and information about
    world history.
  prefs: []
  type: TYPE_NORMAL
- en: The Up-To-Dateness Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The other primary complaint about creating documentation other than source code
    is that, unless the docs are maintained alongside the source, they'll quickly
    go out of date; that reading documentation that's obsolete is worse than reading
    no documentation; and that effort that doesn't go into working code is effort
    wasted.
  prefs: []
  type: TYPE_NORMAL
- en: I'll address the second point first. The point of producing *any* form of developer
    documentation is to make it easier for developers to work with the software. Therefore,
    the cost of creating the documentation should really be weighed against the *opportunity
    cost* of not producing it. If the effort saved by letting developers get straight
    on with their work is greater than the time spent creating and maintaining the
    documentation, then it's worth doing. Conversely, if the trade-off doesn't work
    out, you need to decide whether to give up on that form of documentation for something
    more valuable or find a quicker way to produce it.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what about the other issue – that obsolete docs are worse than no docs?
    There''s some truth to that, in that being led in the wrong direction won''t help
    someone find their way. It''ll probably take much longer than you think, though,
    for this to become important. Remember that the documentation captures the high-level
    features: why (and to some extent, how) the code does what it does. Imagine you''ve
    got some documentation that is, whatever its completeness, current. Your very
    next commit isn''t likely to change the frameworks used by your product, or the
    type of database it connects to, or even how it authenticates to a remote component.
    The product, at a high level, remains the same.'
  prefs: []
  type: TYPE_NORMAL
- en: Just as city guides are still useful if a handful of shops or restaurants change
    what they offer, the tourist guide to your code can still be helpful when some
    of the methods have changed their behavior a little. The risk that documentation
    really is uselessly out of date is one that plays out over years, not days.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically Generated Documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I talked in the last section about an economic trade-off associated with producing
    documentation: whether the cost of production is lower than the opportunity cost
    of not having that documentation available later. The balance can be tipped in
    favor of producing documentation in two ways: either by decreasing the cost of
    production or by increasing the value of the documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The automatic generation of documentation from code—often called *reverse engineering*
    the documentation—is a tactic used to drive down the cost of production. The idea
    is simple: if developers can always create the docs at a moment''s notice from
    the source code, they can always avail themselves of up-to-the-minute descriptions
    of how that code works.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reverse engineering tools, which usually produce UML diagrams, a particular
    format of documentation discussed later in the chapter (To be clear, I''m not
    talking about tools that extract documentation embedded in code comments; you
    still have to write that form of documentation yourself), are good at providing
    high-level overviews of a project with some or all of the details elided. As an
    example, given a class definition such as a `.java` class or Objective-C `.h`
    and `.m` files, a reverse-engineering tool can highlight just the API methods
    and properties, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15099_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: A UML class diagram'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: They say there isn't any such thing as a free lunch (some people say TANSTAAFL),
    and this is correct. On the one hand, it costs almost nothing to produce that
    class diagram. If you understand UML class diagrams (You also need to understand
    how I've chosen to bend the UML to make it better at representing Objective-C
    – the U stands for **Unified**, not **Universal**), it certainly gives a better
    overview of the class's API than diving through the source code and picking out
    all the methods. But because the diagram was produced from the source, and the
    source doesn't tell us *why* it is the way it is, this diagram can't enlighten
    its readers as to the whys behind this class.
  prefs: []
  type: TYPE_NORMAL
- en: Why does the API use delegate callbacks in one place and block callbacks elsewhere?
    Why use `NSURLConnection` rather than another class for downloading the content?
    Why are some of the instance variables protected, rather than private? You can't
    tell from this diagram.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you don't get much of an idea of *how*. Does it matter in what
    order the methods are called? Is it OK to call the cancellation method when nothing's
    in progress? Can the delegate property be `nil`? The diagram doesn't say.
  prefs: []
  type: TYPE_NORMAL
- en: So, yes, the automatic documentation was cheap. It removed information that
    was in the code but didn't provide anything additional. Having that brief overview
    is useful but it's unlikely that reverse-engineered documentation will solve all
    of your problems.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis Paralysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Taking what you learned about generated documentation, it might be tempting
    to turn the controls the other way round. If documentation with zero input effort
    doesn't provide much additional value, then maybe the more you increase the effort
    spent on creating documentation, the more useful it becomes.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps, to a point, this is true. However, the incremental value of adding
    documentation is asymptotic. In fact, no – it's worse than that. Create too much
    documentation and people can't even work out how to use *that* without some guide
    – some meta-documentation. Shovel too much in and it becomes harder to use the
    docs than if they didn't exist at all.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that **analysis paralysis** (http://c2.com/cgi/wiki?AnalysisParalysis)
    isn't *directly* related to writing documentation; it's actually a flawed design
    methods. The interaction with docs comes when you dig into the problem. Analysis
    paralysis occurs when you're afraid to move away from designing a solution toward
    building it. Have you thought of all the edge cases? Is every exceptional condition
    handled? Is there a use case you haven't thought of? You don't know—and you don't
    want to start building until you find out.
  prefs: []
  type: TYPE_NORMAL
- en: Polishing your architecture documentation or class diagram is basically a complete
    waste of time. The best way you can find these edge cases is by building the thing
    and seeing what doesn't work—especially if you're writing unit tests to cover
    the corners of the API. You'll discover that a use case is missing by giving the
    software to your customer.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, analysis paralysis, then, isn''t a problem that falls out of creating documentation;
    it occurs when you *focus* on the documentation. Remember, at the beginning of
    the chapter, I said the docs were there to support the development of the code
    by helping the programmers. Your goal is your product: the thing your customers
    want to be using.'
  prefs: []
  type: TYPE_NORMAL
- en: How to Document
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first couple of sections in this chapter were about the *whys* of documenting,
    what the benefits are, and why you might be in trouble if you do too little or
    too much. Now it's time to discuss the *how*, some of the forms of documentation
    that exist, how they can be useful (or otherwise), and how to go about making
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Coding Standards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most organizations with more than a couple of developers working together have
    a style guide or coding standard. This document explains the minutiae of writing
    code to create a "company style": where to put the brackets, how to name variables,
    how many spaces to indent by, and so on. If you haven''t seen one before, the
    **GNU coding standard**—[http://www.gnu.org/prep/standards/standards.html](http://www.gnu.org/prep/standards/standards.html)
    is very comprehensive. Indeed, one company I worked at required their code to
    conform to the GNU standard rather than writing their own: it already existed,
    covered most issues, and was easy to conform to.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Coding standards are great for ensuring that developers new to the project
    will write consistent code—particularly very novice programmers who may not yet
    appreciate the value of a single approach to layout, variable and method naming,
    and the like. (The value is that you''re not surprised by the names of the variables,
    placement of expressions, and so on. The organization of the code gets out of
    the way so you can focus on the meaning of the code – perhaps in addition to why,
    how, and what, I should''ve added *where*.) For developers who are comfortable
    with the language they''re using and its idioms, a coding standards document is
    a waste of time: they''ll be able to *see* how you lay out your brackets from
    the code; they''ll be able to adapt to your house style automatically, or at the
    very least configure their IDE to do it for them. As Herb Sutter and Alexei Alexandrescu
    put it in C++ Coding Standards:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Issues that are really just personal taste and don''t affect correctness or
    readability don''t belong in a coding standard. Any professional programmer can
    easily read and write code that is formatted a little differently than they''re
    used to.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, many coding standards documents do not progress beyond those superficial
    features.
  prefs: []
  type: TYPE_NORMAL
- en: The parts of a coding standard that don't specifically describe how to lay out
    code are not useful. They're busy work for people who want to be in control of
    what other people are writing. Telling a developer "ensure all exceptions are
    caught" or "handle all errors" is not something that they'll take to heart unless
    it's part of how they work anyway. If what you want to do is to ensure programmers
    are catching exceptions or handling errors, then you need to find those who don't
    and mentor them on making it part of how they think about their work. Writing
    an edict in some document handed to them on day one isn't going to stay with them,
    even into day two.
  prefs: []
  type: TYPE_NORMAL
- en: An experienced developer who hasn't yet learned to handle all errors won't start
    just because a wiki page tells them to. An experienced developer who *has* learned
    to handle all errors, except the one they don't know about, won't discover that
    error through reading a document on coding standards. A novice developer who doesn't
    know how the error conditions arise is left none the wiser.
  prefs: []
  type: TYPE_NORMAL
- en: 'High-level goals such as "handle all errors," "log all assertion failures"
    (Which is probably the entry after "assert all preconditions and postconditions"),
    and so on are great for code review checklists. They''re even *better* for automated
    code analysis rules. They don''t belong in standards documents: no one will make
    those things a "standard" just because they read a bullet point demanding them.'
  prefs: []
  type: TYPE_NORMAL
- en: Coding Standards And Me
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As previously mentioned, I've worked at a company that used the GNU standards.
    I've also created coding standards for a developer team, at a time when all team
    members (myself included) were inexperienced at the language we were using.
  prefs: []
  type: TYPE_NORMAL
- en: In the last 4 years or so, despite working for and contracting at a number of
    different companies, none has had documented coding standards. I haven't really
    missed it – the "standard" layout becomes "whatever the IDE does out of the box,"
    and everything else is done by automated or manual review.
  prefs: []
  type: TYPE_NORMAL
- en: So, would I recommend writing a coding standard? Only if the lack of a standard
    is proving problematic. Actually, it might be just as easy—though more passive-aggressive—to
    write a pre-commit hook that reformats code before it gets into your repository.
    Some IDEs (those from JetBrains, for example) offer this feature already.
  prefs: []
  type: TYPE_NORMAL
- en: Code Comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a couple of platitudes that get trotted out whenever comments are
    mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Real programmers don''t comment their code. If it was hard to write, it should
    be hard to understand and even harder to modify (from* **Real Programmers Don''t
    Write Specs**—[http://ifaq.wap.org/computers/realprogrammers.html](http://ifaq.wap.org/computers/realprogrammers.html))'
  prefs: []
  type: TYPE_NORMAL
- en: '*Any code should be self-documenting.* (found all over the internet; in this
    case, on **Stack Overflow**—[http://stackoverflow.com/questions/209015/what-is-self-documenting-code-and-can-it-replace-well-documented-code](http://stackoverflow.com/questions/209015/what-is-self-documenting-code-and-can-it-replace-well-documented-code))'
  prefs: []
  type: TYPE_NORMAL
- en: It should be obvious that the first quote is a joke, and if it isn't, read the
    referenced article. The second quote is not a joke, just sorely misguided.
  prefs: []
  type: TYPE_NORMAL
- en: At the time that you write any code, you're *in the zone*, mentally speaking.
    You're likely focused on that problem to the exclusion of all (or at least to
    the exclusion of many) others. You've been working on that particular problem
    for a short while, and on problems in that domain for quite a bit longer. So,
    of *course*, you don't think the code needs any comments. When you read the code,
    it fires off all those synaptic connections that remind you why you wrote it and
    what it's supposed to be doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nobody else has the benefit of those connections. Even you, when you come back
    to the code later, do not have that benefit: memories that are not reinforced
    will *decay over time*—[http://www.simplypsychology.org/forgetting.html](http://www.simplypsychology.org/forgetting.html).
    According to that link, memories fade from long-term recollection if they aren''t
    consolidated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, comments are among the best form of documentation you can
    create because they provide a connection between two distinct forms of information.
    The information is the code and the prose comment, and the connection is proximate:
    you see both in the same place (that is, the source code editor in your IDE).
    If one doesn''t remind you what you were thinking about when you produced it,
    its connection with the other will trigger some memories.'
  prefs: []
  type: TYPE_NORMAL
- en: Recalling (pun somewhat intentional) the discussion from the beginning of this
    chapter, code tells you very quickly *what* software does, and with a little work
    tells you *how* it does it. There's no need for comments to retread that ground—you're
    already looking at something that gives you that information. (A quick reminder
    of how the code works can save an amount of reading, though. Or, as Fraser Hess
    put it by paraphrasing Frank Westheimer, *A month in the lab can save an hour
    in the library*— [https://twitter.com/fraserhess/status/299261317892685824](https://twitter.com/fraserhess/status/299261317892685824).)
    Comments should therefore focus on *why*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many people are put off comments by reading code that looks something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When you're experienced enough at programming to know what the various operators
    in your language do, a comment like that is redundant line noise. If all comments
    were similar to this example, then there would be little point in competent developers
    reading comments—a situation in which it would indeed be hard to justify them
    writing comments. Obviously, not all comments *are* like that; indeed, the ones
    you write don't need to be.
  prefs: []
  type: TYPE_NORMAL
- en: If you find it hard to believe that anyone could ever need reminding what the
    `++` operator does, you probably don't remember learning programming, and haven't
    had to teach it either. The **Teaching H.E. Programming blog**—[http://teachingheprogramming.blogspot.co.uk](http://teachingheprogramming.blogspot.co.uk)
    is a good overview of just how hard that thing you do every day is for people
    who don't do it every day.
  prefs: []
  type: TYPE_NORMAL
- en: 'The thing is that redundant comments are simply redundant. You read them, realize
    they don''t help, and move on. This doesn''t waste much time. It''s worse to read
    comments that are mentally jarring: ones that actively stop you thinking about
    the code and make you think about the comment.'
  prefs: []
  type: TYPE_NORMAL
- en: That joke that seems really funny in your head – don't write it down. It might
    work well on Twitter or in the company chatroom, but not in a code comment. Even
    if the person reading it thinks it's funny the first time, they probably won't
    if they have to stop grokking code every day for the rest of their career while
    they read that joke over and over.
  prefs: []
  type: TYPE_NORMAL
- en: While I was writing this book, someone asked on a Q&A website whether *there's
    empirical evidence for the value of comments in code*—[http://programmers.stackexchange.com/questions/187722/are-there-any-empirical-studies-about-the-effects-of-commenting-source-code-on-s](http://programmers.stackexchange.com/questions/187722/are-there-any-empirical-studies-about-the-effects-of-commenting-source-code-on-s).
    More usefully, someone answered that question with references. One of the papers,
    **The effect of modularization and comments on program comprehension**—[http://portal.acm.org/ft_gateway.cfm?id=802534&type=pdf&coll=DL&dl=GUIDE&CFID=278950761&CFTOKEN=48982755](http://portal.acm.org/ft_gateway.cfm?id=802534&type=pdf&coll=DL&dl=GUIDE&CFID=278950761&CFTOKEN=48982755),
    is worth looking into in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Your first reaction may be to look at the date of this paper—March 1981—and
    decide that it can't possibly say anything relevant to modern programmers. But
    wait up. The article investigates how people (who haven't changed much in three
    decades) read (which also hasn't changed much) comments (written in English, which
    hasn't changed much) and code that is organized along different lines of modularity.
    Only the way we write code has changed, and really not by very much. This paper
    investigates code written in FORTRAN, a language that's still in use and not too
    dissimilar from C. It investigates code written with different approaches to modularity,
    a variation that's observed in modern code whether written using procedural or
    object-oriented languages. There's really no reason to dismiss this article based
    on age.
  prefs: []
  type: TYPE_NORMAL
- en: 'What they did was to implement a few different code solutions to one problem:
    a monolithic program, a modularized program, an over-modularized program (each
    "module" consisted of 3-15 lines), and one organized around an abstract data type.
    They produced two different versions of each; one had comments describing each
    module''s functionality and the other did not. Interestingly, to remove other
    hints as to the operation of the programs, they made all variable names nondescriptive
    and removed any formatting hints.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether this represents as good a control as, for example, using a consistent
    (meaningful) naming and formatting strategy throughout all examples would be worth
    exploring. Forty-eight programmers were each given one version of the code and
    a quiz about its operation. They summarized their results as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The comment results seem to imply that the comprehension of a program can
    be significantly improved with the addition of short phrases which summarize the
    function that a module is to perform. Contrary to the original hypothesis, it
    was concluded that comments were not significantly beneficial to logical module
    identification. Those working with the uncommented monolithic version seemed able
    to comprehend the program and understand the interaction of the parts as well
    as those working with the commented monolithic version. However, it seems that
    those working with the uncommented modularized programs found it more difficult
    to understand the function of a module and how it fit into the context of the
    program than those who were given the commented modularized versions.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This does not say "comments are good" or "comments are bad." It *does* say
    that a particular type of comment can help people to understand a modular program.
    Notice that it also says that *uncommented* modular programs are harder to understand
    than *uncommented* monolithic programs. Could this result have any relevance to
    the Dunsmore et al. study in *Chapter 5, Coding Practices*? Remember that they
    found object-oriented programs hard to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The desirable design properties that lead to a connected system of loosely
    coupled objects also produce a system where it''s difficult to discover the flow
    of execution; you can''t easily see where control goes as a result of any particular
    message.*'
  prefs: []
  type: TYPE_NORMAL
- en: Literate Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Donald Knuth took the idea of comments recalling the programmer's thought processes
    much further with his idea of **Literate Programming** ([http://www.literateprogramming.com](http://www.literateprogramming.com)).
    In a literate programming environment, programs are written as "webs" in which
    prose and code can be intermingled.
  prefs: []
  type: TYPE_NORMAL
- en: Programmers are encouraged to explain the thought processes behind the code
    they create, including the code implementation as part of the documentation. A
    hyperlinked tree of code references in the web is used to generate a source-only
    view of the web (via a tool called `tangle`), which can then be fed into the usual
    compiler or interpreter. Another tool, `weave`, converts the web into a pretty-printed
    readable document.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this hyperlinked graph is to separate the structure required
    by the programming language (for example, the classes and methods in an OOP language)
    from the structure of your thoughts. If you're thinking about two different classes
    and how they'll interact, you can write the parts of the code as you think of
    them and tell the compiler how they should be ordered later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading the web back later, the person who wrote it will remember why they
    made the decisions they did as the organization of the code matches their thought
    processes. Other readers will get insight into how the code evolved and why certain
    decisions were made: the key reasons for writing documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: I'm not sure whether literate programming is a style to adopt – I haven't yet
    built any large projects as webs. I've kicked the tires on LP tools though and
    it is a fun way to write software (but then I like writing prose anyway, as you
    can probably tell). I'm not convinced it would scale – not necessarily to large
    projects. If I'd known about CWEB when I wrote **Test-Driven iOS Development**—[http://blog.securemacprogramming.com/2012/04/test-driven-ios-development/](http://blog.securemacprogramming.com/2012/04/test-driven-ios-development/),
    I would have got it done quicker and with fewer errors. When the authors of **The
    Pragmatic Programmer**—[http://pragprog.com/the-pragmatic-programmer/](http://pragprog.com/the-pragmatic-programmer/)
    wrote that book, they effectively re-implemented bits of LP to keep their manuscript
    in sync with their code.
  prefs: []
  type: TYPE_NORMAL
- en: The scaling I wonder about is scaling to multiple developers. If you find reading
    someone else's code style irksome, then wait until you have to read their unproofed
    prose. Of course, there's one way to find out.
  prefs: []
  type: TYPE_NORMAL
- en: Comment Documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While literate programming webs focus on the structure of your thoughts and
    documentation, letting the code fit into that flow, many other tools exist that
    retain the code's structure but extract and pretty-print comments into hyperlinked
    API documentation. (Doesn't comment documentation come under "comments," discussed
    above? Not precisely, as the formality and intention are very different.)
  prefs: []
  type: TYPE_NORMAL
- en: These tools—including Doxygen, Headerdoc, and friends—retain the proximity of
    the code with its documentation. As you're making changes to a method, you can
    see that its comment is right above, inviting an update to remain consistent.
  prefs: []
  type: TYPE_NORMAL
- en: I find it helpful to produce comment documentation for classes and interfaces
    that I believe other people are going to use. I don't normally generate pretty
    output, but that's something people can do if they want. I certainly appreciate
    that option where it exists and use the formatted documentation for another programmers'
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Some static analysis tools, notably Microsoft's, warn about undocumented methods,
    classes, and fields. This leads to comments for the sake of their presence, without
    necessarily leading to a better standard of documentation. Well-formatted comments
    explaining that a method's purpose is "banana" and its return value is "banana"
    are rife.
  prefs: []
  type: TYPE_NORMAL
- en: Much of what is specified in comment documentation often includes restrictions
    on input values to methods ("the `index` argument must be greater than 0 but less
    than `count`"), when to call them ("it is an error to call this method before
    you have called `configure()`"), or expectations about the return value ("the
    object returned will have a `size` less than `2*count`"). These are candidates
    for being expressed as assertions (usually in addition to, rather than instead
    of, the documentation), or you could use a language that supports contracts.
  prefs: []
  type: TYPE_NORMAL
- en: Uml Diagrams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'UML is a huge topic. Several books have been written on the subject. I''m not
    even going to try to replicate all of that, so here''s the potted version, which
    also lets you draw analogies with other diagramming techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A UML diagram is a view of some aspect of your code expressed in a manner
    that conforms to the rules of the UML. Any developer that understands those rules
    will derive the same information (Provided the diagram actually expresses enough
    information to be unambiguous, of course) from the diagram.*'
  prefs: []
  type: TYPE_NORMAL
- en: This means you can consider CRC cards, data flow diagrams, and other techniques
    to be covered by this section.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to notice is that it's possible to understand UML diagrams even
    if you don't know the UML. It's just boxes and lines, though sometimes the meaning
    of "box" is more precise than "thing" and the meaning of "line" is more precise
    than "joined to this other thing." Don't be put off by the idea that it's some
    complicated language with lots of rules you need to learn. That's only true if
    you want it to be.
  prefs: []
  type: TYPE_NORMAL
- en: Diagrams like these can appear in many contexts. I usually create them as quick
    sketches, on whiteboards or with paper and pencil (or their modern equivalent
    – the iPad and stylus). In these cases, the rules are not *too* important, but
    do increase the likelihood that another reader will understand the details on
    my diagram and that I'll create the same diagram twice if documenting the same
    thing.
  prefs: []
  type: TYPE_NORMAL
- en: It may be clear that diagrams produced in this way are for the moment, not forever.
    They might be captured via an iPhone photo "just in case," but the likelihood
    is that they'll never be looked at again. There's certainly no expectation that
    they'll go into some "*Project X Artefacts*" folder to be kept indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: The more effort you put into this sort of graphic, the more likely you are to
    want to keep it around. For something like a blog post or a diagram in a book,
    I'll usually use **Omnigraffle**—[http://www.omnigroup.com/products/omnigraffle/](http://www.omnigroup.com/products/omnigraffle/)),
    **dia**—[https://live.gnome.org/Dia/](https://live.gnome.org/Dia/), or something
    else that lets me use the shapes and lines from the UML but doesn't care about
    the rules.
  prefs: []
  type: TYPE_NORMAL
- en: I have also used tools that *do* care about the rules. One company I worked
    at had a site license for **Enterprise Architect**—[http://www.sparxsystems.com.au](http://www.sparxsystems.com.au)),
    a tool that requires you to construct conforming diagrams and supports "round-trips"
    through the code. A round-trip means that it can both generate the diagram from
    the code (discussed earlier) and also generate stub code from the diagram. It
    could also respect existing code, not trampling over existing methods when adding
    new features to a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few of the other teams made use of this extensively, maintaining the design
    of their components or applications in UML and implementing the behavior in generated
    C++ or Java classes. My team couldn''t make use of it because the tool didn''t
    (and, to my knowledge, still doesn''t) support Objective-C. I therefore feel underqualified
    to talk about whether this is a good idea: my gut feeling is that it could be
    a good idea, because it forces you to think at a high level (the features exposed
    in the diagram) while designing, without getting bogged down in implementation
    details. On the other hand, different languages have different idioms and preferred
    ways of doing things, and those aren''t readily expressed in a UML model. There''s
    also some overhead associated with configuring the code generator to your team''s
    liking—you still have to *read* its code, even if you don''t have to *write* it.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation is a good thing to have, at those times when you need it. It's
    useful for telling you why and how software does what it does, when the code can
    only tell you what it does with a little bit of *how* mixed in.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining documentation incurs additional cost and carries the risk that the
    documentation and the code could become unsynchronized. There are various ways
    to document code, and the preferred trade-off between effort and benefit can be
    found by experimentation.
  prefs: []
  type: TYPE_NORMAL
