- en: '*Chapter 8*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第八章*'
- en: Documentation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档
- en: Introduction
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: The amount of documentation produced as part of a software project varies dramatically.
    Before digging in to when and how it's appropriate to document your code, I'll
    first define how I'm using the term.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 软件项目中产生的文档数量差异很大。在深入探讨何时以及如何记录你的代码之前，我首先定义一下我如何使用这个术语。
- en: 'Documentation in the context of this chapter means things that are produced
    to help other developers understand the software product and code, but that aren''t
    the executable code or any of the other resources that go into the product itself.
    Comments in the code, not being executable, are part of the documentation. Unit
    tests, while executable, don''t go into the product—they *would* be documentation,
    except that I cover automated testing in *Chapter 5, Coding Practices*. UML diagrams,
    developer wikis, commit messages, descriptions in bug reports, whiteboard meetings:
    these all fulfil the goal of explaining to other developers – not to the computer
    – what the code does, how, and why.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的上下文中，文档指的是那些旨在帮助其他开发者理解软件产品和代码，但不是可执行代码或产品本身的任何其他资源。代码中的注释，由于不是可执行的，是文档的一部分。单元测试，虽然可执行，但不包含在产品中——*它们*将是文档，除了我在*第五章，编码实践*中涵盖了自动化测试之外。UML图、开发者维基、提交信息、错误报告中的描述、白板会议：这些都有助于向其他开发者解释——而不是计算机——代码做什么，如何做，为什么这样做。
- en: On the other hand, documentation prepared for other stakeholders, like user
    manuals, online help, and marketing material for your users, or project schedules
    and overviews for managers, will not be considered here. That's all important
    too, and if you need to produce it then you need to do a good job of it. But charity
    begins at home and saving someone time by helping them understand the code they're
    working on is definitely a charitable act.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，为其他利益相关者准备的文档，如用户手册、在线帮助、为用户提供的营销材料，或者为管理者准备的进度表和概述，将不会在此处讨论。这些同样非常重要，如果你需要制作它们，那么你需要做好这项工作。但慈善始于家庭，通过帮助他们理解正在工作的代码来节省他们的时间是肯定的一种慈善行为。
- en: Documentation Is More Useful Than You Might Think
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档比你想象的更有用
- en: A common reason given for not documenting code is that the *source code is accurate
    documentation*—[http://www.codinghorror.com/blog/2012/04/learn-to-read-the-source-luke.html](http://www.codinghorror.com/blog/2012/04/learn-to-read-the-source-luke.html);
    that, while documentation can be created with errors in it or can become inaccurate
    as the software changes, the source is guaranteed to be both an exactly accurate
    *and* exactly precise description of what the software does.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 不记录代码的常见理由是*源代码本身就是准确的文档*——[http://www.codinghorror.com/blog/2012/04/learn-to-read-the-source-luke.html](http://www.codinghorror.com/blog/2012/04/learn-to-read-the-source-luke.html)；也就是说，虽然文档可能会出错或者随着软件的变化而变得不准确，但源代码保证是软件行为的精确且精确的描述。
- en: 'If you assume that framework and compiler bugs don''t exist, then this idea
    is correct: the source *is* complete and exact documentation of the software''s
    behavior. The problem is, it''s not always the most appropriate documentation
    to read.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你假设框架和编译器没有错误，那么这个想法是正确的：源代码*确实是*软件行为的完整且精确的文档。问题是，它并不总是最合适的文档来阅读。
- en: Sure, source code is entirely accurate, but it's also at the lowest possible
    level of abstraction. If you've just been brought onto a project and need to get
    to grips with the unfamiliar software, reading each operation in sequence (once
    you've even worked out the correct sequence) is not the easiest way to proceed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，源代码是完全准确的，但它也是抽象层次最低的。如果你刚刚加入一个项目并需要熟悉不熟悉的软件，按顺序阅读每个操作（一旦你甚至已经找到了正确的顺序），并不是最容易进行的方式。
- en: Even if you leave this point aside, there are still problems with using source
    code as your only source of information about the software. It does indeed tell
    you exactly *what* the product does. Given a bit of time studying, you can discover
    *how* it does it, too. But will the programming language instructions tell you
    *why* the software does what it does? Is that weird `if` statement there to fix
    a bug reported by a customer? Maybe it's there to work around a problem in the
    APIs? Maybe the original developer just couldn't work out a different way to solve
    the problem.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你忽略这一点，仅使用源代码作为了解软件的唯一信息来源也存在问题。它确实能告诉你产品**做什么**。经过一段时间的学习，你也能发现它是如何做到的。但是，编程语言指令能告诉你软件为什么这样做吗？那个奇怪的`if`语句是为了修复客户报告的bug吗？也许它是为了绕过API中的问题？也许原始开发者只是无法想出解决这个问题的其他方法。
- en: So, good documentation should tell you *why* the code does what it does, and
    also let you quickly discover *how*. It should provide the context at the expense
    of the details, whereas the source provides all of the details at the expense
    of making the context hard to discover. In other words, where the source code
    represents an exact plan to the virtual world you're creating, your documentation
    should be the **tourist's guide—**[http://www.infoq.com/presentations/The-Frustrated-Architect](http://www.infoq.com/presentations/The-Frustrated-Architect)
    (This idea was first presented, to my knowledge, by *Simon Brown*—[http://www.codingthearchitecture.com](http://www.codingthearchitecture.com)),
    with maps, recommendations of places to go (and to avoid), and information about
    world history.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，好的文档应该告诉你代码为什么这样做，同时也让你能快速发现它是如何做到的。它应该提供背景信息，而不是细节，而源代码则提供了所有细节，但背景信息难以发现。换句话说，源代码代表了你创建的虚拟世界的精确计划，而你的文档应该是**旅游指南**—[http://www.infoq.com/presentations/The-Frustrated-Architect](http://www.infoq.com/presentations/The-Frustrated-Architect)（据我所知，这个想法首先是由*Simon
    Brown*—[http://www.codingthearchitecture.com](http://www.codingthearchitecture.com)提出的），它提供了地图，推荐去哪些地方（以及避免哪些地方），以及关于世界历史的资料。
- en: The Up-To-Dateness Problem
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**时效性问题**'
- en: The other primary complaint about creating documentation other than source code
    is that, unless the docs are maintained alongside the source, they'll quickly
    go out of date; that reading documentation that's obsolete is worse than reading
    no documentation; and that effort that doesn't go into working code is effort
    wasted.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关于创建除源代码之外的文档的另一个主要抱怨是，除非文档与源代码同时维护，否则它们会很快过时；阅读过时的文档比不阅读文档更糟；而且没有投入到工作代码中的努力都是浪费。
- en: I'll address the second point first. The point of producing *any* form of developer
    documentation is to make it easier for developers to work with the software. Therefore,
    the cost of creating the documentation should really be weighed against the *opportunity
    cost* of not producing it. If the effort saved by letting developers get straight
    on with their work is greater than the time spent creating and maintaining the
    documentation, then it's worth doing. Conversely, if the trade-off doesn't work
    out, you need to decide whether to give up on that form of documentation for something
    more valuable or find a quicker way to produce it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先来谈谈第二个问题。制作**任何**形式的开发者文档的目的，是为了让开发者更容易地使用软件。因此，创建文档的成本应该真正地与不制作文档的机会成本进行权衡。如果让开发者直接开始工作的努力节省的时间大于创建和维护文档所花费的时间，那么这样做是值得的。相反，如果权衡结果不佳，你需要决定是否放弃这种形式的文档，转而寻找更有价值的东西，或者找到更快的方式去制作它。
- en: 'But what about the other issue – that obsolete docs are worse than no docs?
    There''s some truth to that, in that being led in the wrong direction won''t help
    someone find their way. It''ll probably take much longer than you think, though,
    for this to become important. Remember that the documentation captures the high-level
    features: why (and to some extent, how) the code does what it does. Imagine you''ve
    got some documentation that is, whatever its completeness, current. Your very
    next commit isn''t likely to change the frameworks used by your product, or the
    type of database it connects to, or even how it authenticates to a remote component.
    The product, at a high level, remains the same.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但其他问题又如何呢——过时的文档是否比没有文档更糟？这一点确实有道理，因为被引导到错误的方向不会帮助某人找到自己的路。然而，这个过程可能比你想象的要长得多，才会变得重要。记住，文档捕捉了高级功能：为什么（以及在一定程度上，如何）代码执行其功能。想象一下，你有一些文档，无论其完整性如何，都是最新的。你接下来的提交不太可能改变产品使用的框架，或者它连接到的数据库类型，甚至它如何对远程组件进行身份验证。从高层次来看，产品保持不变。
- en: Just as city guides are still useful if a handful of shops or restaurants change
    what they offer, the tourist guide to your code can still be helpful when some
    of the methods have changed their behavior a little. The risk that documentation
    really is uselessly out of date is one that plays out over years, not days.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 就像城市指南即使一些商店或餐厅改变了他们提供的服务仍然有用一样，你的代码旅游指南在方法有所改变时仍然可以有所帮助。文档真正过时无用的风险是一个在几年而不是几天内逐渐显现的问题。
- en: Automatically Generated Documentation
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动生成的文档
- en: 'I talked in the last section about an economic trade-off associated with producing
    documentation: whether the cost of production is lower than the opportunity cost
    of not having that documentation available later. The balance can be tipped in
    favor of producing documentation in two ways: either by decreasing the cost of
    production or by increasing the value of the documentation.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我谈到了与生成文档相关的经济权衡：生产成本是否低于没有该文档的机会成本。可以通过两种方式使文档生产的平衡倾向于生产文档：要么降低生产成本，要么提高文档的价值。
- en: 'The automatic generation of documentation from code—often called *reverse engineering*
    the documentation—is a tactic used to drive down the cost of production. The idea
    is simple: if developers can always create the docs at a moment''s notice from
    the source code, they can always avail themselves of up-to-the-minute descriptions
    of how that code works.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码自动生成文档——通常称为文档的*逆向工程*——是一种降低生产成本的策略。这个想法很简单：如果开发者可以随时从源代码中创建文档，他们就可以随时获得关于代码如何工作的最新描述。
- en: 'Reverse engineering tools, which usually produce UML diagrams, a particular
    format of documentation discussed later in the chapter (To be clear, I''m not
    talking about tools that extract documentation embedded in code comments; you
    still have to write that form of documentation yourself), are good at providing
    high-level overviews of a project with some or all of the details elided. As an
    example, given a class definition such as a `.java` class or Objective-C `.h`
    and `.m` files, a reverse-engineering tool can highlight just the API methods
    and properties, as shown in the following figure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 逆向工程工具，通常产生UML图，这是本章后面讨论的特定格式的文档（为了清楚起见，我并不是在谈论从代码注释中提取文档的工具；你仍然需要自己编写这种形式的文档），擅长提供项目的高级概述，其中省略了一些或所有细节。例如，给定一个类定义，如`.java`类或Objective-C的`.h`和`.m`文件，逆向工程工具可以突出显示API方法和属性，如下面的图所示：
- en: '![](img/B15099_08_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15099_08_01.jpg)'
- en: 'Figure 8.1: A UML class diagram'
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.1：UML类图
- en: They say there isn't any such thing as a free lunch (some people say TANSTAAFL),
    and this is correct. On the one hand, it costs almost nothing to produce that
    class diagram. If you understand UML class diagrams (You also need to understand
    how I've chosen to bend the UML to make it better at representing Objective-C
    – the U stands for **Unified**, not **Universal**), it certainly gives a better
    overview of the class's API than diving through the source code and picking out
    all the methods. But because the diagram was produced from the source, and the
    source doesn't tell us *why* it is the way it is, this diagram can't enlighten
    its readers as to the whys behind this class.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 他们说没有免费的午餐（有些人说TANSTAAFL），这是正确的。一方面，生产那个类图几乎不花任何成本。如果你理解UML类图（你还需要理解我是如何选择弯曲UML以使其更好地表示Objective-C的——U代表**统一**，而不是**通用**），它确实比深入源代码并挑选出所有方法提供了一个更好的类API概述。但由于图表是从源代码生成的，而源代码没有告诉我们*为什么*它是这样的，这个图表不能为读者阐明这个类的背后的原因。
- en: Why does the API use delegate callbacks in one place and block callbacks elsewhere?
    Why use `NSURLConnection` rather than another class for downloading the content?
    Why are some of the instance variables protected, rather than private? You can't
    tell from this diagram.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么API在一个地方使用委托回调而在另一个地方使用块回调？为什么使用`NSURLConnection`而不是其他类来下载内容？为什么一些实例变量是受保护的，而不是私有的？从这张图表中无法得知。
- en: In addition, you don't get much of an idea of *how*. Does it matter in what
    order the methods are called? Is it OK to call the cancellation method when nothing's
    in progress? Can the delegate property be `nil`? The diagram doesn't say.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你无法很好地了解*如何*。方法的调用顺序重要吗？在没有任何操作进行时调用取消方法可以吗？委托属性可以是`nil`吗？图表中没有说明。
- en: So, yes, the automatic documentation was cheap. It removed information that
    was in the code but didn't provide anything additional. Having that brief overview
    is useful but it's unlikely that reverse-engineered documentation will solve all
    of your problems.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，是的，自动生成的文档很便宜。它移除了代码中的信息，但没有提供任何额外的东西。拥有这样一个简要概述是有用的，但不太可能通过逆向工程生成的文档就能解决所有问题。
- en: Analysis Paralysis
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析瘫痪
- en: Taking what you learned about generated documentation, it might be tempting
    to turn the controls the other way round. If documentation with zero input effort
    doesn't provide much additional value, then maybe the more you increase the effort
    spent on creating documentation, the more useful it becomes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 结合你从生成的文档中学到的知识，你可能会有将控制方向反过来。如果零输入努力的文档没有提供很多额外的价值，那么也许你投入更多精力创建文档，它就会变得更有用。
- en: Perhaps, to a point, this is true. However, the incremental value of adding
    documentation is asymptotic. In fact, no – it's worse than that. Create too much
    documentation and people can't even work out how to use *that* without some guide
    – some meta-documentation. Shovel too much in and it becomes harder to use the
    docs than if they didn't exist at all.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，在某种程度上，这是真的。然而，增加文档的增量价值是渐近的。事实上，情况更糟。创建过多的文档，人们甚至无法在没有一些指南——一些元文档的情况下使用*那些*文档——如果文档根本不存在，使用起来反而更容易。
- en: Notice that **analysis paralysis** (http://c2.com/cgi/wiki?AnalysisParalysis)
    isn't *directly* related to writing documentation; it's actually a flawed design
    methods. The interaction with docs comes when you dig into the problem. Analysis
    paralysis occurs when you're afraid to move away from designing a solution toward
    building it. Have you thought of all the edge cases? Is every exceptional condition
    handled? Is there a use case you haven't thought of? You don't know—and you don't
    want to start building until you find out.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，**分析瘫痪**（http://c2.com/cgi/wiki?AnalysisParalysis）并不是*直接*与编写文档相关的；它实际上是一种有缺陷的设计方法。与文档的交互发生在你深入研究问题时。当你害怕从设计解决方案转向构建它时，就会发生分析瘫痪。你是否考虑了所有边缘情况？是否处理了每个异常条件？是否有你没有考虑到的用例？你不知道——你不想在弄清楚之前开始构建。
- en: Polishing your architecture documentation or class diagram is basically a complete
    waste of time. The best way you can find these edge cases is by building the thing
    and seeing what doesn't work—especially if you're writing unit tests to cover
    the corners of the API. You'll discover that a use case is missing by giving the
    software to your customer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 磨练你的架构文档或类图基本上是浪费时间。找到这些边缘情况的最佳方式是构建东西并看看什么不起作用——特别是如果你正在编写单元测试来覆盖API的角落。通过将软件提供给客户，你会发现缺少了一个用例。
- en: 'So, analysis paralysis, then, isn''t a problem that falls out of creating documentation;
    it occurs when you *focus* on the documentation. Remember, at the beginning of
    the chapter, I said the docs were there to support the development of the code
    by helping the programmers. Your goal is your product: the thing your customers
    want to be using.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，分析瘫痪并不是在创建文档时出现的问题；它发生在你*专注于*文档的时候。记住，在章节的开始，我说过文档的存在是为了通过帮助程序员来支持代码的开发。你的目标是你的产品：你的客户想要使用的东西。
- en: How to Document
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何编写文档
- en: The first couple of sections in this chapter were about the *whys* of documenting,
    what the benefits are, and why you might be in trouble if you do too little or
    too much. Now it's time to discuss the *how*, some of the forms of documentation
    that exist, how they can be useful (or otherwise), and how to go about making
    them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的前几节讨论了编写文档的*原因*，即其带来的好处，以及为什么如果你做得太少或太多可能会遇到麻烦。现在，我们来讨论*如何*编写文档，现有的文档形式，它们如何有用（或否则），以及如何着手编写它们。
- en: Coding Standards
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编码标准
- en: 'Most organizations with more than a couple of developers working together have
    a style guide or coding standard. This document explains the minutiae of writing
    code to create a "company style": where to put the brackets, how to name variables,
    how many spaces to indent by, and so on. If you haven''t seen one before, the
    **GNU coding standard**—[http://www.gnu.org/prep/standards/standards.html](http://www.gnu.org/prep/standards/standards.html)
    is very comprehensive. Indeed, one company I worked at required their code to
    conform to the GNU standard rather than writing their own: it already existed,
    covered most issues, and was easy to conform to.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数有超过几个开发者共同工作的组织都有一个风格指南或编码标准。这份文档解释了编写代码以创建“公司风格”的细节：括号应该放在哪里，变量应该如何命名，缩进应该用多少空格，等等。如果你以前没有见过，**GNU编码标准**——[http://www.gnu.org/prep/standards/standards.html](http://www.gnu.org/prep/standards/standards.html)非常全面。事实上，我工作过的公司要求他们的代码符合GNU标准而不是自己编写：它已经存在，涵盖了大多数问题，并且很容易遵守。
- en: 'Coding standards are great for ensuring that developers new to the project
    will write consistent code—particularly very novice programmers who may not yet
    appreciate the value of a single approach to layout, variable and method naming,
    and the like. (The value is that you''re not surprised by the names of the variables,
    placement of expressions, and so on. The organization of the code gets out of
    the way so you can focus on the meaning of the code – perhaps in addition to why,
    how, and what, I should''ve added *where*.) For developers who are comfortable
    with the language they''re using and its idioms, a coding standards document is
    a waste of time: they''ll be able to *see* how you lay out your brackets from
    the code; they''ll be able to adapt to your house style automatically, or at the
    very least configure their IDE to do it for them. As Herb Sutter and Alexei Alexandrescu
    put it in C++ Coding Standards:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 编码标准对于确保新加入项目的开发者编写一致的代码非常有用——尤其是那些可能还没有意识到单一布局、变量和方法命名等价值的新手程序员。 (其价值在于你不会对变量的名称、表达式的位置等感到惊讶。代码的组织不会妨碍你专注于代码的意义——也许除了为什么、如何、什么，我应该再加上*在哪里*。)
    对于熟悉他们使用的语言及其习惯用法的开发者来说，编码标准文档是浪费时间：他们可以从代码中*看到*你如何布局括号；他们可以自动适应你的风格，或者至少配置他们的IDE来为他们完成这项工作。正如Herb
    Sutter和Alexei Alexandrescu在《C++编码标准》中所说：
- en: '*Issues that are really just personal taste and don''t affect correctness or
    readability don''t belong in a coding standard. Any professional programmer can
    easily read and write code that is formatted a little differently than they''re
    used to.*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*那些仅仅是个人品味问题，并不影响正确性或可读性的问题不应包含在编码标准中。任何专业的程序员都能轻松阅读和编写格式略有不同但符合他们习惯的代码。*'
- en: Sadly, many coding standards documents do not progress beyond those superficial
    features.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，许多编码标准文档并没有超出那些表面的特征。
- en: The parts of a coding standard that don't specifically describe how to lay out
    code are not useful. They're busy work for people who want to be in control of
    what other people are writing. Telling a developer "ensure all exceptions are
    caught" or "handle all errors" is not something that they'll take to heart unless
    it's part of how they work anyway. If what you want to do is to ensure programmers
    are catching exceptions or handling errors, then you need to find those who don't
    and mentor them on making it part of how they think about their work. Writing
    an edict in some document handed to them on day one isn't going to stay with them,
    even into day two.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 编码规范中不具体描述如何布局代码的部分是没有用的。它们是那些想要控制别人写作的人的繁琐工作。告诉开发者“确保所有异常都被捕获”或“处理所有错误”并不是他们会放在心上的事情，除非这是他们工作的一部分。如果你想要确保程序员能够捕获异常或处理错误，那么你需要找到那些做不到的人，并指导他们将其作为他们思考工作的一部分。在第一天给他们一些文件上的命令是不够的，甚至第二天也不会记住。
- en: An experienced developer who hasn't yet learned to handle all errors won't start
    just because a wiki page tells them to. An experienced developer who *has* learned
    to handle all errors, except the one they don't know about, won't discover that
    error through reading a document on coding standards. A novice developer who doesn't
    know how the error conditions arise is left none the wiser.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经验丰富的开发者，如果还没有学会处理所有错误，仅仅因为一个维基页面告诉他们这样做，是不会开始的。一个已经学会处理所有错误（除了他们不知道的那个）的开发者，不会通过阅读编码规范文档来发现那个错误。一个不知道错误条件如何出现的初学者，仍然一无所知。
- en: 'High-level goals such as "handle all errors," "log all assertion failures"
    (Which is probably the entry after "assert all preconditions and postconditions"),
    and so on are great for code review checklists. They''re even *better* for automated
    code analysis rules. They don''t belong in standards documents: no one will make
    those things a "standard" just because they read a bullet point demanding them.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 高级目标，如“处理所有错误”、“记录所有断言失败”（这可能是“断言所有前提条件和后置条件”之后的条目），等等，对于代码审查清单来说很棒。它们对于自动代码分析规则来说甚至更好。它们不属于标准文档：没有人会仅仅因为阅读了一个要求它们的要点就把这些事情变成“标准”。
- en: Coding Standards And Me
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编码规范与我
- en: As previously mentioned, I've worked at a company that used the GNU standards.
    I've also created coding standards for a developer team, at a time when all team
    members (myself included) were inexperienced at the language we were using.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我在一家使用GNU标准的公司工作过。我还在一个时期为开发团队创建了编码规范，当时所有团队成员（包括我自己）对我们所使用的语言都不太熟悉。
- en: In the last 4 years or so, despite working for and contracting at a number of
    different companies, none has had documented coding standards. I haven't really
    missed it – the "standard" layout becomes "whatever the IDE does out of the box,"
    and everything else is done by automated or manual review.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去大约4年的时间里，尽管我在多家不同的公司工作并签订合同，但没有任何一家公司有文档化的编码规范。我并没有真正觉得缺少它——所谓的“标准”布局变成了“IDE默认的布局”，其他所有事情都是通过自动化或手动审查完成的。
- en: So, would I recommend writing a coding standard? Only if the lack of a standard
    is proving problematic. Actually, it might be just as easy—though more passive-aggressive—to
    write a pre-commit hook that reformats code before it gets into your repository.
    Some IDEs (those from JetBrains, for example) offer this feature already.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我会推荐编写编码规范吗？只有在缺乏规范导致问题的时候才会。实际上，编写一个在代码提交到仓库之前重新格式化代码的预提交钩子可能更容易——尽管这可能更加被动-aggressive。一些IDE（例如来自JetBrains的IDE）已经提供了这个功能。
- en: Code Comments
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码注释
- en: 'There are a couple of platitudes that get trotted out whenever comments are
    mentioned:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每当提到评论时，总会有人搬出一些陈词滥调：
- en: '*Real programmers don''t comment their code. If it was hard to write, it should
    be hard to understand and even harder to modify (from* **Real Programmers Don''t
    Write Specs**—[http://ifaq.wap.org/computers/realprogrammers.html](http://ifaq.wap.org/computers/realprogrammers.html))'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*真正的程序员不会注释他们的代码。如果编写起来很难，那么理解它应该也很困难，修改起来甚至更难（来自* **真正的程序员不会编写规范**——[http://ifaq.wap.org/computers/realprogrammers.html](http://ifaq.wap.org/computers/realprogrammers.html))'
- en: '*Any code should be self-documenting.* (found all over the internet; in this
    case, on **Stack Overflow**—[http://stackoverflow.com/questions/209015/what-is-self-documenting-code-and-can-it-replace-well-documented-code](http://stackoverflow.com/questions/209015/what-is-self-documenting-code-and-can-it-replace-well-documented-code))'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何代码都应该自文档化*。（在互联网上到处都是；在这个例子中，在**Stack Overflow**上——[http://stackoverflow.com/questions/209015/what-is-self-documenting-code-and-can-it-replace-well-documented-code](http://stackoverflow.com/questions/209015/what-is-self-documenting-code-and-can-it-replace-well-documented-code))'
- en: It should be obvious that the first quote is a joke, and if it isn't, read the
    referenced article. The second quote is not a joke, just sorely misguided.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，第一个引用是一个玩笑，如果不是，请阅读相关的文章。第二个引用不是玩笑，只是非常错误。
- en: At the time that you write any code, you're *in the zone*, mentally speaking.
    You're likely focused on that problem to the exclusion of all (or at least to
    the exclusion of many) others. You've been working on that particular problem
    for a short while, and on problems in that domain for quite a bit longer. So,
    of *course*, you don't think the code needs any comments. When you read the code,
    it fires off all those synaptic connections that remind you why you wrote it and
    what it's supposed to be doing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写任何代码时，从心理上讲，你处于“状态”之中。你很可能专注于那个问题，排除所有（或者至少是许多）其他问题。你已经针对那个特定的问题工作了一段时间，并且在那个领域的问题上工作了一段时间。所以，当然，你认为代码不需要任何注释。当你阅读代码时，它会触发所有那些突触连接，让你回想起你为什么要写它以及它应该做什么。
- en: 'Nobody else has the benefit of those connections. Even you, when you come back
    to the code later, do not have that benefit: memories that are not reinforced
    will *decay over time*—[http://www.simplypsychology.org/forgetting.html](http://www.simplypsychology.org/forgetting.html).
    According to that link, memories fade from long-term recollection if they aren''t
    consolidated.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人能享受到这些联系的好处。即使是你，当你稍后回到代码时，也没有这种好处：没有加强的记忆会*随时间衰减*——[http://www.simplypsychology.org/forgetting.html](http://www.simplypsychology.org/forgetting.html)。根据那个链接，如果它们没有被巩固，记忆就会从长期记忆中消失。
- en: 'With this in mind, comments are among the best form of documentation you can
    create because they provide a connection between two distinct forms of information.
    The information is the code and the prose comment, and the connection is proximate:
    you see both in the same place (that is, the source code editor in your IDE).
    If one doesn''t remind you what you were thinking about when you produced it,
    its connection with the other will trigger some memories.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，注释是你能创建的最好的文档形式之一，因为它们在两种不同的信息形式之间建立了联系。信息是代码和文字注释，联系是直接的：你可以在同一个地方看到它们（即你IDE中的源代码编辑器）。如果其中一个不能让你回想起你产生它的想法，那么它与另一个的联系会触发一些记忆。
- en: Recalling (pun somewhat intentional) the discussion from the beginning of this
    chapter, code tells you very quickly *what* software does, and with a little work
    tells you *how* it does it. There's no need for comments to retread that ground—you're
    already looking at something that gives you that information. (A quick reminder
    of how the code works can save an amount of reading, though. Or, as Fraser Hess
    put it by paraphrasing Frank Westheimer, *A month in the lab can save an hour
    in the library*— [https://twitter.com/fraserhess/status/299261317892685824](https://twitter.com/fraserhess/status/299261317892685824).)
    Comments should therefore focus on *why*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 回想（这里有点故意玩文字游戏）本章开头的讨论，代码可以很快地告诉你软件做什么，经过一点工作就能告诉你它是如何做到的。没有必要再通过注释重复这些内容——你已经在看一些能提供这些信息的东西了。（快速回顾代码的工作原理可以节省阅读时间。或者，正如弗莱泽·赫斯通过引用弗兰克·韦斯特海默的话所说，“在实验室的一个月可以节省在图书馆的一个小时”——[https://twitter.com/fraserhess/status/299261317892685824](https://twitter.com/fraserhess/status/299261317892685824)。）因此，注释应该专注于*为什么*。
- en: 'Many people are put off comments by reading code that looks something like
    this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人会因为看到类似这样的代码而感到厌烦：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you're experienced enough at programming to know what the various operators
    in your language do, a comment like that is redundant line noise. If all comments
    were similar to this example, then there would be little point in competent developers
    reading comments—a situation in which it would indeed be hard to justify them
    writing comments. Obviously, not all comments *are* like that; indeed, the ones
    you write don't need to be.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编程经验足够丰富，知道你语言中各种操作符的作用时，这样的注释就是多余的噪音。如果所有注释都像这个例子一样，那么有能力的开发者阅读注释就几乎没有意义了——在这种情况下，确实很难为他们写注释的行为找到合理的理由。显然，并不是所有的注释都是这样的；实际上，你写的注释不需要是这样的。
- en: If you find it hard to believe that anyone could ever need reminding what the
    `++` operator does, you probably don't remember learning programming, and haven't
    had to teach it either. The **Teaching H.E. Programming blog**—[http://teachingheprogramming.blogspot.co.uk](http://teachingheprogramming.blogspot.co.uk)
    is a good overview of just how hard that thing you do every day is for people
    who don't do it every day.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你很难相信有人需要提醒`++`操作符的作用，那么你可能不记得学习编程的经历，也没有教过编程。**《教学H.E.编程博客》**——[http://teachingheprogramming.blogspot.co.uk](http://teachingheprogramming.blogspot.co.uk)
    是一个很好的概述，说明了对于不经常做这件事的人来说，你每天做的事情有多么困难。
- en: 'The thing is that redundant comments are simply redundant. You read them, realize
    they don''t help, and move on. This doesn''t waste much time. It''s worse to read
    comments that are mentally jarring: ones that actively stop you thinking about
    the code and make you think about the comment.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是多余的注释就是多余的。你读它们，意识到它们没有帮助，然后继续。这不会浪费太多时间。更糟糕的是阅读那些让你精神上感到冲击的注释：那些会打断你对代码思考并让你思考注释的。
- en: That joke that seems really funny in your head – don't write it down. It might
    work well on Twitter or in the company chatroom, but not in a code comment. Even
    if the person reading it thinks it's funny the first time, they probably won't
    if they have to stop grokking code every day for the rest of their career while
    they read that joke over and over.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 那个在你脑海中看起来非常有趣的笑话——不要写下来。它可能在推特或公司聊天室里效果很好，但在代码注释中就不合适了。即使阅读它的人第一次觉得它很有趣，但如果他们每天都要停下来反复阅读这个笑话，以便理解代码，那么他们可能就不会觉得有趣了。
- en: While I was writing this book, someone asked on a Q&A website whether *there's
    empirical evidence for the value of comments in code*—[http://programmers.stackexchange.com/questions/187722/are-there-any-empirical-studies-about-the-effects-of-commenting-source-code-on-s](http://programmers.stackexchange.com/questions/187722/are-there-any-empirical-studies-about-the-effects-of-commenting-source-code-on-s).
    More usefully, someone answered that question with references. One of the papers,
    **The effect of modularization and comments on program comprehension**—[http://portal.acm.org/ft_gateway.cfm?id=802534&type=pdf&coll=DL&dl=GUIDE&CFID=278950761&CFTOKEN=48982755](http://portal.acm.org/ft_gateway.cfm?id=802534&type=pdf&coll=DL&dl=GUIDE&CFID=278950761&CFTOKEN=48982755),
    is worth looking into in more detail.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我写这本书的时候，有人在问答网站上问，是否有关于代码注释价值的实证研究——[http://programmers.stackexchange.com/questions/187722/are-there-any-empirical-studies-about-the-effects-of-commenting-source-code-on-s](http://programmers.stackexchange.com/questions/187722/are-there-any-empirical-studies-about-the-effects-of-commenting-source-code-on-s)。更有用的一点是，有人回答了这个问题，并提供了参考文献。其中一篇论文，**《模块化和注释对程序理解的影响》**——[http://portal.acm.org/ft_gateway.cfm?id=802534&type=pdf&coll=DL&dl=GUIDE&CFID=278950761&CFTOKEN=48982755](http://portal.acm.org/ft_gateway.cfm?id=802534&type=pdf&coll=DL&dl=GUIDE&CFID=278950761&CFTOKEN=48982755)，值得更详细地研究。
- en: Your first reaction may be to look at the date of this paper—March 1981—and
    decide that it can't possibly say anything relevant to modern programmers. But
    wait up. The article investigates how people (who haven't changed much in three
    decades) read (which also hasn't changed much) comments (written in English, which
    hasn't changed much) and code that is organized along different lines of modularity.
    Only the way we write code has changed, and really not by very much. This paper
    investigates code written in FORTRAN, a language that's still in use and not too
    dissimilar from C. It investigates code written with different approaches to modularity,
    a variation that's observed in modern code whether written using procedural or
    object-oriented languages. There's really no reason to dismiss this article based
    on age.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您的第一反应可能是查看这篇论文的日期——1981年3月——并决定它不可能对现代程序员有任何相关性。但请稍等。这篇文章调查了人们（在三十年中变化不大）如何阅读（也没有太大变化）用英语（变化也不大）写的注释和按不同模块化线路组织的代码。唯一改变的是我们编写代码的方式，而且变化并不大。这篇文章调查了FORTRAN语言的代码，这种语言仍在使用，并且与C语言不太相似。它调查了使用不同模块化方法的代码，这种变化在现代代码中是观察到的，无论是使用过程式还是面向对象的编程语言。真的没有理由因为文章的年龄而摒弃这篇文章。
- en: 'What they did was to implement a few different code solutions to one problem:
    a monolithic program, a modularized program, an over-modularized program (each
    "module" consisted of 3-15 lines), and one organized around an abstract data type.
    They produced two different versions of each; one had comments describing each
    module''s functionality and the other did not. Interestingly, to remove other
    hints as to the operation of the programs, they made all variable names nondescriptive
    and removed any formatting hints.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 他们所做的是为一个问题实现几种不同的代码解决方案：一个单一程序，一个模块化程序，一个过度模块化程序（每个“模块”由3-15行组成），以及一个围绕抽象数据类型组织的程序。他们为每种程序产生了两个不同的版本；一个有描述每个模块功能的注释，另一个没有。有趣的是，为了消除关于程序操作的其它线索，他们使所有变量名非描述性，并移除了任何格式化提示。
- en: 'Whether this represents as good a control as, for example, using a consistent
    (meaningful) naming and formatting strategy throughout all examples would be worth
    exploring. Forty-eight programmers were each given one version of the code and
    a quiz about its operation. They summarized their results as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 是否这代表了一种与例如使用一致的（有意义的）命名和格式化策略在所有示例中一样好的控制，这值得探索。48名程序员每人被分配了一个版本的代码和关于其操作的测验。他们总结了以下结果：
- en: '*The comment results seem to imply that the comprehension of a program can
    be significantly improved with the addition of short phrases which summarize the
    function that a module is to perform. Contrary to the original hypothesis, it
    was concluded that comments were not significantly beneficial to logical module
    identification. Those working with the uncommented monolithic version seemed able
    to comprehend the program and understand the interaction of the parts as well
    as those working with the commented monolithic version. However, it seems that
    those working with the uncommented modularized programs found it more difficult
    to understand the function of a module and how it fit into the context of the
    program than those who were given the commented modularized versions.*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*注释结果似乎表明，通过添加总结模块要执行的功能的简短短语，可以显著提高对程序的理解。与原始假设相反，结论是注释对逻辑模块识别没有显著益处。那些使用未注释的单一版本的人似乎能够理解程序并理解各部分之间的交互，就像那些使用带注释的单一版本的人一样。然而，似乎那些使用未注释的模块化程序的人发现理解模块的功能以及它如何融入程序上下文比那些得到带注释的模块化版本的人更困难。*'
- en: 'This does not say "comments are good" or "comments are bad." It *does* say
    that a particular type of comment can help people to understand a modular program.
    Notice that it also says that *uncommented* modular programs are harder to understand
    than *uncommented* monolithic programs. Could this result have any relevance to
    the Dunsmore et al. study in *Chapter 5, Coding Practices*? Remember that they
    found object-oriented programs hard to understand:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说“注释是好的”或“注释是坏的”。*确实*说，特定类型的注释可以帮助人们理解模块化程序。请注意，它还指出，*未注释*的模块化程序比*未注释*的单一程序更难理解。这个结果与第5章“编码实践”中的Dunsmore等人研究有什么相关性吗？记住，他们发现面向对象的程序很难理解：
- en: '*The desirable design properties that lead to a connected system of loosely
    coupled objects also produce a system where it''s difficult to discover the flow
    of execution; you can''t easily see where control goes as a result of any particular
    message.*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*那些导致松散耦合对象连接系统的理想设计属性，也产生了一个难以发现执行流程的系统；你不能轻易地看到任何特定消息的结果控制流向何方。*'
- en: Literate Programming
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文学编程
- en: Donald Knuth took the idea of comments recalling the programmer's thought processes
    much further with his idea of **Literate Programming** ([http://www.literateprogramming.com](http://www.literateprogramming.com)).
    In a literate programming environment, programs are written as "webs" in which
    prose and code can be intermingled.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Donald Knuth 将注释回忆程序员思维过程的想法进一步发展，提出了**文学编程**（[http://www.literateprogramming.com](http://www.literateprogramming.com)）的概念。在文学编程环境中，程序被编写成“网络”，其中散文和代码可以交织在一起。
- en: Programmers are encouraged to explain the thought processes behind the code
    they create, including the code implementation as part of the documentation. A
    hyperlinked tree of code references in the web is used to generate a source-only
    view of the web (via a tool called `tangle`), which can then be fed into the usual
    compiler or interpreter. Another tool, `weave`, converts the web into a pretty-printed
    readable document.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员被鼓励解释他们所创建代码背后的思维过程，包括将代码实现作为文档的一部分。在网络上使用超链接的代码引用树来生成仅包含源代码的网页视图（通过一个名为
    `tangle` 的工具），然后可以将这些内容输入到常规的编译器或解释器中。另一个工具 `weave` 将网页转换成格式化的可读文档。
- en: The purpose of this hyperlinked graph is to separate the structure required
    by the programming language (for example, the classes and methods in an OOP language)
    from the structure of your thoughts. If you're thinking about two different classes
    and how they'll interact, you can write the parts of the code as you think of
    them and tell the compiler how they should be ordered later.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个超链接图的目的是将编程语言所需的结构（例如，面向对象语言中的类和方法）与你的思维结构分开。如果你在思考两个不同的类以及它们将如何交互，你可以在想到它们的时候编写代码的部分，并告诉编译器它们应该如何排序。
- en: 'Reading the web back later, the person who wrote it will remember why they
    made the decisions they did as the organization of the code matches their thought
    processes. Other readers will get insight into how the code evolved and why certain
    decisions were made: the key reasons for writing documentation.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在稍后阅读网页时，编写者会记得他们为什么做出这样的决定，因为代码的组织结构与他们的思维过程相匹配。其他读者将了解代码是如何演变的以及为什么做出某些决定：这是编写文档的关键原因。
- en: I'm not sure whether literate programming is a style to adopt – I haven't yet
    built any large projects as webs. I've kicked the tires on LP tools though and
    it is a fun way to write software (but then I like writing prose anyway, as you
    can probably tell). I'm not convinced it would scale – not necessarily to large
    projects. If I'd known about CWEB when I wrote **Test-Driven iOS Development**—[http://blog.securemacprogramming.com/2012/04/test-driven-ios-development/](http://blog.securemacprogramming.com/2012/04/test-driven-ios-development/),
    I would have got it done quicker and with fewer errors. When the authors of **The
    Pragmatic Programmer**—[http://pragprog.com/the-pragmatic-programmer/](http://pragprog.com/the-pragmatic-programmer/)
    wrote that book, they effectively re-implemented bits of LP to keep their manuscript
    in sync with their code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定文学编程是否是一种应该采纳的风格——我还没有用网络构建过任何大型项目。我虽然尝试过 LP 工具，并且发现这是一种编写软件的有趣方式（但无论如何，我也喜欢写散文）。我不确定它是否能够扩展——不一定适用于大型项目。如果我在写**测试驱动
    iOS 开发**（[http://blog.securemacprogramming.com/2012/04/test-driven-ios-development/](http://blog.securemacprogramming.com/2012/04/test-driven-ios-development/)）时知道
    CWEB，我可能会更快地完成它，并且错误更少。当**《实用程序员**》（[http://pragprog.com/the-pragmatic-programmer/](http://pragprog.com/the-pragmatic-programmer/)）的作者写那本书时，他们实际上重新实现了文学编程的一些部分，以保持他们的手稿与代码同步。
- en: The scaling I wonder about is scaling to multiple developers. If you find reading
    someone else's code style irksome, then wait until you have to read their unproofed
    prose. Of course, there's one way to find out.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我所担忧的扩展问题是扩展到多个开发者。如果你觉得阅读别人的代码风格令人不快，那么等到你必须阅读他们的未经校对的散文。当然，有一种方法可以找到答案。
- en: Comment Documentation
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释文档
- en: While literate programming webs focus on the structure of your thoughts and
    documentation, letting the code fit into that flow, many other tools exist that
    retain the code's structure but extract and pretty-print comments into hyperlinked
    API documentation. (Doesn't comment documentation come under "comments," discussed
    above? Not precisely, as the formality and intention are very different.)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的编程文献网站专注于你的思维和文档的结构，让代码适应这种流程，但许多其他工具存在，它们保留了代码的结构，但提取并格式化注释为超链接API文档。（注释文档不是在上述“注释”中讨论的吗？不完全是这样，因为其形式性和意图非常不同。）
- en: These tools—including Doxygen, Headerdoc, and friends—retain the proximity of
    the code with its documentation. As you're making changes to a method, you can
    see that its comment is right above, inviting an update to remain consistent.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具——包括Doxygen、Headerdoc及其朋友——保留了代码与其文档的邻近性。当你对方法进行更改时，你可以看到其注释就在上面，这邀请你进行更新以保持一致性。
- en: I find it helpful to produce comment documentation for classes and interfaces
    that I believe other people are going to use. I don't normally generate pretty
    output, but that's something people can do if they want. I certainly appreciate
    that option where it exists and use the formatted documentation for another programmers'
    API.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现为那些我认为其他人可能会使用的类和接口生成注释文档很有帮助。我通常不会生成美观的输出，但如果人们想要这么做，他们可以这么做。我当然欣赏这种选项，并且会使用格式化的文档来为其他程序员的API提供帮助。
- en: Some static analysis tools, notably Microsoft's, warn about undocumented methods,
    classes, and fields. This leads to comments for the sake of their presence, without
    necessarily leading to a better standard of documentation. Well-formatted comments
    explaining that a method's purpose is "banana" and its return value is "banana"
    are rife.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一些静态分析工具，特别是微软的，会警告关于未记录的方法、类和字段。这导致仅仅为了存在而添加注释，而不一定导致文档标准得到提高。解释方法目的是“香蕉”及其返回值是“香蕉”的格式化注释到处都是。
- en: Much of what is specified in comment documentation often includes restrictions
    on input values to methods ("the `index` argument must be greater than 0 but less
    than `count`"), when to call them ("it is an error to call this method before
    you have called `configure()`"), or expectations about the return value ("the
    object returned will have a `size` less than `2*count`"). These are candidates
    for being expressed as assertions (usually in addition to, rather than instead
    of, the documentation), or you could use a language that supports contracts.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注释文档中指定的大部分内容通常包括对方法输入值的限制（“`index`参数必须大于0但小于`count`”），何时调用它们（“在调用`configure()`之前调用此方法是一个错误”），或对返回值的期望（“返回的对象将具有小于`2*count`的`size`”）。这些可以作为断言（通常是在文档之外，而不是代替文档）表达的内容，或者你可以使用支持契约的语言。
- en: Uml Diagrams
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Uml 图
- en: 'UML is a huge topic. Several books have been written on the subject. I''m not
    even going to try to replicate all of that, so here''s the potted version, which
    also lets you draw analogies with other diagramming techniques:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: UML是一个很大的主题。关于这个主题已经写了几本书。我甚至不想尝试复制所有这些内容，所以这里有一个简化的版本，它还让你能够与其他绘图技术进行比较：
- en: '*A UML diagram is a view of some aspect of your code expressed in a manner
    that conforms to the rules of the UML. Any developer that understands those rules
    will derive the same information (Provided the diagram actually expresses enough
    information to be unambiguous, of course) from the diagram.*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*UML图是以符合UML规则的方式表达你的代码某些方面的视图。任何理解这些规则的开发者都将从图中获得相同的信息（当然，前提是图实际上表达了足够的信息以避免歧义）。*'
- en: This means you can consider CRC cards, data flow diagrams, and other techniques
    to be covered by this section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以考虑CRC卡片、数据流图和其他技术，这些都被包含在本节中。
- en: The first thing to notice is that it's possible to understand UML diagrams even
    if you don't know the UML. It's just boxes and lines, though sometimes the meaning
    of "box" is more precise than "thing" and the meaning of "line" is more precise
    than "joined to this other thing." Don't be put off by the idea that it's some
    complicated language with lots of rules you need to learn. That's only true if
    you want it to be.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，即使你不了解UML，也可以理解UML图。它只是框和线，尽管有时“框”的意义比“事物”更精确，而“线”的意义比“连接到这个其他事物”更精确。不要被这种想法吓倒，即它是一种复杂的语言，有很多规则需要学习。这只有在你想让它成为这样的时候才是真的。
- en: Diagrams like these can appear in many contexts. I usually create them as quick
    sketches, on whiteboards or with paper and pencil (or their modern equivalent
    – the iPad and stylus). In these cases, the rules are not *too* important, but
    do increase the likelihood that another reader will understand the details on
    my diagram and that I'll create the same diagram twice if documenting the same
    thing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的图表可以在许多上下文中出现。我通常将它们作为快速草图创建，在白板上或用纸和铅笔（或它们的现代等价物——iPad和触控笔）。在这些情况下，规则不是*太*重要，但确实增加了其他读者理解我图表细节的可能性，以及我在记录同一件事情时可能会创建相同的图表两次。
- en: It may be clear that diagrams produced in this way are for the moment, not forever.
    They might be captured via an iPhone photo "just in case," but the likelihood
    is that they'll never be looked at again. There's certainly no expectation that
    they'll go into some "*Project X Artefacts*" folder to be kept indefinitely.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这样产生的图表可能是暂时的，而不是永久的。它们可能会通过iPhone照片“以防万一”来保存，但可能性更大的是，它们将永远不会再次被查看。当然，没有人期望它们会进入某个“*项目X工件*”文件夹而被无限期保留。
- en: The more effort you put into this sort of graphic, the more likely you are to
    want to keep it around. For something like a blog post or a diagram in a book,
    I'll usually use **Omnigraffle**—[http://www.omnigroup.com/products/omnigraffle/](http://www.omnigroup.com/products/omnigraffle/)),
    **dia**—[https://live.gnome.org/Dia/](https://live.gnome.org/Dia/), or something
    else that lets me use the shapes and lines from the UML but doesn't care about
    the rules.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这类图形上投入的精力越多，你越有可能想要保留它。对于像博客文章或书中的图表这样的东西，我通常会使用**Omnigraffle**—[http://www.omnigroup.com/products/omnigraffle/](http://www.omnigroup.com/products/omnigraffle/))，**dia**—[https://live.gnome.org/Dia/](https://live.gnome.org/Dia/)，或者其他一些让我可以使用UML中的形状和线条，但不关心规则的工具。
- en: I have also used tools that *do* care about the rules. One company I worked
    at had a site license for **Enterprise Architect**—[http://www.sparxsystems.com.au](http://www.sparxsystems.com.au)),
    a tool that requires you to construct conforming diagrams and supports "round-trips"
    through the code. A round-trip means that it can both generate the diagram from
    the code (discussed earlier) and also generate stub code from the diagram. It
    could also respect existing code, not trampling over existing methods when adding
    new features to a class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我也使用了一些关心规则的工具。我在一家公司工作过，该公司拥有**Enterprise Architect**—[http://www.sparxsystems.com.au](http://www.sparxsystems.com.au))的站点许可证，这是一个要求你构建符合规则的图表并支持通过代码“往返”的工具。往返意味着它可以从代码（前面讨论过）生成图表，也可以从图表生成存根代码。它还可以尊重现有代码，在向类添加新功能时不会覆盖现有方法。
- en: 'A few of the other teams made use of this extensively, maintaining the design
    of their components or applications in UML and implementing the behavior in generated
    C++ or Java classes. My team couldn''t make use of it because the tool didn''t
    (and, to my knowledge, still doesn''t) support Objective-C. I therefore feel underqualified
    to talk about whether this is a good idea: my gut feeling is that it could be
    a good idea, because it forces you to think at a high level (the features exposed
    in the diagram) while designing, without getting bogged down in implementation
    details. On the other hand, different languages have different idioms and preferred
    ways of doing things, and those aren''t readily expressed in a UML model. There''s
    also some overhead associated with configuring the code generator to your team''s
    liking—you still have to *read* its code, even if you don''t have to *write* it.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他团队广泛使用了这种方法，维护他们的组件或应用程序的UML设计，并在生成的C++或Java类中实现行为。我的团队无法使用它，因为工具不支持（据我所知，现在仍然不支持）Objective-C。因此，我觉得自己没有资格谈论这是否是一个好主意：我的直觉是，这可能是一个好主意，因为它强迫你在设计时从高层次（图表中暴露的功能）思考，而不会陷入实现细节。另一方面，不同的语言有不同的习语和做事的偏好方式，这些在UML模型中并不容易表达。还有一些与配置代码生成器以符合团队喜好相关的开销——即使你不需要编写代码，你仍然需要*阅读*它。
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Documentation is a good thing to have, at those times when you need it. It's
    useful for telling you why and how software does what it does, when the code can
    only tell you what it does with a little bit of *how* mixed in.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要它的时候，文档是一件好事。它有助于告诉你软件为什么和如何做它所做的事情，而当代码只能告诉你它做了什么，以及一点点的*如何*时。
- en: Maintaining documentation incurs additional cost and carries the risk that the
    documentation and the code could become unsynchronized. There are various ways
    to document code, and the preferred trade-off between effort and benefit can be
    found by experimentation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 维护文档会产生额外的成本，并存在文档和代码可能不同步的风险。有各种方式来记录代码，通过实验可以找到努力与收益之间最佳的权衡点。
