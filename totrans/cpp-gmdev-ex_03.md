# 数学与图形概念

在我们开始渲染对象之前，了解本书项目中将使用的数学知识是至关重要的。数学在游戏开发中起着至关重要的作用，图形编程通常广泛使用向量和矩阵。在本章中，你将了解这些数学概念如何派上用场。首先，我们将回顾一些关键数学概念，然后应用它们，以便我们可以处理空间变换和渲染管线。有专门的书籍涵盖了你在游戏开发中需要的所有数学相关主题。然而，由于我们将使用C++进行图形编程，其他数学主题超出了本书的范围。

在接下来的章节中，我们将使用OpenGL和Vulkan图形API来渲染我们的对象，并使用GLM数学库来进行数学运算。在本章中，我们将探讨在虚拟世界中使用矩阵和向量变换创建3D对象的过程。然后，我们将看看如何使用空间变换将3D点转换为2D位置，以及图形管线如何帮助我们实现这一点。

在本章中，我们将涵盖以下主题：

+   3D坐标系

+   向量

+   矩阵

+   GLM OpenGL数学

+   OpenGL数据类型

+   空间变换

+   渲染管线

# 3D坐标系

在我们能够指定一个位置之前，我们必须指定一个坐标系。一个3D坐标系有三个轴：*x*轴、*y*轴和*z*轴。这三个轴从三个轴相交的原点开始。

正的x轴从原点开始，并无限地向一个特定方向移动，而负的*x*轴则向相反方向移动。正的*y*轴从原点开始，以90度角向上移动，与*x*轴垂直，负的*y*轴则向相反方向移动。这描述了一个2D XY平面，它是2D坐标系的基础。

正的*z*轴与*x*轴和*y*轴有相同的原点，并且垂直于X轴和Y轴。正*z*轴可以沿着XY平面的任意方向移动，以形成一个3D坐标系。

假设正*x*轴向右，正*y*轴向上，那么*z*轴可以进入或离开屏幕。这是因为*z*轴与*x*轴和*y*轴垂直。

当正的*z*轴进入屏幕时，这被称为**左手坐标系**。当正的*z*轴从屏幕出来时，这被称为**右手坐标系**。

将你的右手臂伸直，使其在你面前，手掌朝向你，并握紧拳头。将你的大拇指向右伸直，然后伸直食指向上。现在，将你的中指伸直，使其朝向你。这可以用来解释右手坐标系。

拇指代表正*x*轴的方向，食指代表正*y*轴的方向，中指代表正*z*轴的方向。OpenGL、Vulkan或任何使用这些轴的图形框架也使用这个坐标系。

对于左手坐标系，伸出你的左臂，使其在你面前，手掌朝向你，然后握拳。接下来，伸出你的拇指和食指，分别指向右上方。现在，伸出你的中指，使其远离你。在这种情况下，拇指代表*x*轴的方向，食指指向正*y*轴的方向。*z*轴（中指）现在远离你。Direct3D的DirectX使用这个坐标系。

在这本书中，由于我们将要介绍OpenGL和Vulkan，我们将使用**右手坐标系**：

![](img/173e45a5-bdff-42fc-9d6b-ae4e42108aa6.png)

# 点

现在我们已经定义了坐标系，我们可以指定一个点的定义。一个3D点是在3D空间中的一个位置，它通过**X**、**Y**和**Z**轴的距离以及坐标系的起点来指定。它被指定为(X, Y, Z)，其中X、Y和Z是从原点到该点的距离。但我们所说的原点是什么？原点也是三个轴相交的点。原点位于(0, 0, 0)，原点的位置在坐标系中指定，如下所示：

![](img/7c1608c8-03a6-4a61-84f8-75278ce57907.png)

要指定坐标系内的点，想象在每个方向上，轴由更小的单位组成。这个单位可以是1毫米、1厘米或1千米，具体取决于你有多少数据。

如果我们只看X轴和Y轴，这看起来可能就像这样：

![](img/14788c58-1d46-42dc-82c7-1470797f8f59.png)

如果我们看*x*轴，值1和2指定了从原点（值为0）沿该轴的点的距离。所以，*x*轴上的点1位于(1, 0, 0)。同样，沿*y*轴的点1位于(0, 1, 0)。

此外，红色点的位置将在(1, 1, 0)；也就是说，沿*x*轴和*y*轴各1个单位。由于Z值为0，我们指定其值为0。

类似地，3D空间中的点如下表示：

![](img/96c28731-e7cc-4c6c-81a1-ee8e7285d42c.png)

# 向量

向量是一个具有大小和方向的量。具有大小和方向的量的例子包括位移、速度、加速度和力。对于位移，你可以指定方向以及物体移动的总距离。

速度和速度的区别在于，速度只指定物体移动的速度，但不确定物体移动的方向。然而，速度指定了大小，这包括速度和方向。与速度类似，我们还有加速度。加速度的一种形式是重力，我们知道它总是向下作用，并且总是大约9.81 m/s²  —— 好吧，至少在地球上是这样。在月球上，这个值是地球的1/6。

力的一个例子是重量。重量也向下作用，并且是质量乘以加速度的计算结果。

向量通过一个带箭头的线段进行图形表示，线段的长度表示向量的模，而带箭头的箭头表示向量的方向。我们可以围绕一个向量移动，因为这样做不会改变其大小或方向。

两个向量如果它们的大小和方向都相同，即使它们位于不同的位置，则称这两个向量相等。向量用字母上方的箭头表示。

在以下图中，向量![图片](img/2a1e581e-d673-4ab8-a190-742cc0f7cbfd.png)和![图片](img/8bc6892d-8e78-4fcc-ba73-e642288cde44.png)的起点不同。由于箭头的大小和方向相同，它们是相等的：

![图片](img/fa8b7924-63fc-4bfc-9e1a-140d1b32793a.png)

在三维坐标系中，一个向量由相对于该坐标系的坐标来指定。在以下图中，向量![图片](img/ac329482-d883-4a99-9f36-a6f0d7f49832.png)等于(2, 3, 1)并且表示为![图片](img/1798f038-6515-471c-8a07-2b61201db57d.png)=![](img/2dae2535-79ec-444f-b2eb-59341ded4914.png):

![图片](img/ffc09b70-20e0-4a4f-a06e-67a53498412f.png)

# 向量运算

就像标量信息一样，向量也可以相加、相减和相乘。假设你有两个向量![图片](img/214bb708-9019-41ac-b71a-72773b5506e5.png)和![图片](img/c708a57d-c191-4fa0-bc41-daea6143fb64.png)，其中![图片](img/343aaa7e-9caa-4dfe-8520-6d6788753578.png)= (a[x], a[y], a[z])和![图片](img/8ac3e72f-eca2-453e-8494-35b70b081f0d.png)= (b[x], b[y], b[z])。让我们看看我们如何将这些向量相加和相减。

在添加向量时，我们分别将分量相加以创建一个新的向量：

![图片](img/9d1bce52-2dfd-4ec3-9d3a-e74b6cef8c99.png)= ![图片](img/0dbf3fce-6ebc-4977-a9d4-aa03a1d86851.png) + ![图片](img/09c33362-d2f1-4f5a-b394-ea0bc3dacc7e.png)

![图片](img/c74fa717-c4a9-4e66-99d4-d5aa515e3c2e.png)= ((ax + bx) , (ay + by) , (az + bz ))

现在，让我们在图表中可视化两个向量的加法。为了方便起见，Z 值保持为 0.0。在这里，![图片](img/973328f0-7acb-424f-8ae3-e391aad4e811.png)=(1.0, 0.4, 0.0) 和 ![图片](img/4ea4a919-bf8d-46ea-9143-c0f4cf3c5abc.png)=(0.6, 2.0, 0.0)，这意味着结果向量 ![图片](img/df084c7d-cb1b-42ab-9c8f-d0628d213d90.png)= ![图片](img/c7261b2a-0c1e-428d-9a36-fc659f099f4e.png) + ![图片](img/01c1a38c-3785-497f-8ce2-86647d472448.png)，= (1.0 + 0.6, 0.4 + 2.0, 0.0 + 0.0) = (1.6, 2.4, 0.0):

![图片](img/521124c0-58e2-4239-bcb3-f3a0cd0943fb.png)

向量也是交换的，这意味着 ![图片](img/695a78c8-3cbe-46b4-b06f-148bc930aa88.png) + ![图片](img/341c8b1d-aece-41ec-93a7-c5aa1eecc1e4.png) 将给出与 ![图片](img/f5079cea-ebc3-4e26-8636-23f403cfd5e9.png) + ![图片](img/eb876de9-01a5-4b7f-8b67-0ec8161f244c.png) 相同的结果。

然而，如果我们把 ![图片](img/34defdb7-77b3-4f41-b8f4-1b336a81016a.png) 加到 ![图片](img/4b98cad1-6b37-4b07-90bc-cfed48e4b97b.png) 上，那么虚线将从向量 ![图片](img/341c8b1d-aece-41ec-93a7-c5aa1eecc1e4.png) 移动到向量 ![图片](img/041962c2-03d2-43ad-8df1-89ce6c08461d.png)，如图所示。此外，在向量减法中，我们通过减去向量的各个分量来创建一个新的向量：

![图片](img/6161b965-e04f-4219-96bb-1547d2383e8c.png)= ![图片](img/400bff09-6950-4856-9178-dda2eae4243a.png) - ![图片](img/d289cba8-c3bc-4135-a3ab-9bc7227d8028.png)

![图片](img/041962c2-03d2-43ad-8df1-89ce6c08461d.png)= ((ax - bx), (ay - by), (az - bz))

现在，让我们在图表中可视化两个向量的减法。

在这里，![图片](img/baafd86e-4698-4ba9-8552-53869a81e01a.png)= (1.0, 0.4, 0.0) 和 ![图片](img/eba72c42-6fff-4904-ae61-0a3dff1662a4.png)= (0.6, 2.0, 0.0)。因此，结果向量 ![图片](img/e5218906-5593-4155-bb71-5d0d573b9545.png)= ![图片](img/9cb94812-72b8-40c5-b0fb-12eb9639e4f6.png) - ![图片](img/ec2af80a-391a-42d6-825b-c5e413685224.png)，= (1.0 - 0.6, 0.4 - 2.0, 0.0 - 0.0) = (0.4, -1.6, 0.0):

![图片](img/8f597d24-de01-4226-8ca0-aa502bb06312.png)

如果向量 A 和 B 相等，结果将是一个所有三个分量都为零的零向量。

如果 ![图片](img/fc0f6b71-42a0-4fe6-9a3e-1cd3e8ed70b7.png)= ![图片](img/356fd3ab-9b48-4c24-82ce-61a857a6dad3.png)，这意味着 a[x] = b[x], a[y] = b[y], a[z] = b[z]。如果是这种情况，那么，![图片](img/fb484272-bc03-417f-ab5b-58e9eba98f9e.png)= ![图片](img/4728f4f8-ce7e-4d20-9503-27b0ad8e2441.png) - ![图片](img/73224def-1249-491f-ad09-f32f5a84dafb.png)= (0, 0, 0).

我们可以将标量乘以向量。结果是每个向量分量都乘以标量的向量。

例如，如果 A 乘以一个单一的值 s，我们将得到以下结果：

![图片](img/83a4ffeb-5a2c-489a-92df-0bb227e997e6.png)

# 向量的大小

向量的大小等于向量本身的长度。但我们如何从数学上计算它呢？

向量的大小由勾股定理给出，该定理规定，在右手三角形中，对角线长度的平方等于相邻边的平方和。让我们看看以下右手三角形，*c² = x² + y²*：

![图片](img/841cc4e8-7755-4a4b-af66-f282e0a387b4.png)

这可以扩展到三维，*c² = x² + y² + z²*。

向量的大小用双竖线表示，所以向量的大小，

![图片](img/6be0b0cc-8c0a-4aeb-8e23-e0568ec4947f.png)表示为![图片](img/9e90e49e-a576-416f-9463-986d8b3cc5cb.png)。大小始终大于或等于零。

因此，如果向量A = (X, Y, Z)，那么大小由以下方程给出：

![图片](img/228d2181-2e99-4e79-a366-39c23826586e.png)

如果![图片](img/20878924-54f2-4e0b-8d4f-375b4a6681d6.png) = (3, -5, 7)，那么我们得到以下：

![图片](img/26935f31-c45e-4df4-beb5-5ead26087101.png)

因此，![图片](img/d5f5d2ef-1ae8-4fb5-9035-375298c51c41.png)的长度为9.11单位。

# 单位向量

在某些情况下，我们不在乎向量的大小；我们只想知道向量的方向。为了找出这一点，我们希望向量在X、Y和Z方向上的长度等于1。这样的向量被称为单位向量或归一化向量。

在单位向量中，向量的X、Y和Z分量被除以大小以创建一个单位长度的向量。它们用向量名称上方的帽子表示，而不是箭头。因此，向量A的单位向量将表示为![图片](img/dc50564b-a440-479d-b8eb-5a3b18bd05dd.png)，如下所示：

![图片](img/daed6188-72d0-433c-bffa-b594f0975b6c.png)

当一个向量被转换为单位向量时，它被称为归一化。这意味着值始终在0.0和1.0之间。原始值已被缩放到这个范围内。让我们将向量![图片](img/511f231c-a556-4ee7-aab1-f5c0dbcf3baa.png)= (3, -5, 7)归一化。

首先，我们必须计算![图片](img/bf8003d7-bcd0-4ec4-b375-6951969677c3.png)的大小，这我们已经做了（它是9.11）。

因此，单位向量如下：

![图片](img/eb11fae8-5f76-49c4-bbb5-99e1e509f170.png)

# 点积

点积是一种向量乘法，其中结果向量是一个标量。它也被称为标量积，原因相同。两个向量的标量积是对应分量的乘积之和。

如果你有两个向量，A = (a[x], a[y], a[z]) 和 B = (b[x], b[y], b[z])，这由以下方程给出：

![图片](img/39934380-70d0-4e52-9201-8a748093c538.png)

两个向量的点积也等于乘以两个向量大小后夹角的余弦。注意点积用向量之间的点表示：

![图片](img/ac795e9e-2f01-4909-9dd8-5191826ca2cc.png)

θ始终在0和π之间。通过将方程1和2结合起来，我们可以找出两个向量之间的角度：

![](img/7c319066-651c-490f-9d71-5d34200fd421.png)

因此我们得到：

![](img/883e2f82-bc67-4c79-953b-42e31ff5a246.png)

这种形式具有一些独特的几何特性：

+   如果 ![](img/d9e77aee-35ae-4a77-9456-8d3befb50196.png)= 0，那么 ![](img/821d50ac-4d69-4174-82d6-fbce7ae8541e.png) 垂直于 ![](img/a9c31b6b-9b19-4fdd-9775-9cbe74271628.png)，即 cos 90 = 0。

+   如果 ![](img/cb663a1e-8ba7-4eeb-89ea-551bf1b18b63.png) = ![](img/3a2bb232-fd3a-41b6-8572-e1a2d268d900.png) ，那么这两个向量是平行的，即 cos 0 = 1。

+   如果 ![](img/bb285625-eec7-47da-886b-69606c36723f.png)> 0，那么向量之间的角度小于 90 度。

+   如果 ![](img/524fcaca-2c97-45f3-ad1f-c50929ac458e.png)< 0，那么向量之间的角度大于 90 度。

现在，让我们来看一个点积的例子。

如果 ![](img/20486fd6-d306-47bf-8394-5512d2231b56.png)= (3, -5, 7) 和 ![](img/f2c9b707-1e49-4113-adf6-95c35928682c.png) = (2, 4 , 1)，那么 ![](img/274f44c4-038e-47f0-a41c-26251feb4a15.png) = 9.110 和 ![](img/2fae8534-ebaf-4785-b2c6-f30c784a6d73.png)。

接下来，我们这样计算：

![](img/12ad5de1-66f3-4449-a5b8-89ad506cdfd4.png)

# 叉积

叉积是向量乘法的一种形式，其中乘积的结果是另一个向量。将 ![](img/da7b1b6f-4c7e-493b-b661-d60c12afcdc2.png) 和 ![](img/b1027b57-1635-4312-9d74-76cf0115b7d3.png) 的叉积将得到一个第三向量，该向量垂直于向量 ![](img/2a67360a-658e-4526-9ff3-7d77546eece8.png) 和 ![](img/f521ea0d-f08d-4e19-b341-d867fe50082a.png) 。

如果你有两个向量， ![](img/1fb5a9f4-3b10-4592-8eeb-827a24111d48.png) = (a[x], a[y], a[z]) 和 ![](img/aa92a4fd-2f9e-41a2-a4f7-4528edb9bc84.png) = (b[x], b[y], b[z])，那么 ![](img/671707f6-6e01-433e-81d7-a368278356c9.png) 如下所示：

![](img/638d5253-1053-409a-91c1-228c6761e795.png)

以下是对向量叉积的矩阵和图形实现：

![](img/199f16fe-6475-4728-9686-b5741fdcaefe.png) ![](img/fdb31d82-e37f-463b-aef8-4a384926c543.png)

结果法向量的方向将遵循右手定则，即用右手的手指（从 ![](img/0f2bdafb-8c63-48e7-86fa-d27f8d18dff1.png) 到 ![](img/70a3b724-bf19-4392-b0df-61d7f52ae352.png)）弯曲时，拇指将指向结果法向量的方向 (![](img/20ec9163-4b0e-4971-97f9-48d3a7e0f5c6.png))。

此外，请注意，你乘法时向量的顺序很重要，因为如果你反过来乘，那么结果向量将指向相反的方向。

当我们想要找到多边形面（如三角形）的法线时，叉积非常有用。

以下方程帮助我们找到向量 ![](img/3c5a82d4-e513-4969-ad08-16a5c8233559.png)= (3, -5, 7) 和 ![](img/749b7e8e-3a7d-4e37-82ec-924263d4bebd.png)= (2, 4 , 1) 的叉积：

C = A × B = (ay bz - az by, az bx - ax bz, , ax by - ay bx)

= (-5 * 1 - 7*4 , 7 * 2 - 3 * 1, 3 * 4 - (-5) * 2 )

= (-5-28, 14 - 3, 12 + 10)

= (-33, 11, 22)

# 矩阵

在计算机图形学中，矩阵用于计算对象变换，例如平移，即移动，X、Y和Z轴上的缩放，以及围绕X、Y和Z轴的旋转。我们还将改变对象从一个坐标系到另一个坐标系的位置，这被称为空间变换。我们将看到矩阵是如何工作的，以及它们如何帮助我们简化必须使用的数学。

矩阵有行和列。一个有*m*行和*n*列的矩阵被称为*m × n*矩阵。矩阵的每个元素表示为索引*ij*，其中*i*指定行号，*j*表示列号。

因此，一个大小为3 × 2的矩阵M表示如下：

![](img/f1a7ed5a-9ef6-475f-b376-c4d245fd7d73.png)

这里，矩阵M有三行两列，每个元素表示为m11，m12，依此类推，直到m32，这是矩阵的大小。

在3D图形编程中，我们主要处理4 × 4矩阵。让我们看看另一个大小为4 x 4的矩阵：

![](img/a86f16b4-e714-4ee2-86ba-b7047c8cc6b4.png)

矩阵A可以表示如下：

![](img/e618f69a-a18c-4d52-873e-447fc3567f1c.png)

这里，元素是A[11] = 3, A[32] = 1, 和 A[44] = 1，矩阵的维度是4 × 4。

我们还可以有一个一维矩阵，其中向量表示如下。在这里，B被称为行向量，C被称为列向量：

![](img/3e0e45e4-a37f-45c2-8fda-43e0a918ba04.png)

+   如果行数和列数相同，并且对应元素具有相同的值，则两个矩阵相等。

+   如果两个矩阵具有相同的行数和列数，则可以将它们相加。我们将对应位置的每个元素加到两个矩阵上，以得到一个与相加矩阵具有相同维度的第三个矩阵。

# 矩阵加法和减法

考虑以下两个矩阵，A和B。这两个矩阵的大小都是3 x 3：

![](img/9d0d2993-e54b-4811-9527-0645a5f98517.png)

这里，如果C = A + B，则可以表示如下：

![](img/4ac3dcf8-3ea9-4e29-87a9-c2d84aaa7cc1.png)

当矩阵的每个元素从另一个矩阵的对应元素中减去时，矩阵减法以相同的方式工作。

# 矩阵乘法

让我们看看一个标量值如何乘以一个矩阵。我们可以通过将矩阵的每个元素乘以相同的标量值来实现这一点。这将给我们一个新的矩阵，其维度与原始矩阵相同。

再次，考虑一个矩阵A，它已经被一些标量乘过。这里，s×A，如下所示：

![](img/01a79209-4c6f-43df-a073-e0d25e0465f4.png)

两个A和B矩阵可以相乘，前提是A的列数等于B的行数。所以，如果矩阵A的维度是a × b，B的维度是X × Y，那么为了A能够乘以B，b应该等于X：

矩阵的结果大小将是a × Y。两个矩阵可以像这样相乘：

![图片](img/e6838ac1-f95d-4299-a2d4-b314e80bdd1f.png)

在这里，矩阵A的大小是3 × 2，矩阵B的大小是2 × 3，这意味着结果矩阵C的大小将是3 × 3：

![图片](img/dd17ad54-a2df-42aa-a29f-93f54b0083e0.png)

然而，请注意，矩阵乘法不是交换律的，这意味着A×B ≠ B×A。实际上，在某些情况下，甚至无法以另一种方式相乘，就像在这个例子中一样。在这里，我们甚至不能乘以B×A，因为B的列数不等于A的行数。换句话说，矩阵的内部维度应该匹配，以便维度形式为 [a![](img/704dcf14-ac4f-4ac5-88d6-6e4892b833c2.png)t] 和 [t![](img/ce4238d9-5e4c-40a0-93f7-041fb1b9038c.png)b]。

您还可以将向量矩阵与普通矩阵相乘，如下所示：

![图片](img/82ccb486-b8b8-43a1-bfc5-f603a8e8f641.png)

结果将是一个3 × 1大小的单维向量，如下所示：

![图片](img/d892153f-cd44-4ae0-bf49-8cf46e8dd5fb.png)

注意，当用矩阵乘以向量矩阵时，向量位于矩阵的右侧。这样做是为了使3 × 3大小的矩阵能够乘以3 × 1大小的向量矩阵。

当我们有一个只有一列的矩阵时，这被称为列主序矩阵。因此，矩阵C是一个列主序矩阵，就像矩阵V一样。

如果用一行来表示相同的向量V，它将被称为行主序矩阵。这可以表示如下：

![图片](img/a3184621-c6d0-4e20-8a54-8cb49544296d.png)

那么，如果内部维度不匹配，我们如何将一个大小为3 × 3的矩阵A与一个大小为1 × 3的行主序矩阵V相乘呢？

这里的简单解决方案是，而不是乘以矩阵A × V，我们乘以V × A。这样，向量矩阵和普通矩阵的内部维度将匹配1 × 3和3 × 3，结果矩阵也将是一个行主序矩阵。

在整本书中，我们将使用列主序矩阵。

如果我们要使用4 × 4矩阵，例如，我们如何使用x、y和z的坐标来乘以4 × 4矩阵？

当用X、Y和Z点乘以4 × 4矩阵时，我们在列主序矩阵中添加一行，并将其值设为1。新的点将是(X, Y, Z, 1)，这被称为齐次点。这使得用4 × 4矩阵乘以4 × 1向量变得容易：

![图片](img/c19553c6-60de-4b74-9bc7-ad63331666fe.png)

矩阵乘法可以推广到乘以另一个4 × 4矩阵。让我们看看我们如何做到这一点：

![图片](img/b4576903-6bad-4c0e-ae57-ee41d4735e70.png)

![](img/97b1de9b-b9f2-474e-aa2d-3acab4df20c0.png)

# 单位矩阵

单位矩阵是一种特殊的矩阵，其中行数等于列数。这被称为方阵。在单位矩阵中，矩阵对角线上的元素都是 1，而其余元素都是 0。

这里是一个 4 × 4 单位矩阵的例子：

![](img/1b1f9d8f-0a4b-4439-9c65-3dbf5bf11cc8.png)

单位矩阵的工作方式类似于我们乘以任何数与 1 相乘得到相同的数。同样，当我们乘以任何矩阵与单位矩阵时，我们得到相同的矩阵。

例如，A×I = A，其中 A 是一个 4 × 4 矩阵，I 是相同大小的单位矩阵。让我们来看一个这个的例子：

![](img/2d2257c9-ad98-4e5d-abe9-23183926bf08.png)

# 矩阵转置

矩阵转置发生在行和列相互交换时。所以，m X n 矩阵的转置是 n X m。任何矩阵的转置写作 M^T。矩阵的转置如下：

![](img/8273987f-a36a-46c0-8005-b0fa07a0cc18.png)

观察矩阵对角线上的元素保持不变，但所有对角线周围的元素都被交换了。

在矩阵中，这个从左上角到右下角的对角线被称为主对角线。

显然，如果你对转置矩阵再次进行转置，你会得到原始矩阵，所以 (A^T)^T = A。

# 矩阵逆

任何矩阵的逆是任何矩阵乘以其逆矩阵将得到单位矩阵的情况。对于矩阵 M，矩阵的逆表示为 M^(-1)。

逆矩阵在图形编程中非常有用，当我们想要撤销矩阵的乘法时。

例如，矩阵 M 等于 A × B × C × D，其中 A、B、C 和 D 也是矩阵。现在，假设我们想知道 A× B × C 的结果，而不是将三个矩阵相乘，这是一个两步操作：首先，你将 A 与 B 相乘，然后将得到的矩阵与 C 相乘。你可以将 M 与 D^(-1) 相乘，这将得到相同的结果：

![](img/62bbe4bc-41a7-491b-9648-3e2a4ffe67cf.png)

# GLM OpenGL 数学

为了在 OpenGL 和 Vulkan 项目中执行我们刚才看到的数学运算，我们将使用一个仅包含头文件的 C++ 数学库，称为 GLM。这最初是为了与 OpenGL 一起使用而开发的，但它也可以与 Vulkan 一起使用：

![](img/564a8c99-efc2-4116-b27b-f892e1a0b4c3.png)

最新版本的 GLM 可以从 [https://glm.g-truc.net/0.9.9/index.html](https://glm.g-truc.net/0.9.9/index.html) 下载。

除了能够创建点和执行向量加法和减法之外，GLM 还可以定义矩阵，执行矩阵变换，生成随机数，以及生成噪声。以下是一些这些函数如何执行的例子：

+   要定义 2D 和 3D 点，我们需要包含 `#include <glm/glm.hpp>`，它使用 `glm` 命名空间。要定义空间中的 2D 点，我们使用以下代码：

[PRE0]

+   要定义 3D 点，我们使用以下代码：

[PRE1]

+   使用 `glm` 也可以创建一个 4x4 矩阵，如下面的代码所示。一个 4x4 矩阵是 `mat4` 类型，可以创建如下：

[PRE2]

+   对于平移和旋转，您需要包含必要的 GLM 扩展，如下面的代码所示：

[PRE3]

+   要将对象平移到其当前位置的 (`3.0`, `4.0`, `8.0`)，请执行以下操作：

[PRE4]

+   我们还可以将值缩放，使其在 *x*、*y* 和 *z* 方向上是原来大小的两倍：

[PRE5]

上述代码通过 *x* 轴旋转对象 `45,0f` 度，通过 *y* 轴旋转 `25.0f` 度，通过 *z* 轴旋转 `10.0f` 度。

注意，我们在这里使用 `glm::radians()`。这个 `glm` 函数将度数转换为弧度。本章将介绍更多的 GLM 函数。

# OpenGL 数据类型

OpenGL 也有它自己的数据类型。这些类型可以在不同平台上移植。

OpenGL 数据类型以 GL 前缀开头，后跟数据类型。因此，与 `int` 变量等效的 GL 类型是 GLint，依此类推。以下表格显示了一个 GL 数据类型的列表（列表可查看于 [https://www.khronos.org/opengl/wiki/OpenGL_Type](https://www.khronos.org/opengl/wiki/OpenGL_Type)）：

![](img/2ee7f1f6-fd88-4c9b-ae22-6d5cc8091ef6.png)

# 空间变换

3D 图形的主要任务是模拟一个 3D 世界，并将该世界投影到一个 2D 位置，即视口窗口。我们想要渲染的 3D 或 2D 对象不过是顶点的集合。然后这些顶点被组合成三角形的集合，以形成对象的球形：

![](img/cdd49492-69b0-4cca-9a57-4a1428d38a1b.png)

左侧的截图显示了传入的顶点，而右侧的截图显示了顶点被用来创建三角形。每个三角形都形成了最终对象形状表面的一小部分。

# 本地/对象空间

当设置任何对象的顶点时，我们从坐标系的起点开始。这些顶点或点被放置，然后连接起来以创建对象的形状，例如三角形。围绕模型创建的这个坐标系被称为对象空间、模型空间或本地空间：

![](img/4ac3a96b-8985-4734-bf4c-10ab0d6bf76b.png)

# 世界空间

现在我们已经指定了模型的形状，我们想要将它放置在一个场景中，以及一些其他形状，例如球体和立方体。立方体和球体形状也是使用它们自己的模型空间创建的。当我们将这些对象放置到 3D 场景中时，我们是以 3D 对象将被放置的坐标系为基准来进行的。这个新的坐标系被称为世界坐标系，或世界空间。

将对象从对象空间移动到世界空间是通过矩阵变换完成的。对象的局部位置乘以世界空间矩阵。因此，每个顶点都乘以世界空间矩阵，以将其缩放、旋转和位置从局部空间转换到世界空间。

世界空间矩阵是缩放、旋转和平移矩阵的乘积，如下面的公式所示：

*世界矩阵 = W = T × R × S*

S、R和T分别是相对于世界空间局部空间的缩放、旋转和平移。让我们分别看看它们：

+   3D空间的缩放矩阵是一个4x4矩阵，其对角线表示*x*、*y*和*z*方向上的缩放，如下所示：

![图片4](img/d37b3b68-5f94-459f-b441-b5a6919bcb07.png)

+   旋转矩阵可以采取三种形式，具体取决于你正在旋转对象的哪个轴。*Rx*、*Ry*和*Rz*是我们用于沿每个轴旋转的矩阵，如下面的矩阵所示：

![图片1](img/57fc346b-4394-4ef6-9e89-4860ef7d1fd3.png)![图片2](img/2499f72f-7177-4a8f-ac49-b079846dc449.png)![图片3](img/f47b6148-236c-4034-9c0a-a83a707ab072.png)

+   平移矩阵是一个单位矩阵，其中最后一列表示在*x*、*y*和*z*方向上的平移：

![图片6](img/a36a7f29-dedf-44da-8d53-db1ab0cfea6f.png)

现在，我们可以通过将对象的局部位置与世界矩阵相乘来获取世界位置，如下所示：

位置[世界] = 矩阵[世界] × 位置[局部]

# 视图空间

为了查看整个场景，我们需要一个相机。这个相机还将决定哪些对象对我们是可见的，哪些对象不会被渲染到屏幕上。

因此，我们可以在场景中放置一个虚拟相机，位于某个世界位置，如下面的图所示：

![图片5](img/3c0e36de-a1eb-4fad-86c6-3c64682d14a4.png)

场景中的对象随后从世界空间转换到一个新的坐标系，该坐标系位于相机位置。这个位于相机位置的新坐标系被称为视图空间、相机空间或视点空间。*x*轴是红色，*y*轴是绿色，正*z*轴是蓝色。

要将点从世界空间转换到相机空间，我们必须使用虚拟相机位置的负值来平移它们，并使用相机朝向的负值来旋转它们。

然而，使用GLM创建视图矩阵有一个更简单的方法。我们必须提供三个变量来分别定义相机位置、相机目标位置和相机向上向量：

[PRE6]

我们可以通过调用`lookAt`函数并传递相机位置、观察位置和向上向量来使用这些变量创建视图矩阵，如下所示：

[PRE7]

一旦我们有了视图矩阵，局部位置可以通过乘以世界矩阵和视图矩阵来得到视图空间中的位置，如下所示：

位置[视图] = 视图[矩阵] × 世界[矩阵] × 位置[局部]

# 投影空间

下一个任务是将在相机中可见的3D对象投影到2D平面上。投影需要以这种方式进行，使得最远的对象看起来更小，而较近的对象看起来更大。基本上，在观察一个对象时，点需要汇聚到一个消失点上。

在下面的屏幕截图中，右边的图像显示了一个正在渲染的立方体。注意长边上的线条实际上是平行的。

然而，当从相机观察同一个盒子时，相同的侧面线会汇聚，并且当这些线被延伸时，它们会在盒子后面的一个点上汇聚：

![图片](img/e549a806-59e4-4d19-858c-345497be1435.png)

现在，我们将介绍另一个矩阵，称为投影矩阵，它允许使用透视投影渲染对象。对象的顶点将使用所谓的投影矩阵进行变换，以执行透视投影变换。

在投影矩阵中，我们定义了一个称为视锥体的投影体积。视锥体内部的所有对象将被投影到2D显示上。投影平面之外的对象将不会被渲染：

![图片](img/d29e913b-c2d3-46df-b413-9de5bc628a3a.png)

投影矩阵的创建如下：

![图片](img/e03b54bb-80f1-4690-87aa-c2fef3a73a77.png)

*q = 1/tan(FieldOfView/2)*

*A = q/Aspect Ratio*

*B = (zNear + zFar)/(zNear - zFar)*

*C = 2 *(zNear * zFar)/(zNear - zFar)*

宽高比是投影平面的宽度除以投影平面的高度。`zNear` 是从相机到近平面的距离。`zFar` 是从相机到远平面的距离。**视场角**（**FOV**）是视图视锥体上下平面之间的角度。

在GLM中，有一个我们可以用来创建透视投影矩阵的函数，如下所示：

[PRE8]

注意，`nearPlane` 总是必须大于 `0.0f`，这样我们才能在相机前方创建视锥体的起始部分。

`glm::perspective` 函数接受四个参数：

+   **FOV**

+   宽高比

+   到近平面的距离

+   到远平面的距离

因此，在获得投影矩阵后，我们最终可以对我们的视图变换点执行透视投影变换，将顶点投影到屏幕上：

Position[final] = Projection[matrix] × View[matrix] × World[matrix] × Position[local]

现在我们从理论上理解了这一点，让我们看看我们如何实际实现它。

# 屏幕空间

在将局部位置乘以模型、视图和投影矩阵之后，OpenGL会将场景转换到屏幕空间。

如果你的应用程序的屏幕大小分辨率为1,280 x 720，那么它将像这样将场景投影到屏幕上；这是相机在视图空间中的观察结果：

![图片](img/9c1e332d-5f27-4ab0-892f-474f4fdbfd81.png)

对于这个例子，窗口的宽度将是1,280像素，窗口的高度将是720像素。

# 渲染管线

如我之前所述，我们必须将由顶点和纹理组成的3D对象转换为2D屏幕上的像素，以便在屏幕上表示。这是通过所谓的渲染管线来完成的。以下图表解释了涉及的步骤：

![图表](img/e540fba9-fd41-41eb-9526-6d433e8ff8a1.png)

管道简单来说是一系列依次执行以实现特定目标的步骤。在前面的图表中，用橙色框（或如果你阅读的是黑白版本的这本书，则是浅色阴影框）突出显示的阶段是固定的，这意味着你不能修改这些阶段中数据的处理方式。蓝色或更深的框中的阶段是可编程阶段，这意味着你可以编写特殊的程序来修改输出。前面的图表显示了一个基本的管道，它包括我们完成渲染对象所需的最小阶段。还有一些其他阶段，如几何、细分和计算，这些都是可选阶段。然而，由于我们只介绍图形编程，这些内容将不会在本书中讨论。

图形管线本身对OpenGL和Vulkan都是通用的。然而，它们的实现方式不同，但我们将会在接下来的章节中看到这一点。

渲染管线用于将2D或3D对象渲染到电视或显示器上。让我们详细查看图形管线中的每个阶段。

# 顶点规范

当我们想要将对象渲染到屏幕上时，我们设置有关该对象的信息。我们需要设置的信息非常基本，即构成几何形状的点或顶点。我们将通过创建顶点数组来创建对象。这将用于创建构成我们想要渲染的几何形状的多个三角形。这些顶点需要被发送到图形管线。

例如，要向OpenGL中的管道发送信息，我们使用**顶点数组对象**（**VAO**）和**顶点缓冲区对象**（**VBO**）。VAO用于定义每个顶点具有哪些数据；VBO包含实际的顶点数据。

顶点数据可以有一系列属性。一个顶点可以具有属性属性，如位置、颜色、法线等。显然，任何顶点都需要的主要属性之一是位置信息。除了位置之外，我们还将查看可以传递的其他类型的信息，例如每个顶点的颜色。我们将在未来的章节中查看更多属性，在[第3节](e10cd758-82e9-4314-96d2-f3b93f90aca4.xhtml)，*现代OpenGL 3D游戏开发*中，当我们介绍使用OpenGL渲染原语时。

假设我们有一个由三个点组成的数组。让我们看看我们如何创建`VAO`和`VBO`：

[PRE9]

因此，让我们开始吧：

1.  首先，我们生成一个Glint类型的顶点数组对象。OpenGL返回一个实际对象的句柄，以便将来引用，如下所示：

[PRE10]

1.  然后，我们生成一个顶点缓冲区对象，如下所示：

[PRE11]

1.  接下来，我们指定缓冲区对象类型。在这里，它是`GL_ARRAY_BUFFER`类型，这意味着这是一个数组缓冲区：

[PRE12]

1.  然后，我们按照以下方式将数据绑定到缓冲区：

[PRE13]

第一个参数是数据缓冲区类型，它是`GL_ARRAY_BUFFER`类型。第二个参数是传入的数据类型的大小。`sizeof()`是C++关键字，用于获取数据的字节数。

下一个参数是数据本身，而最后一个参数用于指定这些数据是否会改变。`GL_STATIC_DRAW`表示一旦值被存储，数据将不会被修改。

1.  然后，我们指定顶点属性，如下所示：

+   第一个参数是属性的索引。在这种情况下，我们只有一个位于第0个索引的位置属性。

+   第二个是属性的大小。每个顶点由三个浮点数表示*x*，*y*和*z*，所以这里指定的值是`3`。

+   第三个参数是要传递的数据类型，它是`GL_FLOAT`类型。

+   第四个参数是一个布尔值，询问值是否应该被归一化或直接使用。我们指定`GL_FALSE`，因为我们不希望数据被归一化。

+   第五个参数称为步长；它指定了属性之间的偏移量。在这里，下一个位置的值是三个浮点数的大小，即*x*，*y*和*z*。

+   最后一个参数指定了第一个组件的起始偏移量，这里为0。我们将数据类型转换为更通用的数据类型（`void*`），称为空指针：

[PRE14]

1.  最后，我们启用第0个索引处的属性，如下所示：

[PRE15]

这是一个基本示例。当我们添加额外的属性，如颜色时，这会发生变化。

# 顶点着色器

顶点着色器阶段对每个顶点执行操作。根据你传递给顶点着色器的顶点数量，顶点着色器将被调用相应次数。如果你传递三个顶点来形成一个三角形，那么顶点着色器将被调用三次。

根据传入着色器的属性，顶点着色器会修改传入的值，并输出该属性的最终值。例如，当你传入一个位置属性时，你可以操作它的值，并在顶点着色器结束时发送出该顶点的最终位置。

以下代码是为之前传入的单个属性的基本顶点着色器：

[PRE16]

着色器是用类似于C的语言编写的程序。着色器总是以**GL着色器语言**（**GLSL**）的版本开始。还有其他着色器语言，包括**高级着色语言**（**HLSL**），它被Direct 3D和CG使用。CG也被用于Unity。

现在，我们将声明我们想要使用的所有输入属性。为此，我们使用`layout`关键字，并在括号中指定我们想要使用的属性的位置或索引。由于我们传递了一个顶点位置属性，并为其指定了索引0，同时指定了属性指针，我们将位置设置为0。然后，我们使用`in`关键字来说明我们正在接收信息。我们将每个位置值存储在一个名为`vec3`的变量类型中，并附上名称位置。

`vec3`，这是一个变量类型，用于存储传递到着色器的向量，它是GLSL内建数据类型。在这里，由于我们传递了具有*x*、*y*和*z*分量的位置信息，使用`vec3`很方便。我们还有一个`vec4`，它有一个额外的*w*分量，可以用来存储颜色信息，例如。

每个着色器都需要有一个主函数，在其中执行与着色器相关的重大功能。在这里，我们并没有做太复杂的事情：我们只是获取`vec3`，将其转换为`vec4`，然后将值设置为`gl_Position`。我们必须将`vec3`转换为`vec4`，因为`gl_Position`是一个`vec4`。它也是GLSL的内建变量，用于存储和从顶点着色器输出值。

由于这是一个基本的顶点着色器示例，我们不会将每个点与`ModelViewProjection`矩阵相乘以将点转换到投影空间。我们将在本书的后面扩展这个示例。

# 顶点后处理

在这个阶段，会发生裁剪。不在相机可见锥体内的对象不会被渲染到屏幕上。这些未显示的原始对象被称为裁剪。

假设只有部分球体是可见的。原始对象被分解成更小的原始对象，并且只有可见的原始对象将被显示。原始对象的顶点位置将从裁剪空间转换到窗口空间。

例如，在下面的图中，只有球体、三角形和长方体的部分是可见的。形状的其余部分对相机不可见，因此它们已被裁剪：

![图片](img/23c03293-0fcc-4a7f-827d-f9abaf3df9c1.png)

# 原始对象装配

原始对象装配阶段收集了上一阶段未裁剪的所有原始对象，并创建了一系列原始对象。

在这个阶段也会执行面裁剪。面裁剪是一个过程，其中位于视图前方但朝向背面的原始对象将被裁剪，因为它们是不可见的。例如，当你观察一个立方体时，你只能看到立方体的前面，而不是背面，因此当背面不可见时，渲染立方体的背面是没有意义的。这被称为背面裁剪。

# 光栅化

GPU需要将用向量描述的几何形状转换为像素。我们称之为光栅化。通过裁剪和剔除之前阶段的原始图形将被进一步处理，以便它们可以被光栅化。光栅化过程从这些原始图形中创建一系列片段。将原始图形转换为光栅化图像的过程由GPU完成。在光栅化过程中（从向量到像素），我们总是丢失信息，因此得名“原始片段的碎片”。片段着色器用于计算最终像素的颜色值，该值将被输出到屏幕。

# 片段着色器

光栅化阶段的片段随后将使用片段着色器进行处理。就像顶点着色器阶段一样，片段着色器也是一个程序，可以编写以对每个片段进行修改。

对于之前阶段的每个片段，将调用片段着色器。

这是一个基本片段着色器的示例：

[PRE17]

就像顶点着色器一样，你需要指定要使用的GLSL版本。

我们使用`out`关键字从片段着色器发送输出值。在这里，我们想要发送一个名为`Color`的`vec4`类型的变量。主函数是所有魔法发生的地方。对于每个被处理的片段，我们将`Color`的值设置为`蓝色`。因此，当原始图形被渲染到视口时，它将完全呈现蓝色。

这就是球体变成蓝色的原因。

# 每样本操作

与顶点后处理阶段裁剪原始图形的方式相同，每样本操作也会移除不会显示的片段。一个片段是否需要在屏幕上显示取决于用户可以启用的某些测试。

其中一个更常用的测试是深度测试。当启用时，这将检查一个片段是否位于另一个片段之后。如果是这种情况，则当前片段将被丢弃。例如，在这里，由于它位于灰色球体之后，只有部分立方体是可见的：

![图片](img/590f5164-1edf-4d8c-864d-5eceddc171cf.png)

我们还可以执行其他测试，例如裁剪和模板测试，这些测试将根据我们指定的某些条件只显示屏幕或对象的一部分。

颜色混合也在此阶段进行。在这里，基于某些混合方程，颜色可以进行混合。例如，在这里，球体是透明的，因此我们可以看到立方体的颜色与球体的颜色混合：

![图片](img/98373bc0-12bf-46ac-b338-adebee132395.png)

# 帧缓冲区

最后，当一帧中所有片段的每样本操作完成后，最终图像将被渲染到帧缓冲区，然后呈现在屏幕上。

帧缓冲区是一组每帧绘制的图像。这些图像中的每一个都附加到帧缓冲区上。帧缓冲区有附加物，例如显示在屏幕上的颜色图像。还有其他附加物，例如深度或图像/纹理；这仅仅存储了每个像素的深度信息。最终用户看不到这些，但有时游戏会为了图形目的使用它。

在OpenGL中，帧缓冲区在开始时自动创建。也存在用户创建的帧缓冲区，可以用来首先渲染场景，对其应用后处理，然后将它交还给系统以便在屏幕上显示。

# 摘要

在本章中，我们介绍了本书中将要用到的一些数学基础知识。特别是，我们学习了坐标系、点、向量和矩阵。然后，我们学习了如何将这些概念应用到OpenGL数学和空间变换中。之后，我们了解了GLM，这是一个数学库，我们将使用它来简化我们的数学计算。最后，我们涵盖了空间变换并理解了图形管道的流程。

在下一章中，我们将探讨如何使用像SFML这样的简单框架来制作2D游戏
