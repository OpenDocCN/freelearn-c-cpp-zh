- en: '*Chapter 21*: File I/O and the Game Object Factory'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第21章*：文件输入/输出和游戏对象工厂'
- en: This chapter handles how a `GameObject` gets into the `m_GameObjects vector`
    that's used in the game. We will look at how we can describe individual objects
    and an entire level in a text file. We will write code to interpret the text and
    then load up values into a class that will be a blueprint for a game object. We
    will also code a class called `LevelManager` that oversees the whole process,
    starting from the initial request to load a level sent from an `InputHandler`
    via the `ScreenManager`, right through to the factory pattern class that assembles
    a game object from components and delivers it to the `LevelManager`, neatly packed
    away in the `m_GameObjects vector`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章处理 `GameObject` 如何进入游戏中使用的 `m_GameObjects vector`。我们将探讨如何在文本文件中描述单个对象和整个关卡。我们将编写代码来解释文本，然后将值加载到一个将成为游戏对象蓝图的类中。我们还将编写一个名为
    `LevelManager` 的类，它监督整个流程，从 `InputHandler` 通过 `ScreenManager` 发送的初始加载关卡请求开始，一直到工厂模式类从组件组装游戏对象并将其交付给
    `LevelManager`，最后将其整齐地打包到 `m_GameObjects vector` 中。
- en: 'The following are the steps we will go through in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将经历的步骤如下：
- en: Examine how we will describe game objects and their components in a text file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查我们如何在文本文件中描述游戏对象及其组件
- en: Code the `GameObjectBlueprint` class where the data from the text file will
    be temporarily stored
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 `GameObjectBlueprint` 类，其中将临时存储来自文本文件的数据
- en: Code the `ObjectTags` class to help describe game objects consistently and without
    errors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 `ObjectTags` 类以帮助一致且无错误地描述游戏对象
- en: Code `BluePrintObjectParser`, which will be responsible for loading the data
    from a game object description in the text file into a `GameObjectBlueprint` instance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码 `BluePrintObjectParser` 负责从文本文件中的游戏对象描述中加载数据到 `GameObjectBlueprint` 实例
- en: Code `PlayModeObjectLoader`, which will open the text file and receive the `GameObjectBlueprint`
    instances one at a time from `BlueprintObjectParser`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码 `PlayModeObjectLoader`，它将打开文本文件，并从 `BlueprintObjectParser` 逐个接收 `GameObjectBlueprint`
    实例
- en: Code the `GameObjectFactoryPlayMode` class, which will construct `GameObject`
    instances from `GameObjectBlueprint` instances
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 `GameObjectFactoryPlayMode` 类，它将从 `GameObjectBlueprint` 实例构建 `GameObject`
    实例
- en: Code the `LevelManager` class, which oversees this entire process after receiving
    an instruction from the `ScreenManager` class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 `LevelManager` 类，它在接收到 `ScreenManager` 类的指令后监督整个流程
- en: Add the code to the `ScreenManager` class so that we can begin using the new
    system that we will code in this chapter
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码添加到 `ScreenManager` 类中，以便我们可以开始使用本章我们将编写的新的系统
- en: Let's start by examining exactly how we describe a game object such as a space
    invader or a bullet in a text file, let alone a whole wave of them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来具体看看如何在文本文件中描述一个游戏对象，比如一个太空侵略者或子弹，更不用说一整波的它们了。
- en: The structure of the file I/O and factory classes
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件输入/输出和工厂类的结构
- en: 'Have a look at the following diagram, which gives an overview of the classes
    we will code in this chapter and how the `vector` of `GameObject` instances will
    be shared with the `ScreenManager` class that we coded in [*Chapter 19*](B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372),
    *Game Programming Design Patterns – Starting the Space Invaders ++ Game*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下图表，它概述了本章我们将编写的类以及 `GameObject` 实例的 `vector` 将如何与我们在 [*第19章*](B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372)
    中编写的 `ScreenManager` 类共享，*游戏编程设计模式 – 开始太空侵略者 ++ 游戏*：
- en: '![](img/Image93956.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image93956.jpg)'
- en: The preceding diagram shows that there is a `vector` of `GameObject` instances
    that's shared between four classes. This is achieved by passing the `vector` between
    the functions of the classes by reference. Each class can then carry out its role
    with the `vector` and its contents. The `ScreenManager` class will trigger the
    `LevelManager` class when a new level needs to be loaded into the `vector`. The
    individual `Screen` classes and their `InputHandler`-derived classes, as we saw
    in [*Chapter 19*](B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372), *Game Programming
    Design Patterns – Starting the Space Invaders ++ Game*, have access to `ScreenManager`
    via `ScreenManagerRemoteControl`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示显示，存在一个`GameObject`实例的`vector`，它在四个类之间共享。这是通过在类的函数之间通过引用传递`vector`来实现的。每个类都可以使用`vector`及其内容来执行其角色。当需要将新级别加载到`vector`中时，`ScreenManager`类将触发`LevelManager`类。正如我们在[*第19章*](B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372)，“游戏编程设计模式
    - 开始Space Invaders ++ 游戏”中看到的，单个`Screen`类及其由`InputHandler`派生的类可以通过`ScreenManagerRemoteControl`访问`ScreenManager`。
- en: The `LevelManager` class is ultimately responsible for creating and sharing
    the vector. `PlayModeObjectLoader` will use `BlueprintObjectParser` to create
    `GameObjectBlueprint` instances.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`LevelManager`类最终负责创建和共享这个`vector`。`PlayModeObjectLoader`将使用`BlueprintObjectParser`来创建`GameObjectBlueprint`实例。'
- en: The `GameObjectFactoryPlayMode` class will complete the `GameObject` creation
    process using these `GameObjectBlueprint` instances and pack `GameObject` instances
    into the `vector` when prompted to do so by `PlayModeObjectLoader`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameObjectFactoryPlayMode`类将使用这些`GameObjectBlueprint`实例完成`GameObject`的创建过程，并在`PlayModeObjectLoader`提示时将这些`GameObject`实例打包到`vector`中。'
- en: So, where do the different component, position, size, and appearance configurations
    for each `GameObject` instance come from?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，每个`GameObject`实例的不同组件、位置、大小和外观配置是从哪里来的？
- en: We can also see that three classes have access to a `GameObjectBlueprint` instance.
    This instance is created by the `LevelManager` class and passed around by reference.
    `BlueprintObjectParser` will read the `level1.txt` file, which has all the details
    of each of the game objects. It will initialize all the variables of the `GameObjectBlueprint`
    class. `PlayModeObjectLoader` will then pass a reference to the `vector` of `GameObject`
    instances, and also pass a reference to the fully configured `GameObjectBlueprint`
    instance to the `GameObjectFactoryPlayMode` class. This is repeated until all
    the `GameObject` instances are packed away in the `vector`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到，有三个类可以访问一个`GameObjectBlueprint`实例。这个实例由`LevelManager`类创建并通过引用传递。`BlueprintObjectParser`将读取`level1.txt`文件，该文件包含每个游戏对象的详细信息。它将初始化`GameObjectBlueprint`类的所有变量。然后`PlayModeObjectLoader`将传递一个`GameObject`实例的`vector`的引用，并将一个完全配置的`GameObjectBlueprint`实例的引用传递给`GameObjectFactoryPlayMode`类。这个过程会重复，直到所有的`GameObject`实例都被打包到`vector`中。
- en: You might be wondering why I have used slightly cumbersome class names such
    as `GameObjectFactoryPlayMode` and `PlayModeObjectLoader`. The reason is that,
    once you see how convenient this system is, you might like to build tools that
    allow you to design your levels in a visual way by dragging and dropping them
    where required and then have the text file auto-generated rather than typed. This
    is not especially complicated, but I had to stop adding features to the game at
    some point. Therefore, you might well end up with a `GameObjectFactoryDesignMode`
    and a `DesignModeObjectLoader`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我使用了像`GameObjectFactoryPlayMode`和`PlayModeObjectLoader`这样稍微有些繁琐的类名。原因是，一旦你看到这个系统有多方便，你可能就会想构建工具，允许你通过拖放所需的位置来以可视化的方式设计你的级别，然后自动生成文本文件而不是手动输入。这并不特别复杂，但我不得不在某一点停止添加游戏功能。因此，你可能会最终拥有一个`GameObjectFactoryDesignMode`和一个`DesignModeObjectLoader`。
- en: Describing an object in the world
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述世界中的对象
- en: We have already added the `level1.txt` file in the `world` folder in [*Chapter
    19*](B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372), *Game Programming Design
    Patterns – Starting the Space Invaders ++ Game*. Let's discuss its uses, future
    intended uses, and its contents.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第19章*](B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372)，“游戏编程设计模式 - 开始Space
    Invaders ++ 游戏”中添加了`world`文件夹中的`level1.txt`文件。让我们讨论它的用途、未来预期用途及其内容。
- en: First, I would like to point out that a shooter game is not the best way to
    demonstrate how to describe a game world in a text file like this. The reason
    for this is that there are only a few types of game object and the most common
    one, invaders, are all lined up uniformly like soldiers on parade. They would
    actually be more efficiently described programmatically, perhaps in a nested `for`
    loop. However, the intention of this project was to show the ideas, rather than
    learn how to make a Space Invaders clone.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我想指出，射击游戏并不是演示如何在文本文件中描述游戏世界的最佳方式。原因在于游戏中只有几种类型的游戏物体，最常见的入侵者都像列队行进的士兵一样整齐排列。实际上，它们可能更有效地通过编程描述，比如在一个嵌套的`for`循环中。然而，这个项目的目的是展示这些想法，而不是学习如何制作太空入侵者克隆。
- en: 'Take a look at the following text, which is a sample from the `level1.txt`
    file in the `world` folder:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下文本，这是来自`world`文件夹中`level1.txt`文件的样本：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding text describes a single object in the game; in this case, an
    invader. The object begins with the following text:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的文本描述了游戏中的一个单个物体；在这种情况下，是一个入侵者。该物体以以下文本开始：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That will inform our code we''ll write that a new object is being described.
    Next in the text, we can see the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通知我们即将编写的代码，正在描述一个新的物体。在文本的下一部分，我们可以看到以下内容：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This informs the code that the type of object is an invader. This will eventually
    be set as the `m_Tag` of the `ColliderComponent` class. The invader will be identifiable
    for what it is. The text that comes next is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这通知代码该物体的类型是一个入侵者。这最终将被设置为`ColliderComponent`类的`m_Tag`。入侵者将能被识别出其身份。接下来的文本如下：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This tells our system that this object will have three components added to
    it: a `StandardGraphicsComponent` instance, an `InvaderUpdateComponent` instance,
    and a `TransformComponent` instance. This means the object will be drawn in the
    standard way and will behave according to the rules we coded for an invader. It
    will also mean it has a location and scale in the game world. It is possible to
    have objects that don''t have any components or fewer components. An object that
    takes no action and doesn''t move will not need an update component, an object
    that is invisible will not need a graphics component (perhaps just an invisible
    collider which triggers some action), and an object that has no position in the
    world (perhaps a debugging object) will not need a transform component.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们系统，此物体将添加三个组件：一个`StandardGraphicsComponent`实例、一个`InvaderUpdateComponent`实例和一个`TransformComponent`实例。这意味着物体将以标准方式绘制，并按照我们为入侵者编写的规则进行行为。这也意味着它在游戏世界中有一个位置和大小。可能存在没有任何组件或组件较少的物体。一个不采取任何行动且不移动的物体不需要更新组件，一个不可见的物体不需要图形组件（可能只是一个不可见的碰撞器，可以触发某些动作），以及一个在世界上没有位置的物体（可能是一个调试对象）不需要变换组件。
- en: 'The position and scale of an object are determined by the following four lines
    of text:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 物体的位置和大小由以下四行文本确定：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following line of text determines what graphics file will be used for the
    texture of this object:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行文本决定了将用于此物体纹理的图形文件：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following line means that the object can be collided with. A decorative
    object, perhaps floating clouds (or a bee), would not need a collider:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行意味着该物体可以发生碰撞。一个装饰性物体，比如漂浮的云（或一只蜜蜂），可能不需要碰撞器：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The final line of text will inform our system that the object has finished
    describing itself:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 文本的最后一行将通知我们的系统，物体已经完成了自我描述：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s have a look at how we describe a bullet object:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们是如何描述一个子弹物体的：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is very similar but not the same as an invader. A bullet object has additional
    data, such as a set speed. The invader's speed is set in the logic of the `InvaderUpdateComponent`
    class. We could have done this for the bullet's speed as well, but this demonstrates
    that you can describe the object in as much or as little detail as the specific
    game design requires. Also, as we would expect, a bullet has a `BulletUpdateComponent`
    and a different value for the `[BITMAP NAME]` element. Notice that the location
    of the bullet is set to -1, -1\. This means the bullets are outside of the playable
    area at the start of the game. In the next chapter, we will see how an invader,
    or the player, can spawn them into action when required.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这与入侵者非常相似，但又不完全相同。子弹对象有额外的数据，例如设置速度。入侵者的速度是在 `InvaderUpdateComponent` 类的逻辑中设置的。我们也可以为子弹的速度做同样的事情，但这表明你可以根据特定的游戏设计要求，以尽可能多或尽可能少的细节来描述对象。同样，正如我们所期望的，子弹有一个
    `BulletUpdateComponent` 和 `[BITMAP NAME]` 元素的不同值。请注意，子弹的位置被设置为 -1, -1。这意味着子弹在游戏开始时位于可玩区域之外。在下一章中，我们将看到入侵者或玩家如何在需要时将它们激活。
- en: 'Now, study the following text, which describes the player''s ship:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，学习以下文本，它描述了玩家的飞船：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding text was probably quite predictable based on our discussion so
    far. Now that we've gone through this, we can get to work on coding the system
    that will interpret these object descriptions and convert them into usable `GameObject`
    instances.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前的讨论，前面的文本可能相当可预测。现在我们已经通过了这一部分，我们可以开始编码系统，该系统将解释这些对象描述并将它们转换为可用的 `GameObject`
    实例。
- en: Coding the GameObjectBlueprint class
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码 GameObjectBlueprint 类
- en: 'Create a new header file in the `Header Files/FileIO` filter called `GameObjectBlueprint.h`
    and add the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Header Files/FileIO` 过滤器中创建一个新的头文件，命名为 `GameObjectBlueprint.h`，并添加以下代码：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`GameObjectBlueprint` has a member variable for every possible property that
    could go into a game object. Note that it does not compartmentalize the properties
    by component. For example, it just has variables for things such as width, height,
    and location; it doesn''t go to the trouble of identifying these as part of the
    transform component. These details are handled in the factory. It also provides
    getters and setters so that the `BlueprintObjectParser` class can pack away all
    the values from the `level1.txt` file and the `GameObjectFactoryPlayMode` class
    can extract all the values, instantiate the appropriate components, and add them
    to an instance of `GameObject`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameObjectBlueprint` 为可能放入游戏对象中的每个属性都有一个成员变量。请注意，它并没有按组件对属性进行分类。例如，它只有宽度、高度和位置等变量的变量，它不费心将这些识别为变换组件的一部分。这些细节在工厂中处理。它还提供了获取器和设置器，以便
    `BlueprintObjectParser` 类可以将 `level1.txt` 文件中的所有值打包起来，而 `GameObjectFactoryPlayMode`
    类可以提取所有值，实例化适当的组件，并将它们添加到 `GameObject` 的实例中。'
- en: 'Create a new source file in the `Source Files/FileIO` filter called `GameObjectBlueprint.cpp`
    and add the following code, which is for the definitions of the functions we have
    just declared:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Source Files/FileIO` 过滤器中创建一个新的源文件，命名为 `GameObjectBlueprint.cpp`，并添加以下代码，这是为我们刚刚声明的函数的定义：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Although this is a long class, there is nothing here we haven't seen before.
    The setter functions receive values which are copied into a vector or a variable,
    while the getters allow access to these values.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个很长的类别，但这里没有我们之前没有见过的内容。设置函数接收值，这些值被复制到一个向量或变量中，而获取器允许访问这些值。
- en: Coding the ObjectTags class
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码 ObjectTags 类
- en: The way in which we describe the game objects in the `level1.txt` file needs
    to be precise because the `BlueprintObjectParser` class we will code after this
    class will be reading the text from the file and looking for matches. For example,
    the `[START OBJECT]` tag will trigger the start of a new object. If that tag is
    misspelled as, say, `[START OBJECR]`, then the whole system falls apart and there
    will be all kinds of bugs, and even crashes when we run the game. To avoid this
    happening, we will define constant (programmatically unchangeable) `string` variables
    for all the tags we need to describe the game objects. We can use these `string`
    variables instead of typing something such as `[START OBJECT]` and have much less
    chance of making a mistake.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `level1.txt` 文件中描述游戏对象的方式必须精确，因为我们在本类之后将要编写的 `BlueprintObjectParser` 类将读取文件中的文本并寻找匹配项。例如，`[START
    OBJECT]` 标签将触发新对象的开始。如果该标签被误拼为，例如 `[START OBJECR]`，那么整个系统就会崩溃，并且会出现各种错误，甚至在我们运行游戏时发生崩溃。为了避免这种情况发生，我们将为所有需要描述游戏对象的标签定义常量（程序不可更改的）`string`
    变量。我们可以使用这些 `string` 变量而不是键入 `[START OBJECT]`，从而大大减少出错的机会。
- en: 'Create a new header file in the `Header Files/FileIO` filter called `ObjectTags.h`
    and add the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Header Files/FileIO` 过滤器中创建一个新的头文件，命名为 `ObjectTags.h`，并添加以下代码：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have declared a `const string` for every tag we will use to describe the
    game objects. Now, we can initialize them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为将要用于描述游戏对象的每个标签都声明了一个 `const string`。现在，我们可以初始化它们。
- en: 'Create a new source file in the `Source Files/FileIO` filter called `ObjectTags.cpp`
    and add the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Source Files/FileIO` 过滤器中创建一个新的源文件，命名为 `ObjectTags.cpp`，并添加以下代码：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That's all the `string` variables initialized. We can now use them in the next
    class and be sure we are describing the game objects consistently.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `string` 变量都已初始化。现在我们可以将它们用于下一个类，并确保我们一致地描述游戏对象。
- en: Coding the BlueprintObjectParser class
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 BlueprintObjectParser 类
- en: This class will have the code that actually reads the text from the `level1.txt`
    file we have discussed. It will parse one object at a time, as identified by the
    start and end tags we saw previously.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将包含实际从 `level1.txt` 文件中读取文本的代码。它将一次解析一个对象，就像我们之前看到的起始和结束标签所标识的那样。
- en: 'Create a new header file in the `Header Files/FileIO` filter called `BlueprintObjectParser.h`
    and add the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Header Files/FileIO` 过滤器中创建一个新的头文件，命名为 `BlueprintObjectParser.h`，并添加以下代码：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `extractStringBetweenTags` private function will capture the content between
    two tags. The parameters are three `string` instances. The first `string` is a
    full line of text from `level1.txt`, while the second and third are the start
    and end tags, which need to be discarded. The text between the two tags is then
    returned to the calling code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`extractStringBetweenTags` 私有函数将捕获两个标签之间的内容。参数是三个 `string` 实例。第一个 `string`
    是来自 `level1.txt` 的完整文本行，而第二个和第三个是起始和结束标签，需要被丢弃。然后，两个标签之间的文本被返回给调用代码。'
- en: The `parseNextObjectForBlueprint` function receives an `ifstream` reader, just
    like the one we used in the Zombie shooter and the Thomas Was Late games. It is
    used to read from the file. The second parameter is a reference to a `GameObjectBlueprint`
    instance. The function will populate the `GameObjectBlueprint` instance with the
    values that were read from the `level1.txt` file, which can then be used back
    in the calling code to create an actual `GameObject`. We will see how that happens
    when we code the `PlayModeObjectLoader` class next and the `GameObjectFactoryPlayMode`
    class after that.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseNextObjectForBlueprint` 函数接收一个 `ifstream` 读取器，就像我们在僵尸射击游戏和托马斯迟到的游戏中使用的那样。它用于从文件中读取。第二个参数是
    `GameObjectBlueprint` 实例的引用。该函数将使用从 `level1.txt` 文件中读取的值填充 `GameObjectBlueprint`
    实例，这些值随后可以在调用代码中用于创建实际的 `GameObject`。我们将在编写 `PlayModeObjectLoader` 类时看到这个过程，之后是
    `GameObjectFactoryPlayMode` 类。'
- en: Let's code the definitions we have just discussed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写我们刚刚讨论的定义。
- en: 'Create a new source file in the `Source Files/FileIO` filter called `BlueprintObjectParser.cpp`
    and add the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Source Files/FileIO` 过滤器中创建一个新的源文件，命名为 `BlueprintObjectParser.cpp`，并添加以下代码：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code in `parseNextObjectForBlueprint` is lengthy but straightforward. The
    series of `if` statements identifies the starting tag at the beginning of the
    line of text and then passes the line of text to the `extractStringBetweenTags`
    function, which returns the value that is then loaded into the `GameObjectBlueprint`
    reference in the appropriate place. Notice that the function exits when `GameObjectBlueprint`
    has had all the data loaded into it. This point is recognized when `ObjectTags::END_OF_OBJECT`
    is found.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseNextObjectForBlueprint` 中的代码虽然长，但很直接。一系列的 `if` 语句识别文本行开头的起始标签，然后将该文本行传递给
    `extractStringBetweenTags` 函数，该函数返回的值随后被加载到 `GameObjectBlueprint` 引用适当的位置。请注意，当
    `GameObjectBlueprint` 已加载所有数据时，函数会退出。这一点可以通过找到 `ObjectTags::END_OF_OBJECT` 来识别。'
- en: Coding the PlayModeObjectLoader class
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 `PlayModeObjectLoader` 类
- en: This is the class that will pass `GameObjectBlueprint` instances to `BlueprintObjectParser`.
    When it gets the completed blueprint back, it will pass them to the `GameObjectFactoryPlayMode`
    class, which will construct the `GameObject` instance and pack it away in the
    `vector` instance. Once all the `GameObject` instances have been built and stored,
    responsibility will be handed to the `LevelManager` class, which will control
    access to the vector for other parts of the game engine. This is a very small
    class with just one function, but it links many other classes together. Refer
    to the diagram at the start of this chapter for clarification.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将 `GameObjectBlueprint` 实例传递给 `BlueprintObjectParser` 的类。当它收到完整的蓝图后，它将它们传递给
    `GameObjectFactoryPlayMode` 类，该类将构建 `GameObject` 实例并将其打包到 `vector` 实例中。一旦所有 `GameObject`
    实例都构建并存储，责任将转交给 `LevelManager` 类，该类将控制对游戏引擎其他部分的向量访问。这是一个非常小的类，只有一个函数，但它将许多其他类连接在一起。请参考本章开头的图解以获得澄清。
- en: 'Create a new header file in the `Header Files/FileIO` filter called `PlayModeObjectLoader.h`
    and add the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Header Files/FileIO` 过滤器中创建一个新的头文件，命名为 `PlayModeObjectLoader.h`，并添加以下代码：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `PlayModeObjectLoader` class has an instance of the previous class we coded,
    that is, the `BluePrintObjectParser` class. It also has an instance of the class
    we will code next, that is, the `GameObjectFactoryPlayMode` class. It has a single
    public function, which receives a reference to a `vector` that holds `GameObject`
    instances.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayModeObjectLoader` 类包含我们之前编写的类的实例，即 `BluePrintObjectParser` 类。它还包含我们将要编写的类的实例，即
    `GameObjectFactoryPlayMode` 类。它有一个单独的公共函数，该函数接收一个指向包含 `GameObject` 实例的 `vector`
    的引用。'
- en: 'Now, we will code the definition of the `loadGameObjectsForPlayMode` function.
    Create a new source file in the `Source Files/FileIO` filter called `PlayModeObjectLoader.cpp`
    and add the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写 `loadGameObjectsForPlayMode` 函数的定义。在 `Source Files/FileIO` 过滤器中创建一个新的源文件，命名为
    `PlayModeObjectLoader.cpp`，并添加以下代码：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The function receives a `string`, which is the path to the file that needs to
    be loaded. This game only has one such file, but you could add more files with
    different layouts, varying numbers of invaders, or totally different game objects
    if you wanted to.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接收一个 `string`，这是需要加载的文件的路径。这个游戏只有一个这样的文件，但如果你愿意，可以添加更多具有不同布局、不同数量的入侵者或完全不同的游戏对象的文件。
- en: An `ifstream` instance is used to read one line at a time from the file. In
    the `while` loop, the start tag is identified using `ObjectTags::START_OF_OBJECT`,
    and the `parseNextObjectForBlueprint` function of `BlueprintObjectParser` is called.
    You probably remember from the `BlueprintObjectParser` class that the completed
    blueprint is returned when `ObjectTags::END_OF_OBJECT` is reached.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ifstream` 实例逐行读取文件。在 `while` 循环中，使用 `ObjectTags::START_OF_OBJECT` 识别起始标签，并调用
    `BlueprintObjectParser` 的 `parseNextObjectForBlueprint` 函数。你可能还记得，从 `BlueprintObjectParser`
    类中，当达到 `ObjectTags::END_OF_OBJECT` 时，会返回完整的蓝图。
- en: The next line of code calls the `buildGameObject` of the `GameObjectFactoryPlayMode`
    class and passes in the `GameObjectBlueprint` instance. We will code the `GameObjectFactory`
    class now.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条代码调用 `GameObjectFactoryPlayMode` 类的 `buildGameObject` 方法，并传入 `GameObjectBlueprint`
    实例。我们现在将编写 `GameObjectFactory` 类。
- en: Coding the GameObjectFactoryPlayMode class
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 `GameObjectFactoryPlayMode` 类
- en: Now, we will code our factory, which will construct working game objects from
    the `GameObject` class and all the component related classes that we coded in
    the previous chapter. We will make extensive use of smart pointers, so we don't
    have to worry about deleting memory when we have finished with it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写我们的工厂代码，该工厂将从`GameObject`类以及我们在上一章中编写的所有相关组件类构建工作游戏对象。我们将大量使用智能指针，这样我们就不必担心在完成使用后删除内存。
- en: 'Create a new header file in the `Header Files/FileIO` filter called `GameObjectFactoryPlayMode.h`
    and add the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/FileIO`过滤器中创建一个新的头文件，命名为`GameObjectFactoryPlayMode.h`，并添加以下代码：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The factory class has just one function, `buildGameObject`. We have already
    seen the code that calls this function in the previous code we wrote for the `PlayModeObjectLoader`
    class. The function receives a reference to the blueprint, as well as a reference
    to the `vector` of `GameObject` instances.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂类只有一个函数，即`buildGameObject`。我们已经在之前为`PlayModeObjectLoader`类编写的代码中看到了调用此函数的代码。该函数接收蓝图引用以及`GameObject`实例的`vector`引用。
- en: 'Create a new source file in the `Source Files/FileIO` filter called `GameObjectFactoryPlayMode.cpp`
    and add the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/FileIO`过滤器中创建一个新的源文件，命名为`GameObjectFactoryPlayMode.cpp`，并添加以下代码：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first thing that happens in the `buildGameObject` function is that a new
    `GameObject` instance is created and the `setTag` function of the `GameObject`
    class is used to pass in the name of the current object being built:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`buildGameObject`函数中发生的第一件事是创建一个新的`GameObject`实例，并使用`GameObject`类的`setTag`函数传入正在构建的当前对象名称：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, a `for` loop loops through all the components in the `m_Components vector`.
    For each component that is found, a different `if` statement creates a component
    of the appropriate type. The way that each component is created varies, as you
    would expect since the way they are coded varies.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，一个`for`循环遍历`m_Components`向量中的所有组件。对于找到的每个组件，一个不同的`if`语句创建相应类型的组件。每个组件的创建方式各不相同，正如您所预期的，因为它们的编码方式各不相同。
- en: 'The following code creates a shared pointer to a `TransformComponent` instance.
    You can see the necessary arguments being passed to the constructor, that is,
    width, height, and location. The result of creating the new shared pointer to
    a `TransformComponent` instance is passed to the `addComponent` function of the
    `GameObject` class. The `GameObject` instance now has its size and place in the
    world:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个指向`TransformComponent`实例的共享指针。您可以看到传递给构造函数的必要参数，即宽度、高度和位置。创建指向`TransformComponent`实例的新共享指针的结果传递给了`GameObject`类的`addComponent`函数。现在，`GameObject`实例具有其大小和在世界中的位置：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following code executes when a `PlayerUpdateComponent` is required. Again,
    the code creates a new shared pointer to the appropriate class and passes it in
    to the `addComponent` function of the `GameObject` instance:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在需要`PlayerUpdateComponent`时执行。同样，代码创建了一个指向适当类的新的共享指针，并将其传递给`GameObject`实例的`addComponent`函数：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following three blocks of code use exactly the same technique to add either
    an `InvaderUpdateComponent`, `BulletUpdateComponent`, or `StandardGraphicsComponent`
    instance. Notice the extra line of code after adding a `StandardGraphicsComponent`
    instance that calls the `initialize` function, which adds a `Texture` instance
    (if required) to the `BitmapStore` singleton and prepares the component to be
    drawn:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三段代码使用完全相同的技术添加`InvaderUpdateComponent`、`BulletUpdateComponent`或`StandardGraphicsComponent`实例。注意在添加`StandardGraphicsComponent`实例后添加的额外代码行，该代码行调用`initialize`函数，该函数将`Texture`实例（如果需要）添加到`BitmapStore`单例，并准备组件以便绘制：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The final `if` block, as shown in the following code, handles adding a `RectColliderComponent`
    instance. The first line of code creates the shared pointer, while the second
    line of code calls the `addComponent` function to add the instance to the `GameObject`
    instance. The third line of code calls the `setOrMoveCollider` and passes in the
    location and size of the object. At this stage, the object is ready to be collided
    with. Obviously, we still need to write the code that tests for collisions. We
    will do so in the next chapter:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码所示的最后一个`if`块处理添加`RectColliderComponent`实例。第一行代码创建共享指针，第二行代码调用`addComponent`函数将实例添加到`GameObject`实例。第三行代码调用`setOrMoveCollider`并传入对象的位置和大小。在这个阶段，对象准备好进行碰撞。显然，我们仍然需要编写测试碰撞的代码。我们将在下一章中这样做：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following line of code in the class adds the just-constructed `GameObject`
    instance to the `vector` that will be shared with the `GameScreen` class and used
    to make the game come to life:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的以下代码行将刚刚构建的`GameObject`实例添加到将与`GameScreen`类共享的`vector`中，并用于使游戏变得生动：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The next class we will write makes it easy to share the `vector` we have just
    filled with `GameObject` instances around the various classes of the project.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的下一个类使得在项目的各个类之间共享我们刚刚用`GameObject`实例填充的`vector`变得容易。
- en: Coding the GameObjectSharer class
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写GameObjectSharer类
- en: This class will have two pure virtual functions that share `GameObject` instances
    with other classes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此类将有两个共享`GameObject`实例的纯虚函数。
- en: 'Create a new header file in the `Header Files/FileIO` filter called `GameObjectSharer.h`
    and add the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/FileIO`筛选器中创建一个新的头文件，命名为`GameObjectSharer.h`，并添加以下代码：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `getGameObjectsWithGOS` function returns a reference to the entire vector
    of `GameObject` instances. The `findFirstObjectWithTag` function returns just
    a single `GameObject` reference. We will see how we implement these functions
    when we inherit from `GameObjectSharer` when we code the `LevelManager` class
    next.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`getGameObjectsWithGOS`函数返回整个`GameObject`实例`vector`的引用。`findFirstObjectWithTag`函数返回单个`GameObject`引用。当我们编写`LevelManager`类时，我们将看到如何实现这些函数。'
- en: 'Briefly, before the `LevelManager` class, create a new source file in the `Source
    Files/FileIO` filter called `GameObjectSharer.cpp` and add the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在`LevelManager`类之前，在`Source Files/FileIO`筛选器中创建一个新的源文件，命名为`GameObjectSharer.cpp`，并添加以下代码：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Again, this is just a placeholder file and the full functionality goes in any
    of the classes that inherit from `GameObjectSharer`; in this case, the `LevelManager`
    class.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这只是一个占位符文件，完整的功能将包含在从`GameObjectSharer`继承的任何类中；在这种情况下，是`LevelManager`类。
- en: Coding the LevelManager class
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写LevelManager类
- en: The `LevelManager` class is the connection between what we coded in [*Chapter
    19*](B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372), *Game Programming Design
    Patterns – Starting the Space Invaders ++ Game*, and everything we coded in this
    chapter. The `ScreenManager` class will have an instance of the `LevelManager`
    class, and the `LevelManager` class will instigate loading levels (using all the
    classes we have just coded) and share `GameObject` instances with any classes
    that need them.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`LevelManager`类是我们编写的[*第19章*](B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372)，*游戏编程设计模式
    – 开始Space Invaders ++ 游戏*，以及本章中我们编写的所有代码之间的连接。`ScreenManager`类将包含`LevelManager`类的实例，`LevelManager`类将启动加载关卡（使用我们刚刚编写的所有类）并与需要它们的任何类共享`GameObject`实例。'
- en: 'Create a new header file in the `Header Files/Engine` filter called `LevelManager.h`
    and add the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/Engine`筛选器中创建一个新的头文件，命名为`LevelManager.h`，并添加以下代码：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This class provides two different ways to get the `vector` full of the game
    objects. One way is via a simple call to `getGameObjects`, but another is via
    the `getGameObjectsWithGOS` function. The latter is the implementation of a pure
    virtual function from the `GameObjectSharer` class and will be a way to pass access
    to each and every game object so that is has access to all the other game objects.
    You may recall from [*Chapter 20*](B14278_20_Final_AG_ePub.xhtml#_idTextAnchor414),
    *Game Objects and Components*, that a `GameObjectSharer` instance is passed in
    during the `start` function call of the `GameObject` class. It was in this function
    that, among other things, the invaders could get access to the location of the
    player.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此类提供了两种获取充满游戏对象`vector`的不同方式。一种是通过简单的调用`getGameObjects`，另一种是通过`getGameObjectsWithGOS`函数。后者是`GameObjectSharer`类中纯虚函数的实现，它将成为一种传递访问每个游戏对象的方式，以便它能够访问所有其他游戏对象。您可能还记得从[*第20章*](B14278_20_Final_AG_ePub.xhtml#_idTextAnchor414)，*游戏对象和组件*，在`GameObject`类的`start`函数调用期间传递了`GameObjectSharer`实例。正是在这个函数中，除了其他事情之外，入侵者能够获取到玩家的位置。
- en: 'There are also two private functions: `runStartPhase`, which loops through
    all the `GameObject` instances calling start, and `activateAllGameObjects`, which
    loops through and sets all the `GameObject` instances to the active status.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有两个私有函数：`runStartPhase`，它遍历所有`GameObject`实例调用`start`，以及`activateAllGameObjects`，它遍历并将所有`GameObject`实例设置为活动状态。
- en: Also, part of the `LevelManager` class is the `loadGameObjectsForPlayMode` function,
    which will trigger the entire game object creation process that the rest of this
    chapter has described.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`LevelManager` 类的一部分是 `loadGameObjectsForPlayMode` 函数，它将触发本章描述的整个游戏对象创建过程。
- en: The final function in the `LevelManger.h` file is the implementation of the
    other `GameObjectSharer` pure virtual function, `findFirstObjectWithTag`. This
    allows any class with a `GameObjectSharer` instance to track down a specific game
    object using its tag. The code loops through all the `GameObject` instances in
    the `vector` and returns the first match. Note, that if no match is found, a null
    pointer will be returned and crash the game. We use an `#ifdef` statement to output
    some text to the console to tell us what caused the crash so that we won't be
    scratching our heads for hours should we accidentally search for a tag that doesn't
    exist.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`LevelManger.h` 文件中的最后一个函数是实现其他 `GameObjectSharer` 纯虚函数 `findFirstObjectWithTag`
    的代码。这允许任何具有 `GameObjectSharer` 实例的类通过其标签追踪特定的游戏对象。代码遍历 `vector` 中的所有 `GameObject`
    实例，并返回第一个匹配项。注意，如果没有找到匹配项，将返回一个空指针并导致游戏崩溃。我们使用 `#ifdef` 语句向控制台输出一些文本，告诉我们导致崩溃的原因，这样我们就不必为几个小时找不到不存在的标签而抓耳挠腮。'
- en: We can now code the implementations of the functions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编写函数的实现代码了。
- en: 'Create a new source file in the `Source Files/Engine` filter called `LevelManager.cpp`
    and add the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Source Files/Engine` 过滤器中创建一个新的源文件，命名为 `LevelManager.cpp`，并添加以下代码：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `loadLevelForPlayMode` function clears the `vector`, instantiates a `PlayModeObjectLoader`
    instance that does all the file reading, and packs the `GameObject` instances
    in the `vector`. Finally, the `runStartPhase` function is called. In the `runStartPhase`
    function, all the `GameObject` instances are passed a `GameObjectSharer` (`this`)
    and given the opportunity to set themselves up, ready to be played. Remember that,
    inside the `GameObject` class in the `start` function, each of the derived `Component`
    instances is given access to `GameObjectSharer`. Refer to [*Chapter 20*](B14278_20_Final_AG_ePub.xhtml#_idTextAnchor414),
    *Game Objects and Components*, to see what we did with this when we coded the
    `Component` classes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadLevelForPlayMode` 函数清空了 `vector`，实例化了一个执行所有文件读取的 `PlayModeObjectLoader`
    实例，并将 `GameObject` 实例打包到 `vector` 中。最后，调用 `runStartPhase` 函数。在 `runStartPhase`
    函数中，所有 `GameObject` 实例都传递了一个 `GameObjectSharer` (`this`)，并有机会为自己设置好，以便可以播放。记住，在
    `GameObject` 类的 `start` 函数内部，每个派生 `Component` 实例都被赋予了访问 `GameObjectSharer` 的权限。参考[*第20章*](B14278_20_Final_AG_ePub.xhtml#_idTextAnchor414)，*游戏对象和组件*，以了解我们在编写
    `Component` 类时如何使用它。'
- en: The `runStartPhase` function concludes by calling `activateAllGameObjects`,
    which loops through the `vector`, calling `setActive` on every `GameObject` instance.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`runStartPhase` 函数通过调用 `activateAllGameObjects` 来结束，该函数遍历 `vector`，对每个 `GameObject`
    实例调用 `setActive`。'
- en: The `getGameObjects` function passes a reference to the `vector` of `GameObject`
    instances.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`getGameObjects` 函数传递了 `GameObject` 实例的 `vector` 引用。'
- en: Now that we have coded the `LevelManager` class, we can update the `ScreenManager`
    and the `ScreenManagerRemoteControl` classes that it implements.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了 `LevelManager` 类，我们可以更新实现此接口的 `ScreenManager` 和 `ScreenManagerRemoteControl`
    类。
- en: Updating the ScreenManager and ScreenManagerRemoteControl classes
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 `ScreenManager` 和 `ScreenManagerRemoteControl` 类
- en: 'Open the `ScreenManagerRemoteControl.h` file and uncomment everything so that
    the code is the same as the following. I have highlighted the lines that have
    been uncommented:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `ScreenManagerRemoteControl.h` 文件，取消注释所有内容，以便代码与以下内容相同。我已经突出显示了取消注释的行：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, open `ScreenManager.h`, which implements this interface and uncomments
    all the commented-out code. The code in question is abbreviated and highlighted
    as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 `ScreenManager.h`，它实现了此接口并取消注释所有已注释的代码。相关的代码被缩写并突出显示如下：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Be sure to uncomment the include directive, the `m_LevelManager` instance, as
    well as the two functions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要取消注释包含指令、`m_LevelManager` 实例以及两个函数。
- en: The `ScreenManager` and `ScreenManagerRemoteControl` classes are now fully functional
    and the `getGameObjects` and `shareGameObjectSharer` functions are usable by any
    class with a reference to the `ScreenManager` class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScreenManager` 和 `ScreenManagerRemoteControl` 类现在完全功能正常，`getGameObjects` 和
    `shareGameObjectSharer` 函数可以被任何具有 `ScreenManager` 类引用的类使用。'
- en: Where are we now?
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们现在在哪里？
- en: At this point, all the errors in our `GameObject` class, as well as all component-related
    classes, are gone. We are making good progress.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们 `GameObject` 类中的所有错误，以及所有与组件相关的类中的错误都已经消失。我们正在取得良好的进展。
- en: Furthermore, we can revisit the `ScreenManager.h` file and uncomment all the
    commented-out code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以重新访问 `ScreenManager.h` 文件，取消所有注释掉的代码。
- en: 'Open `ScreenManager.h` and uncomment the `#include` directive, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `ScreenManager.h` 文件，取消 `#include` 指令的注释，如下所示：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Change it to this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 改成这样：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Do the same for the functions from the `ScreenManagerRemoteControl` interface
    that are implemented in `ScreenManager.h`. They look like the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在 `ScreenManager.h` 中实现的 `ScreenManagerRemoteControl` 接口中的函数，也进行相同的操作。它们看起来如下所示：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Change them as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式修改它们：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We aren't quite ready to run the game, however, because there are still some
    missing classes that are used in the code, such as `BulletSpawner` in the `InvaderUpdateComponent`
    class.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有准备好运行游戏，因为代码中仍然缺少一些类，例如 `InvaderUpdateComponent` 类中的 `BulletSpawner`。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have put in place a way to describe a level in a game and
    a system to interpret the description and build usable `GameObject` instances.
    The Factory pattern is used in many types of programming, not just game development.
    The implementation we have used is the simplest possible implementation and I
    encourage you to put the Factory pattern on your list of patterns to research
    and develop further. The implementation we have used should serve you well if
    you wish to build some deep and interesting games, however.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们建立了一种描述游戏关卡的方法，以及一个解释描述并构建可用的 `GameObject` 实例的系统。工厂模式在许多类型的编程中都有应用，而不仅仅是游戏开发。我们所使用的实现是最简单的实现，我鼓励您将工厂模式添加到您要研究和进一步开发的模式列表中。如果您希望构建一些深入和有趣的游戏，我们所使用的实现应该会很好地为您服务。
- en: In the next chapter, we will finally make the game come to life by adding collision
    detection, bullet spawning, and the logic of the game itself.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过添加碰撞检测、子弹生成和游戏本身的逻辑，最终让游戏变得生动起来。
