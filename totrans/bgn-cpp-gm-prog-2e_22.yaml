- en: '*Chapter 21*: File I/O and the Game Object Factory'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter handles how a `GameObject` gets into the `m_GameObjects vector`
    that's used in the game. We will look at how we can describe individual objects
    and an entire level in a text file. We will write code to interpret the text and
    then load up values into a class that will be a blueprint for a game object. We
    will also code a class called `LevelManager` that oversees the whole process,
    starting from the initial request to load a level sent from an `InputHandler`
    via the `ScreenManager`, right through to the factory pattern class that assembles
    a game object from components and delivers it to the `LevelManager`, neatly packed
    away in the `m_GameObjects vector`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps we will go through in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Examine how we will describe game objects and their components in a text file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code the `GameObjectBlueprint` class where the data from the text file will
    be temporarily stored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code the `ObjectTags` class to help describe game objects consistently and without
    errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code `BluePrintObjectParser`, which will be responsible for loading the data
    from a game object description in the text file into a `GameObjectBlueprint` instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code `PlayModeObjectLoader`, which will open the text file and receive the `GameObjectBlueprint`
    instances one at a time from `BlueprintObjectParser`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code the `GameObjectFactoryPlayMode` class, which will construct `GameObject`
    instances from `GameObjectBlueprint` instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code the `LevelManager` class, which oversees this entire process after receiving
    an instruction from the `ScreenManager` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the code to the `ScreenManager` class so that we can begin using the new
    system that we will code in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by examining exactly how we describe a game object such as a space
    invader or a bullet in a text file, let alone a whole wave of them.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the file I/O and factory classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Have a look at the following diagram, which gives an overview of the classes
    we will code in this chapter and how the `vector` of `GameObject` instances will
    be shared with the `ScreenManager` class that we coded in [*Chapter 19*](B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372),
    *Game Programming Design Patterns – Starting the Space Invaders ++ Game*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image93956.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows that there is a `vector` of `GameObject` instances
    that's shared between four classes. This is achieved by passing the `vector` between
    the functions of the classes by reference. Each class can then carry out its role
    with the `vector` and its contents. The `ScreenManager` class will trigger the
    `LevelManager` class when a new level needs to be loaded into the `vector`. The
    individual `Screen` classes and their `InputHandler`-derived classes, as we saw
    in [*Chapter 19*](B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372), *Game Programming
    Design Patterns – Starting the Space Invaders ++ Game*, have access to `ScreenManager`
    via `ScreenManagerRemoteControl`.
  prefs: []
  type: TYPE_NORMAL
- en: The `LevelManager` class is ultimately responsible for creating and sharing
    the vector. `PlayModeObjectLoader` will use `BlueprintObjectParser` to create
    `GameObjectBlueprint` instances.
  prefs: []
  type: TYPE_NORMAL
- en: The `GameObjectFactoryPlayMode` class will complete the `GameObject` creation
    process using these `GameObjectBlueprint` instances and pack `GameObject` instances
    into the `vector` when prompted to do so by `PlayModeObjectLoader`.
  prefs: []
  type: TYPE_NORMAL
- en: So, where do the different component, position, size, and appearance configurations
    for each `GameObject` instance come from?
  prefs: []
  type: TYPE_NORMAL
- en: We can also see that three classes have access to a `GameObjectBlueprint` instance.
    This instance is created by the `LevelManager` class and passed around by reference.
    `BlueprintObjectParser` will read the `level1.txt` file, which has all the details
    of each of the game objects. It will initialize all the variables of the `GameObjectBlueprint`
    class. `PlayModeObjectLoader` will then pass a reference to the `vector` of `GameObject`
    instances, and also pass a reference to the fully configured `GameObjectBlueprint`
    instance to the `GameObjectFactoryPlayMode` class. This is repeated until all
    the `GameObject` instances are packed away in the `vector`.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why I have used slightly cumbersome class names such
    as `GameObjectFactoryPlayMode` and `PlayModeObjectLoader`. The reason is that,
    once you see how convenient this system is, you might like to build tools that
    allow you to design your levels in a visual way by dragging and dropping them
    where required and then have the text file auto-generated rather than typed. This
    is not especially complicated, but I had to stop adding features to the game at
    some point. Therefore, you might well end up with a `GameObjectFactoryDesignMode`
    and a `DesignModeObjectLoader`.
  prefs: []
  type: TYPE_NORMAL
- en: Describing an object in the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already added the `level1.txt` file in the `world` folder in [*Chapter
    19*](B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372), *Game Programming Design
    Patterns – Starting the Space Invaders ++ Game*. Let's discuss its uses, future
    intended uses, and its contents.
  prefs: []
  type: TYPE_NORMAL
- en: First, I would like to point out that a shooter game is not the best way to
    demonstrate how to describe a game world in a text file like this. The reason
    for this is that there are only a few types of game object and the most common
    one, invaders, are all lined up uniformly like soldiers on parade. They would
    actually be more efficiently described programmatically, perhaps in a nested `for`
    loop. However, the intention of this project was to show the ideas, rather than
    learn how to make a Space Invaders clone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following text, which is a sample from the `level1.txt`
    file in the `world` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding text describes a single object in the game; in this case, an
    invader. The object begins with the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'That will inform our code we''ll write that a new object is being described.
    Next in the text, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This informs the code that the type of object is an invader. This will eventually
    be set as the `m_Tag` of the `ColliderComponent` class. The invader will be identifiable
    for what it is. The text that comes next is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells our system that this object will have three components added to
    it: a `StandardGraphicsComponent` instance, an `InvaderUpdateComponent` instance,
    and a `TransformComponent` instance. This means the object will be drawn in the
    standard way and will behave according to the rules we coded for an invader. It
    will also mean it has a location and scale in the game world. It is possible to
    have objects that don''t have any components or fewer components. An object that
    takes no action and doesn''t move will not need an update component, an object
    that is invisible will not need a graphics component (perhaps just an invisible
    collider which triggers some action), and an object that has no position in the
    world (perhaps a debugging object) will not need a transform component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The position and scale of an object are determined by the following four lines
    of text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line of text determines what graphics file will be used for the
    texture of this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line means that the object can be collided with. A decorative
    object, perhaps floating clouds (or a bee), would not need a collider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The final line of text will inform our system that the object has finished
    describing itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s have a look at how we describe a bullet object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is very similar but not the same as an invader. A bullet object has additional
    data, such as a set speed. The invader's speed is set in the logic of the `InvaderUpdateComponent`
    class. We could have done this for the bullet's speed as well, but this demonstrates
    that you can describe the object in as much or as little detail as the specific
    game design requires. Also, as we would expect, a bullet has a `BulletUpdateComponent`
    and a different value for the `[BITMAP NAME]` element. Notice that the location
    of the bullet is set to -1, -1\. This means the bullets are outside of the playable
    area at the start of the game. In the next chapter, we will see how an invader,
    or the player, can spawn them into action when required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, study the following text, which describes the player''s ship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding text was probably quite predictable based on our discussion so
    far. Now that we've gone through this, we can get to work on coding the system
    that will interpret these object descriptions and convert them into usable `GameObject`
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the GameObjectBlueprint class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new header file in the `Header Files/FileIO` filter called `GameObjectBlueprint.h`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`GameObjectBlueprint` has a member variable for every possible property that
    could go into a game object. Note that it does not compartmentalize the properties
    by component. For example, it just has variables for things such as width, height,
    and location; it doesn''t go to the trouble of identifying these as part of the
    transform component. These details are handled in the factory. It also provides
    getters and setters so that the `BlueprintObjectParser` class can pack away all
    the values from the `level1.txt` file and the `GameObjectFactoryPlayMode` class
    can extract all the values, instantiate the appropriate components, and add them
    to an instance of `GameObject`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new source file in the `Source Files/FileIO` filter called `GameObjectBlueprint.cpp`
    and add the following code, which is for the definitions of the functions we have
    just declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Although this is a long class, there is nothing here we haven't seen before.
    The setter functions receive values which are copied into a vector or a variable,
    while the getters allow access to these values.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the ObjectTags class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way in which we describe the game objects in the `level1.txt` file needs
    to be precise because the `BlueprintObjectParser` class we will code after this
    class will be reading the text from the file and looking for matches. For example,
    the `[START OBJECT]` tag will trigger the start of a new object. If that tag is
    misspelled as, say, `[START OBJECR]`, then the whole system falls apart and there
    will be all kinds of bugs, and even crashes when we run the game. To avoid this
    happening, we will define constant (programmatically unchangeable) `string` variables
    for all the tags we need to describe the game objects. We can use these `string`
    variables instead of typing something such as `[START OBJECT]` and have much less
    chance of making a mistake.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new header file in the `Header Files/FileIO` filter called `ObjectTags.h`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have declared a `const string` for every tag we will use to describe the
    game objects. Now, we can initialize them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new source file in the `Source Files/FileIO` filter called `ObjectTags.cpp`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That's all the `string` variables initialized. We can now use them in the next
    class and be sure we are describing the game objects consistently.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the BlueprintObjectParser class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This class will have the code that actually reads the text from the `level1.txt`
    file we have discussed. It will parse one object at a time, as identified by the
    start and end tags we saw previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new header file in the `Header Files/FileIO` filter called `BlueprintObjectParser.h`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `extractStringBetweenTags` private function will capture the content between
    two tags. The parameters are three `string` instances. The first `string` is a
    full line of text from `level1.txt`, while the second and third are the start
    and end tags, which need to be discarded. The text between the two tags is then
    returned to the calling code.
  prefs: []
  type: TYPE_NORMAL
- en: The `parseNextObjectForBlueprint` function receives an `ifstream` reader, just
    like the one we used in the Zombie shooter and the Thomas Was Late games. It is
    used to read from the file. The second parameter is a reference to a `GameObjectBlueprint`
    instance. The function will populate the `GameObjectBlueprint` instance with the
    values that were read from the `level1.txt` file, which can then be used back
    in the calling code to create an actual `GameObject`. We will see how that happens
    when we code the `PlayModeObjectLoader` class next and the `GameObjectFactoryPlayMode`
    class after that.
  prefs: []
  type: TYPE_NORMAL
- en: Let's code the definitions we have just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new source file in the `Source Files/FileIO` filter called `BlueprintObjectParser.cpp`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The code in `parseNextObjectForBlueprint` is lengthy but straightforward. The
    series of `if` statements identifies the starting tag at the beginning of the
    line of text and then passes the line of text to the `extractStringBetweenTags`
    function, which returns the value that is then loaded into the `GameObjectBlueprint`
    reference in the appropriate place. Notice that the function exits when `GameObjectBlueprint`
    has had all the data loaded into it. This point is recognized when `ObjectTags::END_OF_OBJECT`
    is found.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the PlayModeObjectLoader class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the class that will pass `GameObjectBlueprint` instances to `BlueprintObjectParser`.
    When it gets the completed blueprint back, it will pass them to the `GameObjectFactoryPlayMode`
    class, which will construct the `GameObject` instance and pack it away in the
    `vector` instance. Once all the `GameObject` instances have been built and stored,
    responsibility will be handed to the `LevelManager` class, which will control
    access to the vector for other parts of the game engine. This is a very small
    class with just one function, but it links many other classes together. Refer
    to the diagram at the start of this chapter for clarification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new header file in the `Header Files/FileIO` filter called `PlayModeObjectLoader.h`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `PlayModeObjectLoader` class has an instance of the previous class we coded,
    that is, the `BluePrintObjectParser` class. It also has an instance of the class
    we will code next, that is, the `GameObjectFactoryPlayMode` class. It has a single
    public function, which receives a reference to a `vector` that holds `GameObject`
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will code the definition of the `loadGameObjectsForPlayMode` function.
    Create a new source file in the `Source Files/FileIO` filter called `PlayModeObjectLoader.cpp`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The function receives a `string`, which is the path to the file that needs to
    be loaded. This game only has one such file, but you could add more files with
    different layouts, varying numbers of invaders, or totally different game objects
    if you wanted to.
  prefs: []
  type: TYPE_NORMAL
- en: An `ifstream` instance is used to read one line at a time from the file. In
    the `while` loop, the start tag is identified using `ObjectTags::START_OF_OBJECT`,
    and the `parseNextObjectForBlueprint` function of `BlueprintObjectParser` is called.
    You probably remember from the `BlueprintObjectParser` class that the completed
    blueprint is returned when `ObjectTags::END_OF_OBJECT` is reached.
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code calls the `buildGameObject` of the `GameObjectFactoryPlayMode`
    class and passes in the `GameObjectBlueprint` instance. We will code the `GameObjectFactory`
    class now.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the GameObjectFactoryPlayMode class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will code our factory, which will construct working game objects from
    the `GameObject` class and all the component related classes that we coded in
    the previous chapter. We will make extensive use of smart pointers, so we don't
    have to worry about deleting memory when we have finished with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new header file in the `Header Files/FileIO` filter called `GameObjectFactoryPlayMode.h`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The factory class has just one function, `buildGameObject`. We have already
    seen the code that calls this function in the previous code we wrote for the `PlayModeObjectLoader`
    class. The function receives a reference to the blueprint, as well as a reference
    to the `vector` of `GameObject` instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new source file in the `Source Files/FileIO` filter called `GameObjectFactoryPlayMode.cpp`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing that happens in the `buildGameObject` function is that a new
    `GameObject` instance is created and the `setTag` function of the `GameObject`
    class is used to pass in the name of the current object being built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Next, a `for` loop loops through all the components in the `m_Components vector`.
    For each component that is found, a different `if` statement creates a component
    of the appropriate type. The way that each component is created varies, as you
    would expect since the way they are coded varies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates a shared pointer to a `TransformComponent` instance.
    You can see the necessary arguments being passed to the constructor, that is,
    width, height, and location. The result of creating the new shared pointer to
    a `TransformComponent` instance is passed to the `addComponent` function of the
    `GameObject` class. The `GameObject` instance now has its size and place in the
    world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code executes when a `PlayerUpdateComponent` is required. Again,
    the code creates a new shared pointer to the appropriate class and passes it in
    to the `addComponent` function of the `GameObject` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following three blocks of code use exactly the same technique to add either
    an `InvaderUpdateComponent`, `BulletUpdateComponent`, or `StandardGraphicsComponent`
    instance. Notice the extra line of code after adding a `StandardGraphicsComponent`
    instance that calls the `initialize` function, which adds a `Texture` instance
    (if required) to the `BitmapStore` singleton and prepares the component to be
    drawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The final `if` block, as shown in the following code, handles adding a `RectColliderComponent`
    instance. The first line of code creates the shared pointer, while the second
    line of code calls the `addComponent` function to add the instance to the `GameObject`
    instance. The third line of code calls the `setOrMoveCollider` and passes in the
    location and size of the object. At this stage, the object is ready to be collided
    with. Obviously, we still need to write the code that tests for collisions. We
    will do so in the next chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line of code in the class adds the just-constructed `GameObject`
    instance to the `vector` that will be shared with the `GameScreen` class and used
    to make the game come to life:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The next class we will write makes it easy to share the `vector` we have just
    filled with `GameObject` instances around the various classes of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the GameObjectSharer class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This class will have two pure virtual functions that share `GameObject` instances
    with other classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new header file in the `Header Files/FileIO` filter called `GameObjectSharer.h`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `getGameObjectsWithGOS` function returns a reference to the entire vector
    of `GameObject` instances. The `findFirstObjectWithTag` function returns just
    a single `GameObject` reference. We will see how we implement these functions
    when we inherit from `GameObjectSharer` when we code the `LevelManager` class
    next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Briefly, before the `LevelManager` class, create a new source file in the `Source
    Files/FileIO` filter called `GameObjectSharer.cpp` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Again, this is just a placeholder file and the full functionality goes in any
    of the classes that inherit from `GameObjectSharer`; in this case, the `LevelManager`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the LevelManager class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `LevelManager` class is the connection between what we coded in [*Chapter
    19*](B14278_19_Final_AG_ePub.xhtml#_idTextAnchor372), *Game Programming Design
    Patterns – Starting the Space Invaders ++ Game*, and everything we coded in this
    chapter. The `ScreenManager` class will have an instance of the `LevelManager`
    class, and the `LevelManager` class will instigate loading levels (using all the
    classes we have just coded) and share `GameObject` instances with any classes
    that need them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new header file in the `Header Files/Engine` filter called `LevelManager.h`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This class provides two different ways to get the `vector` full of the game
    objects. One way is via a simple call to `getGameObjects`, but another is via
    the `getGameObjectsWithGOS` function. The latter is the implementation of a pure
    virtual function from the `GameObjectSharer` class and will be a way to pass access
    to each and every game object so that is has access to all the other game objects.
    You may recall from [*Chapter 20*](B14278_20_Final_AG_ePub.xhtml#_idTextAnchor414),
    *Game Objects and Components*, that a `GameObjectSharer` instance is passed in
    during the `start` function call of the `GameObject` class. It was in this function
    that, among other things, the invaders could get access to the location of the
    player.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also two private functions: `runStartPhase`, which loops through
    all the `GameObject` instances calling start, and `activateAllGameObjects`, which
    loops through and sets all the `GameObject` instances to the active status.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, part of the `LevelManager` class is the `loadGameObjectsForPlayMode` function,
    which will trigger the entire game object creation process that the rest of this
    chapter has described.
  prefs: []
  type: TYPE_NORMAL
- en: The final function in the `LevelManger.h` file is the implementation of the
    other `GameObjectSharer` pure virtual function, `findFirstObjectWithTag`. This
    allows any class with a `GameObjectSharer` instance to track down a specific game
    object using its tag. The code loops through all the `GameObject` instances in
    the `vector` and returns the first match. Note, that if no match is found, a null
    pointer will be returned and crash the game. We use an `#ifdef` statement to output
    some text to the console to tell us what caused the crash so that we won't be
    scratching our heads for hours should we accidentally search for a tag that doesn't
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: We can now code the implementations of the functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new source file in the `Source Files/Engine` filter called `LevelManager.cpp`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `loadLevelForPlayMode` function clears the `vector`, instantiates a `PlayModeObjectLoader`
    instance that does all the file reading, and packs the `GameObject` instances
    in the `vector`. Finally, the `runStartPhase` function is called. In the `runStartPhase`
    function, all the `GameObject` instances are passed a `GameObjectSharer` (`this`)
    and given the opportunity to set themselves up, ready to be played. Remember that,
    inside the `GameObject` class in the `start` function, each of the derived `Component`
    instances is given access to `GameObjectSharer`. Refer to [*Chapter 20*](B14278_20_Final_AG_ePub.xhtml#_idTextAnchor414),
    *Game Objects and Components*, to see what we did with this when we coded the
    `Component` classes.
  prefs: []
  type: TYPE_NORMAL
- en: The `runStartPhase` function concludes by calling `activateAllGameObjects`,
    which loops through the `vector`, calling `setActive` on every `GameObject` instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `getGameObjects` function passes a reference to the `vector` of `GameObject`
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have coded the `LevelManager` class, we can update the `ScreenManager`
    and the `ScreenManagerRemoteControl` classes that it implements.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the ScreenManager and ScreenManagerRemoteControl classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `ScreenManagerRemoteControl.h` file and uncomment everything so that
    the code is the same as the following. I have highlighted the lines that have
    been uncommented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open `ScreenManager.h`, which implements this interface and uncomments
    all the commented-out code. The code in question is abbreviated and highlighted
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to uncomment the include directive, the `m_LevelManager` instance, as
    well as the two functions.
  prefs: []
  type: TYPE_NORMAL
- en: The `ScreenManager` and `ScreenManagerRemoteControl` classes are now fully functional
    and the `getGameObjects` and `shareGameObjectSharer` functions are usable by any
    class with a reference to the `ScreenManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: Where are we now?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, all the errors in our `GameObject` class, as well as all component-related
    classes, are gone. We are making good progress.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we can revisit the `ScreenManager.h` file and uncomment all the
    commented-out code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `ScreenManager.h` and uncomment the `#include` directive, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Do the same for the functions from the `ScreenManagerRemoteControl` interface
    that are implemented in `ScreenManager.h`. They look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Change them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We aren't quite ready to run the game, however, because there are still some
    missing classes that are used in the code, such as `BulletSpawner` in the `InvaderUpdateComponent`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have put in place a way to describe a level in a game and
    a system to interpret the description and build usable `GameObject` instances.
    The Factory pattern is used in many types of programming, not just game development.
    The implementation we have used is the simplest possible implementation and I
    encourage you to put the Factory pattern on your list of patterns to research
    and develop further. The implementation we have used should serve you well if
    you wish to build some deep and interesting games, however.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will finally make the game come to life by adding collision
    detection, bullet spawning, and the logic of the game itself.
  prefs: []
  type: TYPE_NORMAL
