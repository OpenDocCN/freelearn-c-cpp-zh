- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: The TDD Process in Depth
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨TDD过程
- en: We’re going to add a lot of code to the logging library in this chapter, and
    while that’s good, it’s not the main purpose of the chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向日志库中添加大量代码，虽然这样做很好，但这并不是本章的主要目的。
- en: This is a chapter about the **test-driven development** (**TDD**) process. Wasn’t
    [*Chapter 3*](B18567_03.xhtml#_idTextAnchor031) also about the TDD process? Yes,
    but think of the earlier chapter as an introduction. This chapter will explore
    the TDD process in detail with a lot more code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章关于**测试驱动开发**（**TDD**）过程的章节。[第3章](B18567_03.xhtml#_idTextAnchor031)不是也关于TDD过程吗？是的，但将前面的章节视为一个介绍。本章将详细探讨TDD过程，并使用更多的代码。
- en: You’ll get ideas for writing your own tests, how to figure out what’s important,
    and how to refactor code without rewriting tests too, and you’ll also learn when
    testing is too much and learn about many different types of tests.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得编写自己测试的想法，如何确定哪些是重要的，以及如何在不重写测试的情况下重构代码，你还将了解测试过多的情况以及了解许多不同类型的测试。
- en: 'The basic TDD process remains as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的TDD流程如下：
- en: To write tests first that use the software in a natural and intuitive way
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先编写使用软件的自然直观方式的测试
- en: To get the code building with minimal changes even if we need to provide fake
    or stubbed-out implementations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使我们需要提供模拟或存根实现，也要以最小的更改来构建代码
- en: To get basic scenarios working
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使基本场景正常工作
- en: To write more tests and enhance the design
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了编写更多测试并增强设计
- en: Along the way, we’ll add log levels, tags, and filtering to the logging library.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程中，我们将向日志库添加日志级别、标签和过滤功能。
- en: 'Specifically, we’ll cover the following main topics in this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，本章将涵盖以下主要内容：
- en: Finding gaps in the testing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现测试中的差距
- en: Adding log levels
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加日志级别
- en: Adding default tag values
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加默认标签值
- en: Exploring filtering options
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索过滤选项
- en: Adding new tag types
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新的标签类型
- en: Refactoring the tag design with TDD
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TDD重构标签设计
- en: Designing tests to filter log messages
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计测试以过滤日志消息
- en: Controlling what gets logged
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制要记录的内容
- en: Enhancing filtering for relative matches
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强相对匹配的过滤功能
- en: When is testing too much?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时测试过多？
- en: How intrusive should tests be?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试应该有多侵入性？
- en: Where do integration or system tests go in TDD?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在TDD中，集成或系统测试去哪里？
- en: What about other types of tests?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他类型的测试怎么办？
- en: Technical requirements
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All code in this chapter uses standard C++ that builds on any modern C++ 20
    or later compiler and standard library. The code uses the testing library from
    *Part 1* of this book, *Testing MVP*, and continues the development of a logging
    library started in the previous chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有代码都使用标准C++，它构建在任何现代C++ 20或更高版本的编译器和标准库之上。代码使用本书第一部分*测试MVP*中的测试库，并继续开发在前一章中开始的日志库。
- en: 'You can find all the code for this chapter in the following GitHub repository:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下GitHub仓库中找到本章的所有代码：
- en: '[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)'
- en: )
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: Finding gaps in the testing
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现测试中的差距
- en: 'We really need more tests. Right now, we only have two logging tests: one for
    simple log messages and the other for more complicated log messages. The two tests
    look like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的需要更多的测试。目前，我们只有两个日志测试：一个用于简单的日志消息，另一个用于更复杂的日志消息。这两个测试如下所示：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: But is there a good way to find more tests? Let’s look at what we have so far.
    I like to start with simple tests. Can things be constructed?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但有没有一种好的方法来找到更多的测试？让我们看看我们到目前为止所拥有的。我喜欢从简单的测试开始。事情可以构造吗？
- en: That’s why the two tests we have so far are in a file called `Contruction.cpp`.
    This is a good place to start when looking for gaps in your testing. Do you have
    a simple test for each thing that you can construct? Normally, these will be classes.
    Write a test for each constructor of each class that your project provides.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是为什么我们到目前为止的两个测试都在一个名为`Contruction.cpp`的文件中。当你寻找测试中的差距时，这是一个好起点。你为每个可以构造的东西都有一个简单的测试吗？通常，这些将是类。为你的项目提供的每个类的每个构造函数编写一个测试。
- en: For the logging library, we don’t have any classes yet. So instead, I created
    a simple test that calls the `log` function. Then, another test calls the same
    function in a slightly more complicated way.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于日志库，我们还没有任何类。因此，我创建了一个简单的测试，它调用`log`函数。然后，另一个测试以稍微复杂一些的方式调用相同的函数。
- en: There is an argument to be made that the complicated test duplicates some of
    the functionality of the simple test. I think what we have so far is okay, but
    it is something you should be aware of to avoid having a test that does everything
    another test does plus a little more. As long as a simple test represents a common
    use case, then it’s valuable to include it, even if another test might do something
    similar. In general, you want tests that will capture how your code will be used.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个论点可以提出，复杂的测试重复了一些简单测试的功能。我认为我们到目前为止做得还不错，但这是你应该注意的事情，以避免有一个测试做了另一个测试所有的事情再加上一点。只要简单测试代表了一个常见的用例，那么即使另一个测试可能做类似的事情，包含它也是有价值的。总的来说，你希望测试能够捕捉到你的代码是如何被使用的。
- en: Other things to think about when looking for gaps in your testing can be found
    by looking for symmetry. If you have construction tests, maybe you should consider
    destruction tests. We don’t have anything like that for the logging library—at
    least, not yet—but it is something to consider. Another example of symmetry can
    be found later in this chapter. We’ll need to confirm that some text exists in
    a file. Why not include a similar test that makes sure some different text does
    *not* exist in the file?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找测试中的差距时，可以通过寻找对称性来考虑其他事情。如果你有构建测试，也许你应该考虑破坏测试。对于日志库，我们还没有这样的东西——至少，目前还没有——但这是一个需要考虑的事情。本章后面的另一个对称性例子可以找到。我们需要确认某些文本存在于文件中。为什么不包括一个类似的测试，确保某些不同的文本不存在于文件中？
- en: Major features are a good source for tests. Think about which problems your
    code solves and write tests that exercise each feature or capability. For each
    feature, create a simple or common test, and then consider adding a more complicated
    test, some error tests that explore what can go wrong, and some tests that explore
    more purposeful misuses to make sure your code handles everything as expected.
    You’ll even see one example in the next section where a test is added just to
    make sure that it compiles.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 主要功能是测试的好来源。想想你的代码解决了哪些问题，并为每个功能或能力编写测试。对于每个功能，创建一个简单或常见的测试，然后考虑添加一个更复杂的测试，一些探索可能出错情况的错误测试，以及一些探索更有意向的错误使用的测试，以确保你的代码按预期处理所有情况。你甚至会在下一节看到一个例子，其中添加了一个测试只是为了确保它能够编译。
- en: This chapter will mostly explore tests for missing features. We’re just getting
    started with the logging library, so the majority of new tests will be based on
    new features. This is common for a new project and is a great way to let the tests
    drive the development.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将主要探讨缺失功能的测试。我们刚刚开始使用日志库，因此大部分新的测试都将基于新功能。这对于一个新项目来说是常见的，并且是让测试驱动开发的一个很好的方式。
- en: The next section will add a new feature by first creating tests to define the
    feature.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将通过首先创建测试来定义新功能，来添加一个新功能。
- en: Adding log levels
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加日志级别
- en: Logging libraries have a common idea of *log levels* that let you control how
    much information gets logged when an application is run. Let’s say you identify
    an error condition that needs a log message. This error should almost always be
    logged, but maybe there’s another place in the code where you decide that it might
    be useful to record what is happening. This other place is not always interesting,
    so it would be nice to avoid seeing those log messages all the time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 日志库有一个共同的**日志级别**概念，它允许你在应用程序运行时控制记录多少信息。假设你确定了一个需要记录日志消息的错误条件。这个错误几乎总是应该被记录，但也许代码中的另一个地方你决定记录正在发生的事情可能是有用的。这个其他地方并不总是有趣的，所以避免总是看到这些日志消息会很好。
- en: By having different log levels, you can decide how verbose your log files become.
    There are a couple of big problems with this approach. The first thing is simply
    defining what the log levels should be and what each should mean. Common log levels
    include errors, warnings, general informational messages, and debugging messages.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拥有不同的日志级别，你可以决定日志文件变得多么详细。这种方法的几个大问题包括：首先，简单地定义日志级别应该是什么，以及每个级别应该代表什么。常见的日志级别包括错误、警告、一般信息性消息和调试消息。
- en: Errors tend to be easy to identify unless you also want to split them into normal
    errors and critical errors. What makes an error critical? Do you even need to
    tell the difference? In order to support as many different customers as possible,
    a lot of logging libraries provide different log levels and leave it up to the
    programmer to figure out what each level means.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 错误通常很容易识别，除非你还需要将它们分为普通错误和关键错误。什么使一个错误变得关键？你是否真的需要区分它们？为了支持尽可能多的不同客户，许多日志库提供了不同的日志级别，并将决定每个级别含义的任务留给程序员。
- en: The logging levels end up being used primarily to control how much information
    gets logged, which can help reduce the size of the log files when the application
    is running without any problems or complaints. This is a good thing but it leads
    to the next big problem. When something needs further investigation, the only
    way to get more information is to change the logging level, rerun the application,
    and hope to catch the issue again.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 日志级别最终主要用于控制记录多少信息，这有助于在应用程序运行时没有问题或投诉的情况下减少日志文件的大小。这是一件好事，但它导致了下一个大问题。当需要进一步调查时，获取更多信息的方法只有更改日志级别，重新运行应用程序，并希望再次捕捉到问题。
- en: For large applications, changing the logging level to record more information
    can quickly cause so much extra information that it becomes difficult to find
    what you need. The additional log messages can also fill up storage drives and
    cause extra financial charges if the log files are sent to vendors for further
    processing. The debugging process is usually rushed so that the new logging level
    is in effect for a short period of time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型应用程序，将日志级别更改为记录更多信息可能会迅速导致大量额外信息，这使得找到所需信息变得困难。额外的日志消息也可能填满存储驱动器，如果日志文件发送给供应商进行进一步处理，还可能产生额外的财务费用。调试过程通常很匆忙，因此新的日志级别只有效很短的时间。
- en: To get around the need to change the logging level for the entire application,
    a common practice is to temporarily change the level that specific parts of the
    code use when logging information. This requires that an application be rebuilt,
    deployed, and then put back once the problem is found.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过需要更改整个应用程序的日志级别的问题，一种常见的做法是在发现问题时临时更改代码中特定部分使用日志信息时的级别。这需要应用程序重建、部署，然后在问题解决后恢复。
- en: 'How does all this discussion about logging levels help us design a logging
    library? We know who our target customer is: a microservice developer who will
    likely be working with large applications that can produce large log files. Thinking
    about what would help your customer the most is a great way to create a design.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所有关于日志级别的讨论如何帮助我们设计日志库？我们知道我们的目标客户是谁：一个微服务开发者，他们可能会与可以生成大量日志文件的大型应用程序一起工作。考虑什么最能帮助你的客户是一种很好的设计方法。
- en: We’re going to fix the two big problems identified. First, we’re not going to
    define any logging levels in the logging library. There will not be any notion
    of an error log message versus a debug log message. This doesn’t mean that there
    will be no way to control how much information will get logged, just that the
    whole idea of using log levels is fundamentally broken. The levels themselves
    are too confusing, and turning them on and off leads quickly to information overload
    and rushed debugging sessions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修复已识别的两个大问题。首先，我们不会在日志库中定义任何日志级别。将不会有错误日志消息与调试日志消息之间的概念。这并不意味着将没有控制记录多少信息的方法，只是使用日志级别的整个想法在根本上是错误的。级别本身太复杂，开启和关闭它们会迅速导致信息过载和匆忙的调试会话。
- en: The idea of adding extra information such as a log level to a log message is
    good. If we come up with a general-purpose solution that can work for log levels
    as well as other attached information, then we can let the user add whatever is
    needed and makes sense. We can provide the ability to add log levels without actually
    defining what those levels will be and what they mean.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志消息中添加额外信息，如日志级别，的想法是好的。如果我们提出一个通用的解决方案，它不仅可以用于日志级别，还可以用于其他附加信息，那么我们可以让用户添加所需和合理的任何内容。我们可以提供添加日志级别的功能，而无需实际定义这些级别将是什么以及它们代表什么。
- en: So, the first part of the solution will be a general-purpose *tagging* system.
    This should avoid the confusion of fixed log levels that are defined by the library.
    We’ll still refer to the idea of a log level, but that’s only because the idea
    is so common. However, our log levels will be more like log-level tags because
    there won’t be any idea of one log level being above or below another log level.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，解决方案的第一部分将是一个通用 **标签** 系统。这应该避免由库定义的固定日志级别的混淆。我们仍然会提到日志级别的概念，但这仅仅是因为这个概念非常普遍。然而，我们的日志级别将更像日志级别标签，因为不会存在一个日志级别高于或低于另一个日志级别的概念。
- en: The second part will need something new. The ability to control whether a message
    is logged or not based on the value of a log-level tag will just lead to the same
    problem as before. Turning a log level on will end up opening the logs everywhere
    and still lead to a flood of extra log messages. What we need is the ability to
    finely control what gets logged instead of turning extra logging on or off everywhere.
    We’ll need the ability to filter on more than just a log level.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分将需要一些新的内容。根据日志级别标签的值来控制消息是否被记录，这只会导致之前同样的问题。开启日志级别最终会在所有地方打开日志，并仍然导致额外的日志消息泛滥。我们需要的是能够精细控制记录的内容，而不是在所有地方打开或关闭额外的日志记录。我们需要的能力是能够根据不仅仅是日志级别来过滤。
- en: 'Let’s take these two ideas one at a time. What would a general tagging system
    look like? Let’s write a test to find out! We should create a new file called
    `Tags.cpp` in the `tests` folder that looks like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一次考虑这两个想法。一个通用的标签系统会是什么样子？让我们编写一个测试来找出答案！我们应该在 `tests` 文件夹中创建一个名为 `Tags.cpp`
    的新文件，如下所示：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The most important part of this test is the `log` function call. We want this
    to be easy to use and to quickly convey to anybody reading the code that a tag
    is involved. We don’t want the tag to get hidden in the message. It should stand
    out as different and at the same time not be awkward to use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这次测试最重要的部分是 `log` 函数调用。我们希望它易于使用，并能快速传达给阅读代码的任何人，其中涉及一个标签。我们不希望标签被隐藏在消息中。它应该突出显示为不同，同时又不显得使用起来尴尬。
- en: 'The confirmation is a little more complicated. We want the output in the log
    file to use a `key="value"` format. This means that there is some text followed
    by an equals sign and then more text inside quotation marks. This format will
    let us easily find tags by looking for something like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 确认部分稍微复杂一些。我们希望日志文件中的输出使用 `key="value"` 格式。这意味着有一些文本后面跟着一个等号，然后是引号内的更多文本。这种格式将使我们能够通过寻找类似以下内容来轻松找到标签：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For the log level, we’ll expect the output to look like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于日志级别，我们期望输出看起来像这样：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We also want to avoid mistakes such as spelling or differences in capitalization.
    That’s why the syntax doesn’t use a string, which could be mistyped like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望避免诸如拼写或大小写差异之类的错误。这就是为什么语法不使用字符串，因为可能会被误输入如下：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By avoiding strings, we can get the compiler to help make sure that tags are
    consistent. Any mistake should result in a compilation error instead of a malformed
    tag in the log file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过避免字符串，我们可以让编译器帮助确保标签的一致性。任何错误都应导致编译错误，而不是日志文件中的格式错误的标签。
- en: And because the solution uses a function argument, we don’t need to provide
    special forms of `log` such as `logError`, `logInfo`, or `logDebug`. One of our
    goals was to avoid defining specific logging levels in the library itself and
    instead come up with something that will let the user decide what the log levels
    will be, just like any other tag.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于解决方案使用函数参数，我们不需要提供特殊的 `log` 形式，如 `logError`、`logInfo` 或 `logDebug`。我们的一个目标是在库本身中避免定义特定的日志级别，而是想出一些让用户决定日志级别会是什么的东西，就像任何其他标签一样。
- en: 'This is also the reason for the extra include of `LogTags.h`, which is also
    a new file. This is where we will define which log levels we will use. We want
    the definition to be as simple as possible because the log library will not define
    these. The `LogTags.h` file should be placed in the `tests` folder and look like
    this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么额外包含 `LogTags.h` 的原因，它也是一个新文件。这就是我们将定义我们将使用哪些日志级别的地方。我们希望定义尽可能简单，因为日志库不会定义这些。`LogTags.h`
    文件应放置在 `tests` 文件夹中，如下所示：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Just because the logging library doesn’t define its own logging levels doesn’t
    mean it can’t help with this common task. We can make use of a helper class that
    the library will define called `LogLevel`. We include `Log.h` in order to gain
    access to the `LogLevel` class so that we can define instances. Each instance
    should have a name such as `error` that we will use when logging. The constructor
    also needs a string to be used in the logging output. It’s probably a good idea
    to use a string that matches the name of the instance. So, for example, the error
    instance gets an `"``error"` string.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 仅因为日志库没有定义自己的日志级别，并不意味着它不能帮助完成这个常见任务。我们可以利用库定义的一个辅助类，称为`LogLevel`。我们包含`Log.h`是为了获取访问`LogLevel`类，以便我们可以定义实例。每个实例都应该有一个名称，例如`error`，这是我们将在日志记录时使用的。构造函数还需要一个用于日志输出的字符串。可能使用与实例名称匹配的字符串是个好主意。所以，例如，错误实例得到一个`"``error"`字符串。
- en: 'It’s these instances that get passed to the `log` function, like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这些实例被传递给`log`函数，如下所示：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'One thing to note is the namespace of the `LogLevel` instances. Because we’re
    testing the logging library itself, we’ll be calling `log` from within tests.
    Each test body is actually part of the `run` method of a test class defined with
    one of the `TEST` macros. The test class itself is in an unnamed namespace. I
    wanted to avoid needing to specify the `MereMemo` namespace when using one of
    the log levels, like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事项是`LogLevel`实例的命名空间。因为我们正在测试日志库本身，我们将在测试中调用`log`。每个测试体实际上是使用一个`TEST`宏定义的测试类的`run`方法的一部分。测试类本身在一个未命名的命名空间中。我想避免在使用日志级别时需要指定`MereMemo`命名空间，就像这样：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It’s much easier to type just `error` instead of `MereMemo::error`. So, the
    solution (for now) is to declare the log-level instances in the global namespace
    inside `LogTags.h`. I recommend that when you define your own tags for your project,
    you declare the tags in your project’s namespace. Something like this would work:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 直接输入`error`而不是`MereMemo::error`要简单得多。因此，目前的解决方案是在`LogTags.h`中全局命名空间内声明日志级别的实例。我建议当你为自己的项目定义自己的标签时，你在项目的命名空间中声明这些标签。例如，可以这样操作：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then, when you are writing your code in your project that is part of your own
    namespace, you can refer to the tags such as `error` directly without needing
    to specify a namespace. You can use whichever namespace you want in place of `yourproject`.
    You can see a good example of a project that uses both the logging library and
    the testing library in [*Chapter 14*](B18567_14.xhtml#_idTextAnchor139), *How
    To* *Test Services*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当你正在编写你自己的项目中的代码，该项目是你自己的命名空间的一部分时，你可以直接引用像`error`这样的标签，而不需要指定一个命名空间。你可以使用你想要的任何命名空间来代替`yourproject`。你可以在[*第14章*](B18567_14.xhtml#_idTextAnchor139)中看到一个很好的例子，*如何*
    *测试服务*，该项目同时使用了日志库和测试库。
- en: Also, note that you should refer to the `Log.h` file from within your own project
    as a separate project and use angle brackets. This is just like what we did when
    we started work on the logging library and had to start referring to the unit
    test library include with angle brackets.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，你应该从你的项目中作为单独的项目引用`Log.h`文件，并使用尖括号。这就像我们在开始日志库的工作时，不得不使用尖括号引用单元测试库包含文件时所做的。
- en: 'One extra benefit of passing an instance of `MereMemo::LogLevel` to the `log`
    function is that we no longer need to specify the namespace to the `log` function.
    The compiler knows to look in namespaces that function arguments use when trying
    to resolve the function name. The simple act of passing `error` to the `log` function
    lets the compiler figure out that the `log` function is the one defined in the
    same namespace as the `error` instance. I actually thought about this benefit
    once the code was working and I could try to call `log` without a namespace. I
    was then able to add a test to `Tags.cpp` that looks like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将`MereMemo::LogLevel`的实例传递给`log`函数的一个额外好处是，我们不再需要指定`log`函数的命名空间。编译器知道在尝试解析函数名时在函数参数使用的命名空间中查找。将`error`传递给`log`函数的简单行为让编译器推断出`log`函数是在与`error`实例相同的命名空间中定义的。实际上，我在代码工作并且可以尝试不带命名空间调用`log`之后想到了这个好处。然后我能够向`Tags.cpp`添加一个看起来像这样的测试：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, you can see that we can call `log` directly without specifying the `MereMemo`
    namespace, and we can do this because the compiler knows that the `error` instance
    being passed is itself a member of `MereMemo`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们可以直接调用`log`而不需要指定`MereMemo`命名空间，我们可以这样做是因为编译器知道被传递的`error`实例本身就是`MereMemo`的一个成员。
- en: If we try to call `log` without any arguments, then we’ll need to go back to
    using `MereMemo::log` instead of just `log`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试不带任何参数调用`log`，那么我们就需要回退到使用`MereMemo::log`而不是仅仅使用`log`。
- en: Also, notice how this new test was identified. It’s an alternate usage that
    simplifies the code, and making a test helps make sure that we don’t do anything
    later that will break the simpler syntax. The new test has no confirmations either.
    That’s because the test exists just to make sure that the call to `log` without
    the namespace compiles. We already know that `log` can send a log message to the
    log file because the other test confirms this. This test doesn’t need to duplicate
    the confirmation. If it compiles, then it has done its job.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，注意这个新测试是如何被识别的。它是一种简化代码的替代用法，编写一个测试可以帮助确保我们以后不会做任何会破坏更简单语法的操作。新的测试也没有确认。这是因为测试的存在只是为了确保调用`log`时没有命名空间能够编译。我们已经知道`log`可以发送日志消息到日志文件，因为其他测试已经确认了这一点。这个测试不需要重复确认。如果它能编译，那么它就完成了它的任务。
- en: 'The only thing we need now is a definition of the `LogLevel` class. Remember
    that we really want a general-purpose tagging solution and that a log level should
    be just one type of tag. There shouldn’t be anything special about a log level
    versus any other tag. We might as well define a `Tag` class too and make `LogLevel`
    inherit from `Tag`. Put the two new classes at the beginning of `Log.h` just inside
    the `MereMemo` namespace, like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在唯一需要的是`LogLevel`类的定义。记住，我们真正想要的是一个通用的标记解决方案，日志级别应该只是标记的一种类型。日志级别与其他标签之间不应该有任何特殊之处。我们不妨也定义一个`Tag`类，并让`LogLevel`从`Tag`继承。将这两个新类放在`Log.h`的顶部，就在`MereMemo`命名空间内部，如下所示：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Make sure both classes are defined inside the `MereMemo` namespace. Let’s start
    with the `Tag` class, which should not be used directly. The `Tag` class should
    be a base class so that a derived class can specify the key to be used. The purpose
    of the `Tag` class is really just to make sure that the text output follows the
    `key="value"` format.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 确保这两个类都在`MereMemo`命名空间内定义。让我们从`Tag`类开始，这个类不应该被直接使用。`Tag`类应该是一个基类，以便派生类可以指定要使用的键。`Tag`类的真正目的是确保文本输出遵循`key="value"`格式。
- en: The `LogLevel` class inherits from the `Tag` class and only requires the text
    of the log level. The key is hardcoded to always be `log_level`, which enforces
    consistency. We get the consistency of the values when we declare instances of
    `LogLevel` with specific strings and then use the defined instances when calling
    `log`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogLevel`类从`Tag`类继承，并且只需要日志级别的文本。键是硬编码的，总是为`log_level`，这保证了一致性。当我们用特定的字符串声明`LogLevel`的实例并调用`log`时，我们得到了值的一致性。'
- en: The logging library supports tags and even log-level tags but doesn’t define
    any specific log levels itself. The library also doesn’t try to order the log
    levels so that something such as `error` is a higher or lower level than `debug`.
    Everything is just a tag consisting of a key and a value.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 日志库支持标签，甚至支持日志级别标签，但它本身并不定义任何特定的日志级别。库也不尝试对日志级别进行排序，以便像`error`这样的级别比`debug`高或低。一切只是一个由键和值组成的标签。
- en: 'Now that we have the `LogLevel` and `Tag` classes, how are they used by the
    `log` function? We’ll first need a new overload of `log` that accepts a `Tag`
    parameter, like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`LogLevel`和`Tag`类，它们是如何被`log`函数使用的呢？我们首先需要一个接受`Tag`参数的新重载`log`，如下所示：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Place this new `log` function right after the existing `log` function and still
    inside the `MereMemo` namespace in `Log.h`. The new `log` function will convert
    the tag into a string and pass the string to the existing `log` function. We’ll
    need to define a `to_string` function that can be placed right after the definition
    of the `Tag` class, like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个新的`log`函数放在现有的`log`函数之后，并且仍然在`Log.h`中的`MereMemo`命名空间内。新的`log`函数将标签转换为字符串，并将字符串传递给现有的`log`函数。我们需要定义一个`to_string`函数，可以放在`Tag`类的定义之后，如下所示：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `to_string` function just calls the `text` method in the `Tag` class to
    get the string. Do we really need a function for this? Couldn’t we just call the
    text method directly from within the new overloaded `log` function? Yes, we could
    have, but it’s a common practice in C++ to provide a function called `to_string`
    that knows how to convert a class into a string.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`to_string`函数只是调用`Tag`类中的`text`方法来获取字符串。我们真的需要一个函数来做这个吗？我们难道不能直接在新的重载`log`函数中调用`text`方法吗？是的，我们可以这样做，但在C++中提供名为`to_string`的函数，该函数知道如何将类转换为字符串，是一种常见的做法。'
- en: All these new functions need to be declared inline because we’re going to keep
    the logging library as a single include file that another project can simply include
    to begin logging. We want to avoid declaring functions in the `Log.h` file and
    then implementing them inside a `Log.cpp` file because that would require users
    to add `Log.cpp` to their project, or it would require that the logging library
    be built as a library and then linked into the project. By keeping everything
    in a single header file, we make it easier for other projects to use the logging
    library. It’s not really a library—it’s just a header file that gets included.
    We’ll still refer to it as the logging library, though.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些新函数都需要声明在行内，因为我们打算将日志库作为一个单独的包含文件，其他项目可以简单地包含它以开始记录。我们希望避免在 `Log.h` 文件中声明函数，然后在
    `Log.cpp` 文件中实现它们，因为这要求用户将 `Log.cpp` 添加到他们的项目中，或者要求将日志库构建为一个库，然后将其链接到项目中。通过将所有内容保持在单个头文件中，我们使其他项目使用日志库变得更加容易。它实际上不是一个库——它只是一个被包含的头文件。尽管如此，我们仍然将其称为日志库。
- en: 'The existing `log` function needs to be modified to accept a string. It actually
    used to accept a string for the message to be logged until we removed that and
    returned a stream instead that the caller uses to specify the message along with
    any other information to be logged. We’re going to put a string parameter back
    in the `log` function and call it `preMessage`. The `log` function will still
    return a stream that the caller can use. The `preMessage` parameter will be used
    to pass the formatted tag, and the `log` function will output the `preMessage`
    before returning the stream for the caller to use for the other information to
    be logged. The modified `log` function looks like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的 `log` 函数需要修改以接受一个字符串。实际上它曾经用于接受一个字符串作为要记录的消息，直到我们移除了这个功能，转而返回一个流，调用者可以使用这个流来指定消息以及任何其他要记录的信息。我们打算将一个字符串参数放回
    `log` 函数中，并将其命名为 `preMessage`。`log` 函数仍然会返回一个调用者可以使用的流。`preMessage` 参数将用于传递格式化的标签，`log`
    函数将在返回给调用者的流之前输出 `preMessage`。修改后的 `log` 函数看起来像这样：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `preMessage` parameter has a default value so that the `log` function can
    still be called without a log-level tag. All the `log` function does is send a
    timestamp, then the `preMessage` parameter to the stream, followed by a single
    space, before letting the caller have access to the returned stream.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`preMessage` 参数有一个默认值，这样 `log` 函数仍然可以在没有日志级别标签的情况下被调用。`log` 函数所做的只是发送一个时间戳，然后是
    `preMessage` 参数到流中，接着是一个空格，最后让调用者能够访问返回的流。'
- en: Note that we still want the log-level tag to be separated from the timestamp
    with a space too. If there is no log level specified, then the output will have
    two spaces, which is a detail that will be fixed soon.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们仍然希望日志级别标签与时间戳之间也用空格隔开。如果没有指定日志级别，则输出将有两个空格，这是一个将很快修复的细节。
- en: 'We have everything we need now to log with a log level that the new tests make
    use of:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有所有需要的工具来使用新的测试中使用的日志级别进行记录：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And building and running the project shows everything passes:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行项目显示一切通过：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And looking at a new log file shows the log levels, as expected:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 查看新的日志文件可以看到预期的日志级别：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first two entries make use of the new log level. The second one is the one
    we only wanted to make sure compiles. The third and fourth logs are missing a
    log level. That’s because they never specified a log level. We should fix this
    and enable some tags to have default values, which would let us add log levels
    without specifying a log level so that we can make sure that every log message
    entry has a log level. The third and fourth entries also have an extra space,
    which will be fixed too. The next section will add the ability to specify default
    tags.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个条目使用了新的日志级别。第二个条目是我们只想确保它能编译的。第三个和第四个日志条目缺少日志级别。这是因为它们从未指定日志级别。我们应该修复这个问题，并允许一些标签有默认值，这样我们就可以在不指定日志级别的情况下添加日志级别，以确保每个日志消息条目都有一个日志级别。第三个和第四个条目还有一个额外的空格，这也会被修复。下一节将添加指定默认标签的能力。
- en: Before moving on, notice one more thing. The complicated log entry actually
    looks like it uses tags already. That’s because we formatted the message with
    a `key="value"` format. It’s common to include quotation marks around text values
    and to not use quotation marks around numbers. The quotation marks help define
    the entire value when the text has spaces inside of the value, while numbers don’t
    need spaces and therefore don’t need quotation marks.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请注意一件事。复杂的日志条目实际上看起来已经使用了标签。这是因为我们使用`key="value"`格式格式化了消息。在文本值周围包含引号并且不在数字周围使用引号是常见的做法。当文本值内部包含空格时，引号有助于定义整个值，而数字不需要空格，因此不需要引号。
- en: 'Also, note that we don’t add spaces around the equals sign. We don’t log the
    following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们不在等号周围添加空格。我们不会记录以下内容：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The reason we don’t log this is that the extra spaces are not needed and only
    make it harder to process the log output. It might be easier to read with spaces,
    but trying to automate the processing of log files with scripts is harder with
    spaces.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不记录这个的原因是额外的空格不是必需的，只会使处理日志输出变得更困难。虽然带有空格可能更容易阅读，但使用脚本自动处理日志文件会更困难。
- en: 'Likewise, we don’t use commas between tags. So, we don’t do this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们不在标签之间使用逗号。所以，我们不会这样做：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Adding commas between tags might make it easier to read, but they are just one
    more thing that must be handled by code that needs to programmatically process
    log files. Commas are not needed, so we won’t be using them.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在标签之间添加逗号可能会使其更容易阅读，但它们只是代码需要处理日志文件时必须处理的一个额外元素。逗号不是必需的，所以我们不会使用它们。
- en: Now, we can proceed to add default tags.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续添加默认标签。
- en: Adding default tag values
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加默认标签值
- en: The previous section identified the need to sometimes add a tag to log messages
    even if the tag is not given to the `log` function. We can use this to add a default
    log-level tag or any other default value needed for any tag.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节确定了有时需要在日志消息中添加标签，即使标签没有提供给`log`函数。我们可以利用这一点来添加默认日志级别标签或任何其他任何标签所需的默认值。
- en: With this feature, we’re starting to get to the need for the logging library
    to support configuration. What I mean is that we want to be able to tell the logging
    library how to behave before we call `log`, and we want the logging library to
    remember this behavior.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个功能，我们开始需要日志库支持配置。我的意思是，我们希望在调用`log`之前告诉日志库如何表现，并且我们希望日志库记住这种行为。
- en: Most applications support logging only after the configuration is set once at
    the beginning of the application. This configuration setup is usually done at
    the beginning of the `main` function. So, let’s focus on adding some simple configuration
    that will let us set some default tags and then use those default tags when logging.
    If we encounter both a default tag and a tag with the same key used during a call
    to the `log` function, then we will use the tag provided in the call to `log`.
    In other words, the default tags will be used unless overridden in the call to
    `log`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序仅在配置在应用程序开始时设置一次后支持日志记录。这个配置设置通常在`main`函数的开始处完成。因此，让我们专注于添加一些简单的配置，这样我们就可以设置一些默认标签，并在日志记录时使用这些默认标签。如果我们遇到在调用`log`函数期间使用的具有相同键的默认标签和标签，那么我们将使用在`log`函数调用中提供的标签。换句话说，除非在`log`函数调用中覆盖，否则将使用默认标签。
- en: We’ll start with what it will take to set default tag values. This is a case
    where we won’t actually have a test for setting a default value inside of `main`,
    but we will have a test to make sure that a default value set in `main` does appear
    in the log output from within a test. And we might as well design the solution
    so that default values can be set at any time and not just from inside the `main`
    function. This will let us test the setting of a default value directly instead
    of relying on `main`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始讨论设置默认标签值所需的内容。这是一个我们实际上不会在`main`内部设置默认值的测试用例，但我们将有一个测试来确保在`main`中设置的默认值确实出现在测试的日志输出中。我们还可以设计解决方案，以便可以在任何时间设置默认值，而不仅仅是`main`函数内部。这将使我们能够直接测试默认值的设置，而不是依赖于`main`。
- en: 'Even though the following code isn’t inside of a test, we can still modify
    `main` first to make sure that the solution is something we like. Let’s change
    `main` to look like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 即使下面的代码不在测试中，我们仍然可以先修改`main`，以确保解决方案是我们想要的。让我们将`main`修改如下：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We’ll include `Log.h` so that we can get a definition of a new `addDefaultTag`
    function that we’ll write, and we’ll include `LogTags.h` to get access to the
    `info` log level and a new tag for a color. Why a color? Because when adding new
    tests, we want to look for simple and general use cases. We already have the `LogLevel`
    tag defined by the logging library, and the only thing we need to do is define
    specific instances with their own values. But we haven’t yet defined our own tags,
    and this seems like a good place to check that custom tags work too. The usage
    flows well, and it seems reasonable that users would want to define multiple default
    tags.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将包含`Log.h`，以便我们可以获取我们将要编写的`addDefaultTag`函数的定义，并且我们将包含`LogTags.h`以获取对`info`日志级别和一个颜色标签的新标签的访问权限。为什么是颜色标签？因为当我们添加新测试时，我们想要寻找简单和通用的用例。我们已经有了由日志库定义的`LogLevel`标签，我们唯一需要做的是定义具有自己值的特定实例。但我们还没有定义我们自己的标签，这似乎是检查自定义标签是否也工作得好的好地方。使用流程良好，看起来用户想要定义多个默认标签似乎是合理的。
- en: It’s easy to go too far and add a bunch of new functionality that needs to be
    tested, but adding related scenarios such as the two default tags `info` and `green`
    that serve to make a test more generic is okay. At least, it’s the type of thing
    I would do in one step. You might want to make these two separate tests. I figure
    that we can add a single test that just makes sure both tags are present even
    if not provided to the `log` function. The fact that one tag type is provided
    by the logging library and the other is custom is not enough for me to require
    separate tests. I’ll be happy if they both appear in the log output.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易走得太远，添加一大堆需要测试的新功能，但添加相关场景，例如添加两个默认标签`info`和`green`，以使测试更加通用是可行的。至少，这是我可能会一步完成的事情。你可能想要将这两个测试分开。我认为我们可以添加一个单独的测试，确保即使没有提供给`log`函数，两个标签都存在。一个标签类型由日志库提供，另一个是自定义的，这对我来说不足以要求进行单独的测试。如果它们两个都出现在日志输出中，我会很高兴。
- en: 'Let’s add a test now to `Tags.cpp` that looks like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来向`Tags.cpp`添加一个测试，如下所示：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As it turns out, I’m glad that I did add two default tags instead of just one
    because when writing the test, I started thinking about how to verify they both
    appear in the log file, and that’s when I realized that the `isTextInFile` function
    is too rigid for what we now need. The `isTextInFile` function worked okay when
    we were only interested in checking if a specific string appeared in a file, but
    we’re working with tags now, and the order that the tags appear in the output
    is not specified. The important part is that we can’t reliably create a single
    string that will always match the order of the tags in the output, and we definitely
    don’t want to start checking for all possible tag orders.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我很高兴我添加了两个默认标签而不是一个，因为在编写测试时，我开始思考如何验证它们两个都出现在日志文件中，那时我才意识到`isTextInFile`函数对于我们现在需要的来说太僵化了。当我们的兴趣仅限于检查特定字符串是否出现在文件中时，`isTextInFile`函数表现良好，但现在我们正在处理标签，而标签在输出中出现的顺序并未指定。重要的是，我们无法可靠地创建一个始终匹配输出中标签顺序的单个字符串，我们肯定不希望开始检查所有可能的标签顺序。
- en: What we want is the ability to first identify a specific line in the output.
    This is important because we might have many log file entries that have the same
    log level or the same color, but the message with the random number is more specific.
    Once we find a single line in the file that matches the random number, what we
    really want is to check that same line to make sure all the tags are present.
    The order within the line is not important.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的是首先能够识别输出中的特定行。这很重要，因为我们可能有很多具有相同日志级别或相同颜色的日志文件条目，但带有随机数的消息更为具体。一旦我们在文件中找到匹配随机数的单行，我们真正想要做的是检查该行以确保所有标签都存在。行内的顺序并不重要。
- en: So, I changed the `isTextInFile` function to take a third parameter, which will
    be a collection of strings. Each of these strings will be a single tag value to
    check. This actually makes the test easier to understand. We can leave the message
    unchanged and use it as the first argument to identify the line we want to find
    within the log file. Assuming we find that line, we then pass individually formatted
    tags in the `key="value"` format as a collection of strings to verify that they
    each exist in the same line found already.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我将`isTextInFile`函数更改为接受一个第三个参数，它将是一个字符串集合。这些字符串中的每一个都将是一个要检查的单个标签值。这实际上使测试更容易理解。我们可以保持消息不变，并使用它作为第一个参数来标识我们想要在日志文件中找到的行。假设我们找到了该行，然后我们逐个将格式化的标签以`key="value"`格式作为字符串集合传递，以验证它们是否都存在于已找到的同一行中。
- en: Notice also that the tag strings begin and end with a single space. This makes
    sure that the tags are separated properly with spaces and that we also don’t have
    any commas at the end of a tag value.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，标签字符串以单个空格开始和结束。这确保了标签被正确地用空格分隔，并且我们也不会在标签值末尾有任何逗号。
- en: 'We should fix the other test that checks for the existence of the log level,
    like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该修复检查日志级别存在性的其他测试，如下所示：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We no longer need to append the message to the end of a formatted log-level
    tag. We just pass the single `logLevelTag` instance as the single value in the
    collection of additional strings to check. Now that we have default tag values
    set in `main`, there is no guarantee of the order of the tags. So, we could have
    failed this test because the color tag happened to come between the error tag
    and the message. All we check is that the message appears in the output and that
    the error tag also exists somewhere in the same log-line entry.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要将消息追加到格式化的日志级别标签的末尾。我们只需将单个`logLevelTag`实例作为要检查的附加字符串集合中的单个值传递。现在，在`main`中设置了默认标签值，我们无法保证标签的顺序。因此，我们可能因为颜色标签恰好位于错误标签和消息之间而未能通过此测试。我们检查的只是消息是否出现在输出中，以及错误标签是否也存在于同一日志行条目中。
- en: 'Let’s enhance the `isTextInFile` function now to accept a vector of strings
    in a third parameter. The vector should have a default value of an empty collection
    in case the caller just wants to verify that a file contains some simple text
    without also looking for additional strings on the same line. And while we’re
    doing this, let’s add a fourth parameter, which will also be a vector of strings.
    The fourth parameter will check to make sure that its strings are *not* found
    in the line. The updated function declaration looks like this in `Util.h`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来增强`isTextInFile`函数，使其接受一个字符串向量作为第三个参数。如果调用者只想验证文件是否包含一些简单的文本，而不在相同的行上查找其他字符串，则该向量应有一个默认值为空集合。同时，我们添加一个第四个参数，它也将是一个字符串向量。第四个参数将检查确保其字符串不在行中。更新后的函数声明在`Util.h`中看起来如下：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We need to include `vector` and make sure to give the extra parameters default
    empty values. The implementation in `Util.cpp` looks like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要包含`vector`并确保为额外的参数提供默认空值。`Util.cpp`中的实现如下：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The change adds an extra `for` loop once we find the line identified by the
    `text` parameter. For all the wanted tags provided, we search through the line
    again to make sure each tag exists. If any of them are not found, then the function
    returns `false`. Assuming it finds all the tags, then the function returns `true`,
    just like before.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改在找到由`text`参数指定的行后添加了一个额外的`for`循环。对于提供的所有想要的标签，我们再次搜索该行以确保每个标签都存在。如果任何一个未找到，则函数返回`false`。假设它找到了所有标签，那么函数返回`true`，就像之前一样。
- en: Almost the same thing happens for the unwanted tags except that the logic is
    reversed. If we find an unwanted tag, then the function returns `false`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不想要的标签，几乎发生相同的事情，只是逻辑相反。如果我们找到一个不想要的标签，那么函数返回`false`。
- en: 'All we need now is to add the definition of the `Color` tag type and then the
    `green` color instance. We can add these to `LogTags.h`, like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要添加`Color`标签类型的定义，然后添加`green`颜色实例。我们可以将这些添加到`LogTags.h`中，如下所示：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Building the project shows that I forgot to implement the `addDefaultTag` function
    that we started out using in `main`. Remember when I said that it’s easy to get
    sidetracked? I started to add the function to `Log.h`, like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 构建项目显示我忘记实现了我们在`main`中开始使用的`addDefaultTag`函数。记得我曾经说过容易分心吗？我开始将函数添加到`Log.h`中，如下所示：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is a great example of how writing the usage first helped with the implementation.
    What we need to do is store the tag passed to the `addDefaultTag` function so
    that it can be retrieved later and added to log messages. We first need a place
    to store the tags so that the function declares a static map.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的例子，说明了先编写使用情况如何有助于实现。我们需要做的是存储传递给 `addDefaultTag` 函数的标签，以便以后可以检索并添加到日志消息中。我们首先需要一个地方来存储标签，这样函数就可以声明一个静态映射。
- en: Originally, I wanted the map to make a copy of the tag, but that would have
    required changing the `Tag` class so that it could be used directly instead of
    working with derived classes. I like how the derived classes help with keeping
    the key consistent and didn’t want to change that part of the design.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我想让映射复制标签，但这将需要更改 `Tag` 类，以便它可以直接使用而不是与派生类一起使用。我喜欢派生类如何帮助保持键的一致性，并且不想改变设计的那部分。
- en: So, instead, I decided that the collection of tags would use pointers. The problem
    with using pointers is that it’s not obvious to the caller of `addDefaultTag`
    that the lifetimes of any tags passed to the function must remain valid for as
    long as the tag remains in the default tag collection.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我决定使用指针来存储标签集合。使用指针的问题是，对于 `addDefaultTag` 的调用者来说，任何传递给函数的标签的生命周期必须保持有效，直到该标签保留在默认标签集合中。
- en: We can still make copies and store the copies in unique pointers, but that requires
    either extra work for the caller of `addDefaultTag` or some method that knows
    how to clone a tag. I don’t want to add extra complexity to the code in `main`
    that calls `addDefaultTag` and force that code to make a copy. We’ve already written
    the code in `main`, and we should strive to keep that code as-is because it was
    written using TDD principles and provides the solution we will be most happy with.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以创建副本并将副本存储在唯一指针中，但这需要调用者对 `addDefaultTag` 进行额外的工作，或者需要一个知道如何克隆标签的方法。我不想在调用
    `addDefaultTag` 的 `main` 代码中添加额外的复杂性，并强迫该代码进行复制。我们已经在 `main` 中编写了代码，我们应该努力保持该代码不变，因为它使用了
    TDD 原则，并提供了我们将最满意的解决方案。
- en: 'To avoid lifetime surprises, we should add a `clone` method to the `Tag`-derived
    classes. And because we are using a map in `addDefaultTag` and have identified
    the need for unique pointers, we need to include `map` and `memory` at the top
    of `Log.h`, like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免生命周期意外，我们应该在 `Tag` 派生类中添加一个 `clone` 方法。并且因为我们正在 `addDefaultTag` 中使用映射并已确定需要唯一指针，所以我们需要在
    `Log.h` 的顶部包含 `map` 和 `memory`，如下所示：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let’s implement the correct `addDefaultTag` function to make a copy of
    the passed-in tag instead of storing a pointer directly to the caller’s variable.
    This will free up the caller so that the tags passed in no longer have to remain
    alive indefinitely. Add this code to `Log.h` right after the `LogLevel` class:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现正确的 `addDefaultTag` 函数，以便复制传入的标签而不是直接存储调用者的变量指针。这将释放调用者，使得传入的标签不再需要无限期地保持存活。将此代码添加到
    `Log.h` 中，紧接在 `LogLevel` 类之后：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We use a helper function to store the collection of default tags. The collection
    is static, so it gets initialized to an empty map the first time the tags are
    requested.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个辅助函数来存储默认标签的集合。该集合是静态的，因此当第一次请求标签时，它被初始化为空映射。
- en: 'We need to add a pure virtual `clone` method to the `Tag` class that will return
    a unique pointer. The method declaration can go right after the `text` method
    and looks like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `Tag` 类中添加一个纯虚 `clone` 方法，该方法将返回一个唯一指针。方法声明可以直接放在 `text` 方法之后，如下所示：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And now, we need to add the `clone` method implementation to both the `LogLevel`
    and `Color` classes. The first looks like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将 `clone` 方法的实现添加到 `LogLevel` 和 `Color` 类中。第一个看起来像这样：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And the implementation for the `Color` class looks almost identical:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`Color` 类的实现看起来几乎相同：'
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Even though the implementations look almost identical, each makes a new instance
    of the specific type involved, which gets returned as a unique pointer to `Tag`.
    This is the complexity that I was hoping to avoid when I started, but it’s better
    to add complexity to the derived classes instead of placing extra and unexpected
    requirements on the caller of `addDefaultTag`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管实现看起来几乎相同，但每个都创建了一个特定类型的实例，该实例作为 `Tag` 的唯一指针返回。这是我开始时希望避免的复杂性，但最好是向派生类添加复杂性，而不是向
    `addDefaultTag` 的调用者施加额外的和意外的要求。
- en: 'We’re now ready to build and run the test application. One of the tests fails,
    like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好构建和运行测试应用程序。其中一个测试失败了，如下所示：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The failure is actually a good thing and is part of the TDD process. We wrote
    the code as we intended it to be used in `main`, and wrote a test that would verify
    that the default tags appear in the output log file. The default tags are missing,
    and that’s because we need to change the `log` function so that it will include
    the default tags.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 失败实际上是一件好事，它是 TDD（测试驱动开发）过程的一部分。我们像在 `main` 中使用它一样编写了代码，并编写了一个测试来验证默认标签是否出现在输出日志文件中。默认标签缺失，这是因为我们需要更改
    `log` 函数，使其包含默认标签。
- en: Right now, the `log` function only includes the tags that are directly provided—or,
    I should say, the tag that is directly provided because we don’t yet have a way
    to log multiple tags. We’ll get there. One thing at a time.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`log` 函数只包括直接提供的标签——或者说，我应该说是直接提供的标签，因为我们还没有一种方法来记录多个标签。我们会达到那个地步。一次只做一件事。
- en: Our `log` function currently has two overloaded versions. One takes a single
    `Tag` parameter and turns it into a string that it passes to the other. Once the
    tag is turned into a string, it becomes harder to detect which tags are currently
    being used, and we’ll need to know that so that we don’t end up logging both a
    default tag and a directly specified tag with the same key.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `log` 函数目前有两个重载版本。一个接受单个 `Tag` 参数并将其转换为传递给另一个函数的字符串。一旦标签被转换为字符串，就很难检测到当前正在使用的标签，我们需要知道这一点，以免最终记录了具有相同键的默认标签和直接指定的标签。
- en: For example, we don’t want a log message to include both `info` and `debug`
    log levels because the log was made with `debug` while `info` was the default.
    We only want the `debug` tag to appear because it should override the default.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们不希望日志消息同时包含 `info` 和 `debug` 日志级别，因为日志是用 `debug` 模式创建的，而 `info` 是默认模式。我们只想看到
    `debug` 标签出现，因为它应该覆盖默认设置。
- en: We need to pass the tag to the `log` function that does the output as a `Tag`
    instance instead of a string. Instead of a single `Tag` instance, though, let’s
    let callers pass more than one tag when calling `log`. Should we let the number
    of tags be unlimited? Probably not. Three seems like a good amount. If we need
    more than three, we’ll come up with a different solution or add more.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将标签作为 `Tag` 实例传递给执行输出的 `log` 函数，而不是字符串。然而，在调用 `log` 时，让我们允许调用者传递多个标签。我们应该让标签的数量无限吗？可能不是。三个看起来是个不错的数量。如果我们需要超过三个，我们会想出不同的解决方案或增加更多。
- en: 'I thought about different ways to write a `log` function that takes a variadic
    number of tags using templates. While it might be possible, the complexity quickly
    became unworkable. So, instead, here are three overloads of `log` that turn the
    parameters into a vector of `Tag` pointers:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我考虑了使用模板编写接受可变数量标签的 `log` 函数的不同方法。虽然这可能可行，但复杂性很快变得难以处理。所以，相反，这里提供了三个重载的 `log`
    函数，它们将参数转换为 `Tag` 指针的向量：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These functions replace the earlier `log` function that converted the tag into
    a string. The new functions create a vector of `Tag` pointers. We might eventually
    need to call `clone` to create copies instead of using pointers to the caller’s
    arguments, but for now, this works, and we don’t have to worry about the lifetime
    issues we had with the default tags.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数替换了之前将标签转换为字符串的 `log` 函数。新函数创建了一个 `Tag` 指针的向量。我们最终可能需要调用 `clone` 来创建副本而不是使用指向调用者参数的指针，但就目前而言，这可行，我们不必担心我们之前与默认标签相关的生命周期问题。
- en: 'We’ll need to include `vector` at the top of `Log.h`, and while implementing
    the `log` function that actually does the logging, I ended up needing `algorithm`
    too. The new include section looks like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `Log.h` 的顶部包含 `vector`，在实现实际执行日志记录的 `log` 函数时，我最终还需要 `algorithm`。新的包含部分如下所示：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And now, to the changes to the `log` function that does the logging. It looks
    like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看对执行日志记录的 `log` 函数的更改。它看起来是这样的：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Instead of accepting a string of pre-formatted tags, the function now takes
    a vector of `Tag` pointers with a default value of an empty collection. As far
    as this function is concerned, there can be an unlimited number of tags. The limit
    of three tags comes only because of the overloaded `log` functions that take up
    to three tags.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在函数不再接受预格式化的标签字符串，而是接受一个 `Tag` 指针的向量，默认值为空集合。就这个函数而言，可以有无限多个标签。三个标签的限制仅仅是因为重载的
    `log` 函数最多接受三个标签。
- en: The default value for the `tags` vector lets callers continue to be able to
    call `log` with no arguments.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`tags` 向量的默认值允许调用者继续使用不带参数调用 `log`。'
- en: The first part of the function that formats the timestamp, opens the log file,
    and prints the timestamp remains unchanged, except that we no longer display a
    pre-formatted string for the tags.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化时间戳、打开日志文件和打印时间戳的功能的第一部分保持不变，除了我们不再显示标签的预格式化字符串。
- en: The changes start with the first `for` loop, which looks at each default tag.
    We want to try finding the same tag key in the vector of tag pointers. If we find
    the same key, then we skip the default tag and try the next one. If we don’t find
    the same key, then we display the default tag.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 变更从第一个`for`循环开始，该循环检查每个默认标签。我们想要尝试在标签指针的向量中找到相同的标签键。如果我们找到相同的键，则跳过默认标签并尝试下一个。如果我们找不到相同的键，则显示默认标签。
- en: To do the searching, we use the `std::find_if` algorithm and provide a lambda
    that knows how to compare the keys.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行搜索，我们使用`std::find_if`算法并提供一个知道如何比较键的lambda表达式。
- en: After displaying only the default tags that were not overridden, the code goes
    through a second `for` loop to display all the tags passed in directly.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在仅显示未被覆盖的默认标签之后，代码通过第二个`for`循环显示所有直接传递的标签。
- en: 'Building and running the test application shows that all the tests pass, and
    the log file now contains default tags for all the entries, like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行测试应用程序显示所有测试都通过，日志文件现在包含所有条目的默认标签，如下所示：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'All the log messages contain the color tag set to `"green"`, and they all contain
    the `log_level` tag with either the default value of `"info"` or the overridden
    value of `"error"`. For the test that overrides the default value, let’s make
    sure that the default value does not exist. We can make use of the unwanted tags
    parameter in the `isTextInFile` function, like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 所有日志消息都将颜色标签设置为`"green"`，并且它们都包含`log_level`标签，该标签的值要么是默认值`"info"`，要么是覆盖值`"error"`。对于覆盖默认值的测试，让我们确保默认值不存在。我们可以利用`isTextInFile`函数中的不受欢迎的标签参数，如下所示：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Should the extra check that the default tag value does not exist in the log
    file be added to a separate test? The benefit of a separate test is that it makes
    it clear what is being tested. The downside is that the test will be almost identical
    to this one. It’s something to think about. In this case, I think the extra check
    and comment in the existing test is enough.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 是否应该将检查默认标签值是否不存在于日志文件中的额外检查添加到单独的测试中？单独测试的好处是它清楚地说明了正在测试的内容。缺点是测试将几乎与这个测试相同。这是一件需要思考的事情。在这种情况下，我认为在现有测试中添加额外检查和注释就足够了。
- en: Before moving on, we need to add a test for the feature that I slipped in for
    multiple tags. I really should have written a test for this first before enhancing
    the code to support multiple tags, but for the purposes of explaining the code,
    it was much more direct to just explain the idea of multiple tags once instead
    of going back and adding the extra explanation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要为我在多个标签中添加的功能添加一个测试。我真的很应该在增强代码以支持多个标签之前先为这个编写测试，但为了解释代码，一次直接解释多个标签的想法比返回并添加额外的解释要直接得多。
- en: 'Let’s quickly add a new type of `Tag` called `Size` with a few named instances
    in `LogTags.h`, like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速在`LogTags.h`中添加一个名为`Size`的新类型`Tag`，并包含几个命名实例，如下所示：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And now, here is a test for multiple tags:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里是一个针对多个标签的测试：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The log file contains the entry with all three tags, like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件包含包含所有三个标签的条目，如下所示：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We have the ability to log with up to three directly specified tags and multiple
    default tags. We need to eventually use the tags for more than just displaying
    information in the log file. We want to be able to filter log messages based on
    the tag values to control which log messages make it all the way to the log file
    and which are ignored. We’re not quite ready for filtering. The next section will
    explore filtering options based on the tag values.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有使用最多三个直接指定的标签和多个默认标签进行日志记录的能力。我们最终需要使用标签来做的不仅仅是显示日志文件中的信息。我们希望能够根据标签值过滤日志消息，以控制哪些日志消息能够到达日志文件，哪些被忽略。我们还没有准备好进行过滤。下一节将探讨基于标签值的过滤选项。
- en: Exploring filtering options
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索过滤选项
- en: Filtering log messages lets us write code that includes calls to log information
    at important places within the code but then ignore some of those logging calls.
    Why would we go to all the trouble of adding code to do logging but then not do
    the logging?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤日志消息让我们能够编写在代码中的重要位置调用日志信息的代码，但忽略其中的一些日志调用。我们为什么要费尽周折添加用于日志记录的代码，然后又不进行日志记录？
- en: For some events in the code such as an error that gets detected, it makes sense
    to always log that event. Other places might be equally important even if they
    are not errors. Usually, these are places in the code where something gets created
    or deleted. I’m not talking about creating or deleting an instance of a local
    variable. I mean something major, such as the creation of a new customer account,
    the completion of a quest in an adventure game, or the deletion of an old data
    file to free up space. All of these are good examples of important events that
    should probably always be logged.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代码中的某些事件，例如检测到的错误，始终记录该事件是有意义的。其他地方可能同样重要，即使它们不是错误。通常，这些是代码中创建或删除某些内容的地方。我说的不是创建或删除局部变量的实例。我指的是一些重大的事情，比如创建新的客户账户、完成冒险游戏中的任务，或者删除旧数据文件以释放空间。所有这些都是应该始终记录的重要事件的例子。
- en: Other events might help a developer understand what a program was doing right
    before it crashed. These log messages act like signposts along a journey. They’re
    not as big as the errors or major events, but they can let us figure out what
    a program was doing. These are usually good to log too because, without them,
    it can be hard to fix bugs. Sure—the error log might show clearly that something
    bad happened, but understanding what led up to the problem can be difficult without
    the signpost messages.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 其他事件可能有助于开发者了解程序在崩溃前做了什么。这些日志消息就像旅途中的路标。它们不如错误或重大事件那么重要，但它们可以帮助我们了解程序在做什么。这些通常也适合记录，因为没有它们，修复错误可能会很困难。当然——错误日志可能会清楚地显示发生了不好的事情，但没有路标消息，理解导致问题的原因可能会很困难。
- en: And sometimes, when we know the general idea of what led to a problem, we need
    even more details. This is where we sometimes want to turn off the logging because
    log messages such as these can sometimes be extremely verbose and cause the size
    of the log files to increase. They can also make it hard to see the bigger picture.
    Have you ever tried walking someplace with your eyes intently focused on the ground
    at your feet? You can get all the details of every step but might find that you
    get lost. Looking up to see the general direction makes it hard to also notice
    a small rock that can cause you to trip.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当我们知道导致问题的总体思路时，我们还需要更多细节。这就是我们有时想要关闭日志记录的原因，因为像这样的日志消息有时可能会非常冗长，导致日志文件的大小增加。它们也可能使看到整体情况变得困难。你有没有尝试过眼睛紧紧盯着脚下的地面走路？你可以得到每一步的详细信息，但可能会发现你迷路了。抬头看大致方向会使你难以注意到可能让你绊倒的小石头。
- en: When writing code, we want to put all these types of log messages into the code
    because adding extra logging messages later can be difficult, especially if the
    program is running at a remote customer location. So, we want the code to try
    to log everything. And then, at runtime, we want to control exactly how much information
    appears in the log files. Filtering lets us control how much logging we see by
    ignoring some logging requests.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，我们希望将这些类型的日志消息全部放入代码中，因为以后添加额外的日志消息可能会很困难，尤其是在程序在远程客户位置运行时。因此，我们希望代码尝试记录一切。然后，在运行时，我们希望精确控制日志文件中显示的信息量。过滤功能使我们能够通过忽略一些日志请求来控制我们看到多少日志。
- en: We’re going to filter log messages based on tags and their values, but we have
    a problem.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据标签及其值来过滤日志消息，但我们遇到了一个问题。
- en: Let’s say that we want to ignore a log message unless it has a certain tagged
    value. The way our `log` function works now is that it immediately opens a log
    file and starts streaming a timestamp, then adds tags, and finally lets the caller
    send whatever else is needed.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要忽略一个日志消息，除非它具有特定的标签值。我们当前的`log`函数工作方式是立即打开日志文件，开始流式传输时间戳，然后添加标签，最后允许调用者发送所需的其他内容。
- en: The only way to know for certain if a log message should be allowed to complete
    is to look at the tags once they have been finalized. In other words, we need
    to let everything be sent as if it will be logged but without actually doing anything.
    Once we have the complete message, we can look at the message to see if it meets
    the criteria to be sent to the output file.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 确定是否允许日志消息完成输出的唯一方法是在它们最终确定后查看标签。换句话说，我们需要让所有内容都像将被记录一样发送，但实际上不进行任何操作。一旦我们有了完整的消息，我们就可以查看消息，看看它是否符合发送到输出文件的准则。
- en: This means we need to do two things differently. First, we need to stop writing
    to a log file right away and collect everything in case we do eventually need
    to write it. And second, we need to know when a log message is complete. We can’t
    simply return an open stream to the caller and let the caller do whatever they
    want with the stream. Or, I should say that we can’t return a stream that directly
    modifies the output log file. Letting the caller work directly with the final
    output log file gives us no way to know when the caller is done so that we can
    finish up and either ignore the log or let it continue.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要做两件事不同。首先，我们需要立即停止写入日志文件，并收集所有内容，以防我们最终需要写入。其次，我们需要知道何时一个日志消息完成。我们不能简单地返回一个打开的流给调用者，让调用者随意处理流。或者说，我们不能返回一个直接修改输出日志文件的流。让调用者直接与最终的输出日志文件工作，我们无法知道调用者何时完成，以便我们可以完成并决定忽略日志还是让它继续。
- en: 'I know of three ways to determine when a potential log message is complete.
    The first is to put everything into a single function call. The function can accept
    a variable number of arguments, so we won’t be limited to a fixed number. But
    because the entire log message is bundled into a single function call, we will
    know when we have everything. It might look like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道三种确定潜在日志消息何时完成的方法。第一种是将所有内容放入一个单独的函数调用中。该函数可以接受可变数量的参数，所以我们不会受到固定数量的限制。但是，因为整个日志消息都捆绑在一个单独的函数调用中，所以我们会知道何时拥有所有内容。它可能看起来像这样：
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: I’m using a tag instance, a couple of string literals, and an integer number
    in this example. The string literals could instead be string variables or maybe
    function calls that return information to be logged. One of the string literals,
    together with the number, actually forms a `key=value` tag. The point is that
    the `log` function would know for certain exactly how much information was sent
    to be logged and we would know all the values. We could easily test the log message
    to see if it should be allowed to continue or if it should be ignored.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我使用了一个标签实例、几个字符串字面量和一个整数。字符串字面量可以是字符串变量，或者可能是返回要记录的信息的函数调用。其中一个字符串字面量，连同数字一起，实际上形成了一个`key=value`标签。关键是`log`函数会确切地知道发送了多少信息以供记录，并且我们会知道所有值。我们可以轻松地测试日志消息，看看是否应该允许其继续，或者应该忽略它。
- en: We even have the beginning of a solution like this already because we accept
    up to three tag instances in the `log` function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了这种解决方案的初步形式，因为我们接受在`log`函数中最多三个标签实例。
- en: 'The second way to determine when a log is complete is to use something to terminate
    the stream we have now. It might look like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 确定日志何时完成的第二种方法是使用某种方法来终止我们现在的流。它可能看起来像这样：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Notice that we don’t need the extra space inside the `"count="` string literal
    because the `log` function adds one for us after all the tags.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要在`"count="`字符串字面量内部添加额外的空格，因为`log`函数会在所有标签之后为我们添加一个。
- en: 'Or, we could even allow tags to be sent to the stream, like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们甚至可以允许将标签发送到流中，如下所示：
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And we’re back to needing the leading space before the `count` string literal
    again. This is common for streams where the caller needs to manage spaces between
    streamed elements. The only place where we don’t need to add a space is at the
    very first item streamed after the `log` function.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们又回到了在`count`字符串字面量之前需要添加前导空格的情况。这在需要调用者管理流元素之间空格的流中很常见。唯一不需要添加空格的地方是在`log`函数之后流出的第一个项目。
- en: The main idea with the stream approach is that we need something at the end
    to let the logging library know that all the information is ready to be tested
    against the criteria to see if the log should be ignored or not.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 流式方法的主要思想是我们需要在末尾添加一些内容，让日志库知道所有信息都已准备好，可以与标准进行比较，以确定是否应该忽略日志。
- en: I like the stream approach better. It feels more open to me—almost more natural.
    And because of operator precedence and the chaining of the streaming operators,
    we know the order in which the log line will be evaluated. That might not be very
    important, but it plays into the feeling that I like the streaming approach better.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢流式方法。它让我感觉更开放——几乎更自然。而且由于操作符优先级和流操作符的链式操作，我们知道日志行将被评估的顺序。这可能不是非常重要，但它强化了我更喜欢流式方法的感觉。
- en: With this second approach, the stream that the caller gets back from the `log`
    function can’t be a `std::fstream` instance that is directly tied to the log file.
    Working with `fstream` directly would not let us ignore the log message because
    the information would already be sent to the file. Maybe we could return a stream
    that’s tied to a string instead and let the terminating `endlog` element send
    the string that gets built to the log file or ignore it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种第二种方法，调用者从`log`函数获取的流不能是一个直接与日志文件绑定的`std::fstream`实例。直接使用`fstream`将无法忽略日志消息，因为信息已经发送到文件中。也许我们可以返回一个与字符串绑定的流，并让终止的`endlog`元素发送构建的字符串到日志文件或忽略它。
- en: What happens if the terminating `endlog` element is forgotten? The terminating
    `endlog` element needs to evaluate the log and move it forward or ignore it. If
    `endlog` is forgotten, then the log message will not complete. The developer might
    not notice the problem until a need to look at the log file shows that the expected
    log message is always ignored.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果忘记了终止的`endlog`元素会发生什么？终止的`endlog`元素需要评估日志并将其向前移动或忽略它。如果忘记了`endlog`，那么日志消息将不会完成。开发者可能直到需要查看日志文件时才会注意到问题，此时期望的日志消息总是被忽略。
- en: The third approach is similar to the second but without the need for a terminating
    element that can be forgotten. Anytime a design relies on a person to remember
    to do something, there will almost certainly be cases where the required part
    is left out. By removing the need to remember to add a terminating marker, we
    get a better design that can no longer be misused due to a simple oversight.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法与第二种类似，但不需要一个可能被遗忘的终止元素。任何设计依赖于人记住做某事的时候，几乎肯定会有遗漏所需部分的情况。通过消除记住添加终止标记的需要，我们得到了一个更好的设计，它不再会因为简单的疏忽而被误用。
- en: We already know that we can’t just return a stream tied directly to a log file.
    The third approach takes this a step further and returns a custom stream. We don’t
    use a standard stream at all because we need to add code in the stream destructor
    that finishes the logging and decides to either let the message complete or ignore
    it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道不能直接返回一个与日志文件绑定的流。第三种方法更进一步，返回一个自定义流。我们根本不使用标准流，因为我们需要在流析构函数中添加代码来完成日志记录并决定是让消息完成还是忽略它。
- en: 'This approach relies on specific object lifetime rules defined by C++. We need
    to know exactly when the destructor will run because we need the destructor to
    fill the role of a terminating `endlog` element. Other programming languages that
    use garbage collection to clean up deleted objects would not be able to support
    this third solution because the stream would not be deleted until some unspecified
    time in the future. C++ is very clear about when object instances get deleted,
    and we can rely on the order. For instance, we could make a call to `log` like
    this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法依赖于C++定义的特定对象生命周期规则。我们需要确切知道析构函数何时运行，因为我们需要析构函数扮演终止的`endlog`元素的角色。其他使用垃圾回收来清理已删除对象的编程语言无法支持这种第三种解决方案，因为流将不会在未来的某个不确定时间被删除。C++非常明确地说明了对象实例何时被删除，我们可以依赖这个顺序。例如，我们可以这样调用`log`：
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The custom stream that `log` returns will be destructed at the semicolon, which
    ends the expression. The programmer cannot forget anything, and the stream will
    be able to run the same code that an explicit `endlog` element would trigger.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`log`返回的自定义流将在表达式结束的分号处被析构。程序员不会忘记任何事情，流将能够运行与显式的`endlog`元素会触发的相同代码。'
- en: Maybe we could combine the best aspects of all three approaches. The first function
    call approach doesn’t need a terminating element because it knows exactly how
    many arguments are being passed. The second terminating `endlog` approach is more
    open and natural and can work with a standard stream to a string, and the custom
    stream approach is open and natural too and avoids misuse.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们可以结合所有三种方法的最佳之处。第一种函数调用方法不需要终止元素，因为它确切地知道正在传递多少个参数。第二种终止的`endlog`方法更加开放和自然，可以与字符串的标准流一起工作，而自定义流方法也是开放和自然的，并且避免了误用。
- en: I initially wanted to create a logging library that would be able to filter
    messages based on the entire message. While filtering on anything in the message
    seems to be the most flexible and powerful solution, it’s also the most complicated
    to implement. We don’t want to choose one design over another just because one
    is easier to code. We should choose a design based on the end usage that we will
    be happy with and find natural to use. Sometimes, complex implementations are
    a sign that the end use will also be complicated. A solution that might be less
    powerful overall but is easier to use will be better, as long as we don’t take
    away anything that is required.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我最初想要创建一个能够根据整个消息过滤消息的日志库。虽然根据消息中的任何内容进行过滤似乎是最灵活和强大的解决方案，但它也是最难实现的。我们不想因为一个更容易编码而选择一个设计而不是另一个。我们应该选择一个基于最终使用的设计，这样我们会感到满意并且使用起来自然。有时，复杂的实现可能意味着最终使用也会很复杂。一个可能整体上不那么强大但更容易使用的解决方案会更好，只要我们不取消任何必需的功能。
- en: One filtering complexity that we should be able to remove without affecting
    the end use is to only look at tags formed through the `Tag`-derived classes.
    We should be able to drop the ability to filter a log message based on the content
    of manually crafted tags.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能够去除一种过滤复杂性，而不会影响最终使用，那就是只查看通过`Tag`派生类形成的标签。我们应该能够取消根据手动编写的标签内容过滤日志消息的能力。
- en: 'Another simplification we can make will be to only filter tags passed to the
    `log` function. This will combine the aspect of the first approach where the `log`
    function accepts multiple arguments with the custom streaming approach, which
    accepts an intuitive series of information in chunks. So, take a look at the following
    streaming example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做出的另一个简化是只过滤传递给`log`函数的标签。这将结合第一个方法中`log`函数接受多个参数的方面，以及接受一系列直观信息的自定义流式传输方法。所以，看看以下流式传输示例：
- en: '[PRE44]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, there are a total of three `key=value` tags. The first is the `info` tag,
    then the `green` tag, and then a tag formed manually with the count text and number.
    Instead of trying to filter based on all three tags, the only information we’ll
    use for filtering will be the `info` tag because that is the only tag passed to
    the `log` function directly. We should also filter based on default tags because
    the `log` function knows about the default tags too. This makes it easy to understand
    what the `log` function does. The `log` function starts the logging and determines
    if anything that comes after it will be accepted or ignored.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里总共有三个`key=value`标签。第一个是`info`标签，然后是`green`标签，接着是一个手动形成的带有计数文本和数字的标签。我们不需要尝试根据所有三个标签进行过滤，我们将用于过滤的唯一信息将是`info`标签，因为这是唯一直接传递给`log`函数的标签。我们还应该根据默认标签进行过滤，因为`log`函数也了解默认标签。这使得理解`log`函数的功能变得容易。`log`函数启动日志记录并确定其后的任何内容是否被接受或忽略。
- en: 'If we want to consider the `green` tag in the filtering, then we just need
    to add it to the `log` function too, like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在过滤时考虑`green`标签，那么我们只需将其添加到`log`函数中，就像这样：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is the type of use that needs to be thought through with TDD. The result
    is not always the most powerful. Instead, the goal is to meet the needs of the
    user and be easy and intuitive to understand.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用类型需要通过TDD进行深思熟虑。结果并不总是最强大的。相反，目标是满足用户的需求，并且易于理解和直观。
- en: Because tags are becoming more important to this design, we should enhance them
    to support more than just text values. The next section will add new types of
    tags.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标签对这个设计变得越来越重要，我们应该增强它们以支持不仅仅是文本值。下一节将添加新的标签类型。
- en: Adding new tag types
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新的标签类型
- en: Since we’re starting to refer to tags with numbers instead of text for the value,
    now would be a good time to add support for numeric and Boolean tags that don’t
    need quotation marks around the value.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们开始用数字而不是文本来引用值，现在添加对不需要围绕值加引号的数字和布尔标签的支持将是一个好时机。
- en: 'We’re going to get slightly ahead of ourselves here and add some code that
    we don’t have a test for. That’s only because the additional support for numeric
    and Boolean tags is so similar to what we already have. This change is in `Log.h`
    in the `Tag` class. We need to add four extra constructors like this after the
    existing constructor that accepts a string:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里稍微提前一步，添加一些我们没有测试的代码。这仅仅是因为对数字和布尔标签的额外支持与我们已有的非常相似。这个更改在`Log.h`中的`Tag`类中。我们需要在现有的接受字符串的构造函数之后添加四个额外的构造函数，如下所示：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Each constructor forms text following either the `key="value"` or the `key=value`
    syntax. To test the new constructors, we’re going to need some new derived tag
    classes. All of these classes can go in `LogTags.h`. The two integral classes
    look like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 每个构造函数都遵循`key="value"`或`key=value`语法来形成文本。为了测试新的构造函数，我们需要一些新的派生标签类。所有这些类都可以放在`LogTags.h`中。两个整型类看起来是这样的：
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We’re not going to provide named instances of these tags. The earlier `Color`
    and `Size` tag types both have reasonable and common choices that make sense,
    but even they can be used directly if a strange color or an uncommon size needs
    to be logged. The new tags have no such common values.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会提供这些标签的命名实例。早期的`Color`和`Size`标签类型都有合理且常见的选项，但即使如此，如果需要记录奇怪的或不同寻常的颜色或尺寸，它们也可以直接使用。新的标签没有这样的常见值。
- en: 'Continuing, the double tag looks like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 继续说，双精度标签看起来是这样的：
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: And again, it has no obvious default values. Maybe we could provide a named
    value for 1.0 or some other specific values, but these seem like they would be
    best defined by the domain of the application. We’re just testing a logging library
    and will go without named instances for this tag.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，它没有明显的默认值。也许我们可以为1.0或其他特定值提供一个命名值，但这些似乎最好由应用程序的领域定义。我们只是在测试一个日志库，并且将没有命名实例地使用这个标签。
- en: 'The Boolean tag looks like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔标签看起来是这样的：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: And for this one, we have obvious named values for `true` and `false` that we
    can provide.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个，我们有明显的命名值`true`和`false`可以提供。
- en: All of the new tag classes should give you an idea of what they can be used
    for. Many of these are very applicable for large financial microservices where,
    for example, values can take a long time to be calculated and need to be cached.
    Logging whether a result was due to a cache hit or miss is very valuable when
    figuring out the flow of a calculation.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 所有新的标签类都应该给你一个它们可以用于什么目的的思路。其中许多非常适合大型金融微服务，例如，值可能需要很长时间才能计算出来，并且需要缓存。在确定计算的流程时，记录结果是由于缓存命中还是未命中非常有价值。
- en: 'We’d like to be able to pass one of the new tags to the stream returned by
    the `log` function, like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够将新的标签之一传递给`log`函数返回的流，如下所示：
- en: '[PRE50]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To do so, we need to add a stream overload that knows how to handle the `Tag`
    class. Add this function to `Log.h` right after the `to_string` function:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要添加一个知道如何处理`Tag`类的流重载。将此函数添加到`Log.h`中，紧接在`to_string`函数之后：
- en: '[PRE51]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The function uses an *rvalue reference* to the stream because we’re using the
    temporary stream returned from the `log` function.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用对流的右值引用，因为我们正在使用`log`函数返回的临时流。
- en: 'Now, we can create a test that will log and confirm each of the new types.
    You could make separate tests for each type or put all of them into one test,
    like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个测试，该测试将记录并确认每种新的类型。你可以为每种类型制作单独的测试，或者将它们全部放入一个测试中，如下所示：
- en: '[PRE52]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The reason I wasn’t so worried about creating this test before the code we added
    to enable the test is that we already thought through the desired usage before
    beginning.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以在添加代码以启用测试之前不那么担心创建这个测试，是因为我们在开始之前已经思考了期望的使用方式。
- en: 'The tag for double values might need some more work later to control the precision.
    You can see that it uses the default six decimals of precision. The log entries
    for the new test look like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于双精度值的标签可能需要稍后进行更多工作以控制精度。你可以看到它使用了默认的六位小数精度。新测试的日志条目看起来是这样的：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice how the message that is prepared for each `log` call is made unique with
    the numbers `1` to `4`. This makes sure that in the rare case where a duplicate
    random number will be generated, none of the four log messages will have the same
    text.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到为每个`log`调用准备的每条消息是如何通过数字`1`到`4`来确保唯一的。这确保了在极少数情况下，如果生成了重复的随机数，四个日志消息中不会有相同的文本。
- en: We can now log default tags, tags provided directly to the `log` function, and
    tags that are streamed just like any other piece of information. Before we implement
    the actual filtering, there are some enhancements that the next section will make
    to improve the tag classes even more by reducing the amount of code that needs
    to be written for each tag class.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以记录默认标签、直接传递给`log`函数的标签，以及像任何其他信息一样流出的标签。在我们实现实际过滤之前，下一节将进行一些增强，通过减少每个标签类需要编写的代码量来进一步改进标签类。
- en: Refactoring the tag design with TDD
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TDD重构标签设计
- en: We have a base `Tag` class and several derived tag classes in the tests. Even
    though the logging library will only define the log-level tag, it should still
    make it easy for developers to create new derived tag classes. And right now,
    creating a new derived tag class is mostly boilerplate code that needs to be repeated
    over and over. We should be able to enhance the experience by using templates.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我们有一个基类 `Tag` 和几个派生标签类。尽管日志库将只定义日志级别标签，但它仍然应该使开发者能够轻松创建新的派生标签类。目前，创建一个新的派生标签类主要是需要重复多次的样板代码。我们应该能够通过使用模板来提高这种体验。
- en: 'Here’s what an existing derived tag class looks like:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个现有的派生标签类的样子：
- en: '[PRE54]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `LogLevel`-derived tag class is the only class like this that the logging
    library will provide. It defines the log-level tag without actually defining any
    specific log-level values. It’s better to say that this class defines what a log
    level should be.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `LogLevel` 派生的标签类是日志库将提供的唯一此类类。它定义了日志级别标签，但实际上并没有定义任何特定的日志级别值。更好的说法是，这个类定义了日志级别应该是什么。
- en: 'We can compare the `LogLevel` class to one of the other derived tag classes
    from the tests. Let’s choose the `CacheHit` class, which looks like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `LogLevel` 类与测试中其他派生标签类之一进行比较。让我们选择 `CacheHit` 类，它看起来是这样的：
- en: '[PRE55]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: What can we improve about these classes? They’re almost the same, with a few
    differences that can be moved into a template class. What’s different about these
    two classes?
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对这些类进行哪些改进？它们几乎相同，只有一些可以移动到模板类中的不同之处。这两个类有什么不同？
- en: The name, obviously. `LogLevel` versus `CacheHit`.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显然是名称。`LogLevel` 与 `CacheHit`。
- en: The parent class namespace. `LogLevel` is already in the `MereMemo` namespace.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父类命名空间。`LogLevel` 已经在 `MereMemo` 命名空间中。
- en: The key string. `LogLevel` uses `"log_level"` while `CacheHit` uses `"cache_hit"`.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字符串。`LogLevel` 使用 `"log_level"`，而 `CacheHit` 使用 `"cache_hit"`。
- en: The type of the value. `LogLevel` uses a `std::string` value while `CacheHit`
    uses a `bool` value.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值的类型。`LogLevel` 使用 `std::string` 值，而 `CacheHit` 使用 `bool` 值。
- en: That’s all the differences. There should be no need to make developers recreate
    all this every time a new tag class is needed. And we’re going to need to add
    more code to the tag classes in order to support filtering, so now is a great
    time to simplify the design.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是所有的区别。不应该需要开发者每次需要新的标签类时都重新创建所有这些。而且，我们需要向标签类添加更多代码以支持过滤，所以现在是简化设计的好时机。
- en: We should be able to make the upcoming filtering changes without affecting any
    of the existing tests, but that will require design changes now. We’re refactoring
    the design, and the tests will help make sure that the new design continues to
    behave just like the current design. The confidence we get from knowing everything
    still works is one of the benefits of using TDD.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能够在不影响任何现有测试的情况下进行即将到来的过滤更改，但这将需要现在进行设计更改。我们正在重构设计，测试将有助于确保新设计继续像当前设计一样表现。从知道一切仍然正常工作所获得的信心是使用
    TDD 的一大好处。
- en: The `Tag` class represents an interface that all tags support. We’ll leave it
    as-is and simple. Instead of changing the `Tag` class, we’ll introduce a new template
    class that can hold the `clone` method implementation and any upcoming filtering
    changes.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tag` 类代表了一个所有标签都支持的接口。我们将保持其原样并保持简单。我们不会更改 `Tag` 类，而是引入一个新的模板类，它可以包含 `clone`
    方法实现以及任何即将到来的过滤更改。'
- en: 'Change the `LogLevel` class in `Log.h` to use a new `TagType` template class
    that can use different types of values, like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Log.h` 中的 `LogLevel` 类更改为使用新的 `TagType` 模板类，该类可以使用不同类型的值，如下所示：
- en: '[PRE56]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We still have a class called `LogLevel` that can be used just like before. It
    now specifies the type of the value, which is `std::string`, in the template argument
    to `TagType`, and the `key` string is now a constant array of chars that each
    derived tag class will define. The `LogLevel` class is simpler because it no longer
    needs to handle cloning.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有一个名为 `LogLevel` 的类，可以像以前一样使用。现在它指定了值的类型，即 `std::string`，在 `TagType` 模板的参数中，而
    `key` 字符串现在是一个由每个派生标签类定义的常量字符数组。`LogLevel` 类更简单，因为它不再需要处理克隆。
- en: The new `TagType` template class does most of the hard work. For right now,
    that work is just cloning, but we’ll need to add more features in order to implement
    filtering. We should be able to put those upcoming features inside the `TagType`
    class and leave the derived tag classes unchanged.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`TagType`模板类做了大部分的艰苦工作。目前，这项工作只是克隆，但我们需要添加更多功能来实现过滤。我们应该能够将这些即将到来的功能放入`TagType`类中，并保持派生标签类不变。
- en: The way this design works is based on something called the `LogLevel` inherits
    from `TagType`, and `TagType` is given `LogLevel` as one of its template parameters.
    This allows `TagType` to refer back to `LogLevel` from within the `clone` method
    in order to construct a new instance of `LogLevel`. Without the CRTP, then `TagType`
    would have no way to create a new `LogLevel` instance because it would not know
    what type to create.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的工作方式基于某种称为`LogLevel`继承自`TagType`，而`TagType`将`LogLevel`作为其模板参数之一。这使得`TagType`能够在`clone`方法内部回指`LogLevel`以构造一个新的`LogLevel`实例。如果没有CRTP，那么`TagType`将无法创建新的`LogLevel`实例，因为它不知道要创建什么类型。
- en: And `TagType` needs to refer back to `LogLevel` one more time in order to get
    the name of the key. `TagType` does this again by referring to the type given
    to it by the CRTP in the `T` parameter.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 并且`TagType`需要再次回指`LogLevel`以获取键名。`TagType`通过再次引用CRTP在`T`参数中给出的类型来实现这一点。
- en: The `clone` method is a little more complicated because when we’re inside the
    `clone` method, we’re in the `TagType` class, which means that the `this` pointer
    needs to be cast to the derived type.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`clone`方法稍微复杂一些，因为当我们处于`clone`方法内部时，我们处于`TagType`类中，这意味着`this`指针需要被转换为派生类型。'
- en: 'We can now simplify the other derived tag types in `LogTags.h`. The `Color`
    and `Size` types both use `std::string` as the value type just like `LogLevel`,
    and they look like this:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以简化`LogTags.h`中的其他派生标签类型。`Color`和`Size`类型都使用`std::string`作为值类型，就像`LogLevel`一样，它们看起来是这样的：
- en: '[PRE57]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `Count` and `Identity` types both use integral value types of different
    lengths, and they look like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`Count`和`Identity`类型都使用不同长度的整数值类型，看起来是这样的：'
- en: '[PRE58]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `Scale` type uses a `double` value type and looks like this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scale`类型使用`double`值类型，看起来是这样的：'
- en: '[PRE59]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And the `CacheHit` type uses a `bool` value type and looks like this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 而`CacheHit`类型使用`bool`值类型，看起来是这样的：
- en: '[PRE60]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Each of the derived tag types is much simpler than before and can focus on
    what makes each one unique: the class name, the key name, and the type of the
    value.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 每个派生标签类型都比以前简单得多，可以专注于每个类型的独特之处：类名、键名和值的类型。
- en: The next section will create filtering tests based on logical criteria that
    will allow us to specify what should be logged, and we’ll be using the simplified
    tag classes too with the `clone` method.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将创建基于逻辑标准的过滤测试，这将允许我们指定应该记录什么，我们还将使用简化的标签类以及`clone`方法。
- en: Designing tests to filter log messages
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计过滤日志消息的测试
- en: Filtering log messages is going to be one of the biggest features of the logging
    library. That’s why this chapter is devoting so much effort to exploring ideas
    and enhancing the design. Most logging libraries offer some support for filtering,
    but usually, it’s limited to just logging levels. And the logging levels are also
    usually ordered so that when you set one logging level, then you get all logs
    with a level equal to and either above or below the filtered level.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤日志消息将是日志库最重要的功能之一。这就是为什么本章投入了如此多的努力来探索想法并增强设计。大多数日志库都提供了一些过滤支持，但通常仅限于日志级别。日志级别通常也是有序的，当你设置一个日志级别时，你会得到所有等于或高于过滤级别的日志。
- en: This always seemed arbitrary to me. Do the logging levels go up or down? Does
    setting the filtering level to `info` mean that you get `debug` too, or just `info`
    and `error` logs?
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我来说总是显得很随意。日志级别是上升还是下降？将过滤级别设置为`info`是否意味着你也会得到`debug`，或者只是`info`和`error`日志？
- en: And this ignores the bigger problem of information overload. Once you do figure
    out how to get debug-level logs, they all get logged and the logs quickly fill
    up. I’ve even seen logs fill up so fast that the messages I was interested in
    were already zipped up and about to be deleted to save space before I could even
    exit the application to see what happened.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这忽略了更大的问题——信息过载。一旦你弄清楚如何获取调试级别的日志，它们都会被记录下来，日志很快就会填满。我甚至见过日志填得如此快，以至于我感兴趣的日志消息已经被压缩并即将被删除以节省空间，在我能够退出应用程序查看发生了什么之前。
- en: Our target customer for the logging library is a microservices developer. This
    means that the applications being worked on are probably large and distributed.
    Turning on debug logging everywhere, even within a single service, causes a lot
    of problems.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标客户是日志库的微服务开发者。这意味着正在开发的应用程序可能很大且分布广泛。在单个服务中甚至是在所有地方开启调试日志会导致很多问题。
- en: 'The logging library we’re building will fix these problems, but we need to
    start simple. A test like this in `Tags.cpp` is a good start:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建的日志库将解决这些问题，但我们需要从简单开始。在`Tags.cpp`中的这个测试就是一个好的开始：
- en: '[PRE61]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The idea for this test is to first set a filter that will cause a log message
    to be ignored. We confirm that the message does not appear in the log file. Then,
    the test clears the filter and tries to log the same message again. This time,
    it should appear in the log file.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的想法是首先设置一个过滤器，该过滤器将导致日志消息被忽略。我们确认该消息没有出现在日志文件中。然后，测试清除过滤器，并再次尝试记录相同的消息。这次，它应该出现在日志文件中。
- en: Normally, a filter match should allow a log to proceed, and no match should
    cause the message to be ignored. But when there are no filters set at all, then
    we should let everything through. Letting everything through without any filters
    lets users opt into filtering. If filtering is being used at all, then it controls
    the log output, but when there are no filters, then it would be strange to not
    let anything through. When the test sets a filter that does not match the log
    message, then the message does not appear in the log file because filtering has
    been enabled. When the filter is cleared, then we’re assuming there are no other
    filters set, and all log messages will be allowed to proceed again.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，过滤器匹配应允许日志继续，而没有任何匹配应导致消息被忽略。但是，当没有任何过滤器设置时，我们应该让所有内容通过。不设置任何过滤器让所有内容通过，让用户可以选择是否进行过滤。如果正在使用过滤，那么它将控制日志输出，但当没有过滤器时，不让任何内容通过就显得很奇怪。当测试集设置了一个与日志消息不匹配的过滤器时，由于已经启用了过滤，该消息就不会出现在日志文件中。当清除过滤器时，我们假设没有设置其他过滤器，所有日志消息将再次被允许继续。
- en: We’ll be filtering logs based on formulas in the **Disjunctive Normal Form**
    (**DNF**). The DNF specifies one or more clauses that are OR’ed together. Each
    clause contains literals that are AND’ed together. These are not literals in the
    C++ sense. Here, literal is a mathematical term. Each literal in a clause can
    either be AND’ed as-is or NOT’ed first. All this is Boolean logic and has the
    ability to represent any logical condition from simple to complex filters. Explaining
    all the details of DNF is not the purpose of this book, so I won’t be explaining
    all the math behind DNF. Just know that DNF is powerful enough to represent any
    filter we can think of.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据**析取范式**（**DNF**）中的公式来过滤日志。DNF指定了一个或多个通过OR运算组合在一起的子句。每个子句包含通过AND运算组合在一起的文字。这里的“文字”不是C++意义上的文字。在这里，“文字”是一个数学术语。子句中的每个文字可以是直接AND运算，也可以先进行NOT运算。所有这些都是布尔逻辑，并且能够表示从简单到复杂的任何逻辑条件。解释DNF的所有细节不是本书的目的，因此我不会解释DNF背后的所有数学。只需知道DNF足够强大，可以表示我们所能想到的任何过滤器。
- en: This is a case where a powerful solution is needed. Even so, we’ll try to focus
    on the end use and keep the solution as easy to use as possible.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要强大解决方案的案例。即便如此，我们仍将专注于最终用途，并尽可能使解决方案易于使用。
- en: The test calls a `createFilterClause` function that returns an identifier for
    the clause created. Then, the test calls `addFilterLiteral` to add an `error`
    tag to the clause just created. What the test is trying to accomplish is to complete
    a log only if the `error` tag is present. If this tag is not present, then the
    log should be ignored. And remember that in order for a tag to be considered,
    it must either be present in the default tags or supplied directly to the `log`
    function.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 测试调用一个`createFilterClause`函数，该函数返回创建的子句的标识符。然后，测试调用`addFilterLiteral`向刚刚创建的子句添加一个`error`标签。测试试图完成的是，只有当`error`标签存在时，才完成日志。如果这个标签不存在，那么日志应该被忽略。并且记住，为了使标签被考虑，它必须存在于默认标签中或直接提供给`log`函数。
- en: Then, the test calls another function, `clearFilterClause`, which is intended
    to clear the filter clause just created and let everything be logged again.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试调用另一个函数`clearFilterClause`，该函数旨在清除刚刚创建的过滤器子句，并再次允许所有内容被记录。
- en: Normally, the microservices developer won’t run their application with filtering
    completely empty because that would allow all log messages to go through. Some
    amount of filtering will likely be in place at all times. As long as at least
    one filter clause is active, then filtering will only allow messages to proceed
    that match one of the clauses. By allowing multiple clauses, what we’re doing
    is letting extra log messages go through because each additional clause has the
    chance to match more log messages. We’ll have the ability to adjust what gets
    logged with a powerful system of Boolean logic.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，微服务开发者不会运行一个完全空的过滤应用，因为这会让所有日志消息都通过。在任何时候都可能存在一些过滤。只要至少有一个过滤子句是激活的，过滤就会只允许与其中一个子句匹配的消息继续。通过允许多个子句，我们实际上是在让额外的日志消息通过，因为每个额外的子句都有机会匹配更多的日志消息。我们将能够通过一个强大的布尔逻辑系统来调整记录的内容。
- en: A large project could then add tags that identify different components. The
    debug logs could be turned on only for certain components or for other matching
    criteria. The extra logic opens up more flexibility to increase the logging for
    interesting areas during debugging sessions while leaving other areas unaffected
    and logging at normal levels.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 一个大型项目可以添加标识不同组件的标签。调试日志可以只为某些组件或其他匹配标准打开。额外的逻辑在调试会话期间增加了更多灵活性，可以在不影响其他区域并保持正常日志级别的同时，增加对有趣区域的日志记录。
- en: 'What happens if a tag is present in the default tags but gets overridden directly
    in the call to `log`? Should the default tag be ignored in favor of the explicit
    tag? I think so, and this will be a great test to include. Edge cases such as
    this really help define a project and improve the benefits gained by using TDD.
    Let’s add the test now so that we don’t forget. It looks like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个标签存在于默认标签中，但在调用`log`时被直接覆盖，会发生什么？我们应该忽略默认标签，而选择显式的标签吗？我认为是这样，这将是一个很好的测试案例。边缘情况如此类实有助于定义项目并提高使用TDD获得的好处。现在让我们添加这个测试，以免忘记。它看起来是这样的：
- en: '[PRE62]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This test relies on the `info` tag already being set in the default tags. We
    should probably add the ability to test which tags are default so that the test
    can fail if `info` is not found in the default tags, and we need to make sure
    to clear the filter clause at the end of the test so that other tests are not
    affected. The previous test also cleared the clause but at a specific point in
    the test. Even so, the previous test should have a stronger guarantee that the
    test will not end with the filter clause still set. We should make use of a test
    teardown to always clear the filter clause at the end of any test that creates
    one.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试依赖于`info`标签已经在默认标签中设置。我们可能需要添加测试默认标签的能力，以便如果`info`在默认标签中找不到，测试会失败，并且我们需要确保在测试结束时清除过滤子句，以免影响其他测试。之前的测试也清除了子句，但在测试的特定点上。即便如此，之前的测试应该有一个更强的保证，即测试不会以过滤子句仍然设置的状态结束。我们应该利用测试拆解来确保在任何创建过滤子句的测试结束时始终清除过滤子句。
- en: Before continuing to add a teardown, the idea for the test that I started to
    explain is this. After setting a clause to only allow logs with the `info` tag,
    then the log message should have been allowed to continue because it will gain
    the `info` tag through the default set of tags. But instead, the log overrides
    the `info` tag with the `debug` tag. The end result is that the log message should
    not be found in the output log file.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续添加拆解步骤之前，我刚开始解释的测试想法是这样的。在设置一个只允许带有`info`标签的日志的子句后，日志消息应该被允许继续，因为它将通过默认的标签集获得`info`标签。但相反，日志覆盖了`info`标签，使用了`debug`标签。最终结果是，日志消息不应该出现在输出日志文件中。
- en: 'To make sure that we always clear the filter clause even if a test fails and
    throws an exception before it reaches the end of the test, we need to define a
    setup and teardown class in `Tags.cpp`, like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保即使在测试失败并抛出异常之前测试未到达末尾，我们也能始终清除过滤子句，我们需要在`Tags.cpp`中定义一个设置和拆解类，如下所示：
- en: '[PRE63]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If you want more information about setup and teardown classes, refer to [*Chapter
    7*](B18567_07.xhtml#_idTextAnchor065), *Test Setup* *and Teardown*.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于设置和拆解类的信息，请参阅[*第7章*](B18567_07.xhtml#_idTextAnchor065)，*测试设置*和*拆解*。
- en: 'It’s okay for a test to clear the filters itself at the appropriate times.
    Adding an instance of `SetupAndTeardown` will make sure to call the `clearFilterClause`
    function even if it was already called. The first test from this section looks
    like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当的时候，测试自己清除过滤器是可以的。添加一个`SetupAndTeardown`实例将确保即使它已经被调用，也会调用`clearFilterClause`函数。本节的第一项测试看起来像这样：
- en: '[PRE64]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The test now gets the clause ID from the setup and teardown instance. The ID
    is used to add the filter literal and to clear the filter clause at the correct
    time. The filter clause will be cleared again at the end of the test with no effect.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 测试现在从设置和清理实例中获取条款ID。ID用于添加过滤字面量和在正确的时间清除过滤条款。过滤条款将在测试结束时再次清除，但没有效果。
- en: 'The second test from this section no longer needs to explicitly clear the filter
    itself and only needs to add the `SetupAndTeardown` instance, like this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的第二个测试不再需要显式清除过滤器本身，只需要添加`SetupAndTeardown`实例，如下所示：
- en: '[PRE65]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This test was calling `clearFilterClause` at the end to put the filters back
    in an unfiltered state. The test no longer needs to call `clearFilterClause` directly
    because relying on the `SetupAndTeardown` destructor is more reliable.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试在结束时调用`clearFilterClause`以将过滤器放回未过滤的状态。测试不再需要直接调用`clearFilterClause`，因为依赖于`SetupAndTeardown`析构函数更可靠。
- en: 'We have two filter tests that call functions that don’t exist yet. Let’s add
    the following function stubs to `Log.h` right after the `addDefaultTag` function:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个过滤测试调用尚未存在的函数。让我们在`Log.h`文件中`addDefaultTag`函数之后添加以下函数占位符：
- en: '[PRE66]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `createFilterClause` function just returns `1` for now. It will need to
    eventually return a different identifier for each clause created.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 目前`createFilterClause`函数只是返回`1`。它最终需要为每个创建的条款返回不同的标识符。
- en: The `addFilterLiteral` function adds the given tag to the clause identified.
    The `normal` parameter will let us add literals that are NOT’ed or inverted by
    passing `false`. Be careful with the meaning of flags such as this. When I first
    wrote this, the flag was called `invert` and had a default value of `false`. I
    didn’t notice the problem until writing a test for an inverted filter and it seemed
    strange to pass `true` in order to get an inverted literal. The test highlighted
    the backward usage while the initial function declaration let it slip by unnoticed.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`addFilterLiteral`函数将给定的标签添加到指定的条款中。`normal`参数将允许我们通过传递`false`来添加NOT或反转的字面量。小心处理此类标志的含义。当我第一次写这个时，标志被命名为`invert`，默认值为`false`。我没有注意到这个问题，直到为反转过滤器编写测试，并且传递`true`以获取反转字面量看起来很奇怪。测试突出了反向使用，而初始函数声明让它悄悄溜走，没有被发现。'
- en: And the `clearFilterClause` function does nothing for now. We’ll need to have
    some sort of collection of clauses later that we can work with.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`clearFilterClause`函数目前没有任何作用。我们稍后需要有一些可以操作的条款集合。'
- en: 'Stubbing out the filter functions lets us build and run the test application.
    We get two test failures, like this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符过滤函数让我们构建和运行测试应用程序。我们得到两个测试失败，如下所示：
- en: '[PRE67]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The results are expected with TDD. We did the bare minimum needed to get the
    code building so that we can see the failures. We can add a little more implementation
    to the stubbed-out functions next.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 预期结果是使用TDD（测试驱动开发）。我们只做了必要的最小工作来构建代码，以便我们可以看到失败。我们可以在占位符函数中添加更多的实现。
- en: 'I mentioned that we’ll need a collection for the clauses. Add the following
    functions to `Log.h`, right before the stubbed-out filter functions:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到我们需要一个条款的集合。在`Log.h`文件中，在占位符过滤函数之前添加以下函数：
- en: '[PRE68]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The pattern is similar to what we did for the default tags. There is a function
    called `getFilterClauses` that returns a reference to a static map of `FilterClause`
    objects, and the `FilterClause` struct is defined to hold a couple of vectors
    for the normal and inverted literals. The literals are pointers to the tags that
    we get from cloning.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 模式与我们为默认标签所做的是相似的。有一个名为`getFilterClauses`的函数，它返回一个静态`FilterClause`对象映射的引用，而`FilterClause`结构体被定义为包含正常和反转字面量的几个向量。字面量是指从克隆中获得的标签的指针。
- en: 'The `createFilterClause` function can be implemented to use the collection
    of clauses, like this:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`createFilterClause`函数可以实施以使用条款集合，如下所示：'
- en: '[PRE69]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This function keeps track of the current id in a static variable that gets incremented
    each time the function is called. The only other task that needs to be done is
    to create an empty filter clause record. The id is returned to the caller so that
    the filter clause can be modified or cleared later.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数通过一个静态变量跟踪当前id，每次函数被调用时都会递增。需要完成的唯一其他任务是创建一个空的过滤条款记录。id被返回给调用者，以便稍后可以修改或清除过滤条款。
- en: 'The `addfilterLiteral` function can be implemented like this:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`addfilterLiteral`函数可以像这样实现：'
- en: '[PRE70]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This function makes sure that the `clauses` collection contains an entry for
    the given filter id before pushing back a cloned pointer to either the normal
    or inverted vector.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数确保在将克隆指针推入正常或反转向量之前，`clauses`集合包含给定过滤id的条目。
- en: 'And the `clearFilterClause` function is the simplest because it just needs
    to get the collection and erase whichever filter clause exists with the given
    id like this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 而`clearFilterClause`函数是最简单的，因为它只需要获取集合并删除具有给定id的任何过滤条款，如下所示：
- en: '[PRE71]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We still need to examine the filter clauses when logging, and that will be explained
    in the next section. When following TDD, it’s good to get tests working to the
    point where the code builds and the tests fail when run. Let’s get the tests to
    pass in the next section!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要在记录日志时检查过滤条款，这将在下一节中解释。在遵循TDD时，当代码构建并且运行时测试失败时，让测试通过是很好的。让我们在下一节中让测试通过！
- en: Controlling what gets logged
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制要记录的内容
- en: Earlier in this chapter when we were exploring filtering options, I mentioned
    that we will need a custom stream class instead of returning `std::fstream` from
    the `log` function. We need this so that we don’t immediately send information
    to the log file. We need to avoid sending a log message directly to the log file
    because there could be filtering rules in place that could cause the log message
    to be ignored.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早期，当我们探索过滤选项时，我提到过我们需要一个自定义流类，而不是从`log`函数返回`std::fstream`。我们需要这样做，以便我们不会立即将信息发送到日志文件。我们需要避免直接将日志消息发送到日志文件，因为可能存在过滤规则，这些规则可能导致日志消息被忽略。
- en: We also decided that we would make the decision to log or not based entirely
    on the default tags and any tags sent directly to the `log` function. We could
    have the `log` function make the decision and either return `std::fstream` if
    the log message should proceed or a fake stream if the log message should be ignored,
    but it’s probably better to always return the same type. That seems like the simplest
    and most straightforward solution. Switching between stream types just seems like
    a more complicated solution that still requires a custom stream type.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还决定，我们将完全基于默认标签和直接发送到`log`函数的任何标签来决定是否记录。我们可以让`log`函数做出决定，如果日志消息应该继续，则返回`std::fstream`，如果日志消息应该被忽略，则返回一个假流，但可能更好的做法是始终返回相同的类型。这似乎是最简单、最直接的方法。在流类型之间切换似乎是一个更复杂的解决方案，仍然需要自定义流类型。
- en: And using a custom stream type will also let us fix a nagging problem where
    we have to put newlines *before* each log message instead of *after*. This has
    resulted in log files with an empty first line and the last line ending abruptly.
    We went with the temporary solution to put newlines before each log message because
    we didn’t have anything at the time that would let us know when all the information
    had been streamed.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义流类型也将使我们能够解决一个令人烦恼的问题，即我们不得不在每个日志消息之前而不是之后放置换行符。这导致了日志文件的第一行是空的，最后一行突然结束。我们选择了在每次日志消息之前放置换行符的临时解决方案，因为我们当时没有东西可以让我们知道所有信息都已经流过。
- en: 'Well, a custom stream class will let us solve the nagging newline problem and
    give us a way to avoid writing log messages directly to the log file. Let’s start
    with the new stream class. Create this class in `Log.h`, right before the `log`
    functions, like so:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，自定义流类将使我们能够解决这个令人烦恼的换行符问题，并给我们一个避免直接将日志消息写入日志文件的方法。让我们从新的流类开始。在`Log.h`中创建这个类，在`log`函数之前，如下所示：
- en: '[PRE72]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We’re going to fix one problem at a time. So, we’ll continue to refactor this
    class until it does everything we need. Right now, it just inherits from `std::fstream`,
    so it won’t solve the problem of writing directly to the log file. The constructor
    still opens the log file, and all the streaming capability is inherited from `fstream`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一次解决一个问题。因此，我们将继续重构这个类，直到它完成我们需要的所有事情。现在，它只是从`std::fstream`继承，所以它不会解决直接写入日志文件的问题。构造函数仍然打开日志文件，所有的流能力都是从`fstream`继承的。
- en: What this class does solve is the newline problem. It solves this by sending
    `std::endl` to the stream in the class destructor. The constructor that opens
    the file based on the name provided and the destructor that adds the newline are
    really the only parts of this class that solve the problem. The rest of the class
    is needed to get the code to compile and work properly.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类所解决的问题就是换行问题。它是通过在类的析构函数中向流发送`std::endl`来解决的。基于提供的名称打开文件和添加换行的析构函数是这个类解决问题的关键部分。类的其余部分是为了使代码能够编译和正常工作。
- en: Because we added a destructor, that set off a chain reaction of other requirements.
    We now need to provide a copy constructor. We actually need the *move copy constructor*
    because streams tend to act strange when copied. Copying a stream is not a simple
    task, but moving a stream into another stream is much simpler and does everything
    we need anyway. We don’t need to make any copies of the stream but we do need
    to return the stream from the `log` function, which means the stream either needs
    to be copied or moved. So, we explicitly delete the copy constructor and implement
    the move copy constructor.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们添加了一个析构函数，这引发了一系列其他要求。我们现在需要提供一个复制构造函数。实际上，我们需要的是*移动复制构造函数*，因为流在复制时往往会表现得奇怪。复制流不是一个简单的任务，但将流移动到另一个流中要简单得多，并且已经完成了我们需要的所有事情。我们不需要复制流，但我们确实需要从`log`函数返回流，这意味着流要么需要被复制，要么需要被移动。因此，我们显式删除了复制构造函数并实现了移动复制构造函数。
- en: We also delete both the assignment operator and the move assignment operator
    because we don’t need to assign the stream either.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还删除了赋值运算符和移动赋值运算符，因为我们不需要对流进行赋值。
- en: 'We can use the new `LogStream` class by modifying the `log` function to look
    like this:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过修改`log`函数来使用新的`LogStream`类，使其看起来像这样：
- en: '[PRE73]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `log` function now returns a `LogStream` instance instead of `std::fstream`.
    Inside the function, it creates a `LogStream` instance as if it were a `fstream`
    instance. The only thing that changes is the type. And we now have the file open
    mode defaulted to `append`, so we don’t need to specify how to open the file.
    The name of the stream changed to `ls` because this is no longer a log file.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`log`函数返回一个`LogStream`实例而不是`std::fstream`。在函数内部，它创建一个`LogStream`实例，就像它是一个`fstream`实例一样。唯一改变的是类型。现在文件打开模式默认为`append`，因此我们不需要指定如何打开文件。流的名字改为`ls`，因为这已经不再是一个日志文件了。
- en: And then, when sending the initial timestamp, we no longer need to send an initial
    `std::endl` instance and can immediately start with the timestamp.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在发送初始时间戳时，我们不再需要发送初始的`std::endl`实例，可以直接开始发送时间戳。
- en: The only thing different when the test application runs after these changes
    is that the log file will no longer have an empty first line and all lines will
    end with a newline.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改之后，测试应用程序运行时唯一的不同之处在于日志文件将不再有空的第一个行，并且所有行都将以换行符结束。
- en: That’s one small problem fixed. What about the bigger problem of writing directly
    to the log file? We still want to write to a standard stream because implementing
    our own stream class adds a lot of complexity we don’t really need right now.
    So, instead of inheriting the `LogStream` class from `std::fstream`, we’ll instead
    inherit from `std::stringstream`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 那个小问题已经解决了。那么，直接写入日志文件的大问题怎么办？我们仍然希望写入标准流，因为实现我们自己的流类会增加我们目前并不真正需要的很多复杂性。因此，我们不会从`std::fstream`继承`LogStream`类，而是从`std::stringstream`继承。
- en: 'We’re going to need to include `sstream` to get a definition of `stringstream`,
    and we might as well include `ostream` now too. We’ll need `ostream` in order
    to change our streaming helper function in `Log.h`, which currently uses `std::fstream`,
    to look like this instead:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要包含`sstream`以获取`stringstream`的定义，我们也可以现在就包含`ostream`。我们需要`ostream`来更改`Log.h`中的流辅助函数，该函数目前使用`std::fstream`，我们将将其改为如下所示：
- en: '[PRE74]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We probably should have implemented this helper function to use `ostream` from
    the very beginning. This way, we can stream tags to any output stream. And because
    both `fstream` and `stringstream` are based on `ostream`, we can use this one
    helper function to stream to both.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能从一开始就应该实现这个辅助函数来使用`ostream`。这样，我们可以将标签流式传输到任何输出流。由于`fstream`和`stringstream`都基于`ostream`，我们可以使用这个辅助函数将流式传输到两者。
- en: 'Here are the updated includes for `Log.h`:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是更新后的`Log.h`的包含内容：
- en: '[PRE75]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Technically, we don’t need to include `ostream` because we get it already through
    including `fstream` and `stringstream`, but I like to include headers for things
    we are directly using. And while looking into the headers being included, I noticed
    that we were including `iostream`. I think I originally included `iostream` to
    get the definition of `std::endl`, but it seems that `endl` is actually declared
    in `ostream`. So, based on my rule to include headers being used, we should have
    been including `ostream` since the very beginning instead of `iostream`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们不需要包含 `ostream`，因为我们已经通过包含 `fstream` 和 `stringstream` 获得了它。但我喜欢包含我们直接使用的东西的头文件。在查看包含的头文件时，我发现我们包含了
    `iostream`。我认为我最初包含 `iostream` 是为了获取 `std::endl` 的定义，但看起来 `endl` 实际上是在 `ostream`
    中声明的。所以，根据我包含使用头文件的规则，我们应该从一开始就包含 `ostream` 而不是 `iostream`。
- en: 'Back to `LogStream`, we need to change this class to inherit from `stringstream`,
    like this:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `LogStream`，我们需要将这个类修改为从 `stringstream` 继承，如下所示：
- en: '[PRE76]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: There is a new data member called `mProceed` that we set to `true` in the constructor.
    Since we no longer inherit from `std::fstream`, we now need a data member that
    is a file stream. We also need to initialize the `mFile` member. The move copy
    constructor needs to initialize the data members, and the destructor checks if
    the logging should proceed or not. If the logging should proceed, then the string
    content of `stringstream` is sent to the file stream.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个新的数据成员叫做 `mProceed`，我们在构造函数中将它设置为 `true`。由于我们不再从 `std::fstream` 继承，我们现在需要一个文件流的数据成员。我们还需要初始化
    `mFile` 成员。移动拷贝构造函数需要初始化数据成员，析构函数检查是否应该继续日志记录。如果应该继续日志记录，那么 `stringstream` 的字符串内容将被发送到文件流。
- en: We still haven’t implemented the filtering, but we’re getting close. This change
    gets us to the point where we can control the logging. The logging will proceed
    unless we call `ignore` before the destructor is run. This simple change will
    let us build and test to make sure that we haven’t broken anything.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有实现过滤，但我们已经接近了。这个更改让我们达到了可以控制日志记录的点。除非在析构函数运行之前调用 `ignore`，否则日志记录将继续进行。这个简单的更改将使我们能够构建和测试，以确保我们没有破坏任何东西。
- en: Running the test application shows the same two test failures as before related
    to the filtering. The main thing is that the other tests continue to pass, which
    shows that the changes to use `stringstream` are working as before when we were
    streaming directly to the file stream.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试应用程序显示与过滤相关的相同两个测试失败。主要的事情是其他测试继续通过，这表明当我们直接将流直接写入文件流时，使用 `stringstream`
    的更改仍然像以前一样工作。
- en: It’s important when making pivotal changes such as switching streams to make
    sure that nothing breaks. This is why I made the change with a hardcoded choice
    to always log. We can use the TDD tests we already have to verify that the stream
    change works before making more changes to add filtering.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行诸如切换流等关键更改时，确保没有东西被破坏是很重要的。这就是为什么我选择了一个硬编码的选择，总是进行日志记录。我们可以使用我们已有的TDD测试来验证在添加过滤之前，流更改是否正常工作。
- en: 'Let’s take the next change to the `log` function in two parts. We’re going
    to need the full collection of active tags after figuring out which of the default
    tags have been overridden. Instead of sending the tags to the stream, we can first
    put them into an active collection, like this:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分两部分来看一下对 `log` 函数的下一个修改。在确定哪些默认标签被覆盖之后，我们需要收集完整的活动标签集合。我们不需要直接将标签发送到流中，而是可以先将其放入一个活动集合中，如下所示：
- en: '[PRE77]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This not only gets us the active collection, but it also seems simpler. We let
    the map handle the overrides by first putting all the default tags into the map
    and then putting all the provided tags into the map. Building and running the
    test application shows that the change hasn’t broken anything new. So, we’re ready
    for the next part, which is comparing the filtering clauses with the active tags.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这样不仅得到了活动集合，而且看起来也更简单。我们让映射首先处理覆盖，将所有默认标签放入映射中，然后将所有提供的标签放入映射中。构建和运行测试应用程序显示，这个修改并没有破坏任何新的东西。因此，我们准备进行下一部分，即比较过滤子句与活动标签。
- en: 'The filtering needs to change the last part of the `log` function where the
    comment indicates that filtering will go, like this:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤需要更改 `log` 函数的最后部分，其中注释表明过滤将在这里进行，如下所示：
- en: '[PRE78]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The logic is a little complicated, and this is a case where I found it easier
    to implement the logic almost completely instead of trying to break the change
    into multiple parts. Here’s what the code does. Because we are using DNF logic,
    we can treat each clause separately. We start out as if we will proceed with the
    log, just in case there are no filters set at all. If there are any filters, then
    for each one, we start out as if we will not proceed. But we also set a new `bool`
    variable that assumes that all the literals will match until proven otherwise.
    We’ll treat a clause without any literals as a sign that we should proceed with
    the log.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑有点复杂，这是一个我发现几乎完全实现逻辑比试图将更改分成多个部分更容易的案例。以下是代码做了什么。因为我们使用DNF逻辑，我们可以分别处理每个条款。我们开始时假设我们将继续记录日志，以防没有设置任何过滤器。如果有任何过滤器，那么对于每一个，我们开始时假设我们不会继续。但我们还设置了一个新的`bool`变量，它假设所有文字都将匹配，直到证明否则。我们将没有文字的条款视为我们应该继续记录日志的信号。
- en: 'For checking the literals, we have two types: normal and inverted. For the
    normal literals, the tags must all be present in the active tags and have matching
    values. If any tag is missing or has the wrong value, then we did not match all
    the literals for this clause. We’ll continue because there might be another clause
    that will match. This is what I mean about treating each clause separately.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 对于检查文字，我们有两种类型：正常和反转。对于正常文字，标签必须在活动标签中全部存在并且具有匹配的值。如果任何标签缺失或具有错误值，那么我们就没有匹配这个条款的所有文字。我们将继续，因为可能还有另一个条款会匹配。这就是我所说的分别处理每个条款的意思。
- en: Assuming we matched all the normal literals, we must still check the inverted
    literals. Here, the logic is reversed, and we need to make sure that either the
    tag is not present or that it has the wrong value.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经匹配了所有正常文字，我们仍然需要检查反转文字。在这里，逻辑被反转了，我们需要确保标签不存在或者它具有错误值。
- en: Once we’ve checked all the clauses or found a clause that matches all the literals,
    the code makes one last check to see if the log should proceed or not. If not,
    then we call `ignore`, which will stop the log message from being sent to the
    output log file.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们检查完所有条款或找到一个匹配所有文字的条款，代码将进行最后一次检查以确定日志是否应该继续。如果不应该，那么我们将调用`ignore`，这将阻止日志消息被发送到输出日志文件。
- en: This approach makes a decision about whether or not to proceed at the time that
    the `log` function is called based on the default tags and tags sent to the `log`
    function. We’ll let the calling code send whatever information is desired to the
    stream. The information will only make it all the way to the output log file if
    `ignore` was not called.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在调用`log`函数时根据默认标签和发送到`log`函数的标签决定是否继续。我们将让调用代码发送所需的所有信息到流中。如果未调用`ignore`，则信息才会完整地到达输出日志文件。
- en: 'Everything builds and runs now, and we get all tests passing again, like this:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都可以构建和运行了，我们再次通过了所有测试，如下所示：
- en: '[PRE79]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This shows that the filtering is working! At least, for the equality of the
    tags. Testing whether or not a tag is present with a matching value is a good
    start, but our microservices developer will need more power than this. Maybe we
    will need to log only if a count tag has a value greater than 100 or some other
    comparison that involves a numeric value greater or lesser than a specified filter
    value. This is what I meant when I said that I implemented the filtering logic
    *almost* completely. I got the logic and all the loops and breaks working for
    tag equality. We should be able to use the same basic structure of the code for
    relative comparisons in the next section.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明过滤功能正在工作！至少，对于标签的相等性。测试一个标签是否存在并且具有匹配的值是一个好的开始，但我们的微服务开发者将需要比这更多的能力。也许我们只需要在计数标签的值大于100或涉及比较指定过滤器值的数值更大或更小的其他比较时记录日志。这就是我说我几乎完全实现了过滤逻辑的意思。我得到了逻辑以及所有循环和中断，用于标签的相等性。我们应该能够在下一节中相对比较中使用相同的基本代码结构。
- en: There’s one more thing to add before we start relative comparisons, and this
    is important. Whenever code is added like what I did with the DNF logic without
    a test to back it up, we need to add a test. Otherwise, a missed test has a way
    of getting pushed back until it’s forgotten about completely.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始相对比较之前，还有一件事要补充，这是很重要的。每当添加代码，就像我添加DNF逻辑那样，没有测试来支持它，我们需要添加一个测试。否则，遗漏的测试可能会被推迟，直到完全忘记。
- en: And this new test helped out in another way. It caught a problem with the initial
    definition of the `addFilterLiteral` function. The original function defined a
    `bool` parameter called `invert` that had a default value of `false`. The default
    value meant that creating a normal literal could leave out the parameter and use
    the default. But to create an inverted literal, the function required that the
    `true` value be passed. This seemed backward to me. I realized that it would make
    more sense to pass `false` for this parameter to get an inverted literal, and
    that `true` should create a normal literal. So, I went back and changed the function
    definition and implementation. The test caught a problem with the usage of a function
    that went unnoticed at first.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新测试以另一种方式提供了帮助。它捕捉到了`addFilterLiteral`函数初始定义中的一个问题。原始函数定义了一个名为`invert`的`bool`参数，其默认值为`false`。默认值意味着创建一个普通字面量时可以省略该参数并使用默认值。但为了创建一个倒置字面量，该函数要求传递`true`值。这在我看来似乎是反过来的。我意识到，传递`false`给这个参数以获取倒置字面量，而`true`应该创建一个普通字面量，这样会更有意义。因此，我回过头去修改了函数的定义和实现。测试捕捉到了一个最初未被注意到的函数使用问题。
- en: 'Here is the new test that will create an inverted filter:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是创建倒置过滤器的新测试：
- en: '[PRE80]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Building and running shows that the new test passes, and we have confirmed that
    we can filter log messages that contain a matching tag when the filter is inverted.
    This test uses the default `green` tag that is added to log messages and makes
    sure that the log message does not appear in the output log file because of the
    presence of the `green` tag.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行显示新测试通过，并且我们已经确认可以过滤包含匹配标签的日志消息，当过滤器被倒置时。这个测试使用了默认的`green`标签，该标签被添加到日志消息中，并确保由于存在`green`标签，日志消息不会出现在输出日志文件中。
- en: The next section will enhance the filtering to allow filtering based on relative
    values of tags instead of just exact matches.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将增强过滤功能，允许根据标签的相对值而不是仅基于精确匹配进行过滤。
- en: Enhancing filtering for relative matches
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加强相对匹配的过滤
- en: TDD encourages incremental changes and enhancements when designing software.
    Write a test, get something working, and then write a more elaborate test that
    enhances the design. We’ve been following a TDD approach to designing the logging
    library, and the previous section was a great example. We got filtering working
    in the previous section, but only for tag equality.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: TDD鼓励在设计软件时进行增量更改和增强。编写一个测试，让某物工作，然后编写一个更详细的测试来增强设计。我们一直在遵循TDD方法来设计日志库，上一节就是一个很好的例子。我们在上一节中实现了过滤功能，但仅限于标签相等。
- en: In other words, we can now filter log messages based on the presence or absence
    of a tag that matches a filter literal tag. We compare the tags to see if both
    the key and value match. That was a great first step because even getting that
    far required a lot of work. Imagine if we had tried to go all the way and supported,
    for example, logging only if a count tag had a value greater than 100.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们现在可以根据标签是否存在来过滤日志消息，这些标签与过滤字面量标签匹配。我们比较标签以查看键和值是否匹配。这是一个很好的第一步，因为即使达到这一步也需要大量的工作。想象一下，如果我们试图做到极致，并支持例如，只有当计数标签的值大于100时才进行日志记录。
- en: When designing software using TDD, it really helps to look for obvious steps
    that can be taken and confirmed to work before taking the next step. Some steps
    might be bigger than others, and that’s okay as long as you don’t go straight
    to the final implementation because that will only lead to longer development
    times and more frustration. It’s so much better to confirm some parts of the design
    work as expected and have tests to make sure those parts continue to work. It’s
    like building a house with a solid foundation. It’s much better to make sure that
    the foundation really is solid before building the walls, and you want to have
    tests to make sure that the walls stay straight while the roof is being added.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用TDD（测试驱动开发）设计软件时，在采取下一步之前寻找显而易见的步骤并确认其工作情况非常有帮助。有些步骤可能比其他步骤大，但这没关系，只要你不直接跳到最终实现，因为那样只会导致更长的开发时间和更多的挫败感。确认设计的一些部分按预期工作并拥有确保这些部分继续工作的测试要好的多。这就像建造一座房子，有一个坚实的基础。在建造墙壁之前，确保基础确实牢固要好的多，你希望有测试来确保在添加屋顶时墙壁保持笔直。
- en: We have working tests in place to make sure that basic filtering works. We are
    testing both normal and inverted literals. We check for matching tags by comparing
    the text of the tags, which works for all value types. For relative filters such
    as a count greater than 100, we’re going to need a solution that knows how to
    compare the values with a numeric check instead of a string match.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实施了工作测试以确保基本过滤功能正常。我们正在测试正常和倒置的文本。我们通过比较标签的文本来检查匹配的标签，这对于所有值类型都适用。对于像计数大于100这样的相对过滤器，我们需要一个能够用数值检查而不是字符串匹配来比较值的解决方案。
- en: 'We can start by figuring out how to represent a filter literal to check for
    greater or lesser numeric values. Here is a test that can go in `Tags.cpp` that
    sets a filter based on a count greater than 100:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先找出如何表示一个过滤器文本来检查大于或小于的数值。以下是一个可以放入`Tags.cpp`的测试，它基于计数大于100设置一个过滤器：
- en: '[PRE81]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'What’s new with this test? The main part is the way the `Count` tag is created.
    We previously only added a value when creating tags, like this:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试有什么新内容？主要部分是`Count`标签的创建方式。我们之前在创建标签时只添加了一个值，如下所示：
- en: '[PRE82]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: And because we now need a way to specify if something should have a relative
    value, we need a place to say what kind of relative value and a method to communicate
    which relative value to use. I think an enumeration of various relative comparisons
    should work. We probably don’t need more advanced relative comparisons such as
    `"between"` because we can always use DNF to express more elaborate comparisons.
    For a brief overview of how we’re using DNF, refer to the *Designing tests to
    filter log messages* section of this chapter.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在需要一种指定是否应该具有相对值的方法，我们需要一个地方来说明相对值的类型以及一个方法来传达要使用的相对值。我认为各种相对比较的枚举应该可以工作。我们可能不需要更高级的相对比较，如“between”，因为我们总是可以使用DNF来表示更复杂的比较。有关我们如何使用DNF的简要概述，请参阅本章的*设计测试以过滤日志消息*部分。
- en: 'At the tag level, all we really need is to know how to compare one value against
    another. So, it makes sense to specify what type of comparison is needed when
    constructing a tag, like this:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在标签级别，我们真正需要知道的是如何比较一个值与另一个值。因此，在构建标签时指定所需的比较类型是有意义的，如下所示：
- en: '[PRE83]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: It might make sense to treat a tag with a comparison operator such as `GreaterThan`
    as a completely different type, but I think we can get away with a single type.
    With this solution, any tag can have a comparison operator, but it only makes
    sense to specify comparison operators for tags that will be used in filters.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 将具有比较运算符（如`GreaterThan`）的标签视为完全不同的类型可能是有意义的，但我认为我们可以通过单一类型来解决这个问题。在这个解决方案中，任何标签都可以有比较运算符，但只有当标签将用于过滤器时，指定比较运算符才有意义。
- en: What happens if a regular tag without a comparison operator is used in a filter?
    Then, we should treat that as an exact match because that’s what the existing
    tests expect.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在过滤器中使用不带比较运算符的常规标签会发生什么？那么，我们应该将其视为精确匹配，因为这是现有测试所期望的。
- en: Back to the new test. It first creates a filter that should only let a message
    be logged if it has a count tag with a value greater than 100\. It first tries
    to log a message with a count of only 1, and this is verified to not exist in
    the log file.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 回到新的测试。它首先创建了一个过滤器，该过滤器只允许具有计数标签且其值大于100的消息被记录。它首先尝试记录一个计数为1的消息，并验证该消息不存在于日志文件中。
- en: Then, the test creates a count of 101 but does not use the count tag directly
    in the `log` function call. This also should not make it to the output log file
    because we only want to filter on tags that are either default or directly specified
    when calling `log`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试创建了一个计数为101的计数器，但并没有在`log`函数调用中直接使用计数标签。这也应该不会出现在输出日志文件中，因为我们只想在调用`log`时过滤默认或直接指定的标签。
- en: And finally, the test calls `log` with a count tag of 101, and this message
    is verified to appear in the log file.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，测试使用计数标签101调用`log`，并验证该消息是否出现在日志文件中。
- en: 'Now that we have a test, how will we get it working? Let’s define comparison
    operations first in `Log.h`, right before the `TagType` class, like this:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了测试，我们将如何让它工作？让我们首先在`Log.h`中定义比较操作，在`TagType`类之前，如下所示：
- en: '[PRE84]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We’ll use the `None` operation for regular tags that only want to express a
    value. The `Equal` operation will act like the existing equality checks between
    tags. And the real change is to support less than, less than or equal, greater
    than, and greater than or equal comparisons.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`None`操作来表示只想表达值的常规标签。`Equal`操作将像标签之间的现有相等检查一样起作用。真正的变化是支持小于、小于等于、大于和大于等于的比较。
- en: 'We need to compare one tag with another without worrying about what the tags
    represent. A good way to do this is to declare a pure virtual method in the `Tag`
    class, just like what we did for cloning. The new method is called `match` and
    can go right after the `clone` method, like this:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要比较一个标签与另一个标签，而不必担心标签代表什么。一个好的方法是在`Tag`类中声明一个纯虚拟方法，就像我们为克隆所做的那样。新方法被称为`match`，可以紧接在`clone`方法之后，如下所示：
- en: '[PRE85]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here’s where things get a bit difficult. I had wanted to wrap everything up
    in the `TagType` class. The idea was to first check the key of each tag being
    compared and make sure that the tags were the same. If they have the same key,
    then check the value. If they don’t have the same key, then they must not match.
    At least, that was a good plan. I ran into problems when trying to implement the
    `match` method in one place that could compare strings with strings, numerics
    with numerics, and Booleans with Booleans. A tag such as `CacheHit` has a `bool`
    value type, and the only operation that makes sense is `Equal` comparisons. Tags
    based on strings need to compare differently than numerics. And if we really want
    to get elaborate, doubles should compare differently than an `int` type.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这里事情变得有些困难。我原本想将所有内容都封装在`TagType`类中。想法是首先检查每个被比较的标签的键，并确保标签是相同的。如果它们有相同的键，那么检查值。如果它们没有相同的键，那么它们肯定不匹配。至少，这是一个不错的计划。当我尝试在一个可以比较字符串与字符串、数字与数字以及布尔值与布尔值的地方实现`match`方法时遇到了问题。例如，像`CacheHit`这样的标签有一个`bool`类型的值，唯一有意义的操作是`Equal`比较。基于字符串的标签需要与数字进行比较。如果我们真的想做得更细致，双精度浮点数应该与`int`类型进行比较不同。
- en: 'Each derived tag type could know how to compare, but I didn’t want to change
    the derived types and make them each implement the `match` method, especially
    after all the work we went through to avoid the derived types implementing `clone`.
    The best solution I came up with was to create an additional set of intermediate
    classes that derive from `TagType`. Each new class is based on the type of the
    value. Since we only support five different tag value types, this is not a bad
    solution. The main benefit is that the derived tag types that the caller will
    use are only slightly affected. Here’s a new `StringTagType` class that inherits
    from `TagType` so that you can see what I mean. Place this new class in `Log.h`,
    right after the `TagType` class:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 每个派生标签类型都可以知道如何比较，但我不想改变派生类型并让它们各自实现`match`方法，尤其是在我们费了很大力气避免派生类型实现`clone`之后。我想出的最佳解决方案是创建一组额外的中间类，这些类从`TagType`派生。每个新类基于值的类型。由于我们只支持五种不同的标签值类型，这不是一个坏解决方案。主要好处是调用者将使用的派生标签类型仅略有影响。这里有一个新的`StringTagType`类，它从`TagType`继承，以便你可以看到我的意思。将这个新类放在`Log.h`中，紧接在`TagType`类之后：
- en: '[PRE86]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This class is all about comparing string-based tags with other string-based
    tags. The class implements a new virtual method I’ll explain in just a moment,
    called `compareTagTypes`. The only thing this method has to worry about is how
    to compare two strings based on an operation. One of the strings is called `value`
    and the other is called `criteria`. It’s important to not mix up the `value` and
    `criteria` strings because, for example, while `"ABC"` is greater than `"AAA"`,
    the same is not true the other way around. The method uses the `compare` method
    in the `std::string` class to do the comparisons.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类完全是关于比较基于字符串的标签与其他基于字符串的标签。该类实现了一个新虚拟方法，我将在稍后解释，称为`compareTagTypes`。这个方法唯一需要担心的是如何根据操作比较两个字符串。其中一个字符串被称为`value`，另一个被称为`criteria`。重要的是不要混淆`value`和`criteria`字符串，因为例如，虽然`"ABC"`大于`"AAA"`，但反过来并不成立。该方法使用`std::string`类中的`compare`方法来进行比较。
- en: You can see that the `StringTagType` class inherits from `TagType` and passes
    on the `T` derived type while hardcoding `std::string` for the value type. One
    interesting thing about the constructor is the need to repeat the template parameters
    when constructing `TagType` in the constructor initialization list. Normally,
    this should not be required, but maybe there is some arcane rule that only applies
    here that I’m not aware of whereby the compiler does not look at the `TagType`
    parameters in the parent class list to figure out the template parameters.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`StringTagType`类从`TagType`继承，并传递派生类型`T`，同时为值类型硬编码`std::string`。关于构造函数的一个有趣之处在于，在构造函数初始化列表中构造`TagType`时需要重复模板参数。通常情况下，这不应该需要，但也许有一些我尚未意识到的神秘规则仅适用于此处，即编译器不会查看父类列表中的`TagType`参数来找出模板参数。
- en: 'Before moving on to the changes in `TagType`, let’s look at how a derived tag
    class such as `LogLevel` will use the new `StringTagType` intermediate class.
    Change the `LogLevel` class to look like this:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续到`TagType`的更改之前，让我们看看派生标签类如`LogLevel`将如何使用新的`StringTagType`中间类。将`LogLevel`类修改如下：
- en: '[PRE87]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The only change needed for `LogLevel` is to change the parent class from `TagType`
    to the more specific `StringTagType`. We no longer need to worry about specifying
    `std::string` as a template parameter because that information is built into the
    `StringTagType` class. I had wanted to keep the derived tag classes completely
    unchanged, but this slight modification is not so bad because there is no need
    to write any comparison code.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`LogLevel`所需的唯一更改是将父类从`TagType`更改为更具体的`StringTagType`。我们不再需要担心指定`std::string`作为模板参数，因为该信息已内置到`StringTagType`类中。我原本想保持派生标签类完全不变，但这种轻微的修改并不糟糕，因为不需要编写任何比较代码。
- en: 'There is more work to be done in the `TagType` class. In the protected section
    at the end of the `TagType` class, make these changes:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TagType`类中还有更多工作要做。在`TagType`类末尾的保护部分，进行以下更改：
- en: '[PRE88]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The protected constructor needs to store the operation, and this is where the
    virtual `compareTagTypes` method is declared and given a default implementation
    that returns `false`. The `TagType` class also implements the `match` method that
    was declared in the `Tag` class, like this:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的构造函数需要存储操作，这就是声明虚拟`compareTagTypes`方法并为其提供一个默认实现（返回`false`）的地方。`TagType`类还实现了在`Tag`类中声明的`match`方法，如下所示：
- en: '[PRE89]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The `match` method first checks the keys to see whether the two tags being compared
    have the same key. If the keys match, then the types are assumed to be the same
    and the other tag is cast to the same `TagType`.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`match`方法首先检查键，看看被比较的两个标签是否具有相同的键。如果键匹配，则假设类型相同，并将另一个标签转换为相同的`TagType`。'
- en: We have a couple of scenarios to figure out. At least one of the tags should
    be a normal tag without an operation and is the tag we’ll call the value. The
    other tag can also be a regular tag without an operation, in which case all we
    need to do is compare the two values for equality.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几个场景需要确定。至少有一个标签应该是一个没有操作的正常标签，我们将称之为值。另一个标签也可以是一个没有操作的常规标签，在这种情况下，我们只需要比较两个值是否相等。
- en: If one of the two tags is normal and the other has a comparison operation other
    than `None`, then the tag with the comparison operator set is treated as the criteria.
    Remember that it’s important to know which is the value and which is the criteria.
    The code needs to handle the case where we are comparing a value with a criterion
    or the case where we are comparing a criterion with a value. We call into the
    virtual `compareTagTypes` method to do the actual comparison, making sure to pass
    `mValue` and `otherCast.mValue` according to which is the normal tag and which
    is the criteria.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个标签中有一个是正常的，而另一个有除了`None`之外的比较操作，那么设置了比较运算符的标签被视为标准。记住，知道哪个是值，哪个是标准是很重要的。代码需要处理比较值与标准或比较标准与值的情况。我们调用虚拟的`compareTagTypes`方法来进行实际比较，确保根据哪个是正常标签和哪个是标准，传递`mValue`和`otherCast.mValue`。
- en: And finally, if both tags have the comparison operator set to something other
    than `None`, then we treat the match as `false` because it doesn’t make sense
    to compare two criteria tags against each other.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果两个标签的比较运算符都设置为除`None`之外的内容，那么我们将匹配视为`false`，因为比较两个标准标签之间没有意义。
- en: There’s a bit of complexity wrapped up in the `match` method that I wanted to
    implement in only one spot. This is why I decided to keep the `TagType` class
    and create value type-specific intermediate classes such as `StringTagType`. The
    `TagType` class implements part of the comparison by figuring out what is being
    compared with what and then relies on the type-specific classes to do the actual
    comparison.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `match` 方法中，我想要实现的部分有点复杂性，这个方法只在一个地方实现。这就是为什么我决定保留 `TagType` 类并创建特定于值类型的中间类，如
    `StringTagType`。`TagType` 类通过确定正在比较什么以及什么与什么进行比较来实现部分比较，然后依赖于特定类型的类来完成实际的比较。
- en: 'We need to add other type-specific intermediate tag classes. All of these go
    in `Log.h`, right after the `StringTagType` class. Here is the one for the `int`
    type:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加其他特定类型的中间标签类。所有这些都在 `Log.h` 文件中，紧接在 `StringTagType` 类之后。以下是 `int` 类型的示例：
- en: '[PRE90]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This class is almost identical to the `StringTagType` class with changes designed
    for an `int` type instead of a string. Mainly, the comparisons can be done with
    simple arithmetic operators instead of calling the string `compare` method.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类几乎与 `StringTagType` 类相同，只是针对 `int` 类型进行了更改，而不是字符串。主要区别在于比较可以使用简单的算术运算符来完成，而不是调用字符串的
    `compare` 方法。
- en: 'I thought about using this class for all the `int`, `long long`, and `double`
    arithmetic types, but that would have meant it would still need a template parameter
    for the actual type. Then, the question becomes one of consistency. Should the
    `StringTagType` class also have a template parameter to specify the type of string?
    Maybe. There are different kinds of strings so that almost makes sense. But what
    about the `bool` type? We’ll need an intermediate class for Booleans too, and
    it seems strange to specify a `bool` template type when the class name will already
    have `bool` in it. So, to make everything consistent, I decided to go with separate
    intermediate classes for all the supported types. We’ll handle ints with the `IntTagType`
    class and create another class called `LongLongTagType`, like this:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我考虑过将这个类用于所有的 `int`、`long long` 和 `double` 算术类型，但这意味着它仍然需要一个模板参数来指定实际类型。那么，问题就变成了一致性。`StringTagType`
    类也应该有一个模板参数来指定字符串的类型吗？也许吧。因为存在不同类型的字符串，所以这几乎是有道理的。但关于 `bool` 类型怎么办？我们还需要一个中间类来处理布尔值，当类名中已经包含
    `bool` 时，指定一个 `bool` 模板类型似乎很奇怪。因此，为了保持一切的一致性，我决定为所有支持的类型使用单独的中间类。我们将使用 `IntTagType`
    类来处理整数，并创建另一个名为 `LongLongTagType` 的类，如下所示：
- en: '[PRE91]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This is the class I am not very happy about because it duplicates exactly the
    implementation for ints. But the one thing I am happy about is the consistency
    it creates. It means that all the intermediate tag-type classes can be used the
    same way.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这个类不是很满意，因为它与整数的实现完全相同。但让我高兴的是它创造了一致性。这意味着所有中间的标签类型类都可以以相同的方式使用。
- en: 'The next class is for doubles, and while it also has the same implementation,
    there is the potential to compare doubles differently because they don’t compare
    like the integral types. There is always a little room for errors and slight discrepancies
    between floating-point values. For now, we’re not going to do anything different
    about doubles, but this class will give us the ability to compare them differently
    if needed. The class looks like this:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个类是用于 `double` 的，尽管它也有相同的实现，但由于它们不像整型那样比较，所以有潜力以不同的方式比较双精度浮点数。在浮点值之间总是存在一点误差和细微的差异。目前，我们不会对双精度浮点数做任何不同的事情，但这个类将使我们能够在需要时以不同的方式比较它们。这个类的样子如下：
- en: '[PRE92]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The last intermediate tag type class is for Booleans, and it does need to do
    something different. This class is really only interested in equality and looks
    like this:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个中间标签类型类是用于布尔值的，它确实需要做一些不同的事情。这个类实际上只对相等性感兴趣，其样子如下：
- en: '[PRE93]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now that we have all the tags worked out, the place where comparison needs
    to be made is in the `log` function, which currently uses the text of the tags
    to compare the normal and inverted tags. Change the `normal` block to look like
    this:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了所有标签的问题，需要进行比较的地方是在 `log` 函数中，该函数目前使用标签的文本来比较正常和反转的标签。将 `normal` 块更改为如下所示：
- en: '[PRE94]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The code still loops through the tags and checks for the existence of the keys
    involved. Once it finds that the tags exist and need to be compared, instead of
    getting the text of each tag and comparing for equality, the code now calls the
    `match` method.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 代码仍然遍历标签并检查涉及的键是否存在。一旦发现标签存在并且需要比较，代码现在将调用 `match` 方法，而不是获取每个标签的文本并比较它们是否相等。
- en: 'The inverted block needs to change in a similar manner, like this:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 反转块需要以类似的方式进行更改，如下所示：
- en: '[PRE95]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: For the inverted loop, I was able to simplify the code a little. The real change
    is similar to the normal loop where the `match` method is called to make the comparison
    instead of directly comparing the tag text.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 对于反转循环，我能够稍微简化一下代码。真正的变化与正常循环类似，其中调用`match`方法进行比较，而不是直接比较标签文本。
- en: 'Before we can build and try out the new test, we need to update the other derived
    tag types in the test application. Just like how we needed to update the `LogLevel`
    tag class to use the new intermediate tag class, we need to change all the tag
    classes in `LogTags.h`. The first is the `Color` class, like this:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够构建和尝试新的测试之前，我们需要更新测试应用中其他派生标签类型。就像我们需要更新`LogLevel`标签类以使用新的中间标签类一样，我们需要更改`LogTags.h`中的所有标签类。首先是`Color`类，如下所示：
- en: '[PRE96]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The `Color` class is based on a string value type, just like `LogLevel`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`Color`类基于字符串值类型，就像`LogLevel`。'
- en: 'The `Size` tag type also uses a string and looks like this now:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`Size`标签类型也使用字符串，现在看起来像这样：'
- en: '[PRE97]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The `Count` and `Identity` tag types are based on an `int` type and a `long
    long` type respectively, and they look like this:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`Count`和`Identity`标签类型分别基于`int`类型和`long long`类型，它们看起来像这样：'
- en: '[PRE98]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'And finally, the `Scale` and `CacheHit` tag types are based on a `double` type
    and a `bool` type, and look like this:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Scale`和`CacheHit`标签类型分别基于`double`类型和`bool`类型，它们看起来像这样：
- en: '[PRE99]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The changes to each tag type were minimal. I think this is acceptable, especially
    because the tests that use the tag types don’t need to change. Let’s take another
    look at the test that started this section:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 每个标签类型的更改都很小。我认为这是可以接受的，尤其是因为使用标签类型的测试不需要更改。让我们再次看看开始这个部分的测试：
- en: '[PRE100]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This test should make more sense now. It creates a `Count` tag with a value
    of `100` and a `TagOperation` tag of `GreaterThan`. The operation is what makes
    this tag into a criteria tag that can be compared with other instances of the
    `Count` tag to see if the count in the other instance is really greater than 100
    or not.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试现在应该更有意义。它创建了一个值为`100`的`Count`标签和一个`TagOperation`标签为`GreaterThan`。操作使得这个标签成为了一个可以与其他`Count`标签实例进行比较的准则标签，以查看其他实例中的计数是否真的大于100。
- en: Then, the test tries to log with a normal `Count` tag with a value of `1`. We
    know now how this will fail the match, and the log message will be ignored.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，测试尝试使用具有值为`1`的正常`Count`标签进行日志记录。我们现在知道这将如何失败匹配，并且日志消息将被忽略。
- en: The test then tries to log with a `Count` tag of `101`, but this time, the tag
    is outside of the `log` function and will not be considered. The second log message
    will also be ignored without ever trying to call `match`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 测试随后尝试使用`101`的`Count`标签进行日志记录，但这次标签位于`log`函数外部，将不会被考虑。第二个日志消息也将被忽略，而不会尝试调用`match`。
- en: The test then tries to log with a count of `101` inside the `log` function.
    This one should match because 101 is indeed greater than 100, and the message
    should appear in the output log file.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 测试随后尝试在`log`函数内部使用`101`个计数进行日志记录。这个应该匹配，因为101确实大于100，并且消息应该出现在输出日志文件中。
- en: Notice how the test is structured. It starts out with a couple of known scenarios
    that should not succeed before finally moving on to a scenario that should succeed.
    This is a good pattern for you to follow when writing your tests and helps to
    confirm that everything is working as designed.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 注意测试的结构。它从几个已知场景开始，这些场景不应该成功，最终过渡到一个应该成功的场景。当你编写测试时，这是一个很好的模式，有助于确认一切按设计工作。
- en: The filtering is now working completely even with relative comparisons! The
    rest of this chapter will provide insights and advice to help you design better
    tests.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 现在过滤功能即使在相对比较的情况下也能完全工作！本章的其余部分将提供见解和建议，以帮助您设计更好的测试。
- en: When is testing too much?
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时测试过多？
- en: I remember a story I heard once about a child that was in a hospital in intensive
    care and was connected to all the monitoring machines, including one that watched
    the heartbeat electrical signals. The child’s condition took a sudden turn for
    the worse and showed all the signs of a lack of blood flow to the brain. The doctors
    couldn’t figure out why because the heart was beating, and they were about to
    send the child for a scan to look for a blood clot that would cause a stroke when
    one doctor thought to listen for a heartbeat. There was none. The machine showed
    that the heart was beating but there was no sound to confirm the beat. The doctors
    were able to determine that swelling around the heart was putting pressure on
    the heart and preventing it from beating. I don’t know how, but they reduced the
    swelling and the child’s heart started pumping again.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得曾经听到过一个关于一个孩子在重症监护室的故事，他连接着所有的监测机器，包括一个监测心跳电信号的机器。孩子的状况突然恶化，显示出大脑血流不足的所有迹象。医生们无法理解为什么会这样，因为心跳还在，他们正准备将孩子送去扫描以寻找可能导致中风的血凝块，这时一位医生想到要听一下心跳。没有声音。机器显示心跳还在，但没有声音来确认心跳。医生们能够确定心脏周围的水肿正在对心脏施加压力，阻止它跳动。我不知道他们是怎么做到的，但他们减少了肿胀，孩子的心脏又开始泵血了。
- en: Why does this story come to mind? Because the machine that monitored heart activity
    was looking for electrical signals. In normal circumstances, the presence of proper
    electrical signals is a great way to monitor heart activity. But it’s indirect.
    Electrical signals are *how* the heart beats. The signals cause the heart to beat,
    but as the story shows, they don’t always mean *that* the heart is beating.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这个故事会浮现在脑海中？因为监测心脏活动的机器正在寻找电信号。在正常情况下，适当的电信号是监测心脏活动的好方法。但它是不直接的。电信号是心脏跳动的*方式*。信号导致心脏跳动，但正如故事所示，它们并不总是意味着*心脏真的在跳动*。
- en: It’s easy to fall into the same trap with software testing. We think that because
    we have a lot of tests, the software must be well-tested. But are the tests really
    testing the right things? In other words, is each test looking for tangible results?
    Or are some tests instead looking at how the results would normally be obtained?
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易在软件测试中陷入同样的陷阱。我们以为因为我们有很多测试，所以软件一定经过了很好的测试。但测试真的测试了正确的事情吗？换句话说，每个测试都在寻找有形的结果吗？或者有些测试只是在看结果通常是如何获得的？
- en: When is testing too much? My answer is that testing is good, and every test
    that you can add will normally help to improve the quality of the software. Testing
    can become too much if it starts looking at the wrong things.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 何时测试过多？我的答案是测试是好的，你添加的每个测试通常都会帮助提高软件的质量。如果测试开始关注错误的事情，它就会变得过多。
- en: It’s not that a test that is looking at the wrong thing is bad. The bad part
    comes when we rely on that test to predict some outcome. It’s much better to directly
    confirm the desired outcome than it is to confirm some internal step along the
    way.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 并非一个关注错误事情的测试是坏的。坏的部分在于我们依赖于这个测试来预测某些结果。直接确认期望的结果比确认过程中的某个内部步骤要好得多。
- en: 'For example, have a look at a recent test that added a `filter` literal:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看最近添加了一个`filter`字面量的测试：
- en: '[PRE101]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We could have verified that a filter was indeed added to the collection. We
    have access to call the `getFilterClauses` function from within the test and examine
    each clause and look for the literal just added. We could even confirm that the
    literal itself behaves as expected and has the value `100` assigned to the literal.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以验证过滤器确实被添加到了收集中。我们可以在测试中调用`getFilterClauses`函数，检查每个子句，寻找刚刚添加的字面量。我们甚至可以确认这个字面量本身的行为符合预期，并且将值`100`分配给了这个字面量。
- en: The test doesn’t do this. Why? Because that is how filters work. Looking for
    a filter in the collection would be like watching heartbeat electrical signals.
    The ability to call `getFilterClauses` is a detail that exists just because of
    our desire to keep the logging library contained in a single header file. The
    function is not intended to be called by customers. The test instead looks at
    the results of setting the filter.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 测试并不这样做。为什么？因为这就是过滤器的工作方式。在收集过程中寻找过滤器就像观察心跳电信号一样。能够调用`getFilterClauses`的能力仅仅是因为我们希望将日志库包含在一个单独的头文件中。这个函数并不是打算由客户调用的。测试反而检查设置过滤器的结果。
- en: Once the filter is set, the test tries to log a few messages and makes sure
    that the results match the expectations.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好过滤器，测试就会尝试记录一些消息，并确保结果符合预期。
- en: What if the logging library needed some type of custom collection? Would it
    make sense to test that the filter literal was properly added to the collection
    then? Again, my answer is no, at least not here in the filter test.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 如果日志库需要某种自定义集合，那么测试过滤字面量是否正确添加到集合中是否有意义呢？我的回答是，不，至少在这里的过滤测试中不是这样。
- en: If the project needed a custom collection, then it would need tests to make
    sure that the collection works. I’m not saying to skip the tests for any code
    that needs to be written just because that code serves a supporting role within
    a project. What I am saying is to keep the tests focused on what they are testing.
    What is the desired outcome that the test is looking to confirm? In the case of
    the filters test, the desired outcome is that some log messages will be ignored
    while others will appear in the output log file. The test directly sets up the
    conditions needed to confirm the outcome, causes the needed steps to be run, and
    confirms the outcome. Along the way, the collection and all the matching code
    will be tested too in an indirect manner.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目需要自定义集合，那么它需要测试以确保集合能够正常工作。我并不是说因为代码在项目中的支持角色而跳过任何需要编写的代码的测试。我想要表达的是，要使测试集中在它们要测试的内容上。测试试图确认的期望结果是什么？在过滤测试的情况下，期望的结果是某些日志消息将被忽略，而其他消息将出现在输出日志文件中。测试直接设置确认结果所需的条件，执行必要的步骤，并确认结果。在这个过程中，集合和所有匹配的代码也将以间接方式得到测试。
- en: If we have a custom collection involved, then indirect testing is not enough.
    But direct testing inside the filter test is also not appropriate. What we need
    is a set of tests designed to directly test the custom collection itself.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 如果涉及到自定义集合，那么间接测试是不够的。但在过滤器测试中进行直接测试也是不合适的。我们需要的是一组设计用来直接测试自定义集合本身的测试。
- en: So, if we have a need for a supporting component such as a custom collection,
    then that component needs to be tested by itself. The tests can be included in
    the same overall test application. Maybe put them into their own test suite. Think
    about the code that will be using the component as a customer of the component
    and think about the customer’s needs.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们需要像自定义集合这样的支持组件，那么这个组件需要单独进行测试。这些测试可以包含在同一个整体测试应用程序中。也许可以将它们放入自己的测试套件中。考虑一下将作为组件客户的代码，并考虑客户的需求。
- en: If the component is big enough or serves a more general purpose so that it might
    be useful outside of the project, then giving it a project on its own is a good
    idea. This is what we’re doing in this book by treating the unit test library
    and the logging library as separate projects.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件足够大或具有更通用的用途，以至于它可能在项目之外也有用，那么给它一个单独的项目是一个好主意。这就是我们在本书中将单元测试库和日志库视为独立项目所做的事情。
- en: One final thought about when testing is too much will help you to identify when
    you are in this situation because it can be easy to slide into too much indirect
    testing. If you find that you need to change a lot of tests after refactoring
    how your software works, then you could be testing too much.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 关于过度测试的最后一想法将帮助您识别何时处于这种情况，因为很容易滑入过度间接测试。如果您发现重构软件工作方式后需要更改大量测试，那么您可能测试得太多了。
- en: Think about how this chapter added filters and was able to keep the existing
    tests almost entirely unchanged. Sure—we had to change the code underneath by
    adding a whole set of intermediate tag-type classes, but we did not have to rewrite
    the existing tests.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下这一章是如何添加过滤器并能够几乎完全不变地保留现有测试的。当然——我们不得不通过添加一系列中间标签类型类来更改底层的代码，但我们不需要重写现有的测试。
- en: If a refactor causes the tests to also need a lot of work, then either you are
    testing too much or the problem could be that you are changing the desired usage
    of the software. Be careful of changing how you want your design to be used, because
    if you are following TDD, then that initial usage is one of the first things you
    want to get right. Once you have the software designed in a way that makes it
    easy and intuitive to use, then be extra cautious about any refactoring that would
    cause changes to the test.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重构导致测试也需要大量工作，那么要么是你测试得太多，要么可能是问题在于你正在改变软件的预期使用方式。注意改变你希望设计如何被使用的方式，因为如果你遵循TDD，那么最初的使用方式是你想要首先做对的事情之一。一旦你以使软件易于使用和直观的方式设计了软件，那么在重构可能改变测试的情况下要格外小心。
- en: The next section explains a topic related to this section. Once you know what
    needs to be tested, a question that often comes up next is how to design software
    to make it easy to be tested, and specifically, if the tests need to reach inside
    the inner workings of the components being tested.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分解释了与这一部分相关的一个主题。一旦你知道需要测试什么，接下来经常出现的问题是如何设计软件使其易于测试，特别是测试是否需要深入到被测试组件的内部工作原理。
- en: How intrusive should tests be?
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试应该有多侵入性？
- en: There is a benefit to designing software that is easy to test. To me, this starts
    by following TDD and writing tests first that make use of the software as the
    customer would most expect it to be used. This is the most important consideration.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 设计易于测试的软件是有好处的。对我来说，这始于遵循TDD（测试驱动开发）并首先编写测试，这些测试利用软件以客户最期望的方式使用。这是最重要的考虑因素。
- en: You don’t want to make the user of your software question why extra steps are
    needed or why it is difficult to understand how to use your software. And by customer
    or user, I mean anybody that will use your software. A customer or user could
    be another software developer who needs to use a library that is being designed.
    The tests are a great example of what a user must go through. If there is an extra
    step that a user must take that provides no value to the user, then that step
    should be removed, even if the step makes it easier to test the code.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望你的软件用户质疑为什么需要额外的步骤，或者为什么难以理解如何使用你的软件。在这里，客户或用户指的是任何将使用你的软件的人。客户或用户可能是一个需要使用正在设计的库的软件开发者。测试是用户必须经历的很好的例子。如果用户必须采取的额外步骤对用户没有任何价值，那么应该移除这个步骤，即使这个步骤使得测试代码更容易进行。
- en: Maybe the extra step can be hidden from the user, and if so, then it might make
    sense to keep it as long as it makes the testing better. Anytime a test relies
    on something extra that the user doesn’t need or know about, then the test is
    intruding on the software design.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的步骤可能可以隐藏起来，如果可以的话，那么只要它使测试变得更好，就有可能保留它。任何时候测试依赖于用户不需要或不知道的额外内容，那么测试就是在侵犯软件设计。
- en: 'I’m not saying this is a bad thing. Intrusion often has a negative meaning.
    It can be good for a test to be able to reach inside a component as long as you
    are aware that this makes it easy to fall into the trap that the previous section
    describes: too much testing.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是说这是坏事。侵入通常有负面含义。只要你知道这会使你容易陷入前述章节描述的陷阱：过度测试，测试能够深入到组件内部对测试来说可能是好事。
- en: The main thing to understand is that anything that a test uses should become
    part of a supported interface. If a component exposes an inner working so that
    it can be confirmed by a test, then this inner working should be accepted as part
    of the design and not some internal detail that is subject to change at any time.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的主要一点是，任何测试所使用的都应该成为支持接口的一部分。如果一个组件暴露了内部工作原理以便测试可以确认，那么这个内部工作原理应该被视为设计的一部分，而不是任何可以随时更改的内部细节。
- en: The difference between what this section describes and the previous section
    comes down to what is agreed to be supported. We get into too much testing when
    we try to test things that either should be tested someplace else or that are
    internal details and should be off-limits to testing. If there’s an internal detail
    that is stable and agreed should not change, and if that internal detail makes
    testing more reliable, then it might make sense for a test to use the detail.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 本节所描述的内容与上一节之间的区别在于什么被同意支持。当我们试图测试那些应该在其他地方测试或内部细节且应该对测试不可达的事物时，我们会进行过多的测试。如果一个内部细节是稳定的，并且被同意不应该改变，并且如果这个内部细节使测试更可靠，那么测试使用这个细节可能是合理的。
- en: I remember one project I worked on many years ago that exposed the internal
    state of classes through **Extensible Markup Language** (**XML**). The state could
    be quite complicated at times, and using XML let the tests confirm that the state
    was configured correctly. The XML would then be passed to other classes that would
    make use of it. The user was not aware of the XML and did not need to use it,
    but the tests relied on it to break complicated scenarios in half. One half of
    the test could make sure that the configuration was correct by verifying the XML
    matched. The other half could then make sure that the actions taken worked properly
    when supplied with known XML input data.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得多年前参与的一个项目，该项目通过**可扩展标记语言**（**XML**）暴露了类的内部状态。有时状态可能相当复杂，使用XML可以让测试确认状态配置正确。然后，XML会被传递给其他使用它的类。用户对XML并不知情，也不需要使用它，但测试依赖于它来将复杂的场景一分为二。测试的一半可以通过验证XML匹配来确保配置正确。然后另一半可以确保在提供已知XML输入数据时采取的行动是正确的。
- en: The software did not have to be designed like this to use XML. It could even
    be said that the tests intruded on the design. The XML became a supported part
    of the design. What could have been just a detail became something more. But I
    would go further and say that the use of XML in this case never started out as
    a detail. It was a conscious design decision that was added for the specific reason
    of making the testing more reliable.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 软件并不需要按照这种方式设计才能使用XML。甚至可以说，测试侵入了设计。XML成为了设计的一部分。原本可能只是细节的东西变成了更多。但我还会进一步说，在这种情况下使用XML从来不是作为一个细节开始的。这是一个有意识的设计决策，是为了特定的原因——使测试更加可靠。
- en: So far, we’ve only explored unit tests. That’s why this book starts out by building
    a unit test library. When considering what should be tested and how intrusive
    the tests should be, there are other types of tests that the next section will
    begin explaining.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只探讨了单元测试。这就是为什么这本书从构建单元测试库开始。在考虑应该测试什么以及测试应该有多侵入性时，下一节将开始解释其他类型的测试。
- en: Where do integration or system tests go in TDD?
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在TDD中，集成或系统测试放在哪里？
- en: Sometimes, it’s good to create a test that brings together multiple components
    and confirms that the overall system being built works as expected. These are
    called integration tests because they integrate multiple components to make sure
    they work well together. Or, the tests can be called system tests because they
    test the entire system. The two names are mostly interchangeable with each other.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，创建一个将多个组件组合在一起并确认正在构建的整体系统按预期工作的测试是很有好处的。这些被称为集成测试，因为它们将多个组件集成在一起以确保它们能够良好地协同工作。或者，这些测试也可以被称为系统测试，因为它们测试整个系统。这两个名称在大多数情况下是可以互换的。
- en: For our microservice developer who is the target customer of the logging library,
    there will likely be unit tests for an individual service, and even unit tests
    for various classes and functions inside the service. Some of the tests for a
    particular service might even be called integration tests, but usually, an integration
    test will be working with multiple services. The services should work together
    to accomplish something bigger. So, having tests that make sure the overall results
    can be reached will help improve the reliability and quality of all the services
    involved.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的微服务开发者，他们是日志库的目标客户，他们可能会为单个服务编写单元测试，甚至为服务内部的各种类和函数编写单元测试。特定服务的某些测试甚至可能被称为集成测试，但通常，集成测试将与多个服务一起工作。服务应该协同工作以完成更大的任务。因此，确保整体结果可以实现的测试将有助于提高所有参与服务的可靠性和质量。
- en: What if you’re not building a set of microservices? What if you’re building
    a desktop application to manage a cryptocurrency wallet? You can still make use
    of system tests. Maybe you want a system test that opens a new wallet and makes
    sure it can synchronize the blockchain data up to the current block, or maybe
    you want another system test that stops the synchronization and then resumes it
    again. Each of these tests will make use of many different components such as
    classes and functions in the application. System tests make sure that some higher-level
    goal can be accomplished and, more importantly, system tests use real data that
    is downloaded over the network.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是在构建一组微服务呢？如果你正在构建一个桌面应用程序来管理加密货币钱包呢？你仍然可以使用系统测试。也许你想要一个系统测试，它可以打开一个新的钱包并确保它能够同步到当前区块的区块链数据，或者也许你想要另一个系统测试，它停止同步然后再重新开始。每个这样的测试都将使用许多不同的组件，例如应用程序中的类和函数。系统测试确保能够实现某些高级目标，更重要的是，系统测试使用通过网络下载的真实数据。
- en: It’s common for a system test to take a long time to complete. Add in multiple
    system tests, and the entire set of tests might need several hours to run. Or,
    maybe there are tests that continuously use the software for a day or more.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试通常需要很长时间才能完成。加上多个系统测试，整个测试集可能需要几个小时才能运行。或者，也许有一些测试会连续使用软件一天或更长时间。
- en: Whether or not a particular test is called a unit test or a system test often
    comes down to how long it takes to run and which resources are needed. Unit tests
    tend to be quick and are able to determine whether something passes without needing
    to rely on other external factors or components. If a test needs to request information
    from another service, then that’s a good sign that the test is more of an integration
    test instead of a unit test. A unit test should never need to download data from
    a network.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特定的测试是否被称为单元测试或系统测试，通常取决于其运行所需的时间以及所需的资源。单元测试通常运行得很快，能够确定某事物是否通过，而无需依赖其他外部因素或组件。如果一个测试需要从另一个服务请求信息，那么这通常是一个很好的迹象，表明这个测试更像是集成测试而不是单元测试。单元测试不应该需要从网络上下载数据。
- en: When it comes to TDD, in order for a test to actually drive the design—as the
    name implies—then the test will normally be of the unit test variety. Don’t get
    me wrong—system tests are important and can help uncover strange usage patterns
    that can be missed by unit tests. But the typical system test or integration test
    is not intended to make sure that the design is easy to use and intuitive. Instead,
    a system test makes sure that a higher-level goal can be reached and that nothing
    breaks the ultimate goals.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到TDD时，为了使测试真正驱动设计——正如其名称所暗示的——那么测试通常将是单元测试类型。请别误会——系统测试很重要，可以帮助发现单元测试可能错过的奇怪使用模式。但典型的系统测试或集成测试并不是为了确保设计易于使用且直观。相反，系统测试确保能够达到高级目标，并且没有任何东西会破坏最终目标。
- en: If there’s any difference between system tests and integration tests, then in
    my mind, it comes down to integration tests being all about making sure that multiple
    components work well together, while a system test is more about the higher-level
    goals. Both integration tests and system tests are at a higher level than unit
    tests.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统测试和集成测试之间有任何区别，那么在我看来，它归结为集成测试主要是确保多个组件能够良好地协同工作，而系统测试则更多地关注高级目标。集成测试和系统测试都高于单元测试。
- en: TDD makes more use of unit tests when creating the initial designs of small
    components and functions. And then, TDD makes use of system and integration tests
    to make sure that the overall solution makes sense and works properly.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: TDD在创建小型组件和函数的初始设计时更多地使用了单元测试。然后，TDD利用系统测试和集成测试来确保整体解决方案合理且运行正常。
- en: You can think of all the testing we are doing for the logging library as system
    tests for the unit test library. We’re making sure that the unit test library
    can actually help design another project.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将我们对日志库进行的所有测试都视为单元测试库的系统测试。我们确保单元测试库实际上可以帮助设计另一个项目。
- en: As for where to put system or integration tests, they normally belong in a different
    test project—something that can be run on its own. This could even be a script.
    If you put them in the same test project as the unit tests, then there needs to
    be some way to only run the unit tests when a quick response is needed.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 至于系统或集成测试放在哪里，它们通常属于不同的测试项目——可以独立运行的项目。这甚至可以是一个脚本。如果你把它们放在与单元测试相同的测试项目中，那么就需要有一种方法来确保在需要快速响应时只运行单元测试。
- en: Other than system and integration tests, there are still more tests you’ll want
    to consider adding. The next section describes more types of tests.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 除了系统和集成测试之外，还有更多测试你可能想要考虑添加。下一节将描述更多类型的测试。
- en: What about other types of tests?
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么，其他类型的测试又如何呢？
- en: There are still more types of tests to consider, such as performance testing,
    load testing, and penetration testing. You can even get into usability testing,
    upgrade testing, certification testing, continuous operation testing, and more,
    including types that I’ve probably never heard of.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多类型的测试需要考虑，例如性能测试、负载测试和渗透测试。你甚至可以涉及到可用性测试、升级测试、认证测试、持续运行测试等等，包括我可能从未听说过的类型。
- en: Each type of test has a purpose that is valuable to software development. Each
    type has its own process and steps, ways of running the test, and ways to verify
    success.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 每种测试类型都有对软件开发有价值的用途。每种类型都有自己的流程和步骤，测试的运行方式以及验证成功的方式。
- en: A performance test might pick a specific scenario such as loading a large file
    and making sure that the operation can complete within a certain amount of time.
    If the test also checks to make sure that the operation completes by only using
    a certain amount of computer memory or CPU time, then it starts becoming more
    of a load test, in my opinion. And if the test makes sure that the end user doesn’t
    have to wait or is notified of a delay, then it starts becoming more of a usability
    test.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试可能会选择一个特定的场景，比如加载一个大文件，并确保操作可以在一定时间内完成。如果测试还检查确保操作仅使用一定量的计算机内存或CPU时间即可完成，那么在我看来，它开始更像是一个负载测试。而且如果测试确保最终用户不需要等待或被通知延迟，那么它开始更像是一个可用性测试。
- en: The lines between the test types sometimes are not clear. The previous section
    already explained that system tests and integration tests are often the same thing,
    with a subtle distinction that often doesn’t matter. The same is true of other
    tests. For example, whether a particular test is a load test or a performance
    test often comes down to the intent. Is the test trying to make sure that an operation
    completes in a certain time? Who decides what time is good enough? Or, is the
    test trying to make sure that an operation can complete while other things are
    going on at the same time? Or, maybe for a test that loads a large file, a large
    file of several megabytes is used for performance testing because that is a typical
    large file that a customer might encounter, while a load test would try to load
    a file much larger. These are just some ideas.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类型之间的界限有时并不清晰。前一个章节已经解释了系统测试和集成测试通常是同一件事，有一个细微的区别，通常并不重要。其他测试也是如此。例如，一个特定的测试是负载测试还是性能测试，通常取决于意图。测试是否试图确保操作在特定时间内完成？谁决定什么时间足够好？或者，测试是否试图确保操作可以在同时进行其他事情时完成？或者，也许对于加载大文件的测试，一个几兆字节的大文件用于性能测试，因为这是客户可能遇到的一个典型的大文件，而负载测试会尝试加载一个更大的文件。这些只是一些想法。
- en: Penetration tests are a little different because they are normally created as
    part of an official security review. The whole software solution will be analyzed,
    lots of documents produced, and tests created. A penetration test is often trying
    to make sure that the software does not crash when malicious data is provided
    or when the system is misused.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试略有不同，因为它们通常作为官方安全审查的一部分创建。整个软件解决方案将被分析，产生大量文档，并创建测试。渗透测试通常试图确保在提供恶意数据或系统被滥用时，软件不会崩溃。
- en: Other penetration tests will check for information disclosure. Is it possible
    to misuse the software so that an attacker gains knowledge that should have remained
    confidential?
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 其他渗透测试将检查信息泄露。是否有滥用软件的可能性，使得攻击者获得本应保持机密的知识？
- en: Even more important are penetration tests that catch data manipulation. A common
    example is students trying to change their grades, but this type of attack can
    be used to steal money or delete critical information.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是渗透测试，它可以捕捉到数据操纵。一个常见的例子是学生试图更改他们的成绩，但这种攻击可以用来窃取金钱或删除关键信息。
- en: Elevation-of-privilege attacks are super important to prevent penetration testing
    because they let an attacker gain access that can lead to more attacks. When an
    attacker is able to take control of a remote server, this is an obvious elevation
    of privilege, but elevation of privilege can be used to gain any extra permissions
    or capabilities that an attacker would not normally have.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 提权攻击对于防止渗透测试至关重要，因为它们让攻击者获得可以导致更多攻击的访问权限。当攻击者能够控制远程服务器时，这显然是一种提权，但提权可以用来获得攻击者通常没有的任何额外权限或能力。
- en: Usability tests are more subjective and often involve customer interviews or
    trials.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性测试更加主观，通常涉及客户访谈或试用。
- en: All of the various different types of tests are important, and my goal with
    this section is not to list or describe every type of test possible but to give
    you an idea of the types of testing available and which benefits different tests
    can provide.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 所有不同类型的测试都很重要，我的目标不是列出或描述所有可能的测试类型，而是给你一个关于可用的测试类型以及不同测试可以提供哪些益处的概念。
- en: 'Software testing is not a question of which tests to use but where each type
    fits into the process. An entire book could be written about each of these test
    types, and many have been written. There’s a reason this book is so focused on
    unit testing: because unit tests are closest to the TDD process.'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试不是关于使用哪种测试的问题，而是每种类型在过程中的位置。关于每种测试类型都可以写一本书，而且已经有很多这样的书。这本书之所以如此专注于单元测试，是因为单元测试与TDD过程最为接近。
- en: Summary
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The TDD process is much more important than the features added to the logging
    library in this chapter. We added log levels, tags, and filtering, and even refactored
    the design of the logging library. And while all of this is valuable, the most
    important thing to pay attention to is the process involved.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: TDD过程比本章中添加到日志库的功能更为重要。我们添加了日志级别、标签和过滤功能，甚至重构了日志库的设计。虽然所有这些都是有价值的，但最重要的还是要关注涉及的过程。
- en: The reason this chapter is so detailed is so that you can see all the decisions
    that went into the design and how tests were used to guide the entire process.
    You can apply this learning to your own projects. And if you also use the logging
    library, then that’s a bonus.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 本章之所以如此详细，是为了让你看到所有设计决策以及测试是如何在整个过程中起到指导作用的。你可以将这种学习应用到自己的项目中。如果你也使用日志库，那么这将是额外的收获。
- en: You learned the importance of understanding the needs of the customer. A customer
    doesn’t have to be a person who walks into a store to buy something. A customer
    is the intended user of whatever software is being developed. This could even
    be another software developer or another team within your company. Understanding
    the needs of the intended user will let you write better tests that solve those
    needs.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了理解客户需求的重要性。客户不一定是走进商店买东西的人。客户是正在开发的软件的预期用户。这甚至可以是另一个软件开发者或公司内的另一个团队。理解预期用户的需求将使你能够编写更好的测试来解决这些需求。
- en: It’s very easy to write a function or design an interface that seems appropriate,
    only to find it difficult to use later. Writing the tests first helps to avoid
    usage problems. And you saw in this chapter a place where I still had to go back
    and change how a function worked because a test showed it to be backward.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个看似合适的函数或设计一个接口非常容易，但后来发现很难使用。先编写测试可以帮助避免使用问题。在本章中，你看到了一个我仍然需要回去更改函数工作方式的地方，因为测试显示它存在逆向问题。
- en: There was an extensive set of changes needed to support filtering log messages
    by value, and this chapter showed how to make changes while keeping the tests
    unchanged.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 需要支持按值过滤日志消息的广泛更改，而本章展示了如何在保持测试不变的情况下进行更改。
- en: One of the best ways to understand TDD is to use the process in a project. This
    chapter developed a lot of new code for the logging library to give you a front-row
    view into the process and gives you more than simple examples could ever show.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 理解TDD的最好方法是在项目中使用这个过程。本章为日志库开发了很多新代码，让你能够近距离观察这个过程，并提供了比简单示例所能展示的更多内容。
- en: The next chapter will explore dependencies and will extend the logging library
    to send log messages to more than a single log file destination.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨依赖关系，并将日志库扩展到向多个日志文件目的地发送日志消息。
