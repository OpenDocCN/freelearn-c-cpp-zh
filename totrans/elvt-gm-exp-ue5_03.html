<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer128">
<h1 class="chapter-number" id="_idParaDest-71"><a id="_idTextAnchor090"/><a id="_idTextAnchor091"/>3</h1>
<h1 id="_idParaDest-72"><a id="_idTextAnchor092"/>Character Class Components and Blueprint Setup</h1>
<p>In the previous chapter, we learned how to create empty projects and import files, which folder structure to use, and how to work with animations. In this chapter, we’ll explore some other key tools and functionality that you will work with when using Unreal Engine.</p>
<p>Game developers often need to use certain tools that save them time and energy when building game functionality. Unreal Engine’s powerful object inheritance capabilities give developers the edge they need to be more efficient. Developers can also work with both C++ and Blueprints interchangeably and use them to their benefit when developing games.</p>
<p>Another value-added benefit developers gain is the ability to extend code for use later in a project. Let’s say your client has new requirements that build upon the old ones (as is the case in most game studios). Now, to extend functionality, developers can just inherit a class and add more functionality to it to get results quickly. This is very powerful, and it comes in handy in many situations.</p>
<p>This chapter will focus on the <strong class="source-inline">Character</strong> class in C++. You will be shown how to extend the <strong class="source-inline">Character</strong> class in C++ and then extend this newly created <strong class="source-inline">Character</strong> class further in Blueprints via inheritance. You will also work with player input and some movement logic. We will discuss the Unreal <strong class="source-inline">Character</strong> class, create C++ code, and then extend it in Blueprints, before finally using it to create an in-game character.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>The Unreal <strong class="source-inline">Character</strong> class</li>
<li>Extending the C++ class with Blueprints</li>
</ul>
<p>By the end of this chapter, you will understand how class inheritance works in UE5 and how to utilize it to your advantage. You will also be able to work with Axis Mappings and Action Input Mappings, which are key in driving player-related input logic.</p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor093"/>Technical requirements</h1>
<p>This chapter has the following technical requirements:</p>
<ul>
<li>Unreal Engine 5 installed</li>
<li>Visual Studio 2019 installed</li>
</ul>
<p>The complete code for this chapter can be downloaded from GitHub at <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition</a>.</p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor094"/>The Unreal Character class</h1>
<p>Before we talk about the Unreal <strong class="source-inline">Character</strong> class, let’s briefly touch on the concept of inheritance. If you’re used to working with C++ or another similar language, you should already be familiar with <a id="_idIndexMarker265"/>this concept. Inheritance is the process whereby a class derives characteristics and behavior from another class. A C++ class can be extended to create a new class – a derived class – that retains properties of the base class and allows these properties to be modified or new characteristics to be added. An example of this is the <strong class="source-inline">Character</strong> class.</p>
<p>The <strong class="source-inline">Character</strong> class is a special type of pawn and is a descendant of the Unreal <strong class="source-inline">Pawn</strong> class. Extending upon <a id="_idIndexMarker266"/>the <strong class="source-inline">Pawn</strong> class, the <strong class="source-inline">Character</strong> class has some movement capabilities by default, along with some inputs that add movement to the character. As standard, the <strong class="source-inline">Character</strong> class gives users the ability to get a character to walk, run, jump, fly, and swim within the created world.</p>
<p>Since the <strong class="source-inline">Character</strong> class is an extension of the <strong class="source-inline">Pawn</strong> class, it contains all the code/logic of the pawn, and developers can extend this class to add more functionality to it. When extending the <strong class="source-inline">Character</strong> class, its existing components get carried over to the extended class as inherited components (in this case, the Capsule, Arrow, and Mesh components). </p>
<p class="callout-heading">Note</p>
<p class="callout">Inherited components cannot be removed. Their settings may be changed, but a component that’s added to a base class will always be present in the extended class. In this case, the base class is the <strong class="source-inline">Pawn</strong> class, while the extended (or child) class is the <strong class="source-inline">Character</strong> class.</p>
<p>The <strong class="source-inline">Character</strong> class provides <a id="_idIndexMarker267"/>the following inherited components:</p>
<ul>
<li><strong class="bold">Capsule component</strong>: This is the root component that serves as the “origin” that other components get attached to within the hierarchy. This component can also be used for collisions and takes the form of a capsule that logically outlines many character forms (especially humanoid ones<a id="_idTextAnchor095"/>).</li>
<li><strong class="bold">Arrow component</strong>: This provides a simple arrow pointing toward the front of the hierarchy. By default, this is set to <strong class="source-inline">hide</strong> when the game starts, but it can be tweaked to be visible. This component can be useful for debugging and adjusting game logic if required.</li>
<li><strong class="bold">Skeletal Mesh component</strong>: This is the primary component that developers are mostly concerned with within the <strong class="source-inline">Character</strong> class. The Skeletal Mesh, which is the form the character will take, can be set up here, along with all the relevant variables, including animations, collisions, and so on.</li>
</ul>
<p>Most developers usually prefer to code the game and character logic in C++ and extend that class to Blueprints <a id="_idIndexMarker268"/>so that they can perform other simple tasks, such as connecting assets to the class. So, for example, a developer may create a C++ class that inherits from the <strong class="source-inline">Character</strong> class, write all the movement and jumping logic within that class, and then extend this class with a Blueprint, in which the developer updates the components with the required assets (such as the Skeletal Mesh and animation blueprint), and optionally code additional functionality into blueprints.</p>
<h3>Extending the Character class</h3>
<p>The <strong class="source-inline">Character</strong> class is <a id="_idIndexMarker269"/>extended when it is inherited by either C++ or Blueprints. This extended <strong class="source-inline">Character</strong> class will be a child of the <strong class="source-inline">Character</strong> class (<em class="italic">which will be called its parent</em>). Extending classes is a powerful part of object-oriented programming, and classes can be extended to great depths and hierarchies.</p>
<h3>Exercise 3.01 – creating and setting up a third-person Character C++ class </h3>
<p>In this exercise, you will create a C++ class based on a <strong class="source-inline">Character</strong> class. You will also initialize the variables <a id="_idIndexMarker270"/>that will be set in the default values for <a id="_idIndexMarker271"/>the class that will extend this <strong class="source-inline">Character</strong> class.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li>Launch Unreal Engine, select the <strong class="bold">Games</strong> category, and click the <strong class="bold">Next</strong> button.</li>
<li>Select <strong class="bold">Blank</strong> and click the <strong class="bold">Next</strong> button.</li>
<li>Choose <strong class="bold">C++</strong> as the project type, set up the project name as <strong class="source-inline">MyThirdPerson</strong>, choose a suitable project directory, and click the <strong class="bold">Create Project</strong> button.</li>
<li>Right-click in the <strong class="bold">Content Browser</strong> area and click the <strong class="bold">New C++ Class</strong> button.</li>
<li>In the dialog box that opens, select <strong class="source-inline">Character</strong> as the class type and click the <strong class="bold">Next</strong> button. </li>
<li>Name it <strong class="source-inline">MyThirdPersonChar</strong> and click the <strong class="bold">Create Class</strong> button. </li>
<li>Upon doing so, Visual Studio will open the <strong class="source-inline">MyThirdPersonChar.cpp</strong> and <strong class="source-inline">MyThirdPersonChar.h</strong> tabs.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">On some systems, you might be required to run the Unreal Engine editor with administrator privileges to automatically open the Visual Studio solution with the newly created C++ files.</p>
<ol>
<li value="8">Open the <strong class="source-inline">MyThirdPersonChar.h</strong> tab and add the following code under the <strong class="source-inline">GENERATED_BODY()</strong> text:<p class="source-code">// Spring arm component which will act as a </p><p class="source-code">// placeholder for </p><p class="source-code">// the player camera. This component is recommended to // be used as it automatically controls how the </p><p class="source-code">//camera handles situations</p><p class="source-code">// where it becomes obstructed by geometry inside the </p><p class="source-code">// level, etc</p><p class="source-code">UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = </p><p class="source-code">  MyTPS_Cam, meta = (AllowPrivateAccess = "true"))</p><p class="source-code">class USpringArmComponent* CameraBoom;</p><p class="source-code">// Follow camera</p><p class="source-code">UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = </p><p class="source-code">  MyTPS_Cam, meta = (AllowPrivateAccess = "true"))</p><p class="source-code">class UCameraComponent* FollowCamera;</p></li>
</ol>
<p>In the preceding code, we’re declaring two components: the <strong class="source-inline">Camera</strong> component itself and <strong class="source-inline">Camera boom</strong>, which acts as the placeholder for the camera at a <a id="_idIndexMarker272"/>certain distance from the player. These <a id="_idIndexMarker273"/>components will be initialized in the constructor in <em class="italic">step 11</em>.</p>
<ol>
<li value="9">Add the following <strong class="source-inline">#include</strong> statements under <strong class="source-inline">#include “CoreMinimal.h”</strong>, in the <strong class="source-inline">MyThirdPersonChar.h</strong> file:<p class="source-code">#include "GameFramework/SpringArmComponent.h"</p><p class="source-code">#include "Camera/CameraComponent.h"</p></li>
<li>Now, go to the <strong class="source-inline">MyThirdPersonChar.cpp</strong> tab and add the following <strong class="source-inline">#include</strong> statements after the <strong class="source-inline">#include MyThirdPersonChar.h</strong> code:<p class="source-code">#include "Components/CapsuleComponent.h"</p><p class="source-code">#include "GameFramework/CharacterMovementComponent.h"</p></li>
</ol>
<p>The <a id="_idIndexMarker274"/>preceding code adds the relevant classes to <a id="_idIndexMarker275"/>the class, which means we now have access to its methods and definitions.</p>
<ol>
<li value="11">In the <strong class="source-inline">AMyThirdPersonChar::AMyThirdPersonChar()</strong> function, add the following lines:<p class="source-code">// Set size for collision capsule</p><p class="source-code">GetCapsuleComponent()-&gt;InitCapsuleSize(42.f, 96.0f);</p><p class="source-code">// Don't rotate when the controller rotates. Let that // just </p><p class="source-code">  affect the camera.</p><p class="source-code">bUseControllerRotationPitch = false;</p><p class="source-code">bUseControllerRotationYaw = false;</p><p class="source-code">bUseControllerRotationRoll = false;</p><p class="source-code">// Configure character movement</p><p class="source-code">GetCharacterMovement()-&gt;bOrientRotationToMovement = true;</p><p class="source-code">// Create a camera boom (pulls in towards the </p><p class="source-code">  player if there is a collision)</p><p class="source-code">CameraBoom = </p><p class="source-code">  CreateDefaultSubobject&lt;USpringArmComponent&gt;(</p><p class="source-code">  TEXT("CameraBoom"));</p><p class="source-code">CameraBoom-&gt;SetupAttachment(RootComponent);</p><p class="source-code">CameraBoom-&gt;TargetArmLength = 300.0f;</p><p class="source-code">CameraBoom-&gt;bUsePawnControlRotation = true; </p><p class="source-code">// Create a camera that will follow the character</p><p class="source-code">FollowCamera = </p><p class="source-code">  CreateDefaultSubobject&lt;UcameraComponent&gt;(</p><p class="source-code">  TEXT("FollowCamera"));</p><p class="source-code">FollowCamera-&gt;SetupAttachment(CameraBoom, </p><p class="source-code">  USpringArmComponent::SocketName);</p><p class="source-code">FollowCamera-&gt;bUsePawnControlRotation = false;</p></li>
</ol>
<p>The last line of the preceding code snippet will set up the camera to bind its rotation <a id="_idIndexMarker276"/>with the pawns’. This means that the camera <a id="_idIndexMarker277"/>should, in turn, rotate based on the rotation of the player controller that’s associated with this pawn. </p>
<ol>
<li value="12">Head back to the Unreal Engine project and click the <strong class="bold">Compile</strong> icon button on the top bar:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer114">
<img alt="Figure 3.1 – The Compile button on the top bar of Unreal Editor " height="32" src="image/Figure_3.01_B18531.jpg" width="360"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – The Compile button on the top bar of Unreal Editor</p>
<p>A Live coding succeeded message should appear at the bo<a id="_idTextAnchor096"/>ttom right.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the completed exercise code files on GitHub, in the <strong class="source-inline">Chapter03</strong> | <strong class="source-inline">Exercise3.01</strong> directory, at <a href="https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter03/Exercise3.01">https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter03/Exercise3.01</a>.</p>
<p>After extracting the <strong class="source-inline">.rar</strong> file, double-click the <strong class="source-inline">.uproject</strong> file. You will see a prompt asking <strong class="source-inline">Would you like to rebuild now?</strong>. Click <strong class="source-inline">Yes</strong> so that it can build the necessary intermediate files, after which it should open the project in Unreal Editor automatically.</p>
<p>By completing this exercise, you’ve learned how to extend the <strong class="source-inline">Character</strong> class. You have also learned <a id="_idIndexMarker278"/>how to initialize the default components of <a id="_idIndexMarker279"/>the <strong class="source-inline">Character</strong> class and how to compile the updated code from within Unreal Editor. Next, you will learn how to extend the C++ class you created in Blueprints and why that is feasible in many situations.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor097"/>Extending the C++ class with Blueprints</h1>
<p>As mentioned earlier, most developers extend the C++ code logic to blueprints to link this with the assets they will use. This is done to achieve easy asset assignment compared to finding and setting up the asset in code. Furthermore, it allows developers to use powerful blueprint features such as Timelines, Events, and ready-to-use macros, in combination with their C++ code, to achieve the maximum benefit of developing with both C++ and Blueprints.</p>
<p>So far, we have made a C++ <strong class="source-inline">Character</strong> class. In it, we have set up components and movement capabilities. Now, we want to specify the assets that are going to be used in our class, as well as add input and movement ability. For this, it is easier to extend with Blueprint and set up the options there. This is what we will be doing in the next exercise.</p>
<h3>Exercise 3.02 – extending C++ with Blueprints</h3>
<p>In this exercise, you <a id="_idIndexMarker280"/>will learn how to extend the C++ class you <a id="_idIndexMarker281"/>created with Blueprints to add Blueprint code on top of the pre-existing C++ code. You will also be adding input key bindings, which will be responsible for moving the character.</p>
<p>Follow these steps to complete this exercise:</p>
<ol>
<li value="1">Download and extract the contents of the <strong class="source-inline">Chapter03/Exercise3.02/ExerciseFiles</strong> directory, which can be found on GitHub.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">The <strong class="source-inline">ExerciseFiles</strong> directory can be found on GitHub at <a href="https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter03/Exercise3.02/ExerciseFiles">https://github.com/PacktPublishing/Game-Development-Projects-with-Unreal-Engine/tree/master/Chapter03/Exercise3.02/ExerciseFiles</a>.</p>
<ol>
<li value="2">Browse to the <strong class="source-inline">Content</strong> folder inside the <strong class="bold">MyThirdPerson</strong> project we created in <em class="italic">Exercise 3.01 – creating and setting up a third-person Character C++ class</em>.</li>
<li>Copy the <strong class="source-inline">MixamoAnimPack</strong> folder we created in <em class="italic">step 1</em> and paste it into the <strong class="source-inline">Content</strong> folder directory we opened in <em class="italic">step 2</em>, as shown in the following screenshot: <div class="IMG---Figure" id="_idContainer115"><img alt="Figure 3.2 – MixamoAnimPack placed in the project directory " height="137" src="image/Figure_3.02_B18531.jpg" width="671"/></div></li>
</ol>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – MixamoAnimPack placed in the project directory</p>
<p class="callout-heading">Note</p>
<p class="callout">The <strong class="source-inline">MixamoAnimPack</strong> assets <a id="_idIndexMarker282"/>were obtained from the Epic marketplace via the following link: <a href="https://www.unrealengine.com/marketplace/en-US/product/mixamo-animation-pack">https://www.unrealengine.com/marketplace/en-US/product/mixamo-animation-pack</a>.</p>
<ol>
<li value="4">Open the <a id="_idIndexMarker283"/>project. Right-click inside the <strong class="bold">Content Browser</strong> area <a id="_idIndexMarker284"/>and click <strong class="source-inline">Blueprint Class</strong>.</li>
<li>In the <strong class="bold">Search</strong> dialog, type <strong class="source-inline">GameMode</strong>, right-click the class matching the name, and click the <strong class="bold">Select</strong> button. Have a look at the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer116">
<img alt="Figure 3.3 – Creating the GameMode class " height="670" src="image/Figure_3.03_B18531.jpg" width="621"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Creating the GameMode class</p>
<ol>
<li value="6">Name the blueprint we created in <em class="italic">step 6</em> <strong class="source-inline">BP_GameMode</strong>.</li>
<li>Now, repeat <em class="italic">step 5</em>.</li>
<li>In the <strong class="bold">Search</strong> box, type <strong class="source-inline">MyThirdPersonChar</strong>, select the class, and then right-click on the <strong class="bold">Select</strong> button. </li>
<li>Name <a id="_idIndexMarker285"/>the blueprint we created in <em class="italic">step 9</em> <strong class="source-inline">BP_MyTPC</strong>.</li>
<li>In <a id="_idIndexMarker286"/>the <strong class="bold">World Settings</strong> tab, click the <strong class="bold">None</strong> option next to <strong class="bold">GameMode Override</strong> and select <strong class="bold">BP_GameMode</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer117">
<img alt="Figure 3.4 – Specifying Game Mode in World Settings" height="413" src="image/Figure_3.04_B18531.jpg" width="328"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Specifying Game Mode in World Settings</p>
<ol>
<li value="11">Set <strong class="bold">Default Pawn Class</strong> to <strong class="source-inline">BP_MyTPC</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer118">
<img alt="Figure 3.5 – Specifying Default Pawn Class in Game Mode " height="241" src="image/Figure_3.05_B18531.jpg" width="317"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Specifying Default Pawn Class in Game Mode</p>
<ol>
<li value="12">Open <strong class="bold">BP_MyTPC</strong> and click on the <strong class="bold">Mesh (Inherited)</strong> component in the hierarchy of the <strong class="bold">Components</strong> tab on the left-hand side.</li>
<li>In <a id="_idIndexMarker287"/>the <strong class="bold">Details</strong> tab, find the <strong class="bold">Mesh</strong> section <a id="_idIndexMarker288"/>and set <strong class="bold">Skeletal Mesh</strong> to <strong class="bold">Maximo_Adam</strong>.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Meshes and Animations will be covered in depth in <a href="B18531_11.xhtml#_idTextAnchor222"><em class="italic">Chapter 11</em></a><em class="italic">, Working with Blend Space 1D, Key Bindings, and State Machines</em>.</p>
<ol>
<li value="14">In the <strong class="bold">Details</strong> tab, find the <strong class="bold">Animation</strong> section and set <strong class="bold">Anim Class</strong> to <strong class="bold">MixamoAnimBP_Adam_C</strong>. You’ll note that this class name gets suffixed with <strong class="source-inline">_C</strong> when selected. This is the instance of the blueprint that was created by UE5. Blueprints, in a working project/build, usually get suffixed this way to differentiate between a Blueprint class and an instance of that class:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer119">
<img alt="Figure 3.6 – Setting up Anim Class and Skeletal Mesh " height="392" src="image/Figure_3.06_B18531.jpg" width="417"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Setting up Anim Class and Skeletal Mesh</p>
<ol>
<li value="15">From the <a id="_idIndexMarker289"/>top-most menu, go to the <strong class="bold">Edit</strong> drop-down <a id="_idIndexMarker290"/>and click <strong class="bold">Project Settings</strong>.</li>
<li>Click on the <strong class="bold">Input</strong> section, which can be found in the <strong class="bold">Engine</strong> section:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer120">
<img alt="Figure 3.7 – The Input section of Project Settings " height="383" src="image/Figure_3.07_B18531.jpg" width="180"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – The Input section of Project Settings</p>
<ol>
<li value="17">In <a id="_idIndexMarker291"/>the <strong class="bold">Bindings</strong> section, click the <strong class="bold">+</strong> icon <a id="_idIndexMarker292"/>next to <strong class="bold">Axis Mappings</strong> and expand the section.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout"><strong class="bold">Action Mappings</strong> are single keypress <a id="_idIndexMarker293"/>actions that are performed, such as <strong class="source-inline">jump</strong>, <strong class="source-inline">dash</strong>, or <strong class="source-inline">run</strong>, while <strong class="bold">Axis Mappings</strong> are float values that are assigned that will return <a id="_idIndexMarker294"/>a floating-point value based on the keypress of the user. This is more relevant in the case of gamepad controllers or VR controllers, where the analog thumb stick comes into play. In that case, it would return the floating value of the state of the thumb stick, which is very important for managing player movement or related functionalities.</p>
<ol>
<li value="18">Rename <strong class="bold">NewAxisMapping_0</strong> so that it’s called <strong class="source-inline">MoveForward</strong>.</li>
<li>In the <strong class="bold">MoveForward</strong> section, click the drop-down menu and select <strong class="source-inline">W</strong>.</li>
<li>Click the <strong class="bold">+</strong> icon next to the <strong class="bold">MoveForward</strong> icon to add another field.</li>
<li>Set the new field to <strong class="source-inline">S</strong>. Set its scale to <strong class="source-inline">-1.0</strong> (since we want to move backward with the <strong class="source-inline">S</strong> key).</li>
<li>Create <a id="_idIndexMarker295"/>another axis mapping by repeating <em class="italic">step 18</em>, name <a id="_idIndexMarker296"/>it <strong class="source-inline">MoveRight</strong>, and add two fields – <strong class="source-inline">A</strong> with <strong class="source-inline">-1.0</strong> for the scale and <strong class="source-inline">D</strong> with <strong class="source-inline">1.0</strong> for the scale:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer121">
<img alt="Figure 3.8 – Movement Axis Mappings " height="209" src="image/Figure_3.08_B18531.jpg" width="452"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Movement Axis Mappings</p>
<ol>
<li value="23">Open <strong class="bold">BP_MyTPC</strong> and click the <strong class="bold">Event Graph</strong> tab:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer122">
<img alt="Figure 3.9 – The Event Graph tab " height="32" src="image/Figure_3.09_B18531.jpg" width="489"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – The Event Graph tab</p>
<ol>
<li value="24">Right-click anywhere inside the graph, type <strong class="source-inline">MoveForward</strong>, and select the first node option:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer123">
<img alt="Figure 3.10 – The MoveForward Axis Event " height="167" src="image/Figure_3.10_B18531.jpg" width="403"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – The MoveForward Axis Event</p>
<ol>
<li value="25">Right-click <a id="_idIndexMarker297"/>inside the graph, search for <strong class="bold">Get Control Rotation</strong>, and <a id="_idIndexMarker298"/>select the first node option.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Since the camera associated with a player can choose not to show the pawn’s yaw, roll, or pitch, <strong class="source-inline">Get Control Rotation</strong> gives the pawn full aim rotation. This is useful in many calculations.</p>
<ol>
<li value="26">Left-click and drag from <strong class="bold">Return Value</strong> of the <strong class="bold">Get Control Rotation</strong> node, search for <strong class="bold">Break Rotator</strong>, and select it.</li>
<li>Right-click inside the graph, search for <strong class="bold">Make Rotator</strong>, and select the first node option.</li>
<li>Connect the <strong class="source-inline">Z</strong> (<em class="italic">yaw</em>) node from <strong class="bold">Break Rotator</strong> to the <strong class="source-inline">Z</strong> (<em class="italic">yaw</em>) node of <strong class="bold">Make Rotator</strong>.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout"><strong class="bold">Make Rotator</strong> creates a rotator with the pitch, roll, and yaw values, while the break rotator splits a rotator into its components (roll, pitch, and yaw).</p>
<ol>
<li value="29">Left-click <a id="_idIndexMarker299"/>and drag from <strong class="bold">Return Value</strong> of <a id="_idIndexMarker300"/>the <strong class="bold">Make Rotator</strong> node, search for <strong class="bold">Get Forward Vector</strong>, and select it.</li>
<li>Left-click and drag from <strong class="bold">Return Value</strong> of the <strong class="bold">Get Forward Vector</strong> node, search for <strong class="bold">Add Movement Input</strong>, and select it.</li>
<li>Connect the <strong class="bold">Axis Value</strong> node from the <strong class="bold">InputAxis MoveForward</strong> node to the <strong class="bold">Scale Value</strong> node in the <strong class="bold">Add Movement Input</strong> node.</li>
<li>Finally, connect the white <strong class="bold">Execution</strong> pin from the <strong class="bold">InputAxis MoveForward</strong> node to the <strong class="bold">Add Movement Input</strong> node.</li>
<li>Right-click inside the graph, search for <strong class="bold">InputAxis MoveRight</strong>, and select the first node option.</li>
<li>Left-click and drag from <strong class="bold">Return Value</strong> of the <strong class="bold">Make Rotator</strong> node, search for <strong class="bold">Get Right Vector</strong>, and select it.</li>
<li>Left-click and drag from <strong class="bold">Return Value</strong> of the <strong class="bold">Get Right Vector</strong> node, search for <strong class="bold">Add Movement Input</strong>, and select it.</li>
<li>Connect the <strong class="bold">Axis Value</strong> pin from the <strong class="bold">InputAxis MoveRight</strong> node to the <strong class="bold">Scale Value</strong> pin in the <strong class="bold">Add Movement Input</strong> node we created in the previous step.</li>
<li>Finally, connect the <strong class="bold">white Execution</strong> pin from the <strong class="bold">InputAxis MoveRight</strong> node to the <strong class="bold">Add Movement Input</strong> node we added in <em class="italic">step 36</em>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer124">
<img alt="Figure 3.11 – Movement logic " height="384" src="image/Figure_3.11_B18531.jpg" width="849"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – Movement logic</p>
<ol>
<li value="38">Now, head to the <strong class="bold">Viewport</strong> tab. Here, you will see that the character’s front is not pointing in the direction of the arrow and that the character is displaced above the capsule <a id="_idIndexMarker301"/>component. Click on the <strong class="source-inline">Mesh</strong> component <a id="_idIndexMarker302"/>and select the object translation node located at the top of the viewport. Then, drag the arrows on the Mesh to adjust it so that the feet align with the bottom of the capsule component and the Mesh is rotated to point toward the arrow:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer125">
<img alt="Figure 3.12 – The Translation Rotation and Scale Selector section" height="31" src="image/Figure_3.12_B18531.jpg" width="102"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – The Translation Rotation and Scale Selector section</p>
<p>Once the character is aligned in the capsule, it will look as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer126">
<img alt="Figure 3.13 – Mesh adjusted within the capsule component " height="311" src="image/Figure_3.13_B18531.jpg" width="607"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – Mesh adjusted within the capsule component</p>
<ol>
<li value="39">In the <strong class="bold">Toolbar</strong> menu, press the <strong class="bold">Compile</strong> button and then <strong class="bold">Save</strong>.</li>
<li>Go back <a id="_idIndexMarker303"/>to the map tab and press the <strong class="bold">Play</strong> button <a id="_idIndexMarker304"/>to view your character in-game. Use the <em class="italic">W</em>, <em class="italic">A</em>, <em class="italic">S</em>, and <em class="italic">D</em> keys to move around.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">You can find the completed exercise code files on GitHub, in the <strong class="source-inline">Chapter03</strong> | <strong class="source-inline">Exercise3.02</strong> directory, at <a href="https://packt.live/3keGxIU">https://packt.live/3keGxIU</a>.</p>
<p>After extracting the <strong class="source-inline">.rar</strong> file, double-click the <strong class="source-inline">.uproject</strong> file. You will see a prompt asking <strong class="screen-inline">Would you like to rebuild now?</strong>. Click <strong class="source-inline">Yes</strong> on that prompt so that it can build the necessary intermediate files, after which it should open the project in Unreal Editor automatically.</p>
<p>By completing this exercise, you know how to extend C++ code with Blueprints, and why that is favorable in many situations for developers. You also learned how to add input mappings and how they are used to drive player-related input logic.</p>
<p>In the activity for this chapter, you will be combining the skills you have gained from the previous exercises of this chapter and extending the project you completed in <em class="italic">Activity 2.01 – linking animations to a character</em> of <a href="B18531_02.xhtml#_idTextAnchor043"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Unreal Engine</em>. This will allow you to build on your own Blueprint and see how that maps to real-world scenarios.</p>
<h3>Activity 3.01 – extending the C++ Character class with Blueprints in the Animation project</h3>
<p>Now that <a id="_idIndexMarker305"/>you’ve created <a id="_idIndexMarker306"/>a C++ class and <a id="_idIndexMarker307"/>extended it with Blueprints, it is time to bring both concepts together in a real-world scenario. In this activity, you will be making our character from <em class="italic">Activity 2.01 – linking animations to a character</em>, which can be found in <a href="B18531_02.xhtml#_idTextAnchor043"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Unreal Engine</em>, jump using the spacebar key on your keyboard. However, you need to create the <strong class="source-inline">Character</strong> class from scratch in C++ and then later extend it with Blueprint to reach the final goal.</p>
<p>Follow these steps to complete this activity:</p>
<ol>
<li value="1">Open the project from <em class="italic">Activity 2.01– linking animations to a character</em>.</li>
<li>Create a <strong class="source-inline">Character</strong> class in C++ that will initialize the character variables, including the camera associated with the player.</li>
<li>Map the <strong class="source-inline">Jump </strong>input to the spacebar key in the project settings.</li>
<li>Extend the created C++ class with a blueprint to add the associated assets and jump functionality.</li>
</ol>
<p><strong class="bold">Expected Output</strong></p>
<p>The character should be able to jump when you press the spacebar key. The level should use the Blueprint that extends the C++ <strong class="source-inline">Character</strong> class:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><img alt="Figure 3.14 – Ganfault jump activity expected output " height="683" src="image/Figure_3.14_B18531.png" width="620"/></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – Ganfault jump activity expected output</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution to this activity can be found on GitHub here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<p>By completing this <a id="_idIndexMarker308"/>activity, you’ve <a id="_idIndexMarker309"/>understood scenarios where C++ code is extended in Blueprints to implement functionalities <a id="_idIndexMarker310"/>and logic. This combination of C++ and Blueprints is the most powerful tool game developers possess to create masterful and unique games within Unreal Engine.</p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor098"/>Summary</h1>
<p>In this chapter, you learned how to create a C++ <strong class="source-inline">Character</strong> class, add initializer code to it, and then use Blueprints to extend it to set up assets and add additional code. </p>
<p>The result obeys the C++ code, as well as the Blueprint code, and can be used in any purposeful scenario.</p>
<p>You also learned how to set up Axis Mappings that have been mapped to the <em class="italic">W</em>, <em class="italic">A</em>, <em class="italic">S</em>, and <em class="italic">D</em> keys to move players (which is the default movement mapping in many games). You also learned how to make the character jump within the game.</p>
<p>In the next chapter, you will explore Input Mappings in more depth and how to use the Mobile Previewer within Unreal Editor. This will help you create games with solid inputs mapped to game and player logic. It will also allow you to quickly test what your game will look and feel like on a mobile, all within Unreal Editor.</p>
</div>
</div></body></html>