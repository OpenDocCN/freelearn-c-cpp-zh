<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Obstacle Avoidance and Collision Detection</h1>
                </header>
            
            <article>
                
<p>If you are making an autonomous robot that needs to avoid obstacles, a remote-controlled car that needs to detect when it hits something or even a 3D printer that needs to know when the print heads have reached the limits of the print area, you will need to include some sort of obstacle avoidance or collision detection system in your project. In this chapter, we will look at several sensors that can be used for obstacle avoidance and collision detection systems.</p>
<p>Throughout this chapter, you will learn:</p>
<ul>
<li>How to use a crash sensor</li>
<li>How to use an infrared obstacle avoidance sensor</li>
<li>How to use an Ultrasonic rangefinder</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will look at three sensors that we can use to add obstacle avoidance and/or collision detection to our projects. These sensors are:</p>
<ul>
<li><strong>Crash sensor</strong>: Used to detect a crash and also used as limit switches for 3D printers</li>
<li><strong>Infrared obstacle avoidance sensor</strong>: <span>Used for obstacle avoidance for robotics</span></li>
<li><strong>Ultrasonic range finder</strong>: <span>Used for obstacle avoidance for robotics and has many other commercial and military uses</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Crash sensor</h1>
                </header>
            
            <article>
                
<p>A crash sensor is basically a simple switch that has some sort of extender on it that gives it a large area to detect a crash. The following photograph show what a basic crash sensor would look like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7cbf31a3-354a-4918-9ac0-4f1ca523f7c3.png" style="width:27.92em;height:34.25em;"/></p>
<p>The crash sensor shown in the preceding photograph takes a simple mechanical switch, like the types used for end stops on 3D printers, and attaches it to the end of a circuit board. This makes it easy to mount out a robot chassis or other surfaces. The concept behind a crash sensor is when the switch is triggered, the sensor has bumped into something.</p>
<p>The crash sensor has three pins that are clearly marked as <strong>GND</strong>, <strong>VCC</strong>, and <strong>OUT</strong>. The GND pin connects to the ground rail and the VCC connects to power rail on the breadboard. The OUT pin connects directly to a digital pin on the Arduino with a 4.7K pull-up resistor.</p>
<p>The infrared obstacle avoidance sensor consists of an infrared transmitter, an infrared receiver, and a potentiometer that adjusts the distance the sensor will detect obstacles at. The following photographs show the obstacle avoidance sensor that is used for the project in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Obstacle avoidance sensor</h1>
                </header>
            
            <article>
                
<p>The emitter on the infrared obstacle avoidance sensor emits infrared radiation and if an obstacle is in front of the sensor, some of the radiation is reflected back and picked up by the receiver. If no object is in front of the sensor then the radiation will dissipate, and the receiver will not receive anything back.</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d396a4bf-039c-4dcf-bdb5-14d4f99feff5.png" style="width:22.17em;height:30.50em;"/></p>
<p>The pins on the sensor are clearly marked with <strong>OUT</strong>, <strong>GND</strong>, and <strong>VCC</strong>, from left to right. The GND pin is connected to the ground rail and the VCC pin is connected to the power rail of the breadboard. The OUT pin is connected directly to a digital pin on the Arduino. If the signal from the OUT pin is LOW, then an object was detected. If the output is HIGH, then no object was detected.</p>
<p>The distance adjuster will adjust the distance that the sensor detects objects. If the adjuster is turned counter-clockwise then the distance will be decreased, and if you turn it clockwise the distance will increase. The sensor will detect objects from 2 to 30 cm.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ultrasonic range finder</h1>
                </header>
            
            <article>
                
<p>The third sensor that we will be using is a <strong>MaxSonar EZ1</strong> Ultrasonic range finder. This sensor is one of my favorite sensors to use. I have used it in almost every autonomous robot that I have built to determine the distance to nearby objects. The following is an image of the EZ1 Ultrasonic range finder:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e094d1c3-4aea-4525-80cc-8e3989a25b51.png" style="width:18.00em;height:26.33em;"/></p>
<p>For the example, in this chapter, we will be using pins 3,6, and 7 on the sensor. Pin 3 is used for analog out, pin 6 is for VCC and pin 7 is for ground. Pins 4 and 5 are for serial RX/TX connection and pin 2 is for a pulse-width output, however, we will not be using those outputs in the example for this chapter.</p>
<p>An ultrasonic range finder works by sending an ultrasonic pulse in a particular direction. If there is an object in the path of the pulse when it is reflected back in the form of an echo. The sensor determines the distance to the object by measuring the time it takes for the echo to be received back.</p>
<p>The EZ1 ultrasonic sensor can detect and measure the distance to an object from 0 to 6.45 meters (254 inches). This sensor has virtually no dead zone and will detect objects right up to the front sensor face.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Components needed</h1>
                </header>
            
            <article>
                
<p>We will need the following components for this chapter's project:</p>
<ul>
<li>One Arduino Uno or compatible board</li>
<li>One crash sensor</li>
<li>One obstacle avoidance sensor</li>
<li>One EZ1 Ultrasonic sensor</li>
<li>One 4.7K resistor</li>
<li>Jumper wires</li>
<li>One breadboard</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Circuit diagrams</h1>
                </header>
            
            <article>
                
<p>The following diagram shows the Fritzing diagram for this project:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8e69c262-ac80-4c36-a471-747596d1b7df.png" style="width:33.08em;height:28.83em;"/></p>
<p>The middle sensor, shown in the diagram, represents the crash sensor because there isn't a Fritzing part for a crash sensor. The switch in the diagram has the same pin layout as the crash sensor shown earlier in this chapter.</p>
<p>In the diagram, we can see that all of the ground pins on the sensors are connected to the ground rail of the breadboard and all of the VCC pins on the sensors are connected to the power rail on the breadboard.</p>
<p>The analog out on the EZ1 Ultrasonic sonar sensor is connected to the A1 analog pin on the Arduino, the crash sensor is connected to digital pin 3 and the infrared sensor is connected to digital pin 2. The crash sensor also has a 4.7K pull-up resistor. Now that we have the sensors connected to the Arduino, let's look at the code for this project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code</h1>
                </header>
            
            <article>
                
<p>We will begin the code with three macros that define the pins that the three sensors are connected to. The macros will look like this:</p>
<pre>#define COLLISION_SWITCH 4
#define IR_SENSOR 3
#define RANGE_SENSOR A1</pre>
<p>These macros show that the crash sensor is connected to digital pin 4, the infrared sensor is connected to digital pin 3 and the ultrasonic rangefinder is connected to analog pin 1. Now we need to set the mode for the two digital pins that we are using and also initiate the serial monitor. We can do this by adding the following code to the <kbd>setup()</kbd> function:</p>
<pre>Serial.begin(9600);
pinMode(COLLISION_SWITCH, INPUT);
pinMode(IR_SENSOR, INPUT); </pre>
<p>This starts off by initiating the serial monitor and then configures the crash and infrared sensor pins to input so we can read the values. Now we need to add the code to the <kbd>loop()</kbd> function that will read the sensors. Let's start off by looking at how we would read and interrupt the crash sensor:</p>
<pre>int collisionValue = digitalRead(COLLISION_SWITCH); 
if (isnan(collisionValue)) { 
  Serial.println(" Failed to read collision sensor"); 
  return; 
}<br/>if (collisionValue == LOW) { 
  Serial.println("Collision Detected"); <br/>}</pre>
<p>This code starts off by using the <kbd>digitalRead()</kbd> function to read the pin that the crash sensor is connected to and then uses the <kbd>isnan()</kbd> function to verify that the <kbd>digitalRead()</kbd> function returned a correct value. If the value returned by the function is not valid (not a number) then an error message is printed to the serial console the <kbd>return</kbd> statement is called to exit this loop.</p>
<p>If the value returned by the <kbd>digitalRead()</kbd> function is valid, then we check to see if the value is <kbd>LOW</kbd> and if so then an obstacle was detected, and a message is printed to the serial console. Now let's add the code for the infrared sensor:</p>
<pre>int irValue = digitalRead(IR_SENSOR);
if (isnan(irValue)) {
 Serial.println(" Failed to read infrared sensor");
  return;
}
if (irValue == LOW) {
  Serial.println("IR Detected");
} </pre>
<p>This code is exactly the same as the crash sensor except we read the infrared sensor pin and check that value. Now let's add the code for the Ultrasonic range finder:</p>
<pre>int anVolt = analogRead(RANGE_SENSOR);
if (isnan(anVolt)) {
  Serial.println(" Failed to read range sensor");
  return;
}
int mm = anVolt*5;
float inch = mm/25.4;
Serial.println(mm);
Serial.print("MM:   ");
Serial.println(mm);
Serial.print("Inches: ");
Serial.println(inch);
Serial.println("---------------------------");
delay(1000);</pre>
<p>This code starts by using the <kbd>analogRead()</kbd> function to read the pin that the ultrasonic range finder is connected too. We then use the <kbd>isnan()</kbd> function to verify that a correct value was returned.</p>
<p>The distance to the object is then calculated in both millimeters and inches. The numbers used in the calculations documented on the datasheet for the sensor and may be different depending on the model that you are using. Now we will want to put a short delay at the end of the <kbd>loop()</kbd> function to pause the execution.</p>
<p>Now let's run the project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the project</h1>
                </header>
            
            <article>
                
<p>When we run this project, the output should look similar to the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2c55d908-f4ce-468e-be3d-7f6e503ed73c.png" style="width:52.67em;height:31.42em;"/></p>
<p>This screenshot shows that an object tripped the infrared sensor twice, where <kbd>IR Detected</kbd> is printed to the serial console and the crash sensor once, where <kbd>Collision Detected</kbd> was printed to the serial console. It also shows the distance that the rangefinder returned as the closest object.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Challenge</h1>
                </header>
            
            <article>
                
<p>This challenge is going to be a little different than most. There isn't really a project to do; instead, it is a thinking challenge. The challenge is to think about how all three of these sensors work can work together to create an autonomous robot. To do this, think about how all three of the sensors work:</p>
<ol>
<li><strong>Crash sensor</strong>: A digital sensor that is tripped when the sensor bumps into something</li>
<li><strong>Infrared sensor</strong>: A digital sensor that is tripped when something gets close</li>
<li><strong>Ultrasonic range finder</strong>: Analog sensor used to detect how far an object is from the sensor</li>
</ol>
<p>Here are the answers:</p>
<p>The Ultrasonic range finders are the most expensive by far, so I usually use only two of these sensors facing out form the front of the robot. These are used to by the robot to navigate around obstacles. With the ability to tell how far something is from the front of the robot, we can give the robot the logic it needs to decide when to turn and also, with two ultrasonic sensors, the logic to decide which way to turn. We can also use the Ultrasonic sensors to map a room.</p>
<p>The infrared sensors are very inexpensive and can be used on the sides and back to make sure the robot does not bump into anything when it is turning or backing up. Since they are a lot cheaper than the ultrasonic sensors, we can use multiple infrared sensors to make sure we have the full area around the robot covered. We could also use the infrared sensors, facing down, to make sure the robot does not drive off a ledge.</p>
<p>The crash sensors are also very inexpensive and can be used all around to the robot to detect if the robot crashes into anything that the ultrasonic or infrared sensors missed. The biggest problem with the ultrasonic and infrared sensors is how high they are on the robot. If they are too high, then they may miss obstacles that are low to the ground. A crash sensor can be used to detect these.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we saw how to use three sensors that can be used for obstacle avoidance and collision detection. The crash sensor is a digital sensor that can be used to tell when the sensor bumps into something. The infrared obstacle avoidance sensor is also a digital sensor that can tell when the sensor is within a certain distance of an obstacle. The Ultrasonic range finder is an analog sensor that can be used to tell how far an obstacle is from the sensor.</p>
<p>In the next chapter, we will look at some different types of LEDs and see how we can use them in our projects.</p>


            </article>

            
        </section>
    </body></html>