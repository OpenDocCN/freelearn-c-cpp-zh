<html><head></head><body>
<div id="_idContainer089">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">17</span></h1>
<h1 class="chapterTitle" id="_idParaDest-222"><span class="koboSpan" id="kobo.2.1">Libraries and Frameworks</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">While the C++ standard library offers a vast array of containers and algorithms, certain aspects – such as dynamic memory allocation – can pose challenges in constrained environments. </span><span class="koboSpan" id="kobo.3.2">In </span><a href="Chapter_02.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.5.1">, we explored some of these issues and ways to address them. </span><span class="koboSpan" id="kobo.5.2">However, specialized </span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.6.1">libraries, like the </span><strong class="keyWord"><span class="koboSpan" id="kobo.7.1">Embedded Template Library</span></strong><span class="koboSpan" id="kobo.8.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.9.1">ETL</span></strong><span class="koboSpan" id="kobo.10.1">), offer deterministic behavior and fixed memory footprints, making them well suited for embedded systems.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.11.1">Embedded </span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.12.1">applications depend on </span><strong class="keyWord"><span class="koboSpan" id="kobo.13.1">Hardware Abstraction Layers</span></strong><span class="koboSpan" id="kobo.14.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.15.1">HALs</span></strong><span class="koboSpan" id="kobo.16.1">) provided by vendors as C libraries. </span><span class="koboSpan" id="kobo.16.2">In </span><a href="Chapter_12.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.17.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.18.1">, we examined how to use interfaces to decouple application-level C++ code from the underlying C-based hardware interactions. </span><span class="koboSpan" id="kobo.18.2">Wrapping entire HALs in C++ is a lot of work, but luckily, there are projects such as Google’s Pigweed that are tackling exactly that, while offering additional functionality and flexibility for embedded development.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.19.1">In </span><a href="Chapter_11.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.20.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.21.1">, we explored how C++ can perform computations at compile time, reducing memory footprint. </span><span class="koboSpan" id="kobo.21.2">In </span><a href="Chapter_15.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.22.1">Chapter 15</span></em></span></a><span class="koboSpan" id="kobo.23.1">, we learned about the Observer pattern and examined its compile-time </span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.24.1">implementation. </span><span class="koboSpan" id="kobo.24.2">Intel’s </span><strong class="keyWord"><span class="koboSpan" id="kobo.25.1">Compile-time Initialization and Build</span></strong><span class="koboSpan" id="kobo.26.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.27.1">CIB</span></strong><span class="koboSpan" id="kobo.28.1">) elevates these ideas even further, enabling a declarative approach to configuring firmware applications at compile time. </span><span class="koboSpan" id="kobo.28.2">In this chapter, we will go through the following C++ libraries:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.29.1">Standard library</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.30.1">Embedded template library</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.31.1">Pigweed</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.32.1">Compile-time Initialization and Build</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-223"><span class="koboSpan" id="kobo.33.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.34.1">You can try the examples from this chapter in the Renode simulator in the Docker container you set up in </span><a href="Chapter_04.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.35.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.36.1">. </span><span class="koboSpan" id="kobo.36.2">Make sure that the Docker container is running. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.37.1">You can find the files for this chapter on GitHub at </span><a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter17"><span class="url"><span class="koboSpan" id="kobo.38.1">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter17</span></span></a><span class="koboSpan" id="kobo.39.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-224"><span class="koboSpan" id="kobo.40.1">Standard library</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.41.1">The C++ standard </span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.42.1">defines two types of standard library implementation – hosted and freestanding: </span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.43.1">A freestanding </span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.44.1">implementation </span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.45.1">is designed to run without relying on services typically provided by an OS, such as filesystem access or multi-threading support. </span><span class="koboSpan" id="kobo.45.2">As a result, the C++ standard specifies only a limited subset of standard library headers that must be provided by a freestanding implementation.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.46.1">A hosted </span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.47.1">implementation requires a </span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.48.1">globally defined main function, and the environment is responsible for invoking this function at startup. </span><span class="koboSpan" id="kobo.48.2">In a freestanding implementation, the startup routines and the entry point of the program are implementation-defined, allowing developers greater flexibility in specifying the initialization and execution flow of their applications.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.49.1">Although the standard makes a clear distinction between hosted and freestanding implementation in terms of the globally defined main function, the configuration in some examples in this book blurs the line between the two.</span></p>
<h2 class="heading-2" id="_idParaDest-225"><span class="koboSpan" id="kobo.50.1">Freestanding and hosted implementations in GCC</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.51.1">Even though </span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.52.1">we operate in a freestanding </span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.53.1">environment (no OS), some examples in this book use components from the C++ standard library (e.g., </span><code class="inlineCode"><span class="koboSpan" id="kobo.54.1">std::function</span></code><span class="koboSpan" id="kobo.55.1">), which are typically associated with hosted implementations. </span><span class="koboSpan" id="kobo.55.2">This is possible because:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.56.1">As we observed in </span><a href="Chapter_04.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.57.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.58.1">, we set the program entry point in the linker script to </span><code class="inlineCode"><span class="koboSpan" id="kobo.59.1">Reset_Handler</span></code><span class="koboSpan" id="kobo.60.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.61.1">Reset_Handler</span></code><span class="koboSpan" id="kobo.62.1">, implemented in the assembler startup script, performs low-level initialization and explicitly calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.63.1">main</span></code><span class="koboSpan" id="kobo.64.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.65.1">We use nano specs (</span><a href="Chapter_07.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.66.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.67.1">), linking against a size-optimized subset of the C++ standard library. </span><span class="koboSpan" id="kobo.67.2">This allows limited use of hosted features like </span><code class="inlineCode"><span class="koboSpan" id="kobo.68.1">std::function</span></code><span class="koboSpan" id="kobo.69.1"> while avoiding dependencies on an OS.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.70.1">This hybrid </span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.71.1">approach leverages GCC’s flexibility to combine freestanding execution (custom entry point, no OS) with hosted library </span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.72.1">features (standard headers, utilities) in a bare-metal environment.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.73.1">To explicitly request GCC to use a freestanding implementation of the standard library, the compiler flag </span><code class="inlineCode"><span class="koboSpan" id="kobo.74.1">-ffreestanding</span></code><span class="koboSpan" id="kobo.75.1"> should be used. </span><span class="koboSpan" id="kobo.75.2">The C++ standard library provides many components that are “pay only for what you use” and can be very useful even in resource‐constrained environments. </span><span class="koboSpan" id="kobo.75.3">In previous chapters, you’ve already worked with many parts of the standard library, so you have a solid understanding of its capabilities. </span><span class="koboSpan" id="kobo.75.4">Here, we’ll provide an overview of the parts that are best suited for resource‐constrained environments and point out which ones should be used with caution or avoided.</span></p>
<h2 class="heading-2" id="_idParaDest-226"><span class="koboSpan" id="kobo.76.1">Numeric and math</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.77.1">Embedded systems are often employed in automation and process control, requiring precise control </span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.78.1">over numeric types, their ranges, and math </span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.79.1">operations. </span><span class="koboSpan" id="kobo.79.2">The C++ standard library provides the </span><code class="inlineCode"><span class="koboSpan" id="kobo.80.1">&lt;cstdint&gt;</span></code><span class="koboSpan" id="kobo.81.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.82.1">&lt;limits&gt;</span></code><span class="koboSpan" id="kobo.83.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.84.1">&lt;cmath&gt;</span></code><span class="koboSpan" id="kobo.85.1"> headers to define fixed-width integers, query numeric limits, and perform mathematical computations, helping ensure predictable behavior, portability, and efficiency in resource-constrained environments.</span></p>
<h3 class="heading-3" id="_idParaDest-227"><span class="koboSpan" id="kobo.86.1">&lt;cstdint&gt;</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.87.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.88.1">&lt;cstdint&gt;</span></code><span class="koboSpan" id="kobo.89.1"> header </span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.90.1">provides fixed-width integer types such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.91.1">std::int8_t</span></code><span class="koboSpan" id="kobo.92.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.93.1">std::uint32_t</span></code><span class="koboSpan" id="kobo.94.1">, and other well-known C types defined in </span><code class="inlineCode"><span class="koboSpan" id="kobo.95.1">stdint.h</span></code><span class="koboSpan" id="kobo.96.1">. </span><span class="koboSpan" id="kobo.96.2">These types are </span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.97.1">useful in embedded contexts where integer size and bit width are important for direct hardware register access, predictable overflow behavior, and memory usage considerations. </span><span class="koboSpan" id="kobo.97.2">By using them, you explicitly document your intention for a variable’s size, thereby improving code portability and preventing potential surprises when moving between platforms with different native integer widths.</span></p>
<h3 class="heading-3" id="_idParaDest-228"><span class="koboSpan" id="kobo.98.1">&lt;limits&gt;</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.99.1">The header </span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.100.1">provides the </span><code class="inlineCode"><span class="koboSpan" id="kobo.101.1">std::numeric_limits</span></code><span class="koboSpan" id="kobo.102.1"> template, which describes </span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.103.1">properties of fundamental numeric types (like minimum and maximum values, sign, and precision). </span><span class="koboSpan" id="kobo.103.2">This is especially useful in embedded contexts for handling overflow. </span><span class="koboSpan" id="kobo.103.3">Typical usage occurs at compile-time or through trivial inlining by the compiler, resulting in minimal runtime overhead. </span><span class="koboSpan" id="kobo.103.4">By using functions like </span><code class="inlineCode"><span class="koboSpan" id="kobo.104.1">std::numeric_limits::max()</span></code><span class="koboSpan" id="kobo.105.1">, you avoid scattering magic constants or architecture-specific assumptions, aiding portability and maintainability.</span></p>
<h3 class="heading-3" id="_idParaDest-229"><span class="koboSpan" id="kobo.106.1">&lt;cmath&gt;</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.107.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.108.1">&lt;cmath&gt;</span></code><span class="koboSpan" id="kobo.109.1"> header </span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.110.1">provides standard math functions such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.111.1">std::sin</span></code><span class="koboSpan" id="kobo.112.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.113.1">std::cos</span></code><span class="koboSpan" id="kobo.114.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.115.1">std::sqrt</span></code><span class="koboSpan" id="kobo.116.1">, and more. </span><span class="koboSpan" id="kobo.116.2">In embedded environments, especially those without </span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.117.1">floating-point hardware, these functions can be relatively expensive in terms of both runtime performance and code size. </span><span class="koboSpan" id="kobo.117.2">Carefully consider whether you really need floating-point math, and if so, whether approximations or fixed-point routines might be sufficient and more efficient.</span></p>
<h2 class="heading-2" id="_idParaDest-230"><span class="koboSpan" id="kobo.118.1">Containers and algorithms</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.119.1">Embedded systems </span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.120.1">often manage structured </span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.121.1">data and require efficient ways to process it under tight resource constraints. </span><span class="koboSpan" id="kobo.121.2">The C++ standard library offers container and algorithm headers such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.122.1">&lt;array&gt;</span></code><span class="koboSpan" id="kobo.123.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.124.1">&lt;span&gt;</span></code><span class="koboSpan" id="kobo.125.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.126.1">&lt;algorithm&gt;</span></code><span class="koboSpan" id="kobo.127.1"> to organize data and perform common operations like searching, sorting, and transforming, enabling more readable and maintainable code.</span></p>
<h3 class="heading-3" id="_idParaDest-231"><span class="koboSpan" id="kobo.128.1">std::array</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.129.1">The only fixed-size </span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.130.1">container in the standard library </span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.131.1">that avoids dynamic allocation is </span><code class="inlineCode"><span class="koboSpan" id="kobo.132.1">std::array</span></code><span class="koboSpan" id="kobo.133.1">. </span><span class="koboSpan" id="kobo.133.2">We covered it in </span><a href="Chapter_01.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.134.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.135.1">, when we discussed generic types. </span><span class="koboSpan" id="kobo.135.2">In the same chapter, we based the ring buffer implementation on </span><code class="inlineCode"><span class="koboSpan" id="kobo.136.1">std::array</span></code><span class="koboSpan" id="kobo.137.1">, which allowed us to create ring buffers of different types and sizes using the same generic code.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.138.1">std::array</span></code><span class="koboSpan" id="kobo.139.1"> is typically implemented as a wrapper around a C-style array. </span><span class="koboSpan" id="kobo.139.2">Besides being a generic type, it also offers the </span><code class="inlineCode"><span class="koboSpan" id="kobo.140.1">at</span></code><span class="koboSpan" id="kobo.141.1"> method for index-based access with runtime bounds checking, making it a safer alternative to raw arrays. </span><span class="koboSpan" id="kobo.141.2">If an out-of-bounds index is requested, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.142.1">at</span></code><span class="koboSpan" id="kobo.143.1"> method will throw an exception. </span><span class="koboSpan" id="kobo.143.2">If exceptions are disabled, it may call </span><code class="inlineCode"><span class="koboSpan" id="kobo.144.1">std::terminate</span></code><span class="koboSpan" id="kobo.145.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.146.1">std::abort</span></code><span class="koboSpan" id="kobo.147.1">, depending on the library implementation. </span><span class="koboSpan" id="kobo.147.2">These behaviors should be handled according to your system requirements by implementing appropriate terminate and signal handlers.</span></p>
<h3 class="heading-3" id="_idParaDest-232"><span class="koboSpan" id="kobo.148.1">std:: priority_queue</span></h3>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.149.1">std::priority_queue</span></code><span class="koboSpan" id="kobo.150.1"> is a container adapter that provides priority queue functionality. </span><span class="koboSpan" id="kobo.150.2">By default, it </span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.151.1">uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.152.1">std::vector</span></code><span class="koboSpan" id="kobo.153.1"> as the </span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.154.1">underlying container. </span><span class="koboSpan" id="kobo.154.2">However, as shown in </span><a href="Chapter_14.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.155.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.156.1">, you can substitute it with </span><code class="inlineCode"><span class="koboSpan" id="kobo.157.1">etl::vector</span></code><span class="koboSpan" id="kobo.158.1"> from ETL, avoiding issues with dynamic memory allocation.</span></p>
<h3 class="heading-3" id="_idParaDest-233"><span class="koboSpan" id="kobo.159.1">std:: span</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.160.1">As shown in </span><a href="Chapter_09.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.161.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.162.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.163.1">std::span</span></code><span class="koboSpan" id="kobo.164.1"> is a lightweight, non-owning wrapper around a contiguous </span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.165.1">sequence of objects, where the first element </span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.166.1">is at position 0. </span><span class="koboSpan" id="kobo.166.2">It provides essential functionality such as the </span><code class="inlineCode"><span class="koboSpan" id="kobo.167.1">size()</span></code><span class="koboSpan" id="kobo.168.1"> method, </span><code class="inlineCode"><span class="koboSpan" id="kobo.169.1">operator[]</span></code><span class="koboSpan" id="kobo.170.1"> for element access, and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.171.1">begin()</span></code><span class="koboSpan" id="kobo.172.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.173.1">end()</span></code><span class="koboSpan" id="kobo.174.1"> iterators, allowing it to integrate seamlessly with standard library algorithms.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.175.1">std::span</span></code><span class="koboSpan" id="kobo.176.1"> can be constructed from C-style arrays as well as containers like </span><code class="inlineCode"><span class="koboSpan" id="kobo.177.1">std::array</span></code><span class="koboSpan" id="kobo.178.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.179.1">std::vector</span></code><span class="koboSpan" id="kobo.180.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.181.1">etl::vector</span></code><span class="koboSpan" id="kobo.182.1">. </span><span class="koboSpan" id="kobo.182.2">This makes it a practical alternative to using separate pointer and size parameters, which is especially useful when interfacing C++ code with C libraries such as those used in HAL.</span></p>
<h3 class="heading-3" id="_idParaDest-234"><span class="koboSpan" id="kobo.183.1">Iterators</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.184.1">Iterators are abstractions that act like generalized pointers, providing a uniform way to traverse and </span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.185.1">access elements within a container. </span><span class="koboSpan" id="kobo.185.2">For example, standard library containers implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.186.1">begin()</span></code><span class="koboSpan" id="kobo.187.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.188.1">end()</span></code><span class="koboSpan" id="kobo.189.1"> methods, which return </span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.190.1">iterators marking the start and one-past-the-end of their sequence. </span><span class="koboSpan" id="kobo.190.2">This consistent interface allows algorithms to work generically over different container types, enhancing code reusability and clarity.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.191.1">Let us go through the following example using </span><code class="inlineCode"><span class="koboSpan" id="kobo.192.1">std::array</span></code><span class="koboSpan" id="kobo.193.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.194.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.195.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.196.1">&lt;array&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.197.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.198.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.199.1">&lt;algorithm&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.200.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.201.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.202.1">&lt;cstdio&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.203.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.204.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.205.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.206.1">{
    std::array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.207.1">int</span></span><span class="koboSpan" id="kobo.208.1">, 5&gt; arr = {</span><span class="hljs-number"><span class="koboSpan" id="kobo.209.1">5</span></span><span class="koboSpan" id="kobo.210.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.211.1">3</span></span><span class="koboSpan" id="kobo.212.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.213.1">4</span></span><span class="koboSpan" id="kobo.214.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.215.1">1</span></span><span class="koboSpan" id="kobo.216.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.217.1">2</span></span><span class="koboSpan" id="kobo.218.1">};
    std::array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.219.1">int</span></span><span class="koboSpan" id="kobo.220.1">, 5&gt;::iterator start = arr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.221.1">begin</span></span><span class="koboSpan" id="kobo.222.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.223.1">auto</span></span><span class="koboSpan" id="kobo.224.1"> finish = arr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.225.1">end</span></span><span class="koboSpan" id="kobo.226.1">();
    std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.227.1">sort</span></span><span class="koboSpan" id="kobo.228.1">(start, finish);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.229.1">for</span></span><span class="koboSpan" id="kobo.230.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.231.1">auto</span></span><span class="koboSpan" id="kobo.232.1"> it = arr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.233.1">begin</span></span><span class="koboSpan" id="kobo.234.1">(); it != arr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.235.1">end</span></span><span class="koboSpan" id="kobo.236.1">(); ++it) {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.237.1">printf</span></span><span class="koboSpan" id="kobo.238.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.239.1">"%d "</span></span><span class="koboSpan" id="kobo.240.1">, *it);
    }
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.241.1">printf</span></span><span class="koboSpan" id="kobo.242.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.243.1">"\n"</span></span><span class="koboSpan" id="kobo.244.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.245.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.246.1">0</span></span><span class="koboSpan" id="kobo.247.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.248.1">This example </span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.249.1">demonstrates how to use iterators with a standard library container:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.250.1">The iterator </span><code class="inlineCode"><span class="koboSpan" id="kobo.251.1">start</span></code><span class="koboSpan" id="kobo.252.1"> is explicitly declared as </span><code class="inlineCode"><span class="koboSpan" id="kobo.253.1">std::array&lt;int, 5&gt;::iterator</span></code><span class="koboSpan" id="kobo.254.1"> to illustrate the full type name, while the iterator </span><code class="inlineCode"><span class="koboSpan" id="kobo.255.1">finish</span></code><span class="koboSpan" id="kobo.256.1"> is declared using </span><code class="inlineCode"><span class="koboSpan" id="kobo.257.1">auto</span></code><span class="koboSpan" id="kobo.258.1"> for conciseness, allowing the compiler to deduce its type.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.259.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.260.1">std::sort</span></code><span class="koboSpan" id="kobo.261.1"> algorithm is applied using the iterators </span><code class="inlineCode"><span class="koboSpan" id="kobo.262.1">start</span></code><span class="koboSpan" id="kobo.263.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.264.1">finish</span></code><span class="koboSpan" id="kobo.265.1">, obtained from </span><code class="inlineCode"><span class="koboSpan" id="kobo.266.1">arr.begin()</span></code><span class="koboSpan" id="kobo.267.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.268.1">arr.end()</span></code><span class="koboSpan" id="kobo.269.1">, to sort the array in ascending order.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.270.1">The loop uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.271.1">auto</span></code><span class="koboSpan" id="kobo.272.1"> to declare the iterator </span><code class="inlineCode"><span class="koboSpan" id="kobo.273.1">it</span></code><span class="koboSpan" id="kobo.274.1">, which makes the code more concise. </span><span class="koboSpan" id="kobo.274.2">The loop traverses the sorted array, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.275.1">printf</span></code><span class="koboSpan" id="kobo.276.1"> is used to print each element.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.277.1">Iterators are </span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.278.1">used to traverse containers. </span><span class="koboSpan" id="kobo.278.2">They not only promote generic programming but also make it easy to switch container types without changing the algorithmic logic.</span></p>
<h3 class="heading-3" id="_idParaDest-235"><span class="koboSpan" id="kobo.279.1">Algorithms</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.280.1">Algorithms from the standard library offer a consistent way to solve common problems across </span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.281.1">different containers, making the code more </span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.282.1">expressive and easier to maintain. </span><span class="koboSpan" id="kobo.282.2">They allow you to perform operations like searching, sorting, copying, and accumulating data using a uniform interface. </span><span class="koboSpan" id="kobo.282.3">Some of the most used algorithms are listed here:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.283.1">std::sort</span></code><span class="koboSpan" id="kobo.284.1">: Sorts a range of elements in ascending order by default, using the less-than operator for comparison. </span><span class="koboSpan" id="kobo.284.2">It can also accept a custom comparator to sort based on different criteria, such as descending order or a specific object property.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.285.1">std::find</span></code><span class="koboSpan" id="kobo.286.1">: Searches for the first occurrence of a given value in a range and returns an iterator to it. </span><span class="koboSpan" id="kobo.286.2">If the value is not found, it returns the end iterator, signaling that the search failed.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.287.1">std::for_each</span></code><span class="koboSpan" id="kobo.288.1">: Applies a specified function or lambda to each element in a range.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.289.1">std::copy</span></code><span class="koboSpan" id="kobo.290.1">: Copies the elements of one range into another destination range.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.291.1">std::copy_if</span></code><span class="koboSpan" id="kobo.292.1">: Copies only elements that satisfy a specified predicate, making it useful for filtering data as you copy.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.293.1">std::min</span></code><span class="koboSpan" id="kobo.294.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.295.1">std::max</span></code><span class="koboSpan" id="kobo.296.1">: Return the smaller or larger of two values, respectively, using the less-than </span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.297.1">operator by default (or a provided comparison function). </span><span class="koboSpan" id="kobo.297.2">They’re handy for quick comparisons where you just need the minimum or maximum of two values.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.298.1">std::min_element</span></code><span class="koboSpan" id="kobo.299.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.300.1">std::max_element</span></code><span class="koboSpan" id="kobo.301.1">: Return an iterator to the smallest or largest </span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.302.1">element in a range. </span><span class="koboSpan" id="kobo.302.2">These are useful when you need to find the position of an extreme value in a container (instead of comparing just two values).</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.303.1">std::accumulate</span></code><span class="koboSpan" id="kobo.304.1">: Iterates over a range and combines the elements with an initial value using a binary operation (default is addition). </span><span class="koboSpan" id="kobo.304.2">This allows for summing values, computing products, or performing any custom aggregation you define.</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-236"><span class="koboSpan" id="kobo.305.1">Template metaprogramming</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.306.1">As discussed in </span><a href="Chapter_08.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.307.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.308.1">, C++ type traits are compile-time predicates and transformations that allow </span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.309.1">the compiler to enforce constraints based on a type’s properties. </span><span class="koboSpan" id="kobo.309.2">They are used for writing generic, robust code without incurring </span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.310.1">runtime overhead. </span><span class="koboSpan" id="kobo.310.2">In </span><a href="Chapter_12.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.311.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.312.1">, we used type traits to create type-safe register access, preventing invalid type usage at compile time and reducing the risk of subtle errors.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.313.1">Here are some concrete type traits we’ve utilized in the chapters mentioned in this section:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.314.1">std::enable_if</span></code><span class="koboSpan" id="kobo.315.1">: Enables or disables function templates based on a Boolean compile-time expression</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.316.1">std::is_same</span></code><span class="koboSpan" id="kobo.317.1">: Checks if two types are exactly the same</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.318.1">std::is_enum</span></code><span class="koboSpan" id="kobo.319.1">: Checks if a type is an enumeration type</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.320.1">std::underlying_type</span></code><span class="koboSpan" id="kobo.321.1">: Retrieves the underlying integer type of an enum</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.322.1">std::is_arithmetic</span></code><span class="koboSpan" id="kobo.323.1">: Checks if a type is an arithmetic type (integral or floating-point)</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.324.1">std::is_integral</span></code><span class="koboSpan" id="kobo.325.1">: Checks if a type is an integral type</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.326.1">std::is_floating_point</span></code><span class="koboSpan" id="kobo.327.1">: Checks if a type is a floating-point type</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-237"><span class="koboSpan" id="kobo.328.1">Parts of the standard library to avoid in embedded applications</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.329.1">Many containers from the standard library, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.330.1">std::vector</span></code><span class="koboSpan" id="kobo.331.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.332.1">std::list</span></code><span class="koboSpan" id="kobo.333.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.334.1">std::string</span></code><span class="koboSpan" id="kobo.335.1">, use dynamic memory allocation. </span><span class="koboSpan" id="kobo.335.2">If dynamic memory allocation is not allowed in your </span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.336.1">embedded application, these should be avoided.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.337.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.338.1">iostream</span></code><span class="koboSpan" id="kobo.339.1"> library, included with header </span><code class="inlineCode"><span class="koboSpan" id="kobo.340.1">&lt;iostream&gt;,</span></code><span class="koboSpan" id="kobo.341.1"> requires significant memory resources and also relies on dynamic allocation. </span><span class="koboSpan" id="kobo.341.2">That’s why we used the </span><code class="inlineCode"><span class="koboSpan" id="kobo.342.1">&lt;cstdio&gt;</span></code><span class="koboSpan" id="kobo.343.1"> header and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.344.1">printf</span></code><span class="koboSpan" id="kobo.345.1"> function for console output.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.346.1">In </span><a href="Chapter_10.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.347.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.348.1">, we covered </span><code class="inlineCode"><span class="koboSpan" id="kobo.349.1">std::function</span></code><span class="koboSpan" id="kobo.350.1"> from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.351.1">&lt;functional&gt;</span></code><span class="koboSpan" id="kobo.352.1"> header. </span><span class="koboSpan" id="kobo.352.2">There, we outlined that in some scenarios, </span><code class="inlineCode"><span class="koboSpan" id="kobo.353.1">std::function</span></code><span class="koboSpan" id="kobo.354.1"> can use dynamic memory allocation, meaning if used, it should be used with caution. </span><span class="koboSpan" id="kobo.354.2">Note that </span><code class="inlineCode"><span class="koboSpan" id="kobo.355.1">std::function</span></code><span class="koboSpan" id="kobo.356.1"> is not available in a freestanding implementation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.357.1">Next, we will give a short overview of ETL that compliments the standard library in the context of restricted embedded environments.</span></p>
<h1 class="heading-1" id="_idParaDest-238"><span class="koboSpan" id="kobo.358.1">Embedded template library</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.359.1">In </span><a href="Chapter_02.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.360.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.361.1">, we saw that </span><code class="inlineCode"><span class="koboSpan" id="kobo.362.1">std::vector</span></code><span class="koboSpan" id="kobo.363.1"> uses dynamic memory allocation by default. </span><span class="koboSpan" id="kobo.363.2">We also saw that </span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.364.1">we can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.365.1">std:: polymorphic_allocator</span></code><span class="koboSpan" id="kobo.366.1"> and a monotonic buffer to make it use statically allocated memory. </span><span class="koboSpan" id="kobo.366.2">This approach is still not bulletproof as </span><code class="inlineCode"><span class="koboSpan" id="kobo.367.1">std::vector</span></code><span class="koboSpan" id="kobo.368.1"> in some cases can resort to dynamic memory allocation even with this approach.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.369.1">To address some of the challenges posed by the standard library in embedded contexts, ETL provides a set of templated containers and algorithms that closely mimic the interfaces of standard library counterparts but are tailored for systems with limited resources.</span></p>
<h2 class="heading-2" id="_idParaDest-239"><span class="koboSpan" id="kobo.370.1">Fixed-size containers</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.371.1">One of the primary advantages of ETL is that its containers (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.372.1">etl::vector</span></code><span class="koboSpan" id="kobo.373.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.374.1">etl::list</span></code><span class="koboSpan" id="kobo.375.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.376.1">etl::string</span></code><span class="koboSpan" id="kobo.377.1">, and others) allow you to specify a fixed maximum size at compile time. </span><span class="koboSpan" id="kobo.377.2">Container implementations ensure that no dynamic memory allocation is performed at runtime as </span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.378.1">memory is reserved up front as atomic or static storage.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.379.1">As ETL containers are designed to mimic standard library containers, and they implement iterators, they can be used with most algorithms and container adapters from the standard library. </span><span class="koboSpan" id="kobo.379.2">This allows us to leverage components from the standard library without worrying about dynamic allocation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.380.1">ETL also offers </span><code class="inlineCode"><span class="koboSpan" id="kobo.381.1">etl::array</span></code><span class="koboSpan" id="kobo.382.1"> for platforms that do not support C++11, since </span><code class="inlineCode"><span class="koboSpan" id="kobo.383.1">std::array</span></code><span class="koboSpan" id="kobo.384.1"> was introduced in C++11.</span></p>
<h2 class="heading-2" id="_idParaDest-240"><span class="koboSpan" id="kobo.385.1">Storing a callable with etl::delegate</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.386.1">As shown in </span><a href="Chapter_14.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.387.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.388.1">, you </span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.389.1">can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.390.1">etl::delegate</span></code><span class="koboSpan" id="kobo.391.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.392.1">std::function</span></code><span class="koboSpan" id="kobo.393.1"> to store a callable. </span><span class="koboSpan" id="kobo.393.2">However, </span><code class="inlineCode"><span class="koboSpan" id="kobo.394.1">etl::delegate</span></code><span class="koboSpan" id="kobo.395.1"> is non-owning, so you must handle potential dangling references carefully.</span></p>
<h2 class="heading-2" id="_idParaDest-241"><span class="koboSpan" id="kobo.396.1">Other utilities provided by ETL</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.397.1">Besides fixed-size containers and </span><code class="inlineCode"><span class="koboSpan" id="kobo.398.1">etl::delegate</span></code><span class="koboSpan" id="kobo.399.1">, ETL also provides utilities such as a messaging framework – a collection of messages, message routers, message buses, and finite state machines. </span><span class="koboSpan" id="kobo.399.2">It also offers CRC calculations, checksums, and hash functions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.400.1">ETL allows you </span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.401.1">to configure error handling. </span><span class="koboSpan" id="kobo.401.2">It can be configured to throw exceptions or send errors to the user-defined handler. </span><span class="koboSpan" id="kobo.401.3">This allows greater flexibility and project-based configuration depending on system requirements.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.402.1">You can </span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.403.1">learn more about ETL at the website </span><a href="https://www.etlcpp.com/"><span class="url"><span class="koboSpan" id="kobo.404.1">https://www.etlcpp.com/</span></span></a><span class="koboSpan" id="kobo.405.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.406.1">Next, we will discuss Pigweed – a collection of lightweight, modular C++ libraries for embedded systems, developed by Google, offering components like logging, assertions, and Bluetooth connectivity to simplify development and improve code reuse.</span></p>
<h1 class="heading-1" id="_idParaDest-242"><span class="koboSpan" id="kobo.407.1">Pigweed</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.408.1">One of the biggest challenges in embedded systems development is portability. </span><span class="koboSpan" id="kobo.408.2">For code to be truly portable, it must depend on interfaces. </span><span class="koboSpan" id="kobo.408.3">To run it on different hardware targets, someone </span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.409.1">needs to implement those interfaces on different targets. </span><span class="koboSpan" id="kobo.409.2">Maintaining consistent interfaces across various projects and devices can be difficult. </span><span class="koboSpan" id="kobo.409.3">Google’s Pigweed project aims to solve this by providing software modules for embedded applications, with hardware interfaces already implemented for many targets.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.410.1">Pigweed is intended for complex projects and large-scale teams. </span><span class="koboSpan" id="kobo.410.2">Besides the hardware interfaces, it also:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.411.1">Packs software modules </span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.412.1">built on top of them, such </span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.413.1">as logging, serial communication (SPI, I2C, and UART), Bluetooth </span><strong class="keyWord"><span class="koboSpan" id="kobo.414.1">Host Controller Interface</span></strong><span class="koboSpan" id="kobo.415.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.416.1">HCI</span></strong><span class="koboSpan" id="kobo.417.1">), interactive console, </span><strong class="keyWord"><span class="koboSpan" id="kobo.418.1">Remote Procedure Call</span></strong><span class="koboSpan" id="kobo.419.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.420.1">RPC</span></strong><span class="koboSpan" id="kobo.421.1">) system, and more.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.422.1">Provides embedding-friendly alternatives to standard library components: fixed-size strings and containers.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.423.1">Manages the entire toolchain out of the box and simplifies setting up your development environment.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.424.1">Provides an entire framework – </span><code class="inlineCode"><span class="koboSpan" id="kobo.425.1">pw_system</span></code><span class="koboSpan" id="kobo.426.1"> – which pulls together many modules across Pigweed to construct a working system with RPC, logging, and more.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.427.1">As you can see, Pigweed is </span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.428.1">not only a library – it is an entire development ecosystem. </span><span class="koboSpan" id="kobo.428.2">It can be used as a framework, but you can also cherry-pick individual modules that suit your needs. </span><span class="koboSpan" id="kobo.428.3">As stated </span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.429.1">on the documentation website – </span><a href="https://pigweed.dev/"><span class="url"><span class="koboSpan" id="kobo.430.1">https://pigweed.dev/</span></span></a><span class="koboSpan" id="kobo.431.1"> – Pigweed is still in its early stages; some modules are still in development stages, while some are stable and used on devices that are already on the market. </span><span class="koboSpan" id="kobo.431.2">As with any library, you need to evaluate it for potential use in your projects.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.432.1">We’ll go through Pigweed’s Sense tutorial to demonstrate some of its capabilities – mainly the interactive console and </span><strong class="screenText"><span class="koboSpan" id="kobo.433.1">RPC</span></strong><span class="koboSpan" id="kobo.434.1"> system.</span></p>
<h2 class="heading-2" id="_idParaDest-243"><span class="koboSpan" id="kobo.435.1">Pigweed’s Sense tutorial</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.436.1">The Sense project is a demo project that utilizes many Pigweed components and shows how they work together.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.437.1">Sense is a </span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.438.1">simplified version of an air quality sensor that only includes some of the functions of a full product. </span><span class="koboSpan" id="kobo.438.2">The goal is to give you practical experience with working with Pigweed by following these steps:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.439.1">First, make sure the Docker daemon is running. </span><span class="koboSpan" id="kobo.439.2">Start a Docker image in network host mode and attach it to Bash. </span><span class="koboSpan" id="kobo.439.3">You can use the following commands in a Linux environment:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.440.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.441.1">sudo</span></span><span class="language-bash"><span class="koboSpan" id="kobo.442.1"> systemctl start docker</span></span>
<span class="hljs-con-meta"><span class="koboSpan" id="kobo.443.1">$ </span></span><span class="language-bash"><span class="koboSpan" id="kobo.444.1">docker run --network=host -d -it --name dev_env mahmutbegovic/cpp_in_embedded_systems</span></span>
<span class="hljs-con-meta"><span class="koboSpan" id="kobo.445.1">$ </span></span><span class="language-bash"><span class="koboSpan" id="kobo.446.1">docker </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.447.1">exec</span></span><span class="language-bash"><span class="koboSpan" id="kobo.448.1"> -it dev_env /bin/bash</span></span>
</code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.449.1">For the Windows-based host, use the following command to forward the ports needed to run the tutorial:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.450.1">$ </span></span><span class="language-bash"><span class="koboSpan" id="kobo.451.1">docker run -d -it --name dev_env -p 33000:33000 -p 8080:8080 mahmutbegovic/cpp_in_embedded_systems</span></span>
</code></pre>
<ol>
<li class="numberedList" value="2"><span class="koboSpan" id="kobo.452.1">Next, clone the Sense repo:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.453.1">$ </span></span><span class="language-bash"><span class="koboSpan" id="kobo.454.1">git </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.455.1">clone</span></span><span class="language-bash"><span class="koboSpan" id="kobo.456.1"> https://pigweed.googlesource.com/pigweed/showcase/sense</span></span>
</code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.457.1">Next, start Visual Studio Code, attach to the running container, and open the </span><code class="inlineCode"><span class="koboSpan" id="kobo.458.1">/workspace/sense</span></code><span class="koboSpan" id="kobo.459.1"> folder. </span><span class="koboSpan" id="kobo.459.2">If you see a pop-up message in </span><strong class="screenText"><span class="koboSpan" id="kobo.460.1">Visual Studio Code</span></strong><span class="koboSpan" id="kobo.461.1"> recommending the installation of the Pigweed extension, accept it; otherwise, go to </span><strong class="screenText"><span class="koboSpan" id="kobo.462.1">Extensions</span></strong><span class="koboSpan" id="kobo.463.1">, search for </span><code class="inlineCode"><span class="koboSpan" id="kobo.464.1">Pigweed</span></code><span class="koboSpan" id="kobo.465.1">, and install it.</span></li>
</ol>
<figure class="mediaobject"><span class="koboSpan" id="kobo.466.1"><img alt="Figure 17.1 – Visual Studio Code extension" src="../Images/B22402_17_1.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.467.1">Figure 17</span></span><span class="koboSpan" id="kobo.468.1">.1 – Visual Studio Code extension</span></p>
<p class="normal"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.469.1">Figure 17</span></em></span><em class="italic"><span class="koboSpan" id="kobo.470.1">.1</span></em><span class="koboSpan" id="kobo.471.1"> depicts the Visual Studio Code Pigweed extension.</span></p>
<ol>
<li class="numberedList" value="4"><span class="koboSpan" id="kobo.472.1">After the </span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.473.1">installation of the extension, go to Explorer view and expand the </span><strong class="screenText"><span class="koboSpan" id="kobo.474.1">BAZEL BUILD TARGETS</span></strong><span class="koboSpan" id="kobo.475.1"> node. </span><span class="koboSpan" id="kobo.475.2">Click on the </span><strong class="screenText"><span class="koboSpan" id="kobo.476.1">Refresh Target List</span></strong><span class="koboSpan" id="kobo.477.1"> button.</span></li>
</ol>
<figure class="mediaobject"><span class="koboSpan" id="kobo.478.1"><img alt="Figure 17.2 – BAZEL BUILD TARGETS node" src="../Images/B22402_17_2.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.479.1">Figure 17</span></span><span class="koboSpan" id="kobo.480.1">.2 – BAZEL BUILD TARGETS node</span></p>
<p class="normal"><span class="koboSpan" id="kobo.481.1">Refreshing the target list can take between 30 seconds and a couple of minutes. </span><span class="koboSpan" id="kobo.481.2">Pigweed uses </span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.482.1">Bazel for build automation. </span><span class="koboSpan" id="kobo.482.2">The refreshed target list should look similar to the following:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.483.1"><img alt="Figure 17.3 – BAZEL BUILD TARGETS" src="../Images/B22402_17_3.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.484.1">Figure 17</span></span><span class="koboSpan" id="kobo.485.1">.3 – BAZEL BUILD TARGETS</span></p>
<p class="normal"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.486.1">Figure 17</span></em></span><em class="italic"><span class="koboSpan" id="kobo.487.1">.3</span></em><span class="koboSpan" id="kobo.488.1"> depicts Bazel build targets.</span></p>
<ol>
<li class="numberedList" value="5"><span class="koboSpan" id="kobo.489.1">Next, expand the </span><strong class="screenText"><span class="koboSpan" id="kobo.490.1">//apps/blinky</span></strong><span class="koboSpan" id="kobo.491.1"> node.</span></li>
</ol>
<figure class="mediaobject"><span class="koboSpan" id="kobo.492.1"><img alt="Figure 17.4 – //apps/blinky targets" src="../Images/B22402_17_4.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.493.1">Figure 17</span></span><span class="koboSpan" id="kobo.494.1">.4 – //apps/blinky targets</span></p>
<ol>
<li class="numberedList" value="6"><span class="koboSpan" id="kobo.495.1">Now, we will </span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.496.1">build a version of the app that runs on the host. </span><span class="koboSpan" id="kobo.496.2">Right-click </span><strong class="screenText"><span class="koboSpan" id="kobo.497.1">simulator_blinky (host_device_simulator_binary)</span></strong><span class="koboSpan" id="kobo.498.1"> and then click </span><strong class="screenText"><span class="koboSpan" id="kobo.499.1">Build Target</span></strong><span class="koboSpan" id="kobo.500.1">. </span><span class="koboSpan" id="kobo.500.2">The build can take around 10 minutes. </span><span class="koboSpan" id="kobo.500.3">When completed, you should see a message similar to this one:</span></li>
</ol>
<figure class="mediaobject"><span class="koboSpan" id="kobo.501.1"><img alt="Figure 17.5 – Successful build" src="../Images/B22402_17_5.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.502.1">Figure 17</span></span><span class="koboSpan" id="kobo.503.1">.5 – Successful build</span></p>
<ol>
<li class="numberedList" value="7"><span class="koboSpan" id="kobo.504.1">After a successful build, we will start the app. </span><span class="koboSpan" id="kobo.504.2">Right-click</span><strong class="screenText"><span class="koboSpan" id="kobo.505.1"> simulator_blinky (host_device_simulator_binary)</span></strong><span class="koboSpan" id="kobo.506.1"> and then </span><strong class="screenText"><span class="koboSpan" id="kobo.507.1">Run Target</span></strong><span class="koboSpan" id="kobo.508.1">. </span><span class="koboSpan" id="kobo.508.2">If successful, you should see the following message in the terminal: </span><strong class="screenText"><span class="koboSpan" id="kobo.509.1">Awaiting connection on port 33000</span></strong><span class="koboSpan" id="kobo.510.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.511.1">Next, right-click </span><strong class="screenText"><span class="koboSpan" id="kobo.512.1">simulator_console (native_binary)</span></strong><span class="koboSpan" id="kobo.513.1"> and then </span><strong class="screenText"><span class="koboSpan" id="kobo.514.1">Run Target</span></strong><span class="koboSpan" id="kobo.515.1">. </span><span class="koboSpan" id="kobo.515.2">This will build a </span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.516.1">console and connect it to the running simulator. </span><span class="koboSpan" id="kobo.516.2">If successful, you should see the following screen:</span></li>
</ol>
<figure class="mediaobject"><span class="koboSpan" id="kobo.517.1"><img alt="Figure 17.6 – Interactive console running in terminal view" src="../Images/B22402_17_6.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.518.1">Figure 17</span></span><span class="koboSpan" id="kobo.519.1">.6 – Interactive console running in terminal view</span></p>
<p class="normal"><span class="koboSpan" id="kobo.520.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.521.1">Figure 17</span></em></span><em class="italic"><span class="koboSpan" id="kobo.522.1">.6</span></em><span class="koboSpan" id="kobo.523.1">, you can see the interactive console running in the terminal view in Visual Studio Code.</span></p>
<ol>
<li class="numberedList" value="9"><span class="koboSpan" id="kobo.524.1">To make the console easier to work with, right-click on </span><strong class="screenText"><span class="koboSpan" id="kobo.525.1">Run //apps/blinky:simulator_console</span></strong><span class="koboSpan" id="kobo.526.1"> and select </span><strong class="screenText"><span class="koboSpan" id="kobo.527.1">Move Terminal into New Window</span></strong><span class="koboSpan" id="kobo.528.1">. </span><span class="koboSpan" id="kobo.528.2">This will move the console into a separate window, as shown in this image:</span></li>
</ol>
<figure class="mediaobject"><span class="koboSpan" id="kobo.529.1"><img alt="Figure 17.7 – Interactive console running in a separate window" src="../Images/B22402_17_7.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.530.1">Figure 17</span></span><span class="koboSpan" id="kobo.531.1">.7 – Interactive console running in a separate window</span></p>
<p class="normal"><span class="koboSpan" id="kobo.532.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.533.1">Figure 17</span></em></span><em class="italic"><span class="koboSpan" id="kobo.534.1">.7</span></em><span class="koboSpan" id="kobo.535.1">, in the top-right pane, </span><strong class="screenText"><span class="koboSpan" id="kobo.536.1">Device Logs</span></strong><span class="koboSpan" id="kobo.537.1">, we can see logs coming from the simulated device (app running on the host). </span><span class="koboSpan" id="kobo.537.2">It sends </span><strong class="screenText"><span class="koboSpan" id="kobo.538.1">LED blinking</span></strong><span class="koboSpan" id="kobo.539.1"> messages every second.</span></p>
<ol>
<li class="numberedList" value="10"><span class="koboSpan" id="kobo.540.1">Next, we will </span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.541.1">send a message to the device using the RPC protocol, to retrieve the temperature measured by the device. </span><span class="koboSpan" id="kobo.541.2">Enter the following command in the bottom-left pane – </span><strong class="screenText"><span class="koboSpan" id="kobo.542.1">Python Repl</span></strong><span class="koboSpan" id="kobo.543.1">:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.544.1">$ </span></span><span class="language-bash"><span class="koboSpan" id="kobo.545.1">device.rpcs.board.Board.OnboardTemp()</span></span>
</code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.546.1">You should see the following response:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.547.1">$ </span></span><span class="language-bash"><span class="koboSpan" id="kobo.548.1">(Status.OK, board.OnboardTempResponse(temp=20.0))</span></span>
</code></pre>
<ol>
<li class="numberedList" value="11"><span class="koboSpan" id="kobo.549.1">Next, send a message that will toggle the LED:
        </span><pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.550.1">$ </span></span><span class="language-bash"><span class="koboSpan" id="kobo.551.1">device.rpcs.blinky.Blinky.Blink(interval_ms=200, blink_count=3)</span></span>
</code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.552.1">This call will make the LED blink three times at a 200 ms interval and afterward stop the </span><strong class="screenText"><span class="koboSpan" id="kobo.553.1">LED blinking</span></strong><span class="koboSpan" id="kobo.554.1"> messages. </span><span class="koboSpan" id="kobo.554.2">This shows us that we can also provide arguments to RPC calls.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.555.1">Next, we will go through Pigweed’s RPC in more detail.</span></p>
<h2 class="heading-2" id="_idParaDest-244"><span class="koboSpan" id="kobo.556.1">RPC and Protocol Buffers</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.557.1">Pigweed’s </span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.558.1">RPC system is based on Protocol Buffers – a platform-neutral mechanism </span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.559.1">used for data serialization. </span><span class="koboSpan" id="kobo.559.2">Protocol Buffers is </span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.560.1">a language with its own syntax, which can be compiled into a targeted language such as C++ on our Sense device and the Python code we used in the Python </span><strong class="keyWord"><span class="koboSpan" id="kobo.561.1">Read Eval Print Loop </span></strong><span class="koboSpan" id="kobo.562.1">(</span><strong class="keyWord"><span class="koboSpan" id="kobo.563.1">REPL</span></strong><span class="koboSpan" id="kobo.564.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.565.1">So, why use an extra layer of abstraction, such as Protocol Buffers, in an embedded application? </span><span class="koboSpan" id="kobo.565.2">There are a couple of benefits a standardized serialization brings to your projects:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.566.1">Compact binary messages – they add very little overhead.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.567.1">A precise contract (a </span><code class="inlineCode"><span class="koboSpan" id="kobo.568.1">.proto</span></code><span class="koboSpan" id="kobo.569.1"> file) between different parts of a system, ensuring that all parties agree on the structure and meaning of the exchanged data.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.570.1">Updates to the communication protocol can be managed by modifying a proto file.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.571.1">In short, instead of writing serialization and deserialization code in multiple code bases (C++ and Python) and maintaining it as such, you write the communication protocol in a proto file and use the Protocol Buffers compiler to generate C++ and Python code used for serialization.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.572.1">Let us examine a part of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.573.1">modules/blinky/blinky.proto</span></code><span class="koboSpan" id="kobo.574.1"> file describing the Blinky service used in the </span><em class="italic"><span class="koboSpan" id="kobo.575.1">Pigweed’s Sense tutorial</span></em><span class="koboSpan" id="kobo.576.1"> section to blink the LED three times at 200 ms intervals in the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.577.1">syntax = </span><span class="hljs-string"><span class="koboSpan" id="kobo.578.1">"proto3"</span></span><span class="koboSpan" id="kobo.579.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.580.1">package</span></span><span class="koboSpan" id="kobo.581.1"> blinky;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.582.1">import</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.583.1">"pw_protobuf_protos/common.proto"</span></span><span class="koboSpan" id="kobo.584.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.585.1">service </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.586.1">Blinky</span></span><span class="koboSpan" id="kobo.587.1"> {
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.588.1">// Toggles the LED on or off.</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.589.1">rpc</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.590.1"> ToggleLed(pw.protobuf.Empty) </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.591.1">returns</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.592.1">(pw.protobuf.Empty)</span></span><span class="koboSpan" id="kobo.593.1">;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.594.1">// Blinks the board LED a specified number of times.</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.595.1">rpc</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.596.1"> Blink(BlinkRequest) </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.597.1">returns</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.598.1"> (pw.protobuf.Empty)</span></span><span class="koboSpan" id="kobo.599.1">;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.600.1">message </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.601.1">BlinkRequest</span></span><span class="koboSpan" id="kobo.602.1"> {
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.603.1">// The interval at which to blink the LED, in milliseconds. </span><span class="koboSpan" id="kobo.603.2">uint32 interval_ms = 1;</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.604.1">// The number of times to blink the LED.</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.605.1">optional</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.606.1">uint32</span></span><span class="koboSpan" id="kobo.607.1"> blink_count = </span><span class="hljs-number"><span class="koboSpan" id="kobo.608.1">2</span></span><span class="koboSpan" id="kobo.609.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.610.1">This proto file defines a service called </span><code class="inlineCode"><span class="koboSpan" id="kobo.611.1">Blinky</span></code><span class="koboSpan" id="kobo.612.1"> for controlling an LED, using Protocol Buffers version 3 (</span><code class="inlineCode"><span class="koboSpan" id="kobo.613.1">syntax = "proto3"</span></code><span class="koboSpan" id="kobo.614.1">). </span><span class="koboSpan" id="kobo.614.2">It imports a </span><code class="inlineCode"><span class="koboSpan" id="kobo.615.1">common</span></code><span class="koboSpan" id="kobo.616.1"> proto file and defines two methods:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.617.1">ToggleLed</span></code><span class="koboSpan" id="kobo.618.1">: A simple method that switches the LED on or off, using an empty request and response.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.619.1">Blink</span></code><span class="koboSpan" id="kobo.620.1">: A method that blinks the LED with a configurable </span><code class="inlineCode"><span class="koboSpan" id="kobo.621.1">interval_ms</span></code><span class="koboSpan" id="kobo.622.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.623.1">optional blink_count</span></code><span class="koboSpan" id="kobo.624.1"> (members of </span><code class="inlineCode"><span class="koboSpan" id="kobo.625.1">BlinkRequest</span></code><span class="koboSpan" id="kobo.626.1">). </span><span class="koboSpan" id="kobo.626.2">The use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.627.1">optional</span></code><span class="koboSpan" id="kobo.628.1"> keyword means this parameter can be omitted when calling the method.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.629.1">This is a short </span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.630.1">explanation of the blinky.proto file. </span><span class="koboSpan" id="kobo.630.2">A more thorough </span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.631.1">guide to Protocol Buffers can be found at the following website: </span><a href="https://protobuf.dev/programming-guides/proto3/"><span class="url"><span class="koboSpan" id="kobo.632.1">https://protobuf.dev/programming-guides/proto3/</span></span></a><span class="koboSpan" id="kobo.633.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.634.1">For each service in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.635.1">blinky</span></code><span class="koboSpan" id="kobo.636.1"> proto file, Pigweed’s code generator will generate a corresponding C++ class. </span><span class="koboSpan" id="kobo.636.2">The generated </span><code class="inlineCode"><span class="koboSpan" id="kobo.637.1">Blinky</span></code><span class="koboSpan" id="kobo.638.1"> class resides in a dedicated </span><code class="inlineCode"><span class="koboSpan" id="kobo.639.1">pw_rpc::nanopb</span></code><span class="koboSpan" id="kobo.640.1"> sub-namespace within the file’s package: </span><code class="inlineCode"><span class="koboSpan" id="kobo.641.1">blinky::pw_rpc::nanopb::Blinky::Service</span></code><span class="koboSpan" id="kobo.642.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.643.1">The generated class serves as a base class that must be inherited to implement the service’s methods. </span><span class="koboSpan" id="kobo.643.2">It is templated on the derived class. </span><span class="koboSpan" id="kobo.643.3">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.644.1">BlinkyService</span></code><span class="koboSpan" id="kobo.645.1"> class implements the base class. </span><span class="koboSpan" id="kobo.645.2">The following code is part of its definition from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.646.1">modules/blinky/service.h</span></code><span class="koboSpan" id="kobo.647.1"> file:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.648.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.649.1">BlinkyService</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.650.1">final</span></span><span class="koboSpan" id="kobo.651.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.652.1">public</span></span><span class="koboSpan" id="kobo.653.1"> ::blinky::pw_rpc::nanopb::Blinky::Service {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.654.1">public</span></span><span class="koboSpan" id="kobo.655.1">:
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.656.1">pw::Status </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.657.1">ToggleLed</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.658.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.659.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.660.1"> pw_protobuf_Empty&amp;, pw_protobuf_Empty&amp;)</span></span><span class="koboSpan" id="kobo.661.1">;
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.662.1">pw::Status </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.663.1">Blink</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.664.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.665.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.666.1"> blinky_BlinkRequest&amp; request, pw_protobuf_Empty&amp;)</span></span><span class="koboSpan" id="kobo.667.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.668.1">private</span></span><span class="koboSpan" id="kobo.669.1">:
    Blinky blinky_;
};
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.670.1">BlinkyService</span></code><span class="koboSpan" id="kobo.671.1"> bridges the generated RPC interface with the concrete implementation for controlling the LED. </span><span class="koboSpan" id="kobo.671.2">It has a private object, </span><code class="inlineCode"><span class="koboSpan" id="kobo.672.1">blinky_</span></code><span class="koboSpan" id="kobo.673.1">, of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.674.1">Blinky</span></code><span class="koboSpan" id="kobo.675.1">, which is used to control an LED, as shown in the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.676.1">ToggleLed</span></code><span class="koboSpan" id="kobo.677.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.678.1">Blink</span></code><span class="koboSpan" id="kobo.679.1"> methods in the following code block from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.680.1">modules/blinky/service.cc</span></code><span class="koboSpan" id="kobo.681.1"> file:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.682.1">pw::Status </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.683.1">BlinkyService::ToggleLed</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.684.1">(</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.685.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.686.1"> pw_protobuf_Empty&amp;,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.687.1">pw_protobuf_Empty&amp;)</span></span><span class="koboSpan" id="kobo.688.1">
{
    blinky_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.689.1">Toggle</span></span><span class="koboSpan" id="kobo.690.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.691.1">return</span></span><span class="koboSpan" id="kobo.692.1"> pw::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.693.1">OkStatus</span></span><span class="koboSpan" id="kobo.694.1">();
}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.695.1">pw::Status </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.696.1">BlinkyService::Blink</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.697.1">(</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.698.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.699.1"> blinky_BlinkRequest&amp; request,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.700.1">pw_protobuf_Empty&amp;)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.701.1">
{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.702.1">uint32_t</span></span><span class="koboSpan" id="kobo.703.1"> interval_ms = request.interval_ms;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.704.1">uint32_t</span></span><span class="koboSpan" id="kobo.705.1"> blink_count = request.has_blink_count;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.706.1">return</span></span><span class="koboSpan" id="kobo.707.1"> blinky_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.708.1">Blink</span></span><span class="koboSpan" id="kobo.709.1">(blink_count, interval_ms);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.710.1">In this code, the methods </span><code class="inlineCode"><span class="koboSpan" id="kobo.711.1">ToggleLed</span></code><span class="koboSpan" id="kobo.712.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.713.1">Blink</span></code><span class="koboSpan" id="kobo.714.1"> use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.715.1">blinky_</span></code><span class="koboSpan" id="kobo.716.1"> object to control the LED. </span><span class="koboSpan" id="kobo.716.2">When binary proto messages for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.717.1">blinky</span></code><span class="koboSpan" id="kobo.718.1"> service are received over a transport layer, they are converted into actual calls to the code used to control hardware, which is the essence of RPC.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.719.1">As an exercise, expand the </span><code class="inlineCode"><span class="koboSpan" id="kobo.720.1">blinky</span></code><span class="koboSpan" id="kobo.721.1"> service by adding the </span><code class="inlineCode"><span class="koboSpan" id="kobo.722.1">BlinkTwice</span></code><span class="koboSpan" id="kobo.723.1"> method. </span><span class="koboSpan" id="kobo.723.2">You already know the files </span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.724.1">where you need to make changes – the proto file and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.725.1">BlinkyService</span></code><span class="koboSpan" id="kobo.726.1"> implementation files.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.727.1">Pigweed uses </span><strong class="keyWord"><span class="koboSpan" id="kobo.728.1">nanopb</span></strong><span class="koboSpan" id="kobo.729.1"> (</span><a href="https://github.com/nanopb/nanopb"><span class="url"><span class="koboSpan" id="kobo.730.1">https://github.com/nanopb/nanopb</span></span></a><span class="koboSpan" id="kobo.731.1">) to compile proto files in C files and then wrap them in C++. </span><span class="koboSpan" id="kobo.731.2">There is a pure C++ implementation of Protocol Buffers designed especially for microcontrollers – Embedded Proto. </span><span class="koboSpan" id="kobo.731.3">It is an object-oriented implementation </span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.732.1">that only uses static memory allocation. </span><span class="koboSpan" id="kobo.732.2">It has been developed using the MISRA C++ guidelines. </span><span class="koboSpan" id="kobo.732.3">These traits together make Embedded Proto suitable for applications with a wide range of requirements, from low memory usage to safety concerns. </span><span class="koboSpan" id="kobo.732.4">You can find more about it on the GitHub page: </span><a href="https://github.com/Embedded-AMS/EmbeddedProto"><span class="url"><span class="koboSpan" id="kobo.733.1">https://github.com/Embedded-AMS/EmbeddedProto</span></span></a><span class="koboSpan" id="kobo.734.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.735.1">Pigweed has a steep learning curve and should be carefully evaluated based on your system requirements. </span><span class="koboSpan" id="kobo.735.2">It is better suited for larger, more complex projects due to the learning overhead. </span><span class="koboSpan" id="kobo.735.3">Additionally, evaluate the hardware support and take into consideration the memory overhead some modules may introduce.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.736.1">In contrast to Pigweed, Intel’s </span><strong class="screenText"><span class="koboSpan" id="kobo.737.1">CIB</span></strong><span class="koboSpan" id="kobo.738.1"> library leverages C++ compile-time capabilities. </span><span class="koboSpan" id="kobo.738.2">This approach minimizes memory overhead while enhancing flexibility and expressiveness. </span><span class="koboSpan" id="kobo.738.3">Next, we will cover the CIB library.</span></p>
<h1 class="heading-1" id="_idParaDest-245"><span class="koboSpan" id="kobo.739.1">Compile-time Initialization and Build</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.740.1">One of C++’s major advantages in embedded systems is its ability to perform compile-time computation. </span><span class="koboSpan" id="kobo.740.2">In most cases, we have significant knowledge about the application beforehand, allowing us </span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.741.1">to configure it at compile time. </span><span class="koboSpan" id="kobo.741.2">Intel’s CIB library provides a declarative interface for configuring firmware components during compilation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.742.1">As you saw in </span><a href="Chapter_15.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.743.1">Chapter 15</span></em></span></a><span class="koboSpan" id="kobo.744.1">, the Observer design pattern is commonly used in event-driven systems to decouple the source of events (publisher) from the entities that react to those events (observers or subscribers). </span><span class="koboSpan" id="kobo.744.2">By using a subscriber interface, observers can register themselves with the event source, which then notifies them of changes or events without needing to know details about the observers’ implementations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.745.1">This decoupling allows for greater flexibility and modularity in system design, as components can be added, removed, or modified without tightly coupling them to the event generator. </span><span class="koboSpan" id="kobo.745.2">This property is leveraged by the CIB library, which implements a compile-time observer pattern to provide a declarative interface for configuring firmware applications. </span><span class="koboSpan" id="kobo.745.3">By resolving dependencies and establishing event-driven relationships at compile time, CIB eliminates runtime overhead while keeping components loosely coupled and efficiently interconnected.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.746.1">We will start exploring the CIB library on a simple example of a temperature publisher. </span><span class="koboSpan" id="kobo.746.2">The entire example is available at </span><a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter17/cib"><span class="url"><span class="koboSpan" id="kobo.747.1">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter17/cib</span></span></a><span class="koboSpan" id="kobo.748.1">. </span><span class="koboSpan" id="kobo.748.2">You can run it using the following commands:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.749.1">$ cmake –B build
$ cmake --build build --target run_in_renode
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.750.1">You can use </span><code class="inlineCode"><span class="koboSpan" id="kobo.751.1">app/src/main.cpp</span></code><span class="koboSpan" id="kobo.752.1"> to follow through the example, as CIB, at the time of writing, is not available as a library in Compiler Explorer.</span></p>
<h2 class="heading-2" id="_idParaDest-246"><span class="koboSpan" id="kobo.753.1">Using CIB in a temperature publisher example</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.754.1">Let’s </span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.755.1">begin with the following steps:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.756.1">We first need to declare a service (publisher) as an empty struct that inherits from </span><code class="inlineCode"><span class="koboSpan" id="kobo.757.1">callback::service</span></code><span class="koboSpan" id="kobo.758.1">, a variadic class template, provided with types that will be accepted by subscribers, as shown in the following code:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.759.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.760.1">send_temperature</span></span><span class="koboSpan" id="kobo.761.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.762.1">public</span></span><span class="koboSpan" id="kobo.763.1"> callback::service&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.764.1">float</span></span><span class="koboSpan" id="kobo.765.1">&gt; {};
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.766.1">Next, we will create the subscribers (also called components in the context of the CIB library) </span><code class="inlineCode"><span class="koboSpan" id="kobo.767.1">display_temperature_component</span></code><span class="koboSpan" id="kobo.768.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.769.1">data_sender_component</span></code><span class="koboSpan" id="kobo.770.1">, as shown in this code:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.771.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.772.1">display_temperature_component</span></span><span class="koboSpan" id="kobo.773.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.774.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.775.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.776.1">auto</span></span><span class="koboSpan" id="kobo.777.1"> display_temperature = [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.778.1">float</span></span><span class="koboSpan" id="kobo.779.1"> temperature) {
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.780.1">printf</span></span><span class="koboSpan" id="kobo.781.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.782.1">"Temperature is %.2f C\r\n"</span></span><span class="koboSpan" id="kobo.783.1">, temperature);
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.784.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.785.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.786.1">auto</span></span><span class="koboSpan" id="kobo.787.1"> config = cib::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.788.1">config</span></span><span class="koboSpan" id="kobo.789.1">(
    cib::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.790.1">extend</span></span><span class="koboSpan" id="kobo.791.1">&lt;send_temperature&gt;(display_temperature)
);
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.792.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.793.1">data_sender_component</span></span><span class="koboSpan" id="kobo.794.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.795.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.796.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.797.1">auto</span></span><span class="koboSpan" id="kobo.798.1"> send_temp = [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.799.1">float</span></span><span class="koboSpan" id="kobo.800.1"> temp) {
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.801.1">printf</span></span><span class="koboSpan" id="kobo.802.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.803.1">"Sending temperature %.2f C\r\n"</span></span><span class="koboSpan" id="kobo.804.1">, temp);
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.805.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.806.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.807.1">auto</span></span><span class="koboSpan" id="kobo.808.1"> config = cib::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.809.1">config</span></span><span class="koboSpan" id="kobo.810.1">(
    cib::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.811.1">extend</span></span><span class="koboSpan" id="kobo.812.1">&lt;send_temperature&gt;(send_temp)
);
};
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.813.1">The </span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.814.1">preceding code defines two components, which do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.815.1">Provide handlers for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.816.1">send_temperature</span></code><span class="koboSpan" id="kobo.817.1"> service in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.818.1">constexpr</span></code><span class="koboSpan" id="kobo.819.1"> lambdas </span><code class="inlineCode"><span class="koboSpan" id="kobo.820.1">display_temperature</span></code><span class="koboSpan" id="kobo.821.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.822.1">send_temp</span></code><span class="koboSpan" id="kobo.823.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.824.1">Define the </span><code class="inlineCode"><span class="koboSpan" id="kobo.825.1">constexpr static auto config</span></code><span class="koboSpan" id="kobo.826.1"> member through which they extend the service (subscribe to the events).</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.827.1">Config members are instances of variadic template class </span><code class="inlineCode"><span class="koboSpan" id="kobo.828.1">cib::config</span></code><span class="koboSpan" id="kobo.829.1">, and they are used by the CIB library to wire the application at compile time, that is, to connect services (event generators, publishers) with software components that extend those services (observers). </span><span class="koboSpan" id="kobo.829.2">Compile-time initialization and the build process are performed by </span><code class="inlineCode"><span class="koboSpan" id="kobo.830.1">cib::nexus</span></code><span class="koboSpan" id="kobo.831.1">, which needs to be supplied with the project configuration. </span><span class="koboSpan" id="kobo.831.2">Here is the code for configuration for this simple project:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.832.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.833.1">my_project</span></span><span class="koboSpan" id="kobo.834.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.835.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.836.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.837.1">auto</span></span><span class="koboSpan" id="kobo.838.1"> config = cib::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.839.1">config</span></span><span class="koboSpan" id="kobo.840.1">(
    cib::exports&lt;send_temperature&gt;,
                   
    cib::components&lt;display_temperature_component,
                    data_sender_component&gt;
);
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.841.1">This project configuration is a simple struct, </span><code class="inlineCode"><span class="koboSpan" id="kobo.842.1">my_project</span></code><span class="koboSpan" id="kobo.843.1">, with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.844.1">constexpr</span></code><span class="koboSpan" id="kobo.845.1"> member config, which is provided with the following:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.846.1">cib::exports&lt;send_temperature&gt;</span></code><span class="koboSpan" id="kobo.847.1">: Used to declare services (publishers)</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.848.1">cib::components&lt;display_temperature_component, data_sender_component&gt;</span></code><span class="koboSpan" id="kobo.849.1">: Used to declare software components that can extend services</span></li>
</ul>
<ol>
<li class="numberedList" value="3"><span class="koboSpan" id="kobo.850.1">Next, let’s </span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.851.1">see how we use all of this in a firmware application in the following code:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.852.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.853.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.854.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.855.1">{
    cib::nexus&lt;my_project&gt; nexus{};
    nexus.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.856.1">init</span></span><span class="koboSpan" id="kobo.857.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.858.1">for</span></span><span class="koboSpan" id="kobo.859.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.860.1">int</span></span><span class="koboSpan" id="kobo.861.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.862.1">0</span></span><span class="koboSpan" id="kobo.863.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.864.1">3</span></span><span class="koboSpan" id="kobo.865.1">; i++)
    {
        nexus.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.866.1">service</span></span><span class="koboSpan" id="kobo.867.1">&lt;send_temperature&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.868.1">42.0f</span></span><span class="koboSpan" id="kobo.869.1">);
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.870.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.871.1">0</span></span><span class="koboSpan" id="kobo.872.1">;
}
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.873.1">In this code, we perform these steps:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.874.1">cib::nexus&lt;my_project&gt; nexus{};</span></code><span class="koboSpan" id="kobo.875.1">: Create an instance of the class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.876.1">cib::nexus</span></code><span class="koboSpan" id="kobo.877.1"> provided by the project configuration </span><code class="inlineCode"><span class="koboSpan" id="kobo.878.1">my_project</span></code><span class="koboSpan" id="kobo.879.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.880.1">nexus.init();</span></code><span class="koboSpan" id="kobo.881.1">: Initialize Nexus.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.882.1">nexus.service&lt;send_temperature&gt;(42.0f);</span></code><span class="koboSpan" id="kobo.883.1">: Access the service and provide it with the float argument (temperature). </span><span class="koboSpan" id="kobo.883.2">This will trigger calls to lambdas in components that extend the </span><code class="inlineCode"><span class="koboSpan" id="kobo.884.1">send_temperature</span></code><span class="koboSpan" id="kobo.885.1"> service.</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-247"><span class="koboSpan" id="kobo.886.1">Extending the temperature publisher example</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.887.1">Next, we will </span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.888.1">extend this simple example with two components – a dummy temperature sensor and I2C components that we will name </span><code class="inlineCode"><span class="koboSpan" id="kobo.889.1">temperature_sensor_component</span></code><span class="koboSpan" id="kobo.890.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.891.1">i2c</span></code><span class="koboSpan" id="kobo.892.1">. </span><span class="koboSpan" id="kobo.892.2">We will also introduce two new services – </span><code class="inlineCode"><span class="koboSpan" id="kobo.893.1">runtime_init</span></code><span class="koboSpan" id="kobo.894.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.895.1">main_loop</span></code><span class="koboSpan" id="kobo.896.1">:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.897.1">Let’s start with defining new services in this code:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.898.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.899.1">runtime_init</span></span><span class="koboSpan" id="kobo.900.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.901.1">public</span></span><span class="koboSpan" id="kobo.902.1"> flow::service&lt;&gt; {};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.903.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.904.1">main_loop</span></span><span class="koboSpan" id="kobo.905.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.906.1">public</span></span><span class="koboSpan" id="kobo.907.1"> callback::service&lt;&gt; {};
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.908.1">Here, we define two services:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.909.1">runtime_init</span></code><span class="koboSpan" id="kobo.910.1">: Derives from the variadic class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.911.1">flow::service</span></code><span class="koboSpan" id="kobo.912.1">, allowing us to sequence actions</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.913.1">main_loop</span></code><span class="koboSpan" id="kobo.914.1">: Derives from </span><code class="inlineCode"><span class="koboSpan" id="kobo.915.1">callback::service</span></code><span class="koboSpan" id="kobo.916.1">, which will be called in the main </span><code class="inlineCode"><span class="koboSpan" id="kobo.917.1">while</span></code><span class="koboSpan" id="kobo.918.1"> loop</span></li>
</ul>
<ol>
<li class="numberedList" value="2"><span class="koboSpan" id="kobo.919.1">We will </span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.920.1">move now to implementations of I2C components, as shown in this code:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.921.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.922.1">i2c</span></span><span class="koboSpan" id="kobo.923.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.924.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.925.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.926.1">auto</span></span><span class="koboSpan" id="kobo.927.1"> init = flow::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.928.1">action</span></span><span class="koboSpan" id="kobo.929.1">&lt;</span><span class="hljs-string"><span class="koboSpan" id="kobo.930.1">"i2c_init"</span></span><span class="koboSpan" id="kobo.931.1">&gt;(
    [](){
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.932.1">printf</span></span><span class="koboSpan" id="kobo.933.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.934.1">"I2C init ...\r\n"</span></span><span class="koboSpan" id="kobo.935.1">);
    });
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.936.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.937.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.938.1">auto</span></span><span class="koboSpan" id="kobo.939.1"> config = cib::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.940.1">config</span></span><span class="koboSpan" id="kobo.941.1">(
    cib::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.942.1">extend</span></span><span class="koboSpan" id="kobo.943.1">&lt;runtime_init&gt;(*init)
);
};
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.944.1">This code defines a new component – </span><code class="inlineCode"><span class="koboSpan" id="kobo.945.1">i2c</span></code><span class="koboSpan" id="kobo.946.1"> – as a struct with:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.947.1">constexpr static auto init</span></code><span class="koboSpan" id="kobo.948.1">: A lambda wrapped in </span><code class="inlineCode"><span class="koboSpan" id="kobo.949.1">flow::action</span></code><span class="koboSpan" id="kobo.950.1"> that implements the initialization of the I2C peripheral.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.951.1">constexpr static auto config</span></code><span class="koboSpan" id="kobo.952.1">: Adds the above action to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.953.1">runtime_init</span></code><span class="koboSpan" id="kobo.954.1"> flow service. </span><span class="koboSpan" id="kobo.954.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.955.1">*</span></code><span class="koboSpan" id="kobo.956.1"> operator explicitly adds an action to the flow. </span><span class="koboSpan" id="kobo.956.2">Without it, the action is referenced but never added, causing a compile-time error.</span></li>
</ul>
<ol>
<li class="numberedList" value="3"><span class="koboSpan" id="kobo.957.1">Next, let’s go through the temperature sensor component shown in the following code:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.958.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.959.1">temperature_sensor_component</span></span><span class="koboSpan" id="kobo.960.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.961.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.962.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.963.1">auto</span></span><span class="koboSpan" id="kobo.964.1"> init = flow::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.965.1">action</span></span><span class="koboSpan" id="kobo.966.1">&lt;</span><span class="hljs-string"><span class="koboSpan" id="kobo.967.1">"temp_sensor_init"</span></span><span class="koboSpan" id="kobo.968.1">&gt;(
    []() {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.969.1">printf</span></span><span class="koboSpan" id="kobo.970.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.971.1">"Initializing temperature sensor ... </span><span class="koboSpan" id="kobo.971.2">\r\n"</span></span><span class="koboSpan" id="kobo.972.1">);
    });
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.973.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.974.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.975.1">auto</span></span><span class="koboSpan" id="kobo.976.1"> read_temperature = []() {
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.977.1">float</span></span><span class="koboSpan" id="kobo.978.1"> temperature = </span><span class="hljs-number"><span class="koboSpan" id="kobo.979.1">23.4f</span></span><span class="koboSpan" id="kobo.980.1">;
    cib::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.981.1">service</span></span><span class="koboSpan" id="kobo.982.1">&lt;send_temperature&gt;(temperature);
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.983.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.984.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.985.1">auto</span></span><span class="koboSpan" id="kobo.986.1"> config = cib::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.987.1">config</span></span><span class="koboSpan" id="kobo.988.1">(
 
    cib::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.989.1">extend</span></span><span class="koboSpan" id="kobo.990.1">&lt;main_loop&gt;(read_temperature),
    cib::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.991.1">extend</span></span><span class="koboSpan" id="kobo.992.1">&lt;runtime_init&gt;(i2c::init &gt;&gt; *init)
);
};
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.993.1">The preceding </span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.994.1">code shows the struct </span><code class="inlineCode"><span class="koboSpan" id="kobo.995.1">temperature_sensor_component</span></code><span class="koboSpan" id="kobo.996.1"> with the following members:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.997.1">constexpr static auto init</span></code><span class="koboSpan" id="kobo.998.1">: A </span><code class="inlineCode"><span class="koboSpan" id="kobo.999.1">flow_action</span></code><span class="koboSpan" id="kobo.1000.1"> that implements the initialization of the temperature sensor</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1001.1">constexpr static auto read_temperature</span></code><span class="koboSpan" id="kobo.1002.1">: A lambda that implements periodic readings of a temperature sensor and uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.1003.1">cib::service&lt;read_temperature&gt;</span></code><span class="koboSpan" id="kobo.1004.1"> to publish the read value</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1005.1">constexpr static auto config</span></code><span class="koboSpan" id="kobo.1006.1">: Extends the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1007.1">main_loop</span></code><span class="koboSpan" id="kobo.1008.1"> service with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1009.1">read_temperature</span></code><span class="koboSpan" id="kobo.1010.1"> lambda and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1011.1">runtime_init</span></code><span class="koboSpan" id="kobo.1012.1"> flow with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1013.1">i2c::init &gt;&gt; *init</span></code><span class="koboSpan" id="kobo.1014.1">, indicating that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1015.1">i2c::init</span></code><span class="koboSpan" id="kobo.1016.1"> precedes </span><code class="inlineCode"><span class="koboSpan" id="kobo.1017.1">init</span></code></li>
</ul>
<ol>
<li class="numberedList" value="4"><span class="koboSpan" id="kobo.1018.1">Next, we need to modify the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1019.1">my_project</span></code><span class="koboSpan" id="kobo.1020.1"> struct to export new services and add new components, as shown in this code:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1021.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1022.1">my_project</span></span><span class="koboSpan" id="kobo.1023.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1024.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1025.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1026.1">auto</span></span><span class="koboSpan" id="kobo.1027.1"> config = cib::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1028.1">config</span></span><span class="koboSpan" id="kobo.1029.1">(
    cib::exports&lt;runtime_init,
                 main_loop,
                 send_temperature&gt;,
                   
    cib::components&lt;i2c,
                    temperature_sensor_component,
                    display_temperature_component,
                    data_sender_component&gt;
);
};
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1030.1">In this code, we simply added:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1031.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1032.1">runtime_init</span></code><span class="koboSpan" id="kobo.1033.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1034.1">main_loop</span></code><span class="koboSpan" id="kobo.1035.1"> services to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1036.1">cib::exports</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.1037.1">i2c</span></code><span class="koboSpan" id="kobo.1038.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1039.1">temperature_sensor_component</span></code><span class="koboSpan" id="kobo.1040.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1041.1">cib::components</span></code></li>
</ul>
<ol>
<li class="numberedList" value="5"><span class="koboSpan" id="kobo.1042.1">Finally, let </span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.1043.1">us see the new </span><code class="inlineCode"><span class="koboSpan" id="kobo.1044.1">main</span></code><span class="koboSpan" id="kobo.1045.1"> function, as shown here:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1046.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1047.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1048.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1049.1">{
    cib::nexus&lt;my_project&gt; nexus{};
    nexus.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1050.1">init</span></span><span class="koboSpan" id="kobo.1051.1">();
    nexus.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1052.1">service</span></span><span class="koboSpan" id="kobo.1053.1">&lt;runtime_init&gt;();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1054.1">for</span></span><span class="koboSpan" id="kobo.1055.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1056.1">int</span></span><span class="koboSpan" id="kobo.1057.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1058.1">0</span></span><span class="koboSpan" id="kobo.1059.1">; i &lt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1060.1">3</span></span><span class="koboSpan" id="kobo.1061.1">; i++)
    {
        nexus.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1062.1">service</span></span><span class="koboSpan" id="kobo.1063.1">&lt;main_loop&gt;();
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1064.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1065.1">0</span></span><span class="koboSpan" id="kobo.1066.1">;
}
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1067.1">As previously, we first create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1068.1">cib::nexus</span></code><span class="koboSpan" id="kobo.1069.1"> instance and initialize it. </span><span class="koboSpan" id="kobo.1069.2">Then, we perform the following steps:</span></p>
<ol>
<li class="numberedList" value="1"><code class="inlineCode"><span class="koboSpan" id="kobo.1070.1">nexus.service&lt;runtime_init&gt;()</span></code><span class="koboSpan" id="kobo.1071.1">: This will run all actions in the flow </span><code class="inlineCode"><span class="koboSpan" id="kobo.1072.1">runtime_init</span></code><span class="koboSpan" id="kobo.1073.1"> and ensure the specified order of actions.</span></li>
<li class="numberedList"><code class="inlineCode"><span class="koboSpan" id="kobo.1074.1">nexus.service&lt;main_loop&gt;()</span></code><span class="koboSpan" id="kobo.1075.1">: This is a call in the main loop executing all lambdas that are extending this service.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1076.1">This structure is typical for many firmware applications: initialize all components (including hardware peripherals), then repeatedly call relevant services in the main loop. </span><span class="koboSpan" id="kobo.1076.2">Any changes to the application are done in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1077.1">my_project</span></code><span class="koboSpan" id="kobo.1078.1"> struct in a declarative way – by extending services and adding or removing components. </span><span class="koboSpan" id="kobo.1078.2">All initialization is performed in the components themselves, meaning the main function does not need to know the details of individual components and their dependencies.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1079.1">The CIB library also includes logging, interrupt, message, and string constant libraries – all leveraging C++’s compile-time computation. </span><span class="koboSpan" id="kobo.1079.2">You can find more information about CIB on GitHub: </span><a href="https://github.com/intel/compile-time-init-build"><span class="url"><span class="koboSpan" id="kobo.1080.1">https://github.com/intel/compile-time-init-build</span></span></a><span class="koboSpan" id="kobo.1081.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1082.1">You can run the full CIB example in Renode. </span><span class="koboSpan" id="kobo.1082.2">Start Visual Studio Code, attach it to the running container, open the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1083.1">Chapter17/cib</span></code><span class="koboSpan" id="kobo.1084.1"> project, as described in </span><a href="Chapter_04.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1085.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.1086.1">, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1087.1">$ cmake –B build
$ cmake --build build --target run_in_renode
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1088.1">Running </span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.1089.1">the above example will generate the output shown here:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1090.1">I2C init ...
</span><span class="koboSpan" id="kobo.1090.2">Initializing temperature sensor ...
</span><span class="koboSpan" id="kobo.1090.3">Sending temperature 23.40 C
Temperature is 23.40 C
Sending temperature 23.40 C
Temperature is 23.40 C
Sending temperature 23.40 C
Temperature is 23.40 C
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1091.1">This example demonstrates the usage of the CIB library in an event-driven system with loosely coupled components, where some generate events and others react to them. </span><span class="koboSpan" id="kobo.1091.2">The wiring of publishers and subscribers happens at compile time, minimizing the memory footprint and reducing runtime overhead, while the declarative project configuration improves readability.</span></p>
<h1 class="heading-1" id="_idParaDest-248"><span class="koboSpan" id="kobo.1092.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1093.1">In this chapter, we saw an overview of the libraries used throughout this book – the C++ standard library and ETL. </span><span class="koboSpan" id="kobo.1093.2">You also got an insight into Google’s Pigweed library and its capabilities and Intel’s CIB library.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1094.1">In the next chapter, we will go through cross-platform development.</span></p>
</div>
</body></html>