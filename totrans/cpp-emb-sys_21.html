<html><head></head><body>
<div><h1 class="chapterNumber">17</h1>
<h1 class="chapterTitle" id="_idParaDest-222">Libraries and Frameworks</h1>
<p class="normal">While the C++ standard library offers a vast array of containers and algorithms, certain aspects – such as dynamic memory allocation – can pose challenges in constrained environments. In <a href="Chapter_02.xhtml"><em class="italic">Chapter 2</em></a>, we explored some of these issues and ways to address them. However, specialized <a id="_idIndexMarker718"/>libraries, like the <strong class="keyWord">Embedded Template Library</strong> (<strong class="keyWord">ETL</strong>), offer deterministic behavior and fixed memory footprints, making them well suited for embedded systems.</p>
<p class="normal">Embedded <a id="_idIndexMarker719"/>applications depend on <strong class="keyWord">Hardware Abstraction Layers</strong> (<strong class="keyWord">HALs</strong>) provided by vendors as C libraries. In <a href="Chapter_12.xhtml"><em class="italic">Chapter 12</em></a>, we examined how to use interfaces to decouple application-level C++ code from the underlying C-based hardware interactions. Wrapping entire HALs in C++ is a lot of work, but luckily, there are projects such as Google’s Pigweed that are tackling exactly that, while offering additional functionality and flexibility for embedded development.</p>
<p class="normal">In <a href="Chapter_11.xhtml"><em class="italic">Chapter 11</em></a>, we explored how C++ can perform computations at compile time, reducing memory footprint. In <a href="Chapter_15.xhtml"><em class="italic">Chapter 15</em></a>, we learned about the Observer pattern and examined its compile-time <a id="_idIndexMarker720"/>implementation. Intel’s <strong class="keyWord">Compile-time Initialization and Build</strong> (<strong class="keyWord">CIB</strong>) elevates these ideas even further, enabling a declarative approach to configuring firmware applications at compile time. In this chapter, we will go through the following C++ libraries:</p>
<ul>
<li class="bulletList">Standard library</li>
<li class="bulletList">Embedded template library</li>
<li class="bulletList">Pigweed</li>
<li class="bulletList">Compile-time Initialization and Build</li>
</ul>
<h1 class="heading-1" id="_idParaDest-223">Technical requirements</h1>
<p class="normal">You can try the examples from this chapter in the Renode simulator in the Docker container you set up in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>. Make sure that the Docker container is running. </p>
<p class="normal">You can find the files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter17">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter17</a>.</p>
<h1 class="heading-1" id="_idParaDest-224">Standard library</h1>
<p class="normal">The C++ standard <a id="_idIndexMarker721"/>defines two types of standard library implementation – hosted and freestanding: </p>
<ul>
<li class="bulletList">A freestanding <a id="_idIndexMarker722"/>implementation <a id="_idIndexMarker723"/>is designed to run without relying on services typically provided by an OS, such as filesystem access or multi-threading support. As a result, the C++ standard specifies only a limited subset of standard library headers that must be provided by a freestanding implementation.</li>
<li class="bulletList">A hosted <a id="_idIndexMarker724"/>implementation requires a <a id="_idIndexMarker725"/>globally defined main function, and the environment is responsible for invoking this function at startup. In a freestanding implementation, the startup routines and the entry point of the program are implementation-defined, allowing developers greater flexibility in specifying the initialization and execution flow of their applications.</li>
</ul>
<p class="normal">Although the standard makes a clear distinction between hosted and freestanding implementation in terms of the globally defined main function, the configuration in some examples in this book blurs the line between the two.</p>
<h2 class="heading-2" id="_idParaDest-225">Freestanding and hosted implementations in GCC</h2>
<p class="normal">Even though <a id="_idIndexMarker726"/>we operate in a freestanding <a id="_idIndexMarker727"/>environment (no OS), some examples in this book use components from the C++ standard library (e.g., <code class="inlineCode">std::function</code>), which are typically associated with hosted implementations. This is possible because:</p>
<ul>
<li class="bulletList">As we observed in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>, we set the program entry point in the linker script to <code class="inlineCode">Reset_Handler</code>.</li>
<li class="bulletList"><code class="inlineCode">Reset_Handler</code>, implemented in the assembler startup script, performs low-level initialization and explicitly calls <code class="inlineCode">main</code>.</li>
<li class="bulletList">We use nano specs (<a href="Chapter_07.xhtml"><em class="italic">Chapter 7</em></a>), linking against a size-optimized subset of the C++ standard library. This allows limited use of hosted features like <code class="inlineCode">std::function</code> while avoiding dependencies on an OS.</li>
</ul>
<p class="normal">This hybrid <a id="_idIndexMarker728"/>approach leverages GCC’s flexibility to combine freestanding execution (custom entry point, no OS) with hosted library <a id="_idIndexMarker729"/>features (standard headers, utilities) in a bare-metal environment.</p>
<p class="normal">To explicitly request GCC to use a freestanding implementation of the standard library, the compiler flag <code class="inlineCode">-ffreestanding</code> should be used. The C++ standard library provides many components that are “pay only for what you use” and can be very useful even in resource‐constrained environments. In previous chapters, you’ve already worked with many parts of the standard library, so you have a solid understanding of its capabilities. Here, we’ll provide an overview of the parts that are best suited for resource‐constrained environments and point out which ones should be used with caution or avoided.</p>
<h2 class="heading-2" id="_idParaDest-226">Numeric and math</h2>
<p class="normal">Embedded systems are often employed in automation and process control, requiring precise control <a id="_idIndexMarker730"/>over numeric types, their ranges, and math <a id="_idIndexMarker731"/>operations. The C++ standard library provides the <code class="inlineCode">&lt;cstdint&gt;</code>, <code class="inlineCode">&lt;limits&gt;</code>, and <code class="inlineCode">&lt;cmath&gt;</code> headers to define fixed-width integers, query numeric limits, and perform mathematical computations, helping ensure predictable behavior, portability, and efficiency in resource-constrained environments.</p>
<h3 class="heading-3" id="_idParaDest-227">&lt;cstdint&gt;</h3>
<p class="normal">The <code class="inlineCode">&lt;cstdint&gt;</code> header <a id="_idIndexMarker732"/>provides fixed-width integer types such as <code class="inlineCode">std::int8_t</code>, <code class="inlineCode">std::uint32_t</code>, and other well-known C types defined in <code class="inlineCode">stdint.h</code>. These types are <a id="_idIndexMarker733"/>useful in embedded contexts where integer size and bit width are important for direct hardware register access, predictable overflow behavior, and memory usage considerations. By using them, you explicitly document your intention for a variable’s size, thereby improving code portability and preventing potential surprises when moving between platforms with different native integer widths.</p>
<h3 class="heading-3" id="_idParaDest-228">&lt;limits&gt;</h3>
<p class="normal">The header <a id="_idIndexMarker734"/>provides the <code class="inlineCode">std::numeric_limits</code> template, which describes <a id="_idIndexMarker735"/>properties of fundamental numeric types (like minimum and maximum values, sign, and precision). This is especially useful in embedded contexts for handling overflow. Typical usage occurs at compile-time or through trivial inlining by the compiler, resulting in minimal runtime overhead. By using functions like <code class="inlineCode">std::numeric_limits::max()</code>, you avoid scattering magic constants or architecture-specific assumptions, aiding portability and maintainability.</p>
<h3 class="heading-3" id="_idParaDest-229">&lt;cmath&gt;</h3>
<p class="normal">The <code class="inlineCode">&lt;cmath&gt;</code> header <a id="_idIndexMarker736"/>provides standard math functions such as <code class="inlineCode">std::sin</code>, <code class="inlineCode">std::cos</code>, <code class="inlineCode">std::sqrt</code>, and more. In embedded environments, especially those without <a id="_idIndexMarker737"/>floating-point hardware, these functions can be relatively expensive in terms of both runtime performance and code size. Carefully consider whether you really need floating-point math, and if so, whether approximations or fixed-point routines might be sufficient and more efficient.</p>
<h2 class="heading-2" id="_idParaDest-230">Containers and algorithms</h2>
<p class="normal">Embedded systems <a id="_idIndexMarker738"/>often manage structured <a id="_idIndexMarker739"/>data and require efficient ways to process it under tight resource constraints. The C++ standard library offers container and algorithm headers such as <code class="inlineCode">&lt;array&gt;</code>, <code class="inlineCode">&lt;span&gt;</code>, and <code class="inlineCode">&lt;algorithm&gt;</code> to organize data and perform common operations like searching, sorting, and transforming, enabling more readable and maintainable code.</p>
<h3 class="heading-3" id="_idParaDest-231">std::array</h3>
<p class="normal">The only fixed-size <a id="_idIndexMarker740"/>container in the standard library <a id="_idIndexMarker741"/>that avoids dynamic allocation is <code class="inlineCode">std::array</code>. We covered it in <a href="Chapter_01.xhtml"><em class="italic">Chapter 1</em></a>, when we discussed generic types. In the same chapter, we based the ring buffer implementation on <code class="inlineCode">std::array</code>, which allowed us to create ring buffers of different types and sizes using the same generic code.</p>
<p class="normal"><code class="inlineCode">std::array</code> is typically implemented as a wrapper around a C-style array. Besides being a generic type, it also offers the <code class="inlineCode">at</code> method for index-based access with runtime bounds checking, making it a safer alternative to raw arrays. If an out-of-bounds index is requested, the <code class="inlineCode">at</code> method will throw an exception. If exceptions are disabled, it may call <code class="inlineCode">std::terminate</code> or <code class="inlineCode">std::abort</code>, depending on the library implementation. These behaviors should be handled according to your system requirements by implementing appropriate terminate and signal handlers.</p>
<h3 class="heading-3" id="_idParaDest-232">std:: priority_queue</h3>
<p class="normal"><code class="inlineCode">std::priority_queue</code> is a container adapter that provides priority queue functionality. By default, it <a id="_idIndexMarker742"/>uses <code class="inlineCode">std::vector</code> as the <a id="_idIndexMarker743"/>underlying container. However, as shown in <a href="Chapter_14.xhtml"><em class="italic">Chapter 14</em></a>, you can substitute it with <code class="inlineCode">etl::vector</code> from ETL, avoiding issues with dynamic memory allocation.</p>
<h3 class="heading-3" id="_idParaDest-233">std:: span</h3>
<p class="normal">As shown in <a href="Chapter_09.xhtml"><em class="italic">Chapter 9</em></a>, <code class="inlineCode">std::span</code> is a lightweight, non-owning wrapper around a contiguous <a id="_idIndexMarker744"/>sequence of objects, where the first element <a id="_idIndexMarker745"/>is at position 0. It provides essential functionality such as the <code class="inlineCode">size()</code> method, <code class="inlineCode">operator[]</code> for element access, and the <code class="inlineCode">begin()</code> and <code class="inlineCode">end()</code> iterators, allowing it to integrate seamlessly with standard library algorithms.</p>
<p class="normal"><code class="inlineCode">std::span</code> can be constructed from C-style arrays as well as containers like <code class="inlineCode">std::array</code> and <code class="inlineCode">std::vector</code> or <code class="inlineCode">etl::vector</code>. This makes it a practical alternative to using separate pointer and size parameters, which is especially useful when interfacing C++ code with C libraries such as those used in HAL.</p>
<h3 class="heading-3" id="_idParaDest-234">Iterators</h3>
<p class="normal">Iterators are abstractions that act like generalized pointers, providing a uniform way to traverse and <a id="_idIndexMarker746"/>access elements within a container. For example, standard library containers implement the <code class="inlineCode">begin()</code> and <code class="inlineCode">end()</code> methods, which return <a id="_idIndexMarker747"/>iterators marking the start and one-past-the-end of their sequence. This consistent interface allows algorithms to work generically over different container types, enhancing code reusability and clarity.</p>
<p class="normal">Let us go through the following example using <code class="inlineCode">std::array</code>:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;array&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
int main() {
    std::array&lt;int, 5&gt; arr = {5, 3, 4, 1, 2};
    std::array&lt;int, 5&gt;::iterator start = arr.begin();
    auto finish = arr.end();
    std::sort(start, finish);
    for (auto it = arr.begin(); it != arr.end(); ++it) {
        printf("%d ", *it);
    }
    printf("\n");
    return 0;
}
</code></pre>
<p class="normal">This example <a id="_idIndexMarker748"/>demonstrates how to use iterators with a standard library container:</p>
<ul>
<li class="bulletList">The iterator <code class="inlineCode">start</code> is explicitly declared as <code class="inlineCode">std::array&lt;int, 5&gt;::iterator</code> to illustrate the full type name, while the iterator <code class="inlineCode">finish</code> is declared using <code class="inlineCode">auto</code> for conciseness, allowing the compiler to deduce its type.</li>
<li class="bulletList">The <code class="inlineCode">std::sort</code> algorithm is applied using the iterators <code class="inlineCode">start</code> and <code class="inlineCode">finish</code>, obtained from <code class="inlineCode">arr.begin()</code> and <code class="inlineCode">arr.end()</code>, to sort the array in ascending order.</li>
<li class="bulletList">The loop uses <code class="inlineCode">auto</code> to declare the iterator <code class="inlineCode">it</code>, which makes the code more concise. The loop traverses the sorted array, and <code class="inlineCode">printf</code> is used to print each element.</li>
</ul>
<p class="normal">Iterators are <a id="_idIndexMarker749"/>used to traverse containers. They not only promote generic programming but also make it easy to switch container types without changing the algorithmic logic.</p>
<h3 class="heading-3" id="_idParaDest-235">Algorithms</h3>
<p class="normal">Algorithms from the standard library offer a consistent way to solve common problems across <a id="_idIndexMarker750"/>different containers, making the code more <a id="_idIndexMarker751"/>expressive and easier to maintain. They allow you to perform operations like searching, sorting, copying, and accumulating data using a uniform interface. Some of the most used algorithms are listed here:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::sort</code>: Sorts a range of elements in ascending order by default, using the less-than operator for comparison. It can also accept a custom comparator to sort based on different criteria, such as descending order or a specific object property.</li>
<li class="bulletList"><code class="inlineCode">std::find</code>: Searches for the first occurrence of a given value in a range and returns an iterator to it. If the value is not found, it returns the end iterator, signaling that the search failed.</li>
<li class="bulletList"><code class="inlineCode">std::for_each</code>: Applies a specified function or lambda to each element in a range.</li>
<li class="bulletList"><code class="inlineCode">std::copy</code>: Copies the elements of one range into another destination range.</li>
<li class="bulletList"><code class="inlineCode">std::copy_if</code>: Copies only elements that satisfy a specified predicate, making it useful for filtering data as you copy.</li>
<li class="bulletList"><code class="inlineCode">std::min</code> and <code class="inlineCode">std::max</code>: Return the smaller or larger of two values, respectively, using the less-than <a id="_idIndexMarker752"/>operator by default (or a provided comparison function). They’re handy for quick comparisons where you just need the minimum or maximum of two values.</li>
<li class="bulletList"><code class="inlineCode">std::min_element</code> and <code class="inlineCode">std::max_element</code>: Return an iterator to the smallest or largest <a id="_idIndexMarker753"/>element in a range. These are useful when you need to find the position of an extreme value in a container (instead of comparing just two values).</li>
<li class="bulletList"><code class="inlineCode">std::accumulate</code>: Iterates over a range and combines the elements with an initial value using a binary operation (default is addition). This allows for summing values, computing products, or performing any custom aggregation you define.</li>
</ul>
<h2 class="heading-2" id="_idParaDest-236">Template metaprogramming</h2>
<p class="normal">As discussed in <a href="Chapter_08.xhtml"><em class="italic">Chapter 8</em></a>, C++ type traits are compile-time predicates and transformations that allow <a id="_idIndexMarker754"/>the compiler to enforce constraints based on a type’s properties. They are used for writing generic, robust code without incurring <a id="_idIndexMarker755"/>runtime overhead. In <a href="Chapter_12.xhtml"><em class="italic">Chapter 12</em></a>, we used type traits to create type-safe register access, preventing invalid type usage at compile time and reducing the risk of subtle errors.</p>
<p class="normal">Here are some concrete type traits we’ve utilized in the chapters mentioned in this section:</p>
<ul>
<li class="bulletList"><code class="inlineCode">std::enable_if</code>: Enables or disables function templates based on a Boolean compile-time expression</li>
<li class="bulletList"><code class="inlineCode">std::is_same</code>: Checks if two types are exactly the same</li>
<li class="bulletList"><code class="inlineCode">std::is_enum</code>: Checks if a type is an enumeration type</li>
<li class="bulletList"><code class="inlineCode">std::underlying_type</code>: Retrieves the underlying integer type of an enum</li>
<li class="bulletList"><code class="inlineCode">std::is_arithmetic</code>: Checks if a type is an arithmetic type (integral or floating-point)</li>
<li class="bulletList"><code class="inlineCode">std::is_integral</code>: Checks if a type is an integral type</li>
<li class="bulletList"><code class="inlineCode">std::is_floating_point</code>: Checks if a type is a floating-point type</li>
</ul>
<h2 class="heading-2" id="_idParaDest-237">Parts of the standard library to avoid in embedded applications</h2>
<p class="normal">Many containers from the standard library, such as <code class="inlineCode">std::vector</code>, <code class="inlineCode">std::list</code>, and <code class="inlineCode">std::string</code>, use dynamic memory allocation. If dynamic memory allocation is not allowed in your <a id="_idIndexMarker756"/>embedded application, these should be avoided.</p>
<p class="normal">The <code class="inlineCode">iostream</code> library, included with header <code class="inlineCode">&lt;iostream&gt;,</code> requires significant memory resources and also relies on dynamic allocation. That’s why we used the <code class="inlineCode">&lt;cstdio&gt;</code> header and the <code class="inlineCode">printf</code> function for console output.</p>
<p class="normal">In <a href="Chapter_10.xhtml"><em class="italic">Chapter 10</em></a>, we covered <code class="inlineCode">std::function</code> from the <code class="inlineCode">&lt;functional&gt;</code> header. There, we outlined that in some scenarios, <code class="inlineCode">std::function</code> can use dynamic memory allocation, meaning if used, it should be used with caution. Note that <code class="inlineCode">std::function</code> is not available in a freestanding implementation.</p>
<p class="normal">Next, we will give a short overview of ETL that compliments the standard library in the context of restricted embedded environments.</p>
<h1 class="heading-1" id="_idParaDest-238">Embedded template library</h1>
<p class="normal">In <a href="Chapter_02.xhtml"><em class="italic">Chapter 2</em></a>, we saw that <code class="inlineCode">std::vector</code> uses dynamic memory allocation by default. We also saw that <a id="_idIndexMarker757"/>we can use <code class="inlineCode">std:: polymorphic_allocator</code> and a monotonic buffer to make it use statically allocated memory. This approach is still not bulletproof as <code class="inlineCode">std::vector</code> in some cases can resort to dynamic memory allocation even with this approach.</p>
<p class="normal">To address some of the challenges posed by the standard library in embedded contexts, ETL provides a set of templated containers and algorithms that closely mimic the interfaces of standard library counterparts but are tailored for systems with limited resources.</p>
<h2 class="heading-2" id="_idParaDest-239">Fixed-size containers</h2>
<p class="normal">One of the primary advantages of ETL is that its containers (such as <code class="inlineCode">etl::vector</code>, <code class="inlineCode">etl::list</code>, <code class="inlineCode">etl::string</code>, and others) allow you to specify a fixed maximum size at compile time. Container implementations ensure that no dynamic memory allocation is performed at runtime as <a id="_idIndexMarker758"/>memory is reserved up front as atomic or static storage.</p>
<p class="normal">As ETL containers are designed to mimic standard library containers, and they implement iterators, they can be used with most algorithms and container adapters from the standard library. This allows us to leverage components from the standard library without worrying about dynamic allocation.</p>
<p class="normal">ETL also offers <code class="inlineCode">etl::array</code> for platforms that do not support C++11, since <code class="inlineCode">std::array</code> was introduced in C++11.</p>
<h2 class="heading-2" id="_idParaDest-240">Storing a callable with etl::delegate</h2>
<p class="normal">As shown in <a href="Chapter_14.xhtml"><em class="italic">Chapter 14</em></a>, you <a id="_idIndexMarker759"/>can use <code class="inlineCode">etl::delegate</code> instead of <code class="inlineCode">std::function</code> to store a callable. However, <code class="inlineCode">etl::delegate</code> is non-owning, so you must handle potential dangling references carefully.</p>
<h2 class="heading-2" id="_idParaDest-241">Other utilities provided by ETL</h2>
<p class="normal">Besides fixed-size containers and <code class="inlineCode">etl::delegate</code>, ETL also provides utilities such as a messaging framework – a collection of messages, message routers, message buses, and finite state machines. It also offers CRC calculations, checksums, and hash functions.</p>
<p class="normal">ETL allows you <a id="_idIndexMarker760"/>to configure error handling. It can be configured to throw exceptions or send errors to the user-defined handler. This allows greater flexibility and project-based configuration depending on system requirements.</p>
<p class="normal">You can <a id="_idIndexMarker761"/>learn more about ETL at the website <a href="https://www.etlcpp.com/">https://www.etlcpp.com/</a>.</p>
<p class="normal">Next, we will discuss Pigweed – a collection of lightweight, modular C++ libraries for embedded systems, developed by Google, offering components like logging, assertions, and Bluetooth connectivity to simplify development and improve code reuse.</p>
<h1 class="heading-1" id="_idParaDest-242">Pigweed</h1>
<p class="normal">One of the biggest challenges in embedded systems development is portability. For code to be truly portable, it must depend on interfaces. To run it on different hardware targets, someone <a id="_idIndexMarker762"/>needs to implement those interfaces on different targets. Maintaining consistent interfaces across various projects and devices can be difficult. Google’s Pigweed project aims to solve this by providing software modules for embedded applications, with hardware interfaces already implemented for many targets.</p>
<p class="normal">Pigweed is intended for complex projects and large-scale teams. Besides the hardware interfaces, it also:</p>
<ul>
<li class="bulletList">Packs software modules <a id="_idIndexMarker763"/>built on top of them, such <a id="_idIndexMarker764"/>as logging, serial communication (SPI, I2C, and UART), Bluetooth <strong class="keyWord">Host Controller Interface</strong> (<strong class="keyWord">HCI</strong>), interactive console, <strong class="keyWord">Remote Procedure Call</strong> (<strong class="keyWord">RPC</strong>) system, and more.</li>
<li class="bulletList">Provides embedding-friendly alternatives to standard library components: fixed-size strings and containers.</li>
<li class="bulletList">Manages the entire toolchain out of the box and simplifies setting up your development environment.</li>
<li class="bulletList">Provides an entire framework – <code class="inlineCode">pw_system</code> – which pulls together many modules across Pigweed to construct a working system with RPC, logging, and more.</li>
</ul>
<p class="normal">As you can see, Pigweed is <a id="_idIndexMarker765"/>not only a library – it is an entire development ecosystem. It can be used as a framework, but you can also cherry-pick individual modules that suit your needs. As stated <a id="_idIndexMarker766"/>on the documentation website – <a href="https://pigweed.dev/">https://pigweed.dev/</a> – Pigweed is still in its early stages; some modules are still in development stages, while some are stable and used on devices that are already on the market. As with any library, you need to evaluate it for potential use in your projects.</p>
<p class="normal">We’ll go through Pigweed’s Sense tutorial to demonstrate some of its capabilities – mainly the interactive console and <strong class="screenText">RPC</strong> system.</p>
<h2 class="heading-2" id="_idParaDest-243">Pigweed’s Sense tutorial</h2>
<p class="normal">The Sense project is a demo project that utilizes many Pigweed components and shows how they work together.</p>
<p class="normal">Sense is a <a id="_idIndexMarker767"/>simplified version of an air quality sensor that only includes some of the functions of a full product. The goal is to give you practical experience with working with Pigweed by following these steps:</p>
<ol>
<li class="numberedList" value="1">First, make sure the Docker daemon is running. Start a Docker image in network host mode and attach it to Bash. You can use the following commands in a Linux environment:
        <pre class="programlisting con"><code class="hljs-con">$ sudo systemctl start docker
$ docker run --network=host -d -it --name dev_env mahmutbegovic/cpp_in_embedded_systems
$ docker exec -it dev_env /bin/bash
</code></pre>
</li>
</ol>
<p class="normal">For the Windows-based host, use the following command to forward the ports needed to run the tutorial:</p>
<pre class="programlisting con"><code class="hljs-con">$ docker run -d -it --name dev_env -p 33000:33000 -p 8080:8080 mahmutbegovic/cpp_in_embedded_systems
</code></pre>
<ol>
<li class="numberedList" value="2">Next, clone the Sense repo:
        <pre class="programlisting con"><code class="hljs-con">$ git clone https://pigweed.googlesource.com/pigweed/showcase/sense
</code></pre>
</li>
<li class="numberedList">Next, start Visual Studio Code, attach to the running container, and open the <code class="inlineCode">/workspace/sense</code> folder. If you see a pop-up message in <strong class="screenText">Visual Studio Code</strong> recommending the installation of the Pigweed extension, accept it; otherwise, go to <strong class="screenText">Extensions</strong>, search for <code class="inlineCode">Pigweed</code>, and install it.</li>
</ol>
<figure class="mediaobject"><img alt="Figure 17.1 – Visual Studio Code extension" src="img/B22402_17_1.png"/></figure>
<p class="packt_figref">Figure 17.1 – Visual Studio Code extension</p>
<p class="normal"><em class="italic">Figure 17</em><em class="italic">.1</em> depicts the Visual Studio Code Pigweed extension.</p>
<ol>
<li class="numberedList" value="4">After the <a id="_idIndexMarker768"/>installation of the extension, go to Explorer view and expand the <strong class="screenText">BAZEL BUILD TARGETS</strong> node. Click on the <strong class="screenText">Refresh Target List</strong> button.</li>
</ol>
<figure class="mediaobject"><img alt="Figure 17.2 – BAZEL BUILD TARGETS node" src="img/B22402_17_2.png"/></figure>
<p class="packt_figref">Figure 17.2 – BAZEL BUILD TARGETS node</p>
<p class="normal">Refreshing the target list can take between 30 seconds and a couple of minutes. Pigweed uses <a id="_idIndexMarker769"/>Bazel for build automation. The refreshed target list should look similar to the following:</p>
<figure class="mediaobject"><img alt="Figure 17.3 – BAZEL BUILD TARGETS" src="img/B22402_17_3.png"/></figure>
<p class="packt_figref">Figure 17.3 – BAZEL BUILD TARGETS</p>
<p class="normal"><em class="italic">Figure 17</em><em class="italic">.3</em> depicts Bazel build targets.</p>
<ol>
<li class="numberedList" value="5">Next, expand the <strong class="screenText">//apps/blinky</strong> node.</li>
</ol>
<figure class="mediaobject"><img alt="Figure 17.4 – //apps/blinky targets" src="img/B22402_17_4.png"/></figure>
<p class="packt_figref">Figure 17.4 – //apps/blinky targets</p>
<ol>
<li class="numberedList" value="6">Now, we will <a id="_idIndexMarker770"/>build a version of the app that runs on the host. Right-click <strong class="screenText">simulator_blinky (host_device_simulator_binary)</strong> and then click <strong class="screenText">Build Target</strong>. The build can take around 10 minutes. When completed, you should see a message similar to this one:</li>
</ol>
<figure class="mediaobject"><img alt="Figure 17.5 – Successful build" src="img/B22402_17_5.png"/></figure>
<p class="packt_figref">Figure 17.5 – Successful build</p>
<ol>
<li class="numberedList" value="7">After a successful build, we will start the app. Right-click<strong class="screenText"> simulator_blinky (host_device_simulator_binary)</strong> and then <strong class="screenText">Run Target</strong>. If successful, you should see the following message in the terminal: <strong class="screenText">Awaiting connection on port 33000</strong>.</li>
<li class="numberedList">Next, right-click <strong class="screenText">simulator_console (native_binary)</strong> and then <strong class="screenText">Run Target</strong>. This will build a <a id="_idIndexMarker771"/>console and connect it to the running simulator. If successful, you should see the following screen:</li>
</ol>
<figure class="mediaobject"><img alt="Figure 17.6 – Interactive console running in terminal view" src="img/B22402_17_6.png"/></figure>
<p class="packt_figref">Figure 17.6 – Interactive console running in terminal view</p>
<p class="normal">In <em class="italic">Figure 17</em><em class="italic">.6</em>, you can see the interactive console running in the terminal view in Visual Studio Code.</p>
<ol>
<li class="numberedList" value="9">To make the console easier to work with, right-click on <strong class="screenText">Run //apps/blinky:simulator_console</strong> and select <strong class="screenText">Move Terminal into New Window</strong>. This will move the console into a separate window, as shown in this image:</li>
</ol>
<figure class="mediaobject"><img alt="Figure 17.7 – Interactive console running in a separate window" src="img/B22402_17_7.png"/></figure>
<p class="packt_figref">Figure 17.7 – Interactive console running in a separate window</p>
<p class="normal">In <em class="italic">Figure 17</em><em class="italic">.7</em>, in the top-right pane, <strong class="screenText">Device Logs</strong>, we can see logs coming from the simulated device (app running on the host). It sends <strong class="screenText">LED blinking</strong> messages every second.</p>
<ol>
<li class="numberedList" value="10">Next, we will <a id="_idIndexMarker772"/>send a message to the device using the RPC protocol, to retrieve the temperature measured by the device. Enter the following command in the bottom-left pane – <strong class="screenText">Python Repl</strong>:
        <pre class="programlisting con"><code class="hljs-con">$ device.rpcs.board.Board.OnboardTemp()
</code></pre>
</li>
</ol>
<p class="normal">You should see the following response:</p>
<pre class="programlisting con"><code class="hljs-con">$ (Status.OK, board.OnboardTempResponse(temp=20.0))
</code></pre>
<ol>
<li class="numberedList" value="11">Next, send a message that will toggle the LED:
        <pre class="programlisting con"><code class="hljs-con">$ device.rpcs.blinky.Blinky.Blink(interval_ms=200, blink_count=3)
</code></pre>
</li>
</ol>
<p class="normal">This call will make the LED blink three times at a 200 ms interval and afterward stop the <strong class="screenText">LED blinking</strong> messages. This shows us that we can also provide arguments to RPC calls.</p>
<p class="normal">Next, we will go through Pigweed’s RPC in more detail.</p>
<h2 class="heading-2" id="_idParaDest-244">RPC and Protocol Buffers</h2>
<p class="normal">Pigweed’s <a id="_idIndexMarker773"/>RPC system is based on Protocol Buffers – a platform-neutral mechanism <a id="_idIndexMarker774"/>used for data serialization. Protocol Buffers is <a id="_idIndexMarker775"/>a language with its own syntax, which can be compiled into a targeted language such as C++ on our Sense device and the Python code we used in the Python <strong class="keyWord">Read Eval Print Loop </strong>(<strong class="keyWord">REPL</strong>).</p>
<p class="normal">So, why use an extra layer of abstraction, such as Protocol Buffers, in an embedded application? There are a couple of benefits a standardized serialization brings to your projects:</p>
<ul>
<li class="bulletList">Compact binary messages – they add very little overhead.</li>
<li class="bulletList">A precise contract (a <code class="inlineCode">.proto</code> file) between different parts of a system, ensuring that all parties agree on the structure and meaning of the exchanged data.</li>
<li class="bulletList">Updates to the communication protocol can be managed by modifying a proto file.</li>
</ul>
<p class="normal">In short, instead of writing serialization and deserialization code in multiple code bases (C++ and Python) and maintaining it as such, you write the communication protocol in a proto file and use the Protocol Buffers compiler to generate C++ and Python code used for serialization.</p>
<p class="normal">Let us examine a part of the <code class="inlineCode">modules/blinky/blinky.proto</code> file describing the Blinky service used in the <em class="italic">Pigweed’s Sense tutorial</em> section to blink the LED three times at 200 ms intervals in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">syntax = "proto3";
package blinky;
import "pw_protobuf_protos/common.proto";
service Blinky {
// Toggles the LED on or off.
rpc ToggleLed(pw.protobuf.Empty) returns(pw.protobuf.Empty);
// Blinks the board LED a specified number of times.
rpc Blink(BlinkRequest) returns (pw.protobuf.Empty);
}
message BlinkRequest {
// The interval at which to blink the LED, in milliseconds. uint32 interval_ms = 1;
// The number of times to blink the LED.
optional uint32 blink_count = 2;
}
</code></pre>
<p class="normal">This proto file defines a service called <code class="inlineCode">Blinky</code> for controlling an LED, using Protocol Buffers version 3 (<code class="inlineCode">syntax = "proto3"</code>). It imports a <code class="inlineCode">common</code> proto file and defines two methods:</p>
<ul>
<li class="bulletList"><code class="inlineCode">ToggleLed</code>: A simple method that switches the LED on or off, using an empty request and response.</li>
<li class="bulletList"><code class="inlineCode">Blink</code>: A method that blinks the LED with a configurable <code class="inlineCode">interval_ms</code> and <code class="inlineCode">optional blink_count</code> (members of <code class="inlineCode">BlinkRequest</code>). The use of the <code class="inlineCode">optional</code> keyword means this parameter can be omitted when calling the method.</li>
</ul>
<p class="normal">This is a short <a id="_idIndexMarker776"/>explanation of the blinky.proto file. A more thorough <a id="_idIndexMarker777"/>guide to Protocol Buffers can be found at the following website: <a href="https://protobuf.dev/programming-guides/proto3/">https://protobuf.dev/programming-guides/proto3/</a>.</p>
<p class="normal">For each service in a <code class="inlineCode">blinky</code> proto file, Pigweed’s code generator will generate a corresponding C++ class. The generated <code class="inlineCode">Blinky</code> class resides in a dedicated <code class="inlineCode">pw_rpc::nanopb</code> sub-namespace within the file’s package: <code class="inlineCode">blinky::pw_rpc::nanopb::Blinky::Service</code>.</p>
<p class="normal">The generated class serves as a base class that must be inherited to implement the service’s methods. It is templated on the derived class. The <code class="inlineCode">BlinkyService</code> class implements the base class. The following code is part of its definition from the <code class="inlineCode">modules/blinky/service.h</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">class BlinkyService final : public ::blinky::pw_rpc::nanopb::Blinky::Service {
public:
    pw::Status ToggleLed(const pw_protobuf_Empty&amp;, pw_protobuf_Empty&amp;);
    pw::Status Blink(const blinky_BlinkRequest&amp; request, pw_protobuf_Empty&amp;);
private:
    Blinky blinky_;
};
</code></pre>
<p class="normal"><code class="inlineCode">BlinkyService</code> bridges the generated RPC interface with the concrete implementation for controlling the LED. It has a private object, <code class="inlineCode">blinky_</code>, of type <code class="inlineCode">Blinky</code>, which is used to control an LED, as shown in the implementation of the <code class="inlineCode">ToggleLed</code> and <code class="inlineCode">Blink</code> methods in the following code block from the <code class="inlineCode">modules/blinky/service.cc</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">pw::Status BlinkyService::ToggleLed(
const pw_protobuf_Empty&amp;,
pw_protobuf_Empty&amp;)
{
    blinky_.Toggle();
    return pw::OkStatus();
}
pw::Status BlinkyService::Blink(
const blinky_BlinkRequest&amp; request,
pw_protobuf_Empty&amp;) 
{
    uint32_t interval_ms = request.interval_ms;
    uint32_t blink_count = request.has_blink_count;
    return blinky_.Blink(blink_count, interval_ms);
}
</code></pre>
<p class="normal">In this code, the methods <code class="inlineCode">ToggleLed</code> and <code class="inlineCode">Blink</code> use the <code class="inlineCode">blinky_</code> object to control the LED. When binary proto messages for the <code class="inlineCode">blinky</code> service are received over a transport layer, they are converted into actual calls to the code used to control hardware, which is the essence of RPC.</p>
<p class="normal">As an exercise, expand the <code class="inlineCode">blinky</code> service by adding the <code class="inlineCode">BlinkTwice</code> method. You already know the files <a id="_idIndexMarker778"/>where you need to make changes – the proto file and the <code class="inlineCode">BlinkyService</code> implementation files.</p>
<p class="normal">Pigweed uses <strong class="keyWord">nanopb</strong> (<a href="https://github.com/nanopb/nanopb">https://github.com/nanopb/nanopb</a>) to compile proto files in C files and then wrap them in C++. There is a pure C++ implementation of Protocol Buffers designed especially for microcontrollers – Embedded Proto. It is an object-oriented implementation <a id="_idIndexMarker779"/>that only uses static memory allocation. It has been developed using the MISRA C++ guidelines. These traits together make Embedded Proto suitable for applications with a wide range of requirements, from low memory usage to safety concerns. You can find more about it on the GitHub page: <a href="https://github.com/Embedded-AMS/EmbeddedProto">https://github.com/Embedded-AMS/EmbeddedProto</a>.</p>
<p class="normal">Pigweed has a steep learning curve and should be carefully evaluated based on your system requirements. It is better suited for larger, more complex projects due to the learning overhead. Additionally, evaluate the hardware support and take into consideration the memory overhead some modules may introduce.</p>
<p class="normal">In contrast to Pigweed, Intel’s <strong class="screenText">CIB</strong> library leverages C++ compile-time capabilities. This approach minimizes memory overhead while enhancing flexibility and expressiveness. Next, we will cover the CIB library.</p>
<h1 class="heading-1" id="_idParaDest-245">Compile-time Initialization and Build</h1>
<p class="normal">One of C++’s major advantages in embedded systems is its ability to perform compile-time computation. In most cases, we have significant knowledge about the application beforehand, allowing us <a id="_idIndexMarker780"/>to configure it at compile time. Intel’s CIB library provides a declarative interface for configuring firmware components during compilation.</p>
<p class="normal">As you saw in <a href="Chapter_15.xhtml"><em class="italic">Chapter 15</em></a>, the Observer design pattern is commonly used in event-driven systems to decouple the source of events (publisher) from the entities that react to those events (observers or subscribers). By using a subscriber interface, observers can register themselves with the event source, which then notifies them of changes or events without needing to know details about the observers’ implementations.</p>
<p class="normal">This decoupling allows for greater flexibility and modularity in system design, as components can be added, removed, or modified without tightly coupling them to the event generator. This property is leveraged by the CIB library, which implements a compile-time observer pattern to provide a declarative interface for configuring firmware applications. By resolving dependencies and establishing event-driven relationships at compile time, CIB eliminates runtime overhead while keeping components loosely coupled and efficiently interconnected.</p>
<p class="normal">We will start exploring the CIB library on a simple example of a temperature publisher. The entire example is available at <a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter17/cib">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter17/cib</a>. You can run it using the following commands:</p>
<pre class="programlisting con"><code class="hljs-con">$ cmake –B build
$ cmake --build build --target run_in_renode
</code></pre>
<p class="normal">You can use <code class="inlineCode">app/src/main.cpp</code> to follow through the example, as CIB, at the time of writing, is not available as a library in Compiler Explorer.</p>
<h2 class="heading-2" id="_idParaDest-246">Using CIB in a temperature publisher example</h2>
<p class="normal">Let’s <a id="_idIndexMarker781"/>begin with the following steps:</p>
<ol>
<li class="numberedList" value="1">We first need to declare a service (publisher) as an empty struct that inherits from <code class="inlineCode">callback::service</code>, a variadic class template, provided with types that will be accepted by subscribers, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">struct send_temperature : public callback::service&lt;float&gt; {};
</code></pre>
</li>
<li class="numberedList">Next, we will create the subscribers (also called components in the context of the CIB library) <code class="inlineCode">display_temperature_component</code> and <code class="inlineCode">data_sender_component</code>, as shown in this code:
        <pre class="programlisting code"><code class="hljs-code">struct display_temperature_component {
constexpr static auto display_temperature = [](float temperature) {
    printf("Temperature is %.2f C\r\n", temperature);
};
constexpr static auto config = cib::config(
    cib::extend&lt;send_temperature&gt;(display_temperature)
);
};
struct data_sender_component {
constexpr static auto send_temp = [](float temp) {
    printf("Sending temperature %.2f C\r\n", temp);
};
constexpr static auto config = cib::config(
    cib::extend&lt;send_temperature&gt;(send_temp)
);
};
</code></pre>
</li>
</ol>
<p class="normal">The <a id="_idIndexMarker782"/>preceding code defines two components, which do the following:</p>
<ul>
<li class="bulletList">Provide handlers for the <code class="inlineCode">send_temperature</code> service in the <code class="inlineCode">constexpr</code> lambdas <code class="inlineCode">display_temperature</code> and <code class="inlineCode">send_temp</code>.</li>
<li class="bulletList">Define the <code class="inlineCode">constexpr static auto config</code> member through which they extend the service (subscribe to the events).</li>
</ul>
<p class="normal">Config members are instances of variadic template class <code class="inlineCode">cib::config</code>, and they are used by the CIB library to wire the application at compile time, that is, to connect services (event generators, publishers) with software components that extend those services (observers). Compile-time initialization and the build process are performed by <code class="inlineCode">cib::nexus</code>, which needs to be supplied with the project configuration. Here is the code for configuration for this simple project:</p>
<pre class="programlisting code"><code class="hljs-code">struct my_project {
constexpr static auto config = cib::config(
    cib::exports&lt;send_temperature&gt;,
                   
    cib::components&lt;display_temperature_component,
                    data_sender_component&gt;
);
};
</code></pre>
<p class="normal">This project configuration is a simple struct, <code class="inlineCode">my_project</code>, with the <code class="inlineCode">constexpr</code> member config, which is provided with the following:</p>
<ul>
<li class="bulletList"><code class="inlineCode">cib::exports&lt;send_temperature&gt;</code>: Used to declare services (publishers)</li>
<li class="bulletList"><code class="inlineCode">cib::components&lt;display_temperature_component, data_sender_component&gt;</code>: Used to declare software components that can extend services</li>
</ul>
<ol>
<li class="numberedList" value="3">Next, let’s <a id="_idIndexMarker783"/>see how we use all of this in a firmware application in the following code:
        <pre class="programlisting code"><code class="hljs-code">int main() {
    cib::nexus&lt;my_project&gt; nexus{};
    nexus.init();
    for(int i = 0; i &lt; 3; i++)
    {
        nexus.service&lt;send_temperature&gt;(42.0f);
    }
    return 0;
}
</code></pre>
</li>
</ol>
<p class="normal">In this code, we perform these steps:</p>
<ul>
<li class="bulletList"><code class="inlineCode">cib::nexus&lt;my_project&gt; nexus{};</code>: Create an instance of the class template <code class="inlineCode">cib::nexus</code> provided by the project configuration <code class="inlineCode">my_project</code>.</li>
<li class="bulletList"><code class="inlineCode">nexus.init();</code>: Initialize Nexus.</li>
<li class="bulletList"><code class="inlineCode">nexus.service&lt;send_temperature&gt;(42.0f);</code>: Access the service and provide it with the float argument (temperature). This will trigger calls to lambdas in components that extend the <code class="inlineCode">send_temperature</code> service.</li>
</ul>
<h2 class="heading-2" id="_idParaDest-247">Extending the temperature publisher example</h2>
<p class="normal">Next, we will <a id="_idIndexMarker784"/>extend this simple example with two components – a dummy temperature sensor and I2C components that we will name <code class="inlineCode">temperature_sensor_component</code> and <code class="inlineCode">i2c</code>. We will also introduce two new services – <code class="inlineCode">runtime_init</code> and <code class="inlineCode">main_loop</code>:</p>
<ol>
<li class="numberedList" value="1">Let’s start with defining new services in this code:
        <pre class="programlisting code"><code class="hljs-code">struct runtime_init : public flow::service&lt;&gt; {};
struct main_loop : public callback::service&lt;&gt; {};
</code></pre>
</li>
</ol>
<p class="normal">Here, we define two services:</p>
<ul>
<li class="bulletList"><code class="inlineCode">runtime_init</code>: Derives from the variadic class template <code class="inlineCode">flow::service</code>, allowing us to sequence actions</li>
<li class="bulletList"><code class="inlineCode">main_loop</code>: Derives from <code class="inlineCode">callback::service</code>, which will be called in the main <code class="inlineCode">while</code> loop</li>
</ul>
<ol>
<li class="numberedList" value="2">We will <a id="_idIndexMarker785"/>move now to implementations of I2C components, as shown in this code:
        <pre class="programlisting code"><code class="hljs-code">struct i2c {
constexpr static auto init = flow::action&lt;"i2c_init"&gt;(
    [](){
        printf("I2C init ...\r\n");
    });
constexpr static auto config = cib::config(
    cib::extend&lt;runtime_init&gt;(*init)
);
};
</code></pre>
</li>
</ol>
<p class="normal">This code defines a new component – <code class="inlineCode">i2c</code> – as a struct with:</p>
<ul>
<li class="bulletList"><code class="inlineCode">constexpr static auto init</code>: A lambda wrapped in <code class="inlineCode">flow::action</code> that implements the initialization of the I2C peripheral.</li>
<li class="bulletList"><code class="inlineCode">constexpr static auto config</code>: Adds the above action to the <code class="inlineCode">runtime_init</code> flow service. The <code class="inlineCode">*</code> operator explicitly adds an action to the flow. Without it, the action is referenced but never added, causing a compile-time error.</li>
</ul>
<ol>
<li class="numberedList" value="3">Next, let’s go through the temperature sensor component shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">struct temperature_sensor_component {
constexpr static auto init = flow::action&lt;"temp_sensor_init"&gt;(
    []() {
        printf("Initializing temperature sensor ... \r\n");
    });
constexpr static auto read_temperature = []() {
    float temperature = 23.4f;
    cib::service&lt;send_temperature&gt;(temperature);
};
constexpr static auto config = cib::config(
 
    cib::extend&lt;main_loop&gt;(read_temperature),
    cib::extend&lt;runtime_init&gt;(i2c::init &gt;&gt; *init)
);
};
</code></pre>
</li>
</ol>
<p class="normal">The preceding <a id="_idIndexMarker786"/>code shows the struct <code class="inlineCode">temperature_sensor_component</code> with the following members:</p>
<ul>
<li class="bulletList"><code class="inlineCode">constexpr static auto init</code>: A <code class="inlineCode">flow_action</code> that implements the initialization of the temperature sensor</li>
<li class="bulletList"><code class="inlineCode">constexpr static auto read_temperature</code>: A lambda that implements periodic readings of a temperature sensor and uses <code class="inlineCode">cib::service&lt;read_temperature&gt;</code> to publish the read value</li>
<li class="bulletList"><code class="inlineCode">constexpr static auto config</code>: Extends the <code class="inlineCode">main_loop</code> service with the <code class="inlineCode">read_temperature</code> lambda and the <code class="inlineCode">runtime_init</code> flow with <code class="inlineCode">i2c::init &gt;&gt; *init</code>, indicating that <code class="inlineCode">i2c::init</code> precedes <code class="inlineCode">init</code></li>
</ul>
<ol>
<li class="numberedList" value="4">Next, we need to modify the <code class="inlineCode">my_project</code> struct to export new services and add new components, as shown in this code:
        <pre class="programlisting code"><code class="hljs-code">struct my_project {
constexpr static auto config = cib::config(
    cib::exports&lt;runtime_init,
                 main_loop,
                 send_temperature&gt;,
                   
    cib::components&lt;i2c,
                    temperature_sensor_component,
                    display_temperature_component,
                    data_sender_component&gt;
);
};
</code></pre>
</li>
</ol>
<p class="normal">In this code, we simply added:</p>
<ul>
<li class="bulletList">The <code class="inlineCode">runtime_init</code> and <code class="inlineCode">main_loop</code> services to <code class="inlineCode">cib::exports</code></li>
<li class="bulletList"><code class="inlineCode">i2c</code> and <code class="inlineCode">temperature_sensor_component</code> to <code class="inlineCode">cib::components</code></li>
</ul>
<ol>
<li class="numberedList" value="5">Finally, let <a id="_idIndexMarker787"/>us see the new <code class="inlineCode">main</code> function, as shown here:
        <pre class="programlisting code"><code class="hljs-code">int main() {
    cib::nexus&lt;my_project&gt; nexus{};
    nexus.init();
    nexus.service&lt;runtime_init&gt;();
    for(int i = 0; i &lt; 3; i++)
    {
        nexus.service&lt;main_loop&gt;();
    }
    return 0;
}
</code></pre>
</li>
</ol>
<p class="normal">As previously, we first create a <code class="inlineCode">cib::nexus</code> instance and initialize it. Then, we perform the following steps:</p>
<ol>
<li class="numberedList" value="1"><code class="inlineCode">nexus.service&lt;runtime_init&gt;()</code>: This will run all actions in the flow <code class="inlineCode">runtime_init</code> and ensure the specified order of actions.</li>
<li class="numberedList"><code class="inlineCode">nexus.service&lt;main_loop&gt;()</code>: This is a call in the main loop executing all lambdas that are extending this service.</li>
</ol>
<p class="normal">This structure is typical for many firmware applications: initialize all components (including hardware peripherals), then repeatedly call relevant services in the main loop. Any changes to the application are done in the <code class="inlineCode">my_project</code> struct in a declarative way – by extending services and adding or removing components. All initialization is performed in the components themselves, meaning the main function does not need to know the details of individual components and their dependencies.</p>
<p class="normal">The CIB library also includes logging, interrupt, message, and string constant libraries – all leveraging C++’s compile-time computation. You can find more information about CIB on GitHub: <a href="https://github.com/intel/compile-time-init-build">https://github.com/intel/compile-time-init-build</a>.</p>
<p class="normal">You can run the full CIB example in Renode. Start Visual Studio Code, attach it to the running container, open the <code class="inlineCode">Chapter17/cib</code> project, as described in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</p>
<pre class="programlisting con"><code class="hljs-con">$ cmake –B build
$ cmake --build build --target run_in_renode
</code></pre>
<p class="normal">Running <a id="_idIndexMarker788"/>the above example will generate the output shown here:</p>
<pre class="programlisting con"><code class="hljs-con">I2C init ...
Initializing temperature sensor ...
Sending temperature 23.40 C
Temperature is 23.40 C
Sending temperature 23.40 C
Temperature is 23.40 C
Sending temperature 23.40 C
Temperature is 23.40 C
</code></pre>
<p class="normal">This example demonstrates the usage of the CIB library in an event-driven system with loosely coupled components, where some generate events and others react to them. The wiring of publishers and subscribers happens at compile time, minimizing the memory footprint and reducing runtime overhead, while the declarative project configuration improves readability.</p>
<h1 class="heading-1" id="_idParaDest-248">Summary</h1>
<p class="normal">In this chapter, we saw an overview of the libraries used throughout this book – the C++ standard library and ETL. You also got an insight into Google’s Pigweed library and its capabilities and Intel’s CIB library.</p>
<p class="normal">In the next chapter, we will go through cross-platform development.</p>
</div>
</body></html>