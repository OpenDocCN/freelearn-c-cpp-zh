["```cpp\n// Example 01\n#include <stdlib.h>\n#include \"benchmark/benchmark.h\"\nvoid BM_malloc(benchmark::State& state) {\n  constexpr size_t size = 1024;\n  for (auto _ : state) {\n    void* p = malloc(size);\n    benchmark::DoNotOptimize(p);\n    free(p);\n  }\n  state.SetItemsProcessed(state.iterations());\n}\nBENCHMARK(BM_malloc);\nBENCHMARK_MAIN();\n```", "```cpp\n$CXX 01_benchmark.C -I. -I$GBENCH_DIR/include –O3 \\\n  --std=c++17 $GBENCH_DIR/lib/libbenchmark.a -lpthread \\\n  -o 01_benchmark && ./01_benchmark\n```", "```cpp\nvoid BM_increment(benchmark::State& state) {\n  size_t i = 0;\n  for (auto _ : state) {\n    ++i;\n    benchmark::DoNotOptimize(i);\n  }\n  state.SetItemsProcessed(state.iterations());\n}\n```", "```cpp\n// Example 02\n#define REPEAT2(x) x x\n#define REPEAT4(x) REPEAT2(x) REPEAT2(x)\n#define REPEAT8(x) REPEAT4(x) REPEAT4(x)\n#define REPEAT16(x) REPEAT8(x) REPEAT8(x)\n#define REPEAT32(x) REPEAT16(x) REPEAT16(x)\n#define REPEAT(x) REPEAT32(x)\nvoid BM_increment32(benchmark::State& state) {\n  size_t i = 0;\n  for (auto _ : state) {\n    REPEAT(\n      ++i;\n      benchmark::DoNotOptimize(i);\n    )\n  }\n  state.SetItemsProcessed(32*state.iterations());\n}\n```", "```cpp\n#include <vector>\n#include \"gtest/gtest.h\"\nTEST(Memory, Vector) {\n  std::vector<int> v(10);\n  EXPECT_EQ(10u, v.size());\n  EXPECT_LE(10u, v.capacity());\n}\n```", "```cpp\n$CXX 02_test.C -I. -I$GTEST_DIR/include -g -O0 -I. \\\n  -Wall -Wextra -Werror -pedantic --std=c++17 \\\n  $GTEST_DIR/lib/libgtest.a $GTEST_DIR/lib/libgtest_main.a\\\n  -lpthread -lrt -lm -o -2_test && ./02_test\n```", "```cpp\nRunning main() from gtest_main.cc\n[==========] Running 1 test from 1 test case.\n[----------] Global test environment set-up.\n[----------] 1 test from Memory\n[ RUN      ] Memory.Vector\n[       OK ] Memory.Vector (0 ms)\n[----------] 1 test from Memory (0 ms total)\n[----------] Global test environment tear-down\n[==========] 1 test from 1 test case ran. (0 ms total)\n[  PASSED  ] 1 test.\n```", "```cpp\n// Example 03\nstruct object_counter {\n  static int count;\n  static int all_count;\n  object_counter() { ++count; ++all_count; }\n  ~object_counter() { --count; }\n};\nint object_counter::count = 0;\nint object_counter::all_count = 0;\n```", "```cpp\n// Example 03\n#include \"gtest/gtest.h\"\nTEST(Memory, NewDelete) {\n  object_counter::all_count = object_counter::count = 0;\n  object_counter* p = new object_counter;\n  EXPECT_EQ(1, object_counter::count);\n  EXPECT_EQ(1, object_counter::all_count);\n  delete p;\n  EXPECT_EQ(0, object_counter::count);\n  EXPECT_EQ(1, object_counter::all_count);\n}\n```", "```cpp\n[----------] 1 test from Memory\n[ RUN      ] Memory.NewDelete\n[       OK ] Memory.NewDelete (0 ms)\n[----------] 1 test from Memory (0 ms total)\n[  PASSED  ] 1 test.\n```", "```cpp\n{\n  object_counter* p = new object_counter;\n  ... many more lines of code ...\n  // Were we supposed to do something here?\n  // Can't remember now...\n}\n```", "```cpp\n// Example 04\nTEST(Memory, Leak1) {\n  object_counter::all_count = object_counter::count = 0;\n  object_counter* p = new object_counter;\n  EXPECT_EQ(1, object_counter::count);\n  EXPECT_EQ(1, object_counter::all_count);\n  //delete p;  // Forgot that\n  EXPECT_EQ(0, object_counter::count); // This test fails!\n  EXPECT_EQ(1, object_counter::all_count);\n}\n```", "```cpp\n[ RUN      ] Memory.Leak1\n04_memory.C:31: Failure\nExpected equality of these values:\n  0\n  object_counter::count\n    Which is: 1\n[  FAILED  ] Memory.Leak1 (0 ms)\n```", "```cpp\nbool process(... some parameters ... ) {\n  object_counter* p = new object_counter;\n  ... many more lines of code ...\n  delete p;    // A-ha, we remembered!\n  return true;    // Success\n}\n```", "```cpp\nbool process(... some parameters ... ) {\n  object_counter* p = new object_counter;\n  ... many more lines of code ...\n  if (!success) return false;   // Failure, cannot continue\n  ... even more lines of code ...\n  delete p;    // Still here\n  return true;    // Success\n}\n```", "```cpp\nbool process(... some parameters ... ) {\n  object_counter* p = new object_counter;\n  ... many more lines of code ...\n  if (!success) {\n    delete p;\n    return false;    // Failure, cannot continue\n  }\n  ... even more lines of code ...\n  delete p;    // Still here\n  return true;    // Success\n}\n```", "```cpp\nbool process(... some parameters ... ) {\n  object_counter* p = new object_counter[10]; // Array now\n  ... many more lines of code ...\n  if (!success) {\n    delete p;\n    return false;     // Old scalar delete\n  }\n  ... even more lines of code ...\n  delete [] p;    // Matching array delete\n  return true;    // Success\n}\n```", "```cpp\nstd::mutex m1, m2, m3;\nbool process_concurrently(... some parameters ... ) {\n  m1.lock();\n  m2.lock();\n  ... need both locks in this section ...\n  if (!success) {\n    m1.unlock();\n    m2.unlock();\n    return false;\n  } // Both locks unlocked\n  ... more code ...\n  m2.unlock();    // Don't need access to m1-guarded data\n                // Still need m1\n  m3.lock();\n  if (!success) {\n    m1.unlock();\n    return false;\n  } // No need to unlock m2 here\n  ... more code ...\n  m1.unlock();\n  m3.unlock();\n  return true;\n}\n```", "```cpp\nbool process(... some parameters ... ) {\n  object_counter* p = new object_counter;\n  ... many more lines of code ...\n  delete p;\n  return true;    // Success\n}\n```", "```cpp\nbool process(... some parameters ... ) {\n  object_counter* p = new object_counter;\n  ... many more lines of code ...\n  if (!success) // Cannot continue\n    throw process_exception();\n  ... even more lines of code ...\n  // Won't do anything if an exception is thrown!\n  delete p;\n  return true;\n}\n```", "```cpp\nbool process(... some parameters ... ) {\n  object_counter* p = new object_counter;\n  try {\n    ... many more lines of code ...\n    if (!success) // Cannot continue\n      throw process_exception();\n      ... even more lines of code ...\n  } catch ( ... ) {\n    delete p;    // For exceptional case\n  }\n  delete p;    // For normal case return true;\n}\n```", "```cpp\nstd::mutex m;\nbool process(... some parameters ... ) {\n  m.lock(); // Critical section starts here\n  object_counter* p = new object_counter;\n  // Problem #1: constructor can throw\n  try {\n    ... many more lines of code ...\n    m.unlock();    // Critical section ends here\n    ... even more lines of code ...\n  } catch ( ... ) {\n    delete p;    // OK, always needed\n    m.unlock();    // Do we need this? Maybe…\n    throw;    // Rethrow the exception for the client to handle\n  }\n  delete p;    // For normal case, no need to unlock mutex\n  return true;\n}\n```", "```cpp\n// Example 05\ntemplate <typename T> class raii {\n  public:\n  explicit raii(T* p) : p_(p) {}\n  ~raii() { delete p_; }\n  private:\n  T* p_;\n};\n```", "```cpp\n// Example 05\nTEST(RAII, AcquireRelease) {\n  object_counter::all_count = object_counter::count = 0;\n  {\n    raii<object_counter> p(new object_counter);\n    EXPECT_EQ(1, object_counter::count);\n    EXPECT_EQ(1, object_counter::all_count);\n  } // No need to delete p, it's automatic\n  EXPECT_EQ(0, object_counter::count);\n  EXPECT_EQ(1, object_counter::all_count);\n}\n```", "```cpp\nraii p(new object_counter);\n```", "```cpp\n// Example 05\nstruct my_exception {};\nTEST(Memory, NoLeak) {\n  object_counter::all_count = object_counter::count = 0;\n  try {\n    raii p(new object_counter);\n    throw my_exception();\n  } catch ( my_exception& e ) {\n  }\n  EXPECT_EQ(0, object_counter::count);\n  EXPECT_EQ(1, object_counter::all_count);\n}\n```", "```cpp\n// Example 06\ntemplate <typename T> class scoped_ptr {\n  public:\n  explicit scoped_ptr(T* p) : p_(p) {}\n  ~scoped_ptr() { delete p_; }\n  T* operator->() { return p_; }\n  const T* operator->() const { return p_; }\n  T& operator*() { return *p_; }\n  const T& operator*() const { return *p_; }\n  private:\n  T* p_;\n};\n```", "```cpp\n// Example 06\nTEST(Scoped_ptr, AcquireRelease) {\n  object_counter::all_count = object_counter::count = 0;\n  {\n    scoped_ptr p(new object_counter);\n    EXPECT_EQ(1, object_counter::count);\n    EXPECT_EQ(1, object_counter::all_count);\n  }\n  EXPECT_EQ(0, object_counter::count);\n  EXPECT_EQ(1, object_counter::all_count);\n}\n```", "```cpp\n// Example 06\nTEST(Scoped_ptr, EarlyReturnNoLeak) {\n  object_counter::all_count = object_counter::count = 0;\n  do {\n    scoped_ptr p(new object_counter);\n    break;\n  } while (false);\n  EXPECT_EQ(0, object_counter::count);\n  EXPECT_EQ(1, object_counter::all_count);\n}\nTEST(Scoped_ptr, ThrowNoLeak) {\n  object_counter::all_count = object_counter::count = 0;\n  try {\n    scoped_ptr p(new object_counter);\n   throw 1;\n  } catch ( ... ) {}\n  EXPECT_EQ(0, object_counter::count);\n  EXPECT_EQ(1, object_counter::all_count);\n}\n```", "```cpp\n[----------] 6 tests from Scoped_ptr\n[ RUN      ] Scoped_ptr.AcquireRelease\n[       OK ] Scoped_ptr.AcquireRelease (0 ms)\n[ RUN      ] Scoped_ptr.EarlyReturnNoLeak\n[       OK ] Scoped_ptr.EarlyReturnNoLeak (0 ms)\n[ RUN      ] Scoped_ptr.ThrowNoLeak\n[       OK ] Scoped_ptr.ThrowNoLeak (0 ms)\n[ RUN      ] Scoped_ptr.DataMember\n[       OK ] Scoped_ptr.DataMember (0 ms)\n[ RUN      ] Scoped_ptr.Reset\n[       OK ] Scoped_ptr.Reset (0 ms)\n[ RUN      ] Scoped_ptr.Reseat\n[       OK ] Scoped_ptr.Reseat (0 ms)\n[----------] 6 tests from Scoped_ptr (0 ms total)\n```", "```cpp\nclass A {\n  public:\n  A(object_counter* p) : p_(p) {}\n  private:\n  scoped_ptr<object_counter> p_;\n};\n```", "```cpp\n// Example 07\nvoid BM_rawptr_dereference(benchmark::State& state) {\n  int* p = new int;\n  for (auto _ : state) {\n    REPEAT(benchmark::DoNotOptimize(*p);)\n  }\n  delete p;\n  state.SetItemsProcessed(32*state.iterations());\n}\nvoid BM_scoped_ptr_dereference(benchmark::State& state) {\n  scoped_ptr<int> p(new int);\n  for (auto _ : state) {\n    REPEAT(benchmark::DoNotOptimize(*p);)\n  }\n  state.SetItemsProcessed(32*state.iterations());\n}\nvoid BM_unique_ptr_dereference(benchmark::State& state) {\n  std::unique_ptr<int> p(new int);\n  for (auto _ : state) {\n     REPEAT(benchmark::DoNotOptimize(*p);)\n  }\n  state.SetItemsProcessed(32*state.iterations());\n}\nBENCHMARK(BM_rawptr_dereference);\nBENCHMARK(BM_scoped_ptr_ dereference);\nBENCHMARK(BM_unique_ptr_dereference);\nBENCHMARK_MAIN();\n```", "```cpp\n----------------------------------------------------------------------\nBenchmark                   Time        CPU Iterations UserCounters...\nBM_rawptr_dereference      3.42 ns  3.42 ns  817698667 items_per_second=9.35646G/s\nBM_scoped_ptr_dereference  3.37 ns  3.37 ns  826869427 items_per_second=9.48656G/s\nBM_unique_ptr_dereference  3.42 ns  3.42 ns  827030287 items_per_second=9.36446G/s\n```", "```cpp\n// Example 08\nclass mutex_guard {\n  public:\n  explicit mutex_guard(std::mutex& m) : m_(m) {\n    m_.lock();\n  }\n  ~mutex_guard() { m_.unlock(); }\n  private:\n  std::mutex& m_;\n};\n```", "```cpp\n// Example 08\nstd::mutex m;\nTEST(MutexGuard, ThrowNoLeak) {\n  try {\n    mutex_guard lg(m);\n    EXPECT_FALSE(m.try_lock());    // Expect to be locked\n    throw 1;\n  } catch ( ... ) {}\n  EXPECT_TRUE(m.try_lock());    // Expect to be unlocked\n  m.unlock();    // try_lock() will lock, undo it\n}\n```", "```cpp\n  try {\n    std::lock_guard lg(m);        // C++17 constructor\n    EXPECT_FALSE(m.try_lock());    // Expect to be locked\n    throw 1;\n  } catch ( ... ) {}\n  EXPECT_TRUE(m.try_lock());    // Expect to be unlocked\n```", "```cpp\nvoid process(...) {\n  ... do work that does not need exclusive access ...\n  mutex_guard lg(m);    // Now we lock\n  ... work on shared data, now protected by mutex ...\n} // lock is released here\n```", "```cpp\nvoid process(...) {\n  ... do work that does not need exclusive access ...\n  {\n    mutex_guard lg(m);    // Now we lock\n    ... work on shared data, now protected by mutex ...\n  } // lock is released here\n  ... more non-exclusive work ...\n}\n```", "```cpp\n// Example 08\nvoid process(...) {\n  ... do work that does not need exclusive access ...\n  do {    // Not really a loop\n    mutex_guard lg(m);    // Now we lock\n    ... work on shared data, now protected by mutex ...\n    if (work_done) break;    // Exit the scope\n    ... work on the shared data some more ...\n  } while (false);        // lock is released here\n  ... more non-exclusive work ...\n}\n```", "```cpp\n// Example 06\ntemplate <typename T> class scoped_ptr {\n  public:\n  explicit scoped_ptr(T* p) : p_(p) {}\n  ~scoped_ptr() { delete p_; }\n  ...\n  void reset() {\n    delete p_;\n    p_ = nullptr;     // Releases resource early private:\n  }\n  T* p_;\n};\n```", "```cpp\n// Example 08\nclass mutex_guard {\n  public:\n  explicit mutex_guard(std::mutex& m) :\n    m_(m), must_unlock_(true) { m_.lock(); }\n  ~mutex_guard() { if (must_unlock_) m_.unlock(); }\n   void reset() { m_.unlock(); must_unlock_ = false; }\n  private:\n  std::mutex& m_;\n  bool must_unlock_;\n};\n```", "```cpp\nTEST(MutexGuard, Reset) {\n  {\n    mutex_guard lg(m);\n    EXPECT_FALSE(m.try_lock());\n    lg.reset();\n    EXPECT_TRUE(m.try_lock()); m.unlock();\n  }\n  EXPECT_TRUE(m.try_lock()); m.unlock();\n}\n```", "```cpp\n// Example 08\nTEST(LockGuard, Reset) {\n  {\n    std::unique_lock lg(m);\n    EXPECT_FALSE(m.try_lock());\n    lg.unlock();\n    EXPECT_TRUE(m.try_lock()); m.unlock();\n  }\n  EXPECT_TRUE(m.try_lock()); m.unlock();\n}\n```", "```cpp\ntemplate <typename T> class scoped_ptr {\n  public:\n  explicit scoped_ptr(T* p) : p_(p) {}\n  ~scoped_ptr() { delete p_; }\n  ...\n  void reset(T* p = nullptr) {\n    delete p_; p_ = p;    // Reseat the pointer\n  }\n  private:\n  T* p_;\n};\n```", "```cpp\nscoped_ptr<object_counter> p(new object_counter);\nscoped_ptr<object_counter> p1(p);\n```", "```cpp\nscoped_ptr<object_counter> p(new object_counter);\nscoped_ptr<object_counter> p1(new object_counter);\np = p1;\n```", "```cpp\ntemplate <typename T> class scoped_ptr {\n  public:\n  explicit scoped_ptr(T* p) : p_(p) {}\n  ~scoped_ptr() { delete p_; }\n  ...\n  private:\n  T* p_;\n  scoped_ptr(const scoped_ptr&) = delete;\n  scoped_ptr& operator=(const scoped_ptr&) = delete;\n};\n```", "```cpp\nstd::unique_ptr<int> p;\n{\n  // Can be moved out of the scope\n  std::unique_ptr<int> q(new int);\n  q = std::move(p);    // and here it happens\n  // True scoped pointer, cannot be moved anywhere\n  const std::unique_ptr<int> r(new int);\n  q = std::move(r);    // Does not compile\n}\n```", "```cpp\nscoped_ptr<int> p(new int[10]);\n```", "```cpp\nclass raii {\n  ...\n  ~raii() {\n    try {\n      release_resource();    // Might throw\n    } catch ( ... ) {\n      ... handle the exception, do NOT rethrow ...\n    }\n  }\n};\n```", "```cpp\n// Example 09a\nclass lock_guard {\n  std::mutex& m_;\n  const bool log_;\n  const bool mt_;\n  public:\n  lock_guard(std::mutex& m, bool log, bool mt);\n  ~lock_guard();\n};\nlock_guard ::lock_guard(std::mutex& m, bool log, bool mt)\n  : m_(m), log_(log), mt_(mt) {\n  if (log_) std::cout << \"Before locking\" << std::endl;\n  if (mt_) m.lock();\n}\nlock_guard::~lock_guard() {\n  if (mt_) m.unlock();\n  if (log_) std::cout << \"After locking\" << std::endl;\n}\n```", "```cpp\n#include <mutex>\nstd::mutex m;\nconst bool mt_run = true;\nvoid work() {\n  try {\n    lock_guard lg(m, true, mt_run);\n    … this code might throw …\n    std::cout << \"Work is happening\" << std::endl;\n  } catch (...) {}\n}\n```", "```cpp\n#include <mutex>\nstd::mutex m;\nconst bool mt_run = true;\nco_resource<std::mutex> make_guard(std::mutex& m, bool log)\n{\n  if (log) std::cout << \"Before locking\" << std::endl;\n  if (mt_run) m.lock();\n  co_yield m;\n  if (mt_run) m.unlock();\n  if (log) std::cout << \"After locking\" << std::endl;\n}\nvoid work () {\n  try {\n    co_resource<std::mutex> lg { make_guard(m, true) };\n    … this code might throw …\n    std::cout << \"Work is happening\" << std::endl;\n  } catch (...) {}\n}\n```", "```cpp\n// Example 09\n#include <cassert>\n#include <coroutine>\n#include <cstddef>\n#include <memory>\n#include <utility>\ntemplate <typename T> class co_resource {\n  public:\n  using promise_type = struct promise_type<T>;\n  using handle_type = std::coroutine_handle<promise_type>;\n  co_resource(handle_type coro) : coro_(coro) {}\n  co_resource(const co_resource&) = delete;\n  co_resource& operator=(const co_resource&) = delete;\n  co_resource(co_resource&& from)\n     : coro_(std::exchange(from.coro_, nullptr)) {}\n  co_resource& operator=(co_resource&& from) {\n    std::destroy_at(this);\n    std::construct_at(this, std::move(from));\n    return *this;\n  }\n  ~co_resource() {\n    if (!coro_) return;\n    coro_.resume();     // Resume from the co_yield point\n    coro_.destroy();    // Clean up\n  }\n  private:\n  handle_type coro_;\n};\n```", "```cpp\ntemplate <typename T> struct promise_type {\n  const T* yielded_value_p = nullptr;\n  std::suspend_never initial_suspend() noexcept {\n    return {};\n  }\n  std::suspend_always final_suspend() noexcept {\n    return {};\n  }\n  void return_void() noexcept {}\n  void unhandled_exception() { throw; }\n  std::suspend_always yield_value(const T& val) noexcept {\n    yielded_value_p = &val;\n    return {};\n  }\n  using handle_type = std::coroutine_handle<promise_type>;\n  handle_type get_return_object() {\n    return handle_type::from_promise(*this);\n  }\n};\n```", "```cpp\nco_resource<std::mutex> make_guard(std::mutex& m, bool log)\n{\n  if (log) std::cout << \"Before locking\" << std::endl;\n  if (mt_run) m.lock();\n  co_yield m;\n  if (mt_run) m.unlock();\n  if (log) std::cout << \"After locking\" << std::endl;\n}\n```", "```cpp\nco_resource<std::mutex> lg { make_guard(m, true) };\n```", "```cpp\nvoid work(){\n  try {\n    auto lg { [&](bool log)->co_resource<std::mutex> {\n      if (log) std::cout << \"Before locking\" << std::endl;\n      if (mt_run) m.lock();\n      co_yield m;\n      if (mt_run) m.unlock();\n      if (log) std::cout << \"After locking\" << std::endl;\n    }(true) };\n    … this code might throw …\n    std::cout << \"Work is happening\" << std::endl;\n  } catch (...) {}\n}\n```"]