<html><head></head><body>
  <div id="_idContainer029">
   <h1 class="chapter-number" id="_idParaDest-52">
    <a id="_idTextAnchor051">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     3
    </span>
   </h1>
   <h1 id="_idParaDest-53">
    <a id="_idTextAnchor052">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     How to Create and Manage Threads in C++
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     As we learned in the previous two chapters, threads are the smallest and most lightweight units of execution within a program.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     Each thread takes care of a unique task defined by a sequence of instructions running on allocated CPU resources by the OS scheduler.
    </span>
    <span class="koboSpan" id="kobo.3.3">
     Threads play a critical role when managing concurrency within a program aiming to maximize the overall utilization of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      CPU resources.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     During the program’s startup process, after the kernel passes the execution to the process, the C++ runtime creates the main thread and executes the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.6.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.7.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.7.2">
     After that, additional threads can be created to split the program into different tasks that can run concurrently and share resources.
    </span>
    <span class="koboSpan" id="kobo.7.3">
     This way, the program can handle multiple tasks, improving efficiency
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.8.1">
      and responsiveness.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.9.1">
     In this chapter, we will learn the basics of how to create and manage threads using modern C++ features.
    </span>
    <span class="koboSpan" id="kobo.9.2">
     In the subsequent chapters, we will come across explanations of C++ lock synchronization primitives (mutexes, semaphores, barriers, and spinlocks), lock-free synchronization primitives (atomic variables), coordination synchronization primitives (condition variables), and approaches using C++ to solve or avoid potential problems when using concurrency or multithreading (race conditions or data races, deadlocks, livelocks, starvation, oversubscription, load balancing, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.10.1">
      thread exhaustion).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.11.1">
     In this chapter, we are going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.12.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.13.1">
      How to create, manage, and cancel threads
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.14.1">
       in C++
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.15.1">
      How to pass arguments to threads and get results back from
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.16.1">
       the thread
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.17.1">
      How to sleep a thread or yield execution to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.18.1">
       other threads
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.19.1">
      What jthread objects are and why they
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.20.1">
       are useful
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-54">
    <a id="_idTextAnchor053">
    </a>
    <span class="koboSpan" id="kobo.21.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.22.1">
     In this chapter, we will develop different solutions using C++11 and C++20.
    </span>
    <span class="koboSpan" id="kobo.22.2">
     Therefore, we will need to install the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.23.1">
      GNU Compiler Collection
     </span>
    </strong>
    <span class="koboSpan" id="kobo.24.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.25.1">
      GCC
     </span>
    </strong>
    <span class="koboSpan" id="kobo.26.1">
     ), specifically GCC 13, as well as Clang 8 (see
    </span>
    <a href="https://en.cppreference.com/w/cpp/compiler_support">
     <span class="koboSpan" id="kobo.27.1">
      https://en.cppreference.com/w/cpp/compiler_support
     </span>
    </a>
    <span class="koboSpan" id="kobo.28.1">
     for further details on C++
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.29.1">
      compiler support).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.30.1">
     You can find more information about GCC at
    </span>
    <a href="https://gcc.gnu.org">
     <span class="koboSpan" id="kobo.31.1">
      https://gcc.gnu.org
     </span>
    </a>
    <span class="koboSpan" id="kobo.32.1">
     .
    </span>
    <span class="koboSpan" id="kobo.32.2">
     You can find information on how to install GCC
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.33.1">
      here:
     </span>
    </span>
    <a href="https://gcc.gnu.org/install/index.html">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.34.1">
       https://gcc.gnu.org/install/index.html
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.35.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.36.1">
     For more information about Clang, a compiler frontend supporting several languages including C++, visit
    </span>
    <a href="https://clang.llvm.org">
     <span class="koboSpan" id="kobo.37.1">
      https://clang.llvm.org
     </span>
    </a>
    <span class="koboSpan" id="kobo.38.1">
     .
    </span>
    <span class="koboSpan" id="kobo.38.2">
     Clang is part of the LLVM compiler infrastructure project (
    </span>
    <a href="https://llvm.org">
     <span class="koboSpan" id="kobo.39.1">
      https://llvm.org
     </span>
    </a>
    <span class="koboSpan" id="kobo.40.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.40.2">
     C++ support in Clang is documented
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.41.1">
      here:
     </span>
    </span>
    <a href="https://clang.llvm.org/cxx_status.html">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.42.1">
       https://clang.llvm.org/cxx_status.html
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.43.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.44.1">
     In this book, some code snippets do not show the libraries included.
    </span>
    <span class="koboSpan" id="kobo.44.2">
     Additionally, some functions, even the main ones, might be simplified, showing only the relevant instructions.
    </span>
    <span class="koboSpan" id="kobo.44.3">
     You can find all the complete code in the following GitHub
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.45.1">
      repository:
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.46.1">
       https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.47.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.48.1">
     Under the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.49.1">
      scripts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.50.1">
     folder in the root directory in the preceding GitHub repository, you can find a script called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.51.1">
      install_compilers.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.52.1">
     that might be of help with installing the required compilers in Debian-based Linux systems.
    </span>
    <span class="koboSpan" id="kobo.52.2">
     The script has been tested in Ubuntu 22.04
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.53.1">
      and 24.04.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.54.1">
     The examples for this chapter are located under the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.55.1">
      Chapter_03
     </span>
    </strong>
    <span class="koboSpan" id="kobo.56.1">
     folder.
    </span>
    <span class="koboSpan" id="kobo.56.2">
     All source code files can be compiled using C++20 with CMake
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.57.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.58.1">
cmake . </span><span class="koboSpan" id="kobo.58.2">&amp;&amp; cmake —build .</span></pre>
   <p>
    <span class="koboSpan" id="kobo.59.1">
     Executables will be generated under the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.60.1">
       bin
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.61.1">
      directory.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-55">
    <a id="_idTextAnchor054">
    </a>
    <span class="koboSpan" id="kobo.62.1">
     The thread library – an introduction
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.63.1">
     The main library to
    </span>
    <a id="_idIndexMarker157">
    </a>
    <span class="koboSpan" id="kobo.64.1">
     create and manage threads in C++ is the thread library.
    </span>
    <span class="koboSpan" id="kobo.64.2">
     First, let’s go through a recap about threads.
    </span>
    <span class="koboSpan" id="kobo.64.3">
     Then we will dive into what the thread
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.65.1">
      library offers.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-56">
    <a id="_idTextAnchor055">
    </a>
    <span class="koboSpan" id="kobo.66.1">
     What are threads?
    </span>
    <span class="koboSpan" id="kobo.66.2">
     Let’s do a recap
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.67.1">
     The purpose of
    </span>
    <a id="_idIndexMarker158">
    </a>
    <span class="koboSpan" id="kobo.68.1">
     threads is to execute multiple simultaneous tasks in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.69.1">
      a process.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.70.1">
     As we have
    </span>
    <a id="_idIndexMarker159">
    </a>
    <span class="koboSpan" id="kobo.71.1">
     seen in the previous chapter, a thread has its own stack, local data, and CPU registers such as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.72.1">
      Instruction Pointer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.73.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.74.1">
      IP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.75.1">
     ) and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.76.1">
      Stack Pointer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.77.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.78.1">
      SP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.79.1">
     ), but
    </span>
    <a id="_idIndexMarker160">
    </a>
    <span class="koboSpan" id="kobo.80.1">
     shares the address space and virtual memory of its
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.81.1">
      parent process.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.82.1">
     In the user space, we can differentiate
    </span>
    <a id="_idIndexMarker161">
    </a>
    <span class="koboSpan" id="kobo.83.1">
     between
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.84.1">
      native threads
     </span>
    </strong>
    <span class="koboSpan" id="kobo.85.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.86.1">
      lightweight or virtual threads
     </span>
    </strong>
    <span class="koboSpan" id="kobo.87.1">
     .
    </span>
    <span class="koboSpan" id="kobo.87.2">
     Native
    </span>
    <a id="_idIndexMarker162">
    </a>
    <span class="koboSpan" id="kobo.88.1">
     threads are the ones created by
    </span>
    <a id="_idIndexMarker163">
    </a>
    <span class="koboSpan" id="kobo.89.1">
     the OS when using some kernel APIs.
    </span>
    <span class="koboSpan" id="kobo.89.2">
     The C++ thread objects create and manage these types of threads.
    </span>
    <span class="koboSpan" id="kobo.89.3">
     On the other hand, lightweight threads are like native threads, except that they are emulated by a runtime or library.
    </span>
    <span class="koboSpan" id="kobo.89.4">
     In C++,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.90.1">
      coroutines
     </span>
    </strong>
    <span class="koboSpan" id="kobo.91.1">
     belong
    </span>
    <a id="_idIndexMarker164">
    </a>
    <span class="koboSpan" id="kobo.92.1">
     to this group.
    </span>
    <span class="koboSpan" id="kobo.92.2">
     As described in the previous chapter, lightweight threads have faster context switching than native threads.
    </span>
    <span class="koboSpan" id="kobo.92.3">
     Also, multiple lightweight threads can run in the same native thread and can be much smaller than
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.93.1">
      native threads.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.94.1">
     In this chapter, we will start learning about native threads.
    </span>
    <span class="koboSpan" id="kobo.94.2">
     In
    </span>
    <a href="B22219_08.xhtml#_idTextAnchor164">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.95.1">
        Chapter 8
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.96.1">
     , we will learn about lightweight threads in the form
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.97.1">
      of coroutines.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-57">
    <a id="_idTextAnchor056">
    </a>
    <span class="koboSpan" id="kobo.98.1">
     The C++ thread library
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.99.1">
     In C++, threads allow
    </span>
    <a id="_idIndexMarker165">
    </a>
    <span class="koboSpan" id="kobo.100.1">
     multiple functions to run concurrently.
    </span>
    <span class="koboSpan" id="kobo.100.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.101.1">
      thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.102.1">
     class defines a type-safe interface to a native thread.
    </span>
    <span class="koboSpan" id="kobo.102.2">
     This class is defined in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.103.1">
      std::thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.104.1">
     library, in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.105.1">
      &lt;thread&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.106.1">
     header file in
    </span>
    <a id="_idIndexMarker166">
    </a>
    <span class="koboSpan" id="kobo.107.1">
     the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.108.1">
      Standard Template Library
     </span>
    </strong>
    <span class="koboSpan" id="kobo.109.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.110.1">
      STL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.111.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.111.2">
     It is available from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.112.1">
      C++11 onward.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.113.1">
     Before the inclusion of the thread library in the C++ STL, developers used platform-specific libraries such as the POSIX thread (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.114.1">
      pthread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.115.1">
     ) library in Unix or Linux OSs, the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.116.1">
      C Runtime
     </span>
    </strong>
    <span class="koboSpan" id="kobo.117.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.118.1">
      CRT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.119.1">
     ) and Win32
    </span>
    <a id="_idIndexMarker167">
    </a>
    <span class="koboSpan" id="kobo.120.1">
     libraries for Windows NT and CE systems, or third-party libraries such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.121.1">
      Boost.Threads
     </span>
    </strong>
    <span class="koboSpan" id="kobo.122.1">
     .
    </span>
    <span class="koboSpan" id="kobo.122.2">
     In this book, we will only use modern C++ features.
    </span>
    <span class="koboSpan" id="kobo.122.3">
     As
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.123.1">
      &lt;thread&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.124.1">
     is available and provides a portable abstraction on top of platform-specific mechanisms, none of these libraries will be used or explained.
    </span>
    <span class="koboSpan" id="kobo.124.2">
     In
    </span>
    <a href="B22219_09.xhtml#_idTextAnchor184">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.125.1">
        Chapter 9
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.126.1">
     , we will introduce
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.127.1">
      Boost.Asio
     </span>
    </strong>
    <span class="koboSpan" id="kobo.128.1">
     , and in
    </span>
    <a href="B22219_10.xhtml#_idTextAnchor212">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.129.1">
        Chapter 10
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.130.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.131.1">
      Boost.Cobalt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.132.1">
     .
    </span>
    <span class="koboSpan" id="kobo.132.2">
     Both libraries provide advanced frameworks to deal with asynchronous I/O operations
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.133.1">
      and coroutines.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.134.1">
     Now it’s time to learn about the different
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.135.1">
      thread operations.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-58">
    <a id="_idTextAnchor057">
    </a>
    <span class="koboSpan" id="kobo.136.1">
     Thread operations
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.137.1">
     In this section, we will learn
    </span>
    <a id="_idIndexMarker168">
    </a>
    <span class="koboSpan" id="kobo.138.1">
     how to create threads, pass
    </span>
    <a id="_idIndexMarker169">
    </a>
    <span class="koboSpan" id="kobo.139.1">
     arguments during their construction, return values from threads, cancel threads execution, catch exceptions, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.140.1">
      much more.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-59">
    <a id="_idTextAnchor058">
    </a>
    <span class="koboSpan" id="kobo.141.1">
     Thread creation
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.142.1">
     When a thread is created, it executes
    </span>
    <a id="_idIndexMarker170">
    </a>
    <span class="koboSpan" id="kobo.143.1">
     immediately.
    </span>
    <span class="koboSpan" id="kobo.143.2">
     It is only delayed by the OS scheduling process.
    </span>
    <span class="koboSpan" id="kobo.143.3">
     If there are not enough resources to run both parent and child threads in parallel, the order in which they will run is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.144.1">
      not defined.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.145.1">
     The constructor argument defines the function or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.146.1">
      function
     </span>
    </strong>
    <span class="koboSpan" id="kobo.147.1">
     object to be executed by the thread.
    </span>
    <span class="koboSpan" id="kobo.147.2">
     This callable object should not return anything, as its return value will be ignored.
    </span>
    <span class="koboSpan" id="kobo.147.3">
     If for some reason the thread execution ends with an exception,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.148.1">
      std::terminate
     </span>
    </strong>
    <span class="koboSpan" id="kobo.149.1">
     is called unless an exception is caught, as we will see later in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.150.1">
      this chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.151.1">
     In the following examples, we create six threads using different
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.152.1">
      callable objects.
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.153.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.154.1">
     using a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.155.1">
      function pointer:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.156.1">
void func() {
    std::cout &lt;&lt; "Using function pointer\n";
}
std::thread t1(func);</span></pre>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.157.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.158.1">
     using a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.159.1">
      lambda function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.160.1">
auto lambda_func = []() {
    std::cout &lt;&lt; "Using lambda function\n";
};
std::thread t2(lambda_func);</span></pre>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.161.1">
      t3
     </span>
    </strong>
    <span class="koboSpan" id="kobo.162.1">
     using an embedded
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.163.1">
      lambda function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.164.1">
std::thread t3([]() {
    std::cout &lt;&lt; "Using embedded lambda function\n";
});</span></pre>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.165.1">
      t4
     </span>
    </strong>
    <span class="koboSpan" id="kobo.166.1">
     using a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.167.1">
      function
     </span>
    </strong>
    <span class="koboSpan" id="kobo.168.1">
     object where
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.169.1">
      operator()
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.170.1">
      is overloaded:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.171.1">
class FuncObjectClass {
   public:
    void operator()() {
        std::cout &lt;&lt; "Using function object class\n";
    }
};
std::thread t4{FuncObjectClass()};</span></pre>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.172.1">
      t5
     </span>
    </strong>
    <span class="koboSpan" id="kobo.173.1">
     using a non-static
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.174.1">
      member
     </span>
    </strong>
    <span class="koboSpan" id="kobo.175.1">
     function by
    </span>
    <a id="_idIndexMarker171">
    </a>
    <span class="koboSpan" id="kobo.176.1">
     passing the address of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.177.1">
      member
     </span>
    </strong>
    <span class="koboSpan" id="kobo.178.1">
     function and the address of an object to call the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.179.1">
       member
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.180.1">
      function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.181.1">
class Obj {
  public:
    void func() {
        std::cout &lt;&lt; "Using a non-static member function"
                  &lt;&lt; std::endl;
    }
};
Obj obj;
std::thread t5(&amp;Obj::func, &amp;obj);</span></pre>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.182.1">
      t6
     </span>
    </strong>
    <span class="koboSpan" id="kobo.183.1">
     using a static
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.184.1">
      member
     </span>
    </strong>
    <span class="koboSpan" id="kobo.185.1">
     function where only the
    </span>
    <a id="_idIndexMarker172">
    </a>
    <span class="koboSpan" id="kobo.186.1">
     address of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.187.1">
      member
     </span>
    </strong>
    <span class="koboSpan" id="kobo.188.1">
     function is needed as the method
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.189.1">
      is static:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.190.1">
class Obj {
  public:
    static void static_func() {
        std::cout &lt;&lt; "Using a static member function\n";
    }
};
std::thread t6(&amp;Obj::static_func);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.191.1">
     Thread creation incurs some overhead that can be reduced by using thread pools, as we will explore in
    </span>
    <a href="B22219_04.xhtml#_idTextAnchor074">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.192.1">
        Chapter 4
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.193.1">
      .
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.194.1">
     Checking hardware concurrency
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.195.1">
     One of the strategies for effective thread
    </span>
    <a id="_idIndexMarker173">
    </a>
    <span class="koboSpan" id="kobo.196.1">
     management, which is related to scalability and performance and was
    </span>
    <a id="_idIndexMarker174">
    </a>
    <span class="koboSpan" id="kobo.197.1">
     commented on in the previous chapter, is to balance the number of threads with the available resources to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.198.1">
      avoid over-subscription.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.199.1">
     To retrieve the number of concurrent threads supported by the OS, we can use the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.200.1">
       std::thread::hardware_concurrency()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.201.1">
      function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.202.1">
const auto processor_count = std::thread::hardware_concurrency();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.203.1">
     The value returned by this function must be considered to only provide a hint about the number of threads that will run concurrently.
    </span>
    <span class="koboSpan" id="kobo.203.2">
     It is also sometimes not well defined, thus returning a value
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.204.1">
      of
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.205.1">
       0
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.206.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-60">
    <a id="_idTextAnchor059">
    </a>
    <span class="koboSpan" id="kobo.207.1">
     Synchronized stream writing
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.208.1">
     When we print
    </span>
    <a id="_idIndexMarker175">
    </a>
    <span class="koboSpan" id="kobo.209.1">
     messages to the
    </span>
    <a id="_idIndexMarker176">
    </a>
    <span class="koboSpan" id="kobo.210.1">
     console by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.211.1">
      std::cout
     </span>
    </strong>
    <span class="koboSpan" id="kobo.212.1">
     from two or more threads, the output result can be messy.
    </span>
    <span class="koboSpan" id="kobo.212.2">
     This is due to a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.213.1">
      race condition
     </span>
    </strong>
    <span class="koboSpan" id="kobo.214.1">
     happening in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.215.1">
      output stream.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.216.1">
     As commented in the previous chapter, race conditions are bugs in software that happen in concurrent and multithreaded programs, whose behavior depends on the sequence of events happening on a shared resource where at least one of the actions is not atomic.
    </span>
    <span class="koboSpan" id="kobo.216.2">
     We will learn more about how to avoid them in
    </span>
    <a href="B22219_04.xhtml#_idTextAnchor074">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.217.1">
        Chapter 4
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.218.1">
     .
    </span>
    <span class="koboSpan" id="kobo.218.2">
     Additionally, we will learn how to debug race conditions using Clang’s sanitizers in
    </span>
    <a href="B22219_12.xhtml#_idTextAnchor243">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.219.1">
        Chapter 12
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.220.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.221.1">
     The following code snippet shows two threads printing a sequence of numbers.
    </span>
    <span class="koboSpan" id="kobo.221.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.222.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.223.1">
     thread should print lines containing the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.224.1">
      1 2 3 4
     </span>
    </strong>
    <span class="koboSpan" id="kobo.225.1">
     sequence.
    </span>
    <span class="koboSpan" id="kobo.225.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.226.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.227.1">
     thread should print the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.228.1">
      5 6 7 8
     </span>
    </strong>
    <span class="koboSpan" id="kobo.229.1">
     sequence.
    </span>
    <span class="koboSpan" id="kobo.229.2">
     Each thread prints its sequence 100 times.
    </span>
    <span class="koboSpan" id="kobo.229.3">
     Before the main thread exits, it waits for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.230.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.231.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.232.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.233.1">
     to finish by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.234.1">
      join()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.235.1">
     .
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.236.1">
     More about joining threads later in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.237.1">
      this chapter.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.238.1">
#include &lt;iostream&gt;
#include &lt;thread&gt;
int main() {
    std::thread t1([]() {
        for (int i = 0; i &lt; 100; ++i) {
            std::cout &lt;&lt; "1 " &lt;&lt; "2 " &lt;&lt; "3 " &lt;&lt; "4 "
                      &lt;&lt; std::endl;
        }
    });
    std::thread t2([]() {
        for (int i = 0; i &lt; 100; ++i) {
            std::cout &lt;&lt; "5 " &lt;&lt; "6 " &lt;&lt; "7 " &lt;&lt; "8 "
                      &lt;&lt; std::endl;
        }
    });
    t1.join();
    t2.join();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.239.1">
     However, running the previous example shows some lines with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.240.1">
      following content:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.241.1">
6 1 2 3 4
1 5 2 6 3 4 7 8
1 2 3 5 6 7 8</span></pre>
   <p>
    <span class="koboSpan" id="kobo.242.1">
     To avoid these issues, we can
    </span>
    <a id="_idIndexMarker177">
    </a>
    <span class="koboSpan" id="kobo.243.1">
     simply write from a specific thread or use a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.244.1">
      std::ostringstream
     </span>
    </strong>
    <span class="koboSpan" id="kobo.245.1">
     object that makes atomic calls to the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.246.1">
       std::cout
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.247.1">
      object:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.248.1">
std::ostringstream oss;
oss &lt;&lt; "1 " &lt;&lt; "2 " &lt;&lt; "3 " &lt;&lt; "4 " &lt;&lt; "\n";
std::cout &lt;&lt; oss.str();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.249.1">
     From C++20 onward, we also can use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.250.1">
      std::osyncstream
     </span>
    </strong>
    <span class="koboSpan" id="kobo.251.1">
     objects.
    </span>
    <span class="koboSpan" id="kobo.251.2">
     They behave similarly to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.252.1">
      std::cout
     </span>
    </strong>
    <span class="koboSpan" id="kobo.253.1">
     but with writing
    </span>
    <a id="_idIndexMarker178">
    </a>
    <span class="koboSpan" id="kobo.254.1">
     synchronization between threads accessing the same stream.
    </span>
    <span class="koboSpan" id="kobo.254.2">
     However, as only the transfer step from its internal buffer to the output stream is synchronized, every thread needs its own
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.255.1">
       std::osyncstream
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.256.1">
      instance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.257.1">
     The internal buffer is transferred when the stream is destroyed, which is when
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.258.1">
      emit()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.259.1">
     is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.260.1">
      explicitly called.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.261.1">
     The following is a simple solution to allow
    </span>
    <a id="_idIndexMarker179">
    </a>
    <span class="koboSpan" id="kobo.262.1">
     synchronization on each
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.263.1">
      printed line:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.264.1">
#include &lt;iostream&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
int main() {
    std::thread t1([]() {
        for (int i = 0; i &lt; 100; ++i) {
            sync_cout &lt;&lt; "1 " &lt;&lt; "2 " &lt;&lt; "3 " &lt;&lt; "4 "
                      &lt;&lt; std::endl;
        }
    });
    std::thread t2([]() {
        for (int i = 0; i &lt; 100; ++i) {
            sync_cout &lt;&lt; "5 " &lt;&lt; "6 " &lt;&lt; "7 " &lt;&lt; "8 "
                      &lt;&lt; std::endl;
        }
    });
    t1.join();
    t2.join();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.265.1">
     Both solutions will output the sequences without
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.266.1">
      interleaving them
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.267.1">
1 2 3 4
1 2 3 4
5 6 7 8</span></pre>
   <p>
    <span class="koboSpan" id="kobo.268.1">
     As this approach is now the
    </span>
    <a id="_idIndexMarker180">
    </a>
    <span class="koboSpan" id="kobo.269.1">
     official C++20 way of avoiding race conditions when outputting content, we will use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.270.1">
      std::osyncstream
     </span>
    </strong>
    <span class="koboSpan" id="kobo.271.1">
     as the default approach throughout the rest of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.272.1">
      this book.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-61">
    <a id="_idTextAnchor060">
    </a>
    <span class="koboSpan" id="kobo.273.1">
     Sleeping the current thread
    </span>
   </h2>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.274.1">
      std::this_thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.275.1">
     is a
    </span>
    <a id="_idIndexMarker181">
    </a>
    <span class="koboSpan" id="kobo.276.1">
     namespace.
    </span>
    <span class="koboSpan" id="kobo.276.2">
     It gives access to
    </span>
    <a id="_idIndexMarker182">
    </a>
    <span class="koboSpan" id="kobo.277.1">
     functions from the current thread to yield the execution to another thread or block the execution of the current task and wait for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.278.1">
      a period.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.279.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.280.1">
      std::this_thread::sleep_for
     </span>
    </strong>
    <span class="koboSpan" id="kobo.281.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.282.1">
      std::this_thread::sleep_until
     </span>
    </strong>
    <span class="koboSpan" id="kobo.283.1">
     functions block the execution of the thread for a given amount
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.284.1">
      of time.
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.285.1">
      std::this_thread::sleep_for
     </span>
    </strong>
    <span class="koboSpan" id="kobo.286.1">
     sleeps for at least a given duration.
    </span>
    <span class="koboSpan" id="kobo.286.2">
     The blockage can be longer depending on how the OS scheduler decides to run tasks, or due to some resource
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.287.1">
      contention delays.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.288.1">
     Resource contention
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.289.1">
     Resource contention occurs when demand exceeds supply for a certain shared resource, leading to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.290.1">
      performance degradation.
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.291.1">
      std::this_thread::sleep_until
     </span>
    </strong>
    <span class="koboSpan" id="kobo.292.1">
     works like
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.293.1">
      std::this_thread::sleep_for
     </span>
    </strong>
    <span class="koboSpan" id="kobo.294.1">
     .
    </span>
    <span class="koboSpan" id="kobo.294.2">
     However, instead of sleeping for a
    </span>
    <a id="_idIndexMarker183">
    </a>
    <span class="koboSpan" id="kobo.295.1">
     duration, it sleeps until a specific time point has been reached.
    </span>
    <span class="koboSpan" id="kobo.295.2">
     The clock where the time point is
    </span>
    <a id="_idIndexMarker184">
    </a>
    <span class="koboSpan" id="kobo.296.1">
     computed must meet the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.297.1">
      Clock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.298.1">
     requirement (you can find more information on this here:
    </span>
    <a href="https://en.cppreference.com/w/cpp/named_req/Clock">
     <span class="koboSpan" id="kobo.299.1">
      https://en.cppreference.com/w/cpp/named_req/Clock
     </span>
    </a>
    <span class="koboSpan" id="kobo.300.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.300.2">
     It is recommended by the standard to use a steady clock instead of the system clock to set up
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.301.1">
      the duration.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-62">
    <a id="_idTextAnchor061">
    </a>
    <span class="koboSpan" id="kobo.302.1">
     Identifying a thread
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.303.1">
     When debugging
    </span>
    <a id="_idIndexMarker185">
    </a>
    <span class="koboSpan" id="kobo.304.1">
     multithreaded solutions, it is useful to know which thread is executing a given function.
    </span>
    <span class="koboSpan" id="kobo.304.2">
     Each thread can be identified by an identifier, making it possible to log in its value for traceability
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.305.1">
      and debugging.
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.306.1">
      std::thread::id
     </span>
    </strong>
    <span class="koboSpan" id="kobo.307.1">
     is a lightweight class that defines a unique identifier of thread objects (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.308.1">
      std::thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.309.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.310.1">
      std::jthread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.311.1">
     , which we will introduce later in this chapter).
    </span>
    <span class="koboSpan" id="kobo.311.2">
     This identifier is retrieved by using the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.312.1">
       get_id()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.313.1">
      function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.314.1">
     Thread identifier objects can be compared, serialized, and printed via an output stream.
    </span>
    <span class="koboSpan" id="kobo.314.2">
     They can also be used as a key in mapping containers, as they are supported by the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.315.1">
       std::hash
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.316.1">
      function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.317.1">
     The following example prints the identifier of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.318.1">
      t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.319.1">
     thread.
    </span>
    <span class="koboSpan" id="kobo.319.2">
     Later in this chapter, we will learn how to create a thread and sleep for an interval
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.320.1">
      of time:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.321.1">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
void func() {
    std::this_thread::sleep_for(1s);
}
int main() {
    std::thread t(func);
    std::cout &lt;&lt; "Thread ID: " &lt;&lt; t.get_id() &lt;&lt; std::endl;
    t.join();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.322.1">
     Remember that when a thread finishes, its identifier can be reused by a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.323.1">
      future thread.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-63">
    <a id="_idTextAnchor062">
    </a>
    <span class="koboSpan" id="kobo.324.1">
     Passing arguments
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.325.1">
     Arguments
    </span>
    <a id="_idIndexMarker186">
    </a>
    <span class="koboSpan" id="kobo.326.1">
     can be passed to the thread by value, by reference, or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.327.1">
      as pointers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.328.1">
     Here we can see how to pass
    </span>
    <a id="_idIndexMarker187">
    </a>
    <a id="_idIndexMarker188">
    </a>
    <span class="koboSpan" id="kobo.329.1">
     arguments
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.330.1">
      by value:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.331.1">
void funcByValue(const std::string&amp; str, int val) {
    sync_cout &lt;&lt; «str: « &lt;&lt; str &lt;&lt; «, val: « &lt;&lt; val
              &lt;&lt; std::endl;
}
std::string str{"Passing by value"};
std::thread t(funcByValue, str, 1);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.332.1">
     Passing by value avoids data races.
    </span>
    <span class="koboSpan" id="kobo.332.2">
     However, it is much more costly, as data is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.333.1">
      copied across.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.334.1">
     The next example shows how to pass values
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.335.1">
      by reference:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.336.1">
void modifyValues(std::string&amp; str, int&amp; val) {
    str += " (Thread)";
    val++;
}
std::string str{"Passing by reference"};
int val = 1;
std::thread t(modifyValues, std::ref(str), std::ref(val));</span></pre>
   <p>
    <span class="koboSpan" id="kobo.337.1">
     Or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.338.1">
      as
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.339.1">
       const-reference
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.340.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.341.1">
void printVector(const std::vector&lt;int&gt;&amp; v) {
    sync_cout &lt;&lt; "Vector: ";
    for (int num : v) {
        sync_cout &lt;&lt; num &lt;&lt; " ";
    }
    sync_cout &lt;&lt; std::endl;
}
std::vector&lt;int&gt; v{1, 2, 3, 4, 5};
std::thread t(printVector, std::cref(v));</span></pre>
   <p>
    <span class="koboSpan" id="kobo.342.1">
     Passing by reference is achieved by using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.343.1">
      ref()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.344.1">
     (non-const references) or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.345.1">
      cref()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.346.1">
     (const-references).
    </span>
    <span class="koboSpan" id="kobo.346.2">
     Both are defined in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.347.1">
      &lt;functional&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.348.1">
     header file.
    </span>
    <span class="koboSpan" id="kobo.348.2">
     This lets the variadic template define the thread constructor to treat the argument as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.349.1">
      a reference.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.350.1">
     These helper functions are used to generate
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.351.1">
      std::reference_wrapper
     </span>
    </strong>
    <span class="koboSpan" id="kobo.352.1">
     objects, which wrap a reference in a copyable and assignable object.
    </span>
    <span class="koboSpan" id="kobo.352.2">
     Missing these functions when passing arguments makes the arguments to be passed
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.353.1">
      by value.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.354.1">
     You can also move an object into a thread
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.355.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.356.1">
std::thread t(printVector, std::move(v));</span></pre>
   <p>
    <span class="koboSpan" id="kobo.357.1">
     However, note that trying to access the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.358.1">
      v
     </span>
    </strong>
    <span class="koboSpan" id="kobo.359.1">
     vector in the main thread after it is moved into the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.360.1">
      t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.361.1">
     thread would result in
    </span>
    <a id="_idIndexMarker189">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.362.1">
      undefined behavior.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.363.1">
     Finally, we can also allow
    </span>
    <a id="_idIndexMarker190">
    </a>
    <span class="koboSpan" id="kobo.364.1">
     threads to access variables by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.365.1">
      lambda captures:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.366.1">
std::string str{"Hello"};
std::thread t([&amp;]() {
    sync_cout &lt;&lt; "str: " &lt;&lt; str &lt;&lt; std::endl;
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.367.1">
     In this example, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.368.1">
      str
     </span>
    </strong>
    <span class="koboSpan" id="kobo.369.1">
     variable is accessed by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.370.1">
      t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.371.1">
     thread as a reference captured by the embedded
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.372.1">
      lambda function.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-64">
    <a id="_idTextAnchor063">
    </a>
    <span class="koboSpan" id="kobo.373.1">
     Returning values
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.374.1">
     To return
    </span>
    <a id="_idIndexMarker191">
    </a>
    <span class="koboSpan" id="kobo.375.1">
     values that have been computed in a thread, we can use a shared variable with a synchronization mechanism such as a mutex, lock, or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.376.1">
      atomic variable.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.377.1">
     In the following code snippet, we can see how to return a value computed by a thread by using an argument passed by a non-const reference (using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.378.1">
      ref()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.379.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.379.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.380.1">
      result
     </span>
    </strong>
    <span class="koboSpan" id="kobo.381.1">
     variable is computed within the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.382.1">
      t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.383.1">
     thread in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.384.1">
      func
     </span>
    </strong>
    <span class="koboSpan" id="kobo.385.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.385.2">
     The resulting value can be seen from the main thread.
    </span>
    <span class="koboSpan" id="kobo.385.3">
     As we will learn in the next section, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.386.1">
      join()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.387.1">
     function simply waits for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.388.1">
      t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.389.1">
     thread to finish before letting the main thread continue running and checking the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.390.1">
      result
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.391.1">
      variable afterward:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.392.1">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
namespace {
int result = 0;
};
void func(int&amp; result) {
    std::this_thread::sleep_for(1s);
    result = 1 + (rand () % 10);
}
Int main() {
    std::thread t(func, std::ref(result));
    t.join();
    sync_cout &lt;&lt; "Result: " &lt;&lt; result &lt;&lt; std::endl;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.393.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.394.1">
      reference
     </span>
    </strong>
    <a id="_idIndexMarker192">
    </a>
    <span class="koboSpan" id="kobo.395.1">
     argument can be a reference to the input object itself, or to another variable where we want the result to be stored, as done in this example with the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.396.1">
       result
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.397.1">
      variable.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.398.1">
     We can also return the value using a lambda capture, as shown in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.399.1">
      following example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.400.1">
std::thread t([&amp;]() { func(result); });
t.join();
sync_cout &lt;&lt; "Result: " &lt;&lt; result &lt;&lt; std::endl;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.401.1">
     We can also do this by writing into a shared variable protected by a mutex, locking the mutex (using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.402.1">
      std::lock_guard
     </span>
    </strong>
    <span class="koboSpan" id="kobo.403.1">
     , for example) before executing the writing operation.
    </span>
    <span class="koboSpan" id="kobo.403.2">
     However, we will dive deeper into these mechanisms in
    </span>
    <a href="B22219_04.xhtml#_idTextAnchor074">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.404.1">
        Chapter 4
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.405.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.406.1">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;random&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
namespace {
int result = 0;
std::mutex mtx;
};
void funcWithMutex() {
    std::this_thread::sleep_for(1s);
    int localVar = 1 + (rand() % 10);
    std::lock_guard&lt;std::mutex&gt; lock(mtx);
    result = localVar;
}
Int main() {
    std::thread t(funcWithMutex);
    t.join();
    sync_cout &lt;&lt; "Result: " &lt;&lt; result &lt;&lt; std::endl;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.407.1">
     There is a more elegant way of
    </span>
    <a id="_idIndexMarker193">
    </a>
    <span class="koboSpan" id="kobo.408.1">
     returning values from threads.
    </span>
    <span class="koboSpan" id="kobo.408.2">
     This involves using futures and promises, which we will learn about in
    </span>
    <a href="B22219_06.xhtml#_idTextAnchor125">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.409.1">
        Chapter 6
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.410.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-65">
    <a id="_idTextAnchor064">
    </a>
    <span class="koboSpan" id="kobo.411.1">
     Moving threads
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.412.1">
     Threads can be
    </span>
    <a id="_idIndexMarker194">
    </a>
    <span class="koboSpan" id="kobo.413.1">
     moved but not copied.
    </span>
    <span class="koboSpan" id="kobo.413.2">
     This is to avoid having two different thread objects to represent the same
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.414.1">
      hardware thread.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.415.1">
     In the following example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.416.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.417.1">
     is moved to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.418.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.419.1">
     using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.420.1">
      std::move
     </span>
    </strong>
    <span class="koboSpan" id="kobo.421.1">
     .
    </span>
    <span class="koboSpan" id="kobo.421.2">
     Therefore,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.422.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.423.1">
     inherits the same identifier as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.424.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.425.1">
     had before being moved and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.426.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.427.1">
     is not joinable, as it no longer contains any valid
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.428.1">
      thread anymore:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.429.1">
#include &lt;chrono&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
void func() {
    for (auto i=0; i&lt;10; ++i) {
        std::this_thread::sleep_for(500ms);
    }
}
int main() {
    std::thread t1(func);
    std::thread t2 = std::move(t1);
    t2.join();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.430.1">
     When a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.431.1">
      std::thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.432.1">
     object is moved to another
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.433.1">
      std::thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.434.1">
     object, the move-from-thread object will reach a state where it does not represent a real thread anymore.
    </span>
    <span class="koboSpan" id="kobo.434.2">
     This situation also happens to thread objects resulting from the default constructor after detaching or joining them.
    </span>
    <span class="koboSpan" id="kobo.434.3">
     We will introduce these operations in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.435.1">
      next section.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-66">
    <a id="_idTextAnchor065">
    </a>
    <span class="koboSpan" id="kobo.436.1">
     Waiting for a thread to finish
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.437.1">
     There are use
    </span>
    <a id="_idIndexMarker195">
    </a>
    <span class="koboSpan" id="kobo.438.1">
     cases where a thread needs to wait for another thread to finish so that it can use the result computed by the latter thread.
    </span>
    <span class="koboSpan" id="kobo.438.2">
     Other use cases involve running a thread in the background, detaching it, and continuing to execute the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.439.1">
      main thread.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.440.1">
     Joining a thread
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.441.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.442.1">
      join()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.443.1">
     function blocks the
    </span>
    <a id="_idIndexMarker196">
    </a>
    <span class="koboSpan" id="kobo.444.1">
     current thread while waiting for the completion of the joining thread identified by the thread object where the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.445.1">
      join()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.446.1">
     function is being called.
    </span>
    <span class="koboSpan" id="kobo.446.2">
     This ensures that the joining thread has terminated after
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.447.1">
      join()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.448.1">
     returns (see the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.449.1">
      Thread life cycle
     </span>
    </em>
    <span class="koboSpan" id="kobo.450.1">
     section in
    </span>
    <a href="B22219_02.xhtml#_idTextAnchor035">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.451.1">
        Chapter 2
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.452.1">
     for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.453.1">
      more details).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.454.1">
     It is easy to forget to use a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.455.1">
      join()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.456.1">
     function.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.457.1">
      Joining Thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.458.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.459.1">
      jthread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.460.1">
     ) solves
    </span>
    <a id="_idIndexMarker197">
    </a>
    <span class="koboSpan" id="kobo.461.1">
     that problem.
    </span>
    <span class="koboSpan" id="kobo.461.2">
     It is available from C++20 onward.
    </span>
    <span class="koboSpan" id="kobo.461.3">
     We will introduce it in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.462.1">
      next section.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.463.1">
     Checking whether a thread is joinable
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.464.1">
     A thread is considered joinable and therefore active if the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.465.1">
      join()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.466.1">
     function has not been called in that thread.
    </span>
    <span class="koboSpan" id="kobo.466.2">
     This is true even if the thread has finished executing code but still has not been joined.
    </span>
    <span class="koboSpan" id="kobo.466.3">
     On the other hand, a default constructed thread or a thread that has already been joined is
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.467.1">
       not
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.468.1">
      joinable.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.469.1">
     To check whether a thread is joinable, just use the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.470.1">
       std::thread::joinable()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.471.1">
      function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.472.1">
     Let us see the usage of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.473.1">
      std::thread::join()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.474.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.475.1">
      std::thread::joinable()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.476.1">
     in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.477.1">
      following example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.478.1">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
void func() {
    std::this_thread::sleep_for(100ms);
}
int main() {
    std::thread t1;
    std::cout &lt;&lt; "Is t1 joinable? </span><span class="koboSpan" id="kobo.478.2">" &lt;&lt; t1.joinable()
              &lt;&lt; std::endl;
    std::thread t2(func);
    t1.swap(t2);
    std::cout &lt;&lt; "Is t1 joinable? </span><span class="koboSpan" id="kobo.478.3">" &lt;&lt; t1.joinable()
              &lt;&lt; std::endl;
    std::cout &lt;&lt; "Is t2 joinable? </span><span class="koboSpan" id="kobo.478.4">" &lt;&lt; t2.joinable()
              &lt;&lt; std::endl;
    t1.join();
    std::cout &lt;&lt; "Is t1 joinable? </span><span class="koboSpan" id="kobo.478.5">" &lt;&lt; t1.joinable()
              &lt;&lt; std::endl;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.479.1">
     After
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.480.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.481.1">
     has been constructed using the default constructor (not specifying a callable object), the thread will not be joinable.
    </span>
    <span class="koboSpan" id="kobo.481.2">
     As
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.482.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.483.1">
     is constructed specifying a function,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.484.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.485.1">
     is joinable after construction.
    </span>
    <span class="koboSpan" id="kobo.485.2">
     However, when
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.486.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.487.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.488.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.489.1">
     are swapped,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.490.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.491.1">
     becomes joinable again and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.492.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.493.1">
     is not joinable anymore.
    </span>
    <span class="koboSpan" id="kobo.493.2">
     Then the main thread waits for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.494.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.495.1">
     to join, so it is no longer joinable.
    </span>
    <span class="koboSpan" id="kobo.495.2">
     Trying to join
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.496.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.497.1">
     , a non-joinable thread, results in undefined behavior.
    </span>
    <span class="koboSpan" id="kobo.497.2">
     Finally, not joining a joinable thread will lead to resource leaks or potential program crashes due to the unexpected use of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.498.1">
      shared resources.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.499.1">
     Daemon thread by detaching
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.500.1">
     If we want a thread to continue
    </span>
    <a id="_idIndexMarker198">
    </a>
    <span class="koboSpan" id="kobo.501.1">
     running in the background as a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.502.1">
      daemon thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.503.1">
     but finish the execution of the current thread, we can use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.504.1">
      std::thread::detach()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.505.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.505.2">
     A daemon thread is a thread that performs some tasks in the background that do not need to run to completion.
    </span>
    <span class="koboSpan" id="kobo.505.3">
     If the main program exits, all daemon threads are terminated.
    </span>
    <span class="koboSpan" id="kobo.505.4">
     As commented earlier, a thread must join or detach before the main thread terminates, otherwise the program will abort
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.506.1">
      its execution.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.507.1">
     After calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.508.1">
      detach
     </span>
    </strong>
    <span class="koboSpan" id="kobo.509.1">
     , the detached thread cannot be controlled or joined (as it is waiting for its completion) using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.510.1">
      std::thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.511.1">
     object, as this object no longer represents the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.512.1">
      detached thread.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.513.1">
     The following example shows a daemon thread called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.514.1">
      t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.515.1">
     that is detached just after construction, running the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.516.1">
      daemonThread()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.517.1">
     function in the background.
    </span>
    <span class="koboSpan" id="kobo.517.2">
     This function executes for three seconds and then exits, finishing the thread execution.
    </span>
    <span class="koboSpan" id="kobo.517.3">
     Meanwhile, the main thread sleeps for one more second than the thread execution time
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.518.1">
      before exiting:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.519.1">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
namespace {
int timeout = 3;
}
void daemonThread() {
    sync_cout &lt;&lt; "Daemon thread starting...\n";
    while (timeout-- &gt; 0) {
        sync_cout &lt;&lt; "Daemon thread is running...\n";
        std::this_thread::sleep_for(1s);
    }
    sync_cout &lt;&lt; "Daemon thread exiting...\n";
}
int main() {
    std::thread t(daemonThread);
    t.detach();
    std::this_thread::sleep_for(
              std::chrono::seconds(timeout + 1));
    sync_cout &lt;&lt; "Main thread exiting...\n";
    Return 0;
}</span></pre>
   <h2 id="_idParaDest-67">
    <a id="_idTextAnchor066">
    </a>
    <span class="koboSpan" id="kobo.520.1">
     Joining threads – the jthread class
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.521.1">
     From C++20 onward, there is a
    </span>
    <a id="_idIndexMarker199">
    </a>
    <span class="koboSpan" id="kobo.522.1">
     new class:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.523.1">
      std::jthread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.524.1">
     .
    </span>
    <span class="koboSpan" id="kobo.524.2">
     This class is like
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.525.1">
      std:thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.526.1">
     but with the additional functionality that the thread rejoins on destruction,
    </span>
    <a id="_idIndexMarker200">
    </a>
    <span class="koboSpan" id="kobo.527.1">
     following the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.528.1">
      Resource Acquisition is Initialization
     </span>
    </strong>
    <span class="koboSpan" id="kobo.529.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.530.1">
      RAII
     </span>
    </strong>
    <span class="koboSpan" id="kobo.531.1">
     ) technique.
    </span>
    <span class="koboSpan" id="kobo.531.2">
     It can be canceled or stopped in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.532.1">
      some scenarios.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.533.1">
     As you can see in the following example, a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.534.1">
      jthread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.535.1">
     thread has the same interface as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.536.1">
      std::thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.537.1">
     .
    </span>
    <span class="koboSpan" id="kobo.537.2">
     The only difference is that we do not need to call the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.538.1">
      join()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.539.1">
     function to ensure that the main thread waits for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.540.1">
      t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.541.1">
     thread
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.542.1">
      to join:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.543.1">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
void func() {
    std::this_thread::sleep_for(1s);
}
int main() {
    std::jthread t(func);
    sync_cout &lt;&lt; "Thread ID: " &lt;&lt; t.get_id() &lt;&lt; std::endl;
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.544.1">
     When two
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.545.1">
      std::jthread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.546.1">
     s are destroyed, their destructors are called in reverse order from their constructors.
    </span>
    <span class="koboSpan" id="kobo.546.2">
     To demonstrate this behavior, let us implement a thread wrapper class that prints some messages when the wrapped thread is created
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.547.1">
      and destroyed:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.548.1">
#include &lt;chrono&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
class JthreadWrapper {
   public:
    JthreadWrapper(
       const std::function&lt;void(const std::string&amp;)&gt;&amp; func,
       const std::string&amp; str)
        : t(func, str), name(str) {
        sync_cout &lt;&lt; "Thread " &lt;&lt; name
                  &lt;&lt; " being created" &lt;&lt; std::endl;
    }
    ~JthreadWrapper() {
        sync_cout &lt;&lt; "Thread " &lt;&lt; name
                  &lt;&lt; " being destroyed" &lt;&lt; std::endl;
    }
   private:
    std::jthread t;
    std::string name;
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.549.1">
     Using this
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.550.1">
      JthreadWrapper
     </span>
    </strong>
    <span class="koboSpan" id="kobo.551.1">
     wrapper class, we start three threads that
    </span>
    <a id="_idIndexMarker201">
    </a>
    <span class="koboSpan" id="kobo.552.1">
     execute the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.553.1">
      func
     </span>
    </strong>
    <span class="koboSpan" id="kobo.554.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.554.2">
     Each will wait for a second
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.555.1">
      before exiting:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.556.1">
void func(const std::string&amp; name) {
    sync_cout &lt;&lt; "Thread " &lt;&lt; name &lt;&lt; " starting...\n";
    std::this_thread::sleep_for(1s);
    sync_cout &lt;&lt; "Thread " &lt;&lt; name &lt;&lt; " finishing...\n";
}
int main() {
    JthreadWrapper t1(func, «t1»);
    JthreadWrapper t2(func, "t2");
    JthreadWrapper t3(func, "t3");
    std::this_thread::sleep_for(2s);
    sync_cout &lt;&lt; "Main thread exiting..." </span><span class="koboSpan" id="kobo.556.2">&lt;&lt; std::endl;
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.557.1">
     This program will show the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.558.1">
      following output:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.559.1">
Thread t1 being created
Thread t1 starting...
</span><span class="koboSpan" id="kobo.559.2">Thread t2 being created
Thread t2 starting...
</span><span class="koboSpan" id="kobo.559.3">Thread t3 being created
Thread t3 starting...
</span><span class="koboSpan" id="kobo.559.4">Thread t1 finishing...
</span><span class="koboSpan" id="kobo.559.5">Thread t2 finishing...
</span><span class="koboSpan" id="kobo.559.6">Thread t3 finishing...
</span><span class="koboSpan" id="kobo.559.7">Main thread exiting...
</span><span class="koboSpan" id="kobo.559.8">Thread t3 being destroyed
Thread t2 being destroyed
Thread t1 being destroyed</span></pre>
   <p>
    <span class="koboSpan" id="kobo.560.1">
     As we can see,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.561.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.562.1">
     is created first, then
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.563.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.564.1">
     , and finally
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.565.1">
      t3
     </span>
    </strong>
    <span class="koboSpan" id="kobo.566.1">
     .
    </span>
    <span class="koboSpan" id="kobo.566.2">
     The destructors follow the reverse order, with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.567.1">
      t3
     </span>
    </strong>
    <span class="koboSpan" id="kobo.568.1">
     being destroyed first, then
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.569.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.570.1">
     , and
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.571.1">
       t1
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.572.1">
      last.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.573.1">
     As jthreads avoid pitfalls when we
    </span>
    <a id="_idIndexMarker202">
    </a>
    <span class="koboSpan" id="kobo.574.1">
     forget to use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.575.1">
      join
     </span>
    </strong>
    <span class="koboSpan" id="kobo.576.1">
     in a thread, we simply prefer to use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.577.1">
      std::jthread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.578.1">
     over
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.579.1">
      std::thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.580.1">
     .
    </span>
    <span class="koboSpan" id="kobo.580.2">
     There might be cases where we need to use explicit calls to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.581.1">
      join()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.582.1">
     to be sure that threads have been joined and resources properly freed up before moving to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.583.1">
      another task.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-68">
    <a id="_idTextAnchor067">
    </a>
    <span class="koboSpan" id="kobo.584.1">
     Yielding thread execution
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.585.1">
     A thread can also decide to pause its
    </span>
    <a id="_idIndexMarker203">
    </a>
    <span class="koboSpan" id="kobo.586.1">
     execution, let the implementation reschedule the execution of threads, and give the chance to other threads
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.587.1">
      to run.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.588.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.589.1">
      std::this_thread::yield
     </span>
    </strong>
    <span class="koboSpan" id="kobo.590.1">
     method provides a hint to the OS to reschedule another thread.
    </span>
    <span class="koboSpan" id="kobo.590.2">
     The behavior is implementation-dependent, depending on the OS scheduler and the current state of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.591.1">
      the system.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.592.1">
     Some Linux implementations suspend the current thread and move it back to a queue of threads to schedule all threads with the same priority.
    </span>
    <span class="koboSpan" id="kobo.592.2">
     If this queue is empty, the yield has
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.593.1">
      no effect.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.594.1">
     The following example shows two threads,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.595.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.596.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.597.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.598.1">
     , executing the same work function.
    </span>
    <span class="koboSpan" id="kobo.598.2">
     They randomly choose to either do some work (locking a mutex, as we will learn about in the next chapter, and waiting for three seconds) or yield the execution to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.599.1">
      other thread:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.600.1">
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;string&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono;
namespace {
int val = 0;
std::mutex mtx;
}
int main() {
    auto work = [&amp;](const std::string&amp; name) {
        while (true) {
            bool work_to_do = rand() % 2;
            if (work_to_do) {
                sync_cout &lt;&lt; name &lt;&lt; ": working\n";
                std::lock_guard&lt;std::mutex&gt; lock(mtx);
                for (auto start = steady_clock::now(),
                          now = start;
                          now &lt; start + 3s;
                          now = steady_clock::now()) {
                }
            } else {
                sync_cout &lt;&lt; name &lt;&lt; ": yielding\n";
                std::this_thread::yield();
            }
        }
    };
    std::jthread t1(work, "t1");
    std::jthread t2(work, "t2");
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.601.1">
     When running this example, when the execution reaches the yield command, we can see how the thread that is currently running stops and enables the other thread to restart
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.602.1">
      its execution.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-69">
    <a id="_idTextAnchor068">
    </a>
    <span class="koboSpan" id="kobo.603.1">
     Threads cancellation
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.604.1">
     If we are no longer
    </span>
    <a id="_idIndexMarker204">
    </a>
    <span class="koboSpan" id="kobo.605.1">
     interested in the result that a thread is computing, we will want to cancel that thread and avoid more
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.606.1">
      computation costs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.607.1">
     Killing a thread could be a solution.
    </span>
    <span class="koboSpan" id="kobo.607.2">
     However, that leaves resources that belong to the thread handling, such as other threads started from that thread, locks, connections, and so on.
    </span>
    <span class="koboSpan" id="kobo.607.3">
     This could mean ending the program with undefined behavior, a critical section locked under a mutex, or any other
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.608.1">
      unexpected issue.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.609.1">
     To avoid these problems, we need a data race-free mechanism to let the thread know about the intention to stop its execution (to request a stop) so that the thread can take all the specific steps needed to cancel its work and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.610.1">
      terminate gracefully.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.611.1">
     One of the possible ways of achieving this is by using an atomic variable that is periodically checked by the thread.
    </span>
    <span class="koboSpan" id="kobo.611.2">
     We will explore atomic variables at length in the next chapter.
    </span>
    <span class="koboSpan" id="kobo.611.3">
     For now, let’s define an atomic variable as a variable that many threads can write or read from without any locking mechanism or data race due to its atomic transaction operations and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.612.1">
      memory model.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.613.1">
     As an example, let us create a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.614.1">
      Counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.615.1">
     class that calls a callback every second.
    </span>
    <span class="koboSpan" id="kobo.615.2">
     This is done infinitely until the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.616.1">
      running
     </span>
    </strong>
    <span class="koboSpan" id="kobo.617.1">
     atomic variable is set to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.618.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.619.1">
     , when a caller uses the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.620.1">
       stop()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.621.1">
      function:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.622.1">
#include &lt;chrono&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
class Counter {
    using Callback = std::function&lt;void(void)&gt;;
   public:
    Counter(const Callback &amp;callback) {
        t = std::jthread([&amp;]() {
            while (running.load() == true) {
                callback ();
                std::this_thread::sleep_for(1s);
            }
        });
    }
    void stop() { running.store(false); }
   private:
    std::jthread t;
    std::atomic_bool running{true};
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.623.1">
     In the caller function, we will instantiate
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.624.1">
      Counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.625.1">
     as follows.
    </span>
    <span class="koboSpan" id="kobo.625.2">
     Then, when
    </span>
    <a id="_idIndexMarker205">
    </a>
    <span class="koboSpan" id="kobo.626.1">
     desired (here, that is after three seconds), we will call the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.627.1">
      stop()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.628.1">
     function, letting
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.629.1">
      Counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.630.1">
     exit the loop and terminate the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.631.1">
      thread execution:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.632.1">
int main() {
    Counter counter([&amp;]() {
        sync_cout &lt;&lt; "Callback: Running...\n";
    });
    std::this_thread::sleep_for(3s);
    counter.stop();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.633.1">
     Since C++20, there has been a new mechanism
    </span>
    <a id="_idIndexMarker206">
    </a>
    <span class="koboSpan" id="kobo.634.1">
     called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.635.1">
      cooperative interruption
     </span>
    </strong>
    <span class="koboSpan" id="kobo.636.1">
     of a thread.
    </span>
    <span class="koboSpan" id="kobo.636.2">
     This is available
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.637.1">
      via
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.638.1">
       std::stop_token
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.639.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.640.1">
     The thread knows that a stop was requested by checking the result of calling the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.641.1">
       std::stop_token::stop_requested()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.642.1">
      function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.643.1">
     To produce
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.644.1">
      stop_token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.645.1">
     , we will use a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.646.1">
      stop_source
     </span>
    </strong>
    <span class="koboSpan" id="kobo.647.1">
     object via the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.648.1">
       std::stop_source::get_token()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.649.1">
      function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.650.1">
     This thread cancellation mechanism is implemented in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.651.1">
      std::jthead
     </span>
    </strong>
    <span class="koboSpan" id="kobo.652.1">
     objects via an internal member of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.653.1">
      std::stop_source
     </span>
    </strong>
    <span class="koboSpan" id="kobo.654.1">
     type where the shared stop state is stored.
    </span>
    <span class="koboSpan" id="kobo.654.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.655.1">
      jthread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.656.1">
     constructor accepts
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.657.1">
      std::stop_token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.658.1">
     as its first argument.
    </span>
    <span class="koboSpan" id="kobo.658.2">
     This is used when a stop is requested
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.659.1">
      during execution.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.660.1">
     Therefore,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.661.1">
      std::jthread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.662.1">
     exposes some additional functions to manage stop tokens compared with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.663.1">
      std::thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.664.1">
     objects.
    </span>
    <span class="koboSpan" id="kobo.664.2">
     These functions are
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.665.1">
      get_stop_source()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.666.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.667.1">
      get_stop_token()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.668.1">
     ,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.669.1">
      and
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.670.1">
       request_stop()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.671.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.672.1">
     When
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.673.1">
      request_stop()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.674.1">
     is called, it issues a stop request to the internal stop state, which is atomically updated to avoid race conditions (you will learn more about atomic variables in
    </span>
    <a href="B22219_04.xhtml#_idTextAnchor074">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.675.1">
        Chapter 4
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.676.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.677.1">
     Let us check how all these functions work in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.678.1">
      following example.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.679.1">
     First, we will define a template function to show the properties of a stop item object (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.680.1">
      stop_token
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.681.1">
      or
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.682.1">
       stop_source
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.683.1">
      ):
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.684.1">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;string_view&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
template &lt;typename T&gt;
void show_stop_props(std::string_view name,
                     const T&amp; stop_item) {
    sync_cout &lt;&lt; std::boolalpha
              &lt;&lt; name
              &lt;&lt; ": stop_possible = "
              &lt;&lt; stop_item.stop_possible()
              &lt;&lt; ", stop_requested = "
              &lt;&lt; stop_item.stop_requested()
              &lt;&lt; '\n';
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.685.1">
     Now, within the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.686.1">
      main()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.687.1">
     function, we will start a
    </span>
    <a id="_idIndexMarker207">
    </a>
    <span class="koboSpan" id="kobo.688.1">
     worker thread, acquire its stop token object, and show
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.689.1">
      its properties:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.690.1">
auto worker1 = std::jthread(func_with_stop_token);
std::stop_token stop_token = worker1.get_stop_token();
show_stop_props("stop_token", stop_token);</span></pre>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.691.1">
      Worker1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.692.1">
     is running the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.693.1">
      func_with_stop_token()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.694.1">
     function that is defined in the ensuing code block.
    </span>
    <span class="koboSpan" id="kobo.694.2">
     In this function, the stop token is checked by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.695.1">
      stop_requested()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.696.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.696.2">
     If this function returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.697.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.698.1">
     , a stop was requested, so the function simply returns, terminating the thread execution.
    </span>
    <span class="koboSpan" id="kobo.698.2">
     Otherwise, it runs the next loop iteration, sleeping the current thread for further 300 ms until the next stop
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.699.1">
      request check:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.700.1">
void func_with_stop_token(std::stop_token stop_token) {
    for (int i = 0; i &lt; 10; ++i) {
        std::this_thread::sleep_for(300ms);
        if (stop_token.stop_requested()) {
            sync_cout &lt;&lt; "stop_worker: "
                      &lt;&lt; "Stopping as requested\n";
            return;
        }
        sync_cout &lt;&lt; "stop_worker: Going back to sleep\n";
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.701.1">
     We can request a stop from the main thread by using the stop token returned by the thread object
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.702.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.703.1">
worker1.request_stop();
worker1.join();
show_stop_props("stop_token after request", stop_token);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.704.1">
     Also, we can request a stop from a different thread.
    </span>
    <span class="koboSpan" id="kobo.704.2">
     For this, we need to pass a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.705.1">
      stop_source
     </span>
    </strong>
    <span class="koboSpan" id="kobo.706.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.706.2">
     In the following code snippet, we can see how a thread stopper is created with a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.707.1">
      stop_source
     </span>
    </strong>
    <span class="koboSpan" id="kobo.708.1">
     object as an argument, acquired from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.709.1">
      worker2
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.710.1">
      worker thread:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.711.1">
auto worker2 = std::jthread(func_with_stop_token);
std::stop_source stop_source = worker2.get_stop_source();
show_stop_props("stop_source", stop_source);
auto stopper = std::thread( [](std::stop_source source) {
        std::this_thread::sleep_for(500ms);
        sync_cout &lt;&lt; "Request stop for worker2 "
                  &lt;&lt; "via source\n";
        source.request_stop();
    }, stop_source);
stopper.join();
std::this_thread::sleep_for(200ms);
show_stop_props("stop_source after request", stop_source);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.712.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.713.1">
      stopper
     </span>
    </strong>
    <span class="koboSpan" id="kobo.714.1">
     thread waits for 0.5 seconds and requests a stop from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.715.1">
      stop_source
     </span>
    </strong>
    <span class="koboSpan" id="kobo.716.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.716.2">
     Then
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.717.1">
      worker2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.718.1">
     becomes aware of that request and terminates its
    </span>
    <a id="_idIndexMarker208">
    </a>
    <span class="koboSpan" id="kobo.719.1">
     execution, as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.720.1">
      explained earlier.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.721.1">
     We can also register a callback function that will invoke a function when a stop is requested via a stop token or stop source.
    </span>
    <span class="koboSpan" id="kobo.721.2">
     This can be done by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.722.1">
      std::stop_callback
     </span>
    </strong>
    <span class="koboSpan" id="kobo.723.1">
     object, as shown in the ensuing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.724.1">
      code block:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.725.1">
std::stop_callback callback(worker1.get_stop_token(), []{
    sync_cout &lt;&lt; "stop_callback for worker1 "
              &lt;&lt; "executed by thread "
              &lt;&lt; std::this_thread::get_id() &lt;&lt; '\n';
});
sync_cout &lt;&lt; "main_thread: "
          &lt;&lt; std::this_thread::get_id() &lt;&lt; '\n';
std::stop_callback callback_after_stop(
    worker2.get_stop_token(),[] {
        sync_cout &lt;&lt; "stop_callback for worker2 "
                  &lt;&lt; "executed by thread "
                  &lt;&lt; std::this_thread::get_id() &lt;&lt; '\n';
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.726.1">
     If a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.727.1">
      std::stop_callback
     </span>
    </strong>
    <span class="koboSpan" id="kobo.728.1">
     object is destroyed, its execution is prevented.
    </span>
    <span class="koboSpan" id="kobo.728.2">
     For example, this scoped stop callback will not execute, as the callback object is destroyed when going out
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.729.1">
      of scope:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.730.1">
{
    std::stop_callback scoped_callback(
        worker2.get_stop_token(), []{
          sync_cout &lt;&lt; "Scoped stop callback "
                    &lt;&lt; "will not execute\n";
      }
    );
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.731.1">
     After a stop has already been requested, a new stop
    </span>
    <a id="_idIndexMarker209">
    </a>
    <span class="koboSpan" id="kobo.732.1">
     callback object will execute immediately.
    </span>
    <span class="koboSpan" id="kobo.732.2">
     In the following example, if a stop has been requested for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.733.1">
      worker2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.734.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.735.1">
      callback_after_stop
     </span>
    </strong>
    <span class="koboSpan" id="kobo.736.1">
     will execute the lambda function just
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.737.1">
      after construction:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.738.1">
sync_cout &lt;&lt; "main_thread: "
          &lt;&lt; std::this_thread::get_id() &lt;&lt; '\n';
std::stop_callback callback_after_stop(
    worker2.get_stop_token(), []{
        sync_cout &lt;&lt; "stop_callback for worker2 "
                  &lt;&lt; "executed by thread "
                  &lt;&lt; std::this_thread::get_id() &lt;&lt; '\n';
    }
);</span></pre>
   <h2 id="_idParaDest-70">
    <a id="_idTextAnchor069">
    </a>
    <span class="koboSpan" id="kobo.739.1">
     Catching exceptions
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.740.1">
     Any unhandled exception
    </span>
    <a id="_idIndexMarker210">
    </a>
    <span class="koboSpan" id="kobo.741.1">
     thrown within a thread needs to be caught within that thread.
    </span>
    <span class="koboSpan" id="kobo.741.2">
     Otherwise, the C++ runtime calls
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.742.1">
      std::terminate
     </span>
    </strong>
    <span class="koboSpan" id="kobo.743.1">
     , causing the program to terminate abruptly.
    </span>
    <span class="koboSpan" id="kobo.743.2">
     This causes unexpected behavior, data loss, or even
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.744.1">
      program crashes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.745.1">
     One solution is to use try-catch blocks within the thread to catch exceptions.
    </span>
    <span class="koboSpan" id="kobo.745.2">
     However, only exceptions thrown within that thread will be caught.
    </span>
    <span class="koboSpan" id="kobo.745.3">
     Exceptions do not propagate to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.746.1">
      other threads.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.747.1">
     To propagate an exception to another thread, one thread can capture it and store it into a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.748.1">
      std::exception_ptr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.749.1">
     object, then use shared memory techniques to pass it to another thread, where the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.750.1">
      std::exception_ptr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.751.1">
     object will be checked and the exception re-thrown
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.752.1">
      if needed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.753.1">
     The following example shows
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.754.1">
      this approach:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.755.1">
#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;exception&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
std::exception_ptr captured_exception;
std::mutex mtx;
void func() {
    try {
        std::this_thread::sleep_for(1s);
        throw std::runtime_error(
                  "Error in func used within thread");
    } catch (...) {
        std::lock_guard&lt;std::mutex&gt; lock(mtx);
        captured_exception = std::current_exception();
    }
}
int main() {
    std::thread t(func);
    while (!captured_exception) {
        std::this_thread::sleep_for(250ms);
        std::cout &lt;&lt; „In main thread\n";
    }
    try {
        std::rethrow_exception(captured_exception);
    } catch (const std::exception&amp; e) {
        std::cerr &lt;&lt; "Exception caught in main thread: "
                  &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    t.join();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.756.1">
     Here, we can see how a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.757.1">
      std::runtime_error
     </span>
    </strong>
    <span class="koboSpan" id="kobo.758.1">
     exception is thrown when
    </span>
    <a id="_idIndexMarker211">
    </a>
    <span class="koboSpan" id="kobo.759.1">
     executing the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.760.1">
      func
     </span>
    </strong>
    <span class="koboSpan" id="kobo.761.1">
     function by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.762.1">
      t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.763.1">
     thread.
    </span>
    <span class="koboSpan" id="kobo.763.2">
     The exception is caught and stored in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.764.1">
      captured_exception
     </span>
    </strong>
    <span class="koboSpan" id="kobo.765.1">
     , a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.766.1">
      std::exception_ptr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.767.1">
     shared object protected by a mutex.
    </span>
    <span class="koboSpan" id="kobo.767.2">
     The type and value of the thrown exception are determined by calling the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.768.1">
       std::current_exception()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.769.1">
      function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.770.1">
     In the main thread, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.771.1">
      while
     </span>
    </strong>
    <span class="koboSpan" id="kobo.772.1">
     loop runs until an exception is
    </span>
    <a id="_idIndexMarker212">
    </a>
    <span class="koboSpan" id="kobo.773.1">
     captured.
    </span>
    <span class="koboSpan" id="kobo.773.2">
     The exception is re-thrown in the main thread by calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.774.1">
      std::rethrow_exception(captured_exception)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.775.1">
     .
    </span>
    <span class="koboSpan" id="kobo.775.2">
     It is caught again by the main thread where the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.776.1">
      catch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.777.1">
     block is executed, printing a message to the console via the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.778.1">
      std::cerr
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.779.1">
      error stream.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.780.1">
     We will learn a better solution in
    </span>
    <a href="B22219_06.xhtml#_idTextAnchor125">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.781.1">
        Chapter 6
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.782.1">
     by using futures
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.783.1">
      and promises.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-71">
    <a id="_idTextAnchor070">
    </a>
    <span class="koboSpan" id="kobo.784.1">
     Thread-local storage
    </span>
   </h1>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.785.1">
      Thread-local Storage
     </span>
    </strong>
    <span class="koboSpan" id="kobo.786.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.787.1">
      TLS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.788.1">
     ) is a
    </span>
    <a id="_idIndexMarker213">
    </a>
    <span class="koboSpan" id="kobo.789.1">
     memory management technique that allows each thread to have its own instance of a variable.
    </span>
    <span class="koboSpan" id="kobo.789.2">
     This technique allows threads to store thread-specific data that is not accessible by other threads, avoiding race conditions and improving performance.
    </span>
    <span class="koboSpan" id="kobo.789.3">
     This is because the overhead of synchronization mechanisms to access these variables
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.790.1">
      is removed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.791.1">
     TLS is implemented by the OS and accessible by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.792.1">
      thread_local
     </span>
    </strong>
    <span class="koboSpan" id="kobo.793.1">
     keyword, which has been available since C++11.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.794.1">
      thread_local
     </span>
    </strong>
    <span class="koboSpan" id="kobo.795.1">
     provides a uniform way to use the TLS capabilities of many OSs and avoid compiler-specific language extensions for accessing the TLS feature (some examples of such extensions are the TLS Windows API, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.796.1">
      __declspec(thread)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.797.1">
     MSVC compiler language extension, or the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.798.1">
      __thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.799.1">
     GCC compiler
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.800.1">
      language extension).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.801.1">
     To use TLS with compilers that do not support C++11 or newer versions, use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.802.1">
      Boost.Library
     </span>
    </strong>
    <span class="koboSpan" id="kobo.803.1">
     .
    </span>
    <span class="koboSpan" id="kobo.803.2">
     This provides the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.804.1">
      boost::thread_specific_ptr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.805.1">
     container, which implements
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.806.1">
      portable TLS.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.807.1">
     Thread-local variables can be declared
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.808.1">
      as follows:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.809.1">
       Globally
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.810.1">
       In namespaces
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.811.1">
      As class static
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.812.1">
       member variables
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.813.1">
      Inside functions; it has the same effect as variables allocated with the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.814.1">
       static
      </span>
     </strong>
     <span class="koboSpan" id="kobo.815.1">
      keyword, meaning that the variables are allocated for the lifetime of the program and their value are carried through the next
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.816.1">
       function call
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.817.1">
     The following examples show three threads calling the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.818.1">
      multiplyByTwo
     </span>
    </strong>
    <span class="koboSpan" id="kobo.819.1">
     function with different arguments.
    </span>
    <span class="koboSpan" id="kobo.819.2">
     This function sets the value of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.820.1">
      val
     </span>
    </strong>
    <span class="koboSpan" id="kobo.821.1">
     thread-local variable to the argument value, multiplies it by 2, and prints to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.822.1">
      the console:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.823.1">
#include &lt;iostream&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
thread_local int val = 0;
void setValue(int newval) { val = newval; }
void printValue() { sync_cout &lt;&lt; val &lt;&lt; ' '; }
void multiplyByTwo(int arg) {
    setValue(arg);
    val *= 2;
    printValue();
}
int main() {
    val = 1;  // Value in main thread
    std::thread t1(multiplyByTwo, 1);
    std::thread t2(multiplyByTwo, 2);
    std::thread t3(multiplyByTwo, 3);
    t1.join();
    t2.join();
    t3.join();
    std::cout &lt;&lt; val &lt;&lt; std::endl;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.824.1">
     Running this code snippet will show the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.825.1">
      following output:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.826.1">
2 4 6 1</span></pre>
   <p>
    <span class="koboSpan" id="kobo.827.1">
     Here, we can see that each thread operated on its input
    </span>
    <a id="_idIndexMarker214">
    </a>
    <span class="koboSpan" id="kobo.828.1">
     argument, resulting in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.829.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.830.1">
     printing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.831.1">
      2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.832.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.833.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.834.1">
     printing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.835.1">
      4
     </span>
    </strong>
    <span class="koboSpan" id="kobo.836.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.837.1">
      t3
     </span>
    </strong>
    <span class="koboSpan" id="kobo.838.1">
     printing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.839.1">
      6
     </span>
    </strong>
    <span class="koboSpan" id="kobo.840.1">
     .
    </span>
    <span class="koboSpan" id="kobo.840.2">
     The main thread running the main function can also access its thread local variable,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.841.1">
      val
     </span>
    </strong>
    <span class="koboSpan" id="kobo.842.1">
     , which has a value that is set to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.843.1">
      1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.844.1">
     when the program starts but only used when printed out to console at the end of the main function before exiting
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.845.1">
      the program.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.846.1">
     As with any technique, there are some drawbacks.
    </span>
    <span class="koboSpan" id="kobo.846.2">
     TLS increases memory usage, as a variable is created per thread, so it could be problematic in resource-constrained environments.
    </span>
    <span class="koboSpan" id="kobo.846.3">
     Also, accessing TLS variables might have some overhead compared with regular variables.
    </span>
    <span class="koboSpan" id="kobo.846.4">
     This can be problematic in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.847.1">
      performance-critical software.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.848.1">
     Using many of the techniques we have learned so far, let’s build
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.849.1">
      a timer.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-72">
    <a id="_idTextAnchor071">
    </a>
    <span class="koboSpan" id="kobo.850.1">
     Implementing a timer
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.851.1">
     Let us implement a timer that accepts
    </span>
    <a id="_idIndexMarker215">
    </a>
    <span class="koboSpan" id="kobo.852.1">
     intervals and callback functions.
    </span>
    <span class="koboSpan" id="kobo.852.2">
     The timer will execute the callback function at each interval.
    </span>
    <span class="koboSpan" id="kobo.852.3">
     Also, the user will be able to stop the timer by calling its
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.853.1">
       stop()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.854.1">
      function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.855.1">
     The following snippet shows an implementation of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.856.1">
      the timer:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.857.1">
#include &lt;chrono&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
using namespace std::chrono;
template&lt;typename Duration&gt;
class Timer {
   public:
    typedef std::function&lt;void(void)&gt; Callback;
    Timer(const Duration interval,
          const Callback&amp; callback) {
        auto value = duration_cast&lt;milliseconds&gt;(interval);
        sync_cout &lt;&lt; "Timer: Starting with interval of "
                  &lt;&lt; value &lt;&lt; std::endl;
        t = std::jthread([&amp;](std::stop_token stop_token) {
            while (!stop_token.stop_requested()) {
                sync_cout &lt;&lt; "Timer: Running callback "
                          &lt;&lt; val.load() &lt;&lt; std::endl;
                val++;
                callback();
                sync_cout &lt;&lt; "Timer: Sleeping...\n";
                std::this_thread::sleep_for(interval);
            }
            sync_cout &lt;&lt; „Timer: Exit\n";
        });
    }
    void stop() {
        t.request_stop();
    }
   private:
    std::jthread t;
    std::atomic_int32_t val{0};
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.858.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.859.1">
      Timer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.860.1">
     constructor accepts a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.861.1">
      Callback
     </span>
    </strong>
    <span class="koboSpan" id="kobo.862.1">
     function (a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.863.1">
      std::function&lt;void(void)&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.864.1">
     object) and a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.865.1">
      std::chrono::duration
     </span>
    </strong>
    <span class="koboSpan" id="kobo.866.1">
     object
    </span>
    <a id="_idIndexMarker216">
    </a>
    <span class="koboSpan" id="kobo.867.1">
     defining the period or interval when the callback will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.868.1">
      be executed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.869.1">
     Then a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.870.1">
      std::jthread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.871.1">
     object is created with a lambda expression, whereby a loop calls the callback in intervals of time.
    </span>
    <span class="koboSpan" id="kobo.871.2">
     This loop checks whether a stop has been requested via
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.872.1">
      stop_token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.873.1">
     , which is enabled by using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.874.1">
      stop()
     </span>
    </strong>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.875.1">
      Timer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.876.1">
     API function.
    </span>
    <span class="koboSpan" id="kobo.876.2">
     When this is the case, the loop exits and the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.877.1">
      thread terminates.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.878.1">
     Here is how to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.879.1">
      use it:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.880.1">
int main(void) {
    sync_cout &lt;&lt; "Main: Create timer\n";
    Timer timer(1s, [&amp;]() {
        sync_cout &lt;&lt; "Callback: Running...\n";
    });
    std::this_thread::sleep_for(3s);
    sync_cout &lt;&lt; "Main thread: Stop timer\n";
    timer.stop();
    std::this_thread::sleep_for(500ms);
    sync_cout &lt;&lt; "Main thread: Exit\n";
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.881.1">
     In this example, we started the timer that
    </span>
    <a id="_idIndexMarker217">
    </a>
    <span class="koboSpan" id="kobo.882.1">
     will print the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.883.1">
      Callback: Running
     </span>
    </strong>
    <span class="koboSpan" id="kobo.884.1">
     message every second.
    </span>
    <span class="koboSpan" id="kobo.884.2">
     After three seconds, the main thread will call the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.885.1">
      timer.stop()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.886.1">
     function, terminating the timer thread.
    </span>
    <span class="koboSpan" id="kobo.886.2">
     The main thread then waits for 500 milliseconds
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.887.1">
      before exiting.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.888.1">
     This is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.889.1">
      the output:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.890.1">
Main: Create timer
Timer: Starting with interval of 1000ms
Timer: Running callback 0
Callback: Running...
</span><span class="koboSpan" id="kobo.890.2">Timer: Sleeping...
</span><span class="koboSpan" id="kobo.890.3">Timer: Running callback 1
Callback: Running...
</span><span class="koboSpan" id="kobo.890.4">Timer: Sleeping...
</span><span class="koboSpan" id="kobo.890.5">Timer: Running callback 2
Callback: Running...
</span><span class="koboSpan" id="kobo.890.6">Timer: Sleeping...
</span><span class="koboSpan" id="kobo.890.7">Main thread: Stop timer
Timer: Exit
Main thread: Exit</span></pre>
   <p>
    <span class="koboSpan" id="kobo.891.1">
     As an exercise, you can slightly modify this example to implement a timeout class that calls a callback function if there is no input event within a given timeout interval.
    </span>
    <span class="koboSpan" id="kobo.891.2">
     This is a common pattern when dealing with network communications where a packet replay request is sent if no packets have been received for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.892.1">
      some time.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-73">
    <a id="_idTextAnchor072">
    </a>
    <span class="koboSpan" id="kobo.893.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.894.1">
     In this chapter, we learned how to create and manage threads, how to pass arguments or retrieve results, how TLS works, and how to wait for a thread to finish.
    </span>
    <span class="koboSpan" id="kobo.894.2">
     We also learned how to make a thread yield control to others or cancel its execution.
    </span>
    <span class="koboSpan" id="kobo.894.3">
     If something goes wrong and an exception is thrown, we now know how to pass the exception between threads and avoid an unexpected program termination.
    </span>
    <span class="koboSpan" id="kobo.894.4">
     Finally, we implemented a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.895.1">
      timer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.896.1">
     class that periodically runs a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.897.1">
      callback function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.898.1">
     In the next chapter, we will learn about thread safety, mutual exclusion, and atomic operations.
    </span>
    <span class="koboSpan" id="kobo.898.2">
     That will include mutexes, locking and lock-free algorithms, and memory synchronization ordering, among other topics.
    </span>
    <span class="koboSpan" id="kobo.898.3">
     That knowledge will help us develop thread-safe data structures
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.899.1">
      and algorithms.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-74">
    <a id="_idTextAnchor073">
    </a>
    <span class="koboSpan" id="kobo.900.1">
     Further reading
    </span>
   </h1>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.901.1">
      Compiler
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.902.1">
       support:
      </span>
     </span>
     <a href="https://en.cppreference.com/w/cpp/compiler_support">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.903.1">
        https://en.cppreference.com/w/cpp/compiler_support
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.904.1">
      GCC
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.905.1">
       releases:
      </span>
     </span>
     <a href="https://gcc.gnu.org/releases.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.906.1">
        https://gcc.gnu.org/releases.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.907.1">
       Clang:
      </span>
     </span>
     <a href="https://clang.llvm.org">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.908.1">
        https://clang.llvm.org
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.909.1">
      Clang 8
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.910.1">
       documentation:
      </span>
     </span>
     <a href="https://releases.llvm.org/8.0.0/tools/clang/docs/index.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.911.1">
        https://releases.llvm.org/8.0.0/tools/clang/docs/index.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.912.1">
      LLVM
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.913.1">
       project:
      </span>
     </span>
     <a href="https://llvm.org">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.914.1">
        https://llvm.org
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.915.1">
       Boost.Threads:
      </span>
     </span>
     <a href="https://www.boost.org/doc/libs/1_78_0/doc/html/thread.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.916.1">
        https://www.boost.org/doc/libs/1_78_0/doc/html/thread.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.917.1">
      P0024 – Technical Specification for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.918.1">
       Parallelism:
      </span>
     </span>
     <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0024r0.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.919.1">
        https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0024r0.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.920.1">
      TLS
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.921.1">
       proposal:
      </span>
     </span>
     <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2659.htm">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.922.1">
        https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2659.htm
       </span>
      </span>
     </a>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.923.1">
       Thread Launching for
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.924.1">
        C++0X
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.925.1">
       :
      </span>
     </span>
     <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2184.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.926.1">
        https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2184.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.927.1">
      TLS from
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.928.1">
       IBM:
      </span>
     </span>
     <a href="https://docs.oracle.com/cd/E19683-01/817-3677/chapter8-1/index.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.929.1">
        https://docs.oracle.com/cd/E19683-01/817-3677/chapter8-1/index.html
       </span>
      </span>
     </a>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.930.1">
       Data that is private to a
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.931.1">
        thread
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.932.1">
       :
      </span>
     </span>
     <a href="https://www.ibm.com/docs/en/i/7.5?topic=techniques-data-that-is-private-thread">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.933.1">
        https://www.ibm.com/docs/en/i/7.5?topic=techniques-data-that-is-private-thread
       </span>
      </span>
     </a>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.934.1">
       Resource Acquisition Is Initialization
      </span>
     </strong>
     <span class="koboSpan" id="kobo.935.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.936.1">
       RAII
      </span>
     </strong>
     <span class="koboSpan" id="kobo.937.1">
      ):
     </span>
     <a href="https://en.cppreference.com/w/cpp/language/raii">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.938.1">
        https://en.cppreference.com/w/cpp/language/raii
       </span>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.939.1">
      Bjarne Stroustrup,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.940.1">
       A Tour of C++
      </span>
     </em>
     <span class="koboSpan" id="kobo.941.1">
      , Third Edition, 18.2
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.942.1">
       and 18.7.
      </span>
     </span>
    </li>
   </ul>
  </div>
 </body></html>