<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-52">
    <a id="_idTextAnchor051">
    </a>
    
     3
    
   </h1>
   <h1 id="_idParaDest-53">
    <a id="_idTextAnchor052">
    </a>
    
     How to Create and Manage Threads in C++
    
   </h1>
   <p>
    
     As we learned in the previous two chapters, threads are the smallest and most lightweight units of execution within a program.
    
    
     Each thread takes care of a unique task defined by a sequence of instructions running on allocated CPU resources by the OS scheduler.
    
    
     Threads play a critical role when managing concurrency within a program aiming to maximize the overall utilization of
    
    
     
      CPU resources.
     
    
   </p>
   <p>
    
     During the program’s startup process, after the kernel passes the execution to the process, the C++ runtime creates the main thread and executes the
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function.
    
    
     After that, additional threads can be created to split the program into different tasks that can run concurrently and share resources.
    
    
     This way, the program can handle multiple tasks, improving efficiency
    
    
     
      and responsiveness.
     
    
   </p>
   <p>
    
     In this chapter, we will learn the basics of how to create and manage threads using modern C++ features.
    
    
     In the subsequent chapters, we will come across explanations of C++ lock synchronization primitives (mutexes, semaphores, barriers, and spinlocks), lock-free synchronization primitives (atomic variables), coordination synchronization primitives (condition variables), and approaches using C++ to solve or avoid potential problems when using concurrency or multithreading (race conditions or data races, deadlocks, livelocks, starvation, oversubscription, load balancing, and
    
    
     
      thread exhaustion).
     
    
   </p>
   <p>
    
     In this chapter, we are going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      How to create, manage, and cancel threads
     
     
      
       in C++
      
     
    </li>
    <li>
     
      How to pass arguments to threads and get results back from
     
     
      
       the thread
      
     
    </li>
    <li>
     
      How to sleep a thread or yield execution to
     
     
      
       other threads
      
     
    </li>
    <li>
     
      What jthread objects are and why they
     
     
      
       are useful
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-54">
    <a id="_idTextAnchor053">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     In this chapter, we will develop different solutions using C++11 and C++20.
    
    
     Therefore, we will need to install the
    
    <strong class="bold">
     
      GNU Compiler Collection
     
    </strong>
    
     (
    
    <strong class="bold">
     
      GCC
     
    </strong>
    
     ), specifically GCC 13, as well as Clang 8 (see
    
    <a href="https://en.cppreference.com/w/cpp/compiler_support">
     
      https://en.cppreference.com/w/cpp/compiler_support
     
    </a>
    
     for further details on C++
    
    
     
      compiler support).
     
    
   </p>
   <p>
    
     You can find more information about GCC at
    
    <a href="https://gcc.gnu.org">
     
      https://gcc.gnu.org
     
    </a>
    
     .
    
    
     You can find information on how to install GCC
    
    
     
      here:
     
    
    <a href="https://gcc.gnu.org/install/index.html">
     
      
       https://gcc.gnu.org/install/index.html
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     For more information about Clang, a compiler frontend supporting several languages including C++, visit
    
    <a href="https://clang.llvm.org">
     
      https://clang.llvm.org
     
    </a>
    
     .
    
    
     Clang is part of the LLVM compiler infrastructure project (
    
    <a href="https://llvm.org">
     
      https://llvm.org
     
    </a>
    
     ).
    
    
     C++ support in Clang is documented
    
    
     
      here:
     
    
    <a href="https://clang.llvm.org/cxx_status.html">
     
      
       https://clang.llvm.org/cxx_status.html
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     In this book, some code snippets do not show the libraries included.
    
    
     Additionally, some functions, even the main ones, might be simplified, showing only the relevant instructions.
    
    
     You can find all the complete code in the following GitHub
    
    
     
      repository:
     
    
    <a href="https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP">
     
      
       https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Under the
    
    <strong class="source-inline">
     
      scripts
     
    </strong>
    
     folder in the root directory in the preceding GitHub repository, you can find a script called
    
    <strong class="source-inline">
     
      install_compilers.sh
     
    </strong>
    
     that might be of help with installing the required compilers in Debian-based Linux systems.
    
    
     The script has been tested in Ubuntu 22.04
    
    
     
      and 24.04.
     
    
   </p>
   <p>
    
     The examples for this chapter are located under the
    
    <strong class="source-inline">
     
      Chapter_03
     
    </strong>
    
     folder.
    
    
     All source code files can be compiled using C++20 with CMake
    
    
     
      as follows:
     
    
   </p>
   <pre class="console">
cmake . &amp;&amp; cmake —build .</pre>
   <p>
    
     Executables will be generated under the
    
    
     <strong class="source-inline">
      
       bin
      
     </strong>
    
    
     
      directory.
     
    
   </p>
   <h1 id="_idParaDest-55">
    <a id="_idTextAnchor054">
    </a>
    
     The thread library – an introduction
    
   </h1>
   <p>
    
     The main library to
    
    <a id="_idIndexMarker157">
    </a>
    
     create and manage threads in C++ is the thread library.
    
    
     First, let’s go through a recap about threads.
    
    
     Then we will dive into what the thread
    
    
     
      library offers.
     
    
   </p>
   <h2 id="_idParaDest-56">
    <a id="_idTextAnchor055">
    </a>
    
     What are threads?
    
    
     Let’s do a recap
    
   </h2>
   <p>
    
     The purpose of
    
    <a id="_idIndexMarker158">
    </a>
    
     threads is to execute multiple simultaneous tasks in
    
    
     
      a process.
     
    
   </p>
   <p>
    
     As we have
    
    <a id="_idIndexMarker159">
    </a>
    
     seen in the previous chapter, a thread has its own stack, local data, and CPU registers such as
    
    <strong class="bold">
     
      Instruction Pointer
     
    </strong>
    
     (
    
    <strong class="bold">
     
      IP
     
    </strong>
    
     ) and
    
    <strong class="bold">
     
      Stack Pointer
     
    </strong>
    
     (
    
    <strong class="bold">
     
      SP
     
    </strong>
    
     ), but
    
    <a id="_idIndexMarker160">
    </a>
    
     shares the address space and virtual memory of its
    
    
     
      parent process.
     
    
   </p>
   <p>
    
     In the user space, we can differentiate
    
    <a id="_idIndexMarker161">
    </a>
    
     between
    
    <strong class="bold">
     
      native threads
     
    </strong>
    
     and
    
    <strong class="bold">
     
      lightweight or virtual threads
     
    </strong>
    
     .
    
    
     Native
    
    <a id="_idIndexMarker162">
    </a>
    
     threads are the ones created by
    
    <a id="_idIndexMarker163">
    </a>
    
     the OS when using some kernel APIs.
    
    
     The C++ thread objects create and manage these types of threads.
    
    
     On the other hand, lightweight threads are like native threads, except that they are emulated by a runtime or library.
    
    
     In C++,
    
    <strong class="bold">
     
      coroutines
     
    </strong>
    
     belong
    
    <a id="_idIndexMarker164">
    </a>
    
     to this group.
    
    
     As described in the previous chapter, lightweight threads have faster context switching than native threads.
    
    
     Also, multiple lightweight threads can run in the same native thread and can be much smaller than
    
    
     
      native threads.
     
    
   </p>
   <p>
    
     In this chapter, we will start learning about native threads.
    
    
     In
    
    <a href="B22219_08.xhtml#_idTextAnchor164">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     , we will learn about lightweight threads in the form
    
    
     
      of coroutines.
     
    
   </p>
   <h2 id="_idParaDest-57">
    <a id="_idTextAnchor056">
    </a>
    
     The C++ thread library
    
   </h2>
   <p>
    
     In C++, threads allow
    
    <a id="_idIndexMarker165">
    </a>
    
     multiple functions to run concurrently.
    
    
     The
    
    <strong class="source-inline">
     
      thread
     
    </strong>
    
     class defines a type-safe interface to a native thread.
    
    
     This class is defined in the
    
    <strong class="source-inline">
     
      std::thread
     
    </strong>
    
     library, in the
    
    <strong class="source-inline">
     
      &lt;thread&gt;
     
    </strong>
    
     header file in
    
    <a id="_idIndexMarker166">
    </a>
    
     the
    
    <strong class="bold">
     
      Standard Template Library
     
    </strong>
    
     (
    
    <strong class="bold">
     
      STL
     
    </strong>
    
     ).
    
    
     It is available from
    
    
     
      C++11 onward.
     
    
   </p>
   <p>
    
     Before the inclusion of the thread library in the C++ STL, developers used platform-specific libraries such as the POSIX thread (
    
    <strong class="source-inline">
     
      pthread
     
    </strong>
    
     ) library in Unix or Linux OSs, the
    
    <strong class="bold">
     
      C Runtime
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CRT
     
    </strong>
    
     ) and Win32
    
    <a id="_idIndexMarker167">
    </a>
    
     libraries for Windows NT and CE systems, or third-party libraries such as
    
    <strong class="source-inline">
     
      Boost.Threads
     
    </strong>
    
     .
    
    
     In this book, we will only use modern C++ features.
    
    
     As
    
    <strong class="source-inline">
     
      &lt;thread&gt;
     
    </strong>
    
     is available and provides a portable abstraction on top of platform-specific mechanisms, none of these libraries will be used or explained.
    
    
     In
    
    <a href="B22219_09.xhtml#_idTextAnchor184">
     
      <em class="italic">
       
        Chapter 9
       
      </em>
     
    </a>
    
     , we will introduce
    
    <strong class="source-inline">
     
      Boost.Asio
     
    </strong>
    
     , and in
    
    <a href="B22219_10.xhtml#_idTextAnchor212">
     
      <em class="italic">
       
        Chapter 10
       
      </em>
     
    </a>
    
     ,
    
    <strong class="source-inline">
     
      Boost.Cobalt
     
    </strong>
    
     .
    
    
     Both libraries provide advanced frameworks to deal with asynchronous I/O operations
    
    
     
      and coroutines.
     
    
   </p>
   <p>
    
     Now it’s time to learn about the different
    
    
     
      thread operations.
     
    
   </p>
   <h1 id="_idParaDest-58">
    <a id="_idTextAnchor057">
    </a>
    
     Thread operations
    
   </h1>
   <p>
    
     In this section, we will learn
    
    <a id="_idIndexMarker168">
    </a>
    
     how to create threads, pass
    
    <a id="_idIndexMarker169">
    </a>
    
     arguments during their construction, return values from threads, cancel threads execution, catch exceptions, and
    
    
     
      much more.
     
    
   </p>
   <h2 id="_idParaDest-59">
    <a id="_idTextAnchor058">
    </a>
    
     Thread creation
    
   </h2>
   <p>
    
     When a thread is created, it executes
    
    <a id="_idIndexMarker170">
    </a>
    
     immediately.
    
    
     It is only delayed by the OS scheduling process.
    
    
     If there are not enough resources to run both parent and child threads in parallel, the order in which they will run is
    
    
     
      not defined.
     
    
   </p>
   <p>
    
     The constructor argument defines the function or
    
    <strong class="source-inline">
     
      function
     
    </strong>
    
     object to be executed by the thread.
    
    
     This callable object should not return anything, as its return value will be ignored.
    
    
     If for some reason the thread execution ends with an exception,
    
    <strong class="source-inline">
     
      std::terminate
     
    </strong>
    
     is called unless an exception is caught, as we will see later in
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     In the following examples, we create six threads using different
    
    
     
      callable objects.
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     using a
    
    
     
      function pointer:
     
    
   </p>
   <pre class="source-code">
void func() {
    std::cout &lt;&lt; "Using function pointer\n";
}
std::thread t1(func);</pre>
   <p>
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     using a
    
    
     
      lambda function:
     
    
   </p>
   <pre class="source-code">
auto lambda_func = []() {
    std::cout &lt;&lt; "Using lambda function\n";
};
std::thread t2(lambda_func);</pre>
   <p>
    <strong class="source-inline">
     
      t3
     
    </strong>
    
     using an embedded
    
    
     
      lambda function:
     
    
   </p>
   <pre class="source-code">
std::thread t3([]() {
    std::cout &lt;&lt; "Using embedded lambda function\n";
});</pre>
   <p>
    <strong class="source-inline">
     
      t4
     
    </strong>
    
     using a
    
    <strong class="source-inline">
     
      function
     
    </strong>
    
     object where
    
    <strong class="source-inline">
     
      operator()
     
    </strong>
    
     
      is overloaded:
     
    
   </p>
   <pre class="source-code">
class FuncObjectClass {
   public:
    void operator()() {
        std::cout &lt;&lt; "Using function object class\n";
    }
};
std::thread t4{FuncObjectClass()};</pre>
   <p>
    <strong class="source-inline">
     
      t5
     
    </strong>
    
     using a non-static
    
    <strong class="source-inline">
     
      member
     
    </strong>
    
     function by
    
    <a id="_idIndexMarker171">
    </a>
    
     passing the address of the
    
    <strong class="source-inline">
     
      member
     
    </strong>
    
     function and the address of an object to call the
    
    
     <strong class="source-inline">
      
       member
      
     </strong>
    
    
     
      function:
     
    
   </p>
   <pre class="source-code">
class Obj {
  public:
    void func() {
        std::cout &lt;&lt; "Using a non-static member function"
                  &lt;&lt; std::endl;
    }
};
Obj obj;
std::thread t5(&amp;Obj::func, &amp;obj);</pre>
   <p>
    <strong class="source-inline">
     
      t6
     
    </strong>
    
     using a static
    
    <strong class="source-inline">
     
      member
     
    </strong>
    
     function where only the
    
    <a id="_idIndexMarker172">
    </a>
    
     address of the
    
    <strong class="source-inline">
     
      member
     
    </strong>
    
     function is needed as the method
    
    
     
      is static:
     
    
   </p>
   <pre class="source-code">
class Obj {
  public:
    static void static_func() {
        std::cout &lt;&lt; "Using a static member function\n";
    }
};
std::thread t6(&amp;Obj::static_func);</pre>
   <p>
    
     Thread creation incurs some overhead that can be reduced by using thread pools, as we will explore in
    
    <a href="B22219_04.xhtml#_idTextAnchor074">
     
      <em class="italic">
       
        Chapter 4
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <h3>
    
     Checking hardware concurrency
    
   </h3>
   <p>
    
     One of the strategies for effective thread
    
    <a id="_idIndexMarker173">
    </a>
    
     management, which is related to scalability and performance and was
    
    <a id="_idIndexMarker174">
    </a>
    
     commented on in the previous chapter, is to balance the number of threads with the available resources to
    
    
     
      avoid over-subscription.
     
    
   </p>
   <p>
    
     To retrieve the number of concurrent threads supported by the OS, we can use the
    
    
     <strong class="source-inline">
      
       std::thread::hardware_concurrency()
      
     </strong>
    
    
     
      function:
     
    
   </p>
   <pre class="source-code">
const auto processor_count = std::thread::hardware_concurrency();</pre>
   <p>
    
     The value returned by this function must be considered to only provide a hint about the number of threads that will run concurrently.
    
    
     It is also sometimes not well defined, thus returning a value
    
    
     
      of
     
    
    
     <strong class="source-inline">
      
       0
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-60">
    <a id="_idTextAnchor059">
    </a>
    
     Synchronized stream writing
    
   </h2>
   <p>
    
     When we print
    
    <a id="_idIndexMarker175">
    </a>
    
     messages to the
    
    <a id="_idIndexMarker176">
    </a>
    
     console by using
    
    <strong class="source-inline">
     
      std::cout
     
    </strong>
    
     from two or more threads, the output result can be messy.
    
    
     This is due to a
    
    <strong class="bold">
     
      race condition
     
    </strong>
    
     happening in the
    
    
     
      output stream.
     
    
   </p>
   <p>
    
     As commented in the previous chapter, race conditions are bugs in software that happen in concurrent and multithreaded programs, whose behavior depends on the sequence of events happening on a shared resource where at least one of the actions is not atomic.
    
    
     We will learn more about how to avoid them in
    
    <a href="B22219_04.xhtml#_idTextAnchor074">
     
      <em class="italic">
       
        Chapter 4
       
      </em>
     
    </a>
    
     .
    
    
     Additionally, we will learn how to debug race conditions using Clang’s sanitizers in
    
    <a href="B22219_12.xhtml#_idTextAnchor243">
     
      <em class="italic">
       
        Chapter 12
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The following code snippet shows two threads printing a sequence of numbers.
    
    
     The
    
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     thread should print lines containing the
    
    <strong class="source-inline">
     
      1 2 3 4
     
    </strong>
    
     sequence.
    
    
     The
    
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     thread should print the
    
    <strong class="source-inline">
     
      5 6 7 8
     
    </strong>
    
     sequence.
    
    
     Each thread prints its sequence 100 times.
    
    
     Before the main thread exits, it waits for
    
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     to finish by using
    
    <strong class="source-inline">
     
      join()
     
    </strong>
    
     .
    
   </p>
   <p>
    
     More about joining threads later in
    
    
     
      this chapter.
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
#include &lt;thread&gt;
int main() {
    std::thread t1([]() {
        for (int i = 0; i &lt; 100; ++i) {
            std::cout &lt;&lt; "1 " &lt;&lt; "2 " &lt;&lt; "3 " &lt;&lt; "4 "
                      &lt;&lt; std::endl;
        }
    });
    std::thread t2([]() {
        for (int i = 0; i &lt; 100; ++i) {
            std::cout &lt;&lt; "5 " &lt;&lt; "6 " &lt;&lt; "7 " &lt;&lt; "8 "
                      &lt;&lt; std::endl;
        }
    });
    t1.join();
    t2.join();
    return 0;
}</pre>
   <p>
    
     However, running the previous example shows some lines with the
    
    
     
      following content:
     
    
   </p>
   <pre class="console">
6 1 2 3 4
1 5 2 6 3 4 7 8
1 2 3 5 6 7 8</pre>
   <p>
    
     To avoid these issues, we can
    
    <a id="_idIndexMarker177">
    </a>
    
     simply write from a specific thread or use a
    
    <strong class="source-inline">
     
      std::ostringstream
     
    </strong>
    
     object that makes atomic calls to the
    
    
     <strong class="source-inline">
      
       std::cout
      
     </strong>
    
    
     
      object:
     
    
   </p>
   <pre class="source-code">
std::ostringstream oss;
oss &lt;&lt; "1 " &lt;&lt; "2 " &lt;&lt; "3 " &lt;&lt; "4 " &lt;&lt; "\n";
std::cout &lt;&lt; oss.str();</pre>
   <p>
    
     From C++20 onward, we also can use the
    
    <strong class="source-inline">
     
      std::osyncstream
     
    </strong>
    
     objects.
    
    
     They behave similarly to
    
    <strong class="source-inline">
     
      std::cout
     
    </strong>
    
     but with writing
    
    <a id="_idIndexMarker178">
    </a>
    
     synchronization between threads accessing the same stream.
    
    
     However, as only the transfer step from its internal buffer to the output stream is synchronized, every thread needs its own
    
    
     <strong class="source-inline">
      
       std::osyncstream
      
     </strong>
    
    
     
      instance.
     
    
   </p>
   <p>
    
     The internal buffer is transferred when the stream is destroyed, which is when
    
    <strong class="source-inline">
     
      emit()
     
    </strong>
    
     is
    
    
     
      explicitly called.
     
    
   </p>
   <p>
    
     The following is a simple solution to allow
    
    <a id="_idIndexMarker179">
    </a>
    
     synchronization on each
    
    
     
      printed line:
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
int main() {
    std::thread t1([]() {
        for (int i = 0; i &lt; 100; ++i) {
            sync_cout &lt;&lt; "1 " &lt;&lt; "2 " &lt;&lt; "3 " &lt;&lt; "4 "
                      &lt;&lt; std::endl;
        }
    });
    std::thread t2([]() {
        for (int i = 0; i &lt; 100; ++i) {
            sync_cout &lt;&lt; "5 " &lt;&lt; "6 " &lt;&lt; "7 " &lt;&lt; "8 "
                      &lt;&lt; std::endl;
        }
    });
    t1.join();
    t2.join();
    return 0;
}</pre>
   <p>
    
     Both solutions will output the sequences without
    
    
     
      interleaving them
     
    
   </p>
   <pre class="console">
1 2 3 4
1 2 3 4
5 6 7 8</pre>
   <p>
    
     As this approach is now the
    
    <a id="_idIndexMarker180">
    </a>
    
     official C++20 way of avoiding race conditions when outputting content, we will use
    
    <strong class="source-inline">
     
      std::osyncstream
     
    </strong>
    
     as the default approach throughout the rest of
    
    
     
      this book.
     
    
   </p>
   <h2 id="_idParaDest-61">
    <a id="_idTextAnchor060">
    </a>
    
     Sleeping the current thread
    
   </h2>
   <p>
    <strong class="source-inline">
     
      std::this_thread
     
    </strong>
    
     is a
    
    <a id="_idIndexMarker181">
    </a>
    
     namespace.
    
    
     It gives access to
    
    <a id="_idIndexMarker182">
    </a>
    
     functions from the current thread to yield the execution to another thread or block the execution of the current task and wait for
    
    
     
      a period.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      std::this_thread::sleep_for
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      std::this_thread::sleep_until
     
    </strong>
    
     functions block the execution of the thread for a given amount
    
    
     
      of time.
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      std::this_thread::sleep_for
     
    </strong>
    
     sleeps for at least a given duration.
    
    
     The blockage can be longer depending on how the OS scheduler decides to run tasks, or due to some resource
    
    
     
      contention delays.
     
    
   </p>
   <p class="callout-heading">
    
     Resource contention
    
   </p>
   <p class="callout">
    
     Resource contention occurs when demand exceeds supply for a certain shared resource, leading to
    
    
     
      performance degradation.
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      std::this_thread::sleep_until
     
    </strong>
    
     works like
    
    <strong class="source-inline">
     
      std::this_thread::sleep_for
     
    </strong>
    
     .
    
    
     However, instead of sleeping for a
    
    <a id="_idIndexMarker183">
    </a>
    
     duration, it sleeps until a specific time point has been reached.
    
    
     The clock where the time point is
    
    <a id="_idIndexMarker184">
    </a>
    
     computed must meet the
    
    <strong class="source-inline">
     
      Clock
     
    </strong>
    
     requirement (you can find more information on this here:
    
    <a href="https://en.cppreference.com/w/cpp/named_req/Clock">
     
      https://en.cppreference.com/w/cpp/named_req/Clock
     
    </a>
    
     ).
    
    
     It is recommended by the standard to use a steady clock instead of the system clock to set up
    
    
     
      the duration.
     
    
   </p>
   <h2 id="_idParaDest-62">
    <a id="_idTextAnchor061">
    </a>
    
     Identifying a thread
    
   </h2>
   <p>
    
     When debugging
    
    <a id="_idIndexMarker185">
    </a>
    
     multithreaded solutions, it is useful to know which thread is executing a given function.
    
    
     Each thread can be identified by an identifier, making it possible to log in its value for traceability
    
    
     
      and debugging.
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      std::thread::id
     
    </strong>
    
     is a lightweight class that defines a unique identifier of thread objects (
    
    <strong class="source-inline">
     
      std::thread
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      std::jthread
     
    </strong>
    
     , which we will introduce later in this chapter).
    
    
     This identifier is retrieved by using the
    
    
     <strong class="source-inline">
      
       get_id()
      
     </strong>
    
    
     
      function.
     
    
   </p>
   <p>
    
     Thread identifier objects can be compared, serialized, and printed via an output stream.
    
    
     They can also be used as a key in mapping containers, as they are supported by the
    
    
     <strong class="source-inline">
      
       std::hash
      
     </strong>
    
    
     
      function.
     
    
   </p>
   <p>
    
     The following example prints the identifier of the
    
    <strong class="source-inline">
     
      t
     
    </strong>
    
     thread.
    
    
     Later in this chapter, we will learn how to create a thread and sleep for an interval
    
    
     
      of time:
     
    
   </p>
   <pre class="source-code">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
void func() {
    std::this_thread::sleep_for(1s);
}
int main() {
    std::thread t(func);
    std::cout &lt;&lt; "Thread ID: " &lt;&lt; t.get_id() &lt;&lt; std::endl;
    t.join();
    return 0;
}</pre>
   <p>
    
     Remember that when a thread finishes, its identifier can be reused by a
    
    
     
      future thread.
     
    
   </p>
   <h2 id="_idParaDest-63">
    <a id="_idTextAnchor062">
    </a>
    
     Passing arguments
    
   </h2>
   <p>
    
     Arguments
    
    <a id="_idIndexMarker186">
    </a>
    
     can be passed to the thread by value, by reference, or
    
    
     
      as pointers.
     
    
   </p>
   <p>
    
     Here we can see how to pass
    
    <a id="_idIndexMarker187">
    </a>
    <a id="_idIndexMarker188">
    </a>
    
     arguments
    
    
     
      by value:
     
    
   </p>
   <pre class="source-code">
void funcByValue(const std::string&amp; str, int val) {
    sync_cout &lt;&lt; «str: « &lt;&lt; str &lt;&lt; «, val: « &lt;&lt; val
              &lt;&lt; std::endl;
}
std::string str{"Passing by value"};
std::thread t(funcByValue, str, 1);</pre>
   <p>
    
     Passing by value avoids data races.
    
    
     However, it is much more costly, as data is
    
    
     
      copied across.
     
    
   </p>
   <p>
    
     The next example shows how to pass values
    
    
     
      by reference:
     
    
   </p>
   <pre class="source-code">
void modifyValues(std::string&amp; str, int&amp; val) {
    str += " (Thread)";
    val++;
}
std::string str{"Passing by reference"};
int val = 1;
std::thread t(modifyValues, std::ref(str), std::ref(val));</pre>
   <p>
    
     Or
    
    
     
      as
     
    
    
     <strong class="source-inline">
      
       const-reference
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
void printVector(const std::vector&lt;int&gt;&amp; v) {
    sync_cout &lt;&lt; "Vector: ";
    for (int num : v) {
        sync_cout &lt;&lt; num &lt;&lt; " ";
    }
    sync_cout &lt;&lt; std::endl;
}
std::vector&lt;int&gt; v{1, 2, 3, 4, 5};
std::thread t(printVector, std::cref(v));</pre>
   <p>
    
     Passing by reference is achieved by using
    
    <strong class="source-inline">
     
      ref()
     
    </strong>
    
     (non-const references) or
    
    <strong class="source-inline">
     
      cref()
     
    </strong>
    
     (const-references).
    
    
     Both are defined in the
    
    <strong class="source-inline">
     
      &lt;functional&gt;
     
    </strong>
    
     header file.
    
    
     This lets the variadic template define the thread constructor to treat the argument as
    
    
     
      a reference.
     
    
   </p>
   <p>
    
     These helper functions are used to generate
    
    <strong class="source-inline">
     
      std::reference_wrapper
     
    </strong>
    
     objects, which wrap a reference in a copyable and assignable object.
    
    
     Missing these functions when passing arguments makes the arguments to be passed
    
    
     
      by value.
     
    
   </p>
   <p>
    
     You can also move an object into a thread
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
std::thread t(printVector, std::move(v));</pre>
   <p>
    
     However, note that trying to access the
    
    <strong class="source-inline">
     
      v
     
    </strong>
    
     vector in the main thread after it is moved into the
    
    <strong class="source-inline">
     
      t
     
    </strong>
    
     thread would result in
    
    <a id="_idIndexMarker189">
    </a>
    
     
      undefined behavior.
     
    
   </p>
   <p>
    
     Finally, we can also allow
    
    <a id="_idIndexMarker190">
    </a>
    
     threads to access variables by
    
    
     
      lambda captures:
     
    
   </p>
   <pre class="source-code">
std::string str{"Hello"};
std::thread t([&amp;]() {
    sync_cout &lt;&lt; "str: " &lt;&lt; str &lt;&lt; std::endl;
});</pre>
   <p>
    
     In this example, the
    
    <strong class="source-inline">
     
      str
     
    </strong>
    
     variable is accessed by the
    
    <strong class="source-inline">
     
      t
     
    </strong>
    
     thread as a reference captured by the embedded
    
    
     
      lambda function.
     
    
   </p>
   <h2 id="_idParaDest-64">
    <a id="_idTextAnchor063">
    </a>
    
     Returning values
    
   </h2>
   <p>
    
     To return
    
    <a id="_idIndexMarker191">
    </a>
    
     values that have been computed in a thread, we can use a shared variable with a synchronization mechanism such as a mutex, lock, or
    
    
     
      atomic variable.
     
    
   </p>
   <p>
    
     In the following code snippet, we can see how to return a value computed by a thread by using an argument passed by a non-const reference (using
    
    <strong class="source-inline">
     
      ref()
     
    </strong>
    
     ).
    
    
     The
    
    <strong class="source-inline">
     
      result
     
    </strong>
    
     variable is computed within the
    
    <strong class="source-inline">
     
      t
     
    </strong>
    
     thread in the
    
    <strong class="source-inline">
     
      func
     
    </strong>
    
     function.
    
    
     The resulting value can be seen from the main thread.
    
    
     As we will learn in the next section, the
    
    <strong class="source-inline">
     
      join()
     
    </strong>
    
     function simply waits for the
    
    <strong class="source-inline">
     
      t
     
    </strong>
    
     thread to finish before letting the main thread continue running and checking the
    
    <strong class="source-inline">
     
      result
     
    </strong>
    
     
      variable afterward:
     
    
   </p>
   <pre class="source-code">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
namespace {
int result = 0;
};
void func(int&amp; result) {
    std::this_thread::sleep_for(1s);
    result = 1 + (rand () % 10);
}
Int main() {
    std::thread t(func, std::ref(result));
    t.join();
    sync_cout &lt;&lt; "Result: " &lt;&lt; result &lt;&lt; std::endl;
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      reference
     
    </strong>
    <a id="_idIndexMarker192">
    </a>
    
     argument can be a reference to the input object itself, or to another variable where we want the result to be stored, as done in this example with the
    
    
     <strong class="source-inline">
      
       result
      
     </strong>
    
    
     
      variable.
     
    
   </p>
   <p>
    
     We can also return the value using a lambda capture, as shown in the
    
    
     
      following example:
     
    
   </p>
   <pre class="source-code">
std::thread t([&amp;]() { func(result); });
t.join();
sync_cout &lt;&lt; "Result: " &lt;&lt; result &lt;&lt; std::endl;</pre>
   <p>
    
     We can also do this by writing into a shared variable protected by a mutex, locking the mutex (using
    
    <strong class="source-inline">
     
      std::lock_guard
     
    </strong>
    
     , for example) before executing the writing operation.
    
    
     However, we will dive deeper into these mechanisms in
    
    <a href="B22219_04.xhtml#_idTextAnchor074">
     
      <em class="italic">
       
        Chapter 4
       
      </em>
     
    </a>
    
     
      :
     
    
   </p>
   <pre class="source-code">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;random&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
namespace {
int result = 0;
std::mutex mtx;
};
void funcWithMutex() {
    std::this_thread::sleep_for(1s);
    int localVar = 1 + (rand() % 10);
    std::lock_guard&lt;std::mutex&gt; lock(mtx);
    result = localVar;
}
Int main() {
    std::thread t(funcWithMutex);
    t.join();
    sync_cout &lt;&lt; "Result: " &lt;&lt; result &lt;&lt; std::endl;
}</pre>
   <p>
    
     There is a more elegant way of
    
    <a id="_idIndexMarker193">
    </a>
    
     returning values from threads.
    
    
     This involves using futures and promises, which we will learn about in
    
    <a href="B22219_06.xhtml#_idTextAnchor125">
     
      <em class="italic">
       
        Chapter 6
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-65">
    <a id="_idTextAnchor064">
    </a>
    
     Moving threads
    
   </h2>
   <p>
    
     Threads can be
    
    <a id="_idIndexMarker194">
    </a>
    
     moved but not copied.
    
    
     This is to avoid having two different thread objects to represent the same
    
    
     
      hardware thread.
     
    
   </p>
   <p>
    
     In the following example,
    
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     is moved to
    
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     using
    
    <strong class="source-inline">
     
      std::move
     
    </strong>
    
     .
    
    
     Therefore,
    
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     inherits the same identifier as
    
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     had before being moved and
    
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     is not joinable, as it no longer contains any valid
    
    
     
      thread anymore:
     
    
   </p>
   <pre class="source-code">
#include &lt;chrono&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
void func() {
    for (auto i=0; i&lt;10; ++i) {
        std::this_thread::sleep_for(500ms);
    }
}
int main() {
    std::thread t1(func);
    std::thread t2 = std::move(t1);
    t2.join();
    return 0;
}</pre>
   <p>
    
     When a
    
    <strong class="source-inline">
     
      std::thread
     
    </strong>
    
     object is moved to another
    
    <strong class="source-inline">
     
      std::thread
     
    </strong>
    
     object, the move-from-thread object will reach a state where it does not represent a real thread anymore.
    
    
     This situation also happens to thread objects resulting from the default constructor after detaching or joining them.
    
    
     We will introduce these operations in the
    
    
     
      next section.
     
    
   </p>
   <h2 id="_idParaDest-66">
    <a id="_idTextAnchor065">
    </a>
    
     Waiting for a thread to finish
    
   </h2>
   <p>
    
     There are use
    
    <a id="_idIndexMarker195">
    </a>
    
     cases where a thread needs to wait for another thread to finish so that it can use the result computed by the latter thread.
    
    
     Other use cases involve running a thread in the background, detaching it, and continuing to execute the
    
    
     
      main thread.
     
    
   </p>
   <h3>
    
     Joining a thread
    
   </h3>
   <p>
    
     The
    
    <strong class="source-inline">
     
      join()
     
    </strong>
    
     function blocks the
    
    <a id="_idIndexMarker196">
    </a>
    
     current thread while waiting for the completion of the joining thread identified by the thread object where the
    
    <strong class="source-inline">
     
      join()
     
    </strong>
    
     function is being called.
    
    
     This ensures that the joining thread has terminated after
    
    <strong class="source-inline">
     
      join()
     
    </strong>
    
     returns (see the
    
    <em class="italic">
     
      Thread life cycle
     
    </em>
    
     section in
    
    <a href="B22219_02.xhtml#_idTextAnchor035">
     
      <em class="italic">
       
        Chapter 2
       
      </em>
     
    </a>
    
     for
    
    
     
      more details).
     
    
   </p>
   <p>
    
     It is easy to forget to use a
    
    <strong class="source-inline">
     
      join()
     
    </strong>
    
     function.
    
    <strong class="bold">
     
      Joining Thread
     
    </strong>
    
     (
    
    <strong class="bold">
     
      jthread
     
    </strong>
    
     ) solves
    
    <a id="_idIndexMarker197">
    </a>
    
     that problem.
    
    
     It is available from C++20 onward.
    
    
     We will introduce it in the
    
    
     
      next section.
     
    
   </p>
   <h3>
    
     Checking whether a thread is joinable
    
   </h3>
   <p>
    
     A thread is considered joinable and therefore active if the
    
    <strong class="source-inline">
     
      join()
     
    </strong>
    
     function has not been called in that thread.
    
    
     This is true even if the thread has finished executing code but still has not been joined.
    
    
     On the other hand, a default constructed thread or a thread that has already been joined is
    
    
     <em class="italic">
      
       not
      
     </em>
    
    
     
      joinable.
     
    
   </p>
   <p>
    
     To check whether a thread is joinable, just use the
    
    
     <strong class="source-inline">
      
       std::thread::joinable()
      
     </strong>
    
    
     
      function.
     
    
   </p>
   <p>
    
     Let us see the usage of
    
    <strong class="source-inline">
     
      std::thread::join()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      std::thread::joinable()
     
    </strong>
    
     in the
    
    
     
      following example:
     
    
   </p>
   <pre class="source-code">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
void func() {
    std::this_thread::sleep_for(100ms);
}
int main() {
    std::thread t1;
    std::cout &lt;&lt; "Is t1 joinable? " &lt;&lt; t1.joinable()
              &lt;&lt; std::endl;
    std::thread t2(func);
    t1.swap(t2);
    std::cout &lt;&lt; "Is t1 joinable? " &lt;&lt; t1.joinable()
              &lt;&lt; std::endl;
    std::cout &lt;&lt; "Is t2 joinable? " &lt;&lt; t2.joinable()
              &lt;&lt; std::endl;
    t1.join();
    std::cout &lt;&lt; "Is t1 joinable? " &lt;&lt; t1.joinable()
              &lt;&lt; std::endl;
}</pre>
   <p>
    
     After
    
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     has been constructed using the default constructor (not specifying a callable object), the thread will not be joinable.
    
    
     As
    
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     is constructed specifying a function,
    
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     is joinable after construction.
    
    
     However, when
    
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     are swapped,
    
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     becomes joinable again and
    
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     is not joinable anymore.
    
    
     Then the main thread waits for
    
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     to join, so it is no longer joinable.
    
    
     Trying to join
    
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     , a non-joinable thread, results in undefined behavior.
    
    
     Finally, not joining a joinable thread will lead to resource leaks or potential program crashes due to the unexpected use of
    
    
     
      shared resources.
     
    
   </p>
   <h3>
    
     Daemon thread by detaching
    
   </h3>
   <p>
    
     If we want a thread to continue
    
    <a id="_idIndexMarker198">
    </a>
    
     running in the background as a
    
    <strong class="bold">
     
      daemon thread
     
    </strong>
    
     but finish the execution of the current thread, we can use the
    
    <strong class="source-inline">
     
      std::thread::detach()
     
    </strong>
    
     function.
    
    
     A daemon thread is a thread that performs some tasks in the background that do not need to run to completion.
    
    
     If the main program exits, all daemon threads are terminated.
    
    
     As commented earlier, a thread must join or detach before the main thread terminates, otherwise the program will abort
    
    
     
      its execution.
     
    
   </p>
   <p>
    
     After calling
    
    <strong class="source-inline">
     
      detach
     
    </strong>
    
     , the detached thread cannot be controlled or joined (as it is waiting for its completion) using the
    
    <strong class="source-inline">
     
      std::thread
     
    </strong>
    
     object, as this object no longer represents the
    
    
     
      detached thread.
     
    
   </p>
   <p>
    
     The following example shows a daemon thread called
    
    <strong class="source-inline">
     
      t
     
    </strong>
    
     that is detached just after construction, running the
    
    <strong class="source-inline">
     
      daemonThread()
     
    </strong>
    
     function in the background.
    
    
     This function executes for three seconds and then exits, finishing the thread execution.
    
    
     Meanwhile, the main thread sleeps for one more second than the thread execution time
    
    
     
      before exiting:
     
    
   </p>
   <pre class="source-code">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
namespace {
int timeout = 3;
}
void daemonThread() {
    sync_cout &lt;&lt; "Daemon thread starting...\n";
    while (timeout-- &gt; 0) {
        sync_cout &lt;&lt; "Daemon thread is running...\n";
        std::this_thread::sleep_for(1s);
    }
    sync_cout &lt;&lt; "Daemon thread exiting...\n";
}
int main() {
    std::thread t(daemonThread);
    t.detach();
    std::this_thread::sleep_for(
              std::chrono::seconds(timeout + 1));
    sync_cout &lt;&lt; "Main thread exiting...\n";
    Return 0;
}</pre>
   <h2 id="_idParaDest-67">
    <a id="_idTextAnchor066">
    </a>
    
     Joining threads – the jthread class
    
   </h2>
   <p>
    
     From C++20 onward, there is a
    
    <a id="_idIndexMarker199">
    </a>
    
     new class:
    
    <strong class="source-inline">
     
      std::jthread
     
    </strong>
    
     .
    
    
     This class is like
    
    <strong class="source-inline">
     
      std:thread
     
    </strong>
    
     but with the additional functionality that the thread rejoins on destruction,
    
    <a id="_idIndexMarker200">
    </a>
    
     following the
    
    <strong class="bold">
     
      Resource Acquisition is Initialization
     
    </strong>
    
     (
    
    <strong class="bold">
     
      RAII
     
    </strong>
    
     ) technique.
    
    
     It can be canceled or stopped in
    
    
     
      some scenarios.
     
    
   </p>
   <p>
    
     As you can see in the following example, a
    
    <strong class="source-inline">
     
      jthread
     
    </strong>
    
     thread has the same interface as
    
    <strong class="source-inline">
     
      std::thread
     
    </strong>
    
     .
    
    
     The only difference is that we do not need to call the
    
    <strong class="source-inline">
     
      join()
     
    </strong>
    
     function to ensure that the main thread waits for the
    
    <strong class="source-inline">
     
      t
     
    </strong>
    
     thread
    
    
     
      to join:
     
    
   </p>
   <pre class="source-code">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
void func() {
    std::this_thread::sleep_for(1s);
}
int main() {
    std::jthread t(func);
    sync_cout &lt;&lt; "Thread ID: " &lt;&lt; t.get_id() &lt;&lt; std::endl;
    return 0;
}</pre>
   <p>
    
     When two
    
    <strong class="source-inline">
     
      std::jthread
     
    </strong>
    
     s are destroyed, their destructors are called in reverse order from their constructors.
    
    
     To demonstrate this behavior, let us implement a thread wrapper class that prints some messages when the wrapped thread is created
    
    
     
      and destroyed:
     
    
   </p>
   <pre class="source-code">
#include &lt;chrono&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
class JthreadWrapper {
   public:
    JthreadWrapper(
       const std::function&lt;void(const std::string&amp;)&gt;&amp; func,
       const std::string&amp; str)
        : t(func, str), name(str) {
        sync_cout &lt;&lt; "Thread " &lt;&lt; name
                  &lt;&lt; " being created" &lt;&lt; std::endl;
    }
    ~JthreadWrapper() {
        sync_cout &lt;&lt; "Thread " &lt;&lt; name
                  &lt;&lt; " being destroyed" &lt;&lt; std::endl;
    }
   private:
    std::jthread t;
    std::string name;
};</pre>
   <p>
    
     Using this
    
    <strong class="source-inline">
     
      JthreadWrapper
     
    </strong>
    
     wrapper class, we start three threads that
    
    <a id="_idIndexMarker201">
    </a>
    
     execute the
    
    <strong class="source-inline">
     
      func
     
    </strong>
    
     function.
    
    
     Each will wait for a second
    
    
     
      before exiting:
     
    
   </p>
   <pre class="source-code">
void func(const std::string&amp; name) {
    sync_cout &lt;&lt; "Thread " &lt;&lt; name &lt;&lt; " starting...\n";
    std::this_thread::sleep_for(1s);
    sync_cout &lt;&lt; "Thread " &lt;&lt; name &lt;&lt; " finishing...\n";
}
int main() {
    JthreadWrapper t1(func, «t1»);
    JthreadWrapper t2(func, "t2");
    JthreadWrapper t3(func, "t3");
    std::this_thread::sleep_for(2s);
    sync_cout &lt;&lt; "Main thread exiting..." &lt;&lt; std::endl;
    return 0;
}</pre>
   <p>
    
     This program will show the
    
    
     
      following output:
     
    
   </p>
   <pre class="console">
Thread t1 being created
Thread t1 starting...
Thread t2 being created
Thread t2 starting...
Thread t3 being created
Thread t3 starting...
Thread t1 finishing...
Thread t2 finishing...
Thread t3 finishing...
Main thread exiting...
Thread t3 being destroyed
Thread t2 being destroyed
Thread t1 being destroyed</pre>
   <p>
    
     As we can see,
    
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     is created first, then
    
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     , and finally
    
    <strong class="source-inline">
     
      t3
     
    </strong>
    
     .
    
    
     The destructors follow the reverse order, with
    
    <strong class="source-inline">
     
      t3
     
    </strong>
    
     being destroyed first, then
    
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     , and
    
    
     <strong class="source-inline">
      
       t1
      
     </strong>
    
    
     
      last.
     
    
   </p>
   <p>
    
     As jthreads avoid pitfalls when we
    
    <a id="_idIndexMarker202">
    </a>
    
     forget to use
    
    <strong class="source-inline">
     
      join
     
    </strong>
    
     in a thread, we simply prefer to use
    
    <strong class="source-inline">
     
      std::jthread
     
    </strong>
    
     over
    
    <strong class="source-inline">
     
      std::thread
     
    </strong>
    
     .
    
    
     There might be cases where we need to use explicit calls to
    
    <strong class="source-inline">
     
      join()
     
    </strong>
    
     to be sure that threads have been joined and resources properly freed up before moving to
    
    
     
      another task.
     
    
   </p>
   <h2 id="_idParaDest-68">
    <a id="_idTextAnchor067">
    </a>
    
     Yielding thread execution
    
   </h2>
   <p>
    
     A thread can also decide to pause its
    
    <a id="_idIndexMarker203">
    </a>
    
     execution, let the implementation reschedule the execution of threads, and give the chance to other threads
    
    
     
      to run.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      std::this_thread::yield
     
    </strong>
    
     method provides a hint to the OS to reschedule another thread.
    
    
     The behavior is implementation-dependent, depending on the OS scheduler and the current state of
    
    
     
      the system.
     
    
   </p>
   <p>
    
     Some Linux implementations suspend the current thread and move it back to a queue of threads to schedule all threads with the same priority.
    
    
     If this queue is empty, the yield has
    
    
     
      no effect.
     
    
   </p>
   <p>
    
     The following example shows two threads,
    
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     , executing the same work function.
    
    
     They randomly choose to either do some work (locking a mutex, as we will learn about in the next chapter, and waiting for three seconds) or yield the execution to the
    
    
     
      other thread:
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;string&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono;
namespace {
int val = 0;
std::mutex mtx;
}
int main() {
    auto work = [&amp;](const std::string&amp; name) {
        while (true) {
            bool work_to_do = rand() % 2;
            if (work_to_do) {
                sync_cout &lt;&lt; name &lt;&lt; ": working\n";
                std::lock_guard&lt;std::mutex&gt; lock(mtx);
                for (auto start = steady_clock::now(),
                          now = start;
                          now &lt; start + 3s;
                          now = steady_clock::now()) {
                }
            } else {
                sync_cout &lt;&lt; name &lt;&lt; ": yielding\n";
                std::this_thread::yield();
            }
        }
    };
    std::jthread t1(work, "t1");
    std::jthread t2(work, "t2");
    return 0;
}</pre>
   <p>
    
     When running this example, when the execution reaches the yield command, we can see how the thread that is currently running stops and enables the other thread to restart
    
    
     
      its execution.
     
    
   </p>
   <h2 id="_idParaDest-69">
    <a id="_idTextAnchor068">
    </a>
    
     Threads cancellation
    
   </h2>
   <p>
    
     If we are no longer
    
    <a id="_idIndexMarker204">
    </a>
    
     interested in the result that a thread is computing, we will want to cancel that thread and avoid more
    
    
     
      computation costs.
     
    
   </p>
   <p>
    
     Killing a thread could be a solution.
    
    
     However, that leaves resources that belong to the thread handling, such as other threads started from that thread, locks, connections, and so on.
    
    
     This could mean ending the program with undefined behavior, a critical section locked under a mutex, or any other
    
    
     
      unexpected issue.
     
    
   </p>
   <p>
    
     To avoid these problems, we need a data race-free mechanism to let the thread know about the intention to stop its execution (to request a stop) so that the thread can take all the specific steps needed to cancel its work and
    
    
     
      terminate gracefully.
     
    
   </p>
   <p>
    
     One of the possible ways of achieving this is by using an atomic variable that is periodically checked by the thread.
    
    
     We will explore atomic variables at length in the next chapter.
    
    
     For now, let’s define an atomic variable as a variable that many threads can write or read from without any locking mechanism or data race due to its atomic transaction operations and
    
    
     
      memory model.
     
    
   </p>
   <p>
    
     As an example, let us create a
    
    <strong class="source-inline">
     
      Counter
     
    </strong>
    
     class that calls a callback every second.
    
    
     This is done infinitely until the
    
    <strong class="source-inline">
     
      running
     
    </strong>
    
     atomic variable is set to
    
    <strong class="source-inline">
     
      false
     
    </strong>
    
     , when a caller uses the
    
    
     <strong class="source-inline">
      
       stop()
      
     </strong>
    
    
     
      function:
     
    
   </p>
   <pre class="source-code">
#include &lt;chrono&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
class Counter {
    using Callback = std::function&lt;void(void)&gt;;
   public:
    Counter(const Callback &amp;callback) {
        t = std::jthread([&amp;]() {
            while (running.load() == true) {
                callback ();
                std::this_thread::sleep_for(1s);
            }
        });
    }
    void stop() { running.store(false); }
   private:
    std::jthread t;
    std::atomic_bool running{true};
};</pre>
   <p>
    
     In the caller function, we will instantiate
    
    <strong class="source-inline">
     
      Counter
     
    </strong>
    
     as follows.
    
    
     Then, when
    
    <a id="_idIndexMarker205">
    </a>
    
     desired (here, that is after three seconds), we will call the
    
    <strong class="source-inline">
     
      stop()
     
    </strong>
    
     function, letting
    
    <strong class="source-inline">
     
      Counter
     
    </strong>
    
     exit the loop and terminate the
    
    
     
      thread execution:
     
    
   </p>
   <pre class="source-code">
int main() {
    Counter counter([&amp;]() {
        sync_cout &lt;&lt; "Callback: Running...\n";
    });
    std::this_thread::sleep_for(3s);
    counter.stop();
}</pre>
   <p>
    
     Since C++20, there has been a new mechanism
    
    <a id="_idIndexMarker206">
    </a>
    
     called
    
    <strong class="bold">
     
      cooperative interruption
     
    </strong>
    
     of a thread.
    
    
     This is available
    
    
     
      via
     
    
    
     <strong class="source-inline">
      
       std::stop_token
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The thread knows that a stop was requested by checking the result of calling the
    
    
     <strong class="source-inline">
      
       std::stop_token::stop_requested()
      
     </strong>
    
    
     
      function.
     
    
   </p>
   <p>
    
     To produce
    
    <strong class="source-inline">
     
      stop_token
     
    </strong>
    
     , we will use a
    
    <strong class="source-inline">
     
      stop_source
     
    </strong>
    
     object via the
    
    
     <strong class="source-inline">
      
       std::stop_source::get_token()
      
     </strong>
    
    
     
      function.
     
    
   </p>
   <p>
    
     This thread cancellation mechanism is implemented in
    
    <strong class="source-inline">
     
      std::jthead
     
    </strong>
    
     objects via an internal member of the
    
    <strong class="source-inline">
     
      std::stop_source
     
    </strong>
    
     type where the shared stop state is stored.
    
    
     The
    
    <strong class="source-inline">
     
      jthread
     
    </strong>
    
     constructor accepts
    
    <strong class="source-inline">
     
      std::stop_token
     
    </strong>
    
     as its first argument.
    
    
     This is used when a stop is requested
    
    
     
      during execution.
     
    
   </p>
   <p>
    
     Therefore,
    
    <strong class="source-inline">
     
      std::jthread
     
    </strong>
    
     exposes some additional functions to manage stop tokens compared with
    
    <strong class="source-inline">
     
      std::thread
     
    </strong>
    
     objects.
    
    
     These functions are
    
    <strong class="source-inline">
     
      get_stop_source()
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      get_stop_token()
     
    </strong>
    
     ,
    
    
     
      and
     
    
    
     <strong class="source-inline">
      
       request_stop()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     When
    
    <strong class="source-inline">
     
      request_stop()
     
    </strong>
    
     is called, it issues a stop request to the internal stop state, which is atomically updated to avoid race conditions (you will learn more about atomic variables in
    
    <a href="B22219_04.xhtml#_idTextAnchor074">
     
      <em class="italic">
       
        Chapter 4
       
      </em>
     
    </a>
    
     
      ).
     
    
   </p>
   <p>
    
     Let us check how all these functions work in the
    
    
     
      following example.
     
    
   </p>
   <p>
    
     First, we will define a template function to show the properties of a stop item object (
    
    <strong class="source-inline">
     
      stop_token
     
    </strong>
    
     
      or
     
    
    
     <strong class="source-inline">
      
       stop_source
      
     </strong>
    
    
     
      ):
     
    
   </p>
   <pre class="source-code">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;string_view&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
template &lt;typename T&gt;
void show_stop_props(std::string_view name,
                     const T&amp; stop_item) {
    sync_cout &lt;&lt; std::boolalpha
              &lt;&lt; name
              &lt;&lt; ": stop_possible = "
              &lt;&lt; stop_item.stop_possible()
              &lt;&lt; ", stop_requested = "
              &lt;&lt; stop_item.stop_requested()
              &lt;&lt; '\n';
};</pre>
   <p>
    
     Now, within the
    
    <strong class="source-inline">
     
      main()
     
    </strong>
    
     function, we will start a
    
    <a id="_idIndexMarker207">
    </a>
    
     worker thread, acquire its stop token object, and show
    
    
     
      its properties:
     
    
   </p>
   <pre class="source-code">
auto worker1 = std::jthread(func_with_stop_token);
std::stop_token stop_token = worker1.get_stop_token();
show_stop_props("stop_token", stop_token);</pre>
   <p>
    <strong class="source-inline">
     
      Worker1
     
    </strong>
    
     is running the
    
    <strong class="source-inline">
     
      func_with_stop_token()
     
    </strong>
    
     function that is defined in the ensuing code block.
    
    
     In this function, the stop token is checked by using the
    
    <strong class="source-inline">
     
      stop_requested()
     
    </strong>
    
     function.
    
    
     If this function returns
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     , a stop was requested, so the function simply returns, terminating the thread execution.
    
    
     Otherwise, it runs the next loop iteration, sleeping the current thread for further 300 ms until the next stop
    
    
     
      request check:
     
    
   </p>
   <pre class="source-code">
void func_with_stop_token(std::stop_token stop_token) {
    for (int i = 0; i &lt; 10; ++i) {
        std::this_thread::sleep_for(300ms);
        if (stop_token.stop_requested()) {
            sync_cout &lt;&lt; "stop_worker: "
                      &lt;&lt; "Stopping as requested\n";
            return;
        }
        sync_cout &lt;&lt; "stop_worker: Going back to sleep\n";
    }
}</pre>
   <p>
    
     We can request a stop from the main thread by using the stop token returned by the thread object
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
worker1.request_stop();
worker1.join();
show_stop_props("stop_token after request", stop_token);</pre>
   <p>
    
     Also, we can request a stop from a different thread.
    
    
     For this, we need to pass a
    
    <strong class="source-inline">
     
      stop_source
     
    </strong>
    
     object.
    
    
     In the following code snippet, we can see how a thread stopper is created with a
    
    <strong class="source-inline">
     
      stop_source
     
    </strong>
    
     object as an argument, acquired from the
    
    <strong class="source-inline">
     
      worker2
     
    </strong>
    
     
      worker thread:
     
    
   </p>
   <pre class="source-code">
auto worker2 = std::jthread(func_with_stop_token);
std::stop_source stop_source = worker2.get_stop_source();
show_stop_props("stop_source", stop_source);
auto stopper = std::thread( [](std::stop_source source) {
        std::this_thread::sleep_for(500ms);
        sync_cout &lt;&lt; "Request stop for worker2 "
                  &lt;&lt; "via source\n";
        source.request_stop();
    }, stop_source);
stopper.join();
std::this_thread::sleep_for(200ms);
show_stop_props("stop_source after request", stop_source);</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      stopper
     
    </strong>
    
     thread waits for 0.5 seconds and requests a stop from the
    
    <strong class="source-inline">
     
      stop_source
     
    </strong>
    
     object.
    
    
     Then
    
    <strong class="source-inline">
     
      worker2
     
    </strong>
    
     becomes aware of that request and terminates its
    
    <a id="_idIndexMarker208">
    </a>
    
     execution, as
    
    
     
      explained earlier.
     
    
   </p>
   <p>
    
     We can also register a callback function that will invoke a function when a stop is requested via a stop token or stop source.
    
    
     This can be done by using the
    
    <strong class="source-inline">
     
      std::stop_callback
     
    </strong>
    
     object, as shown in the ensuing
    
    
     
      code block:
     
    
   </p>
   <pre class="source-code">
std::stop_callback callback(worker1.get_stop_token(), []{
    sync_cout &lt;&lt; "stop_callback for worker1 "
              &lt;&lt; "executed by thread "
              &lt;&lt; std::this_thread::get_id() &lt;&lt; '\n';
});
sync_cout &lt;&lt; "main_thread: "
          &lt;&lt; std::this_thread::get_id() &lt;&lt; '\n';
std::stop_callback callback_after_stop(
    worker2.get_stop_token(),[] {
        sync_cout &lt;&lt; "stop_callback for worker2 "
                  &lt;&lt; "executed by thread "
                  &lt;&lt; std::this_thread::get_id() &lt;&lt; '\n';
});</pre>
   <p>
    
     If a
    
    <strong class="source-inline">
     
      std::stop_callback
     
    </strong>
    
     object is destroyed, its execution is prevented.
    
    
     For example, this scoped stop callback will not execute, as the callback object is destroyed when going out
    
    
     
      of scope:
     
    
   </p>
   <pre class="source-code">
{
    std::stop_callback scoped_callback(
        worker2.get_stop_token(), []{
          sync_cout &lt;&lt; "Scoped stop callback "
                    &lt;&lt; "will not execute\n";
      }
    );
}</pre>
   <p>
    
     After a stop has already been requested, a new stop
    
    <a id="_idIndexMarker209">
    </a>
    
     callback object will execute immediately.
    
    
     In the following example, if a stop has been requested for
    
    <strong class="source-inline">
     
      worker2
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      callback_after_stop
     
    </strong>
    
     will execute the lambda function just
    
    
     
      after construction:
     
    
   </p>
   <pre class="source-code">
sync_cout &lt;&lt; "main_thread: "
          &lt;&lt; std::this_thread::get_id() &lt;&lt; '\n';
std::stop_callback callback_after_stop(
    worker2.get_stop_token(), []{
        sync_cout &lt;&lt; "stop_callback for worker2 "
                  &lt;&lt; "executed by thread "
                  &lt;&lt; std::this_thread::get_id() &lt;&lt; '\n';
    }
);</pre>
   <h2 id="_idParaDest-70">
    <a id="_idTextAnchor069">
    </a>
    
     Catching exceptions
    
   </h2>
   <p>
    
     Any unhandled exception
    
    <a id="_idIndexMarker210">
    </a>
    
     thrown within a thread needs to be caught within that thread.
    
    
     Otherwise, the C++ runtime calls
    
    <strong class="source-inline">
     
      std::terminate
     
    </strong>
    
     , causing the program to terminate abruptly.
    
    
     This causes unexpected behavior, data loss, or even
    
    
     
      program crashes.
     
    
   </p>
   <p>
    
     One solution is to use try-catch blocks within the thread to catch exceptions.
    
    
     However, only exceptions thrown within that thread will be caught.
    
    
     Exceptions do not propagate to
    
    
     
      other threads.
     
    
   </p>
   <p>
    
     To propagate an exception to another thread, one thread can capture it and store it into a
    
    <strong class="source-inline">
     
      std::exception_ptr
     
    </strong>
    
     object, then use shared memory techniques to pass it to another thread, where the
    
    <strong class="source-inline">
     
      std::exception_ptr
     
    </strong>
    
     object will be checked and the exception re-thrown
    
    
     
      if needed.
     
    
   </p>
   <p>
    
     The following example shows
    
    
     
      this approach:
     
    
   </p>
   <pre class="source-code">
#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;exception&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
using namespace std::chrono_literals;
std::exception_ptr captured_exception;
std::mutex mtx;
void func() {
    try {
        std::this_thread::sleep_for(1s);
        throw std::runtime_error(
                  "Error in func used within thread");
    } catch (...) {
        std::lock_guard&lt;std::mutex&gt; lock(mtx);
        captured_exception = std::current_exception();
    }
}
int main() {
    std::thread t(func);
    while (!captured_exception) {
        std::this_thread::sleep_for(250ms);
        std::cout &lt;&lt; „In main thread\n";
    }
    try {
        std::rethrow_exception(captured_exception);
    } catch (const std::exception&amp; e) {
        std::cerr &lt;&lt; "Exception caught in main thread: "
                  &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    t.join();
}</pre>
   <p>
    
     Here, we can see how a
    
    <strong class="source-inline">
     
      std::runtime_error
     
    </strong>
    
     exception is thrown when
    
    <a id="_idIndexMarker211">
    </a>
    
     executing the
    
    <strong class="source-inline">
     
      func
     
    </strong>
    
     function by the
    
    <strong class="source-inline">
     
      t
     
    </strong>
    
     thread.
    
    
     The exception is caught and stored in
    
    <strong class="source-inline">
     
      captured_exception
     
    </strong>
    
     , a
    
    <strong class="source-inline">
     
      std::exception_ptr
     
    </strong>
    
     shared object protected by a mutex.
    
    
     The type and value of the thrown exception are determined by calling the
    
    
     <strong class="source-inline">
      
       std::current_exception()
      
     </strong>
    
    
     
      function.
     
    
   </p>
   <p>
    
     In the main thread, the
    
    <strong class="source-inline">
     
      while
     
    </strong>
    
     loop runs until an exception is
    
    <a id="_idIndexMarker212">
    </a>
    
     captured.
    
    
     The exception is re-thrown in the main thread by calling
    
    <strong class="source-inline">
     
      std::rethrow_exception(captured_exception)
     
    </strong>
    
     .
    
    
     It is caught again by the main thread where the
    
    <strong class="source-inline">
     
      catch
     
    </strong>
    
     block is executed, printing a message to the console via the
    
    <strong class="source-inline">
     
      std::cerr
     
    </strong>
    
     
      error stream.
     
    
   </p>
   <p>
    
     We will learn a better solution in
    
    <a href="B22219_06.xhtml#_idTextAnchor125">
     
      <em class="italic">
       
        Chapter 6
       
      </em>
     
    </a>
    
     by using futures
    
    
     
      and promises.
     
    
   </p>
   <h1 id="_idParaDest-71">
    <a id="_idTextAnchor070">
    </a>
    
     Thread-local storage
    
   </h1>
   <p>
    <strong class="bold">
     
      Thread-local Storage
     
    </strong>
    
     (
    
    <strong class="bold">
     
      TLS
     
    </strong>
    
     ) is a
    
    <a id="_idIndexMarker213">
    </a>
    
     memory management technique that allows each thread to have its own instance of a variable.
    
    
     This technique allows threads to store thread-specific data that is not accessible by other threads, avoiding race conditions and improving performance.
    
    
     This is because the overhead of synchronization mechanisms to access these variables
    
    
     
      is removed.
     
    
   </p>
   <p>
    
     TLS is implemented by the OS and accessible by using the
    
    <strong class="source-inline">
     
      thread_local
     
    </strong>
    
     keyword, which has been available since C++11.
    
    <strong class="source-inline">
     
      thread_local
     
    </strong>
    
     provides a uniform way to use the TLS capabilities of many OSs and avoid compiler-specific language extensions for accessing the TLS feature (some examples of such extensions are the TLS Windows API, the
    
    <strong class="source-inline">
     
      __declspec(thread)
     
    </strong>
    
     MSVC compiler language extension, or the
    
    <strong class="source-inline">
     
      __thread
     
    </strong>
    
     GCC compiler
    
    
     
      language extension).
     
    
   </p>
   <p>
    
     To use TLS with compilers that do not support C++11 or newer versions, use
    
    <strong class="source-inline">
     
      Boost.Library
     
    </strong>
    
     .
    
    
     This provides the
    
    <strong class="source-inline">
     
      boost::thread_specific_ptr
     
    </strong>
    
     container, which implements
    
    
     
      portable TLS.
     
    
   </p>
   <p>
    
     Thread-local variables can be declared
    
    
     
      as follows:
     
    
   </p>
   <ul>
    <li>
     
      
       Globally
      
     
    </li>
    <li>
     
      
       In namespaces
      
     
    </li>
    <li>
     
      As class static
     
     
      
       member variables
      
     
    </li>
    <li>
     
      Inside functions; it has the same effect as variables allocated with the
     
     <strong class="source-inline">
      
       static
      
     </strong>
     
      keyword, meaning that the variables are allocated for the lifetime of the program and their value are carried through the next
     
     
      
       function call
      
     
    </li>
   </ul>
   <p>
    
     The following examples show three threads calling the
    
    <strong class="source-inline">
     
      multiplyByTwo
     
    </strong>
    
     function with different arguments.
    
    
     This function sets the value of the
    
    <strong class="source-inline">
     
      val
     
    </strong>
    
     thread-local variable to the argument value, multiplies it by 2, and prints to
    
    
     
      the console:
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
thread_local int val = 0;
void setValue(int newval) { val = newval; }
void printValue() { sync_cout &lt;&lt; val &lt;&lt; ' '; }
void multiplyByTwo(int arg) {
    setValue(arg);
    val *= 2;
    printValue();
}
int main() {
    val = 1;  // Value in main thread
    std::thread t1(multiplyByTwo, 1);
    std::thread t2(multiplyByTwo, 2);
    std::thread t3(multiplyByTwo, 3);
    t1.join();
    t2.join();
    t3.join();
    std::cout &lt;&lt; val &lt;&lt; std::endl;
}</pre>
   <p>
    
     Running this code snippet will show the
    
    
     
      following output:
     
    
   </p>
   <pre class="console">
2 4 6 1</pre>
   <p>
    
     Here, we can see that each thread operated on its input
    
    <a id="_idIndexMarker214">
    </a>
    
     argument, resulting in
    
    <strong class="source-inline">
     
      t1
     
    </strong>
    
     printing
    
    <strong class="source-inline">
     
      2
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      t2
     
    </strong>
    
     printing
    
    <strong class="source-inline">
     
      4
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      t3
     
    </strong>
    
     printing
    
    <strong class="source-inline">
     
      6
     
    </strong>
    
     .
    
    
     The main thread running the main function can also access its thread local variable,
    
    <strong class="source-inline">
     
      val
     
    </strong>
    
     , which has a value that is set to
    
    <strong class="source-inline">
     
      1
     
    </strong>
    
     when the program starts but only used when printed out to console at the end of the main function before exiting
    
    
     
      the program.
     
    
   </p>
   <p>
    
     As with any technique, there are some drawbacks.
    
    
     TLS increases memory usage, as a variable is created per thread, so it could be problematic in resource-constrained environments.
    
    
     Also, accessing TLS variables might have some overhead compared with regular variables.
    
    
     This can be problematic in
    
    
     
      performance-critical software.
     
    
   </p>
   <p>
    
     Using many of the techniques we have learned so far, let’s build
    
    
     
      a timer.
     
    
   </p>
   <h1 id="_idParaDest-72">
    <a id="_idTextAnchor071">
    </a>
    
     Implementing a timer
    
   </h1>
   <p>
    
     Let us implement a timer that accepts
    
    <a id="_idIndexMarker215">
    </a>
    
     intervals and callback functions.
    
    
     The timer will execute the callback function at each interval.
    
    
     Also, the user will be able to stop the timer by calling its
    
    
     <strong class="source-inline">
      
       stop()
      
     </strong>
    
    
     
      function.
     
    
   </p>
   <p>
    
     The following snippet shows an implementation of
    
    
     
      the timer:
     
    
   </p>
   <pre class="source-code">
#include &lt;chrono&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#define sync_cout std::osyncstream(std::cout)
using namespace std::chrono_literals;
using namespace std::chrono;
template&lt;typename Duration&gt;
class Timer {
   public:
    typedef std::function&lt;void(void)&gt; Callback;
    Timer(const Duration interval,
          const Callback&amp; callback) {
        auto value = duration_cast&lt;milliseconds&gt;(interval);
        sync_cout &lt;&lt; "Timer: Starting with interval of "
                  &lt;&lt; value &lt;&lt; std::endl;
        t = std::jthread([&amp;](std::stop_token stop_token) {
            while (!stop_token.stop_requested()) {
                sync_cout &lt;&lt; "Timer: Running callback "
                          &lt;&lt; val.load() &lt;&lt; std::endl;
                val++;
                callback();
                sync_cout &lt;&lt; "Timer: Sleeping...\n";
                std::this_thread::sleep_for(interval);
            }
            sync_cout &lt;&lt; „Timer: Exit\n";
        });
    }
    void stop() {
        t.request_stop();
    }
   private:
    std::jthread t;
    std::atomic_int32_t val{0};
};</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Timer
     
    </strong>
    
     constructor accepts a
    
    <strong class="source-inline">
     
      Callback
     
    </strong>
    
     function (a
    
    <strong class="source-inline">
     
      std::function&lt;void(void)&gt;
     
    </strong>
    
     object) and a
    
    <strong class="source-inline">
     
      std::chrono::duration
     
    </strong>
    
     object
    
    <a id="_idIndexMarker216">
    </a>
    
     defining the period or interval when the callback will
    
    
     
      be executed.
     
    
   </p>
   <p>
    
     Then a
    
    <strong class="source-inline">
     
      std::jthread
     
    </strong>
    
     object is created with a lambda expression, whereby a loop calls the callback in intervals of time.
    
    
     This loop checks whether a stop has been requested via
    
    <strong class="source-inline">
     
      stop_token
     
    </strong>
    
     , which is enabled by using the
    
    <strong class="source-inline">
     
      stop()
     
    </strong>
    <strong class="source-inline">
     
      Timer
     
    </strong>
    
     API function.
    
    
     When this is the case, the loop exits and the
    
    
     
      thread terminates.
     
    
   </p>
   <p>
    
     Here is how to
    
    
     
      use it:
     
    
   </p>
   <pre class="source-code">
int main(void) {
    sync_cout &lt;&lt; "Main: Create timer\n";
    Timer timer(1s, [&amp;]() {
        sync_cout &lt;&lt; "Callback: Running...\n";
    });
    std::this_thread::sleep_for(3s);
    sync_cout &lt;&lt; "Main thread: Stop timer\n";
    timer.stop();
    std::this_thread::sleep_for(500ms);
    sync_cout &lt;&lt; "Main thread: Exit\n";
    return 0;
}</pre>
   <p>
    
     In this example, we started the timer that
    
    <a id="_idIndexMarker217">
    </a>
    
     will print the
    
    <strong class="source-inline">
     
      Callback: Running
     
    </strong>
    
     message every second.
    
    
     After three seconds, the main thread will call the
    
    <strong class="source-inline">
     
      timer.stop()
     
    </strong>
    
     function, terminating the timer thread.
    
    
     The main thread then waits for 500 milliseconds
    
    
     
      before exiting.
     
    
   </p>
   <p>
    
     This is
    
    
     
      the output:
     
    
   </p>
   <pre class="console">
Main: Create timer
Timer: Starting with interval of 1000ms
Timer: Running callback 0
Callback: Running...
Timer: Sleeping...
Timer: Running callback 1
Callback: Running...
Timer: Sleeping...
Timer: Running callback 2
Callback: Running...
Timer: Sleeping...
Main thread: Stop timer
Timer: Exit
Main thread: Exit</pre>
   <p>
    
     As an exercise, you can slightly modify this example to implement a timeout class that calls a callback function if there is no input event within a given timeout interval.
    
    
     This is a common pattern when dealing with network communications where a packet replay request is sent if no packets have been received for
    
    
     
      some time.
     
    
   </p>
   <h1 id="_idParaDest-73">
    <a id="_idTextAnchor072">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we learned how to create and manage threads, how to pass arguments or retrieve results, how TLS works, and how to wait for a thread to finish.
    
    
     We also learned how to make a thread yield control to others or cancel its execution.
    
    
     If something goes wrong and an exception is thrown, we now know how to pass the exception between threads and avoid an unexpected program termination.
    
    
     Finally, we implemented a
    
    <strong class="source-inline">
     
      timer
     
    </strong>
    
     class that periodically runs a
    
    
     
      callback function.
     
    
   </p>
   <p>
    
     In the next chapter, we will learn about thread safety, mutual exclusion, and atomic operations.
    
    
     That will include mutexes, locking and lock-free algorithms, and memory synchronization ordering, among other topics.
    
    
     That knowledge will help us develop thread-safe data structures
    
    
     
      and algorithms.
     
    
   </p>
   <h1 id="_idParaDest-74">
    <a id="_idTextAnchor073">
    </a>
    
     Further reading
    
   </h1>
   <ul>
    <li>
     
      Compiler
     
     
      
       support:
      
     
     <a href="https://en.cppreference.com/w/cpp/compiler_support">
      
       
        https://en.cppreference.com/w/cpp/compiler_support
       
      
     </a>
    </li>
    <li>
     
      GCC
     
     
      
       releases:
      
     
     <a href="https://gcc.gnu.org/releases.html">
      
       
        https://gcc.gnu.org/releases.html
       
      
     </a>
    </li>
    <li>
     
      
       Clang:
      
     
     <a href="https://clang.llvm.org">
      
       
        https://clang.llvm.org
       
      
     </a>
    </li>
    <li>
     
      Clang 8
     
     
      
       documentation:
      
     
     <a href="https://releases.llvm.org/8.0.0/tools/clang/docs/index.html">
      
       
        https://releases.llvm.org/8.0.0/tools/clang/docs/index.html
       
      
     </a>
    </li>
    <li>
     
      LLVM
     
     
      
       project:
      
     
     <a href="https://llvm.org">
      
       
        https://llvm.org
       
      
     </a>
    </li>
    <li>
     
      
       Boost.Threads:
      
     
     <a href="https://www.boost.org/doc/libs/1_78_0/doc/html/thread.html">
      
       
        https://www.boost.org/doc/libs/1_78_0/doc/html/thread.html
       
      
     </a>
    </li>
    <li>
     
      P0024 – Technical Specification for
     
     
      
       Parallelism:
      
     
     <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0024r0.html">
      
       
        https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0024r0.html
       
      
     </a>
    </li>
    <li>
     
      TLS
     
     
      
       proposal:
      
     
     <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2659.htm">
      
       
        https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2659.htm
       
      
     </a>
    </li>
    <li>
     <em class="italic">
      
       Thread Launching for
      
     </em>
     
      <em class="italic">
       
        C++0X
       
      </em>
     
     
      
       :
      
     
     <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2184.html">
      
       
        https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2184.html
       
      
     </a>
    </li>
    <li>
     
      TLS from
     
     
      
       IBM:
      
     
     <a href="https://docs.oracle.com/cd/E19683-01/817-3677/chapter8-1/index.html">
      
       
        https://docs.oracle.com/cd/E19683-01/817-3677/chapter8-1/index.html
       
      
     </a>
    </li>
    <li>
     <em class="italic">
      
       Data that is private to a
      
     </em>
     
      <em class="italic">
       
        thread
       
      </em>
     
     
      
       :
      
     
     <a href="https://www.ibm.com/docs/en/i/7.5?topic=techniques-data-that-is-private-thread">
      
       
        https://www.ibm.com/docs/en/i/7.5?topic=techniques-data-that-is-private-thread
       
      
     </a>
    </li>
    <li>
     <strong class="bold">
      
       Resource Acquisition Is Initialization
      
     </strong>
     
      (
     
     <strong class="bold">
      
       RAII
      
     </strong>
     
      ):
     
     <a href="https://en.cppreference.com/w/cpp/language/raii">
      
       
        https://en.cppreference.com/w/cpp/language/raii
       
      
     </a>
    </li>
    <li>
     
      Bjarne Stroustrup,
     
     <em class="italic">
      
       A Tour of C++
      
     </em>
     
      , Third Edition, 18.2
     
     
      
       and 18.7.
      
     
    </li>
   </ul>
  </div>
 </body></html>