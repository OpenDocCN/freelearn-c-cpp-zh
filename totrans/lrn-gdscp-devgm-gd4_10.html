<html><head></head><body>
		<div id="_idContainer239">
			<h1 class="chapter-number" id="_idParaDest-240"><a id="_idTextAnchor632"/>10</h1>
			<h1 id="_idParaDest-241"><a id="_idTextAnchor633"/>Creating Menus, Making Enemies, and Using Autoloads</h1>
			<p>Although it was a lot of fun setting up all the current systems, the game is still kind of boring. There is no real adversary, nothing to stop the player from just picking up all the gold coins they desire. Let’s bring some challenge into the mix by creating enemies that attack the player and try to stop their road to glory <span class="No-Break">and fame!</span></p>
			<p>Next to that, we’ll also create a little menu to start our game from. We’ll do this with Godot’s <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) system, which makes use of <strong class="bold">Control</strong> nodes. In this chapter, we will discuss the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Creating <span class="No-Break">a menu</span></li>
				<li><span class="No-Break">Making enemies</span></li>
				<li><span class="No-Break">Shooting projectiles</span></li>
				<li>Scoring highscores <span class="No-Break">in autoloads</span></li>
			</ul>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor634"/>Technical requirements</h1>
			<p>As for every chapter, you can find the final code on the GitHub repository in the subfolder for this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter10"><span class="No-Break">https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter10</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor635"/>Creating a menu</h1>
			<p>The most exciting <a id="_idIndexMarker552"/>part of developing a game is, of course, making the game itself! Making things move, fight, jump, shoot, interact, and so forth. But there is another part that is just as important: the UI. A UI binds everything together. It informs the player of what is happening and lets them navigate from menu to menu with ease and without having to think about how to get from one interface to <span class="No-Break">the other.</span></p>
			<p>Good user experience, UI, or human-computer interaction design is hard! But it all starts with learning how to make the UI in the first place. So, let’s have a look at how we can create menus <span class="No-Break">and</span><span class="No-Break"><a id="_idIndexMarker553"/></span><span class="No-Break"> interfaces.</span></p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor636"/>Control nodes</h2>
			<p>The Godot <a id="_idIndexMarker554"/>engine comes with an extensive library of interface nodes. We already made use of one, the <strong class="bold">Label</strong> node, in <a href="B19358_06.xhtml#_idTextAnchor411"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>. These nodes are called <strong class="bold">Control nodes</strong> and get labeled by the <span class="No-Break">color green:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer185">
					<img alt="Figure 10.1 – Some Control nodes can be recognized by their green color" src="image/B19358_10_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Some Control nodes can be recognized by their green color</p>
			<p>If you go and open the <strong class="bold">Create New Node</strong> menu, you’ll see there are a lot of these <strong class="bold">Control</strong> nodes. We could categorize these into three different groups. Let’s go over some of the nodes and what they can do for us in <span class="No-Break">each group.</span></p>
			<h3>Nodes showing information</h3>
			<p>The first group <a id="_idIndexMarker555"/>of nodes shows information. In this group, you would find the <strong class="bold">Label</strong> node we used in <a href="B19358_06.xhtml#_idTextAnchor411"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, but also the <strong class="bold">ColorRect</strong> and <span class="No-Break"><strong class="bold">TextureRect</strong></span><span class="No-Break"> nodes:</span></p>
			<ul>
				<li><strong class="bold">Label</strong>: Shows a short string <span class="No-Break">of text.</span></li>
				<li><strong class="bold">RichTextLabel</strong>: Shows a longer piece of text that can be formatted in <span class="No-Break">specific ways.</span></li>
				<li><strong class="bold">ColorRect</strong>: Shows a solid rectangle in <span class="No-Break">one color.</span></li>
				<li><strong class="bold">TextureRect</strong>: Shows a texture in a rectangle. This node is similar to the <strong class="bold">Sprite2D</strong> node in that they are both used to show a texture but in <span class="No-Break">different contexts.</span></li>
			</ul>
			<p>In the following figure, you can see what these nodes look like in <span class="No-Break">the editor:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer186">
					<img alt="Figure 10.2 – Examples of Control nodes that show information" src="image/B19358_10_2.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Examples of Control nodes that show information</p>
			<p>These nodes<a id="_idIndexMarker556"/> all show something to <span class="No-Break">the user.</span></p>
			<h3>Nodes taking input</h3>
			<p>Any good UI <a id="_idIndexMarker557"/>can also take input, with – for example – buttons. Here are some of the input nodes that the Godot engine UI <span class="No-Break">nodes provide:</span></p>
			<ul>
				<li><strong class="bold">Button</strong>: A simple button that can <span class="No-Break">be clicked.</span></li>
				<li><strong class="bold">CheckBox</strong>: A checkbox that can be turned on <span class="No-Break">and off.</span></li>
				<li><strong class="bold">CheckButton</strong>: The same as a checkbox, but just with a <span class="No-Break">different aesthetic.</span></li>
				<li><strong class="bold">LineEdit</strong>: A simple node that can take a single line of text input and provide it as <span class="No-Break">a string.</span></li>
				<li><strong class="bold">HSlider</strong> and <strong class="bold">VSlider</strong>: Sliders that are used to input a number. <strong class="bold">HSlider</strong> slides horizontally while <strong class="bold">VSlider</strong> <span class="No-Break">slides vertically.</span></li>
			</ul>
			<p>In the following figure, you can see what these nodes look like in <span class="No-Break">the editor:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer187">
					<img alt="Figure 10.3 – Examples of Control nodes that take input" src="image/B19358_10_3.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Examples of Control nodes that take input</p>
			<p>These nodes <a id="_idIndexMarker558"/>all take input in one way <span class="No-Break">or another.</span></p>
			<h3>Nodes containing other nodes</h3>
			<p>Lastly, there<a id="_idIndexMarker559"/> are the nodes that you don’t see but that are very important because they make sure all the other UI elements are placed correctly. These nodes form the skeleton in which the other <strong class="bold">Control</strong> nodes can find <span class="No-Break">their place.</span></p>
			<p><strong class="bold">Container</strong> nodes <a id="_idIndexMarker560"/>help us to lay out the UI as we want. This type of node can display elements nicely next to each other, add some spacing between nodes, and <span class="No-Break">so forth.</span></p>
			<p>These containers can also help keep the interface usable and beautiful when we resize the screen. This does not happen often, but games can be played on so many different screen sizes and aspect ratios these days. Just think about the difference between a computer screen and a <span class="No-Break">phone screen.</span></p>
			<p>Some interesting container nodes are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">VBoxContainer</strong> and <strong class="bold">HBoxContainer</strong>: Organize all their child nodes nicely, vertically <span class="No-Break">or horizontally</span></li>
				<li><strong class="bold">CenterContainer</strong>: Centers its <span class="No-Break">child nodes</span></li>
				<li><strong class="bold">GridContainer</strong>: Organizes all its child nodes in a <span class="No-Break">tidy grid</span></li>
				<li><strong class="bold">MarginContainer</strong>: Adds spacing around its child nodes so that they have some room <span class="No-Break">to breathe</span></li>
				<li><strong class="bold">Panel</strong>: Provides a background that shows this part of the UI logically <span class="No-Break">belongs together</span></li>
			</ul>
			<p>In the following figure, you can see what these nodes look like in <span class="No-Break">the editor:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer188">
					<img alt="Figure 10.4 – Examples of Control nodes that can contain other nodes" src="image/B19358_10_4.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Examples of Control nodes that can contain other nodes</p>
			<p><strong class="bold">Container</strong> nodes all contain and place their child nodes in a <span class="No-Break">specific way.</span></p>
			<p>The lists of nodes in this section are not exhaustive; a quick glance in the <strong class="bold">Control</strong> node category while adding a node makes this pretty obvious. But these are the most important nodes that you will likely use first. The others are <span class="No-Break">more specialized.</span></p>
			<p>The cool thing is that the complete Godot editor itself is constructed out of these Control nodes, just to show how flexible and powerful they are for building <span class="No-Break">out UIs.</span></p>
			<p>Now that we<a id="_idIndexMarker561"/> have a basic knowledge of the different <strong class="bold">Control</strong> nodes, we can start making a menu <span class="No-Break">with them.</span></p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor637"/>Creating a basic start menu</h2>
			<p>Let’s create a <a id="_idIndexMarker562"/>start menu that displays when we start up the game. This menu should simply display the game’s name, a button to start playing, a button to exit the game, and lastly, we could add some information on who created <span class="No-Break">the game:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer189">
					<img alt="Figure 10.5 – This is what our start menu will look like" src="image/B19358_10_5.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – This is what our start menu will look like</p>
			<p>Let’s go over the steps to create a start menu, as shown in <span class="No-Break"><em class="italic">Figure 10</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">:</span></p>
			<ol>
				<li>Create<a id="_idIndexMarker563"/> a new scene called <strong class="source-inline">menu.tscn</strong> under a new <span class="No-Break"><strong class="source-inline">screens/ui</strong></span><span class="No-Break"> folder.</span></li>
				<li>Select <strong class="bold">User Interface</strong> as the root <span class="No-Break">node’s type:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer190">
					<img alt="Figure 10.6 – Choosing User Interface as the root node for our menu" src="image/B19358_10_6.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Choosing User Interface as the root node for our menu</p>
			<ol>
				<li value="3">Rename the root <span class="No-Break">node </span><span class="No-Break"><strong class="source-inline">Menu</strong></span><span class="No-Break">.</span></li>
				<li>Let’s start by adding a <strong class="bold">ColorRect</strong> node to the menu; this will be our <span class="No-Break">background color.</span></li>
				<li>Now, to stretch the <strong class="bold">ColorRect</strong> node to cover the whole screen, <strong class="bold">Control</strong> nodes have a handy dandy little menu in the top bar. Select the <strong class="bold">ColorRect</strong> node in the scene tree and select <strong class="bold">Full Rect</strong> from the <strong class="bold">Anchor </strong><span class="No-Break"><strong class="bold">preset</strong></span><span class="No-Break"> list:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer191">
					<img alt="Figure 10.7 – Choosing Full Rect to make the ColorRect node cover the full screen" src="image/B19358_10_7.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Choosing Full Rect to make the ColorRect node cover the full screen</p>
			<ol>
				<li value="6">Now, add<a id="_idIndexMarker564"/> a <strong class="bold">CenterContainer</strong> node to the root node, give it a <strong class="bold">VBoxContainer</strong> node as a child, and call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">MainUIContainer</strong></span><span class="No-Break">.</span></li>
				<li>Now, add a <strong class="bold">Label</strong> node as the first child under the <strong class="bold">MainUIContainer</strong> node. Rename this <strong class="source-inline">TitleLabel</strong>. This label will show the title of <span class="No-Break">our game:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer192">
					<img alt="Figure 10.8 – The scene tree of our menu until now" src="image/B19358_10_8.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – The scene tree of our menu until now</p>
			<ol>
				<li value="8">Think of a good title for the game and put it in the text field of the <span class="No-Break"><strong class="bold">TitleLabel</strong></span><span class="No-Break"> node.</span></li>
				<li>Now, go to <strong class="bold">Theme Overrides</strong> and set the <strong class="bold">Font Size</strong> option to something more appropriate for the game’s title, such as <span class="No-Break"><strong class="source-inline">60</strong></span><span class="No-Break"> px:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer193">
					<img alt="Figure 10.9 – You can change the font size of a label in Theme Overrides" src="image/B19358_10_9.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – You can change the font size of a label in Theme Overrides</p>
			<p>This was just to create a title label for our game UI. It might seem like a lot of steps, but some of the nodes we used will make it easy to extend the UI in the next <span class="No-Break">few steps.</span></p>
			<p>Let’s add a panel<a id="_idIndexMarker565"/> with buttons and a <span class="No-Break">credit line:</span></p>
			<ol>
				<li>Add a <strong class="bold">PanelContainer</strong> node to the <span class="No-Break"><strong class="bold">MainUIContainer</strong></span><span class="No-Break"> node.</span></li>
				<li>Now, create the following structure in this <span class="No-Break">panel container:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer194">
					<img alt="Figure 10.10 – The scene tree structure from the PanelContainer node" src="image/B19358_10_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – The scene tree structure from the PanelContainer node</p>
			<ol>
				<li value="3">Rename the first button <strong class="bold">PlayButton</strong> and change its text <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">PLAY</strong></span><span class="No-Break">.</span></li>
				<li>Rename the second button <strong class="bold">ExitButton</strong> and change its text <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">EXIT</strong></span><span class="No-Break">.</span></li>
				<li>Rename the label <strong class="bold">CreditLabel</strong> and change its text to whatever you would like it <span class="No-Break">to say!</span></li>
				<li>Now, go into the first <strong class="bold">VBocContainer</strong> node and change the <strong class="bold">Separation</strong> constant to <span class="No-Break"><strong class="source-inline">50</strong></span><span class="No-Break"> px.</span></li>
				<li>Change the <strong class="bold">Separation</strong> constant of the second <strong class="bold">VBoxContainer</strong> node to <span class="No-Break"><strong class="source-inline">20</strong></span><span class="No-Break"> px.</span></li>
				<li>Lastly, set the <strong class="bold">Separation</strong> constant of the <strong class="bold">MainUIContainer</strong> node to <span class="No-Break"><strong class="source-inline">200</strong></span><span class="No-Break"> px.</span></li>
			</ol>
			<p>Great work – the UI layout is finished. The complete scene tree should look <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer195">
					<img alt="Figure 10.11 – The complete scene tree of our menu" src="image/B19358_10_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – The complete scene tree of our menu</p>
			<p>The only thing <a id="_idIndexMarker566"/>left to do is to make the buttons functional! Let us do that <span class="No-Break">real quick:</span></p>
			<ol>
				<li>Add an empty script to the root <strong class="bold">Menu</strong> node <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">menu.gd</strong></span><span class="No-Break">.</span></li>
				<li>Now, connect the pressed signal of the <strong class="bold">PlayButton</strong> node to <span class="No-Break">this node.</span><p class="list-inset">The body of the connected function is <span class="No-Break">quite simple:</span></p><pre class="source-code">
func _on_play_button_pressed():
   get_tree().change_scene_to_file("res://screens/game/main.tscn")</pre></li>				<li>Also, connect the pressed signal of the <span class="No-Break"><strong class="bold">ExitButton</strong></span><span class="No-Break"> node.</span><p class="list-inset">The body of this function is <span class="No-Break">even simpler:</span></p><pre class="source-code">
func _on_exit_button_pressed():
   get_tree().quit()</pre></li>			</ol>
			<p>In the preceding code snippets, we reached out to the root of the scene tree with <strong class="source-inline">get_tree()</strong>. This function returns <strong class="source-inline">SceneTree</strong>, the object that manages the whole hierarchy of nodes while the game <span class="No-Break">is running.</span></p>
			<p>In the function that is connected to the <strong class="bold">Play</strong> button, we call the <strong class="source-inline">change_scene_to_file()</strong> function on this object, which switches out the current running scene to the one that is specified by the path we provide to the function. So, to start the main game scene, we just give it the path, starting from the root of the project, to the <span class="No-Break"><strong class="source-inline">main.tscn</strong></span><span class="No-Break"> scene.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">It’s good to note that from the moment it is called, <strong class="source-inline">change_scene_to file()</strong> will also load the scene file it is supposed to switch to. This means that the game will block or freeze for this loading duration. This is not great when we are switching to a big scene, which we luckily are not doing in <span class="No-Break">our case.</span></p>
			<p>In the function<a id="_idIndexMarker567"/> that is connected to the <strong class="bold">Exit</strong> button, we call the <strong class="source-inline">quit()</strong> function, which simply shits down <span class="No-Break">the runtime.</span></p>
			<p>You can now try out the menu by <span class="No-Break">running it!</span></p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor638"/>Setting the main scene</h2>
			<p>To make sure our <a id="_idIndexMarker568"/>menu is the main scene that boots up the game, we’ll quickly need to step into the project settings to declare this. In the project settings, under <strong class="bold">Application </strong>| <strong class="bold">Run</strong>, specify that <strong class="source-inline">menu.tscn</strong> is the <span class="No-Break">main scene:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer196">
					<img alt="Figure 10.12 – Setting the main scene in the project settings" src="image/B19358_10_12.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – Setting the main scene in the project settings</p>
			<p>This will make sure that when we run the game, using the <strong class="bold">Play</strong> button at the top or using the <em class="italic">F5</em> shortcut, the <strong class="source-inline">menu.tscn</strong> scene is the scene that gets launched <span class="No-Break">by default.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Remember that when there is no main scene set and we run the game through the aforementioned methods, Godot will ask us if we want to use the currently opened scene as the <span class="No-Break">main scene.</span></p>
			<p>We learned a<a id="_idIndexMarker569"/> lot about <strong class="bold">Control</strong> nodes and how to use them to quickly construct UIs. Let’s go and make <span class="No-Break">some enemies.</span></p>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor639"/>Making enemies</h1>
			<p>In real life, making<a id="_idIndexMarker570"/> enemies is never a good idea. But in the context of video game development, it is often a great way to challenge the player and put them against <span class="No-Break">some opposition.</span></p>
			<p>The enemy that we will be creating is fairly simple and straightforward. But we will still learn a lot along the way – for example, how to let enemies navigate toward the player to <span class="No-Break">attack them.</span></p>
			<p>Like I said, we’ll keep the enemy simple. We’ll be making an enemy that spawns at a random time in a random spot of the arena and starts charging toward the player. From the moment the enemy touches the player, we’ll deduct one health point from the player’s life and remove the enemy from the game. This way, the player has some adversaries but should not get overwhelmed by a horde <span class="No-Break">of enemies.</span></p>
			<p>In the following <a id="_idIndexMarker571"/>section, <em class="italic">Shooting projectiles</em>, we’ll develop a way for the player to defend themselves. But for now, we’ll solely focus on the enemy and <span class="No-Break">its behavior.</span></p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor640"/>Constructing the base scene</h2>
			<p>As with any new <a id="_idIndexMarker572"/>part of our game, let’s start by creating the base structure in a scene tree for the enemy and add code and other interesting things later in <span class="No-Break">the section:</span></p>
			<ol>
				<li>Create a <strong class="source-inline">parts/enemy</strong> folder, and within it, create a new scene <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">enemy.tscn</strong></span><span class="No-Break">.</span></li>
				<li>Recreate the following scene tree. Note that the root is a <span class="No-Break"><strong class="bold">CharacterBody</strong></span><span class="No-Break"> node:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer197">
					<img alt="Figure 10.13 – The scene tree of our Enemy scene" src="image/B19358_10_13.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.13 – The scene tree of our Enemy scene</p>
			<ol>
				<li value="3">Choose a sprite from the <strong class="source-inline">assets/sprites/enemies</strong> folder as the texture for the <span class="No-Break"><strong class="bold">Sprite2D</strong></span><span class="No-Break"> node:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer198">
					<img alt="Figure 10.14 – The Enemy scene in the 2D editor" src="image/B19358_10_14.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.14 – The Enemy scene in the 2D editor</p>
			<ol>
				<li value="4">Make sure you set the scale of the sprite node to <strong class="source-inline">(</strong><span class="No-Break"><strong class="source-inline">3, 3)</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>For the <a id="_idIndexMarker573"/>moment, the <strong class="source-inline">Enemy</strong> scene is very simple. Let’s look into how we could do navigation to complexify it a <span class="No-Break">little bit.</span></p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor641"/>Navigating enemies</h2>
			<p>We can easily <a id="_idIndexMarker574"/>make enemies move directly toward the player. The problem with this is that they will get stuck behind walls and bump into boulders, which doesn’t feel very natural and makes them look <span class="No-Break">quite dumb.</span></p>
			<p>Luckily, the Godot engine comes with a <strong class="bold">NavigationServer</strong> property that calculates a path around all these obstacles and makes enemy movement more natural <span class="No-Break">and fluent.</span></p>
			<p>To accomplish this, we will look at<a id="_idIndexMarker575"/> two new nodes: <strong class="source-inline">NavigationRegion2D</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">NavigationAgent2D</strong></span><span class="No-Break">.</span></p>
			<h3>Creating a NavigationRegion2D node</h3>
			<p>Firstly, we need to <a id="_idIndexMarker576"/>define in what region of the<a id="_idIndexMarker577"/> level our enemy can move around, then we want to cut out spots where a wall or boulder is situated from this region. This is exactly what the <strong class="source-inline">NavigationRegion2D</strong> node does! Let’s <span class="No-Break">define one:</span></p>
			<ol>
				<li>Go to the <strong class="source-inline">main.tscn</strong> <span class="No-Break">game scene.</span></li>
				<li>In the root node called <strong class="source-inline">Main</strong>, add a <span class="No-Break"><strong class="source-inline">NavigationRegion2D</strong></span><span class="No-Break"> node.</span></li>
				<li>Click on the empty <strong class="bold">Navigation Polygon</strong> property and select <span class="No-Break"><strong class="bold">New NavigationPolygon</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer199">
					<img alt="Figure 10.15 – Clicking on New NavigationPolygon" src="image/B19358_10_15.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.15 – Clicking on New NavigationPolygon</p>
			<ol>
				<li value="4">Now, we’ll first define the outer bounds of where enemies will be able to move. Draw a polygon shape by clicking in the editor. Try to trace the outside of the arena closely. Don’t forget to close the shape by clicking the first point <span class="No-Break">you placed:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer200">
					<img alt="Figure 10.16 – Creating the outer bounds of the NavigationRegion2D node" src="image/B19358_10_16.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.16 – Creating the outer bounds of the NavigationRegion2D node</p>
			<ol>
				<li value="5">Press <strong class="bold">Bake NavigationPolygon</strong> at the <a id="_idIndexMarker578"/>top of the window to create a <span class="No-Break">navigation</span><span class="No-Break"><a id="_idIndexMarker579"/></span><span class="No-Break"> polygon:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer201">
					<img alt="Figure 10.17 – Pressing Bake NavigationPolygon" src="image/B19358_10_17.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.17 – Pressing Bake NavigationPolygon</p>
			<p>After following these steps, the <strong class="source-inline">NavigationRegion2D</strong> node should look <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer202">
					<img alt="Figure 10.18 – The NavigationRegion2D node after baking the polygon for the first time" src="image/B19358_10_18.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.18 – The NavigationRegion2D node after baking the polygon for the first time</p>
			<p>The blue/greenish area is where enemies will be able to navigate and move in. But you can already see a <a id="_idIndexMarker580"/>problem – this region also spans<a id="_idIndexMarker581"/> over our walls and boulders. We don’t want enemies to think that they can walk through them because, well, they can’t; they are static physics bodies. Luckily, Godot has the functionality to automatically detect these and bake the <strong class="source-inline">NavigationPolygon</strong> property in such a way that it takes them <span class="No-Break">into account.</span></p>
			<p>Unfold the <strong class="bold">Navigation Polygon</strong> property of the <strong class="source-inline">NavigationRegion2D</strong> node by clicking on it and configure it <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Set <strong class="bold">Geometry</strong> | <strong class="bold">Parsed Geometry Type</strong> to <strong class="bold">Static Colliders</strong>. We do this to only consider static colliders in the <span class="No-Break">automatic generation.</span></li>
				<li>Set <strong class="bold">Geometry</strong> | <strong class="bold">Source Geometry Mode</strong> to <strong class="bold">Group With Children</strong>. This way, the automatic generation will scan through the children of nodes to find the <span class="No-Break">static colliders.</span></li>
				<li>Set <strong class="bold">Agents</strong> | <strong class="bold">Radius</strong> to <strong class="source-inline">40</strong> px. With this, we define the radius of the agents we want to use in the <strong class="source-inline">NavigationRegion2D</strong> node, and the automatic generation can take this into account so that agents don’t bump into obstacles they should be able <span class="No-Break">to avoid:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer203">
					<img alt="Figure 10.19 – Configuring the NavigationPolygon property" src="image/B19358_10_19.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.19 – Configuring the NavigationPolygon property</p>
			<ol>
				<li value="4">Select <a id="_idIndexMarker582"/>the <strong class="source-inline">Arena</strong> node<a id="_idIndexMarker583"/> and switch to the <strong class="bold">Node</strong> tab, next to the <span class="No-Break"><strong class="bold">Inspector</strong></span><span class="No-Break"> tab:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer204">
					<img alt="Figure 10.20 – Going to the Node tab" src="image/B19358_10_20.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.20 – Going to the Node tab</p>
			<ol>
				<li value="5">Switch to<a id="_idIndexMarker584"/> the <strong class="bold">Groups</strong> tab, which is<a id="_idIndexMarker585"/> next to the <span class="No-Break"><strong class="bold">Signals</strong></span><span class="No-Break"> tab:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer205">
					<img alt="Figure 10.21 – Switching to the Groups tab" src="image/B19358_10_21.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.21 – Switching to the Groups tab</p>
			<ol>
				<li value="6">Paste <strong class="source-inline">navigation_polygon_source_geometry_group</strong> into the text field and <span class="No-Break">press </span><span class="No-Break"><strong class="bold">Add</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer206">
					<img alt="Figure 10.22 – Adding the navigation_polygon_source_geometry_group group" src="image/B19358_10_22.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.22 – Adding the navigation_polygon_source_geometry_group group</p>
			<ol>
				<li value="7">Now, select the <strong class="source-inline">NavigationRegion2D</strong> node again and press <strong class="bold">Bake </strong><span class="No-Break"><strong class="bold">NavigationPolygon</strong></span><span class="No-Break"> again.</span></li>
			</ol>
			<p>When you are<a id="_idIndexMarker586"/> done, the navigation region should <a id="_idIndexMarker587"/>look <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer207">
					<img alt="Figure 10.23 – The resulting NavigationRegion2D node" src="image/B19358_10_23.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.23 – The resulting NavigationRegion2D node</p>
			<p>The blue/greenish region now nicely avoids walls and boulders. You can also see that there is some margin between obstacles and where the region begins. This is what we set up when defining the <strong class="bold">Radius</strong> property of the agents. This margin makes sure the pathfinding doesn’t come too close to obstacles, making enemies avoid colliding <span class="No-Break">with them.</span></p>
			<p>In <em class="italic">steps 2</em> to <em class="italic">4</em>, we added the <strong class="source-inline">Arena</strong> node to<a id="_idIndexMarker588"/> a <strong class="bold">node group</strong>. We did this because, when baking the <strong class="bold">NavigationPolygon</strong> property, it will look for all nodes in the <strong class="source-inline">navigation_polygon_source_geometry_group</strong> node group and consider the static bodies <a id="_idIndexMarker589"/>within<a id="_idIndexMarker590"/> them. Let’s take a small detour to talk about <span class="No-Break">node groups.</span></p>
			<h3>What are node groups?</h3>
			<p><strong class="bold">Groups</strong> or <strong class="bold">node groups</strong> in the <a id="_idIndexMarker591"/>Godot engine are like tags in other pieces of <a id="_idIndexMarker592"/>software. You can add any number of groups to a node. We can simply do this through the <strong class="bold">Groups</strong> tab, just like we did in the steps of the <span class="No-Break">last section.</span></p>
			<p>Groups are extremely useful because you can, for example, do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Check if a node is part of <span class="No-Break">a group.</span></li>
				<li>Get all nodes within a group from <span class="No-Break">the tree.</span></li>
				<li>Call methods on all nodes within <span class="No-Break">a group.</span></li>
			</ul>
			<p>We’ll use groups some more <span class="No-Break">later on.</span></p>
			<p>The <strong class="source-inline">NavigationRegion2D</strong> node is ready, so now, let’s take a look at the process of adding a <strong class="source-inline">NavigationAgent2D</strong> node to the <span class="No-Break"><strong class="source-inline">Enemy</strong></span><span class="No-Break"> scene.</span></p>
			<h3>Adding a NavigationAgent2D node to the Enemy scene</h3>
			<p>The last <a id="_idIndexMarker593"/>thing we <a id="_idIndexMarker594"/>need<a id="_idIndexMarker595"/> to add to the <strong class="source-inline">enemy.tscn</strong> scene from within the editor before starting to write code is a <strong class="source-inline">NavigationAgent2D</strong> node. This node handles pathfinding and navigation within the <strong class="source-inline">NavigationRegion2D</strong> node that we created in the <span class="No-Break">previous section.</span></p>
			<p>Just add a <strong class="source-inline">NavigationAgent2D</strong> node in the root <strong class="source-inline">Enemy</strong> node. We don’t have to do any <span class="No-Break">other setup:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer208">
					<img alt="Figure 10.24 – Adding a NavigationAgent2D node to the Enemy scene" src="image/B19358_10_24.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.24 – Adding a NavigationAgent2D node to the Enemy scene</p>
			<p>Now, we<a id="_idIndexMarker596"/> can start writing <a id="_idIndexMarker597"/>the <a id="_idIndexMarker598"/>code for <span class="No-Break">our enemy!</span></p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor642"/>Writing the enemy script</h2>
			<p>The code for our<a id="_idIndexMarker599"/> enemy is going to be very similar to the code for our player. They both walk around based on the physics of an accelerating velocity. The only difference is that for the enemy, the position where it wants to move is defined by the <strong class="source-inline">NavigationServer</strong> property. This server looks at the <strong class="source-inline">NavigationRegion2D</strong> node and the current position of the <strong class="source-inline">NavigationAgent2D</strong> node to calculate the best route with the point on the map we choose to <span class="No-Break">go to.</span></p>
			<p>Let’s start out by writing some boilerplate code that defines some of our <span class="No-Break">enemy’s movement:</span></p>
			<pre class="source-code">
class_name Enemy extends CharacterBody2D
@onready var _navigation_agent_2d: NavigationAgent2D = $NavigationAgent2D
@export var max_speed: float = 400.0
@export var acceleration: float = 1500.0
@export var deceleration: float = 1500.0
var player: Player
func _physics_process(delta: float):
   <strong class="bold">_navigation_agent_2d.target_position = player.global_position</strong>
   if <strong class="bold">_navigation_agent_2d.is_navigation_finished()</strong>:
      velocity = velocity.move_toward(Vector2.ZERO, deceleration * delta)
   else:
      <strong class="bold">var next_position: Vector2 = _navigation_agent_2d.get_next_path_position()</strong>
      var direction_to_next_position: Vector2 = global_position.direction_to(next_position)
      velocity = velocity.move_toward(direction_to_next_position * max_speed, acceleration * delta)
   move_and_slide()</pre>			<p>In general, this code is <a id="_idIndexMarker600"/>very similar to the movement code that we wrote for the <strong class="source-inline">player.gd</strong> script. The only difference is that we now use the <strong class="source-inline">NavigationAgent2D</strong> node to say where we need <span class="No-Break">to go:</span></p>
			<pre class="source-code">
_navigation_agent_2d.target_position = target.global_position</pre>			<p>As you can see, we are going toward the global position of the <strong class="source-inline">player</strong> variable. We’ll define this <strong class="source-inline">player</strong> variable in <span class="No-Break">a bit.</span></p>
			<p class="callout-heading">Position and global_position</p>
			<p class="callout">The <strong class="source-inline">position</strong> variable of a <strong class="bold">Node2D</strong> node is always the position relative to its parent node. The <strong class="source-inline">global_position</strong> variable, on the other hand, is the position of the node in world space, relative to the root of the scene tree. Both get automatically updated when the node moves in 2D space; it is basically the same data but with a different point <span class="No-Break">of reference.</span></p>
			<p class="callout">We need to use the <strong class="source-inline">global_position</strong> variable here because the target position of a <strong class="source-inline">NavigationAgent2D</strong> node has to be a <span class="No-Break">global position.</span></p>
			<p>Then, we need to check whether we need to move <span class="No-Break">or not:</span></p>
			<pre class="source-code">
if _navigation_agent_2d.is_navigation_finished():</pre>			<p>If we need to move, we ask the <strong class="source-inline">NavigationAgent2D</strong> node what the next position we should move <span class="No-Break">to is:</span></p>
			<pre class="source-code">
var next_position: Vector2 = _navigation_agent_2d.get_next_path_position()</pre>			<p>Then, all we need to do is calculate the direction from our current position to this next position, and the rest of the code is exactly the same as for the <strong class="source-inline">Player</strong> scene from <a href="B19358_07.xhtml#_idTextAnchor523"><span class="No-Break"><em class="italic">Chapter 7</em></span></a><span class="No-Break">.</span></p>
			<p>To select the <strong class="source-inline">Player</strong> node, we<a id="_idIndexMarker601"/> are going to use node groups by adding this <span class="No-Break"><strong class="source-inline">_ready()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func _ready():
   var player_nodes: Array = <strong class="bold">get_tree().get_nodes_in_group("player")</strong>
   if not player_nodes.is_empty():
      target = player_nodes[0]</pre>			<p>To get the player from within the scene tree, we do something new. We ask the current scene tree for all nodes that are in the <strong class="source-inline">player</strong> group. This function will return an array with nodes that belong to this group. So, we’ll have to take the first element, if there <span class="No-Break">is any.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">It might look weird to ask for all the player nodes in the scene while there is only one. We do this so that we can use roughly the same code to target more players when we deal with multiple players in the <span class="No-Break">next chapter.</span></p>
			<p>These node groups are a useful feature of the Godot engine because the engine will keep track of all nodes within a group so that we can easily query them or check if a node belongs to a <span class="No-Break">certain group.</span></p>
			<p>Now, this code will not work yet because, well, the player is actually not yet in the <strong class="source-inline">player</strong> group! To add them to this group, we need to alter the <strong class="source-inline">Player</strong> scene <span class="No-Break">a little:</span></p>
			<ol>
				<li>Go to the <span class="No-Break"><strong class="source-inline">player.tscn</strong></span><span class="No-Break"> scene.</span></li>
				<li>Select the <span class="No-Break">root node.</span></li>
				<li>In the window that contains the node’s signals, there is a button called <strong class="bold">Groups</strong>. Press it, and you will see the <span class="No-Break"><strong class="bold">Groups</strong></span><span class="No-Break"> window:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer209">
					<img alt="Figure 10.25 – Adding the player’s root node to the node group called player" src="image/B19358_10_25.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.25 – Adding the player’s root node to the node group called player</p>
			<ol>
				<li value="4">Here, type <strong class="source-inline">player</strong> into the line input and <span class="No-Break">press </span><span class="No-Break"><strong class="bold">Add</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>Put an enemy in the<a id="_idIndexMarker602"/> main scene, and you will see that it starts moving toward the player! This is great. But enemies should be able to damage the player, so let’s work on <span class="No-Break">that next.</span></p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor643"/>Damaging the player in a collision</h2>
			<p>To detect if an <a id="_idIndexMarker603"/>enemy is close enough to the player to deal damage, we are going to use an <strong class="bold">Area2D</strong> node, as we did for collectibles in <a href="B19358_09.xhtml#_idTextAnchor590"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><span class="No-Break">:</span></p>
			<ol>
				<li>Let’s start by adding a <strong class="source-inline">get</strong><strong class="source-inline">_hit()</strong> function to the <strong class="source-inline">player.gd</strong> script. This function will get called when the player is hit by an enemy and lower the health of <span class="No-Break">the player:</span><pre class="source-code">
func hit():
   health -= 1</pre></li>				<li>Add an <strong class="bold">Area2D</strong> node to the <strong class="source-inline">enemy.tscn</strong> scene and call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">PlayerDetectionArea</strong></span><span class="No-Break">.</span></li>
				<li>Under this area, add a <span class="No-Break"><strong class="bold">CollisionShape2D</strong></span><span class="No-Break"> node:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer210">
					<img alt="Figure 10.26 – Adding an Area2D node to the Enemy scene" src="image/B19358_10_26.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.26 – Adding an Area2D node to the Enemy scene</p>
			<ol>
				<li value="4">Make this <a id="_idIndexMarker604"/>collision shape a <strong class="bold">CircleShape2D</strong> node that is a little bigger than the <span class="No-Break">enemy’s sprite:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer211">
					<img alt="Figure 10.27 – Covering the whole enemy with some margin with the CollisionShape2D node" src="image/B19358_10_27.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.27 – Covering the whole enemy with some margin with the CollisionShape2D node</p>
			<ol>
				<li value="5">Connect the <strong class="source-inline">body_entered</strong> signal to the root node of <span class="No-Break">the enemy.</span></li>
				<li>Now, use the next snippet of code as the body of the connected function in the <span class="No-Break">enemy’s script:</span><pre class="source-code">
func _on_player_detection_area_body_entered(body: Node2D):
   if not body.is_in_group("player"):
      return
   body.get_hit()
   queue_free()</pre></li>			</ol>
			<p>The code of this function is straightforward. First, we check if the body that entered the area actually is the player. We can do this simply with the <span class="No-Break">following check:</span></p>
			<pre class="source-code">
body.is_in_group("player")</pre>			<p>This way, we can check whether a certain node is in a certain group. If this body is not in the <strong class="source-inline">player</strong> group, we return out of <span class="No-Break">the function.</span></p>
			<p>But if the body is a player node, then we remove one point from its health and free the enemy that <span class="No-Break">made contact.</span></p>
			<p>Great – our enemy can now damage the player when it comes close enough. There is only one more problem: there are only as many enemies as we can drag and drop into the scene. Enemies should be able to spawn automatically and constantly! Otherwise, the game would <a id="_idIndexMarker605"/>be over very quickly. Let’s make an automatic spawner that spawns enemies but also <span class="No-Break">health potions.</span></p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor644"/>Spawning enemies and collectibles</h2>
			<p>To automatically <a id="_idIndexMarker606"/>spawn enemies or collectibles in our playfield is actually harder than it looks at first sight. We can randomly pick a location and spawn something there. Doing this, however, could spawn an enemy or a collectible within a wall or boulder. Even worse, the enemy or collectible could spawn miles away from the arena and the navigation region, rendering <span class="No-Break">them useless.</span></p>
			<p>We could solve this in many smart and abstract ways, but often, the simplest way is the best to start out with. That is why we’ll construct our own entity spawner that can spawn different kinds of entities, enemies, collectibles, or <span class="No-Break">anything else.</span></p>
			<h3>Creating the scene structure</h3>
			<p>An easier way<a id="_idIndexMarker607"/> of solving the problem of the location of enemy spawning is by defining certain points within the arena at which we are sure the enemy can safely spawn. So, that is what we are going to do in the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Create a new scene that derives from the <strong class="bold">Node2D</strong> node <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">EntitySpawner</strong></span><span class="No-Break">.</span></li>
				<li>Save this scene as <strong class="source-inline">entity_spawner.tscn</strong> <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">parts/entity_spawner</strong></span><span class="No-Break">.</span></li>
				<li>Under <strong class="source-inline">EntitySpawner</strong>, add another <strong class="bold">Node2D</strong> node called <strong class="source-inline">Positions</strong>. Here we’ll later define all positions where we can <span class="No-Break">spawn something:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer212">
					<img alt="Figure 10.28 – The structure for our EntitySpawner scene" src="image/B19358_10_28.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.28 – The structure for our EntitySpawner scene</p>
			<ol>
				<li value="4">Drag and drop an instance of <strong class="source-inline">EntitySpawner</strong> into the <strong class="source-inline">main.tscn</strong> scene and rename <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">EnemySpawner</strong></span><span class="No-Break">.</span></li>
				<li>Now, right-click <strong class="source-inline">EnemySpawner</strong> and select <span class="No-Break"><strong class="bold">Editable Children</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer213">
					<img alt="Figure 10.29 – Enabling Editable Children to directly edit the children of an instanced scene" src="image/B19358_10_29.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.29 – Enabling Editable Children to directly edit the children of an instanced scene</p>
			<p class="list-inset">You will see <a id="_idIndexMarker608"/>the <strong class="bold">Positions</strong> node that is a child of the <span class="No-Break"><strong class="source-inline">EnemySpawner</strong></span><span class="No-Break"> scene:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer214">
					<img alt="Figure 10.30 – Adding Marker2D nodes that will be used to position enemies" src="image/B19358_10_30.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.30 – Adding Marker2D nodes that will be used to position enemies</p>
			<ol>
				<li value="6">Now, under this <strong class="bold">Positions</strong> node, add multiple <strong class="bold">Marker2D</strong> nodes and place them at <a id="_idIndexMarker609"/>locations where you want enemies to be able <span class="No-Break">to spawn:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer215">
					<img alt="Figure 10.31 – The different positions at which I wanted enemies to spawn" src="image/B19358_10_31.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.31 – The different positions at which I wanted enemies to spawn</p>
			<p>The <strong class="source-inline">EnemySpawner</strong> node was pretty simple to set up until now, but we did use some new things. Firstly, we enabled <strong class="bold">Editable Children</strong> on a node that is a complete scene. This exposes that whole scene’s structure to us and makes it easy for us to edit the individual nodes within. This is very useful for reusing scenes <span class="No-Break">very directly.</span></p>
			<p>Note that the nodes under the <strong class="source-inline">EnemySpawner</strong> node are grayed out. This means that we can edit them, move them around, and such, just like when we inherited from the collectible scene to make the health potion, but we cannot delete these <span class="No-Break">grayed-out nodes.</span></p>
			<p>Next to editing the children, we used a new node type: <strong class="bold">Marker2D</strong>. This is a node that actually does<a id="_idIndexMarker610"/> nothing special during the game, but in the editor, it will display a little cross to mark the location it is positioned at. This node gets used if you need to mark a position like we are <span class="No-Break">doing here.</span></p>
			<h3>Writing the base code</h3>
			<p>For the code, we’ll do <a id="_idIndexMarker611"/>something pretty simple and provide a <strong class="source-inline">spawn_entity()</strong> function that spawns a new entity, be it an enemy or a health potion, at one of the <span class="No-Break">defined positions:</span></p>
			<pre class="source-code">
extends Node2D
<strong class="bold">@export var entity_scene: PackedScene</strong>
@onready var _positions: Node2D = $Positions
func spawn_entity():
   var random_position: Marker2D = _positions.get_children().pick_random()
   var new_entity: Node2D = <strong class="bold">entity_scene.instantiate()</strong>
   new_entity.position = random_position.position
   add_child(new_entity)</pre>			<p>The first new thing that we encounter is an exported variable of the <strong class="source-inline">PackedScene</strong> type. This <strong class="source-inline">PackedScene</strong> variable is basically the definition of any scene – a scene file. Any scene file can fill <span class="No-Break">this variable.</span></p>
			<p class="callout-heading">Difference between a PackedScene variable and a Node variable</p>
			<p class="callout">A <strong class="source-inline">PackedScene</strong> variable represents a scene file, such as the <strong class="source-inline">enemy.tscn</strong> file. It is a template that we can use to create new <span class="No-Break">nodes from.</span></p>
			<p class="callout">A <strong class="source-inline">Node</strong> variable, on the other hand, is a building block of the scene tree and can be an instance of a <span class="No-Break"><strong class="source-inline">PackedScene</strong></span><span class="No-Break"> variable.</span></p>
			<p class="callout">You could see a <strong class="source-inline">PackedScene</strong> variable as a class, while a <strong class="source-inline">Node</strong> variable is an instanced object of <span class="No-Break">that class.</span></p>
			<p>Then, later, we can use this packed scene to instantiate a <span class="No-Break">new entity:</span></p>
			<pre class="source-code">
var new_entity: Node2D = entity_scene<strong class="bold">.instantiate()</strong></pre>			<p>The last thing we need to do to make this new instanced entity a part of the scene tree is to add it to an existing node within the tree because if we don’t add it somewhere within the scene tree, it is not used within the game or <span class="No-Break">its execution.</span></p>
			<p>We can add a new node as a child to another node by calling the <strong class="source-inline">add_child()</strong> function on any node within the tree with this new entity node as the parameter. The entity will then get added as a child to that node. Here, we add the entity node <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">EntitySpawner</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
<strong class="bold">add_child</strong>(new_entity)</pre>			<p>Now, the entity is truly put into the tree and thus within <span class="No-Break">the game.</span></p>
			<p>To select a<a id="_idIndexMarker612"/> random position, we also do something new. First, we get an array of children from the <strong class="bold">Positions</strong> node with <strong class="source-inline">get_children()</strong>, which is an array of position markers. Then, to pick a random element from this array, we can make use of the <strong class="source-inline">pick_random()</strong> function to easily select one random <span class="No-Break">position marker:</span></p>
			<pre class="source-code">
var random_position: Marker2D = _positions.get_children().<strong class="bold">pick_random()</strong></pre>			<p>This will provide us with a <strong class="bold">Marker2D</strong> node at random that we can use to spawn <span class="No-Break">the enemy.</span></p>
			<p>To make our <strong class="source-inline">EnemySpawner</strong> node that is in the <strong class="source-inline">main.tscn</strong> scene spawn enemies, we just need to drag and drop the <strong class="source-inline">enemy.tscn</strong> scene on top of the <strong class="bold">Entity Scene</strong> property in the <strong class="bold">Inspector</strong> tab for the <span class="No-Break"><strong class="source-inline">EnemySpawner</strong></span><span class="No-Break"> node:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer216">
					<img alt="Figure 10.32 – Dragging and dropping the enemy.tscn file into the Entity Scene property" src="image/B19358_10_32.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.32 – Dragging and dropping the enemy.tscn file into the Entity Scene property</p>
			<p>With this set <a id="_idIndexMarker613"/>up, we can start spawning entities at a fixed <span class="No-Break">time interval.</span></p>
			<h3>Automatically spawning entities</h3>
			<p>Now that we have<a id="_idIndexMarker614"/> a function that can spawn an entity, we still need to trigger it at some point. To do this, we are going to make use of the <strong class="bold">Timer</strong> node. This node counts down a certain amount of time and throws a <strong class="source-inline">timeout</strong> signal when the timer <span class="No-Break">runs out.</span></p>
			<p>Let’s add a <strong class="bold">Timer</strong> node to the <span class="No-Break"><strong class="source-inline">EntitySpawner</strong></span><span class="No-Break"> scene:</span></p>
			<ol>
				<li>Add a <strong class="bold">Timer</strong> node to the <strong class="source-inline">entity_spawner.tscn</strong> scene file and call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">SpawnTimer</strong></span><span class="No-Break">.</span></li>
				<li>Now, connect the timeout signal to the <strong class="source-inline">EntitySpawner</strong> <span class="No-Break">root node.</span></li>
				<li>In the connected function, just call the <span class="No-Break"><strong class="source-inline">spawn_entity()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func _on_spawn_timer_timeout():
   spawn_entity()</pre></li>				<li>Add a reference to the <strong class="source-inline">SpawnTimer</strong> node and an <strong class="source-inline">export</strong> variable that will represent the interval at which we’ll spawn entities at the top of <span class="No-Break">the script:</span><pre class="source-code">
@onready var _spawn_timer: Timer = $SpawnTimer
@export var spawn_interval: float = 1.5</pre></li>				<li>Now, we can add two extra functions that help us start and stop <span class="No-Break">the timer:</span><pre class="source-code">
func start_timer():
   _spawn_timer.start(spawn_interval)
func stop_timer():
   _spawn_timer.stop()</pre></li>				<li>Lastly, to autostart the timer at the start of the game, add this <strong class="source-inline">_ready()</strong> function to the <span class="No-Break"><strong class="source-inline">EntitySpawner</strong></span><span class="No-Break"> script:</span><pre class="source-code">
func _ready():
   start_timer()</pre></li>			</ol>
			<p class="callout-heading">Important note</p>
			<p class="callout">Remember – when we talk about a scene, we talk about a whole scene file, such as the <strong class="source-inline">entity_spawner.tscn</strong> file. When we talk about a node, we are talking about a specific node within the scene file, such as the <span class="No-Break"><strong class="source-inline">EntitySpawner</strong></span><span class="No-Break"> node.</span></p>
			<p>The start and stop functions will help when we want to stop enemies from spawning when the player dies, for example. In the body, they just start and stop <strong class="source-inline">_spawn_timer</strong> directly. You can see that when starting a timer, we can give a time in seconds that will be used as the amount of time before the timer <span class="No-Break">runs out.</span></p>
			<p>Running the game<a id="_idIndexMarker615"/> now, we’ll get a new enemy every 1.5 seconds. Great! Now that we have a stream of enemies coming in, let’s spawn some potions so that the player can <span class="No-Break">heal themselves.</span></p>
			<h3>Spawning health potions</h3>
			<p>To spawn health<a id="_idIndexMarker616"/> potion collectibles, we can easily use the same <strong class="source-inline">EntitySpawner</strong> node that we just constructed! <span class="No-Break">Here’s how:</span></p>
			<ol>
				<li>Add a new <strong class="source-inline">EntitySpawner</strong> node to the <strong class="source-inline">main.tscn</strong> scene and call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">HealthPotionSpawner</strong></span><span class="No-Break">.</span></li>
				<li>Make this spawner’s children editable and add <strong class="bold">Marker2D</strong> nodes to the <strong class="bold">Positions</strong> node at which you want to spawn <span class="No-Break">health potions:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer217">
					<img alt="Figure 10.33 – Adding Marker2D nodes where I would like to spawn health potions" src="image/B19358_10_34.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.33 – Adding Marker2D nodes where I would like to spawn health potions</p>
			<ol>
				<li value="3">Drag and drop the <strong class="source-inline">health_potion.tscn</strong> scene into the <strong class="source-inline">Entity Scene</strong> property of <span class="No-Break">the spawner.</span></li>
				<li>Set the <strong class="bold">Spawn Interval</strong> value <a id="_idIndexMarker617"/>of the spawner to a bigger number, such as 20, so that we don’t spawn too many <span class="No-Break">health potions:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer218">
					<img alt="Figure 10.34 – Setting the Spawn Interval value to 20 seconds" src="image/B19358_10_35.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.34 – Setting the Spawn Interval value to 20 seconds</p>
			<p>That is it! Spawning <a id="_idIndexMarker618"/>new things is easy if we create a scene, <strong class="source-inline">EntitySpawner</strong>, that is easily reusable for it, <span class="No-Break">isn’t it?</span></p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor645"/>Making a Game Over screen</h2>
			<p>Now that enemies <a id="_idIndexMarker619"/>can damage the player and the player’s health goes down, we need to account for the scenario where the player’s health reaches 0. This would mean the end of the game. We’ll add a little <strong class="source-inline">Game Over</strong> screen that gives the player the option to retry or go back to the main menu <span class="No-Break">after dying.</span></p>
			<h3>Creating the base scene</h3>
			<p>As always, we’ll start <a id="_idIndexMarker620"/>off by creating the <span class="No-Break">scene structure:</span></p>
			<ol>
				<li>Create a new scene that has a <strong class="bold">CenterContainer</strong> node as root, call this node <strong class="source-inline">GameOverMenu</strong>, and save the scene as <strong class="source-inline">game_over_menu.tscn</strong> <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">parts/game_over_scene</strong></span><span class="No-Break">.</span></li>
				<li>Recreate the following <span class="No-Break">scene structure:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer219">
					<img alt="Figure 10.35 – The scene tree for the Game Over menu" src="image/B19358_10_36.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.35 – The scene tree for the Game Over menu</p>
			<ol>
				<li value="3">Fill each element with the right text, enlarge the <strong class="bold">Font Size</strong> value of the <strong class="source-inline">GameOverLabel</strong> node, and add some separation to the <strong class="bold">VBoxContainer</strong> node that holds<a id="_idIndexMarker621"/> the two buttons. Make it so that the UI looks <span class="No-Break">like this:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer220">
					<img alt="Figure 10.36 – What the Game Over menu will look like" src="image/B19358_10_37.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.36 – What the Game Over menu will look like</p>
			<ol>
				<li value="4">Now, select the <strong class="source-inline">GameOverMenu</strong> root node and set its <strong class="bold">Anchor preset</strong> type to <span class="No-Break"><strong class="bold">Full Rect</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer221">
					<img alt="Figure 10.37 – Choosing Full Rect from the Anchor presets list" src="image/B19358_10_38.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.37 – Choosing Full Rect from the Anchor presets list</p>
			<p>Now that we <a id="_idIndexMarker622"/>have a little menu, let’s add it to the <span class="No-Break"><strong class="source-inline">main.tscn</strong></span><span class="No-Break"> scene:</span></p>
			<ol>
				<li>In the <strong class="source-inline">main.tscn</strong> scene, add a <span class="No-Break"><strong class="source-inline">CanvasLayer</strong></span><span class="No-Break"> node.</span></li>
				<li>Under this <strong class="source-inline">CanvasLayer</strong> node, add our freshly created <span class="No-Break"><strong class="source-inline">GameOverMenu</strong></span><span class="No-Break"> node:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer222">
					<img alt="Figure 10.38 – The GameOverMenu node added to the scene tree" src="image/B19358_10_39.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.38 – The GameOverMenu node added to the scene tree</p>
			<ol>
				<li value="3">Now, hide the <strong class="source-inline">GameOverMenu</strong> node by clicking the eye symbol next to the name of the node. We only want to show this menu when the player <span class="No-Break">is dead:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer223">
					<img alt="Figure 10.39 – Hiding the GameOverMenu node by clicking the eye symbol next to its name" src="image/B19358_10_40.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.39 – Hiding the GameOverMenu node by clicking the eye symbol next to its name</p>
			<p>We use a <strong class="source-inline">CanvasLayer</strong> node to display our menu here because this node makes sure that all its children are displayed on top of everything else. The <strong class="source-inline">CanvasLayer</strong> node does not adhere to the display order that is determined by the scene tree order of the nodes. Within the <strong class="source-inline">CanvasLayer</strong> node, its children do again adhere to this order. This makes<a id="_idIndexMarker623"/> the <strong class="source-inline">CanvasLayer</strong> node very suitable for UIs within the <span class="No-Break">game itself.</span></p>
			<p>That was it for the base scene structure; now, we should add some logic to <span class="No-Break">the menu.</span></p>
			<h3>Adding logic to the Game Over menu</h3>
			<p>The script for <a id="_idIndexMarker624"/>the <strong class="source-inline">GameOverMenu</strong> node is very simple. All we want to do is add functionality when the buttons are pressed. When the <strong class="bold">Play</strong> button is pressed, we reload the main game scene, and when the menu button is pressed, we go back to the <span class="No-Break">main menu.</span></p>
			<p>So, connect both buttons and load the right scene in each of their <span class="No-Break">connected functions:</span></p>
			<pre class="source-code">
extends CenterContainer
func _on_retry_button_pressed() -&gt; void:
   get_tree().reload_current_scene()
func _on_menu_button_pressed() -&gt; void:
   get_tree().change_scene_to_file("res://screens/ui/menu.tscn")</pre>			<p class="callout-heading">Important note</p>
			<p class="callout">Note that we used a new function, <strong class="source-inline">reload_current_scene()</strong>, on the tree. This function is very similar to <strong class="source-inline">change_scene_to_file()</strong>, except it will just change to the same scene as we are currently in, and we don’t have to load the scene file as it is obviously <span class="No-Break">already loaded.</span></p>
			<p>The <strong class="bold">Game Over</strong> menu<a id="_idIndexMarker625"/> is ready; now, we just need to make use of it within <span class="No-Break">the game.</span></p>
			<h3>Showing the Game Over menu when the player dies</h3>
			<p>We have seen<a id="_idIndexMarker626"/> how we can connect to signals that nodes throw. But we can also make and throw our own signals! We’ll make use of this to detect when the <span class="No-Break">player dies:</span></p>
			<ol>
				<li>In the <strong class="source-inline">player.gd</strong> script, right under the line that carries the <strong class="source-inline">extends</strong> keyword, add our <span class="No-Break">new signal:</span><pre class="source-code">
class_name Player extends CharacterBody2D
<strong class="bold">signal died</strong></pre></li>				<li>Let’s emit this signal and stop the player from moving in the <strong class="source-inline">health</strong> setter when <strong class="source-inline">health</strong> <span class="No-Break">equals </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">:</span><pre class="source-code">
   set(new_value):
      var new_health: int = clamp(new_value, 0, MAX_HEALTH)
      if health &gt; 0 and new_health == 0:
         <strong class="bold">died.emit()</strong>
         <strong class="bold">set_physics_process(false)</strong>
      health = new_health
      update_health_label()</pre></li>			</ol>
			<p>You can see that to define a new signal, we just need to use the <strong class="source-inline">signal</strong> keyword, followed by the name of <span class="No-Break">the signal.</span></p>
			<p>Then, later on, we can just emit this signal by calling the <strong class="source-inline">emit()</strong> function on it. In a way, a signal is also <span class="No-Break">a variable.</span></p>
			<p>To check whether the player died, we check whether the current <strong class="source-inline">health</strong> value is greater than 0 and the <strong class="source-inline">new_health</strong> value is 0. This way, we are sure that we only trigger the <strong class="source-inline">died</strong> signal once, when the player goes from a living to a dead state. We don’t want this signal thrown multiple times because that would signal the game that the player died more than once and create unwanted <span class="No-Break">side effects.</span></p>
			<p>Then, we also use the <strong class="source-inline">set_physics_process()</strong> function and give it <strong class="source-inline">false</strong> as the only parameter. This tells the node if it should stop executing the <strong class="source-inline">_physics_process()</strong> function and will effectively stop the player from moving because that is where all our movement <span class="No-Break">code lives.</span></p>
			<p>Now that the <strong class="source-inline">Player</strong> node throws a signal when it dies, we can hook into this with the <span class="No-Break"><strong class="source-inline">main.tscn</strong></span><span class="No-Break"> scene:</span></p>
			<ol>
				<li>In <a id="_idIndexMarker627"/>the <strong class="source-inline">main.tscn</strong> scene, select the <strong class="source-inline">Player</strong> node. You’ll see that a new signal has appeared – the <strong class="source-inline">died</strong> signal that we defined in the <span class="No-Break"><strong class="source-inline">player.gd</strong></span><span class="No-Break"> script:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer224">
					<img alt="Figure 10.40 – The signal we defined in the player’s script also turns up in the signal menu" src="image/B19358_10_41.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.40 – The signal we defined in the player’s script also turns up in the signal menu</p>
			<ol>
				<li value="2">Add an empty script to the <strong class="source-inline">Main</strong> node of the <strong class="source-inline">main.tscn</strong> scene and connect the <strong class="source-inline">died</strong> signal <span class="No-Break">to it.</span></li>
				<li>In the connected function, we should show the <strong class="source-inline">GameOverMenu</strong> node and stop the <strong class="source-inline">EnemySpawner</strong> node <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">HealthPotionSpawner</strong></span><span class="No-Break">:</span><pre class="source-code">
extends Node2D
@onready var _game_over_menu: CenterContainer = $CanvasLayer/GameOverMenu
@onready var _enemy_spawner: Node2D = $EnemySpawner
@onready var _health_potion_spawner: Node2D = $HealthPotionSpawner
func _on_player_died() -&gt; void:
   _game_over_menu.show()
   _enemy_spawner.stop()
   _health_potion_spawner.stop()</pre></li>			</ol>
			<p>This script is pretty simple because it just needs to handle the menu and stop <span class="No-Break">some spawners.</span></p>
			<p>We covered a lot of ground in this section. We learned about how we can use the <strong class="source-inline">NavigationRegion2D</strong> and <strong class="source-inline">NavigationAgent2D</strong> nodes to make enemies navigate toward the player character. We used <strong class="source-inline">PackedScene</strong> variables to instance scenes from within the code. We used the <strong class="bold">Timer</strong> node to spawn enemies and collectibles after a certain amount of time. We used the <strong class="source-inline">CanvasLayer</strong> node to show a <strong class="bold">Game Over</strong> menu <a id="_idIndexMarker628"/>on top of the game. We created a custom signal and hooked into it. We had a lot of fun, and now it is time for the player to learn how to <span class="No-Break">defend themselves!</span></p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor646"/>Shooting projectiles</h1>
			<p>We’ve sent enough <a id="_idIndexMarker629"/>enemies at the player without them being able to defend themselves. Let’s change that in this section! We’ll be creating projectiles the player character automatically shoots at enemies to kill them off. To keep it simple, we’ll make the projectile hone in on the target we are trying to hit; this way, it <span class="No-Break">never misses.</span></p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor647"/>Creating the base scene</h2>
			<p>Before we can<a id="_idIndexMarker630"/> shoot the projectiles, we’ll have to construct the base scene we’ll work from. Let’s do that right now with the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Create a new scene that has a <strong class="bold">Node2D</strong> node as the root node and call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">Projectile</strong></span><span class="No-Break">.</span></li>
				<li>Create a scene structure as <span class="No-Break">shown next:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer225">
					<img alt="Figure 10.41 – The scene tree of the projectile scene" src="image/B19358_10_42.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.41 – The scene tree of the projectile scene</p>
			<ol>
				<li value="3">Use one of the textures from <strong class="source-inline">assets/sprites/projectils/</strong> as the texture for the sprite. Remember to set the scale of the sprite to <strong class="source-inline">(</strong><span class="No-Break"><strong class="source-inline">3, 3)</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer226">
					<img alt="Figure 10.42 – The projectile" src="image/B19358_10_43.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.42 – The projectile</p>
			<ol>
				<li value="4">Now, use a <strong class="source-inline">CapsuleShape2D</strong> node for the <strong class="source-inline">CollisionShape2D</strong> node’s shape and make sure it covers <span class="No-Break">the sprite:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer227">
					<img alt="Figure 10.43 – Covering the projectile’s sprite with the CollisionShape2D node" src="image/B19358_10_44.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.43 – Covering the projectile’s sprite with the CollisionShape2D node</p>
			<ol>
				<li value="5">We’ll use the <strong class="bold">Area2D</strong> node to detect whether the projectile hit an enemy, so rename this<a id="_idIndexMarker631"/> area <span class="No-Break">node </span><span class="No-Break"><strong class="source-inline">EnemyDetectionArea</strong></span><span class="No-Break">.</span></li>
				<li>To detect the <strong class="source-inline">Enemy</strong> node entering the <strong class="source-inline">EnemyDetectionArea</strong> area node, name the third <strong class="bold">2D Physics</strong> <span class="No-Break">layer </span><span class="No-Break"><strong class="bold">Projectile</strong></span><span class="No-Break">.</span></li>
				<li>Set the <strong class="source-inline">EnemyDetectionArea</strong> area node’s <strong class="bold">Collision Mask</strong> property to detect the <span class="No-Break"><strong class="bold">Projectile</strong></span><span class="No-Break"> layer:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer228">
					<img alt="Figure 10.44 – The Collision layer configuration for the EnemyDetectionArea area node" src="image/B19358_10_45.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.44 – The Collision layer configuration for the EnemyDetectionArea area node</p>
			<ol>
				<li value="8">In the <strong class="source-inline">enemy.tscn</strong> scene, set the <strong class="source-inline">Enemy</strong> node’s <strong class="bold">Collision Layer</strong> property to be on the <strong class="bold">Projectile</strong> <span class="No-Break">layer too:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer229">
					<img alt="Figure 10.45 – The Collision layer configuration for the enemy" src="image/B19358_10_46.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.45 – The Collision layer configuration for the enemy</p>
			<p>This is all we need in<a id="_idIndexMarker632"/> terms of the scene structure, so let’s get to writing the behavior of <span class="No-Break">the projectile.</span></p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor648"/>Writing the logic of the projectile</h2>
			<p>Next up is the code that <a id="_idIndexMarker633"/>steers the projectile toward a target, destroys it on impact, and notifies the enemy it has been hit. We’ll make the projectile always go straight toward its target; this makes it easy for <span class="No-Break">us code-wise:</span></p>
			<ol>
				<li>Attach a script called <strong class="source-inline">projectile.gd</strong> to the <strong class="source-inline">Projectile</strong> root node and fill it with the following code to <span class="No-Break">move it:</span><pre class="source-code">
class_name Projectile
extends Node2D
@export var speed: float = 600.0
var target: Node2D
func _physics_process(delta: float):
   global_position = global_position.move_toward(target.global_position, speed * delta)
   look_at(target.global_position)</pre><p class="list-inset">We’ve seen most of this code already, except for the <strong class="source-inline">look_at()</strong> function. This function rotates a node to orient itself toward a point in space that we provide it. So, here, it rotates the projectile node toward the position of <span class="No-Break">the target.</span></p></li>				<li>Now, connect the <strong class="source-inline">body_entered</strong> signal from the <strong class="source-inline">EnemyDetectionArea</strong> node to the projectile’s script. All we need to do in the connected function is to notify the enemy that it got hit and destroy the <span class="No-Break">projectile itself:</span><pre class="source-code">
func _on_enemy_detection_area_body_entered(body: Node2D):
   body.get_hit()
   queue_free()</pre></li>				<li>Lastly, in the <strong class="source-inline">enemy.gd</strong> script, add this <strong class="source-inline">get_hit()</strong> function that we want to use when the projectile hits <span class="No-Break">the enemy:</span><pre class="source-code">
func get_hit():
   queue_free()</pre></li>			</ol>
			<p>This is all we need <a id="_idIndexMarker634"/>code-wise on the side of the <span class="No-Break">projectile itself.</span></p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor649"/>Spawning projectiles</h2>
			<p>We want the projectile<a id="_idIndexMarker635"/> to be shot automatically every so often. To achieve this, we’ll need to make some changes in the <strong class="source-inline">Player</strong> and <span class="No-Break"><strong class="source-inline">Enemy</strong></span><span class="No-Break"> scenes:</span></p>
			<ol>
				<li>Add a <strong class="source-inline">Timer</strong> node to the <strong class="source-inline">Player</strong> scene and call this new <span class="No-Break">node </span><span class="No-Break"><strong class="source-inline">ShootTimer</strong></span><span class="No-Break">.</span></li>
				<li>Set the time of this <strong class="source-inline">ShootTimer</strong> node to <strong class="source-inline">0.5</strong> and <span class="No-Break">enable </span><span class="No-Break"><strong class="bold">Autostart</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer230">
					<img alt="Figure 10.46 – Adding a Timer node called ShootTimer to the Player scene" src="image/B19358_10_47.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.46 – Adding a Timer node called ShootTimer to the Player scene</p>
			<ol>
				<li value="3">Next, in the player’s script, preload the projectile scene at <span class="No-Break">the top:</span><pre class="source-code">
@export var projectile_scene: PackedScene = preload("res://parts/projectile/projectile.tscn")</pre></li>				<li>While the <strong class="source-inline">Player</strong> node is selected, drag and drop the <strong class="source-inline">projectile.tscn</strong> file into the <strong class="bold">Projectile Scene</strong> property in the <span class="No-Break"><strong class="bold">Inspector</strong></span><span class="No-Break"> tab.</span></li>
			</ol>
			<p>Just like with the <strong class="source-inline">EntitySpawner</strong> node, we export a variable of the <strong class="source-inline">PackedScene</strong> type that we can fill from the editor and instantiate later on when we need it. This time, though, we directly fill it with the <strong class="source-inline">projectile.tscn</strong> scene. The <strong class="source-inline">preload()</strong> function loads this<a id="_idIndexMarker636"/> scene and puts it in the <strong class="source-inline">projectile_scene</strong> variable, ready to be used. But this variable is also exported, which means that if, someday, we want the player to shoot a different kind of projectile, we can drag and drop this scene in the <strong class="bold">Inspector</strong> tab of <span class="No-Break">the player.</span></p>
			<p>We’ll now add the logic that actually spawns <span class="No-Break">the projectile:</span></p>
			<ol>
				<li>In the <strong class="source-inline">enemy.tscn</strong> scene, add the root node to the <strong class="source-inline">enemy</strong> group as we did for the player. This will make sure we can access all enemy <span class="No-Break">nodes later:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer231">
					<img alt="Figure 10.47 – Adding the enemy node to the enemy group" src="image/B19358_10_48.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.47 – Adding the enemy node to the enemy group</p>
			<ol>
				<li value="2">Add a new <strong class="source-inline">export</strong> variable to the top of the <strong class="source-inline">player.gd</strong> script. This variable will represent how far the player can shoot <span class="No-Break">in pixels:</span><pre class="source-code">
@export var shoot_distance: float = 400.0</pre></li>				<li>Now, connect the timeout signal of the <strong class="source-inline">ShootTimer</strong> node to the <strong class="source-inline">Player</strong> <span class="No-Break">node’s script.</span><p class="list-inset">This should be<a id="_idIndexMarker637"/> the body for the <span class="No-Break">connected signal:</span></p><pre class="source-code">
func _on_shoot_timer_timeout():
   var closest_enemy: Enemy
   var smallest_distance: float = INF
   var all_enemies: Array = get_tree().get_nodes_in_group("enemy")
   for enemy in all_enemies:
      var distance_to_enemy: float = global_position.distance_to(enemy.global_position)
      if distance_to_enemy &lt; smallest_distance:
         closest_enemy = enemy
         smallest_distance = distance_to_enemy
   if not closest_enemy:
      return
   if smallest_distance &gt; shoot_distance:
      return
   var new_projectile: Projectile = ProjectileScene.instantiate()
   new_projectile.target = closest_enemy
   get_parent().add_child(new_projectile)
   new_projectile.global_position = global_position</pre></li>				<li>We should also<a id="_idIndexMarker638"/> stop the <strong class="source-inline">ShootTimer</strong> node when the player dies, cache the <strong class="source-inline">ShootTimer</strong> node at the top of the player script, and stop it when the player’s health <span class="No-Break">reaches 0:</span><pre class="source-code">
<strong class="bold">@onready var _shoot_timer = $ShootTimer</strong>
@export_range(0, MAX_HEALTH) var health: int = 10:
   set(new_value):
      # Code to update the health
      if health &gt; 0 and new_health == 0:
         # Code when player dies
         <strong class="bold">shoot_timer.stop()</strong></pre></li>			</ol>
			<p>The high-level explanation of this function’s body is that we first get a list of all enemies, using the group functionality. Then, we go over every single one of them to see how far away they are from the player. While doing this loop, we always keep the enemy that is the closest along with that distance. This way, we know that we’ll end up with the enemy that is nearest to the <span class="No-Break">player character.</span></p>
			<p>The result of this algorithm can result in no enemy being selected. That is why we need to make sure <strong class="source-inline">closest_enemy</strong> is not accidentally empty and need to return from the function if <span class="No-Break">it is.</span></p>
			<p>After all this, we create a new projectile, set its target, add it to the scene tree, and put its position to the position of <span class="No-Break">the player.</span></p>
			<p>That was it for creating projectiles! You can now run the game and start trying to survive as long as possible. We<a id="_idIndexMarker639"/> also saw some more intricate code with an algorithm to find the closest node from any other node and how to preload a scene within <span class="No-Break">a script.</span></p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor650"/>Storing highscores in autoloads</h1>
			<p>Now that the player <a id="_idIndexMarker640"/>can fight back and survive, we might need to<a id="_idIndexMarker641"/> give the player a goal to attain – something that will make them play again and again. We could add a highscore – for example, the amount of time the player was able to survive. The player can then try to better their own time or compare times with <span class="No-Break">their friends.</span></p>
			<p>To achieve this, we will be using an autoload. This is a node that gets initialized at the start of the game and will exist throughout the complete execution of <span class="No-Break">the game.</span></p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor651"/>Using an autoload</h2>
			<p>The survival time<a id="_idIndexMarker642"/> should be stored somewhere so that it is easily accessible from anywhere within the game. This way, we can change it after the player dies but also display the score on the main menu, <span class="No-Break">for example.</span></p>
			<p>Normal nodes and scenes have to be managed by us, the programmer. But there is another kind of node that we could use: autoloads. An autoload is a scene or script that is always loaded. The Godot engine initiates this scene for us anytime we run <span class="No-Break">the game.</span></p>
			<p>A node or script that is autoloaded will exist as long as the game is running. Earlier, when using <strong class="source-inline">get_tree().change_scene_to_file()</strong> to change scenes, everything of the current scene gets removed from the scene tree and switched out for the new scene. However, autoloads do not share the same faith; they stay put and retain the values of all <span class="No-Break">their variables.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Although autoloads are great, they should not be misused or overused. They should only be used for systems that are truly global, such as the <strong class="source-inline">HighscoreManager</strong> autoload we are going to create in <span class="No-Break">this section.</span></p>
			<p>We are not going to store the highscore autoload in a file just yet; we’ll do this in <a href="B19358_15.xhtml#_idTextAnchor740"><span class="No-Break"><em class="italic">Chapter 15</em></span></a>. For now, we<a id="_idIndexMarker643"/> just want to save and load the highscore autoload while the game <span class="No-Break">is running.</span></p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor652"/>Creating a HighscoreManager autoload</h2>
			<p>To create an <a id="_idIndexMarker644"/>autoload, we first need to create a normal scene or script. Because we don’t really need a whole scene to keep track of a highscore, which is basically just a number, we are going to write a script. When the Godot engine initiates our game, it will create a node and attach our script to it. The following steps illustrate the process of creating <span class="No-Break">an autoload:</span></p>
			<ol>
				<li>Create a new <strong class="source-inline">autoloads/</strong> folder in the root of <span class="No-Break">the project.</span></li>
				<li>Add a new script in this folder <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">highscore_manager.gd</strong></span><span class="No-Break">.</span><p class="list-inset">The <strong class="source-inline">HighscoreManager</strong> script is going to be pretty simple <span class="No-Break">and straightforward:</span></p><pre class="source-code">
extends Node
var highscore: int = 0
func set_new_highscore(value: int):
   if value &gt; highscore:
      highscore = value</pre></li>			</ol>
			<p>The preceding code defined a <strong class="source-inline">highscore</strong> variable and a <strong class="source-inline">set_new_highscore()</strong>. function. This function checks if the new score is bigger than the current highscore. If it is, we save this new, higher score; otherwise, we don’t need <span class="No-Break">to bother.</span></p>
			<p>Now, let’s set this script up as <span class="No-Break">an autoload:</span></p>
			<ol>
				<li>Open the project settings and navigate to the <span class="No-Break"><strong class="bold">Autoload</strong></span><span class="No-Break"> tab.</span></li>
				<li>Select the file icon button to search for <span class="No-Break">a file:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer232">
					<img alt="Figure 10.48 – Pressing the folder icon to select a file that you want to load as an autoload" src="image/B19358_10_49.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.48 – Pressing the folder icon to select a file that you want to load as an autoload</p>
			<ol>
				<li value="3">Navigate <a id="_idIndexMarker645"/>to the <span class="No-Break"><strong class="source-inline">autoloads/highscore_manager.gd</strong></span><span class="No-Break"> script.</span></li>
				<li>Select it and <span class="No-Break">press </span><span class="No-Break"><strong class="bold">Open</strong></span><span class="No-Break">.</span></li>
				<li>Now, back in on the <strong class="bold">Autoload</strong> panel within the project settings, press the <span class="No-Break"><strong class="bold">Add</strong></span><span class="No-Break"> button.</span></li>
			</ol>
			<p>That is all for setting up our autoload. You’ll see that the <strong class="bold">Highscore</strong> autoload is now displayed within the list <span class="No-Break">of autoloads:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer233">
					<img alt="Figure 10.49 – The highscore_manager.gd script is loaded as an autoload" src="image/B19358_10_50.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.49 – The highscore_manager.gd script is loaded as an autoload</p>
			<p>Next to seeing the script in the list of autoloads, there is another way we can check whether the<a id="_idIndexMarker646"/> autoload <span class="No-Break">is there.</span></p>
			<p class="callout-heading">Using a scene as an autoload</p>
			<p class="callout">Both scripts and full scenes can be autoloads. To use a scene, load the scene just like we did for the script <span class="No-Break">just now.</span></p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor653"/>Autoloads in the remote tree</h2>
			<p>As said earlier, autoloads <a id="_idIndexMarker647"/>get instantiated by the Godot engine when the<a id="_idIndexMarker648"/> game starts running. So, we can’t see them present in separate scenes, but they should be there in the remote tree when we run <span class="No-Break">the game.</span></p>
			<p>Run the game using the <strong class="bold">Run Project</strong> button or any scene of the game using the <strong class="bold">Run Current Scene</strong> button. Open the remote tree, and you will see a node called <strong class="bold">HighscoreManager</strong>. This is our <span class="No-Break"><strong class="bold">HighscoreManager</strong></span><span class="No-Break"> autoload!</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer234">
					<img alt="Figure 10.50 – We can see the HighscoreManager node in the remote tree" src="image/B19358_10_51.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.50 – We can see the HighscoreManager node in the remote tree</p>
			<p>Now that we set up our <strong class="bold">HighscoreManager</strong> autoload, let’s use it within the game and keep <span class="No-Break">some highscores!</span></p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor654"/>Adding a UI in the main menu and game scene</h2>
			<p>First, we’ll need to <a id="_idIndexMarker649"/>make sure the<a id="_idIndexMarker650"/> player knows what their score is while playing the game. Because we said that the score would be the amount of time the player is able to survive, we’ll show this score by adding a timer on <span class="No-Break">the screen:</span></p>
			<ol>
				<li>In the <strong class="source-inline">main.tscn</strong> scene, under the existing <strong class="source-inline">CanvasLayer</strong> node, add a <strong class="bold">CenterContainer</strong> node and call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">TimerUI</strong></span><span class="No-Break">.</span></li>
				<li>For the <strong class="source-inline">TimerUI</strong> node, select the <strong class="bold">Top Wide</strong> anchor so that it stays on the top of <span class="No-Break">the screen:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer235">
					<img alt="Figure 10.51 – Selecting Top Wide from the Anchor preset list" src="image/B19358_10_52.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.51 – Selecting Top Wide from the Anchor preset list</p>
			<ol>
				<li value="3">Add <a id="_idIndexMarker651"/>a <strong class="bold">Label</strong> node <a id="_idIndexMarker652"/>to <strong class="source-inline">TimerUI</strong> and call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">TimeLabel</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer236">
					<img alt="Figure 10.52 – The scene structure for our timer" src="image/B19358_10_53.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.52 – The scene structure for our timer</p>
			<ol>
				<li value="4">Let’s fill this label with a fake time of <strong class="source-inline">"123"</strong> so that we can see how the score will look when it <span class="No-Break">is filled.</span></li>
				<li>Change the font size of this label to something larger, such as <span class="No-Break"><strong class="source-inline">30</strong></span><span class="No-Break"> px.</span></li>
			</ol>
			<p>Now, we’ll need to account for the timer in the <strong class="source-inline">main.gd</strong> <span class="No-Break">game script:</span></p>
			<ol>
				<li>First cache a reference to the <strong class="source-inline">TimeLabel</strong> node at the top of the script and add a variable in which we’ll keep the current <span class="No-Break">elapsed time:</span><pre class="source-code">
@onready var _time_label: Label = $ CanvasLayer/TimerUI/TimeLabel
var _time: float = 0.0:
   set(value):
      _time = value
      _time_label.text = str(floor(_time))</pre></li>				<li>Now, all we need to do is update the value of this <strong class="source-inline">_time</strong> variable. We’ll do this in the <strong class="source-inline">_process()</strong> function by adding the delta to the <span class="No-Break">current time:</span><pre class="source-code">
func _process(delta: float):
   _time += delta</pre></li>				<li>Lastly, we’ll need to submit this time whenever the player dies and stop the game from counting more time. So, change the function that is connected to the <strong class="source-inline">died</strong> signal from the player to include the following <span class="No-Break">two lines:</span><pre class="source-code">
func _on_player_died() -&gt; void:
   _game_over_menu.show()
   _enemy_spawner.stop()
   _health_potion_spawner.stop()
   set_process(false)
   HighscoreManager.set_new_highscore(_time)</pre></li>			</ol>
			<p>That’s it to<a id="_idIndexMarker653"/> get the <a id="_idIndexMarker654"/>highscore linked within the game itself. Now, we’ll tackle showing the highscore in the main <span class="No-Break">menu too.</span></p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor655"/>Using the highscore in the main menu</h2>
			<p>Now that we can<a id="_idIndexMarker655"/> make new highscores, let’s display the highest score within <span class="No-Break">the menu:</span></p>
			<ol>
				<li>Open the <span class="No-Break"><strong class="source-inline">menu.tscn</strong></span><span class="No-Break"> scene.</span></li>
				<li>Add a new <strong class="bold">Label</strong> node to the <strong class="bold">VBoxContainer</strong> node that contains the <strong class="bold">Play</strong> and <strong class="bold">Exit</strong> buttons and call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">HighscoreLabel</strong></span><span class="No-Break">.</span></li>
				<li>Now, in the <strong class="source-inline">menu.gd</strong> script, add the <span class="No-Break">following code:</span><pre class="source-code">
@onready var highscore_label: Label = $CenterContainer/VBoxContainer/PanelContainer/MarginContainer/VBoxContainer/VBoxContainer/HighscoreLabel
func _ready():
   highscore_label.text = "Highscore: " + str(HighscoreManager.highscore)</pre></li>			</ol>
			<p>The result is that the menu will now show the <span class="No-Break">current highscore:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer237">
					<img alt="Figure 10.53 – The main menu with an added Highscore label" src="image/B19358_10_54.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.53 – The main menu with an added Highscore label</p>
			<p>None of this code is new to us. First, we save the <strong class="bold">HighscoreLabel</strong> node in a variable called <strong class="source-inline">highscore_label</strong>. Next, when the menu scene is ready, we populate the <strong class="bold">HighscoreLabe</strong>l with a string that contains the current <span class="No-Break">highest score.</span></p>
			<p>That was our venture into autoloads. We saw how easy it is to add a script or scene as a node that is always loaded at the start of our game without having to manage this node ourselves. Then, we <a id="_idIndexMarker656"/>made use of this autoload through its global variable to save information between <span class="No-Break">different scenes.</span></p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor656"/>Additional exercises – Sharpening the axe</h1>
			<ol>
				<li>Enemies get spawned at a slow, fixed rate. This can get a little boring because the difficulty never really increases. Make it so that enemies get spawned faster and faster after every round. For a simple way of doing this, you could follow the <span class="No-Break">next steps:</span><ol><li class="upper-roman">Add <strong class="source-inline">start_interval</strong>, <strong class="source-inline">end_interval</strong>, and <strong class="source-inline">time_delta</strong> as export variables to the <strong class="source-inline">EntitySpawner</strong> node. The <strong class="source-inline">start_interval</strong> variable will be the time we use between spawning entities at the start of the game, <strong class="source-inline">end_interval</strong> will be the final value, and <strong class="source-inline">time_delta</strong> is the increment at which we will go from the <strong class="source-inline">start_interval</strong> variable to the <span class="No-Break"><strong class="source-inline">end_interval</strong></span><span class="No-Break"> variable:</span></li></ol></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer238">
					<img alt="Figure 10.54 – The new exported variables for the EntitySpawner node" src="image/B19358_10_55.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.54 – The new exported variables for the EntitySpawner node</p>
			<ol>
				<li class="upper-roman" value="2">Now, track in a separate variable, <strong class="source-inline">_current_spawn_interval</strong>, the time for the next enemy to spawn. Set <strong class="source-inline">_current_spawn_interval</strong> equal to the <strong class="source-inline">start_interval</strong> variable at the start of the game. This variable replaces the old <span class="No-Break"><strong class="source-inline">spawn_interval</strong></span><span class="No-Break"> variable.</span></li>
				<li class="upper-roman">Every time we spawn an entity in the <strong class="source-inline">spawn_entity</strong> function, add the <strong class="source-inline">time_delta</strong> variable to the <strong class="source-inline">_current_spawn_interva</strong><strong class="source-inline">l</strong> variable. Make sure to not go past the <strong class="source-inline">end_interval</strong> <span class="No-Break">variable, though.</span></li>
				<li class="upper-roman">Then, still in the <strong class="source-inline">spawn_entity()</strong> function, start <strong class="source-inline">_spawn_timer</strong> again but with the new <strong class="source-inline">_current_spawn_interval</strong> variable: by calling <strong class="source-inline">start_timer()</strong> again. For the <strong class="source-inline">HealthPotionSpawner</strong> node, you’ll have to set <strong class="source-inline">time_delta</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0.0</strong></span><span class="No-Break">.</span></li>
				<li class="upper-roman">The menu that shows up when the player dies is quite lacking in information. Add a nice label to show the score the player <span class="No-Break">just achieved.</span></li>
			</ol>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor657"/>Summary</h1>
			<p>We learned and crea<a id="_idTextAnchor658"/>ted so many different things within this chapter. First, we learned all about <strong class="bold">Control</strong> nodes and how to use them to construct a main menu for our game. Then we created some challenges in the game with enemies that try to stop the player. We even made these enemies navigate smartly over the playing field using the <strong class="source-inline">NavigationServer</strong> property. To let the player have a chance to defend themselves, we created projectiles that get shot automatically on a timer. Lastly, we added a small high-score system that stores the current highscore within an autoload so that the player is incentivized to replay the game and try to beat their own <span class="No-Break">best time.</span></p>
			<p>In the next chapter, we’ll do something very interesting: make our <span class="No-Break">game multiplayer!</span></p>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor659"/>Quiz time</h1>
			<ul>
				<li><strong class="bold">Control</strong> nodes are used to create UIs such as menus. For each of the following scenarios, give a <strong class="bold">Control</strong> node that could do <span class="No-Break">the job:</span></li>
				<li>Showing a long piece <span class="No-Break">of text</span></li>
				<li>Grouping other <strong class="bold">Control</strong> nodes to the center of <span class="No-Break">the screen</span></li>
				<li>Showing a button to start <span class="No-Break">the game</span></li>
				<li>Which node did we add to the <strong class="source-inline">Enemy</strong> scene to make it find a path to <span class="No-Break">the player?</span></li>
				<li>Let’s say that we have this piece of code where we define a signal called <strong class="source-inline">shot</strong> to indicate that we shot <span class="No-Break">a projectile:</span><pre class="source-code">
signal shot</pre><p class="list-inset">Write the line of code that is needed to emit <span class="No-Break">this signal.</span></p></li>				<li>How do you load a scene from within the code into <span class="No-Break">a variable?</span></li>
				<li>How can we make a script <span class="No-Break">globally accessible?</span></li>
			</ul>
		</div>
	</body></html>