<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-240"><a id="_idTextAnchor632"/>10</h1>
			<h1 id="_idParaDest-241"><a id="_idTextAnchor633"/>Creating Menus, Making Enemies, and Using Autoloads</h1>
			<p>Although it was a lot of fun setting up all the current systems, the game is still kind of boring. There is no real adversary, nothing to stop the player from just picking up all the gold coins they desire. Let’s bring some challenge into the mix by creating enemies that attack the player and try to stop their road to glory and fame!</p>
			<p>Next to that, we’ll also create a little menu to start our game from. We’ll do this with Godot’s <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) system, which makes use of <strong class="bold">Control</strong> nodes. In this chapter, we will discuss the following topics:</p>
			<ul>
				<li>Creating a menu</li>
				<li>Making enemies</li>
				<li>Shooting projectiles</li>
				<li>Scoring highscores in autoloads</li>
			</ul>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor634"/>Technical requirements</h1>
			<p>As for every chapter, you can find the final code on the GitHub repository in the subfolder for this chapter: <a href="https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter10">https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter10</a>.</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor635"/>Creating a menu</h1>
			<p>The most exciting <a id="_idIndexMarker552"/>part of developing a game is, of course, making the game itself! Making things move, fight, jump, shoot, interact, and so forth. But there is another part that is just as important: the UI. A UI binds everything together. It informs the player of what is happening and lets them navigate from menu to menu with ease and without having to think about how to get from one interface to the other.</p>
			<p>Good user experience, UI, or human-computer interaction design is hard! But it all starts with learning how to make the UI in the first place. So, let’s have a look at how we can create menus and<a id="_idIndexMarker553"/> interfaces.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor636"/>Control nodes</h2>
			<p>The Godot <a id="_idIndexMarker554"/>engine comes with an extensive library of interface nodes. We already made use of one, the <strong class="bold">Label</strong> node, in <a href="B19358_06.xhtml#_idTextAnchor411"><em class="italic">Chapter 6</em></a>. These nodes are called <strong class="bold">Control nodes</strong> and get labeled by the color green:</p>
			<div><div><img alt="Figure 10.1 – Some Control nodes can be recognized by their green color" src="img/B19358_10_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Some Control nodes can be recognized by their green color</p>
			<p>If you go and open the <strong class="bold">Create New Node</strong> menu, you’ll see there are a lot of these <strong class="bold">Control</strong> nodes. We could categorize these into three different groups. Let’s go over some of the nodes and what they can do for us in each group.</p>
			<h3>Nodes showing information</h3>
			<p>The first group <a id="_idIndexMarker555"/>of nodes shows information. In this group, you would find the <strong class="bold">Label</strong> node we used in <a href="B19358_06.xhtml#_idTextAnchor411"><em class="italic">Chapter 6</em></a>, but also the <strong class="bold">ColorRect</strong> and <strong class="bold">TextureRect</strong> nodes:</p>
			<ul>
				<li><strong class="bold">Label</strong>: Shows a short string of text.</li>
				<li><strong class="bold">RichTextLabel</strong>: Shows a longer piece of text that can be formatted in specific ways.</li>
				<li><strong class="bold">ColorRect</strong>: Shows a solid rectangle in one color.</li>
				<li><strong class="bold">TextureRect</strong>: Shows a texture in a rectangle. This node is similar to the <strong class="bold">Sprite2D</strong> node in that they are both used to show a texture but in different contexts.</li>
			</ul>
			<p>In the following figure, you can see what these nodes look like in the editor:</p>
			<div><div><img alt="Figure 10.2 – Examples of Control nodes that show information" src="img/B19358_10_2.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Examples of Control nodes that show information</p>
			<p>These nodes<a id="_idIndexMarker556"/> all show something to the user.</p>
			<h3>Nodes taking input</h3>
			<p>Any good UI <a id="_idIndexMarker557"/>can also take input, with – for example – buttons. Here are some of the input nodes that the Godot engine UI nodes provide:</p>
			<ul>
				<li><strong class="bold">Button</strong>: A simple button that can be clicked.</li>
				<li><strong class="bold">CheckBox</strong>: A checkbox that can be turned on and off.</li>
				<li><strong class="bold">CheckButton</strong>: The same as a checkbox, but just with a different aesthetic.</li>
				<li><strong class="bold">LineEdit</strong>: A simple node that can take a single line of text input and provide it as a string.</li>
				<li><strong class="bold">HSlider</strong> and <strong class="bold">VSlider</strong>: Sliders that are used to input a number. <strong class="bold">HSlider</strong> slides horizontally while <strong class="bold">VSlider</strong> slides vertically.</li>
			</ul>
			<p>In the following figure, you can see what these nodes look like in the editor:</p>
			<div><div><img alt="Figure 10.3 – Examples of Control nodes that take input" src="img/B19358_10_3.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Examples of Control nodes that take input</p>
			<p>These nodes <a id="_idIndexMarker558"/>all take input in one way or another.</p>
			<h3>Nodes containing other nodes</h3>
			<p>Lastly, there<a id="_idIndexMarker559"/> are the nodes that you don’t see but that are very important because they make sure all the other UI elements are placed correctly. These nodes form the skeleton in which the other <strong class="bold">Control</strong> nodes can find their place.</p>
			<p><strong class="bold">Container</strong> nodes <a id="_idIndexMarker560"/>help us to lay out the UI as we want. This type of node can display elements nicely next to each other, add some spacing between nodes, and so forth.</p>
			<p>These containers can also help keep the interface usable and beautiful when we resize the screen. This does not happen often, but games can be played on so many different screen sizes and aspect ratios these days. Just think about the difference between a computer screen and a phone screen.</p>
			<p>Some interesting container nodes are the following:</p>
			<ul>
				<li><strong class="bold">VBoxContainer</strong> and <strong class="bold">HBoxContainer</strong>: Organize all their child nodes nicely, vertically or horizontally</li>
				<li><strong class="bold">CenterContainer</strong>: Centers its child nodes</li>
				<li><strong class="bold">GridContainer</strong>: Organizes all its child nodes in a tidy grid</li>
				<li><strong class="bold">MarginContainer</strong>: Adds spacing around its child nodes so that they have some room to breathe</li>
				<li><strong class="bold">Panel</strong>: Provides a background that shows this part of the UI logically belongs together</li>
			</ul>
			<p>In the following figure, you can see what these nodes look like in the editor:</p>
			<div><div><img alt="Figure 10.4 – Examples of Control nodes that can contain other nodes" src="img/B19358_10_4.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Examples of Control nodes that can contain other nodes</p>
			<p><strong class="bold">Container</strong> nodes all contain and place their child nodes in a specific way.</p>
			<p>The lists of nodes in this section are not exhaustive; a quick glance in the <strong class="bold">Control</strong> node category while adding a node makes this pretty obvious. But these are the most important nodes that you will likely use first. The others are more specialized.</p>
			<p>The cool thing is that the complete Godot editor itself is constructed out of these Control nodes, just to show how flexible and powerful they are for building out UIs.</p>
			<p>Now that we<a id="_idIndexMarker561"/> have a basic knowledge of the different <strong class="bold">Control</strong> nodes, we can start making a menu with them.</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor637"/>Creating a basic start menu</h2>
			<p>Let’s create a <a id="_idIndexMarker562"/>start menu that displays when we start up the game. This menu should simply display the game’s name, a button to start playing, a button to exit the game, and lastly, we could add some information on who created the game:</p>
			<div><div><img alt="Figure 10.5 – This is what our start menu will look like" src="img/B19358_10_5.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – This is what our start menu will look like</p>
			<p>Let’s go over the steps to create a start menu, as shown in <em class="italic">Figure 10</em><em class="italic">.5</em>:</p>
			<ol>
				<li>Create<a id="_idIndexMarker563"/> a new scene called <code>menu.tscn</code> under a new <code>screens/ui</code> folder.</li>
				<li>Select <strong class="bold">User Interface</strong> as the root node’s type:</li>
			</ol>
			<div><div><img alt="Figure 10.6 – Choosing User Interface as the root node for our menu" src="img/B19358_10_6.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – Choosing User Interface as the root node for our menu</p>
			<ol>
				<li value="3">Rename the root node <code>Menu</code>.</li>
				<li>Let’s start by adding a <strong class="bold">ColorRect</strong> node to the menu; this will be our background color.</li>
				<li>Now, to stretch the <strong class="bold">ColorRect</strong> node to cover the whole screen, <strong class="bold">Control</strong> nodes have a handy dandy little menu in the top bar. Select the <strong class="bold">ColorRect</strong> node in the scene tree and select <strong class="bold">Full Rect</strong> from the <strong class="bold">Anchor </strong><strong class="bold">preset</strong> list:</li>
			</ol>
			<div><div><img alt="Figure 10.7 – Choosing Full Rect to make the ColorRect node cover the full screen" src="img/B19358_10_7.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Choosing Full Rect to make the ColorRect node cover the full screen</p>
			<ol>
				<li value="6">Now, add<a id="_idIndexMarker564"/> a <code>MainUIContainer</code>.</li>
				<li>Now, add a <code>TitleLabel</code>. This label will show the title of our game:</li>
			</ol>
			<div><div><img alt="Figure 10.8 – The scene tree of our menu until now" src="img/B19358_10_8.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – The scene tree of our menu until now</p>
			<ol>
				<li value="8">Think of a good title for the game and put it in the text field of the <strong class="bold">TitleLabel</strong> node.</li>
				<li>Now, go to <code>60</code> px:</li>
			</ol>
			<div><div><img alt="Figure 10.9 – You can change the font size of a label in Theme Overrides" src="img/B19358_10_9.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – You can change the font size of a label in Theme Overrides</p>
			<p>This was just to create a title label for our game UI. It might seem like a lot of steps, but some of the nodes we used will make it easy to extend the UI in the next few steps.</p>
			<p>Let’s add a panel<a id="_idIndexMarker565"/> with buttons and a credit line:</p>
			<ol>
				<li>Add a <strong class="bold">PanelContainer</strong> node to the <strong class="bold">MainUIContainer</strong> node.</li>
				<li>Now, create the following structure in this panel container:</li>
			</ol>
			<div><div><img alt="Figure 10.10 – The scene tree structure from the PanelContainer node" src="img/B19358_10_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – The scene tree structure from the PanelContainer node</p>
			<ol>
				<li value="3">Rename the first button <code>PLAY</code>.</li>
				<li>Rename the second button <code>EXIT</code>.</li>
				<li>Rename the label <strong class="bold">CreditLabel</strong> and change its text to whatever you would like it to say!</li>
				<li>Now, go into the first <code>50</code> px.</li>
				<li>Change the <code>20</code> px.</li>
				<li>Lastly, set the <code>200</code> px.</li>
			</ol>
			<p>Great work – the UI layout is finished. The complete scene tree should look like this:</p>
			<div><div><img alt="Figure 10.11 – The complete scene tree of our menu" src="img/B19358_10_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – The complete scene tree of our menu</p>
			<p>The only thing <a id="_idIndexMarker566"/>left to do is to make the buttons functional! Let us do that real quick:</p>
			<ol>
				<li>Add an empty script to the root <code>menu.gd</code>.</li>
				<li>Now, connect the pressed signal of the <strong class="bold">PlayButton</strong> node to this node.<p class="list-inset">The body of the connected function is quite simple:</p><pre class="source-code">
func _on_play_button_pressed():
   get_tree().change_scene_to_file("res://screens/game/main.tscn")</pre></li>				<li>Also, connect the pressed signal of the <strong class="bold">ExitButton</strong> node.<p class="list-inset">The body of this function is even simpler:</p><pre class="source-code">
func _on_exit_button_pressed():
   get_tree().quit()</pre></li>			</ol>
			<p>In the preceding code snippets, we reached out to the root of the scene tree with <code>get_tree()</code>. This function returns <code>SceneTree</code>, the object that manages the whole hierarchy of nodes while the game is running.</p>
			<p>In the function that is connected to the <code>change_scene_to_file()</code> function on this object, which switches out the current running scene to the one that is specified by the path we provide to the function. So, to start the main game scene, we just give it the path, starting from the root of the project, to the <code>main.tscn</code> scene.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">It’s good to note that from the moment it is called, <code>change_scene_to file()</code> will also load the scene file it is supposed to switch to. This means that the game will block or freeze for this loading duration. This is not great when we are switching to a big scene, which we luckily are not doing in our case.</p>
			<p>In the function<a id="_idIndexMarker567"/> that is connected to the <code>quit()</code> function, which simply shits down the runtime.</p>
			<p>You can now try out the menu by running it!</p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor638"/>Setting the main scene</h2>
			<p>To make sure our <a id="_idIndexMarker568"/>menu is the main scene that boots up the game, we’ll quickly need to step into the project settings to declare this. In the project settings, under <code>menu.tscn</code> is the main scene:</p>
			<div><div><img alt="Figure 10.12 – Setting the main scene in the project settings" src="img/B19358_10_12.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – Setting the main scene in the project settings</p>
			<p>This will make sure that when we run the game, using the <code>menu.tscn</code> scene is the scene that gets launched by default.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Remember that when there is no main scene set and we run the game through the aforementioned methods, Godot will ask us if we want to use the currently opened scene as the main scene.</p>
			<p>We learned a<a id="_idIndexMarker569"/> lot about <strong class="bold">Control</strong> nodes and how to use them to quickly construct UIs. Let’s go and make some enemies.</p>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor639"/>Making enemies</h1>
			<p>In real life, making<a id="_idIndexMarker570"/> enemies is never a good idea. But in the context of video game development, it is often a great way to challenge the player and put them against some opposition.</p>
			<p>The enemy that we will be creating is fairly simple and straightforward. But we will still learn a lot along the way – for example, how to let enemies navigate toward the player to attack them.</p>
			<p>Like I said, we’ll keep the enemy simple. We’ll be making an enemy that spawns at a random time in a random spot of the arena and starts charging toward the player. From the moment the enemy touches the player, we’ll deduct one health point from the player’s life and remove the enemy from the game. This way, the player has some adversaries but should not get overwhelmed by a horde of enemies.</p>
			<p>In the following <a id="_idIndexMarker571"/>section, <em class="italic">Shooting projectiles</em>, we’ll develop a way for the player to defend themselves. But for now, we’ll solely focus on the enemy and its behavior.</p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor640"/>Constructing the base scene</h2>
			<p>As with any new <a id="_idIndexMarker572"/>part of our game, let’s start by creating the base structure in a scene tree for the enemy and add code and other interesting things later in the section:</p>
			<ol>
				<li>Create a <code>parts/enemy</code> folder, and within it, create a new scene called <code>enemy.tscn</code>.</li>
				<li>Recreate the following scene tree. Note that the root is a <strong class="bold">CharacterBody</strong> node:</li>
			</ol>
			<div><div><img alt="Figure 10.13 – The scene tree of our Enemy scene" src="img/B19358_10_13.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.13 – The scene tree of our Enemy scene</p>
			<ol>
				<li value="3">Choose a sprite from the <code>assets/sprites/enemies</code> folder as the texture for the <strong class="bold">Sprite2D</strong> node:</li>
			</ol>
			<div><div><img alt="Figure 10.14 – The Enemy scene in the 2D editor" src="img/B19358_10_14.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.14 – The Enemy scene in the 2D editor</p>
			<ol>
				<li value="4">Make sure you set the scale of the sprite node to <code>(</code><code>3, 3)</code>.</li>
			</ol>
			<p>For the <a id="_idIndexMarker573"/>moment, the <code>Enemy</code> scene is very simple. Let’s look into how we could do navigation to complexify it a little bit.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor641"/>Navigating enemies</h2>
			<p>We can easily <a id="_idIndexMarker574"/>make enemies move directly toward the player. The problem with this is that they will get stuck behind walls and bump into boulders, which doesn’t feel very natural and makes them look quite dumb.</p>
			<p>Luckily, the Godot engine comes with a <strong class="bold">NavigationServer</strong> property that calculates a path around all these obstacles and makes enemy movement more natural and fluent.</p>
			<p>To accomplish this, we will look at<a id="_idIndexMarker575"/> two new nodes: <code>NavigationRegion2D</code> and <code>NavigationAgent2D</code>.</p>
			<h3>Creating a NavigationRegion2D node</h3>
			<p>Firstly, we need to <a id="_idIndexMarker576"/>define in what region of the<a id="_idIndexMarker577"/> level our enemy can move around, then we want to cut out spots where a wall or boulder is situated from this region. This is exactly what the <code>NavigationRegion2D</code> node does! Let’s define one:</p>
			<ol>
				<li>Go to the <code>main.tscn</code> game scene.</li>
				<li>In the root node called <code>Main</code>, add a <code>NavigationRegion2D</code> node.</li>
				<li>Click on the empty <strong class="bold">Navigation Polygon</strong> property and select <strong class="bold">New NavigationPolygon</strong>:</li>
			</ol>
			<div><div><img alt="Figure 10.15 – Clicking on New NavigationPolygon" src="img/B19358_10_15.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.15 – Clicking on New NavigationPolygon</p>
			<ol>
				<li value="4">Now, we’ll first define the outer bounds of where enemies will be able to move. Draw a polygon shape by clicking in the editor. Try to trace the outside of the arena closely. Don’t forget to close the shape by clicking the first point you placed:</li>
			</ol>
			<div><div><img alt="Figure 10.16 – Creating the outer bounds of the NavigationRegion2D node" src="img/B19358_10_16.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.16 – Creating the outer bounds of the NavigationRegion2D node</p>
			<ol>
				<li value="5">Press <strong class="bold">Bake NavigationPolygon</strong> at the <a id="_idIndexMarker578"/>top of the window to create a navigation<a id="_idIndexMarker579"/> polygon:</li>
			</ol>
			<div><div><img alt="Figure 10.17 – Pressing Bake NavigationPolygon" src="img/B19358_10_17.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.17 – Pressing Bake NavigationPolygon</p>
			<p>After following these steps, the <code>NavigationRegion2D</code> node should look like this:</p>
			<div><div><img alt="Figure 10.18 – The NavigationRegion2D node after baking the polygon for the first time" src="img/B19358_10_18.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.18 – The NavigationRegion2D node after baking the polygon for the first time</p>
			<p>The blue/greenish area is where enemies will be able to navigate and move in. But you can already see a <a id="_idIndexMarker580"/>problem – this region also spans<a id="_idIndexMarker581"/> over our walls and boulders. We don’t want enemies to think that they can walk through them because, well, they can’t; they are static physics bodies. Luckily, Godot has the functionality to automatically detect these and bake the <code>NavigationPolygon</code> property in such a way that it takes them into account.</p>
			<p>Unfold the <code>NavigationRegion2D</code> node by clicking on it and configure it as follows:</p>
			<ol>
				<li>Set <strong class="bold">Geometry</strong> | <strong class="bold">Parsed Geometry Type</strong> to <strong class="bold">Static Colliders</strong>. We do this to only consider static colliders in the automatic generation.</li>
				<li>Set <strong class="bold">Geometry</strong> | <strong class="bold">Source Geometry Mode</strong> to <strong class="bold">Group With Children</strong>. This way, the automatic generation will scan through the children of nodes to find the static colliders.</li>
				<li>Set <code>40</code> px. With this, we define the radius of the agents we want to use in the <code>NavigationRegion2D</code> node, and the automatic generation can take this into account so that agents don’t bump into obstacles they should be able to avoid:</li>
			</ol>
			<div><div><img alt="Figure 10.19 – Configuring the NavigationPolygon property" src="img/B19358_10_19.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.19 – Configuring the NavigationPolygon property</p>
			<ol>
				<li value="4">Select <a id="_idIndexMarker582"/>the <code>Arena</code> node<a id="_idIndexMarker583"/> and switch to the <strong class="bold">Node</strong> tab, next to the <strong class="bold">Inspector</strong> tab:</li>
			</ol>
			<div><div><img alt="Figure 10.20 – Going to the Node tab" src="img/B19358_10_20.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.20 – Going to the Node tab</p>
			<ol>
				<li value="5">Switch to<a id="_idIndexMarker584"/> the <strong class="bold">Groups</strong> tab, which is<a id="_idIndexMarker585"/> next to the <strong class="bold">Signals</strong> tab:</li>
			</ol>
			<div><div><img alt="Figure 10.21 – Switching to the Groups tab" src="img/B19358_10_21.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.21 – Switching to the Groups tab</p>
			<ol>
				<li value="6">Paste <code>navigation_polygon_source_geometry_group</code> into the text field and press <strong class="bold">Add</strong>:</li>
			</ol>
			<div><div><img alt="Figure 10.22 – Adding the navigation_polygon_source_geometry_group group" src="img/B19358_10_22.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.22 – Adding the navigation_polygon_source_geometry_group group</p>
			<ol>
				<li value="7">Now, select the <code>NavigationRegion2D</code> node again and press <strong class="bold">Bake </strong><strong class="bold">NavigationPolygon</strong> again.</li>
			</ol>
			<p>When you are<a id="_idIndexMarker586"/> done, the navigation region should <a id="_idIndexMarker587"/>look like this:</p>
			<div><div><img alt="Figure 10.23 – The resulting NavigationRegion2D node" src="img/B19358_10_23.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.23 – The resulting NavigationRegion2D node</p>
			<p>The blue/greenish region now nicely avoids walls and boulders. You can also see that there is some margin between obstacles and where the region begins. This is what we set up when defining the <strong class="bold">Radius</strong> property of the agents. This margin makes sure the pathfinding doesn’t come too close to obstacles, making enemies avoid colliding with them.</p>
			<p>In <em class="italic">steps 2</em> to <em class="italic">4</em>, we added the <code>Arena</code> node to<a id="_idIndexMarker588"/> a <code>navigation_polygon_source_geometry_group</code> node group and consider the static bodies <a id="_idIndexMarker589"/>within<a id="_idIndexMarker590"/> them. Let’s take a small detour to talk about node groups.</p>
			<h3>What are node groups?</h3>
			<p><strong class="bold">Groups</strong> or <strong class="bold">node groups</strong> in the <a id="_idIndexMarker591"/>Godot engine are like tags in other pieces of <a id="_idIndexMarker592"/>software. You can add any number of groups to a node. We can simply do this through the <strong class="bold">Groups</strong> tab, just like we did in the steps of the last section.</p>
			<p>Groups are extremely useful because you can, for example, do the following:</p>
			<ul>
				<li>Check if a node is part of a group.</li>
				<li>Get all nodes within a group from the tree.</li>
				<li>Call methods on all nodes within a group.</li>
			</ul>
			<p>We’ll use groups some more later on.</p>
			<p>The <code>NavigationRegion2D</code> node is ready, so now, let’s take a look at the process of adding a <code>NavigationAgent2D</code> node to the <code>Enemy</code> scene.</p>
			<h3>Adding a NavigationAgent2D node to the Enemy scene</h3>
			<p>The last <a id="_idIndexMarker593"/>thing we <a id="_idIndexMarker594"/>need<a id="_idIndexMarker595"/> to add to the <code>enemy.tscn</code> scene from within the editor before starting to write code is a <code>NavigationAgent2D</code> node. This node handles pathfinding and navigation within the <code>NavigationRegion2D</code> node that we created in the previous section.</p>
			<p>Just add a <code>NavigationAgent2D</code> node in the root <code>Enemy</code> node. We don’t have to do any other setup:</p>
			<div><div><img alt="Figure 10.24 – Adding a NavigationAgent2D node to the Enemy scene" src="img/B19358_10_24.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.24 – Adding a NavigationAgent2D node to the Enemy scene</p>
			<p>Now, we<a id="_idIndexMarker596"/> can start writing <a id="_idIndexMarker597"/>the <a id="_idIndexMarker598"/>code for our enemy!</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor642"/>Writing the enemy script</h2>
			<p>The code for our<a id="_idIndexMarker599"/> enemy is going to be very similar to the code for our player. They both walk around based on the physics of an accelerating velocity. The only difference is that for the enemy, the position where it wants to move is defined by the <code>NavigationServer</code> property. This server looks at the <code>NavigationRegion2D</code> node and the current position of the <code>NavigationAgent2D</code> node to calculate the best route with the point on the map we choose to go to.</p>
			<p>Let’s start out by writing some boilerplate code that defines some of our enemy’s movement:</p>
			<pre class="source-code">
class_name Enemy extends CharacterBody2D
@onready var _navigation_agent_2d: NavigationAgent2D = $NavigationAgent2D
@export var max_speed: float = 400.0
@export var acceleration: float = 1500.0
@export var deceleration: float = 1500.0
var player: Player
func _physics_process(delta: float):
   <strong class="bold">_navigation_agent_2d.target_position = player.global_position</strong>
   if <strong class="bold">_navigation_agent_2d.is_navigation_finished()</strong>:
      velocity = velocity.move_toward(Vector2.ZERO, deceleration * delta)
   else:
      <strong class="bold">var next_position: Vector2 = _navigation_agent_2d.get_next_path_position()</strong>
      var direction_to_next_position: Vector2 = global_position.direction_to(next_position)
      velocity = velocity.move_toward(direction_to_next_position * max_speed, acceleration * delta)
   move_and_slide()</pre>			<p>In general, this code is <a id="_idIndexMarker600"/>very similar to the movement code that we wrote for the <code>player.gd</code> script. The only difference is that we now use the <code>NavigationAgent2D</code> node to say where we need to go:</p>
			<pre class="source-code">
_navigation_agent_2d.target_position = target.global_position</pre>			<p>As you can see, we are going toward the global position of the <code>player</code> variable. We’ll define this <code>player</code> variable in a bit.</p>
			<p class="callout-heading">Position and global_position</p>
			<p class="callout">The <code>position</code> variable of a <code>global_position</code> variable, on the other hand, is the position of the node in world space, relative to the root of the scene tree. Both get automatically updated when the node moves in 2D space; it is basically the same data but with a different point of reference.</p>
			<p class="callout">We need to use the <code>global_position</code> variable here because the target position of a <code>NavigationAgent2D</code> node has to be a global position.</p>
			<p>Then, we need to check whether we need to move or not:</p>
			<pre class="source-code">
if _navigation_agent_2d.is_navigation_finished():</pre>			<p>If we need to move, we ask the <code>NavigationAgent2D</code> node what the next position we should move to is:</p>
			<pre class="source-code">
var next_position: Vector2 = _navigation_agent_2d.get_next_path_position()</pre>			<p>Then, all we need to do is calculate the direction from our current position to this next position, and the rest of the code is exactly the same as for the <code>Player</code> scene from <a href="B19358_07.xhtml#_idTextAnchor523"><em class="italic">Chapter 7</em></a>.</p>
			<p>To select the <code>Player</code> node, we<a id="_idIndexMarker601"/> are going to use node groups by adding this <code>_ready()</code> function:</p>
			<pre class="source-code">
func _ready():
   var player_nodes: Array = <strong class="bold">get_tree().get_nodes_in_group("player")</strong>
   if not player_nodes.is_empty():
      target = player_nodes[0]</pre>			<p>To get the player from within the scene tree, we do something new. We ask the current scene tree for all nodes that are in the <code>player</code> group. This function will return an array with nodes that belong to this group. So, we’ll have to take the first element, if there is any.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">It might look weird to ask for all the player nodes in the scene while there is only one. We do this so that we can use roughly the same code to target more players when we deal with multiple players in the next chapter.</p>
			<p>These node groups are a useful feature of the Godot engine because the engine will keep track of all nodes within a group so that we can easily query them or check if a node belongs to a certain group.</p>
			<p>Now, this code will not work yet because, well, the player is actually not yet in the <code>player</code> group! To add them to this group, we need to alter the <code>Player</code> scene a little:</p>
			<ol>
				<li>Go to the <code>player.tscn</code> scene.</li>
				<li>Select the root node.</li>
				<li>In the window that contains the node’s signals, there is a button called <strong class="bold">Groups</strong>. Press it, and you will see the <strong class="bold">Groups</strong> window:</li>
			</ol>
			<div><div><img alt="Figure 10.25 – Adding the player’s root node to the node group called player" src="img/B19358_10_25.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.25 – Adding the player’s root node to the node group called player</p>
			<ol>
				<li value="4">Here, type <code>player</code> into the line input and press <strong class="bold">Add</strong>.</li>
			</ol>
			<p>Put an enemy in the<a id="_idIndexMarker602"/> main scene, and you will see that it starts moving toward the player! This is great. But enemies should be able to damage the player, so let’s work on that next.</p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor643"/>Damaging the player in a collision</h2>
			<p>To detect if an <a id="_idIndexMarker603"/>enemy is close enough to the player to deal damage, we are going to use an <strong class="bold">Area2D</strong> node, as we did for collectibles in <a href="B19358_09.xhtml#_idTextAnchor590"><em class="italic">Chapter 9</em></a>:</p>
			<ol>
				<li>Let’s start by adding a <code>get</code><code>_hit()</code> function to the <code>player.gd</code> script. This function will get called when the player is hit by an enemy and lower the health of the player:<pre class="source-code">
func hit():
   health -= 1</pre></li>				<li>Add an <code>enemy.tscn</code> scene and call it <code>PlayerDetectionArea</code>.</li>
				<li>Under this area, add a <strong class="bold">CollisionShape2D</strong> node:</li>
			</ol>
			<div><div><img alt="Figure 10.26 – Adding an Area2D node to the Enemy scene" src="img/B19358_10_26.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.26 – Adding an Area2D node to the Enemy scene</p>
			<ol>
				<li value="4">Make this <a id="_idIndexMarker604"/>collision shape a <strong class="bold">CircleShape2D</strong> node that is a little bigger than the enemy’s sprite:</li>
			</ol>
			<div><div><img alt="Figure 10.27 – Covering the whole enemy with some margin with the CollisionShape2D node" src="img/B19358_10_27.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.27 – Covering the whole enemy with some margin with the CollisionShape2D node</p>
			<ol>
				<li value="5">Connect the <code>body_entered</code> signal to the root node of the enemy.</li>
				<li>Now, use the next snippet of code as the body of the connected function in the enemy’s script:<pre class="source-code">
func _on_player_detection_area_body_entered(body: Node2D):
   if not body.is_in_group("player"):
      return
   body.get_hit()
   queue_free()</pre></li>			</ol>
			<p>The code of this function is straightforward. First, we check if the body that entered the area actually is the player. We can do this simply with the following check:</p>
			<pre class="source-code">
body.is_in_group("player")</pre>			<p>This way, we can check whether a certain node is in a certain group. If this body is not in the <code>player</code> group, we return out of the function.</p>
			<p>But if the body is a player node, then we remove one point from its health and free the enemy that made contact.</p>
			<p>Great – our enemy can now damage the player when it comes close enough. There is only one more problem: there are only as many enemies as we can drag and drop into the scene. Enemies should be able to spawn automatically and constantly! Otherwise, the game would <a id="_idIndexMarker605"/>be over very quickly. Let’s make an automatic spawner that spawns enemies but also health potions.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor644"/>Spawning enemies and collectibles</h2>
			<p>To automatically <a id="_idIndexMarker606"/>spawn enemies or collectibles in our playfield is actually harder than it looks at first sight. We can randomly pick a location and spawn something there. Doing this, however, could spawn an enemy or a collectible within a wall or boulder. Even worse, the enemy or collectible could spawn miles away from the arena and the navigation region, rendering them useless.</p>
			<p>We could solve this in many smart and abstract ways, but often, the simplest way is the best to start out with. That is why we’ll construct our own entity spawner that can spawn different kinds of entities, enemies, collectibles, or anything else.</p>
			<h3>Creating the scene structure</h3>
			<p>An easier way<a id="_idIndexMarker607"/> of solving the problem of the location of enemy spawning is by defining certain points within the arena at which we are sure the enemy can safely spawn. So, that is what we are going to do in the following steps:</p>
			<ol>
				<li>Create a new scene that derives from the <code>EntitySpawner</code>.</li>
				<li>Save this scene as <code>entity_spawner.tscn</code> under <code>parts/entity_spawner</code>.</li>
				<li>Under <code>EntitySpawner</code>, add another <code>Positions</code>. Here we’ll later define all positions where we can spawn something:</li>
			</ol>
			<div><div><img alt="Figure 10.28 – The structure for our EntitySpawner scene" src="img/B19358_10_28.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.28 – The structure for our EntitySpawner scene</p>
			<ol>
				<li value="4">Drag and drop an instance of <code>EntitySpawner</code> into the <code>main.tscn</code> scene and rename it <code>EnemySpawner</code>.</li>
				<li>Now, right-click <code>EnemySpawner</code> and select <strong class="bold">Editable Children</strong>:</li>
			</ol>
			<div><div><img alt="Figure 10.29 – Enabling Editable Children to directly edit the children of an instanced scene" src="img/B19358_10_29.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.29 – Enabling Editable Children to directly edit the children of an instanced scene</p>
			<p class="list-inset">You will see <a id="_idIndexMarker608"/>the <code>EnemySpawner</code> scene:</p>
			<div><div><img alt="Figure 10.30 – Adding Marker2D nodes that will be used to position enemies" src="img/B19358_10_30.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.30 – Adding Marker2D nodes that will be used to position enemies</p>
			<ol>
				<li value="6">Now, under this <strong class="bold">Positions</strong> node, add multiple <strong class="bold">Marker2D</strong> nodes and place them at <a id="_idIndexMarker609"/>locations where you want enemies to be able to spawn:</li>
			</ol>
			<div><div><img alt="Figure 10.31 – The different positions at which I wanted enemies to spawn" src="img/B19358_10_31.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.31 – The different positions at which I wanted enemies to spawn</p>
			<p>The <code>EnemySpawner</code> node was pretty simple to set up until now, but we did use some new things. Firstly, we enabled <strong class="bold">Editable Children</strong> on a node that is a complete scene. This exposes that whole scene’s structure to us and makes it easy for us to edit the individual nodes within. This is very useful for reusing scenes very directly.</p>
			<p>Note that the nodes under the <code>EnemySpawner</code> node are grayed out. This means that we can edit them, move them around, and such, just like when we inherited from the collectible scene to make the health potion, but we cannot delete these grayed-out nodes.</p>
			<p>Next to editing the children, we used a new node type: <strong class="bold">Marker2D</strong>. This is a node that actually does<a id="_idIndexMarker610"/> nothing special during the game, but in the editor, it will display a little cross to mark the location it is positioned at. This node gets used if you need to mark a position like we are doing here.</p>
			<h3>Writing the base code</h3>
			<p>For the code, we’ll do <a id="_idIndexMarker611"/>something pretty simple and provide a <code>spawn_entity()</code> function that spawns a new entity, be it an enemy or a health potion, at one of the defined positions:</p>
			<pre class="source-code">
extends Node2D
<strong class="bold">@export var entity_scene: PackedScene</strong>
@onready var _positions: Node2D = $Positions
func spawn_entity():
   var random_position: Marker2D = _positions.get_children().pick_random()
   var new_entity: Node2D = <strong class="bold">entity_scene.instantiate()</strong>
   new_entity.position = random_position.position
   add_child(new_entity)</pre>			<p>The first new thing that we encounter is an exported variable of the <code>PackedScene</code> type. This <code>PackedScene</code> variable is basically the definition of any scene – a scene file. Any scene file can fill this variable.</p>
			<p class="callout-heading">Difference between a PackedScene variable and a Node variable</p>
			<p class="callout">A <code>PackedScene</code> variable represents a scene file, such as the <code>enemy.tscn</code> file. It is a template that we can use to create new nodes from.</p>
			<p class="callout">A <code>Node</code> variable, on the other hand, is a building block of the scene tree and can be an instance of a <code>PackedScene</code> variable.</p>
			<p class="callout">You could see a <code>PackedScene</code> variable as a class, while a <code>Node</code> variable is an instanced object of that class.</p>
			<p>Then, later, we can use this packed scene to instantiate a new entity:</p>
			<pre class="source-code">
var new_entity: Node2D = entity_scene<strong class="bold">.instantiate()</strong></pre>			<p>The last thing we need to do to make this new instanced entity a part of the scene tree is to add it to an existing node within the tree because if we don’t add it somewhere within the scene tree, it is not used within the game or its execution.</p>
			<p>We can add a new node as a child to another node by calling the <code>add_child()</code> function on any node within the tree with this new entity node as the parameter. The entity will then get added as a child to that node. Here, we add the entity node to <code>EntitySpawner</code>:</p>
			<pre class="source-code">
<strong class="bold">add_child</strong>(new_entity)</pre>			<p>Now, the entity is truly put into the tree and thus within the game.</p>
			<p>To select a<a id="_idIndexMarker612"/> random position, we also do something new. First, we get an array of children from the <code>get_children()</code>, which is an array of position markers. Then, to pick a random element from this array, we can make use of the <code>pick_random()</code> function to easily select one random position marker:</p>
			<pre class="source-code">
var random_position: Marker2D = _positions.get_children().<strong class="bold">pick_random()</strong></pre>			<p>This will provide us with a <strong class="bold">Marker2D</strong> node at random that we can use to spawn the enemy.</p>
			<p>To make our <code>EnemySpawner</code> node that is in the <code>main.tscn</code> scene spawn enemies, we just need to drag and drop the <code>enemy.tscn</code> scene on top of the <code>EnemySpawner</code> node:</p>
			<div><div><img alt="Figure 10.32 – Dragging and dropping the enemy.tscn file into the Entity Scene property" src="img/B19358_10_32.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.32 – Dragging and dropping the enemy.tscn file into the Entity Scene property</p>
			<p>With this set <a id="_idIndexMarker613"/>up, we can start spawning entities at a fixed time interval.</p>
			<h3>Automatically spawning entities</h3>
			<p>Now that we have<a id="_idIndexMarker614"/> a function that can spawn an entity, we still need to trigger it at some point. To do this, we are going to make use of the <code>timeout</code> signal when the timer runs out.</p>
			<p>Let’s add a <code>EntitySpawner</code> scene:</p>
			<ol>
				<li>Add a <code>entity_spawner.tscn</code> scene file and call it <code>SpawnTimer</code>.</li>
				<li>Now, connect the timeout signal to the <code>EntitySpawner</code> root node.</li>
				<li>In the connected function, just call the <code>spawn_entity()</code> function:<pre class="source-code">
func _on_spawn_timer_timeout():
   spawn_entity()</pre></li>				<li>Add a reference to the <code>SpawnTimer</code> node and an <code>export</code> variable that will represent the interval at which we’ll spawn entities at the top of the script:<pre class="source-code">
@onready var _spawn_timer: Timer = $SpawnTimer
@export var spawn_interval: float = 1.5</pre></li>				<li>Now, we can add two extra functions that help us start and stop the timer:<pre class="source-code">
func start_timer():
   _spawn_timer.start(spawn_interval)
func stop_timer():
   _spawn_timer.stop()</pre></li>				<li>Lastly, to autostart the timer at the start of the game, add this <code>_ready()</code> function to the <code>EntitySpawner</code> script:<pre class="source-code">
func _ready():
   start_timer()</pre></li>			</ol>
			<p class="callout-heading">Important note</p>
			<p class="callout">Remember – when we talk about a scene, we talk about a whole scene file, such as the <code>entity_spawner.tscn</code> file. When we talk about a node, we are talking about a specific node within the scene file, such as the <code>EntitySpawner</code> node.</p>
			<p>The start and stop functions will help when we want to stop enemies from spawning when the player dies, for example. In the body, they just start and stop <code>_spawn_timer</code> directly. You can see that when starting a timer, we can give a time in seconds that will be used as the amount of time before the timer runs out.</p>
			<p>Running the game<a id="_idIndexMarker615"/> now, we’ll get a new enemy every 1.5 seconds. Great! Now that we have a stream of enemies coming in, let’s spawn some potions so that the player can heal themselves.</p>
			<h3>Spawning health potions</h3>
			<p>To spawn health<a id="_idIndexMarker616"/> potion collectibles, we can easily use the same <code>EntitySpawner</code> node that we just constructed! Here’s how:</p>
			<ol>
				<li>Add a new <code>EntitySpawner</code> node to the <code>main.tscn</code> scene and call it <code>HealthPotionSpawner</code>.</li>
				<li>Make this spawner’s children editable and add <strong class="bold">Marker2D</strong> nodes to the <strong class="bold">Positions</strong> node at which you want to spawn health potions:</li>
			</ol>
			<div><div><img alt="Figure 10.33 – Adding Marker2D nodes where I would like to spawn health potions" src="img/B19358_10_34.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.33 – Adding Marker2D nodes where I would like to spawn health potions</p>
			<ol>
				<li value="3">Drag and drop the <code>health_potion.tscn</code> scene into the <code>Entity Scene</code> property of the spawner.</li>
				<li>Set the <strong class="bold">Spawn Interval</strong> value <a id="_idIndexMarker617"/>of the spawner to a bigger number, such as 20, so that we don’t spawn too many health potions:</li>
			</ol>
			<div><div><img alt="Figure 10.34 – Setting the Spawn Interval value to 20 seconds" src="img/B19358_10_35.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.34 – Setting the Spawn Interval value to 20 seconds</p>
			<p>That is it! Spawning <a id="_idIndexMarker618"/>new things is easy if we create a scene, <code>EntitySpawner</code>, that is easily reusable for it, isn’t it?</p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor645"/>Making a Game Over screen</h2>
			<p>Now that enemies <a id="_idIndexMarker619"/>can damage the player and the player’s health goes down, we need to account for the scenario where the player’s health reaches 0. This would mean the end of the game. We’ll add a little <code>Game Over</code> screen that gives the player the option to retry or go back to the main menu after dying.</p>
			<h3>Creating the base scene</h3>
			<p>As always, we’ll start <a id="_idIndexMarker620"/>off by creating the scene structure:</p>
			<ol>
				<li>Create a new scene that has a <code>GameOverMenu</code>, and save the scene as <code>game_over_menu.tscn</code> in <code>parts/game_over_scene</code>.</li>
				<li>Recreate the following scene structure:</li>
			</ol>
			<div><div><img alt="Figure 10.35 – The scene tree for the Game Over menu" src="img/B19358_10_36.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.35 – The scene tree for the Game Over menu</p>
			<ol>
				<li value="3">Fill each element with the right text, enlarge the <code>GameOverLabel</code> node, and add some separation to the <strong class="bold">VBoxContainer</strong> node that holds<a id="_idIndexMarker621"/> the two buttons. Make it so that the UI looks like this:</li>
			</ol>
			<div><div><img alt="Figure 10.36 – What the Game Over menu will look like" src="img/B19358_10_37.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.36 – What the Game Over menu will look like</p>
			<ol>
				<li value="4">Now, select the <code>GameOverMenu</code> root node and set its <strong class="bold">Anchor preset</strong> type to <strong class="bold">Full Rect</strong>:</li>
			</ol>
			<div><div><img alt="Figure 10.37 – Choosing Full Rect from the Anchor presets list" src="img/B19358_10_38.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.37 – Choosing Full Rect from the Anchor presets list</p>
			<p>Now that we <a id="_idIndexMarker622"/>have a little menu, let’s add it to the <code>main.tscn</code> scene:</p>
			<ol>
				<li>In the <code>main.tscn</code> scene, add a <code>CanvasLayer</code> node.</li>
				<li>Under this <code>CanvasLayer</code> node, add our freshly created <code>GameOverMenu</code> node:</li>
			</ol>
			<div><div><img alt="Figure 10.38 – The GameOverMenu node added to the scene tree" src="img/B19358_10_39.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.38 – The GameOverMenu node added to the scene tree</p>
			<ol>
				<li value="3">Now, hide the <code>GameOverMenu</code> node by clicking the eye symbol next to the name of the node. We only want to show this menu when the player is dead:</li>
			</ol>
			<div><div><img alt="Figure 10.39 – Hiding the GameOverMenu node by clicking the eye symbol next to its name" src="img/B19358_10_40.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.39 – Hiding the GameOverMenu node by clicking the eye symbol next to its name</p>
			<p>We use a <code>CanvasLayer</code> node to display our menu here because this node makes sure that all its children are displayed on top of everything else. The <code>CanvasLayer</code> node does not adhere to the display order that is determined by the scene tree order of the nodes. Within the <code>CanvasLayer</code> node, its children do again adhere to this order. This makes<a id="_idIndexMarker623"/> the <code>CanvasLayer</code> node very suitable for UIs within the game itself.</p>
			<p>That was it for the base scene structure; now, we should add some logic to the menu.</p>
			<h3>Adding logic to the Game Over menu</h3>
			<p>The script for <a id="_idIndexMarker624"/>the <code>GameOverMenu</code> node is very simple. All we want to do is add functionality when the buttons are pressed. When the <strong class="bold">Play</strong> button is pressed, we reload the main game scene, and when the menu button is pressed, we go back to the main menu.</p>
			<p>So, connect both buttons and load the right scene in each of their connected functions:</p>
			<pre class="source-code">
extends CenterContainer
func _on_retry_button_pressed() -&gt; void:
   get_tree().reload_current_scene()
func _on_menu_button_pressed() -&gt; void:
   get_tree().change_scene_to_file("res://screens/ui/menu.tscn")</pre>			<p class="callout-heading">Important note</p>
			<p class="callout">Note that we used a new function, <code>reload_current_scene()</code>, on the tree. This function is very similar to <code>change_scene_to_file()</code>, except it will just change to the same scene as we are currently in, and we don’t have to load the scene file as it is obviously already loaded.</p>
			<p>The <strong class="bold">Game Over</strong> menu<a id="_idIndexMarker625"/> is ready; now, we just need to make use of it within the game.</p>
			<h3>Showing the Game Over menu when the player dies</h3>
			<p>We have seen<a id="_idIndexMarker626"/> how we can connect to signals that nodes throw. But we can also make and throw our own signals! We’ll make use of this to detect when the player dies:</p>
			<ol>
				<li>In the <code>player.gd</code> script, right under the line that carries the <code>extends</code> keyword, add our new signal:<pre class="source-code">
class_name Player extends CharacterBody2D
<code>health</code> setter when <code>health</code> equals <code>0</code>:<pre class="source-code">
   set(new_value):
      var new_health: int = clamp(new_value, 0, MAX_HEALTH)
      if health &gt; 0 and new_health == 0:
         <strong class="bold">died.emit()</strong>
         <strong class="bold">set_physics_process(false)</strong>
      health = new_health
      update_health_label()</pre></li>			</ol>
			<p>You can see that to define a new signal, we just need to use the <code>signal</code> keyword, followed by the name of the signal.</p>
			<p>Then, later on, we can just emit this signal by calling the <code>emit()</code> function on it. In a way, a signal is also a variable.</p>
			<p>To check whether the player died, we check whether the current <code>health</code> value is greater than 0 and the <code>new_health</code> value is 0. This way, we are sure that we only trigger the <code>died</code> signal once, when the player goes from a living to a dead state. We don’t want this signal thrown multiple times because that would signal the game that the player died more than once and create unwanted side effects.</p>
			<p>Then, we also use the <code>set_physics_process()</code> function and give it <code>false</code> as the only parameter. This tells the node if it should stop executing the <code>_physics_process()</code> function and will effectively stop the player from moving because that is where all our movement code lives.</p>
			<p>Now that the <code>Player</code> node throws a signal when it dies, we can hook into this with the <code>main.tscn</code> scene:</p>
			<ol>
				<li>In <a id="_idIndexMarker627"/>the <code>main.tscn</code> scene, select the <code>Player</code> node. You’ll see that a new signal has appeared – the <code>died</code> signal that we defined in the <code>player.gd</code> script:</li>
			</ol>
			<div><div><img alt="Figure 10.40 – The signal we defined in the player’s script also turns up in the signal menu" src="img/B19358_10_41.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.40 – The signal we defined in the player’s script also turns up in the signal menu</p>
			<ol>
				<li value="2">Add an empty script to the <code>Main</code> node of the <code>main.tscn</code> scene and connect the <code>died</code> signal to it.</li>
				<li>In the connected function, we should show the <code>GameOverMenu</code> node and stop the <code>EnemySpawner</code> node and <code>HealthPotionSpawner</code>:<pre class="source-code">
extends Node2D
@onready var _game_over_menu: CenterContainer = $CanvasLayer/GameOverMenu
@onready var _enemy_spawner: Node2D = $EnemySpawner
@onready var _health_potion_spawner: Node2D = $HealthPotionSpawner
func _on_player_died() -&gt; void:
   _game_over_menu.show()
   _enemy_spawner.stop()
   _health_potion_spawner.stop()</pre></li>			</ol>
			<p>This script is pretty simple because it just needs to handle the menu and stop some spawners.</p>
			<p>We covered a lot of ground in this section. We learned about how we can use the <code>NavigationRegion2D</code> and <code>NavigationAgent2D</code> nodes to make enemies navigate toward the player character. We used <code>PackedScene</code> variables to instance scenes from within the code. We used the <code>CanvasLayer</code> node to show a <strong class="bold">Game Over</strong> menu <a id="_idIndexMarker628"/>on top of the game. We created a custom signal and hooked into it. We had a lot of fun, and now it is time for the player to learn how to defend themselves!</p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor646"/>Shooting projectiles</h1>
			<p>We’ve sent enough <a id="_idIndexMarker629"/>enemies at the player without them being able to defend themselves. Let’s change that in this section! We’ll be creating projectiles the player character automatically shoots at enemies to kill them off. To keep it simple, we’ll make the projectile hone in on the target we are trying to hit; this way, it never misses.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor647"/>Creating the base scene</h2>
			<p>Before we can<a id="_idIndexMarker630"/> shoot the projectiles, we’ll have to construct the base scene we’ll work from. Let’s do that right now with the following steps:</p>
			<ol>
				<li>Create a new scene that has a <code>Projectile</code>.</li>
				<li>Create a scene structure as shown next:</li>
			</ol>
			<div><div><img alt="Figure 10.41 – The scene tree of the projectile scene" src="img/B19358_10_42.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.41 – The scene tree of the projectile scene</p>
			<ol>
				<li value="3">Use one of the textures from <code>assets/sprites/projectils/</code> as the texture for the sprite. Remember to set the scale of the sprite to <code>(</code><code>3, 3)</code>:</li>
			</ol>
			<div><div><img alt="Figure 10.42 – The projectile" src="img/B19358_10_43.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.42 – The projectile</p>
			<ol>
				<li value="4">Now, use a <code>CapsuleShape2D</code> node for the <code>CollisionShape2D</code> node’s shape and make sure it covers the sprite:</li>
			</ol>
			<div><div><img alt="Figure 10.43 – Covering the projectile’s sprite with the CollisionShape2D node" src="img/B19358_10_44.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.43 – Covering the projectile’s sprite with the CollisionShape2D node</p>
			<ol>
				<li value="5">We’ll use the <code>EnemyDetectionArea</code>.</li>
				<li>To detect the <code>Enemy</code> node entering the <code>EnemyDetectionArea</code> area node, name the third <strong class="bold">2D Physics</strong> layer <strong class="bold">Projectile</strong>.</li>
				<li>Set the <code>EnemyDetectionArea</code> area node’s <strong class="bold">Collision Mask</strong> property to detect the <strong class="bold">Projectile</strong> layer:</li>
			</ol>
			<div><div><img alt="Figure 10.44 – The Collision layer configuration for the EnemyDetectionArea area node" src="img/B19358_10_45.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.44 – The Collision layer configuration for the EnemyDetectionArea area node</p>
			<ol>
				<li value="8">In the <code>enemy.tscn</code> scene, set the <code>Enemy</code> node’s <strong class="bold">Collision Layer</strong> property to be on the <strong class="bold">Projectile</strong> layer too:</li>
			</ol>
			<div><div><img alt="Figure 10.45 – The Collision layer configuration for the enemy" src="img/B19358_10_46.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.45 – The Collision layer configuration for the enemy</p>
			<p>This is all we need in<a id="_idIndexMarker632"/> terms of the scene structure, so let’s get to writing the behavior of the projectile.</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor648"/>Writing the logic of the projectile</h2>
			<p>Next up is the code that <a id="_idIndexMarker633"/>steers the projectile toward a target, destroys it on impact, and notifies the enemy it has been hit. We’ll make the projectile always go straight toward its target; this makes it easy for us code-wise:</p>
			<ol>
				<li>Attach a script called <code>projectile.gd</code> to the <code>Projectile</code> root node and fill it with the following code to move it:<pre class="source-code">
class_name Projectile
extends Node2D
@export var speed: float = 600.0
var target: Node2D
func _physics_process(delta: float):
   global_position = global_position.move_toward(target.global_position, speed * delta)
   look_at(target.global_position)</pre><p class="list-inset">We’ve seen most of this code already, except for the <code>look_at()</code> function. This function rotates a node to orient itself toward a point in space that we provide it. So, here, it rotates the projectile node toward the position of the target.</p></li>				<li>Now, connect the <code>body_entered</code> signal from the <code>EnemyDetectionArea</code> node to the projectile’s script. All we need to do in the connected function is to notify the enemy that it got hit and destroy the projectile itself:<pre class="source-code">
func _on_enemy_detection_area_body_entered(body: Node2D):
   body.get_hit()
   queue_free()</pre></li>				<li>Lastly, in the <code>enemy.gd</code> script, add this <code>get_hit()</code> function that we want to use when the projectile hits the enemy:<pre class="source-code">
func get_hit():
   queue_free()</pre></li>			</ol>
			<p>This is all we need <a id="_idIndexMarker634"/>code-wise on the side of the projectile itself.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor649"/>Spawning projectiles</h2>
			<p>We want the projectile<a id="_idIndexMarker635"/> to be shot automatically every so often. To achieve this, we’ll need to make some changes in the <code>Player</code> and <code>Enemy</code> scenes:</p>
			<ol>
				<li>Add a <code>Timer</code> node to the <code>Player</code> scene and call this new node <code>ShootTimer</code>.</li>
				<li>Set the time of this <code>ShootTimer</code> node to <code>0.5</code> and enable <strong class="bold">Autostart</strong>:</li>
			</ol>
			<div><div><img alt="Figure 10.46 – Adding a Timer node called ShootTimer to the Player scene" src="img/B19358_10_47.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.46 – Adding a Timer node called ShootTimer to the Player scene</p>
			<ol>
				<li value="3">Next, in the player’s script, preload the projectile scene at the top:<pre class="source-code">
@export var projectile_scene: PackedScene = preload("res://parts/projectile/projectile.tscn")</pre></li>				<li>While the <code>Player</code> node is selected, drag and drop the <code>projectile.tscn</code> file into the <strong class="bold">Projectile Scene</strong> property in the <strong class="bold">Inspector</strong> tab.</li>
			</ol>
			<p>Just like with the <code>EntitySpawner</code> node, we export a variable of the <code>PackedScene</code> type that we can fill from the editor and instantiate later on when we need it. This time, though, we directly fill it with the <code>projectile.tscn</code> scene. The <code>preload()</code> function loads this<a id="_idIndexMarker636"/> scene and puts it in the <code>projectile_scene</code> variable, ready to be used. But this variable is also exported, which means that if, someday, we want the player to shoot a different kind of projectile, we can drag and drop this scene in the <strong class="bold">Inspector</strong> tab of the player.</p>
			<p>We’ll now add the logic that actually spawns the projectile:</p>
			<ol>
				<li>In the <code>enemy.tscn</code> scene, add the root node to the <code>enemy</code> group as we did for the player. This will make sure we can access all enemy nodes later:</li>
			</ol>
			<div><div><img alt="Figure 10.47 – Adding the enemy node to the enemy group" src="img/B19358_10_48.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.47 – Adding the enemy node to the enemy group</p>
			<ol>
				<li value="2">Add a new <code>export</code> variable to the top of the <code>player.gd</code> script. This variable will represent how far the player can shoot in pixels:<pre class="source-code">
@export var shoot_distance: float = 400.0</pre></li>				<li>Now, connect the timeout signal of the <code>ShootTimer</code> node to the <code>Player</code> node’s script.<p class="list-inset">This should be<a id="_idIndexMarker637"/> the body for the connected signal:</p><pre class="source-code">
func _on_shoot_timer_timeout():
   var closest_enemy: Enemy
   var smallest_distance: float = INF
   var all_enemies: Array = get_tree().get_nodes_in_group("enemy")
   for enemy in all_enemies:
      var distance_to_enemy: float = global_position.distance_to(enemy.global_position)
      if distance_to_enemy &lt; smallest_distance:
         closest_enemy = enemy
         smallest_distance = distance_to_enemy
   if not closest_enemy:
      return
   if smallest_distance &gt; shoot_distance:
      return
   var new_projectile: Projectile = ProjectileScene.instantiate()
   new_projectile.target = closest_enemy
   get_parent().add_child(new_projectile)
   new_projectile.global_position = global_position</pre></li>				<li>We should also<a id="_idIndexMarker638"/> stop the <code>ShootTimer</code> node when the player dies, cache the <code>ShootTimer</code> node at the top of the player script, and stop it when the player’s health reaches 0:<pre class="source-code">
<strong class="bold">@onready var _shoot_timer = $ShootTimer</strong>
@export_range(0, MAX_HEALTH) var health: int = 10:
   set(new_value):
      # Code to update the health
      if health &gt; 0 and new_health == 0:
         # Code when player dies
         <strong class="bold">shoot_timer.stop()</strong></pre></li>			</ol>
			<p>The high-level explanation of this function’s body is that we first get a list of all enemies, using the group functionality. Then, we go over every single one of them to see how far away they are from the player. While doing this loop, we always keep the enemy that is the closest along with that distance. This way, we know that we’ll end up with the enemy that is nearest to the player character.</p>
			<p>The result of this algorithm can result in no enemy being selected. That is why we need to make sure <code>closest_enemy</code> is not accidentally empty and need to return from the function if it is.</p>
			<p>After all this, we create a new projectile, set its target, add it to the scene tree, and put its position to the position of the player.</p>
			<p>That was it for creating projectiles! You can now run the game and start trying to survive as long as possible. We<a id="_idIndexMarker639"/> also saw some more intricate code with an algorithm to find the closest node from any other node and how to preload a scene within a script.</p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor650"/>Storing highscores in autoloads</h1>
			<p>Now that the player <a id="_idIndexMarker640"/>can fight back and survive, we might need to<a id="_idIndexMarker641"/> give the player a goal to attain – something that will make them play again and again. We could add a highscore – for example, the amount of time the player was able to survive. The player can then try to better their own time or compare times with their friends.</p>
			<p>To achieve this, we will be using an autoload. This is a node that gets initialized at the start of the game and will exist throughout the complete execution of the game.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor651"/>Using an autoload</h2>
			<p>The survival time<a id="_idIndexMarker642"/> should be stored somewhere so that it is easily accessible from anywhere within the game. This way, we can change it after the player dies but also display the score on the main menu, for example.</p>
			<p>Normal nodes and scenes have to be managed by us, the programmer. But there is another kind of node that we could use: autoloads. An autoload is a scene or script that is always loaded. The Godot engine initiates this scene for us anytime we run the game.</p>
			<p>A node or script that is autoloaded will exist as long as the game is running. Earlier, when using <code>get_tree().change_scene_to_file()</code> to change scenes, everything of the current scene gets removed from the scene tree and switched out for the new scene. However, autoloads do not share the same faith; they stay put and retain the values of all their variables.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Although autoloads are great, they should not be misused or overused. They should only be used for systems that are truly global, such as the <code>HighscoreManager</code> autoload we are going to create in this section.</p>
			<p>We are not going to store the highscore autoload in a file just yet; we’ll do this in <a href="B19358_15.xhtml#_idTextAnchor740"><em class="italic">Chapter 15</em></a>. For now, we<a id="_idIndexMarker643"/> just want to save and load the highscore autoload while the game is running.</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor652"/>Creating a HighscoreManager autoload</h2>
			<p>To create an <a id="_idIndexMarker644"/>autoload, we first need to create a normal scene or script. Because we don’t really need a whole scene to keep track of a highscore, which is basically just a number, we are going to write a script. When the Godot engine initiates our game, it will create a node and attach our script to it. The following steps illustrate the process of creating an autoload:</p>
			<ol>
				<li>Create a new <code>autoloads/</code> folder in the root of the project.</li>
				<li>Add a new script in this folder called <code>highscore_manager.gd</code>.<p class="list-inset">The <code>HighscoreManager</code> script is going to be pretty simple and straightforward:</p><pre class="source-code">
extends Node
var highscore: int = 0
func set_new_highscore(value: int):
   if value &gt; highscore:
      highscore = value</pre></li>			</ol>
			<p>The preceding code defined a <code>highscore</code> variable and a <code>set_new_highscore()</code>. function. This function checks if the new score is bigger than the current highscore. If it is, we save this new, higher score; otherwise, we don’t need to bother.</p>
			<p>Now, let’s set this script up as an autoload:</p>
			<ol>
				<li>Open the project settings and navigate to the <strong class="bold">Autoload</strong> tab.</li>
				<li>Select the file icon button to search for a file:</li>
			</ol>
			<div><div><img alt="Figure 10.48 – Pressing the folder icon to select a file that you want to load as an autoload" src="img/B19358_10_49.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.48 – Pressing the folder icon to select a file that you want to load as an autoload</p>
			<ol>
				<li value="3">Navigate <a id="_idIndexMarker645"/>to the <code>autoloads/highscore_manager.gd</code> script.</li>
				<li>Select it and press <strong class="bold">Open</strong>.</li>
				<li>Now, back in on the <strong class="bold">Autoload</strong> panel within the project settings, press the <strong class="bold">Add</strong> button.</li>
			</ol>
			<p>That is all for setting up our autoload. You’ll see that the <strong class="bold">Highscore</strong> autoload is now displayed within the list of autoloads:</p>
			<div><div><img alt="Figure 10.49 – The highscore_manager.gd script is loaded as an autoload" src="img/B19358_10_50.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.49 – The highscore_manager.gd script is loaded as an autoload</p>
			<p>Next to seeing the script in the list of autoloads, there is another way we can check whether the<a id="_idIndexMarker646"/> autoload is there.</p>
			<p class="callout-heading">Using a scene as an autoload</p>
			<p class="callout">Both scripts and full scenes can be autoloads. To use a scene, load the scene just like we did for the script just now.</p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor653"/>Autoloads in the remote tree</h2>
			<p>As said earlier, autoloads <a id="_idIndexMarker647"/>get instantiated by the Godot engine when the<a id="_idIndexMarker648"/> game starts running. So, we can’t see them present in separate scenes, but they should be there in the remote tree when we run the game.</p>
			<p>Run the game using the <strong class="bold">Run Project</strong> button or any scene of the game using the <strong class="bold">Run Current Scene</strong> button. Open the remote tree, and you will see a node called <strong class="bold">HighscoreManager</strong>. This is our <strong class="bold">HighscoreManager</strong> autoload!</p>
			<div><div><img alt="Figure 10.50 – We can see the HighscoreManager node in the remote tree" src="img/B19358_10_51.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.50 – We can see the HighscoreManager node in the remote tree</p>
			<p>Now that we set up our <strong class="bold">HighscoreManager</strong> autoload, let’s use it within the game and keep some highscores!</p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor654"/>Adding a UI in the main menu and game scene</h2>
			<p>First, we’ll need to <a id="_idIndexMarker649"/>make sure the<a id="_idIndexMarker650"/> player knows what their score is while playing the game. Because we said that the score would be the amount of time the player is able to survive, we’ll show this score by adding a timer on the screen:</p>
			<ol>
				<li>In the <code>main.tscn</code> scene, under the existing <code>CanvasLayer</code> node, add a <code>TimerUI</code>.</li>
				<li>For the <code>TimerUI</code> node, select the <strong class="bold">Top Wide</strong> anchor so that it stays on the top of the screen:</li>
			</ol>
			<div><div><img alt="Figure 10.51 – Selecting Top Wide from the Anchor preset list" src="img/B19358_10_52.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.51 – Selecting Top Wide from the Anchor preset list</p>
			<ol>
				<li value="3">Add <a id="_idIndexMarker651"/>a <code>TimerUI</code> and call it <code>TimeLabel</code>:</li>
			</ol>
			<div><div><img alt="Figure 10.52 – The scene structure for our timer" src="img/B19358_10_53.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.52 – The scene structure for our timer</p>
			<ol>
				<li value="4">Let’s fill this label with a fake time of <code>"123"</code> so that we can see how the score will look when it is filled.</li>
				<li>Change the font size of this label to something larger, such as <code>30</code> px.</li>
			</ol>
			<p>Now, we’ll need to account for the timer in the <code>main.gd</code> game script:</p>
			<ol>
				<li>First cache a reference to the <code>TimeLabel</code> node at the top of the script and add a variable in which we’ll keep the current elapsed time:<pre class="source-code">
@onready var _time_label: Label = $ CanvasLayer/TimerUI/TimeLabel
var _time: float = 0.0:
   set(value):
      _time = value
      _time_label.text = str(floor(_time))</pre></li>				<li>Now, all we need to do is update the value of this <code>_time</code> variable. We’ll do this in the <code>_process()</code> function by adding the delta to the current time:<pre class="source-code">
func _process(delta: float):
   _time += delta</pre></li>				<li>Lastly, we’ll need to submit this time whenever the player dies and stop the game from counting more time. So, change the function that is connected to the <code>died</code> signal from the player to include the following two lines:<pre class="source-code">
func _on_player_died() -&gt; void:
   _game_over_menu.show()
   _enemy_spawner.stop()
   _health_potion_spawner.stop()
   set_process(false)
   HighscoreManager.set_new_highscore(_time)</pre></li>			</ol>
			<p>That’s it to<a id="_idIndexMarker653"/> get the <a id="_idIndexMarker654"/>highscore linked within the game itself. Now, we’ll tackle showing the highscore in the main menu too.</p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor655"/>Using the highscore in the main menu</h2>
			<p>Now that we can<a id="_idIndexMarker655"/> make new highscores, let’s display the highest score within the menu:</p>
			<ol>
				<li>Open the <code>menu.tscn</code> scene.</li>
				<li>Add a new <code>HighscoreLabel</code>.</li>
				<li>Now, in the <code>menu.gd</code> script, add the following code:<pre class="source-code">
@onready var highscore_label: Label = $CenterContainer/VBoxContainer/PanelContainer/MarginContainer/VBoxContainer/VBoxContainer/HighscoreLabel
func _ready():
   highscore_label.text = "Highscore: " + str(HighscoreManager.highscore)</pre></li>			</ol>
			<p>The result is that the menu will now show the current highscore:</p>
			<div><div><img alt="Figure 10.53 – The main menu with an added Highscore label" src="img/B19358_10_54.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.53 – The main menu with an added Highscore label</p>
			<p>None of this code is new to us. First, we save the <code>highscore_label</code>. Next, when the menu scene is ready, we populate the <strong class="bold">HighscoreLabe</strong>l with a string that contains the current highest score.</p>
			<p>That was our venture into autoloads. We saw how easy it is to add a script or scene as a node that is always loaded at the start of our game without having to manage this node ourselves. Then, we <a id="_idIndexMarker656"/>made use of this autoload through its global variable to save information between different scenes.</p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor656"/>Additional exercises – Sharpening the axe</h1>
			<ol>
				<li>Enemies get spawned at a slow, fixed rate. This can get a little boring because the difficulty never really increases. Make it so that enemies get spawned faster and faster after every round. For a simple way of doing this, you could follow the next steps:<ol><li class="upper-roman">Add <code>start_interval</code>, <code>end_interval</code>, and <code>time_delta</code> as export variables to the <code>EntitySpawner</code> node. The <code>start_interval</code> variable will be the time we use between spawning entities at the start of the game, <code>end_interval</code> will be the final value, and <code>time_delta</code> is the increment at which we will go from the <code>start_interval</code> variable to the <code>end_interval</code> variable:</li></ol></li>
			</ol>
			<div><div><img alt="Figure 10.54 – The new exported variables for the EntitySpawner node" src="img/B19358_10_55.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.54 – The new exported variables for the EntitySpawner node</p>
			<ol>
				<li class="upper-roman" value="2">Now, track in a separate variable, <code>_current_spawn_interval</code>, the time for the next enemy to spawn. Set <code>_current_spawn_interval</code> equal to the <code>start_interval</code> variable at the start of the game. This variable replaces the old <code>spawn_interval</code> variable.</li>
				<li class="upper-roman">Every time we spawn an entity in the <code>spawn_entity</code> function, add the <code>time_delta</code> variable to the <code>_current_spawn_interva</code><code>l</code> variable. Make sure to not go past the <code>end_interval</code> variable, though.</li>
				<li class="upper-roman">Then, still in the <code>spawn_entity()</code> function, start <code>_spawn_timer</code> again but with the new <code>_current_spawn_interval</code> variable: by calling <code>start_timer()</code> again. For the <code>HealthPotionSpawner</code> node, you’ll have to set <code>time_delta</code> to <code>0.0</code>.</li>
				<li class="upper-roman">The menu that shows up when the player dies is quite lacking in information. Add a nice label to show the score the player just achieved.</li>
			</ol>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor657"/>Summary</h1>
			<p>We learned and crea<a id="_idTextAnchor658"/>ted so many different things within this chapter. First, we learned all about <code>NavigationServer</code> property. To let the player have a chance to defend themselves, we created projectiles that get shot automatically on a timer. Lastly, we added a small high-score system that stores the current highscore within an autoload so that the player is incentivized to replay the game and try to beat their own best time.</p>
			<p>In the next chapter, we’ll do something very interesting: make our game multiplayer!</p>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor659"/>Quiz time</h1>
			<ul>
				<li><strong class="bold">Control</strong> nodes are used to create UIs such as menus. For each of the following scenarios, give a <strong class="bold">Control</strong> node that could do the job:</li>
				<li>Showing a long piece of text</li>
				<li>Grouping other <strong class="bold">Control</strong> nodes to the center of the screen</li>
				<li>Showing a button to start the game</li>
				<li>Which node did we add to the <code>Enemy</code> scene to make it find a path to the player?</li>
				<li>Let’s say that we have this piece of code where we define a signal called <code>shot</code> to indicate that we shot a projectile:<pre class="source-code">
signal shot</pre><p class="list-inset">Write the line of code that is needed to emit this signal.</p></li>				<li>How do you load a scene from within the code into a variable?</li>
				<li>How can we make a script globally accessible?</li>
			</ul>
		</div>
	</body></html>