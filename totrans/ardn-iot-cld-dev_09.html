<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-195"><a id="_idTextAnchor195"/>9</h1>
<h1 id="_idParaDest-196"><a id="_idTextAnchor196"/>Project 4 – Collecting Data from the Soil and Environment for Smart Farming</h1>
<p>This chapter is dedicated to <strong class="bold">smart agriculture</strong>. Our population is growing rapidly and food consumption is directly <a id="_idIndexMarker723"/>proportional to population. Fortunately, we have the latest tools and technologies that help us to boost our crop yields by using fewer natural resources. In smart agriculture, there are different parameters to monitor, but we will only focus on soil moisture and soil temperature as both are linked to water consumption; access to clean water is another issue with the rapid growth of industries and population.</p>
<p>In this chapter, we will practically explore smart agriculture by monitoring the soil moisture level, soil temperature, and outdoor temperature and humidity, which will help us to understand how our soil responds to changes in the outside environment and for how many days the soil retains moisture after watering the crop. Our smart agriculture device will send all the data to the Arduino IoT Cloud, where we will monitor it in real time and make decisions that will help us to use controlled watering for crops, which will save water and improve the soil quality.</p>
<p>In this chapter, we are going to use open source and cost-effective sensors to carry out experiments in labs as well as in the field. For the development board, we are using the <strong class="bold">ESP32</strong> and <strong class="bold">ADS1115</strong> <strong class="bold">analog-to-digital converter</strong> (<strong class="bold">ADC</strong>) modules in combination with four capacitive soil moisture and four <strong class="bold">DS18B20</strong> sensors for soil temperature monitoring, as well as a <strong class="bold">DHT22</strong> module for outdoor temperature and humidity monitoring. This project will help you optimize your crops with precision farming, tunnel farming, and drip irrigation, as well as be useful for home gardening.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Smart farming with IoT</li>
<li>Essential hardware for your agri-tech project</li>
<li>Architecting your agriculture IoT system</li>
<li>Perfecting sensor calibration</li>
<li>Setting up things, networks, and cloud variables</li>
<li>Creating web and mobile dashboards</li>
</ul>
<h1 id="_idParaDest-197"><a id="_idTextAnchor197"/>Technical requirements</h1>
<p>The following hardware components are required to complete this chapter:</p>
<ul>
<li>ESP32 development board</li>
<li>ADS1115 ADC module</li>
<li>DHT22 module</li>
<li>Soil moisture sensor x4</li>
<li>DS18B20 x4</li>
<li>PCB (link is available in the <em class="italic">PCB design and the assembly of hardware </em><em class="italic">components</em> section)</li>
<li>2.54 mm three-pin connectors</li>
<li>Female headers</li>
<li>Jumper cables</li>
</ul>
<p>For coding, we will use the Arduino Web Editor, which includes a large collection of development board and sensor libraries, and we will use the Arduino IoT Cloud for Thing and dashboard setup. To develop hardware and sensor designs, we need the Fritzing desktop software.</p>
<p>The chapter code is available in the book’s official GitHub repository, or you can directly download the code at <a href="https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers">https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers</a>.</p>
<h1 id="_idParaDest-198"><a id="_idTextAnchor198"/>Smart farming with IoT</h1>
<p><strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>) technology is used in smart agriculture<a id="_idIndexMarker724"/> to optimize farm operations, improve crop yields, reduce waste, and increase profits. Here are some examples <a id="_idIndexMarker725"/>of how IoT is used<a id="_idIndexMarker726"/> in smart agriculture:</p>
<ul>
<li><strong class="bold">Automated irrigation</strong>: IoT sensors can be used to monitor soil moisture levels and weather<a id="_idIndexMarker727"/> conditions to determine when to irrigate crops. Automated irrigation systems can then be triggered to deliver the right amount of water to crops, which can reduce water wastage and increase crop yields.</li>
<li><strong class="bold">Livestock management</strong>: IoT sensors can be used to monitor the health and behavior of livestock, such<a id="_idIndexMarker728"/> as their movement, feeding habits, and sleeping patterns. This data can be used to detect early signs of illness, track breeding cycles, and ensure optimal conditions for the livestock.</li>
<li><strong class="bold">Crop monitoring</strong>: IoT sensors can be used to monitor crop growth, detect pests and<a id="_idIndexMarker729"/> diseases, and identify areas that need attention. This data can be used to make timely interventions and improve crop yields.</li>
<li><strong class="bold">Precision farming</strong>: IoT sensors can be used to gather data on individual plants<a id="_idIndexMarker730"/> or crops, enabling farmers to optimize their use of resources, such as water, fertilizers, and pesticides. This can help reduce waste, improve yields, and save money.</li>
<li><strong class="bold">Smart harvesting</strong>: IoT sensors can be used to monitor crop ripeness and determine<a id="_idIndexMarker731"/> the optimal time for harvesting. This can help reduce waste and improve the quality of harvested crops.</li>
<li><strong class="bold">Weather monitoring</strong>: IoT sensors can be used to monitor weather conditions such <a id="_idIndexMarker732"/>as temperature, humidity, and rainfall. This data can be used to make informed decisions about planting, harvesting, and other farming<a id="_idIndexMarker733"/> operations.</li>
</ul>
<p>Overall, IoT technology is transforming the way that agriculture is practiced. By using real-time data and analytics, farmers can make better decisions and achieve better outcomes, ultimately leading to a more sustainable food supply for the world.</p>
<p>In this section, we have discussed smart agriculture and different terms and techniques that are common in smart agriculture. In the next section, we will discuss the hardware components that we are going to use in this chapter’s project.</p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor199"/>Essential hardware for your agri-tech project</h1>
<p>In this project, we have chosen open<a id="_idIndexMarker734"/> source and easily available hardware<a id="_idIndexMarker735"/> components. To demonstrate how the Arduino IoT Cloud works with ESP32 series development boards, we have chosen the following hardware. In the ESP32 series, we have a wide selection of development <a id="_idIndexMarker736"/>boards that vary in size and number of pins. In this chapter, we are using <strong class="bold">ESP32-DevKit V1</strong> as it’s very compact and smaller in size compared to other<a id="_idIndexMarker737"/> boards. It is, of course, also cheaper and provides a 5V pin, which is also<a id="_idIndexMarker738"/> known as VIN, as well as having the option of a 3.3V pin. The following figure shows the <strong class="bold">pin layout</strong> (<strong class="bold">pinout</strong>) diagram of ESP32 V1.</p>
<div><div><img alt="Figure 9.1: ESP32-DevKit V1" src="img/B19752_09_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1: ESP32-DevKit V1</p>
<p>ESP32 provides multiple<a id="_idIndexMarker739"/> pins for digital and analog input/output. If you want<a id="_idIndexMarker740"/> to use multiple analog sensors, then ADCs are available. One of the most well-known ADCs is the ADS1115/ADS1015 module, which provides four analog pins and is good when you need to add additional analog pins to your project. In this project, four analog pins are required to fetch soil moisture sensor values; this board has enough analog pins but I am using ADS1115 to demonstrate how we can use the ADC module to add extra analog pins to our projects.</p>
<p>In the current project, we need five digital pins for the DHT22 module and DS18B20 temperature probe and four analog pins for the capacitive soil moisture sensors. One of the good features of this development board is that it provides a 5V power pin, which is not available in most ESP32 series development boards.</p>
<p>Next, we are using the DHT22 module to sense outdoor temperature and humidity, but you can also use the DHT11 sensor, depending on your requirements. If specifically talking about features, then the DHT22 provides a broader range of sensors compared to the DHT11, but it costs more. The following figure shows the DHT22 module, and we have labeled the pins for better understanding.</p>
<div><div><img alt="Figure 9.2: DHT22 and DHT11 module pinout" src="img/B19752_09_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2: DHT22 and DHT11 module pinout</p>
<p>The preceding figure shows<a id="_idIndexMarker741"/> the pinout of the DHT22/DHT11 sensor<a id="_idIndexMarker742"/> module; the complete pin connection configuration can be seen in <em class="italic">Table 9.3</em>. The first pin (<strong class="bold">VCC</strong>) works with both 3.3V and 5V. The second pin is the <strong class="bold">DATA</strong> pin, which connects with any digital pin of ESP32-DevKit V1. The third pin is the <strong class="bold">GND</strong> pin, which connects with the GND pin of the development board.</p>
<p>Before moving on, the following table explains all the specification differences between the DHT22 and DHT11. The most notable things are the sensing range and sensing period:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-5">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Feature</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">DHT22</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">DHT11</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Power supply</p>
</td>
<td class="No-Table-Style" colspan="2">
<p>3.3 to 5V</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Output signal</p>
</td>
<td class="No-Table-Style" colspan="2">
<p>Digital signal via a single bus</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Sensing element</p>
</td>
<td class="No-Table-Style" colspan="2">
<p>Polymer capacitor</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Sensing range</p>
</td>
<td class="No-Table-Style">
<p>Humidity 0-100% Relative Humidity (RH)</p>
<p>Temperature 40-0°C</p>
</td>
<td class="No-Table-Style">
<p>Humidity 20-90% RH</p>
<p>Temperature 0-50°C</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Accuracy</p>
</td>
<td class="No-Table-Style">
<p>Humidity: +-2% RH (max +-5% RH)</p>
<p>Temperature: &lt;+-0.5°C</p>
</td>
<td class="No-Table-Style">
<p>Humidity: 1% RH (max 5% RH)</p>
<p>Temperature: &lt;2°C</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Sensing period</p>
</td>
<td class="No-Table-Style">
<p>Average 2 s</p>
</td>
<td class="No-Table-Style">
<p>Average 1 s</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.1: DHT22 and DHT11 sensor specification</p>
<p>The main sensor of the project is a capacitive soil moisture sensor and it is used to monitor the soil moisture of a specific area. It is a low-cost soil moisture monitoring sensor and is rustproof due to its use of PCB (PCB sheets use plastic and paint, making them rustproof). It senses the soil moisture by passing a small amount of electric current into the soil moisture sensors, as shown in <em class="italic">Figure 9</em><em class="italic">.3</em>, and determining the soil moisture based on the returned<a id="_idIndexMarker743"/> current. If the sensor receives a higher <a id="_idIndexMarker744"/>current, then it means the moisture is high; if it receives a low current, then there is little or no moisture content in the soil.</p>
<div><div><img alt="Figure 9.3: Capacitive soil moisture sensor pinout" src="img/B19752_09_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3: Capacitive soil moisture sensor pinout</p>
<p>The soil moisture sensor consists of three pins: <code>map()</code> method under the <code>FetchSoilMoisture()</code> method. The complete code is available on GitHub in the folder for this chapter. The sensor operates with both 5V power as well as 3.3V, but 5V is recommended.</p>
<p>The other main sensor of this project is the DS18B20 waterproof temperature sensor probe, which is used to monitor the soil temperature of a specific area, along with soil moisture levels. It is a low-cost<a id="_idIndexMarker745"/> waterproof temperature monitoring sensor and is rustproof due to its steel <a id="_idIndexMarker746"/>enclosure. The following figure shows the DS18B20 waterproof temperature probe and its pinout and connection diagram with ESP32-DevKit V1.</p>
<div><div><img alt="Figure 9.4: DS18B20 waterproof temperature probe" src="img/B19752_09_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4: DS18B20 waterproof temperature probe</p>
<p>The preceding figure shows the sensor and its pinout diagram. DS18B20 contains three colored wires: the black wire is used for GND, the red wire is used to connect VCC either with 3.3V or 5V, and the yellow wire is used to connect with any digital pin but with a 4.7k pull resistor, as shown in the figure. If we’re talking about sensor specifications, then its temperature sensing range is good – it is capable of measuring a temperature from -55 to 125°C. All the other details are given in the following table for further exploration:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-3">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Feature</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">DS18B20</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Power supply</p>
</td>
<td class="No-Table-Style">
<p>3.3 to 5V</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Output signal</p>
</td>
<td class="No-Table-Style">
<p>Digital signal/one wire</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Temperature sensing range</p>
</td>
<td class="No-Table-Style">
<p>-55~125°C</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Temperature accuracy</p>
</td>
<td class="No-Table-Style">
<p>Temperature ± 0.5°C</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Sensing period</p>
</td>
<td class="No-Table-Style">
<p>&lt;750 ms</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.2 – DS18B20 specification table</p>
<p>In this section, we have discussed <a id="_idIndexMarker747"/>development boards and sensors in detail, with complete specifications <a id="_idIndexMarker748"/>and pinout diagrams. In the next section, we will talk about how these sensors connect to ESP32-DevKit V1 as well as the PCB design of the project.</p>
<h1 id="_idParaDest-200"><a id="_idTextAnchor200"/>Architecting your agriculture IoT system</h1>
<p>In the previous sections, we discussed <a id="_idIndexMarker749"/>the sensors and development board in detail. Now it’s time to put things into practice. In hardware development, before starting to work with sensors and development boards, we need to develop the design concepts to get a better understanding of how things will be connected. There are many pieces of software available<a id="_idIndexMarker750"/> to design and develop design concepts for electronic projects, but we are going to use <strong class="bold">Fritzing</strong>.</p>
<p>In the following two subsections, we will first talk about the schematics and design of the project and explain how to connect the pins with the development board. Then, we will talk about PCB design and its implementation to make the product ready for deployment in the field.</p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor201"/>Schematics and design</h2>
<p>The purpose of the design<a id="_idIndexMarker751"/> is to get a clear understanding of how sensors will connect with the development board. It helps engineers develop prototypes on a breadboard or Veroboard by basing them on these design files. A major benefit of designing using Fritzing is that it builds hardware schematics and PCB design in the background according to your design, which can be adjusted by designers according to the system requirements. The following figure shows the whole project diagram, illustrating how the sensors and ADS1115 module connect to the ESP32-DevKit V1 board.</p>
<div><div><img alt="Figure 9.5: Smart agriculture system design" src="img/B19752_09_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5: Smart agriculture system design</p>
<p><em class="italic">Figure 9</em><em class="italic">.5</em> depicts the whole project<a id="_idIndexMarker752"/> schematic diagram, which also includes the pin numbers. But to make it easier for you, we have provided the following tables with all the pin numbers. <em class="italic">Table 9.3</em> contains the pin configuration for DHT22 with ESP32:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table003-1">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">ESP32</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">DHT22</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>D13</p>
</td>
<td class="No-Table-Style">
<p>Data (I/O)</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>GND</p>
</td>
<td class="No-Table-Style">
<p>GND</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>3.3V</p>
</td>
<td class="No-Table-Style">
<p>VCC</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.3: ESP32 and DHT22 pinout table</p>
<p><em class="italic">Table 9.4</em> contains the pin configuration for DS18B20 temperature probes with ESP32. Here, we are using four DS18B20 temperature probes, and in each column of sensors, we have mentioned the ESP32 pin<a id="_idIndexMarker753"/> number that will connect with the DS18B20 data pin. GND and VCC pins of ESP32 development board will be common to all sensors:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table004">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Soil Temperature </strong><strong class="bold">Sensor #1</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Soil Temperature </strong><strong class="bold">Sensor #2</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Soil Temperature </strong><strong class="bold">Sensor #3</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Soil Temperature </strong><strong class="bold">Sensor #4</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Data pin with ESP32 (D32)</p>
</td>
<td class="No-Table-Style">
<p>Data pin with ESP32 (D33)</p>
</td>
<td class="No-Table-Style">
<p>Data pin with ESP32 (D25)</p>
</td>
<td class="No-Table-Style">
<p>Data pin with ESP32 (D26)</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>ESP32 GND to GND</p>
</td>
<td class="No-Table-Style">
<p>ESP32 GND to GND</p>
</td>
<td class="No-Table-Style">
<p>ESP32 GND to GND</p>
</td>
<td class="No-Table-Style">
<p>ESP32 GND to GND</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>ESP32 3.3V to VCC</p>
</td>
<td class="No-Table-Style">
<p>ESP32 3.3V to VCC</p>
</td>
<td class="No-Table-Style">
<p>ESP32 3.3V to VCC</p>
</td>
<td class="No-Table-Style">
<p>ESP32 3.3V to VCC</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.4: ESP32 and DS18B20 temperature probes pinout table</p>
<p><em class="italic">Table 9.5</em> illustrates ESP32 to ADS1115 pin configuration. The rest of the soil moisture sensors will connect to the system via ADS1115 analog pins, which are explained in <em class="italic">Table 9.6</em>:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table005">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">ESP32</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">ADS1115</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>D22</p>
</td>
<td class="No-Table-Style">
<p>SCL</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>D21</p>
</td>
<td class="No-Table-Style">
<p>SDA</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>3.3V</p>
</td>
<td class="No-Table-Style">
<p>VCC</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>GND</p>
</td>
<td class="No-Table-Style">
<p>GND</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.5: ESP32 and ADS1115 pinout table</p>
<p>In <em class="italic">Table 9.6</em>, you will see how we have attached soil moisture<a id="_idIndexMarker754"/> sensors to the system using ADS1115. The second row of the table states which pin of ADS1115 will be used to connect soil moisture sensors to the system:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table006">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Soil Moisture </strong><strong class="bold">Sensor #1</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Soil Moisture </strong><strong class="bold">Sensor #2</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Soil Moisture </strong><strong class="bold">Sensor #3</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Soil Moisture </strong><strong class="bold">Sensor #4</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Soil moisture analog pin to ADS1115 (A0)</p>
</td>
<td class="No-Table-Style">
<p>Soil moisture analog pin to ADS1115 (A1)</p>
</td>
<td class="No-Table-Style">
<p>Soil moisture analog pin to ADS1115 (A2)</p>
</td>
<td class="No-Table-Style">
<p>Soil moisture analog pin to ADS1115 (A3)</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>ESP32 GND to GND</p>
</td>
<td class="No-Table-Style">
<p>ESP32 GND to GND</p>
</td>
<td class="No-Table-Style">
<p>ESP32 GND to GND</p>
</td>
<td class="No-Table-Style">
<p>ESP32 GND to GND</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>ESP32 VCC to VCC</p>
</td>
<td class="No-Table-Style">
<p>ESP32 VCC to VCC</p>
</td>
<td class="No-Table-Style">
<p>ESP32 VCC to VCC</p>
</td>
<td class="No-Table-Style">
<p>ESP32 VCC to VCC</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.6: ADS1115 and soil moisture sensors pinout table</p>
<p>The preceding design provides a full overview showing how you can connect the sensors to the development board. According to the design, we have only one 5V and one GND from the development board, which will be used across all the sensors. Soil moisture sensors are analog sensors, so we connected all the sensors with ADS1115 module pins from the AO pin to the A4 pin, as shown in <em class="italic">Figure 9</em><em class="italic">.5</em> and <em class="italic">Table 9.6</em>, while the DHT22 module and DS18B20 are digital sensors and are connected to the D12, D32, D33, D25, and D26 pins of ESP32, as shown in <em class="italic">Figure 9</em><em class="italic">.5</em> and in <em class="italic">Table 9.3</em> and <em class="italic">Table 9.4</em>, respectively. The ESP32 to ADS1115 pinout<a id="_idIndexMarker755"/> is shown in <em class="italic">Table 9.5</em> as well as in <em class="italic">Figure 9</em><em class="italic">.5</em>.</p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor202"/>PCB design and the assembly of hardware components</h2>
<p>In the preceding section, we saw<a id="_idIndexMarker756"/> a design that is good for creating prototypes using<a id="_idIndexMarker757"/> a breadboard or Veroboard, but what if we want to deploy that solution in the field? Fritzing is a great tool that provides the option to design a PCB, and when you develop the design, it automatically creates the PCB design in the backend, which is accessible in the Fritzing software via the <strong class="bold">PCB Design</strong> tab. Automatic PCB design is just a basic functionality and is not suitable for direct production, so it’s mandatory to review and rearrange the design according to professional practices. The following figure shows the PCB design for the current project.</p>
<div><div><img alt="Figure 9.6: Smart agriculture system PCB design" src="img/B19752_09_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6: Smart agriculture system PCB design</p>
<p>The preceding figure shows<a id="_idIndexMarker758"/> the final PCB design of the project. (I was able to create this design easily thanks to Fritzing.) There are many different<a id="_idIndexMarker759"/> tools <a id="_idIndexMarker760"/>available for PCB design, such as <strong class="bold">EasyEDA</strong>, <strong class="bold">Circuit Maker</strong>, and <strong class="bold">Altium</strong>. It’s easy to develop a PCB; just make <a id="_idIndexMarker761"/>sure that the connection line<a id="_idIndexMarker762"/> on the PCB doesn’t intersect with other connection lines.</p>
<p>After the PCB design, you have two options: either develop the PCB yourself using the DIY method (which is good for learning purposes but not suitable for large-scale products) or choose a professional organization that will manufacture the PCB professionally. Many organizations in China provide PCB manufacturing and fabrication services, such as Seeed Studio, JLCPCB, and PCBWay. We tried PCBWay and were impressed with their working and delivery time. We have uploaded the PCB design to the PCBWay project repository, and from there, you can select the PCB design and order easily: <a href="https://www.pcbway.com/project/shareproject/ESP32_Based_Smart_Agriculture_Node_11223e5a.html">https://www.pcbway.com/project/shareproject/ESP32_Based_Smart_Agriculture_Node_11223e5a.html</a>.</p>
<p>After getting the PCBs, it’s time<a id="_idIndexMarker763"/> to solder the female headers and 2.54 mm three-pin<a id="_idIndexMarker764"/> connectors for development boards and sensors. Never solder the development board and sensors directly on a PCB so that if anything stops working, then it’s easy to detach and replace. The following figure shows the final face of the PCB which contains 2.5mm three-pin connectors in white color for soil moisture sensors, DS18B20 &amp; DHT22 while black female headers are used to insert the ESP32-DevKit V1 and ADS1115 module.</p>
<div><div><img alt="Figure 9.7: Smart agriculture system PCB" src="img/B19752_09_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7: Smart agriculture system PCB</p>
<p>The preceding figure shows how the PCB<a id="_idIndexMarker765"/> looks after soldering the three-pin 2.54 mm connectors<a id="_idIndexMarker766"/> and female headers. Soil moisture connectors are marked with <strong class="bold">SM</strong> while DS18B20 connectors are marked with <strong class="bold">T</strong> and resistances are marked with <strong class="bold">R</strong>, as shown in <em class="italic">Figure 9</em><em class="italic">.7</em>. Now it’s time to plug all the connectors to get our smart agriculture node ready for further procedures. But wait – by default, soil moisture sensors come with a very small length of wire, which is not enough, so here you need to extend the cable lengths by putting 2.54 mm female connectors on both ends, as soil moisture sensors also use the same connectors for connectivity. DS18B20 also comes with a naked terminal but we plugged a 2.54 mm female connector for easy and clean connectivity. The following figure shows the complete setup with all the sensors and cabling arrangement.</p>
<div><div><img alt="Figure 9.8: Smart agriculture system with all sensors and modules" src="img/B19752_09_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8: Smart agriculture system with all sensors and modules</p>
<p>The preceding figure shows all the components stacked on the PCB. We can see that soil moisture sensors are extended with custom cabling with the help of connectors, while the DS18B20 naked terminal is connected to female connectors, and the same for the DHT22 module. After hardware<a id="_idIndexMarker767"/> assembly, we need to calibrate the soil moisture<a id="_idIndexMarker768"/> and DS18B20 temperature before deploying the node into the field.</p>
<h1 id="_idParaDest-203"><a id="_idTextAnchor203"/>Perfecting sensor calibration</h1>
<p>Sensor calibration is a very important<a id="_idIndexMarker769"/> aspect of product development, especially when you have a plan to deploy your product in a real-time environment. So, before moving on, first we need to calibrate the capacitive soil moisture and DS18B20 sensors. The soil moisture sensor operation varies from area to area due to air humidity and water levels.</p>
<p>So firstly, we will calibrate the soil moisture sensor by taking the values of sensors in the air and then putting sensors in the water. These values will be used to bind the final readings and, finally, we will convert the soil moisture sensor value from 0 to 100% via the map method. The soil<a id="_idIndexMarker770"/> moisture sensor is an analog sensor, so there<a id="_idIndexMarker771"/> is no requirement for an extra helping library, except the <strong class="bold">ADS module library</strong>, which is shown in the following figure with the name <strong class="bold">Adafruit ADS1X15</strong>.</p>
<div><div><img alt="Figure 9.9 – ADS1115 library" src="img/B19752_09_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – ADS1115 library</p>
<p>Here, we need to install a library for ADS1115/ADS1015 in the Arduino IDE so we can use the ADS module. Navigate to <code>Adafruit ADS1X15</code>, and install the latest version, which is shown in the preceding figure. After installation of the library, download the code from the official GitHub book repository and open the code from the <code>Soil-Moisture-Calibration</code> folder:</p>
<pre class="source-code">
int AirValue[]={0,0,0,0};
int WaterValue[]={0,0,0,0};</pre> <p>The preceding code snippet contains two arrays: one for air values and one for sensor values when they are dipped into the water. For soil sensor calibration, we need to get <code>AirValue</code> and then <code>WaterValue</code> values only by one time. Upload the code to the development board and make sure your soil moisture sensors are dry. Open the serial monitor and note down the <code>AirValue</code> value for each sensor. After that, dip the sensors into a pot of water and note down the <code>WaterValue</code> value of the sensors.</p>
<p>Let’s look at the <code>AirValue</code>s of AIN0, AIN1, AIN2, and AIN3, as shown in <em class="italic">Figure 9</em><em class="italic">.10</em>. <strong class="bold">AIN</strong> is short for <strong class="bold">Analog Input</strong> and the proceeding 0, 1, 2, and 3 are the pin<a id="_idIndexMarker772"/> numbers of the ADC1115 module where soil moisture<a id="_idIndexMarker773"/> sensors are connected:</p>
<div><div><img alt="Figure 9.10: Air values of soil moisture sensors" src="img/B19752_09_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10: Air values of soil moisture sensors</p>
<p>Now let’s look at the <code>WaterValue</code>s after putting the soil moisture sensors in the water:</p>
<div><div><img alt="Figure 9.11: Water values of soil moisture sensors" src="img/B19752_09_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11: Water values of soil moisture sensors</p>
<p>Wait for some time and note down<a id="_idIndexMarker774"/> the values when they become stable. After fetching the <code>Air</code> and <code>Water</code> values, put these values into the preceding arrays and upload the code again to the development board. Verify the values of the soil moisture percentage levels by putting the sensors into the water and then cleaning them. Here, you will get 100% when sensors are deeply in water and 0% when they are dry.</p>
<p>After the soil moisture levels, it’s time to verify the DS18B20 temperature probe sensor readings. Firstly, we need to install a library for the DS18B20 temperature sensor. Navigate to <code>Dallas Temperature by Miles Burton</code>, and install the latest version. After installation of the library, download the code from the official GitHub book repository and open the code from the <code>DS18B20-Calibration</code> folder:</p>
<pre class="source-code">
OneWire ds18x20[] = {32,33,25,26};</pre> <p>In the preceding code, we have mentioned digital pin numbers, which are reserved on the PCB to connect DS18B20 sensors. If you are using different pins on the breadboard, then update the pin number according to your selection. Upload the code on the development board, then after uploading, open up the serial monitor and see whether you are getting the values from the sensors or not. The following figure shows the DS18B20 temperature probe readings on the serial monitor for calibration purposes.</p>
<div><div><img alt="Figure 9.12: DS18B20 temperature sensor values on the Serial Monitor" src="img/B19752_09_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12: DS18B20 temperature sensor values on the Serial Monitor</p>
<p>The preceding figure shows that<a id="_idIndexMarker775"/> the DS18B20 temperature sensors are working fine and the values are stabilized. Now, we can move forward with lab calibration.</p>
<p class="callout-heading">Important note</p>
<p class="callout">A 4.7k <strong class="bold">pull resistor</strong> is mandatory for DS18B20. Without <a id="_idIndexMarker776"/>pull-up resistor, you will not get the values.</p>
<p>After the soil moisture sensors have tested with the <code>Air</code> and <code>Water</code> values, it’s time to calibrate both sensors in the lab. For moisture testing, we used the hot air oven method to verify the accuracy of the soil moisture sensor. We added water to soil, sand, and salt at different levels and measured it with sensors. After that, we inserted these samples into a hot air oven and compared the sensor readings between the two methods; the results were incredible: only a ±0.5 difference. For DS18B20, we used a calibrated analog thermometer and observed only a ±0.5 difference. The following figure shows a photo of the lab where we calibrated the soil moisture and DS18B20 sensors to industry standards.</p>
<div><div><img alt="Figure 9.13: Moisture sensor and temperature sensor calibration in the lab" src="img/B19752_09_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13: Moisture sensor and temperature sensor calibration in the lab</p>
<p>The preceding figure shows the calibration of sensors in the lab. Here, we have tested the sensors with soil, sand, and salt.</p>
<p>In this section, we discussed sensors and their connection to ES32-DevKit V1 using a schematic diagram, as well as PCB design and its implementation. After that, we discussed soil moisture and DS18B20 sensor<a id="_idIndexMarker777"/> calibration. In the upcoming section, we will set up things, network credentials, and cloud variables and look into the code.</p>
<h1 id="_idParaDest-204"><a id="_idTextAnchor204"/>Setting up things, networks, and cloud variables</h1>
<p>After setting up the hardware, it’s time<a id="_idIndexMarker778"/> to set up a thing in the<a id="_idIndexMarker779"/> Arduino IoT Cloud. For this project, we need 10 cloud variables<a id="_idIndexMarker780"/> to fetch monitoring parameters from the device; the network settings will be different due to the ESP series board. The following figure gives a complete overview of the <strong class="bold">AgriStack</strong> Thing we will set up.</p>
<div><div><img alt="Figure 9.14: Smart agriculture system thing setup" src="img/B19752_09_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14: Smart agriculture system thing setup</p>
<p>Set up a new thing with the name <code>AgriStack</code>. Follow these steps to create variables, an associated device, network configuration, and, finally, the code. We have marked the preceding figure with different red boxes<a id="_idIndexMarker781"/> and assigned numbers. These numbers correspond <a id="_idIndexMarker782"/>to the following <a id="_idIndexMarker783"/>steps, which will help you to set up the Thing:</p>
<ol>
<li>Firstly, we need to set up 10 cloud variables, as shown in <em class="italic">Figure 9</em><em class="italic">.14</em>. There are two cloud variables for outdoor temperature and humidity; these values will be taken from DHT22. There are four cloud variables for soil moisture and four variables for soil temperature. The previous four will use soil moisture sensor and the latter four will use the DS18B20 temperature probe. More details about cloud variables are available in the next subsection.</li>
<li>After that, we need to associate the device with the Thing. In the current project, we are going to use ESP32-DevKit V1, so the wizard will be different compared to Arduino boards. Complete details are available in the <em class="italic">Associating a </em><em class="italic">device</em> section.</li>
<li>Finally, we need to set up the network configuration for the device, but this time, we need to provide a security key for ESP series boards to make the connection secure, whereas Arduino-compatible boards are configured by the Arduino IoT Cloud<a id="_idIndexMarker784"/> automatically during <a id="_idIndexMarker785"/>the device setup <a id="_idIndexMarker786"/>wizard.</li>
</ol>
<p>Here, we have discussed the different steps that help us to set up our thing. In the proceeding section, we will start looking into cloud variables.</p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor205"/>Cloud variables</h2>
<p>The following table explains<a id="_idIndexMarker787"/> all the properties of variables<a id="_idIndexMarker788"/> that we need to use during cloud variable creation. An integer (<code>int</code>) is a very famous data type, but here you will observe two new variable types regarding humidity and temperature, which take values in percentage and Celsius, respectively. Also, ensure you have the same variable declaration as per the table; otherwise, you will need to modify the example code according to your naming.</p>
<p>We have set the permission of all cloud variables to <strong class="bold">Read Only</strong>, but we also have the <strong class="bold">Read/Write</strong> option. In this project, we only want to receive data from the device instead of sending data from dashboard, which is why <strong class="bold">Read Only</strong> mode is used, to avoid issues with data consistency. <strong class="bold">Update Policy</strong> is set to <strong class="bold">On change</strong>, as the device will send the data after five minutes, so this option is more appropriate compared to <strong class="bold">Periodically update</strong>:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table007">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Serial </strong><strong class="bold">no.</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Variable Name</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Variable Type</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Declaration</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Permission</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Update </strong><strong class="bold">Policy</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>1</p>
</td>
<td class="No-Table-Style">
<p><code>Humidity</code></p>
</td>
<td class="No-Table-Style">
<p><code>CloudRelativeHumidity</code></p>
</td>
<td class="No-Table-Style">
<p><code>humidity</code></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Read Only</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">On change</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>2</p>
</td>
<td class="No-Table-Style">
<p><code>Temperature</code></p>
</td>
<td class="No-Table-Style">
<p><code>CloudTemperatureSensor</code></p>
</td>
<td class="No-Table-Style">
<p><code>temperature</code></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Read Only</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">On change</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>3</p>
</td>
<td class="No-Table-Style">
<p><code>SM1</code></p>
</td>
<td class="No-Table-Style">
<p><code>int</code></p>
</td>
<td class="No-Table-Style">
<p><code>sM1</code></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Read Only</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">On change</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>4</p>
</td>
<td class="No-Table-Style">
<p><code>SM2</code></p>
</td>
<td class="No-Table-Style">
<p><code>int</code></p>
</td>
<td class="No-Table-Style">
<p><code>sM2</code></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Read Only</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">On change</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>5</p>
</td>
<td class="No-Table-Style">
<p><code>SM3</code></p>
</td>
<td class="No-Table-Style">
<p><code>int</code></p>
</td>
<td class="No-Table-Style">
<p><code>sM3</code></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Read Only</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">On change</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>6</p>
</td>
<td class="No-Table-Style">
<p><code>SM4</code></p>
</td>
<td class="No-Table-Style">
<p><code>int</code></p>
</td>
<td class="No-Table-Style">
<p><code>sM4</code></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Read Only</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">On change</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>7</p>
</td>
<td class="No-Table-Style">
<p><code>ST1</code></p>
</td>
<td class="No-Table-Style">
<p><code>int</code></p>
</td>
<td class="No-Table-Style">
<p><code>sT1</code></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Read Only</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">On change</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>8</p>
</td>
<td class="No-Table-Style">
<p><code>ST2</code></p>
</td>
<td class="No-Table-Style">
<p><code>int</code></p>
</td>
<td class="No-Table-Style">
<p><code>sT2</code></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Read Only</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">On change</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>9</p>
</td>
<td class="No-Table-Style">
<p><code>ST3</code></p>
</td>
<td class="No-Table-Style">
<p><code>int</code></p>
</td>
<td class="No-Table-Style">
<p><code>sT3</code></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Read Only</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">On change</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>10</p>
</td>
<td class="No-Table-Style">
<p><code>ST4</code></p>
</td>
<td class="No-Table-Style">
<p><code>int</code></p>
</td>
<td class="No-Table-Style">
<p><code>sT4</code></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Read Only</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">On change</strong></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.7: Cloud variables list with complete parameters</p>
<p>After the successful creation<a id="_idIndexMarker789"/> of cloud variables, we will proceed further with the device association step, where we will add and associate the ESP32-DevKit V1 with<a id="_idIndexMarker790"/> our thing.</p>
<h3>Associating a device</h3>
<p>After variable<a id="_idIndexMarker791"/> creation, it’s time to add a device and associate it with the Thing. Before adding the device, connect the development board to the computer, and open the <strong class="bold">Arduino Create Agent</strong> application. We discussed the Arduino Create Agent in <a href="B19752_02.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, in the <em class="italic">What is the Arduino Create </em><em class="italic">Agent?</em> section.</p>
<div><div><img alt="Figure 9.15: Device selection wizard" src="img/B19752_09_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15: Device selection wizard</p>
<p>Click on the <strong class="bold">Select Device</strong> button under the <strong class="bold">Associated Device</strong> section on the Thing page. A popup will appear where you can see all the devices that are already available. If you have already added your WeMos D1 mini, select it. Otherwise, click on <strong class="bold">SET UP NEW DEVICE</strong>. Next, click on the <strong class="bold">Set up a 3rd party device</strong> option. Select <strong class="bold">ESP32</strong> and <strong class="bold">DOIT ESP32 DEVKIT V1</strong> from the dropdown and click on the <strong class="bold">CONTINUE</strong> button. Provide the device name and click on the <strong class="bold">Next</strong> button. In the final wizard, the <strong class="bold">Device ID</strong> and <strong class="bold">Secret Key</strong> details will be displayed. Copy the secret key to a safe place as it will be used during<a id="_idIndexMarker792"/> the network configuration.</p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor206"/>Network configuration</h2>
<p>After associating<a id="_idIndexMarker793"/> the device with the Thing, it is time to configure the Wi-Fi settings for device communication, as shown in <em class="italic">Figure 9</em><em class="italic">.14</em>, in the area marked <em class="italic">3</em>. Under <strong class="bold">Network</strong>, you will find the option to fill in the form with the Wi-Fi name and password. In the last field, you will find a new field for the secret key. Paste the secret key that we received from the system during device creation.</p>
<div><div><img alt="Figure 9.16: Network configuration for the Thing" src="img/B19752_09_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16: Network configuration for the Thing</p>
<p>After network configuration, we are done with our main task; now, the coding task remains, and in the<a id="_idIndexMarker794"/> next section, we will go through it.</p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor207"/>Coding</h2>
<p>The project code<a id="_idIndexMarker795"/> is available in the book’s official GitHub repository in a ZIP file named <code>AgriStack_mar05a</code>. Download it and import it to your Arduino Web Editor.</p>
<p>You can download the code and put it into your thing by navigating to the <code>setup</code> method and use the <code>timer</code> library to delay calling; remember, never try to use the <code>delay</code> method as it will block the <code>ArduinoCloud.update()</code> method. Then, a method called <code>SmartAgri()</code> is called every five minutes. The following is the complete <code>SmartAgri()</code> method. After this, we will explore what operations are carried out by this method:</p>
<pre class="source-code">
bool SmartAgri(void *){
  //Fetch Soil Moisture
  FetchSoilMoisture();
  //Fetch Soil Temperature
  FetchTemperature();
  //Fetch DHT Temp &amp; Humiditiy
  FetchDHTTempHum();
  //Send Data To Arduino IoT Cloud
  SendToArduinoIoTCloud();
  //Print The Readings on Serial Port
  PrintTheReadingsSerialPort();
  return true;
}</pre> <p>In this project, we have divided all the operations into different methods for easiness. So, firstly, we are calling <code>FetchSoilMoisture()</code>, which is responsible for fetching soil moisture readings from sensors and storing them in an array. Before storing the data in an array, it maps the value for the percentage. Next, we have the <code>FetchTemperature()</code> method, which is responsible for fetching the temperatures from all DS18B20 sensors and saving them into the soil temperature array for further usage. Finally, we call <code>FetchDHTTempHum()</code> to fetch the outdoor temperature and humidity values from the DHT22 module, which will be stored in two variables. Now, we will explore how we get the values<a id="_idIndexMarker796"/> from the soil moisture sensors in the following method:</p>
<pre class="source-code">
float getSoilMoisture(int Pin){
  float SoilMoisture=0;
    //loop 10 times for averaging
  for(int j = 0; j &lt; 5; j++){
    delay(1000);
    SoilMoisture+= ads.readADC_SingleEnded(Pin);
  }
  //divide by 5 to get the average
  SoilMoisture /= 5;
  return SoilMoisture;
 }</pre> <p>The preceding technique is used in the <code>FetchSoilMoisture()</code> method to fetch the readings for soil moisture. Here, you will see that the method takes values from the sensor five times with a delay of one second and adds them to the variable; then later, it divides the sensor readings by 5 to get the average. The benefit of this technique is that you will get the best possible value from the soil sensor.</p>
<p>The previous three methods have been used to fetch values from different sensors and store them in global variables and arrays. Now it’s time to send these values to the Arduino IoT Cloud; for that reason, we have the <code>SendToArduinoIoTCloud()</code> method, which assigns all the values of sensors to cloud variables, and these values will be updated on the cloud with the help of the <code>ArduinoCloud.update()</code> method. At the end, we have the <code>PrintTheReadingsSerialPort()</code> method, which is optional for use at runtime and is used to display all the sensor values on the serial monitor.</p>
<p>Upload the code to the device<a id="_idIndexMarker797"/> and verify the connectivity and readings. If you want to change the reading time, then just modify the <code>timer.every(600000, SmartAgri);</code> value. Make sure you are providing the time in milliseconds, where 1 second equals 1,000 milliseconds.</p>
<p class="callout-heading">Important note</p>
<p class="callout">If you used a different naming scheme in the variable declaration, then update the code according to your naming scheme. But first, you should follow all the steps according to the book and then you can later change the cloud variable names and modify your code, respectively.</p>
<p class="callout">Never try to use the <code>delay</code> method, as it will block the <code>ArduinoCloud.update()</code> method. Always use milliseconds to calculate the waiting time. Review the <code>loop()</code> method to call the other methods after five minutes.</p>
<p class="callout">The Arduino IoT Cloud only updates the value on the dashboard whenever the variable value is changed. For example, if the temperature is 30°C and it’s the same after five minutes, then the Arduino IoT Cloud will not record the value, so don’t get confused if values are not changing on the graph. Another benefit of this feature is you will not get duplicated data when you are exporting the content.</p>
<p>After successfully discussing the different methods in the code and uploading the code to ESP32-DevKit V1, it’s time<a id="_idIndexMarker798"/> to explore how to visualize all the data using awesome Arduino IoT Cloud dashboard widgets.</p>
<h1 id="_idParaDest-208"><a id="_idTextAnchor208"/>Creating web and mobile dashboards</h1>
<p>After uploading the code<a id="_idIndexMarker799"/> to the device, it’s time to set up a dashboard for web and mobile<a id="_idIndexMarker800"/> to visualize the data with different widgets. The following figure shows the visualization of readings with different widgets:</p>
<div><div><img alt="Figure 9.17: Thing dashboard" src="img/B19752_09_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17: Thing dashboard</p>
<p>We have 10 different readings: <strong class="bold">Outdoor Temperature</strong>, <strong class="bold">Outdoor Humidity</strong>, four <strong class="bold">Soil Moisture</strong> readings, and four <strong class="bold">Soil Temperature</strong> readings. For every reading, we are using the gauge widget control, and advanced charts have been used to compare <strong class="bold">Soil Moisture</strong> and <strong class="bold">Soil Temperature</strong> to visualize the proper correlation between these two attributes. But we also want to monitor historical data; graphs are the best widgets to display live as well as older data. Here, as seen in the lower part of the preceding figure, we have used four graphs, and each graph is connected to a specific cloud variable.</p>
<p>In this section, we have successfully<a id="_idIndexMarker801"/> created a dashboard for a smart agriculture<a id="_idIndexMarker802"/> thing that shows all the sensor readings in text format, as well as used graphs for comparison purposes.</p>
<h1 id="_idParaDest-209"><a id="_idTextAnchor209"/>What next?</h1>
<p>We still have a lot of options available to explore, but now it’s your turn to use different sensors and development boards to do some more experiments and learn from them. In this chapter, we used 10 sensors but only 3 different types, that is, moisture, temperature, and outdoor temperature and humidity. However, on the market, there are a lot of sensors that provide a wide variety of functionalities for soil, such as <strong class="bold">NPK</strong> (which stands for <strong class="bold">nitrogen, phosphorus, and potassium</strong>), <strong class="bold">EC</strong> (which stands for <strong class="bold">electrical conductivity</strong>), and pH sensors and different gas sensors for outdoor measurement.</p>
<p>Try the following sensors to enhance your practical knowledge and compare them with other sensors in terms of features, ranges, and cost:</p>
<ul>
<li>NPK sensor</li>
<li>Soil EC sensor</li>
<li>Soil pH sensor</li>
<li>MQ series sensors, which are designed to sense specific gases, including MQ-2, MQ-3, MQ-4, MQ-5, MQ-7, MQ-8, and MQ-9, to find the correlation of gases and their effects on soil and crops</li>
<li>Seeed Studio SCD30 (temperature, humidity, and CO2) for outdoor monitoring</li>
</ul>
<h1 id="_idParaDest-210"><a id="_idTextAnchor210"/>Summary</h1>
<p>In this chapter, we explored how to develop a smart agriculture monitoring system using DHT22, capacitive soil moisture sensors, a DS18B20 probe for soil temperature, and an ESP32 development board along with the ADS1115 ADC module. We calibrated soil moisture and temperature sensors in the lab before using them in the field. We also set up a thing, which included creating cloud variables, device association, network configuration, and coding of the development board. Then, we created a dashboard to visualize the Thing’s sensor readings with different types of widgets to display current readings as well as historical data with the help of graphs.</p>
<p>This project will help you and give you the confidence to collaborate with agriculture researchers and soil scientists to work on a more advanced level. It will help you to add IoT systems to real fields and tunnel farms, as well as help you in home gardening.</p>
<p>In the next chapter, we will work on a smart home project where we will develop a smart RGB LED light that will be connected to the Amazon Alexa Voice assistant and help you to understand and develop smart home solutions.</p>
</div>
</body></html>