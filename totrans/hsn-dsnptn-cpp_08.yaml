- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: The Curiously Recurring Template Pattern
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奇特重复模板模式
- en: We are already familiar with the concepts of inheritance, polymorphism, and
    virtual functions. A derived class inherits from the base class and customizes
    the behavior of the base class by overriding its virtual functions. All operations
    are done on an instance of the base class, polymorphically. When the base object
    is actually an instance of the derived class, the right customized overrides are
    called. The base class knows nothing about the derived class, which may not even
    have been written when the base class code was written and compiled. The **Curiously
    Recurring Template Pattern** (**CRTP**) turns this well-ordered picture on its
    head, and inside out.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了继承、多态和虚函数的概念。派生类从基类继承，并通过重写基类的虚函数来自定义基类的行为。所有操作都是在基类的一个实例上多态执行的。当基类对象实际上是派生类的实例时，会调用正确的自定义重写。基类对派生类一无所知，派生类可能甚至在基类代码编写和编译时还没有被编写。**奇特重复模板模式**（**CRTP**）将这个有序的画面颠倒过来，并彻底翻转。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is CRTP?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CRTP是什么？
- en: What is static polymorphism and how does it differ from dynamic polymorphism?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态多态是什么，它与动态多态有什么区别？
- en: What are the downsides of virtual function calls, and why may it be preferable
    to resolve such calls at compile time?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚函数调用的缺点是什么，为什么可能更希望在编译时解决这些调用？
- en: What are the other uses of CRTP?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CRTP还有其他什么用途？
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The Google Benchmark library: [https://github.com/google/benchmark](https://github.com/google/benchmark)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Google Benchmark库：[https://github.com/google/benchmark](https://github.com/google/benchmark)
- en: 'Example code: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter08)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter08)
- en: Wrapping your head around CRTP
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 理解CRTP
- en: CRTP was first introduced, under this name, by James Coplien in 1995, in his
    article in *C++ Report*. It is a particular form of a more general bounded polymorphism
    (Peter S. Canning et al., *F-bounded polymorphism for object-oriented programming,
    Conference on Functional Programming Languages and Computer Architecture*, 1989).
    While not a general replacement for virtual functions, it provides the C++ programmer
    with a similar tool that, under the right circumstances, offers several advantages.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: CRTP（Curiously Recurring Template Pattern）这个名称最早由James Coplien在1995年提出，在他的文章《C++
    Report》中。它是一种更一般的有界多态的特殊形式（Peter S. Canning等人，*面向对象编程的有界多态，功能编程语言和计算机架构会议，1989年*）。虽然它不是虚函数的一般替代品，但它为C++程序员提供了一个在适当情况下提供几个优势的类似工具。
- en: What is wrong with a virtual function?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚函数有什么问题？
- en: Before we can talk about a *better* alternative to a virtual function, we should
    consider why we would want to have an alternative at all. What is not to like
    about virtual functions?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论虚函数的更好替代方案之前，我们应该考虑为什么我们想要有替代方案。有什么不喜欢的虚函数？
- en: The problem is the performance overhead. A virtual function call can be several
    times more expensive than a non-virtual call, more for very simple functions that
    would have been inlined were they not virtual (recall that a virtual function
    can never be inlined). We can measure this difference with a microbenchmark, the
    ideal tool for measuring the performance of small fragments of code. There are
    many microbenchmark libraries and tools out there; in this book, we will use the
    Google Benchmark library. To follow along with the examples in this chapter, you
    must first download and install the library (the detailed instructions can be
    found in [*Chapter 5*](B19262_05.xhtml#_idTextAnchor199), *A Comprehensive Look
    at RAII*). Then, you can compile and run the examples.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于性能开销。虚函数调用可能比非虚调用贵几倍，对于本来可以内联但因为是虚函数而不能内联的非常简单的函数来说更是如此（回想一下，虚函数永远不能内联）。我们可以通过微基准测试来衡量这种差异，微基准测试是衡量代码小片段性能的理想工具。现在有很多微基准测试库和工具；在这本书中，我们将使用Google
    Benchmark库。为了跟随本章的示例，您必须首先下载并安装该库（详细说明可以在[*第5章*](B19262_05.xhtml#_idTextAnchor199)，*RAII的全面探讨*中找到）。然后，您可以编译并运行示例。
- en: 'Now that we have the microbenchmark library ready, we can measure the overhead
    of a virtual function call. We are going to compare a very simple virtual function,
    with the minimum amount of code, against a non-virtual function doing the same
    thing. Here is our virtual function:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了微基准测试库，我们可以测量虚函数调用的开销。我们将比较一个非常简单的虚函数，代码量最少，与执行相同操作的非虚函数进行对比。下面是我们的虚函数：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And, here is the equivalent non-virtual one:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是等效的非虚函数：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can now call both of them in a micro-benchmark fixture and measure how long
    each call takes:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在微基准测试环境中调用这两个函数，并测量每个调用所需的时间：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `benchmark::DoNotOptimize` wrapper prevents the compiler from optimizing
    away the unused object, and, along with it, removing the entire set of function
    calls as unnecessary. Note that there is a subtlety in measuring the virtual function
    call time; a simpler way to write the code would be to avoid the `new` and `delete`
    operators and simply construct the derived object on the stack:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`benchmark::DoNotOptimize` 包装器阻止编译器优化掉未使用的对象，以及随之移除的整个函数调用集，因为它们被认为是多余的。注意，在测量虚函数调用时间时存在一个细微之处；编写代码的一个更简单的方法是避免使用
    `new` 和 `delete` 操作符，而直接在栈上构造派生对象：'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, this benchmark is likely to yield the same time as the non-virtual
    function call. The reason is not that a virtual function call has no overhead.
    Rather, in this code, the compiler is able to deduce that the call to the virtual
    function, `f()`, is always a call to `D::f()` (it helps that the call is not done
    through the base class pointer, but rather the derived class reference, so it
    could hardly be anything else). A decent optimizing compiler will de-virtualize
    such a call, for instance, generating a direct call to `D::f()` without the indirection
    and the reference to the *v-table*. Such a call can even be inlined.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个基准测试可能产生的结果与非虚函数调用相同。原因不是虚函数调用没有开销。相反，在这个代码中，编译器能够推断出对虚函数的调用，即 `f()`，总是调用
    `D::f()`（这得益于调用不是通过基类指针，而是通过派生类引用进行的，所以它几乎不可能是其他任何东西）。一个优秀的优化编译器会取消这种调用的虚化，例如，生成一个直接调用
    `D::f()` 的调用，而不需要间接和 `v-table` 的引用。这样的调用甚至可以被内联。
- en: 'Another possible complication is that both microbenchmarks, especially the
    non-virtual call, may be too fast—the body of the benchmark loop is likely to
    take less time than the overhead of the loop. We can remedy that by making several
    calls inside the body of the loop. This can be accomplished with the copy-paste
    feature of your editor, or with the C++ preprocessor macros:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的复杂情况是，这两个微基准测试，尤其是非虚函数调用，可能太快——基准测试循环的主体可能花费的时间少于循环的开销。我们可以通过在循环体内部进行多次调用来解决这个问题。这可以通过编辑器的复制粘贴功能或使用C++预处理器宏来完成：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, inside the benchmark loop, we can write the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在基准测试循环中，我们可以编写以下代码：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The per-iteration time reported by the benchmark now refers to `32` function
    calls. While this does not matter for comparing the two calls, it may be convenient
    to make the benchmark itself report the true number of calls per second by adding
    this line to the end of the benchmark fixture, after the loop:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试报告的每次迭代时间现在指的是 `32` 次函数调用。虽然这并不影响比较两次调用，但可能方便基准测试本身通过在基准测试环境末尾添加此行来报告每秒真正的调用次数：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can now compare the results of the two benchmarks:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以比较两个基准测试的结果：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We see that the virtual function call is almost 10 times more expensive than
    the non-virtual one. Note that this is not exactly a fair comparison; the virtual
    call provides additional functionality. However, some of this functionality can
    be implemented in other ways, without paying the performance overhead.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到虚函数调用几乎是非虚函数调用的10倍昂贵。注意，这并不是一个完全公平的比较；虚调用提供了额外的功能。然而，其中一些功能可以通过其他方式实现，而不必付出性能开销。
- en: Introducing CRTP
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍CRTP
- en: 'Now, we will introduce CRTP, which turns inheritance on its head:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将介绍CRTP，它颠覆了继承的传统：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first change that jumps out is that the base class is now a `class` template.
    The derived class still inherits from the base class, but now from the specific
    instantiation of the base class template—on its own! Class `B` is instantiated
    on class `D`, and class `D` inherits from that instantiation of class `B`, which
    is instantiated on class `D`, which inherits from class `B`, which... that’s recursion
    in action. Get used to it because you will see it often in this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个引人注目的变化是，基类现在是一个`class`模板。派生类仍然从基类继承，但现在是从基类模板的具体实例化继承——独立地！类`B`在类`D`上实例化，而类`D`则从类`B`的该实例化继承，这个实例化是在类`D`上进行的，它又从类`B`继承，以此类推——这就是递归的作用。习惯它吧，因为在本章中你经常会看到它。
- en: 'What is the motivation for this mind-twisting pattern? Consider that now the
    base class has compile-time information about the derived class. Therefore, what
    used to be a virtual function call can now be bound to the right function at compile
    time:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个令人困惑的模式背后的动机是什么？考虑一下，现在基类有了关于派生类的编译时信息。因此，以前是虚拟函数调用现在可以在编译时绑定到正确的函数：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The call itself can still be done on the base class pointer:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 调用本身仍然可以在基类指针上进行：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There is no indirection and no overhead for the virtual call. The compiler
    can, at compile time, track the call all the way to the actual function called,
    and even inline it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 没有间接引用和虚拟调用的开销。编译器可以在编译时跟踪调用，直到实际调用的函数，甚至可以内联它：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The benchmark shows that the function call made through the CRTP takes exactly
    as much time as a regular function call:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试表明，通过CRTP进行的函数调用所需的时间与常规函数调用完全相同：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The main restriction on the CRTP is that the size of the base class, `B`, cannot
    depend on its template parameter, `D`. More generally, the template for class
    `B` has to instantiate with type `D` being an incomplete type. For example, this
    will not compile:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: CRTP的主要限制是基类`B`的大小不能依赖于其模板参数`D`。更普遍地说，类`B`的模板必须实例化，使得类型`D`是一个不完整类型。例如，以下代码将无法编译：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The realization that this code will not compile may come somewhat as a surprise,
    given how similar it is to many widely used templates that refer to the nested
    types of their template parameters. For example, consider this template, which
    converts any sequence container with `push_back()` and `pop_back()` functions
    to a stack:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代码无法编译的认识可能会让人有些惊讶，考虑到它与许多广泛使用的模板非常相似，这些模板引用了它们的模板参数的嵌套类型。例如，考虑以下模板，它将任何具有`push_back()`和`pop_back()`函数的序列容器转换为栈：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that the `using` type alias for `value_type` looks exactly the same as
    the preceding one, in our attempt to declare class `B`. So, what is wrong with
    the one in `B`? Actually, nothing is wrong with class `B` itself. It would compile
    just fine in a context similar to that of our stack class:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`using`类型别名`value_type`看起来与我们在尝试声明类`B`时使用的完全相同。那么，`B`中的那个有什么问题？实际上，类`B`本身并没有问题。在类似于我们的栈类的上下文中，它完全可以编译：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The problem lies not with class `B` itself, but with our intended use of it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 问题不在于类`B`本身，而在于我们对其的预期使用：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At the point where `B<D>` has to be known, type `D` has not been declared yet.
    It cannot be—the declaration of class `D` requires us to know exactly what the
    base class `B<D>` is. So, if class `D` has not been declared yet, how does the
    compiler know that the identified `D` even refers to a type? After all, you cannot
    instantiate a template on a completely unknown type. The answer lies somewhere
    in between—class `D` is forward-declared, the same as if we had this code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`B<D>`必须被知道的时候，类型`D`还没有被声明。它不能被声明——类`D`的声明需要我们知道基类`B<D>`的确切内容。所以，如果类`D`还没有被声明，编译器怎么知道标识的`D`甚至指的是一个类型呢？毕竟，你不能在完全未知的类型上实例化一个模板。答案就在其中——类`D`是提前声明的，就像我们有了以下代码一样：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Some templates can be instantiated on forward-declared types, while others cannot.
    The exact rules can be painstakingly gathered from the standard, but the gist
    is this—anything that might affect the size of the class has to be fully declared.
    A reference to a type declared inside an incomplete type, such as our `using T
    = typename D::T`, would be a forward declaration of a nested class, and those
    are not allowed either.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一些模板可以在前置声明的类型上实例化，而另一些则不能。确切规则可以从标准中痛苦地收集到，但精髓是这样的——任何可能影响类大小的元素都必须完全声明。例如，`using
    T = typename D::T`中对内部声明的类型的引用，将是一个嵌套类的提前声明，这些也是不允许的。
- en: 'On the other hand, the body of a member function of a class template is not
    instantiated until it’s called. In fact, for a given template parameter, a member
    function does not even have to compile, as long as it’s not called. Therefore,
    references to the derived class, its nested types, and its member functions, inside
    the member functions of the base class are perfectly fine. Also, since the derived
    class type is considered forward-declared inside the base class, we can declare
    pointers and references to it. Here is a very common refactoring of the CRTP base
    class that consolidates the uses of the static cast in one place:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，类模板的成员函数的体直到被调用时才会实例化。事实上，对于给定的模板参数，成员函数甚至不需要编译，只要它没有被调用。因此，在基类的成员函数内部对派生类的引用、其嵌套类型及其成员函数的引用是完全正常的。此外，由于派生类类型在基类内部被认为是前向声明的，我们可以声明指向它的指针和引用。以下是一个非常常见的
    CRTP 基类重构示例，它将静态转换的使用集中在了一个地方：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The base class declaration owns a pointer to the incomplete (forward-declared)
    type `D`. It works like any other pointer to an incomplete type; by the time the
    pointer is de-referenced, the type has to be complete. In our case, this happens
    inside the body of the member function; `B::f()`, which, as we discussed, is not
    compiled until it’s called by the client code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 基类声明拥有一个指向不完整（前向声明的）类型 `D` 的指针。它就像任何指向不完整类型的指针一样工作；在指针被解引用之前，类型必须完整。在我们的例子中，这发生在成员函数的体内；`B::f()`，正如我们讨论的那样，它只有在客户端代码调用它时才会被编译。
- en: 'So what do we do if we need to use a nested type of the derived class while
    writing the base class? Inside a function body, there is no problem. If we need
    to use the nested type in the base class itself, it is usually for one of two
    reasons. The first is to declare the return type of a member function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们需要在编写基类时使用派生类的嵌套类型，我们应该怎么办？在函数体内，没有问题。如果我们需要在基类本身中使用嵌套类型，通常有两个原因。第一个是声明成员函数的返回类型：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As we have just discussed, this will not compile. Fortunately, this problem
    is easy to solve, all we have to do is let the compiler deduce the return type:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才讨论的，这不会编译。幸运的是，这个问题很容易解决，我们只需要让编译器推断出返回类型：
- en: '[PRE20]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The second case is more difficult: the nested type is needed to declare a data
    member or a parameter. In this case, there is only one option left: the type should
    be passed into the base class as an additional template parameter. Of course,
    it introduces some redundancy into the code, but it can’t be helped:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况更困难：需要嵌套类型来声明数据成员或参数。在这种情况下，只剩下一种选择：类型应该作为额外的模板参数传递给基类。当然，这会在代码中引入一些冗余，但这是不可避免的：
- en: '[PRE21]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we know what is CRTP and how to code it, let us see what design problems
    can be solved with it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了 CRTP 是什么以及如何编码它，让我们看看它能解决哪些设计问题。
- en: CRTP and static polymorphism
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CRTP 和静态多态
- en: Since CRTP allows us to override base class functions with those of the derived
    class, it implements polymorphic behavior. The key difference is that polymorphism
    happens at compile time, not at runtime.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 CRTP 允许我们用派生类的函数覆盖基类函数，它实现了多态行为。关键的区别在于多态发生在编译时，而不是运行时。
- en: Compile-time polymorphism
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译时多态
- en: 'As we have just seen, CRTP can be used to allow the derived class to customize
    the behavior of the base class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，CRTP 可以用来允许派生类自定义基类的行为：
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If the base class `B::f()` method is called, it dispatches the call to the
    derived class method for the real derived class, just like a virtual function
    does. Of course, in order to fully take advantage of this polymorphism, we have
    to be able to call the methods of the base class through the base class pointer.
    Without this ability, we are simply calling methods of the derived class whose
    type we already know:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用基类 `B::f()` 方法，它将调用传递给实际派生类的方法，就像虚拟函数一样。当然，为了充分利用这种多态，我们必须能够通过基类指针调用基类的方法。如果没有这种能力，我们只是在调用我们已知类型的派生类的方法：
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that the function call looks exactly like any virtual function class, with
    the base class pointer. The actual function, `f()`, that is called comes from
    the derived class, `D::f()`. There is, however, a significant difference—the actual
    type of the derived class, `D`, has to be known at compile time—the base class
    pointer is not `B*` but rather `B<D>*`, which implies that the derived object
    is of type `D`. There does not seem to be much point to such *polymorphism* if
    the programmer has to know the actual type. But, that is because we have not fully
    thought through what *compile-time polymorphism* really means. Just as the benefit
    of a virtual function is that we can call member functions of a type we don’t
    even know exists, the same has to be true for *static polymorphism* to be useful.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数调用看起来与任何带有基类指针的虚拟函数类完全一样。被调用的实际函数，`f()`，来自派生类，`D::f()`。然而，有一个显著的区别——派生类`D`的实际类型必须在编译时已知——基类指针不是`B*`而是`B<D>*`，这意味着派生对象是类型`D`。如果程序员必须知道实际类型，这种*多态*似乎没有太多意义。但是，这是因为我们还没有完全想清楚*编译时多态*真正意味着什么。正如虚拟函数的好处在于我们可以调用我们甚至不知道存在的类型的成员函数一样，静态多态也必须具有同样的好处才能有用。
- en: 'How do we write a function that has to compile for parameters of an unknown
    type? With a function template, of course:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何编写一个必须为未知类型参数编译的函数？当然，使用函数模板：
- en: '[PRE24]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is a template function that can be called on any base class pointer, and
    it automatically deduces the type of the derived class, `D`. Now, we can write
    what looks like regular polymorphic code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个模板函数，可以在任何基类指针上调用，并且它自动推断派生类`D`的类型。现在，我们可以编写看起来像常规多态代码的东西：
- en: '[PRE25]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note that, on line one, the object has to be constructed with the knowledge
    of the actual type. This is always the case; the same is true for regular runtime
    polymorphism with virtual functions:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第一行，对象必须使用实际类型的知识来构建。这始终是这种情况；对于具有虚拟函数的常规运行时多态也是如此：
- en: '[PRE26]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In both cases, on line two, we invoke some code that was written only with
    the knowledge of the base class. The difference is that, with run-time polymorphism,
    we have a common base class and some functions that operate on it. With CRTP and
    static polymorphism, there is a common base class template but no single common
    base class (a template is not a type) and every function that operates on this
    base template becomes a template itself. To make the symmetry (not equivalence!)
    between the two types of polymorphism complete, we just need to figure out two
    more special cases: pure virtual functions and polymorphic destruction. Let’s
    start with the former.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种情况下，在第二行，我们调用了一些只了解基类知识编写的代码。区别在于，在运行时多态中，我们有一个共同的基类和一些操作它的函数。在CRTP和静态多态中，有一个共同的基类模板，但没有单个共同的基类（模板不是类型）并且每个操作这个基类模板的函数本身也成为了一个模板。为了使两种多态类型的对称性（而不是等价性！）完整，我们只需要找出另外两个特殊情况：纯虚拟函数和多态析构。让我们从前者开始。
- en: The compile-time pure virtual function
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译时纯虚拟函数
- en: What would be the equivalent of the pure virtual function in the CRTP scenario?
    A pure virtual function must be implemented in all derived classes. A class that
    declares a pure virtual function, or inherits one and does not override it, is
    an abstract class; it can be further derived from, but it cannot be instantiated.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在CRTP场景中，纯虚拟函数的等价物是什么？纯虚拟函数必须在所有派生类中实现。声明纯虚拟函数的类，或者继承了一个纯虚拟函数但没有重写的类，是一个抽象类；它可以进一步派生，但不能实例化。
- en: When we contemplate the equivalent of a pure virtual function for static polymorphism,
    we realize that our CRTP implementation suffers from a major vulnerability. What
    happens if we forget to override the *compile-time virtual function,* `f()`, in
    one of the derived classes?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑静态多态中纯虚拟函数的等价物时，我们意识到我们的CRTP实现存在一个主要漏洞。如果我们忘记在派生类中重写*编译时虚拟函数*，`f()`，会发生什么？
- en: '[PRE27]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code compiles with no errors or warnings—on line one, we call `B::f()`,
    which, in turn, calls `D::f()`. Class `D` does not declare its own version of
    the member `f()`, so the one inherited from the base class is the one that is
    called. That is, of course, the member function, `B::f()`, that we have already
    seen, which again calls `D::f()`, which is really `B::f()` `...` and we have an
    infinite loop.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码编译时没有错误或警告——在第一行，我们调用`B::f()`，它反过来调用`D::f()`。类`D`没有声明自己的`f()`成员函数版本，所以调用的是从基类继承的版本。也就是说，当然是之前已经见过的成员函数`B::f()`，它再次调用`D::f()`，实际上是`B::f()`
    `...`，我们得到了一个无限循环。
- en: 'The problem here is that nothing requires us to override the member function
    `f()` in the derived class, but the program is malformed if we don’t. The root
    of the problem is that we are mixing together the interface and the implementation—the
    public member function declaration in the base class says that all derived classes
    must have a function, `void f(int)`, as a part of their public interface. The
    derived class’s version of the same function provides the actual implementation.
    We will cover separating the interface and the implementation in [*Chapter 14*](B19262_14.xhtml#_idTextAnchor640),
    *The Template Method Pattern and the Non-Virtual Idiom*, but for now, suffice
    it to say that our life would be a lot easier if these functions had different
    names:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是没有要求我们在派生类中覆盖成员函数`f()`，但如果我们不覆盖，程序就会不完整。问题的根源在于我们将接口和实现混合在一起——基类中的公共成员函数声明表明所有派生类都必须有一个`void
    f(int)`函数作为它们公共接口的一部分。派生类中相同函数的版本提供了实际实现。我们将在[*第14章*](B19262_14.xhtml#_idTextAnchor640)“模板方法模式和不可虚拟语法的非虚拟方法”中介绍如何分离接口和实现，但到目前为止，只需说如果这些函数有不同的名字，我们的生活就会容易得多：
- en: '[PRE28]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: What happens now if we forget to implement `D::f_impl()`? The code does not
    compile, because there is no such member function in class `D`, either directly
    or through inheritance. So, we have implemented a compile-time pure virtual function!
    Note that the virtual function is actually `f_impl()`, not `f()`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们忘记实现`D::f_impl()`会发生什么？代码无法编译，因为类`D`中既没有这样的成员函数，也没有通过继承。因此，我们已经实现了一个编译时纯虚函数！请注意，虚拟函数实际上是`f_impl()`，而不是`f()`。
- en: 'With that accomplished, how would we implement a regular virtual function,
    with a default implementation that can be optionally overridden? If we follow
    the same pattern of separating the interface and the implementation, we only have
    to provide the default implementation for `B::f_impl()`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个任务后，我们该如何实现一个常规的虚函数，它有一个默认实现，可以被可选地覆盖？如果我们遵循分离接口和实现的相同模式，我们只需要提供`B::f_impl()`的默认实现：
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The last special case we need to cover is polymorphic destruction.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理的最后一个特殊情况是多态销毁。
- en: Destructors and polymorphic deletion
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 析构函数和多态删除
- en: So far, we have willfully avoided tackling the issue of deleting objects implemented
    with CRTP in some sort of polymorphic fashion. In fact, if you go back and reread
    the examples that presented complete code, such as the benchmark fixture, `BM_static`,
    in the *Introducing CRTP* section, we either avoided deleting the object altogether
    or constructed a derived object on the stack. This is because polymorphic deletion
    presents an additional complication that we are finally ready to deal with.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们故意避免以某种多态方式处理使用CRTP实现的删除对象的问题。实际上，如果你回顾并重新阅读了介绍完整代码的示例，例如在“介绍CRTP”部分中的基准测试组件`BM_static`，我们要么完全避免了删除对象，要么在栈上构建了一个派生对象。这是因为多态删除带来了额外的复杂性，我们终于准备好处理它了。
- en: 'First of all, let’s note that, in many cases, polymorphic deletion is not a
    concern. All objects are created with their actual types known. If the code that
    constructs the objects also owns and eventually deletes them, the question *what
    is the type of the deleted object?* is never really asked. Similarly, if the objects
    are stored in a container, they are not deleted through the base class pointer
    or reference:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们注意，在许多情况下，多态删除并不是一个问题。所有对象都是已知其实际类型的情况下创建的。如果构建对象的代码也拥有并最终删除它们，那么关于“被删除对象的类型是什么？”这个问题就永远不会真正被提出。同样，如果对象存储在容器中，它们不是通过基类指针或引用来删除的：
- en: '[PRE30]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In many cases, as shown in the preceding example, the objects are constructed
    and deleted with their actual type known and no polymorphism involved, but the
    code that works on them in between is universal, written to work on the base type
    and, therefore, any class derived from that base type.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，正如前一个示例所示，对象以其实际类型构建和删除，并且在此过程中没有涉及多态，但在这之间对它们进行操作的代码是通用的，编写为针对基类型工作，因此，任何从该基类型派生的类。
- en: 'But, what if we need to actually delete the object through the base class pointer?
    Well, that is not easy. First of all, a simple call to the `delete` operator will
    do the wrong thing:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们需要通过基类指针实际删除对象呢？这并不容易。首先，对`delete`运算符的简单调用将做错事：
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code compiles. Worse, even the compilers that normally warn when a class
    has a virtual function but a non-virtual destructor do not generate any warnings
    in this case, because there are no virtual functions, and CRTP polymorphism is
    not recognized by the compiler as a potential source of trouble. However, the
    trouble there is that only the destructor of the base class, `B<D>`, itself is
    called; the destructor of `D` is never called!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以编译。更糟糕的是，甚至那些通常在类有虚拟函数但没有虚拟析构函数时发出警告的编译器在这种情况下也不会生成任何警告，因为没有虚拟函数，并且编译器不将CRTP多态识别为潜在的问题来源。然而，问题在于只调用了基类析构函数`B<D>`本身；`D`的析构函数从未被调用！
- en: 'You may be tempted to resolve this problem the same way as we deal with other
    *compile-time virtual* functions, by casting to the known derived type and calling
    the indented member function of the derived class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会倾向于以处理其他*编译时虚拟*函数相同的方式解决这个问题，通过转换为已知的派生类型并调用派生类的缩进成员函数：
- en: '[PRE32]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Unlike the regular functions, this attempt at polymorphism is badly broken,
    for not one but two reasons—first of all, in the destructor of the base class,
    the actual object is not of the derived type anymore, and calling any member functions
    of the derived class on it results in undefined behavior. Secondly, even if this
    somehow worked, the destructor of the derived class is going to do its work and
    then call the destructor of the base class, which results in an infinite loop.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规函数不同，这种多态尝试严重错误，原因有两个——首先，在基类的析构函数中，实际对象不再是派生类型，对其调用派生类的任何成员函数都会导致未定义行为。其次，即使这
    somehow 成功了，派生类的析构函数将执行其工作并调用基类的析构函数，这会导致无限循环。
- en: 'There are two solutions to this problem. One option is to extend the compile-time
    polymorphism to the act of deletion in the same way as we do for any other operation,
    with a function template:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种解决这个问题的方法。一个选择是将编译时多态扩展到与任何其他操作相同的删除操作，使用一个函数模板：
- en: '[PRE33]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is well-defined. The `delete` operator is called on the pointer of the
    actual type, `D`, and the right destructor is called. However, you must take care
    to always delete these objects using this `destroy()` function, instead of calling
    the `delete` operator.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是明确定义的。`delete`运算符被调用在实型的指针上，`D`，并且调用正确的析构函数。然而，你必须注意始终使用这个`destroy()`函数来删除这些对象，而不是调用`delete`运算符。
- en: The second option is to actually make the destructor virtual. This does bring
    back the overhead of the virtual function call, but only for the destructor. It
    also increases the object size by the size of the virtual pointer. If neither
    of these two sources of overhead is a concern, you could use this hybrid static-dynamic
    polymorphism, where all virtual function calls are bound at compile time and with
    no overhead, except the destructor.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是实际上使析构函数成为虚拟的。这确实会带来虚拟函数调用的开销，但仅限于析构函数。它还会使对象大小增加虚拟指针的大小。如果这两个开销来源都不是问题，你可以使用这种混合静态-动态多态，其中所有虚拟函数调用都在编译时绑定，并且没有开销，除了析构函数之外。
- en: CRTP and access control
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CRTP和访问控制
- en: When implementing CRTP classes, you do have to worry about access—any method
    you want to call has to be accessible. Either the method has to be public, or
    the caller has to have special access. This is a little different from the way
    virtual functions are called—when calling a virtual function, the caller must
    have access to the member function that is named in the call. For example, a call
    to the base class function, `B::f()`, requires that either `B::f()` is public
    or the caller has access to non-public member functions (another member function
    of class `B` can call `B::f()` even if it’s private). Then, if `B::f()` is virtual
    and overridden by the derived class `D`, the override `D::f()` is actually called
    at `D::f()` be accessible from the original call site; for example, `D::f()` can
    be private.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 CRTP 类时，你必须担心访问权限——你想调用的任何方法都必须是可访问的。要么方法必须是公共的，要么调用者必须具有特殊访问权限。这与调用虚函数的方式略有不同——在调用虚函数时，调用者必须有权访问在调用中命名的成员函数。例如，调用基类函数
    `B::f()` 要求 `B::f()` 是公共的，或者调用者有权访问非公共成员函数（类 `B` 的另一个成员函数可以调用 `B::f()` 即使它是私有的）。然后，如果
    `B::f()` 是虚函数并被派生类 `D` 覆盖，那么覆盖 `D::f()` 实际上是在 `D::f()` 可从原始调用点访问时调用的；例如，`D::f()`
    可以是私有的。
- en: 'The situation with CRTP polymorphic calls is somewhat different. All calls
    are explicit in the code, and the callers must have access to the functions they
    call. Usually, it means that the base class must have access to the member functions
    of the derived class. Consider the following example from an earlier section,
    but now with explicit access control:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: CRTP 多态调用的情形略有不同。所有调用在代码中都是显式的，调用者必须有权访问他们调用的函数。通常这意味着基类必须有权访问派生类的成员函数。考虑以下来自早期部分的示例，但现在带有显式访问控制：
- en: '[PRE34]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, both functions, `B::f_impl()` and `D::f_impl()`, are private in their
    respective classes. The base class has no special access to the derived class,
    and cannot call its private member functions. Unless we want to change the member
    function, `D::f_impl()`, from private to public and allow any caller access to
    it, we have to declare the base class to be a friend of the derived class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，两个函数，`B::f_impl()` 和 `D::f_impl()`，在各自的类中都是私有的。基类对派生类没有特殊访问权限，无法调用其私有成员函数。除非我们想将成员函数
    `D::f_impl()` 从私有改为公共，并允许任何调用者访问它，否则我们必须声明基类为派生类的友元。
- en: 'There is also some benefit in doing the reverse. Let’s create a new derived
    class, `D1`, with a different override of the implementation function, `f_impl()`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来操作也有一些好处。让我们创建一个新的派生类 `D1`，它有一个不同的实现函数 `f_impl()` 的覆盖：
- en: '[PRE35]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This class has a subtle error—it is not actually derived from `B<D1>` but from
    the old class, `B<D>`; a mistake that is easy to make when creating a new class
    from an old template. This mistake will be found if we attempt to use the class
    polymorphically:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个细微的错误——它实际上并没有从 `B<D1>` 派生，而是从旧类 `B<D>` 派生；在从一个旧模板创建新类时容易犯的错误。如果我们尝试多态地使用这个类，这个错误就会被发现：
- en: '[PRE36]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This does not compile because `B<D1>` is not a base class of `D1`. However,
    not all uses of CRTP involve a polymorphic call. In any case, it would be better
    if the error was caught when class `D1` was first declared. We can accomplish
    that by making class `B` into a sort of abstract class, only in the sense of static
    polymorphism. All it takes is to make the constructor of class `B` private and
    to declare the derived class to be a friend:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这无法编译，因为 `B<D1>` 不是 `D1` 的基类。然而，并非所有 CRTP 的使用都涉及多态调用。无论如何，如果在类 `D1` 首次声明时就能捕获这个错误会更好。我们可以通过将类
    `B` 变成一种抽象类来实现这一点，仅从静态多态的角度来看。只需将类 `B` 的构造函数设为私有，并将派生类声明为友元即可：
- en: '[PRE37]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Note the somewhat unusual form of the friend declaration—`friend D` and not
    `friend class D`. This is how you write a friend declaration for the template
    parameter. Now, the only type that can construct an instance of class `B<D>` is
    that specific derived class, `D`, which is used as the template parameter, and
    the erroneous code, `class D1 : public B<D>`, does not compile any longer.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '注意友元声明的形式有些不寻常——`friend D` 而不是 `friend class D`。这是为模板参数编写友元声明的方式。现在，唯一可以构造
    `B<D>` 类实例的类型是特定派生类 `D`，它用作模板参数，而错误的代码 `class D1 : public B<D>` 现在无法编译。'
- en: Now that we know how CRTP works, let us see what it is useful for.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了 CRTP 的工作原理，让我们看看它有什么用途。
- en: CRTP as a delegation pattern
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CRTP 作为一种委托模式
- en: So far, we have used CRTP as a compile-time equivalent of dynamic polymorphism,
    including virtual-like calls through the base pointer (compile-time, of course,
    with a template function). This is not the only way CRTP can be used. In fact,
    more often than not, the function is called directly on the derived class. This
    is a very fundamental difference—typically, public inheritance expresses the *is-a*
    relationship—the derived object is a kind of a base object. The interface and
    the generic code are in the base class, while the derived class overrides the
    specific implementation. This relation continues to hold when a CRTP object is
    accessed through the base class pointer or reference. Such use of CRTP is sometimes
    also called a **static interface**.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已将 CRTP 作为动态多态的编译时等价物使用，包括通过基指针进行的类似虚函数的调用（当然，是编译时，通过模板函数）。这并不是 CRTP
    可以使用的唯一方式。实际上，更常见的情况是函数直接在派生类上调用。这是一个非常基本的不同点——通常，公有继承表示 *is-a* 关系——派生对象是一种基对象。接口和泛型代码在基类中，而派生类覆盖了特定的实现。当通过基类指针或引用访问
    CRTP 对象时，这种关系仍然成立。这种使用 CRTP 的方式有时也被称为 **静态接口**。
- en: When the derived object is used directly, the situation is quite different—the
    base class is no longer the interface, and the derived class is not just the implementation.
    The derived class expands the interface of the base class, and the base class
    delegates some of its behavior to the derived class.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当直接使用派生对象时，情况就完全不同了——基类不再是接口，派生类不仅仅是实现。派生类扩展了基类的接口，基类将一些行为委派给派生类。
- en: Expanding the interface
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展接口
- en: Let’s consider several examples where CRTP is used to delegate behavior from
    the base class to the derived one.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑几个使用 CRTP 将行为从基类委派到派生类的例子。
- en: 'The first example is a very simple one—for any class that provides `operator+=()`,
    we want to generate `operator+()` automatically that used the former:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子非常简单——对于任何提供 `operator+=()` 的类，我们希望自动生成 `operator+()`，它使用前者：
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Any class that inherits from `plus_base` in this manner automatically acquires
    the addition operator that is guaranteed to match the provided increment operator.
    The observant among you might point out that the way we have declared the operator
    `+` here is, well, strange. Aren’t two-argument operators supposed to be non-member
    functions? Indeed, they usually are. Nothing in the standard requires them to
    be, and the preceding code is technically valid. The reason binary operators such
    as `==`, `+`, and so on are usually declared as non-member functions has to do
    with implicit conversions—if we have an addition, `x + y`, and the intended `operator+`
    is a member function, it has to be a member function of the `x` object. Not any
    object implicitly convertible to the type of `x`, but `x` itself—it’s a member
    function call on `x`. In contrast, the `y` object has to be implicitly convertible
    to the type of the argument of that member `operator+` usually, the same type
    as `x`. To restore the symmetry and allow implicit conversions (if any are provided)
    on both the left- and right-hand side of the `+` sign, we have to declare `operator+`
    as a non-member function. Usually, such a function needs to have access to the
    private data members of the class, as in the example previously, so it has to
    be declared a friend. Putting all of this together, we arrive at this alternative
    implementation:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 任何以这种方式从 `plus_base` 继承的类都会自动获得一个加法运算符，该运算符保证与提供的增量运算符匹配。你们中的一些人可能会指出，我们在这里声明运算符
    `+` 的方式很奇怪。二元运算符不应该是非成员函数吗？的确，它们通常是这样的。标准中没有规定它们必须是，前面的代码在技术上也是有效的。二元运算符如 `==`、`+`
    等通常声明为非成员函数的原因与隐式转换有关——如果我们有一个加法操作 `x + y`，并且预期的 `operator+` 是成员函数，它必须是 `x` 对象的成员函数。不是任何可以隐式转换为
    `x` 类型的对象，而是 `x` 本身——这是对 `x` 的成员函数调用。相比之下，`y` 对象必须隐式转换为那个成员 `operator+` 的参数类型，通常与
    `x` 相同。为了恢复对称性并允许在 `+` 符号的左右两侧进行隐式转换（如果提供了的话），我们必须将 `operator+` 声明为非成员函数。通常，这样的函数需要访问类的私有数据成员，就像之前的例子一样，因此它必须被声明为友元。将所有这些放在一起，我们得到了这个替代实现：
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There is a significant difference between this use of CRTP and the one we saw
    earlier—the object that is going to be used in the program is of type `C`, and
    it will never be accessed through a pointer to `plus_base<C>`. The latter isn’t
    a complete interface for anything but is really an implementation that makes use
    of the interface provided by the derived class. CRTP here is used as an implementation
    technique, not as a design pattern. However, the boundary between the two is not
    always clear: some implementation techniques are so powerful that they can alter
    design choices.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前看到的CRTP的使用相比，这里有一个显著的区别——程序中将使用的对象是类型`C`，它将永远不会通过`plus_base<C>`的指针来访问。后者并不是任何事物的完整接口，而是一个利用派生类提供的接口的实现。在这里，CRTP被用作实现技术，而不是设计模式。然而，两者之间的界限并不总是清晰的：一些实现技术非常强大，以至于它们可以改变设计选择。
- en: 'One example is the generated comparison and ordering operations. In C++20,
    the recommended choice for designing interfaces of value types (or any other comparable
    and ordered types) is to provide only two operators, `operator==()` and `operator<=>()`.
    The compiler will generate the rest. If you like this approach to interface design
    and want to use it in earlier versions of C++, you need a way to implement it.
    CRTP offers us a possible implementation. We will need a base class that will
    generate `operator!=()` from the `operator==()` of the derived class. It will
    also generate all ordering operators; of course, we cannot use `operator<=>()`
    before C++20, but we can use any member function name we agree on, such as `cmp()`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是生成的比较和排序操作。在C++20中，设计值类型（或任何其他可比较和排序的类型）的接口的推荐选择是只提供两个运算符，`operator==()`和`operator<=>()`。编译器将生成其余部分。如果你喜欢这种接口设计方法，并想在C++的早期版本中使用它，你需要一种实现它的方法。CRTP为我们提供了一个可能的实现。我们需要一个基础类，它将从派生类的`operator==()`生成`operator!=()`。它还将生成所有排序运算符；当然，在C++20之前我们不能使用`operator<=>()`，但我们可以使用任何我们同意的成员函数名称，例如`cmp()`：
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There are many such examples to be found in the literature on CRTP. Along with
    these examples, you can find discussions on whether C++20 concepts offer a better
    alternative. The next section explains what this is about.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在CRTP的文献中可以找到许多这样的例子。随着这些例子，你还可以找到关于C++20概念是否提供了更好的替代方案的讨论。下一节将解释这是关于什么的。
- en: CRTP and concepts
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CRTP和概念
- en: At the first glance, it is unclear how concepts could replace CRTP. Concepts
    (which you can read more about in [*Chapter 7*](B19262_07.xhtml#_idTextAnchor314),
    *SFINAE, Concepts, and Overload Resolution Management*) are all about restricting
    interfaces, while CRTP extends the interfaces.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一眼看上去，不清楚概念如何取代CRTP。概念（你可以在[*第7章*](B19262_07.xhtml#_idTextAnchor314)，*SFINAE、概念和重载解析管理）都是关于限制接口的，而CRTP扩展了接口。
- en: 'There are discussions inspired by cases where both concepts and CRTP can solve
    the same problem by totally different means. Recall our use of CRTP to automatically
    generate `operator+()` from `operator+=()`; all we had to do was to inherit from
    the special base class template:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些讨论是由那些概念和CRTP都可以通过完全不同的方式解决相同问题的案例引发的。回想一下我们使用CRTP从`operator+=()`自动生成`operator+()`的情况；我们唯一需要做的就是从特殊的基础类模板继承：
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Our base class serves two purposes. First, it generates `operator+()` from
    `operator+=()`. Second, it provides a mechanism for classes to opt into this automation:
    to receive the generated `operator+()`, a class must inherit from `plus_base`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基础类有两个作用。首先，它从`operator+=()`生成`operator+()`。其次，它为类提供了一个选择加入这种自动化的机制：要接收生成的`operator+()`，一个类必须继承自`plus_base`。
- en: 'The first problem by itself is easy to solve, we can just define a global `operator+()`
    template:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题本身很容易解决，我们只需定义一个全局的`operator+()`模板：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'There is a “slight” problem with this template: we just provided a global `operator+()`
    for every type in our program, whether it needs one or not. Furthermore, most
    of the time it won’t even compile since not all classes define `operator+=()`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板有一个“轻微”的问题：我们为程序中的每一个类型都提供了一个全局的`operator+()`，无论它是否需要。此外，大多数时候甚至无法编译，因为并非所有类都定义了`operator+=()`。
- en: 'This is where the concepts come in: we can restrict the applicability of our
    new `operator+()` so, in the end, it is generated for the same types that we would
    have otherwise inherited from `plus_base` and no other.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是概念发挥作用的地方：我们可以限制我们新`operator+()`的应用范围，最终，它只为与我们原本从`plus_base`继承的类型生成，而不为其他类型生成。
- en: 'One way to do this is to require that the template parameter type T at least
    have the increment operator:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的一种方法是要求数据模板参数类型 T 至少要有增量操作符：
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'However, this is not the same result as what we got with CRTP. In some cases,
    it may be a better result: instead of having to opt every class into the automatic
    generation of `operator+()`, we did it for every class that satisfies certain
    restrictions. But in other cases, any reasonable description of these restrictions
    produces overly broad results, and we have to opt into our types one by one. This
    is easy to do with concepts as well, but the technique used is not widely known.
    All you need to do is to define a concept whose general case is false (a Boolean
    variable will suffice):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是我们用 CRTP 得到的相同结果。在某些情况下，它可能是一个更好的结果：我们不需要为每个类选择加入自动生成 `operator+()`，我们只为满足某些限制的每个类做了这件事。但在其他情况下，任何对这些限制的合理描述都会产生过于宽泛的结果，我们必须逐个选择加入我们的类型。使用概念也可以这样做，但使用的技巧并不广为人知。你所需要做的就是定义一个其通用情况为假的（布尔变量就足够了）概念：
- en: '[PRE44]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, for every type that needs to opt in, we specialize the concept:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于需要选择加入的每种类型，我们专门化这个概念：
- en: '[PRE45]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'There are some advantages to both approaches: CRTP uses a base class that can
    be more complex than just a wrapper for a definition of an operator; while concepts
    can combine explicit opt-in with some more general restrictions when appropriate.
    However, these discussions miss a much more important distinction: CRTP can be
    used to expand class interface with both member and non-member functions, while
    concepts can be used only with non-member functions, including non-member operators.
    When both concepts and CRTP-based solutions are applicable, you should choose
    the most appropriate one (for simple functions such as `operator+()`, concepts
    are probably easier to read). Also, you don’t have to wait until C++20 to use
    the concept-based restrictions: the methods of emulating concepts shown in [*Chapter
    7*](B19262_07.xhtml#_idTextAnchor314), *SFINAE, Concepts, and Overload Resolution
    Management*, are more than adequate here.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有一些优点：CRTP 使用一个基类，它可以比仅仅是一个操作符定义的包装更复杂；而概念可以在适当的时候结合显式选择加入和一些更一般的限制。然而，这些讨论忽略了一个更重要的区别：CRTP
    可以用来通过成员和非成员函数扩展类接口，而概念只能用于非成员函数，包括非成员操作符。当概念和基于 CRTP 的解决方案都适用时，你应该选择最合适的一个（对于像
    `operator+()` 这样的简单函数，概念可能更容易阅读）。此外，你不必等到 C++20 才能使用基于概念的限制：在 [*第 7 章*](B19262_07.xhtml#_idTextAnchor314)，*SFINAE、概念和重载解析管理*
    中展示的模拟概念的技巧在这里是绰绰有余的。
- en: 'Of course, we can use concepts with CRTP instead of trying to replace CRTP:
    if the CRTP base class template has some requirements on the type we want to derive
    from it, we can enforce these with concepts. The use of concepts here is no different
    from what we find in the chapter dedicated to them. But we are going to stay with
    CRTP and what else can be done with it.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用与 CRTP 一起的概念，而不是试图替换 CRTP：如果 CRTP 的基类模板对我们想要从中派生的类型有一些要求，我们可以通过概念来强制执行这些要求。在这里使用概念的方式与我们发现的那一章中的方式没有不同。但我们将继续使用
    CRTP 以及它还能做什么。
- en: CRTP as an implementation technique
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CRTP 作为一种实现技术
- en: 'As we pointed out earlier, CRTP is often used as a purely implementation pattern;
    however, even in this role, it can influence design: some design choices are desirable
    but hard to implement, and, if a good implementation technique comes along, the
    design choices often change. So, let us see what problems can be solved with CRTP.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前指出的，CRTP 通常被用作一种纯实现模式；然而，即使在这个角色中，它也可以影响设计：一些设计选择是可取的但难以实现，如果出现一种好的实现技术，设计选择通常会改变。因此，让我们看看
    CRTP 可以解决哪些问题。
- en: CRTP for code reuse
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CRTP 用于代码复用
- en: 'Let us start with a specific implementation issue: we have multiple classes
    that have some common code. Ordinarily, we would write a base class for them.
    But the common code is not really common: it does the same thing for all classes
    except it for the types it uses. What we need is not a common base class but a
    common base class template. And that brings us to CRTP.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从具体实现问题开始：我们有多达多个具有一些共同代码的类。通常，我们会为它们写一个基类。但共同代码并不真正通用：它为所有类做同样的事情，除了它使用的类型。我们需要的是一个通用基类模板。这把我们带到了
    CRTP。
- en: 'An example is an object registry. It may be desirable, often for debugging
    purposes, to know how many objects of a certain type are currently in existence,
    and perhaps even to maintain a list of such objects. We definitely do not want
    to instrument every class with the registry mechanism, so we want to move it to
    the base class. But, now we have a problem—if we have two derived classes, `C`
    and `D`, both inherit from the same base class, `B`, and the count of instances
    of `B` will be the total for both `C` and `D`. The problem is not that the base
    class can’t determine what the real type of the derived class is—it can, if we’re
    willing to pay the cost of runtime polymorphism. The problem is that the base
    class has only one counter (or however many are coded in the class), while the
    number of different derived classes is unlimited. We could implement a very complex,
    expensive, and non-portable solution that uses `typeid`, to determine the class
    name and maintain a map of names and counters. But, what we really need is one
    counter per derived type, and the only way to do it is to make the base class
    aware of the derived class type at compile time. This brings us back to CRTP:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是对象注册表。出于调试目的，可能需要知道当前存在多少个特定类型的对象，甚至可能需要维护这样一个对象的列表。我们肯定不希望将注册机制应用于每个类，因此我们希望将其移动到基类。但是，现在我们遇到了一个问题——如果我们有两个派生类，`C`
    和 `D`，它们都从同一个基类 `B` 继承，那么 `B` 的实例计数将是 `C` 和 `D` 的总和。问题不在于基类无法确定派生类的实际类型——如果愿意承担运行时多态的成本，它是可以确定的。问题在于基类只有一个计数器（或者类中编码的任何数量），而派生类的数量是无限的。我们可以实现一个非常复杂、昂贵且不可移植的解决方案，使用
    `typeid` 来确定类名并维护一个名称和计数器的映射。但，我们真正需要的是每个派生类型一个计数器，而唯一的方法是在编译时让基类知道派生类类型。这又把我们带回了
    CRTP：
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We have declared the constructor and the destructor protected because we don’t
    want any registry objects created, except by the derived classes. It is also important
    to not forget the copy constructor, otherwise, the default one is generated by
    the compiler, and it does not increment the counter or update the list (but the
    destructor does, so the counter will go negative and overflow). For each derived
    class, `D`, the base class is `registry<D>`, which is a separate type with its
    own static data members, `count` and `head` (the latter is the head of the list
    of currently active objects). Any type that needs to maintain the runtime registry
    of active objects now only needs to inherit from `registry`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构造函数和析构函数声明为受保护的，因为我们不希望除了派生类之外创建任何注册对象。同样重要的是不要忘记复制构造函数，否则编译器会生成默认的复制构造函数，它不会增加计数器或更新列表（但析构函数会，所以计数器会变成负数并溢出）。对于每个派生类
    `D`，基类是 `registry<D>`，这是一个独立的类型，具有自己的静态数据成员，`count` 和 `head`（后者是当前活动对象列表的头部）。任何需要维护活动对象运行时注册的类型现在只需要从
    `registry` 继承：
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: A similar example, where the base class needs to know the type of the derived
    class and use it to declare its own members, can be found in [*Chapter 9*](B19262_09.xhtml#_idTextAnchor406),
    *Named Arguments, Method Chaining, and Builder Pattern*. Next, we will see another
    example of CRTP, and this time the availability of the implementation opens the
    door to a particular design choice.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类似的例子，其中基类需要知道派生类的类型并使用它来声明自己的成员，可以在[*第9章*](B19262_09.xhtml#_idTextAnchor406)中找到，*命名参数、方法链和构建器模式*。接下来，我们将看到另一个
    CRTP 的例子，这次实现的可用性为特定的设计选择打开了大门。
- en: CRTP for generic interfaces
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型接口的 CRTP
- en: 'Another scenario where it is often necessary to delegate behavior to derived
    classes is the problem of visitation. Visitors, in a general sense, are objects
    that are invoked to process a collection of data objects and execute a function
    on each one in turn. Often, there are hierarchies of visitors, where the derived
    classes customize or alter some aspect of the behavior of the base classes. While
    the most common implementation of visitors uses dynamic polymorphism and virtual
    function calls, a static visitor offers the same sort of performance benefits
    we saw earlier. Visitors are not usually invoked polymorphically; you create the
    visitor you want and run it. The base visitor class, however, does call the member
    functions that may be dispatched, at compile time, to the derived classes if they
    have the right overrides. Consider this generic visitor for a collection of animals:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个经常需要将行为委托给派生类的情况是访问问题。在广义上，访问者是指被调用以处理一组数据对象并对每个对象依次执行函数的对象。通常，存在访问者层次结构，其中派生类定制或改变基类行为的一些方面。虽然访问者的最常见实现使用动态多态和虚函数调用，但静态访问者提供了我们之前看到的相同类型的性能优势。访问者通常不是通过多态调用的；你创建你想要的访问者并运行它。然而，基访问者类会调用在编译时可能被调度到派生类的成员函数，如果它们有正确的覆盖。考虑以下用于动物集合的通用访问者：
- en: '[PRE48]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Note that the main visitation method is a template member function (a template
    within a template!), and it accepts any kind of iterator that can iterate over
    a sequence of `Animal` objects. Also, by declaring a private default constructor
    at the bottom of the class, we are protecting ourselves from making a mistake
    where the derived class incorrectly specifies its own type for the inheritance.
    Now, we can start creating some visitors. The default visitor simply accepts the
    default actions provided by the generic visitor:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，主要访问方法是一个模板成员函数（一个模板中的模板！），它接受任何可以遍历`Animal`对象序列的迭代器。此外，通过在类底部声明一个私有默认构造函数，我们保护自己免于在派生类中错误地指定其自己的继承类型。现在，我们可以开始创建一些访问者。默认访问者简单地接受通用访问者提供的默认操作：
- en: '[PRE49]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can visit any sequence of `Animal` objects, for example, a vector:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以访问任何`Animal`对象的序列，例如，一个向量：
- en: '[PRE50]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The visitation yields the expected result:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 访问产生了预期的结果：
- en: '[PRE51]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'But, we don’t have to constrain ourselves to the default actions—we can override
    the visitation actions for one or more animal types:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们不必局限于默认操作——我们可以覆盖一个或多个动物类型的访问操作：
- en: '[PRE52]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'When a dog trainer chooses to visit our animals, we use `TrainerVisitor`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当一名狗训练师选择访问我们的动物时，我们使用`TrainerVisitor`：
- en: '[PRE53]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, a visiting cat would have a set of actions all of its own:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一只访问猫将有一套它自己的动作：
- en: '[PRE54]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We will learn a lot more about different kinds of visitors later, in [*Chapter
    17*](B19262_17.xhtml#_idTextAnchor783), *The Visitor Pattern and Multiple Dispatch*.
    Now, however, we are going to explore the use of CRTP in conjunction with another
    common pattern.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第17章*](B19262_17.xhtml#_idTextAnchor783)，*访问者模式和多重分派*中学习更多关于不同类型访问者的知识。然而，现在我们将探索CRTP与另一个常见模式结合使用的情况。
- en: CRTP and policy-based design
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CRTP和基于策略的设计
- en: Policy-based design is a compile-time variant of the well-known Strategy pattern;
    we have an entire chapter dedicated to it, [*Chapter 15*](B19262_15.xhtml#_idTextAnchor689),
    aptly named *Policy-Based Design*. Here, we’re going to stay focused on the use
    of CRTP to provide additional functionality to the derived classes. Specifically,
    we are going to generalize the use of CRTP base classes to extend the interface
    of the derived class.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 基于策略的设计是众所周知的策略模式的编译时变体；我们有一个专门章节介绍它，[*第15章*](B19262_15.xhtml#_idTextAnchor689)，恰当地命名为*基于策略的设计*。在这里，我们将专注于使用CRTP为派生类提供额外功能。具体来说，我们将泛化CRTP基类的使用，以扩展派生类的接口。
- en: 'So far, we have used one base class to add features to the derived class:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已使用一个基类来为派生类添加功能：
- en: '[PRE55]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'However, if we want to extend the interface of the derived class in multiple
    ways, a single base class presents an unnecessary restriction. First of all, if
    we add several member functions, the base class can get quite large. Second, we
    may want a more modular approach to the interface design. For example, we can
    have one base class template that adds factory construction methods to any derived
    class:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想以多种方式扩展派生类的接口，单个基类会带来不必要的限制。首先，如果我们添加几个成员函数，基类可能会变得相当大。其次，我们可能希望接口设计有更模块化的方法。例如，我们可以有一个基类模板，它为任何派生类添加工厂构建方法：
- en: '[PRE56]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can even have several different factories that present the same interface
    but allocate memory differently. We can have another base class template that
    adds the conversion to string to any class that has the stream inserter operator:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以有多个不同的工厂，它们提供相同的接口但以不同的方式分配内存。我们可以有一个另一个基类模板，它为任何具有流插入运算符的类添加字符串转换功能：
- en: '[PRE57]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'It makes no sense to combine the two into a single base. In a large system,
    there can be many more of these classes, each adds a specific feature to the derived
    class and uses CRTP to implement it. But not every derived class needs every one
    of these features. With multiple base classes to choose from, it is easy to construct
    a derived class that has a specific set of features:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个结合成一个单一的基类是没有意义的。在一个大型系统中，可能会有更多这样的类，每个类都为派生类添加特定的功能，并使用CRTP来实现它。但并非每个派生类都需要这些功能中的每一个。有了多个基类可供选择，很容易构建一个具有特定功能集的派生类：
- en: '[PRE58]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This works, but we are in danger of repeating nearly identical code if we need
    to implement several derived classes that have very similar behavior, except for
    the features provided by the CRTP bases. For example, if we have another factory
    that constructs objects in thread-local memory to speed up the performance of
    concurrent programs (let’s call it `TLFactory`), we might have to write this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这方法可行，但如果需要实现几个具有非常相似行为（除了CRTP基类提供的特性）的派生类，我们就有重复编写几乎完全相同的代码的风险。例如，如果我们还有一个工厂，它在线程局部内存中构建对象以加快并发程序的性能（让我们称它为`TLFactory`），我们可能不得不编写如下代码：
- en: '[PRE59]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'But the two classes `C1` and `C2` are exactly the same except for the base
    classes, and yet, as written we would have to implement and maintain two copies
    of identical code. It would be better if we could write a single class template
    and plug different base classes into it as needed. This is the main idea of policy-based
    design; there are different approaches to it and you can learn about them in [*Chapter
    15*](B19262_15.xhtml#_idTextAnchor689), *Policy-Based Design*. For now, let us
    focus on using CRTP base classes in a template. Since we now need a class template
    that accepts multiple base class types, we will need to use a variadic template.
    We need something like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但`C1`和`C2`这两个类除了基类之外完全相同，然而，按照目前的写法，我们仍然需要实现和维护两份相同的代码。如果能编写一个单一代码模板，并根据需要将其不同的基类插入其中，那就更好了。这就是基于策略设计的主要思想；对此有几种不同的方法，你可以在[*第15章*](B19262_15.xhtml#_idTextAnchor689)，*基于策略的设计*中了解它们。现在，让我们专注于在模板中使用CRTP基类。由于我们现在需要一个可以接受多个基类类型的类模板，我们将需要使用变长模板。我们需要类似以下的内容：
- en: '[PRE60]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'There are versions of the policy-based design that use this exact template;
    but in our case, it won’t compile if we try to use `Factory` or `Stringify` as
    policies. The reason is that they are not types (classes) and, therefore, cannot
    be used as a type name. They are templates, so we have to declare the template
    parameters of the template `C` as templates themselves (this is known as a template
    template parameter). The syntax is easier to understand if we first recall how
    to declare a single template template parameter:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 基于策略的设计有使用这种确切模板的版本；但在这个例子中，如果我们尝试使用`Factory`或`Stringify`作为策略，它将无法编译。原因是它们不是类型（类），因此不能用作类型名称。它们是模板，因此我们必须将模板`C`的模板参数声明为模板本身（这被称为模板模板参数）。如果我们首先回忆一下如何声明单个模板模板参数，语法就更容易理解：
- en: '[PRE61]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If we wanted to inherit from a specific instantiation of this class template
    `B`, we would write
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要从这个类模板`B`的特定实例继承，我们会写成：
- en: '[PRE62]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When using CRTP, the template argument is the type of the derived class itself,
    `C<B>`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用CRTP时，模板参数是派生类本身的类型，`C<B>`：
- en: '[PRE63]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Generalizing this to a parameter pack is straightforward:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将此推广到参数包是直接的：
- en: '[PRE64]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The template parameter is a pack (any number of templates instead of a single
    class). The derived class inherits from the entire pack `Policies…`, except `Policies`
    are templates and we need to specify the actual instantiations of these templates.
    Each template in the pack is instantiated on the derived class, whose type is
    `C<Policies…>`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数是一个包（任何数量的模板而不是单个类）。派生类从整个包 `Policies…` 继承，除了 `Policies` 是模板，我们需要指定这些模板的实际实例化。包中的每个模板都在派生类上实例化，其类型为
    `C<Policies…>`。
- en: 'If we need additional template parameters, for example, to enable using different
    value types in the class `C`, we can combine them with policies:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要额外的模板参数，例如，为了在类 `C` 中启用使用不同的值类型，我们可以将它们与策略结合：
- en: '[PRE65]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To use this class with a particular set of policies, it is convenient to define
    some aliases:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个类与特定的策略集，定义一些别名是方便的：
- en: '[PRE66]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If we want to use several classes with the same Policies, we can define a template
    alias as well:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用具有相同 Policies 的几个类，我们也可以定义一个模板别名：
- en: '[PRE67]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We will learn more about policies in the [*Chapter 15*](B19262_15.xhtml#_idTextAnchor689),
    *Policy-Based Design*. We will encounter the technique we just studied, CRPT,
    there and in other chapters of this book – it is a flexible and powerful tool.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 15 章*](B19262_15.xhtml#_idTextAnchor689) 的 “基于策略的设计” 中了解更多关于策略的内容。我们将在那里和其他章节中遇到我们刚刚研究的技巧，CRPT
    ——它是一个灵活且强大的工具。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have examined a rather convoluted design pattern that combines both sides
    of C++—generic programming (templates) and object-oriented programming (inheritance).
    True to its name, the Curiously Recurring Template Pattern creates a circular
    loop, where the derived class inherits the interface and the implementation from
    the base class, while the base class has access to the interface of the derived
    class through the template parameters. CRTP has two main use modes—true static
    polymorphism, or *static interface*, where the object is primarily accessed as
    the base type, and expanding the interface, or delegation, where the derived class
    is accessed directly but the implementation uses CRTP to provide common functionality.
    The latter can vary from a simple addition of one or two methods to a complex
    task of composing the interfaces of derived classes from multiple building blocks
    or policies.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经检查了一个相当复杂的设计模式，它结合了 C++ 的两个方面——泛型编程（模板）和面向对象编程（继承）。正如其名，Curiously Recurring
    Template Pattern 创建了一个循环，其中派生类从基类继承接口和实现，而基类通过模板参数访问派生类的接口。CRTP 有两种主要的使用模式——真正的静态多态，或
    *静态接口*，其中对象主要作为基类型访问，以及扩展接口，或委托，其中直接访问派生类，但实现使用 CRTP 提供共同功能。后者可以从简单添加一到两个方法到从多个构建块或策略组合派生类接口的复杂任务。
- en: The next chapter introduces an idiom that makes use of the pattern we have just
    learned. This idiom also changes the standard way we pass arguments to functions,
    in order of the parameters, and lets us have order-independent named arguments
    instead. Read on to find out how!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章介绍了一个习语，它利用了我们刚刚学到的模式。这个习语也改变了我们按参数顺序传递函数参数的标准方式，并允许我们有顺序无关的命名参数。继续阅读以了解如何！
- en: Questions
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How expensive is a virtual function call, and why?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虚函数调用有多昂贵，为什么？
- en: Why does a similar function call, resolved at compile time, have no such performance
    overhead?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么类似的函数调用，在编译时解析，没有这样的性能开销？
- en: How would you make compile-time polymorphic function calls?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何实现编译时多态函数调用？
- en: How would you use CRTP to expand the interface of the base class?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何使用 CRTP 来扩展基类的接口？
- en: What is necessary to use multiple CRTP base classes in a single derived class?.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单个派生类中使用多个 CRTP 基类需要什么？
