<html><head></head><body>
		<div><h1 id="_idParaDest-123"><em class="italic"><a id="_idTextAnchor122"/>Chapter 4</em>: Compatible Iterators</h1>
			<p>Iterators are a<a id="_idIndexMarker311"/> fundamental concept in the STL. Iterators are implemented with the semantics of C pointers, using the same increment, decrement, and dereference operators. The pointer idiom is familiar to most C/C++ programmers, and it allows <em class="italic">algorithms</em> such as <code>std::sort</code> and <code>std::transform</code> to work on primitive memory buffers as well as STL containers.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor123"/>Iterators are fundamental</h1>
			<p>The STL uses iterators to<a id="_idIndexMarker312"/> navigate the elements of its container classes. Most containers include <code>begin()</code> and <code>end()</code> iterators. These are usually implemented as member functions that return an iterator object. The <code>begin()</code> iterator<a id="_idIndexMarker313"/> points to the initial container element, and the <code>end()</code> iterator points <em class="italic">past</em> the final element:</p>
			<div><div><img src="img/B18267_04_01.jpg" alt="Figure 4.1 – The begin() and end() iterators&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – The begin() and end() iterators</p>
			<p>The <code>end()</code> iterator<a id="_idIndexMarker314"/> may function as a <em class="italic">sentinel</em> for containers of indeterminate length. We'll see some examples of that in this chapter.</p>
			<p>Most STL containers define their own specific <em class="italic">iterator type</em>. For example, for a <code>vector</code> of <code>int</code>:</p>
			<pre>std::vector&lt;int&gt; v;</pre>
			<p>The iterator type would be defined as:</p>
			<pre>std::vector&lt;int&gt;::iterator v_it;</pre>
			<p>You can see how this could easily get out of hand. If we had a <code>vector</code> of <code>vector</code> of <code>string</code>:</p>
			<pre>std::vector&lt;std::vector&lt;int, std::string&gt;&gt; v;</pre>
			<p>Its iterator type would be:</p>
			<pre>std::vector&lt;std::vector&lt;int, std::string&gt;&gt;::iterator v_it;</pre>
			<p>Fortunately, C++11 gave us automatic type deduction and the <code>auto</code> type. By using <code>auto</code>, we rarely need to use the full iterator type definition. For example, if we need an iterator in a <code>for</code> loop, we can use the <code>auto</code> type:</p>
			<pre>for(auto v_it = v.begin(); v_it != v.end(); ++v_it) {
    cout &lt;&lt; <strong class="bold">*v_it</strong> &lt;&lt; '\n';
}</pre>
			<p>Notice the use<a id="_idIndexMarker315"/> of the dereference operator <code>*</code> to access the elements from the iterator. This is the same syntax you would use to dereference a pointer:</p>
			<pre>const int a[]{ 1, 2, 3, 4, 5 };
size_t count{ sizeof(a) / sizeof(int) };
for(const int* p = a; count &gt; 0; ++p, --count) {
    cout &lt;&lt; <strong class="bold">*p</strong> &lt;&lt; '\n';
}</pre>
			<p>This also means that you can use a range-based <code>for</code> loop with either a primitive array:</p>
			<pre>const int a[]{ 1, 2, 3, 4, 5 };
for(auto e : a) {
    cout &lt;&lt; e &lt;&lt; '\n';
}</pre>
			<p>Or with an STL container:</p>
			<pre>std::vector&lt;int&gt; v{ 1, 2, 3, 4, 5 };
for(auto e : v) {
    cout &lt;&lt; e &lt;&lt; '\n';
}</pre>
			<p>The range-based <code>for</code> loop is just a shorthand for a <code>for</code> loop with iterators:</p>
			<pre>{
    auto begin_it{ std::begin(container) };
    auto end_it{ std::end(container) };
    for ( ; begin_it != end_it; ++begin_it) {
        auto e{ *begin_it };
        cout &lt;&lt; e &lt;&lt; '\n';
    } 
}</pre>
			<p>Because iterators use the same syntax as a primitive pointer, the range-based <code>for</code> loop works the same with either container.</p>
			<p>Notice that the range-based <code>for</code> loop calls <code>std::begin()</code> and <code>std::end()</code>, instead of directly calling the <code>begin()</code> and <code>end()</code> member functions. The <code>std::</code> functions call the member functions to get the iterators. So, why not just call the member functions? The <code>std::</code> non-member functions are designed to also work with primitive arrays. That's why a <code>for</code> loop works with an array:</p>
			<pre>const int arr[]{ 1, 2, 3, 4, 5 };
for(auto e : arr) {
    cout &lt;&lt; format("{} ", e);
}</pre>
			<p>Output:</p>
			<pre>1 2 3 4 5</pre>
			<p>For most purposes, I tend<a id="_idIndexMarker316"/> to favor the member function <code>begin()</code> and <code>end()</code> because they are more explicit. Others favor the <code>std::</code> non-member functions because they are more general. Six or half-dozen; I suggest you pick a style and stick with it.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/>Iterator categories</h2>
			<p>Prior to C++20, iterators <a id="_idIndexMarker317"/>were divided into categories based on their capabilities:</p>
			<div><div><img src="img/B18267_04_Table_01.jpg" alt=""/>
				</div>
			</div>
			<p>These <a id="_idIndexMarker318"/>categories are hierarchical, where the more capable iterators inherit the capabilities of the less capable iterators. In other words, the <em class="italic">input iterator</em> can<a id="_idIndexMarker319"/> read and increment once. The <em class="italic">forward iterator</em> has the <a id="_idIndexMarker320"/>capabilities of the Input Iterator <em class="italic">plus</em> it can increment multiple times. The <em class="italic">bidirectional iterator</em> has<a id="_idIndexMarker321"/> those capabilities <em class="italic">plus</em> it can decrement. And on down the list.</p>
			<p>The <em class="italic">output iterator</em> can <a id="_idIndexMarker322"/>write and increment once. If any of the other iterators can also write, it is <a id="_idIndexMarker323"/>considered a <em class="italic">mutable iterator</em>.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor125"/>Iterator concepts</h2>
			<p><em class="italic">Concepts</em> and <em class="italic">constraints</em> are<a id="_idIndexMarker324"/> new with C++20. A concept is simply a named constraint that restricts the types of arguments to a template function or class, and helps the compiler choose appropriate specializations.</p>
			<p>Beginning with C++20, the STL defines iterators in terms of concepts instead of categories. Each of these concepts are in the <code>std::</code> namespace.</p>
			<div><div><img src="img/B18267_04_Table_02.jpg" alt=""/>
				</div>
			</div>
			<p>You can use these<a id="_idIndexMarker325"/> concepts to constrain the arguments of a template:</p>
			<pre>template&lt;typename T&gt;
<strong class="bold">requires std::random_access_iterator&lt;typename T::iterator&gt;</strong>
void printc(const T &amp; c) {
        for(auto e : c) {
        cout &lt;&lt; format("{} ", e);
    }
    cout &lt;&lt; '\n';
    cout &lt;&lt; format("element 0: {}\n", c[0]);
}</pre>
			<p>This function requires a <code>random_access_iterator</code>. If I call it with a <code>list</code>, which is not a random-access container, the compiler will give me an error:</p>
			<pre>int main()
{
    list&lt;int&gt; c{ 1, 2, 3, 4, 5 };
    printc(c);       
}</pre>
			<p>The <code>list</code> iterator<a id="_idIndexMarker326"/> type does not support the <code>random_access_iterator</code> concept. So, the compiler gives me an error:</p>
			<pre>error: no matching function for call to 'printc(std::__cxx11::list&lt;int&gt;&amp;)'
   27 |     printc(c);
      |     ~~~~~~^~~
note: candidate: 'template&lt;class T&gt;  requires  random_access_iterator&lt;typename T::iterator&gt; void printc(const T&amp;)'
   16 | void printc(const T &amp; c) {
      |      ^~~~~~
note:   template argument deduction/substitution failed:
note: constraints not satisfied</pre>
			<p>This is the error output from GCC. Your errors may look different.</p>
			<p>If I call it with a <code>vector</code>, which is a random-access container:</p>
			<pre>int main()
{
    vector&lt;int&gt; c{ 1, 2, 3, 4, 5 };
    printc(c);       
}</pre>
			<p>Now it compiles and runs without error:</p>
			<pre>$ ./working
1 2 3 4 5
element 0: 1</pre>
			<p>While there <a id="_idIndexMarker327"/>are different types of iterators for different types of capabilities (and concepts), the complexity is there to support of ease of use.</p>
			<p>With this introduction to iterators, let's now proceed with the following recipes in this chapter:</p>
			<ul>
				<li>Create an iterable range</li>
				<li>Make your iterators compatible with STL iterator traits</li>
				<li>Use iterator adapters to fill STL containers</li>
				<li>Create a generator as iterators</li>
				<li>Use reverse iterator adapters to iterate backward</li>
				<li>Iterate objects of unknown length with a sentinel</li>
				<li>Build a zip iterator adapter</li>
				<li>Create a random-access iterator</li>
			</ul>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor126"/>Technical requirements</h1>
			<p>You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap04">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap04</a>.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor127"/>Create an iterable range</h1>
			<p>This<a id="_idIndexMarker328"/> recipe describes a simple class that generates an iterable range, suitable for use with the range-based <code>for</code> loop. The idea is to create a <em class="italic">sequence generator</em> that iterates from a beginning value to an ending value.</p>
			<p>To accomplish this task, we need an iterator class, along with the object interface class.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor128"/>How to do it…</h2>
			<p>There's two major<a id="_idIndexMarker329"/> parts to this recipe, the main interface, <code>Seq</code>, and the <code>iterator</code> class.</p>
			<ul>
				<li>First, we'll define the <code>Seq</code> class. It only needs to implement the <code>begin()</code> and <code>end()</code> member functions:<pre>template&lt;typename T&gt;
class Seq {
    T start_{};
    T end_{};
public:
    Seq(T start, T end) : start_{start}, end_{end} {}
    iterator&lt;T&gt; begin() const {
        return iterator{start_};
    }
    iterator&lt;T&gt; end() const { return iterator{end_}; }
};</pre></li>
			</ul>
			<p>The constructor sets up the <code>start_</code> and <code>end_</code> variables. These are used to construct the <code>begin()</code> and <code>end()</code> iterators, respectively. The member functions <code>begin()</code> and <code>end()</code> return <code>iterator</code> objects.</p>
			<ul>
				<li>The <code>iterator</code> class is normally defined inside the public section of the container class. This is called a <em class="italic">member class</em> or a <em class="italic">nested class</em>. We'll insert it right after the <code>Seq</code> constructor:<pre>public:
    Seq(T start, T end) : start_{ start }, end_{ end } {}
    class iterator {
        T value_{};
    public:
        explicit iterator(T position = 0)
            : value_{position} {}
        T operator*() const { return value_; }
        iterator&amp; operator++() {
            ++value_;
            return *this;
        }
        bool operator!=(const iterator&amp; other) const {
            return value_ != other.value_;
        }
    };</pre></li>
			</ul>
			<p>It's traditional <a id="_idIndexMarker330"/>to name the iterator class <code>iterator</code>. This allows it to be referenced as <code>Seq&lt;</code><em class="italic">type</em><code>&gt;::iterator</code>.</p>
			<p>The <code>iterator</code> constructor is qualified <code>explicit</code> to avoid implicit conversions.</p>
			<p>The <code>value_</code> variable is maintained by the iterator. This is used to return a value from the pointer dereference.</p>
			<p>The minimum requirement for supporting the range-based <code>for</code> loop is a dereference operator <code>*</code>, a pre-increment operator <code>++</code>, and the not-equal comparison operator <code>!=</code>.</p>
			<ul>
				<li>Now we can write a <code>main()</code> function to test our sequence generator:<pre>int main()
{
    Seq&lt;int&gt; r{ 100, 110 };
    for (auto v : r) {
        cout &lt;&lt; format("{} ", v);
    }
    cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>This <a id="_idIndexMarker331"/>constructs a <code>Seq</code> object and prints out its sequence.</p>
			<p>The output looks like this:</p>
			<pre><strong class="bold">$ ./seq</strong>
<strong class="bold">100 101 102 103 104 105 106 107 108 109</strong></pre>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor129"/>How it works…</h2>
			<p>The point of this recipe is to make a sequence generator that works with a range-based <code>for</code> loop. Let's first consider the equivalent code for the range-based <code>for</code> loop:</p>
			<pre>{
    auto begin_it{ <strong class="bold">std::begin(container)</strong> };
    auto end_it{ <strong class="bold">std::end(container)</strong> };
    for ( ; <strong class="bold">begin_it != end_it</strong>; <strong class="bold">++begin_it</strong>) {
        auto v{ <strong class="bold">*begin_it</strong> };
        cout &lt;&lt; v &lt;&lt; '\n';
    } 
}</pre>
			<p>From this equivalent code, we can deduce the requirements for an object to work with the <code>for</code> loop:</p>
			<ul>
				<li><code>begin()</code> and <code>end()</code> iterators</li>
				<li>Iterator support for the not-equal comparison <code>!=</code> operator</li>
				<li>Iterator support for the prefix increment <code>++</code> operator</li>
				<li>Iterator support for the dereference <code>*</code> operator</li>
			</ul>
			<p>Our<a id="_idIndexMarker332"/> main <code>Seq</code> class interface only has three public member functions: the constructor, and the <code>begin()</code> and <code>end()</code> iterators:</p>
			<pre><strong class="bold">Seq</strong>(T start, T end) : start_{ start }, end_{ end } {}
iterator <strong class="bold">begin()</strong> const { return iterator{start_}; }
iterator <strong class="bold">end()</strong> const { return iterator{end_}; }</pre>
			<p>The implementation of the <code>Seq::iterator</code> class carries the actual payload:</p>
			<pre>class iterator {
    T <strong class="bold">value_</strong>{};</pre>
			<p>This is the common configuration because the payload is only accessed through iterators.</p>
			<p>We've implemented only the three operators we need:</p>
			<pre>    T <strong class="bold">operator*</strong>() const { return value_; }
    iterator&amp; <strong class="bold">operator++</strong>() {
        ++value_;
        return *this;
    }
    bool <strong class="bold">operator!=</strong>(const iterator&amp; other) const {
        return value_ != other.value_;
    }</pre>
			<p>This is all we need to support the range-based <code>for</code> loop:</p>
			<pre>Seq&lt;int&gt; r{ 100, 110 };
for (auto v : r) {
    cout &lt;&lt; format("{} ", v);
}</pre>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor130"/>There's more…</h2>
			<p>It's traditional, but<a id="_idIndexMarker333"/> not required, to define the iterator as a member class of the container. This allows the <code>iterator</code> type to be subordinate to the container type:</p>
			<pre>Seq&lt;int&gt;::iterator it = r.begin();</pre>
			<p>It's not as important post C++11 because of the <code>auto</code> type, but it's still considered best practice.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor131"/>Make your iterators compatible with STL iterator traits</h1>
			<p>Many<a id="_idIndexMarker334"/> STL algorithms require iterators to conform to certain traits. Unfortunately, these requirements are inconsistent across compilers, systems, and C++ versions.</p>
			<p>For our <a id="_idIndexMarker335"/>purposes, we'll use the class from the <em class="italic">Create an iterable range</em> recipe to illustrate the issue. You may find this makes more sense if you read that recipe before continuing.</p>
			<p>In <code>main()</code>, if I add a call to the <code>minmax_element()</code> algorithm:</p>
			<pre>Seq&lt;int&gt; r{ 100, 110 };
auto [min_it, max_it] = minmax_element(r.begin(), r.end());
cout &lt;&lt; format("{} - {}\n", *min_it, *max_it);</pre>
			<p>It does not compile. The error messages are vague, cryptic, and cascading, but if you look closely, you'll see that our iterator does not meet the requirements to be compatible with this algorithm.</p>
			<p>Okay, let's fix that.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/>How to do it…</h2>
			<p>We need to <a id="_idIndexMarker336"/>make a few simple additions to our iterator to make it compatible with the algorithm. Our iterator needs to meet<a id="_idIndexMarker337"/> the minimum requirements for a <em class="italic">forward iterator</em>, so let's start there:</p>
			<ul>
				<li>We have almost all the operators necessary for a forward iterator. The only one we're missing is the equality comparison operator <code>==</code>. We can easily add this to our iterator with an <code>operator==()</code> overload:<pre>bool operator==(const iterator&amp; other) const {
    return value_ == other.value_;
}</pre></li>
			</ul>
			<p>Interestingly, this makes the code compile and run on some systems, but not on <em class="italic">Clang</em>, where we get the error message:</p>
			<pre><strong class="bold">No type named 'value_type' in 'std::iterator_traits&lt;Seq&lt;int&gt;::iterator&gt;'</strong></pre>
			<p>This tells me that we need to set up the traits in the iterator.</p>
			<ul>
				<li>The <code>iterator_traits</code> class looks for a set of <em class="italic">type definitions</em> (implemented as <code>using</code> aliases) in the <code>iterator</code> class:<pre>public:
    using iterator_concept  = std::forward_iterator_tag;
    using iterator_category = 
      std::forward_iterator_tag;
    using value_type        = std::remove_cv_t&lt;T&gt;;
    using difference_type   = std::ptrdiff_t;
    using pointer           = const T*;
    using reference         = const T&amp;;</pre></li>
			</ul>
			<p>I tend to put these at the top of the <code>public:</code> section of the <code>iterator</code> class, where they'll be easy to see.</p>
			<p>Now we have a fully conforming <em class="italic">forward iterator</em> class, and the code runs on all the compilers I have.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>How it works…</h2>
			<p>The <code>using</code> statements<a id="_idIndexMarker338"/> are traits that may be <a id="_idIndexMarker339"/>used to define what capabilities the iterator can perform. Let's look at each of them:</p>
			<pre>using iterator_concept  = std::forward_iterator_tag;
using iterator_category = std::forward_iterator_tag;</pre>
			<p>The first two are the <em class="italic">category</em> and the <em class="italic">concept</em>, and both are set to <code>forward_iterator_tag</code>. This value indicates that the iterator conforms to the forward iterator specification.</p>
			<p>Some code doesn't look at those values, and instead looks for individual settings and capabilities:</p>
			<pre>using value_type        = std::remove_cv_t&lt;T&gt;;
using difference_type   = std::ptrdiff_t;
using pointer           = const T*;
using reference         = const T&amp;;</pre>
			<p>The <code>value_type</code> alias is set to <code>std::remove_cv_t&lt;T&gt;</code>, which is the type of the value, with any <code>const</code> qualifier removed.</p>
			<p>The <code>difference_type</code> alias is set to <code>std::ptrdiff_t</code>, as special type for pointer differences.</p>
			<p>The <code>pointer</code> and <code>reference</code> aliases are set to <code>const</code>-qualified versions of the pointer and reference, respectively.</p>
			<p>Defining these type aliases is a basic requirement for most iterators.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/>There's more…</h2>
			<p>It's worth<a id="_idIndexMarker340"/> noting that defining these traits allows us to use concept-restricted templates with our iterator. For example:</p>
			<pre>template&lt;typename T&gt;
requires std::forward_iterator&lt;typename T::iterator&gt;
void printc(const T &amp; c) {
    for(auto v : c) {
        cout &lt;&lt; format("{} ", v);
    }
    cout &lt;&lt; '\n';
}</pre>
			<p>This<a id="_idIndexMarker341"/> function that prints our sequence is restricted by the <code>forward_iterator</code> concept. If our class did not qualify, it wouldn't compile.</p>
			<p>We can also use the <code>ranges::</code> versions of the algorithms:</p>
			<pre>auto [min_it, max_it] = ranges::minmax_element(r);</pre>
			<p>This makes it more convenient to use our iterators.</p>
			<p>We can test for <code>forward_range</code> compatibility with a static assertion:</p>
			<pre>static_assert(ranges::forward_range&lt;Seq&lt;int&gt;&gt;);</pre>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor135"/>Use iterator adapters to fill STL containers</h1>
			<p>An iterator is <a id="_idIndexMarker342"/>essentially an abstraction. It has a specific interface and is used in specific ways. But beyond that, it's just code and it <a id="_idIndexMarker343"/>can be used for other purposes. An <em class="italic">iterator adapter</em> is a class<a id="_idIndexMarker344"/> that looks like an iterator but does something else.</p>
			<p>The STL comes with an assortment of iterator adapters. Often used with the <code>algorithm</code> library, they are quite useful. The <a id="_idIndexMarker345"/>STL iterator adaptors generally fall into three categories:</p>
			<ul>
				<li><strong class="bold">Insert iterators</strong>, or <em class="italic">inserters</em>, are <a id="_idIndexMarker346"/>used to insert elements into a container.</li>
				<li><strong class="bold">Stream iterators</strong> read <a id="_idIndexMarker347"/>from and write to a stream.</li>
				<li><strong class="bold">Reverse iterators</strong> reverse <a id="_idIndexMarker348"/>the direction of an iterator.</li>
			</ul>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/>How to do it…</h2>
			<p>In this<a id="_idIndexMarker349"/> recipe, we'll look at a few examples of <a id="_idIndexMarker350"/>STL iterator adapters:</p>
			<ul>
				<li>We'll start with a simple function to print the contents of a container:<pre>void printc(const auto &amp; v, const string_view s = "") {
    if(s.size()) cout &lt;&lt; format("{}: ", s);
    for(auto e : v) cout &lt;&lt; format("{} ", e);
    cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>The <code>printc()</code> function allows us to easily view the results of our algorithms. It includes an optional <code>string_view</code> argument for a description.</p>
			<ul>
				<li>In our <code>main()</code> function, we'll define a couple of <code>deque</code> containers. We're using <code>deque</code> containers so we can insert at both ends:<pre>int main() {
    deque&lt;int&gt; d1{ 1, 2, 3, 4, 5 };
    deque&lt;int&gt; d2(d1.size());
    copy(d1.begin(), d1.end(), d2.begin());
    printc(d1);
    printc(d2, "d2 after copy"); 
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">1 2 3 4 5</strong>
<strong class="bold">d2 after copy: 1 2 3 4 5</strong></pre>
			<p>We <a id="_idIndexMarker351"/>defined deque <code>d1</code> with five <code>int</code> values, and <code>d2</code> with space for the same number of elements. The <code>copy()</code> algorithm will not allocate space, so <code>d2</code> must have room for the elements.</p>
			<p>The <code>copy()</code> algorithm takes three iterators: the <em class="italic">begin</em> and <em class="italic">end</em> iterators indicate<a id="_idIndexMarker352"/> the range of elements to copy from, and the <em class="italic">begin</em> iterator of the destination range. It does not check the iterators to make sure they're valid. (Try this without allocating space in a <code>vector</code> and you'll get a <em class="italic">segmentation fault</em> error.)</p>
			<p>We call <code>printc()</code> on both containers to show the results.</p>
			<ul>
				<li>The <code>copy()</code> algorithm is not always convenient for this. Sometimes you want to copy and add elements to the end of a container. It would be nice to have an algorithm that calls <code>push_back()</code> for each element. This is where an iterator adapter is useful. Let's add some code at the end of <code>main()</code>:<pre>copy(d1.begin(), d1.end(), back_inserter(d2));
printc(d2, "d2 after back_inserter");</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">d2 after back_inserter: 1 2 3 4 5 1 2 3 4 5</strong></pre>
			<p><code>back_inserter()</code> is an <em class="italic">insert iterator adapter</em> that calls <code>push_back()</code> for each item assigned to it. You can use it anywhere an output iterator is expected.</p>
			<ul>
				<li>There's also a <code>front_inserter()</code> adapter for when you want to insert at the front of a container:<pre>deque&lt;int&gt; d3{ 47, 73, 114, 138, 54 };
copy(d3.begin(), d3.end(), front_inserter(d2));
printc(d2, "d2 after front_inserter");</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">d2 after front_inserter: 54 138 114 73 47 1 2 3 4 5 1 2 3 4 5</strong></pre>
			<p>The <code>front_inserter()</code> adapter inserts elements at the front using the container's <code>push_front()</code> method. Notice that the elements in the destination <a id="_idIndexMarker353"/>are reversed, because each element is inserted before the previous one.</p>
			<ul>
				<li>If we<a id="_idIndexMarker354"/> want to insert in the middle, we can use the <code>inserter()</code> adapter:<pre>auto it2{ d2.begin() + 2};
copy(d1.begin(), d1.end(), inserter(d2, it2));
printc(d2, "d2 after middle insert");</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">d2 after middle insert: 54 138 1 2 3 4 5 114 73 47 ...</strong></pre>
			<p>The <code>inserter()</code> adapter takes an iterator for the insertion begin point.</p>
			<ul>
				<li><em class="italic">Stream iterators</em> are <a id="_idIndexMarker355"/>convenient for reading from and writing to <code>iostream</code> objects, this is <code>ostream_iterator()</code>:<pre>cout &lt;&lt; "ostream_iterator: ";
copy(d1.begin(), d1.end(), ostream_iterator&lt;int&gt;(cout));
cout &lt;&lt; '\n';</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">ostream_iterator: 12345</strong></pre>
			<ul>
				<li>And<a id="_idIndexMarker356"/> here is <code>istream_iterator()</code>:<pre>vector&lt;string&gt; vs{};
copy(istream_iterator&lt;string&gt;(cin), 
    istream_iterator&lt;string&gt;(),
    back_inserter(vs));
printc(vs, "vs2");</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">$ ./working &lt; five-words.txt</strong>
<strong class="bold">vs2: this is not a haiku</strong></pre>
			<p>The <code>istream_iterator()</code> adapter will return an end iterator by default, if no <a id="_idIndexMarker357"/>stream is passed.</p>
			<ul>
				<li><em class="italic">Reverse adapters</em> are included <a id="_idIndexMarker358"/>with most containers, as function members <code>rbegin()</code> and <code>rend()</code>:<pre>for(auto it = d1.rbegin(); it != d1.rend(); ++it) {
    cout &lt;&lt; format("{} ", *it);
}
cout &lt;&lt; '\n';</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">5 4 3 2 1</strong></pre>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/>How it works…</h2>
			<p>The iterator adapters work by wrapping around an existing container. When you call an adapter, like <code>back_inserter()</code> with a container object:</p>
			<pre>copy(d1.begin(), d1.end(), back_inserter(d2));</pre>
			<p>The adapter returns an object that <em class="italic">mimics</em> an iterator, in this case a <code>std::back_insert_iterator</code> object, which calls the <code>push_back()</code> method on the container object each time a value is assigned to the iterator. This allows the adapter to be used in place of an iterator, while performing its useful task.</p>
			<p>The <code>istream_adapter()</code> also requires a <em class="italic">sentinel</em>. A sentinel signals the end of an iterator <a id="_idIndexMarker359"/>of indeterminate length. When you read from a stream, you don't know how many objects are in the stream until you hit the end. When the stream hits the end, the sentinel will compare equal with the iterator, signaling the end of the stream. The <code>istream_adapter()</code> will create a sentinel when it's called without a parameter:</p>
			<pre>auto it = istream_adapter&lt;string&gt;(cin);
auto it_end = istream_adapter&lt;string&gt;();  // creates sentinel</pre>
			<p>This allows you to test for the end of a stream, as you would with any container:</p>
			<pre>for(auto it = <strong class="bold">istream_iterator&lt;string&gt;(cin)</strong>;
        it != <strong class="bold">istream_iterator&lt;string&gt;()</strong>;
        ++it) {
    cout &lt;&lt; format("{} ", *it);
}
cout &lt;&lt; '\n';</pre>
			<p>Output:</p>
			<pre>$ ./working &lt; five-words.txt
this is not a haiku</pre>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor138"/>Create a generator as iterators</h1>
			<p>A <em class="italic">generator</em> is an<a id="_idIndexMarker360"/> iterator that <a id="_idIndexMarker361"/>generates<a id="_idIndexMarker362"/> its own sequence of values. It does not use a container. It creates values on the fly, returning one at a time as needed. A C++ generator stands on its own; it does not need to wrap around another object.</p>
			<p>In this <a id="_idIndexMarker363"/>recipe, we'll build a generator for a <em class="italic">Fibonacci sequence</em>. This <a id="_idIndexMarker364"/>is a sequence where each number is the sum of the previous two numbers in <a id="_idIndexMarker365"/>the sequence, starting with 0 and 1:</p>
			<div><div><img src="img/B18267_04_02.jpg" alt="Figure 4.2 – Definition of a Fibonacci sequence&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Definition of a Fibonacci sequence</p>
			<p>The first ten values of the Fibonacci sequence, not counting zero, are: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55. This is a close approximation of the <em class="italic">golden ratio</em> found in nature.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor139"/>How to do it…</h2>
			<p>A Fibonacci sequence is often created with a <em class="italic">recursive loop</em>. Recursion<a id="_idIndexMarker366"/> in a generator can be difficult and resource-intensive, so instead we'll just save the previous two values in the sequence and add them together. This is more efficient.</p>
			<ul>
				<li>First let's define a function to print the sequence:<pre>void printc(const auto &amp; v, const string_view s = "") {
    if(s.size()) cout &lt;&lt; format("{}: ", s);
    for(auto e : v) cout &lt;&lt; format("{} ", e);
    cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>We've used this <code>printc()</code> function before. It prints an iterable range, along with a description string, if provided.</p>
			<ul>
				<li>Our class begins with a <em class="italic">type alias</em>, and a few object variables, all in the <code>private</code> section.<pre>class fib_generator {
    <strong class="bold">using fib_t</strong> = unsigned long;
    fib_t <strong class="bold">stop_</strong>{};
    fib_t <strong class="bold">count_</strong> { 0 };
    fib_t <strong class="bold">a_</strong> { 0 };
    fib_t <strong class="bold">b_</strong> { 1 };</pre></li>
			</ul>
			<p>The <code>stop_</code> variable will be used later as a <em class="italic">sentinel</em>. It's set to the number of values to generate. <code>count_</code> is used to keep track of how many values we've generated. <code>a_</code> and <code>b_</code> are the<a id="_idIndexMarker367"/> previous two sequence values, used for calculating the next value.</p>
			<ul>
				<li>Still <a id="_idIndexMarker368"/>in the <code>private</code> section, we have a simple function for calculating the next value in the Fibonacci sequence.<pre>    constexpr void do_fib() {
        const fib_t old_b = b_;
        b_ += a_;
        a_  = old_b;
    }</pre></li>
				<li>Now in the <code>public</code> section, we have a simple constructor with a default value:<pre>public:
    explicit fib_generator(fib_t stop = 0) : stop_{ stop } {}</pre></li>
			</ul>
			<p>This constructor is used without an argument to create a sentinel. The <code>stop</code> argument initializes the <code>stop_</code> variable to represent how many values to generate.</p>
			<ul>
				<li>The rest of the public functions<a id="_idIndexMarker369"/> are the operator overloads <a id="_idIndexMarker370"/>expected of a <em class="italic">forward iterator</em>:<pre>    fib_t operator*() const { return b_; }
    constexpr fib_generator&amp; operator++() {
        do_fib();
        ++count_;
        return *this;
    }
    fib_generator <strong class="bold">operator++</strong>(int) {
        auto temp{ *this };
        ++*this;
        return temp; 
    }
    bool <strong class="bold">operator!=</strong>(const fib_generator &amp;o) const {
        return count_ != o.count_; 
    }
    bool <strong class="bold">operator==</strong>(const fib_generator&amp;o) const { 
        return count_ == o.count_; 
    }
    const fib_generator&amp; <strong class="bold">begin()</strong> const { return *this; }
    const fib_generator <strong class="bold">end()</strong> const { 
        auto sentinel = fib_generator();
        sentinel.count_ = stop_;
        return sentinel;
    }
    fib_t <strong class="bold">size()</strong> { return stop_; }
};</pre></li>
			</ul>
			<p>There's also a simple <code>size()</code> function which can be useful if you need to initialize a target container for a copy operation.</p>
			<ul>
				<li>Now we <a id="_idIndexMarker371"/>can use the generator in our main function with a simple call to <code>printc()</code>:<pre>int main() {
    printc(fib_generator(10));
}</pre></li>
			</ul>
			<p>This creates<a id="_idIndexMarker372"/> an anonymous <code>fib_generator</code> object to pass to the <code>printc()</code> function.</p>
			<ul>
				<li>We get this output with the first 10 Fibonacci numbers, not including zero:<pre><strong class="bold">1 1 2 3 5 8 13 21 34 55</strong></pre></li>
			</ul>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor140"/>How it works…</h2>
			<p>The <code>fib_generator</code> class operates as a forward iterator, simply because it provides all the necessary interface functions:</p>
			<pre>fib_generator {
public:
    fib_t operator*() const;
    constexpr fib_generator&amp; operator++();
    fib_generator operator++(int);
    bool operator!=(const fib_generator &amp;o) const;
    bool operator==(const fib_generator&amp;o) const;
    const fib_generator&amp; begin() const;
    const fib_generator end() const;
};</pre>
			<p>As far as the range-based <code>for</code> loop is concerned, this is an iterator because it looks like an iterator.</p>
			<p>The value is <a id="_idIndexMarker373"/>calculated in the <code>do_fib()</code> function:</p>
			<pre>constexpr void do_fib() {
    const fib_t old_b = b_;
    b_ += a_;
    a_  = old_b;
}</pre>
			<p>This<a id="_idIndexMarker374"/> simply adds <code>b_ += a_</code>, stores the result in <code>b_</code> and the old <code>b_</code> in <code>a_</code>, setting it up for the next iteration.</p>
			<p>The dereference operator <code>*</code> returns the value from <code>b_</code>, which is the next value in the sequence:</p>
			<pre>fib_t operator*() const { return b_; }</pre>
			<p>The <code>end()</code> function creates an object where the <code>count_</code> variable is equal to the <code>stop_</code> variable, creating a <em class="italic">sentinel</em>:</p>
			<pre>const fib_generator end() const { 
    auto <strong class="bold">sentinel</strong> = fib_generator();
    <strong class="bold">sentinel.count_ = stop_</strong>;
    return <strong class="bold">sentinel</strong>;
}</pre>
			<p>Now the equality comparison operator can easily detect the end of the sequence:</p>
			<pre>bool operator==(const fib_generator&amp;o) const { 
    return count_ == o.count_; 
}</pre>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor141"/>There's more…</h2>
			<p>If we <a id="_idIndexMarker375"/>want to make our generator work with the <code>algorithm</code> library, we need to <a id="_idIndexMarker376"/>provide the <code>traits</code> aliases. These go at the top of the <code>public</code> section:</p>
			<pre>public:
    using iterator_concept  = std::forward_iterator_tag;
    using iterator_category = std::forward_iterator_tag;
    using value_type        = std::remove_cv_t&lt;fib_t&gt;;
    using difference_type   = std::ptrdiff_t;
    using pointer           = const fib_t*;
    using reference         = const fib_t&amp;;</pre>
			<p>Now we can use our generator with algorithms:</p>
			<pre>fib_generator fib(10);
auto x = ranges::views::transform(fib, 
    [](unsigned long x){ return x * x; });
printc(x, "squared:");</pre>
			<p>This uses the <code>ranges::views</code> version of the <code>transform()</code> algorithm to square every value. The resulting object can be used wherever you can use an iterator. We get this output from the <code>printc()</code> call:</p>
			<pre>squared:: 1 1 4 9 25 64 169 441 1156 3025</pre>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor142"/>Use reverse iterator adapters to iterate backward</h1>
			<p>A <em class="italic">reverse iterator adapter</em> is an<a id="_idIndexMarker377"/> abstraction that reverses the<a id="_idIndexMarker378"/> direction of an iterator class. It <a id="_idIndexMarker379"/>requires <a id="_idIndexMarker380"/>a bidirectional iterator.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor143"/>How to do it…</h2>
			<p>Most bidirectional containers in the STL include a reverse iterator adapter. Other containers, such<a id="_idIndexMarker381"/> as the primitive C-array, do not. Let's look at some examples:</p>
			<ul>
				<li>Let's start with the <code>printc()</code> function we've used throughout this chapter:<pre>void printc(const auto &amp; c, const string_view s = "") {
    if(s.size()) cout &lt;&lt; format("{}: ", s);
    for(auto e : c) cout &lt;&lt; format("{} ", e);
    cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>This uses a range-based <code>for</code> loop to print the elements of a container.</p>
			<ul>
				<li>The<a id="_idIndexMarker382"/> range-based <code>for</code> loop works even with primitive C-arrays, which have no iterator class. So, our <code>printc()</code> function already works with a C-array:<pre>int main() {
    int array[]{ 1, 2, 3, 4, 5 };
    printc(array, "c-array");
}</pre></li>
			</ul>
			<p>We get this output:</p>
			<pre><strong class="bold">c-array: 1 2 3 4 5</strong></pre>
			<ul>
				<li>We can use the <code>begin()</code> and <code>end()</code> iterator adapters to create normal forward iterators for the C-array:<pre>auto it = std::begin(array);
auto end_it = std::end(array);
while (it != end_it) {
    cout &lt;&lt; format("{} ", *it++);
}</pre></li>
			</ul>
			<p>Output from the <code>for</code> loop:</p>
			<pre><strong class="bold">1 2 3 4 5</strong></pre>
			<ul>
				<li>Or we can use the <code>rbegin()</code> and <code>rend()</code> reverse iterator adapters to create reverse iterators for the C-array:<pre>auto it = std::rbegin(array);
auto end_it = std::rend(array);
while (it != end_it) {
    cout &lt;&lt; format("{} ", *it++);
}</pre></li>
			</ul>
			<p>Now our output is reversed:</p>
			<pre><strong class="bold">5 4 3 2 1</strong></pre>
			<ul>
				<li>We <a id="_idIndexMarker383"/>can even create a<a id="_idIndexMarker384"/> modified version of <code>printc()</code> that prints in reverse:<pre>void printr(const auto &amp; c, const string_view s = "") {
    if(s.size()) cout &lt;&lt; format("{}: ", s);
    auto rbegin = std::rbegin(c);
    auto rend = std::rend(c);
    for(auto it = rbegin; it != rend; ++it) {
        cout &lt;&lt; format("{} ", *it);
    }
    cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>When we call it with the C-array:</p>
			<pre>printr(array, "rev c-array");</pre>
			<p>We get this output:</p>
			<pre><strong class="bold">rev c-array: 5 4 3 2 1</strong></pre>
			<ul>
				<li>Of course, this <a id="_idIndexMarker385"/>works just as well with any bidirectional STL container:<pre>vector&lt;int&gt; v{ 1, 2, 3, 4, 5 };
printc(v, "vector");
printr(v, "rev vector");</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">vector: 1 2 3 4 5</strong>
<strong class="bold">rev vector: 5 4 3 2 1</strong></pre>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor144"/>How it works…</h2>
			<p>A normal iterator<a id="_idIndexMarker386"/> class has a <code>begin()</code> iterator that points to the first element, and an <code>end()</code> iterator that points <em class="italic">past</em> the last element:</p>
			<div><div><img src="img/B18267_04_03.jpg" alt="Figure 4.3 – Forward iterator&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Forward iterator</p>
			<p>You iterate the container by incrementing the <code>begin()</code> iterator with the <code>++</code> operator, until it reaches the value of the <code>end()</code> iterator.</p>
			<p>A reverse iterator adapter <em class="italic">intercepts the iterator interface</em> and turns it around so the <code>begin()</code> iterator points at to the last element, and <code>end()</code> iterator points <em class="italic">before</em> the first element. The <code>++</code> and <code>--</code> operators are also inverted:</p>
			<div><div><img src="img/B18267_04_04.jpg" alt="Figure 4.4 – Reverse iterator adapter&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – Reverse iterator adapter</p>
			<p>In the reversed iterator, the <code>++</code> operator decrements and the <code>--</code> operator increments.</p>
			<p>It's worth<a id="_idIndexMarker387"/> noting that most bidirectional STL <a id="_idIndexMarker388"/>containers already include a reverse iterator adapter, accessible by member functions <code>rbegin()</code> and <code>rend()</code>:</p>
			<pre>vector&lt;int&gt; v;
it = v.<strong class="bold">rbegin()</strong>;
it_end = v.<strong class="bold">rend()</strong>;</pre>
			<p>These iterators will operate in reverse and are suitable for many purposes.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor145"/>Iterate objects of unknown length with a sentinel</h1>
			<p>Some <a id="_idIndexMarker389"/>objects don't have a specific length. To know their length, you need to iterate through all their elements. For example, elsewhere in this chapter we've seen a <em class="italic">generator</em> that doesn't have a specific length. A <a id="_idIndexMarker390"/>more common example would be a <em class="italic">C-string</em>.</p>
			<p>A C-string <a id="_idIndexMarker391"/>is a primitive C-array of characters, terminated with a null <code>'\0'</code> value.</p>
			<div><div><img src="img/B18267_04_05.jpg" alt="Figure 4.5 – A C-string with its null terminator&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – A C-string with its null terminator</p>
			<p>We use C-strings <a id="_idIndexMarker392"/>all the time, even if we don't realize it. Any <em class="italic">literal</em> string in C/C++ is a C-string:</p>
			<pre>std::string s = <strong class="bold">"string"</strong>;</pre>
			<p>Here, the STL string <code>s</code> is initialized with a literal string. The literal string is a C-string. If we look at the individual characters in hexadecimal, we'll see the null terminator:</p>
			<pre>for (char c : "string") {
    std::cout &lt;&lt; format("{:02x} ", c);
}</pre>
			<p>The word "string" has six letters. The output from our loop shows seven elements in the array:</p>
			<pre>73 74 72 69 6e 67 00</pre>
			<p>The<a id="_idIndexMarker393"/> seventh element is the null terminator.</p>
			<p>The <a id="_idIndexMarker394"/>loop sees the primitive C-array of characters, with seven values. The fact that it's a string is an abstraction invisible to the loop. If we want the loop to treat it like a string, we'll need an <em class="italic">iterator</em> and a <em class="italic">sentinel</em>.</p>
			<p>A <em class="italic">sentinel</em> is <a id="_idIndexMarker395"/>an object that signals the end of an iterator of indeterminate length. When the iterator hits the end of the data, the sentinel will compare equal with the iterator.</p>
			<p>To see how this works, let's build an iterator for C-strings!</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor146"/>How to do it…</h2>
			<p>To use a sentinel with a C-string, we need to build a custom iterator. It doesn't need to be complicated, just the essentials for use with a range-based <code>for</code> loop.</p>
			<ul>
				<li>We'll start with a couple of convenience definitions:<pre>using sentinel_t = const char;
constexpr sentinel_t nullchar = '\0';</pre></li>
			</ul>
			<p>The <code>using</code> alias for <code>sentinel_t</code> is <code>const char</code>. We'll use this for the sentinel in our class.</p>
			<p>We also define the constant <code>nullchar</code> for the null character terminator.</p>
			<ul>
				<li>Now <a id="_idIndexMarker396"/>we can define<a id="_idIndexMarker397"/> our iterator type:<pre>class cstr_it {
    const char *s{};
public:
    explicit cstr_it(const char *str) : s{str} {}
    char operator*() const { return *s; }
    cstr_it&amp; operator++() {
        ++s;
        return *this;
    }
    bool operator!=(sentinel_t) const {
        return s != nullptr &amp;&amp; *s != nullchar;
    }
    cstr_it begin() const { return *this; }
    sentinel_t end() const { return nullchar; }
};</pre></li>
			</ul>
			<p>This is short and simple. It's the minimum necessary for a range-based <code>for</code> loop. Notice the <code>end()</code> function returns a <code>nullchar</code> and the <code>operator!=()</code> overload compares against the <code>nullchar</code>. That's all we need for the sentinel.</p>
			<ul>
				<li>Now we can define a function for printing our C-string using the sentinel:<pre>void print_cstr(const char * s) {
    cout &lt;&lt; format("{}: ", s);
    for (char c : <strong class="bold">cstr_it(s)</strong>) {
        std::cout &lt;&lt; format("<strong class="bold">{:02x}</strong> ", c);
    }
    std::cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>In this <a id="_idIndexMarker398"/>function we first print the string. Then we use the <code>format()</code> function to print each individual character as a hexadecimal value.</p>
			<ul>
				<li>Now <a id="_idIndexMarker399"/>we can call <code>print_cstr()</code> from our <code>main()</code> function:<pre>int main() {
    const char carray[]{"array"};
    print_cstr(carray);
    const char * cstr{"c-string"};
    print_cstr(cstr);
}</pre></li>
			</ul>
			<p>The output looks like this:</p>
			<pre><strong class="bold">array: 61 72 72 61 79</strong>
<strong class="bold">c-string: 63 2d 73 74 72 69 6e 67</strong></pre>
			<p>Notice that there are no extraneous characters and no null terminators. This is because our sentinel tells the for loop to stop when it sees the <code>nullchar</code>.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor147"/>How it works…</h2>
			<p>The<a id="_idIndexMarker400"/> sentinel part of the iterator <a id="_idIndexMarker401"/>class is very simple. We can easily use the null terminator as the sentinel value by returning it in the <code>end()</code> function:</p>
			<pre>sentinel_t end() const { return nullchar; }</pre>
			<p>Then the not-equal comparison operator can test for it:</p>
			<pre>bool operator!=(<strong class="bold">sentinel_t</strong>) const {
    return s != nullptr &amp;&amp; <strong class="bold">*s != nullchar</strong>;
}</pre>
			<p>Notice that the parameter is just a type (<code>sentinel_t</code>). A parameter type is necessary for the function signature, but we don't need the value. All that's necessary is to compare the current iterator with the sentinel.</p>
			<p>This technique should be useful whenever you have a type or class that doesn't have a predetermined end point for comparison.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor148"/>Build a zip iterator adapter</h1>
			<p>Many <a id="_idIndexMarker402"/>scripting languages include a function for <em class="italic">zipping</em> two sequences together. A typical zip operation will take two input sequences and return a pair of values for each position in both inputs:</p>
			<p>Consider the case of two sequences – they can be containers, iterators, or initialization lists:</p>
			<div><div><img src="img/B18267_04_06.jpg" alt="Figure 4.6 – Containers to be zipped&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Containers to be zipped</p>
			<p>We want to <em class="italic">zip</em> them together to make a new sequence with pairs of elements from the first two sequences:</p>
			<div><div><img src="img/B18267_04_07.jpg" alt="Figure 4.7 – Zip operation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – Zip operation</p>
			<p>In this recipe we will accomplish this task with an iterator adapter.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor149"/>How to do it…</h2>
			<p>In this<a id="_idIndexMarker403"/> recipe we'll build a zip iterator adapter that takes two containers of the same type and zips the values into <code>std::pair</code> objects:</p>
			<ul>
				<li>In our <code>main()</code> function we want to call our adapter with two vectors:<pre>int main()
{
    vector&lt;std::string&gt; vec_a {"Bob", "John", "Joni"};
    vector&lt;std::string&gt; vec_b {"Dylan", "Williams", 
        "Mitchell"};
    cout &lt;&lt; "zipped: ";
    for(auto [a, b] : zip_iterator(vec_a, vec_b)) {
        cout &lt;&lt; format("[{}, {}] ", a, b);
    }
    cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>This allows us to use the <code>zip_iterator</code> in place of the individual <code>vector</code> iterators.</p>
			<p>And we expect an output like this:</p>
			<pre><strong class="bold">zipped: [Bob, Dylan] [John, Williams] [Joni, Mitchell]</strong></pre>
			<ul>
				<li>Our<a id="_idIndexMarker404"/> iterator adapter is in a class called <code>zip_iterator</code>. We'll start with some type aliases for convenience:<pre>template&lt;typename T&gt;
class zip_iterator {
    using val_t = typename T::value_type;
    using ret_t = std::pair&lt;val_t, val_t&gt;;
    using it_t = typename T::iterator;</pre></li>
			</ul>
			<p>These allow us to conveniently define objects and functions.</p>
			<ul>
				<li>We don't store any data in our iterator. We only store copies of the target containers' <code>begin()</code> and <code>end()</code> iterators:<pre>it_t ita_{};
it_t itb_{};
// for begin() and end() objects
it_t ita_begin_{};
it_t itb_begin_{};
it_t ita_end_{};
it_t itb_end_{};</pre></li>
			</ul>
			<p><code>ita_</code> and <code>itb_</code> are iterators from the target containers. The other four iterators are used to generate the <code>begin()</code> and <code>end()</code> iterators for the <code>zip_iterator</code> adapter.</p>
			<ul>
				<li>We <a id="_idIndexMarker405"/>also have a private constructor:<pre>// private constructor for begin() and end() objects
zip_iterator(it_t ita, it_t itb) : ita_{ita}, itb_{itb} {}</pre></li>
			</ul>
			<p>This is used later to construct adapter objects specifically for <code>begin()</code> and <code>end()</code> iterators.</p>
			<ul>
				<li>In the <code>public</code> section, we start with the iterator <em class="italic">traits</em> type definitions:<pre>public:
    using iterator_concept  = 
      std::forward_iterator_tag;
    using iterator_category = 
      std::forward_iterator_tag;
    using value_type        = std::pair&lt;val_t, val_t&gt;;
    using difference_type   = long int;
    using pointer           = const val_t*;
    using reference         = const val_t&amp;;</pre></li>
				<li>The constructor sets up all the private iterator variables:<pre>zip_iterator(T&amp; a, T&amp; b) : 
    ita_{a.begin()},
    itb_{b.begin()},
    ita_begin_{ita_},
    itb_begin_{itb_},
    ita_end_{a.end()},
    itb_end_{b.end()}
{}</pre></li>
				<li>We define<a id="_idIndexMarker406"/> the minimum operator overloads to work with a forward iterator:<pre>zip_iterator&amp; operator++() {
    ++ita_;
    ++itb_;
    return *this;
}
bool operator==(const zip_iterator&amp; o) const {
    return ita_ == o.ita_ || itb_ == o.itb_;
}
bool operator!=(const zip_iterator&amp; o) const {
    return !operator==(o);
}
ret_t operator*() const {
    return { *ita_, *itb_ };
}</pre></li>
				<li>And finally, the <code>begin()</code> and <code>end()</code> functions return the respective iterators:<pre>zip_iterator begin() const
    { return zip_iterator(ita_begin_, itb_begin_); }
zip_iterator end() const
    { return zip_iterator(ita_end_, itb_end_); }</pre></li>
			</ul>
			<p>These are made simple by the stored iterators and the private constructor.</p>
			<ul>
				<li>Now let's expand our <code>main()</code> function for testing:<pre>int main()
{
    vector&lt;std::string&gt; vec_a {"Bob", "John", "Joni"};
    vector&lt;std::string&gt; vec_b {"Dylan", "Williams", 
        "Mitchell"};
    cout &lt;&lt; "vec_a: ";
    for(auto e : vec_a) cout &lt;&lt; format("{} ", e);
    cout &lt;&lt; '\n';
    cout &lt;&lt; "vec_b: ";
    for(auto e : vec_b) cout &lt;&lt; format("{} ", e);
    cout &lt;&lt; '\n';
    cout &lt;&lt; "zipped: ";
    for(auto [a, b] : zip_iterator(vec_a, vec_b)) {
        cout &lt;&lt; format("[{}, {}] ", a, b);
    }
    cout &lt;&lt; '\n';
}</pre></li>
				<li>This gives<a id="_idIndexMarker407"/> us the output we're looking for:<pre><strong class="bold">vec_a: Bob John Joni</strong>
<strong class="bold">vec_b: Dylan Williams Mitchell</strong>
<strong class="bold">zipped: [Bob, Dylan] [John, Williams] [Joni, Mitchell]</strong></pre></li>
			</ul>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor150"/>How it works…</h2>
			<p>The <em class="italic">zipped iterator adapter</em> is an <a id="_idIndexMarker408"/>example of how flexible the iterator abstraction can be. We can take the iterators of two containers and use them in one aggregated iterator. Let's see how this works.</p>
			<p>The main constructor for the <code>zip_iterator</code> class takes two container objects. For the purposes of this discussion, we'll refer to these objects as the <em class="italic">target</em> objects.</p>
			<pre>zip_iterator(T&amp; a, T&amp; b) : 
    ita_{a.begin()},
    itb_{b.begin()},
    ita_begin_{ita_},
    itb_begin_{itb_},
    ita_end_{a.end()},
    itb_end_{b.end()}
{}</pre>
			<p>The constructor initializes the <code>ita_</code> and <code>itb_</code> variables from the target <code>begin()</code> iterators. These will be used to navigate the target objects. The target <code>begin()</code> and <code>end()</code> iterators are also saved for later use.</p>
			<p>These variables are defined in the private section:</p>
			<pre>it_t ita_{};
it_t itb_{};
// for begin() and end() objects
it_t ita_begin_{};
it_t itb_begin_{};
it_t ita_end_{};
it_t itb_end_{};</pre>
			<p>The <code>it_t</code> type is defined as the type of the target iterator class:</p>
			<pre>using <strong class="bold">val_t</strong> = typename T::value_type;
using <strong class="bold">ret_t</strong> = std::pair&lt;val_t, val_t&gt;;
using <strong class="bold">it_t</strong> = typename T::iterator;</pre>
			<p>The other<a id="_idIndexMarker409"/> aliased types are <code>val_t</code> for the type of the target value, and <code>ret_t</code> for the return <code>pair</code>. These type definitions are used for convenience throughout the class.</p>
			<p>The <code>begin()</code> and <code>end()</code> functions use a private constructor that only initializes the <code>ita_</code> and <code>itb_</code> values:</p>
			<pre>zip_iterator begin() const
  { return zip_iterator(<strong class="bold">ita_begin_</strong>, <strong class="bold">itb_begin_</strong>); }
zip_iterator end() const
  { return zip_iterator(<strong class="bold">ita_end_</strong>, <strong class="bold">itb_end_</strong>); }</pre>
			<p>The <code>private</code> constructor looks like this:</p>
			<pre>// private constructor for begin() and end() objects
zip_iterator(<strong class="bold">it_t</strong> ita, <strong class="bold">it_t</strong> itb) : <strong class="bold">ita_</strong>{ita}, <strong class="bold">itb_</strong>{itb} {}</pre>
			<p>This is a constructor that takes <code>it_t</code> iterators for parameters. It only initializes <code>ita_</code>and <code>itb_</code> so they can be used in the comparison operator overloads.</p>
			<p>The rest of the class just acts like a normal iterator, but it's operating on iterators from the target class:</p>
			<pre>zip_iterator&amp; operator++() {
    ++ita_;
    ++itb_;
    return *this;
}
bool operator==(const zip_iterator&amp; o) const {
    return ita_ == o.ita_ || itb_ == o.itb_;
}
bool operator!=(const zip_iterator&amp; o) const {
    return !operator==(o);
}</pre>
			<p>The dereference <a id="_idIndexMarker410"/>operator returns a <code>std::pair</code> object (<code>ret_t</code> is an alias for <code>std::pair&lt;val_t, val_t&gt;</code>). This is the interface for retrieving a value from the iterator.</p>
			<pre>ret_t operator*() const {
    return { *ita_, *itb_ };
}</pre>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor151"/>There's more…</h2>
			<p>The <code>zip_iterator</code> adapter can<a id="_idIndexMarker411"/> be used to easily zip objects into a <code>map</code>:</p>
			<pre>map&lt;string, string&gt; name_map{};
for(auto [a, b] : zip_iterator(vec_a, vec_b)) {
    name_map.try_emplace(a, b);
}
cout &lt;&lt; "name_map: ";
for(auto [a, b] : name_map) {
    cout &lt;&lt; format("[{}, {}] ", a, b);
}
cout &lt;&lt; '\n';</pre>
			<p>If we add this code to <code>main()</code>, we get this output:</p>
			<pre>name_map: [Bob, Dylan] [John, Williams] [Joni, Mitchell]</pre>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor152"/>Create a random-access iterator</h1>
			<p>This recipe is an <a id="_idIndexMarker412"/>example of a full-featured contiguous/random-access iterator. This is the most complete type of iterator for a container. A random-access iterator includes all the features of all the other types of container iterators, along with its random-access capabilities.</p>
			<p>While I felt it important to include a complete iterator in this chapter, with over 700 lines of code this example is somewhat larger than the other examples in this book. I'll cover the essential components of the code here. Please see the full source at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap04/container-iterator.cpp">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap04/container-iterator.cpp</a>.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/>How to do it…</h2>
			<p>We need a container for our iterator. We'll use a simple array for this, and we'll call it <code>Container</code>. The <code>iterator</code> class is nested within the <code>Container</code> class.</p>
			<p>All of this is designed to be consistent with the STL container interfaces.</p>
			<ul>
				<li><code>Container</code> is defined as a <code>template</code> class. Its <code>private</code> section has only two elements:<pre>template&lt;typename T&gt;
class Container {
    std::<strong class="bold">unique_ptr</strong>&lt;T[]&gt; <strong class="bold">c_</strong>{};
    size_t <strong class="bold">n_elements_</strong>{};</pre></li>
			</ul>
			<p>We use a <code>unique_pointer</code> for the data. We let the <em class="italic">smart pointer</em> manage its own memory. This mitigates the need for a <code>~Container()</code> destructor. The <code>n_elements_</code> variable keeps the size of our container.</p>
			<ul>
				<li>In the public section, we have our constructors:<pre>Container(<strong class="bold">initializer_list</strong>&lt;T&gt; l) : n_elements_{l.size()} {
    c_ = std::<strong class="bold">make_unique</strong>&lt;T[]&gt;(n_elements_);
    size_t index{0};
    for(T e : l) {
        c_[index++] = e;
    }
}</pre></li>
			</ul>
			<p>The first constructor uses an <code>initializer_list</code> to pass elements for the container. We call <code>make_unique</code> to allocate space and populate the container with a range-based <code>for</code> loop.</p>
			<ul>
				<li>We<a id="_idIndexMarker413"/> also have a constructor that allocates space without populating the elements:<pre>Container(size_t sz) : n_elements_{sz} {
    c_ = std::<strong class="bold">make_unique</strong>&lt;T[]&gt;(n_elements_);
}</pre></li>
			</ul>
			<p>The <code>make_unique()</code> function constructs empty objects for element.</p>
			<ul>
				<li>The <code>size()</code> function returns the number of elements:<pre>size_t size() const {
    return n_elements_;
}</pre></li>
				<li>The <code>operator[]()</code> function returns an indexed element:<pre>const T&amp; operator[](const size_t index) const {
    return c_[index];
}</pre></li>
				<li>The <code>at()</code> function returns an indexed element <em class="italic">with bounds checking</em>:<pre>T&amp; at(const size_t index) const {
    <strong class="bold">if(index &gt; n_elements_ - 1)</strong> {
        <strong class="bold">throw std::out_of_range</strong>(
            "Container::at(): index out of range"
        );
    }
    return c_[index];
}</pre></li>
			</ul>
			<p>This is consistent with STL usage. The <code>at()</code> function is the preferred method.</p>
			<ul>
				<li>The <code>begin()</code> and <code>end()</code> functions call the iterator constructor with the address <a id="_idIndexMarker414"/>of the container data.<pre>iterator begin() const { return iterator(<strong class="bold">c_.get()</strong>); }
iterator end() const { 
    return iterator(<strong class="bold">c_.get()</strong> + n_elements_); 
}</pre></li>
			</ul>
			<p>The <code>unique_ptr::get()</code> function returns the address from the smart pointer.</p>
			<ul>
				<li>The <code>iterator</code> class is nested within the <code>Container</code> class as a <code>public</code> member.<pre>class iterator {
    T* ptr_;</pre></li>
			</ul>
			<p>The iterator class has one private member, a pointer that's initialized in the <code>begin()</code> and <code>end()</code> methods of the Container class.</p>
			<ul>
				<li>The iterator constructor takes a pointer to the container data.<pre>iterator(T* ptr = nullptr) : ptr_{ptr} {}</pre></li>
			</ul>
			<p>We provide a default value because the standard requires a default constructor.</p>
			<h3>Operator overloads</h3>
			<p>This iterator <a id="_idIndexMarker415"/>provides operator overloads for the following operators: <code>++</code>, <em class="italic">postfix</em> <code>++</code>, <code>--</code>, <em class="italic">postfix</em> <code>--</code>, <code>[]</code>, <em class="italic">default comparison</em> <code>&lt;=&gt;</code> <em class="italic">(C++20)</em>, <code>==</code>, <code>*</code>, <code>-&gt;</code>, <code>+</code>, <em class="italic">non-member</em> <code>+</code>, <em class="italic">numeric</em> <code>-</code>, <em class="italic">object</em> <code>-</code>, <code>+=</code>, and <code>-=</code>. We'll cover a few notable overloads here. See the source code for all of them.</p>
			<ul>
				<li>The C++20 default comparison operator <code>&lt;=&gt;</code> provides the functionality of the full suite of comparison operators, except the equality <code>==</code> operator:<pre>const auto operator&lt;=&gt;(const iterator&amp; o) const {
    return ptr_ &lt;=&gt; o.ptr_;
}</pre></li>
			</ul>
			<p>This is a C++20 feature, so it requires a compliant compiler and library.</p>
			<ul>
				<li>There are two <code>+</code> operator overloads. These support <em class="italic">it + n</em> and <em class="italic">n + it</em> operations.<pre>iterator <strong class="bold">operator+</strong>(<strong class="bold">const size_t n</strong>) const {
    return iterator(ptr_ + n);
}
// non-member operator (n + it)
<strong class="bold">friend</strong> const iterator <strong class="bold">operator+</strong>(
        <strong class="bold">const size_t n</strong>, <strong class="bold">const iterator&amp; o</strong>) {
    return iterator(o.ptr_ + n);
}</pre></li>
			</ul>
			<p>The <code>friend</code> declaration is a special case. When used in a template class member function, it's the equivalent of a non-member function. This allows a non-member function to be defined in the class context.</p>
			<ul>
				<li>The <code>-</code> operator also has two overloads. We need to support both a numeric operand and an iterator operand.<pre>const iterator operator-(const size_t n) {
    return iterator(ptr_ - n);
}
const size_t operator-(const iterator&amp; o) {
    return ptr_ - o.ptr_;
}</pre></li>
			</ul>
			<p>This <a id="_idIndexMarker416"/>allows both <em class="italic">it – n</em> and <em class="italic">it – it</em> operations. There's no need for a non-member function, as <em class="italic">n – it</em> is not a valid operation.</p>
			<h3>Validation code</h3>
			<p>The C++20 specification §23.3.4.13 requires a <a id="_idIndexMarker417"/>specific set of operations and results for a valid random-access iterator. I've included a <code>unit_tests()</code> function in the source code to validate those requirements.</p>
			<p>The <code>main()</code> function creates a <code>Container</code> object and performs some simple validation functions.</p>
			<ul>
				<li>First, we create a <code>Container&lt;string&gt;</code> object <code>x</code> with ten values.<pre>Container&lt;string&gt; x{"one", "two", "three", "four", "five", 
    "six", "seven", "eight", "nine", "ten" };
cout &lt;&lt; format("Container x size: {}\n", x.size());</pre></li>
			</ul>
			<p>The output gives the number of elements:</p>
			<pre><strong class="bold">Container x size: 10</strong></pre>
			<ul>
				<li>We display the elements of the container with a range-based <code>for</code> loop:<pre>puts("Container x:");
for(auto e : x) {
    cout &lt;&lt; format("{} ", e);
}
cout &lt;&lt; '\n';</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">Container x:</strong>
<strong class="bold">one two three four five six seven eight nine ten</strong></pre>
			<ul>
				<li>Next, we<a id="_idIndexMarker418"/> test several direct access methods:<pre>puts("direct access elements:");
cout &lt;&lt; format("element at(5): {}\n", x.at(5));
cout &lt;&lt; format("element [5]: {}\n", x[5]);
cout &lt;&lt; format("element begin + 5: {}\n",
    *(x.begin() + 5));
cout &lt;&lt; format("element 5 + begin: {}\n",
    *(5 + x.begin()));
cout &lt;&lt; format("element begin += 5: {}\n",
    *(x.begin() += 5));</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">direct access elements:</strong>
<strong class="bold">element at(5): six</strong>
<strong class="bold">element [5]: six</strong>
<strong class="bold">element begin + 5: six</strong>
<strong class="bold">element 5 + begin: six</strong>
<strong class="bold">element begin += 5: six</strong></pre>
			<ul>
				<li>We test the container with a <code>ranges::views</code> pipe and <code>views::reverse</code>:<pre>puts("views pipe reverse:");
auto result = x | views::reverse;
for(auto v : result) cout &lt;&lt; format("{} ", v);
cout &lt;&lt; '\n';</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">views pipe reverse:</strong>
<strong class="bold">ten nine eight seven six five four three two one</strong></pre>
			<ul>
				<li>Finally, we <a id="_idIndexMarker419"/>create a <code>Container</code> object <code>y</code> with 10 uninitialized elements:<pre>Container&lt;string&gt; y(x.size());
cout &lt;&lt; format("Container y size: {}\n", y.size());
for(auto e : y) {
    cout &lt;&lt; format("[{}] ", e);
}
cout &lt;&lt; '\n';</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">Container y size: 10</strong>
<strong class="bold">[] [] [] [] [] [] [] [] [] []</strong></pre>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/>How it works…</h2>
			<p>Although it's a lot of code, this <a id="_idIndexMarker420"/>iterator is no more complicated than a smaller iterator. Most of the code is in the operator overloads, which are mostly one or two lines of code each.</p>
			<p>The container itself is managed by a <em class="italic">smart pointer</em>. This is simplified by the fact that it's a flat array and doesn't require expansion or compression.</p>
			<p>Of course, the STL provides a flat <code>std::array</code> class, as well as other more complex data structures. Still, you may find it valuable to demystify the workings of a complete iterator class.</p>
		</div>
	</body></html>