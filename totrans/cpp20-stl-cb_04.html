<html><head></head><body>
		<div id="_idContainer027">
			<h1 id="_idParaDest-123"><em class="italic"><a id="_idTextAnchor122"/>Chapter 4</em>: Compatible Iterators</h1>
			<p>Iterators are a<a id="_idIndexMarker311"/> fundamental concept in the STL. Iterators are implemented with the semantics of C pointers, using the same increment, decrement, and dereference operators. The pointer idiom is familiar to most C/C++ programmers, and it allows <em class="italic">algorithms</em> such as <strong class="source-inline">std::sort</strong> and <strong class="source-inline">std::transform</strong> to work on primitive memory buffers as well as STL containers.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor123"/>Iterators are fundamental</h1>
			<p>The STL uses iterators to<a id="_idIndexMarker312"/> navigate the elements of its container classes. Most containers include <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> iterators. These are usually implemented as member functions that return an iterator object. The <strong class="source-inline">begin()</strong> iterator<a id="_idIndexMarker313"/> points to the initial container element, and the <strong class="source-inline">end()</strong> iterator points <em class="italic">past</em> the final element:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B18267_04_01.jpg" alt="Figure 4.1 – The begin() and end() iterators&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – The begin() and end() iterators</p>
			<p>The <strong class="source-inline">end()</strong> iterator<a id="_idIndexMarker314"/> may function as a <em class="italic">sentinel</em> for containers of indeterminate length. We'll see some examples of that in this chapter.</p>
			<p>Most STL containers define their own specific <em class="italic">iterator type</em>. For example, for a <strong class="source-inline">vector</strong> of <strong class="source-inline">int</strong>:</p>
			<p class="source-code">std::vector&lt;int&gt; v;</p>
			<p>The iterator type would be defined as:</p>
			<p class="source-code">std::vector&lt;int&gt;::iterator v_it;</p>
			<p>You can see how this could easily get out of hand. If we had a <strong class="source-inline">vector</strong> of <strong class="source-inline">vector</strong> of <strong class="source-inline">string</strong>:</p>
			<p class="source-code">std::vector&lt;std::vector&lt;int, std::string&gt;&gt; v;</p>
			<p>Its iterator type would be:</p>
			<p class="source-code">std::vector&lt;std::vector&lt;int, std::string&gt;&gt;::iterator v_it;</p>
			<p>Fortunately, C++11 gave us automatic type deduction and the <strong class="source-inline">auto</strong> type. By using <strong class="source-inline">auto</strong>, we rarely need to use the full iterator type definition. For example, if we need an iterator in a <strong class="source-inline">for</strong> loop, we can use the <strong class="source-inline">auto</strong> type:</p>
			<p class="source-code">for(auto v_it = v.begin(); v_it != v.end(); ++v_it) {</p>
			<p class="source-code">    cout &lt;&lt; <strong class="bold">*v_it</strong> &lt;&lt; '\n';</p>
			<p class="source-code">}</p>
			<p>Notice the use<a id="_idIndexMarker315"/> of the dereference operator <strong class="source-inline">*</strong> to access the elements from the iterator. This is the same syntax you would use to dereference a pointer:</p>
			<p class="source-code">const int a[]{ 1, 2, 3, 4, 5 };</p>
			<p class="source-code">size_t count{ sizeof(a) / sizeof(int) };</p>
			<p class="source-code">for(const int* p = a; count &gt; 0; ++p, --count) {</p>
			<p class="source-code">    cout &lt;&lt; <strong class="bold">*p</strong> &lt;&lt; '\n';</p>
			<p class="source-code">}</p>
			<p>This also means that you can use a range-based <strong class="source-inline">for</strong> loop with either a primitive array:</p>
			<p class="source-code">const int a[]{ 1, 2, 3, 4, 5 };</p>
			<p class="source-code">for(auto e : a) {</p>
			<p class="source-code">    cout &lt;&lt; e &lt;&lt; '\n';</p>
			<p class="source-code">}</p>
			<p>Or with an STL container:</p>
			<p class="source-code">std::vector&lt;int&gt; v{ 1, 2, 3, 4, 5 };</p>
			<p class="source-code">for(auto e : v) {</p>
			<p class="source-code">    cout &lt;&lt; e &lt;&lt; '\n';</p>
			<p class="source-code">}</p>
			<p>The range-based <strong class="source-inline">for</strong> loop is just a shorthand for a <strong class="source-inline">for</strong> loop with iterators:</p>
			<p class="source-code">{</p>
			<p class="source-code">    auto begin_it{ std::begin(container) };</p>
			<p class="source-code">    auto end_it{ std::end(container) };</p>
			<p class="source-code">    for ( ; begin_it != end_it; ++begin_it) {</p>
			<p class="source-code">        auto e{ *begin_it };</p>
			<p class="source-code">        cout &lt;&lt; e &lt;&lt; '\n';</p>
			<p class="source-code">    } </p>
			<p class="source-code">}</p>
			<p>Because iterators use the same syntax as a primitive pointer, the range-based <strong class="source-inline">for</strong> loop works the same with either container.</p>
			<p>Notice that the range-based <strong class="source-inline">for</strong> loop calls <strong class="source-inline">std::begin()</strong> and <strong class="source-inline">std::end()</strong>, instead of directly calling the <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> member functions. The <strong class="source-inline">std::</strong> functions call the member functions to get the iterators. So, why not just call the member functions? The <strong class="source-inline">std::</strong> non-member functions are designed to also work with primitive arrays. That's why a <strong class="source-inline">for</strong> loop works with an array:</p>
			<p class="source-code">const int arr[]{ 1, 2, 3, 4, 5 };</p>
			<p class="source-code">for(auto e : arr) {</p>
			<p class="source-code">    cout &lt;&lt; format("{} ", e);</p>
			<p class="source-code">}</p>
			<p>Output:</p>
			<p class="source-code">1 2 3 4 5</p>
			<p>For most purposes, I tend<a id="_idIndexMarker316"/> to favor the member function <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> because they are more explicit. Others favor the <strong class="source-inline">std::</strong> non-member functions because they are more general. Six or half-dozen; I suggest you pick a style and stick with it.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/>Iterator categories</h2>
			<p>Prior to C++20, iterators <a id="_idIndexMarker317"/>were divided into categories based on their capabilities:</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B18267_04_Table_01.jpg" alt=""/>
				</div>
			</div>
			<p>These <a id="_idIndexMarker318"/>categories are hierarchical, where the more capable iterators inherit the capabilities of the less capable iterators. In other words, the <em class="italic">input iterator</em> can<a id="_idIndexMarker319"/> read and increment once. The <em class="italic">forward iterator</em> has the <a id="_idIndexMarker320"/>capabilities of the Input Iterator <em class="italic">plus</em> it can increment multiple times. The <em class="italic">bidirectional iterator</em> has<a id="_idIndexMarker321"/> those capabilities <em class="italic">plus</em> it can decrement. And on down the list.</p>
			<p>The <em class="italic">output iterator</em> can <a id="_idIndexMarker322"/>write and increment once. If any of the other iterators can also write, it is <a id="_idIndexMarker323"/>considered a <em class="italic">mutable iterator</em>.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor125"/>Iterator concepts</h2>
			<p><em class="italic">Concepts</em> and <em class="italic">constraints</em> are<a id="_idIndexMarker324"/> new with C++20. A concept is simply a named constraint that restricts the types of arguments to a template function or class, and helps the compiler choose appropriate specializations.</p>
			<p>Beginning with C++20, the STL defines iterators in terms of concepts instead of categories. Each of these concepts are in the <strong class="source-inline">std::</strong> namespace.</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B18267_04_Table_02.jpg" alt=""/>
				</div>
			</div>
			<p>You can use these<a id="_idIndexMarker325"/> concepts to constrain the arguments of a template:</p>
			<p class="source-code">template&lt;typename T&gt;</p>
			<p class="source-code"><strong class="bold">requires std::random_access_iterator&lt;typename T::iterator&gt;</strong></p>
			<p class="source-code">void printc(const T &amp; c) {</p>
			<p class="source-code">        for(auto e : c) {</p>
			<p class="source-code">        cout &lt;&lt; format("{} ", e);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    cout &lt;&lt; '\n';</p>
			<p class="source-code">    cout &lt;&lt; format("element 0: {}\n", c[0]);</p>
			<p class="source-code">}</p>
			<p>This function requires a <strong class="source-inline">random_access_iterator</strong>. If I call it with a <strong class="source-inline">list</strong>, which is not a random-access container, the compiler will give me an error:</p>
			<p class="source-code">int main()</p>
			<p class="source-code">{</p>
			<p class="source-code">    list&lt;int&gt; c{ 1, 2, 3, 4, 5 };</p>
			<p class="source-code">    printc(c);       </p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">list</strong> iterator<a id="_idIndexMarker326"/> type does not support the <strong class="source-inline">random_access_iterator</strong> concept. So, the compiler gives me an error:</p>
			<p class="source-code">error: no matching function for call to 'printc(std::__cxx11::list&lt;int&gt;&amp;)'</p>
			<p class="source-code">   27 |     printc(c);</p>
			<p class="source-code">      |     ~~~~~~^~~</p>
			<p class="source-code">note: candidate: 'template&lt;class T&gt;  requires  random_access_iterator&lt;typename T::iterator&gt; void printc(const T&amp;)'</p>
			<p class="source-code">   16 | void printc(const T &amp; c) {</p>
			<p class="source-code">      |      ^~~~~~</p>
			<p class="source-code">note:   template argument deduction/substitution failed:</p>
			<p class="source-code">note: constraints not satisfied</p>
			<p>This is the error output from GCC. Your errors may look different.</p>
			<p>If I call it with a <strong class="source-inline">vector</strong>, which is a random-access container:</p>
			<p class="source-code">int main()</p>
			<p class="source-code">{</p>
			<p class="source-code">    vector&lt;int&gt; c{ 1, 2, 3, 4, 5 };</p>
			<p class="source-code">    printc(c);       </p>
			<p class="source-code">}</p>
			<p>Now it compiles and runs without error:</p>
			<p class="source-code">$ ./working</p>
			<p class="source-code">1 2 3 4 5</p>
			<p class="source-code">element 0: 1</p>
			<p>While there <a id="_idIndexMarker327"/>are different types of iterators for different types of capabilities (and concepts), the complexity is there to support of ease of use.</p>
			<p>With this introduction to iterators, let's now proceed with the following recipes in this chapter:</p>
			<ul>
				<li>Create an iterable range</li>
				<li>Make your iterators compatible with STL iterator traits</li>
				<li>Use iterator adapters to fill STL containers</li>
				<li>Create a generator as iterators</li>
				<li>Use reverse iterator adapters to iterate backward</li>
				<li>Iterate objects of unknown length with a sentinel</li>
				<li>Build a zip iterator adapter</li>
				<li>Create a random-access iterator</li>
			</ul>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor126"/>Technical requirements</h1>
			<p>You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap04">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap04</a>.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor127"/>Create an iterable range</h1>
			<p>This<a id="_idIndexMarker328"/> recipe describes a simple class that generates an iterable range, suitable for use with the range-based <strong class="source-inline">for</strong> loop. The idea is to create a <em class="italic">sequence generator</em> that iterates from a beginning value to an ending value.</p>
			<p>To accomplish this task, we need an iterator class, along with the object interface class.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor128"/>How to do it…</h2>
			<p>There's two major<a id="_idIndexMarker329"/> parts to this recipe, the main interface, <strong class="source-inline">Seq</strong>, and the <strong class="source-inline">iterator</strong> class.</p>
			<ul>
				<li>First, we'll define the <strong class="source-inline">Seq</strong> class. It only needs to implement the <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> member functions:<p class="source-code">template&lt;typename T&gt;</p><p class="source-code">class Seq {</p><p class="source-code">    T start_{};</p><p class="source-code">    T end_{};</p><p class="source-code">public:</p><p class="source-code">    Seq(T start, T end) : start_{start}, end_{end} {}</p><p class="source-code">    iterator&lt;T&gt; begin() const {</p><p class="source-code">        return iterator{start_};</p><p class="source-code">    }</p><p class="source-code">    iterator&lt;T&gt; end() const { return iterator{end_}; }</p><p class="source-code">};</p></li>
			</ul>
			<p>The constructor sets up the <strong class="source-inline">start_</strong> and <strong class="source-inline">end_</strong> variables. These are used to construct the <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> iterators, respectively. The member functions <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> return <strong class="source-inline">iterator</strong> objects.</p>
			<ul>
				<li>The <strong class="source-inline">iterator</strong> class is normally defined inside the public section of the container class. This is called a <em class="italic">member class</em> or a <em class="italic">nested class</em>. We'll insert it right after the <strong class="source-inline">Seq</strong> constructor:<p class="source-code">public:</p><p class="source-code">    Seq(T start, T end) : start_{ start }, end_{ end } {}</p><p class="source-code">    class iterator {</p><p class="source-code">        T value_{};</p><p class="source-code">    public:</p><p class="source-code">        explicit iterator(T position = 0)</p><p class="source-code">            : value_{position} {}</p><p class="source-code">        T operator*() const { return value_; }</p><p class="source-code">        iterator&amp; operator++() {</p><p class="source-code">            ++value_;</p><p class="source-code">            return *this;</p><p class="source-code">        }</p><p class="source-code">        bool operator!=(const iterator&amp; other) const {</p><p class="source-code">            return value_ != other.value_;</p><p class="source-code">        }</p><p class="source-code">    };</p></li>
			</ul>
			<p>It's traditional <a id="_idIndexMarker330"/>to name the iterator class <strong class="source-inline">iterator</strong>. This allows it to be referenced as <strong class="source-inline">Seq&lt;</strong><em class="italic">type</em><strong class="source-inline">&gt;::iterator</strong>.</p>
			<p>The <strong class="source-inline">iterator</strong> constructor is qualified <strong class="source-inline">explicit</strong> to avoid implicit conversions.</p>
			<p>The <strong class="source-inline">value_</strong> variable is maintained by the iterator. This is used to return a value from the pointer dereference.</p>
			<p>The minimum requirement for supporting the range-based <strong class="source-inline">for</strong> loop is a dereference operator <strong class="source-inline">*</strong>, a pre-increment operator <strong class="source-inline">++</strong>, and the not-equal comparison operator <strong class="source-inline">!=</strong>.</p>
			<ul>
				<li>Now we can write a <strong class="source-inline">main()</strong> function to test our sequence generator:<p class="source-code">int main()</p><p class="source-code">{</p><p class="source-code">    Seq&lt;int&gt; r{ 100, 110 };</p><p class="source-code">    for (auto v : r) {</p><p class="source-code">        cout &lt;&lt; format("{} ", v);</p><p class="source-code">    }</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>This <a id="_idIndexMarker331"/>constructs a <strong class="source-inline">Seq</strong> object and prints out its sequence.</p>
			<p>The output looks like this:</p>
			<p class="source-code"><strong class="bold">$ ./seq</strong></p>
			<p class="source-code"><strong class="bold">100 101 102 103 104 105 106 107 108 109</strong></p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor129"/>How it works…</h2>
			<p>The point of this recipe is to make a sequence generator that works with a range-based <strong class="source-inline">for</strong> loop. Let's first consider the equivalent code for the range-based <strong class="source-inline">for</strong> loop:</p>
			<p class="source-code">{</p>
			<p class="source-code">    auto begin_it{ <strong class="bold">std::begin(container)</strong> };</p>
			<p class="source-code">    auto end_it{ <strong class="bold">std::end(container)</strong> };</p>
			<p class="source-code">    for ( ; <strong class="bold">begin_it != end_it</strong>; <strong class="bold">++begin_it</strong>) {</p>
			<p class="source-code">        auto v{ <strong class="bold">*begin_it</strong> };</p>
			<p class="source-code">        cout &lt;&lt; v &lt;&lt; '\n';</p>
			<p class="source-code">    } </p>
			<p class="source-code">}</p>
			<p>From this equivalent code, we can deduce the requirements for an object to work with the <strong class="source-inline">for</strong> loop:</p>
			<ul>
				<li><strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> iterators</li>
				<li>Iterator support for the not-equal comparison <strong class="source-inline">!=</strong> operator</li>
				<li>Iterator support for the prefix increment <strong class="source-inline">++</strong> operator</li>
				<li>Iterator support for the dereference <strong class="source-inline">*</strong> operator</li>
			</ul>
			<p>Our<a id="_idIndexMarker332"/> main <strong class="source-inline">Seq</strong> class interface only has three public member functions: the constructor, and the <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> iterators:</p>
			<p class="source-code"><strong class="bold">Seq</strong>(T start, T end) : start_{ start }, end_{ end } {}</p>
			<p class="source-code">iterator <strong class="bold">begin()</strong> const { return iterator{start_}; }</p>
			<p class="source-code">iterator <strong class="bold">end()</strong> const { return iterator{end_}; }</p>
			<p>The implementation of the <strong class="source-inline">Seq::iterator</strong> class carries the actual payload:</p>
			<p class="source-code">class iterator {</p>
			<p class="source-code">    T <strong class="bold">value_</strong>{};</p>
			<p>This is the common configuration because the payload is only accessed through iterators.</p>
			<p>We've implemented only the three operators we need:</p>
			<p class="source-code">    T <strong class="bold">operator*</strong>() const { return value_; }</p>
			<p class="source-code">    iterator&amp; <strong class="bold">operator++</strong>() {</p>
			<p class="source-code">        ++value_;</p>
			<p class="source-code">        return *this;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    bool <strong class="bold">operator!=</strong>(const iterator&amp; other) const {</p>
			<p class="source-code">        return value_ != other.value_;</p>
			<p class="source-code">    }</p>
			<p>This is all we need to support the range-based <strong class="source-inline">for</strong> loop:</p>
			<p class="source-code">Seq&lt;int&gt; r{ 100, 110 };</p>
			<p class="source-code">for (auto v : r) {</p>
			<p class="source-code">    cout &lt;&lt; format("{} ", v);</p>
			<p class="source-code">}</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor130"/>There's more…</h2>
			<p>It's traditional, but<a id="_idIndexMarker333"/> not required, to define the iterator as a member class of the container. This allows the <strong class="source-inline">iterator</strong> type to be subordinate to the container type:</p>
			<p class="source-code">Seq&lt;int&gt;::iterator it = r.begin();</p>
			<p>It's not as important post C++11 because of the <strong class="source-inline">auto</strong> type, but it's still considered best practice.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor131"/>Make your iterators compatible with STL iterator traits</h1>
			<p>Many<a id="_idIndexMarker334"/> STL algorithms require iterators to conform to certain traits. Unfortunately, these requirements are inconsistent across compilers, systems, and C++ versions.</p>
			<p>For our <a id="_idIndexMarker335"/>purposes, we'll use the class from the <em class="italic">Create an iterable range</em> recipe to illustrate the issue. You may find this makes more sense if you read that recipe before continuing.</p>
			<p>In <strong class="source-inline">main()</strong>, if I add a call to the <strong class="source-inline">minmax_element()</strong> algorithm:</p>
			<p class="source-code">Seq&lt;int&gt; r{ 100, 110 };</p>
			<p class="source-code">auto [min_it, max_it] = minmax_element(r.begin(), r.end());</p>
			<p class="source-code">cout &lt;&lt; format("{} - {}\n", *min_it, *max_it);</p>
			<p>It does not compile. The error messages are vague, cryptic, and cascading, but if you look closely, you'll see that our iterator does not meet the requirements to be compatible with this algorithm.</p>
			<p>Okay, let's fix that.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/>How to do it…</h2>
			<p>We need to <a id="_idIndexMarker336"/>make a few simple additions to our iterator to make it compatible with the algorithm. Our iterator needs to meet<a id="_idIndexMarker337"/> the minimum requirements for a <em class="italic">forward iterator</em>, so let's start there:</p>
			<ul>
				<li>We have almost all the operators necessary for a forward iterator. The only one we're missing is the equality comparison operator <strong class="source-inline">==</strong>. We can easily add this to our iterator with an <strong class="source-inline">operator==()</strong> overload:<p class="source-code">bool operator==(const iterator&amp; other) const {</p><p class="source-code">    return value_ == other.value_;</p><p class="source-code">}</p></li>
			</ul>
			<p>Interestingly, this makes the code compile and run on some systems, but not on <em class="italic">Clang</em>, where we get the error message:</p>
			<p class="source-code"><strong class="bold">No type named 'value_type' in 'std::iterator_traits&lt;Seq&lt;int&gt;::iterator&gt;'</strong></p>
			<p>This tells me that we need to set up the traits in the iterator.</p>
			<ul>
				<li>The <strong class="source-inline">iterator_traits</strong> class looks for a set of <em class="italic">type definitions</em> (implemented as <strong class="source-inline">using</strong> aliases) in the <strong class="source-inline">iterator</strong> class:<p class="source-code">public:</p><p class="source-code">    using iterator_concept  = std::forward_iterator_tag;</p><p class="source-code">    using iterator_category = </p><p class="source-code">      std::forward_iterator_tag;</p><p class="source-code">    using value_type        = std::remove_cv_t&lt;T&gt;;</p><p class="source-code">    using difference_type   = std::ptrdiff_t;</p><p class="source-code">    using pointer           = const T*;</p><p class="source-code">    using reference         = const T&amp;;</p></li>
			</ul>
			<p>I tend to put these at the top of the <strong class="source-inline">public:</strong> section of the <strong class="source-inline">iterator</strong> class, where they'll be easy to see.</p>
			<p>Now we have a fully conforming <em class="italic">forward iterator</em> class, and the code runs on all the compilers I have.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>How it works…</h2>
			<p>The <strong class="source-inline">using</strong> statements<a id="_idIndexMarker338"/> are traits that may be <a id="_idIndexMarker339"/>used to define what capabilities the iterator can perform. Let's look at each of them:</p>
			<p class="source-code">using iterator_concept  = std::forward_iterator_tag;</p>
			<p class="source-code">using iterator_category = std::forward_iterator_tag;</p>
			<p>The first two are the <em class="italic">category</em> and the <em class="italic">concept</em>, and both are set to <strong class="source-inline">forward_iterator_tag</strong>. This value indicates that the iterator conforms to the forward iterator specification.</p>
			<p>Some code doesn't look at those values, and instead looks for individual settings and capabilities:</p>
			<p class="source-code">using value_type        = std::remove_cv_t&lt;T&gt;;</p>
			<p class="source-code">using difference_type   = std::ptrdiff_t;</p>
			<p class="source-code">using pointer           = const T*;</p>
			<p class="source-code">using reference         = const T&amp;;</p>
			<p>The <strong class="source-inline">value_type</strong> alias is set to <strong class="source-inline">std::remove_cv_t&lt;T&gt;</strong>, which is the type of the value, with any <strong class="source-inline">const</strong> qualifier removed.</p>
			<p>The <strong class="source-inline">difference_type</strong> alias is set to <strong class="source-inline">std::ptrdiff_t</strong>, as special type for pointer differences.</p>
			<p>The <strong class="source-inline">pointer</strong> and <strong class="source-inline">reference</strong> aliases are set to <strong class="source-inline">const</strong>-qualified versions of the pointer and reference, respectively.</p>
			<p>Defining these type aliases is a basic requirement for most iterators.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/>There's more…</h2>
			<p>It's worth<a id="_idIndexMarker340"/> noting that defining these traits allows us to use concept-restricted templates with our iterator. For example:</p>
			<p class="source-code">template&lt;typename T&gt;</p>
			<p class="source-code">requires std::forward_iterator&lt;typename T::iterator&gt;</p>
			<p class="source-code">void printc(const T &amp; c) {</p>
			<p class="source-code">    for(auto v : c) {</p>
			<p class="source-code">        cout &lt;&lt; format("{} ", v);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    cout &lt;&lt; '\n';</p>
			<p class="source-code">}</p>
			<p>This<a id="_idIndexMarker341"/> function that prints our sequence is restricted by the <strong class="source-inline">forward_iterator</strong> concept. If our class did not qualify, it wouldn't compile.</p>
			<p>We can also use the <strong class="source-inline">ranges::</strong> versions of the algorithms:</p>
			<p class="source-code">auto [min_it, max_it] = ranges::minmax_element(r);</p>
			<p>This makes it more convenient to use our iterators.</p>
			<p>We can test for <strong class="source-inline">forward_range</strong> compatibility with a static assertion:</p>
			<p class="source-code">static_assert(ranges::forward_range&lt;Seq&lt;int&gt;&gt;);</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor135"/>Use iterator adapters to fill STL containers</h1>
			<p>An iterator is <a id="_idIndexMarker342"/>essentially an abstraction. It has a specific interface and is used in specific ways. But beyond that, it's just code and it <a id="_idIndexMarker343"/>can be used for other purposes. An <em class="italic">iterator adapter</em> is a class<a id="_idIndexMarker344"/> that looks like an iterator but does something else.</p>
			<p>The STL comes with an assortment of iterator adapters. Often used with the <strong class="source-inline">algorithm</strong> library, they are quite useful. The <a id="_idIndexMarker345"/>STL iterator adaptors generally fall into three categories:</p>
			<ul>
				<li><strong class="bold">Insert iterators</strong>, or <em class="italic">inserters</em>, are <a id="_idIndexMarker346"/>used to insert elements into a container.</li>
				<li><strong class="bold">Stream iterators</strong> read <a id="_idIndexMarker347"/>from and write to a stream.</li>
				<li><strong class="bold">Reverse iterators</strong> reverse <a id="_idIndexMarker348"/>the direction of an iterator.</li>
			</ul>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/>How to do it…</h2>
			<p>In this<a id="_idIndexMarker349"/> recipe, we'll look at a few examples of <a id="_idIndexMarker350"/>STL iterator adapters:</p>
			<ul>
				<li>We'll start with a simple function to print the contents of a container:<p class="source-code">void printc(const auto &amp; v, const string_view s = "") {</p><p class="source-code">    if(s.size()) cout &lt;&lt; format("{}: ", s);</p><p class="source-code">    for(auto e : v) cout &lt;&lt; format("{} ", e);</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">printc()</strong> function allows us to easily view the results of our algorithms. It includes an optional <strong class="source-inline">string_view</strong> argument for a description.</p>
			<ul>
				<li>In our <strong class="source-inline">main()</strong> function, we'll define a couple of <strong class="source-inline">deque</strong> containers. We're using <strong class="source-inline">deque</strong> containers so we can insert at both ends:<p class="source-code">int main() {</p><p class="source-code">    deque&lt;int&gt; d1{ 1, 2, 3, 4, 5 };</p><p class="source-code">    deque&lt;int&gt; d2(d1.size());</p><p class="source-code">    copy(d1.begin(), d1.end(), d2.begin());</p><p class="source-code">    printc(d1);</p><p class="source-code">    printc(d2, "d2 after copy"); </p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">1 2 3 4 5</strong></p>
			<p class="source-code"><strong class="bold">d2 after copy: 1 2 3 4 5</strong></p>
			<p>We <a id="_idIndexMarker351"/>defined deque <strong class="source-inline">d1</strong> with five <strong class="source-inline">int</strong> values, and <strong class="source-inline">d2</strong> with space for the same number of elements. The <strong class="source-inline">copy()</strong> algorithm will not allocate space, so <strong class="source-inline">d2</strong> must have room for the elements.</p>
			<p>The <strong class="source-inline">copy()</strong> algorithm takes three iterators: the <em class="italic">begin</em> and <em class="italic">end</em> iterators indicate<a id="_idIndexMarker352"/> the range of elements to copy from, and the <em class="italic">begin</em> iterator of the destination range. It does not check the iterators to make sure they're valid. (Try this without allocating space in a <strong class="source-inline">vector</strong> and you'll get a <em class="italic">segmentation fault</em> error.)</p>
			<p>We call <strong class="source-inline">printc()</strong> on both containers to show the results.</p>
			<ul>
				<li>The <strong class="source-inline">copy()</strong> algorithm is not always convenient for this. Sometimes you want to copy and add elements to the end of a container. It would be nice to have an algorithm that calls <strong class="source-inline">push_back()</strong> for each element. This is where an iterator adapter is useful. Let's add some code at the end of <strong class="source-inline">main()</strong>:<p class="source-code">copy(d1.begin(), d1.end(), back_inserter(d2));</p><p class="source-code">printc(d2, "d2 after back_inserter");</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">d2 after back_inserter: 1 2 3 4 5 1 2 3 4 5</strong></p>
			<p><strong class="source-inline">back_inserter()</strong> is an <em class="italic">insert iterator adapter</em> that calls <strong class="source-inline">push_back()</strong> for each item assigned to it. You can use it anywhere an output iterator is expected.</p>
			<ul>
				<li>There's also a <strong class="source-inline">front_inserter()</strong> adapter for when you want to insert at the front of a container:<p class="source-code">deque&lt;int&gt; d3{ 47, 73, 114, 138, 54 };</p><p class="source-code">copy(d3.begin(), d3.end(), front_inserter(d2));</p><p class="source-code">printc(d2, "d2 after front_inserter");</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">d2 after front_inserter: 54 138 114 73 47 1 2 3 4 5 1 2 3 4 5</strong></p>
			<p>The <strong class="source-inline">front_inserter()</strong> adapter inserts elements at the front using the container's <strong class="source-inline">push_front()</strong> method. Notice that the elements in the destination <a id="_idIndexMarker353"/>are reversed, because each element is inserted before the previous one.</p>
			<ul>
				<li>If we<a id="_idIndexMarker354"/> want to insert in the middle, we can use the <strong class="source-inline">inserter()</strong> adapter:<p class="source-code">auto it2{ d2.begin() + 2};</p><p class="source-code">copy(d1.begin(), d1.end(), inserter(d2, it2));</p><p class="source-code">printc(d2, "d2 after middle insert");</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">d2 after middle insert: 54 138 1 2 3 4 5 114 73 47 ...</strong></p>
			<p>The <strong class="source-inline">inserter()</strong> adapter takes an iterator for the insertion begin point.</p>
			<ul>
				<li><em class="italic">Stream iterators</em> are <a id="_idIndexMarker355"/>convenient for reading from and writing to <strong class="source-inline">iostream</strong> objects, this is <strong class="source-inline">ostream_iterator()</strong>:<p class="source-code">cout &lt;&lt; "ostream_iterator: ";</p><p class="source-code">copy(d1.begin(), d1.end(), ostream_iterator&lt;int&gt;(cout));</p><p class="source-code">cout &lt;&lt; '\n';</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">ostream_iterator: 12345</strong></p>
			<ul>
				<li>And<a id="_idIndexMarker356"/> here is <strong class="source-inline">istream_iterator()</strong>:<p class="source-code">vector&lt;string&gt; vs{};</p><p class="source-code">copy(istream_iterator&lt;string&gt;(cin), </p><p class="source-code">    istream_iterator&lt;string&gt;(),</p><p class="source-code">    back_inserter(vs));</p><p class="source-code">printc(vs, "vs2");</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">$ ./working &lt; five-words.txt</strong></p>
			<p class="source-code"><strong class="bold">vs2: this is not a haiku</strong></p>
			<p>The <strong class="source-inline">istream_iterator()</strong> adapter will return an end iterator by default, if no <a id="_idIndexMarker357"/>stream is passed.</p>
			<ul>
				<li><em class="italic">Reverse adapters</em> are included <a id="_idIndexMarker358"/>with most containers, as function members <strong class="source-inline">rbegin()</strong> and <strong class="source-inline">rend()</strong>:<p class="source-code">for(auto it = d1.rbegin(); it != d1.rend(); ++it) {</p><p class="source-code">    cout &lt;&lt; format("{} ", *it);</p><p class="source-code">}</p><p class="source-code">cout &lt;&lt; '\n';</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">5 4 3 2 1</strong></p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/>How it works…</h2>
			<p>The iterator adapters work by wrapping around an existing container. When you call an adapter, like <strong class="source-inline">back_inserter()</strong> with a container object:</p>
			<p class="source-code">copy(d1.begin(), d1.end(), back_inserter(d2));</p>
			<p>The adapter returns an object that <em class="italic">mimics</em> an iterator, in this case a <strong class="source-inline">std::back_insert_iterator</strong> object, which calls the <strong class="source-inline">push_back()</strong> method on the container object each time a value is assigned to the iterator. This allows the adapter to be used in place of an iterator, while performing its useful task.</p>
			<p>The <strong class="source-inline">istream_adapter()</strong> also requires a <em class="italic">sentinel</em>. A sentinel signals the end of an iterator <a id="_idIndexMarker359"/>of indeterminate length. When you read from a stream, you don't know how many objects are in the stream until you hit the end. When the stream hits the end, the sentinel will compare equal with the iterator, signaling the end of the stream. The <strong class="source-inline">istream_adapter()</strong> will create a sentinel when it's called without a parameter:</p>
			<p class="source-code">auto it = istream_adapter&lt;string&gt;(cin);</p>
			<p class="source-code">auto it_end = istream_adapter&lt;string&gt;();  // creates sentinel</p>
			<p>This allows you to test for the end of a stream, as you would with any container:</p>
			<p class="source-code">for(auto it = <strong class="bold">istream_iterator&lt;string&gt;(cin)</strong>;</p>
			<p class="source-code">        it != <strong class="bold">istream_iterator&lt;string&gt;()</strong>;</p>
			<p class="source-code">        ++it) {</p>
			<p class="source-code">    cout &lt;&lt; format("{} ", *it);</p>
			<p class="source-code">}</p>
			<p class="source-code">cout &lt;&lt; '\n';</p>
			<p>Output:</p>
			<p class="source-code">$ ./working &lt; five-words.txt</p>
			<p class="source-code">this is not a haiku</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor138"/>Create a generator as iterators</h1>
			<p>A <em class="italic">generator</em> is an<a id="_idIndexMarker360"/> iterator that <a id="_idIndexMarker361"/>generates<a id="_idIndexMarker362"/> its own sequence of values. It does not use a container. It creates values on the fly, returning one at a time as needed. A C++ generator stands on its own; it does not need to wrap around another object.</p>
			<p>In this <a id="_idIndexMarker363"/>recipe, we'll build a generator for a <em class="italic">Fibonacci sequence</em>. This <a id="_idIndexMarker364"/>is a sequence where each number is the sum of the previous two numbers in <a id="_idIndexMarker365"/>the sequence, starting with 0 and 1:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B18267_04_02.jpg" alt="Figure 4.2 – Definition of a Fibonacci sequence&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Definition of a Fibonacci sequence</p>
			<p>The first ten values of the Fibonacci sequence, not counting zero, are: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55. This is a close approximation of the <em class="italic">golden ratio</em> found in nature.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor139"/>How to do it…</h2>
			<p>A Fibonacci sequence is often created with a <em class="italic">recursive loop</em>. Recursion<a id="_idIndexMarker366"/> in a generator can be difficult and resource-intensive, so instead we'll just save the previous two values in the sequence and add them together. This is more efficient.</p>
			<ul>
				<li>First let's define a function to print the sequence:<p class="source-code">void printc(const auto &amp; v, const string_view s = "") {</p><p class="source-code">    if(s.size()) cout &lt;&lt; format("{}: ", s);</p><p class="source-code">    for(auto e : v) cout &lt;&lt; format("{} ", e);</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>We've used this <strong class="source-inline">printc()</strong> function before. It prints an iterable range, along with a description string, if provided.</p>
			<ul>
				<li>Our class begins with a <em class="italic">type alias</em>, and a few object variables, all in the <strong class="source-inline">private</strong> section.<p class="source-code">class fib_generator {</p><p class="source-code">    <strong class="bold">using fib_t</strong> = unsigned long;</p><p class="source-code">    fib_t <strong class="bold">stop_</strong>{};</p><p class="source-code">    fib_t <strong class="bold">count_</strong> { 0 };</p><p class="source-code">    fib_t <strong class="bold">a_</strong> { 0 };</p><p class="source-code">    fib_t <strong class="bold">b_</strong> { 1 };</p></li>
			</ul>
			<p>The <strong class="source-inline">stop_</strong> variable will be used later as a <em class="italic">sentinel</em>. It's set to the number of values to generate. <strong class="source-inline">count_</strong> is used to keep track of how many values we've generated. <strong class="source-inline">a_</strong> and <strong class="source-inline">b_</strong> are the<a id="_idIndexMarker367"/> previous two sequence values, used for calculating the next value.</p>
			<ul>
				<li>Still <a id="_idIndexMarker368"/>in the <strong class="source-inline">private</strong> section, we have a simple function for calculating the next value in the Fibonacci sequence.<p class="source-code">    constexpr void do_fib() {</p><p class="source-code">        const fib_t old_b = b_;</p><p class="source-code">        b_ += a_;</p><p class="source-code">        a_  = old_b;</p><p class="source-code">    }</p></li>
				<li>Now in the <strong class="source-inline">public</strong> section, we have a simple constructor with a default value:<p class="source-code">public:</p><p class="source-code">    explicit fib_generator(fib_t stop = 0) : stop_{ stop } {}</p></li>
			</ul>
			<p>This constructor is used without an argument to create a sentinel. The <strong class="source-inline">stop</strong> argument initializes the <strong class="source-inline">stop_</strong> variable to represent how many values to generate.</p>
			<ul>
				<li>The rest of the public functions<a id="_idIndexMarker369"/> are the operator overloads <a id="_idIndexMarker370"/>expected of a <em class="italic">forward iterator</em>:<p class="source-code">    fib_t operator*() const { return b_; }</p><p class="source-code">    constexpr fib_generator&amp; operator++() {</p><p class="source-code">        do_fib();</p><p class="source-code">        ++count_;</p><p class="source-code">        return *this;</p><p class="source-code">    }</p><p class="source-code">    fib_generator <strong class="bold">operator++</strong>(int) {</p><p class="source-code">        auto temp{ *this };</p><p class="source-code">        ++*this;</p><p class="source-code">        return temp; </p><p class="source-code">    }</p><p class="source-code">    bool <strong class="bold">operator!=</strong>(const fib_generator &amp;o) const {</p><p class="source-code">        return count_ != o.count_; </p><p class="source-code">    }</p><p class="source-code">    bool <strong class="bold">operator==</strong>(const fib_generator&amp;o) const { </p><p class="source-code">        return count_ == o.count_; </p><p class="source-code">    }</p><p class="source-code">    const fib_generator&amp; <strong class="bold">begin()</strong> const { return *this; }</p><p class="source-code">    const fib_generator <strong class="bold">end()</strong> const { </p><p class="source-code">        auto sentinel = fib_generator();</p><p class="source-code">        sentinel.count_ = stop_;</p><p class="source-code">        return sentinel;</p><p class="source-code">    }</p><p class="source-code">    fib_t <strong class="bold">size()</strong> { return stop_; }</p><p class="source-code">};</p></li>
			</ul>
			<p>There's also a simple <strong class="source-inline">size()</strong> function which can be useful if you need to initialize a target container for a copy operation.</p>
			<ul>
				<li>Now we <a id="_idIndexMarker371"/>can use the generator in our main function with a simple call to <strong class="source-inline">printc()</strong>:<p class="source-code">int main() {</p><p class="source-code">    printc(fib_generator(10));</p><p class="source-code">}</p></li>
			</ul>
			<p>This creates<a id="_idIndexMarker372"/> an anonymous <strong class="source-inline">fib_generator</strong> object to pass to the <strong class="source-inline">printc()</strong> function.</p>
			<ul>
				<li>We get this output with the first 10 Fibonacci numbers, not including zero:<p class="source-code"><strong class="bold">1 1 2 3 5 8 13 21 34 55</strong></p></li>
			</ul>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor140"/>How it works…</h2>
			<p>The <strong class="source-inline">fib_generator</strong> class operates as a forward iterator, simply because it provides all the necessary interface functions:</p>
			<p class="source-code">fib_generator {</p>
			<p class="source-code">public:</p>
			<p class="source-code">    fib_t operator*() const;</p>
			<p class="source-code">    constexpr fib_generator&amp; operator++();</p>
			<p class="source-code">    fib_generator operator++(int);</p>
			<p class="source-code">    bool operator!=(const fib_generator &amp;o) const;</p>
			<p class="source-code">    bool operator==(const fib_generator&amp;o) const;</p>
			<p class="source-code">    const fib_generator&amp; begin() const;</p>
			<p class="source-code">    const fib_generator end() const;</p>
			<p class="source-code">};</p>
			<p>As far as the range-based <strong class="source-inline">for</strong> loop is concerned, this is an iterator because it looks like an iterator.</p>
			<p>The value is <a id="_idIndexMarker373"/>calculated in the <strong class="source-inline">do_fib()</strong> function:</p>
			<p class="source-code">constexpr void do_fib() {</p>
			<p class="source-code">    const fib_t old_b = b_;</p>
			<p class="source-code">    b_ += a_;</p>
			<p class="source-code">    a_  = old_b;</p>
			<p class="source-code">}</p>
			<p>This<a id="_idIndexMarker374"/> simply adds <strong class="source-inline">b_ += a_</strong>, stores the result in <strong class="source-inline">b_</strong> and the old <strong class="source-inline">b_</strong> in <strong class="source-inline">a_</strong>, setting it up for the next iteration.</p>
			<p>The dereference operator <strong class="source-inline">*</strong> returns the value from <strong class="source-inline">b_</strong>, which is the next value in the sequence:</p>
			<p class="source-code">fib_t operator*() const { return b_; }</p>
			<p>The <strong class="source-inline">end()</strong> function creates an object where the <strong class="source-inline">count_</strong> variable is equal to the <strong class="source-inline">stop_</strong> variable, creating a <em class="italic">sentinel</em>:</p>
			<p class="source-code">const fib_generator end() const { </p>
			<p class="source-code">    auto <strong class="bold">sentinel</strong> = fib_generator();</p>
			<p class="source-code">    <strong class="bold">sentinel.count_ = stop_</strong>;</p>
			<p class="source-code">    return <strong class="bold">sentinel</strong>;</p>
			<p class="source-code">}</p>
			<p>Now the equality comparison operator can easily detect the end of the sequence:</p>
			<p class="source-code">bool operator==(const fib_generator&amp;o) const { </p>
			<p class="source-code">    return count_ == o.count_; </p>
			<p class="source-code">}</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor141"/>There's more…</h2>
			<p>If we <a id="_idIndexMarker375"/>want to make our generator work with the <strong class="source-inline">algorithm</strong> library, we need to <a id="_idIndexMarker376"/>provide the <strong class="source-inline">traits</strong> aliases. These go at the top of the <strong class="source-inline">public</strong> section:</p>
			<p class="source-code">public:</p>
			<p class="source-code">    using iterator_concept  = std::forward_iterator_tag;</p>
			<p class="source-code">    using iterator_category = std::forward_iterator_tag;</p>
			<p class="source-code">    using value_type        = std::remove_cv_t&lt;fib_t&gt;;</p>
			<p class="source-code">    using difference_type   = std::ptrdiff_t;</p>
			<p class="source-code">    using pointer           = const fib_t*;</p>
			<p class="source-code">    using reference         = const fib_t&amp;;</p>
			<p>Now we can use our generator with algorithms:</p>
			<p class="source-code">fib_generator fib(10);</p>
			<p class="source-code">auto x = ranges::views::transform(fib, </p>
			<p class="source-code">    [](unsigned long x){ return x * x; });</p>
			<p class="source-code">printc(x, "squared:");</p>
			<p>This uses the <strong class="source-inline">ranges::views</strong> version of the <strong class="source-inline">transform()</strong> algorithm to square every value. The resulting object can be used wherever you can use an iterator. We get this output from the <strong class="source-inline">printc()</strong> call:</p>
			<p class="source-code">squared:: 1 1 4 9 25 64 169 441 1156 3025</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor142"/>Use reverse iterator adapters to iterate backward</h1>
			<p>A <em class="italic">reverse iterator adapter</em> is an<a id="_idIndexMarker377"/> abstraction that reverses the<a id="_idIndexMarker378"/> direction of an iterator class. It <a id="_idIndexMarker379"/>requires <a id="_idIndexMarker380"/>a bidirectional iterator.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor143"/>How to do it…</h2>
			<p>Most bidirectional containers in the STL include a reverse iterator adapter. Other containers, such<a id="_idIndexMarker381"/> as the primitive C-array, do not. Let's look at some examples:</p>
			<ul>
				<li>Let's start with the <strong class="source-inline">printc()</strong> function we've used throughout this chapter:<p class="source-code">void printc(const auto &amp; c, const string_view s = "") {</p><p class="source-code">    if(s.size()) cout &lt;&lt; format("{}: ", s);</p><p class="source-code">    for(auto e : c) cout &lt;&lt; format("{} ", e);</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>This uses a range-based <strong class="source-inline">for</strong> loop to print the elements of a container.</p>
			<ul>
				<li>The<a id="_idIndexMarker382"/> range-based <strong class="source-inline">for</strong> loop works even with primitive C-arrays, which have no iterator class. So, our <strong class="source-inline">printc()</strong> function already works with a C-array:<p class="source-code">int main() {</p><p class="source-code">    int array[]{ 1, 2, 3, 4, 5 };</p><p class="source-code">    printc(array, "c-array");</p><p class="source-code">}</p></li>
			</ul>
			<p>We get this output:</p>
			<p class="source-code"><strong class="bold">c-array: 1 2 3 4 5</strong></p>
			<ul>
				<li>We can use the <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> iterator adapters to create normal forward iterators for the C-array:<p class="source-code">auto it = std::begin(array);</p><p class="source-code">auto end_it = std::end(array);</p><p class="source-code">while (it != end_it) {</p><p class="source-code">    cout &lt;&lt; format("{} ", *it++);</p><p class="source-code">}</p></li>
			</ul>
			<p>Output from the <strong class="source-inline">for</strong> loop:</p>
			<p class="source-code"><strong class="bold">1 2 3 4 5</strong></p>
			<ul>
				<li>Or we can use the <strong class="source-inline">rbegin()</strong> and <strong class="source-inline">rend()</strong> reverse iterator adapters to create reverse iterators for the C-array:<p class="source-code">auto it = std::rbegin(array);</p><p class="source-code">auto end_it = std::rend(array);</p><p class="source-code">while (it != end_it) {</p><p class="source-code">    cout &lt;&lt; format("{} ", *it++);</p><p class="source-code">}</p></li>
			</ul>
			<p>Now our output is reversed:</p>
			<p class="source-code"><strong class="bold">5 4 3 2 1</strong></p>
			<ul>
				<li>We <a id="_idIndexMarker383"/>can even create a<a id="_idIndexMarker384"/> modified version of <strong class="source-inline">printc()</strong> that prints in reverse:<p class="source-code">void printr(const auto &amp; c, const string_view s = "") {</p><p class="source-code">    if(s.size()) cout &lt;&lt; format("{}: ", s);</p><p class="source-code">    auto rbegin = std::rbegin(c);</p><p class="source-code">    auto rend = std::rend(c);</p><p class="source-code">    for(auto it = rbegin; it != rend; ++it) {</p><p class="source-code">        cout &lt;&lt; format("{} ", *it);</p><p class="source-code">    }</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>When we call it with the C-array:</p>
			<p class="source-code">printr(array, "rev c-array");</p>
			<p>We get this output:</p>
			<p class="source-code"><strong class="bold">rev c-array: 5 4 3 2 1</strong></p>
			<ul>
				<li>Of course, this <a id="_idIndexMarker385"/>works just as well with any bidirectional STL container:<p class="source-code">vector&lt;int&gt; v{ 1, 2, 3, 4, 5 };</p><p class="source-code">printc(v, "vector");</p><p class="source-code">printr(v, "rev vector");</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">vector: 1 2 3 4 5</strong></p>
			<p class="source-code"><strong class="bold">rev vector: 5 4 3 2 1</strong></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor144"/>How it works…</h2>
			<p>A normal iterator<a id="_idIndexMarker386"/> class has a <strong class="source-inline">begin()</strong> iterator that points to the first element, and an <strong class="source-inline">end()</strong> iterator that points <em class="italic">past</em> the last element:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B18267_04_03.jpg" alt="Figure 4.3 – Forward iterator&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Forward iterator</p>
			<p>You iterate the container by incrementing the <strong class="source-inline">begin()</strong> iterator with the <strong class="source-inline">++</strong> operator, until it reaches the value of the <strong class="source-inline">end()</strong> iterator.</p>
			<p>A reverse iterator adapter <em class="italic">intercepts the iterator interface</em> and turns it around so the <strong class="source-inline">begin()</strong> iterator points at to the last element, and <strong class="source-inline">end()</strong> iterator points <em class="italic">before</em> the first element. The <strong class="source-inline">++</strong> and <strong class="source-inline">--</strong> operators are also inverted:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B18267_04_04.jpg" alt="Figure 4.4 – Reverse iterator adapter&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – Reverse iterator adapter</p>
			<p>In the reversed iterator, the <strong class="source-inline">++</strong> operator decrements and the <strong class="source-inline">--</strong> operator increments.</p>
			<p>It's worth<a id="_idIndexMarker387"/> noting that most bidirectional STL <a id="_idIndexMarker388"/>containers already include a reverse iterator adapter, accessible by member functions <strong class="source-inline">rbegin()</strong> and <strong class="source-inline">rend()</strong>:</p>
			<p class="source-code">vector&lt;int&gt; v;</p>
			<p class="source-code">it = v.<strong class="bold">rbegin()</strong>;</p>
			<p class="source-code">it_end = v.<strong class="bold">rend()</strong>;</p>
			<p>These iterators will operate in reverse and are suitable for many purposes.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor145"/>Iterate objects of unknown length with a sentinel</h1>
			<p>Some <a id="_idIndexMarker389"/>objects don't have a specific length. To know their length, you need to iterate through all their elements. For example, elsewhere in this chapter we've seen a <em class="italic">generator</em> that doesn't have a specific length. A <a id="_idIndexMarker390"/>more common example would be a <em class="italic">C-string</em>.</p>
			<p>A C-string <a id="_idIndexMarker391"/>is a primitive C-array of characters, terminated with a null <strong class="source-inline">'\0'</strong> value.</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B18267_04_05.jpg" alt="Figure 4.5 – A C-string with its null terminator&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – A C-string with its null terminator</p>
			<p>We use C-strings <a id="_idIndexMarker392"/>all the time, even if we don't realize it. Any <em class="italic">literal</em> string in C/C++ is a C-string:</p>
			<p class="source-code">std::string s = <strong class="bold">"string"</strong>;</p>
			<p>Here, the STL string <strong class="source-inline">s</strong> is initialized with a literal string. The literal string is a C-string. If we look at the individual characters in hexadecimal, we'll see the null terminator:</p>
			<p class="source-code">for (char c : "string") {</p>
			<p class="source-code">    std::cout &lt;&lt; format("{:02x} ", c);</p>
			<p class="source-code">}</p>
			<p>The word "string" has six letters. The output from our loop shows seven elements in the array:</p>
			<p class="source-code">73 74 72 69 6e 67 00</p>
			<p>The<a id="_idIndexMarker393"/> seventh element is the null terminator.</p>
			<p>The <a id="_idIndexMarker394"/>loop sees the primitive C-array of characters, with seven values. The fact that it's a string is an abstraction invisible to the loop. If we want the loop to treat it like a string, we'll need an <em class="italic">iterator</em> and a <em class="italic">sentinel</em>.</p>
			<p>A <em class="italic">sentinel</em> is <a id="_idIndexMarker395"/>an object that signals the end of an iterator of indeterminate length. When the iterator hits the end of the data, the sentinel will compare equal with the iterator.</p>
			<p>To see how this works, let's build an iterator for C-strings!</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor146"/>How to do it…</h2>
			<p>To use a sentinel with a C-string, we need to build a custom iterator. It doesn't need to be complicated, just the essentials for use with a range-based <strong class="source-inline">for</strong> loop.</p>
			<ul>
				<li>We'll start with a couple of convenience definitions:<p class="source-code">using sentinel_t = const char;</p><p class="source-code">constexpr sentinel_t nullchar = '\0';</p></li>
			</ul>
			<p>The <strong class="source-inline">using</strong> alias for <strong class="source-inline">sentinel_t</strong> is <strong class="source-inline">const char</strong>. We'll use this for the sentinel in our class.</p>
			<p>We also define the constant <strong class="source-inline">nullchar</strong> for the null character terminator.</p>
			<ul>
				<li>Now <a id="_idIndexMarker396"/>we can define<a id="_idIndexMarker397"/> our iterator type:<p class="source-code">class cstr_it {</p><p class="source-code">    const char *s{};</p><p class="source-code">public:</p><p class="source-code">    explicit cstr_it(const char *str) : s{str} {}</p><p class="source-code">    char operator*() const { return *s; }</p><p class="source-code">    cstr_it&amp; operator++() {</p><p class="source-code">        ++s;</p><p class="source-code">        return *this;</p><p class="source-code">    }</p><p class="source-code">    bool operator!=(sentinel_t) const {</p><p class="source-code">        return s != nullptr &amp;&amp; *s != nullchar;</p><p class="source-code">    }</p><p class="source-code">    cstr_it begin() const { return *this; }</p><p class="source-code">    sentinel_t end() const { return nullchar; }</p><p class="source-code">};</p></li>
			</ul>
			<p>This is short and simple. It's the minimum necessary for a range-based <strong class="source-inline">for</strong> loop. Notice the <strong class="source-inline">end()</strong> function returns a <strong class="source-inline">nullchar</strong> and the <strong class="source-inline">operator!=()</strong> overload compares against the <strong class="source-inline">nullchar</strong>. That's all we need for the sentinel.</p>
			<ul>
				<li>Now we can define a function for printing our C-string using the sentinel:<p class="source-code">void print_cstr(const char * s) {</p><p class="source-code">    cout &lt;&lt; format("{}: ", s);</p><p class="source-code">    for (char c : <strong class="bold">cstr_it(s)</strong>) {</p><p class="source-code">        std::cout &lt;&lt; format("<strong class="bold">{:02x}</strong> ", c);</p><p class="source-code">    }</p><p class="source-code">    std::cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>In this <a id="_idIndexMarker398"/>function we first print the string. Then we use the <strong class="source-inline">format()</strong> function to print each individual character as a hexadecimal value.</p>
			<ul>
				<li>Now <a id="_idIndexMarker399"/>we can call <strong class="source-inline">print_cstr()</strong> from our <strong class="source-inline">main()</strong> function:<p class="source-code">int main() {</p><p class="source-code">    const char carray[]{"array"};</p><p class="source-code">    print_cstr(carray);</p><p class="source-code">    const char * cstr{"c-string"};</p><p class="source-code">    print_cstr(cstr);</p><p class="source-code">}</p></li>
			</ul>
			<p>The output looks like this:</p>
			<p class="source-code"><strong class="bold">array: 61 72 72 61 79</strong></p>
			<p class="source-code"><strong class="bold">c-string: 63 2d 73 74 72 69 6e 67</strong></p>
			<p>Notice that there are no extraneous characters and no null terminators. This is because our sentinel tells the for loop to stop when it sees the <strong class="source-inline">nullchar</strong>.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor147"/>How it works…</h2>
			<p>The<a id="_idIndexMarker400"/> sentinel part of the iterator <a id="_idIndexMarker401"/>class is very simple. We can easily use the null terminator as the sentinel value by returning it in the <strong class="source-inline">end()</strong> function:</p>
			<p class="source-code">sentinel_t end() const { return nullchar; }</p>
			<p>Then the not-equal comparison operator can test for it:</p>
			<p class="source-code">bool operator!=(<strong class="bold">sentinel_t</strong>) const {</p>
			<p class="source-code">    return s != nullptr &amp;&amp; <strong class="bold">*s != nullchar</strong>;</p>
			<p class="source-code">}</p>
			<p>Notice that the parameter is just a type (<strong class="source-inline">sentinel_t</strong>). A parameter type is necessary for the function signature, but we don't need the value. All that's necessary is to compare the current iterator with the sentinel.</p>
			<p>This technique should be useful whenever you have a type or class that doesn't have a predetermined end point for comparison.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor148"/>Build a zip iterator adapter</h1>
			<p>Many <a id="_idIndexMarker402"/>scripting languages include a function for <em class="italic">zipping</em> two sequences together. A typical zip operation will take two input sequences and return a pair of values for each position in both inputs:</p>
			<p>Consider the case of two sequences – they can be containers, iterators, or initialization lists:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B18267_04_06.jpg" alt="Figure 4.6 – Containers to be zipped&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Containers to be zipped</p>
			<p>We want to <em class="italic">zip</em> them together to make a new sequence with pairs of elements from the first two sequences:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B18267_04_07.jpg" alt="Figure 4.7 – Zip operation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – Zip operation</p>
			<p>In this recipe we will accomplish this task with an iterator adapter.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor149"/>How to do it…</h2>
			<p>In this<a id="_idIndexMarker403"/> recipe we'll build a zip iterator adapter that takes two containers of the same type and zips the values into <strong class="source-inline">std::pair</strong> objects:</p>
			<ul>
				<li>In our <strong class="source-inline">main()</strong> function we want to call our adapter with two vectors:<p class="source-code">int main()</p><p class="source-code">{</p><p class="source-code">    vector&lt;std::string&gt; vec_a {"Bob", "John", "Joni"};</p><p class="source-code">    vector&lt;std::string&gt; vec_b {"Dylan", "Williams", </p><p class="source-code">        "Mitchell"};</p><p class="source-code">    cout &lt;&lt; "zipped: ";</p><p class="source-code">    for(auto [a, b] : zip_iterator(vec_a, vec_b)) {</p><p class="source-code">        cout &lt;&lt; format("[{}, {}] ", a, b);</p><p class="source-code">    }</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>This allows us to use the <strong class="source-inline">zip_iterator</strong> in place of the individual <strong class="source-inline">vector</strong> iterators.</p>
			<p>And we expect an output like this:</p>
			<p class="source-code"><strong class="bold">zipped: [Bob, Dylan] [John, Williams] [Joni, Mitchell]</strong></p>
			<ul>
				<li>Our<a id="_idIndexMarker404"/> iterator adapter is in a class called <strong class="source-inline">zip_iterator</strong>. We'll start with some type aliases for convenience:<p class="source-code">template&lt;typename T&gt;</p><p class="source-code">class zip_iterator {</p><p class="source-code">    using val_t = typename T::value_type;</p><p class="source-code">    using ret_t = std::pair&lt;val_t, val_t&gt;;</p><p class="source-code">    using it_t = typename T::iterator;</p></li>
			</ul>
			<p>These allow us to conveniently define objects and functions.</p>
			<ul>
				<li>We don't store any data in our iterator. We only store copies of the target containers' <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> iterators:<p class="source-code">it_t ita_{};</p><p class="source-code">it_t itb_{};</p><p class="source-code">// for begin() and end() objects</p><p class="source-code">it_t ita_begin_{};</p><p class="source-code">it_t itb_begin_{};</p><p class="source-code">it_t ita_end_{};</p><p class="source-code">it_t itb_end_{};</p></li>
			</ul>
			<p><strong class="source-inline">ita_</strong> and <strong class="source-inline">itb_</strong> are iterators from the target containers. The other four iterators are used to generate the <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> iterators for the <strong class="source-inline">zip_iterator</strong> adapter.</p>
			<ul>
				<li>We <a id="_idIndexMarker405"/>also have a private constructor:<p class="source-code">// private constructor for begin() and end() objects</p><p class="source-code">zip_iterator(it_t ita, it_t itb) : ita_{ita}, itb_{itb} {}</p></li>
			</ul>
			<p>This is used later to construct adapter objects specifically for <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> iterators.</p>
			<ul>
				<li>In the <strong class="source-inline">public</strong> section, we start with the iterator <em class="italic">traits</em> type definitions:<p class="source-code">public:</p><p class="source-code">    using iterator_concept  = </p><p class="source-code">      std::forward_iterator_tag;</p><p class="source-code">    using iterator_category = </p><p class="source-code">      std::forward_iterator_tag;</p><p class="source-code">    using value_type        = std::pair&lt;val_t, val_t&gt;;</p><p class="source-code">    using difference_type   = long int;</p><p class="source-code">    using pointer           = const val_t*;</p><p class="source-code">    using reference         = const val_t&amp;;</p></li>
				<li>The constructor sets up all the private iterator variables:<p class="source-code">zip_iterator(T&amp; a, T&amp; b) : </p><p class="source-code">    ita_{a.begin()},</p><p class="source-code">    itb_{b.begin()},</p><p class="source-code">    ita_begin_{ita_},</p><p class="source-code">    itb_begin_{itb_},</p><p class="source-code">    ita_end_{a.end()},</p><p class="source-code">    itb_end_{b.end()}</p><p class="source-code">{}</p></li>
				<li>We define<a id="_idIndexMarker406"/> the minimum operator overloads to work with a forward iterator:<p class="source-code">zip_iterator&amp; operator++() {</p><p class="source-code">    ++ita_;</p><p class="source-code">    ++itb_;</p><p class="source-code">    return *this;</p><p class="source-code">}</p><p class="source-code">bool operator==(const zip_iterator&amp; o) const {</p><p class="source-code">    return ita_ == o.ita_ || itb_ == o.itb_;</p><p class="source-code">}</p><p class="source-code">bool operator!=(const zip_iterator&amp; o) const {</p><p class="source-code">    return !operator==(o);</p><p class="source-code">}</p><p class="source-code">ret_t operator*() const {</p><p class="source-code">    return { *ita_, *itb_ };</p><p class="source-code">}</p></li>
				<li>And finally, the <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> functions return the respective iterators:<p class="source-code">zip_iterator begin() const</p><p class="source-code">    { return zip_iterator(ita_begin_, itb_begin_); }</p><p class="source-code">zip_iterator end() const</p><p class="source-code">    { return zip_iterator(ita_end_, itb_end_); }</p></li>
			</ul>
			<p>These are made simple by the stored iterators and the private constructor.</p>
			<ul>
				<li>Now let's expand our <strong class="source-inline">main()</strong> function for testing:<p class="source-code">int main()</p><p class="source-code">{</p><p class="source-code">    vector&lt;std::string&gt; vec_a {"Bob", "John", "Joni"};</p><p class="source-code">    vector&lt;std::string&gt; vec_b {"Dylan", "Williams", </p><p class="source-code">        "Mitchell"};</p><p class="source-code">    cout &lt;&lt; "vec_a: ";</p><p class="source-code">    for(auto e : vec_a) cout &lt;&lt; format("{} ", e);</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">    cout &lt;&lt; "vec_b: ";</p><p class="source-code">    for(auto e : vec_b) cout &lt;&lt; format("{} ", e);</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">    cout &lt;&lt; "zipped: ";</p><p class="source-code">    for(auto [a, b] : zip_iterator(vec_a, vec_b)) {</p><p class="source-code">        cout &lt;&lt; format("[{}, {}] ", a, b);</p><p class="source-code">    }</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
				<li>This gives<a id="_idIndexMarker407"/> us the output we're looking for:<p class="source-code"><strong class="bold">vec_a: Bob John Joni</strong></p><p class="source-code"><strong class="bold">vec_b: Dylan Williams Mitchell</strong></p><p class="source-code"><strong class="bold">zipped: [Bob, Dylan] [John, Williams] [Joni, Mitchell]</strong></p></li>
			</ul>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor150"/>How it works…</h2>
			<p>The <em class="italic">zipped iterator adapter</em> is an <a id="_idIndexMarker408"/>example of how flexible the iterator abstraction can be. We can take the iterators of two containers and use them in one aggregated iterator. Let's see how this works.</p>
			<p>The main constructor for the <strong class="source-inline">zip_iterator</strong> class takes two container objects. For the purposes of this discussion, we'll refer to these objects as the <em class="italic">target</em> objects.</p>
			<p class="source-code">zip_iterator(T&amp; a, T&amp; b) : </p>
			<p class="source-code">    ita_{a.begin()},</p>
			<p class="source-code">    itb_{b.begin()},</p>
			<p class="source-code">    ita_begin_{ita_},</p>
			<p class="source-code">    itb_begin_{itb_},</p>
			<p class="source-code">    ita_end_{a.end()},</p>
			<p class="source-code">    itb_end_{b.end()}</p>
			<p class="source-code">{}</p>
			<p>The constructor initializes the <strong class="source-inline">ita_</strong> and <strong class="source-inline">itb_</strong> variables from the target <strong class="source-inline">begin()</strong> iterators. These will be used to navigate the target objects. The target <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> iterators are also saved for later use.</p>
			<p>These variables are defined in the private section:</p>
			<p class="source-code">it_t ita_{};</p>
			<p class="source-code">it_t itb_{};</p>
			<p class="source-code">// for begin() and end() objects</p>
			<p class="source-code">it_t ita_begin_{};</p>
			<p class="source-code">it_t itb_begin_{};</p>
			<p class="source-code">it_t ita_end_{};</p>
			<p class="source-code">it_t itb_end_{};</p>
			<p>The <strong class="source-inline">it_t</strong> type is defined as the type of the target iterator class:</p>
			<p class="source-code">using <strong class="bold">val_t</strong> = typename T::value_type;</p>
			<p class="source-code">using <strong class="bold">ret_t</strong> = std::pair&lt;val_t, val_t&gt;;</p>
			<p class="source-code">using <strong class="bold">it_t</strong> = typename T::iterator;</p>
			<p>The other<a id="_idIndexMarker409"/> aliased types are <strong class="source-inline">val_t</strong> for the type of the target value, and <strong class="source-inline">ret_t</strong> for the return <strong class="source-inline">pair</strong>. These type definitions are used for convenience throughout the class.</p>
			<p>The <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> functions use a private constructor that only initializes the <strong class="source-inline">ita_</strong> and <strong class="source-inline">itb_</strong> values:</p>
			<p class="source-code">zip_iterator begin() const</p>
			<p class="source-code">  { return zip_iterator(<strong class="bold">ita_begin_</strong>, <strong class="bold">itb_begin_</strong>); }</p>
			<p class="source-code">zip_iterator end() const</p>
			<p class="source-code">  { return zip_iterator(<strong class="bold">ita_end_</strong>, <strong class="bold">itb_end_</strong>); }</p>
			<p>The <strong class="source-inline">private</strong> constructor looks like this:</p>
			<p class="source-code">// private constructor for begin() and end() objects</p>
			<p class="source-code">zip_iterator(<strong class="bold">it_t</strong> ita, <strong class="bold">it_t</strong> itb) : <strong class="bold">ita_</strong>{ita}, <strong class="bold">itb_</strong>{itb} {}</p>
			<p>This is a constructor that takes <strong class="source-inline">it_t</strong> iterators for parameters. It only initializes <strong class="source-inline">ita_</strong>and <strong class="source-inline">itb_</strong> so they can be used in the comparison operator overloads.</p>
			<p>The rest of the class just acts like a normal iterator, but it's operating on iterators from the target class:</p>
			<p class="source-code">zip_iterator&amp; operator++() {</p>
			<p class="source-code">    ++ita_;</p>
			<p class="source-code">    ++itb_;</p>
			<p class="source-code">    return *this;</p>
			<p class="source-code">}</p>
			<p class="source-code">bool operator==(const zip_iterator&amp; o) const {</p>
			<p class="source-code">    return ita_ == o.ita_ || itb_ == o.itb_;</p>
			<p class="source-code">}</p>
			<p class="source-code">bool operator!=(const zip_iterator&amp; o) const {</p>
			<p class="source-code">    return !operator==(o);</p>
			<p class="source-code">}</p>
			<p>The dereference <a id="_idIndexMarker410"/>operator returns a <strong class="source-inline">std::pair</strong> object (<strong class="source-inline">ret_t</strong> is an alias for <strong class="source-inline">std::pair&lt;val_t, val_t&gt;</strong>). This is the interface for retrieving a value from the iterator.</p>
			<p class="source-code">ret_t operator*() const {</p>
			<p class="source-code">    return { *ita_, *itb_ };</p>
			<p class="source-code">}</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor151"/>There's more…</h2>
			<p>The <strong class="source-inline">zip_iterator</strong> adapter can<a id="_idIndexMarker411"/> be used to easily zip objects into a <strong class="source-inline">map</strong>:</p>
			<p class="source-code">map&lt;string, string&gt; name_map{};</p>
			<p class="source-code">for(auto [a, b] : zip_iterator(vec_a, vec_b)) {</p>
			<p class="source-code">    name_map.try_emplace(a, b);</p>
			<p class="source-code">}</p>
			<p class="source-code">cout &lt;&lt; "name_map: ";</p>
			<p class="source-code">for(auto [a, b] : name_map) {</p>
			<p class="source-code">    cout &lt;&lt; format("[{}, {}] ", a, b);</p>
			<p class="source-code">}</p>
			<p class="source-code">cout &lt;&lt; '\n';</p>
			<p>If we add this code to <strong class="source-inline">main()</strong>, we get this output:</p>
			<p class="source-code">name_map: [Bob, Dylan] [John, Williams] [Joni, Mitchell]</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor152"/>Create a random-access iterator</h1>
			<p>This recipe is an <a id="_idIndexMarker412"/>example of a full-featured contiguous/random-access iterator. This is the most complete type of iterator for a container. A random-access iterator includes all the features of all the other types of container iterators, along with its random-access capabilities.</p>
			<p>While I felt it important to include a complete iterator in this chapter, with over 700 lines of code this example is somewhat larger than the other examples in this book. I'll cover the essential components of the code here. Please see the full source at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap04/container-iterator.cpp">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/blob/main/chap04/container-iterator.cpp</a>.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/>How to do it…</h2>
			<p>We need a container for our iterator. We'll use a simple array for this, and we'll call it <strong class="source-inline">Container</strong>. The <strong class="source-inline">iterator</strong> class is nested within the <strong class="source-inline">Container</strong> class.</p>
			<p>All of this is designed to be consistent with the STL container interfaces.</p>
			<ul>
				<li><strong class="source-inline">Container</strong> is defined as a <strong class="source-inline">template</strong> class. Its <strong class="source-inline">private</strong> section has only two elements:<p class="source-code">template&lt;typename T&gt;</p><p class="source-code">class Container {</p><p class="source-code">    std::<strong class="bold">unique_ptr</strong>&lt;T[]&gt; <strong class="bold">c_</strong>{};</p><p class="source-code">    size_t <strong class="bold">n_elements_</strong>{};</p></li>
			</ul>
			<p>We use a <strong class="source-inline">unique_pointer</strong> for the data. We let the <em class="italic">smart pointer</em> manage its own memory. This mitigates the need for a <strong class="source-inline">~Container()</strong> destructor. The <strong class="source-inline">n_elements_</strong> variable keeps the size of our container.</p>
			<ul>
				<li>In the public section, we have our constructors:<p class="source-code">Container(<strong class="bold">initializer_list</strong>&lt;T&gt; l) : n_elements_{l.size()} {</p><p class="source-code">    c_ = std::<strong class="bold">make_unique</strong>&lt;T[]&gt;(n_elements_);</p><p class="source-code">    size_t index{0};</p><p class="source-code">    for(T e : l) {</p><p class="source-code">        c_[index++] = e;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>The first constructor uses an <strong class="source-inline">initializer_list</strong> to pass elements for the container. We call <strong class="source-inline">make_unique</strong> to allocate space and populate the container with a range-based <strong class="source-inline">for</strong> loop.</p>
			<ul>
				<li>We<a id="_idIndexMarker413"/> also have a constructor that allocates space without populating the elements:<p class="source-code">Container(size_t sz) : n_elements_{sz} {</p><p class="source-code">    c_ = std::<strong class="bold">make_unique</strong>&lt;T[]&gt;(n_elements_);</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">make_unique()</strong> function constructs empty objects for element.</p>
			<ul>
				<li>The <strong class="source-inline">size()</strong> function returns the number of elements:<p class="source-code">size_t size() const {</p><p class="source-code">    return n_elements_;</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">operator[]()</strong> function returns an indexed element:<p class="source-code">const T&amp; operator[](const size_t index) const {</p><p class="source-code">    return c_[index];</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">at()</strong> function returns an indexed element <em class="italic">with bounds checking</em>:<p class="source-code">T&amp; at(const size_t index) const {</p><p class="source-code">    <strong class="bold">if(index &gt; n_elements_ - 1)</strong> {</p><p class="source-code">        <strong class="bold">throw std::out_of_range</strong>(</p><p class="source-code">            "Container::at(): index out of range"</p><p class="source-code">        );</p><p class="source-code">    }</p><p class="source-code">    return c_[index];</p><p class="source-code">}</p></li>
			</ul>
			<p>This is consistent with STL usage. The <strong class="source-inline">at()</strong> function is the preferred method.</p>
			<ul>
				<li>The <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> functions call the iterator constructor with the address <a id="_idIndexMarker414"/>of the container data.<p class="source-code">iterator begin() const { return iterator(<strong class="bold">c_.get()</strong>); }</p><p class="source-code">iterator end() const { </p><p class="source-code">    return iterator(<strong class="bold">c_.get()</strong> + n_elements_); </p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">unique_ptr::get()</strong> function returns the address from the smart pointer.</p>
			<ul>
				<li>The <strong class="source-inline">iterator</strong> class is nested within the <strong class="source-inline">Container</strong> class as a <strong class="source-inline">public</strong> member.<p class="source-code">class iterator {</p><p class="source-code">    T* ptr_;</p></li>
			</ul>
			<p>The iterator class has one private member, a pointer that's initialized in the <strong class="source-inline">begin()</strong> and <strong class="source-inline">end()</strong> methods of the Container class.</p>
			<ul>
				<li>The iterator constructor takes a pointer to the container data.<p class="source-code">iterator(T* ptr = nullptr) : ptr_{ptr} {}</p></li>
			</ul>
			<p>We provide a default value because the standard requires a default constructor.</p>
			<h3>Operator overloads</h3>
			<p>This iterator <a id="_idIndexMarker415"/>provides operator overloads for the following operators: <strong class="source-inline">++</strong>, <em class="italic">postfix</em> <strong class="source-inline">++</strong>, <strong class="source-inline">--</strong>, <em class="italic">postfix</em> <strong class="source-inline">--</strong>, <strong class="source-inline">[]</strong>, <em class="italic">default comparison</em> <strong class="source-inline">&lt;=&gt;</strong> <em class="italic">(C++20)</em>, <strong class="source-inline">==</strong>, <strong class="source-inline">*</strong>, <strong class="source-inline">-&gt;</strong>, <strong class="source-inline">+</strong>, <em class="italic">non-member</em> <strong class="source-inline">+</strong>, <em class="italic">numeric</em> <strong class="source-inline">-</strong>, <em class="italic">object</em> <strong class="source-inline">-</strong>, <strong class="source-inline">+=</strong>, and <strong class="source-inline">-=</strong>. We'll cover a few notable overloads here. See the source code for all of them.</p>
			<ul>
				<li>The C++20 default comparison operator <strong class="source-inline">&lt;=&gt;</strong> provides the functionality of the full suite of comparison operators, except the equality <strong class="source-inline">==</strong> operator:<p class="source-code">const auto operator&lt;=&gt;(const iterator&amp; o) const {</p><p class="source-code">    return ptr_ &lt;=&gt; o.ptr_;</p><p class="source-code">}</p></li>
			</ul>
			<p>This is a C++20 feature, so it requires a compliant compiler and library.</p>
			<ul>
				<li>There are two <strong class="source-inline">+</strong> operator overloads. These support <em class="italic">it + n</em> and <em class="italic">n + it</em> operations.<p class="source-code">iterator <strong class="bold">operator+</strong>(<strong class="bold">const size_t n</strong>) const {</p><p class="source-code">    return iterator(ptr_ + n);</p><p class="source-code">}</p><p class="source-code">// non-member operator (n + it)</p><p class="source-code"><strong class="bold">friend</strong> const iterator <strong class="bold">operator+</strong>(</p><p class="source-code">        <strong class="bold">const size_t n</strong>, <strong class="bold">const iterator&amp; o</strong>) {</p><p class="source-code">    return iterator(o.ptr_ + n);</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">friend</strong> declaration is a special case. When used in a template class member function, it's the equivalent of a non-member function. This allows a non-member function to be defined in the class context.</p>
			<ul>
				<li>The <strong class="source-inline">-</strong> operator also has two overloads. We need to support both a numeric operand and an iterator operand.<p class="source-code">const iterator operator-(const size_t n) {</p><p class="source-code">    return iterator(ptr_ - n);</p><p class="source-code">}</p><p class="source-code">const size_t operator-(const iterator&amp; o) {</p><p class="source-code">    return ptr_ - o.ptr_;</p><p class="source-code">}</p></li>
			</ul>
			<p>This <a id="_idIndexMarker416"/>allows both <em class="italic">it – n</em> and <em class="italic">it – it</em> operations. There's no need for a non-member function, as <em class="italic">n – it</em> is not a valid operation.</p>
			<h3>Validation code</h3>
			<p>The C++20 specification §23.3.4.13 requires a <a id="_idIndexMarker417"/>specific set of operations and results for a valid random-access iterator. I've included a <strong class="source-inline">unit_tests()</strong> function in the source code to validate those requirements.</p>
			<p>The <strong class="source-inline">main()</strong> function creates a <strong class="source-inline">Container</strong> object and performs some simple validation functions.</p>
			<ul>
				<li>First, we create a <strong class="source-inline">Container&lt;string&gt;</strong> object <strong class="source-inline">x</strong> with ten values.<p class="source-code">Container&lt;string&gt; x{"one", "two", "three", "four", "five", </p><p class="source-code">    "six", "seven", "eight", "nine", "ten" };</p><p class="source-code">cout &lt;&lt; format("Container x size: {}\n", x.size());</p></li>
			</ul>
			<p>The output gives the number of elements:</p>
			<p class="source-code"><strong class="bold">Container x size: 10</strong></p>
			<ul>
				<li>We display the elements of the container with a range-based <strong class="source-inline">for</strong> loop:<p class="source-code">puts("Container x:");</p><p class="source-code">for(auto e : x) {</p><p class="source-code">    cout &lt;&lt; format("{} ", e);</p><p class="source-code">}</p><p class="source-code">cout &lt;&lt; '\n';</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">Container x:</strong></p>
			<p class="source-code"><strong class="bold">one two three four five six seven eight nine ten</strong></p>
			<ul>
				<li>Next, we<a id="_idIndexMarker418"/> test several direct access methods:<p class="source-code">puts("direct access elements:");</p><p class="source-code">cout &lt;&lt; format("element at(5): {}\n", x.at(5));</p><p class="source-code">cout &lt;&lt; format("element [5]: {}\n", x[5]);</p><p class="source-code">cout &lt;&lt; format("element begin + 5: {}\n",</p><p class="source-code">    *(x.begin() + 5));</p><p class="source-code">cout &lt;&lt; format("element 5 + begin: {}\n",</p><p class="source-code">    *(5 + x.begin()));</p><p class="source-code">cout &lt;&lt; format("element begin += 5: {}\n",</p><p class="source-code">    *(x.begin() += 5));</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">direct access elements:</strong></p>
			<p class="source-code"><strong class="bold">element at(5): six</strong></p>
			<p class="source-code"><strong class="bold">element [5]: six</strong></p>
			<p class="source-code"><strong class="bold">element begin + 5: six</strong></p>
			<p class="source-code"><strong class="bold">element 5 + begin: six</strong></p>
			<p class="source-code"><strong class="bold">element begin += 5: six</strong></p>
			<ul>
				<li>We test the container with a <strong class="source-inline">ranges::views</strong> pipe and <strong class="source-inline">views::reverse</strong>:<p class="source-code">puts("views pipe reverse:");</p><p class="source-code">auto result = x | views::reverse;</p><p class="source-code">for(auto v : result) cout &lt;&lt; format("{} ", v);</p><p class="source-code">cout &lt;&lt; '\n';</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">views pipe reverse:</strong></p>
			<p class="source-code"><strong class="bold">ten nine eight seven six five four three two one</strong></p>
			<ul>
				<li>Finally, we <a id="_idIndexMarker419"/>create a <strong class="source-inline">Container</strong> object <strong class="source-inline">y</strong> with 10 uninitialized elements:<p class="source-code">Container&lt;string&gt; y(x.size());</p><p class="source-code">cout &lt;&lt; format("Container y size: {}\n", y.size());</p><p class="source-code">for(auto e : y) {</p><p class="source-code">    cout &lt;&lt; format("[{}] ", e);</p><p class="source-code">}</p><p class="source-code">cout &lt;&lt; '\n';</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">Container y size: 10</strong></p>
			<p class="source-code"><strong class="bold">[] [] [] [] [] [] [] [] [] []</strong></p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/>How it works…</h2>
			<p>Although it's a lot of code, this <a id="_idIndexMarker420"/>iterator is no more complicated than a smaller iterator. Most of the code is in the operator overloads, which are mostly one or two lines of code each.</p>
			<p>The container itself is managed by a <em class="italic">smart pointer</em>. This is simplified by the fact that it's a flat array and doesn't require expansion or compression.</p>
			<p>Of course, the STL provides a flat <strong class="source-inline">std::array</strong> class, as well as other more complex data structures. Still, you may find it valuable to demystify the workings of a complete iterator class.</p>
		</div>
	</body></html>