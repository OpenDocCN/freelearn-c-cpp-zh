["```cpp\nVkShaderModuleCreateInfo shader_module_create_info = { \n  VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO, \n  nullptr, \n  0, \n  source_code.size(), \nreinterpret_cast<uint32_t const *>(source_code.data()) \n};\n\n```", "```cpp\nVkResult result = vkCreateShaderModule( logical_device, &shader_module_create_info, nullptr, &shader_module ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not create a shader module.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nstructShaderStageParameters { \n  VkShaderStageFlagBits        ShaderStage; \n  VkShaderModule               ShaderModule; \n  char const                 * EntryPointName; \n  VkSpecializationInfo const * SpecializationInfo; \n};\n\n```", "```cpp\nstd::vector<ShaderStageParameters>shader_stage_params = { \n  { \n    VK_SHADER_STAGE_VERTEX_BIT, \n    *vertex_shader_module, \n    \"main\", \n     nullptr \n  }, \n  { \n    VK_SHADER_STAGE_FRAGMENT_BIT, \n    *fragment_shader_module, \n    \"main\", \n    nullptr \n  } \n};\n\n```", "```cpp\nshader_stage_create_infos.clear(); \nfor( auto & shader_stage : shader_stage_params ) { \n  shader_stage_create_infos.push_back( { \n    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, \n    nullptr, \n    0, \n    shader_stage.ShaderStage, \n    shader_stage.ShaderModule, \n    shader_stage.EntryPointName, \n    shader_stage.SpecializationInfo \n  } ); \n}\n\n```", "```cpp\nstd::vector<VkVertexInputBindingDescription> binding_descriptions = { \n  { \n    0, \n    8 * sizeof( float ), \n    VK_VERTEX_INPUT_RATE_VERTEX \n  } \n};\n\n```", "```cpp\nstd::vector<VkVertexInputAttributeDescription> attribute_descriptions = { \n  { \n    0, \n    0, \n    VK_FORMAT_R32G32B32_SFLOAT, \n    0 \n  }, \n  { \n    1, \n    0, \n    VK_FORMAT_R32G32_SFLOAT, \n    3 * sizeof( float ) \n  }, \n  { \n    2, \n    0, \n    VK_FORMAT_R32G32B32_SFLOAT, \n    5 * sizeof( float ) \n  } \n};\n\n```", "```cpp\nvertex_input_state_create_info = { \n  VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO, \n  nullptr, \n  0, \n  static_cast<uint32_t>(binding_descriptions.size()), \n  binding_descriptions.data(), \n  static_cast<uint32_t>(attribute_descriptions.size()), \n  attribute_descriptions.data() \n};\n\n```", "```cpp\ninput_assembly_state_create_info = { \n  VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO, \n  nullptr, \n  0, \n  topology, \n  primitive_restart_enable \n};\n\n```", "```cpp\ntessellation_state_create_info = { \n  VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO, \n  nullptr, \n  0, \n  patch_control_points_count \n};\n\n```", "```cpp\nstruct ViewportInfo { \n  std::vector<VkViewport>   Viewports; \n  std::vector<VkRect2D>     Scissors; \n};\n\n```", "```cpp\nViewportInfo viewport_infos = { \n  { \n    { \n      0.0f, \n      0.0f, \n      512.0f, \n      512.0f, \n      0.0f, \n      1.0f \n    }, \n  }, \n  { \n    { \n      { \n        0, \n        0 \n      }, \n      { \n        512, \n        512 \n      } \n    } \n  } \n};\n\n```", "```cpp\nuint32_t viewport_count = static_cast<uint32_t>(viewport_infos.Viewports.size()); \nuint32_t scissor_count = static_cast<uint32_t>(viewport_infos.Scissors.size()); \nviewport_state_create_info = { \n  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO, \n  nullptr, \n  0, \n  viewport_count, \n  viewport_infos.Viewports.data(), \n  scissor_count, \n  viewport_infos.Scissors.data() \n};\n\n```", "```cpp\nVkPipelineRasterizationStateCreateInfo rasterization_state_create_info = { \n  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO, \n  nullptr, \n  0, \n  depth_clamp_enable, \n  rasterizer_discard_enable, \n  polygon_mode, \n  culling_mode, \n  front_face, \n  depth_bias_enable, \n  depth_bias_constant_factor, \n  depth_bias_clamp, \n  depth_bias_slope_factor, \n  line_width \n};\n\n```", "```cpp\nmultisample_state_create_info = { \n  VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO, \n  nullptr, \n  0, \n  sample_count, \n  per_sample_shading_enable, \n  min_sample_shading, \n  sample_masks, \n  alpha_to_coverage_enable, \n  alpha_to_one_enable \n};\n\n```", "```cpp\nVkPipelineDepthStencilStateCreateInfo depth_and_stencil_state_create_info = { \n  VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO, \n  nullptr, \n  0, \n  depth_test_enable, \n  depth_write_enable, \n  depth_compare_op, \n  depth_bounds_test_enable, \n  stencil_test_enable, \n  front_stencil_test_parameters, \n  back_stencil_test_parameters, \n  min_depth_bounds, \n  max_depth_bounds \n};\n\n```", "```cpp\nstd::vector<VkPipelineColorBlendAttachmentState> attachment_blend_states = { \n  { \n    false, \n    VK_BLEND_FACTOR_ONE, \n    VK_BLEND_FACTOR_ONE, \n    VK_BLEND_OP_ADD, \n    VK_BLEND_FACTOR_ONE, \n    VK_BLEND_FACTOR_ONE, \n    VK_BLEND_OP_ADD, \n    VK_COLOR_COMPONENT_R_BIT | \n    VK_COLOR_COMPONENT_G_BIT | \n    VK_COLOR_COMPONENT_B_BIT | \n    VK_COLOR_COMPONENT_A_BIT \n  } \n}; \nVkPipelineColorBlendStateCreateInfo blend_state_create_info; \nSpecifyPipelineBlendState( false, VK_LOGIC_OP_COPY, attachment_blend_states, { 1.0f, 1.0f, 1.0f, 1.0f }, blend_state_create_info );\n\n```", "```cpp\nblend_state_create_info = { \n  VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO, \n  nullptr, \n  0, \n  logic_op_enable, \n  logic_op, \n  static_cast<uint32_t>(attachment_blend_states.size()), \n  attachment_blend_states.data(), \n  { \n    blend_constants[0], \n    blend_constants[1], \n    blend_constants[2], \n    blend_constants[3] \n  } \n};\n\n```", "```cpp\nVkPipelineDynamicStateCreateInfo dynamic_state_creat_info = { \n  VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO, \n  nullptr, \n  0, \n  static_cast<uint32_t>(dynamic_states.size()), \ndynamic_states.data() \n};\n\n```", "```cpp\nVkPipelineLayoutCreateInfo pipeline_layout_create_info = { \n  VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO, \n  nullptr, \n  0, \n  static_cast<uint32_t>(descriptor_set_layouts.size()), \n  descriptor_set_layouts.data(), \n  static_cast<uint32_t>(push_constant_ranges.size()), \n  push_constant_ranges.data() \n}; \n\nVkResult result = vkCreatePipelineLayout( logical_device, &pipeline_layout_create_info, nullptr, &pipeline_layout ); \n\nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not create pipeline layout.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nVkGraphicsPipelineCreateInfo graphics_pipeline_create_info = { \n  VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO, \n  nullptr, \n  additional_options, \n  static_cast<uint32_t>(shader_stage_create_infos.size()), \n  shader_stage_create_infos.data(), \n  &vertex_input_state_create_info, \n  &input_assembly_state_create_info, \n  &tessellation_state_create_info, \n  &viewport_state_create_info, \n  &rasterization_state_create_info, \n  &multisample_state_create_info, \n  &depth_and_stencil_state_create_info, \n  &blend_state_create_info, \n  &dynamic_state_creat_info, \n  pipeline_layout, \n  render_pass, \n  subpass, \n  base_pipeline_handle, \n  base_pipeline_index \n};\n\n```", "```cpp\nVkPipelineCacheCreateInfo pipeline_cache_create_info = { \n  VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO, \n  nullptr, \n  0, \n  static_cast<uint32_t>(cache_data.size()), \n  cache_data.data() \n}; \n\nVkResult result = vkCreatePipelineCache( logical_device, &pipeline_cache_create_info, nullptr, &pipeline_cache ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not create pipeline cache.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nsize_t data_size = 0; \nVkResult result = VK_SUCCESS; \n\nresult = vkGetPipelineCacheData( logical_device, pipeline_cache, &data_size, nullptr ); \nif( (VK_SUCCESS != result) || \n    (0 == data_size) ) { \n  std::cout << \"Could not get the size of the pipeline cache.\" << \n  std::endl; \n  return false; \n} \npipeline_cache_data.resize( data_size );\n\n```", "```cpp\nresult = vkGetPipelineCacheData( logical_device, pipeline_cache, &data_size, pipeline_cache_data.data()); \nif( (VK_SUCCESS != result) || \n    (0 == data_size) ) { \n  std::cout << \"Could not acquire pipeline cache data.\" << std::endl; \n  return false; \n} \n\nreturn true;\n\n```", "```cpp\nVkResult result = vkMergePipelineCaches( logical_device, target_pipeline_cache, static_cast<uint32_t>(source_pipeline_caches.size()), source_pipeline_caches.data() ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not merge pipeline cache objects.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\ngraphics_pipelines.resize( graphics_pipeline_create_infos.size() ); \nVkResult result = vkCreateGraphicsPipelines( logical_device, pipeline_cache, static_cast<uint32_t>(graphics_pipeline_create_infos.size()), graphics_pipeline_create_infos.data(), nullptr, graphics_pipelines.data() ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not create a graphics pipeline.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nVkComputePipelineCreateInfo compute_pipeline_create_info = { \n  VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO, \n  nullptr, \n  additional_options, \n  compute_shader_stage, \n  pipeline_layout, \n  base_pipeline_handle, \n  -1 \n}; \n\nVkResult result = vkCreateComputePipelines( logical_device, pipeline_cache, 1, &compute_pipeline_create_info, nullptr, &compute_pipeline ); \nif( VK_SUCCESS != result ) { \n  std::cout << \"Could not create compute pipeline.\" << std::endl; \n  return false; \n} \nreturn true;\n\n```", "```cpp\nvkCmdBindPipeline( command_buffer, pipeline_type, pipeline );\n\n```", "```cpp\nstd::vector<VkDescriptorSetLayoutBinding> descriptor_set_layout_bindings = { \n  { \n    0, \n    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, \n    1, \n    VK_SHADER_STAGE_FRAGMENT_BIT, \n    nullptr \n  }, \n  { \n    1, \n    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, \n    1, \n    VK_SHADER_STAGE_VERTEX_BIT, \n    nullptr \n  } \n}; \n\nif( !CreateDescriptorSetLayout( logical_device, descriptor_set_layout_bindings, descriptor_set_layout ) ) { \n  return false; \n}\n\n```", "```cpp\nif( !CreatePipelineLayout( logical_device, { descriptor_set_layout }, push_constant_ranges, pipeline_layout ) ) { \n  return false; \n} \nreturn true;\n\n```", "```cpp\nstd::vector<unsigned char> vertex_shader_spirv; \nif( !GetBinaryFileContents( vertex_shader_filename, vertex_shader_spirv ) ) { \n  return false; \n} \n\nVkDestroyer<VkShaderModule> vertex_shader_module( logical_device ); \nif( !CreateShaderModule( logical_device, vertex_shader_spirv, *vertex_shader_module ) ) { \n  return false; \n} \n\nstd::vector<unsigned char> fragment_shader_spirv; \nif( !GetBinaryFileContents( fragment_shader_filename, fragment_shader_spirv ) ) { \n  return false; \n} \nVkDestroyer<VkShaderModule> fragment_shader_module( logical_device ); \nif( !CreateShaderModule( logical_device, fragment_shader_spirv, *fragment_shader_module ) ) { \n  return false; \n} \n\nstd::vector<ShaderStageParameters> shader_stage_params = { \n  { \n    VK_SHADER_STAGE_VERTEX_BIT, \n    *vertex_shader_module, \n    \"main\", \n    nullptr \n  }, \n  { \n    VK_SHADER_STAGE_FRAGMENT_BIT, \n    *fragment_shader_module, \n    \"main\", \n    nullptr \n  } \n}; \n\nstd::vector<VkPipelineShaderStageCreateInfo> shader_stage_create_infos; \nSpecifyPipelineShaderStages( shader_stage_params, shader_stage_create_infos );\n\n```", "```cpp\nVkPipelineVertexInputStateCreateInfo vertex_input_state_create_info; \nSpecifyPipelineVertexInputState( vertex_input_binding_descriptions, vertex_attribute_descriptions, vertex_input_state_create_info ); \n\nVkPipelineInputAssemblyStateCreateInfo input_assembly_state_create_info; \nSpecifyPipelineInputAssemblyState( primitive_topology, primitive_restart_enable, input_assembly_state_create_info );\n\n```", "```cpp\nViewportInfo viewport_infos = { \n  { \n    { \n      0.0f, \n      0.0f, \n      500.0f, \n      500.0f, \n      0.0f, \n      1.0f \n    } \n  }, \n  { \n    { \n      { \n        0, \n        0 \n      }, \n      { \n        500, \n        500 \n      } \n    } \n  } \n}; \nVkPipelineViewportStateCreateInfo viewport_state_create_info; \nSpecifyPipelineViewportAndScissorTestState( viewport_infos, viewport_state_create_info );\n\n```", "```cpp\nVkPipelineRasterizationStateCreateInfo rasterization_state_create_info; \nSpecifyPipelineRasterizationState( false, false, polygon_mode, culling_mode, front_face, false, 0.0f, 1.0f, 0.0f, 1.0f, rasterization_state_create_info ); \n\nVkPipelineMultisampleStateCreateInfo multisample_state_create_info; \nSpecifyPipelineMultisampleState( VK_SAMPLE_COUNT_1_BIT, false, 0.0f, nullptr, false, false, multisample_state_create_info );\n\n```", "```cpp\nVkStencilOpState stencil_test_parameters = { \n  VK_STENCIL_OP_KEEP, \n  VK_STENCIL_OP_KEEP, \n  VK_STENCIL_OP_KEEP, \n  VK_COMPARE_OP_ALWAYS, \n  0, \n  0, \n  0 \n}; \nVkPipelineDepthStencilStateCreateInfo depth_and_stencil_state_create_info; \nSpecifyPipelineDepthAndStencilState( true, true, VK_COMPARE_OP_LESS_OR_EQUAL, false, 0.0f, 1.0f, false, stencil_test_parameters, stencil_test_parameters, depth_and_stencil_state_create_info );\n\n```", "```cpp\nVkPipelineColorBlendStateCreateInfo blend_state_create_info; \nSpecifyPipelineBlendState( logic_op_enable, logic_op, attachment_blend_states, blend_constants, blend_state_create_info );\n\n```", "```cpp\nstd::vector<VkDynamicState> dynamic_states = { \n  VK_DYNAMIC_STATE_VIEWPORT, \n  VK_DYNAMIC_STATE_SCISSOR \n}; \nVkPipelineDynamicStateCreateInfo dynamic_state_create_info; \nSpecifyPipelineDynamicStates( dynamic_states, dynamic_state_create_info );\n\n```", "```cpp\nVkGraphicsPipelineCreateInfo graphics_pipeline_create_info; \nSpecifyGraphicsPipelineCreationParameters( additional_options, shader_stage_create_infos, vertex_input_state_create_info, input_assembly_state_create_info, nullptr, &viewport_state_create_info, \nrasterization_state_create_info, &multisample_state_create_info, &depth_and_stencil_state_create_info, &blend_state_create_info, &dynamic_state_create_info, pipeline_layout, render_pass, \nsubpass, base_pipeline_handle, -1, graphics_pipeline_create_info ); \n\nif( !CreateGraphicsPipelines( logical_device, { graphics_pipeline_create_info }, pipeline_cache, graphics_pipeline ) ) { \n  return false; \n} \nreturn true;\n\n```", "```cpp\nstd::vector<unsigned char> cache_data; \nGetBinaryFileContents( pipeline_cache_filename, cache_data ); \n\nstd::vector<VkDestroyer<VkPipelineCache>> pipeline_caches( graphics_pipelines_create_infos.size() ); \nfor( size_t i = 0; i < graphics_pipelines_create_infos.size(); ++i ) { \n  pipeline_caches[i] = VkDestroyer< VkPipelineCache >( logical_device ); \n  if( !CreatePipelineCacheObject( logical_device, cache_data, *pipeline_caches[i] ) ) { \n    return false; \n  } \n}\n\n```", "```cpp\nstd::vector<std::thread>threads( graphics_pipelines_create_infos.size() ); \nfor( size_t i = 0; i < graphics_pipelines_create_infos.size(); ++i ) { \n  graphics_pipelines[i].resize( graphics_pipelines_create_infos[i].size() ); \n  threads[i] = std::thread::thread( CreateGraphicsPipelines, logical_device, graphics_pipelines_create_infos[i], *pipeline_caches[i], graphics_pipelines[i] ); \n}\n\n```", "```cpp\nfor( size_t i = 0; i < graphics_pipelines_create_infos.size(); ++i ) { \n  threads[i].join(); \n} \n\nVkPipelineCache target_cache = *pipeline_caches.back(); \nstd::vector<VkPipelineCache> source_caches( pipeline_caches.size() - 1); \nfor( size_t i = 0; i < pipeline_caches.size() - 1; ++i ) { \n  source_caches[i] = *pipeline_caches[i]; \n} \n\nif( !MergeMultiplePipelineCacheObjects( logical_device, target_cache, source_caches ) ) { \n  return false; \n} \n\nif( !RetrieveDataFromPipelineCache( logical_device, target_cache, cache_data ) ) { \n  return false; \n} \n\nif( !SaveBinaryFile( pipeline_cache_filename, cache_data ) ) { \n  return false; \n} \n\nreturn true;\n\n```", "```cpp\nif( VK_NULL_HANDLE != pipeline ) { \n  vkDestroyPipeline( logical_device, pipeline, nullptr ); \n  pipeline = VK_NULL_HANDLE; \n}\n\n```", "```cpp\nif( VK_NULL_HANDLE != pipeline_cache ) { \n  vkDestroyPipelineCache( logical_device, pipeline_cache, nullptr ); \n  pipeline_cache = VK_NULL_HANDLE; \n}\n\n```", "```cpp\nif( VK_NULL_HANDLE != pipeline_layout ) { \n  vkDestroyPipelineLayout( logical_device, pipeline_layout, nullptr ); \n  pipeline_layout = VK_NULL_HANDLE; \n}\n\n```", "```cpp\nif( VK_NULL_HANDLE != shader_module ) { \n  vkDestroyShaderModule( logical_device, shader_module, nullptr ); \n  shader_module = VK_NULL_HANDLE; \n}\n\n```"]