- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ Is Not Memory-Safe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*If you still write C++ like* *it’s 2000*'
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ has its issues in terms of safety, and memory can be a part of it. Two
    types of memory issues exist: spatial and temporal. Spatial issues refer to accessing
    memory outside of the bounds, while temporal issues refer to accessing memory
    in an uncertain or freed state. Modern C++ attempts to avoid many of the pitfalls
    by avoiding the usage of naked pointers and through the use of **std::span** or
    concepts. There’s still work to do, though; we will show in this chapter that
    the current C++ mechanisms are still incomplete and look at safety profiles as
    a possible future improvement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Memory safety is important
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The memory safety problems of older C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modern C++ to the rescue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The limits of modern C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s still more to do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter is available on GitHub at [https://github.com/PacktPublishing/Debunking-CPP-Myths](https://github.com/PacktPublishing/Debunking-CPP-Myths)
    , in the **ch6** folder. The doctest ( [https://github.com/doctest/doctest](https://github.com/doctest/doctest)
    ) is used for the test functions and it is included in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Memory safety is important
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of us living in the modern world expect things to work. We expect to have
    electricity, clean water, and sanitation to the point that they have faded into
    the background. We don’t notice or consider the work required to keep the flow
    of electricity going; it’s just expected.
  prefs: []
  type: TYPE_NORMAL
- en: Software is the newcomer on this stage. I imagine people don’t realize how involved
    software is in almost everything people do, from payments to entertainment, from
    life-saving emergency services to going from one place to another.
  prefs: []
  type: TYPE_NORMAL
- en: Yet of all the omnipresent services in the modern world, software is the one
    that, for all its benefits, can really make your life difficult. Consider all
    the people whose identities have been leaked and sometimes stolen, whose money
    has been estranged, and who have been denied or got delayed medical attention
    because of hospitals affected by ransomware. Software is everywhere, and software
    must do better.
  prefs: []
  type: TYPE_NORMAL
- en: Yet we, the programmers, seem oblivious to these issues. Software is complicated,
    we tell ourselves. Users get scammed all the time due to their own fault. There’s
    no program without bugs. And yes, this is correct. Software is increasingly complex,
    with more people working on very small pieces. Users are not as careful as they
    should be. To make things worse, technology keeps changing so that a code base
    that worked perfectly 6 months ago might not work anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'But this does not remove our responsibility in the process. Air travel companies
    could say the same things: planes are complex machines; of course, they might
    develop defects and occasionally fall from the sky. Passengers don’t read or listen
    to emergency instructions; let’s blame them. Instead, the system around air travel
    is such that the risk of flying has continuously decreased over the years, becoming
    the safest way to travel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we, the programmers, were oblivious to these issues, very few of us
    were expecting a technical recommendation regarding the languages we should use
    coming from the White House. Published on February 26, 2024, the technical report
    notes that the software industry has a history of ignoring common root causes
    of security issues, and that for the sake of national security, applications should
    be written in memory-safe languages. The list of memory-safe languages includes
    Java, C#, Python, and Rust and excludes C and C++. You can read more about this
    at the following link: [https://www.whitehouse.gov/oncd/briefing-room/2024/02/26/press-release-technical-report/](https://www.whitehouse.gov/oncd/briefing-room/2024/02/26/press-release-technical-report/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: The reaction to this report was a mix of surprise, amusement, and consternation.
    Yet the importance of the report was reestablished a few months later, on July
    19, 2024, when about half of the world was affected by a memory issue in the CrowdStrike
    suite of products that caused a kernel panic in Windows systems around the world.
    The incident grounded planes, stopped emergency systems from functioning, took
    payment systems offline, and wreaked havoc on the lives of millions of people.
    I believe this may be the first time when a lot of people realized how important
    software has become, which means they might start paying attention to politicians
    who talk about it.
  prefs: []
  type: TYPE_NORMAL
- en: So, yes, memory safety is important. Memory management mistakes lead in the
    best case to a minor inconvenience of restarting a piece of software, but in the
    worst case to hackers exploiting vulnerabilities or to whole systems needing manual
    intervention. As with everything in software, the need for memory safety is contextual;
    a life-critical application needs a different type of attention in comparison
    to a single-player game. I would argue, though, that attention to this issue matters
    no matter what software you’re building. I believe programmers have a responsibility
    to write code that not only works as it should but also shields its users as much
    as possible from peril and perhaps even delights them sometimes. We, the programmers,
    need to remember that the code we write is used by people, and people matter.
    And while this is not the only problem we have, dealing with memory safety head-on
    is a good way to advance.
  prefs: []
  type: TYPE_NORMAL
- en: The memory safety problems of older C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we move on to discuss the memory safety issues in older and modern C++,
    let’s attempt to define it. Citing from the White House report: “ *Memory safety
    vulnerabilities are a class of vulnerability affecting how memory can be accessed,
    written, allocated, or deallocated in unintended ways (...) There are two broad
    categories of memory safety vulnerabilities: spatial and temporal. Spatial memory
    safety issues result from memory accesses performed outside of the “correct” bounds
    established for variables and objects in memory. Temporal memory safety issues
    arise when memory is accessed outside of time or state, such as accessing object
    data after the object is freed or when memory accesses are* *unexpectedly interleaved.*
    ”'
  prefs: []
  type: TYPE_NORMAL
- en: '*To view the source of the citing, you can go through page 7 of the document
    at the following* *link:* [https://www.whitehouse.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf](https://www.whitehouse.gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any C++ programmer should be familiar with both types of issues. The spatial
    memory issues were most common with naked arrays in C++. Try, for example, executing
    this program that creates an array, adds some values to it, and then attempts
    to write and read elements beyond its allocated memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The surprising thing about the preceding code is that it’s undefined behavior.
    That is, your compiler might react to the attempt to read or write after the bounds
    of the array in different ways, from ignoring it to a compilation error. Moreover,
    depending on the OS and the context, the code might work and overwrite unspecified
    blocks of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For attackers, this type of code is gold. Why? Well, there’s a small chance
    that this process will at some point be placed in RAM next to a process that does
    something valuable. If an attacker can send the right values into this function
    and catch the process at exactly the right moment, they might be able to overwrite
    the code that checks for authentication into your banking application, install
    a keylogger, or add malware to your system. Sure, such an attack is not guaranteed
    to succeed, but hackers have a lot of time since these things are automated anyway.
    It only needs to succeed once.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve tested this code on my computer, running Ubuntu Linux and compiling with
    **clang** and **g++** . The **g++** compiler happily compiles the program without
    a warning, even when turning on all warnings. Meanwhile, **clang** gives a warning
    at compile time that the array is accessed after its bounds. When I try to run
    the program, I get the message **"*** stack smashing detected ***: terminated"**
    . So, I have some protection at runtime, but the code still runs with unknown
    possible side effects.'
  prefs: []
  type: TYPE_NORMAL
- en: Note, however, that this is a very simple example. If I were to create an array
    somewhere in the code, pass it around to various functions, and compute the indexes
    based on some complicated formula, my bet is that no compiler would figure it
    out. We are left, therefore, with our tests and the OS protections.
  prefs: []
  type: TYPE_NORMAL
- en: '*Is this type of problem the language’s fault?* Few people may know this, but
    it’s possible to write this type of code in programming languages that are on
    the memory-safe list. C#, for example, has the notion of unsafe code and has pointers.
    You can mark a part of code unsafe, create pointers to access data, and use pointer
    arithmetic, with some limitations. The difference is that you need to work a lot
    to make this happen, and it still doesn’t have the same effects as in C++. Moreover,
    the piece of code that juggles with memory in similar ways is very visible in
    C# because it needs to be part of an unsafe block. **The problem with C++ is not
    as much that it is possible to do these things; it’s that it’s very easy to do
    them** **by default.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’re talking about pointers, let’s see how to misuse them. The following
    code uses a **void*** instance to access the memory beyond the allocated value
    of an **int*** type, through some casts and pointer arithmetic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we hit some undefined behavior: assigning a value to a pointer
    that results from pointer arithmetic is left to the compiler to decide. This time,
    both **g++** and **clang** give me warnings, but only about deleting a void pointer.
    None of the two have any problems with the fact that I try to write and read beyond
    the allocated region. Even more interestingly, the tests run perfectly fine, the
    result of the function is the expected one, and everyone is happy! Not even the
    OS is complaining about this nonsense – hopefully, because I haven’t exceeded
    the process’s allocated memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully.
  prefs: []
  type: TYPE_NORMAL
- en: We have looked until now at examples of spatial memory safety issues, and things
    don’t look good. What about temporal ones?
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyone who’s used pointers has had to deal with the need to remember to do
    two things after they are no longer needed: free the allocated memory and reset
    them to **NULL** . Both things are important because forgetting one of them leads
    to temporal memory safety issues: a dangling pointer that still has access to
    an area of memory that has been released, or a memory leak when the pointer has
    not been freed and maybe the pointer was reset so that the memory area is no longer
    accessible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take as an example the following function that initializes a pointer to **int**
    with a value, frees the memory, and then returns the value stored in the memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, the program compiles fine. There’s no warning in **g++** or **clang**
    . It also runs, but the test fails because the value stored in the memory at that
    address is not the expected one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The value stored at that address changes at each subsequent call, giving me
    other results such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It’s unexpectedly easy to use this value in a computation later in the code
    and return a weird value. It’s also a way to find out what’s in a memory area
    if you know a little bit about the computation performed and can pass repeated
    inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Temporal memory safety issues are worse since it’s harder to keep track of the
    lifetime of a pointer in the labyrinth of a large code base than to ensure that
    we aren’t reading past its bounds. So, yes – unfortunately, memory issues can
    be a big problem in C++.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll have noticed, however, that all the previous examples have been in the
    old C++ style. We used naked arrays, naked pointers, and pointer arithmetic. These
    are all constructs that you should use very sparingly in modern C++, for these
    exact reasons. I can’t say never use them, because there are specific situations
    when we need naked pointers and naked arrays, but nowadays, they tend to be limited
    to memory optimization or low-level programming. Even in these situations, you
    can usually introduce a clear boundary between the unsafe and the modern C++.
  prefs: []
  type: TYPE_NORMAL
- en: So, does modern C++ solve all these issues?
  prefs: []
  type: TYPE_NORMAL
- en: Modern C++ to the rescue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s revisit the preceding examples but replace the naked arrays and naked
    pointers with their STL equivalents, as recommended in modern C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the array bounds example. We simply replace the naked array with a **vector<int>**
    instance and we get the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the result of running this example is not great. Neither **g++**
    nor **clang** complains, and we get the following result when running the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Is **std::vector<>** unsafe? Well, we still need to pay attention to the space
    allocated for it. We have a few options: initialize it properly, use the methods
    provided to append to the collection, or ask to reserve memory for a specific
    number of items. The first two are what I would typically use since they are less
    likely to lead to issues. But even the third option results in a passing test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A pleasant surprise is the behavior of **std::vector** , at least on **g++**
    , after reserve. I tried to access **values[2]** , not set in this example, and
    I got the value 0. This is much better than accessing the value previously stored
    in that memory block, and I imagine it’s a feature of the default allocator used
    by **std::vector** . This difference is due to the undefined behavior of **operator[]**
    , and it is avoidable by using the **vector::at()** method. Still, we had to do
    some work. So, we can still write code that leads to memory issues, even with
    the modern STL. Of course, if we quit monkeying around and use one of the easy
    methods, this problem disappears completely. If we use the initializer syntax,
    the vector is created based on the data passed in without us having to do any
    more counting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this syntax makes us add all the elements to the vector rather than
    some of them, thus preventing an off-by-1 error. The alternative is adding the
    elements one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, this version works perfectly as well. The moral: use the boring
    constructs, and you’ll get the expected behavior 99% of the time. This is a good
    mantra for coding in any programming language, but even more so in C++.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look now again at the example that uses pointer arithmetic and **void***
    to access memory outside of the bounds. This is how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: I’ve done my best to convert this code to use **std::unique_ptr** or **std::shared_ptr**
    , and I believe it’s possible but it’s extremely convoluted. The first problem
    is dealing with all the pointer conversions we are using. There’s no easy way
    to convert **std::unique_ptr<int>** to **std::unique_ptr<char>** ; the only way
    is to convert the value and get a new **unique_ptr<>** instance.
  prefs: []
  type: TYPE_NORMAL
- en: The second problem is that **void*** doesn’t have a direct translation into
    **std::shared_ptr<void>** ; you can use it but only by allocating the memory manually
    and passing a custom **deleter** function. So, while it’s possible to write something
    resembling this code with the modern STL, it takes so much work that programmers
    will stick to the safe methods unless they have very specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We encounter the same situation with the dangling pointer example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s no straightforward way to delete the smart pointer and then return
    the value. We could reallocate using a call to **unique_ptr::reset** , but that
    would use pointers again. The simplest translation into pure smart pointers looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Only this works exactly as it should: the value is returned correctly, and
    the memory is released. No dangling pointer by default!'
  prefs: []
  type: TYPE_NORMAL
- en: We could make it a dangling pointer if we allocate it manually and pass in a
    deleter that does nothing to **std::unique_ptr<>** . There’s no reason to do this
    in most situations, therefore I would expect most programmers to avoid this issue
    altogether. Add in the option to use **std::shared_ptr<>** in case you need multiple
    owners of the memory block, and your most common situations are sorted out.
  prefs: []
  type: TYPE_NORMAL
- en: We can conclude from all this that modern C++ is much safer, reducing a lot
    of the potential issues by default. But it still has its limits, which is what
    we will focus on next.
  prefs: []
  type: TYPE_NORMAL
- en: The limits of modern C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s assume for a moment that we use only STL collections, we avoid pointers,
    and when we really need them, we use the smart pointers implemented in the standard
    library, and we write our types with memory safety in mind. Are we done?
  prefs: []
  type: TYPE_NORMAL
- en: 'Herb Sutter, one of the well-known members of the C++ standardization committee,
    has looked at this issue and at the more general issue of avoiding security issues
    in C++, in a blog post titled *C++ safety, in context* ( [https://herbsutter.com/2024/03/11/safety-in-context/](https://herbsutter.com/2024/03/11/safety-in-context/)
    ) published on March 11, 2024. His conclusion is that it’s too easy to write C++
    code that by default has security and safety vulnerabilities. The article identifies
    four areas that need more attention: types, bounds, initialization, and lifetime.
    Then, he states that there are already some mechanisms in place in C++ 20: **span**
    , **string_view** concepts, and bound-aware ranges. What is missing from the language,
    as the article discusses next, is safety rules that are enabled by default but
    that programmers can turn off if needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s unpack all this information and give some examples.
  prefs: []
  type: TYPE_NORMAL
- en: First on the list, the new **std::span** introduced in C++20. It represents
    a contiguous sequence of objects, extracted from a naked array, **std::array**
    , a pointer with a size, **std::vector** , or **std::string** . Its big advantage
    is that it automatically deduces the size of the sequence, thus removing the common
    instance of off-by-1 errors. Thus, we now have a safe way to pass a subset of
    a collection into a function without the fear of messing up the sequence length.
    Also, it allows us to completely forbid pointer arithmetic and use **std::span**
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Second, **string_view** . A **std::string_view** instance allows us to have
    a read-only view on a string, thus eliminating another source of potential safety
    issues, with strings being modified where they shouldn’t or with operations on
    strings that are prone to being unsafe.
  prefs: []
  type: TYPE_NORMAL
- en: Third, concepts. Concepts allow C++ programmers to define constraints upon generic
    functions and classes, thus enhancing the safety of the types. For example, one
    could request that the value passed in a generic function has a type that has
    both an addition and a subtraction method. Concepts are still under development,
    with improvements coming in C++ 26, but they already help solve a lot of potential
    safety issues.
  prefs: []
  type: TYPE_NORMAL
- en: Fourth, bound-aware ranges. The **ranges** library allows C++ programmers to
    write efficient functional programming-inspired operations that work on collections,
    thus eliminating another source of potential misuse. Ranges know their bounds
    and shield the developers from passing in every function the begin and end iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'These improvements, if used, have gone a long way from C++ 98. Still, things
    are missing. Remember the code that accessed an index in **std::vector** that
    did not reserve any memory and got a bad memory error at runtime? Let’s take a
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with this code is that we can happily access indexes beyond the
    allocated vector size while skipping the initialization for index 2. A possible
    solution to this issue would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable a **safemode** compiler flag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiler generates a range check upon every index access that verifies that
    **0 <= index <** **collection.size()**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We get no error at runtime because nothing happens when we try to call this
    code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such a compile option could be enabled on existing code with no change and prevent
    unknown issues. Sure, some programmers will have an issue with this because of
    the potential for reducing performance. That’s precisely why such an option should
    be either turned on by a compiler flag, or, even better, turned on by default
    with the option to turn it off by a compiler flag.
  prefs: []
  type: TYPE_NORMAL
- en: This shows that there’s still more to do to make C++ memory safe.
  prefs: []
  type: TYPE_NORMAL
- en: There’s still more to do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standardization committee is currently working on a proposal called **safety
    profiles** , which allows a combined approach formed of compile enhancements,
    static analysis, and profiler tools to eliminate most of these safety issues.
    It is unclear when it will be done, and I for one don’t envy their task. There
    are millions if not billions of lines of C++ code used today, and any proposal
    needs to have a minimal impact on the existing code, other than pointing out potential
    security issues. It must also affect performance as little as possible, given
    how important it is for many existing applications.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the urgency is clear. C++ has issues with memory safety,
    and it might end up on a blacklist for US government projects, and likely for
    other governments as well. Only time will tell when the issue is resolved and
    how it impacts the usage of the language.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen in this chapter how it’s too easy to write unsafe code by default
    in C++. Despite the improvements introduced by subsequent standards, by the STL
    collections and smart pointers, it’s still likely that programmers will make mistakes
    with a potentially huge cost. Sure, there are ways to catch these mistakes: automated
    developer tests, exploratory tests, penetration testing, and so on. But the defaults
    of the language matter, and C++’s defaults are still unsafe.'
  prefs: []
  type: TYPE_NORMAL
- en: After examining these issues, my only option is to conclude that C++ is still
    memory-unsafe by default and that writing memory-safe code requires continuous
    attention and the appropriate tools. The safety profiles that will hopefully arrive
    soon in the standard will most likely alleviate many of the issues, but there’s
    still an unfathomable quantity of C++ code in the world that was written like
    it’s still 2000. So, a mixed bag.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will examine the state of parallelism and concurrency
    in C++.
  prefs: []
  type: TYPE_NORMAL
