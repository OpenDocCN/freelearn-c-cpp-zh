["```cpp\n#include <vulkan\\vulkan.h> \n#include <vector> \n\n#include <fstream> \n\nclass GraphicsPipeline \n{ \npublic: \n   GraphicsPipeline(); \n   ~GraphicsPipeline(); \n\n   VkPipelineLayout pipelineLayout; \n   VkPipeline graphicsPipeline; \n\n   void createGraphicsPipelineLayoutAndPipeline(VkExtent2D \n     swapChainImageExtent, VkDescriptorSetLayout descriptorSetLayout, \n     VkRenderPass renderPass); \n\n   void destroy(); \n\nprivate: \n\n   std::vector<char> readfile(const std::string& filename); \n   VkShaderModule createShaderModule(const std::vector<char> & code); \n\n   void createGraphicsPipelineLayout(VkDescriptorSetLayout \n      descriptorSetLayout); \n   void createGraphicsPipeline(VkExtent2D swapChainImageExtent, \n      VkRenderPass renderPass); \n\n}; \n```", "```cpp\n#include \"GraphicsPipeline.h\" \n\n#include \"VulkanContext.h\" \n#include \"Mesh.h\" \n\nGraphicsPipeline::GraphicsPipeline(){} \n\nGraphicsPipeline::~GraphicsPipeline(){} \n```", "```cpp\nvoid GraphicsPipeline::createGraphicsPipelineLayoutAndPipeline(VkExtent2D \n  swapChainImageExtent, VkDescriptorSetLayout descriptorSetLayout, \n  VkRenderPass renderPass){ \n\n   createGraphicsPipelineLayout(descriptorSetLayout); \n   createGraphicsPipeline(swapChainImageExtent, renderPass); \n\n} \n```", "```cpp\nvoid GraphicsPipeline::createGraphicsPipelineLayout(VkDescriptorSetLayout \n  descriptorSetLayout){ \n\n   VkPipelineLayoutCreateInfo pipelineLayoutInfo = {}; \n   pipelineLayoutInfo.sType = VK_STRUCTURE_TYPEPIPELINE_                              LAYOUT_CREATE_INFO; \n\n// used for passing uniform objects and images to the shader \n\npipelineLayoutInfo.setLayoutCount = 1; \n   pipelineLayoutInfo.pSetLayouts = &descriptorSetLayout; \n\n   if (vkCreatePipelineLayout(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, &pipelineLayoutInfo, nullptr, \n      &pipelineLayout) != VK_SUCCESS) { \n\n         throw std::runtime_error(\" failed to create pieline \n            layout !\"); \n   } \n\n} \n```", "```cpp\nstd::vector<char> GraphicsPipeline::readfile(const std::string& filename) { \n\n   std::ifstream file(filename, std::ios::ate | std::ios::binary); \n\n   if (!file.is_open()) { \n         throw std::runtime_error(\" failed to open shader file\"); \n   } \n   size_t filesize = (size_t)file.tellg(); \n\n   std::vector<char> buffer(filesize); \n\n   file.seekg(0); \n   file.read(buffer.data(), filesize); \n\n   file.close(); \n\n   return buffer; \n\n}  \n```", "```cpp\nVkShaderModule GraphicsPipeline::createShaderModule(const std::vector<char> & code) { \n\n   VkShaderModuleCreateInfo cInfo = {}; \n\n   cInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO; \n   cInfo.codeSize = code.size(); \n   cInfo.pCode = reinterpret_cast<const uint32_t*>(code.data()); \n\n   VkShaderModule shaderModule; \n   if (vkCreateShaderModule(VulkanContext::getInstance()->getDevice()->\n     logicalDevice, &cInfo, nullptr, &shaderModule) != VK_SUCCESS) { \n     throw std::runtime_error(\" failed to create shader module !\"); \n   } \n\n   return shaderModule; \n} \n```", "```cpp\nvoid GraphicsPipeline::createGraphicsPipeline(VkExtent2D swapChainImageExtent,  VkRenderPass renderPass) { \n\n... \n\n} \n```", "```cpp\n   auto vertexShaderCode = readfile(\"shaders/SPIRV/basic.vert.spv\"); \n\n   VkShaderModule vertexShadeModule = createShaderModule(vertexShaderCode); \n```", "```cpp\n   VkPipelineShaderStageCreateInfo vertShaderStageCreateInfo = {}; \n   vertShaderStageCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER\n                                     _STAGE_CREATE_INFO; \n   vertShaderStageCreateInfo.stage = VK_SHADER_STAGE_VERTEX_BIT; \n   vertShaderStageCreateInfo.module = vertexShadeModule; \n   vertShaderStageCreateInfo.pName = \"main\";  \n```", "```cpp\n   auto fragmentShaderCode = readfile(\"shaders/SPIRV/basic.frag.spv\"); \n   VkShaderModule fragShaderModule = createShaderModule\n                                     (fragmentShaderCode); \n\n   VkPipelineShaderStageCreateInfo fragShaderStageCreateInfo = {}; \n\n   fragShaderStageCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINESHADER_                                      STAGE_CREATE_INFO; \n   fragShaderStageCreateInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT; \n   fragShaderStageCreateInfo.module = fragShaderModule; \n   fragShaderStageCreateInfo.pName = \"main\";\n```", "```cpp\nVkPipelineShaderStageCreateInfo shaderStages[] = {    \n    vertShaderStageCreateInfo, fragShaderStageCreateInfo }; \n```", "```cpp\nauto bindingDescription = Vertex::getBindingDescription(); \nauto attribiteDescriptions = Vertex::getAttributeDescriptions(); \n\nVkPipelineVertexInputStateCreateInfo vertexInputInfo = {}; \nvertexInputInfo.sType = VK_STRUCTURE_TYPE*PIPELINE\n*                           VERTEX_INPUT_STATE_CREATE_INFO;\n// initially was 0 as vertex data was hardcoded in the shader \nvertexInputInfo.vertexBindingDescriptionCount = 1; \nvertexInputInfo.pVertexBindingDescriptions = &bindingDescription; \n\nvertexInputInfo.vertexAttributeDescriptionCount = static_cast<uint32_t> \n                                                  (attribiteDescriptions.size());    \nvertexInputInfo.pVertexAttributeDescriptions = attribiteDescriptions\n                                               .data();\n```", "```cpp\n   VkPipelineInputAssemblyStateCreateInfo inputAssemblyInfo = {}; \n   inputAssemblyInfo.sType = VK_STRUCTURE_TYPE_PIPELINE*INPUT\n*                             ASSEMBLY_STATE_CREATE_INFO; \n   inputAssemblyInfo.topology =  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST; \n   inputAssemblyInfo.primitiveRestartEnable = VK_FALSE; \n```", "```cpp\n   VkPipelineRasterizationStateCreateInfo rastStateCreateInfo = {}; \n   rastStateCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE*RASTERIZATION\n*                               STATE_CREATE_INFO; \n   rastStateCreateInfo.depthClampEnable = VK_FALSE; \n   rastStateCreateInfo.rasterizerDiscardEnable = VK_FALSE;  \n   rastStateCreateInfo.polygonMode = VK_POLYGON_MODE_FILL; \n   rastStateCreateInfo.lineWidth = 1.0f; \n   rastStateCreateInfo.cullMode = VK_CULL_MODE_BACK_BIT; \n   rastStateCreateInfo.frontFace = VK_FRONT_FACE_CLOCKWISE; \n   rastStateCreateInfo.depthBiasEnable = VK_FALSE; \n   rastStateCreateInfo.depthBiasConstantFactor = 0.0f; \n   rastStateCreateInfo.depthBiasClamp = 0.0f; \n   rastStateCreateInfo.depthBiasSlopeFactor = 0.0f; \n\n```", "```cpp\n   VkPipelineMultisampleStateCreateInfo msStateInfo = {}; \n   msStateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE*MULTISAMPLE\n*                       STATE_CREATE_INFO; \n   msStateInfo.sampleShadingEnable = VK_FALSE; \n   msStateInfo.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;\n```", "```cpp\n   VkPipelineColorBlendAttachmentState  cbAttach = {}; \n   cbAttach.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | \n                             VK_COLOR_COMPONENT_G_BIT | \n                             VK_COLOR_COMPONENT_B_BIT | \n                             VK_COLOR_COMPONENT_A_BIT; \n   cbAttach.blendEnable = VK_FALSE; \n```", "```cpp\n   cbCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_COLORBLEND_                        STATE_CREATE_INFO; \n   cbCreateInfo.attachmentCount = 1; \n   cbCreateInfo.pAttachments = &cbAttach;  \n```", "```cpp\n   VkViewport viewport = {}; \n   viewport.x = 0; \n   viewport.y = 0; \n   viewport.width = (float)swapChainImageExtent.width; \n   viewport.height = (float)swapChainImageExtent.height; \n   viewport.minDepth = 0.0f; \n   viewport.maxDepth = 1.0f; \n\n   VkRect2D scissor = {}; \n   scissor.offset = { 0,0 }; \n   scissor.extent = swapChainImageExtent; \n```", "```cpp\n   VkPipelineViewportStateCreateInfo vpStateInfo = {}; \n   vpStateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE*VIEWPORT\n*                       STATE_CREATE_INFO; \n   vpStateInfo.viewportCount = 1; \n   vpStateInfo.pViewports = &viewport; \n   vpStateInfo.scissorCount = 1; \n   vpStateInfo.pScissors = &scissor;  \n```", "```cpp\n   VkGraphicsPipelineCreateInfo gpInfo = {}; \n   gpInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO; \n\n   gpInfo.stageCount = 2; \n   gpInfo.pStages = shaderStages; \n\n   gpInfo.pVertexInputState = &vertexInputInfo; \n   gpInfo.pInputAssemblyState = &inputAssemblyInfo; \n   gpInfo.pRasterizationState = &rastStateCreateInfo; \n   gpInfo.pMultisampleState = &msStateInfo; \n   gpInfo.pDepthStencilState = nullptr; \n   gpInfo.pColorBlendState = &cbCreateInfo; \n   gpInfo.pDynamicState = nullptr; \n\ngpInfo.pViewportState = &vpStateInfo; \n```", "```cpp\n   gpInfo.layout = pipelineLayout; \n   gpInfo.renderPass = renderPass; \n   gpInfo.subpass = 0; \n```", "```cpp\n  if (vkCreateGraphicsPipelines(VulkanContext::getInstance()->\n    getDevice()->logicalDevice, VK_NULL_HANDLE, 1, &gpInfo, nullptr, \n    &graphicsPipeline) != VK_SUCCESS) { \n         throw std::runtime_error(\"failed to create graphics pipeline !!\"); \n   } \n```", "```cpp\n   vkDestroyShaderModule(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, vertexShadeModule, nullptr); \n   vkDestroyShaderModule(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, fragShaderModule, nullptr); \n```", "```cpp\n void GraphicsPipeline::destroy(){ \n\n   vkDestroyPipeline(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, graphicsPipeline, nullptr); \n   vkDestroyPipelineLayout(VulkanContext::getInstance()->\n      getDevice()->logicalDevice, pipelineLayout, nullptr); \n\n} \n```", "```cpp\n#include \"GraphicsPipeline.h\" \n#include \"ObjectBuffers.h\" \n#include \"Descriptor.h\" \n\n#include \"Camera.h\" \n\nclass ObjectRenderer \n{ \npublic: \n  void createObjectRenderer(MeshType modelType, glm::vec3 _position, \n     glm::vec3 _scale); \n\n   void updateUniformBuffer(Camera camera); \n\n   void draw(); \n\n   void destroy(); \n\nprivate: \n\n   GraphicsPipeline gPipeline; \n   ObjectBuffers objBuffers; \n   Descriptor descriptor; \n\n   glm::vec3 position; \n   glm::vec3 scale; \n\n};\n```", "```cpp\n#include \"ObjectRenderer.h\" \n#include \"VulkanContext.h\" \nvoid ObjectRenderer::createObjectRenderer(MeshType modelType, glm::vec3 _position, glm::vec3 _scale){ \n\nuint32_t swapChainImageCount = VulkanContext::getInstance()->\n                               getSwapChain()->swapChainImages.size(); \n\nVkExtent2D swapChainImageExtent = VulkanContext::getInstance()->\n                                  getSwapChain()->swapChainImageExtent; \n\n   // Create Vertex, Index and Uniforms Buffer; \n   objBuffers.createVertexIndexUniformsBuffers(modelType); \n\n   // CreateDescriptorSetLayout \n     descriptor.createDescriptorLayoutSetPoolAndAllocate\n     (swapChainImageCount); \n     descriptor.populateDescriptorSets(swapChainImageCount,\n     objBuffers.uniformBuffers); \n\n   // CreateGraphicsPipeline \n   gPipeline.createGraphicsPipelineLayoutAndPipeline( \n       swapChainImageExtent, \n       descriptor.descriptorSetLayout, \n       VulkanContext::getInstance()->getRenderpass()->renderPass); \n\n   position = _position; \n   scale = _scale; \n\n } \n```", "```cpp\nvoid ObjectRenderer::updateUniformBuffer(Camera camera){ \n\n   UniformBufferObject ubo = {}; \n\n   glm::mat4 scaleMatrix = glm::mat4(1.0f); \n   glm::mat4 rotMatrix = glm::mat4(1.0f); \n   glm::mat4 transMatrix = glm::mat4(1.0f); \n\n   scaleMatrix = glm::scale(glm::mat4(1.0f), scale); \n   transMatrix = glm::translate(glm::mat4(1.0f), position); \n\n   ubo.model = transMatrix * rotMatrix * scaleMatrix; \n\n   ubo.view = camera.viewMatrix \n\n   ubo.proj = camera.getprojectionMatrix \n\n   ubo.proj[1][1] *= -1; // invert Y, in Opengl it is inverted to\n                            begin with \n\n   void* data; \n   vkMapMemory(VulkanContext::getInstance()->getDevice()->\n     logicalDevice, objBuffers.uniformBuffersMemory, 0, \n     sizeof(ubo), 0, &data); \n\n   memcpy(data, &ubo, sizeof(ubo)); \n\n   vkUnmapMemory(VulkanContext::getInstance()->getDevice()->\n     logicalDevice, objBuffers.uniformBuffersMemory); \n\n}\n```", "```cpp\nvoid ObjectRenderer::draw(){ \n\n   VkCommandBuffer cBuffer = VulkanContext::getInstance()->\n                             getCurrentCommandBuffer(); \n\n   // Bind the pipeline \n   vkCmdBindPipeline(cBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, \n     gPipeline.graphicsPipeline); \n\n   // Bind vertex buffer to command buffer \n   VkBuffer vertexBuffers[] = { objBuffers.vertexBuffer }; \n   VkDeviceSize offsets[] = { 0 }; \n\n   vkCmdBindVertexBuffers(cBuffer, \n         0, // first binding index \n         1, // binding count \n         vertexBuffers, \n         offsets); \n\n   // Bind index buffer to the command buffer \n   vkCmdBindIndexBuffer(cBuffer, \n         objBuffers.indexBuffer, \n         0, \n         VK_INDEX_TYPE_UINT32); \n\n   //    Bind uniform buffer using descriptorSets \n   vkCmdBindDescriptorSets(cBuffer, \n         VK_PIPELINE_BIND_POINT_GRAPHICS, \n         gPipeline.pipelineLayout, \n         0, \n         1, \n         &descriptor.descriptorSet, 0, nullptr); \n\n   vkCmdDrawIndexed(cBuffer, \n         static_cast<uint32_t>(objBuffers.indices.size()), // no of indices \n         1, // instance count -- just the 1 \n         0, // first index -- start at 0th index \n         0, // vertex offset -- any offsets to add \n         0);// first instance -- since no instancing, is set to 0  \n\n} \n```", "```cpp\n void ObjectRenderer::destroy() { \n\n   gPipeline.destroy(); \n   descriptor.destroy(); \n   objBuffers.destroy(); \n\n} \n```", "```cpp\n   void drawBegin(); \n   void drawEnd(); \n   void cleanup(); \n\n   SwapChain* getSwapChain(); \n   Renderpass* getRenderpass(); \n   VkCommandBuffer getCurrentCommandBuffer();  \n```", "```cpp\nSwapChain * VulkanContext::getSwapChain() { \n\n   return swapChain; \n} \n\nRenderpass * VulkanContext::getRenderpass() { \n\n   return renderPass; \n} \n\nVkCommandBuffer VulkanContext::getCurrentCommandBuffer() { \n\n   return curentCommandBuffer; \n} \n```", "```cpp\n#pragma once \n\n#define GLM_FORCE_RADIAN \n#include <glm\\glm.hpp> \n#include <glm\\gtc\\matrix_transform.hpp> \n\nclass Camera \n{ \npublic: \n\n   void init(float FOV, float width, float height, float nearplane, \n      float farPlane); \n\nvoid setCameraPosition(glm::vec3 position); \n   glm::mat4 getViewMatrix(); \n   glm::mat4 getprojectionMatrix(); \n\nprivate: \n\n   glm::mat4 projectionMatrix; \n   glm::mat4 viewMatrix; \n   glm::vec3 cameraPos; \n\n};\n```", "```cpp\n#include \"Camera.h\" \n\nvoid Camera::init(float FOV, float width, float height, float nearplane, \n   float farPlane) { \n\n   cameraPos = glm::vec3(0.0f, 0.0f, 4.0f); \n   glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, 0.0f); \n   glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f); \n\n   viewMatrix = glm::mat4(1.0f); \n   projectionMatrix = glm::mat4(1.0f); \n\n   projectionMatrix = glm::perspective(FOV, width / height, nearplane, \n                      farPlane); \n   viewMatrix = glm::lookAt(cameraPos, cameraFront, cameraUp); \n\n} \n\nglm::mat4 Camera::getViewMatrix(){ \n\n   return viewMatrix; \n\n} \nglm::mat4 Camera::getprojectionMatrix(){ \n\n   return projectionMatrix; \n} \n\nvoid Camera::setCameraPosition(glm::vec3 position){ \n\n   cameraPos = position; \n} \n```", "```cpp\n#define GLFW_INCLUDE_VULKAN \n#include<GLFW/glfw3.h> \n\n#include \"VulkanContext.h\" \n\n#include \"Camera.h\" \n#include \"ObjectRenderer.h\" \n```", "```cpp\nint main() { \n\n   glfwInit(); \n\n   glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); \n   glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); \n\n   GLFWwindow* window = glfwCreateWindow(1280, 720, \n                        \"HELLO VULKAN \", nullptr, nullptr); \n\n   VulkanContext::getInstance()->initVulkan(window); \n\n   Camera camera; \n   camera.init(45.0f, 1280.0f, 720.0f, 0.1f, 10000.0f); \n   camera.setCameraPosition(glm::vec3(0.0f, 0.0f, 4.0f)); \n\n   ObjectRenderer object; \n   object.createObjectRenderer(MeshType::kTriangle, \n         glm::vec3(0.0f, 0.0f, 0.0f), \n         glm::vec3(0.5f)); \n```", "```cpp\n  while (!glfwWindowShouldClose(window)) { \n\n         VulkanContext::getInstance()->drawBegin(); \n\n         object.updateUniformBuffer(camera); \n         object.draw(); \n\n         VulkanContext::getInstance()->drawEnd(); \n\n         glfwPollEvents(); \n   }               \n```", "```cpp\n   object.destroy(); \n\n   VulkanContext::getInstance()->cleanup(); \n\n   glfwDestroyWindow(window); \n   glfwTerminate(); \n\n   return 0; \n} \n```", "```cpp\n   const int MAX_FRAMES_IN_FLIGHT = 2; \n   VkSemaphore imageAvailableSemaphore;  \n   VkSemaphore renderFinishedSemaphore;  \n   std::vector<VkFence> inFlightFences;  \n```", "```cpp\n   drawComBuffer = new DrawCommandBuffer(); \n   drawComBuffer->createCommandPoolAndBuffer(swapChain->\n      swapChainImages.size()); \n\n   // Synchronization \n\n   VkSemaphoreCreateInfo semaphoreInfo = {}; \n   semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO; \n\n   vkCreateSemaphore(device->logicalDevice, &semaphoreInfo, \n      nullptr, &imageAvailableSemaphore); \n   vkCreateSemaphore(device->logicalDevice, &semaphoreInfo, \n      nullptr, &renderFinishedSemaphore); \n\n   inFlightFences.resize(MAX_FRAMES_IN_FLIGHT); \n\n   VkFenceCreateInfo fenceCreateInfo = {}; \n   fenceCreateInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO; \n   fenceCreateInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT; \n\n   for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) { \n\n         if (vkCreateFence(device->logicalDevice, &fenceCreateInfo, \n           nullptr, &inFlightFences[i]) != VK_SUCCESS) { \n\n         throw std::runtime_error(\" failed to create synchronization \n            objects per frame !!\"); \n         } \n   } \n```", "```cpp\n   vkAcquireNextImageKHR(device->logicalDevice, \n         swapChain->swapChain, \n         std::numeric_limits<uint64_t>::max(), \n         imageAvailableSemaphore, // is  signaled \n         VK_NULL_HANDLE, \n         &imageIndex); \n```", "```cpp\nvkWaitForFences(device->logicalDevice, 1, &inFlightFences[imageIndex], \n   VK_TRUE, std::numeric_limits<uint64_t>::max());\n```", "```cpp\n  vkResetFences(device->logicalDevice, 1, &inFlightFences[imageIndex]);  \n```", "```cpp\n   // submit command buffer \n   VkSubmitInfo submitInfo = {}; \n   submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO; \n   submitInfo.commandBufferCount = 1; \n   submitInfo.pCommandBuffers = &currentCommandBuffer; \n\n   // Wait for the stage that writes to color attachment \n   VkPipelineStageFlags waitStages[] = { VK_PIPELINE*STAGE*COLOR_\n                                       ATTACHMENT_OUTPUT_BIT }; \n   // Which stage of the pipeline to wait \n   submitInfo.pWaitDstStageMask = waitStages; \n\n   // Semaphore to wait on before submit command execution begins \n   submitInfo.waitSemaphoreCount = 1; \n   submitInfo.pWaitSemaphores = &imageAvailableSemaphore;   \n\n   // Semaphore to be signaled when command buffers have completed \n   submitInfo.signalSemaphoreCount = 1; \n   submitInfo.pSignalSemaphores = &renderFinishedSemaphore; \n```", "```cpp\nvkQueueSubmit(device->graphicsQueue, 1, &submitInfo, inFlightFences[imageIndex]);\n```", "```cpp\n   // Present frame \n   VkPresentInfoKHR presentInfo = {}; \n   presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR; \n\n   presentInfo.waitSemaphoreCount = 1; \n   presentInfo.pWaitSemaphores = &renderFinishedSemaphore;  \n\n   presentInfo.swapchainCount = 1; \n   presentInfo.pSwapchains = &swapChain->swapChain; \n   presentInfo.pImageIndices = &imageIndex; \n\n   vkQueuePresentKHR(device->presentQueue, &presentInfo); \n   vkQueueWaitIdle(device->presentQueue);  \n\n```", "```cpp\n void VulkanContext::cleanup() { \n\n   vkDeviceWaitIdle(device->logicalDevice); \n\n   vkDestroySemaphore(device->logicalDevice, \n      renderFinishedSemaphore, nullptr); \n   vkDestroySemaphore(device->logicalDevice, \n      imageAvailableSemaphore, nullptr); \n\n   // Fences and Semaphores \n   for (size_t i = 0; i < MAX_FRAMES_IN_FLIGHT; i++) { \n\n        vkDestroyFence(device->logicalDevice, inFlightFences[i], nullptr); \n   } \n\n   drawComBuffer->destroy(); \n   renderTarget->destroy(); \n   renderPass->destroy(); \n   swapChain->destroy(); \n\n   device->destroy(); \n\n   valLayersAndExt->destroy(vInstance->vkInstance, isValidationLayersEnabled); \n\n   vkDestroySurfaceKHR(vInstance->vkInstance, surface, nullptr);   \n   vkDestroyInstance(vInstance->vkInstance, nullptr); \n\n} \n```", "```cpp\n#define GLFW_INCLUDE_VULKAN\n#include<GLFW/glfw3.h>\n#include \"VulkanContext.h\"\n#include \"Camera.h\"\n#include \"ObjectRenderer.h\"\nint main() {\n\nglfwInit();\n\nglfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);\nglfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);\n\nGLFWwindow* window = glfwCreateWindow(1280, 720, \"HELLO VULKAN \", \n                     nullptr, nullptr);\nVulkanContext::getInstance()->initVulkan(window);\n\nCamera camera;\ncamera.init(45.0f, 1280.0f, 720.0f, 0.1f, 10000.0f);\ncamera.setCameraPosition(glm::vec3(0.0f, 0.0f, 4.0f));\nObjectRenderer tri;\ntri.createObjectRenderer(MeshType::kTriangle,\nglm::vec3(-1.0f, 1.0f, 0.0f),\nglm::vec3(0.5f));\n\nObjectRenderer quad;\nquad.createObjectRenderer(MeshType::kQuad,\nglm::vec3(1.0f, 1.0f, 0.0f),\nglm::vec3(0.5f));\n\nObjectRenderer cube;\ncube.createObjectRenderer(MeshType::kCube,\nglm::vec3(-1.0f, -1.0f, 0.0f),\nglm::vec3(0.5f));\n\nObjectRenderer sphere;\nsphere.createObjectRenderer(MeshType::kSphere,\nglm::vec3(1.0f, -1.0f, 0.0f),\nglm::vec3(0.5f));\n\nwhile (!glfwWindowShouldClose(window)) {\n\nVulkanContext::getInstance()->drawBegin();\n\n// updatetri.updateUniformBuffer(camera);\nquad.updateUniformBuffer(camera);\ncube.updateUniformBuffer(camera);\nsphere.updateUniformBuffer(camera);\n\n// draw command\ntri.draw();\nquad.draw();\ncube.draw();\nsphere.draw();\nVulkanContext::getInstance()->drawEnd();\nglfwPollEvents();\n}\ntri.destroy();\nquad.destroy();\ncube.destroy();\nsphere.destroy();\nVulkanContext::getInstance()->cleanup();\nglfwDestroyWindow(window);\nglfwTerminate();\nreturn 0;\n}\n```"]