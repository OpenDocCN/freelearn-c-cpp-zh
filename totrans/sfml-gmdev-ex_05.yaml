- en: Chapter 5. Can I Pause This? – Application States
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 我能暂停吗？ – 应用程序状态
- en: 'A piece of software like a video game is rarely as simple as the term suggests.
    Most of the time, it''s not just the game mechanics and rendering one has to deal
    with in such an application. Nowadays, an industry-standard product also includes
    a nice introduction animation before the game begins. It also has a menu for the
    player to tinker with in order to start playing the game, manage the different
    settings it offers, view the credits or quit the application. On top of that,
    the title of this chapter also suggests the possibility of putting your game on
    pause for a moment or two. In hindsight, it''s simple conveniences like this that
    draw the line in the sand between a game in its early stages, that''s awkward
    to navigate and possibly confusing, and a product that offers the same level of
    control as most games on the market. To supply the backbone to such an idea, in
    this chapter we will be covering:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一款软件，如视频游戏，很少像术语所暗示的那样简单。大多数时候，你不仅要处理游戏机制和渲染，还要处理这种应用程序。如今，行业标准的产品在游戏开始之前还包括一个很好的开场动画。它还有一个菜单，玩家可以用来开始游戏，管理它提供的不同设置，查看版权信息或退出应用程序。除此之外，本章标题还暗示了暂停游戏一会儿的可能性。事后看来，这样的简单便利性正是区分早期游戏（操作尴尬，可能令人困惑）和提供与市场上大多数游戏相同控制水平的产品之间的界限。为了为这样的想法提供支撑，在本章中，我们将涵盖以下内容：
- en: Implementing the state manager
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现状态管理器
- en: Upgrading the event manager to handle different states
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级事件管理器以处理不同状态
- en: Creating different states for the introduction, main menu and game-play sections
    of our game
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的游戏介绍、主菜单和游戏玩法部分创建不同的状态
- en: Providing the means to pause the game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供暂停游戏的方法
- en: Implementing state blending
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现状态混合
- en: Stringing the states together to create cohesive application flow
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将状态串联起来以创建连贯的应用程序流程
- en: What is a state?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是状态？
- en: Before we get into any kind of implementation, it's necessary to understand
    what we're dealing with. If you've been reading up on any kind of game development
    material before, you probably came across the term **state**. It can mean different
    things, depending on its context. In this case, a state is any one of the many
    different layers of your game, like the main menu, the intro that plays before
    the menu is shown, or the actual game-play. Naturally, each one of these layers
    has its own way of updating itself and rendering its contents onto the screen.
    The game developer's job when utilizing this system is to break down a given problem
    into separate, manageable states and transitions between them. This essentially
    means that if you are presented with the problem of having a menu in the game,
    the solution would be creating two states, one for the menu and one for your game-play,
    and transitioning between the two at appropriate times.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始任何类型的实现之前，理解我们所处理的内容是必要的。如果你之前阅读过任何类型的游戏开发材料，你可能已经遇到了术语**状态**。它可以根据上下文有不同的含义。在这种情况下，状态是游戏中的许多不同层次之一，比如主菜单、在显示菜单之前播放的介绍，或者实际的游戏玩法。自然地，这些层次中的每一个都有自己的方式来更新自己并将内容渲染到屏幕上。当利用这个系统时，游戏开发者的工作是将给定的问题分解成单独的、可管理的状态以及它们之间的转换。这本质上意味着，如果你面临在游戏中添加菜单的问题，解决方案将是创建两个状态，一个用于菜单，一个用于你的游戏玩法，并在适当的时候在这两个状态之间进行转换。
- en: The most simplistic approach
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最简单的方法
- en: 'Let''s begin by illustrating the most common approach newcomers take in order
    to solve this problem. It starts by enumerating all the possible states a game
    could have:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从新手解决这个问题的最常见方法开始说明。它首先列举了游戏可能具有的所有可能状态：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Good start. Now let''s put it to work by simply using a `switch` statement:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的开始。现在让我们通过简单地使用`switch`语句来使用它：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The same goes for drawing it on screen:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在屏幕上绘制它：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While this approach is okay for really small games, scalability here is completely
    out of the question. First of all, the switch statements are going to continue
    to grow when more states are added. Assuming we keep the functionality for updating
    and rendering a specific state localized to just one method, the number of these
    methods will also continue to grow by at least two methods per state, one of them
    being used for updating and another for rendering. Keep in mind, that's the *minimal*
    amount of expansion needed in order to support an extra state. If we also process
    events for each state individually or perform some kind of additional logic like
    *late updating*, that's four switch statements, one extra switch branch for each
    state and four extra methods that have to be implemented and added to the branches.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法对于非常小的游戏来说是可行的，但可扩展性在这里完全是个问题。首先，随着状态的增加，switch语句将继续增长。假设我们保持更新和渲染特定状态的功能仅本地化到一种方法，那么这些方法的数量也将随着每个状态至少增加两种方法而增长，其中一种用于更新，另一种用于渲染。记住，这是为了支持额外状态所需的**最小**扩展量。如果我们还为每个状态单独处理事件或执行某种类型的附加逻辑，如**延迟更新**，那么就是四个switch语句，每个状态一个额外的switch分支，以及四个必须实现并添加到分支中的额外方法。
- en: 'Next, consider state transitions. If, for whatever reason, you want to render
    two states at the same time for a short while, this entire approach collapses.
    It is possible to still somehow string that functionality together by tying up
    a bunch of flags or creating combination states as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，考虑状态转换。如果你出于某种原因想在短时间内同时渲染两个状态，整个方法就会崩溃。仍然可以通过绑定一串标志或创建如下组合状态来以某种方式将那种功能组合在一起：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This just keeps getting messier by the minute, and we haven't even got to expand
    our already large switch statements yet, let alone implement all the states we
    want!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种混乱的情况正变得越来越严重，我们甚至还没有开始扩展我们已有的庞大的switch语句，更不用说实现我们想要的全部状态了！
- en: 'If you still aren''t thinking about migrating to a different tactic by now,
    consider this one final point: resources. If you''re keeping all of the data from
    all of the possible states a game might have loaded at the same time, you may
    have quite a bit of a problem on your hands from the point of efficiency. You
    may dynamically allocate classes that represent certain states and check for when
    they''re not in use anymore somehow to de-allocate them, however that''s additional
    clutter in your already mostly unreadable code-base, and since you''re already
    thinking of using classes, why not do it better?'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你到现在还没有考虑过迁移到不同的策略，请考虑以下最后一个观点：资源。如果你同时加载了游戏可能具有的所有可能状态的所有数据，那么从效率的角度来看，你可能会遇到相当大的问题。你可以动态分配代表某些状态的类，并检查它们何时不再使用，从而以某种方式释放它们，然而，这将在你已经几乎无法阅读的代码库中增加额外的混乱，而且既然你已经考虑使用类，为什么不做得更好呢？
- en: Introducing the state pattern
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍状态模式
- en: 'All of the problems mentioned previously can be avoided after some careful
    white-boarding and consideration. The possibility was brought up earlier of different
    game states simply being localized to their own classes. All of these classes
    will share the same methods for being updated and rendered, which makes **inheritance**
    the word of the hour. Let''s take a look at our base state header:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在经过一些仔细的白板讨论和考虑之后，之前提到的问题都可以避免。之前已经提出过，不同的游戏状态可以简单地本地化到它们自己的类中。所有这些类都将共享相同的更新和渲染方法，这使得**继承**成为了当务之急。让我们看看我们的基础状态头文件：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, you'll notice we're using a *forward declaration* of the `StateManager`
    class. The base class doesn't really need to know anything about the way our state
    manager will be implemented, only that it needs to keep a pointer to it. This
    is also done in order to avoid *recursive definitions*, because the `StateManager`
    class header needs to include the `BaseState` class header.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你会注意到我们正在使用`StateManager`类的**前向声明**。基类实际上不需要了解我们的状态管理器将如何实现，只需要知道它需要保持对其的指针。这样做也是为了避免**递归定义**，因为`StateManager`类头文件需要包含`BaseState`类头文件。
- en: Since we want to enforce the use of the same methods throughout all states,
    we make them *purely virtual*, which means that the class inheriting from `BaseState`
    has to implement each and every one of them in order for the project to compile.
    The methods that any derived class has to implement consist of `OnCreate` and
    `OnDestroy`, which get invoked when the state is created and pushed on the stack,
    and later removed from the stack, `Activate` and `Deactivate`, which are called
    once a state is moved to the top of the stack as well as when it gets removed
    from the top position, and lastly, `Update` and `Draw`, which are used for updating
    the state and drawing its contents.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在整个状态中强制使用相同的方法，我们将它们定义为**纯虚**的，这意味着从 `BaseState` 继承的类必须实现每一个，以便项目可以编译。任何派生类必须实现的方
    法包括 `OnCreate` 和 `OnDestroy`，这些方法在状态被创建并推入栈中时调用，稍后从栈中移除，`Activate` 和 `Deactivate`，这些方法在状态被移动到栈顶以及从栈顶位置移除时调用，最后是
    `Update` 和 `Draw`，这些方法用于更新状态和绘制其内容。
- en: 'One last thing to note about this class is that it has a pair of flags: `m_transparent`
    and `m_transcendent`. These flags indicate if this state also needs to render
    or update a state that came before it. This eliminates the need for countless
    enumerations of different transitions between states and can be done automatically
    without any additional expansion.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个类的一个需要注意的最后一点是，它有一对标志：`m_transparent` 和 `m_transcendent`。这些标志表示这个状态是否也需要渲染或更新其之前的状态。这消除了对状态之间不同转换的无数枚举的需求，并且可以自动完成，无需任何额外的扩展。
- en: Defining common types
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义常见类型
- en: 'One thing that we''re definitely going to keep from the previous example is
    the enumeration table of the state types:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定要保留从上一个示例中的状态类型枚举表：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Having the state types enumerated is convenient and it helps with automating
    the state creation, as you will see later on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将状态类型枚举出来既方便又有助于自动化状态创建，您稍后将会看到。
- en: 'Another common type we need to keep around is the device context we''ll be
    using with our states. Don''t be confused by the name, it simply means having
    a pointer to some of our most commonly used classes or "devices." Because there''s
    more than one, it''s quite useful to define a simple structure that will keep
    around pointers to the main window class and the event manager:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要保留的另一个常见类型是我们将与状态一起使用的设备上下文。不要被这个名字迷惑，它仅仅意味着有一个指向我们最常用的一些类或“设备”的指针。因为不止一个，定义一个简单的结构来保留指向主窗口类和事件管理器的指针非常有用：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This can and will be expanded later when needed, in order to hold information
    about the player and other assistant classes that deal with resource allocation,
    sound and networking.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在需要时进行扩展，以保存有关玩家和其他处理资源分配、声音和网络辅助类的信息。
- en: The state manager class
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态管理类
- en: 'Now that we have our helper structures set up, let''s actually define the types
    that will be used to hold information in our state manager class. As always, we
    will be using type definitions, the beauty of which is the fact that they reduce
    the amount of code you have to change in a case of modifying something about the
    type definition. Let''s take a look at the state container type first:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了辅助结构，让我们实际定义将在状态管理类中使用的类型，以保存信息。像往常一样，我们将使用类型定义，其美妙之处在于它们减少了在修改类型定义时需要更改的代码量。让我们首先看看状态容器类型：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once again, we're using a vector. The element type is a pair of our state type
    and a pointer to a `BaseState` type object. You might be wondering why a map isn't
    a better choice, and the answer depends on your idea of implementation, however,
    one major factor is that a map doesn't keep a stack-like order in the container,
    which is important if we want our state manager to work correctly.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们正在使用一个向量。元素类型是我们状态类型和指向 `BaseState` 类型对象的指针的配对。你可能想知道为什么映射不是更好的选择，答案取决于你的实现想法，然而，一个主要因素是映射在容器中不保持类似栈的顺序，这对于我们希望状态管理器正确工作来说非常重要。
- en: 'One of the design decisions in the state manager class also requires a container
    of state types, so let''s define that:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 状态管理类中的一个设计决策也需要一个状态类型的容器，让我们定义一下：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, it's simply a vector of the `StateType` enumeration types.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它只是一个 `StateType` 枚举类型的向量。
- en: 'The last type we need to define is a container for custom functions that will
    serve as a way of automatically producing objects of different types derived from
    the `BaseState` class:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义的最后一个类型是用于存储自定义函数的容器，这些函数将作为自动生成从 `BaseState` 类派生的不同类型对象的手段：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We're using an unordered map here in order to map a specific state type to a
    specific function that will generate that type. If that sounds confusing now,
    be patient. It will be covered more thoroughly when we actually use it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用无序映射来将特定的状态类型映射到将生成该类型的特定函数。如果现在听起来很困惑，请耐心等待。当我们实际使用它时，将会更详细地介绍。
- en: Defining the state manager class
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义状态管理器类
- en: 'All the individual bits and pieces we needed to actually bang out a header
    for the state manager class are now present, so let''s write it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的所有单个部分现在都已齐备，因此让我们编写它：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The constructor takes in a pointer to the `SharedContext` type we talked about
    earlier, which will be created in our main `Game` class. Predictably enough, the
    state manager also employs the use of `Update` and `Draw` methods, because it
    will be operated by the `Game` class, and it's nice to keep the interface familiar.
    For convenience sake, it offers helper methods for obtaining the context as well
    as determining if it currently has a certain state on the stack.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受一个指向我们之前提到的 `SharedContext` 类型的指针，它将在我们的主 `Game` 类中创建。不出所料，状态管理器也使用了 `Update`
    和 `Draw` 方法，因为它将由 `Game` 类操作，并且保持接口熟悉是件好事。为了方便起见，它还提供了获取上下文以及确定当前是否具有某个状态在栈上的辅助方法。
- en: Concluding the public methods, we have `SwitchTo`, which takes in a state type
    and changes the current state to one that corresponds to said type, and `Remove`,
    for removing a state from the state stack by its type.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共方法结束时，我们有 `SwitchTo`，它接受一个状态类型并将当前状态更改为与该类型相对应的状态，以及 `Remove`，用于通过其类型从状态栈中删除状态。
- en: If you looked at the class definition from top to bottom, you may have noticed
    that we have a `TypeContainer` member called `m_toRemove`. In order to ensure
    smooth and error-free transitions, we cannot simply delete any state we want from
    the state container at any time. A simple solution here is keeping track of the
    state types we want to remove and only removing them when they're no longer being
    used, which is what the `ProcessRequests` method does. It is called last in the
    game loop, which ensures that the states in the `m_toRemove` container are no
    longer in use.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从上到下查看类定义，你可能已经注意到我们有一个名为 `m_toRemove` 的 `TypeContainer` 成员。为了确保平稳且无错误的转换，我们不能在任何时候随意从状态容器中删除任何状态。这里的简单解决方案是跟踪我们想要删除的状态类型，并且只有在它们不再被使用时才删除它们，这就是
    `ProcessRequests` 方法所做的工作。它在游戏循环的最后被调用，这确保了 `m_toRemove` 容器中的状态不再被使用。
- en: Let's continue with the more advanced private methods and implementation of
    our state manager class in the next section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节继续介绍更高级的私有方法和状态管理器类的实现。
- en: Implementing the state manager
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现状态管理器
- en: 'In order to maintain the automated approach of creating our states on the heap,
    we must have some way of defining how they''re created. The `m_stateFactory` member
    is a map that links a state type to a `std::function` type, which we can be set
    to hold a body of a function through use of the lambda expression:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们在堆上自动创建状态的自动化方法，我们必须有一种定义它们如何创建的方式。`m_stateFactory` 成员是一个将状态类型映射到 `std::function`
    类型的映射，我们可以通过使用 lambda 表达式来设置它以包含函数体：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The code above maps the type `l_type` in the `m_stateFactory` map to a function
    that simply returns a pointer to newly allocated memory. We''re using templates
    here in order to reduce the amount of code. Because each state requires a pointer
    to the `StateManager` class in its constructor, we pass the *this pointer* in.
    We can now register different states like so:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将 `m_stateFactory` 映射中的 `l_type` 类型映射到一个简单的函数，该函数返回新分配的内存的指针。我们在这里使用模板来减少代码量。因为每个状态在其构造函数中都需要指向
    `StateManager` 类的指针，所以我们传递了 *this 指针*。我们现在可以像这样注册不同的状态：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It''s time to begin implementing the rest of the class now. Let''s take a look
    at the destructor:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始实现类的其余部分了。让我们看看析构函数：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because we localize all the dynamic memory allocation of any states to this
    class, it's imperative that we also free the memory appropriately. Iterating over
    all the states and deleting the second value of the pair which makes up the element
    does just that.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将任何状态的动态内存分配都本地化到这个类中，因此我们也有必要适当地释放内存。遍历所有状态并删除组成元素的配对的第二个值正是这样做的。
- en: 'Next, let''s take a look at how to implement the draw method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何实现绘制方法：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, just like the `Update` method, we check if the state container has *at
    least one* state. If it does, we check the most recently added one's **transparency
    flag**, as well as if there's more than one state on the stack, otherwise the
    transparency would be useless. If there's only one state on the stack or if the
    current state isn't transparent, we simply invoke its `Draw` method. Otherwise,
    things get a little bit more interesting.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，就像 `Update` 方法一样，我们检查状态容器是否至少有一个状态。如果有，我们检查最近添加的一个的**透明度标志**，以及栈上是否只有一个状态，否则透明度将没有用。如果栈上只有一个状态或者当前状态不是透明的，我们只需调用它的
    `Draw` 方法。否则，事情会变得有点更有趣。
- en: In order to correctly render transparent states, we must call their respective
    `Draw` methods in a correct order, where the latest state on the stack is drawn
    on screen last. To do that, it's necessary to iterate through the state vector
    *backwards* until a state is found that is either not transparent or is the first
    state on the stack, which is what the `while` loop does. After such state is found,
    the `Draw` calls of all states from and including the one found, up to the very
    last one are invoked in the `for` loop. This effectively renders multiple states
    at once in correct order.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确渲染透明状态，我们必须以正确的顺序调用它们的相应 `Draw` 方法，其中栈上最新的状态最后被绘制到屏幕上。为此，需要从状态向量中向后迭代，直到找到一个既不是透明的状态，或者是栈上的第一个状态，这正是
    `while` 循环所做的事情。找到这样的状态后，`for` 循环将调用从找到的状态开始，包括最后一个状态的所有状态的 `Draw` 方法。这有效地以正确的顺序一次渲染多个状态。
- en: 'A fairly similar procedure is followed when updating states:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 更新状态时遵循相当类似的程序：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The state's *transcendence* flag is checked first, in order to determine whether
    the top state allows others to be updated. The state or states that need to get
    updated then have their `Update` methods invoked with the elapsed time passed
    in as the argument, more commonly known as **delta time**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查状态的单**超越**标志，以确定顶部状态是否允许其他状态更新。然后需要更新的状态或状态的 `Update` 方法被调用，传入的参数是经过的时间，通常称为**delta
    time**。
- en: 'As always, we need to define some helper methods for a class to be truly flexible
    and useful:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 总是如此，我们需要为类定义一些辅助方法，使其真正灵活和有用：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first method of obtaining the context is pretty straightforward. All it
    does is return a pointer to the `m_shared` member. The second method simply iterates
    over the `m_states` container until it finds a state with the type `l_type` and
    returns `true`. If it doesn't find such state, or if the state is found but it's
    about to be removed, it returns `false`. This gives us a way to check if a certain
    state is on the stack.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 获取上下文的第一种方法相当直接。它只是返回对 `m_shared` 成员的指针。第二种方法简单地遍历 `m_states` 容器，直到找到一个类型为 `l_type`
    的状态并返回 `true`。如果没有找到这样的状态，或者找到了但即将被移除，它返回 `false`。这为我们提供了一种检查特定状态是否在栈上的方法。
- en: 'Having a way to remove a state is just as necessary as having a way of adding
    one. Let''s implement the public method `Remove`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以移除状态，就像有方法添加状态一样必要。让我们实现公共方法 `Remove`：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This method pushes back a state type into the `m_toRemove` vector for later
    removal, which is then processed by this method:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将状态类型推入 `m_toRemove` 向量中，稍后由该方法处理：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The last method of this class that ever gets called, `ProcessRequests`, simply
    iterates over the `m_toRemove` vector and invokes a private method `RemoveState`
    which takes care of actual resource de-allocation. It then removes the element,
    ensuring the container is cleared.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中最后被调用的方法 `ProcessRequests` 简单地遍历 `m_toRemove` 向量，并调用一个私有方法 `RemoveState`，该方法负责实际的资源释放。然后它移除元素，确保容器被清空。
- en: 'Being able to change the current state is of paramount importance, which is
    what the `SwitchTo` method takes care of:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 能够更改当前状态至关重要，这正是 `SwitchTo` 方法所处理的：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, you will notice that we access the event manager through our shared context
    and call a method `SetCurrentState`. We haven't yet gotten around to adding it,
    however it will be covered shortly. What it does is it simply modifies an internal
    data member of the event manager class, which keeps track of which state the game
    is in.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你会注意到我们通过共享上下文访问事件管理器并调用一个名为 `SetCurrentState` 的方法。我们还没有添加它，但是很快就会涉及到。它的作用是简单地修改事件管理器类的一个内部数据成员，这个成员跟踪游戏处于哪个状态。
- en: Next, we must find the state with the type we want to switch to, so we iterate
    over the state vector. If we have a match, the current state that's about to be
    pushed back has its `Deactivate` method called to perform whatever functionality
    it has to, in case the state cares about when it gets moved down. Then, we create
    two temporary variables to hold the state type and the pointer to a state object,
    so we don't lose that information when the element we're interested in is removed
    from the vector by calling `erase`. After doing that, all the *iterators* to the
    state container are invalidated, but it doesn't matter in our case, because we
    no longer need any. Moving the desired state is now as simple as pushing back
    another element onto the vector and passing in our temporary variables. Then,
    we call the `Activate` method of the state that just got moved in case it has
    any logic that is needed to be performed at that time.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须找到我们想要切换到的类型的状态，因此我们遍历状态向量。如果我们找到一个匹配项，即将被推回的当前状态将调用其 `Deactivate` 方法以执行任何必要的功能，以防状态关心它被移动下来的时刻。然后，我们创建两个临时变量来保存状态类型和状态对象的指针，这样在通过调用
    `erase` 从向量中移除我们感兴趣的元素时，我们不会丢失这些信息。完成这些后，所有指向状态容器的迭代器都无效了，但在我们的情况下，这并不重要，因为我们不再需要任何。移动所需状态现在就像将另一个元素推回向量并传入我们的临时变量一样简单。然后，我们调用刚刚移动进来的状态的
    `Activate` 方法，以防它在那时需要执行任何逻辑。
- en: If the state with `l_type` isn't found, creating one is necessary. First, however,
    it's important to check if there's at least one state for which to call the `Deactivate`
    method, and call it, if there is one. After invoking a private method `CreateState`
    and passing in the state type, we grab the element from the state vector that
    was added most recently by `CreateState`, and call `Activate`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到具有 `l_type` 的状态，则需要创建一个。然而，首先，重要的是检查是否至少有一个状态可以调用 `Deactivate` 方法，如果有，就调用它。在调用私有方法
    `CreateState` 并传入状态类型之后，我们从状态向量中获取最近由 `CreateState` 添加的元素，并调用 `Activate`。
- en: 'It''s time to see what exactly goes into creating a state:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看创建一个状态究竟需要包含哪些内容了：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A state factory iterator gets created and checked for matching the iterator
    returned by the `end()` method of `std::unordered_map`, allowing us to make sure
    a state with such type can be created. If it can, a pointer of type `BaseState`,
    called `state` is created. It catches the return result of our iterator's second
    value getting invoked as a function, which if you remember was the `std::function`
    type and returns a pointer to a newly created state class. This is how we put
    the previously mentioned "factory" to work. After retrieving a pointer to the
    newly allocated memory for a state, we simply push it back onto the state vector
    and call `OnCreate` for the state to do its internal logic regarding being freshly
    created.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个状态工厂迭代器并检查它是否与 `std::unordered_map` 的 `end()` 方法返回的迭代器匹配，这样我们可以确保可以创建具有该类型的状态。如果可以，创建一个类型为
    `BaseState` 的指针，称为 `state`。它捕获了我们的迭代器第二个值作为函数调用的返回结果，如果你记得，那是 `std::function`
    类型，并返回一个指向新创建的状态类的指针。这就是我们如何使用之前提到的“工厂”。在检索到状态的新分配内存的指针后，我们只需将其推回状态向量并调用 `OnCreate`
    以执行状态关于刚刚创建的内部逻辑。
- en: 'How do we go about removing a state? Let''s take a look:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何移除一个状态？让我们看看：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As always when dealing with `std::vector` types, we iterate over it until a
    match is found. Removing the actual state begins by calling the `OnDestroy` method
    of said state, again, just so it can perform whatever logic it needs in order
    to be ready for removal. Then we simply de-allocate the memory by using the `delete`
    keyword. Finally, we erase the element from the state vector and return from the
    method.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理 `std::vector` 类型时，我们遍历它直到找到匹配项。移除实际状态的过程是从调用该状态的 `OnDestroy` 方法开始的，再次强调，这是为了让它执行任何必要的逻辑以便准备好被移除。然后我们简单地使用
    `delete` 关键字来释放内存。最后，我们从状态向量中删除元素并从方法中返回。
- en: Improving the Event Manager class
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进事件管理器类
- en: 'Having different states in a game will, without a shadow of a doubt, create
    situations where the same key or event will be needed by at least two of the states.
    Let''s say we have a menu, where navigation is done by pressing the arrow keys.
    That''s all fine, but what if the game-play state also registers the use of arrow
    keys and sets up its own callbacks? The very best case scenario is that callbacks
    from all states will be invoked at the same time and create weird behavior. Things
    get worse, however, when you have function pointers to methods that are no longer
    in memory, especially since nobody likes application crashes. A simple way of
    dealing with this problem is grouping the callbacks together by state and only
    invoking them if the current state is that of a callback. This obviously means
    some re-definition of the types being dealt with:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中存在不同的状态无疑会创造需要相同键或事件的场景，至少有两个状态会需要。假设我们有一个菜单，通过按箭头键进行导航。这都很好，但如果游戏状态也注册了箭头键的使用并设置了它自己的回调呢？最好的情况是所有状态的回调将同时被调用并产生奇怪的行为。然而，当你有指向不再内存中的方法的函数指针时，事情变得更糟，特别是没有人喜欢应用程序崩溃。处理这个问题的简单方法是将回调按状态分组，并且只有在当前状态是回调状态时才调用它们。这显然意味着需要对正在处理的数据类型进行一些重新定义：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Things are getting a little bit more complicated now. What used to be the `Callback`
    definition is now renamed `CallbackContainer`. We only want one of those per state,
    so it means having to use another map, which is where the new `Callback` definition
    comes in. It maps a state type to a `CallbackContainer` type, so that we can have
    only one `CallbackContainer` per state in addition to only one callback function
    per name.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事情变得有点复杂了。之前是`Callback`定义的地方现在被重命名为`CallbackContainer`。我们每个状态只想有一个这样的，这意味着我们需要使用另一个映射，这就是新的`Callback`定义出现的地方。它将状态类型映射到`CallbackContainer`类型，这样我们就可以在每个状态中只有一个`CallbackContainer`，同时每个名称也只有一个回调函数。
- en: 'Despite these changes, the declaration for `m_callbacks` in the event manager
    header remains the same:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这些变化，事件管理器头文件中`m_callbacks`的声明保持不变：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There is one minor addition to the class data member list, and that is the
    current state:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 类数据成员列表中增加了一个小的内容，那就是当前状态：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'What does change, however, are the methods for adding, removing and utilizing
    callbacks. Let''s adapt the `AddCallback` method to these changes:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，改变的是添加、移除和利用回调的方法。让我们将`AddCallback`方法适应这些变化：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first thing to note is that we have a new argument `l_state` in the method's
    footprint. Next, we attempt to insert a new element to the `m_callbacks` map,
    pairing together the state argument and a new `CallbackContainer`. Since a map
    can only have one element with a specific index, in this case it's the state type,
    the `emplace` method always returns a pair of elements, the first of which is
    an iterator. If the insertion succeeded, the iterator points to the element that
    was newly created. On the other hand, if an element with a specified index already
    existed, the iterator points to that element instead. This is a good strategy
    to use, because we need that iterator no matter what, and if there is no element
    with the index we specified, we're going to want to insert one.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们在方法签名中有一个新的参数`l_state`。接下来，我们尝试向`m_callbacks`映射中插入一个新元素，将状态参数和一个新的`CallbackContainer`配对。由于映射只能有一个具有特定索引的元素，在这种情况下是状态类型，`emplace`方法总是返回一个元素对，其中第一个元素是一个迭代器。如果插入成功，迭代器指向新创建的元素。另一方面，如果已经存在具有指定索引的元素，迭代器将指向该元素。这是一个很好的策略，因为我们无论如何都需要那个迭代器，如果没有我们指定的索引的元素，我们想要插入一个。
- en: After the function binding, which remains unchanged, we need to insert the actual
    callback into the `CallbackContainer` type, which is the second value in the pair
    that makes up the `m_callbacks` elements. The second value of a pair that gets
    returned by the insert method of a map is a Boolean that represents the success
    of an insertion, and that's what gets returned for error checking.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 函数绑定之后，它保持不变，我们需要将实际的回调插入到`CallbackContainer`类型中，这是构成`m_callbacks`元素的配对中的第二个值。映射插入方法返回的配对的第二个值是一个布尔值，表示插入的成功，这就是用于错误检查返回的内容。
- en: 'Now let''s take a look at revising the removal of callbacks:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看修改回调移除的方法：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This one's fairly simple. All we do is use the find method twice instead of
    once. First, we `find` the state pair in the first map, then we `erase` the actual
    callback by its name in the second map, just like before.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相当简单。我们只是使用`find`方法两次而不是一次。首先，我们在第一个映射中`find`到状态对，然后就像之前一样，通过名称在第二个映射中`erase`实际的回调。
- en: 'The last part of making this work just the way we want is fixing the way callback
    functions are actually called. Due to the type definitions that got changed, the
    way we invoke callbacks is also slightly different:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使其按我们想要的方式工作的最后一部分是修复回调函数实际调用的方式。由于类型定义发生了变化，我们调用回调的方式也略有不同：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The main difference here is that we have two states for which callbacks get
    checked now, not just one: `stateCallbacks` and `otherCallbacks`. The former is
    quite obvious, we''re simply using `find` to obtain the map of all callbacks for
    the current state. The latter, however, passes in a state type value of `0`, which
    isn''t a valid state type, since the enumeration starts at `1`. This is done because
    even in the case of having multiple states in a game, we still want to process
    global callbacks for the `Window` class, as well as other classes that extend
    beyond the scope of simple states and persist all the way throughout the life
    of an application. Anything with the state type `0` will be invoked regardless
    of which state we''re in.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别是现在有两个状态需要检查回调，而不仅仅是其中一个：`stateCallbacks`和`otherCallbacks`。前者相当明显，我们只是使用`find`来获取当前状态的回调映射。然而，后者传递了一个状态类型值`0`，这不是一个有效的状态类型，因为枚举从`1`开始。这样做是因为即使在游戏中存在多个状态的情况下，我们仍然希望处理`Window`类的全局回调，以及其他超出简单状态范围并持续整个应用程序生命周期的类。任何状态类型为`0`的都将被调用，无论我们处于哪个状态。
- en: The rest is fairly straightforward. Just like before, we're using the find method
    of the second value in the iterator that gets returned from the first search,
    which is our actual callback map. If a match is found, the function gets invoked.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 其余部分相当直接。就像之前一样，我们使用从第一次搜索返回的迭代器的第二个值中的`find`方法，这实际上是我们真正的回调映射。如果找到匹配项，函数将被调用。
- en: 'One last thing we want to do here is modify the `keys.cfg` file to hold some
    extra keys for us in order to use them later:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里想要做的最后一件事是修改`keys.cfg`文件，以便为我们保留一些额外的键，以便以后使用：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `Intro_Continue` binding represents a Spacebar "key down" event, `Mouse_Left`
    is the mouse left click event, `Key_Escape` is bound to the *ESC* "key down" event,
    and lastly, `Key_P` represents the letter *P* "key down" event.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intro_Continue`绑定代表空格键的“按下”事件，`Mouse_Left`是鼠标左键点击事件，`Key_Escape`绑定到*ESC*“按下”事件，最后，`Key_P`代表字母*P*“按下”事件。'
- en: Incorporating the state manager
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成状态管理器
- en: 'While it''s not quite time for fanfare, excitement is definitely in order because
    we can finally put our brand new `StateManager` class to work! The `Game` class
    header modification is a good start:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然现在还不是欢庆的时候，但兴奋之情确实在所难免，因为我们可以最终开始使用我们全新的`StateManager`类了！对`Game`类头文件的修改是一个良好的开端：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Sticking a new data member to the `Game` class and adding a new method for
    late updating are all the adjustments that need to be made in the header. Let''s
    adjust the `Game` constructor to initialize the state manager:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将新的数据成员附加到`Game`类并添加一个新的方法以进行后期更新，这些都是需要在头文件中进行的调整。让我们调整`Game`构造函数以初始化状态管理器：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Naturally, the first thing we do is create the context that will be used by
    all of the states and pass it into the constructor of the state manager. We then
    begin the "domino effect" by switching to the introduction state, which will in
    due time switch to other states and force the flow of the application.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们首先创建将被所有状态使用的上下文，并将其传递给状态管理器的构造函数。然后我们开始“多米诺效应”，切换到介绍状态，这将最终切换到其他状态并强制应用程序的流程。
- en: 'Lastly, let''s adjust the three most important methods of the `Game` class:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们调整`Game`类中最重要三种方法：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'That''s about as straightforward as it can be. One thing to note is that the
    `RestartClock` method is now called by the `LateUpdate`, which means we have to
    adjust the `main.cpp` file as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经很直接了。需要注意的是，`RestartClock`方法现在由`LateUpdate`调用，这意味着我们必须按照以下方式调整`main.cpp`文件：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Everything seems to be in order now. Compiling and launching the application
    should give you a very impressive black screen. Hoorah! Let's actually create
    some states for the game in order to honor the work that was put into this.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切似乎都井然有序。编译并启动应用程序应该会给你一个非常令人印象深刻的黑色屏幕。太棒了！让我们实际上为游戏创建一些状态，以表彰为此付出的努力。
- en: Creating the intro state
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建介绍状态
- en: 'It seems rather fitting to start with the intro state, in turn giving the state
    manager a bit of an introduction at the same time. As always, a good place to
    start is with the header file, so let''s get going:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从介绍状态开始似乎很合适，这样同时也给状态管理器一个介绍。一如既往，一个好的开始是从头文件开始，让我们开始吧：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `State_Intro` class, just like all the other state classes we'll build,
    inherits from the `BaseState` class. All of the purely virtual methods of the
    base class have to be implemented here. In addition to that, we have a unique
    method named `Continue` and some private data members that will be used in this
    state. Predictably enough, we will be rendering a sprite on screen, as well as
    some text. The floating point data member on the very bottom will be used to keep
    track of how much time we have spent in this state, in order to present the user
    with the ability to hit the Spacebar key after a certain interval to proceed into
    the main menu. The `Continue` method is responsible for handling that transition.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`State_Intro` 类，就像我们将要构建的所有其他状态类一样，继承自 `BaseState` 类。基类中的所有纯虚方法都必须在这里实现。除此之外，我们还有一个名为
    `Continue` 的独特方法以及一些将在该状态下使用的私有数据成员。不出所料，我们将在屏幕上渲染一个精灵以及一些文本。位于最底部的浮点数据成员将用于跟踪我们在该状态下花费的时间，以便在经过一定间隔后，用户能够按下空格键进入主菜单。`Continue`
    方法负责处理这个转换。'
- en: Implementing the intro state
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现介绍状态
- en: 'We are getting close to finishing our first functional state! All that needs
    to be finished now is the actual implementation of the methods declared in the
    header file, and we''re golden. Let''s begin by including the header file of our
    class in `State_Intro.cpp`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将完成我们的第一个功能状态！现在需要完成的是在头文件中声明的实际方法的实现，这样我们就可以大功告成了。让我们首先在 `State_Intro.cpp`
    中包含我们类的头文件：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note the second line. Because the `StateManager` class is forwardly declared
    in the `BaseState` header, we *must* include the state manager header in the implementation
    file. This is true for any state we build in the future, including this one.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第二行。因为 `StateManager` 类在 `BaseState` 头文件中是前向声明的，所以我们*必须*在实现文件中包含状态管理器头文件。这对于我们将要构建的任何状态都适用，包括这个。
- en: 'We will never use constructors and destructors of our states to initialize
    or allocate anything and instead rely on the `OnCreate` and `OnDestroy` methods
    in order to retain maximum control of when the resource allocation and de-allocation
    actually happens:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们永远不会使用我们状态的结构体和析构函数来初始化或分配任何东西，而是依赖于 `OnCreate` 和 `OnDestroy` 方法来保持对资源分配和释放实际发生时间的最大控制：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There's quite a bit of code, however, only a tiny portion of it is new to us
    at this point. First, we must initialize our data member `m_timePassed` to zero.
    Next, we obtain the shared context through the use of the state manager pointer
    from the base class, and use it to obtain the current window size.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代码量相当大，但到目前为止，其中只有一小部分对我们来说是新的。首先，我们必须将我们的数据成员 `m_timePassed` 初始化为零。接下来，我们通过从基类使用状态管理器指针来获取共享上下文，并使用它来获取当前窗口大小。
- en: In order to position the `m_text` right in the middle of the screen, we set
    its origin to be the absolute center first, which is done by first obtaining a
    `sf::FloatRect` data type by calling the `getLocalBounds` method of our `sf::text`
    object. The left and top values of the `sf::FloatRect` represent the top left
    corner of the text, which can be used to calculate the center by adding half of
    the rectangle size to it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 `m_text` 正好放置在屏幕中间，我们首先将其原点设置为绝对中心，这是通过首先调用我们的 `sf::text` 对象的 `getLocalBounds`
    方法来获取一个 `sf::FloatRect` 数据类型来完成的。`sf::FloatRect` 的左和上值代表文本的左上角，可以通过向其添加矩形大小的一半来计算中心。
- en: Tip
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If any changes are made to the character size, the string or to the font that
    the `sf::text` object is using, the origin has to be re-calculated, because the
    physical dimensions of the local boundary rectangle are changed too.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对字符大小、字符串或 `sf::text` 对象使用的字体进行了任何更改，则必须重新计算原点，因为局部边界矩形的物理尺寸也发生了变化。
- en: 'The basic idea of this intro state is to have a sprite come down from the top
    of the screen to the middle. After five seconds have passed, some text will appear
    underneath the sprite notifying the user that they can hit the Spacebar in order
    to proceed to the main menu. This is the texture we will be using for the descending
    sprite:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个介绍状态的基本想法是让一个精灵从屏幕顶部下降到中间。经过五秒钟后，一些文本将出现在精灵下方，通知用户可以按空格键进入主菜单。这是我们将会使用的下降精灵纹理：
- en: '![Implementing the intro state](img/B04284_05_01.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![实现介绍状态](img/B04284_05_01.jpg)'
- en: 'The last thing we need to do is to bind the Spacebar key to the `Continue`
    method of our intro class. We do that by obtaining the event manager instance
    through the shared context and setting up the callback, pretty much as we did
    in the previous chapter, except this time we need an additional argument: the
    state type.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的是将空格键绑定到我们介绍类的`Continue`方法。我们通过共享上下文获取事件管理器实例并设置回调来实现，这与上一章的做法几乎相同，只是这次我们需要一个额外的参数：状态类型。
- en: 'Even though this class doesn''t allocate any memory, it''s still important
    it removes its callback when removed, which can be done here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个类没有分配任何内存，但在移除时仍然很重要，它需要移除其回调，这可以在下面这样做：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Just like the `AddCallback` method, removal of callbacks also requires a state
    type as its first argument.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`AddCallback`方法一样，移除回调也要求第一个参数为状态类型。
- en: 'Because we''re dealing with time and movement here, updating this state will
    be necessary:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里处理的是时间和移动，因此更新这个状态将是必要的：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Seeing how it''s only desired for the sprite to be moving until it reaches
    the middle, a five second window is defined. If the total time passed is less
    than that, we add the delta time argument to it for the next iteration and move
    the sprite by a set number of pixels per second in the y direction, while keeping
    x the same. This guarantees vertical movement, which is, of course, completely
    useless, unless we draw everything:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只希望精灵移动到中间，因此定义了一个五秒钟的窗口。如果总时间少于这个值，我们将delta time参数添加到下一次迭代中，并以每秒一定像素数在y方向上移动精灵，同时保持x方向不变。这保证了垂直移动，当然，除非我们绘制一切，否则这是完全无用的：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After obtaining a pointer to a window through the shared context, we draw the
    sprite on screen. If more than five seconds have passed, we also draw the text,
    which notifies the player about the possibility of continuing past the intro state,
    the final piece of the puzzle:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过共享上下文获得窗口指针后，我们在屏幕上绘制精灵。如果已经过去五秒钟以上，我们还会绘制文本，通知玩家可以继续通过介绍状态，这是最后一部分的拼图：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Once again, we check if enough time has passed to continue past this state.
    The actual switching happens when the `SwitchTo` method is called. Because we
    won't need the introduction state on the stack anymore, it removes itself in the
    next line.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 再次检查是否已经过去足够的时间以继续到下一个状态。实际的切换发生在调用`SwitchTo`方法时。由于我们不再需要在栈中保留介绍状态，它将在下一行自行移除。
- en: 'Although we won''t be needing the last two methods, we still need to implement
    empty versions of them, like so:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不需要最后两种方法，但我们仍然需要实现它们的空版本，如下所示：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now it''s time to sound the fanfares! Our first state''s done and is ready
    for use. Building and launching your application should leave you with something
    like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候吹响号角了！我们的第一个状态已经完成，并准备好使用。构建和启动你的应用程序应该会得到类似这样的结果：
- en: '![Implementing the intro state](img/B04284_05_02.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![实现介绍状态](img/B04284_05_02.jpg)'
- en: As illustrated above, the sprite descends all the way to the middle of the screen
    and displays the message about continuing underneath after five seconds. Upon
    hitting Spacebar you will find yourself in a black window because we haven't implemented
    the main menu state yet.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，精灵下降到屏幕中间，并在五秒后显示继续的提示信息。按下空格键后，你将发现自己在一个黑色窗口中，因为我们还没有实现主菜单状态。
- en: From this point on, all the repetitive code will be left out. For complete source
    code, please take a look at the source files of this chapter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，所有重复的代码都将被省略。对于完整的源代码，请查看本章的源文件。
- en: The main menu state
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主菜单状态
- en: 'The main menu of any game out there is a major vein in terms of application
    flow, even though it''s mostly overlooked. It''s time we took a stab at building
    one, albeit a very simplistic version, starting as always with the header file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 任何游戏的主菜单在应用程序流程中都是一个重要的部分，尽管它通常被忽视。是我们尝试构建一个的时候了，尽管是一个非常简化的版本，就像往常一样，从头文件开始：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The unique method to this class is the `MouseClick`. Since we''re dealing with
    a menu here, predictably enough it will be used to process mouse input. For private
    data members, we have a text variable for the title, size, position and padding
    size variables for buttons, drawable rectangles for buttons and text variables
    for button labels. Let''s throw it all together:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类独特的功能是`MouseClick`方法。由于我们在这里处理的是一个菜单，可以预见它将用于处理鼠标输入。对于私有数据成员，我们有一个用于标题的文本变量，按钮的大小、位置和填充大小变量，按钮的可绘制矩形以及按钮标签的文本变量。让我们把它们放在一起：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the method above, all of the graphical elements get set up. The text data
    members get defined, origins are set up, and the labels for individual buttons
    get named. Lastly, the callback for the mouse left click gets set up. This is
    by no means a sophisticated GUI system. A more robust way of actually designing
    one will be covered in later chapters, however, this will suit our needs for now.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述方法中，所有图形元素都得到了设置。定义了文本数据成员，设置了原点，并为单个按钮命名了标签。最后，设置了鼠标左键点击的回调。这绝对不是一个复杂的GUI系统。然而，在后面的章节中，我们将介绍一种更健壮的设计方法，但就目前而言，这将满足我们的需求。
- en: 'When the state gets destroyed, we need to remove its callbacks, as mentioned
    before:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当状态被销毁时，我们需要移除其回调，如前所述：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Upon the state getting activated, we need to check if the main game-play state
    exists on the state stack in order to adjust the "play" button to instead say
    "resume":'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当状态被激活时，我们需要检查主游戏状态是否存在于状态堆栈中，以便调整“play”按钮以显示“继续”：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The text origin has to be recalculated again because the dimensions of the `sf::drawable`
    object are now different.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 文本原点需要重新计算，因为`sf::drawable`对象的尺寸现在不同了。
- en: 'The `MouseClick` method can be implemented as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`MouseClick`方法可以按以下方式实现：'
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: First, we obtain the mouse position from the event information structure, which
    gets passed in as the argument. Then we set up some local floating point type
    variables that will be used to check the boundaries of the buttons and begin looping
    over all the buttons. Because the origins of every button are set to the absolute
    middle, we must adjust the position according to that when checking if the mouse
    position is within the rectangle. If we have a mouse to button collision, an if-else
    statement checks which ID has collided and performs an action accordingly. In
    the case of the "play" button being pressed, we switch to the game state. If the
    exit button is pressed, we invoke the `Window::Close` method through the shared
    context.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从事件信息结构中获取鼠标位置，该结构作为参数传递。然后我们设置一些局部浮点类型变量，这些变量将被用来检查按钮的边界，并开始遍历所有按钮。由于每个按钮的原点都设置为绝对中间，我们必须在检查鼠标位置是否在矩形内时根据这个进行调整。如果我们有一个鼠标到按钮的碰撞，一个if-else语句会检查哪个ID发生了碰撞，并相应地执行操作。在“play”按钮被按下的情况下，我们切换到游戏状态。如果退出按钮被按下，我们通过共享上下文调用`Window::Close`方法。
- en: 'Finally, let''s draw the main menu:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们绘制主菜单：
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: After obtaining the render window pointer through the shared context, drawing
    the entire menu is as easy as iterating a few times to draw a button and a label.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过共享上下文获取渲染窗口指针后，绘制整个菜单就像迭代几次来绘制一个按钮和一个标签一样简单。
- en: 'Upon successful compilation and execution, we''re again presented with the
    intro screen. When hitting spacebar, a main menu opens, looking something like
    this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功编译和执行后，我们再次看到主界面。当按下空格键时，主菜单打开，看起来像这样：
- en: '![The main menu state](img/B04284_05_03.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![主菜单状态](img/B04284_05_03.jpg)'
- en: It's not the prettiest sight in the world, but it gets the job done. Clicking
    the **PLAY** button once again leaves us with a black screen, while hitting **EXIT**
    closes the application. Neat!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是世界上最漂亮的样子，但它完成了工作。点击**PLAY**按钮一次会留下一个黑屏，而点击**EXIT**会关闭应用程序。整洁！
- en: A sample game state
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个示例游戏状态
- en: 'Just to demonstrate the full use of our system, let''s get something bouncing
    on the screen that will demonstrate switching between the menu, game, and paused
    states. For testing purposes, a bouncing mushroom from previous chapters will
    more than suffice. We also need methods for switching to the menu state, as well
    as the paused state. Knowing that, let''s bang out the header for the game-play
    state:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示我们系统的完整使用，让我们在屏幕上得到一些弹跳的东西，这将展示在菜单、游戏和暂停状态之间的切换。为了测试目的，前几章中的弹跳蘑菇就足够了。我们还需要切换到菜单状态和暂停状态的方法。知道了这一点，让我们为游戏状态编写头文件：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We begin, like many other times, with resource allocation and set up of data
    members in the `OnCreate` method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始，就像许多其他时候一样，在`OnCreate`方法中进行资源分配和数据成员的设置：
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After loading the texture and binding the sprite to it, we set up its position,
    define the increment vector, much like before, and add callbacks to our extra
    two methods for switching to different states. Of course, we need to remove them
    upon destruction of the state, like so:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载纹理并将精灵绑定到它之后，我们设置其位置，定义增量向量，就像之前一样，并添加回调到我们额外的两个方法以切换到不同的状态。当然，我们需要在状态销毁时移除它们，如下所示：
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The update method will hold the same code we''ve used previously:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 更新方法将保持我们之前使用的相同代码：
- en: '[PRE50]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The sprite position gets checked, and if it is outside of the window boundaries,
    the increment vector on the appropriate axis gets inverted. Then, the sprite position
    is updated, taking into account the time passed between frames. It''s as regular
    as clockwork. Let''s draw the sprite on the screen:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 检查精灵位置，如果它在窗口边界之外，则适当的轴上的增量向量被反转。然后，更新精灵位置，考虑到帧之间的时间差。就像时钟一样规律。让我们在屏幕上绘制精灵：
- en: '[PRE51]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now let''s implement the methods for switching states:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现切换状态的方法：
- en: '[PRE52]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Notice that the game state does not remove itself here, just like the main menu
    state. This means that it's still alive in memory and is waiting to be pushed
    back to the front of the vector to be updated and rendered again. This allows
    the user to pop back to the main menu and resume the game state at any time without
    losing progress.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，游戏状态在这里并没有删除自己，就像主菜单状态一样。这意味着它仍然在内存中，并等待被推回到向量前面以更新和重新渲染。这使用户能够在任何时间点返回主菜单并恢复游戏状态，而不会丢失进度。
- en: 'Running the application now will transition us through the intro state into
    the main menu. Hitting the **PLAY** button will leave us with a bouncing mushroom,
    just like before:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序将带我们通过介绍状态进入主菜单。按下**PLAY**按钮将出现一个弹跳的蘑菇，就像之前一样：
- en: '![A sample game state](img/B04284_05_04.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![一个示例游戏状态](img/B04284_05_04.jpg)'
- en: Hitting the escape key now will bring you back to the main menu, at which point
    you can choose to click the **RESUME** button to pop back into the game state,
    or the **EXIT** button to quit the application. There's just one more state left
    to implement to fully showcase the abilities of this system!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按下Esc键将带您回到主菜单，此时您可以点击**RESUME**按钮返回游戏状态，或者点击**EXIT**按钮退出应用程序。只剩下一个状态需要实现，才能完全展示这个系统的能力！
- en: The means to pause
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂停的方式
- en: 'One might simply consider navigating to the main menu from the game state as
    a way of putting the game on pause. While that''s technically true, why not explore
    a second option, which looks much trendier than simply popping the main menu open?
    After writing so much code, we deserve a nice looking paused state:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会简单地认为从游戏状态导航到主菜单是将游戏暂停的一种方式。虽然这在技术上是真的，但为什么不探索第二种选项，它看起来比简单地弹出主菜单更时尚？在写了这么多代码之后，我们值得一个看起来很棒的暂停状态：
- en: '[PRE53]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This one is quite simple. Once more, we define an additional method, in this
    case `Unpause`, to switch to a different state. There''s also only two data members
    used in order to draw the text "PAUSED" on screen, as well as a nice semi-transparent
    backdrop, represented by the `sf::RectangleShape`. Let''s implement the `OnCreate`
    method for the last time in this chapter:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个很简单。再次定义一个额外的方法，在这种情况下是`Unpause`，以切换到不同的状态。同时，也只使用了两个数据成员来在屏幕上绘制“PAUSED”文本，以及一个漂亮的半透明背景，由`sf::RectangleShape`表示。让我们在这个章节中最后一次实现`OnCreate`方法：
- en: '[PRE54]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: A distinct difference here is the use of `m_transparent` flag, which is a protected
    data member of the `BaseState` class. Setting it to true means we're allowing
    the state manager to render the state directly behind this one on the state stack.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个显著区别是使用了`m_transparent`标志，它是`BaseState`类的一个受保护的数据成员。将其设置为true意味着我们允许状态管理器直接在状态堆栈中渲染此状态之后的状态。
- en: Besides that, we create a rectangle the size of the entire window and set its
    fill color to black with the alpha channel value of 150 out of the maximum 255\.
    This makes it nice and translucent while darkening everything that's behind it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，我们创建一个与整个窗口大小相同的矩形，并将其填充颜色设置为黑色，alpha通道值为255中的150。这使得它既透明又暗淡，使其背后的所有东西都变暗。
- en: 'The final part of the method above, quite like all the other ones, is adding
    the callback to the `Unpause` method. Upon destruction of this state, it needs
    to be removed like so:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 上文所述方法的最后一部分，与其他所有方法一样，是将回调函数添加到`Unpause`方法中。当此状态被销毁时，需要像这样将其移除：
- en: '[PRE55]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now let''s draw the rectangle and text we created:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们绘制我们创建的矩形和文字：
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Also, let''s implement the `Unpause` method by simply switching to the game-play
    state:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们通过简单地切换到游戏状态来实现`Unpause`方法：
- en: '[PRE57]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Because the main game state is the only state that can be paused so far, simply
    switching back to it is sufficient.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于主游戏状态是目前唯一可以暂停的状态，因此只需简单地切换回它就足够了。
- en: 'Now, take a deep breath and compile the application again. Getting past the
    intro state, hitting the **PLAY** button in the main menu, and hitting the **P**
    key on your keyboard will effectively pause the game-play state and darken the
    screen subtly, while displaying the text **PAUSED** right in the middle, as shown
    here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，深呼吸并再次编译应用程序。通过跳过初始状态，点击主菜单中的**PLAY**按钮，以及按下键盘上的**P**键，将有效地暂停游戏状态并微妙地变暗屏幕，同时在中间显示**PAUSED**文字，如图所示：
- en: '![The means to pause](img/B04284_05_05.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![暂停的方法](img/B04284_05_05.jpg)'
- en: If you have come this far, congratulations! While this is by no means a finished
    product, it has come a long way from being a static, immovable class that can
    barely be controlled.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经走到这一步，恭喜你！虽然这绝对不是一个成品，但它已经从几乎无法控制的静态、不可移动的类走了很长的路。
- en: Common mistakes
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见错误
- en: A likely mistake that might be made when using this system is the absence of
    registration of newly added states. If you have built a state and it simply draws
    a black screen when you switch to it, chances are it was never registered in the
    constructor of `StateManager`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此系统时可能犯的一个常见错误是未注册新添加的状态。如果你构建了一个状态，当你切换到它时它只是简单地显示一个黑色屏幕，那么很可能是它从未在`StateManager`的构造函数中注册。
- en: 'The window not responding to the *F5* key being pressed or the close button
    being hit is a sign of the global callbacks not being set up right. In order to
    make sure a callback is invoked no matter which state you''re in, it must be set
    up with the state type of 0, like so:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口对按下**F5**键或点击关闭按钮没有反应是全局回调没有正确设置的标志。为了确保无论处于何种状态都会调用回调，它必须设置为状态类型0，如下所示：
- en: '[PRE58]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Finally, remember that when the mouse position is retrieved in the main menu
    state, the coordinates stored inside the event are automatically relative to the
    window. Obtaining coordinates through `sf::Mouse::GetPosition` is not going to
    do the same, unless a reference to a `sf::Window` class is provided as an argument.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，记住当在主菜单状态中检索鼠标位置时，事件内部存储的坐标是自动相对于窗口的。通过`sf::Mouse::GetPosition`获取坐标不会做同样的事情，除非提供一个`sf::Window`类的引用作为参数。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Upon this chapter concluding, you should have everything you need in your tool
    belt to fashion states that can be transparent, updated in groups, and supported
    by the rest of our codebase. There's no reason to stop there. Build it again,
    make it better, faster and implement different features that didn't get covered
    in this chapter. Expand it, crash it, fix it and learn from it. Nothing is ever
    good enough, so build onto the knowledge you've gained here.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当本章结束时，你应该已经拥有了制作可以透明、批量更新并由我们代码库的其他部分支持的状态的工具。没有必要就此止步。再次构建它，让它变得更好、更快，并实现本章未涉及的不同功能。扩展它，崩溃它，修复它并从中学习。永远没有足够好的东西，所以在这里构建你获得的知识。
- en: '*A famous Chinese proverb states: "Life is like a game of chess, changing with
    each move".*'
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*一句著名的中国谚语说：“人生如棋，每一步都在变”。*'
- en: While that analogy holds true, life can also be like a game with states. Breaking
    it down into smaller and more manageable parts makes it a whole lot easier to
    handle. Whether it is life imitating code or code imitating life is irrelevant.
    Great ideas come from different backgrounds coming together. Hopefully, by the
    end of this chapter you are taking off with not only the knowledge of simply how
    to build yet another manager, but also the wisdom to seek inspiration from every
    resource and idea available. There is no exclusive knowledge, only inclusive thinking.
    See you in the next chapter!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个类比是正确的，但生活也可以像是一个具有不同状态的游戏。将其分解成更小、更易于管理的部分，会使处理起来容易得多。无论是生活模仿代码还是代码模仿生活，这都不重要。伟大的想法来自于不同背景的融合。希望到这一章结束时，你不仅掌握了如何构建另一个管理者的知识，而且也拥有了从每一个可用资源和想法中寻求灵感的智慧。没有专属的知识，只有包容性的思维。下一章见！
